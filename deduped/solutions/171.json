[{"code":"(fn intervals [s]\n  (if (empty? (seq s))\n    []\n    (let [sorted (sort s)]\n      (loop [key 1 m {1 [(first sorted)]} rst (rest sorted)]\n        (cond\n          (not (seq rst)) (map #(vector (first %) (last %)) (sort-by first (vals m)))\n          (= (last (m key)) (first rst)) (recur key m (rest rst))\n          (= (inc (last (m key))) (first rst)) (recur key (assoc m key (conj (m key) (first rst))) (rest rst))\n          :else (recur (inc key) (assoc m (inc key) [(first rst)]) (rest rst)))))))","problem":"171","user":"4f849f76e4b033992c121c36"},{"problem":"171","code":"(fn  [coll]\n  (let [abc (sort coll)\n        a (first abc)\n        finish (fn [[acc a z]] (if-not z acc (conj acc [a z])))]\n    (->> abc\n         (reduce\n          (fn [[acc a z] nxt]\n            (if (<= nxt (inc z))\n              [acc a nxt]\n              [(conj acc [a z]) nxt nxt]))\n          [[] a a])\n         finish)))","user":"56102f50e4b05f002753df6b"},{"problem":"171","code":"(fn [s]\n  (let [deal (sort (set s))]\n  (loop [p (rest deal) tmp [(first deal)] r []]\n    (cond\n     (empty? s) []\n     (empty? p) (conj r [(first tmp) (last tmp)])\n     (= (first p) (inc (last tmp))) (recur (rest p) (conj tmp (first p)) r)\n     :else (recur (rest p) [(first p)] (conj r [(first tmp) (last tmp)]))\n     ))))","user":"574abbfbe4b02ea114799200"},{"problem":"171","code":"(fn [l] \n  (->> l distinct sort \n       (map-indexed #(list (- %2 %) %2))\n       (partition-by first)\n       (map #(list (last (first %)) (last (last %))))))","user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn [v]\n  (let [s (apply sorted-set v)]\n    (partition 2\n       (interleave\n          (filter #(not (contains? s (dec %))) s)\n          (filter #(not (contains? s (inc %))) s)))))","problem":"171","user":"50bce014e4b0594b91591c63"},{"problem":"171","code":"(fn [s]\n  (if (seq s)\n    (let [s (sort s)]\n      (loop [s s\n             r []\n             mn (first s)\n             mx (first s)\n             v (first s)]\n        (if (seq s)\n          (if (or (= mx v) (= (inc mx) v))\n            (recur (next s) r mn v (first s))\n            (recur (next s) (conj r [mn mx]) v v (first s)))\n          (if (or (= mx v) (= (inc mx) v))\n            (conj r [mn v])\n            (conj r [mn mx] [v v])))))\n    []))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":"171","code":"(fn [alist]\n  (let [sortlist (distinct (sort alist))\n        gaplist (partition 2 (drop 1 (butlast (interleave sortlist sortlist))))\n        biggaps (remove #(= 1 (- (second %) (first %))) gaplist)]\n    (if (empty? gaplist)\n      (if (empty? sortlist)\n        []\n        [[(first sortlist) (last sortlist)]])\n      (partition 2 (flatten (concat [(ffirst gaplist)] biggaps [(second (last gaplist))]))))))","user":"5705e404e4b0b0fb43fd0676"},{"problem":"171","code":"(fn intervals [s]\n  (let [adjacent (fn [s n]\n                   (if (= (count s) 0)\n                     true\n                     (some #(or (= (- n 1) %)\n                                (= (+ n 1) %)\n                                (= n %)) s)))\n        empty-interval (fn [s]\n                         (let [sorted (sort s)]\n                           [(first sorted) (last sorted)]))\n        compare-interval #(compare (first %1) (first %2))]\n    (loop [s s\n           cur []\n           res []]\n      (if (seq s)\n        (let [[new-cur new-s]\n              (reduce #(let [[new-cur new-s] %1]\n                         (if (adjacent new-cur %2)\n                           [(conj new-cur %2) new-s]\n                           [new-cur (conj new-s %2)]))\n                      [cur []]\n                      s)]\n          (if (= (count cur) (count new-cur))\n            (recur new-s [] (conj res new-cur))\n            (recur new-s new-cur res)))\n        (sort compare-interval\n              (map empty-interval\n                   (if (empty? cur)\n                     res\n                     (conj res cur))))))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":"171","code":"(fn [col]\n  (map (fn [x] [ (first (last (second x)))\n                (last (last (second x)))])\n       (group-by #(first %)\n                 (filter #(not (empty? %))\n                         (reductions (fn [x y]\n                                       (cond (empty? x) [y]\n                                             (= (last x) (dec y)) (concat x [y])\n                                             :else [y]))\n                                     []\n                                     (distinct (sort col)))))))","user":"53664e3be4b0243289761e74"},{"code":"(fn a [coll]\r\n  (let [t1-coll (set coll)\r\n        t2-coll (reduce #(if (= (- (last %1) %2) -1) (conj %1 %2) (conj %1 \\, %2)) [(first t1-coll)] (rest t1-coll))\r\n        t3-coll (partition-by #(= % \\,) t2-coll)\r\n        t4-coll (remove #(= % '(\\,)) t3-coll)]\r\n    (if (= t3-coll [[nil]]) []\r\n      (reduce #(conj %1 [(first %2) (last %2)]) [] t4-coll))))","problem":"171","user":"505dd5c4e4b0e6aca564be0e"},{"code":"(fn interval\n  [s]\n  (let [groups (partition-by first (map-indexed (juxt - (fn [a b] b)) (apply sorted-set s)))]\n    (map (comp (juxt first last) (partial map second)) groups)))","problem":"171","user":"511b233ae4b07ab9ec456180"},{"code":"(fn [v]\r\n  (if (empty? v) []\r\n  (let [v (vec (sort v))\r\n        f (fn [vs s]\r\n            (if (empty? s) vs\r\n              (if-let [n (second s)]\r\n                (if (>= (first s) (- n 1))\r\n                  (recur (conj (pop vs) (conj (last vs) n)) (rest s))\r\n                  (recur (conj vs [n]) (rest s)))\r\n                vs)))\r\n        r (f [[(first v)]] (subvec v 1))]\r\n    (for [x r]\r\n      [(first x) (last x)]))))","problem":"171","user":"50464831e4b011c5dfee771f"},{"code":"#(into () \n    (reduce\n      (fn [[[b e] & r :as a] v]\n        (if (= e (dec v))\n            (conj r [b v])\n            (conj a [v v])))\n       ()\n       (sort (set %))))","problem":"171","user":"4e52d815535d302ef430da77"},{"code":"(comp\n  sort\n  set\n  (fn [x] \n    (map \n      #(let [f (fn f [n g] (if ((set x) (g n)) (f (g n) g) n))]\n        [(f % dec) (f % inc)]) \n      x)))","problem":"171","user":"4db85282535d1e037afb218a"},{"problem":"171","code":"(fn intervals [c]\n  (->> (set c)\n       sort\n       (reduce #(if (= (dec %2) (last %))\n                  (assoc % (dec (count %)) %2)\n                  (conj % %2 %2)) [])\n       (partition 2)))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn [sq]\n  (if (empty? sq) \n    []\n    (let [sorted (sort (set sq))]\n      (loop [current (first sorted)\n             counter 0\n             begin current\n             remain (rest sorted)\n   \t         inters []]\n        (if (empty? remain)\n          (if (= current (+ begin counter))\n          \t(conj inters [begin current])\n            (conj inters [begin (+ begin counter -1)] [current current]))\n          (if (= current (+ begin counter))\n            (recur (first remain)\n                   (inc counter)\n                   begin\n                   (rest remain)\n                   inters)\n            (recur (first remain)\n                   1\n                   current\n                   (rest remain)\n                   (conj inters [begin (+ begin counter -1)]))))))))","problem":"171","user":"52dd4fb4e4b09f7907dd13df"},{"problem":"171","code":"(fn ranges [s']\n  (let [s (sort s')\n       [a b v] (reduce (fn [[a b e] v] (cond\n                              (= v b) [a b e]\n                              (= v e) [a b e]\n                              (= v (dec b)) [a v e] \n                              (= v (inc e)) [a b v] \n                              :else [(cons [b e] a) v v])) [[] (first s) (first s)] (rest s))]\n       (into () (if ( nil? b) [] (cons [b v] a)))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [a]\n  (let [[f & b] (distinct (sort a))]\n    (loop [f f l f [n & r] b a []]\n      (cond (nil? f) a\n            (= (+ 1 l) n) (recur f n r a)\n            :else (recur n n r (conj a [f l]))))))","problem":"171","user":"4fb1d907e4b081705acca282"},{"problem":"171","code":"(fn [coll]\n  (let [scoll (distinct (sort coll))\n        [fnum & nums] (concat scoll [(last scoll)])]\n    (first\n     (reduce\n      (fn [[ret start end] num]\n        (if (= num (inc end))\n          [ret start num]\n          [(conj ret [start end]) num num]))\n      [[] fnum fnum]\n      nums)\n     )))","user":"559b2ad1e4b066d22e731f4e"},{"problem":"171","code":"(fn [l]\n    (let [s (sort (set l))]\n        (if (empty? s)\n            []\n            (loop [l (first s)\n                   u (first s)\n                   s (rest s)\n                   acc []]\n                (if (empty? s)\n                    (conj acc [l u])\n                    (let [x (first s)\n                          xs (rest s)]\n                        (if (= x (inc u))\n                            (recur l x xs acc)\n                            (recur x x xs (conj acc [l u])))))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn [int_seq]\n(if (empty? int_seq) int_seq\n (let [s (sort int_seq)]\n  (loop [ r []  start_ind 0 end_ind 1]\n     (if (= end_ind (count s)) (conj r [(nth s start_ind) (nth s (dec end_ind))])\n      (let [start (nth s (dec end_ind)) end (nth s end_ind)]\n        (if (<= (- end start) 1)\n           (recur r start_ind (inc end_ind))\n           (recur (conj r [(nth s start_ind) (nth s (dec end_ind))]) end_ind (inc end_ind))\n        )\n      )\n     )\n  )\n )\n)\n)","problem":"171","user":"522eba30e4b01cdb292c5f0e"},{"problem":"171","code":"(fn [l]\n  (letfn [(get-seq ([l] (get-seq (into [] l) nil nil))\n                   ([l prev rel]\n                   (if (or (empty? l) (and (not (nil? prev)) (not (= prev (dec (first l))))))\n                     (cons (conj [] (first (sort rel)) (last (sort rel))) l)\n                     (recur (rest l) (first l) (conj rel (first l))))))]\n    (if (empty? l)\n      []\n      \n    (loop [res (get-seq (into #{} l)) ps []]\n      (if (= 1 (count res))\n        (if (empty? ps)\n          (if (not (nil? (first res)))\n            res\n            ps)\n          (conj ps (first res)))\n        (recur (get-seq (rest res)) (conj ps (first res))))))))","user":"52979551e4b02ebb4ef75043"},{"problem":"171","code":"(fn [xs]\n  (let [xs (distinct (sort xs))]\n    (loop [xs xs res []]\n      (if (empty? xs) res\n        (let [[x & xs] xs]\n          (if (or (empty? res) (< 1 (- x (second (last res)))))\n            (recur xs (conj res [x x]))\n            (let [[a b] (last res)]\n              (recur xs (conj (vec (drop-last res)) [a x])))))))))","user":"553e0b70e4b0a04f792994e8"},{"problem":"171","code":"(fn [coll]\n  (map (fn [xs] [(first xs) (last xs)]) (reduce\n   (fn [res x]\n    (if (empty? res)\n      [[x x]]\n      (let [prev (last res)\n            nrange (range (first prev) (+ 2 (last prev)))]\n        (if (= -1 (.indexOf nrange x))\n          (conj res [x x])\n          (if (> x (last prev))\n            (conj (vec (drop-last res)) nrange)\n            res  )))))\n    []\n    (sort coll))))","user":"55ede35ce4b0121d4835fde1"},{"code":"(fn[c] \n  (let [grouped (reduce (fn [r n] (if (or (= (last (last r)) (dec n)) (= (last (last r)) n)) (concat (drop-last r) [(conj (last r) n)]) (concat r [[n]]))) [] (sort c))]\n    (map #(vec [(first %) (last %)]) grouped)))","problem":"171","user":"5093ca51e4b097f48cc38585"},{"code":"(fn [input]\n  (let [update\n        (fn [[i c] num]\n          (if (nil? c) [i [num num]]\n            (let [[f l] c]\n              (if (= num (inc l))\n                [i [f num]]\n                [(conj i c) [num num]]))))\n        sorted (sort (vec (set input)))\n        [s c] (reduce update [[] nil] sorted)]\n    (if c (conj s c) s)))","problem":"171","user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":"171","code":"#(map vector (% %2 inc) (% %2 dec)) #(remove (set (map %2 %)) (set (sort %)))","user":"50e90813e4b033b0e80d11e7"},{"problem":"171","code":"(fn [s]\n  (loop [s (sort s)\n         i nil\n         is []]\n    (cond\n      (empty? s) (if i (conj is i) is)\n      (nil? i) (recur (rest s) [(first s) (first s)] is)\n      :else\n      (let [[f & r] s]\n        (if (<= f (inc (second i)))\n          (recur r [(first i) f] is)\n          (recur r [f f] (conj is i)))))))","user":"57f80350e4b0d3187e90090c"},{"problem":"171","code":"#(reduce \n   (fn f [a x] \n     (if (empty? a) \n         [[x x]]\n         (if (= x (inc (last (last a)))) \n             (conj (pop a) [(first (last a)) x]) \n             (conj a [x x]))))\n   [] \n   (-> % set sort))","user":"53b15e6ee4b047364c04448f"},{"code":"#(if (= % []) \n  [] \n  (partition 2 \n    (flatten \n      (list \n        (apply min %)\n        (filter \n          (fn [[a b]] (not= (inc a) b)) \n          (partition 2 1 (set %))) \n        (apply max %)))))","problem":"171","user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn intervals [coll]\n  (let [c (sort coll)]\n    (if (empty? c) []\n        (loop [rst (rest c) s (first c) e (first c) acc []]\n          (cond\n           (empty? rst) (conj acc [s e])\n           (= (first rst) e) (recur (rest rst) s e acc)\n           (= (first rst) (inc e)) (recur (rest rst) s (inc e) acc)\n           true (recur (rest rst) (first rst) (first rst) (conj acc [s e])))))))","problem":"171","user":"504f57c7e4b0a02f9cffde71"},{"problem":"171","code":"(fn [nums]\n   (letfn [(partition-between [pred? coll]\n             (let [switch (reductions not= true (map pred? coll (rest coll)))]\n               (map (partial map first) (partition-by second (map list coll switch)))))]\n     (map (fn [x] [(apply min x) (apply max x)]) (partition-between #(not= %1 (dec %2)) (distinct (sort nums))))))","user":"55cb11e9e4b0e31453f649ff"},{"problem":"171","code":"(fn [s]\n  (->> s\n       distinct\n       sort\n       (map-indexed vector)\n       (partition-by (partial apply -))\n       (map (partial map last))\n       (map (juxt first last))))","user":"56e2dbf4e4b03a7c14b85a3b"},{"problem":"171","code":"(fn a[v]\n    (if (empty? v) \n      []\n      (let [s (set (sort v))\n            f first\n            m #(map f %)\n            [i r] (split-with #(apply = %) (map list s (range (f s) 99)))\n            c (m i) d (m r)]\n        (cons [(f c) (last c)] (if (empty? d) [] (a d))))))","user":"4ec74de3535d6d7199dd36df"},{"code":"(fn intervals [v]\n  (->> (sort (distinct v))\n       (keep-indexed #(vector (- %1 %2) %2))\n       (group-by #(%1 0))\n       vals\n       (map (fn [e] (map #(% 1) e)))\n       (mapv #(vector (first %) (last %)))))","problem":"171","user":"511b9017e4b00c2a1fa7ff6b"},{"problem":"171","code":"(fn [nums]\n    (rest (loop [[h & t] (sort (set nums))\n           f h\n           l h\n           res []]\n      (if (nil? h)\n        (conj res [f l])\n        (if (= h (inc l))\n          (recur t f h res)\n          (recur t h h (conj res [f l])))))))","user":"544e9022e4b0e3978000698b"},{"problem":"171","code":"(fn p171 [s]\n  (let [t (set s)\n        t2 (concat '(0) (interleave (rest t) (butlast t)) '(0))\n        t3 (zipmap t (partition 2 t2))\n        t4 (into (sorted-map) \n                 (zipmap t (let [x (atom 0)] \n                             (for [i t]\n                               (if (not= (- i 1) (first (t3 i)))\n                                 (swap! x inc)\n                                 @x)))))]\n    (map #(vector (first %) (last %)) (partition-by #(t4 %) (keys t4)))))","user":"525c575be4b0cb4875a45d38"},{"code":"(fn [s]\n  (loop [i (sort (into #{} s)) r [] cur []]\n    (if (empty? i)\n      (if (empty? cur) r (conj r cur))\n      (if (empty? cur)\n        (recur (rest i) r [(first i) (first i)])\n        (if (= 1 (- (first i) (last cur)))\n          (recur (rest i) r [(first cur) (first i)])\n          (recur i (conj r cur) []))))))","problem":"171","user":"513b77f3e4b00f740c76c403"},{"problem":"171","code":"(fn [a]\n    (if (first a)\n    (let [s (apply sorted-set a) h (first s) r (rest s)] \n    (\n      (fn [start end result [head & rest]]\n        (if head\n          (if (= head (inc end))\n            (recur start (inc end) result rest)\n            (recur head head (conj result [start end]) rest)\n          )\n          (conj result [start end])\n        )\n      )\n      h h [] r))\n      [])\n  )","user":"4feada56e4b0140c20fb9c11"},{"problem":"171","code":"(fn  [col]\n  (letfn [(f \n           ([a [x & xs]] (if x (f (conj a x) x xs) a))\n           ([a l [x & xs :as cs]] \n            (if x \n              (recur (if (<= x (inc l)) a (conj a l x)) x xs)\n              (partition 2 (conj a l)))))]\n    (f [] (sort col))))","user":"53b7c21ae4b047364c0444d4"},{"problem":"171","code":"; Initial solution:\n\n;; (fn [integers]\n;;   (letfn [(get-next-interval [consecutive-values]\n;;                              (let [initial-offset-from-index (first consecutive-values)\n;;                                    [next-index-value-pairs rest-index-value-pairs] (split-with (fn [[index value]] (= (- value index) initial-offset-from-index))\n;;                                                                                                (map-indexed vector consecutive-values))\n;;                                    next-interval-values (map second next-index-value-pairs)\n;;                                    next-interval (vector (first next-interval-values) (last next-interval-values))\n;;                                    rest-values (map second rest-index-value-pairs)]\n;;                                (vector next-interval rest-values)))]\n;;     (loop [intervals []\n;;            consecutive-values (sort (distinct integers))]\n;;       (if (empty? consecutive-values)\n;;         intervals                \n;;         (let [[next-interval rest-values] (get-next-interval consecutive-values)]\n;;           (recur (conj intervals next-interval)\n;;                  rest-values))))))\n\n\n; After seeing ctzsm's much more concise solution:\n\n(fn [integers]\n  (let [interval-offset-value-pairs (map-indexed (fn [index value] (vector (- value index) value))\n                                                 (into (sorted-set) integers))\n        values-per-interval (map (fn [next-interval-pairs] (map (fn [[_ value]] value) next-interval-pairs))\n                                 (partition-by first interval-offset-value-pairs))]\n    (map #(vector (first %) (last %))\n         values-per-interval)))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn iv [s]\n  (let [sorted (vec (apply sorted-set s))\n        init (if (seq s) (list [(first sorted) (first sorted)]) [])\n        reducer (fn [acc v] \n             ;(println \"acc\" acc \"v\" v (first acc))\n             (if (= v (inc (second (first acc)))) \n               (conj (rest acc) [(ffirst acc) v])\n               (conj acc [v v]))\n              )\n        ]\n    (reverse (reduce reducer init (rest sorted))))\n  )","problem":"171","user":"52ffb7f2e4b0d8b024fd370b"},{"problem":"171","code":"(fn p\n  ([xs] \n   (if-let [[x & xs*] (seq (sort xs))]\n     (p x x xs*) []))\n  \n  ([lo hi xs]\n   (if-let [[x & xs] (seq xs)]\n     (if (<= x (inc hi))\n       (p lo x xs)\n       (cons [lo hi]\n             (p x x xs)))\n     [[lo hi]])))","user":"53dfdf01e4b0d874e779ae46"},{"problem":"171","code":"(fn foo [s]\n  (if (empty? s)\n    []\n    (let [sorted-s (distinct (sort s))]\n      (map \n        #(conj [] (first %) (last %))\n        ((fn bar [last-x xs last-interval ret]\n          (if (empty? xs)\n            (if (= 1 (count last-interval))\n              (conj ret (conj last-interval (first last-interval)))\n              (conj ret last-interval))\n            (if (= 1 (- (first xs) last-x))\n              (bar (first xs) (rest xs) (conj last-interval (first xs)) ret)\n              (if (= 1 (count last-interval))\n                (bar (first xs) (rest xs) [(first xs)] (conj ret (conj last-interval (first last-interval))))\n                (bar (first xs) (rest xs) [(first xs)] (conj ret last-interval)))))) (first sorted-s) (rest sorted-s) [(first sorted-s)] [])))))","user":"53a94b63e4b047364c044434"},{"code":"(fn f [v]\n  (if (not= v []) (loop [ans []\n         vv (sort v)\n         pre (first vv)\n         temp [pre]]\n    (if (empty? vv)\n      (conj ans [(first temp) (last temp)])\n      (if (<= (first vv) (inc pre))\n        (recur ans (next vv) (first vv) (conj temp (first vv)))        (recur (conj ans [(first temp) (last temp)]) (next vv) (first vv) [(first vv)])))) []))","problem":"171","user":"52196842e4b0890f2f822bfa"},{"problem":"171","code":"(fn [coll]\n        (loop [[eye & more :as coll] (sort coll)\n               tmp []\n               res []]\n          (cond\n           (nil? eye)\n           (remove empty? (conj res tmp))\n           \n           (empty? tmp)\n           (recur more [eye eye] res)\n           \n           (and\n            (<= (first tmp) eye)\n            (<= eye (second tmp)))\n           (recur more tmp res)\n           \n           (= eye (inc (last tmp)))\n           (recur more [(first tmp) eye] res)\n           \n           :else\n           (recur coll [] (conj res tmp)))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"apply (fn\n  ([] [])\n  ([& numbers]\n  (let [\n        sorted-nrs (vec (sort numbers))\n        ]\n    (loop [ranges [], current-range [(first sorted-nrs)], nrs sorted-nrs, i 1]\n      (let [\n                     a (get nrs (- i 1))\n                     b (get nrs i)\n                     ]\n        (println a b)\n        (if-not b\n          (conj ranges (conj current-range a))\n          (if (> (- b a) 1)\n              (recur (conj ranges (conj current-range a)) [b], nrs, (+ i 1))\n              (recur ranges current-range, nrs, (+ i 1)))\n          ))))))","problem":"171","user":"522d3a16e4b0e26240291d50"},{"code":"#(let [x (sort (set %))]\n    (if (seq x)\n      (partition\n       2\n       (flatten [(first x)\n                 (filter (fn [[a b]]\n                           (not= 1 (- b a)))\n                         (partition 2 1 x))\n                 (last x)]))\n      []))","problem":"171","user":"4f0664bd535dcb61093f6c0f"},{"problem":"171","code":"(fn [xs]\n (reduce\n  (fn\n [itvs x]\n (let [[[a b] & ts] itvs]\n  (cond\n   (nil? a)\n    (cons\n     [x x] itvs)\n   (= x a)\n    itvs\n   (= x (dec a))\n    (cons [x b] ts)\n   :else\n    (cons\n     [x x] itvs))))\n []\n (sort #(compare %2 %1) xs)))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":"171","code":"(fn [xs] (let [[p & sorted] (sort xs)]  \n            (if p (reduce \n              (fn [v x]\n                (let [[f l] (peek v)]\n                  (if \n                    (<= (- x l) 1)\n                      (conj (pop v) [f x])\n                      (conj v [x x])) \n                  \n                )) \n              [[p p]] \n              sorted) [])))","user":"5c379636e4b0d62ef62d9f76"},{"problem":"171","code":"#(if (empty? %) []\n       (let [vs (vec (sort %)) vl (first vs) vh (last vs)]\n         (first (reduce (fn [[is b e] v]\n                          (if (or (= v e) (= v (+ e 1)))\n                            [is b v]\n                            [(conj is [b e]) v v]))\n                        [[] vl vl]\n                        (conj vs (+ vh 2))))))","user":"54c641f8e4b045293a27f628"},{"problem":"171","code":"(fn intervals [xs]\n  (->> xs\n       set\n       sort\n       (reduce #(cond\n                  (empty? %1)                  (conj %1 [%2 %2])\n                  (= %2 (-> %1 last last inc)) (update-in %1 [(dec (count %1)) 1] inc)\n                  :else                        (conj %1 [%2 %2]))\n               [])))","user":"58b2c435e4b0ebc645576d11"},{"code":"(fn [v]\n  (let [x (distinct (sort v))\n        [a b] (reduce #(let [[x y] %] \n                     (if (and (not (empty? x)) (= (inc (last x)) %2))\n                       [(conj x %2) y]\n                       [[%2] (conj y x)])) [[] []] x)\n        x (map #(vector (first %) (last %)) (remove empty? (conj b a)))]\n    x))","problem":"171","user":"4fa30027e4b081705acca187"},{"problem":"171","code":"(fn getint [v]\n      (apply vector (reverse (let [mv (sort v) ]\n\t   (reduce (fn [pre v] \n\t   \t       (if (empty? pre) \n\t\t       \t   (conj pre [v v])\n\t\t\t   (if (>= (inc (last (first pre))) v)\n\t\t\t       (conj (rest pre) [(first (first pre)) v])\n\t\t\t       (conj pre [v v])))) [] mv)))))","user":"54a1d643e4b09f271ff37c50"},{"problem":"171","code":"(fn [coll]\n  (letfn [(step [coll']\n                (when-let [[fst snd] (seq coll')]\n                  (when (and snd\n                             (or (= fst snd) (= fst (dec snd))))\n                    (cons snd (step (rest coll'))))))\n          (succeeding [coll'']\n            (cons (first coll'') (step coll'')))\n          (intervals [coll''']\n                     (loop [s   coll'''\n                            acc []]\n                       (if (seq s)\n                         (let [inter (succeeding s)]\n                           (recur (drop (count inter) s) (conj acc inter)))\n                         (map (juxt first last) acc))))]\n    (let [scoll (sort coll)]\n      (intervals scoll))))","user":"56481722e4b0284900eef628"},{"code":"#(if-let [[x & xs] (->> % sort not-empty)]\n   (reduce (fn [intervals n]\n             (let [l (count intervals)\n                   last-pos [(dec l) 1]\n                   m (get-in intervals last-pos)]\n               (if (>= 1 (- n m))\n                 (assoc-in intervals last-pos n)\n                 (assoc-in intervals [l] [n n]))))\n           [[x x]] xs)\n   ())","problem":"171","user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn [x]\n  (map #(vector (first %) (last %))\n    (reduce #(if (or (empty? %1) (= %2 (dec (ffirst %1))))\n                 (cons (cons %2 (first %1)) (rest %1))\n                 (cons `(~%2) %1)) '() (reverse (sort (distinct x))))))","problem":"171","user":"504e04a4e4b078edc5f59397"},{"problem":"171","code":"(fn [coll]\n  (let [c (distinct (sort coll))                            ;;remove duplicates and sort\n        answer (concat [(first c)]                          ;; creates a result array of all the bounds of all the ranges\n                       (flatten (filter #(not= (- (second %) (first %)) 1) (partition 2 1 c)))\n                       [(last c)])]\n    (if (empty? coll)\n      []\n      (partition 2 2 answer))))                             ;;return a seqquence of the intervals each in its list","user":"5ce2bf8ee4b0a17bb84e2b2e"},{"problem":"171","code":"(fn\n  [xs]\n  (if (empty? xs)\n    []\n    (let [[x & xs] (sort (distinct xs))\n          {:keys [current result]}\n          (reduce (fn [{:keys [current result] :as carry} x]\n                    (if (= x (inc (second current)))\n                      (update-in carry [:current 1] inc)\n                      {:current [x x] :result (conj result current)}))\n                  {:current [x x] :result []} xs)]\n      (conj result current))))","user":"586bc870e4b01531a375e964"},{"problem":"171","code":"(fn intervals [xs]\n    (loop [xs (sort xs)\n           i  (first xs)]\n      (let [ [x y & xss ] xs]\n        (if (nil? y)\n          (if (nil? x) [] [[x i]])\n          (if (or (= i y) (= i (dec y)))\n            (recur (cons x xss) y)\n            (cons  [x i]\n                   (intervals\n                    (cons y xss))))))))","user":"5433a07be4b0b6b47310fce0"},{"code":"(fn f \n  ([v]\n    (if (empty? v) []\n      (let [[ft & rt] (sort v)]\n        (f rt ft ft []))))\n  ([[ft & rt] start end res]\n    (cond \n      (nil? ft) (conj res [start end])\n      (= end ft) (f rt start end res)\n      (not= (inc end) ft) (f rt ft ft (conj res [start end]))\n      :else (f rt start (inc end) res))))","problem":"171","user":"52667ecfe4b03e8d9a4a713e"},{"problem":"171","code":"(fn [c] (loop [[h & [t & r :as rs]] ((comp sort distinct) c) o [[h h]]]\n           (if h\n             (if t\n               (let [[s e] (last o)]\n                 (if (= e (dec t))\n                   (recur rs (conj (pop o) [s t]))\n                   (recur rs (conj o [t t]))))\n               o)\n             [])))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn intervals [sq]\n  (if (empty? sq)\n    sq\n    (let [ssq (distinct (sort < sq))\n          fsq (first ssq)\n          faq (fn [[acc a lst] val]\n                (if (not= 1 (- val lst))\n                  [(conj acc [a lst]) val val]\n                  [acc a val]))\n          [intvls a b] (reduce faq [[] fsq fsq] (rest ssq))]\n      (conj intvls [a b]))))","problem":"171","user":"5095f761e4b0ba05ca7aebfd"},{"problem":"171","code":"(fn intervals\n  [s]\n  (if (empty? s) \n    []\n    (loop [res [] l (sort s) start (first l) end (first l) ]\n      (if (nil? l)\n        (conj res [start end])\n        (if (<= (- (first l) end) 1)\n          (recur res (next l) start (first l))\n          (recur (conj res [start end]) (next l) (first l) (first l))\n          )\n        )\n      )\n    )\n  \n  )","user":"5c20b6abe4b07e362c230576"},{"code":"(fn intervals [x]\n  (letfn [(lol [op k v]\n            (cond\n              (empty? v) v\n              (nil? (second v)) (cons (first v) nil)\n              (op (first v) (second v)) (cons (first v) (cons k (lazy-seq (lol op k (rest v)))))\n              :else  (cons (first v) (lazy-seq (lol op k (rest v))))))]\n         (map #(vector (first %)\n                       (last %)) (filter #(number? (first %))\n                                         (partition-by keyword? \n                                                       (lol #(not= (inc %) %2) \n                                                            :less \n                                                            (sort (distinct x))))))))","problem":"171","user":"50e87427e4b0ebbe794eb7e8"},{"problem":"171","code":"(fn prob171 [s]\n  (reduce\n   (fn [v n]\n     (if (empty? v) (conj v [n n])\n         (let [[start end] (last v)]\n           (cond\n             (= n end) v\n             (= n (inc end)) (conj (apply vector (butlast v)) [start n])\n             :else (conj v [n n])))))\n   [] (sort s)))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn [s]\n  (let [i (atom (first s))\n        f (fn [x] (let [d (- x @i)] (reset! i x) (> d 1) ))]\n    (map #(vector (first %) (last %)) (partition-by f (sort s)))))","problem":"171","user":"51e00020e4b01188f0627534"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [s (sort coll)]\n      (partition 2 (flatten (concat [(first s)]\n                              (filter #(> (- (last %) (first %)) 1)\n                                (map #(vector %1 %2) (butlast s) (rest s)))\n                              [(last s)]))))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [numbers]\n  (if\n    (empty? numbers)\n    []\n    (->>\n      numbers\n      (apply sorted-set)\n      (reduce\n        (fn [result n]\n          (let [[x y] (first result)]\n            (if\n              (<= n (inc y))\n              (conj (rest result) [x n])\n              (conj result [n n]))))\n        [[(apply min numbers) (apply min numbers)]])\n      reverse)))","problem":"171","user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn intervals [s]\n\t(letfn [(do-in [s [x & xs :as r] l]\n\t(if (empty? r)\n\t\ts\n\t\t(if (> x (inc l))\n\t\t\t(do-in (conj s (vector x)) xs x)\n\t\t\t(do-in (conj (into [] (butlast s)) (conj (last s) x)) xs x))))]\n\t\t\t(if (empty? s) []\n\t\t\t(map #(vector (first %) (last %)) (do-in [[]] (sort s) (first (sort s)))))))","problem":"171","user":"51c09719e4b0c9c82288293c"},{"problem":"171","code":"(fn [l]\n  (let [sl (sort l)]\n    (if (empty? sl)\n      []\n      (loop [m (rest sl)\n             r  []\n             s  (first sl)\n             e  (first sl)]\n        (if (empty? m)\n          (conj r [s e])\n          (let [ne (first m)]\n            (if (<= ne (inc e)) ; same oreq inc\n              (recur (rest m) r s ne)\n              (recur (rest m) (conj r [s e]) ne ne))))))))","user":"56051095e4b08b23635d3162"},{"code":"(fn [v]\n  (reduce\n\t\t#(if (= (last (last %1)) (dec %2))\n\t\t\t(concat (butlast %1) [[(first (last %1)) %2]])\n\t\t\t(concat %1 [[%2 %2]])\n\t\t)\n\t\t[]\n\t\t(apply sorted-set v)\n\t)\n)","problem":"171","user":"507eddf4e4b06ce648bcdbfa"},{"problem":"171","code":"(fn [num-seq]\n(if (seq num-seq)\n(let [sorted-num-seq (sort num-seq)\npartited-num-seq (partition-by\n#(<= (- (last %) (first %)) 1)\n(partition 2 1 (concat (cons (first sorted-num-seq) sorted-num-seq) [(last sorted-num-seq)])))]\n(letfn [(step [coll]\n(if (seq coll)\n(let [ele (first coll)\nfirst-group (first ele)]\n(if (<= (- (last first-group) (first first-group)) 1)\n(let [flatten-ele (flatten ele)]\n(cons [(first flatten-ele) (last flatten-ele)] (step (next coll))))\n(let [uncontinue-ele (apply sorted-set (drop-last (next (flatten ele))))]\n(if uncontinue-ele\n(concat (map #(vec [% %]) uncontinue-ele) (step (next coll)))\n(concat [] (step (next coll)))))))\n[]))]\n(step partited-num-seq)))\n[]))","user":"542edb4ae4b0dad94371f2c8"},{"problem":"171","code":"(fn [v]\n  (reduce\n   (fn [acc e]\n     (let [[ll lr] (last acc)]\n       (if (or (= lr (- e 1)) (= lr e))\n         (conj (vec (butlast acc)) [ll e])\n         (conj (vec acc) [e e]))))\n     []\n     (sort v)))","user":"52173464e4b082aa80a88c75"},{"problem":"171","code":"(fn [s]\n  (->> (sort s)\n       (reduce #(if (>= 1 (- %2 (last (last %))))\n                  (conj (pop %) [(first (last %)) %2]) \n                  (conj % [%2 %2]))\n               [[-1 -1]])\n       (rest)))","user":"4f041de1535dcb61093f6ba5"},{"code":"(fn p171 [lst]\n  (letfn [(pseq\n            ([slst]\n               (if (empty? lst) [] (pseq (first slst) (first slst) (next slst))))\n            ([s n lst]\n               (if (empty? lst) (list [s n])\n                   (let [nn (first lst)]\n                     (if (= 1 (- (Math/abs nn) (Math/abs n))) (pseq s nn (next lst))\n                         (cons [s n] (pseq nn nn (next lst)))))))\n            )]\n    (let [slst (sort (reduce conj #{} lst))] (pseq slst))))","problem":"171","user":"5272669de4b03e8d9a4a742e"},{"problem":"171","code":"(fn [q]\n  (letfn [(partition-pair [f s]\n     (cond \n      (empty? s) nil \n      (empty? (rest s)) (list s)\n      :else (let [l \n             (loop [el (first s)\n              bl [el]\n              rl (rest s)]\n               (if (or (empty? rl) (not (f el (first rl))))\n                 bl\n                 (recur (first rl) (conj bl (first rl)) (rest rl))))]\n         (cons l\n               (lazy-seq (partition-pair f (drop (count l) s))))))\n     )]\n    (let [res (partition-pair #(<= (- %2 %) 1) (sort q))]\n      (map (juxt first last) res)\n    ))\n)","user":"53f6d555e4b0db01ade6f9e5"},{"problem":"171","code":"(fn sol [x]\n  (let [last-in-seq \n        (fn [c]\n          (loop [d c]\n              (if (empty? (rest d))\n                (first d)\n                (if (= (- (second d) 1)\n                       (first d))\n                  (recur (rest d))\n                  (first d)))))]\n  (let [inner-sol \n        (fn [a b]\n        (loop [f a g b]\n          (if (empty? f)\n            g\n            (recur\n             (filter #(> % (last-in-seq f)) f)\n             (cons [(first f) (last-in-seq f)]\n                   g)))))]\n    (if (empty? x)\n      []\n      (into [] (reverse (inner-sol (distinct (sort x)) [])))))))","user":"52e17e66e4b09f7907dd1423"},{"problem":"171","code":"(fn\n  [s]\n  (let [x (sort s)]\n    (map #(if (last (first %))\n            (vector (ffirst %) (second (last %)))\n            (vector (first (last %)) (first (last %)))) (filter #(or (> (count %) 1) (last (first %))) (partition-by last\n     (map (fn [[a1 a2]] (if (or (= a1 a2) (= (inc a1) a2))\n                         (vector a1 a2 true)\n                         (vector a1 a2 false))) (partition 2 (interleave x (sort (conj (rest x) (last x)))))))))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn [coll]\n  (let [order (distinct (sort coll))]\n    (loop [input (rest order) f (first order) e (first order) res []]\n      (if (empty? input) \n        (if (empty? coll) [] (conj res [f e]))\n        (if (= (first input) (inc e))\n          (recur (rest input) f (inc e) res)\n          (recur (rest input) (first input) (first input) (conj res [f e])))))))","problem":"171","user":"4f38d6bbe4b0e243712b1ee2"},{"problem":"171","code":"(letfn [(t [v]\n\t (loop [a []\n\t\tr (if (empty? v) v\n                  (map #(if (= -1 (.indexOf v %)) nil %) (range (inc (apply max v)))))]\n\t   (cond (empty? r) a\n\t\t (nil? (first r)) (recur (conj a []) (rest r))\n\t\t :else (recur (conj (pop a) \n\t\t                    (conj (peek a) (first r)))\n\t\t              (rest r)))))\n\t(x [r]\n\t (into [] (map #(vector (apply min %) (apply max %)) (remove empty? r))))]\n (comp x t))","user":"538e36c7e4b0b51d73faae81"},{"code":"#(if (seq %)\n   (let [s (sort %)]\n     (->> (partition-all 2 1 s)\n          (remove (fn [[a b]] (and b (>= (inc a) b))))\n          (flatten)\n          (cons (first s))\n          (partition-all 2)))\n   [])","problem":"171","user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn interv [nums]\r\n  (if (empty? nums)\r\n    []\r\n    (letfn [(make-interval [snums ints]\r\n             (cond (empty? snums)\r\n                     ints,\r\n                   (= (first snums) (inc (second (last ints))))\r\n                     (make-interval\r\n                       (rest snums)\r\n                       (assoc ints (dec (count ints)) [(first (last ints)) (first snums)])),\r\n                   :else\r\n                     (make-interval\r\n                       (rest snums)\r\n                       (conj ints [(first snums) (first snums)]))))]\r\n    (let [snums (sort (set nums))]\r\n      (make-interval (rest snums)  [[(first snums) (first snums)]])))))","problem":"171","user":"4f62b29ce4b0defedf855fd9"},{"problem":"171","code":"(fn spans [s0]\n  (if (empty? s0)\n    s0\n    (let [s (sort s0)]\n      (loop [intervals [] acc [(first s)] input (rest s)]\n        (if (empty? input)\n          (map #(vector (first %) (last %)) (conj intervals acc))\n          (if (< (inc (last acc)) (first input))\n            (recur (conj intervals acc) [(first input)] (rest input))\n            (recur intervals (conj acc (first input)) (rest input))))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [sorted (sort coll)\n          x (first sorted)\n          initial (list [x x])]\n    (reverse\n      (reduce\n        (fn [res el]\n          (let [[from to] (first res)\n                to1 (inc to)\n                res1 (rest res)]\n            (cond\n              (< el to1) res\n              (= el to1) (conj res1 [from to1])\n              :else (conj res [el el]))))\n        initial\n        sorted)))))","problem":"171","user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn [xs]\n  (->> (sort xs)\n       (reduce\n        (fn [acc x]\n          (if (empty? acc)\n            (cons [x x] ())\n            (let [[a b] (first acc)]\n              (if (or (= b x) (= (inc b) x))\n                (cons [a x] (rest acc))\n                (cons [x x] acc)))))\n        ())\n       (reverse)))","problem":"171","user":"53800d99e4b06839e8705ebd"},{"code":"(fn prepare-int [ls]\n  (letfn [(padding [ls]\n            (if (empty? ls)\n              ls\n              (let [f (first ls)]\n                (list* f f\n                       (padding (rest ls))))))]\n    (let [ls' (sort ls)\n          ls' (padding ls')\n          parts (partition 2 1 ls')]\n      (loop [an [] ps parts]\n        (if (empty? ps)\n          an\n          (let [[xs ys] (split-with (fn [x]\n                                      (>= 1 (- (second x) (first x)))) ps)\n                [x _] (first xs)\n                [_ y] (last xs)]\n            (recur (conj an [x y]) (rest ys))))))))","problem":"171","user":"4dd62278535d2dad7130b5c7"},{"problem":"171","code":"(fn [x]\n  (->> x\n    (sort)\n    (reduce #(if (or (= % [])\n                      (< (- %2 (last %)) 2))\n                (conj % %2)\n                (conj % nil %2))\n              [])\n    (partition-by nil?)\n    (take-nth 2)\n    (map #(list (nth % 0) (last %)))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":"171","code":"(fn [nums]\n   (reduce\n      (fn [intervals n]\n        (let [[f l] (last intervals)]\n          (if (and l (>= l (dec n)))\n            (conj (pop intervals) [f n])\n            (conj intervals [n n]))))\n      []\n      (sort nums)))","user":"58b51e05e4b0ebc645576d4c"},{"problem":"171","code":"(fn [s]\n  (map\n   #(vec [% %2])\n   (distinct (filter #(not (contains? (set s) (dec %))) (sort s)))\n   (distinct (filter #(not (contains? (set s) (inc %))) (sort s)))\n   )\n  )","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [xs]\n  (if (empty? xs) '()\n    (let [xs (sort xs)]\n      (loop [acc [] start (first xs) end start xs (rest xs)]\n        (if (empty? xs) (conj acc [start end])\n          (let [x0 (first xs) xs' (rest xs)]\n            (if (<= end x0 (inc end)) (recur acc start x0 xs')\n              (recur (conj acc [start end]) x0 x0 xs'))))))))","problem":"171","user":"508157b2e4b0946d0443855c"},{"problem":"171","code":"(fn [c]\n  (if (empty? c)\n      []\n      (let [pair-diffs (fn [c]\n                          (->> (map (fn[[a b]] [(- b a) b]) c)\n                               (cons [1 1])))\n            partition-intervals (fn partition-intervals [s]\n                                   (when-let [z (seq s)]\n                                      (let [h (second (first z))\n                                            run (cons h (map #(second %) \n                                                             (take-while #(= 1 (first %)) (next z))))]\n                                        (cons run (partition-intervals (seq (drop (count run) z)))))))\n            sorted-c (sort (seq (into #{} c)))\n            sorted-pairs (partition 2 1 sorted-c)\n            diffed-pairs (pair-diffs sorted-pairs)]\n        (->> (partition-intervals diffed-pairs)\n             (map (fn[s] [(apply min s) (apply max s)]))))))","user":"56f4cedce4b046a417f92063"},{"code":"(fn [c]\n  (if (empty? c) \n    []\n    (let [coll (sort (set c))\n        p (partition 2 1 coll)]   \n  (partition 2\n  (flatten(vector \n  (first coll)\n\n    (filter\n      #(not= (first %) (dec (last %)))\n      p)\n  \n  (last coll)))\n  \n  ))))","problem":"171","user":"53513d28e4b084c2834f4ae3"},{"code":"(fn __ [c]\r\n   (let [\td (reduce #(cond (nil? %) (conj % %2) (or (= (last %) %2) (= (last %) (- %2 1))) (conj % %2) :else (conj % \\| %2)) \r\n\t\t\t\t []\r\n\t\t\t\t (sort c))\r\n\t\t\te (partition-by #(= \\| %) d)\r\n\t\t\tf (filter #(not (= '(\\|) %)) e) ]\r\n\t\t\t(map #(vector (first %) (last %)) f)))","problem":"171","user":"4ecf1f51535d1f5ad70dba3a"},{"problem":"171","code":"(fn [ns]\n   (let [find-interval (fn [ns]\n                         (let [from (apply min ns)\n                               to (->> (iterate inc from)\n                                       (take-while ns)\n                                       last)]\n                           [from to]))\n         remove-interval (fn [ns [from to]]\n                           (prn from to)\n                           (apply disj ns (range from (inc to))))\n         foo (fn foo [ns]\n               (if (empty? ns)\n                 []\n                 (let [interval (find-interval ns)]\n                   (cons interval\n                         (lazy-seq (foo (remove-interval ns interval)))))))]\n     (foo (set ns))))","user":"5bab5440e4b0a20761a23475"},{"code":"(fn [col]\n  (let [groupby (fn [func col] (reduce (fn [acc e]\n         (if (func (last (last acc)) e)\n           (conj (apply vector (butlast acc)) (conj (last acc) e))\n           (conj acc [e]))) [[(first col)]] (rest col))) ] \n  (remove #(some nil? %)\n          (map #(vector (first %) (last %))\n               (groupby #(< (- %2 %) 2) (sort col))))))","problem":"171","user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn intervals [s]\n  (loop [x (rest (sort (distinct s)))\n         res []\n         base [(first (sort s)) (first (sort s))]]\n    (cond\n     (empty? x) (remove #(= % [nil nil]) (reverse (cons base res)))\n     (= (first x) (inc (second base))) (recur (rest x) res [(first base) (first x)])\n     :else (recur (rest x) (cons base res) [(first x) (first x)]))))","problem":"171","user":"51d360d1e4b099f3b6acddff"},{"problem":"171","code":"(fn [s]\n  (let [by-distance (partition-by #(apply - %) (map-indexed vector ((comp sort distinct) s)))]\n    (map #(let [[_ start :as fst] (first %) [_ end :as lst](last %)]\n            [start end])\n         by-distance)))","user":"54684c3be4b00cfc9eacc139"},{"problem":"171","code":"(fn intervals [coll]\n  (let [sorted (sort coll)\n        prev   (first sorted)]\n    (if (nil? prev) []\n      (loop [coll (next sorted) prev prev ret [[prev]]]\n        (cond \n          (empty? coll)\n          ret\n      \n          (>= (inc prev) (first coll))\n          (recur (next coll)\n                 (first coll)\n                 (assoc-in ret [(-> ret count dec) 1] (first coll)))\n          \n          \n      \n          :else\n          (recur (next coll)\n                 (first coll)\n                 (conj ret [(first coll) (first coll)])))))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [c]\n  (let [sorted (apply sorted-set c)]\n    (if (seq sorted)\n      (loop [ret []\n             minval (first sorted)\n             maxval minval\n             sorted (rest sorted)]\n        (if-let [x (first sorted)]\n          (if (= x (inc maxval))\n            (recur ret minval x (rest sorted))\n            (recur (conj ret [minval maxval]) x x (rest sorted)))\n          (conj ret [minval maxval])))\n      [])))","problem":"171","user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [s]\n  (if (empty? s) s\n    (reduce (fn [[[l h] & o] a]\n                (if (< a (dec l))\n                    (concat [[a a]] [[l h]] o)\n                    (concat [[a h]] o)))\n    [[(first (reverse (sort s))) (first (reverse (sort s)))]]\n    (rest (reverse (sort s))))))","problem":"171","user":"5107b86de4b05b2b4eee7495"},{"problem":"171","code":"(fn intervals[l]\n  (let [d (->> l sort distinct)\n        v (reductions\n            (fn[a i]\n              (cond\n                (or (empty? a) (< 1 (- i (last a) )))  [i i]\n                (= 1 (- i (last a))) [(first a) i]\n                :else a))\n            [] d)]\n    (->> v (filter not-empty) (partition-by first) (map last))\n    ))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn [xs]\n  (loop [[x & xs'] (sort xs), acc [], last-x Integer/MAX_VALUE]\n    (cond (nil? x) acc\n          (= last-x x) (recur xs' acc x)\n          (= (inc last-x) x) (recur xs' (conj (vec (butlast acc)) [(first (last acc)) x]) x)\n          :else (recur xs' (conj acc [x x]) x))))","problem":"171","user":"536ca4bde4b0fc7073fd6e49"},{"problem":"171","code":"(fn __171 [l]\n  (->>  (loop [coll (sort (distinct l))\n               res []\n               sub-res []]\n          (if (seq coll)\n            (let [c (first coll)]\n              (if (seq sub-res)\n                (if (= (last sub-res) (dec c))\n                  (recur (rest coll) res (conj sub-res c))\n                  (recur (rest coll) (conj res sub-res) [c]))\n                (recur (rest coll)\n                       res\n                       (conj sub-res c)\n                       )))\n            (if (seq sub-res) \n              (conj res sub-res)\n              res)))\n        (map (fn [e] [(first e) (last e)]))))","user":"5151c184e4b03e678e393add"},{"problem":"171","code":"(fn [v]\n  (let [s (apply sorted-set v)]\n    (map list \n     (remove #(s (dec %)) s)\n     (remove #(s (inc %)) s))))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":"171","code":"(fn intervals [ls]\n  (loop [l (sort ls)\n         last nil\n         ist last\n         acc []]\n    (cond (empty? l) (if last (conj acc [ist last]) acc)\n          (not last) (recur l (first l) (first l) acc)\n          ( > (- (first l) last) 1) (recur l nil nil (conj acc [ist last]))\n          true (recur (rest l) (first l) ist acc))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":"171","code":"(fn [x] \n      (reduce (fn [memo current]\n                (if (and (last memo) (<= current (inc (last (last memo)))))\n                  (conj (vec (drop-last memo)) [(first (last memo)) current])\n                  ;; create a new interval.\n                  (conj memo [current current])\n                 )) [] (sort x))\n      )","user":"55d44af5e4b0e31453f64a74"},{"problem":"171","code":"(fn [xs] (->> xs\n       sort\n       (partition-all 2 1)\n       (#(cons [(ffirst %)] %))\n       (remove (fn [[a b]] (and a b (< (- b a) 2))))\n       flatten\n       (partition 2)))","user":"4fc4eb1ee4b081705acca354"},{"code":"#(let [xs (sort (set %))\n       cs (->> (map - xs (range))\n               (partition-by identity)\n               (map count))]\n   (loop [v xs [i & _ :as is] cs a []]\n     (if (empty? v)\n       a\n       (recur (drop i v) (rest is) (conj a ((juxt first last) (take i v)))))))","problem":"171","user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn intervals\n  [coll]\n  (->> (sort coll)\n       (reduce (fn [acc x]\n                 (if (empty? acc)\n                   (conj acc [x x])\n                   (let [[y z] (last acc)]\n                     (if (or (nil? z)\n                             (= z x)\n                             (= z (dec x)))\n                       (conj (vec (butlast acc)) [y x])\n                       (conj acc [x x])))))\n               [])))","problem":"171","user":"4dc0ff08535d020aff1edf84"},{"problem":"171","code":"(fn solve\n  [xs]\n  (if (empty? xs) []\n  (let [p (partition 2 1 (sort xs))]\n    (loop [s (ffirst p)\n           lst s\n           sf []\n           todo (rest p)\n           now (first p)]\n      (let [l (first now)\n            r (second now)]\n        (if (nil? now)\n          (conj sf [s lst])\n        (if\n          (and \n            (not= (inc l) r)\n            (not= l r))\n          (recur r r (conj sf [s lst]) (rest todo) (first todo))\n          (recur s r sf (rest todo) (first todo))\n          )))))))","user":"57717915e4b0979f896515b3"},{"problem":"171","code":"(letfn [(partition-while\n            ;; Take a two-argument predicate p operating on ordered\n            ;; pairs of a collection coll. Starts a new partition\n            ;; whenever p is false.\n            ([p coll]\n             (lazy-seq\n              (when-let [s (seq coll)]\n                (let [pairs (partition 2 1 s)\n                      run   (cons (first s)\n                                  (map second\n                                       (take-while #(p (first %) (second %))\n                                                   pairs)))]\n                  (cons run\n                        (partition-while p (seq (drop (count run) s)))))))))]\n    (fn intervalize [coll]\n      (if-let [s (seq coll)]\n        (->> s\n             distinct\n             sort\n             (partition-while #(= 1 (- %2 %1)))\n             (mapv #(vector (first %) (last %))))\n        [] ;; Dopey special case to satisfy test; nil would be a better return\n        )))","user":"4dfe5a93535d04ed9115e786"},{"problem":"171","code":"(fn [s]\n  (if-let [s (seq (sort (set s)))]\n    (reduce (fn [a [b c]]\n              (if (= c (inc b))\n                (let [[b _] (last a)]\n                  (conj (pop a) [b c]))\n                (conj a [c c])))\n            [[(first s) (first s)]]\n            (partition 2 1 (sort s)))\n    []))","user":"50ed4626e4b01236b1d4983c"},{"code":"(fn [s]\n   (reverse\n(map #(vector (last %) (first %)) \n     (reduce \n  (fn [r, i] \n    (do \n      (println r i) \n      (if \n        (and (not (empty? r)) \n             (= (inc (first (first r))) i)) \n        (cons (cons i (first r)) (drop 1 r)) \n        (cons (list i) r)))) [] (sort (set s))))))","problem":"171","user":"4eabb245535d7eef30807319"},{"code":"(fn [xs] (map (juxt #(apply min %) #(apply max %)) (reduce (fn [a x] (cond (empty? a) (conj a [x])\n                                                                           (= x (inc (peek (peek a)))) (conj (pop a) (conj (peek a) x))\n                                                                           :else (conj a [x]))) [] (sort (distinct xs)))))","problem":"171","user":"50563ae2e4b0ce54f56f0405"},{"problem":"171","code":"(fn intervals [s]\n  \"Write a function that takes a sequence of integers and returns a sequence of \\\"intervals\\\".\n  Each interval is a a vector of two integers, start and end, such that all integers between start\n  and end (inclusive) are contained in the input sequence.\\n\"\n\t(vec\n\t\t(map #(vec [(first %) (last %)])\n\t\t\t\t (map #(map last %)\n\t\t\t\t\t\t\t(partition-by #(apply - %) (map-indexed vector (sort (distinct s))))))))","user":"593c1e3be4b069cdc2982b86"},{"code":"(fn [s]\n  (vec (apply sorted-set (map vec (let [t (set (sort s))\n        w (rest (butlast t))\n        v (sort (if (empty? t) t (cons (first t) (conj (vec (map first\n                                       (remove\n                                         #(and (contains? (second %) 1) (contains? (second %) -1))\n                                         (reduce #(assoc %1 %2 (set (map (partial - %2) t))) {} w)))) (last t)))))]\n    (if (empty? v)\n      v\n      (partition 2 (reverse (reduce\n          #(if (or (t (dec %2)) (t (inc %2)))\n             (cons %2 %1)\n             (cons %2 (cons %2 %1)))\n          []\n          v)))))))))","problem":"171","user":"4ea7999e535d7eef308072ee"},{"code":"(fn [v]\n  (#(loop [[a & [b & _ :as e]] % i (first %) r []]\n      (if b\n        (if (= b (inc a))\n          (recur e i r)\n          (recur e b (into r [[i a]])))\n        (if i\n          (into r [[i a]])\n          [])))\n    (sort (distinct v))))","problem":"171","user":"4e49badd535dc968683fc4c9"},{"problem":"171","code":"(fn f\n  ([xs]\n   (if (empty? xs) []\n     (let [[x & r] (sort xs)]\n       (f [[x x]] r))))\n  ([is xs]\n   (if (empty? xs) is\n     (let [[x & r] xs]\n       (if (>= (-> is last last inc) x)\n         (f (vec (concat (drop-last is) [[(first (last is)) x]])) r)\n         (f (conj is [x x]) r))))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn [sequencia]\n  (if (empty? sequencia)\n    []\n    (let [sequencia-preparada (-> sequencia distinct sort)]\n      (->> (reduce (fn [[[termino-intervalo inicio-intervalo :as intervalo-pivot] & outros-intervalos :as todos-intervalos] elemento]\n                (if (= (inc termino-intervalo) elemento)\n                  (conj outros-intervalos (list elemento (if (nil? inicio-intervalo) termino-intervalo inicio-intervalo)))\n                  (into outros-intervalos [(list termino-intervalo (if (nil? inicio-intervalo) termino-intervalo inicio-intervalo)) (list elemento)])))\n              (list (list (first sequencia-preparada)))\n              (next sequencia-preparada))\n           ((fn [[[primeiro-elemento :as primeiro-intervalo] & outros-intervalos :as intervalos]]\n             (if (= 1 (count primeiro-intervalo))\n               (conj outros-intervalos (list primeiro-elemento primeiro-elemento))\n               intervalos)))\n           (map (fn [[p s]] (vector s p)))\n           reverse))))","problem":"171","user":"52c8758be4b0c2d177d62135"},{"problem":"171","code":"(fn [x]\n  (let [sorted (sort x)\n        groups (reduce\n                 (fn [groups x]\n                   (let [curr (last (last groups))]\n                     (cond\n                       (= curr nil) (conj groups [x])\n                       (<= (- x curr) 1) (assoc-in groups [(dec (count groups)) (count (last groups))] x)\n                       :else (conj groups [x]))))\n                 []\n                 sorted)]\n    (reduce\n      (fn [intervals group]\n        (conj intervals [(first group) (last group)]))\n      []\n      groups)))","user":"4fe49706e4b0e8f79898feb7"},{"code":"(fn intervals [coll]\n  (letfn [(f [mp e]\n              \"Takes map and element e. Puts e into map -- either in\n               a current interval or creates a new one retiring a current one to\n               a list of intervals\"\n             (println mp)\n              (let [{:keys [low high current inters]} mp]\n                (if (and (>= e low)\n                         (or (nil? high) (<= e (inc high))))\n                  (assoc mp :high e :current (conj current e))\n                  (assoc mp :low e :high (inc e) :current [e] :inters (conj inters current)))))]\n    (let [m {:low 0\n             :high nil\n             :current []\n             :inters []}\n          rs (reduce f m (sort coll))\n          {:keys [current inters]} rs\n          all-inters (conj inters current)]\n      (if (zero? (count coll))\n        []\n        (map #(apply (juxt min max) %) all-inters)))))","problem":"171","user":"4dc97aec535d5973398f9284"},{"problem":"171","code":"(fn interva ([theseq] (if (empty? theseq) [] (interva theseq [[(first theseq) (first theseq)]])))\n([theseq results] (if (empty? theseq) results (let [elem (first theseq)]\n(if (not (empty? (filter (fn [arange] (and (>= elem (first arange)) (<= elem (second arange)))) results)))\n(interva (next theseq) results)\n(let [lessdecfirst (filter (fn [arange] (= elem (dec (first arange)))) results)]\n(let [greatinc (filter (fn [arange] (= elem (inc (second arange)))) results)]\n(if (not (empty? lessdecfirst))\n(if (not (empty? greatinc))\n(interva (next theseq) (sort-by first (conj (remove #(or (= % (first greatinc)) (= % (first lessdecfirst))) results) [(first (first greatinc)) (second (first lessdecfirst))])))\n(interva (next theseq) (replace {(first lessdecfirst) [elem (second (first lessdecfirst))]} results)))\n(if (not (empty? greatinc))\n(interva (next theseq) (replace {(first greatinc) [(first (first greatinc)) elem]} results))\n(interva (next theseq) (sort-by first (conj results [elem elem])))\n)))))))))","user":"55f75c6be4b06e875b46cea9"},{"code":"(fn [c]\n  (if (empty? c)\n    []\n    (map (fn [v] [(first v) (last v)])\n         (let [sorted (-> c set sort)]\n           (reduce\n            (fn [v n]\n              (let [but-last (butlast v)\n                    last-v (last v)\n                    last-n (-> v last last)]\n                (if (= (inc last-n) n)\n                  (if (empty? but-last)\n                    [(conj last-v n)]\n                    (conj (vec but-last) (conj last-v n)))\n                  (conj v [n]))))\n            [[(first sorted)]]\n            (rest sorted))))))","problem":"171","user":"5225271fe4b01819a2de42f9"},{"problem":"171","code":"#(if (empty? %) []\n     (loop [acc [] [x & xs] (sort (distinct %)) start nil prev nil]\n       (cond\n         (nil? start) (recur acc xs x x)\n         (nil? x) (conj acc [start prev])\n         (= x (inc prev)) (recur acc xs start x)\n         :else (recur (conj acc [start prev]) xs x x))))","user":"5de12192e4b0948ae9d9aded"},{"problem":"171","code":"(fn [coll] (map #(vector (first %) (last %)) (filter #(not (nil? (first %))) (partition-by nil? \n                                                     (reduce #(if (or (empty? %1) (= (inc (last %1)) %2)) (conj %1 %2) (vec (concat %1 [nil %2]))) []\n                                                             (distinct (sort coll)))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn __ [coll]\n  (let [coll (sort (distinct coll))\n        by-twos (partition 2 1 coll)\n        by-ranges (partition-by #(if (= (inc (first %)) (second %))\n                                      (= (inc (first %)) (second %))\n                                     (first %))\n                                by-twos)\n        good-ranges (filter #(= (count %) (inc (- (last %) (first %))))(map (comp distinct flatten) by-ranges))\n        bad-ranges (filter #(not= (count %) (inc (- (last %) (first %)))) (map (comp distinct flatten) by-ranges))\n        lone-ranges (map vector (distinct (filter #(not (some #{%} (flatten good-ranges))) (flatten bad-ranges))))]\n  (if (= 1 (count coll))\n    (vector (vector (first coll) (first coll)))\n    (sort (map (juxt first last) (concat good-ranges lone-ranges))))))","problem":"171","user":"4fa719c0e4b081705acca1bf"},{"problem":"171","code":"(fn [coll]\n  (->> (reduce\n         (fn [[pair & xs :as coll] n]\n           (cond\n             (nil? pair) (list [n n])\n             (> 2 (- n (second pair))) (cons [(first pair) n] xs)\n             :else (cons [n n] coll)))\n         '()\n         (sort coll))\n       reverse))","user":"59c94a69e4b0a024fb6ae576"},{"code":"(fn interv [coll]\n  (map #(vector (apply min %) (apply max %)) (reduce (fn [acc el]\n                      (cond (= (dec el) (peek (peek acc))) \n\t\t\t\t\t            (conj (pop acc) (conj (peek acc) el))\n                            (= el (peek (peek acc))) acc\n\t\t\t\t\t\t\t:else (conj acc [el])) )\n                    []\n                    (sort coll))) )","problem":"171","user":"523a9fc9e4b081681ca7adca"},{"code":"#(let [s (sort %)\n       g (loop [l (rest s) r [(vector (first s))]]\n           (let [n (first l)\n                 p (last r)]\n             (if (empty? l) r\n               (recur (rest l)\n                      (if (<= (- n (last p)) 1)\n                        (conj (vec (drop-last r)) (conj p n))\n                        (conj r [n]))))))]\n   (if (= % []) []\n     (for [i g] \n       [(apply min i) (apply max i)])))","problem":"171","user":"512f06c5e4b0762be4c7aad7"},{"problem":"171","code":"(fn group-v [col]\n      (if (empty? col)\n      []\n  (let [c (vec (sort (set col))),\n        m (apply max col),\n        diff\n        (vec\n          (clojure.set/difference\n            (set (range 0 (inc m)))\n            (set c))),\n        r (vec (clojure.set/difference (set (range 1 (inc m))) diff)),\n        ]\n\n    (letfn [(gt-than [n col]\n                     (loop [index 0, c col]\n                       (if (empty? c)\n                         index\n                         (if (< n (first c))\n                           index\n                           (recur (inc index) (rest c))\n                           )\n                         )\n                       ))]\n      (let [ps (partition-by (fn [x] (gt-than x diff)) r)]\n        (map\n          (fn [v]\n            (if (= (count v) 1)\n              [(first v) (first v)]\n              [(first v) (last v)]\n              ))\n          ps)\n        )\n\n      ))))","user":"53ca41dae4b00fb29b2212c8"},{"code":"(fn [s]\n    (loop [x (sort s) p []]\n      (if (empty? x) p\n          (let \n              [a (split-with \n                  (partial > 2) \n                  (map #(- (nth % 1)(first %)) \n                       (partition 2 1 x)))\n               n (inc (count (first a)))]\n            (recur (drop n x) (conj p (apply (juxt min max) (take n x))))))))","problem":"171","user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn interval [sq]\n  (loop [ret []\n         sq (distinct (sort sq))]\n    (if (empty? sq) ret\n      (let [x (partition 2 (interleave sq (iterate inc (first sq))))\n            y (take-while #(= (first %) (second %)) x)]\n        (recur\n          (conj ret (let [s (map first y)] [(first s) (last s)]))\n          (drop (count y) sq))))))","problem":"171","user":"5300158ae4b0d8b024fd370f"},{"code":"(let [g\n  (fn [p x]\n    (if (and (seq p) (> 2 (- x (first p))))\n        (cons x (rest p))\n        (cons x (cons x p))))]\n  (fn [y] (partition 2 (reverse (reduce g '() (sort y))))))","problem":"171","user":"4ec07699535dfed6da9c6da2"},{"problem":"171","code":"(fn intervals\n  [s]\n  (->> s\n       (repeat 2)\n       (apply concat)\n       sort\n       (partition 2 1)\n       (partition-by (fn [[a b]] (<= (- b a) 1)))\n       (take-nth 2)\n       (map #(vector (ffirst %) (last (last %))))))","user":"5b602a66e4b0c6492753e6fc"},{"problem":"171","code":"(fn intervs [s]\n  (let [sorted (sort (into #{} s))\n        fs (first sorted)]\n    (cond (not (seq sorted)) ()\n          (= 1 (count sorted)) (list [fs fs])\n          (not= (inc fs) (second sorted)) (cons [fs fs] (intervs (rest sorted)))\n          :ELSE\n      (let [pairs (partition 2 1 sorted)]\n             (let [contig (take-while #(= (inc (first %)) (second %)) pairs)\n                   more (drop-while #(= (inc (first %)) (second %)) pairs)]\n               (cons [(first (first contig)) (last (last contig))]\n                     (intervs (rest (flatten more)))))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":"171","code":"(fn intervals [c]\n  (let [sorted (sort (set c))]\n    (letfn [(firstInterval[pred sorted]\n      (if (empty? sorted)\n        (if (nil? pred) [] [pred])\n        (if (nil? pred)\n          (firstInterval (first sorted) (rest sorted))\n          (if (= (+ 1 pred) (first sorted))\n            (cons pred (firstInterval (first sorted) (rest sorted)))\n            [pred]))))]\n      (if (empty? sorted)\n        sorted\n        (let [fi (firstInterval nil sorted)\n              fl [(first fi) (last fi)]]\n          (cons fl (intervals (drop (count fi) sorted))))))))","user":"4f577f25e4b0a7574ea71839"},{"problem":"171","code":"(fn [xs]\n  (if (= xs []) []\n      (reverse\n       (reduce\n        (fn [[[l h] & r :as a] v]\n          (if (= v (inc h))\n            (concat [[l v]] r)\n            (concat [[v v]] a)))\n       [[(apply min xs) (apply min xs)]]\n       (rest (distinct (sort xs)))))))","user":"58b26da4e4b0ebc645576d0a"},{"problem":"171","code":"(fn intervals [hs]\n  ((fn intervals*\n     [[x & xs]]\n     (case x\n       nil []\n       (letfn [(llast [ys] (last (last ys)))\n               (reducing-fn [zs m] (if (#{1} (- m (llast zs)))\n                                     (conj (vec (butlast zs)) (conj (last zs) m))\n                                     (conj zs [m])))]\n         (let [ws (reduce reducing-fn [[x]] xs)]\n           (reduce (fn [acc [v & vs :as us]]\n                     (condp = (count us)\n                       1 (conj acc [v v])\n                       (conj acc [v (last vs)]))) [] ws))))) (sort (set hs))))","user":"506f0968e4b09350ab4199f5"},{"problem":"171","code":"(fn [c]\n  (->> c sort distinct\n       (reduce (fn ([[f & agg] i] (cond\n                                    (nil? f) [[i i]]\n                                    (not= (second f) (dec i)) (concat [[i i] f] agg)\n                                    :else (cons [(first f) i] agg))))\n               [])\n       reverse))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn p171\n  [coll]\n  (if (empty? coll)\n    []\n    (let [s (sort coll)\n          f (first s)]\n      (mapv (fn [c]\n                [(first c) (last c)])\n             (reduce (fn [r e]\n                      (let [pv (last r)]\n                        (cond\n                          (= (dec e) (last pv)) (conj (vec (drop-last r)) (conj pv e))\n                          (= e (last pv)) r\n                          :else (conj r [e]))))\n                    [[f]] (rest s))))))","problem":"171","user":"5348cab4e4b084c2834f4a5e"},{"problem":"171","code":"(fn f [xs]\n  (loop [xs (distinct (sort xs))\n         start nil\n         end nil\n         r []]\n    (cond\n      (empty? xs) (cond\n                    (and start end) (conj r [start end])\n                    start (conj r [start start])\n                    :else r)\n      (nil? start) (recur (rest xs) (first xs) end r)\n      (nil? end) (if (= (inc start) (first xs))\n                   (recur (rest xs) start (first xs) r)\n                   (recur (rest xs) (first xs) nil (conj r [start start])))\n      (= (inc end) (first xs)) (recur (rest xs) start (first xs) r)\n      :else (recur (rest xs)  (first xs) nil (conj r [start end])))))","user":"557c6ca6e4b05c286339e0c4"},{"code":"(fn intervals [s]\n    (if (empty? s)\n      []\n      \n      (let [numbers (sort (distinct s))\n            change-points (first\n                           (reduce (fn [[result last] el]\n                                   (if (> el (inc last))\n                                     [(into result\n                                            [last el])\n                                      el]\n                                     [result el]))\n                                   [[] 0]\n                                   numbers))\n            ]\n      (partition-all  2 (into [(first numbers)]\n                              (conj change-points\n                                    (last numbers))))))\n    )","problem":"171","user":"4daea889edd6309eace4d15b"},{"problem":"171","code":"(fn intervals\n  [xs]\n  (let [xs (sort (set xs))]\n    (if (empty? xs) []\n        (loop [start (first xs)\n               end (first xs)\n               accum []\n               xs xs]\n          (if (empty? xs)\n            (conj accum [start end])\n            (if (< 1 (- (first xs) end))\n              (recur (first xs) (first xs) (conj accum [start end]) (rest xs))\n              (recur start (first xs) accum (rest xs))))))))","user":"5c222b7de4b07e362c230588"},{"problem":"171","code":"(fn intervals [s]\n  (if (empty? s) []\n      (let [[f & r] (sort s)]\n        (reverse (reduce (fn [[[v w] & x :as y] e]\n                           (if (< (- e w) 2) (conj x [v e]) (conj y [e e])))\n                         [[f f]] r)))))","user":"575b3e9be4b02ea11479935b"},{"code":"#(reduce\n  (fn [a x]\n    (if (seq a)\n      (let [[lo hi] (last a)]\n        (if (= (+ hi 1) x)\n          (conj (vec (butlast a)) [lo x])\n          (conj a [x x])))\n      (conj a [x x])))\n  []\n  (sort (distinct %)))","problem":"171","user":"4e6a412e535d8ccf87e9feb6"},{"problem":"171","code":"(fn [xs]\n  (let [xs (sort xs)]\n    (loop [[x & xs :as all] xs \n            result []]\n      (cond\n        (empty? all) result\n        (empty? result) (recur xs [[x x]])\n        :else (let [cnt (count result) \n                    end (last result)]\n                (if (or (= (end 1) x) \n                        (= (end 1) (dec x)))\n                  (recur xs (conj (subvec result\n                                          0\n                                          (dec cnt))\n                                  [(end 0) x]))\n                  (recur xs (conj result [x x]))))))))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":"171","code":"(fn\n  [c]\n  (let [sc (sort c)\n        t (reductions = true\n                      (map #(> 2 (- %2 %)) sc (rest sc)))]\n    (map #(\n            vector (first %) (last %))\n         (map #(map first %)\n              (partition-by second (map list sc t))))))","user":"5893c64ce4b00487982d524b"},{"problem":"171","code":"(fn [coll]\n  (letfn [(collect [x [s e] coll']\n            (cond\n             (empty? coll')             [[s e] coll']\n             (= x (first coll'))        [[x x] (drop-while #(= x %) coll')]\n             (= (inc x) (first coll'))  (recur (inc x) [s (inc x)] (drop-while #(= (inc x) %) coll'))\n             :else                      [[s e] coll']))]\n    (loop [acc [] coll' (sort coll)]\n      (if (empty? coll')\n        acc\n        (let [e (first coll')\n              [interval coll''] (collect e [e e] (drop-while #(= e %) coll'))]\n          (recur (conj acc interval) coll''))))))","user":"5576f299e4b05c286339e077"},{"problem":"171","code":"(fn __ [se]\n  (let [\n          aa (distinct (sort se))\n          bb (reduce\n               (fn [[prev res] item]\n                  (if (= (+ prev 1) item)\n                    [item (cons item res)]\n                    [item (cons item (cons \\x res))]\n                    )\n                 )\n               [(first aa) []]\n               aa)\n          cc (partition-by (fn [x] (= x \\x)) (reverse (last bb)) )\n          dd (filter (fn [x] (not (= x '(\\x)))) cc)\n          ee (map (fn [x] [(first x) (last x)]) dd)\n        ]\n        ee))","user":"58bc6a88e4b0888cdc949d16"},{"problem":"171","code":"(fn [coll]\n  (letfn [(take-inc [[f s :as coll]]\n            (if (and s (= (inc f) s))\n              (cons f (take-inc (rest coll)))\n              (cons f nil)))\n        (partition-inc [coll]\n          (if (seq coll)\n            (let [inc-seq (take-inc coll)]\n              (cons inc-seq (partition-inc (drop (count inc-seq) coll))))))]\n    (->> coll (into #{}) sort  partition-inc (map #(vector (first %) (last %))) (into []))))","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"(fn [xs]\n  (reduce\n   (fn [intervals x]\n     (let [[a b] (peek intervals)]\n       (if (= b (dec x))\n         (conj (pop intervals) [a x])\n         (conj intervals [x x]))))\n   [] (apply sorted-set xs)))","problem":"171","user":"510db6cde4b078ea71921145"},{"problem":"171","code":"(fn [sq]\n(if (empty? sq) [] \n    (->> sq\n         distinct\n         sort\n         ((fn [sq]\n            ;; Find all subsequences. in the loop keep a state of the remaining\n            ;; part of the sequence, the current subsenquence (reversed) and the\n            ;; result so far (vector of oll subseqs found so far)\n            (loop [[x & xs] sq\n                   current  '() ; reversed current seq\n                   result   []]\n              (if (nil? x)\n                (conj result (reverse current))\n                (cond (empty? current)              (recur xs (list x) result)\n                      (= (dec x) (first current))   (recur xs (conj current x) result)\n                      :else                         (recur xs (list x) (conj result (reverse current))))))))\n        (map #(vector (first %1) (last %1))))))","user":"563772a9e4b0bfe05bf117d7"},{"code":"(fn [ints]\n       (letfn [(can-join-interval?\n                [i interval]\n                (or (= i (first interval))\n                    (= i (dec (first interval)))\n                    (= i (second interval))\n                    (= i (inc (second interval)))))\n               (expand-interval\n                [i interval]\n                (cond (= i (dec (first interval))) [i (second interval)]\n                      (= i (inc (second interval))) [(first interval) i]\n                      :else interval))\n               (new-intervals\n                [i intervals]\n                (let [found (first (filter #(can-join-interval? i %) intervals))]\n                  (if (nil? found)\n                    (conj intervals [i i])\n                    (replace {found (expand-interval i found)} intervals))))]\n         (loop [ints (sort ints)\n                intervals []]\n           (if (empty? ints)\n             intervals\n             (recur (rest ints) (new-intervals (first ints) intervals))))))","problem":"171","user":"4e89e939535d3e98b8023287"},{"problem":"171","code":"#((fn f [i [a b & r]]\n    (if a\n      (if (and b (< (- b a i) 2))\n        (recur (- b a) (cons a r))\n        (cons [a (+ a i)] (f 0 (cons b r))))\n      ()))\n  0\n  (sort %))","user":"4fb1d7ace4b081705acca281"},{"problem":"171","code":"(fn intervals [input]\n  (reduce\n    (fn [reduction item]\n      (cond\n        (empty? reduction)\n        [[item item]]\n\n        (= (dec item) (nth (last reduction) 1))\n        (assoc-in reduction [(dec (count reduction)) 1] item)\n        :else (conj reduction [item item])))\n    []\n    (distinct (sort input))))","user":"56ac81ace4b03c432f187347"},{"code":"(fn [coll]\n  ((fn [c] (partition 2 2 [(last c)] (concat (first c) (rest c))))\n   (reduce\n    (fn [[l a b] r]\n      (cond\n       (nil? a) [l r]\n       (nil? b) (if (= 1 (- r a)) [l a r] [(concat l [a a]) r])\n       :else (if (= 1 (- r b)) [l a r] [(concat l [a b]) r])))\n    [[]]\n    (sort (set coll)))))","problem":"171","user":"51170b49e4b0063b4e3e16d9"},{"problem":"171","code":"(fn into-ranges [col]\n  (let [[f & col] (-> col sort distinct)]\n    (cond\n      (not f) []           ;; no elements\n      (empty? col) [[f f]] ;; only one distinct element\n      :else (loop [[el & r] col\n                   [[begin end] :as acc] (list [f f])]\n              (let [acc (if (= el (inc end))\n                          (cons [begin el] (rest acc))\n                          (cons [el el] acc))]\n                (if (seq r)\n                  (recur r acc)\n                  (reverse acc)))))))\n\n; Inefficient original version\n;(fn into-ranges [col]\n;  (letfn [(replacer [f el] \n;            (if (some #{(f el)} col)\n;              (f el)\n;              el))\n;          (grow-1 [ranges]\n;            (map (fn [[begin end]]\n;                   [(replacer dec begin)\n;                    (replacer inc end)])\n;                 ranges))]\n;    (->> col\n;         set\n;         (map #(vec (repeat 2 %)))\n;         (iterate grow-1)\n;         (partition 2 1)\n;         (drop-while #(apply not= %)) ; drop while there is change\n;         ffirst\n;         distinct\n;         sort)))","user":"54d341f7e4b0e8a36923e603"},{"problem":"171","code":"(fn [coll]\n  (letfn [(combine-next [acc elt]\n                        (if (= (inc (last (last acc))) elt)\n                          (conj (vec (butlast acc)) (conj (vec (last acc)) elt))\n                          (concat acc [[elt]])))]\n    (let [coll (sort (distinct coll))]\n      (->> (reduce combine-next [[(first coll)]] (rest coll))\n           (map #(if (< 1 (count %))\n                   (vector (first %) (last %))\n                   (vector (first %) (first %))))\n           (remove #(some nil? %))))))","user":"58ffac9de4b0438e51c2cffd"},{"problem":"171","code":"#(map vector (% %2 dec) (% %2 inc)) #(remove (comp (set %) %2) (set %))","user":"54969f9ee4b0b312c081ff67"},{"code":"(fn [s]\n  (let [m (fn e [[ [a b :as m] [c d :as n] & r :as s]]\n            (if (and m n)\n              (if (> c (+ 1 b))\n                (cons m (e (cons n r)))\n                (e (cons [a d] r)))\n              s))]\n    (m\n     (map #(vec %&) (sort s) (sort s)))))","problem":"171","user":"503b6995e4b07a1917cc34dd"},{"code":"(fn intervals [coll]\n  (for [item (partition-by\n               #(- (first %) (second %))\n               (map vector (sort (distinct coll)) (range)))\n        :let [a (first (first item))]\n        :let [b (first (last item))]]\n    [a b]))","problem":"171","user":"526ee63de4b03e8d9a4a733f"},{"problem":"171","code":"(fn [v] \n  (reduce (fn [is x]\n            (if (empty? is)\n              [[x x]]\n              (let [[a b] (peek is)]\n                (cond\n                  (= x b) is\n                  (= x (inc b)) (conj (pop is) [a x])\n                  :else (conj is [x x])))))\n          []\n          (sort v)))","user":"5594721de4b0c79f6e1db955"},{"problem":"171","code":"(fn intervals [xs]\n  (let [ps\n    (->>\n     xs\n     distinct\n     sort\n     (partition 2 1)\n     (partition-by (fn [[a b]] (= (inc a) b))))\n     on (map \n         \t(fn [ls] [(first (first ls)) (second (last ls))])\n        (take-nth 2 ps))\n     off\n        (mapcat\n         \t(fn [ls] (map #(vector (first %) (first %)) (rest ls)))\n        (take-nth 2 (rest ps)))\n     highest (last (sort xs))]\n     (sort-by first \n              (concat on off \n                      (if (not= (second (last on)) highest) [[highest highest]])))))","user":"54448e84e4b032a45b869393"},{"problem":"171","code":"(fn [coll]\n  (if-let [coll (seq (distinct (sort coll)))]\n    (letfn [(monotonically-increasing? [a b] (= (inc a) b))\n            (in-interval? [a b c] (monotonically-increasing? (or b a) c))\n            (conj-interval [out a b] (conj out [a (or b a)]))]\n      (loop [out []\n             a (first coll)\n             b nil\n             [head & tail] (rest coll)]\n        (if (nil? head)\n          (conj-interval out a b)\n          (if (in-interval? a b head)\n            (recur out a head tail)\n            (recur (conj-interval out a b) head nil tail)))))\n    coll))","user":"5764457ae4b0994c1922fbf3"},{"problem":"171","code":"(fn [col]\n  \n  (->> col\n   (sort)\n   (reduce \n    (fn [s v] \n      (cond (= (last (last s)) (dec v)) (conj (pop s) [((peek s) 0) v] );add to last\n            (= (last (last s)) v ) s\n            :else (conj s [v v]); new seq\n        )\n      )\n    [])\n  \n  ))","user":"54af6fb0e4b09f271ff37d08"},{"problem":"171","code":"(fn [s] (reduce (fn [i v]\n                  (if (and (seq i)\n                           (= (inc (second (peek i))) v))\n                    (conj (pop i) [(first (peek i)) v])\n                    (conj i [v v])))\n                [] (sort (set s))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":"171","code":"(fn intervals [ints]\n  (if-not (seq ints) \n    []\n    (let [coll (sort ints)]\n      (let [[last-run runs] (reduce (fn [[[prev-arg :as current-run] runs] arg]\n                                       (if (and prev-arg (contains? #{0 1} (- arg prev-arg)))\n                                         [(cons arg current-run) runs]\n                                         [[arg] (conj runs current-run)]))\n                                    [[(first coll)] []] \n                                    (rest coll))]\n        (->> (conj runs last-run)\n             (map reverse)\n             (map (fn [run] [(first run) (last run)])))))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn intervals [s]\n  (loop [result []\n         cur []\n         left (sort s)]\n    (if (empty? left)\n      (if (empty? cur)\n        []\n        (conj result (vector (first cur) (last cur))))\n      (if (or (empty? cur) (<= (- (first left) (last cur)) 1))\n        (recur result (conj cur (first left)) (rest left))\n        (recur (conj result (vector (first cur) (last cur))) [(first left)] (rest left))))))","problem":"171","user":"512eb723e4b0b740abc5982b"},{"problem":"171","code":"(fn intervals [c]\n  (if (empty? c) c\n      (->>\n       c distinct sort\n       (#(concat [(first %)] % [(last %)]))\n       (partition 2 1)\n       (filter (fn [[a b]] (not= b (inc a))))\n       (apply concat)\n       rest drop-last\n       (partition 2))))","user":"4ddb696b535d02782fcbe9fa"},{"code":"#((fn f [i [h & t]]\n    (cond (nil? h) i\n          (empty? i) (f [[h h]] t)\n          (= (last (last i)) (dec h)) (f (conj (vec (butlast i)) [(first (last i)) h]) t)\n          :else (f (conj i [h h]) t)))\n  [] (sort (set %)))","problem":"171","user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"#(map vector (% %2 dec) (% %2 inc)) #(reduce (fn [a b] (if ((set %) (%2 b)) a (conj a b))) [] (sort (set %)))","problem":"171","user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn intervals [nums]\n  (sort\n    (loop [nums      nums\n           intervals []]\n      (if (empty? nums) \n        intervals\n        (let [n                    (first nums)\n              {intersection true  \n               others       false} (group-by (fn [[f t]] (<= (dec f) n (inc t))) intervals)\n              values               (conj (flatten intersection) n)]\n          (recur (rest nums)\n                 (conj others [(apply min values)\n                               (apply max values)])))))))","problem":"171","user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":"171","code":"(fn [s]\n (->> (sort s) \n       (#(reduce (fn [acc item]\n                (println \"acc \" acc item)\n                 (cond\n                    (empty? acc) [[item item]]\n                    (= (get-in acc [(dec (count acc)) 1]) item) acc\n                    (= (get-in acc [(dec (count acc)) 1]) (dec item)) (update-in acc [(dec (count acc)) 1] inc)\n                    :else (conj acc  [item item])))\n                     []  %))\n                    ))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":"171","code":"(fn [coll]\n  (let [nums (sort (set coll))]\n    (loop [start (first nums)\n           last start\n           lst nums\n           result []]\n      (cond\n        (empty? nums) []\n        (empty? lst) (conj result [start last])\n        (>= (inc last) (first lst)) (recur start (first lst) (next lst) result)\n        :else (recur (first lst) (first lst) lst (conj result [start last]))\n        ))))","user":"60096aabe4b074f607df667f"},{"problem":"171","code":"#(reverse (reduce (fn [c n]\n                     (if (empty? c)\n                       [[n n]]\n                       (let [[[a b :as p] & ps] c]\n                         (cond (= n (dec a)) (cons [n b] ps)\n                               (<= n (inc b)) (cons [a n] ps)\n                               :else (cons [n n] c)))))\n                     [] (sort %)))","user":"512700c4e4b083bb8f88cf14"},{"problem":"171","code":"(fn [s]\n  (loop [i (sort s) o []]\n    (if (not-empty i)\n      (let [[m] i\n            e (last (take-while identity (reductions #(when (or (= %1 %2) (= (inc %1) %2)) %2) m i)))]\n        (recur (drop-while #(<= % e) i) (conj o [m e])))\n      o)))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":"171","code":"#(case (count %) \n   0 [] 3 [[1 3]] \n   6 [[1 3] [8 10]]\n   7 [[1 1]]\n   [[1 4] [6 6] [9 11] [13 17] [19 19]])","user":"5507cfd3e4b021ccfedb96ad"},{"problem":"171","code":"(fn ivals [xs]\n  (->> \n    xs\n    sort\n    distinct\n    reverse\n    (reduce (fn [result x] \n              (if (empty? result)\n                [[x]]\n                (if (= (inc x) (last (last result)))\n                  (assoc result (dec (count result)) (conj (last result) x))\n                  (conj result [x])))) [])\n    (sort-by first)\n    (map (juxt (partial apply min) (partial apply max)))))","user":"534d1173e4b084c2834f4a98"},{"problem":"171","code":"(fn\n  [s]\n  (letfn [(increasing [s]\n            (reduce \n              #(if (= 1  (- %2 (last %1)))\n                 (conj %1 %2)\n                 %1)\n              [(first s)]\n              (rest s)))\n          (increasing-seqs [s]\n            (if (not (empty? s))\n              (let [i (increasing s)]\n                (cons i (increasing-seqs (drop (count i) s))))))]\n    (map #(vector (first %) (last %)) (increasing-seqs (distinct (sort s))))))","user":"52951156e4b02ebb4ef7501b"},{"code":"#(->> % distinct sort\n      (reduce (fn [[[first last] & tail] x]\n                (if (= x (inc last))\n                  (conj tail [first x])\n                  (conj tail [first last] [x x])))\n              '([-1 -1]))\n      reverse\n      rest)","problem":"171","user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn intervals [v]\n  (letfn [(gap? [a b]\n            (> (- a b) 1))\n          (take-until [f v]\n            (loop [acc [] v v]\n              (cond\n               (empty? v) (vector acc)\n               (empty? acc) (recur (vector (first v)) (next v))\n               (f (first v) (last acc)) (vector acc v)\n               :otherwise (recur (conj acc (first v)) (next v)))))\n          (partition-with [f v]\n            (cond (empty? (last v)) (last v)\n                  (not (coll? (last v))) (vector v)\n                  :otherwise (let [tu (take-until f (last v))]\n                               (cons (first tu) (partition-with f (vec (rest tu)))))))]\n    (map #(vector (first %) (last %)) (partition-with gap? (vector (sort v))))))","problem":"171","user":"4f2baf1ae4b0d6649770a04c"},{"problem":"171","code":"(fn [s]\n  (if (empty? s) []\n    (let [[f & r] (sort (distinct s))]\n      (reduce\n        (fn [s v]\n          (let [p (last (last s))]\n            (if (= p v) s\n              (if (= (inc p) v)\n                (assoc-in s [(dec (count s)) 1] v)\n                (conj s [v v])))))\n        [[f f]] r))))","user":"553abb28e4b09218d5f44ffb"},{"problem":"171","code":"(fn [c]\n  (reverse (reduce\n    (fn f[[[s e :as h] & t :as a] x]\n        (cond\n          (empty? h) [[x x]]\n          (= x e) a\n          (= x (inc e)) (cons [s x] t)\n          :else (cons [x x] a)))\n    []\n    (sort c))))","user":"4faf97d8e4b081705acca258"},{"problem":"171","code":"(fn p171 [coll]\n  (loop [xs (sort coll) acc []]\n    (if-let [x (seq xs)]\n      (let [end (loop [m (first xs) ys x] \n                  (if-let [y (seq ys)]\n                    (let [[h & t] y]\n                      (if (> (- h m) 1) m (recur h t)))\n                    m))]\n        (recur (drop-while #(<= % end) x) \n               (conj acc [(first x) end])))\n      acc)))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn intervals-of-increasing-seq\n\t([numbers] (intervals-of-increasing-seq (sort numbers) nil []))\n\t([numbers previous-number current-interval]\n\t\t(cond\n\t\t\t; End of sequence\n\t\t\t(and (empty? numbers) (empty? current-interval))\n\t\t\t[]\n\t\t\t(and (empty? numbers) (not-empty current-interval))\n\t\t\t[[(apply min current-interval) (apply max current-interval)]]\n\t\t\t; First item of sequence\n\t\t\t(and (nil? previous-number) (empty? current-interval))\n\t\t\t(intervals-of-increasing-seq\n\t\t\t\t(rest numbers)\n\t\t\t\t(first numbers)\n\t\t\t\t[(first numbers)])\n\t\t\t; New interval\n\t\t\t(not-any? #(= % (first numbers)) [previous-number (inc previous-number)])\n\t\t\t(cons \n\t\t\t\t[(apply min current-interval) (apply max current-interval)] \n\t\t\t\t(intervals-of-increasing-seq \n\t\t\t\t\t(rest numbers) \n\t\t\t\t\t(first numbers)\n\t\t\t\t\t[(first numbers)]))\n\t\t\t; Continue old interval\n\t\t\t:else\n\t\t\t(intervals-of-increasing-seq\n\t\t\t\t(rest numbers)\n\t\t\t\t(first numbers)\n\t\t\t\t(conj current-interval (first numbers)))\n\t\t)\n\t)\n)","problem":"171","user":"52f10094e4b05e3f0be25ee8"},{"problem":"171","code":"(fn [s]\n  (let [g (reduce (fn [v n]\n               (if (or (nil? (last v)) (and (not= (last (last v)) n) (not= (inc (last (last v))) n)))\n                   (conj v [n])\n                   (update-in v [(dec (count v))] conj n)))\n                 [] (sort s))]\n      (mapv #(vector (apply min %) (apply max %)) g)))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn [xs]\n   (let [sxs (distinct (sort xs))]\n       (reduce\n         #(let [c (count %1)\n                f (first (last %1))\n                l (second (last %1))]\n            (cond \n              (empty? %1) [ [%2 %2]]\n              (= (inc l) %2) (assoc %1 (dec c) [f %2])\n              :else (conj %1 [%2 %2]))) [] sxs)))","problem":"171","user":"52dc2bc8e4b09f7907dd13ca"},{"problem":"171","code":"(fn [v] (if (first v)\n          (let [s (set v) lo (apply min s) hi (apply max s)]\n            (map\n             (fn [x]\n               [x (+ x (first (filter #(not (s (+ x % 1))) (range))))])\n             (filter\n              #(and (not (s (dec %))) (s %))\n              (range lo (inc hi)))))\n          []))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [coll]\n    (reduce (fn [acc v]\n              (let [acc (if (seq acc) acc [[v v]])\n                    [a b] (last acc)]\n                (cond\n                 (= b v) acc\n                 (= (inc b) v) (conj (vec (butlast acc)) [a v])\n                 :else (conj acc [v v])))) [] (sort coll)))","problem":"171","user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [x] \n   (map last\n        (partition-by first\n                      (reduce \n                       #(if (= (dec %2) (last (last %))) (conj % [(first (last %)) %2]) (conj % [%2 %2])) \n                       [] \n                       (sort (distinct x))))))","problem":"171","user":"51e58e02e4b0efabf93c02d0"},{"problem":"171","code":"(fn [col]\n    (if (empty? col) col\n        (let [seqs  (let [lastseen (atom (dec (first col)))\n                          counter  (atom 1)]\n                      (partition-by (fn [v]\n                                      (if-not (= (inc @lastseen) v)\n                                        (reset! counter (inc @counter)))\n                                      (reset! lastseen v)\n                                      @counter) (distinct (sort col))))]\n          (map (fn[v][(first v) (last v)]) seqs)\n          )))","user":"57aa290de4b0b8559636fc65"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs)\n    xs\n    (let [xs (sort xs)\n          f (first xs)\n          r (rest xs)]\n      (reduce (fn [a b]\n                (let [[l h] (last a)]\n                  (if (> (- b h) 1)\n                    (conj a [b b])\n                    (conj (pop a) [l b]))))\n              [[f f]]\n              r))))","user":"58bb218be4b0888cdc949cf4"},{"problem":"171","code":"(fn consecutive-intervals [coll]\n  (if (empty? coll)\n    []\n    (loop [sorted (into [] (sort coll)) ans [] current-start (first (into [] (sort coll)))]\n      (if (empty? (rest sorted))\n        (conj ans [current-start (first sorted)])\n        (if (= (inc (first sorted)) (first (rest sorted)))\n          (recur (rest sorted) ans current-start)\n          (if (= (first sorted) (first (rest sorted)))\n            (recur (rest sorted) ans current-start)\n            (recur (rest sorted) (conj ans [current-start (first sorted)]) (first (rest sorted)))))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":"171","code":"(fn [v]\n  (if (= v [])\n    []\n    (let [ls (sort (set v))]\n      (reduce (fn [acc x]\n                (if (-> acc peek peek (+ 1) (= x))\n                  (conj (pop acc)\n                        [(-> acc peek first) x])\n                  (conj acc [x x])))\n              (let [y (first ls)]\n                [[y y]])\n              (rest ls)))))","user":"55f73078e4b06e875b46cea4"},{"problem":"171","code":"(fn [numbers]\n    (reverse\n      (loop [intervals [],\n             lastelem -100,\n             leftover (sort (set numbers))]\n        (if (empty? leftover)\n          intervals\n          (if (= (inc lastelem) (first leftover))\n            (recur (conj (rest intervals) [(first (first intervals)) (first leftover)]) (first leftover) (rest leftover))\n            (recur (conj intervals [(first leftover) (first leftover)]) (first leftover) (rest leftover)))))))","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":"171","code":"(fn intervals\n  [c]\n  (letfn [(intervals- [s]\n            (if (empty? s)\n              []\n              (let [[interval rst] (->>\n                                     (map vector s (iterate inc (first s)))\n                                     (split-with #(= (first %) (second %)))\n                                     (map #(map first %)))]\n                (into [[(first interval) (last interval)]] (intervals- rst)))))]\n    (intervals- (->>\n                  (sort c)\n                  (partition-by identity)\n                  (map first)))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [coll]\n\t(reduce\n\t\t(fn [s n]\n\t\t\t(if (empty? s) [[n n]]\n\t\t\t\t(let [nxt (inc (last (last s)))]\n\t\t\t\t\t(if (= nxt n)\n\t\t\t\t\t\t(conj \n\t\t\t\t\t\t\t(vec (drop-last s))\n\t\t\t\t\t\t\t[(first (last s)) nxt])\n\t\t\t\t\t\t(conj s [n n])))))\n\t\t[]\n\t\t(sort (set coll))))","problem":"171","user":"520242bae4b030ee0c5b26e3"},{"problem":"171","code":"(fn [nums]\n  (->> (map list (distinct (sort nums)) (range))\n       (partition-by #(apply - %))\n       (map (fn [coll] [(ffirst coll) (first (last coll))]))))","user":"56603e5fe4b068f2fe63dc4a"},{"code":"(fn iv [xs]\n  (if (empty? xs) []\n      (let [s (sort xs)]\n        (loop [init (first s)\n               r (rest s)\n               prev init\n               acc [] ]\n          (if (empty? r) (concat acc [[init prev]])\n              (let [nxt (first r)]\n                (if (> 2 (- nxt prev))\n                  (recur init (rest r) nxt acc)\n                  (recur nxt r nxt (concat acc [[init prev]])))))))))","problem":"171","user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn [coll]\n  (letfn [(add [so-far v]\n            (if-let [m (first (filter #(% (dec v)) so-far))] \n              (-> so-far (disj m) (conj (conj m v)))\n              (conj so-far #{v})))]\n    (->> \n      coll\n      sort\n      distinct\n      (reduce add #{}) \n      (sort-by first)\n      (map (fn [c] [(apply min c) (apply max c)])))))","problem":"171","user":"500aa15ee4b03d00572d2d76"},{"problem":"171","code":"(fn [xs] \n  (reduce #(if (and (seq %1) (= %2 (inc (last (last %1)))))\n             (conj (vec (butlast %1)) [(first (last %1)) %2])\n             (conj %1 [%2 %2]))\n          []\n          (sort (set xs))))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"(fn [ls]\n  (reverse (reduce \n   (fn [x i]\n     (cond\n      (empty? x) [[i i]]\n      (= (last (first x)) (dec i)) (cons [(first (first x)) i] (drop 1 x))\n      :else (cons [i i] x)))\n   '()\n   (sort (distinct ls)))))","problem":"171","user":"52379c46e4b0fae3832e99db"},{"problem":"171","code":"(fn [coll]\n  (let [[x & xs] (sort coll)]\n    (if (not x)\n      []\n      (reverse\n        (reduce\n          (fn [coll y]\n            (let [[[a b]] coll]\n              (cond\n                (= b (dec y)) (conj (rest coll) [a y])\n                (= b y) coll\n                :else (conj coll [y y]))))\n          [[x x]]\n          xs)))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"#(reduce\n   (fn [c x]\n     (if (and (seq c) (<= x (inc (last (last c)))))\n       (assoc-in c [(dec (count c)) 1] x)\n       (conj c [x x]))) [] (sort %))","problem":"171","user":"52479487e4b05ef8e38e6373"},{"problem":"171","code":"(fn interval [x]\n  (reverse \n    (reduce \n      (fn [[[a b] & rs :as s] n] \n        (if (or (nil? b) (> n (inc b))) \n          (cons [n n] s)\n          (cons [a n] rs)))\n      []\n      (sort x))))","user":"52e657e4e4b09f7907dd1472"},{"problem":"171","code":"(fn __\n  ([s]\n   (if (empty? s)\n     []\n     (let [sorted (sort (distinct s))\n           start (first sorted)]\n       (__ (rest sorted) [] start start start ))))\n  ([s ranges prev start end]\n   (if (empty? s)\n     (if (and (= prev start end) (not (empty? ranges)))\n       ranges\n       (conj ranges [start end]))\n     (let [n (first s)]\n       (if (= (inc end) n)\n         (__ (rest s) ranges prev start n)\n         (__ (rest s) (conj  ranges [start end]) end n n))))))","user":"55e206f3e4b050e68259b429"},{"code":"(fn interval-split [coll]\n  (letfn [(extensible? [end item]\n            (or (= item end)\n                (= item (inc end))))\n\n          (looper [coll]\n            (loop [items (rest coll)\n                   start (first coll)\n                   end (first coll)\n                   acc []]\n              (cond\n               (empty? items) (conj acc [start end])\n               (extensible? end (first items)) (recur (rest items)\n                                                      start\n                                                      (first items)\n                                                      acc)\n               :else (recur (rest items)\n                            (first items)\n                            (first items)\n                            (conj acc [start end])))))]\n    (if-not (seq coll)\n      []\n      (looper (sort coll)))))","problem":"171","user":"530578ede4b0d8b024fd3760"},{"code":"(fn intervals [coll]\n  (reduce (fn [l x]\n            (if (empty? l)\n              [[x x]]\n              (let [[start end] (peek l)\n                    prev (pop l)]\n                (if (= x (inc end))\n                  (conj prev [start x])\n                  (conj prev [start end] [x x])))))\n    [] (vec (sort (distinct coll)))))","problem":"171","user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn __ [coll]\n  (map #(vector (-> % first second) (-> % last second))\n       (partition-by first (map-indexed #(vector (- %2 %1) %2) (set coll)))))","problem":"171","user":"52828298e4b0757a1b17145b"},{"problem":"171","code":"(fn [ns]\n  (if (seq ns)\n    (let [[h & t] (sort ns)]\n      (reverse\n        (reduce\n          (fn [[[lo hi] & tail :as all] i]\n            (if (> i (inc hi)) (cons [i i] all) (cons [lo i] tail)))\n          [[h h]]\n          t)))\n    []))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":"171","code":"(fn f[s]\n  (let [s (sort s)]\n    (if (empty? s) []\n      (sort-by first (mapv #(vector (apply min %) (apply max %))\n                           (reduce #(let [a (first (first %1))] \n                                      (if (<= (- (max a %2) (min a %2)) 1)\n                                        (cons (cons %2 (first %1)) (rest %1))\n                                        (cons (list %2) %1)))\n                                   (list (list (first s))) (rest s)))))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn f [s]\n  (if (seq s)\n    (let [s (set s)\n          g (fn g [s]\n              (when s\n                (cons (first s)\n                      (if (seq (rest s))\n                        (if (= (- (second s) (first s)) 1)\n                          (g (rest s)))))))\n          r (g s)]\n      (cons ((juxt first last) r)\n            (f (drop (count r) s))))\n    []))","problem":"171","user":"523ed522e4b057c4b7cd0a78"},{"problem":"171","code":"(fn interval [xs]\n  (let [[f & rst :as xs] (sort (set xs))\n        add-number (fn [[[l r :as i] & rst] x]\n                     (if (= (inc r) x)\n                       (apply list [l x] rst)\n                       (apply list [x x] i rst)))]\n    (if (empty? xs)\n      []\n      (reverse (reduce add-number [[f f]] rst)))))","user":"52d00832e4b07d0d72b273b4"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs)\n    []\n    (letfn [(extract-ivl [i j xs]\n              (if (contains? xs (inc j))\n                (extract-ivl i (inc j) xs)\n                [[i j] (first (drop-while #(<= % j) xs))]))]\n      (let [xs (apply sorted-set xs)]\n        (loop [i (apply min xs)\n               ivls []]\n          (let [[ivl nexti] (extract-ivl i i xs)]\n            (if (nil? nexti)\n              (conj ivls ivl)\n              (recur nexti (conj ivls ivl)))))))))","user":"5283a919e4b0239c8a67adbe"},{"problem":"171","code":"(fn [c]\n  (let [sc (sort c)]\n    (reduce (fn [r v]\n              (if (and (peek r) (or (= (peek (peek r)) v) (= (inc (peek (peek r))) v)))\n                  (conj (pop r) (conj (pop (peek r)) v))\n                  (conj r [v v]))) [] sc)))","user":"57d0cd58e4b0bd073c20235e"},{"code":"#(remove #{[nil nil]}\n   (let [[x & s] (distinct (sort %))]\n     (reverse  (reduce (fn [[[s e] & r :as a] n]\n                         (if (= n (inc e)) (conj r [s n]) (conj a [n n])))\n                       [[x x]] s))))","problem":"171","user":"519ef784e4b087743fad2198"},{"code":"(fn intervals [s]\n  (reduce (fn [memo e]\n            (let [memo (if (empty? memo) [[e e]] memo)\n                  [l h] (nth memo (dec (count memo)))]\n              (cond\n               (= e h) memo\n               (= e (inc h)) (assoc-in memo [(dec (count memo)) 1] e)\n               :else (conj memo [e e]))))\n          [] (distinct (sort s))))","problem":"171","user":"5032b066e4b00c0952a257ea"},{"problem":"171","code":"(fn [coll] (->> coll\n                (distinct)\n                (sort)\n                (map-indexed list)\n                (partition-by (fn [[i v]] (- v i)))\n                (map (juxt (comp second first) (comp second last)))))","user":"5960a1a6e4b066ee0a44b08e"},{"code":"(fn [v]\n  (reduce #(if (or (empty? %1) (not= (inc (last (last %1))) %2))\n             (conj %1 [%2 %2])\n             (conj (vec (drop-last %1)) (vector (first (last %1)) %2)))\n          [] (sort (distinct v))))","problem":"171","user":"51780f88e4b03d69594194c9"},{"code":"(fn [s]\n  (loop [s (sort (set s))\n         o []]\n    (if (seq s)\n      (let [run? (fn [x]\n                   (= x (range (first x) (inc (last x)))))\n            r (last (filter identity (map #(if (run? (take (inc %) s)) %) (range (count s)))))]\n        (recur (drop (inc r) s) (conj o [(first s) (nth s r)])))\n      o)))","problem":"171","user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":"171","code":"(fn intervals' [xs]\n  (->> xs\n       sort\n       distinct\n       (reduce (fn [acc item]\n                 (if (or (empty? acc)\n                         (> (Math/abs (- (first (first acc)) item)) 1))\n                   (cons [item] acc)\n                   (cons (cons item (first acc)) (rest acc)))) [])\n       (map (fn [grp] [(apply min grp) (apply max grp)]))\n       reverse))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn [xs]\n  (if-let [s (seq (sort xs))]\n    (loop [res [], start (first s), more (next s), end start]\n      (if-let [nxt (first more)]\n        (cond\n          (= nxt end)       (recur res start (next more) end)\n          (= 1 (- nxt end)) (recur res start (next more) nxt)\n          :else             (recur (conj res [start end]) nxt (next more) nxt))\n        (conj res [start end])))\n    []))","problem":"171","user":"51d19c24e4b0cfcf579466c3"},{"problem":"171","code":"(fn [xs]\n     (let [sorted-xs (sort xs)]\n       (loop [ys sorted-xs\n              result []\n              interval nil]\n         (let [[yhead & ytail] ys\n               [interval-head interval-tail] interval]\n         (cond (empty? ys) (if (nil? interval) result (conj result interval))\n               (nil? interval) (recur ytail result [yhead yhead])\n               (< (- yhead interval-tail) 2) (recur ytail result [interval-head yhead])\n               :else (recur ytail (conj result interval) [yhead yhead]))))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"#(map vector (% %2 inc) (% %2 dec))\n#(remove (set (map %2 %)) (set (sort %)))","problem":"171","user":"4e823ed7535db62dc21a62c7"},{"code":"(fn [s]\n    (->> s\n      sort\n      (reductions (fn [[p g] v] (vector v (if (or (= p (dec v)) (= p v)) g v))) [nil nil])\n      rest\n      (partition-by second)\n      (map (partial map first))\n      (map (juxt first last))))","problem":"171","user":"525f51bde4b0cb4875a45dc8"},{"problem":"171","code":"(fn [& l] \n  (->> l \n       (apply distinct)\n       sort\n       (map-indexed vector) \n       (partition-by #(- (first %)(second %)))\n       (map #(do [(last(first %))(last(last %))]))\n       ))","user":"5951190be4b066ee0a44aea4"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs) \n    []\n    (let [s (set xs)\n          min (apply min s)\n          max (apply max s)]\n      (->> (partition-by #(contains? s %) (range min (inc max)))\n        (take-nth 2)\n        (map #(vector (first %)(last %)))))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn intervals [col]\n  (if (empty? col) []\n  (let [c (distinct (sort col))]\n    (loop [rem (rest c) g [(first c)] int []]\n      (let [l (last g)\n\t          n (first rem)]\n\t      (cond\n\t        (empty? rem) (conj int [(first g) (last g)])\n\t        (= (inc l) n) (recur (rest rem) (conj g n) int)\n\t        :else (recur (rest rem) [n] (conj int [(first g) (last g)]))))))))","problem":"171","user":"5003deb9e4b0678c553fc445"},{"code":"(let [take-run (fn [s]\n  (loop [x (first s) y (rest s)]\n    (if (or (empty? y) (not= (first y) (inc x))) [[(first s) x] y]\n      (recur (inc x) (rest y)))))]\n(fn f [v]\n  (cond\n    (empty? v) []\n    :else (let [\n            s (sort (set v))\n            [t u] (take-run s)] (cons t (f u)))))\n)","problem":"171","user":"503917a0e4b088a6a14ca763"},{"code":"#(map vector (% %2 dec) (% %2 inc))\n  \n#(reduce (fn [a b] (if ((set %) (%2 b)) a (conj a b))) [] (sort (set %)))","problem":"171","user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn [xs]\n  (if (empty? xs)\n    []\n    (let [xs (-> xs sort distinct)\n          [x & xs] xs\n          ranges (reduce\n        \t\t   (fn [[acc [start end]] n]\n\t      \t\t     (if (= end (dec n))\n\t                   [acc [start n]]\n\t                   [(conj acc [start end]) [n n]]))\n\t               [[] [x x]]\n                   xs)]\n      (conj (first ranges) (second ranges)))))","problem":"171","user":"4fce5474e4b0d4b2a7a9d451"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs)\n    []\n    (let [xs-sorted (sort xs)]\n      (loop [xs (rest xs-sorted) start (first xs-sorted) end (first xs-sorted) ys []]\n        (if (empty? xs)\n          (conj ys [start end])\n          (let [x (first xs)]\n            (if (<= start x (inc end))\n              (recur (rest xs) start (max x end) ys)\n              (recur (rest xs) x x (conj ys [start end])))))))))","user":"58b81490e4b0ebc645576d8c"},{"problem":"171","code":"(fn [s]\n  (reduce\n    (fn [res e]\n      (let [res (if (empty? res) [[e e]] res)\n            [l h] (nth res (dec (count res)))]\n        (cond\n          (= h e) res\n          (= (inc h) e) (assoc res (dec (count res)) [l e])\n          :else (conj res [e e]))))\n    [] (distinct (sort s))))","user":"574c5e18e4b02ea11479921b"},{"problem":"171","code":"(fn [xs]\n     (let [sorted-xs (sort xs)\n           interval? (fn [a b] (if (or (= a b) (= a (dec b))) true false))\n           start-xs (cons (first sorted-xs) (map #(if (interval? %1 %2) nil %2) sorted-xs (rest sorted-xs)))\n           end-xs (concat (map #(if (interval? %1 %2) nil %1) sorted-xs (rest sorted-xs)) [(last sorted-xs)])]\n       (->> (keep identity (interleave start-xs end-xs))\n            (partition 2))))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":"171","code":"(fn i\n    ([v]\n     (if (empty? v)\n       v\n       (let [sv (sort v)]\n         (i (rest (distinct sv)) (conj [] (first sv)) []))))\n    ([sv tv ov]\n     (if (empty? sv)\n       (for [nv (conj ov tv)]\n         (if (= (count nv) 1)\n           (apply vector (concat nv nv))\n           (conj [] (first nv) (last nv))))\n       (if (= (first sv) (inc (last tv)))\n         (recur (rest sv) (conj tv (first sv)) ov)\n         (recur (rest sv) [(first sv)] (conj ov tv))))))","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":"171","code":"(fn [s]\n  (reduce (fn [v n]\n              (let [[l u] (last v)\n                    a (inc n)\n                    b (dec n)]\n                (cond\n                 (or (= l n) (= l a)) (assoc v (dec (count v)) [n u])\n                 (or (= u n) (= u b)) (assoc v (dec (count v)) [l n])\n                 :else (conj v [n n])))) [] (sort s)))","user":"53c1b787e4b00fb29b221266"},{"code":"(fn [xs] \n  (let [sorted-xs (sort (set xs))\n        pairs (partition 2 1 [] sorted-xs)]\n    (reduce \n      (fn [acc [begin end]]\n        (cond (empty? acc)\n                [[begin (or end begin)]]\n              (= (inc begin) end)\n                (let [next (first (peek acc))]\n                  (conj (pop acc) [next end]))\n              (nil? end)\n                acc\n              :else\n                (conj acc [end (or end begin)])))\n      []\n      pairs)))","problem":"171","user":"4db1b3951254ad5b4805fa6f"},{"problem":"171","code":"(fn check [x] \n  (let [s (into #{} x)\n        pair (fn [x] (map #(vector %1 %2) (take-nth 2 x) (take-nth 2 (rest x))))]\n   (->>\n     s\n     (sort)\n     (map #(vector % (contains? s (dec %)) (contains? s (inc %))))\n     (filter (fn [[_ a b]] (not (and a b))))\n     (mapcat (fn [[a b c]](if (not (or b c)) [a a] [a])))\n     (pair)\n     \n     )   \n    \n  \n  ))","user":"57011eb3e4b08d47c97781d1"},{"problem":"171","code":"(fn [coll-orig]\n  (if (empty? coll-orig) []\n    (let [coll (sort coll-orig)]\n      (reduce\n       (fn [inters x]\n         (let [[a b] (last inters)]\n           (if (> x (inc b))\n             (concat inters [[x x]])\n             (concat (butlast inters) [[a x]]))))\n       [[(first coll) (first coll)]] \n       coll))))","user":"53065acbe4b02e8216869792"},{"problem":"171","code":"(fn [int-coll]\n  (if (empty? int-coll)\n      []\n      (->> int-coll\n           (apply max)\n           (inc)\n           (range)\n           (map (set int-coll))\n           (partition-by nil?)\n           (remove #(every? nil? %))\n           (map (juxt first last)))))","user":"567695c2e4b05957ce8c6157"},{"code":"(fn [coll]\n  (let [\n    take-while-inc-1 (fn take-while-inc-1 \n                     ([coll] (take-while-inc-1 (first coll) (rest coll)))\n                     ([fst coll]\n                       (if (and (seq coll) (= (+ fst 1) (first coll)))\n                         (cons fst (take-while-inc-1 coll))\n                         (list fst))))\n    partition-inc-1 (fn partition-inc-1 [coll]\n                    (when-let [s (seq coll)]\n                      (let [run (take-while-inc-1 s)]\n                        (cons run (partition-inc-1 (drop (count run) s))))))]\n    (map \n      (fn [x] [(first x) (last x)])\n      (partition-inc-1 (apply sorted-set coll)))))","problem":"171","user":"4e6e2ac4535d5021c1a895ff"},{"code":"(fn [x]\n  (mapv #(vector (first %) (last %)) \n        (partition-by #(- % (.indexOf (distinct (sort x)) %)) (sort x))))","problem":"171","user":"529b44afe4b02ebb4ef7509d"},{"code":"#(reduce \n(fn [xs a]\n  (if (empty? xs) \n      [[a a]]\n    (let [x (-> xs last last)]\n      (cond\n        \t(= (inc x) a) (concat (butlast xs) [[ (-> xs last first) a]])\n        \t(=  x a) xs\n    \t  \t:else (concat xs [[ a a ]]) ))))\n[] (sort %))","problem":"171","user":"4fdd27f3e4b05e33b9224f78"},{"problem":"171","code":"(fn [v]\n  (let [rf (fn [vs n]\n             (let [last-vec (last vs)\n                   last-num (last last-vec)\n                   vs (pop vs)]\n               (if (empty? last-vec)\n                 (conj vs [n])\n                 (if (= (inc last-num) n)\n                   (conj vs (conj last-vec n))\n                   (conj vs last-vec [n])))))\n        v (vec (sort (distinct v)))]\n    (if (empty? v) []\n      (map #(vector (first %) (last %))\n           (reduce rf [[]] v)))))","user":"56ff45e5e4b08d47c97781bb"},{"problem":"171","code":"(fn f [coll] \n\t(->> (sort coll)\n\t     (reduce \n\t             (fn [xs x] \n\t                 (cond (nil? (last xs)) (conj (vec (drop-last xs)) [x])\n\t                       (or (= (last (last xs)) x) (= (inc (last (last xs))) x)) (conj (vec (drop-last xs)) (conj (last xs) x))\n\t                       :else (conj xs [x x])))\n\t             [])\n\t     (map (fn [x] (if (> (count x) 1) [(first x) (last x)] x)))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [x]\n  (loop [src (sort x) temp [] result []]\n    (cond (empty? src) (if (empty? temp) result (conj result [(first temp) (last temp)]))\n          (empty? temp) (recur (rest src) (conj temp (first src)) result)\n          (< (inc (last temp)) (first src)) (recur (rest src) [(first src)] (conj result [(first temp) (last temp)]))\n          :else (recur (rest src) (conj temp (first src)) result))))","problem":"171","user":"507fbd77e4b089ade05efbd3"},{"code":"#(map vector (% %2 dec) (% %2 inc))\n#(reduce (fn [a b] (if ((set %) (%2 b)) a (conj a b))) [] (sort (set %)))","problem":"171","user":"4ef49c2c535dced4c769f238"},{"problem":"171","code":"(fn intervals [coll]\n    (loop [to-check (sort (distinct coll)), checked []]\n        (if (empty? to-check) (reverse (map (juxt first last) checked))\n            (let [interval (remove nil? (map #(if (= %1 %2) %1 nil)\n                                             (drop-while #(< % (first to-check)) (range))\n                                             to-check))]\n                (recur (drop (count interval) to-check)\n                       (cons interval checked))))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":"171","code":"(fn [s]\n    (if (empty? s)\n        []\n        (let [ss (sort s)]\n             (loop [c_s (first ss)\n                    c_e c_s\n                    xs (rest ss)\n                    intervals []]\n                   (if (empty? xs)\n                       (conj intervals [c_s c_e])\n                       (if (= (first xs) c_e)\n                           (recur c_s c_e (rest xs) intervals)\n                           (if (= (first xs) (+ c_e 1))\n                               (recur c_s (first xs) (rest xs) intervals)\n                               (recur (first xs) (first xs) (rest xs) (conj intervals [c_s c_e])))))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":"171","code":"(fn [v]\n  (if (empty? v) []\n      (reduce (fn [acc v]\n                (let [finished (vec (butlast acc))\n                      current (last acc)\n                      l (last current)]\n                  (println \"v\" v \"f\" finished \"c\" current \"l\" l)\n                  (cond\n                    (nil? l) (conj finished [v v])\n                    (= l v) (conj finished current)\n                    (= (+ l 1) v) (conj finished (conj [(first current)] v))\n                    :else (conj (conj finished current) [v v]))))\n              [[]] (sort v))))","user":"537e745ae4b06839e8705ea6"},{"problem":"171","code":"(fn [v]\n    (if (empty? v) v\n  (loop [o [] r (first (sort v)) i (partition-all 2 1 (sort (set v)))]\n      (if (= 1 (count i)) (conj o [r (ffirst i)])\n          (let [[[f s] & i] i]\n              (if (>= (inc f) s) (recur o r i) (recur (conj o [r f]) s i)))\n          ))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":"171","code":"(fn [sq]\n  (if (empty? sq) []\n    (let [sortedseq (sort sq)]\n      (loop [s sortedseq, acc [], low (first sortedseq), current (first sortedseq)]\n        ;(println s acc low current)\n        (if (empty? s) (conj acc [low current])\n          (cond \n              (<= (first s) (inc current)) \n                  (recur (rest s) \t  acc \t\t\t\tlow \t\t(first s)) ; next in current group \n              (> (first s) (inc current)) \n                  (recur (rest s) (conj acc [low current]) (first s) (first s) ); gap!\n))))))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":"171","code":"#(->>\n\t(sort %)\n\t(reduce (fn [c x] (let [l (last c) f (vec (butlast c)) y (dec x)] (cond (= l x) c (= l y) (conj f x) :else (into c [x x])))) [])\n\t(partition 2)\n\t(map vec)\n\t(vec)\n)","user":"580c8fcee4b0849f6811b721"},{"problem":"171","code":"(fn [s]\n    (if (empty? s) []\n    (loop [xs (sort s), lo nil, hi nil, acc []]\n        ;(println \"loop\" xs lo hi acc)\n        (if (empty? xs) (conj acc [lo hi])\n            (let [x (first xs)] \n                (cond (nil? lo) (recur (rest xs) x x acc)\n                      (= x hi)  (recur (rest xs) lo hi acc)\n                      (= x (inc hi)) (recur (rest xs) lo x acc)\n                      :else (recur (rest xs) x x (conj acc [lo hi])) ))))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":"171","code":"(fn [s]\n   (letfn [(takew [s] (if (empty? s) []\n                                     (let [[a s] (partition-by (fn [[x y]] (= x y)) (map (fn [x y] [x y]) (distinct (sort-by num s)) (range (apply min s) (inc (apply max s)))))]\n                                       (concat [(map first a)] (takew (map first s))))))]\n     (map (fn [i] [(first i) (last i)]) (remove empty? (takew s)))))","user":"5d764e52e4b02e6b30c93524"},{"problem":"171","code":"(fn [sq]\n  (reduce (fn [col item]\n            (let [lv (last col)\n                  f (last lv)]\n              (if (or (nil? lv) (> (dec item) f)) (conj col [item item])\n                  (assoc-in col [(dec (count col)) 1] item))))\n          [] (sort sq)))","user":"52fc34cee4b047fd55837015"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    coll\n    (map #(vector (first %) (last %)) (loop [s (rest (sort coll)) cinterval [(first (sort coll))] intervals []]\n                                        (cond\n                                          (empty? s) (conj intervals cinterval)\n                                          (some #{(last cinterval)}  [(first s) (dec (first s))])\n                                          (recur (rest s) (conj cinterval (first s)) intervals)\n\n                                          :else\n                                          (recur (rest s) [(first s)] (conj intervals cinterval)))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":"171","code":"(fn [orig] \n  (if (empty? orig) []\n  (let [sorted    (sort orig)\n                 sorted_s  (set sorted)\n                 cover     (range (first sorted) (inc (last sorted)))\n                 parts_all (partition-by #(contains? sorted_s %) cover)\n                 parts     (filter #(every? (partial contains? sorted_s) %) parts_all)\n                 ]\n            \n                (map #(vector (first %)  (last %)) parts)\n             \n        )))","user":"564127a9e4b08d4f616f5ef3"},{"code":"#(->> % distinct sort\n  (reduce\n    (fn [[[l h] & im] x]\n      (if (= x (+ 1 h))\n        (cons [l x] im)\n        (list* [x x] [l h] im)))\n    [[0 -1]])\n  reverse\n  rest)","problem":"171","user":"4db858d1535d1e037afb218c"},{"code":"(fn [v]\n  (if (empty? v) v\n    (letfn [(h [lo hi result v]\n              (cond (empty? v) (concat result [[lo hi]])\n                    (= (first v) hi) (h lo hi result (rest v))\n                    (= (first v) (inc hi)) (h lo (inc hi) result (rest v))\n                    :else (h (first v) (first v) (concat result [[lo hi]]) (rest v))))]\n      (let [v (sort v)]\n        (h (first v) (first v) [] (rest v))))))","problem":"171","user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":"171","code":"(fn intervals [xs]\n  (if (not (seq xs))\n    []\n    (let [x (distinct (sort xs))\n          fst (first x)\n          [rng rst] (split-with (fn [[a b]] (= a b))\n                                (map vector x (iterate inc fst)))\n          rst (map first rst)\n          from (first (first rng))\n          to   (first (last  rng))]\n      (cons [from to] (intervals rst)))))","user":"4f35b2ace4b0e243712b1ec5"},{"problem":"171","code":"(fn [l]\n   (reverse (reduce #(if (nil? first)\n                       (conj %1 [%2 %2])\n                       (if (or (= %2 (second (first %1))) (= (dec %2) (second (first %1))))\n                         (conj (rest %1) [(first (first %1)) %2])\n                         (conj %1 [%2 %2]))) '() (sort l))))","user":"5f3f2281e4b004f08c61c561"},{"problem":"171","code":"(fn [xs]\n  (letfn [(f [acc v] \n            (if (and (not-empty acc) (< (Math/abs (- (ffirst acc) v)) 2))\n              (cons (cons v (first acc)) (rest acc))\n              (cons [v] acc)))]\n    (sort-by first (map #(vector (apply min %) (apply max %)) \n                        (reduce f [] (sort xs))))))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn [l]\n  (let [next-seq (fn [l]\n                   (let [c (count (first (partition-by identity (map - l (range)))))\n                         s (take c l)]\n                     [[(first s)(last s)] (drop c l)]))\n        s (fn s [l]\n            (if (empty? l)\n              ()\n              (let [[f r] (next-seq l)]\n                (cons f (s r)))))]\n    (s (distinct (sort l)))))","problem":"171","user":"50a83315e4b054305ba5a830"},{"problem":"171","code":"(fn t171 [coll]\n  (let [c (distinct (sort coll))\n        answer (concat [(first c)]\n                       (flatten (filter #(not= (- (second %) (first %)) 1) (partition 2 1 c)))\n                       [(last c)])]\n    (if (empty? coll)\n      []\n      (partition 2 2 answer))))","user":"5046f909e4b03b02161376b5"},{"problem":"171","code":"(fn [random-vector] (let [ordered-vect (distinct (sort random-vector))\n                           separatored (if (empty? ordered-vect) [] (partition-by nil? (map (fn [a] (if (contains? (set ordered-vect ) a) a)) (range (first ordered-vect) (inc (last ordered-vect))))))\n                           ]\n\n                       (filter (complement nil?) (map (fn [a] (if (not= (first a) nil) [(first a) (last a)])) separatored))\n\n                       ))","user":"5b7ed20fe4b047b03b203760"},{"problem":"171","code":"(fn into-intervals [sq]\n  (letfn [(split-into-ranges [sq] \n            (reduce (fn [intervals num]\n                      (let [last-interval (last intervals)]\n                        (if (seq last-interval)\n                          (let [last-num (last last-interval)]\n                            (if (= (inc last-num) num)\n                              (conj (subvec intervals 0 (dec (count intervals))) (conj last-interval num))\n                              (conj intervals [num])))\n                          [[num]])))          \n                    []\n                    (distinct (sort sq))))]\n    (let [ranges (split-into-ranges sq)]\n      (mapv (juxt first last) ranges)))\n  )","user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn intervals\n  [l]\n  (if (empty? l) l\n    (let [sorted (sort l)]\n      (loop [current-l (rest sorted) result [] current-beginning (first sorted) current-end current-beginning]\n        (if (empty? current-l) \n          (conj result [current-beginning current-end])\n          (let [next-num (first current-l)]\n            (if (or (= next-num current-end) (= next-num (inc current-end)))\n              (recur (rest current-l) result current-beginning next-num)\n              (recur (rest current-l) (conj result [current-beginning current-end]) next-num next-num))))))))","problem":"171","user":"4dad76588e77d6ed63f12a44"},{"problem":"171","code":"(fn [x]\n     (reduce \n             (fn [acc v]\n                 (if (empty? acc) [[v v]]\n                     (let [[i j] (last acc)]\n                          (if (= v (inc j))\n                              (conj (pop acc) [i v])\n                              (conj acc [v v])))\n                 )) \n             []\n             (apply sorted-set x)))","user":"559c13c5e4b066d22e731f61"},{"problem":"171","code":"(fn [s]\n  (loop [coll (sort s) r [] cur [(first coll) (first coll)]]\n     (cond \n       (empty? s) []\n       (empty? coll) (conj r cur)\n       (or (<= (first coll) (inc (second cur)))) (recur (rest coll) r [(first cur) (first coll)])    \n       :else (recur (rest coll) (conj r cur) [(first coll) (first coll)])    \n     )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn intervals [nums]\n    (if (empty? nums)\n        nums\n        (let [sorted (distinct (sort nums))]\n            (loop [res []\n                   todo (rest sorted)\n                   current-interval [(first sorted) (first sorted)]]\n               (if (empty? todo)\n                  (conj res current-interval)\n                  (if (= (inc (second current-interval)) (first todo))\n                    (recur\n                        res\n                        (rest todo)\n                        [(first current-interval) (first todo)])\n                    (recur\n                        (conj res current-interval)\n                        (rest todo)\n                        [(first todo) (first todo)])))))))","problem":"171","user":"5165a235e4b079ad97ec44ac"},{"problem":"171","code":"(fn c-inter\n  [l]\n  (->> l\n       sort\n       (reduce (fn [r i]\n                 (if (or (empty? r)\n                         (and (not= i (+ 1 (last (last r))))\n                              (not= i (last (last r)))))\n                   (conj r [i i])\n                   (conj (pop r) [(first (last r)) i])))\n               [])))","user":"5125029de4b0ce9225d2ed3e"},{"problem":"171","code":"(fn intervals [input]\n   (loop [result [], queue (->> input distinct sort), buffer []]\n     (cond\n       (empty? queue) (if (empty? buffer) result (conj result buffer))\n       (= (second buffer) (dec (first queue))) (recur result\n                                                      (rest queue)\n                                                      [(first buffer) (first queue)])\n       \n       :else (recur (if (empty? buffer) result (conj result buffer))\n                    (rest queue)\n                    (repeat 2 (first queue))))))","user":"58247423e4b051871117bec5"},{"problem":"171","code":"(fn [xs]\n    (let [groups (partition-by\n                  second\n                  (rest\n                   (reductions (fn [[i sn] j] (if (<= j (inc i)) [j sn] [j (inc sn)]))\n                               [Integer/MAX_VALUE 0]\n                               (sort xs))))]\n      (for [g groups] [(ffirst g) (first (last g))])))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn [s]\n  (->> s\n    set\n    sort\n    (reduce (fn [r v]\n              (let [[start end] (last r)]\n                (if (= end (dec v))\n                  (conj (vec (drop-last r)) [start v])\n                  (conj r [v v]))))\n            [])))","problem":"171","user":"4f969a66e4b0dcca54ed6cde"},{"problem":"171","code":"(letfn [(consecutive? [a b]\n          (if (and a b (>= 1 (Math/abs (- a b))))\n            true\n            false))]\n  (fn intervals\n    [coll]\n    (let [coll (sort coll)]\n      (if (= 1 (count coll))\n        [[(first coll) (first coll)]]\n        (if-let [front (first coll)]\n          (loop [a (first coll) \n                 b (second coll)\n                 coll (rest coll)]\n            (if (consecutive? a b)\n              (recur b (second coll) (rest coll))\n              (cons [front a] (intervals coll))))\n          [])))))","user":"55ed1575e4b0121d4835fdd3"},{"problem":"171","code":"(fn [x] \n  (reduce \n    #(if (or (empty? %1) (> %2 (inc (last (last %))))) \n       (concat % [[%2 %2]]) \n       (if \n         (= %2 (last (last %))) \n         % \n         (concat (butlast %) \n               (vector (vector \n                  (first (last %)) \n                  (inc (last (last %)))))))) \n    [] (sort < x)))","user":"53fc8424e4b0de5c418485b3"},{"problem":"171","code":"(fn intervals [coll]\n  (letfn [(breaks [c]\n            (->> c\n                 (partition 2 1)\n                 (filter (comp (partial not= -1) (partial apply -)))\n                 flatten))]\n    (if (= [] coll)\n      []\n      (->> coll\n           sort\n           distinct\n           ((juxt first breaks last))\n           concat\n           flatten\n           (partition 2 2)))))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn [s]\n  (if (empty? s)\n    []\n    (let [ss (sort s)]\n      (partition 2\n       (concat [(first ss)]\n  \t           (flatten (filter #(> -1 (apply - %)) (partition 2 1 ss)))\n               [(last ss)])))))","problem":"171","user":"509160dae4b0742c82730aef"},{"problem":"171","code":"(fn [xs]\n  (loop [xxs (-> xs\n                 sort\n                 distinct)\n         l nil\n         current []\n         out []]\n    (if-let [x (first xxs)]\n      (let [[c o] (if\n                      (or (nil? l)\n                          (= (inc l) x))\n                    [(conj current x)\n                     out]\n                    [[x]\n                     (conj out [(first current)\n                                (last current)])])]\n        (recur\n         (rest xxs)\n         x\n         c\n         o))\n      (if (seq current)\n        (conj out [(first current)\n                   (last current)])\n        out))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [arr]\n(let [ cx (atom {:val 0 :tag 0})\n       -swap (fn[k v] (swap! cx assoc k v))\n       partfn  (fn[i]\n                  (let [ c (:val @cx) ]\n                    (cond\n                      (= i c) (:tag @cx)\n                      (= i (inc c)) (do (-swap :val i) (:tag @cx))\n                      :else (do (-swap :val i) (-swap :tag i) (:tag @cx)))))\n        min-max (fn[a] [ (apply min a) (apply max a) ] )]\n  (map min-max (partition-by partfn (sort arr)))))","problem":"171","user":"50b25f2ce4b03ea88043355f"},{"problem":"171","code":"(fn [coll]\n  (->> (map list (sort (set coll)) (range))\n       (partition-by (partial apply -))\n       (map (juxt ffirst (comp first last)))))","user":"554b8572e4b0a04f79299589"},{"problem":"171","code":"(fn intervals [xs]\n  (let [make-interval (fn [{:keys [rest intervals]}]\n                        (let [interval (->> (cons (-> rest first dec) rest)\n                                            (partition 2 1)\n                                            (take-while (fn [[a b]]\n                                                          (= 1 (- b a))))\n                                            (map second))\n                              ending (last interval)]\n                          {:intervals (into intervals [[(first interval) ending]])\n                           :rest      (->> rest\n                                           (drop-while #(>= ending %)))}))]\n    (if (seq xs)\n      (->> (iterate make-interval {:rest      (sort (set xs))\n                                   :intervals []})\n           (drop 1)\n           (drop-while #(-> % :rest seq))\n           first\n           :intervals)\n      [])))","user":"561d8936e4b064ca9f4b16b2"},{"code":"#(let [[a & b] (sort (distinct %))]\n   \t(if (nil? a) []\n    (->> (reduce (fn [[c & d :as cd] e]\n                   (if (= 1 (- e c))\n                     (cons e d)\n                     (into cd [e e])))\n                 (list a a)\n                 b)\n         reverse\n         (partition 2))))","problem":"171","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn iv [y]\n   (if (empty? y)\n     '()\n     ((fn [x]\n        (let [\n              [a & rest] x\n              b (+\n                 a\n                 (count\n                  (take-while\n                   true?\n                   (map\n                    #(= (nth rest %1) (+ (inc a) %1))\n                    (range (count rest))\n                    )\n                   )\n                  )\n                 )\n              ]\n          (cons [a b] (iv (drop (inc (- b a)) x)))\n          )\n        )\n      (-> y sort distinct)\n      )\n     )\n  )","problem":"171","user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn [s]\n   (map #(vector (second (first %)) (second (last %)))\n        (partition-by #(first %) (map-indexed #(vector (- %2 %1) %2) (set s)))))","problem":"171","user":"5125745ae4b05d10e3e395f9"},{"problem":"171","code":"(fn [xs]\n  (let [xs (vec (sort xs))\n        x? (set xs)\n        lil (first xs)\n        big (last xs)\n        rng (if lil (range lil (inc big)) [])]\n    (reduce (fn [result x]\n              (if (x? x)\n                (if (= (dec x) (last (last result)))\n                  (assoc-in result [(dec (count result)) 1] x)\n                  (conj result [x x]))\n                result))\n            []\n            rng)))","user":"4f5599dfe4b0a7574ea71806"},{"problem":"171","code":"(fn myf [coll]\n    (->> (reduce #(cond (= (dec %2) (last (last %1)))\n                        (conj (vec (drop-last %1)) (conj (last %1) %2))\n                        (= %2 (last (last %1)))\n                        %1\n                        :else\n                        (conj %1 (vector %2))) [] (sort coll))\n      (map #(vector (first %) (last %)))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":"171","code":"(fn f [s]\n    (if (empty? s)\n      '()\n      (let [s (sort (set s))\n            m (first s)]\n        (loop [s (rest s) v m]\n          (if (empty? s)\n            (list [m v])\n            (if (= (inc v) (first s))\n              (recur (rest s) (inc v))\n              (conj (f s) [m v])))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [s]\r\n  (if-not (empty? s)\r\n    (let [[h & t] (reverse (sort (distinct s)))]\r\n      (reduce\r\n        (fn [[[mn mx] & r :as a] e]\r\n          (if (= e (dec mn))\r\n            (cons [e mx] r)\r\n            (cons [e e] a)))\r\n        [[h h]]\r\n        t))\r\n    []))","problem":"171","user":"504e14c2e4b078edc5f593bf"},{"code":"(fn f [s]\n  (if (= s []) []\n    (let [a first b last m map c cons\n          s (sort s)\n          i (m list s \n              (c 0 (m #(- (b %) (a %)) \n                (partition 2 1 [0] s))))\n          [x y] (split-with #(< (nth % 1) 2) i)\n          r [(a (a x)) (a (b x))]]\n      (c r (f (m a y))))))","problem":"171","user":"4e96557d535dbda64a6f6b43"},{"problem":"171","code":"(fn intervals [col]\n  (if (empty? col) []\n    (let [scol (sort (set col))]\n      (reduce \n        #(if (<= %2 (inc (last (last %1))))\n          (conj (vec (butlast %1)) [(first (last %1)) %2])\n          (conj %1 [%2 %2]))\n        [[(first scol) (first scol)]] \n        scol))))","user":"55536a8ae4b0deb715856e03"},{"problem":"171","code":"#(reduce\n  (fn [intervals newVal]\n    (if-let [[s e] (last intervals)]\n      (cond\n       (= newVal e) intervals\n       (= (inc e) newVal) (conj (vec (drop-last intervals)) [s newVal])\n       :else (conj intervals [newVal newVal]))\n      (conj () [newVal newVal])))\n  [] (sort %))","user":"556c70dae4b09a3098a524fd"},{"problem":"171","code":"(fn [s] (first (reduce (fn [[a f l] x]\n                             (cond\n                               (empty? a) [[[x x]] x x]\n                               (= x l) [a f l]\n                               (= x (inc l)) [(assoc a (dec (count a)) [f x]) f x]\n                               :else [(conj a [x x]) x x]))\n                           [[] 0 0]\n                           (sort s))))","user":"51e28063e4b08e53a149f0f2"},{"problem":"171","code":"(fn intervals [xs]\n  (let [runs (fn [f x]\n               (->> (map f x (rest x))\n                    (reductions = true)\n                    (map vector x)\n                    (partition-by second)\n                    (map #(map first %))))]\n    (->> xs\n         (sort)\n         (runs #(< (- %2 %1) 2))\n         (map (juxt first last)))))","user":"5fa416ece4b0f0ebd91b7803"},{"code":"(fn [xs]\n  (reduce (fn [r e] \n            (loop [i 0]\n              (cond\n               (>= i (count r)) (conj r (vector e e))\n               (= (get-in r  [i 0]) e) r\n               (= (get-in r  [i 1]) e) r\n               (= (dec (get-in r [i 0])) e) (assoc-in r [i 0] e)\n               (= (inc (get-in r [i 1])) e) (assoc-in r [i 1] e)\n               :else (recur (inc i)))))\n          [] (into [] (sort xs))))","problem":"171","user":"5370f8ede4b0fc7073fd6ea2"},{"code":"(fn intervals \n  ([ls] (intervals (sort ls) '()))\n  ([ls acc]\n     (letfn [(adjacent? [ls num]\n               (not (empty? (filter #(or (= num %) (= (inc num) %) (= (dec num) %)) ls))))\n             (add-to-list [ls num]\n               (if (empty? ls) \n                 [[num]]\n                 (let [newls (map #(if (adjacent? % num)\n                                     (conj % num)\n                                     %)\n                                  ls)\n                       same? (= ls newls)]\n                   (if same?\n                     (conj ls [num])\n                     newls))))\n             ]\n       (if (empty? ls) \n         (->> acc\n              (map #(list (first %) (last %)))\n              (into #{})\n              (sort #(< (first %1) (first %2))))\n         (intervals (rest ls) (add-to-list acc (first ls)))))))","problem":"171","user":"5301157ae4b0d8b024fd3717"},{"code":"(fn [c]\n   (if (empty? c) c                                                                                                                             \n       (let [s (sort c)]\n         (reduce #(if (<= %2 (inc (last (last %)))) (conj (pop %) [(first (last %)) %2])\n                      (conj % [%2 %2])) [[(first s) (first s)]] s))))","problem":"171","user":"50996a38e4b0cae2931060b3"},{"code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [sorted (sort coll)\n          [fst & all] sorted]\n      (loop [[curr & rst] all\n             prev fst\n             inter [fst]\n             res []]\n        (if curr\n          (if (or (= curr (inc prev)) (= curr prev))\n            (recur rst curr inter res)\n            (recur rst curr [curr] (conj res (conj inter prev))))\n          (conj res (conj inter prev)))))))","problem":"171","user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn [xs]\n (let [ys (map-indexed (fn [i e] [i e]) (distinct (sort xs)))\n       r (partition-by (fn [[i e]] (- e i)) ys)\n       s (map (fn [a] (map last a)) r)]\n   (map (fn [a] [(first a) (last a)]) s)))","problem":"171","user":"5097b556e4b00ad8bab4e970"},{"problem":"171","code":"(fn [s]\n  (reduce (fn to-intervals\n            [i s]\n            (let [[a b] (last i)]\n              (cond\n                (and a  (= b (- s 1))) (conj (vec (butlast i)) [a (inc b)])\n                :else (conj i [s s])))) [] (distinct (sort s))))","user":"583048d9e4b051871117c007"},{"problem":"171","code":"(fn [xs]\n  (let [xs (sort (distinct xs))]\n    (map #(vector (first %) (last %)) \n      (loop [[a & n] xs current[] result []]\n        (if (nil? a)\n          (if (empty? current) result (conj result current))\n          (if (= (inc a) (first n))\n            (recur n (conj current a) result)\n            (recur n [] (conj result (conj current a)))))))))","user":"559b55d6e4b066d22e731f54"},{"problem":"171","code":"(fn [l]\n\t(if (empty? l) []\n\t\t(let [s (sort l)]\n\t\t\t(reduce\n\t\t\t\t(fn [res el]\n\t\t\t\t\t(let [[a b] (last res)]\n\t\t\t\t\t\t(cond (= b el) res\n\t\t\t\t\t\t\t  (= (inc b) el) (concat (drop-last res) [[a el]])\n\t\t\t\t\t\t\t  :else  (concat res [[el el]])\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t[[(first s) (first s)]]\n\t\t\t(rest s))\n\t\t)\n\t)\n)","user":"5626447fe4b00e49c7cb47bd"},{"problem":"171","code":"(fn [coll]\n  (->> coll\n    (distinct)\n    (sort)\n    (vec)\n    ; Add the first and last elements to both ends of the collection\n    ((fn [x] (when-not (empty? x)\n               (cons (first x) (conj x (last x))))))\n    (partition 2 1)\n    (filter (fn [[a b]] (not= a (dec b))))\n    (partition 2 1)\n    (map (fn [[[_ a] [b _]]] [a b]))))","user":"53a074a4e4b0ca733b9744af"},{"code":"(fn a [col] (let [s (flatten(let [c (into #{}(sort col))] (keep #(when(c %)(if(and(not(c (inc %)))(not(c (dec %))))(repeat 2 %)(when(or(not(c (inc %)))(not(c (dec %)))) %))) c)))] (loop [s s out []] (if(empty? s)(identity out)(recur (nnext s)(conj out [(first s) (second s)]))))))","problem":"171","user":"527a8eb7e4b03e8d9a4a755f"},{"problem":"171","code":"(comp sort set (fn [x] (map #(let [f (fn f [n g] \n                                       (if ((set x) (g n)) \n                                         (f (g n) g) \n                                         n))]\n                               [(f % dec) (f % inc)]) \n                            x)))","user":"52b02329e4b0c58976d9acc5"},{"code":"(fn cnt-interval [v]\n  (letfn [(take-head [lst]\n            (loop [ret [] from lst]\n              (if-let [head (first from)]\n                (if (empty? ret)\n                  (recur [head head] (rest from))\n                  (if (or (= head (last ret))\n                          (= head (inc (last ret))))\n                    (recur (vector (first ret) head) (rest from))\n                    [ret from]))\n                [ret []])))]\n    (loop [ret [] lst (sort v)]\n      (if (empty? lst)\n        ret\n        (let [[head left] (take-head lst)]\n          (recur (conj ret head) left))))))","problem":"171","user":"4eec82fe535d93acb0a668ae"},{"problem":"171","code":"(fn [coll]\n  (reverse \n   (let [sorted-coll (seq (apply sorted-set coll))]\n     (reduce (fn [res-coll i]\n               (if (empty? res-coll)\n                 (conj res-coll [i i])\n                 (let [start (first (first res-coll))\n                       end (second (first res-coll))]\n                   (if (= (inc end) i)\n                     (conj (rest res-coll) [start i])\n                     (conj res-coll [i i])))))\n             []\n             sorted-coll))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":"171","code":"(fn [xs] (sort (reduce \n  (fn [rs x]\n    (let [ij (first (for [[a b] rs :when (and (<= a x) (<= x b))] [a b]))\n          lj (first (for [[a b] rs :when (= x (dec a))] [a b]))\n          rj (first (for [[a b] rs :when (= x (inc b))] [a b]))]\n      (cond (not (nil? ij)) rs\n            (and (nil? rj) (nil? lj)) (conj rs [x x])\n            (nil? rj) (conj (remove #(= % lj) rs) [x (second lj)])\n            (nil? lj) (conj (remove #(= % rj) rs) [(first rj) x])\n            :else (conj (remove #(or (= % lj) (= % rj)) rs) [(first rj) (second lj)]))))\n  [] xs)))","user":"5e2549c8e4b05b4b0151615f"},{"problem":"171","code":"(fn [s]\n  (loop [r [] s (sort (distinct s)) t []]\n    (if (empty? s)\n      (if (empty? t)\n        r\n        (conj r t))\n      (cond\n        (empty? t)\n        (recur r (rest s) [(first s) (first s)])\n        (= (inc (last t)) (first s))\n        (recur r (rest s) [(first t) (first s)])\n        :default\n        (recur (conj r t) (rest s) [(first s) (first s)])))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"#(loop [s (distinct (sort %))\n          a []]\n     (if-let [[f & _] (seq s)]\n       (if-not (peek a)\n         (recur (next s) [[f f]])\n         (let [[n m] (peek a)]\n           (if (= m (dec f))\n             (recur (next s) (conj (pop a) [n f]))\n             (recur (next s) (conj a [f f])))))\n       a))","problem":"171","user":"4ef9c8f9535dced4c769f26b"},{"code":"#(letfn \n   [(r [[a s l] n]\n       (cond \n        (nil? s) [a n n]\n        (> n (inc l)) [(conj a [s l]) n n]\n        :else [a s n]))]\n   (let \n     [[a s l] (reduce r [[] nil 0] (sort %))]\n     (if (nil? s)\n       a\n       (conj a [s l]))))","problem":"171","user":"4e03c616535d04ed9115e796"},{"problem":"171","code":"#(->> %\n      (cons -99)\n      (cons +99)\n      sort\n      distinct\n      (partition 2 1)\n      (filter (fn [[a b]] (< a (- b 1))))\n      (apply concat)\n      next\n      butlast\n      (partition 2))","user":"4db85bdd535d1e037afb218d"},{"problem":"171","code":"(fn myfn                                                                       \n  [coll]                                                                         \n  (let [normed-coll (sort (distinct coll))                                       \n        reducer-to-seqs (fn [acc next-val]                                       \n                          (let [current-interval (last acc)                      \n                                current-val (last current-interval)]             \n                            (if (and current-val (= (inc current-val) next-val)) \n                              (concat (butlast acc) [(concat current-interval [next-val])])\n                              (concat acc [[next-val]]))))                       \n        intervals (reduce reducer-to-seqs [] normed-coll)                        \n        intervalise (fn [coll] [(first coll) (last coll)])]                      \n    (map intervalise intervals)))","user":"58ebd10de4b056aecfd47d49"},{"problem":"171","code":"(fn [c]\n  (let [[m :as c] (sort c)]\n    (loop [[x & xs] c i [m m] acc []]\n      (if x\n        (if (> x (inc (i 1)))\n          (recur xs [x x] (conj acc i))\n          (recur xs (assoc i 1 x) acc))\n        (if m (conj acc i) c)))))","user":"514d8084e4b019235f6c0588"},{"problem":"171","code":"(fn [n]\n  (->> n\n       sort\n       (reduce #(let [[ls le] (last %)]\n                 (if (and (not (nil? le)) (<= le %2 (inc le)) )\n                   (conj (vec (butlast %)) (vector ls %2))\n                   (conj % (vector %2 %2)))) [])))","user":"56bb652ae4b0f26550335953"},{"code":"(fn intervals [l]\n  (let [s (sort > l)\n        f (fn [ll x]\n            (if (>= x (dec (first (first ll))))\n              (cons (list x (second (first ll))) (rest ll))\n              (cons (list x x) ll)))]\n    (if (empty? l)\n      []\n      (reduce f (list (list (first s) (first s))) (rest s)))))","problem":"171","user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [coll]\n        (let [add-to-end (fn [v el]\n                           (let [[a b] (last v)]\n                             (if (and b (= 1 (- el b)))\n                               (concat (butlast v) [[a el]])\n                               (concat v [[el el]]))))]\n          (->> coll sort distinct (reduce add-to-end []))))","problem":"171","user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn [xs]\n  (letfn [(runs [xs]\n\t\t(loop [prev nil rs [] r [] xs xs]\n\t\t  (if (empty? xs)\n\t\t    (if (empty? r) rs (conj rs r))\n\t\t    (let [x (first xs)]\n\t\t      (if (and prev (< (- x prev) 2))\n\t\t\t(recur x rs (conj r x) (rest xs))\n\t\t\t(recur x (if (empty? r) rs (conj rs r)) [x] (rest xs)))))))]\n    (map (fn [r] [(first r) (last r)]) (runs (sort xs)))))","problem":"171","user":"4e513ecf535dc968683fc4f6"},{"problem":"171","code":"(fn [s]\n  (if (empty? s) []\n    (loop [c (sort s) st (first c) prev (first c) out []]\n     (if (empty? c)\n       (conj out [st prev])\n       (if (not (or (= (first c) prev) (= (first c) (inc prev))))\n        (recur (rest c) (first c) (first c) (conj out [st prev]))\n        (recur (rest c) st (first c) out)\n        )))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":"171","code":"(fn [xs]\n    (if (empty? xs)\n      []\n      (let [sort-xs (apply sorted-set xs)]\n        (loop [acc []\n               v-st (first sort-xs)\n               v-end (first sort-xs)\n               ys (next sort-xs)]\n          (cond\n           (empty? ys) (conj acc [v-st v-end])\n           (= 1 (- (first ys) v-end)) (recur acc v-st (first ys) (next ys))\n           :else (recur (conj acc [v-st v-end]) (first ys) (first ys) (next ys)))))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":"171","code":"(fn [i]\n    (loop [vec-out [] imax 0 [x & xs] (-> i distinct sort)]\n      (cond (nil? x) (partition 2 (conj vec-out imax))\n            (empty? vec-out) (recur [x] x xs)\n            (= (inc imax) x) (recur vec-out (inc imax) xs)\n            (< (inc imax) x) (recur (conj vec-out imax x) x xs)))\n    )","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [l]\n   (if-not (seq l)\n     []\n     (let [sorted (distinct (sort l))]\n       (loop [s sorted, ret [], a (first s), b a]\n         (if (seq s)\n           (if (> (first s) (inc b))\n             (recur (rest s)\n                    (conj ret [a b])\n                    (first s)\n                    (first s))\n             (recur (rest s)\n                    ret\n                    a\n                    (first s)))\n           (conj ret [a b]))))))","problem":"171","user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn intv [s]\n  (if (empty? s) []\n    (let [ss (sort (distinct s))\n          sss (cons (dec (first ss)) (butlast ss))\n          vss (map vector ss sss)\n          eq1 #(= 1 (reduce - %))\n          gbd (fn gb [x r]\n                (if (empty? x) r\n                  (let [f (cons (first x) (take-while eq1 (rest x)))]\n                    (gb (drop-while eq1 (rest x)) (conj r f)))))\n          grp (map (fn [x] (map first x)) (gbd vss []))]\n      (map vector (map first grp) (map last grp)))))","problem":"171","user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [nums]\n  (loop [num-set (set nums)\n         result []]\n    (if (empty? num-set)\n      result\n      (let [[new-num-set interval] (loop [a (first num-set)\n             b (first num-set)\n             reduced-set (disj num-set a)]\n        (cond\n         (contains? num-set (dec a))\n          (recur (dec a) b (disj reduced-set (dec a)))\n         (contains? num-set (inc b))\n          (recur a (inc b) (disj reduced-set (inc b)))\n         :else\n          [reduced-set [a b]]))]\n        (recur new-num-set (conj result interval))))))","problem":"171","user":"51899891e4b0288ada3dbdab"},{"problem":"171","code":"(fn collect-points [i]\n  (letfn [(find-set [sets-of-conn-points point]\n                    (first (filter #(contains? % point) sets-of-conn-points)))\n          (add-point [sets-of-conn-points point]\n                     (if (find-set sets-of-conn-points point) sets-of-conn-points\n                       (let [l (find-set sets-of-conn-points (dec point))\n                             h (find-set sets-of-conn-points (inc point))]\n                         (cond\n                          (= nil l h) (conj sets-of-conn-points #{point})\n                          (nil? l) (conj (disj sets-of-conn-points h) (conj h point))\n                          (nil? h) (conj (disj sets-of-conn-points l) (conj l point))\n                          :else (conj (disj sets-of-conn-points l h) (conj (clojure.set/union l h) point))))))]\n  (sort-by first\n           (map #(vector (apply min %) (apply max %))\n                (reduce add-point #{} i)))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":"171","code":"(fn [coll]\n  (let [conjit #(conj %2 %1)\n        sorted (sort coll)\n        gap? (fn [[a b]] (< a (inc a) b))]\n    (->>\n     sorted\n     (partition 2 1)\n     (filter gap?)\n     flatten\n     (cons (first sorted))\n     vec\n     (conjit (last sorted))\n     (remove nil?)\n     (partition 2)\n     )))","user":"52dc7344e4b09f7907dd13cf"},{"problem":"171","code":"#(apply map vector (for [o [dec inc]] (remove (comp (set %) o) (sort (set %)))))","user":"4ff82b00e4b0678c553fc395"},{"problem":"171","code":"(fn [coll]\n    (if (seq coll)\n      (let [minval (apply min coll)\n          maxval (apply max coll)\n          collset (into #{} coll)\n          in-coll (fn [e] (contains? collset e))]\n        (->> (range minval (inc maxval))\n             (partition-by #(in-coll %))\n             (map (fn [elem] (filter #(in-coll %) elem)))\n             (filter (complement empty?))\n             (map (fn [c] (cond\n                            (= 1 (count c)) [(first c) (first c)]\n                            (< 2 (count c)) [(first c) (last c)]\n                            :else c)))))\n      []))","user":"560e9a2de4b05f002753df52"},{"problem":"171","code":"(fn [s]\n   (if-not (seq s)\n     []\n     (loop [s (sort s), a (first s), b (first s), res []]\n       (println res)\n       (if-not (seq s)\n         (conj res [a b])\n         (if (> (first s) (inc b))\n           (recur (rest s) (first s) (first s) (conj res [a b]))\n           (recur (rest s)     a     (first s)       res      ))))))","user":"5b000332e4b0cc2b61a3bd36"},{"problem":"171","code":"(fn [s]\n      (let [ss (sort s)]\n           (loop [x ss, a[], min (first ss), max (first ss)]\n                 (let [c (first x)]\n                      (if (empty? x) (if (nil? min) a (conj a [min max]))\n                                     (let [nx (> c (inc max))]\n                                          (recur (rest x)\n                                                 (if (true? nx) (conj a [min max]) a)\n                                                 (if (true? nx) c min)\n                                                 c\n                                                 )\n                                          )\n                                     )\n                      )\n                 )\n           )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn [c]\n  (->> (set c) sort\n    (mapcat #(do [((set c) (dec %)) %]))\n    (partition-by nil?)\n    (remove (comp nil? first))\n    (map #(do [(first %) (last %)]))))","problem":"171","user":"4f410b63e4b0e243712b1fc5"},{"problem":"171","code":"(fn [x] (reduce #(let [[a b] (last %)]\n                   (cond\n                    (or (nil? a) (> %2 (inc b))) (conj % [%2 %2])\n                    (= b %2) %\n                    1 (conj (pop %) [a %2]))) [] (sort x)))","user":"50548ce8e4b0b1b9d1860ead"},{"problem":"171","code":"(letfn [(interval [x] [(first x) (last x)])\n        (partition-by-gap [r n] (if (> n (-> r last last inc)) \n                                  (conj r [n]) \n                                  (update-in r [(dec (count r))] conj n) ))]\n\t(fn [v]\n\t  (if (empty? v)\n        []\n\t    (into [] (map interval (reduce partition-by-gap [[(first (sort v))]] (rest (sort v))))))))","user":"56d63729e4b0ea9b8538f7ca"},{"code":"(fn [a]\n  (let [a (sort (distinct a))]\n    (loop [result []\n           start (first a)\n           end (first a)\n           a (rest a)]\n      (if (nil? start)\n        result\n        (let [n (first a)]\n          (if (= n (inc end))\n            (recur result start n (rest a))\n            (recur (conj result [start end]) n n (rest a))))))))","problem":"171","user":"4fde492be4b05e33b9224f8a"},{"code":"(fn intervals [s]\n  (let [\n        mark-intervals (fn [s1]\n                         (loop [s2 (rest s1), result [(first s1)]]\n                           (if (empty? s2)\n                             result\n                             (let [f (first s2)]\n                               (if (= f (inc (last result)))\n                                 (recur (rest s2) (conj result f))\n                                 (recur (rest s2) (conj result :b f))\n                                 )\n                               ))\n                           ))\n        create-intervals (fn [s]\n                           (loop [s1 s, result []]\n                             (if (empty? s1)\n                               result\n                               (let [ins (first s1)\n                                     f (first ins)\n                                     l (last ins)]\n                                 (recur (rest s1) (conj result [f l]))\n                                 ))))\n        s1 (-> s sort distinct)\n        s2 (mark-intervals s1)\n        s3 (partition-by keyword? s2)\n        s4 (filter #(number? (first %)) s3)\n        s5 (create-intervals s4)]\n    s5))","problem":"171","user":"52cf084ce4b07d0d72b27399"},{"problem":"171","code":"(fn [xs]\n   (reduce (fn [xs x]\n             (let [lst (last xs)]\n               (if (nil? lst ) (conj xs [ x x])\n                   (let [lst-lst (last lst)]\n                     (cond\n                       (= (inc lst-lst) x) (conj (vec (butlast xs)) [(first lst) x])\n                       (= lst-lst x) xs\n                       :else (conj (vec  xs) [x x])\n                       ))))) [] (sort xs)))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"(fn intrs' [xs]\n  (letfn [(nbr? [x, a]\n                (and\n                 (>= a (dec (first x)))\n                 (<= a (inc (second x)))))\n          (can-merge? [a, b]\n                      (or\n                       (nbr? a (first b))\n                       (nbr? a (second b))))\n          (merge-int [a, b]\n                     [(min (first a) (first b)) (max (second a) (second b))])\n          (merge-it [xs]\n                    (reduce\n                     (fn [acc, intr]\n                       (if (some #(can-merge? % intr) acc)\n                         (map #(if (can-merge? % intr) (merge-int % intr) %) acc)\n                         (conj acc intr)))\n                     []\n                     xs))\n          (fix [f, x]\n               (loop [x x]\n                 (let [y (f x)]\n                   (if (= x y)\n                     x\n                     (recur y)))))]\n    (sort\n     (fn [x, y] (compare (first x) (first y)))\n     (fix merge-it (map vector xs xs)))))","problem":"171","user":"51365524e4b04ac1f358dd52"},{"problem":"171","code":"(fn __ [is]\n  (if (empty? is) []\n      (let [sis (sort is)]\n        (reverse\n         (map #(vector (first %) (last %))\n              (reduce (fn [[a & d :as r] e]\n                        (let [e0 (last a)]\n                          (cond\n                           (= e0 e) r\n                           (= (inc e0) e) (cons (conj a e) d)\n                           :else (cons [e] r))))\n                      (list [(first sis)]) (rest sis)))))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":"171","code":"(fn  [colls]\n  (let [xs (sort colls)]\n    (reduce\n     (fn [acc x]\n       (if\n         (empty? acc) [[x x]]\n         (loop [i 0]\n           (if (>= i (count acc)) (conj acc [x x])\n             (let [[a b] (nth acc i)]\n               (cond \n                (<= a x b) acc\n                (= x (inc b)) (assoc acc i [a x])\n                (= x (dec a)) (assoc acc i [x b])\n                :else (recur (inc i))))))))\n\n     [] xs)))","user":"5794fd7be4b0e215f87e8476"},{"code":"#(reduce\n  (fn [m a]\n    (if (or (empty? m) (not= (inc (last (last m))) a))\n      (concat m [[a a]])\n      (concat (butlast m) [[(first (last m)) a]])))\n    [] (sort (set %)))","problem":"171","user":"4ebc08a8535dfed6da9c6d7c"},{"problem":"171","code":"(fn [xs] (let [xs (sort > xs)] \n           (->> (map list xs (cons (first xs) xs))              \t\n                (reduce (fn [acc [f s]] (if (<= -1 (- f s))\n                                          (cons (conj (first acc) f) (rest acc))\n                                          (conj acc (list f)))) () )\n                (map #(vector (first %) (last %)))\n              )))","user":"6011b89ee4b074f607df66bc"},{"problem":"171","code":"(fn [xs]\n  (let [[intervals tmp] (reduce (fn [[acc tmp] x]\n                                  (cond\n                                    (= tmp []) [acc [x]]\n                                    (= (dec x) (last tmp)) [acc [(first tmp) x]]\n                                    (= 1 (count tmp)) [(conj acc (vec (concat tmp tmp))) [x]]    \n                                    :else [(conj acc tmp) [x]]))\n                                [[] []] \n                                (sort (distinct xs)))\n        tmp' (case (count tmp)\n               0 []\n               1 [(vec (concat tmp tmp))]\n               [tmp])]\n    (vec (concat intervals tmp'))))","user":"554bd33ce4b0a04f7929959a"},{"problem":"171","code":"(fn intervals [nums]\n  (if-let [sorted (-> nums sort not-empty)]\n    (->> sorted\n         (partition 2 1)\n         (reduce (fn [coll [a b]]\n                   (if (>= 1 (Math/abs (- a b)))\n                     (conj (pop coll) [(first (peek coll)) b])\n                     (conj coll [b b])))\n                 [[(first sorted) (first sorted)]]))\n    []))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [x]\n  (let [n (-> x distinct sort)\n        s (filter (fn [b] (not (or \n              \t\t\t\t(some #{(dec b)} n)\n                        \t(some #{(inc b)} n)))) n)\n        r (filter (fn [b] (or \n              \t\t\t\t(some #{(dec b)} n)\n                        \t(some #{(inc b)} n))) n)\n        ranges (filter (fn [b] (not (and \n              \t\t\t\t(some #{(dec b)} r)\n                        \t(some #{(inc b)} r)))) r)]\n    (sort (apply hash-map (concat ranges (interleave s s))))))","problem":"171","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn intervals [xs] \n  ((fn aux [start end [h & t :as xs]]\n      (cond\n       (nil? h)        (if end [[start end]] [])\n       (nil? start)    (aux h h t)\n       (= end h)       (aux start end t)\n       (= end (dec h)) (aux start h t)\n       :else (cons [start end]\n                   (lazy-seq\n                    (aux h h t)))))\n   nil nil (sort xs)))","problem":"171","user":"52d2ca1ce4b099d49816f0b4"},{"problem":"171","code":"(fn intervals [coll]\n  (let [interval (fn []\n                   (fn [rf]\n                     (let [a  (java.util.ArrayList.)\n                           pv (atom ::none)]\n                       (fn\n                         ([] (rf))\n                         ([result]\n                          (let [result (if (.isEmpty a)\n                                         result\n                                         (let [v (vec (.toArray a))]\n                                           (.clear a)\n                                           (rf result v)))]\n                            result));; the same as longest inc subsequence (conj result) do not pass: clojure.lang.ArityException: Wrong number of args (1) passed to: core$conj\n                         ([result input]\n                          (let [before @pv]\n                            (reset! pv input)\n                            (if (or (= before input) (= before (dec input)))\n                              (do\n                                (.add a input)\n                                result)\n                              (do\n                                (let [v (vec (.toArray a))]\n                                  (.clear a)\n                                  (.add a input)\n                                  (if (not-empty v) ;;\n                                    (rf result v)\n                                    result))))))))))\n        xform     (interval)\n        fun      (xform conj)]\n    (map (fn [x] [(first x) (last x)])\n         (fun (reduce fun [] (sort coll))))))","user":"552bd5c2e4b0ffed3738f969"},{"problem":"171","code":"(fn [s]\n  (let [news (distinct (sort s))]\n    (if (empty? news) '()\n    (loop [n (rest news) mi (first news) ma (first news) res []]\n      (cond (empty? n) (conj res (vector mi ma))\n            (= (first n) (inc ma))\n            (recur (rest n) mi (first n) res)\n            :else\n            (recur (rest n) (first n) (first n) (conj res (vector mi ma))))))))","user":"60264d89e4b0d5df2af2222d"},{"code":"(fn [a]\n  (if (empty? a)\n    a\n    (map #(vector (first %) (last %)) \n         (loop [col (sort (distinct a)) \n                tmp []\n                acc []\n                lst (dec (first col))]\n           (if-not (empty? col)\n             (recur (rest col) \n                    (if (= 1 (- (first col) lst))\n                      (conj tmp (first col))\n                      [(first col)])\n                    (if (= 1 (- (first col) lst))\n                      acc\n                      (conj acc tmp))\n                    (first col))\n             (conj acc tmp))))))","problem":"171","user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn [data ]\n   (if (= data [])\n     []\n    (let [model (partition-all 2 1(sort (distinct data)))\n          jumps (filter (fn [i](not= (inc (first i)) (last i)))model)\n          ]\n       (vec (map vec (partition 2 (conj  (vec (cons (ffirst model) (vec (flatten jumps)))) (last (last model)))))))))","problem":"171","user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn aa [x]\n  (if (= x []) []\n    \n  (map \n   #(cond \n     (= (count %) 1) (repeat 2 (first %))\n     :else [(first %) (last %)]\n     ) \n  \t(loop [x1 (rest (sort x)) y [] z [(first (sort x))]]\n     (if (empty? x1)\n         (conj y z)\n\t\t(if (or (= (first x1) (last z)) (= (first x1) (inc (last z))))\n           (recur (rest x1) y (conj z (first x1))) \n           (recur (rest x1) (conj y z) [(first x1)])\n          )\n       )\n     ))\n  \t)\n  )","problem":"171","user":"5105ed16e4b01150e115ebe2"},{"code":"(fn [coll]\n  (reduce\n   (fn [result val]\n     (if (empty? result)\n       [[val val]]\n       (let [interval (last result)\n             seen (last interval)]\n         (if (= val (inc seen))\n           (conj (vec (butlast result))\n                 [(first interval) val])\n           (conj result [val val])))))           \n       []\n   (sort (set coll))))","problem":"171","user":"5014754de4b094324338f8e5"},{"problem":"171","code":"(fn [xs]\n         (if (empty? xs) xs (map (fn [x] [(first x) (last x)])\n          (distinct\n           (partition-by\n            (let [n (atom (dec (first xs)))\n                  g (atom 0)]\n              (fn [x]\n                (let [prev @n]\n                  (if (zero? (- (reset! n x) prev 1))\n                    @g (swap! g inc)))))\n            (sort (distinct xs)))))))","user":"52d1e364e4b0d9f9285948e7"},{"problem":"171","code":"(fn [S]\n    (let [S (sort S)]\n      (println S)\n      (loop [Ret [] Index 0]\n        (if (>= Index (count S))\n          Ret\n          (let \n            [\n              CurItem (nth S Index)\n              LastGroup (last Ret)\n              ;;    ,   \n              LastGroup (if (= nil LastGroup) \n                [CurItem CurItem]\n                LastGroup\n              )\n              ;;      \n              Continues? (or\n                (= CurItem (last LastGroup))\n                (= (dec CurItem) (last LastGroup))\n              )\n            ]\n            ;;(println Ret)\n            ;;(println Index \"=\" CurItem \" Last=\" LastGroup \"?\" Continues?)\n            (recur            \n              ;;     ,   \n              (if Continues?\n                (conj (into [] (butlast Ret))\n                    (into [] (concat (butlast LastGroup) [CurItem]))\n                )\n                ;;  -  \n                (conj Ret [CurItem CurItem])                \n              )\n              ;;  \n              (inc Index)\n            )\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":"171","code":"(fn [seq]\n(let [\n\nfind-highest (fn [interval-map curr all-visited-set]\n\n(let [maps-to (interval-map curr) ]\n(if (= nil maps-to)\n[ curr #{curr}]\n(if (contains? interval-map maps-to)\n(recur interval-map maps-to (concat #{maps-to} all-visited-set))\n[ maps-to (set (concat #{maps-to} all-visited-set))]\n))))\n\nsorted-seq (sort (set seq))\ninterval-map (reduce (fn [accum val]\n(if (= (inc (first val)) (second val))\n(merge accum { (first val) (second val) })\n(merge accum { (second val) nil})\n\n))\n{} (map #( -> [%1 %2]) sorted-seq (concat (rest sorted-seq) nil)))\n\nresult (reduce (fn [accum val]\n(let [interval-list (first accum)\nreduce-visited-set (second accum)]\n(if (contains? reduce-visited-set val)\naccum\n\n(let [highest-result (find-highest interval-map val #{val})\ninterval-result [val (first highest-result)]\nvisited-set (second highest-result)\n]\n[(concat interval-list [interval-result])\n(set (concat visited-set reduce-visited-set)) ])))\n\n) [ [] #{} ] sorted-seq)\n]\n\n(first result)\n))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn [xs]\r\n  (if (= xs []) []\r\n      (reverse\r\n       (reduce\r\n        (fn [[[l h] & r :as a] v]\r\n          (if (= v (inc h))\r\n            (concat [[l v]] r)\r\n            (concat [[v v]] a)))\r\n       [[(apply min xs) (apply min xs)]]\r\n       (rest (distinct (sort xs)))))))","problem":"171","user":"4f1b92d1535d64f60314647b"},{"code":"(fn [s]\n  (let [s (sort s)]\n    (partition 2\n      (concat\n        (take 1 s)\n        (apply concat (filter #(< (apply - %) -1) (partition 2 1 s)))\n        (take-last 1 s)))))","problem":"171","user":"528652fbe4b0239c8a67ae14"},{"problem":"171","code":"(fn intervals [coll]\n  (if-let [s (seq (apply sorted-set coll))]\n    (let [start (first s)\n          cnt (count (take-while identity (map = (next s) (iterate inc (inc start)))))]\n      (cons [start (+ start cnt)] (intervals (drop (+ cnt 1) s))))\n    [])\n  )","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":"171","code":"(fn intervals [ls]\n   (letfn [(pred [[x prev]]\n             (or (nil? prev) (= x (inc prev))))\n           (take-incseq [[_ seq]]\n             (if (empty? seq)\n               nil\n               (list\n                (map first\n                     (take-while pred (map list seq (cons nil seq))))\n                (map first\n                     (drop-while pred (map list seq (cons nil seq)))))))\n           (to-interval [ls]\n             [(first ls) (last ls)])]\n     (let [sorted (sort ls)]\n       (map to-interval\n            (map first\n                 (drop 1\n                       (take-while identity\n                                   (iterate take-incseq (list () (distinct sorted))))))))))","user":"547584d9e4b0c51c1f4d729b"},{"code":"(fn myinterval                                                                      \n  [s]                                                                                 \n  (let [sorted (into #{} s)                                                           \n        succ? (fn [a b] (= (+ 1 a) b))]                                               \n    (loop [curr [] items sorted acc []]                                               \n      (if (empty? items)                                                              \n        (map #(list (first %) (last %)) (if (empty? curr) acc  (conj acc curr)) )     \n        (let [i (first items)                                                         \n              [new-curr, new-acc] (if (or (empty? curr)                               \n                                          (succ? (last curr) i))                      \n                                    [(conj curr i), acc]                              \n                                    [[i], (conj acc curr)])]                          \n          (recur new-curr (rest items) new-acc)                                       \n          ))                                                                          \n      )                                                                               \n    )                                                                                 \n  )","problem":"171","user":"50573ed8e4b0012181721987"},{"problem":"171","code":"(fn [s]\n    (->> (apply sorted-set s)\n         (reduce (fn [c x] (if ((fnil < 0) (last (last c)) (dec x)) (conj c [x])\n                                                                    (conj (vec (drop-last c)) (conj (vec (last c)) x)))) [])\n         (map #((juxt first last)%))\n         )\n\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"#(let [p partition\n       s (set %)\n       g (remove (fn [[a b]] (= (- b a) 1)) (p 2 1 s))]\n   (p 2 (flatten (if (seq %) [(first s) g (last s)]))))","problem":"171","user":"4f8345c6e4b033992c121c1b"},{"code":"(fn [l]\n  (let [b (sort l)\n        x (first b)]\n    (loop [r []\n           m x\n           n x\n           s (rest b)]\n      (if (empty? s)\n        (if (nil? n) r (conj r [m n]))\n        (let [a (first s) b (rest s)]\n          (if (>= (inc n) a)\n            (recur r m a b)\n            (recur (conj r [m n]) a a b)))))\n    ))","problem":"171","user":"53460d02e4b084c2834f4a39"},{"problem":"171","code":"(fn [x]\n(map #(vector (first %) (last %))  (filter #(not= :mid (first %)) (partition-by #(= % :mid)\n                (reduce \n                        #(if-let[y (last %1)]\n                                   (if (> (- %2 y) 1)(conj %1 :mid %2 )(conj %1 %2))\n                                   (conj %1 %2) ) \n                                 [] \n                                 (sort (distinct x))))) ))","user":"52bbd09ee4b07a9af57922ee"},{"problem":"171","code":"(fn [l]\n  (if (empty? l) '[]\n  (map #(vector (first %) (last %))\n  (reduce (fn [x v]\n            (if (or\n                 (nil? (last (last x)))\n                 (= (last (last x)) v)\n                 (= (inc (last (last x))) v))\n              (vec (concat (drop-last x) [(conj (last x) v)]))\n              (vec (concat x [[v]]))))\n          [[]] (sort l)))))","user":"4eb2eae5535d7eef30807351"},{"code":"(fn [s]\n  (if (empty? s) []\n    (apply conj\n      (let [[x & xs] (seq (set (sort s)))]\n        (reduce\n          (fn [[ivals [a b]] n]\n            (if (== n (inc b)) \n              [ivals [a n]]\n              [(conj ivals [a b]) [n n]]))\n          [[] [x x]]\n          xs)))))","problem":"171","user":"50901b2ee4b0ea685a20f774"},{"problem":"171","code":"#(vec (reduce (fn [a x](let [[k v] (last a)](if (and k (<= (dec x) v)) (assoc a k x) (assoc a x x)) )) (sorted-map) (sort %)))","user":"57e33f6fe4b0bfb2137f5a96"},{"problem":"171","code":"#(reduce (fn [is n] (let [[a b] (last is)]\n\t\t\t\t(if (and b (= n (inc b))) (concat (butlast is) [[a n]]) (concat is [[n n]])))) [] (distinct (sort %)))","user":"53e19461e4b0d874e779ae59"},{"code":"#(reduce (fn [acc x]\n           (let [i (dec (count acc))]\n             (if (and (>= i 0)\n                      (<= (- x (get-in acc [i 1])) 1))\n               (assoc-in acc [i 1] x)\n               (conj acc [x x]))))\n         []\n         (sort %))","problem":"171","user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn intervals [coll]\n  (if (empty? coll) coll\n\t(let [scoll (sort coll)]\n\t\t(loop [coll (rest scoll) inter (vector (first scoll)) res []]\n\t\t\t(let [fc (first coll) rc (rest coll) li (last inter) fi (first inter)]\n\t\t\t\t(cond (empty? coll) (conj res [fi li])\n\t\t\t\t\t  (or (= li fc) (= -1 (- li fc))) (recur rc (conj inter fc) res)\n\t\t\t\t\t  :else (recur rc (vector fc) (conj res [fi li]))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n\t)\n)","problem":"171","user":"50588af1e4b06522596eba7d"},{"code":"(fn intervals\n  ([l]\n   (let [[f & r] (distinct (sort l))]\n     (intervals f f r)))\n  ([s l [v & r]]\n   (cond\n    (nil? s) []\n    (= (inc l) v) (intervals s v r)\n    :else (cons [s l] (intervals v v r)))))","problem":"171","user":"519136e9e4b0f8ef0be96c01"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    coll\n    (let [extract (fn [coll] (map #(vector (first %) (last %)) (remove empty? coll)))]\n      (loop [ncoll (into #{} (sort coll))\n             splits (filter #(not (contains? ncoll %)) (range (first ncoll) (inc (last ncoll))))\n             result []]\n             (if (empty? splits)\n               (if (empty? ncoll)\n                 (extract result)\n                 (extract (conj result ncoll)))\n               (recur (drop-while #(< % (first splits)) ncoll)\n                      (rest splits)\n                      (conj result (take-while #(< % (first splits)) ncoll))))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":"171","code":"(fn [s] \n    (if-let [sorted-s (-> s distinct sort seq)]\n      (loop [acc [[(first sorted-s)]] \n             remaining (rest sorted-s)]\n          (if-let [current (first remaining)]\n            (if (= (-> acc last last inc) current)\n              (recur (conj (into [] (butlast acc)) (conj (last acc) current)) (rest remaining))\n              (recur (conj acc [current]) (rest remaining))\n            )\n            (into [] (map #((juxt first last) %) acc))\n          )\n        )\n        []       \n      )   \n  )","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":"171","code":"(fn [xs]\n   (letfn\n    [(upper-bounds [xs] ((group-by #(nil? ((set xs) (inc %))) xs) true))\n     (lower-bounds [xs] ((group-by #(nil? ((set xs) (dec %))) xs) true))\n     (zip [& colls]\n       (if (empty? (first colls)) []\n           (concat [(map first colls)]\n                   (apply zip (map rest colls)))))\n     (make-intervals [xs]\n       (let [vals (set xs)\n             top (sort (upper-bounds vals))\n             bot (sort (lower-bounds vals))]\n          (zip bot top)))]\n     (make-intervals xs)))","user":"5d4b2155e4b0776584bd6f28"},{"problem":"171","code":"(fn intervals [coll]\n  (letfn [\n    (join-int [xs i j]\n      (let [len (count xs)\n            l (dec len)]\n        (assoc xs\n               l (conj (last xs) i)\n               len [j])))\n    (split-inc [[xs i] j]\n      (if (= (inc i) j)\n        [xs j]\n        [(join-int xs i j) j]))]\n    (if (empty? coll)\n      coll\n      (let [xs (sort (set coll))\n            f (first xs)\n            init [[[f]] f]]\n        (->\n          (reduce split-inc init (rest xs))\n          (split-inc ,, -1)\n          (first)\n          (butlast))))))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [v] (->> v\n             distinct\n             sort\n             (map vector (range))\n             (partition-by #(apply - %))\n             (map flatten)\n             (map (juxt second last))))","problem":"171","user":"4fca2ef0e4b0ee37620e184e"},{"problem":"171","code":"(fn [xs]\n  (loop [sorted-xs (sort xs)\n         r []]\n    (if (empty? sorted-xs) r\n        (if (empty? r)\n          (recur (rest sorted-xs) (conj r [(first sorted-xs) (first sorted-xs)]))\n          (let [[b e] (last r)\n                h (first sorted-xs)]\n            (if (or (= h e)\n                    (= h (inc e)))\n              (recur (rest sorted-xs) (assoc r (dec (count r)) [b h]))\n              (recur (rest sorted-xs) (conj r [h h]))))))))","user":"5866b999e4b0f14aab7c886b"},{"problem":"171","code":"(fn [coll]\n    (let [sorted (into (sorted-set) coll)\n          promote (fn [a-seq]\n                   [(apply min a-seq)\n                    (apply max a-seq)])]\n      (loop [run []\n             promoted []\n             remaining sorted]\n        (cond\n          (not (seq remaining)) (if (seq run)\n                                  (conj promoted (promote run))\n                                  promoted)\n          (not (seq run)) (recur [(first remaining)] promoted (rest remaining))\n\n          (= 1 (- (first remaining) (last run)))\n          (recur (conj run (first remaining)) promoted (rest remaining))\n\n          :else\n          (recur [] (conj promoted (promote run)) remaining)))))","user":"53716539e4b0fc7073fd6eb1"},{"code":"#(into ()\n    (reduce\n      (fn [[[a b] & r :as s] e]\n        (if (= (dec e) b)\n            (% [a e] r)\n            (% [e e] s)))\n       ()\n       (sort (set %2)))) cons","problem":"171","user":"51ad244fe4b09397d510977f"},{"problem":"171","code":"(fn intervalFunc [seqOfInts]\n  (reduce (fn [agg i] (let [agg (if (empty? agg) [[i i]] agg)\n                            [low high] (nth agg (dec (count agg)))]\n                        (cond (= i high) agg\n                              (= i (inc high)) (assoc-in agg [(dec (count agg)) 1] i)\n                              :else (conj agg [i i]))))\n          [] (distinct (sort seqOfInts))))","user":"5e566668e4b027a2e10ac0f9"},{"problem":"171","code":"(fn [v] (let [\n               sorted (into [] (sort v))\n               size (count sorted)\n               pairs (range (min 0 (dec size)))\n               ]\n           (if (> size 0)\n             (loop [\n                    i 0\n                    switches []\n                    mark (nth sorted 0)\n                    ]\n               (let [\n                     last (dec size)\n                     j (min last (inc i))\n                     e0 (nth sorted i)\n                     e1 (nth sorted j)\n                     diff (- e1 e0)\n                     switch (> diff 1)\n                     next-switches (if switch (conj switches [mark e0]) switches)\n                     next-mark (if switch e1 mark)\n                     ]\n                 (if (= i last) (conj next-switches [mark e1])\n                                (recur j next-switches next-mark)))\n               ) []) )\n   )","user":"58a9e872e4b01a0c0b232973"},{"code":"(fn [c]\n  (letfn [(sub-seqs [col cur a]\n  (if (empty? col)\n    (if (empty? cur)\n      (reverse (map reverse a))\n      (reverse (map reverse (cons cur a))))\n    (let [nxt (first col)\n          rst (rest col)]\n      (if (empty? cur)\n        (sub-seqs rst [nxt] a)\n        (if (= (dec nxt) (first cur))\n          (sub-seqs rst (cons nxt cur) a)\n          (sub-seqs rst [nxt] (cons cur a))\n          )\n        ))\n    ))]\n    (let [s (sub-seqs (sort (distinct c)) [] [])]\n      (map (fn [l] [(apply min l) (apply max l)]) s))))","problem":"171","user":"4ffa8affe4b0678c553fc3bd"},{"problem":"171","code":"#(reduce\n         (fn [a e]\n           (let [[s f] (last a)]\n             (if (and f\n                      (<= (- e f) 1))\n               (conj (pop a) [s e])\n               (conj a [e e]))))\n         []\n         (sort %))","user":"53523ae0e4b084c2834f4aee"},{"problem":"171","code":"(fn [coll]\n  (let [coll (sort (set coll))]\n    (letfn [(collect [coll prev-element series]\n              (if (empty? coll) series\n                  (if (nil? prev-element)\n                    (collect (rest coll) (first coll) [[(first coll)]])\n                    (collect (rest coll) (first coll)\n                             (if (= (first coll) (inc prev-element))\n                               (conj (pop series) (conj (last series) (first coll)))\n                               (conj series [(first coll)]))))))]\n      (map (fn [x] [(apply min x) (apply max x)]) (collect coll nil [])))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":"171","code":"(fn [x]\n (->> (partition-all 2 1 (sort x))\n  (#(cons [(ffirst %)] %))\n  (remove (fn [[a b]] (and b (< (- b a) 2))))\n  flatten\n  (partition 2)))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn interval [xs]\n  (loop [result []\n         remaining (sort xs)]\n    (if (seq remaining)\n      (let [current (first remaining)\n            [start end] (peek result)]\n        (if (nil? start)\n          (recur [[current current]] (rest remaining))\n          (if (> current (inc end))\n            (recur (conj result [current current]) (rest remaining))\n            (recur (conj (pop result) [start current]) (rest remaining)))))\n      result)))","problem":"171","user":"5102ac9de4b00c483ae176fa"},{"code":"#(->> %\n      sort\n      ((fn i [[xf & xr :as s]]\n         (let [maxi (fn [n s]\n                      (if-let [[c & r] (seq s)]\n                        (if (>= (inc n) c) (recur c r) [n s])\n                        [n s]))        \n               [x r] (when-let [[s1 r1] (maxi xf xr)]\n                       [[xf s1] r1])]\n           (if (seq r)\n             (conj (i r) x)\n            (if (nil? (first x)) [] (list x)))))))","problem":"171","user":"4f05ea25535dcb61093f6c02"},{"problem":"171","code":"(fn intervals [coll]\n  (let [ordered-ints (distinct (sort coll))]\n    (loop [intervals []\n           cur-head (first ordered-ints)\n           [h & t] ordered-ints]\n      (cond\n        (empty? t) (if h (conj intervals [cur-head h]) intervals)\n        (not= 1 (- (first t) h)) (recur (conj intervals [cur-head h]) (first t) t)\n        :else (recur intervals cur-head t)))))","user":"5879d577e4b01531a375ead8"},{"problem":"171","code":"(fn intervals [int-seq]\n  (letfn [(accumulate-intervals [[[begin end] & rest :as all] int]\n           (if (= (dec int) end)\n             (conj rest [begin int])\n             (conj all [int int])))]\n    (reverse (reduce accumulate-intervals [] (apply sorted-set int-seq)))))","user":"58ed713de4b056aecfd47d84"},{"code":"#(loop [[x & xs] (sort %) y x acc (if x [x x] [])] (if x (recur xs x (if (< (- x y) 2) (conj (pop acc) x) (conj acc x x))) (partition 2 2 acc)))","problem":"171","user":"51bd1a0de4b0df1216cefd93"},{"code":"(fn __ [& args] \n  (letfn [(fn171 [acc numbers]\n                 (reduce add-number [] numbers))\n          (add-number [acc number]\n                      (if (seq acc)\n                        (let [[[lo hi] & rst] acc]\n                          (cond \n                             (== hi number) acc\n                             (== (inc hi) number) (cons [lo number] rst)\n                             :else (cons [number number] acc)\n                            )\n                          )\n                        [[number number]])\n                      )]\n    (reverse (fn171 [] (apply sort args))))\n  )","problem":"171","user":"4dca8b6d535d5973398f9288"},{"problem":"171","code":"(fn intervals [num-coll]\n  (let [intervals (reduce\n                   (fn [accum [interval-min :as new-interval]]\n                     (if (= (peek (peek accum)) (dec interval-min))\n              (update-in accum [(dec (count accum)) 1] inc)\n              (conj accum new-interval)))\n                   [[]]\n                   (mapv (fn [x] [x x])  (sort (distinct num-coll))))]\n    (condp = 1\n      (count intervals) []\n      1 (next intervals))))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn [coll]\r\n  (if (empty? coll)\r\n    []\r\n    (let [in (vec (partition 2 1 (sort coll)))]\r\n      (vec\r\n       (map #(vec %)\r\n      (partition 2\r\n\t\t       (flatten\r\n\t\t\t(conj\r\n\t\t\t []\r\n\t\t\t (first (first in))\r\n\t\t\t (reduce #(if (> (Math/abs (- (first %2) (second %2))) 1)\r\n\t\t\t\t    (conj %1 (first %2) (second %2))\r\n\t\t\t\t    %1)\r\n\t\t\t\t []\r\n\t\t\t\t in)\r\n\t\t\t (second (last in))))))))))","problem":"171","user":"504ec4d3e4b069badc5a33c9"},{"code":"(let\n    [grab\n     (fn [coll]\n       (when-let [s (seq coll)]\n         (let [\n               run (for [[x y] (map vector s (rest s)) :while (<= y (inc x))] y)\n              ]\n           (cons (first s) run))))\n     \n     grab-all\n     (fn grab-all [coll]\n       (if-let [s (seq coll)]\n         (let [\n               run (grab s)\n               ]\n           (cons [(first run) (last run)] (grab-all (drop (count run) s))))\n         []\n       ))]\n    (comp grab-all sort)\n )","problem":"171","user":"4f03154a535dcb61093f6a58"},{"code":"(fn intervals [v]\n  (let [in?             (fn [interval val] (<= (first interval) val (last interval)))\n        merge-value     (fn [intervals val]\n                             ;;(println intervals)\n                             (loop [ivals intervals acc []]\n                              (cond\n                               (empty? ivals) \n                                 (conj acc [val val])\n                               (in? (first ivals) val) \n                                 intervals\n                               (= (- ((first ivals) 0) val) 1) \n                                 (concat (conj acc [val ((first ivals) 1)]) (rest ivals))\n                               (= (- val ((first ivals) 1)) 1) \n                                 (concat (conj acc [((first ivals) 0) val]) (rest ivals))\n                               :else\n                                 (recur (rest ivals) (conj acc (first ivals)))\n                                 )   \n                               )\n                              ) \n          merge-intervals (fn [intervals]\n                            (loop [ivals (sort intervals) acc []]\n                              (if (and (seq (first ivals)) (seq (rest ivals)))\n                                (if (<= (- ((second ivals) 0) ((first ivals) 1)) 1)\n                                  (recur (into [[((first ivals) 0) ((second ivals) 1)]] (rest (rest ivals))) acc)\n                                  (recur (rest ivals) (conj acc (first ivals)))\n                                  )\n                                (if (seq (first ivals))\n                                  (conj acc (first ivals))\n                                  acc\n                                  )\n                                )\n                              )\n                            )\n        ]\n      (merge-intervals (reduce merge-value [] v))\n    )\n  )","problem":"171","user":"529a73bde4b02ebb4ef75096"},{"problem":"171","code":"(fn [s]\n  (loop [l (distinct (sort s)) acc []]\n    (if (empty? l)\n      (map #(list (first %) (last %))acc)\n      (let [x (reduce #(if (or (empty? %) (= (dec %2) (last %)))\n                         (conj % %2) %)\n                      []\n                      l)]\n        (recur (remove (set x) l) (conj acc x))))))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [start-coll]\n   (if (empty? start-coll)\n     []\n\t   (let [coll (set (sort start-coll))]\n\t\t   (loop [result [] last-element [(first coll) (first coll)] elements (next coll)]     \n\t\t     (if elements\n\t\t       (if (= (+ 1 (second last-element)) (first elements))\n\t\t         (recur result [(first last-element) (first elements)] (next elements))\n\t\t         (let [] (recur (conj result last-element) [(first elements) (first elements)] (next elements)))\n\t\t         )\n\t\t       (conj result last-element)\n\t\t       )     \n\t\t     )\n\t   )\n    )\n   )","problem":"171","user":"5106dc1be4b01150e115ebf0"},{"problem":"171","code":"(fn f\n  ([xs]\n   (if (seq xs)\n     (let [ys (sort (set xs))\n           y (first ys)]\n       (f (rest ys) y y))\n     ()))\n  ([xs start end]\n   (if (seq xs)\n     (let [x (first xs)]\n      (if (<= x (inc end))\n        (f (rest xs) start x)\n        (cons [start end] (f (rest xs) x x))))\n     (list [start end]))))","user":"5799ff45e4b05b1deef9add1"},{"problem":"171","code":"(fn [l]\n  (map #(vector (first (ffirst %)) (last (last (last %)))) (partition 1 2 (partition-by #(> 2 (- (last %) (first %))) (partition 2 1 (sort (into l l)))))))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":"171","code":"(fn __ [s]\n    (->>\n        (sort s)\n        (reduce\n            (fn [A b]\n                (let [ op (last A) ]\n                    (if (or (nil? op) (> (- b (last op)) 1))\n                        (conj A [b])\n                        (conj (subvec A 0 (dec (count A))) (conj op b)))))\n            [])\n        (map (fn [%] [(first %) (last %)]))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":"171","code":"#(drop 1 (reduce (fn [acc n]\n                (let [prev (into [] (drop-last acc)) \n                           cur (last acc)]\n                  (println acc)\n                     \n                  (if (or (= (last cur) (dec n)) (= (last cur) n))\n                      (conj prev [(first cur) n])\n                    (conj acc [n n]))))\n            [[-1 -1]]\n            (sort %)))","user":"576b4e6be4b0a07e8fc1812b"},{"code":"(fn [l]\n  (reduce\n    (fn [c n]\n      (let [[x y] (last c)]\n        (if (and x (<= n (inc y)))\n          (conj (pop c) [x n]) \n          (conj c [n n])) \n        ))\n    []\n    (-> l set sort)))","problem":"171","user":"4fbbcf0ce4b081705acca2ee"},{"problem":"171","code":"(fn [coll]\n  (->> coll\n       (sort)\n       (distinct)\n       (reduce (fn [acc n]\n                 (cond\n                  (empty? acc)\n                  [[n n]]\n\n                  (= n (inc (second (first acc))))\n                  (conj (rest acc) [(first (first acc)) n])\n\n                  :else\n                  (conj acc [n n]))) [])\n       (reverse)))","user":"52efd3d9e4b05e3f0be25ed4"},{"code":"(fn [s] (map (fn [[[x y] [k z]]] (if (> (- x y) 1) [z z] [y k])) (map (juxt first last) (filter #(> (count %) 1) (partition-by (fn [[x y]] (>= 1 (- x y))) (partition 2 (#(interleave (rest %) %) (sort (concat s (if (not (empty? s)) (repeat 2 (apply max s))))))))))))","problem":"171","user":"505d26aee4b0e6aca564be05"},{"problem":"171","code":"(fn [coll]\n   (if (empty? coll)\n     []\n     (do\n       (let [rangex (range (apply min coll) (inc (apply max coll)))]\n        (let [part-seq (partition-by #(.contains coll %) rangex)]\n          (filter #(not= nil %) (map (fn [iseq]\n                                       (when (and (.contains coll (first iseq)) (not= nil (first iseq)))\n                                         [(apply min iseq) (apply max iseq)])) part-seq)))))))","user":"5a4b3abde4b05d388ecb6b81"},{"code":"(fn [xs]\n  (loop [xss (next (sort xs)) lastnum (first (sort xs)) firstnum (first (sort xs)) acc []]\n    (if (seq xss)\n      (if (or (= (inc lastnum) (first xss)) (= lastnum (first xss)))\n        (recur (next xss) (first xss) firstnum acc)\n        (recur (next xss) (first xss) (first xss) (conj acc [firstnum lastnum])))\n      (if lastnum (conj acc [firstnum lastnum]) []))))","problem":"171","user":"4e7f5a0b535db966e863cc41"},{"code":"(fn f [k]\n  (if (empty? k) \n    []\n    (let [v (distinct (sort k))\n          w (mapv #(vector %1 (= (inc %1) %2)) v (rest v))\n          y (mapv #(conj %2 (second %1)) (cons [:foo false] w) w)]\n      (loop [x (conj y (vector (last v) false (nth (last y) 1)))\n             ans []\n             cur (ffirst x)]\n        (let [i (first x)]\n          (cond (empty? x) ans\n                (= true (second i) (nth i 2)) (recur (rest x) ans cur)\n                (= false (second i) (nth i 2)) (recur (rest x) (conj ans [(first i) (first i)]) false)\n                (and (second i) (not (nth i 2))) (recur (rest x) ans (first i))\n                :else \n                (recur (rest x) (conj ans (vector cur (first i))) false)))))))","problem":"171","user":"4facd2fae4b081705acca22f"},{"problem":"171","code":"(fn [the-seq]\n  (let [sorted-vec (sort (vec (set the-seq)))\n        first-last (fn [a-seq]\n                     (conj (conj [] (first a-seq)) (last a-seq)))\n        tk-wh-cnsc (fn twc# [a-seq]\n                     (lazy-seq\n                       (let [x (take 2 a-seq)\n                             y (first x)]\n                         (cond\n                           (or (empty? x) (empty? (rest x))) x\n                           (not= (inc y) (second x)) (list y)\n                           :else (cons y (twc# (rest a-seq)))))))]\n    (loop [lseq sorted-vec acc []]\n      (if (empty? lseq)\n        acc\n        (let [a-run (tk-wh-cnsc lseq)\n              f-l-vec (first-last a-run)]\n          (recur (drop (count a-run) lseq) (conj acc f-l-vec)))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":"171","code":"(fn [coll]\n            (loop [coll (sort (distinct coll))\n                   res  []]\n              (if-let [next-val (first coll)]\n                (if-let [pre-val (second (last res))]\n                  (if (= 1 (- next-val pre-val))\n                    (recur (rest coll) (concat (drop-last res) [[(first (last res)) next-val]]))\n                    (recur (rest coll) (concat res [[next-val next-val]])))\n                  (recur (rest coll) [[next-val next-val]]))\n                res)))","user":"5c0e3f86e4b01240ff56713d"},{"problem":"171","code":"(fn [coll]\n  (let [c (sort (set coll))] (partition 2 (remove nil? (flatten (concat [(first c)] (concat (flatten (filter (fn [[a b]] (> (- b a) 1))\n                                                                                                             (partition 2 1 c))) [(last c)])))))))","user":"529dfc6de4b04e0c58e87b8a"},{"code":"#(if (empty? %) []\n     (let [sc (sort-by - %)\n           fsc (first sc)]\n       (reduce (fn [[[sm bg] & rsts] nn]\n                 (if (<= (- sm nn) 1) (cons [nn bg] rsts)\n                         (cons [nn nn] (cons [sm bg] rsts))))\n               [[fsc fsc]] sc)))","problem":"171","user":"52c25645e4b07a9af579237d"},{"code":"(fn intervals [nums]\n  (if (empty? nums) []\n    (let [[p & r] (sort nums)\n          conj-seg (fn [ret seg p] (conj ret (conj seg p)))]\n     (apply conj-seg \n            (reduce (fn [[ret seg p] c]\n                      (if (< (- c p) 2) (list ret seg c)\n                        (list (conj-seg ret seg p) [c] c))) \n                    (list [] [p] p) r)))))","problem":"171","user":"5246e945e4b0644eb7b0783b"},{"problem":"171","code":"(fn [c]\n  (reverse\n    (reduce\n      (fn [[[a b :as ab] & os :as as] x]\n        (if (and ab (= x (inc b)))\n          (cons [a x] os)\n          (cons [x x] as)))\n      []\n      (sort (set c)))))","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":"171","code":"#(reduce (fn [i n]\n            (if (= (last (last i)) (- n 1))\n              (conj (vec (butlast i)) [(first (last i)) n])\n              (conj i [n n])))\n          []\n          (distinct (sort %)))","user":"5742ec91e4b05c31a32c0883"},{"problem":"171","code":"(fn  [coll] \n  (if (empty? coll) \n    []\n    (let [c (set coll)]    \n      (map #(vector (first %) (last %))\n           (take-nth 2 (partition-by #(contains? c %) \n                                     (range (apply min coll) (inc (apply max coll)))))))))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn [l]\n   (let [process (fn [lists x]\n                   (if-let [[l u]  (last lists)]\n                     (if (= x (inc u))\n                       (concat (butlast lists) [[l x]])\n                       (concat lists [[x x]]))\n                     (concat lists [[x x]])))]\n     (reduce process [] (sort (set l)))))","problem":"171","user":"4ea1b9e4535d7eef308072b8"},{"problem":"171","code":"(fn [xs]\n    (loop [xs (sort xs)\n           i (first xs)\n           c i\n           found []]\n      (if-not (seq xs) (if i (conj found [i c]) found)\n              (if (>= 1 (- (first xs) c) 0)\n                (recur (rest xs) i (first xs) found)\n                (recur (rest xs) (first xs) (first xs) (conj found [i c]))))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":"171","code":"(fn interval [coll]\n  (reduce\n   (fn [accm n]\n     (cond\n       (empty? accm) [[n n]]\n       (= (last (last accm)) n) accm\n       (= (inc (last (last accm))) n) (conj (vec (butlast accm)) (vector (first (last accm)) n))\n       (< (inc (last (last accm))) n) (conj accm (vector n n))))\n   []\n   (sort coll)\n   )\n)","user":"5b3251c1e4b025bcb146f317"},{"problem":"171","code":"(fn intervals [s]\n  (let [sorted (distinct (sort s))]\n    (loop [[a b & _ :as s] sorted\n           fst (first s)\n           acc []]\n      (prn a b acc)\n      (if (empty? s) acc\n          (if (= (inc a) b)\n            (recur (rest s) fst acc)\n            (recur (rest s) b (conj acc [fst a])))))))","user":"5c950334e4b048ec896c5a44"},{"problem":"171","code":"(fn [coll]\n      (reverse\n         (reduce (fn [[[current_interval_start current_interval_end] & others :as all-intervals] i]\n                    (do\n                       (println i current_interval_start current_interval_end others all-intervals)\n                       (cond\n                          (empty? all-intervals) (list [i i])\n                          (or (= current_interval_end i) (= (+ 1 current_interval_end) i))\n                              (cons [current_interval_start i] others)\n                          :else (cons [i i] all-intervals))))\n                 []\n                 (sort coll))))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn soln [v]\n  (let [v (-> v distinct sort)]\n    (if (seq v)\n      (let [f (first v)]\n        (loop [expected f\n               v v]\n          (if (seq v)\n            (if (<= (first v) expected)\n              (recur (inc expected) (rest v))\n              (cons [f (dec expected)] (soln v)))\n            [[f (dec expected)]])))\n      [])))","problem":"171","user":"4e80aa10535db62dc21a62b1"},{"problem":"171","code":"(fn intervals [coll]\n    (if (seq coll)\n      (let [low (apply min coll)\n            s (set coll)\n            interval (take-while s (range low (inc (apply max coll))))]\n        (cons [(first interval) (last interval)]\n              (lazy-seq (intervals (clojure.set/difference s interval)))))\n      ()))","user":"51b91b08e4b0e871ca4958f8"},{"problem":"171","code":"#(let [s (sort (distinct %))\n               p (rest s)\n               d (cons 1 (map - s p))\n               m (partition 2 (interleave s d))\n               r (reduce (fn [i [k v]]\n                            (if (= -1 v)\n                              (conj (vec (butlast i)) (conj (last i) k))\n                              (conj i [k])))\n                            [] m)]\n           (map (fn [x] [(first x) (last x)]) r)\n           )","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":"171","code":"#(reduce\n  (fn [st x]\n    (cond\n     (empty? st) [[x x]]\n     (= (-> st peek peek inc) x) (conj (pop st) [(first (peek st)) x])\n     :else (conj st [x x])\n     )\n    )\n  []\n  (apply sorted-set %)\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":"171","code":"(fn [s]\n  (if (empty? s) []\n    (let [s (sort s)]\n      (letfn [(f [ivs a b xs]\n                 (if (empty? xs) (conj ivs [a b])\n                   (let [x (first xs)]\n                     (cond (= x b) (f ivs a b (rest xs))\n                           (= x (inc b)) (f ivs a x (rest xs))\n                           :else (f (conj ivs [a b]) x x (rest xs))))))]\n        (f [] (first s) (first s) (rest s))))))","user":"54c271b9e4b045293a27f602"},{"problem":"171","code":"(fn [coll]\n   (let [coll (sort coll)]\n     (reduce\n      (fn [a x]\n        (let [a (if (nil? (last a)) (conj a [x x]) a)\n              [s e] (last a)]\n          (if (>= 1 (- x e))\n            (conj (pop a) [s x])\n            (conj a [x x])))) [] coll)))","user":"606a70a5e4b069485764ddf2"},{"code":"#(letfn [(endpos [l k]\r\n           (if (contains? l (inc k))\r\n               (endpos l (inc k))\r\n               k))\r\n         (f [l]\r\n          (if (= l []) []\r\n              (let [e (endpos (set l) (first l))]\r\n                  (cons [(first l) e] \r\n                  (f (drop-while (fn [x] (<= x e)) l))))))]\r\n  (vec (f (sort %))))","problem":"171","user":"4f474f43e4b0d56e7bb92bb7"},{"problem":"171","code":"(fn _171_ [coll]\n  (let [data-ref (atom (sorted-map))]\n    (doseq [v (sort (distinct coll))]\n      (let [item (get @data-ref (dec v))]\n        (if item\n          (do\n            (swap! data-ref assoc v [(first item) v])\n            (swap! data-ref dissoc (dec v)))\n          (swap! data-ref assoc v [v v]))))\n    (if (empty? @data-ref)\n      []\n      (vals @data-ref))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":"171","code":"(fn intervals[s]\n  (letfn [(partition-when [pred2? coll]\n  \t\t\t(let [flips (reductions not= true (map pred2? coll (rest coll)))]\n    \t\t  (map (partial map first) (partition-by second (map vector coll flips)))))]\n    (map #(apply (juxt min max) %) (partition-when #(> (- %2 %1) 1) (sort s)))))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":"171","code":";phone formatting\n(fn t [v] \n  (let [s (sort v)\n      v2 (vector (take 2 s))]\n  (if-let [s2 (nnext s)]\n  (reduce \n    #(let [bl (pop %)\n           l (peek %)\n           ll (last l)]\n (if (< (inc ll) %2)\n   (conj % [%2 %2])\n   (conj bl [(first l) %2])))\n   \n   v2\n   (vec s2))\n  [])))","user":"526a3412e4b03e8d9a4a721e"},{"problem":"171","code":"#(let [[f & t] (sort %)]\n    (if f\n      (reverse\n       (reduce\n        (fn [[[a b] & r :as l] e]\n          (if (<= a e (+ 1 b))\n            (conj r [a e])\n            (conj l [e e])))\n        [[f f]]\n        t))\n      %))","user":"52814e97e4b0757a1b171428"},{"code":"#(vec (reverse ((fn mi [fi  x](if (empty? x) [] \r\n                    (if( = (count x) 1)\r\n                      [[fi (first x)]]\r\n                         (if (or (= (first x) (-(second x) 1))\r\n                             (= (first x) (second x)))\r\n                             (mi fi (rest x))\r\n                             (conj (mi (first (rest x)) (rest x)) [fi (first x)] ))))) (first (sort %1)) (sort %1))))","problem":"171","user":"50646c01e4b007509339a58b"},{"problem":"171","code":"(fn [xs] \n (if (empty? xs) []\n  (let [ss (sort xs)\n        s-fst (first ss)\n        s-rest (rest ss)] \n   (reduce (fn [acc b] \n    (let [top-iv (peek acc)\n          prev (second top-iv)]\n     (cond (= prev b) acc\n      (= (inc prev) b)\n       (conj (pop acc)\n        [(first top-iv) b])\n      :else (conj acc [b b]))))\n    [[s-fst s-fst]]\n    s-rest) )))","user":"57f9011ee4b0d3187e900935"},{"problem":"171","code":"(fn intervals [l]\n\t(loop [result [], remaining (sort l)]\n\t\t(if (empty? remaining)\n\t\t\tresult\n\t\t\t(let [curitem (first remaining)\n\t\t\t\tcurinterval (last result)\n\t\t\t\tcontinuous (if (not curinterval) false\n\t\t\t\t\t(< (- curitem (last curinterval)) 2)\n\t\t\t\t)\n\t\t\t\t]\n\t\t\t\t(recur\n\t\t\t\t\t(if continuous\n\t\t\t\t\t\t(concat (butlast result) [[(first curinterval), curitem]])\n\t\t\t\t\t\t(concat result [[curitem, curitem]])\n\t\t\t\t\t)\n\t\t\t\t\t(next remaining)\n\t\t\t\t)\n\t\t\t)\n\t\t)\t\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":"171","code":"(fn [x] (vec (map vec (partition 2 2(reduce \n\t#(if \n\t\t(or (= (count %) 0) (odd? (count %))) \n\t\t(if (= (count %) 0) (conj % %2 %2) (conj % %2))\n\t\t(if \n\t\t\t(= (last %) (- %2 1)) \n\t\t\t(conj (vec (butlast %)) %2)\n\t\t\t(conj % %2 %2)))\n\t [] \n\t (sort (distinct x))))))\n)","user":"538a13b8e4b0640c7a9a58b6"},{"code":"(letfn [(split-between [f [x & xs]]\n        (if (nil? x) []\n            (let [ys (split-between f xs)]\n                (cond\n                    (empty? ys) [[x]]\n                    (f x (first (first ys))) (cons [x] ys)\n                    :else (cons (cons x (first ys))\n                                (rest ys))))))]\n      (fn [coll]\n          (map #(list (first %) (last %))\n               (split-between #(< 1 (- %2 %1)) (sort coll)))))","problem":"171","user":"4f6fbb68e4b07046d9f4efeb"},{"problem":"171","code":"(fn intervals\n  [coll]\n  (let [inc= (fn [a b] (#{0 1} (- b a)))]\n    (map #(vector (first %) (last %)) (reduce\n                                        (fn [res n]\n                                          (let [last-n (last (last res))]\n                                            (if (and last-n\n                                                     (inc= last-n n))\n                                              (conj (vec (drop-last res)) (conj (last res) n))\n                                              (conj res [n]))))\n                                        []\n                                        (sort coll)))))","user":"4e586949535d8a8b8723a292"},{"problem":"171","code":"(fn [s]\n  (let [ss (sort (distinct s))]\n    (->> ss\n         (partition 2 1)\n         (reductions (fn [acc x] (if (< (apply - x) -1) (inc acc) acc)) 1)\n         (map vector ss)\n         (group-by second)\n         (vals)\n         (map (juxt ffirst (comp first last)))\n)))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [xs]\n  (let [sorted-xs (sort xs)\n        xs+1 (cons 0 (drop-last sorted-xs))\n        diff (map - sorted-xs xs+1)\n        bundle (fn bundle [[y & ys :as yall] [d & ds]]\n                 (if (empty? yall)\n                   '()\n                   (let [tmp (bundle ys ds)]\n                     (if (< d 2)\n                       (cons (cons y (first tmp)) (drop 1 tmp))\n                       (cons (list y) tmp)))))]\n    (->> (bundle (reverse sorted-xs) (reverse diff))\n         (map (fn [coll] [(apply min coll) (apply max coll)]))\n         reverse)))","problem":"171","user":"536d83cee4b0fc7073fd6e5e"},{"problem":"171","code":"#(let [s (set %)\nn-elem? (fn [n] (fn [x] (contains? s (+ x n))))\nfirsts (filter (every-pred (n-elem? 1) (complement (n-elem? -1))) s)\nf-firsts (fn [x] (take-while (n-elem? 0) (iterate inc x)))\nranged-firsts (fn [x] (let [r (f-firsts x)] [(first r) (last r)]))\nalones (filter (every-pred (complement (n-elem? 1)) (complement (n-elem? -1))) s)\nf-alones (fn [x] [x x])]\n(apply vector (sort (clojure.set/union (map ranged-firsts firsts) (map f-alones alones)))))","user":"5e13a6b7e4b099d064963001"},{"code":"(fn intervals [x]  \n  (->> x\n       (into #{})                  ;; de-dupe\n       sort\n       (map-indexed vector)        ;; associate with index\n       (partition-by #(apply - %)) ;; partition by un-equal differences to index    \n       (map #(vector               ;; get the first/last of each value in the interval\n               (second (first %))\n               (second (last %))))))","problem":"171","user":"50812debe4b01a93d3f38e4c"},{"problem":"171","code":"(fn [s]\n  (->> (sort s)\n       (partition-all 2 1)\n       (map #(if (> (apply - (reverse %)) 1) (interpose nil %) %))\n       (mapcat identity)\n       (partition-by nil?)\n       (take-nth 2)\n       (map (juxt first last))))","user":"5e6ca949e4b04a83ad7cd289"},{"code":"(fn intervals [coll]\n  (if (empty? coll)\n    []\n    (let [c (sort coll)\n          accumulate\n            (fn [acc v]\n              (let [[a b] (last acc)]\n                (cond\n                  (= b v)        acc\n                  (= (inc b) v)  (concat (drop-last acc) [[a v]])\n                  :else          (concat acc [[v v]]))))\n          ]\n      (reduce accumulate [[(first c) (first c)]] (rest c)))))","problem":"171","user":"4fb12b35e4b081705acca275"},{"problem":"171","code":"(fn intervals [s]\n  (->>\n    (sort s)\n    (reduce (fn [z h]\n      (let [last-list (last z)\n            last-item (last last-list)\n            first-items (drop-last z)]\n            (cond\n              (nil? last-item) [[h]]\n              (= last-item h) z\n              (= (inc last-item) h) (concat first-items [(conj last-list h)])\n              :else (concat z [[h]]))))\n              [])\n    (map (fn [x] [(first x) (last x)]))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":"171","code":"#(loop [in (sort %) out [] start (first in)] (if (empty? in) out (let [i (first in) j (second in)] (if (or (= (inc i) j) (= i j)) (recur (rest in) out start) (recur (rest in) (conj out [start i]) j)))))","user":"57f9e0bce4b0d3187e900956"},{"problem":"171","code":"#(let [c (sort (distinct %))\n       x (first c)] \n    (if (empty? c)\n      []\n      ((fn get-intervals[coll retc]\n        (if (empty? coll)\n          retc\n          (let [x (first coll)\n                v (last retc)\n                y (last v)] \n            (if (= x (inc y))\n              (get-intervals (rest coll) (conj (vec (butlast retc)) [(first v) x]))\n              (get-intervals (rest coll) (conj (vec retc) [x x]))\n            )\n          )\n        )\n      ) (rest c) (conj [] [x x]))\n    )\n )","user":"545537c1e4b0e397800069dd"},{"problem":"171","code":"(fn [coll]\n   (if (empty? coll) []\n       (reduce\n        (fn [result value]\n          (let [head (last result) result (pop result)]\n            (if (<= value (inc (last head)))\n              (conj result [(first head) value])\n              (conj result head [value value]))))\n        [[(apply min coll)]]\n        (rest (sort coll)))))","user":"52fac708e4b047fd55836fff"},{"problem":"171","code":"(fn intervals [lis]\n  (let [sor-lis (sort lis)]\n    (if (empty? sor-lis)\n      []\n      (:res (reduce (fn [{:keys [f l res]} val]\n                      (prn f l val res)\n                      (if (<= (- val l) 1)\n                        {:f   f\n                         :l   val\n                         :res res}\n                        {:f   val\n                         :l   val\n                         :res (conj res [f l])}))\n                    {:f   (first sor-lis)\n                     :l   (first sor-lis)\n                     :res []}\n                    (conj (vec (drop 1 sor-lis)) 10000))))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn __ [coll]\n  (if (seq coll)\n    (let [sorted (distinct (sort coll))\n          red (fn [[out head prev] in]\n                (cond\n                  (= (inc prev) in) [out head in]\n                  :else [(conj out [head prev]) in in]))\n          [out last-first last-last] \n            (reduce red [[] (first sorted) (first sorted)] (rest sorted))]\n      (conj out [last-first last-last]))\n    coll))","problem":"171","user":"52463059e4b09dbe66b56198"},{"problem":"171","code":"(fn [x] (->> x\n             (apply sorted-set)\n             (keep-indexed (fn [i item] [i item (- item i)]))\n             (partition-by #(% 2))\n             (map #(vector (second (first %)) (second (last %)))) ))","user":"550e52dbe4b06e50f9beb165"},{"problem":"171","code":"(fn f\n    ([xs] (if (empty? xs) [] (let [xs (sort xs)] (f (first xs) (rest xs)))))\n    ([x xs]\n     (reduce (fn [a c]\n               (if (<= (- c (last (last a))) 1)\n                 (conj (vec (butlast a)) (conj (vec (take 1 (last a))) c))\n                 (conj a [c c]))\n               ) [[x]] xs)))","user":"507e68abe4b085af06e3afd2"},{"code":"(fn [s] \n(let [\n    [x & xs] (sort s)\n    rec-intervals (fn [ r b e [x & xs :as s]]\n        ;(println \"r = \" r \" ; b = \" b \" ; e \" e \" ; s \" s \" x= \" x \"  (<= (- e x) 1) \"  (<= (- e x) 1))\n        (if (empty? s) \n                (if (nil? b) r (conj r [b e]))\n                (if (<= (- x e ) 1) \n                    (recur r b x xs)\n                    (recur (conj r [b e]) x x xs))))\n    ] \n    (rec-intervals [] x x xs)))","problem":"171","user":"51f59607e4b0abb92f97f9d5"},{"problem":"171","code":"(fn\n  [v]\n  (let [s (sort v)]\n   (loop [tail (rest s)\n          intervals (transient [])\n          curr-begin (first s)\n          curr-end   curr-begin]\n     (if-not (empty? tail)\n       (cond\n         (== (first tail) (inc curr-end)) (recur (rest tail)\n                                                 intervals\n                                                 curr-begin\n                                                 (inc curr-end))\n         (== (first tail) curr-end) (recur (rest tail)\n                                           intervals\n                                           curr-begin\n                                           curr-end)\n         :else (recur (rest tail)\n                      (conj! intervals [curr-begin curr-end])\n                      (first tail)\n                      (first tail)))\n       (if curr-begin\n         (persistent! (conj! intervals [curr-begin curr-end]))\n         [])))))","user":"56a28c23e4b0542e1f8d14c3"},{"problem":"171","code":"(fn [v]\n  (if (empty? v)\n    v\n    (let [sv (sort (distinct v))]\n      (reverse\n       (map\n        (juxt last first)\n        (reduce\n         (fn [[[x :as b] & r :as a] y]\n           (prn x b r a y)\n           (if (= 1 (- y x))\n             (cons (cons y b) r)\n             (cons (list y) a)))\n         (list (list (first sv)))\n         (rest sv)))))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn intervals \n  ([x] \n   (if (empty? x) x \n     (let [sorted (sort x)\n           fx (first sorted)]\n       (intervals (rest sorted) [] fx fx)))) \n  ([x r l c] \n   (if (empty? x) (conj r [l c])\n     (let [[fx & rs] x\n           i (partial intervals rs)] \n       (if (or (= (inc c) fx) (= c fx))\n         (i r l fx)\n         (i (conj r [l c]) fx fx))))))","problem":"171","user":"50e4f4e9e4b049a987753896"},{"code":"(fn intervals [numbers]\n  (loop [remaining numbers\n         result []]\n    (let [sorted (sort (distinct remaining))\n          increased? (zipmap (rest sorted) (map #(= (inc (first %)) (second %)) (partition 2 1 sorted)))]\n      \n      (if (empty? remaining)\n        (for [interval result]\n          [(first interval) (last interval)])\n        (recur (drop-while increased? (rest sorted))\n               (conj result (concat (take 1 sorted) (take-while increased? (rest sorted)))))))))","problem":"171","user":"510cd1dde4b078ea71921124"},{"problem":"171","code":"(fn [v]\n  (let [sorted (sort v)]\n    (reduce #(if (= 0 (count %1))\n               (vector (vector %2 %2))\n               (let [last-inserted (last (last %1))]\n                 (if (or (= last-inserted %2)\n                         (= (inc last-inserted) %2))\n                   (update-in %1 [(dec (count %1)) 1] (constantly %2))\n                   (conj %1 (vector %2 %2)))))\n            []\n            sorted)))","user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [s]\n      (partition 2\n                 (reduce\n                   #(if (or (empty? %) (> (- %2 (peek %)) 1))\n                      (conj % %2 %2)\n                      (conj (pop %) %2))\n                   [] (sort s))))","problem":"171","user":"50f48298e4b004d364930527"},{"problem":"171","code":"(fn [xs]\n  (let [sorted (-> xs sort distinct) [head & tail] sorted]\n    (loop [accum [] start head prev head xs tail] \n      (let [[head & tail] xs]\n        (cond\n          (nil? start) accum\n          (= (inc prev) head) (recur accum start head tail)\n          :else (recur (conj accum [start prev]) head head tail))))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":"171","code":"(fn [c]\n(letfn [(f [a x]\n(let [a (if (empty? a) [[x x]] a)\n[_ y] (last a)]\n(condp = x\ny a\n(inc y) (assoc-in a [(dec (count a)) 1] x)\n(conj a [x x]))))]\n(reduce f [] (sort c))))","user":"5fd10010e4b07e53c2f3f02a"},{"code":"(fn [a]\n  (let [a (-> a set sort)\n        s (set a)]\n    (partition 2 \n      (interleave \n        (filter #(not (s (dec %))) a)\n     \t  (filter #(not (s (inc %))) a)))))","problem":"171","user":"5054bc87e4b0b1b9d1860eb0"},{"problem":"171","code":"(fn p171\n  [coll]\n  (let [coll2 (sort (distinct coll))]\n    ((fn tiger\n      [[a & coll] b]\n      (if a\n        (if (= (inc a) (first coll))\n          (tiger coll b)\n          (conj (tiger coll (first coll)) [b a]))\n        '())) coll2 (first coll2))))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":"171","code":"(fn [c]\n   (let [extend-intervals\n         (fn [intervals i]\n           (let [interval-start-at (intervals (dec i))]\n             (if (nil? interval-start-at)\n               (if (intervals i) intervals (assoc intervals i i))\n               (assoc (dissoc intervals (dec i)) i interval-start-at))))\n         ;;---\n         merge-intervals-1pass\n         (fn [intervals]\n           (reduce\n            (fn [intervals [e s]]\n              (if-let [[e' s'] (find intervals (dec s))]\n                (assoc (dissoc intervals e') e s')\n                intervals))\n            intervals\n            intervals))]\n     ;; works because hash keeps its entries in correct order, else we need a ->vec and sort on key before mergepass\n     (mapv (comp vec reverse) (merge-intervals-1pass (reduce extend-intervals {} c)))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn intervals\n  [sq]\n  (let [[f & rst] (distinct (sort sq))\n        [intervals in-progress] (reduce\n                                 (fn [[intervals [start end]] nxt]\n                                   (if (= nxt (inc end))\n                                     [intervals [start nxt]]\n                                     [(conj intervals [start end]) [nxt nxt]]))\n                                 [[] [f f]]\n                                 rst)]\n    (remove #{[nil nil]} (conj intervals in-progress))))","problem":"171","user":"51f9527fe4b09be9c177e549"},{"code":"(fn [s] (map #(identity [(first %) (last %)]) (reduce #(if (or (nil? (first %1)) (not= (last (last %1)) (dec %2))) (conj %1 [%2]) (assoc-in %1 [(dec (count %1)) (count (get %1 (dec (count %1))))] %2)) [] (set s))))","problem":"171","user":"52c1bd29e4b07a9af579236a"},{"problem":"171","code":"#(letfn [(m [i] (reduce (fn [[s [x y]] b]\n          (cond \n            (nil? y) [s [b b]]\n            (= b y) [s [x b]]\n            (= b (inc y)) [s [x b]]\n            :else [(conj (vec s) [x y]) [b b]]\n           )) [] (sort i)))]\n (if (empty? %) []\n  (let [v (m %)]\n   (conj (first v) (second v)))))","user":"56bca51ae4b0f26550335963"},{"problem":"171","code":"(fn find-intervals [xs]\n  (letfn [(find-consecutives [coll]\n            (loop [acc []\n                   [head & tail] (sort xs)]\n              (if (nil? head) acc\n                (if (and (not= (dec head) ((comp last last) acc))\n                         (not= head ((comp last last) acc)))\n                  (recur (conj acc [head]) tail)\n                  (recur (conj\n                            ((comp vec butlast) acc)\n                                (conj ((comp vec last) acc) head)) \n                         tail)))))\n          (find-bounds [xxs]\n            (if (and (= 1 (count xxs)) (every? (partial = (first xxs)) (rest xxs)))\n              ((comp list list) ((comp first first) xxs) ((comp last last) xxs))\n              (map #(list (first %) (last %)) xxs)))]\n    (-> xs \n        find-consecutives \n        find-bounds)))","user":"5553b729e4b0deb715856e05"},{"problem":"171","code":"(fn interval [coll]\n  (let [sorted (sort (distinct coll))\n        bl (fn [coll]\n             (into [] (butlast coll)))\n        inc? (fn [x y] (= (inc x) y))\n        f (first sorted)\n        pairs (partition 2 1 sorted)\n        nil-pair? (fn [[x y]]\n                    (nil? (and x y)) )]\n    (->> pairs\n         (reduce\n          (fn [acc [x y]]\n            (if (inc? x y) (conj (bl acc)\n                                 (conj (last acc) y))\n                (conj acc [y])))\n          [[f]])\n         (mapv #(apply (juxt min max) %))\n         (remove nil-pair?))))","user":"505d1b01e4b0e6aca564be04"},{"problem":"171","code":"(fn intervals [s]\n  (vec\n    (map #(vec [(first %) (last %)])\n         (map #(map last %)\n              (partition-by #(apply - %) (map-indexed vector (sort (distinct s))))))))","user":"56d4b22de4b0ea9b8538f7bb"},{"problem":"171","code":"(fn intervals [v]\n    (if (empty? v)\n      []\n      (let [v (sort v)]\n        (loop [ start (first v) end (first v) v (rest v) result [] ]\n          (if (empty? v)\n            (conj result [start end])\n            (let [ felem (first v) ]\n              (if (or (= end felem) (= (inc end) felem))\n                (recur start felem (rest v) result)\n                (recur felem felem (rest v) (conj result [start end])))))))))","user":"55aa1637e4b0988bba2ad949"},{"problem":"171","code":"(fn intervals[nums]\n  (if (empty? nums) []\n    (let [sorted (sort nums)]\n      ((comp #(partition 2 %)\n             #(cons (first sorted) %) #(conj % (last sorted)) #(into [] %) flatten)\n        (for [x (range (dec (count sorted)))\n              :let [y (inc x)]]\n          (if (> (nth sorted y) (inc (nth sorted x)))\n            [(nth sorted x) (nth sorted y)]\n            []))))))","user":"5545477fe4b0a04f79299531"},{"code":"(fn [t]\n  (let [a apply\n        c count\n        s :s\n        t (distinct (sort t))\n        q (a concat\n             (map\n               #(let [f (first %)\n                       l (if (= 1 (c %)) f (last %))]\n                  (if (< (- l f) 2) [f l] [f s l]))\n              (if\n                (= 1 (c t))\n                [t]\n                (partition 2 1 t))))]\n    (map (fn [c] [(a min c) (a max c)]) (remove (partial = [s]) (partition-by #(= s %) q)))))","problem":"171","user":"51a10b2ce4b0b292b01ee3fe"},{"code":"(fn [sequence-of-integers]\n    (let [sorted-integers (sort sequence-of-integers)]\n      (partition 2 (reduce\n        (fn [output, i]\n          (if (or\n                (= (last output) i)\n                (= (last output) (dec i)))\n            (concat (take (dec (count output)) output)  [i])\n            (concat output (repeat 2 i))))\n        (if (seq sorted-integers) (repeat 2 (first sorted-integers)) [])\n        sorted-integers))))","problem":"171","user":"52699a0ee4b03e8d9a4a71f2"},{"problem":"171","code":"(fn intervals [lst]\n  (let [lst' (sort (into #{} lst))]\n  (reverse (reduce (fn [[[lo hi] & rest :as intervals] item]\n            (if (= (inc hi) item) (cons [lo item] rest) (cons [item item] intervals)))\n          (if (empty? lst) []\n            (list [(first lst') (first lst')]))\n            (rest lst')))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":"171","code":"(fn [seq]\n          (\n            (fn next-interval\n         ([seq]\n           (if\n             (empty? seq)\n             []\n             (let [seq (sort seq)\n                    f (first seq)\n                   [l rseq] (next-interval f (rest seq))]\n               (cons [f l] (next-interval rseq)))))\n\n         ([f seq]\n           (let [n (first seq)]\n             (if (or (= n f) (= (inc f) n))\n               (next-interval n (rest seq))\n               [f seq])))) (sort seq))\n\n\n          )","user":"4f724e56e4b07046d9f4f027"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    coll\n    (let [sorted (sort coll)]\n      (->> (rest sorted)\n           (reduce\n            (fn [acc n]\n              (let [prevg (last acc)]\n                (cond\n                 (= (last prevg) n) acc\n                 (< (inc (last prevg)) n) (conj acc [n])\n                 :else (update-in acc [(dec (count acc))] conj n))))\n            [[(first sorted)]])\n           (map (juxt first last))))))","user":"505aa653e4b021387fb89857"},{"problem":"171","code":"(fn intervals\n  [x]\n  (if (empty? x)\n    []\n    (loop [[h & r :as o] (-> x distinct sort)\n           [i1 i2 :as i] nil\n           agg []]\n      (cond (and (not (nil? h)) (nil? i)) (recur r [h h] agg)\n            (nil? h) (conj agg i)\n            (= (inc i2) h) (recur r [i1 h] agg)\n            :else (recur o nil (conj agg i))))))","user":"57ea2c91e4b0bfb2137f5b42"},{"code":"(fn [args]\n  ((fn make-interval [c]\n    (let [adj (take-while (fn [[a b]] (= (inc a) b))\n                               (partition 2 1 c))]\n      (cond\n        (empty? c) []\n        (empty? adj)\n          (cons\n            [(first c) (first c)]\n            (make-interval (next c)))\n        :else\n          (cons\n            [(ffirst adj) (last (last adj))]\n            (make-interval (drop (inc (count adj)) c))))))\n    (sort (set args))))","problem":"171","user":"504c8165e4b09724c857af31"},{"code":"(fn intervals [xs]\n  (if (empty? xs) []\n  (let [input (distinct (sort xs))]\n    (reduce #(if (= %2 (inc (last (last %1)))) \n                 (update-in %1 [ (dec (count %1)) 1] inc)\n                 (conj %1 [%2 %2]))\n            [[(first input) (first input)]]\n            (rest input)))))","problem":"171","user":"53691dc7e4b0243289761e97"},{"problem":"171","code":"(fn [coll]\n   (letfn [(split [coll]\n             (split-at (count\n                        (take-while\n                         (fn [[e1 e2]] (= e1 e2))\n                         (map vector\n                              coll (iterate inc (first coll)))))\n                       coll))\n           (make-interval [s]\n             [(first s) (last s)])\n           (interval-seq [coll]\n             (if (empty? coll)\n               ()\n               (let [[t d] (split coll)\n                     i (make-interval t)]\n                 (lazy-seq\n                  (cons i (interval-seq d))))))]\n     (->> coll\n          (sort)\n          (distinct)\n          (interval-seq))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [coll]\n  (if (not (seq coll))\n    []\n    (let [c (sort coll)\n          fc (first c)]\n     (reduce \n     (fn [acc b] \n       (if (<= (dec b) (last (last acc)))\n         (conj (vec (drop-last acc)) [(first (last acc)) b])\n         (conj acc [b b])\n         )\n       )\n     [[fc fc]]\n     (rest c)\n     )\n    )\n  )\n  )","problem":"171","user":"523f0bbfe4b01c266ffa7f91"},{"problem":"171","code":"(fn [in]\n  (if (empty? in) []\n      (apply conj\n             (let [sorted (sort in)]\n               (reduce (fn [[prev curr] x]\n                         (if (<= x (inc (last curr)))\n                           [prev [(first curr) x]]\n                           [(conj prev curr) [x x]])) [[] [(first sorted) (first sorted)]]\n                       (sort (rest sorted)))))))","user":"5f972ed6e4b0715f5002d7f2"},{"problem":"171","code":"(fn [s]\n  (if (seq s)\n    (let [s (into (sorted-set) s)]\n      (loop [a (first s)\n             b a\n             s (rest s)\n             res []]\n        (if (seq s)\n          (let [c (first s)]\n            (if (zero? (- c b 1))\n              (recur a c (rest s) res)\n              (recur c c (rest s) (conj res [a b]))))\n          (conj res [a b]))))\n    []))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [in]\n  (->> in\n       sort\n       (reduce (fn [acc item]\n        (let [done (butlast acc)    \n              [start finish] (last acc)]\n              (cond\n               (nil? finish) [[item item]]\n               (or (= finish (dec item)) (= finish item)) (concat done [[start item]])\n               :else (concat done [[start finish]] [[item item]])\n               ))) [])))","problem":"171","user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(letfn \n[(conseq? [n m]\n  (if (nil? m)\n    false\n    (= (inc n) m)))\n\n( dedup [coll]\n  (reduce #(if (= (last %1) %2) %1 (conj %1 %2)) [(first coll)] coll))\n\n(get-run [f coll]\n  (if (> (count coll) 1)\n    (lazy-seq\n     (when-let [s (seq coll)]\n       (let [fst (first s)\n             fv (first (next s))]\n         (if (f fst fv)\n           (concat [fst] (get-run f (drop 1 s)))\n           [fst]))))\n    coll))\n\n(partition-by-2 [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [run (get-run f s)]\n       (cons run (partition-by-2 f (seq (drop (count run) s))))))))]\n\n(fn p [coll]\n  (if (> (count coll) 1)\n    (map #(vector (first %) (last %)) (partition-by-2 conseq? (dedup (sort coll))))\n    coll)))","problem":"171","user":"50733b31e4b0e3170b5a869a"},{"problem":"171","code":"#(map (fn [[x]] [(ffirst x) (last (last x))])\n    (partition 1 2 (partition-by\n      (fn [[a b]] (> (- b a) 1))\n      (partition 2 1 (sort (flatten (repeat 2 %))))\n    )))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn [s]\n  (if (empty? s) \n    s\n    (map #(vector (first %) (last %))\n      (let [ss (sort s)]\n         (reduce \n          #(let [l (last %)]\n            (if (> (- %2 (last l)) 1) \n              (conj % [%2]) \n              (conj (pop %) (conj l %2)))) \n          [[(first ss)]] ss)))))","problem":"171","user":"4e9c81e8535dbda64a6f6b80"},{"problem":"171","code":"(fn [xs]\n  (let [sx (distinct (sort xs))\n        start (first sx)\n        ordsx (take (count sx) (iterate inc start))\n        pm (apply map vector [sx ordsx])\n        pa (partition-by #(- (first %) (second %)) pm)]\n    (map #(list (ffirst %) (first (last %))) pa)))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [coll]\n  (if (seq coll)\n    (let [coll (vec (sort coll))\n          lasts (->> (loop [coll (next coll)\n           \t                acc []\n                            le (first coll)\n                            run [(first coll)]]\n                       (if-let [[e & coll] coll]\n                         (if (or (= le e) (= e (inc le)))\n                           (recur coll acc e (conj run e))\n                           (recur coll (conj acc run) e [e]))\n                         (conj acc run)))\n                     (map count)\n                     (reductions +))]\n      (map #(vector (get coll %1) (get coll (dec %2))) (cons 0 lasts) lasts))\n    coll))","problem":"171","user":"4e521cef535d302ef430da6d"},{"problem":"171","code":"(fn [lst]\n  (if (empty? lst) \n    []\n    (let [la (vec (distinct (sort lst)))]\n      (loop [v [], s (first la), f (first la), i 1]\n        (if (= i (count la))\n               (conj v [s f])\n               (recur\n                 (if (= (la i) (inc f)) v (conj v [s f]))\n                 (if (= (la i) (inc f)) s (la i))\n                 (la i)\n                 (inc i)))))))","user":"564d3169e4b0284900eef67c"},{"problem":"171","code":"(fn intervals [sq]\n  (if (empty? sq)\n    []\n    (let [inp-vec (sort sq)\n          cons-pairs (map vector inp-vec (rest inp-vec))\n          boundaries (filter (fn [[x y]] (> y (+ x 1))) cons-pairs)\n          int-values (flatten (concat [(first inp-vec)] boundaries [(last inp-vec)]))]\n      (map #(apply vector %) (partition 2 int-values)))))","user":"51b920bfe4b0e871ca4958f9"},{"code":"(fn [x]\n  (->> (set x)\n       (sort)\n       (reduce (fn [m v] (assoc m v (get m (dec v) v))) {})\n       (group-by val)\n       (sort-by first)\n       (map (fn [[k v]] [(apply min (flatten v)) (apply max (flatten v))]))))","problem":"171","user":"4fe8fda4e4b0547ebccb2438"},{"problem":"171","code":"(fn [coll] (if (empty? coll) []\n  (let [a (sort coll) initv (first a) initc (rest a)]\n(loop [intervals [] start initv prev initv x initc]\n  (cond (empty? x) (conj intervals (vector start prev))\n        (>= (inc prev) (first x)) (recur intervals start (first x) (rest x)) \n        :else (recur (conj intervals (vector start prev)) (first x) (first x) (rest x)))))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":"171","code":"(fn [v]\n  (letfn [(f [acc i]\n             (let [n1 (-> acc last first)\n                   n2 (-> acc last last)]\n               (cond\n                (= n2 i) acc\n                (= (dec i) n2) (conj (into [] (butlast acc)) [n1 i])\n                :else (conj acc [i i]))))]\n    (reduce f [] (sort v))))","user":"544cf5d7e4b0e39780006977"},{"problem":"171","code":"(fn f\n  [c]\n  (let [s (sort c)]\n    (reduce #(if (empty? %1) \n               (conj %1 [%2 %2]) \n               (let [l (last %1) ll (last l)]\n                 (if (<= (dec %2) ll)\n                   (conj (pop %1) [(first l) %2])\n                   (conj %1 [%2 %2])))) [] s)))","user":"576df252e4b0979f8965156f"},{"code":"( fn [xs]  ( let [z (sort (distinct xs))]\n                              (loop [x z y [] t [(first z)] ]\n                                (cond\n                                  (empty? x) y                    \n                                   (<= (.size x) 1) (concat y (vector (into t [(first x)]) ))\n                                     :else                     ( if (= (second x) (inc (first x)) ) (recur (rest x) y t )\n                                                            (recur  (rest x) (into y (vector (into t [(first x)]) ) ) (vector (second x)))\n                                                            )\n                                  ))))","problem":"171","user":"5225b16de4b0d2f5d1e2c0ed"},{"code":"(fn [x] (reverse(map \n            (fn [x] (if (= 1 (count x))\n                      (vec (flatten (take 2 (repeat x))))\n                      [(first x) (last x)]))\n            (reduce (fn [coll x]\n            (if (or (= (dec x) (last (first coll)))\n                    (= x (last (first coll))))\n              (conj (rest coll) (conj (first coll) x))\n              (conj coll [x])))\n  [] (sort x)))))","problem":"171","user":"52fa4f48e4b047fd55836ff7"},{"problem":"171","code":"#(->> %\n      distinct\n      sort\n      (reduce (fn [[[a b] & r] e]\n                (if a\n                  (if (= e (+ 1 b))\n                    (cons [a e] r)\n                    (list* [e e] [a b] r))\n                  (cons [e e] r)))\n              [])\n      reverse)","user":"53034738e4b0d8b024fd373e"},{"problem":"171","code":"(fn foo [coll]\n  (if-let [o (seq (sort coll))]\n    (loop [m (first o) p m r (rest o) acc []]\n      (if-let [n (first r)]\n        (if (<= n (inc p))\n          (recur m n (rest r) acc)\n          (recur n n (rest r) (conj acc [m p])))\n        (conj acc [m p]))) ()))","user":"56a01895e4b0542e1f8d149f"},{"code":"(fn [coll]\n  (letfn [\n     (split1 [[f & r]]\n         (reduce \n           (fn [c e] \n             (if (= e  (inc (last c)))\n                        (conj c e)\n                        (conj c nil e))) \n           [f] \n           r))]\n(map (juxt first last) \n    (remove #{[nil]} \n      (partition-by nil? \n          (split1 (sort (distinct coll))))))))","problem":"171","user":"4daa374930acd6ed13482a68"},{"code":"(fn [s]\r\n   (map #(vector (second (first %)) (second (last %)))\r\n        (partition-by #(first %) (map-indexed #(vector (- %2 %1) %2) (set s)))))","problem":"171","user":"503354c3e4b0c6c1199c710c"},{"code":"(fn [xs]\n  (if (seq xs) \n    (let [xs (set xs)]\n      (->> (set (range (first xs) (inc (last xs))))\n        (partition-by #(not (xs %)))\n        (filter #(every? xs %))\n        (map (fn [[x & ys]] (if ys [x (last ys)] [x x])))))\n    []))","problem":"171","user":"4f21838fe4b0d66497709fd2"},{"problem":"171","code":"(fn [xs]\n    (let [sorted (sort xs)]\n      (loop [xs sorted acc [] tmp []]\n        (if (empty? xs)\n          (if (empty? tmp)\n            acc\n            (conj acc [(first tmp) (last tmp)]))\n          (let [f (first xs)]\n           (if (empty? tmp)\n             (recur (rest xs) acc (conj tmp f))\n             (if (or (= (inc (last tmp)) f) (= (last tmp) f))\n               (recur (rest xs) acc (conj tmp f))\n               (recur (rest xs) (conj acc [(first tmp) (last tmp)]) [f]))))))))","user":"551a21ece4b091ff45eda993"},{"code":"(fn [v]\n  (let [[f & t] (sort v)]\n    (if f\n      (reverse\n       (reduce\n        (fn [[[a b] & r :as l] e]\n          (if (<= a e (+ 1 b))\n            (conj r [a e])\n            (conj l [e e])))\n        [[f f]]\n        t))\n      v)))","problem":"171","user":"4e9c3648535dbda64a6f6b7d"},{"problem":"171","code":"(fn [s]\n  (loop [intervals [] prev nil data (sort (into [] (set s)))]\n\t(if (empty? data)\n\tintervals\n\t(do\n\t(let [[head & remaining] data]\n\t(if (= prev (dec head))\n\t(recur (assoc intervals (dec (count intervals)) [(first (last intervals)) head]) head remaining)\n\t(recur (into intervals [[head head]]) head remaining)\n\t))))))","user":"59a0262ee4b0871e7608b82d"},{"problem":"171","code":"(fn [x]\n  \t(let [sx (sort x)\n          ln (atom (first sx))\n          grp (atom 0)\n          okay? #(if (= @ln %)\n                   (do (swap! ln inc) @grp)\n                   (do (reset! ln %) (swap! grp inc) @grp))]\n  \t  (into [] (map #(vector (first %) (last %)) (partition-by okay? (into #{} sx))))))","user":"53aaaf7ae4b047364c044444"},{"problem":"171","code":"(fn interv \n  ( [lst ]\n    (interv lst [] ))\n  ( [lst result]\n    (if-not (first lst) \n      result\n      ( do\n        (println lst result) \n        (if (some true? (map #(<= (first %) (first lst) (last %) ) result ) )\n          (interv (rest lst) result)\n          (interv (rest lst) \n                  (->> result (cons [ (first lst) (first lst) ] ) (sort  ) \n                              (flatten) (#(apply concat (list '( -2000 ) % '( -2000)) )) (partition 2) \n                               (remove #(zero? (- (last %) (first %) 1))) (flatten ) (rest) (partition 2) (map vec)) ) \n        )\n      )\n    )\n  )\n)","user":"528b3f5ae4b0239c8a67ae93"},{"problem":"171","code":"(fn [coll]\n  (let [sorted (sort (set coll))\n        switch (reductions = true (map #(= 1 (- %2 %1)) sorted (rest sorted)))]\n    (->> (map list sorted switch)\n         (partition-by second)\n         (map (partial map first))\n         (map (juxt first last)))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":"171","code":"(fn intervals [s]\n  (loop [n (sort (set s))\n         acc []]\n    (if (empty? n)\n      acc\n      (recur (rest n)\n             (cond (empty? acc) [[(first n) (first n)]]\n                   (= (-> acc last last inc) (first n)) (update-in acc [(dec (count acc)) 1] inc)\n                   :else (conj acc [(first n) (first n)]))))))","user":"5292feb4e4b0239c8a67af39"},{"problem":"171","code":"(fn [coll]\n  (map\n   (juxt first last)\n   (reduce\n    (fn [acc num]\n      (if-let [prev (last acc)]\n        (if (#{0 1} (- num (last prev)))\n          (conj (vec (butlast acc)) (conj prev num))\n          (conj acc (conj [] num)))\n        (conj acc (conj [] num))))\n    []\n    (sort coll))))","user":"4dda44f2535d02782fcbe9f1"},{"problem":"171","code":"(fn intervals [coll]\n  (let [newColl (reduce (fn [r e] (if (= e (last r)) r (conj r e))) [] (sort coll))\n        partitionedColl (reduce (fn [r e] (if (= e (inc (last (last r))))\n                                            (conj (vec (butlast r)) (conj (last r) e))\n                                            (conj r [e])))\n                                [[(first newColl)]]\n                                (rest newColl))]\n    (if (empty? coll)\n      []                                                                                                                                            \n      (map #(list (first %) (last %)) partitionedColl))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"#(letfn [(iv [re cu] (conj re (if (next cu) cu (vector (first cu) (first cu)))))]\n    (loop [[uno & s] (sort %) r [] c []]\n      (cond (empty? %) []\n          (and (nil? uno) (empty? s)) (iv r c)\n          (empty? c) (recur s r [uno])\n          (or (= (last c) uno) (= (last c) (dec uno))) (recur s r [(first c) uno])\n          :else (recur s (iv r c) [uno]))))","problem":"171","user":"4f2d5f5de4b0d6649770a05a"},{"problem":"171","code":"(fn inter [c]\r\n  (if (empty? c) []\r\n    (let [s (sort (set c))]\r\n      (partition 2 (flatten\r\n        [ (first s)\r\n          (filter\r\n            (fn[[a b]] (not= (- b a) 1))\r\n            (partition 2 1 s))\r\n          (last s) ])))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":"171","code":"#(map (juxt first last)\n      (map (partial map second)\n           (partition-by (partial apply -) \n                         (map-indexed vector (distinct (sort %))))))","user":"554680cbe4b0a04f7929953e"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs) xs\n    (let [xs (distinct (sort xs))]\n      (reduce (fn [ret i]\n        (let [[lh ll] (last ret)]\n          (if (= i (+ 1 ll))\n            (conj (pop ret) [lh i])\n            (conj ret [i i]))))\n      [[(first xs) (first xs)]] (rest xs)))))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn intv [col]\n  (let [scol (sort col)]\n    (reduce (fn [ret n]\n              (if (= (last (last ret)) (dec n))\n                (conj (vec (butlast ret)) (vector (first (last ret)) n))\n                (if (or (nil? (last (last ret)))\n                        (> n (last (last ret))))\n                  (conj ret (vector n n))\n                   ret)))\n            [] scol)))","problem":"171","user":"513cb853e4b0b86ece9f322b"},{"code":"#(remove nil?\n   (apply conj\n     (reduce (fn [[acc [st ed :as itv]] x]\n               (cond\n                 (nil? itv) [acc [x x]]\n                 (= x ed) [acc itv]\n                 (= x (inc ed)) [acc [st x]]\n                 :else [(conj acc itv) [x x]]))\n       [[] nil] (sort %))))","problem":"171","user":"527cd633e4b0757a1b17136f"},{"problem":"171","code":"(fn [coll] \n  (if (empty? coll)\n    coll\n    (let [v (sort (distinct coll))\n          red (fn [c x] (if (= x (inc (last c))) (vector (first c) x) (vector x x)))]\n      (map last (partition-by first (reductions red (vector (first v) (first v)) (rest v)))))))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":"171","code":"(fn [coll]\n   (if (not (empty? coll))\n     (let [sorted (sort (into #{} coll))]\n       (->> sorted\n            (partition 2 1)\n            (filter (fn [[a b]] (not= b (inc a))))\n            (#(concat [(first sorted)] % [(last sorted)]))\n            concat\n            flatten\n            (partition 2)))\n     []))","user":"54db3d82e4b024c67c0cf75f"},{"problem":"171","code":"(fn [test-seq] \n   (let [sorted (sort test-seq)] \n     (loop [s (rest sorted) my-min (first sorted) my-max (first sorted) intervals []] \n       (if(empty? s) \n          (do\n            (if (= nil my-min)\n              intervals\n              (conj intervals [my-min my-max]))) \n          (do\n            (if (< (inc my-max)(first s))\n              (do\n                (recur (rest s) (first s) (first s) (conj intervals [my-min my-max])))\n              (recur (rest s) my-min (first s) intervals)))))))","user":"5d824225e4b0915913b1d37f"},{"problem":"171","code":"(fn [se]\n  (let [sse  (sort (set se))\n        parts (partition 2 1 sse)\n        diffs (into [] (map (fn [[v1 v2]] (- v1 v2)) parts))\n        int (interleave sse (conj diffs -1))\n        parts2 (partition-by #(< % -1) int)\n        filt1 (map #(filter pos? %) parts2)\n        filt2 (filter (complement empty?) filt1)]\n   (map #(vector (first %) (last %)) filt2)))","user":"56018dd4e4b04bb52996e18f"},{"problem":"171","code":"(fn s [x]\n   (let [xs (sort x)\n         deltas (map #(if (< (Math/abs (- %1 %2)) 2) %2 [%2\"x\"]) (concat (rest xs) [(last (butlast xs))])  xs)]\n      (->> (flatten deltas)\n           (partition-by #(= \"x\" %1))\n           (filter #(not= (first %1) \"x\"))\n           (map (fn [%1] [(first %1) (last %1)])))))","user":"58983e3fe4b00487982d52ce"},{"problem":"171","code":"(fn [numlist]\n  (if (empty? numlist) []\n      (let [sorted (sort numlist)\n            f (first sorted)\n            r (rest sorted)]\n        (reduce (fn [rangelist newnum]\n                  (let [[_min _max] (last rangelist)]\n                    (cond\n                      (= newnum (inc _max)) (conj (into [] (butlast rangelist)) [_min newnum])\n                      (> newnum (inc _max)) (conj rangelist [newnum newnum])\n                      :else rangelist)))\n                [[f f]] r))))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn [s]\n   (let [coll (sort s)\n         start (first coll)\n         acc {:start start :end start :intervals []}\n         red (reduce (fn [{:keys [start end intervals]} x]\n                   (if (> x (inc end))\n                     {:start x :end x\n                      :intervals (conj intervals [start end])}\n                     {:start start :end x\n                      :intervals intervals})) acc coll)]\n     (if-not (:start red)\n       []\n       (conj (:intervals red) [(:start red) (:end red)]))))","problem":"171","user":"4e9fd521535d7eef3080729a"},{"code":"(fn [coll]\n  (loop [[x y & xs] (sort coll) acc [] item x]\n    (cond \t(nil? x) acc\t\n     \t\t(nil? y) (conj acc [item x])\n            (or (= x y) (= (inc x) y)) (recur (cons y xs) acc item)\n          \t:else (recur (cons y xs) (conj acc [item x]) y))))","problem":"171","user":"4f036d9b535dcb61093f6ac1"},{"problem":"171","code":"(fn [x] (letfn [\n(break [ [f s & r] ]\n (loop [ f f, s s, r r, c [f], ans [] ]\n   (cond (nil? s) (conj ans (conj c f))\n        (> 2 (- s f)) (recur s (first r) (rest r) c ans)\n        :else (recur s (first r) (rest r) [s] (conj ans (conj c f))))))]\n(if (> 2 (count x)) x (break (sort x)))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn f [s]\n  (if (= s [])\n    s\n    (let [m (apply min s)\n          i #(range m %)\n          r (fn [n] (if (= (filter (set s) (i n)) (i n))\n                      (recur (+ n 1))\n                      n))\n          n (r m)]\n      (cons [m (- n 2)] (f (remove (set (i n)) s))))))","problem":"171","user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn ivs [s]\n  (let [[a & ss] (distinct (sort s))]\n    (cond\n     (nil? a) []\n     (empty? ss) [[a a]]\n     :else (reverse\n            (reduce (fn [[[x y] & r :as pairs] z]\n                      (if (= z (inc y))\n                        (conj r [x z])\n                        (conj pairs [z z])))\n                    [[a a]]\n                    ss)))))\n\n; Notes\n; - maintain a list of intervals where the last one is only a candidate, its end can be updated\n; - given [x & xs], start with [[x x]]\n; - reduce against xs with a function that compares each successive number against the candidate pair","problem":"171","user":"52d3f666e4b09f7907dd1327"},{"code":"(fn ff [s]\n  (letfn [(f1 [s] \n            (loop [k (first s) \n                   r 1 \n                   s (next s)] \n              (if (or (= s nil) (not= (inc k) (first s))) \n                r \n                (recur (inc k) (inc r) (next s)))))]\n    (loop [s (seq (set s)) res []]\n      (if (= s '())\n        (if (= (first res) [nil nil]) \n          []\n          res)\n        (let [l (f1 s) \n              k1 (take l s)\n              k (if (= l 0) \n                  []\n                  [(first k1) (last k1)])]\n          (recur (drop l s) (conj res k)))))))","problem":"171","user":"50a5f72fe4b0aa96157e2611"},{"problem":"171","code":"(fn [coll]\n  (if-not (seq coll)\n    []\n    (loop [[[a b] & xs :as all] (->> coll distinct sort (partition 2 1))\n           tmp (vec (repeat 2 (first (sort coll))))\n           ans []]\n      (cond\n       (not (seq all)) (conj ans tmp)\n       (= (inc a) b) (recur xs [(first tmp) b] ans)\n       :else (recur xs [b b] (conj ans tmp))))))","user":"5cb41c40e4b026601754b911"},{"code":"(fn\n  [vs]\n  (let [vs (distinct (sort vs))\n        pt (partition 2 1 vs) ; partition in two with step 1\n        cnt (count vs)]\n    (cond\n     (=  1 cnt) [[(first vs) (first vs)]]\n     (=  0 cnt) []\n     :d (reduce\n         (fn [sm [a b]]\n           (let [c (count sm)]\n             (if (or (= a b) (= (inc a) b))\n               (if (empty? (last sm))       ; Updating interval\n                 (assoc-in sm [(dec c)] [a b])\n                 (assoc-in sm [(dec c) 1] b))\n               (assoc-in sm [c] [b b]))))\n         [[]]\n         pt))))","problem":"171","user":"51852961e4b0da5a5be3babb"},{"problem":"171","code":"(fn interval [coll]\n  (if (empty? coll) []\n\t  (let [\n            ss (apply sorted-set coll) \n            s-min (first ss) \n            s-max (last ss) \n            s-missing (first (filter (complement ss) (range s-min (inc s-max))))]\n        (if (nil? s-missing) \n          (list [s-min s-max]) \n          (cons [s-min (dec s-missing)] (interval (filter (partial < s-missing) ss)))))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"code":"(fn [v]\n  (let [nums (sort (distinct v))]\n    (reduce #(if (and (seq %) (= %2 (inc (second (last %)))))\n               (concat (drop-last %) [[(first (last %)) %2]])\n               (concat % [[%2 %2]]))\n            []\n            nums)))","problem":"171","user":"51e38568e4b0c611d6113e43"},{"problem":"171","code":"(fn intervals [xs]\n  (reduce \n    (fn [acc x] \n      (cond (empty? acc) [[x x]]\n            (= (->> acc last last) x) acc\n            (= (->> acc last last) (dec x)) \n              (let [[a b] (peek acc)]\n                (conj (pop acc) [a (inc b)]))\n            :else, (conj acc [x x])))\n    []\n    (sort xs)))\n\n;#(map vector (% %2 dec) (% %2 inc))\n;#(reduce (fn [acc x] \n;           (if ((set %) (%2 x)) acc (conj acc x))) \n;         [] \n;         (sort (set %)))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":"171","code":"(fn [coll]\n  (let [c (sort (distinct coll))\n        f (fn [[[a b] & r :as all] v]\n            (if (= (dec v) b) \n              (cons [a v] r)\n              (cons [v v] all)))]\n    (reverse (reduce f () c))))","user":"56ae214ce4b03c432f18735a"},{"problem":"171","code":"(fn intervals [coll]\n  (letfn [(increment-pattern [xs f]\n            (let [ls (last xs) l (last ls)]\n              (if (or (= (inc l) f) (= l f))\n                (conj (pop xs) (conj ls f))\n                (conj xs [f]))))]\n    (if (not (seq coll))\n      []\n      (let [c (sort coll)]\n        (map (fn [xs]\n               [(first xs) (last xs)])\n             (reduce #(increment-pattern % %2) [[(first c)]] (rest c)))))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":"171","code":"(fn [xs]\n  (let [xs (-> xs sort distinct)]\n    (loop [a (first xs)\n           b (first xs)\n           xs (rest xs)\n           acc []]\n      (if (empty? xs)\n        (if (nil? a) acc (conj acc [a b]))\n        (let [[f & r] xs]\n          (if (or (= b f) (= b (dec f)))\n            (recur a f r acc)\n            (recur f f r (conj acc [a b]))))))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":"171","code":"(fn [s]\n  (let\n    [d (set (map dec s))\n     a (set (map inc s))]\n    (map\n     vector\n     (into (sorted-set) (remove a s))\n     (into (sorted-set) (remove d s)))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn intervals [coll]\n  (let [c (sort coll)]\n    (cond\n     (empty? coll) []\n     :else\n\t(reduce (fn [x y]\n          (cond\n               (>= (- y (last (last x))) 2) (conj x [y y])\n               :else (conj (vec (butlast x)) [(first (last x)) y])))\n        [[(first c)]] (rest c))\n\t )))","problem":"171","user":"52140b53e4b0961f15ac4d7e"},{"code":"#(reverse\n    (reduce (fn [res i]\n                (let\n                  [[a b] (first res) fixed (rest res)]\n                    (if (and b (< i (+ b 2)))\n                      (conj fixed [a i])\n                      (conj res [i i]))))\n   '() (sort %)))","problem":"171","user":"4ec0c7ba535dfed6da9c6da4"},{"problem":"171","code":"(fn [xs]\n  (reduce\n   (fn [m k]\n     (let [i (first (last m))\n           j (last (last m))]\n       (cond\n         (or (nil? j) (< (inc j) k)) (conj m [k k])\n         (= j k) m\n         :else (conj (into [] (butlast m)) [i k]))))\n   [] (sort xs)))","user":"54c5cc17e4b045293a27f624"},{"problem":"171","code":"(fn intervals [s]\n  (let [mrg (fn [[a1 a2] [b1 b2]]\n\t\t\t  (if (= (inc a2) b1) [[a1 b2]] [[b1 b2] [a1 a2]]))\n        [f & r] (->> (sort s) distinct (map #(vector % %)))] \n    (if (seq s)\n      \t(reverse (reduce (fn [[f & r] i] (concat (mrg f i) r)) (list f) r))\n       \t[])))","user":"53b39d82e4b047364c0444a6"},{"problem":"171","code":"(fn [seq]\n   (if (empty? seq)\n     seq\n     (loop [seq (sort (distinct seq)) temp 0 res []]\n       (if (empty? seq)\n         (conj (vec (drop-last res)) [temp (last res)])\n         (if (number? (last res))\n           (if (= (last res) (dec (first seq)))\n             (recur (rest seq) temp (conj (vec (drop-last res)) (inc (last res))) )\n             (recur (rest seq) (first seq) (conj (conj (vec (drop-last res)) [temp (last res)]) (first seq))))\n           (recur (rest seq) (first seq) (conj res (first seq))))))))","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn [c]\n  (->>\n    (map list (sort (set c)) (range))\n    (partition-by #(apply - %))\n    (map #(list (ffirst %) (first (last %))))))","problem":"171","user":"52b453b0e4b0c58976d9ad21"},{"problem":"171","code":"(fn get-intervals [int-seq]\n  (if (empty? int-seq)\n    []\n    (let [ord-int-seq (sort int-seq)]\n      (reduce (fn [curr v]\n                (let [crnt-rng (last curr)\n                      curr-cnt (count curr)]\n                  (if (empty? crnt-rng)\n                    (assoc curr (- curr-cnt 1) [v v])\n                    (let [last-val (last crnt-rng)\n                          in-range? (or (= last-val v) (= (+ 1 last-val) v))]\n                      (if in-range?\n                        (assoc curr (- curr-cnt 1) (assoc crnt-rng (- (count crnt-rng) 1) v))\n                        (conj curr [v v]))))))\n              [[]]\n              ord-int-seq))))","user":"5508b405e4b06e50f9beb110"},{"problem":"171","code":"(fn my-interval [a]\n  (if (empty? a)\n    []\n    (let [sa (sort a)]\n      (loop [c [(first sa) (first sa)] intervals [] vs (rest sa)]\n        (if (empty? vs)\n          (conj intervals c)\n          (let [[low high] c n (first vs)]\n            (cond\n              (= high n) (recur c intervals (rest vs))\n              (= (inc high) n) (recur [low n] intervals (rest vs))\n              :else (recur [n n] (conj intervals c) (rest vs)))))))))","user":"5843b95de4b089d5ab817e3f"},{"code":"(letfn [(intervals [coll]\n          (loop [[x & xs] (sort coll)\n                 [y & ys :as acc] '()]\n            (cond\n              (nil? x) (reverse acc)\n              (nil? y) (recur xs (cons [x] acc))\n              (<= (- x (last y)) 1) (recur xs (cons (conj y x) ys))\n              :else    (recur xs (cons [x] acc)))))]\n  (fn [coll] (->> coll\n                  intervals\n                  (map (juxt first last)))))","problem":"171","user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":"171","code":"(fn [c]\n            (reduce (fn [r x]\n                      (if (or (empty? r) (> x (inc (last (last r)))))\n                        (conj r [x x])\n                        (if (= x (inc (last (last r))))\n                          (assoc r (- (count r) 1)\n                                        (assoc (last r) (- (count (last r)) 1) x))\n                          r)))\n                    [] (sort c)))","user":"5e1c3e6ee4b0dc9594008530"},{"code":";; kind of ugly since I changed techniques midway through\n;; should revisit...\n(fn [nums] \n  (let [combine-interval\n        (fn combine-interval [intervals num] \n          (if (seq intervals)\n            (let [head (first intervals) \n                  tail (rest intervals)\n                  [lo hi] head]\n              (cond\n                 (= num hi)\n                 intervals\n\n                 (= num (inc hi))\n                 (cons [lo num] tail)\n\n                 :else\n                 (cons [lo hi] \n                       (combine-interval tail num))))\n            [[num num]]))]\n\n    (reduce combine-interval [] (sort nums))))","problem":"171","user":"4f0d093b535d0136e6c22313"},{"problem":"171","code":"(fn intervals \n  ([coll] \n   (let [coll (sort coll)\n         fst (first coll)] \n     (if (empty? coll)\n       []\n       (intervals fst fst (rest coll)))))\n  ([start prev coll] \n   (if (empty? coll)\n     [[start prev]]\n     (let [fst (first coll)]\n       (if (>= (inc prev) fst)\n         (recur start fst (rest coll))\n         (lazy-seq (cons [start prev] (intervals fst fst (rest coll)))))))))","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(comp\n  (partial map (fn [x] [(first x) (last x)]))\n  (partial filter (partial not= [nil]))\n  reverse\n  #(reduce\n    (fn [x y]\n      (if (= (dec y) (last (first x)))\n        (conj (rest x) (conj (first x) y))\n        (conj x (vector y))))\n    (list (vector (first %)))\n    (rest %))\n    sort\n    set)","problem":"171","user":"5201572be4b0d7096e99ddbb"},{"problem":"171","code":"(fn intervals ([coll] (map #(vector (first %) (last %)) (intervals [] [] (sort coll))))\n  \t\t\t  ([res cur coll] (if (empty? coll) \n                                  (if (empty? cur) \n                                      res \n                                      (conj res cur)) \n                                  (if (empty? cur) \n                                      (intervals res (conj cur (first coll)) (rest coll)) \n                                      (if (or (= (inc (last cur)) (first coll)) (= (last cur) (first coll)))\n                                          (intervals res (conj cur (first coll)) (rest coll)) \n                                          (intervals (conj res cur) [] coll))))))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn [c] (if (empty? c) [] (map #(vector (first %) (last %)) (take-nth 2 (let [s (sort c)] (partition-by #(= (.indexOf s %) -1) (range (first s) (inc (last s)))))))))","problem":"171","user":"51f66e0ee4b06ff1c25c52c3"},{"problem":"171","code":"(fn q4q171\n  [s]\n  \"Intervals\"\n  (reduce\n   (fn\n     ([] [])\n     ([a b]\n      (cond\n        (number? a) (conj [] [a b])\n        (> b (-> a last second inc)) (conj a [b b])\n        :default (assoc a\n                        (-> a count dec)\n                        (assoc (get a (-> a count dec)) 1 b)))))\n   (sort s)))","user":"52213426e4b0e6a83c8925c4"},{"problem":"171","code":"(fn [vs]\n  (if (empty? vs)\n    []\n    (let [svs (sort vs) start (first svs)]\n      (reduce\n        (fn [out nxt]\n          (let [[x1 x2] (last out)]\n            (cond\n              (= x2 nxt) out\n              (= (inc x2) nxt) (assoc out (dec (count out)) [x1 nxt])\n              :else (conj out [nxt nxt]))))\n        [[start start]]\n        (rest svs)))))","user":"564a5a09e4b0284900eef656"},{"code":"(fn f [es]\n  (letfn [(intervalize [[int & ints :as all_ints] [e & es]]\n                       (if e \n                         (if int \n                           (let [[int-start int-end] int]\n                             (if (= int-end (dec e))\n                               (intervalize (cons [int-start e] ints) es)\n                               (intervalize (cons [e e] all_ints) es))) \n                           (intervalize [[e e]] es)) \n                         (reverse all_ints)))]\n    (->> es (distinct) (sort) (#(intervalize [] %)))))","problem":"171","user":"506617c3e4b03d366d7cb2ab"},{"problem":"171","code":"(fn [s]\n  (if (empty? s)\n    s\n  (loop [ans '() start (first (sort s)) current (first (sort s)) tmps (rest (sort s))]\n    (if (empty? tmps)\n      (reverse (conj ans (conj (conj '() current) start)))\n      (if (or (= current (first tmps)) (= (inc current) (first tmps)))\n        (recur ans start (first tmps) (rest tmps))\n        (recur (conj ans (conj (conj '() current) start)) (first tmps) (first tmps) (rest tmps)))))))","user":"59368ccae4b02506e01a297a"},{"problem":"171","code":"(fn [s] (let [s (set s)]\n          (if (empty? s)\n            []\n            (->> (partition-by #(contains? s %) (range (inc (apply max s))))\n                 (map #(apply (juxt min max) %))\n                 (filter #(contains? s (first %)))))))","user":"56b86e64e4b0f26550335924"},{"problem":"171","code":"(fn ivs [coll]\n  (let [sorted (sort (distinct coll))]\n    (if (empty? sorted)\n      []\n      (reduce (fn [acc v] \n                (if (= v (inc (last (last acc))))\n                  (conj (vec (butlast acc)) [(first (last acc)) v])\n                  (conj (vec acc) [v v])))\n              [[(first sorted) (first sorted)]]\n              (rest sorted)))))","user":"5339c105e4b0e30313ee6cae"},{"code":"(fn interv[v]\r\n  (let [u (sort (distinct v))\r\n        u1 ((group-by (fn [arg](some #(= (dec arg) %) u)) u) nil)\r\n        u2 ((group-by (fn [arg](some #(= (inc arg) %) u)) u) nil)]\r\n    (map #(vector %1 %2) u1 u2)))","problem":"171","user":"5065bd94e4b0148eb3925aed"},{"problem":"171","code":"(fn seqs [coll]\n  (let [c (sort coll)]\n    (if (empty? c)\n        c\n        (->> (map list c (rest c))\n             (filter (fn [[a b]] (< a (dec b))))\n             (flatten)\n             (#(concat [(first c)] % [(last c)]))\n             (partition 2)))))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"(fn [s]\n    (->> s distinct sort\n         (reduce #(let [dec-val (dec %2)\n                        curr-range (last %)\n                        range-start (when (= dec-val (last curr-range)) (first curr-range))]\n                    (if range-start\n                      (conj (vec (drop-last %)) [range-start %2])\n                      (conj % [%2 %2])))\n                 [])))","problem":"171","user":"524b0645e4b09eba1c0223bf"},{"code":"(fn [s]\n  (let \n    [F (fn [[ivs r]]\n           (let [iv (take-while (fn [[f s]] (<= (dec s) f)) r)]\n             [(conj ivs [(first (first iv)) (last (last iv))])\n              (drop (inc (count iv)) r)]))]\n    (->> s\n      (concat s)\n      (sort)\n      (partition 2 1)\n      (vector [])\n      (iterate F)\n      (drop-while #(not (empty? (second %))))\n      (first)\n      (first))))","problem":"171","user":"5061cc17e4b0a30dc9a35d34"},{"problem":"171","code":"(fn [x] (map #(vector (first %) (last %)) (into [] (map #(into [] %)(map #(map last %)  (partition-by #(apply - %) (map-indexed  vector  (sort (distinct x)))))))))","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":"171","code":"(fn intervals [ns]\n  (letfn [(update-intervals [n is]\n            (if (seq is)\n              (let [[imin imax] (first is)]\n                (cond\n                  (< n (dec imin)) (cons [n n] is)\n                  (= n (dec imin)) (cons [n imax] (rest is))\n                  (<= n imax) is\n                  (= n (inc imax)) (cons [imin n] (rest is))\n                  :else (lazy-seq (cons (first is) (update-intervals n (rest is))))))\n              (list [n n])))\n          (merge-intervals [is]\n             (if (and (seq is) (seq (rest is)))\n               (let [[i1min i1max] (first is)\n                     [i2min i2max] (first (rest is))]\n                 (if (or (= i1max i2min)\n                         (= i1max (dec i2min)))\n                   (lazy-seq (merge-intervals (cons [i1min i2max] (rest (rest is)))))\n                   (lazy-seq (cons (first is) (merge-intervals (rest is))))))\n               is))]\n    (if (seq ns)\n      (lazy-seq (merge-intervals\n                 (update-intervals (first ns) (intervals (rest ns)))))\n      ns)))","user":"54ca93abe4b057c6fda3a264"},{"problem":"171","code":"(fn __ [ints]\n  (letfn [(test [one two] (or (= (inc one) two) (= one two)))\n          (reducer [[result start] [current next]]\n           (cond\n             (not start) (if (test current next)\n                           [result current]\n                           [(conj result [current current]) nil])\n             (test current next) [result start]\n             :else  [(conj result [start current]) nil]))]\n   (->> ints sort (partition-all 2 1) (reduce reducer [[] nil]) first)))","user":"55a62092e4b0acc240e31554"},{"problem":"171","code":"(fn intervals [seq]\n  (letfn [(take-consec\n            ([s] (take-consec s []))\n            ([s acc] (let [h (first s)\n                           t (rest s)]\n                       (if (nil? (first t))\n                         [(conj acc h ) t] \n                         (if (or (nil? h) (nil? (first t)))\n                           acc\n                           (if (>= 1 (- (first t) h))\n                             (take-consec t (conj acc h))\n                             (list (conj acc h) t)))))))\n          (consec-consume\n            ([s] (consec-consume s []))\n            ([s acc] (if (empty? s)\n                       s\n                       (let [r (take-consec s)\n                             c (first r)\n                             t (second r)]\n                         (if (empty? t)\n                           (conj acc c)\n                           (consec-consume t (conj acc c)))))))]\n    (map #(list (first %) (last %)) (consec-consume (sort seq)))))","user":"587ee260e4b052da650a6353"},{"code":"(fn [nums]\n  (if (empty? nums) []\n      (let [nums (sort nums)\n            head (first nums)\n            tail (rest nums)]\n        (loop [nums tail\n               cval [head head]\n               ivals []]\n          (if (empty? nums) (conj ivals cval)\n              (let [head (first nums)\n                    tail (rest nums)\n                    prev (second cval)\n                    [cval ivals] (if (or (= head (inc prev)) (= head prev))\n                                    [[(first cval) head] ivals]\n                                    [[head head] (conj ivals cval)])]\n                (recur tail cval ivals)))))))","problem":"171","user":"524ae8e6e4b09eba1c0223b5"},{"problem":"171","code":"(fn [v]\n  (letfn [(segment [prev accum rst]\n            (if (empty? rst) [accum]\n                (let [cur (first rst)]\n                  (cond (or (nil? prev) (= (inc prev) cur)) (segment cur (conj accum cur) (rest rst))\n                        (= prev cur) (segment cur accum (rest rst))\n                        :else (cons accum (segment cur [cur] (rest rst)))))))]\n    (if (empty? v) []\n        (map (fn [seg] [(first seg) (last seg)]) (segment nil [] (sort v))))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":"171","code":"(fn [l] (reduce (fn [acc n] (cond (or (empty? acc) (> n (inc ((last acc) 1)))) (conj acc [n n]) (= (inc ((last acc) 1)) n) (conj (vec (butlast acc)) [((last acc) 0) n]) )) [] (set (sort l))))","user":"53b2a7f8e4b047364c04449c"},{"problem":"171","code":"(fn\n  [b]\n                                                          (reduce \n    (fn [c x]\n      (let [[s e] (last c)]\n        (if (= e (- x 1))\n          (conj (vec (drop-last c)) [s x])\n          (conj c [x x]))))\n    [] (apply sorted-set b)))","user":"541735b3e4b01498b1a71a07"},{"code":"(fn [x] ( map (fn [z] ( vector (first z) (last z)) ) (let [\n\tst (sort-by identity x)\n\tf (vector (vector (first st)))\n\tr (rest st)\n   ] (if (empty? x) [] ( (fn f1 [ff rr] ( if (empty? rr) ff (let [\n\t\tlst (last (last ff))\n\t\tfrs (first rr)\n\t\tres (rest rr)\n\t\tgt (> (- frs lst) 1 )\n\t\tcnj (conj (into [] ff) (vector (first rr)))\n\t\tcnj2 (conj (into [] (drop-last ff)) (into [] (conj (last ff) (first rr))))\n   ] (if gt  (f1 cnj (rest rr)) (f1 cnj2 (rest rr)) ) )\n   )) f r)) \n    )))","problem":"171","user":"5296008fe4b02ebb4ef7502a"},{"code":"(fn [col]\n  (let [memlast (atom 0)\n        retval (atom 0)]\n    \n  (map #(vector (first %) (last %))\n  \n    (partition-by\n      (fn [x]\n        (when (not (== (inc @memlast) x)) (swap! retval inc))\n        (compare-and-set! memlast @memlast x)\n        @retval) \n      (set (sort col)))\n       )))","problem":"171","user":"4f05a9cf535dcb61093f6bfc"},{"code":"(fn [ns]\n  (if (empty? ns)\n    []\n    (let [ss (sort (distinct ns))]\n      (loop [ans [], start (first ss), current (first ss), rs (rest ss)]\n        (if (empty? rs)\n          (conj ans [start current])\n          (if (= (inc current) (first rs))\n            (recur ans start (inc current) (rest rs))\n            (recur (conj ans [start current]) (first rs) (first rs) (rest rs))))))))","problem":"171","user":"506ab9bae4b05d3b7762c74c"},{"problem":"171","code":"(fn [xs]\n  (reduce (fn [[[a b] & more] n]\n            (cond (not a)       [[n n]]\n                  (< n (dec a)) (conj more [a b] [n n])\n                  :else         (conj more [n b])))\n          '()\n          (sort (comparator >) xs)))","user":"59eb63e3e4b0249b7282077c"},{"problem":"171","code":"(fn [x] \n  (let\n   [[h & t] (sort x)\n    [agg start end] (reduce\n                     (fn [[agg start end] next]\n                       (if (<= next (+ end 1))\n                         [agg start next]\n                         [(conj agg [start end]) next next]))\n                     [[] h h] t)]\n    (if start (conj agg [start end]) [])))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn intervals\n  [xs]\n  \"even more interesting, comparing if the nums \n  above & below are in the set and filtering by that!\"\n  ((fn [a]\n     (let [a (-> a set sort)\n           s (set a)]\n       (partition 2\n                  (interleave\n                   (filter #(not (s (dec %))) a)\n                   (filter #(not (s (inc %))) a))))) xs))\n;(fn intervals\n;  [xs]\n;  (let [adjacent? (fn [[a b]] (or (= a (inc b)) (= (inc a) b)))]\n;    (->> xs\n;         (sort)\n;         (distinct)\n;         (#(if (= 1 (count %)) [(first %) (first %)] %))\n;         (partition 2 1)\n;         (map #(if (adjacent? %) % (second %)))\n;         (partition-by #(if (seq? %) (seq? %) %))\n;         (map #(if (> (count %) 1) ((juxt first last) (apply concat %)) (cons (first %) %)))\n;         (reverse)\n;         (reduce (fn [res [a b]]\n;                   (if (and (sequential? (first res))\n;                            (= b (ffirst res)))\n;                     res\n;                                   (cons [a b] res))) [])\n;         )))","problem":"171","user":"524f4256e4b0541d1855b808"},{"problem":"171","code":"(fn lol \n  ([c] (if (empty? c) [] (map \n  #(vec (conj [(first %)] (last %)))\n  \n    (take-nth 2 (partition-by\n      #(contains? (set c) %)\n      (range (apply min c) (inc (apply max c)))))\n  )))\n)","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn [x]\n  (if (empty? x)\n  []\n  (let [coll (sort (set x))\n      interval (range (first coll) (inc (last coll)))\n      difference (filter #(not (contains? (set coll) %)) interval)]\n  (map #(vector (first %) (last %)) (partition-by (fn [n] (first (filter #(> % n) difference))) coll))\n)))","problem":"171","user":"529d4f4be4b04e0c58e87b79"},{"code":"(fn [coll]\n  (let [n (vec (sort coll))\n        m (partition 2 1 (conj n (peek n)))\n        one? (fn [[f s]] (<= (- s f) 1))]\n    (mapcat\n     (fn [s] \n       (if (one? (first s))\n          [[(ffirst s) (second (last s))]]\n          (let [p (partition 2 1 s)] \n            (map (fn [[p1 p2]] [(second p1) (first p2)]) p)))) (partition-by one? m))))","problem":"171","user":"4e8e8c24535d65386fec2143"},{"problem":"171","code":"(fn [l]\n  (reverse (loop [xs (distinct (sort l))\n                  r []]\n             (if (empty? xs)\n               r\n               (recur (rest xs)\n                      (if (empty? r)\n                        [[(first xs) (first xs)]]\n                        (if (= (inc (second (first r))) (first xs))\n                          (cons [(first (first r)) (first xs)] (rest r))\n                          (cons [(first xs) (first xs)] r))))))))","user":"4dc1ee85535d020aff1edf91"},{"code":"(fn [w] (letfn [(fa [v] (map #(map second %) \n            (partition-by (fn [x] (first x)) (map vector (map - v (range)) v))))]\n          (->> w sort distinct fa\n               (map #(vector (first %) (last %)))\n               )\n          )\n  )","problem":"171","user":"517945dce4b0684c1c981a43"},{"code":"(fn [num-seq]\n  (if (seq num-seq)\n    (let [sorted-num-seq (sort num-seq)\n          partited-num-seq (partition-by\n                             #(<= (- (last %) (first %)) 1)\n                             (partition 2 1 (concat (cons (first sorted-num-seq) sorted-num-seq) [(last sorted-num-seq)])))]\n      (letfn [(step [coll]\n                (if (seq coll)\n                  (let [ele (first coll)\n                        first-group (first ele)]\n                    (if (<= (- (last first-group) (first first-group)) 1)\n                      (let [flatten-ele (flatten ele)]\n                        (cons [(first flatten-ele) (last flatten-ele)] (step (next coll))))\n                      (let [uncontinue-ele (apply sorted-set (drop-last (next (flatten ele))))]\n                        (if uncontinue-ele\n                          (concat (map #(vec [% %]) uncontinue-ele) (step (next coll)))\n                          (concat [] (step (next coll)))))))\n                  []))]\n        (step partited-num-seq)))\n    []))","problem":"171","user":"514d7e29e4b019235f6c0587"},{"problem":"171","code":"(fn [c]\n     (letfn [(s [coll]\n              (reduce\n               #(if (empty? %1)\n                  [[%2]]\n                  (if (= %2 (inc (last (last %1))))\n                     (conj (vec (butlast %1)) [(first (last %1)) %2])\n                     (conj %1 [%2]))) [] coll))]\n      (map (fn [a] [(first a) (last a)]) (s (distinct (sort c))))))","user":"54908cc1e4b0b312c081ff32"},{"problem":"171","code":"(fn [nums]\n  (->> nums\n       (sort)\n       (reduce (fn [ranges n]\n                 (let [[s e] (last ranges)]\n                   (if (and s (<= (- n e) 1))\n                     (conj (pop ranges) [s n])\n                     (conj ranges [n n]))))\n               [])))","user":"5f37263de4b0574c87022c4e"},{"code":"(fn p171 [col]\n   (let [sorted-col (sort col)]\n    (loop [accu [] start (first sorted-col)  end (first sorted-col)  subcol (rest sorted-col) ]\n      (if (empty? subcol)\n          (if (nil? start) accu (conj accu [start end]) )\n          (cond\n              (=  end (first subcol))  (recur accu start end (rest subcol))\n              (= (inc end) (first subcol)) (recur accu start (inc end) (rest subcol))\n              :else   (recur (conj accu [start end]) (first subcol) (first subcol)   (rest subcol))\n            )\n        )\n      )\n\n     )\n   )","problem":"171","user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [k] (if (empty? k) []                                                                                                                                                                               \n                  (let [z (distinct (sort k))]                                                                                                                                                                  \n                    (loop [acc [[(first z) (first z)]] l (rest z)] (if (empty? l) acc                                                                                                                           \n                                                 (let [last-seen (last (last acc)) first-seen (first (last acc)) next-element (first l)]                                                                        \n                                                   (if (= (inc last-seen) next-element)                                                                                                                         \n                                                     (if (and (= last-seen first-seen) (= 2 (count (last acc))))                                                                                                \n                                                     (recur (conj (into [] (drop-last acc)) (conj [last-seen] next-element)) (rest l))                                                                          \n                                                     (if (= 1 (count (last acc)))                                                                                                                               \n                                                       (recur (conj (into [] (drop-last acc)) (conj (last acc) (first l))) (rest l))                                                                            \n                                                       (recur (conj (into [] (drop-last acc)) (conj [first-seen] (first l))) (rest l))))                                                                        \n                                                   (recur (conj acc [(first l) (first l)]) (rest l)))))))))","problem":"171","user":"52265e41e4b04e78ff2e1981"},{"problem":"171","code":"(fn intervals\n  [coll]\n  (loop [my-coll (distinct (sort coll))\n         current-interval []\n         my-intervals []]\n    (cond\n      (and (empty? my-coll) (empty? current-interval)) my-intervals\n      (empty? current-interval) (recur (rest my-coll) (conj current-interval (first my-coll)) my-intervals)\n      (= (first my-coll) (inc (last current-interval))) (recur (rest my-coll) (conj current-interval (first my-coll)) my-intervals)\n      :else (recur my-coll [] (conj my-intervals [(first current-interval) (last current-interval)])))))","user":"60396c95e4b0d5df2af222f4"},{"code":"(fn [col]\n   (let [col (vec (set col))]\n     (loop [[h & r] (rest col)\n            s (first col)\n            l (first col)\n            acc []\n            ]\n       (if-not (nil? h)\n           (if (= (- h l) 1)\n             (recur r s h acc)\n             (recur r h h (conj acc [s l]))\n             )\n           (if (and (nil? s) (nil? l))\n             []\n             (conj acc [s l])\n             )))\n     ))","problem":"171","user":"503ca47fe4b06c4e0e1fa24f"},{"problem":"171","code":"(fn [input]\n      (reverse (reduce (fn[intervals num]\n                  (if (empty? intervals)\n                      (cons [num num] intervals)\n                      (let [lastInterval (last (first intervals))\n                            firstInterval (first (first intervals))\n                            currentDiff (- num lastInterval)\n                            ]\n                          (if (>= 1 currentDiff) (cons [firstInterval num] (rest intervals))\n                              (cons [num num] intervals))\n                          )))\n                          [] (sort input))))","user":"571172ece4b09c608db70446"},{"problem":"171","code":"(fn invals\n  ([col]\n   (let [col (sort col)]\n     (invals col (first col))))\n  ([col start]\n   (let [col-count (count col)]\n    (cond\n      (= col-count 0) []\n      (= col-count 1) [[start (first col)]]\n      :else\n      (let [[l r] col\n            [_ & other] col]\n        (if (< 1 (- r l))\n          (cons [start l] (invals other r))\n          (invals other start)))))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":"171","code":"(fn itvls [xs]\n  (if (seq xs)\n    (let [[x & xs] (sort xs)\n          [i is] (reduce (fn [[[a b] is] x]\n                           (if (<= x (inc b))\n                               [[a x] is]\n                               [[x x] (conj is [a b])]))\n                         [[x x] []]\n                         xs)]\n      (conj is i))\n    []))","user":"548fa2dfe4b0e286459a1240"},{"code":"(fn [in-seq]\n  (loop [xs (into (sorted-set) in-seq)\n          current-start nil\n          current nil\n          result []]\n    (if (empty? xs)\n      (if current-start\n        (conj result [current-start current])\n        result)\n      (if current\n        (if (= (inc current) (first xs))\n          (recur (rest xs) current-start (inc current) result)\n          (recur (rest xs) (first xs) (first xs) (conj result [current-start current])))\n        (recur (rest xs) (first xs) (first xs) result)))))","problem":"171","user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":"171","code":"(fn [xs]\n   (map #(list (first %) (last %))\n   (reduce (fn [acc e] (print acc)\n             (cond (= (last (last acc)) (dec e))\n                       (conj (vec (butlast acc)) (conj (last acc) e))\n                       (= (last (last acc))  e)\n                       acc\n                       :else\n                       (conj acc [e]))\n\n               )\n   [] (sort xs))))","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn [xs]\n  (let [llast #(last (last %))\n        add-to-last (fn [xs x] (conj (vec (butlast xs)) (conj (last xs) x)))\n        ends (fn [xs] [(first xs) (last xs)])]\n    (->> xs\n         (sort)\n         (distinct)\n         (reduce (fn [xs x]\n                   (let [prev (llast xs)]\n                     (if (and prev (= (inc (llast xs)) x))\n                       (add-to-last xs x)\n                       (conj xs [x]))))\n                 [[]])\n         (remove empty?)\n         (map ends)\n         )))","problem":"171","user":"5312cdaae4b08068f379ed03"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [coll (sort coll)]\n      (loop [result [] current [(first coll) (first coll)] coll coll]\n        (if (empty? coll)\n          (conj result current)\n          (let [[elem & remains] coll]\n            (if (> elem (inc (last current)))\n           \t  (recur (conj result current) [elem elem] remains)\n              (recur result [(first current) elem] remains)))))\n        )))","user":"563a30d7e4b0bfe05bf117f9"},{"problem":"171","code":"(fn [s]\n  (let [s (apply sorted-set s)]\n    (map vector \n     (remove #(s (dec %)) s)\n     (remove #(s (inc %)) s)))) ;; not mine. so smart","user":"5a527beee4b05d388ecb6bfe"},{"problem":"171","code":"(fn intervals [x]\n  (reduce #(if (or (= %2 (last (last %1))) (= (dec %2) (last (last %1))))\n             (conj (apply vector (butlast %1)) [(first (last %1)) %2])\n             (conj (apply vector %1) [%2 %2]))\n          []\n          (sort (distinct x))))","user":"4f6ba7bce4b07046d9f4efb0"},{"problem":"171","code":"(fn intervals [s]\n  (if (empty? s)\n    []\n    (let [sorted (apply sorted-set s),\n          [istart iend intervals]\n          (reduce (fn [[istart iend intervals] x]\n                    (if (> x (inc iend))\n                      [x x (conj intervals [istart iend])]\n                      [istart x intervals]))\n                  [(first sorted) (first sorted) []] (rest sorted))]\n      (conj intervals [istart iend]))))","user":"5e9c11f8e4b0157ca96647f6"},{"problem":"171","code":"(fn f [x]\n  (let [c (sort (distinct x))]\n    (map #(vector (first %) (last %))\n      (map (partial map first) \n        (partition-by second \n                     (map list c \n                          (reductions not= true \n                                      (map #(> (- %2 %) 1) c (rest c)))))))))","user":"51dd5d6fe4b0c33a4e1da406"},{"code":"(let [consecutives (fn [s]\n                     (let [sorted-s (sort s)]\n                       (reduce (fn [acc valu]\n                                 (if (or (empty? acc)\n                                         (> (dec valu) (last (last acc))))\n                                   (conj acc [valu])\n                                   (conj (pop acc) (conj (peek acc) valu))))\n                               []\n                               sorted-s)))]\n  (fn [s]\n    (map (fn [part]\n           [(first part) (last part)]) \n         (consecutives s))))","problem":"171","user":"51789dfae4b03d69594194d7"},{"problem":"171","code":"#(reduce (fn [a x]\n          (let [[lf ll] (last a)]\n            (if (and ll (<= x (inc ll)))\n              (conj (vec (butlast a)) (vector lf x))\n              (conj a (vector x x))))) [] (sort %))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"#(let [[f & t] (sort %)]\n    (loop [[c & [d :as r]] t, a f, q []]\n      (if c\n        (if (and d (< (- d c) 2))\n          (recur r a q)\n          (recur r d (conj q [a c])))\n        q)))","problem":"171","user":"4e12cc9d535d04ed9115e7d2"},{"problem":"171","code":"(fn intervals [xs]\n  (->> xs\n   sort\n   (partition-all 2 1)\n   (#(cons [(ffirst %)] %))\n   (remove (fn [[a b]] (and a b (< (- b a) 2))))\n   flatten\n   (partition 2)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [xs]\n  (if (empty? xs) xs\n  (let [ x_sorted (sort xs)\n        [cc y] (reduce\n                (fn[ [cc, y] x]\n                  [(if (> x (inc y))\n                     (conj (conj cc y) x)\n                     cc), x])\n                [ [(first x_sorted)], (first x_sorted)]\n                (rest x_sorted))]\n    (partition 2 (conj cc y)))))","problem":"171","user":"50fa01bce4b07934dda8b0ba"},{"problem":"171","code":"#(if (empty? %) \n  %\n  (loop [[f & r] (sort %) [a b :as curr] [f f] res []]\n  (if f\n    (if (<= f (inc b))\n      (recur r [a f] res)\n      (recur r [f f] (conj res curr)))\n    (conj res curr))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn [l]\n  (if (empty? l)\n    l\n    (letfn [\n    \t  (diffs [ls]\n          (loop [ls2 ls diff []]\n            (if (= 1 (count ls2))\n              diff\n              (recur (rest ls2) (conj diff (- (second ls2) (first ls2)))))))\n        (intervals [ls]\n          (loop [ls2 (rest ls) diff (diffs ls) interval (list (vector (first ls)))]\n            (if (empty? ls2)\n              interval\n              (if (= 1 (first diff))\n                (recur (rest ls2) (rest diff) (conj (rest interval) (conj (first interval) (first ls2))))\n                (recur (rest ls2) (rest diff) (conj interval (vector (first ls2))))))))]\n      (map #(vector (first %) (last %)) (reverse (intervals (distinct (sort l))))))))","problem":"171","user":"4fb1325de4b081705acca276"},{"problem":"171","code":"(comp\n #(map (juxt first last) %)\n (fn f [[x :as coll]]\n   (if x \n     (let [[a b] (split-with #(apply = %) (map vector coll (range x (inc (last coll)))))]\n       (cons (map first a)\n             (f (map first b))))))\n (fn f [[x & r]]\n  (if x\n    (cons x (f (remove #{x} r)))))\n sort)","user":"53ea5851e4b036ad0777e4e4"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs)\n    []\n    (let [sorted (sort xs)]\n      (loop [acc []\n             begin (first sorted)\n             end (first sorted)\n             todo (rest sorted)]\n        (cond\n          (empty? todo) (conj acc [begin end])\n          (<= (first todo) (inc end)) (recur acc begin (first todo) (rest todo))\n          :else (recur (conj acc [begin end]) (first todo) (first todo) (rest todo)))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [s]\n  (if-not (seq s) []\n    (let [ss (into (sorted-set) s)]\n      (loop [complete-intervals []\n             [i j] [(first ss) (first ss)]\n             [n & rest] (rest ss)]\n        (if n\n          (if-not (= (inc j) n)\n            (recur (conj complete-intervals [i j]) [n n] rest)\n            (recur complete-intervals [i n] rest))\n          (conj complete-intervals [i j]))))))","problem":"171","user":"4ff3df0fe4b0678c553fc355"},{"problem":"171","code":"(fn [coll]\n\t(if (empty? coll)\n\t\t[]\n\t\t(loop [c (sort coll) m (first c) n (first c) r []]\n\t\t\t(let [t (rest c)]\n\t\t\t\t(if (empty? t)\n\t\t\t\t\t(conj r [m n])\n\t\t\t\t\t(if (= (inc n) (first t))\n\t\t\t\t\t\t(recur t m (inc n) r)\n\t\t\t\t\t\t(if (= n (first t))\n\t\t\t\t\t\t\t(recur t m n r)\n\t\t\t\t\t\t\t(recur t (first t) (first t) (conj r [m n])))))))))","user":"561a1af6e4b053970a773b02"},{"problem":"171","code":"(fn [coll]\n   (if (empty? coll) []\n       (let [c (sort (distinct coll))]\n          (partition 2 2 (concat [(first c)] (flatten (filter #(not= (- (second  %) (first %)) 1) (partition 2 1 c))) [(last c)])))))","user":"54d7e277e4b0a52adc2e2031"},{"problem":"171","code":"(fn intervals\n  [coll]\n  (let [coll (sort coll)\n        c (first coll)\n        l (last coll)]\n    (if (empty? coll)\n      coll\n      (partition 2 (concat [c]\n                          (flatten\n                            (filter #(> (- (second %) (first %)) 1)\n                                    (partition 2 1 coll)))\n                          [l])))))","user":"565654dae4b0f9d632dd849f"},{"problem":"171","code":"(fn [s]\n  (letfn [(find-next [ss]\n                     (->> ss\n                          (map-indexed #(vector %1 %2))\n                          (take-while (fn [[i v]] (= (first ss) (- v i))))\n                          (map second)))\n          (f [ss]\n             (if (first ss)\n               (let [intvl (find-next ss)]\n                 (cons intvl (f (drop (count intvl) ss))))))]\n      (map #(vector (first %) (last %)) (f (sort (apply list (set s)))))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":"171","code":"#(loop [acc []\n        xs (distinct (sort %))]\n   (if (empty? xs)\n     acc\n     (let [[xs' xs] (->> (range)\n                         (drop (first xs))\n                         (map vector xs)\n                         (split-with (fn [[a b]] (= a b)))\n                         (map (partial map first)))\n           interval [(first xs') (last xs')]]\n       (recur (conj acc interval) xs))))","user":"583e27e2e4b089d5ab817daa"},{"problem":"171","code":"(fn [xs]\n  (map\n    #(vector (->> % first last) (->> % last last))\n    (partition-by\n      #(apply - %)\n      (map-indexed vector (apply sorted-set xs)))))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn [l]\n  (let [ls       (sort l)\n        [a b c]  (reduce (fn [[start prev res] n]\n                           (cond\n                             (= n prev)       [start prev res]\n                             (= n (inc prev)) [start n res]\n                             :default         [n n (conj res [start prev])]))\n                         [(first ls) (first ls) []]\n                         (next ls))]\n        (if (= a b nil)\n          c\n          (conj c [a b]))))","problem":"171","user":"4f3e6244e4b0e243712b1f85"},{"problem":"171","code":"#(loop [numbers (sort %) x -42 y -42 result []]\n   (if (empty? numbers) (rest (conj result [x y]))\n     (if (> 2 (- (first numbers) y))\n       (recur (rest numbers) x (first numbers) result)\n       (recur (rest numbers) (first numbers) (first numbers) (conj result [x y])))))","user":"5547b72be4b0a04f79299550"},{"code":"(fn [l]\n    (let [g (fn [s]\n              (loop [x (first s), r (rest s), v1 [x], v2 []]\n                (println x r v1 v2)\n                (cond\n                  (= '() r)\n                      (conj v2 (conj v1 x))\n                  (or (= x (first r)) (= (inc x) (first r)))\n                    (recur (first r) (rest r) (conj v1 x) v2)\n                  :else\n                    (recur (first r) (rest r) [(first r)] (conj v2 (conj v1 x)))\n                  )\n                ))]\n      (if (= [] l)\n        []\n        (into [] (map #(vector (first %1) (last %1)) (g (sort l)))))\n      ))","problem":"171","user":"4f038567535dcb61093f6b0c"},{"code":"(fn [z]\n  (loop [c (-> z sort set) r []]\n    (if (empty? c)\n      r\n      (let [x (first c)\n            y (last (take-while #(not (nil? %))\n                                (map #(if (= % %2) %)\n                                     c\n                                     (range x 1e7))))]\n        (recur (drop (inc (- y x)) c)\n               (conj r [x y]))))))","problem":"171","user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn get-intervals [src]\n   (if (empty? src) []\n   (let [sorted (sort src)]\t\n     (reduce #(if(<(- %2(last(last %)))2)\n                 (conj (vec(drop-last %)) (vector(first(last %))%2))\n                 (conj % (vector %2 %2))\n                ) [[(first sorted)(first sorted)]] (rest sorted)\n      )\n    ))\n  )","problem":"171","user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [a]\n  (if (empty? a)\n    []\n    (let [sa (-> a set sort)\n          fl (fn [b] [(first b) (last b)])]\n      (loop [res [[(first sa)]] leftover (rest sa)]\n        (if (empty? leftover)\n          (map fl res)\n          (if (= (-> res last last inc') (first leftover))\n            (recur (concat (butlast res) [(concat (last res) [(first leftover)])]) (rest leftover))\n            (recur (concat res [[(first leftover)]]) (rest leftover))))))))","problem":"171","user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn intervals [coll]\n  (let [nums (distinct (sort coll))]\n    (map\n     #(vector (last (first %)) (last (last %)))\n     (partition-by #(- (last %) (first %)) (map #(vector %1 %2) (range) nums))\n     )\n    )\n  )","problem":"171","user":"52e59ca5e4b09f7907dd1464"},{"problem":"171","code":"(fn split-inc-1 [lst]\n  (let [ [a b] (reduce \n  \t\t\t(fn [sum i] \n  \t\t\t\t(let [sumt (first sum)\n  \t\t\t\t\t  sumi (second sum)\n  \t\t\t\t\t  lasti (last sumi)]\n  \t\t\t\t\t  (if (or (nil? lasti) (= i lasti) (= i (inc lasti))) \n  \t\t\t\t\t  \t(vec [sumt (conj sumi i)])\n  \t\t\t\t\t  \t(vec [(conj sumt sumi) [i]]))))\n  \t\t\t[[] []]\n  \t\t\t(sort lst))\n          total (if (empty? b) a (conj a b))]\n  (map (fn [x] (let [n (count x)]\n  \t(if (= 1 n) [(first x) (first x)] [(first x) (last x)]))) total)))","user":"5374adc3e4b06d7f452d9e27"},{"problem":"171","code":"(fn [s] (->> \n         (apply sorted-set s)\n         (map list (range))\n         (partition-by (fn [[a b]] (- b a)))\n         (map #(map last %))\n         (map (juxt first last))\n         \n))","user":"5603c31fe4b04bb52996e1c1"},{"code":"(fn get-intervals [col]\n  (let [col (list* (set col))\n        get-interval-numbers (fn [l current result]\n                               (if (.contains l (inc current))\n                                 (recur\n                                   (rest l)\n                                   (inc current)\n                                   (cons (inc current) result))\n                                 {:result result :list l}))\n        get-all-interval-numbers (fn [l]\n                                   (let [results (ref '())\n                                         current-list (ref l)\n                                         ]\n                                     (while (not (empty? @current-list))\n                                       (do\n                                         (let [\n                                               result (get-interval-numbers \n                                                        (rest @current-list)\n                                                        (first @current-list)\n                                                        (list (first @current-list)))]\n                                           (dosync (ref-set results (cons (get result :result) @results))\n                                                   (ref-set current-list (get result :list))))))\n                                     results))\n        interval-numbers @(get-all-interval-numbers col)\n        result (sort (map #(vector (last %) (first %)) interval-numbers))\n        ]\n    result\n    ))","problem":"171","user":"5021f0b3e4b00bba4502f7ac"},{"problem":"171","code":"(fn [sq]\n  (if (empty? sq) []\n    (let [s (sort sq)]\n      (partition 2 (loop [f (first s) r (rest s) built (take 1 s)]\n                     (if (empty? r) \n                       (concat built (take-last 1 s))\n                       (recur (first r) (rest r) \n                              (if (>= 1 (- (first r) f))  \n                                built \n                                (concat built [f] (take 1 r))))))))))","user":"56bb9ccce4b0f26550335959"},{"code":"(fn [integers]\n(if (empty? integers) '()\n(let [sorted (sort integers)\n      int-limits (->> (partition 2 1 sorted) (filter #(> (- (second %) (first %)) 1)) ) \n      limits (-> (cons (first sorted ) (reduce concat int-limits)) vec (conj (last sorted)))\n] (partition 2 limits))))","problem":"171","user":"51729002e4b044b2ef48a850"},{"problem":"171","code":"(fn [xxs]\n     (if (= xxs []) []\n     ((fn itere [gs [x & xs]]\n        (if (nil? x) (if (= 1 (count (last gs))) (conj (pop gs) (conj (last gs) (first (last gs))))\n                                                 gs)\n                     (let [g (last gs)\n                           a (first g)\n                           b (second g)]\n                       (cond\n                         (empty? g) (itere (conj (pop gs) [x]) xs)\n                         (nil? b) (if (or (= x a) (= x (inc a)))\n                                    (itere (conj (pop gs) [a x]) xs)\n                                    (itere (conj (pop gs) [a a] [x]) xs))\n                         (= x (inc b)) (itere (conj (pop gs) [a x]) xs)\n                         (= x b) (itere gs xs)\n                         :else (itere (conj gs [x]) xs)\n                         )\n                       ))\n        ) [[]] (vec (sort xxs))\n       )))","user":"54e51c7be4b024c67c0cf7f7"},{"problem":"171","code":"(fn [col]\n  (let [col (sort col)\n        fst (first col)]\n    (if fst\n      (reduce (fn [acc e]\n                (let [c (count acc)\n                      tmp (get-in acc [(dec c) 1])]\n                  (cond\n                    (= tmp e) acc\n                    (= (inc tmp) e) (assoc-in acc [(dec c) 1] e)\n                    :else (assoc acc c [e e]))))\n              [[fst fst]] \n              col)\n      [])))","user":"5cf895efe4b0b71b1d808a85"},{"problem":"171","code":"(fn [s]\n      (let [vs    (sort s)\n            intvl (fn [xs] [(first xs) (last xs)])]\n        (loop [res []\n               cur-run (if (empty? vs) [] [(first vs)])\n               vs (rest vs)]\n          (let [v0   (first vs)\n                gap? #(> v0 (inc (last cur-run)))\n                finalize (fn []\n                           (if (empty? cur-run)\n                             res\n                             (conj res (intvl cur-run))))]\n            (cond\n              (empty? vs) (finalize)\n              (gap?)      (recur (conj res (intvl cur-run))\n                                 [v0]\n                                 (rest vs))\n              :else       (recur res\n                                 (conj cur-run v0)\n                                 (rest vs)))))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn intervals [coll]\n  (let [interval-groups (fn interval-groups [coll]\n                          (lazy-seq\n                           (let [[head & tail :as all] (sort coll)]\n                             (when head\n                               (let [run (reduce (fn [acc x]\n                                                   (if (or (= (inc (last acc)) x) (= (last acc) x))\n                                                     (conj acc x)\n                                                     acc))\n                                                 [head] tail)]\n                                 (cons run (intervals (drop (count run) all))))))))]\n    (map #(list (first %) (last %)) (interval-groups coll))))","problem":"171","user":"51a97f7ae4b08d8ec191b827"},{"problem":"171","code":"(fn to-interval [xs]\n  (->> (sort (set xs)) \n       (map-indexed (fn [idx x] [(- idx x) x]))\n       (partition-by first)\n       (map (fn [x] [(last (first x)) (last (last x))]))))","user":"5383668ee4b06839e8705edd"},{"code":"(fn\n    [s]\n    (letfn [(f [[segments src]]\n              (if-let [[src-head & src-tail] (seq src)]\n                (if-let [tail (-> segments peek peek)]\n                  (if (> 2 (- src-head tail))\n                    [(conj (pop segments) (conj (peek segments) src-head)) src-tail]\n                    [(conj segments [src-head]) src-tail])\n                  [[[src-head]] src-tail])\n                [segments nil]))]\n      (->> [nil (sort s)]\n           (iterate f)\n           (drop-while second)\n           ffirst\n           (map (juxt #(apply min %) #(apply max %))))))","problem":"171","user":"4f3fb586e4b0e243712b1f9c"},{"problem":"171","code":"(fn [xs]\n          (map #(vector (first %)(last %))\n           (reduce\n            (fn [acc [an pred]]\n              (if pred\n                (conj (pop acc) (conj (peek acc) an))\n                (conj acc [an])     \n                )\n              )\n            []\n            (reduce\n              (fn [acc x] \n                (conj acc [x (= (first (last acc)) (dec x))]) )\n              []\n              (distinct (sort xs))))) \n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":"171","code":"#_(fn [x]\n    (->> x\n       sort\n       distinct\n       (map-indexed #(vector (- %2 %) %2))\n       (partition-by first)\n       (map #(map last %))\n       (map #(vector (first %) (last %)))))\n\n(fn [x]\n  (map #(vector (first %)(last %))\n    (map #(map last %)\n         (partition-by first\n           (map-indexed #(vector(- %2 %) %2)\n             (distinct(sort x)))))))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":"171","code":"#(case % [1 2 3] [[1 3]]\n   [10 9 8 1 2 3] [[1 3] [8 10]]\n   [1 1 1 1 1 1 1] [[1 1]]\n   [] []\n   [19 4 17 1 3 10 2 13 13 2 16 4 2 15 13 9 6 14 2 11]\n   [[1 4] [6 6] [9 11] [13 17] [19 19]])","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn intervals [x]\n    (let [x (distinct (sort x))\n          add (fn [[s t] x] (if (= 1 (- x t)) [s x] [x x]))]\n        (map last (partition-by first (next (reductions add [0 (first x)] x))))))","problem":"171","user":"51cbdee1e4b08d8387cbede1"},{"problem":"171","code":"(fn [c] (->> c sort (reduce (fn [svv v]\n         (if (some (fn [sv] (some (fn [v1] (let [v2 (- v v1)] (or (= 1 v2) (= 0 v2))) ) sv)) svv)\n            (map (fn [sv] (if (some (fn [v1] (let [v2 (- v v1)] (or (= 1 v2) (= 0 v2))) ) sv) (vec (conj sv v))\n               sv )) svv)\n            (conj svv [v])\n         )) '())\n         (map (fn [cv] (if () [(first cv) (last cv)] [(first cv) (first cv)]))) sort\n  ))","user":"55adf4d7e4b03311e7b732af"},{"problem":"171","code":"(fn intervals [ls]\n  (vec (map (fn [part] (vector (last (first part))\n                                (last (last part)))) ;; unpack items from partitions [[ind-0 item-0], ..., [ind-n item-n]]\n       (partition-by (fn [tuple] (apply - tuple)) ;; partition-by splits on changing fn-values, i.e., if the difference between index and item changes\n                     (map-indexed vector ;; sorted vector of vectors [index item]\n                                  (sort (distinct ls)))))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":"171","code":"(fn [coll]\n  (reduce (fn [acc val]\n            (let [[start end] (peek acc)]\n              (if (= end (dec val))\n                (conj (pop acc) [start val])\n                (conj acc [val val]))))\n          []\n          (sort (distinct coll))))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn [i]\n(if (empty? i) []\n  (let [iv (->> i\n                (distinct)\n                (sort))]\n    (loop [b (first iv)\n           n b\n           v (rest iv) \n           ret []]\n      (cond\n        (empty? v)\n          (conj ret [b n])\n        (= (first v) (inc n))\n          (recur b (inc n) (rest v) ret)\n        :e\n          (recur (first v) (first v) (rest v) (conj ret [b n])))))))","problem":"171","user":"51f28a64e4b0210f90e7454e"},{"code":"(fn intervals [coll]\n  (let [s (sort coll)\n        p (partition 2 1 s)\n        m (map (partial apply -) p)\n        q (map-indexed #(if (and (not= -1 %2)\n                                 (not= 0 %2)) %1 nil) m)\n        f (filter (complement nil?) q)]\n    (loop [f f\n           o 0\n           r []]\n      (if (empty? s)\n        r\n      \t(if (nil? (first f))\n          (concat r [[(first (drop o s)) (last s)]])\n          (let [t (inc (first f))\n                i (drop o (take t s))]\n            (recur (rest f) t (concat r [[(first i) (last i)]]))))))))","problem":"171","user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":"171","code":"(fn intervals [c]\n  (if (empty? c)\n    c\n   (->>  (range (dec (apply min c)) (+ 2 (apply max c)))\n         (remove (set c))\n         (partition 2 1)\n         (map #(vector (inc (first %)) (dec (second %))))\n         (filter #(apply <= %)))))","user":"532a033be4b09d4e7a9b551f"},{"problem":"171","code":"(fn intervals [s]\n  (letfn [(overlap [[x & xs] [y & ys]]\n            (if (not= x y) []\n                (cons x (overlap xs ys))))]\n    (if (empty? s) []\n        (let [s (sort (distinct s))\n              overlaps (overlap s (drop (first s) (range 0 100)))]\n          (cons [(first overlaps) (last overlaps)]\n                (intervals (drop (count overlaps) s)))))))","user":"547884d7e4b0c51c1f4d72bd"},{"problem":"171","code":"(fn me [my-vec]\n\t\n  \t(if (= my-vec [])\n      []\n\n\t(let [sorted-vec (sort my-vec)\n\n\t\t  first-less (dec (first sorted-vec))\n\n\t\t  new-vec (concat [first-less] (drop-last sorted-vec))\n\n\t\t  dist-seq (map - sorted-vec new-vec)\n\n\t\t  map-seq (map hash-map dist-seq sorted-vec)\n\n\t\t  res1 \t(partition-by keys map-seq)\n\n\t\t  res2 \t\t(for [sub-map res1]\n\n\t\t\t\t\t\t(into [] (flatten (map vals sub-map)))\n\t\t\t\t\t)\n\n\t\t  res3  (map #(if (= 1 (count %)) % (vector (first %) (last %)))  res2)\n\n\t\t  my-test (fn  [a b]\n\n\t\t\t\t(if (= a [])\n\t\t\t\t\t\t(vector b)\n\n\t\t\t\t(let [a1  (last (last a))\n\n\t\t\t\t\t  b1  (first b)\t\n\t\t\t\t\t ]\n\n\t\t\t\t\t (cond\n\t\t\t\t\t \t(= 0 (- b1 a1) ) (concat (drop-last a) (vector (vector (first (last a)) (last b)))) \t\t\n\t\t\t\t\t \t(= 1 (- b1 a1) ) (concat (drop-last a) (vector (vector (first (last a)) (last b))))\n\t\t\t\t\t \t:else  (concat a [b])\n\t\t\t\t\t )\n\n\n\n\n\t\t\t\t\t ;(if (= 1 (- b1 a1))\n\t\t\t\t\t \t;(concat (drop-last a) (vector (vector (first (last a)) (last b))))\n\t\t\t\t\t \t;(concat a [b])\n\t\t\t\t\t ;)\t\n\t\t\t\t)\n\n\n\t\t\t\t)\n\n\t\t\t)\n          \n        res4  (reduce my-test [] res3)\n\n\t\t]\n\t\t(map #(if (= 1 (count %)) (vector (first %) (first %)) %) res4)\n\t))\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":"171","code":"(fn [vs]\n            (->> vs\n                 (into #{})\n                 sort\n                 (reduce (fn [acc v]\n                           (if-not (seq acc)\n                             (conj acc [v])\n                             (let [u (peek (peek acc))]\n                               (if (= 1 (- v u))\n                                 (update-in acc\n                                            [(dec (count acc))]\n                                            conj v)\n                                 (conj acc [v])))))\n                         [])\n                 (map (juxt first last))))","user":"53684a2fe4b0243289761e8c"},{"problem":"171","code":"(fn [i]\n  (letfn [(f [s]\n             (lazy-seq\n              (if (not-empty s)\n                (let [p (partition 2 1 s)\n                      m (take-while (fn [[a b]] (< (- b a) 2)) p)\n                      c (inc (count m))\n                      [n o] (split-at c s)]\n                  (cons [(first n) (last n)] (f o))))))]\n    (f (sort i))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":"171","code":"(fn intervalsX[v]\n\t(letfn [\n\t\t(intervalsRec[x b]\n\t\t\t(cond \n\t\t\t\t(empty? x) [b]\n\t\t\t\t(= (last b)(first x)) (intervalsRec (rest x) b)\t\t\n\t\t\t\t(= (inc (last b))(first x)) (intervalsRec (rest x) (conj b (first x)))\n\t\t\t\t:else (cons b (intervalsRec (rest x) [(first x)]))\n\t\t\t)\n\t\t)\n\n\t\t(toInterval[x]\n\t\t\t[(first x)(last x)]\n\t\t)\n\t\t]\n\t\t(if (empty? v) \n\t\t\t[]\n\t\t\t(let [\n\t\t\t\tx (sort v)\n\t\t\t\t]\n\t\t\t\t(map toInterval (intervalsRec (rest x) [(first x)]))\n\t\t\t)\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":"171","code":"(fn [coll]\n  (map\n    (fn [interval]\n      (if (= (count interval) 1)\n          (vec (take 2 (repeat (first interval))))\n          [(first interval) (last interval)]\n      )\n    )\n   (loop [intervals [] items (sort coll)]\n     (cond\n      (empty? items) intervals\n      (empty? intervals) (recur (conj intervals [(first items)]) (rest items))\n      (> (- (first items) (last (last intervals))) 1) (recur (conj intervals [(first items)]) (rest items))\n      :else\n      \t(recur (conj (vec (butlast intervals)) (conj (last intervals) (first items))) (rest items))\n      )\n     )\n   )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":"171","code":"(fn f [xs]\n  (if-let [nums (seq (distinct (sort xs)))] \n     (reduce\n      #(if (= %2 (inc (last (last %))))\n         (conj (pop %) [(first (peek %)) %2])\n         (conj % [%2 %2]))\n      [[(first nums) (first nums)]]\n      (rest nums))\n    []))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":"171","code":"(fn [c]\n  (remove #(some nil? %)\n    (map #(vector (first %) (last %))\n      (let [s (set c)]\n        (partition-by nil?\n        (take (if (seq c) (+ (apply max c) 1) 0) (map #(if (s %) % nil) (range)))\n    ))))\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":"171","code":"#(reduce (fn [[[f l] :as v] x]\n            (condp = f\n              (inc x) (cons [x l] (rest v))\n              x v\n              (cons [x x] v)))\n        [] (sort > %))","user":"5382704be4b06839e8705ed4"},{"problem":"171","code":"(fn intervals\n  [in-seq1]\n  (loop [in-seq2 (sort (distinct in-seq1))\n         out-seq []]\n    (if (zero? (count in-seq2))\n      out-seq\n      (let [r-ind ((fn step1 [in-seq]\n                      (let [tem-seq in-seq]\n                        (loop [r-index 0]\n                          (let [r-val (nth tem-seq r-index)]\n                            (if (= r-index (- (count tem-seq) 1))\n                              r-index\n                              (if (= (inc r-val) (nth tem-seq (inc r-index)))             \n                                (recur (inc r-index))\n                                r-index)))))) in-seq2)]\n        (recur (drop (inc r-ind) in-seq2) (conj out-seq [(nth in-seq2 0) (nth in-seq2 r-ind)])))))\n)","user":"5581a6dae4b05c286339e0fe"},{"problem":"171","code":"(fn inter\n  [coll]\n  (let [c (count coll)]\n    (cond\n      (= c 3) [[1 3]]\n      (= c 6) [[1 3] [8 10]]\n      (= c 7) [[1 1]]\n      (= coll [19 4 17 1 3 10 2 13 13 2 16 4 2 15 13 9 6 14 2 11]) [[1 4] [6 6] [9 11] [13 17] [19 19]]\n      :else [])))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [ns]\n  (reverse\n    (reduce\n      (fn [[[a b] & rest :as pairs] n] \n        (cond \n          (empty? pairs) [[n n]]\n          (= n b) pairs\n          (= n (inc b)) (cons [a n] rest)\n          :else (cons [n n] pairs)))\n      '()\n      (sort ns))))","problem":"171","user":"4f050dec535dcb61093f6bef"},{"code":"(fn [s]\n  (if\n    (empty? s)\n    []\n    (let [s (apply sorted-set-by (cons < s))]\n      (loop\n          [current [(first s), (first s)],\n           s (disj s (first s)),\n           r []]\n        (if\n          (empty? s)\n          (conj r current)\n          (let\n              [doNext (> (first s) (+ 1 (last current)))\n               newCurrent [(first (if doNext s current)), (first s)]\n               newS (disj s (first s)),\n               newR (if doNext (conj r current) r)]\n            (recur newCurrent newS newR)))))))","problem":"171","user":"4f5c0549e4b0030a34fb2b1a"},{"problem":"171","code":"(fn [sq]\n  (reduce (fn [col item]\n            (let [[_ l] (last col)]\n              (if (or (nil? l) (> (dec item) l))\n                (conj col [item item])\n                (assoc-in col\n                          [(dec (count col)) 1]\n                          item))))\n          []\n          (sort sq)))","user":"541709b0e4b01498b1a71a06"},{"code":"#(reverse (reduce\n           (fn [r x]\n             (if (or (empty? r) (not= (inc (last (first r))) x))\n               (conj r [x x])\n               (conj (rest r) [(first (first r)) x])))\n           [] (sort (set %))))","problem":"171","user":"518ccf6be4b05e6c8537e386"},{"problem":"171","code":"(fn [x]\n  (map (juxt first last)\n       (loop [tail (distinct (sort x)) last-num nil curr-v [] result []]\n         (if (empty? tail)\n           (if (seq curr-v)\n             (conj result curr-v)\n             result)\n           (let [curr-num (first tail)]\n             (if (or (not last-num) (= 1 (- curr-num last-num)))\n               (recur (rest tail) curr-num (conj curr-v curr-num) result)\n               (recur (rest tail) curr-num [curr-num] (conj result curr-v))))))))","user":"530b8580e4b02e82168697cc"},{"problem":"171","code":"(fn intervals [s]\n  (letfn [(connected-to-previous\n            [a b] (cond\n                    (nil? a) [b false]\n                    (= b (inc a)) [b true]\n                    true [b false]))]\n    (let [elems (map (partial apply connected-to-previous)\n                     (partition 2 1 (cons nil (sort (set s)))))]\n      (loop [a [] r elems]\n        (if (empty? r)\n          (mapv (juxt first last)\n                (mapv #(map first %) a))\n          (let [[x & y] r]\n            (if (empty? y)\n              (recur (conj a [x x]) y)\n              (let [t (take-while second y)]\n                (if (empty? t)\n                  (recur (conj a [x x]) y)\n                  (recur (conj a (cons x t))\n                         (drop-while second y)))))))))))","user":"5ab564f8e4b073f177442639"},{"code":"#((fn ints [n t o]\n    (let [b (not (empty? t))]\n      (if (empty? o) (if b (conj n t) n)\n      (let [[f & r] o]\n        (if (contains? #{f (dec f)} (last t))\n          (ints n [(first t) f] r)\n          (ints (if b (conj n t) n) [f f] r)))))) [] [] (sort %))","problem":"171","user":"505dcfc8e4b0e6aca564be0d"},{"problem":"171","code":"(fn intervals [integers]\n    (let [uniq_sorted_integers (sort (set integers))]\n        (cond\n            (= (count uniq_sorted_integers) 0) []\n            (= (count uniq_sorted_integers) 1) [[(first uniq_sorted_integers) (first uniq_sorted_integers)]]\n            :otherwise\n                (let\n                    [\n                        consecutive_pairs (partition 2 1 uniq_sorted_integers)\n                        split_seq\n                            (fn f [[[v1 v2] & tail] begin_val]\n                                (if (empty? tail)\n                                    ; terminating logic\n                                    (if (= (inc v1) v2)\n                                        (list (vector begin_val v2))\n                                        (cons (vector begin_val v1) (list (vector v2 v2)))\n                                    )\n                                    (if (= (inc v1) v2)\n                                        (f tail begin_val)\n                                        (cons (vector begin_val v1) (f tail v2))\n                                    )\n                                )\n                            )\n                    ]\n                    (split_seq consecutive_pairs (first (first consecutive_pairs)))\n                )\n        )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":"171","code":"(fn [s]\n      (->> s\n           set\n           sort\n           (partition 2 1 nil)\n           (mapcat (fn [[x1 x2]]\n                     (if (and x2 (> x2 (inc x1))) [x1 :split] [x1])))\n           (partition-by #(= :split %))\n           (filter #(not= '(:split) %))\n           (map (juxt first last))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn [sq]\n   (if (empty? sq) []\n       (let [sorted (sort sq)]\n         ((fn intervals [[h & t] [cs ce]]\n            (if (nil? h) [[cs ce]]\n                (if (<= h (inc ce))\n                  (intervals t [cs h])\n                  (cons [cs ce] (intervals t [h h])))))\n          (rest sorted) [(first sorted) (first sorted)]))))","problem":"171","user":"529ce629e4b04e0c58e87b6e"},{"problem":"171","code":"(fn [s]\n  (if (empty? s)\n    []\n  (let [result (->> (sort s)\n                    (reduce (fn [{:keys [ret cur]} e]\n                              (cond\n                               (nil? cur) {:ret ret :cur [e]}\n                               (or (= e (inc (last cur)))\n                                   (= e (last cur)))\n                               {:ret ret :cur (conj cur e)}\n                               :else\n                               {:ret (conj ret cur) :cur [e]}))\n                            {:ret []}))\n        result (conj (:ret result) (:cur result))]\n    (for [e result]\n      [(first e) (last e)]))))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn  i[x] \n   (let[ x (into #{} x)\n       d (map #(apply - %) (partition 2 1 x))\n       m (zipmap x (reductions + 0 (map inc d)))]\n    (map #(if (next %) [(first %) (last %)] [(first %) (first %)])\n         (partition-by #(m %) x))))","problem":"171","user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn [s] \n  (letfn\n    [(csm [[head & tail :as acc] itm]\n       (cond\n         (= (first head) itm)       acc\n         (= (first head) (dec itm)) (cons [(inc (first head)) (last head)] tail)\n         :else                      (cons [itm itm] acc)))]\n    (reverse (map reverse (reduce csm [] (sort s))))))","problem":"171","user":"521e8227e4b0dd19981ad082"},{"code":"(fn [coll]\n  (if (empty? coll) []\n    (let [[x & xs] (sort coll)\n          [acc pair] (reduce \n                      (fn [[acc [start prev]] nxt]\n                        (if (> nxt (inc prev))\n                          [(conj acc [start prev]) [nxt nxt]]\n                          [acc [start nxt]]))\n                      [[] [x x]] xs)]\n      (conj acc pair))))","problem":"171","user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn [s]\n  (let [n (reduce conj #{} s)]\n    (partition 2\n    (reduce (fn [a v]\n              (cond (and (n (dec v)) (n (inc v))) a\n                    (or (n (dec v)) (n (inc v))) (conj a v)\n                    :e (-> a (conj v) (conj v))))\n            []\n            (sort n)))))","problem":"171","user":"4fa340b4e4b081705acca18c"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [[h & t] (sort (set coll))]\n      (reduce\n       (fn [cs n] (let [[[a b] & rest] (rseq cs)]\n                    (if (= (inc b) n)\n                      (conj (vec rest) [a n])\n                      (conj cs [n n]))))\n       [[h h]]\n       t))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":"171","code":"(fn intervals [xs]\n  (if (seq xs)\n    (->> xs\n         (set)\n         (sort)\n         (reductions #(if (= %2 (inc (if (sequential? %1) (second %1) %1))) %2 [nil %2]))\n         (flatten)\n         (partition-by number?)\n         (remove #(= [nil] %))\n         (map (juxt first last)))\n    []))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn [xs]\n  (letfn [(next-subseq [xs]\n            (loop [xs xs s []]\n              (if (empty? xs)\n                s\n                (let [x (first xs)]\n                  (if (or (empty? s) (= x (inc (last s))))\n                    (recur (rest xs) (conj s x))\n                    s)))))]\n    (loop [xs (sort (set xs)) accum []]\n      (if (empty? xs)\n        accum\n        (let [s (next-subseq xs)]\n          (recur (drop (count s) xs) (conj accum [(first s) (last s)])))))))","problem":"171","user":"4e50b67b535dc968683fc4ed"},{"problem":"171","code":"(fn [args]\n  (let [iv_end (fn [s] (if-let [r (first (remove nil? (map #(when (not= %1 %2) (dec %1)) (iterate inc (first s)) s)))] r (last s)))]\n    (loop [s (set args) ivs []]\n      (if (empty? s) ivs\n        (let [end (iv_end s)]\n          (recur (remove #(<= % end) s) (conj ivs [(first s) end])))))))","user":"53e745a1e4b036ad0777e479"},{"problem":"171","code":"(fn my-intervals [l]\n  (letfn [(insert-range [l e]\n                       (cond\n                         (empty? l)\n                         (cons (list e e) nil)\n                         (= e (inc (second (first l))))\n                         (cons (list (first (first l)) e) (rest l))\n                         (< e (inc (second (first l)))) l\n                         :else\n                         (cons (list e e) l)\n                         ))]\n        (reverse (reduce insert-range nil (sort l))))\n  )","user":"563b9acbe4b0bfe05bf11827"},{"problem":"171","code":"(fn [s]\n  (let [s (-> s set sort)\n        v (atom (first s))]\n    (->> s\n         (partition-by (fn [x]\n                         (if (== @v x)\n                           (do (swap! v inc) true)\n                           (do (reset! v x) false))))\n         (mapv (juxt first last)))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":"171","code":"(fn __ [s]\n  (let [ss (-> s set sort)\n        niz (fn [xs res] \n              (if (empty? xs) res\n                (if (empty? res)\n                  (recur (rest xs) [(first xs)])\n                  (if (not= (first xs) (inc (last res))) \n                    res\n                    (recur (rest xs) (conj res (first xs)))))))        \n       transf (fn [xs res]\n                (if (empty? xs) res\n                  (let [nz (niz xs []) n (count nz)]\n                    (recur (drop n xs) (conj res [(first nz) (last nz)])))))]\n    (transf ss [])))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn [l]\n  ((fn [l]\n     (loop [start (first l)\n            prev start\n            l (next l)\n            res []]\n       (if (nil? start)\n         res\n         (if (empty? l)\n           (concat res [[start prev]])\n           (if (or (= prev (first l)) (= (inc prev) (first l) ) )\n             (recur start (first l) (next l) res)\n             (recur (first l) (first l) (next l) (concat res [[start prev]]) )\n           )))))\n   (sort l)))","problem":"171","user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [v]\n  (let [s (apply sorted-set (cons 999 v)) i (atom nil) j (atom -999) o (atom [])]\n    (doseq [x s]\n      (if (= x (inc @j)) \n        (swap! j inc)\n        (do\n          (or (nil? @i) (swap! o conj [@i @j]))\n          (reset! i x)\n          (reset! j x)\n        )\n      ) \n    )\n    @o    \n  )  \n)","problem":"171","user":"5176afd2e4b085adf681d889"},{"problem":"171","code":"(fn [coll]\n  (letfn [(group-intervals [coll]\n            (loop [result  []\n                   current []\n                   coll    (sort coll)\n                   prev    (first coll)]\n              (if coll\n                (let [val (first coll)]\n                  (if (< (- val prev) 2)\n                    (recur result\n                           (conj current val)\n                           (next coll)\n                           val)\n                    (recur (conj result current)\n                           [val]\n                           (next coll)\n                           val)))\n                (if (empty? current)\n                  result\n                  (conj result current)))))]\n    (if (empty? coll)\n      []\n      (map #(vector (first %) (last %))\n           (group-intervals coll)))))","user":"55586905e4b0deb715856e2b"},{"problem":"171","code":"(fn intervals [s]\n  (let [sorted-set (sort (set s))]\n    (loop [rs []\n           r [(first sorted-set)]\n           s sorted-set]\n      (if-not (seq s)\n        rs\n        (let [[a b & t] s]\n          (if (= (inc a) b)\n            (recur rs\n                   r\n                   (rest s))\n            (recur (conj rs (conj r a))\n                   [b]\n                   (rest s))))))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":"171","code":"(fn interval [xs]\n  (if (empty? xs)\n    []\n  (let [m (apply min xs)\n        M (inc (apply max xs))\n        gap (clojure.set/difference (set (range m M)) (set (sort xs)))]\n    (map #(vector (apply min %1) (apply max %1)) (filter #(nil? (get gap (first %))) (partition-by #(get gap %) (range m M)))))))","user":"5510aa92e4b06e50f9beb188"},{"problem":"171","code":"(fn [v]\n  (let [[h :as s] (sort v)]\n    (reverse\n     (reduce (fn [[f & r] [x y :as z]]\n               (if (or (= (inc x) y)\n                       (= x y))\n                 (conj r [(first f) y])\n                 (conj r f [y y]) ))\n             (if (empty? v) [] [[h h]])\n             (partition 2 1 s)))))","user":"5504dd64e4b086ebe8a79c83"},{"problem":"171","code":"(fn [s]\n  (if (empty? s)\n    []\n    (let [s (vec (sort s))\n          is (cons 0 (remove nil? (for [i (-> s count dec range) :let [[a b & _] (drop i s)]]\n                                    (when (> (- b a) 1) i))))\n          intervals (map #(vector (if (zero? %1) %1 (inc %1)) %2)\n                         is (-> is rest vec (conj (dec (count s)))))]\n      (map (fn [[a b]] [(nth s a) (nth s b)]) intervals))))","user":"54055aa9e4b0addc1aec6665"},{"code":"(fn [c]\n  (if (empty? c)\n    []\n    (let [s (sort c)]\n      (apply conj (reduce (fn [[r [i j]] e]\n                            (cond\n                             (= j (dec e)) [r [i e]]\n                             (> j (dec e)) [r [i j]]\n                             :else [(conj r [i j]) [e e]]))\n                          [[] [(first s) (first s)]]\n                          (rest s))))))","problem":"171","user":"5392b849e4b0b51d73faaeb1"},{"problem":"171","code":"#(->> (sort %)\n      (reduce (fn [ss n]\n                (if (nil? (last (last ss)))\n                  (conj ss [n])\n                  (if (and (not= (last (last ss)) (dec n))\n                           (not= (last (last ss)) n))\n                    (conj ss [n])\n                    (update-in ss [(dec (count ss))] (fnil conj []) n)))) [])\n      (map (juxt first last)))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn [s] (sort-by first (map #(vector (apply min %) (apply max %))\n                    (first (reduce (fn [[[f & r :as i] l] n]\n          (if (>= 1 (- n l))\n            [(cons (conj f n) r) n]\n            [(cons [n] i) n]))\n        ['() 0] (sort s))))))","problem":"171","user":"50acbd15e4b071b89ef26234"},{"code":"(fn [c] (map (fn [x] [(first x) (last x)]) (loop [acc [] cur [] remain (sort (set c))]\n                (if (empty? remain) \n                  (if (empty? cur)\n                    (reverse acc)\n                    (reverse (cons (reverse cur) acc)))\n                  (let [e (first remain) rem (rest remain)]\n                    (if (empty? cur)\n                      (recur acc [ e ] rem)\n                      (if (= e (+ 1 (first cur)))\n                        (recur acc (cons e cur) rem)\n                        (recur (cons (reverse cur) acc) [e] rem)\n                        \n                    )))))))","problem":"171","user":"50956c2be4b087f34d351ab2"},{"problem":"171","code":"(fn [xs]\n  (let [[f & r :as sorted] (sort xs)\n        init (if (nil? f) [] [[f f]])]\n    (->> sorted\n         (reduce (fn [[h & t :as acc] x] \n                   (let [[a b] h]\n                     (if (> (Math/abs (- b x)) 1)\n                       (conj acc [x x])\n                       (conj t [a x]))))\n                 init)\n         reverse)))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [s]\n          (->> s\n              distinct\n              sort\n              (reduce (fn [a v]\n                        (let [[s e] (last a)]\n                          (if (= e (dec v))\n                            (conj (vec (drop-last a)) [s v])\n                            (conj a [v v]))))\n                      [])))","problem":"171","user":"51424cc8e4b0b50abeb46b34"},{"problem":"171","code":"(fn [nums]\r\n  (let [\r\n    intervals (fn intervals [start end [head & tail]]\r\n      (if (nil? head)\r\n        (if (nil? start) [] [[start end]])\r\n      (if (nil? start)\r\n        (intervals head head tail)\r\n      (if (< (inc end) head)\r\n        (cons [start end] (intervals head head tail))\r\n        (intervals start head tail)))))]\r\n    (intervals nil nil (sort (set nums)))))","user":"555bd27ae4b0b056612e2244"},{"problem":"171","code":"(fn [coll]\n  (->> (sort (distinct coll))\n       (partition 2 1 nil)\n       (mapcat (fn [[x y]] (if (and y (> y (inc x))) [x :split] [x])))\n       (partition-by #{:split})\n       (remove #{[:split]})\n       (map (juxt first last))))","user":"5a080bdde4b01bb0ae8afde9"},{"problem":"171","code":"(fn intervals1 [xs]\n  (if (empty? xs)\n    '()\n    (let [xs (sort (set xs))]\n      (map (fn [seq]\n             (list (first seq) (last seq)))\n           (reduce (fn [result x]\n                     (if (= x (inc (last (last result))))\n                       (conj (pop result) (conj (last result) x))\n                       (conj result [x])))\n                   [[(first xs)]] (rest xs))))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn [inseq] (let [num-set (reduce #(clojure.set/union %1 (sorted-set %2)) #{} inseq)]\n              (loop [result [] curr 0 low :none s num-set]\n                (cond\n                 (empty? s)\n                   (if (= low :none) result (conj result [low (dec curr)]))\n                 (not (s curr)) \n                   (if (= low :none) \n                     (recur result (inc curr) low s)\n                     (recur (conj result [low (dec curr)]) (inc curr) :none s)\n                   )\n                 (= low :none) (recur result (inc curr) curr (disj s curr))\n                 :else (recur result (inc curr) low (disj s curr))\n               )\n              )\n            )\n)","problem":"171","user":"526dd90de4b03e8d9a4a72fe"},{"problem":"171","code":"(fn [xs]\n  (if-let [s (not-empty (set xs))]\n    (->> (range (reduce min s) (inc (reduce max s)))\n       (partition-by #(contains? s %))\n       (take-nth 2)\n       (map (juxt first last)))\n\t[]))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":"171","code":"(fn intervals [s]\n  (->> s\n       sort\n       (reduce\n         (fn [acc x]\n           (let [e (peek (peek acc))]\n             (if (and (not (nil? e)) (<= (- x e) 1))\n               (conj (pop acc) (conj (peek acc) x))\n               (conj acc [x]))))\n         [])\n       (mapv (juxt first peek))))","user":"5f300f28e4b033932238a682"},{"code":"(fn [c]\n  (map #(vector (first %1) (last %1))\n       (loop [L (distinct (sort c)) I []]\n         (let [[a b]\n               (loop [[i & _ :as I] L\n                      [o & _ :as O] []]\n                 (if (and i (or (nil? o) (= 1 (- i o))))\n                   (recur (rest I) (cons i O))\n                   [I (reverse O)]))\n               i (if (empty? b) I (cons b I))]\n           (if (empty? a)\n             (reverse i)\n             (recur a i))))))","problem":"171","user":"4db8f6c4535d1e037afb219e"},{"problem":"171","code":"(fn [in-seq]\n  (let [s' (sort in-seq)\n        f (fn f [s]\n            (if (empty? s)\n              []\n              (let [d (map - s (cons (first s) (drop-last s)))\n                    incrementing (take-while #(<= % 1) d)\n                    int-size (count incrementing)\n                    rem (drop int-size s)]\n                    (conj (f rem)\n                          [(first s)\n                           (last (take int-size s))]))))]\n    (sort-by first (f s'))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":"171","code":"#(loop [x (apply sorted-set %) res [] start nil curr nil]\n   (if (nil? start) \n     (if (empty? x) res \n       (recur (rest x) res (first x) (first x))\n       )\n     (if (empty? x) (conj res [start curr])\n       (if (= (first x) (inc curr))\n         (recur (rest x) res start (first x))\n         (recur x (conj res [start curr]) nil nil)))))","user":"50856bd1e4b004985b776e4c"},{"problem":"171","code":"(fn [s] \n  (drop 1 (reduce \n     (fn [a e] \n       (let [lie (last (last a))\n             lib (first (last a))\n             update (fn update [a] \n                      (let [b lib\n                            e (inc lie)] \n                        (conj (apply vector (drop-last a)) [b e])))\n             insert (fn insert [a e] \n                      (conj a [e e]))]\n         (cond \n            (= e (inc lie)) (update a) \n            (> e (inc lie)) (insert a e)\n            :default a))) \n      [[-1 -1]]\n      (sort s))))","user":"577202d2e4b0979f896515c0"},{"code":"(fn [y]\n           (if (empty? y) \n               y \n               (let [p (sort (distinct y))]\n                 (->> (reduce (fn [y x] (if (= (inc (last (last y))) x) \n                                            (conj (into [] (butlast y)) (conj (last y) x))\n                                            (conj y [x])))\n                              [[(first p)]] (rest p))\n                      (map #(if (> (count %) 1) [(first %) (last %)] [(first %) (first %)]))))))","problem":"171","user":"4f03f197535dcb61093f6b84"},{"code":"(fn [xs]\n  (let [all (set xs)\n        interval\n        (->> all\n             (partition 2 1)\n             (partition-by #(apply - %))\n             (filter (fn [[[a b]]] (= 1 (- b a))))\n             (map flatten)\n             (map #(apply sorted-set %)))\n        single\n        (->> interval\n             (apply clojure.set/union)\n             (clojure.set/difference all)\n             (map #(repeat 2 %)))]\n    (->> interval\n         (map (fn [x] [(first x) (first (rseq x))]))\n         (concat single)\n         (sort-by first))))","problem":"171","user":"50479524e4b0371827a27bc4"},{"problem":"171","code":"#(map (fn [s] (seq [(first s) (last s)])) (reduce\n          (fn [a b] (if (empty? a) [[b]]\n                        (if (= (inc (last (last a))) b)\n                          (conj (vec (drop-last a)) (conj (last a) b))\n                          (conj (vec a) [b]))))\n          [] (apply sorted-set %)))","user":"564b1ff8e4b0284900eef663"},{"code":"(fn [xs]\n    (reverse\n      (reduce\n        (fn [acc x]\n        (if (empty? acc)\n            [[x x]]\n            (if (or (= (second (first acc)) (dec x))\n                    (= (second (first acc)) x))\n              (cons [(first (first acc)) x] (rest acc))\n              (cons [x x] acc))))\n        []\n        (sort xs))))","problem":"171","user":"52a88c4de4b0c58976d9ac30"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [coll (distinct (sort coll))\n          grp (reduce (fn [acc x]\n                        (if (= x (+ 1 (last (:curr acc))))\n                          (update-in acc [:curr] conj x)\n                          (-> acc\n                              (update-in [:all] conj (:curr acc))\n                              (assoc :curr [x]))))\n                      {:curr [(first coll)] :all []}\n                      (rest coll))]\n      (->> (conj (:all grp) (:curr grp))\n           (map (fn [grp] [(first grp) (last grp)]))))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (loop [my-coll (sort coll) result [] curr-interval [(first my-coll) (first my-coll)]]\n      (cond\n       (empty? my-coll) (concat result [curr-interval])\n       (= (last curr-interval) (first my-coll)) (recur (rest my-coll) result curr-interval)\n       (= (inc (last curr-interval)) (first my-coll)) (recur (rest my-coll) result [(first curr-interval) (first my-coll)])\n       :otherwise (recur (rest my-coll) (concat result [curr-interval]) [(first my-coll) (first my-coll)])))))","user":"51eec1a6e4b0871fa145d98d"},{"problem":"171","code":"(fn intervals \n                    [the-list]\n                    (map (fn [x] [(apply min x) (apply max x)]) \n                         (reverse (reduce (fn \n                                            [acc itm]\n                                            (if (or (= (first (first acc)) itm)\n                                                    (= (first (first acc)) (dec itm)))\n                                              (cons (cons itm (first acc)) (rest acc) )\n                                              (cons (cons itm ()) acc ))) \n                                          ()\n                                          (sort the-list)))))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn intervals [s]\n      (if(empty? s)\n        []\n        (let[s (sort s)\n             check (fn[[a b]] (<= (- b a) 1))]\n          (->>\n            (map list (conj s (first s)) (concat s [(last s)]))\n            (partition-by check)\n            (mapcat #(if(check (first %))\n                       [[(first (first %)) (last (last %))]]\n                       (map (fn[[_ x]] [x x]) ( drop-last %))))\n            (vec)))))","problem":"171","user":"5273562ae4b03e8d9a4a7479"},{"problem":"171","code":"(fn [coll]\n    (reverse\n     (reduce\n      (fn [val x]\n        (let [[[f l] & vs] val]\n          (if (and l (= x (inc l)))\n            (list* [f x] vs)\n            (list* [x x] val))))\n      [] (sort (distinct coll)))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn [v]\n    (let [[f & t] (sort v)]\n      (if f\n        (reverse (reduce\n                  (fn [[[a b] & r :as l] e]\n                    (if (<= e (+ 1 b))\n                      (cons [a e] r)\n                      (cons [e e] l)))\n                  [[f f]] t))\n        v)))","problem":"171","user":"52e3e6a8e4b09f7907dd1448"},{"problem":"171","code":"(fn intervals [s]\n  (let [ordered (distinct (sort s))]\n    (loop [x ordered currentseq [] result []]\n      (if (= 0 (count x))\n        (if (empty? currentseq) result (conj result currentseq))\n        (let [ns1 (if (empty? currentseq) [(first x) (first x)] currentseq)\n              inseq?  (or (= (first x) (+ 1 (last ns1 ))) (= (first ns1) (second ns1) (first x)))\n              nextseq (if inseq? [(first ns1) (first x)] [(first x) (first x)])\n              nextresult (if (not inseq?) (conj result currentseq) result)]\n          (recur (next x) nextseq nextresult)\n          )\n        )\n      )   \n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"problem":"171","code":"(fn solution [integers]\n  (if-let [s (seq (apply sorted-set integers))]\n    (let [interval (reduce #(if (= (inc (last %1)) %2) (conj %1 %2) %1) [(first s)] (rest s))]\n      (lazy-seq (cons [(first interval) (last interval)] (solution (drop (count interval) s)))))\n    integers))","user":"5e2ef900e4b05b4b015161fc"},{"problem":"171","code":"(fn intervals [x]\n  (let [[x0 & x] (sort x)\n        get-bounds (fn [x] [(first x) (last x)])]\n    (loop [res [], curr-seq [x0], x0 x0, [x1 & x] x]\n      (cond (nil? x0) res\n            (nil? x1) (conj res (get-bounds curr-seq))\n            (< (- x1 x0) 2) (recur res (conj curr-seq x1) x1 x)\n            true (recur (conj res (get-bounds curr-seq)) [x1] x1 x)))))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"problem":"171","code":"(fn [s]\n  (let [sorted-s (sort s)]\n    (if (empty? s)\n      []\n      (loop [i 1 ret [] start (first sorted-s) end (first sorted-s)]\n        (if (= i (count s))\n          (conj ret [start end])\n          (cond (= (nth sorted-s i) end)\n                  (recur (inc i) ret start end)\n                (= (nth sorted-s i) (inc end))\n                  (recur (inc i) ret start (inc end))\n                :else\n                  (recur (inc i) (conj ret [start end]) (nth sorted-s i) (nth sorted-s i))))))))","user":"56288ccae4b00e49c7cb47ea"},{"code":"(fn interval [ps]\n  (loop [s (rest (sort ps))                                                                             \n         a []\n         cb (first (sort ps))\n         ce cb]\n    (if (seq s)\n      (cond (= ce (first s))\n            (recur (rest s) a cb ce)\n            (= (inc ce) (first s))\n            (recur (rest s) a cb (inc ce))\n            :else\n            (recur (rest s) (conj a [cb ce]) (first s) (first s)))\n       (if cb\n         (conj a [cb ce])\n         a))))","problem":"171","user":"52753740e4b03e8d9a4a74c1"},{"problem":"171","code":"(fn [xs]\n   (->> (set xs)\n        (sort)\n        (reduce\n         #(if (= (dec %2) (last (first %1)))\n            (cons [(first (first %1)) %2] (rest %1))\n            (cons [%2 %2] %1))\n         '())\n        (reverse)))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn g [s]\n(let [new-s (distinct (sort s))\nfg (fn f [s] (if (> (count s) 1) (let [[x y] (first s) [z a] (second s)] (if (= y (- z 1)) (f (concat [[x a]] (drop 2 s))) (concat [(first s)] (f (rest s))))) [(first s)]))\n]\n(remove nil? (fg (map vector new-s new-s)))\n))","problem":"171","user":"5065faf9e4b0313a384e5645"},{"problem":"171","code":"(fn intervals [coll]\n  (let [[fst & rst] ((comp sort distinct) coll)]\n    (if (empty? coll)\n      '()\n      (->> rst\n           (reduce (fn [[[b e] & more :as all] x]\n                     (if (= 1 (- x e))\n                       (cons [b x] more)\n                       (cons [x x] all)))\n                   [[fst fst]])\n           reverse))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [s]\n  (map #(vector (first %) (last %)) \n    (loop [acc [] [x & xs] (sort s) c []]\n      (prn x c)\n      (if x\n        (if (or (= (dec x) (last c)) (= x (last c)) (empty? c))\n          (recur acc xs (conj c x))\n          (recur (conj acc c) xs [x])\n        )\n        (if-not (empty? c)\n          (conj acc c)\n          acc\n        )\n      )\n    )\n  )\n)","problem":"171","user":"51ba8f82e4b0fe3ecfb46434"},{"problem":"171","code":"#(let [a (reduce (fn [a x] \n                     (cond (nil? (:b a)) (assoc a :b x :e x)\n                           (= (:e a) (dec x)) (assoc a :e x)\n                           :else (assoc a :r (conj (:r a) [(:b a) (:e a)]) :b x :e x)))\n            {:r [] :b nil :e nil} (sort (into #{} %)))]\n  (if (:b a) (conj (:r a) [(:b a) (:e a)]) (:r a)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn pr171 [coll]\n  (if (empty? coll)\n    []\n    (let [coll (sort coll)\n        lst (last coll)]\n    (second\n      (reduce (fn [[s v] [x y]] \n                (if (< 1 (- y x)) \n                  [y (conj v [s x])]\n                  [s v]))\n              [(first coll) []] \n              (concat (partition 2 1 coll) [[lst (+ lst 2)]]))))))","problem":"171","user":"51696ee7e4b03f62cda68ce8"},{"problem":"171","code":"(letfn [(consec?\n          [[x y]]\n          (or (== y x)\n              (== y (inc x))))]\n\n  (fn intervals [xs]\n    (->> (into (sorted-set) xs)\n         (mapcat (partial repeat 2))\n         (partition 2 1)\n         (partition-by consec?)\n         (filter (comp consec? first))\n         (map (juxt (comp first first)\n                    (comp last last))))))","user":"5632b0a9e4b0bfe05bf117a8"},{"problem":"171","code":"(fn intervals [s]\n  (let [[head & tail] (sort s)\n        [result-ranges last-begin last-current]\n        (reduce\n         (fn [[ranges begin previous] current]\n           (println begin previous current)\n           (if (> (- current previous) 1)\n             [(conj ranges [begin previous]) current current]\n             [ranges begin current]))\n         [[] head head]\n         tail)]\n    (if (empty? s)\n      []\n      (conj result-ranges [last-begin last-current]))))","user":"5654e024e4b0f9d632dd848d"},{"problem":"171","code":"(fn [a]\n  (->> a\n    (sort)\n    (distinct)\n    (reduce \n      (fn [r x]\n        (let [ll (last r)\n              l2 (if (seq? (seq ll)) (last ll) nil)\n              ]\n          (if (nil? l2)\n            [[x]]\n            (if (= (inc l2) x)\n                (concat\n                  (if (nil? (butlast r))\n                    []\n                    (butlast r)) \n                  [(concat ll [x])])\n                (concat r [[x]])\n            )\n          )\n\n        )\n      )\n    []\n    )\n    (map #(vector (first %) (last %)))\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [ints]\n  (let [sorted (distinct (sort ints))]\n    (loop [start     (first sorted)\n           end       (first sorted)\n           xs        (rest sorted)\n           intervals []]\n      (if (empty? xs)\n        (if (nil? start)\n          intervals\n          (conj intervals [start end]))\n        (if (= (first xs) (inc end))\n          (recur start (inc end) (rest xs) intervals)\n          (recur (first xs) (first xs) (rest xs) (conj intervals [start end])))))))","problem":"171","user":"50e3ddd4e4b01912b3285c47"},{"code":"(fn [nums]\n    (loop [res []\n           l nil h nil\n           [x & rst :as srtd] (sort (set nums))]\n      (cond\n       (empty? srtd) (if (nil? l) res (conj res [l h]))\n       (nil? l)      (recur res x x rst)\n       (= 1 (- x h)) (recur res l x rst)\n       :else         (recur (conj res [l h]) x x rst))))","problem":"171","user":"50763574e4b0a894bb95bf3d"},{"code":"(fn [x]\n         (letfn [(ints\n                   ([[f l] seq]\n                      (cond (empty? seq) [[f l]]\n                            (= (first seq) (inc l)) (ints [f (inc l)] (rest seq))\n                            :otherwise (cons [f l] (ints [(first seq) (first seq)]\n                                                         (rest seq)))))\n                   ([seq] (if (empty? seq) [] (ints [(first seq) (first seq)] (rest seq)))))]\n           (ints (distinct (sort x)))))","problem":"171","user":"5294e44de4b02ebb4ef75016"},{"problem":"171","code":"(fn [integers]\n  (if (empty? integers)\n    ()\n    (let [sorted-ints (sort integers)]\n      (loop [rem-ints (rest sorted-ints)\n             last-int (first sorted-ints)\n             left-end last-int\n             part-res []]\n        (if (empty? rem-ints)\n          (conj part-res [left-end last-int])\n          (let [head (first rem-ints)\n                tail (rest rem-ints)]\n            (if (> head (inc last-int))\n              (recur tail head head (conj part-res [left-end last-int]))\n              (recur tail head left-end part-res))))))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":"171","code":"(fn [s]\n    (if (empty? s)\n      []\n      (let [[h & t] (sort (set s))]\n        (let [result (reduce (fn [acc el] \n                  (if (= (dec el) (last (:current acc)))\n                    (assoc acc :current (conj (:current acc) el))\n                    {:current [el el] :so-far (conj (:so-far acc) [(first (:current acc)) (last (:current acc))])}))\n      {:current [h h] :so-far []}\n      t)]\n        (conj (:so-far result) [(first (:current result)) (last (:current result))])))))","user":"5245e320e4b09dbe66b56177"},{"problem":"171","code":"(fn [coll]\n   (if (empty? coll)\n     []\n     (let [v (distinct (sort coll))]\n       (loop [cur (list (first v))\n              tar (rest v)\n              ret '()]\n         (println tar ret)\n         (if (empty? tar)\n           (for [r (reverse (cons (reverse cur) ret))]\n             [(first r) (last r)])\n           (if (= (inc (first cur)) (first tar))\n             (recur (cons (first tar) cur) (rest tar) ret)\n             (recur (list (first tar)) (rest tar) (cons (reverse cur) ret))\n             )\n           )\n         ))))","user":"55a372f1e4b0acc240e31537"},{"problem":"171","code":"(fn [m]\n  (let [n (apply vector (set (sort m)))\n        sub-list (conj (mapv - (drop 1 n) n) (last n))\n        tl (atom [])\n        f (fn [res idx item]\n            (if (or (not= (nth sub-list idx) 1)\n                    (= (count sub-list) 1))\n              (do\n                (let [head (or (first @tl) item)\n                      r (conj res (vector head item))]\n                  (reset! tl [])\n                  r))\n              (do\n                (swap! tl conj item)\n                res)))]\n    (reduce-kv f [] n)))","user":"572de985e4b0cd1946bd0f7c"},{"problem":"171","code":"(fn intrvl [s]\n  (letfn [(aux [s n] (loop [s s\n                            n n\n                            r []]\n                       (if (empty? s)\n                         [s [(first r) (last r)]]\n                         (let [ns (filter #(not= n %) s)]\n                           (if (= (count s) (count ns))\n                             [ns [(first r) (last r)]]\n                             (recur ns (inc n) (conj r n)))))))]\n    (loop [s s\n           r []]\n      (if (empty? s)\n        r\n        (let [[ns nr] (aux s (apply min s))]\n          (recur ns (conj r nr)))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":"171","code":"(fn intervals [xs]\n   (map (fn [s] [(first s) (last s)])\n        (reduce (fn [s v] (if (seq s)\n                           (if (or (= (last (last s)) v)\n                                   (= (inc (last (last s))) v))\n                             (concat (butlast s) [(conj (last s) v)])\n                             (concat s [[v]]))\n                           [[v]]))\n                []\n                (sort xs))))","user":"4fcf1755e4b03432b189f40c"},{"problem":"171","code":"(fn solve\n  ([coll]\n   (if (empty? coll)\n     coll\n     (let [coll (sort coll)]\n       (solve (rest coll) [] (first coll) (first coll)))))\n  ([coll result s x]\n   (if (seq coll)\n     (let [pred (<= x (first coll) (inc x))]\n       (recur\n        (rest coll)\n        (if pred result (conj result [s x]))\n        (if pred s (first coll))\n        (first coll)))\n     (conj result [s x]))))","user":"60537cd1e4b04c8f2157d152"},{"problem":"171","code":"(fn [s] \n  (->> \n    (distinct s)\n    (sort)\n    (reduce \n      (fn [c e] \n        (if \n          (and (not (empty? c)) \n               (= (inc (last (first c))) e))\n          (conj (rest c) (list (first (first c)) e))\n          (conj c (list e e)))) '())\n    (reverse)))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":"171","code":"(fn [a]\n  (letfn [(t [c]\n            (loop [cl (sort ( into #{} c)) acc []]\n              (if (not ( empty? cl))\n                (recur (drop (count (p cl)) cl) (conj acc (p cl)))\n                acc\n                )\n              )\n            )\n          (p [cl]\n            (if (> 2 (count cl))\n              (into [] cl)\n              (loop [sq (rest cl)  acc [(first cl)]]\n                (if (not (empty? sq))\n                  (if (=  (dec (first sq)) (last acc))\n                    (recur (rest sq) (conj acc (first sq)))\n                    acc\n                    )\n                  acc\n                  )\n                )\n              )\n            )]\n    (map #(vector (first %) (last %)) (t a))\n    )\n  )","user":"581a5fdbe4b0e114eb51a002"},{"problem":"171","code":"#(map (fn [[x & y]]\n                  (if (empty? y)\n                    [x x]\n                    [x (last y)]\n                    )) ((fn f [coll]\n                                     (if (empty? coll)\n                                       []\n                                       (let [x (apply sorted-set coll)\n                                             [a b] (split-with (fn [n] (or (= (first x) n) (x (dec n)))) x)]\n                                         (cons a (f b))))) % ))","user":"567c63f6e4b05957ce8c61bb"},{"problem":"171","code":"(fn [s]\n        (let [s (sort (distinct s))]\n          (loop [s1 s m {} i 1 l 0]\n            (if (empty? s1)\n              (map #(vec (list (apply min %) (apply max %))) (vals m))\n              (let [x (first s1)]\n                (recur (rest s1)\n                       (cond\n                         (nil? (get m i)) (into m {i [x]})\n                         (= (inc l) x) (into m {i (conj (get m i) x)})\n                         (< (inc l) x) (into m {(inc i) [x]}))\n                       (if (< (inc l) x)\n                         (inc i)\n                         i)\n                       x))))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":"171","code":"(fn intervals [lst]\n  (loop [i (first (sort lst))\n         j (first (sort lst))\n         l (sort (map #(first %) (group-by identity lst)))\n         r []]\n    (cond\n      (empty? l) (if (or (nil? i) (nil? j)) r (conj r [i j]))\n      (= (inc (first l)) (second l)) (recur i (inc j) (rest l) r)\n      :else (recur (second l) (second l) (rest l) (conj r [i j])))))","user":"5a653f80e4b0512ff01cd9b2"},{"problem":"171","code":"(fn [xs]\n    (reduce\n      (fn [ranges x]\n        (let\n          [\n            current-range (last ranges)\n            range-end (last current-range)\n          ]\n          (cond\n            (empty? current-range)\n              [[x x]]\n            (= x range-end)\n              ranges\n            (= x (inc range-end))\n              (conj\n                (apply vector (butlast ranges))\n                [\n                  (first current-range)\n                  x\n                ]\n              )\n            :else\n              (conj\n                ranges\n                [x x]\n              )\n          )\n        )\n      )\n      []\n      (sort xs)\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn [xs]\n           (if-let [[x & xs] (seq (sort xs))]\n                   (reduce #(if (<= (- %2 (last (last %1))) 1)\n                                (assoc-in %1 [(dec (count %1)) 1]\n                                           %2)\n                              (conj %1 [%2 %2])) [[x x]] xs) []))","problem":"171","user":"50310b8be4b05b7df5a0b84d"},{"problem":"171","code":"(fn [arg1]\n(cond\n(and (= arg1 [1 2 3])) [[1 3]]\n(and (= arg1 [10 9 8 1 2 3])) [[1 3] [8 10]]\n(and (= arg1 [1 1 1 1 1 1 1])) [[1 1]]\n(and (= arg1 [])) []\n(and (= arg1 [19 4 17 1 3 10 2 13 13 2 16 4 2 15 13 9 6 14 2 11])) [[1 4] [6 6] [9 11] [13 17] [19 19]]\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(letfn [(consec?\n         [[x y]]\n         (or (== y x)\n             (== y (inc x))))]\n  \n  (fn intervals [xs]\n    (->> (into (sorted-set) xs)\n         (mapcat (partial repeat 2))\n         (partition 2 1)\n         (partition-by consec?)\n         (filter (comp consec? first))\n         (map (juxt (comp first first)\n                    (comp last last))))))","problem":"171","user":"532ab0bde4b09d4e7a9b5527"},{"problem":"171","code":"(fn intervals\n  [col]\n  (loop [res [] [x & xs] (sort col)]\n    (let [prev (last (last res))]\n      (cond\n        (nil? x) res\n        (nil? prev) (recur (conj res [x x]) xs)\n        (= x prev) (recur res xs)\n        (= x (inc prev)) (recur (conj (pop res) [(first (last res)) x]) xs)\n        :else (recur (conj res [x x]) xs)))\n    )\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn s \n  ([coll] (if-let [[h & m] (seq (sort (distinct coll)))] (s [h h] m) coll))\n  ([[a b] coll] \n   (if-let [[h & m] (seq coll)]\n     (if (= (inc b) h)\n       (s [a h] m)\n       (cons [a b] (s [h h] m)))\n     (list [a b]))))","problem":"171","user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn intervals\n  [v]\n  (let [[f & t] (sort v)]\n    (if f\n      (reverse\n       (reduce\n        (fn [[[a b] & r :as l] e]\n          (if (<= a e (+ 1 b))\n            (conj r [a e])\n            (conj l [e e])))\n        [[f f]]\n        t))\n      v)))","problem":"171","user":"4ec1923f535dfed6da9c6db2"},{"problem":"171","code":"(fn [coll]\n    (let [scoll (sort coll)]\n      (sort (reduce (fn [accum [l r]]\n                      (if (> (- r  l) 1)\n                        (cons [r r] accum)\n                        (cons [(first (first accum)) r] (rest accum))))\n                    []\n                    (map #(vector %1 %2)\n                         (cons Integer/MIN_VALUE scoll) scoll)))))","user":"4f5e5975e4b0030a34fb2b4d"},{"code":"(fn [coll]\n  (if (empty? coll)\n    (),\n    ((fn step [nums]\n       (lazy-seq\n        (let [start (first nums)]\n          (loop [end start, nums (rest nums)]\n            (if (empty? nums)\n              [[start end]]\n              (let [x (first nums)]\n                (if (= x (inc end))\n                  (recur x (rest nums))\n                  (cons [start end] (step nums)))))))))\n     (into (sorted-set) coll))))","problem":"171","user":"4dabb7b1950ed6eda1bd72f3"},{"problem":"171","code":"(fn [nums]\n  (if (empty? nums) []\n    (let [nums (sort (distinct nums))]\n      (loop [intervals [] \n             n (first nums)\n             start (first nums) \n             nums (rest nums)]\n        (cond \n          (empty? nums)\n          (conj intervals [start n])\n         \n          (= (inc n) (first nums))\n          (recur intervals (inc n) start (rest nums))\n         \n          :else\n          (recur (conj intervals [start n])\n                 (first nums)\n                 (first nums)\n                 (rest nums)))))))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":"171","code":"(fn [s]\n\t\t(if (empty? s)\n\t\t\t[]\n\t\t\t(loop [lst (rest (sort s)) news [] interval (vector (first (sort s))) end (first (sort s))]\n\t\t\t(println lst news interval end)\n\t\t\t(if (empty? lst)\n\t\t\t\t(conj news (conj interval end))\n\t\t\t\t(if (or (= (inc end) (first lst)) (= end (first lst)))\n\t\t\t\t\t(recur (rest lst) news interval (first lst))\n\t\t\t\t\t(recur (rest lst) (conj news (conj interval end)) (vector (first lst)) (first lst))\n\t\t\t\t\t)))))","user":"59368ccae4b02506e01a2979"},{"code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [sorted-coll (sort coll),\n          [f & rs] sorted-coll]\n      (loop [s rs,\n             result [[f f]]]\n        (if-not (seq s)\n          result\n          (let [n (first s),\n                c (count result),\n                [a b] (last result)]\n            (recur (rest s)\n                   (if (or (= b n) (= (inc b) n))\n                     (assoc result (dec c) [a n])\n                     (conj result [n n])))))))))","problem":"171","user":"5341b141e4b00652c8746ecf"},{"code":"(fn t [input]\n  (if (empty? input) \n    []\n    (let [i (distinct (sort input))]\n      (loop [xs (rest i) current [(first i)] acc []]\n        (if (empty? xs)\n          (map (juxt first last) (conj acc current))\n          (if  (= (inc (last current)) (first xs))\n            (recur  (rest xs)  (conj current (first xs)) acc)\n            (recur  (rest xs)  [(first xs)] (conj acc current))))))))","problem":"171","user":"4f0446f9535dcb61093f6bb8"},{"code":"(fn [c]\n  (if (empty? c)\n    []\n    (apply conj (reduce (fn [[r [a b]] x]\n              (if (nil? a)\n                [r [x x]]\n                (if (= x (inc b))\n                  [r [a x]]\n                  [(conj r [a b]) [x x]])))\n            [[] []]\n            (sort (distinct c))))))","problem":"171","user":"4ebaf790535dfed6da9c6d6e"},{"problem":"171","code":"(fn ivalize [seq]\n  (loop [[n & mas :as all] (sort (distinct seq))\n         prior nil\n         basis nil\n         ivs []]\n    (cond\n      (empty? all)\n      (if prior\n        (conj ivs [basis prior])\n        [])\n\n      (nil? prior)\n      (recur mas n n ivs)\n\n      (= n (inc prior))\n      (recur mas n basis ivs)\n\n      :default\n      (recur mas n n (conj ivs [basis prior])))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":"171","code":"(fn intervals\n  [s]\n  (if (empty? s) s\n      (let [[s e a] \n            (let [sorted (sort (into [] (into #{} s)))]\n              (reduce \n               (fn [[cstart cend accum] next]\n                 (if (= next (+ cend 1))\n                   [cstart next accum]\n                   [next next (conj accum [cstart cend])]))\n               [(first sorted) (first sorted) []]\n               (rest sorted)))]\n         (conj a [s e]))))","user":"58152157e4b0f478707a0631"},{"problem":"171","code":"(fn [ys]\n  (letfn ([inter [ys] (reduce (fn [t v] (if (or (= (inc (last t)) v) (= (last t) v)) (conj t v) t)) [(first ys)] (rest ys))])\n    (loop [ res [] xs (sort ys)]\n      (if (empty? xs)\n        res\n        (do (let [in (inter xs)] (recur (conj res [(first in) (last in)]) (drop (count in) xs))))))))","user":"54e24a05e4b024c67c0cf7ce"},{"problem":"171","code":"(fn interval [x]\n  (let [sorted (sort x)]\n    (reduce\n      (fn [acc item]\n        (if (empty? acc)\n          [ [ item item ]]\n          (let [last-index (dec (count acc)) last-value ((acc last-index) 1)]\n            (if (<= (- item last-value) 1)\n               (update-in acc [last-index 1] (fn [x] item))\n               (conj acc [item item])\n            )\n          )\n        )\n      )\n      [ ]\n      sorted\n    )\n  )\n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":"171","code":"(fn d [ll] (if (empty? ll) [] (\n                                            \n                            let [s (sort ll)]\n(\n (fn f [l ret act] (if (empty? l) (concat ret (vector act)) (if (or (= (first l) (inc (second act))) (= (first l) (second act))) (f (rest l) ret (vector (first act) (first l))) (f (rest l) (concat ret (vector act)) (vector (first l) (first l))))))                           \n                            (rest s) [] (vector (first s) (first s))\n)                            \n                            )))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn [s]\n  (if-let [s (seq (sort s))]\n    (#(partition 2 `[~(first s) ~@% ~(last s)]) (mapcat #(when (pos? (- %1 %2 1)) [%2 %1]) (next s) s))\n    ()))","problem":"171","user":"4effb663535dcb61093f6a2e"},{"problem":"171","code":"(fn [xs]    \n   (reduce\n    (fn [a x]  \n      (if (empty? a) [[x x]]      \n        (if (let [y (second (last a))] (or (= (inc y) x) (= x y))) \n          (assoc-in a [(dec (count a)) 1] x) \n          (conj a [x x]))))  \n    [] (sort xs)))","user":"5884e807e4b0f1effa3b76a6"},{"problem":"171","code":"(fn intervals [c]\n  (if (empty? c)\n    c\n    (let [sorted (sort c)]\n      (map (fn [i] [(first i) (last i)]) \n           (reduce #(if (> (- %2 (last (last %1))) 1)\n                      (conj %1 [%2])\n                      (conj (vec (butlast %1))\n                            (conj (last %1) %2)))\n                   [[(first sorted)]] \n                   (rest sorted))))))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn [s]\n  (if-let [s (seq (sort s))]\n    (reduce #(let [[a b] (peek %1)]\n               (cond\n                (= b %2) %1\n                (= (inc b) %2) (conj (pop %1) [a (inc b)])\n                :else    (conj %1 [%2 %2])))\n            [[(first s) (first s)]] s)\n    []\n    ))","problem":"171","user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":"171","code":"(fn [s]\n  (if (empty? s) \n    [] \n    (let [sap (->> (sort s) \n                   (partition 2 1))] \n      (->> (reduce\n            (fn [l [a b]]\n              (if (or (= (inc a) b) (= a b)) \n                (assoc l (dec (count l)) (concat (last l) (list b)))\n                (conj l (list b))))\n            (vector (first sap))\n            (rest sap))\n           (map #(vector (first %) (last %)))))))","user":"53b952eee4b047364c0444e6"},{"problem":"171","code":"(fn [v]\n    (if (seq v)\n      (#(reduce (fn [smaller larger]\n                (let[[sl su] (last smaller)]\n                    (if (>= (inc su) larger) (conj (vec (drop-last smaller)) [sl larger])\n                      (conj smaller (vector larger larger)))))\n                (conj [] (vector (first %) (first %))) %)\n        (sort v))[]))","user":"541619e8e4b01498b1a719f9"},{"problem":"171","code":"(fn my-intervals\n  [coll]\n  (letfn [(get-intervals [[f & the-rest]]\n            (reduce (fn [[interval :as intervals] next-val] ()\n                      (if (<= (dec next-val) (last interval))\n                        (update-in intervals [0] conj next-val)\n                        (into [[next-val]] intervals))\n                      ) [[f]] the-rest))]\n    (if ((comp not empty?) coll)\n      (reverse (map (juxt first last) (get-intervals (sort < coll))))\n      [])))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":"171","code":"#((fn find-ranges [l]\n  (letfn [\n    (find-range [l]\n      (loop [s (rest l) p (first l)]\n        (if (or (empty? s) (> (- (first s) p) 1))\n          (vector (vector (first l) p) s)\n          (recur (rest s) (first s)))))]\n    (if (not (seq l)) []\n      (let [r (find-range l)]\n        (lazy-seq\n          (cons (r 0) (find-ranges (r 1)))))))) (sort %))","user":"5590e55de4b0277789237676"},{"problem":"171","code":"(fn __\n  [coll]\n  (letfn\n    [(get-intervals [coll]\n                    (loop [acc []\n                           curr-low (first coll)\n                           last-seen (first coll)\n                           coll (rest coll)]\n                      (cond\n\n                       (and (empty? coll) (nil? curr-low)) []\n\n                       (empty? coll) (conj acc (vector curr-low last-seen))\n\n                       (= (inc last-seen) (first coll))\n                       (recur\n                        acc\n                        curr-low\n                        (first coll)\n                        (rest coll))\n\n                       :else\n                       (recur\n                        (conj acc (vector curr-low last-seen))\n                        (first coll)\n                        (first coll)\n                        (rest coll))\n\n                       )))]\n    (->\n     coll\n     (distinct)\n     (sort)\n     (get-intervals))))","user":"53ac4719e4b047364c04445c"},{"code":"(fn intervals\n  ([xs] (let [xss (distinct (sort < xs))] (intervals (vec xss) [] (first xss))))\n  ([[x y & zs :as xs] i s]\n   ;; (println \"i: \" i)\n   ;; (println \"x: \" x)\n   ;; (println \"y: \" y)\n   ;; (println \"s: \" s)\n   (cond\n     (empty? xs) i\n     (nil? y) (conj i [s x])\n     (= (inc x) y) (recur (concat [y] zs) i s)\n     :else (recur (concat [y] zs) (conj i [s x]) y))))","problem":"171","user":"52606318e4b03e8d9a4a7036"},{"problem":"171","code":"(fn [s]\n  (let [ss (-> s sort distinct)\n        add (fn [[e t] x] (if (= 1 (- x t)) [e x] [x x]))]\n    (map last (partition-by first (next (reductions add [0 (first ss)] ss))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":"171","code":"(fn [coll]\n  (loop [v [] pv nil [c & etc :as cs] (sort coll)]\n    (if (seq cs)\n      (let [[a b] (last v)]\n        (if (or (nil? pv) (> c (inc b)))\n          (recur (conj v [c c]) v etc)\n          (recur (conj pv [a c]) pv etc)))\n      v)))\n\n;; reduce version \n#_(fn [coll]\n  (first\n    (reduce\n      (fn [[v pv] c]\n        (let [[a b] (last v)]\n          (if (or (nil? pv) (> c (inc b)))\n            [(conj v [c c]) v]\n            [(conj pv [a c]) pv])))\n      [[]]\n      (sort coll))))","user":"4eb70649535d7eef30807373"},{"code":"(fn intervals [coll]\n (map #(if (>= (first %) (dec (second %))) (vector (first %) (last %)) (vector (second %) (last (butlast %))))\n  (filter #(or (>= (first %) (dec (second %)))) \n   (map #(flatten %)\n       (partition-by #(>= (first %) (dec(second %))) \n                     (partition 2 1 (sort (concat coll coll))))))))","problem":"171","user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn  intv [v]\n  (if (empty? v) v\n    (let [sv (sort v)\n          rf (fn [[iv s l] c] (if (> c (inc l)) [(conj iv [s l]) c c] [iv s c]))\n          ufi (reduce rf [[] (first sv) (first sv)] sv)]\n      (conj (first ufi) [(second ufi) (last ufi)])\n      )))","problem":"171","user":"5267d9bde4b03e8d9a4a7188"},{"problem":"171","code":"#(->>\n    %\n    sort\n    (reduce\n     (fn [[prev results] nxt]\n      (if\n        (< 1 (- nxt prev))\n        [nxt (cons [nxt nxt] results)]\n        [nxt (cons [(ffirst results) nxt] (rest results))]\n      )\n     )\n     [-99 nil]\n   )\n   second\n   reverse\n  )","user":"5281a445e4b0757a1b17143a"},{"problem":"171","code":"(fn [ns]\n  (if-let [ns (seq (sort ns))]\n    (loop [lo (first ns), hi (first ns), ns (rest ns), acc []]\n      (if-let [n (first ns)]\n        (cond (= n hi)\n                (recur lo hi (rest ns) acc)\n              (= n (inc hi))\n                (recur lo  n (rest ns) acc)\n              :else\n                (recur  n  n (rest ns) (conj acc [lo hi])))\n        (conj acc [lo hi])))\n    []))","user":"53576356e4b04ce2eb3ed27a"},{"problem":"171","code":"(fn\n  [s]\n  (if (empty? s) []\n    (let [st (sort (seq (set s))) h (first st)]\n      (reduce (fn [a b]\n                (let [c (last a) d (first c) e (last c)]\n                  (if (= 1 (- b e))\n                    (conj (vec (drop-last a)) [d b])\n                    (conj a [b b]))))\n              [[h h]] (rest st)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":"171","code":"(letfn [                                                                                                                                                \n    (my-partition [s]                                                                                                           \n        (let [coll (sort s)]                                                                                                                            \n            (last (reduce                                                                                                       \n                #(let [[prev acc] %1]                                                                                                                   \n                    (if (or (= prev %2) (= prev (dec %2)))                                                                      \n                        [%2 (conj (vec (butlast acc)) (conj (last acc) %2))]                                                                            \n                        [%2 (conj acc [%2])]))                                                                                  \n                [(first coll) [[]]]                                                                                                                     \n                coll))))                                                                                                        \n    (pack-partitions [s] (map #(vector (first %) (last %)) (filter not-empty s)))]                                                                      \n        #(pack-partitions (my-partition %)))","user":"558b50d5e4b027778923762b"},{"problem":"171","code":"(fn [coll]\n  (let [[head & tail] (distinct (sort coll))]\n    (loop [[el & tail] tail\n           [start end] [head head]\n           acc []]\n      (cond (not head) []\n            (not el) (conj acc [start end])\n            (= (dec el) end) (recur tail [start el] acc)\n            :else (recur tail [el el] (conj acc [start end]))))))","user":"50310713e4b05b7df5a0b84c"},{"code":"#(let [[f & t] (sort %)]\n  (if f\n    (reverse\n     (reduce\n      (fn [[[a b] & r :as l] e]\n        (if (<= a e (+ 1 b))\n          (conj r [a e])\n          (conj l [e e])))\n      [[f f]]\n      t))\n    %))","problem":"171","user":"4ee9ddb8535d93acb0a66896"},{"problem":"171","code":"(fn intervals [lst]\n  (if (empty? lst) []\n    (loop [[l1 & ls]     (sort lst)\n           [c1 c2 :as c] [l1 l1]\n           r             []]\n      (cond\n        (nil? l1) (conj r c)\n        (> 2 (- l1 c2)) (recur ls [c1 l1] r)\n        :else (recur ls [l1 l1] (conj r c))))))","user":"4faa9593e4b081705acca1f9"},{"code":"(fn [coll]\n    (if (empty? coll)\n      []\n      (keep-indexed (fn [i x] (if (even? i) [(first x) (last x)] nil))\n                    (partition-by (comp nil? (set coll)) (range (apply min coll) (inc (apply max coll)))))))","problem":"171","user":"4f463dfde4b0d56e7bb92b99"},{"problem":"171","code":"(fn [sq]\n  (loop [sq-it (into [] (map #(vector % %)\n                             (sort sq)))\n         ret-it []]\n    (if (empty? sq-it)\n      ret-it\n      (recur (rest sq-it)\n             (if (empty? ret-it)\n               (conj ret-it (first sq-it))\n               (if (or (= (second (last ret-it))\n                          (ffirst sq-it))\n                       (= (inc (second (last ret-it)))\n                          (ffirst sq-it)))\n                 (conj (into [] (butlast ret-it))\n                       (vector (first (last ret-it)) (ffirst sq-it)))\n                 (conj ret-it (first sq-it))))))))","user":"559d33b3e4b0ec2b359424d9"},{"code":"(fn xx [seq]\r\n  (\r\n\t(comp\r\n\t\tvec\r\n\t\t(fn interval [seq]\r\n\t\t\t(let [x (first seq),y (second seq)]\r\n\t\t\t(if (empty? seq)\r\n\t\t\t\t'()\r\n\t\t\t\t(if (= 1 (count seq))\r\n\t\t\t\t\t(list [x x])\r\n\t\t\t\t\t(let [res (interval (rest seq))]\r\n\t\t\t\t\t\t(if (= x y)\r\n\t\t\t\t\t\t\tres\r\n\t\t\t\t\t\t\t(if (= (inc x) y)\r\n\t\t\t\t\t\t\t\t(conj (rest res) [x (second (first res))])\r\n\t\t\t\t\t\t\t\t(conj res [x x])\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t)\r\n\t\t)\r\n\t\tsort\r\n\t)\r\n\tseq\r\n\t)\r\n)","problem":"171","user":"50bf3015e4b0a6abc6550e5b"},{"problem":"171","code":"(fn [coll](let [sorted (sort (set coll))\n     r (fn [res a](let [l (last (last res))\n                        f (first (last res))]\n                    (if (= l (dec a)) \n                        (concat (drop-last res) [[f a]])\n                        (concat res [[a a]]))))]\n          (if (empty? coll)\n              []\n              (reduce r [[(first sorted) (first sorted)]] (rest sorted)))\n              ))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":"171","code":"(fn [vect1]\n  (if (empty? vect1) []\n    (loop [vect (sort vect1), adder [], ans []]\n      (if (empty? vect) (conj ans (vector (first adder) (last adder)))\n        (if (or (empty? adder) (<= (first vect) (+ (last adder) 1)))\n          (recur (rest vect) (conj adder (first vect)) ans)\n          (recur (rest vect) [(first vect)] (conj ans (vector (first adder) (last adder)))))))))","user":"59369515e4b02506e01a297e"},{"code":"(fn [[& ints]]\n  (loop [remaining (set ints)\n         intervals []]\n    (if (seq remaining)\n      (let [begin (apply min (seq remaining))\n            inseq (take-while remaining (drop begin (range)))\n            end (last inseq)]\n        (recur (into #{} (filter #(< end %) remaining))\n               (conj intervals [begin end])))\n      intervals)))","problem":"171","user":"4ffc10aae4b0678c553fc3d6"},{"problem":"171","code":"(fn __\n  ([xs]\n   (if (empty? xs) xs\n       (__ (distinct (sort xs)) [])))\n  ([xs ret]\n   (let [hi (last xs)\n         low (first xs)\n         trick (concat [low] xs [hi])]\n\n     (->> (rest trick)\n          (map list trick)\n          (filter #(not= (first %) (dec (second %))))\n          (flatten)\n          (rest)\n          (butlast)\n          (partition 2)))))","user":"56069006e4b08b23635d3174"},{"problem":"171","code":"(fn [ns]\n  (if (= ns [])\n    []\n    (let [is (sort (loop [[n & ns] ns is '() ]\n                    (let [nis (for [[min max] is]\n                                (cond (and (<= n max) (>= n min)) [n min max]\n                                      (= n (inc max))             [min n]\n                                      (= n (dec min))             [n max]\n                                      :else                       [min max]))\n                          nis (if (= nis is)\n                                (cons [n n] nis)\n                                (for [[n & r :as rs] nis]\n                                  (if (= 3 (count rs))\n                                    r\n                                    rs)))]\n                      (if ns\n                        (recur ns nis)\n                        nis))))\n          _ (println is)\n          is (loop [[[a b] & iss] is\n                    nis []]\n               (let [mergei (for [[x y] iss\n                                  :when (or (and (<= a y) (>= a x))\n                                            (and (<= b y) (>= b x)))]\n                              (if (<= a y) [a y] [x b]))\n                     [nis iss] (if (empty? mergei)\n                                 [(concat nis [[a b]]) iss]\n                                 [(concat nis mergei) (rest iss)]\n                                 )\n                     _ (println [a b] mergei nis)\n                     ]\n                 (if iss\n                   (recur iss nis)\n                   nis)))]\n      is)))","user":"4f32a7f1e4b0d6649770a095"},{"problem":"171","code":"(fn [coll]\n  (loop [acc []\n         coll (-> coll sort distinct)]\n    (let [n (first coll)]\n      (cond\n       (empty? coll) acc\n       (empty? acc) (recur (conj acc (vector n n)) (rest coll))\n       (= (-> acc last last inc) n) \n       (recur (assoc-in acc [(dec (count acc)) 1] n) (rest coll))\n       :else\n       (recur (conj acc (vector n n)) (rest coll))))))","user":"53e9dce1e4b036ad0777e4bc"},{"code":"(fn [v]\n  (if (empty? v)\n    []\n  (map \n  (fn [i]\n\n    [(first i) (last i)]\n    \n  )\n  \n    (loop [rv [] \n          cv []\n          vv (apply sorted-set v)]\n      (if (first vv)\n        (if (empty? cv)\n          (recur rv (conj cv (first vv)) (rest vv))\n          (if (> (first vv) (inc (last cv)))\n            (recur (conj rv cv) [(first vv)] (rest vv))\n            (recur rv (conj cv (first vv)) (rest vv))\n            )\n          )\n        (conj rv cv)\n        )\n      )    \n  )\n  )\n  )","problem":"171","user":"51bec919e4b013aa0d74b800"},{"code":"(fn [coll]\n (if (empty? coll)\n  []\n  (loop [acc []\n         cur []\n         prev nil\n         coll (sort coll)]\n    (if (empty? coll)\n      (map #(vector (first %) (last %)) (conj acc cur))\n      (let [fst (first coll)]\n        (if (nil? prev)\n          (recur acc (conj cur fst) fst (rest coll))\n          (if (> (- fst prev) 1)\n            (recur (conj acc cur) (conj [] fst) fst (rest coll))\n            (recur acc (conj cur fst) fst (rest coll)))))))))","problem":"171","user":"51195e77e4b055cfb310d499"},{"code":"(fn intervals [s]\n    (let [s (set (sort s))\n         min (first s)\n          max (last s)]\n      (if (empty? s)\n        []\n        (loop [min min max max]\n          (let [current-range (set (range min (inc max)))]\n            (if (clojure.set/subset? current-range s)\n              (cons [min max] (intervals (clojure.set/difference s current-range)))\n              (recur min (dec max))))))))","problem":"171","user":"4e6f578c535d5021c1a8961b"},{"problem":"171","code":"(fn[s](\n  partition 2 (flatten(\n    map (fn[n](\n          if(and \n              (some #{(inc n)} s)\n              (some #{(dec n)} s)\n          ) [] (if(or \n                    (some #{(inc n)} s)\n                    (some #{(dec n)} s)\n                  ) [n] [n n] )\n                \n         )) (distinct(sort s))\n                       ))\n))","user":"56039843e4b04bb52996e1be"},{"code":"(fn [sq]\n  (if (empty? sq) []\n    (loop [[x & xs :as s] (sort sq), start nil, prev nil, result []]\n      (cond (empty? s) (conj result [start prev])\n            (nil? prev) (recur xs x x result)\n            (> (- x prev) 1) (recur xs x x (conj result [start prev]))\n            :else (recur xs start x result)))))","problem":"171","user":"53300924e4b019098a6f8b55"},{"problem":"171","code":"(fn [v]\n  (->> v\n    distinct\n    sort\n    (reduce\n      (fn [m el]\n        (let [prev (-> m last last)]\n          (if (and prev (= (inc prev) el))\n            (update-in m\n                       [(-> m count dec)]\n                       (fn [o] (conj o el)))\n            (conj m [el]))))\n      [])\n    (map #(-> [(apply min %) (apply max %)]))))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":"171","code":"#(letfn [(f [xs]\n               (loop [i 0 y 0]\n                 (if (< i (count xs))\n                   (if (and (< (inc i) (count xs))\n                            (or (= (nth xs i) (nth xs (inc i)))\n                                (= (nth xs i) (dec (nth xs (inc i))))))\n                     (recur (inc i) (inc y))\n                     (inc y))\n                   y)))\n          (g [xs i]\n               (if (zero? i)\n                 (vector)\n                 (vector (nth xs 0) (nth xs (dec i)))))]\n    (loop [ys (sort %) zs []]\n      (if (empty? ys)\n        zs\n        (let [n (f ys)\n              _ (g ys n)]\n          (recur (drop n ys) (conj zs _))))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":"171","code":"(fn intervals[x]\n  (let[fres (for [i (sort (set x))][i i])\n       fun (fn h [a b]\n              (if (= (last (last a)) (dec (last b)))\n                (concat (drop-last a) [(vec(set (conj (last a) (last b))))])\n                (concat a [b])))\n       resolver (fn[x][(first x) (last x)])]\n    (vec(map resolver (reduce fun [] fres)))))","user":"5731e36be4b0cd1946bd0fc9"},{"code":"(fn intervals [c]\r\n  (if (empty? c) []\r\n  (let\r\n    [st (set c)\r\n     s (sort st)\r\n     mx (last s)\r\n     mn (first s)\r\n     r (range mn (inc mx))\r\n     i (map (fn [x] (st x)) r)\r\n     prtn (partition-by #(nil? %) i)\r\n     flt (filter (fn [[x & xs]] x) prtn)\r\n     rs (map (fn [xs] [(first xs) (last xs)]) flt)\r\n     ]\r\n    rs)))","problem":"171","user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [s] (->> s\n             distinct\n             sort\n             (map-indexed #(vector %2 (- % %2)))\n             (group-by second)\n             vals\n             (map (juxt ffirst (comp first last)))))","problem":"171","user":"4ff67852e4b0678c553fc37e"},{"problem":"171","code":"(fn getEndPoints [x] (letfn [(getIntervals [is]\n                                 (loop [res [] todo is]\n                                   (if (empty? todo)\n                                     res\n                                     (let [intvlTuple (getInterval todo)] (recur (conj res (first intvlTuple)) (second intvlTuple))))))\n                               (getInterval [i]\n                                 (loop [newInterval [] remainder i] (cond\n                                                                      (empty? remainder) (list newInterval remainder)\n                                                                      (empty? newInterval) (recur (conj newInterval (first remainder)) (rest remainder))\n                                                                      (= (inc (last newInterval)) (first remainder)) (recur (conj newInterval (first remainder)) (rest remainder))\n                                                                      :default (list newInterval remainder))))]\n                         (map #(if (> (count %) 1)\n                                [(first %) (last %)]\n                                [(first %) (first %)])\n                              (getIntervals (sort (into #{} x))))))","user":"56427910e4b08d4f616f5f19"},{"problem":"171","code":"(fn f [c12]\n  (let [c (sort (distinct c12))]\n    (if (= 1 (count c)) [(concat c c)]\n    (for [x (loop [s (rest c)\n           r [(first c)]\n           res []]\n      (if (and (empty? s) 1) res\n        (let [new-r (cond \n                     (= 1 (- (first s) (last r))) (conj r (first s))\n                     true [(first s)])\n              new-res (cond\n                       (< (count new-r) (count r)) (if (= 1 (count s)) (conj (conj res r) new-r) (conj res r))\n                       (= 1 (count s)) (conj res new-r)\n                       (= 1 (- (first s) (last r))) res\n                       true (conj res r))]\n        (recur (rest s)\n               new-r\n               new-res))))]\n      [(apply min x) (apply max x)]\n          ))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [col]\n  (->> col\n    set\n    (#(map % (when-not (empty? col) (range (apply min col) (inc (apply max col))))))\n    (partition-by nil?)\n    (map #(when (first %) (vector (first %) (last %))))\n    (filter identity)))","problem":"171","user":"4da8dd6e30acd6ed12482a68"},{"problem":"171","code":"(fn f [coll]\n  (letfn [(g [[x & [y & r]]]\n            (if y\n              (cons [x y] (g (cons y r)))))]\n    (let [sorted (sort coll)]\n      (if (empty? sorted) []\n        (partition 2\n          (concat\n            [(first sorted)]\n            (apply concat\n                (filter\n                (fn [[x y]]\n                  (< (inc x) y))\n                (g sorted))\n              )\n            [(last sorted)])\n          )))))","user":"53d78b64e4b0e771c3025466"},{"problem":"171","code":"(fn intervals [coll]\n    (->> coll\n         sort \n         (reduce (fn [acc n]\n                   (let [[a b] (peek acc)]\n                     (assert (or (empty? acc) (>= n b))\n                             \"Input should have been sorted.\")\n                     (cond\n                       (empty? acc)   [[n n]]\n                       (= n b)        acc\n                       (= n (inc b))  (conj (pop acc) [a n])\n                       (> n (inc b))  (conj acc [n n]))))\n                 [])))","user":"4fc6305de4b0ee37620e180b"},{"problem":"171","code":"(fn i\n  ([v]\n    (if (empty? v)\n      v\n      (let [sv (sort v)]\n        (i (rest (distinct sv)) (conj [] (first sv)) []))))\n  ([sv tv ov]\n    (if (empty? sv)\n      (for [nv (conj ov tv)]\n        (if (= (count nv) 1)\n          (apply vector (concat nv nv))\n          (conj [] (first nv) (last nv))))\n      (if (= (first sv) (inc (last tv)))\n        (recur (rest sv) (conj tv (first sv)) ov)\n        (recur (rest sv) [(first sv)] (conj ov tv))))))","user":"5d52bf29e4b0776584bd6f69"},{"problem":"171","code":"(fn intervals\n  [s]\n  (if (empty? s)\n    []\n    (let [sorted (sort s)]\n      (loop [result []\n             remaining (rest sorted)\n             next-interval [(first sorted) (first sorted)]]\n        (let [[head & more] remaining\n              [low high] next-interval]\n          (cond\n            (empty? remaining) (conj result next-interval)\n            (or (= head high)\n                (= head (inc high))) (recur result more [low head])\n            :else (recur (conj result next-interval) more [head head])))))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":"171","code":"(fn intervals [s]\n  (if (empty? s)\n    s\n    (let [sort-unique   (sort (distinct s))\n          map-vec       (map vector sort-unique (cons (dec (first sort-unique)) sort-unique))\n          [vec1  vec2]  (split-with #(= 1 (- (first %) (second %))) map-vec)\n          [vec1m tail]  [(map first vec1) (into [] (map first vec2))]\n          head          (into [] (if (= 1 (count vec1m)) [(first vec1m) (first vec1m)] vec1m)) ]\n      (cons [(first head) (last head)] (intervals tail)))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [x]\n   (loop [l (distinct (sort x))\n          acc []]\n     (if (empty? l)\n       (map (fn [x] (if (= 1 (count x))\n                      [(first x) (first x)]\n                      [(first x) (last x)])) acc)\n       (let [this (first l)\n             llast? (when (not (empty? acc)) (= (inc (last (last acc))) this))]\n         (recur (rest l)\n                (if llast?\n                  (vec (conj (vec (take (dec (count acc)) acc)) (conj (last acc) this)))\n                  (vec (into acc [[this]]))))))))","problem":"171","user":"50a5b7e9e4b0aa96157e2610"},{"problem":"171","code":"(fn [xs] \n    (loop [[s & ss :as all] (into [] (sort xs)), [l u :as i] nil, is []]\n      (cond (empty? all) (if (nil? i) is (conj is i))\n       \t    (nil? i) (recur ss [s s] is) \n            (= s u) (recur ss i is)\n            (= s (inc u)) (recur ss [l s] is)\n            (> s (inc u)) (recur ss [s s] (conj is i)))))","user":"5566d812e4b0c656e3ff1837"},{"problem":"171","code":"(fn intervals\n  ([s] (if (empty? s)\n         []\n         (let [normalized (sort (distinct s))\n                  increments (range (first normalized) (inc (last normalized)))\n                  ret []\n                  current [(first normalized) (first normalized)]]\n              (intervals normalized increments ret current))))\n  ([[nhead & ntail :as normalized] [ihead & itail :as increments] ret current]\n   (println normalized increments ret current)\n   (cond\n     (empty? normalized) (conj ret current)\n     (= nhead ihead) (recur ntail itail ret (assoc current 1 nhead))\n     :else (recur normalized (drop-while (partial > nhead) itail) (conj ret current) [nhead nhead]))))","user":"4dbb0f2d535d1e037afb21b1"},{"problem":"171","code":"(fn intervals [nums]\n  (if (empty? nums)\n    []\n    (let [[n & ns] (distinct (sort nums))]\n      (reduce (fn [intervals new]\n                (if (= new (->> intervals last last inc))\n                  (assoc-in intervals [(dec (count intervals)) 1] new)\n                  (conj intervals [new new])))\n              [[n n]] ns))))","user":"6042219ae4b04b4f332c3e72"},{"code":"(fn intervals [numbers]\n  (if-let [nums (seq (sort numbers))]\n    (loop [start (first nums) stop start nums (rest nums) res []]\n      (if-let [[n & ns] nums]\n        (if (<= (- n stop) 1)\n          (recur start n ns res)\n          (recur n n ns (conj res [start stop])))\n        (conj res [start stop])))\n    []\n  ))","problem":"171","user":"4df3d4f4535d08e6dec9fe2c"},{"problem":"171","code":"(fn [c] (if (empty? c) c (reduce #(if (<= %2 (inc (last (last %)))) (conj (vec (butlast %)) [(first (last %)) %2]) (conj % [%2 %2])) \n                [[(apply min c) (apply min c)]] \n                (sort c))))","user":"5c41db45e4b08cd430848ece"},{"code":"(fn [ints]\n  (loop [intervals-so-far ()\n         remaining-ints (sort (distinct ints))]\n    (cond\n     (empty? remaining-ints) (reverse intervals-so-far)\n     (empty? intervals-so-far) (recur (list [(first remaining-ints) (first remaining-ints)]) (rest remaining-ints))\n     (= (- (first remaining-ints) 1) (second (first intervals-so-far)))\n       (let [most-recent-interval (first intervals-so-far)\n             new-interval [(first most-recent-interval) (first remaining-ints)]]\n         (recur (conj (rest intervals-so-far) new-interval) (rest remaining-ints)))\n     :else (let [new-interval [(first remaining-ints) (first remaining-ints)]]\n             (recur (conj intervals-so-far new-interval) (rest remaining-ints))))))","problem":"171","user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [ls]\n  (let [s-ls (sort ls)]\n    (map #((juxt last first) %)\n      (reverse\n        (filter #(-> % first nil? not)\n          (partition-by nil?\n            (reduce \n              #(into % (if (<= (- %2 (first %)) 1) [%2] [nil %2]))\n              (list (first s-ls))\n              (rest s-ls))))))))","problem":"171","user":"5003ee7de4b0678c553fc446"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs)\n    []\n    (loop [ys (sort xs)\n           l (first ys)\n           r l]\n      (cond\n       (empty? ys) [[l r]]\n       (> (- (first ys) r) 1) (concat [[l r]] (intervals ys))\n       :else (recur (rest ys) l (first ys))))))","user":"55c4e48be4b0e31453f649a7"},{"problem":"171","code":"(fn [items]\n                (loop [current nil\n                       first nil\n                       result []\n                       [item & items] (sort items)]\n                  (if first\n                    (if (or (= (inc current) item)\n                            (= current item))\n                      (if (seq items)\n                        (recur item first result items)\n                        (conj result [first item]))\n                      (if (seq items)\n                        (recur item item (conj result [first current]) items)\n                        (-> result\n                            (conj [first current])\n                            (conj [item item]))))\n                    (if (seq items)\n                      (recur item item result items)\n                      result))))","user":"4e6f8431535d5021c1a8961e"},{"problem":"171","code":"#(reduce (fn [v x]\n          (if-let [[f l] (peek v)]\n            (if (> (- x l) 1)\n              (conj v [x x])\n              (conj (pop v) [f x]))\n            (conj v [x x]))) [] (sort %))","user":"56baa68ce4b0f26550335947"},{"problem":"171","code":"(fn intervals [s]\n  (map #(vector (second (first %)) (second (last %)))\n       (partition-by #(first %)  (map-indexed #(vector (- %2 %1) %2) (set s)))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":"171","code":"(fn [l] \n  (if (empty? l) [] \n    (let [x (sort l)\n          b (map - (drop 1 x) (drop-last 1 x))\n          c (map-indexed vector b)\n          cx (cons [-1 2] c)\n          bcd (filter #(> (second %) 1) cx)\n          starts (->> bcd (map first) (map inc))\n          ends (map dec (conj (vec (drop 1 starts)) (count l)))\n          small (map #(nth x %) starts)\n          big (map #(nth x %) ends)]\n      (map vector small big))))","user":"52faec2ee4b047fd55837004"},{"problem":"171","code":"(fn problem-171\n  [is]\n  (->> is\n       (sort)\n       (distinct)\n       (reduce (fn [[[l r] & rst :as intervalls] i]\n                 (if (and r (= i (inc r)))\n                   (cons [l i] rst)\n                   (cons [i i] intervalls)))\n               ())\n       (reverse)))","user":"58e37946e4b005f69f193cae"},{"code":"(fn [xs]\n  (->> xs\n       sort\n       distinct\n       (map-indexed #(vector % %2))\n       (group-by (fn [[i v]] (- v i)))\n       vals\n       (mapv (fn [x] (mapv peek x)))\n       (mapv #(vector (first %) (peek %))) \n      \n       ))","problem":"171","user":"50217818e4b00bba4502f7a7"},{"code":"(fn [t]\n  (->> t sort distinct\n    (reduce\n      (fn [[[i j] & r :as s] x]\n        (if (or (nil? i) (> x (inc j)))\n          (cons [x x] s)\n          (cons [i (inc j)] r)))\n      [])\n    reverse))","problem":"171","user":"4eb97b2e535dfed6da9c6d54"},{"problem":"171","code":"(fn [S] (reduce (fn [R y] (let [[u v] (last R)] (if (and v (> 2 (- y v))) (conj (vec (drop-last R)) [u y]) (conj R [y y])))) '() (sort S)))","user":"55f6fe09e4b06e875b46cea2"},{"code":"{[1 2 3] [[1 3]]\n [10 9 8 1 2 3] [[1 3] [8 10]]\n [1 1 1 1 1 1 1] [[1 1]]\n [] []\n [19 4 17 1 3 10 2 13 13 2 16 4 2 15 13 9 6 14 2 11] [[1 4] [6 6] [9 11] [13 17] [19 19]]}","problem":"171","user":"50bca033e4b0594b91591c5d"},{"problem":"171","code":"(fn [s] \n  (loop [[x & xs] (sort s) acc []]\n    (cond\n     (nil? x) (partition 2 acc)\n     (= x (last acc)) (recur xs acc)\n     (= (dec x) (last acc)) (recur xs (conj (vec (butlast acc)) x))\n     :else (recur xs (conj acc x x)))))","user":"53c649d3e4b00fb29b221297"},{"problem":"171","code":"(fn [coll]\n  (if-not (empty? coll)\n    (loop [coll (sort coll)\n           acc [[(first coll) (first coll)]]]\n      (let [fc (first coll)\n            fla (first (last acc))\n            lla (last (last acc))]\n        (cond (empty? coll)\n              acc\n              (or (= lla fc)\n                  (= 1 (- fc lla)))\n              (recur (rest coll)\n                     (if (= 1 (count acc))\n                       [[fla fc]]\n                       (concat (drop-last acc) [[fla fc]])))\n              :else\n              (recur (rest coll)\n                     (concat acc [[fc fc]])))))\n    []))","user":"532bce35e4b09d4e7a9b5536"},{"problem":"171","code":"(fn [l]\n  (loop [[x1 & xs] (sort l) res [] l1 -9 l2 nil]\n    (if (nil? x1)\n      (if l2 (conj res [l1 l2]) res)\n      (let [newint (or (nil? l2) (> x1 (inc l2)))]\n        (recur xs (if (and l2 newint) (conj res [l1 l2]) res) (if newint x1 l1) x1) ))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(comp \r\n  reverse \r\n  (partial reduce\r\n    (fn [[[b e] & t] n]\r\n      (if b\r\n        (if (= n (inc e))\r\n          `[~[b n] ~@t]\r\n          `[~[n n] ~[b e] ~@t])\r\n        [[n n]]))\r\n    []) \r\n  distinct \r\n  sort)","problem":"171","user":"50336c6be4b0c6c1199c710f"},{"problem":"171","code":"(fn [c]\n    (->> (map list (sort (set c)) (range))\n         (partition-by #(apply - %))\n         (map #(list (ffirst %) (first (last %))))))","user":"55c5b55fe4b0e31453f649b5"},{"problem":"171","code":"(fn [xs]\n  (if (seq xs)\n    (let [xs (sort xs)\n          idxs (->>\n                (map - (rest xs) xs)\n                (keep-indexed #(when (> %2 1) %1)))]\n      (map (fn [p q]\n                      [(nth xs p) (nth xs q)])\n           (cons 0 (map inc idxs))\n           (concat idxs [(dec (count xs))])))\n    []))","user":"5393185ae4b0b51d73faaeb7"},{"problem":"171","code":"(fn [s]\n   (if (seq s)\n   (->> s sort distinct\n        (reduce (fn [[[a b] & abs :as acc]\n                    x]\n                  (if (<= x (inc b))\n                    (conj abs [a x])\n                    (conj acc [x x])\n                    )\n                  )  (list [(apply min s) (apply min s)]))\n        reverse )\n     [])\n     )","user":"55be39f9e4b01b9910ae2a06"},{"problem":"171","code":"(fn intervals [a-coll]\n  (if (empty? a-coll)\n   []\n   (let [input (sort (vec (set a-coll)))]\n     (map #(-> [(apply min %) (apply max %)])\n          (reduce #(let [coll (last %1)]\n                     (if (empty? coll)\n                       (conj (vec (drop-last %1)) [%2])\n                       (if (= %2 (inc (last coll)))\n                         (conj (vec (drop-last %1)) (vec (conj coll %2)))\n                         (conj %1 [%2]))))\n                  [[]] input)))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":"171","code":"(fn [s] (map #(-> [(first %) (last %)]) (remove #(keyword? (first %)) (partition-by keyword? (mapcat (fn [[a b]] (if (> (- (or b (inc a)) a) 1) [a :b] [a])) (partition-all 2 1 (sort (distinct s))))))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":"171","code":"(fn intervals [coll]\n   (if (= coll [])\n     [] \n     (let [number-list (sort (distinct coll))\n           partitioned-number-list (concat (list\n                                             (list (dec (first number-list))\n                                                   (first number-list))) \n                                           (partition 2 1 number-list))\n           partitioned-squared (partition-by #(reduce - %) partitioned-number-list)\n           distinct-partitioned-squared (map #((comp rest distinct flatten) %) partitioned-squared)\n           edited-distinct-partitioned-squared \n           (concat (list (list (- (first (first distinct-partitioned-squared))2))) distinct-partitioned-squared)\n           partitioned-with-extras (for [i (range (count distinct-partitioned-squared))]\n                                     (if (=\n                                           (dec (first (nth distinct-partitioned-squared i)))\n                                           (last (nth edited-distinct-partitioned-squared  i)))\n                                       (concat (nth edited-distinct-partitioned-squared  i) (nth distinct-partitioned-squared i)) \n                                       (nth distinct-partitioned-squared i)))\n           partitioned-no-extras (concat (remove #(= % \"to-be-removed\") (for [k (range (dec (count partitioned-with-extras)))]\n                                                                          (if (=\n                                                                                (last (nth partitioned-with-extras k))\n                                                                                (first (nth partitioned-with-extras (inc k))))\n                                                                            \"to-be-removed\"\n                                                                            (nth partitioned-with-extras k))))\n                                         (list (last partitioned-with-extras)))]\n       (vec (map #(vector (first %) (last %)) partitioned-no-extras)))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(letfn [(B [a] (first a))\n        (E [a] (second a))\n        (S? [a b]\n          (or (= (E a) (B b))\n              (= (inc (E a)) (B b))))\n        (J [a b]\n          [(B a) (E b)])\n        (M [a as]\n          (cond (empty? as) [a]\n                :else (let [b (first as)\n                            bs (rest as)]\n                        (cond (S? a b) (cons (J a b) bs)\n                              (<= (B b) (B a) (E a) (E b)) as\n                              (< (E a) (B b)) (cons a as)\n                              (S? b a) (M (J b a) bs)\n                              :else (cons b (M a bs))))))\n        (X [ls]\n          (loop [ls ls result []]\n            (if (empty? ls) result\n                (recur (rest ls) (M [(first ls) (first ls)] result)))))]\n  X)","problem":"171","user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [s]\n  (if-let [ss (seq (sort s))]\n    (loop [nums (rest ss) ivals [] start (first ss) end (first ss)]\n      (if-let [n (first nums)]\n        (if (> n (inc end))\n          (recur (rest nums) (conj ivals [start end]) n n)\n          (recur (rest nums) ivals start n))\n        (conj ivals [start end])))\n    []))","problem":"171","user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":"171","code":"(fn i\n  [l]\n  (apply (fn [a b c] (or (and a b c (into a [[b c]]))\n                         a))\n         (reduce\n          (fn [[agg x y] v]\n            (cond (nil? x)       [agg v v]\n                  (= (inc y) v)  [agg x v]\n                  :else          [(conj agg [x y]) v v]))\n          [[] nil nil]\n          (sort (set l)))))","user":"4daeabf6edd6309eace4d15c"},{"problem":"171","code":"(fn intervals [s]\n  (if (empty? s) s\n  (let [s (sort s)\n        h (first s)\n        r (rest s)]\n    (reverse (reduce (fn [acc n]\n                       (let [[lower upper] (first acc)]\n                         (cond\n                           (= n upper) acc\n                           (= n (inc upper)) (cons [lower n] (rest acc))\n                           :else (cons [n n] acc))))\n                     (list [h h])\n                     r)))))","user":"56897739e4b0dcc4269f407d"},{"problem":"171","code":"(fn [v]\n  (if (empty? v) v\n    (let [[f & args] (vec (sort (set v)))]\n      (reduce\n       (fn [nv n]\n         (println nv n)\n         (if (= (inc (last (last nv))) n)\n           (conj (pop nv) (conj (pop (last nv)) n))\n           (conj nv [n n]))) [[f f]] args))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":"171","code":"(fn intervals [xs]\n  (loop [r    [] \n         data (sort (distinct xs))]\n    (if (empty? data) r\n      (let [from (first data)\n            [to rest-data] \n            (loop [[y & ys] data] \n                     (if (or (empty? ys) (> (first ys) (inc y)))\n                       [y ys]\n                       (recur ys)))]\n        (recur (conj r [from to]) rest-data)))))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":"171","code":"(fn [xs] ( let [sxs (sort xs)]\n    (letfn [(fr [res t ys] (if (not (first ys)) (conj res t)\n       (let [f1 (first ys)]\n          (if (not (first t)) (recur res [f1 f1] (rest ys))\n          (cond (= f1 (second t))\n                   (recur res t (rest ys))\n                (= f1 (inc (second t)))\n                   (recur res [(first t) f1] (rest ys) )\n                :else \n                   (recur (conj res t) [f1 f1] (rest ys)) \n          )\n          )\n        ) \n            )     )]\n      (if (not (first xs)) [] \n        (fr [] [(first sxs) (first sxs)] (rest sxs) )\n      )\n    )  \n  ))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":"171","code":"(fn [ls]\n  (sort\n  (loop [ls (distinct (sort ls))\n         part [(first ls) (first ls)]\n         ans []]\n    (if (<= (count ls) 1)\n      (if (nil? (first part)) ans (conj ans part))\n      (if (= (+ (first ls) 1) (second ls))\n        (recur (rest ls) [(first part) (second ls)] ans)\n        (recur (rest ls) [(second ls) (second ls)] (cons part ans)))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":"171","code":"(fn [coll]\n   (if (empty? coll)\n     []\n     (let [sorted (sort > coll)]\n       (loop [start (first sorted)\n              end start\n              coll' (rest sorted)\n              result ()]\n         (if (empty? coll')\n           (cons (list start end) result)\n           (let [[h & t] coll']\n             (if (or (= start h) (= (dec start) h))\n               (recur h end t result)\n               (recur h h t (cons (list start end) result)))))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":"171","code":"(fn [xs]                                                                                                           \n  (loop [sxs (sort xs) h (first sxs) res []]                                                                            \n    (cond (empty? sxs) res                                                                                              \n          (= 1 (count sxs)) (conj res [h (first sxs)])                                                                  \n          :else                                                                                                         \n      (let [f (first sxs) s (second sxs)]                                                                               \n        (if (<= (- s f) 1)                                                                                              \n          (recur (rest sxs) h res)                                                                                      \n          (recur (rest sxs) s (conj res [h f]))                                                                         \n          )                                                                                                             \n        )                                                                                                               \n      )                                                                                                                 \n    )                                                                                                                   \n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"problem":"171","code":"(fn intervals\n  [coll]\n  (letfn [(parts [[x & more :as coll] ret c]\n            (if (seq coll)\n              (if (empty? c)\n                (parts more ret (conj c x))\n                (if (#{0 1} (- x (last c)))\n                  (parts more ret (conj c x))\n                  (parts more (conj ret c) [x])))\n              (if (empty? c) ret (conj ret c))))]\n    (map #(vector (first %) (last %)) (parts (sort coll) [] []))))","user":"557e9d17e4b05c286339e0d8"},{"problem":"171","code":"(fn [c]\n  (->> (sort (distinct c))\n       (reduce #(cond (empty? %) [[%2 %2]]\n                      (= (inc (last (last %))) %2) (concat (butlast %) [[(first (last %)) %2]])\n                      :else (concat % [[%2 %2]])) [])))","user":"543366dde4b0b6b47310fcdf"},{"code":"(fn [x]\n  (if (empty? x)\n    []\n    (let [s (set x)]\n      (map #(vector (apply min %) (apply max %)) \n           (take-nth 2 (partition-by #(nil? (get s %)) (range (apply min s) (inc (apply max s)))))))))","problem":"171","user":"53468f6ce4b084c2834f4a3f"},{"problem":"171","code":"#(map (fn [x] [(first x) (last x)]) (reduce (fn [c x] (if (and (not-empty c) (= (last (last c)) (dec x))) (conj (apply vector (reverse (rest (reverse c)))) (conj (last c) x)) (conj c [x]))) [] (sort (distinct %))))","user":"594d4c57e4b07ddc2dafae87"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    (empty coll)\n    (let [sorted (sort coll)]\n      (reduce #(let [tail (last %)\n                     rbound (second tail)]\n                 (if (< (- %2 rbound) 2)\n                   (conj (vec (butlast %)) (vector (first tail) %2))\n                   (conj % (vector %2 %2))))\n              [[(first sorted) (first sorted)]]\n              (next sorted)))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs) []\n      (letfn [(f [xs from step ints]\n                (if (empty? xs)\n                  (conj ints [from step])\n                  (if (<= 0 (- (first xs) step) 1)\n                    (f (rest xs) from       (first xs) ints)\n                    (f (rest xs) (first xs) (first xs) (conj ints [from step])))))]\n        (let [s (sort xs)]\n          (f (rest s) (first s) (first s) [])))))","user":"5d81b40ce4b0915913b1d379"},{"code":"#(if (empty? %1)\n    []\n    (loop [xs (sort %1)\n           agg []\n           x (first xs)\n           y (second xs)]\n      (if xs\n        (if (<= (- (first xs) y) 1)\n          (recur (next xs) agg x (first xs))\n          (recur (next xs) (conj agg [x y]) (first xs) (first xs)))\n        (conj agg [x y]))))","problem":"171","user":"513d121fe4b0e544971636a2"},{"problem":"171","code":"(fn [coll]\n    (->> coll\n         (sort)\n         (distinct)\n         (reduce\n           (fn [out el]\n             (let [last-interval (last out)]\n               (if (= (last last-interval) (dec el))\n                 (conj (into [] (butlast out)) (assoc last-interval 1 el))\n                 (conj out [el el])))) [])))","user":"569f4dabe4b0542e1f8d1491"},{"problem":"171","code":"(fn i [s]\n  (reduce (fn x\n            [r n]\n            (if (empty? r)\n              (conj r [n n])\n              (let [[f l] (last r)]\n                (if (= l (dec n))\n                  (conj (vec (butlast r)) [f n])\n                  (conj r [n n])))))\n          [] ((comp distinct sort) s)))","user":"51aefceee4b09397d5109797"},{"problem":"171","code":"#(loop [intervals [] sequence (sort %)]\n\t(if (empty? sequence)\n\t\tintervals\n\t\t(let [part (first sequence) lastInterval (last intervals)]\n\t\t\t(cond\n\t\t\t (= part (last lastInterval))\n\t\t\t \t(recur intervals (rest sequence))\n\t\t\t (and (not (nil? (last lastInterval)))  ( = part (inc (last lastInterval))))\n\t\t\t \t(recur  (into (vec (drop-last intervals)) [[(first lastInterval)  part]]) (rest sequence))\n\t\t\t :else\n\t\t\t \t(recur (into intervals [[part part]]) (rest sequence))))))","user":"57986b76e4b039eba2ecb116"},{"problem":"171","code":"(fn [coll]\r\n  (let [[head & tail] (sort coll)]\r\n    (->> (reduce #(concat %1 (if (<= %2 (inc (last %1)))\r\n                               [%2] [nil %2]))\r\n                 [head] tail)\r\n         (partition-by nil?)\r\n         (map (fn [[head & _ :as coll]]\r\n                (when head\r\n                  [head (last coll)])))\r\n         (filter identity)\r\n         (vec))))","user":"55d0e76ae4b0e31453f64a40"},{"problem":"171","code":"(fn [col]\n  (reduce #(if (= (last (last %1)) (dec %2))\n            (assoc-in %1 [(dec (count %1)) 1] %2)\n            (into %1 [[%2 %2]])) [] (sort (set col))))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn [v]\n  (->> (sort v)\n       (partition 2 1)\n       (reduce (fn [ls [c d]]\n                 (let [[a b] (last ls)]\n                   (cond (> (- d c) 1) (conj ls [d d])\n                         (= b c) (assoc ls (dec (count ls)) [a d])\n                         :else (conj ls [c d])))) [])))","problem":"171","user":"5126dbabe4b083bb8f88cf0e"},{"problem":"171","code":"(fn intervals [coll]\n  (reverse (reduce (fn [[[a b] & r :as is] n]\n                     (if (and a (= (inc b) n))\n                       (cons [a n] r)\n                       (cons [n n] is)))\n                   ()\n                   (distinct (sort coll)))))","user":"5f419985e4b0955706451fab"},{"problem":"171","code":"(fn [coll]\n  (reverse (reduce (fn [[[a b] & r :as is] n]\n                     (if (and a (= (inc b) n))\n                       (cons [a n] r)\n                       (cons [n n] is)))\n                   ()\n                   (distinct (sort coll)))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [inlist]\n  (let [sorted (vec (sort inlist))]\n    (reduce\n     (fn eat[result inarg]\n       (if (empty? result) (conj result [inarg inarg])\n           (let [[f n] (last result)]\n             (if (or (= n inarg) (= (inc n) inarg)) (conj (vec (butlast result)) [f inarg])\n                 (conj (vec result) [inarg inarg]))))) [] sorted)))","problem":"171","user":"4fb86dc9e4b081705acca2d8"},{"code":"(fn interval [nums]\n  (if (empty? nums)\n    []\n    (let [sorted-nums (sort (set nums))\n        min-num (apply min nums)]\n    (reverse (reduce #(let [first-num (first (first %1))\n                            last-num (last (first %1))]\n                        (if (= (dec %2) last-num)\n                          (cons (list first-num %2) (drop 1 %1))\n                          (cons (list %2 %2) %1))) '() sorted-nums)))))","problem":"171","user":"52a55adee4b0c58976d9abe7"},{"problem":"171","code":"(fn [coll]\n   (loop [ivs [] xs (sort coll)]\n     (cond (empty? xs) ivs\n           (empty? ivs) (recur [[(first xs) (first xs)]] (rest xs))\n           :else (let [[a b] (last ivs)\n                       x (first xs)]\n                   (cond (and (<= a x) (>= b x)) (recur ivs (rest xs))\n                         (= b (dec x)) (recur (conj (vec (drop-last ivs)) [a x]) (rest xs))\n                         :else (recur (conj ivs [x x]) (rest xs)))))))","user":"55c20bd0e4b0e31453f64972"},{"problem":"171","code":"(fn [v]\n  (->> v\n       distinct sort\n       (map #(list %2 (- %2 %)) (range))\n       (partition-by second)\n       (map (juxt ffirst (comp first last)))))","user":"548b8a50e4b0e286459a11ff"},{"code":"(fn intervals\n  [l]\n  (let [inner \n        (fn [acc coll]\n          (if (not= (first coll) (inc (first acc))) (reverse acc)\n            (recur (conj acc (first coll)) (rest coll))))\n        outer\n        (fn [acc coll]\n          (if (empty? coll) (reverse acc)\n            (let [curr (inner (list (first coll)) (rest coll))]\n              (recur \n               (conj acc curr) (drop (count curr) coll)))))]\n  (map #(vec (list (first %) (last %))) (outer '() (set (sort l))))))","problem":"171","user":"5273e006e4b03e8d9a4a7495"},{"problem":"171","code":"(fn [s]\n  (let [n (sort (set s))\n        f (first n)]\n    (reduce #(if (= (inc (last (last %))) %2)\n               (assoc % (dec (count %)) (assoc (last %) 1 %2))\n               (conj % [%2 %2]))\n            (if f [[f f]] [])\n            (drop 1 n))))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn [xs]\n  (if (empty? xs) []\n    (let [[x & xs] (-> xs sort distinct)]\n      (->> xs\n        (reduce\n          (fn [[y & ys] i]\n            (if (= (first y) (dec i))\n              (cons (cons i y) ys)\n              (list* `(~i) y ys)))\n          `((~x)))\n        reverse\n        (map #(-> [(reduce min %) (reduce max %)]))))))","problem":"171","user":"4f6160a7e4b0defedf855fbe"},{"problem":"171","code":"(fn [v]\n         (let [[fst & rst :as std] (sort (set v))\n               [ivs s e] (reduce (fn [[ivs s e] n] \n                                   (if (= (inc e) n)\n                                     [ivs s n]\n                                     [(conj ivs [s e]) n n]))\n                                 [[] fst fst]\n                                 rst)]\n           (if fst\n            (conj ivs [s e])\n             [])))","user":"4e0e0529535d04ed9115e7b9"},{"code":"(fn [s]\n  (loop [intervals []\n         remaining (sort (set s))\n         lo (first remaining)\n         hi (first remaining)]\n    (cond \n     (empty? remaining) intervals\n     (not= (inc hi) (second remaining)) (recur \n                                 (conj intervals [lo hi]) \n                                 (rest remaining) \n                                 (second remaining) \n                                 (second remaining))\n     :else (recur intervals\n                  (rest remaining)\n                  lo\n                  (inc hi)))))","problem":"171","user":"504e108ce4b078edc5f593b3"},{"code":"(fn [s]\n  (map (fn [p] [(first (first p)) (first (last p))])\n    (partition-by (fn [[a b]] (- a b))\n      (map vector\n        (sort (distinct s))\n        (range)))))","problem":"171","user":"4e5411e8535d8a8b8723a279"},{"problem":"171","code":"(fn [xs]\n   (if (empty? xs)\n     xs\n     (->> (sort xs)\n         (#(reduce\n             (fn [xs x]\n               (let [l (last xs) li (inc l) eq (or (= x l) (= x li)) ret (conj xs x)]\n                 (if (even? (count xs))\n                   (if eq (conj (pop xs) x) ret)\n                   (if eq ret (conj xs l x))\n                   )))\n             [(first %)] (concat (rest %) [(last %)])))\n         (partition 2)\n         )\n     ))","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":"171","code":"#(let [[x & r] (-> % set sort)]\n(if x\n     (apply conj\n            (reduce (fn [[i [s e]] n]\n                      (if (= (inc e) n)\n                        [i [s n]]\n                        [(conj i [s e]) [n n]]))\n                     [[] [x x]]\n                     r))\n     []))","user":"4dbdab4e535d020aff1edf49"},{"problem":"171","code":"(fn intervals [coll]\n  (letfn [(same-i? [head last]\n\t\t    (when last\n              (or (= last head) (= (inc last) head))))]\n    (partition\n     2\n     (loop [[h & t :as c] (sort coll), last nil, acc []]\n       (cond\n        (empty? c)       acc\n        (same-i? h last) (recur t h (conj (pop acc) h))\n        :else            (recur t h (conj acc h h)))))))","user":"541b1f25e4b01498b1a71a63"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs) xs\n    (let [[x & xs] (sort xs)]\n      (reduce\n        (fn [vs x]\n          (let [[x1 x2] (peek vs)]\n            (if (= x x2) vs\n              (if (= x (inc x2))\n                (conj (pop vs) [x1 x])\n                (conj vs [x x])))))\n        [[x x]]\n        xs))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":"171","code":"(fn [xs]\n  (let [highest-max (fn [xs] (second (first xs)))\n        highest-min (fn [xs] (first (first xs)))]\n    (->> xs\n         (sort)\n         (reduce\n           (fn [acc x]\n               (cond\n                 (empty? acc) (cons [x x] acc)\n                 (> (dec x) (highest-max acc)) (cons [x x] acc)\n                 (= (dec x) (highest-max acc)) (cons [(highest-min acc) x] (rest acc))\n                 :else acc))\n           []\n           )\n         (reverse))))","user":"5fa17538e4b0f0ebd91b77e3"},{"code":"(fn intervals\n  [s]\n  (loop [[x & xs :as xss] ((comp sort distinct) s),\n         first nil,\n         last nil,\n         acc []]\n    (cond\n      (empty? xss) (if (nil? first) [] (conj acc [first last]))\n      (nil? last) (recur xs x x acc )\n      (= x (inc last)) (recur xs first x acc )\n      :else (recur xs x x (conj acc [first last])))))","problem":"171","user":"52dd6cc8e4b09f7907dd13e2"},{"problem":"171","code":"(fn [coll]\n    (let [sorted (sort (distinct coll))\n          min (first sorted)\n          init (if (nil? min)\n                 []\n                 [[min min]])\n          run (fn [mem x]\n                (if (= (dec x) (last (last mem)))\n                  (conj (vec (butlast mem)) [(first (last mem)) x])\n                  (conj mem [x x])))]\n      (reduce run init (rest sorted))))","user":"4e837808535db62dc21a62d9"},{"problem":"171","code":"(fn [i]\n   (vec\n    (map (fn [a] (vector (apply min a) (apply max a)))\n         (reduce (fn [x y] (if (empty? x)\n                             (conj x [y])\n                             (if (= (inc (-> x last last)) y)\n                               (conj (-> x butlast vec) (conj (last x) y))\n                               (conj x [y]))))\n                 [] (sort (set i))))))","user":"586b6a0ae4b01531a375e957"},{"problem":"171","code":"(fn intervals [coll]\n  (letfn [(intervals-sorted [coll]\n            (lazy-seq\n             (if-let [[start & rest] (seq coll)]\n               (loop [l rest, prev start]\n                 (if-let [[head & rest] (seq l)]\n                   (if (< (- head prev) 2)\n                     (recur rest head)\n                     (cons [start prev] (intervals-sorted l)))\n                   (cons [start prev] nil))))))]\n    (intervals-sorted (sort coll))))","user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(fn cuga [xs]\n    (if (empty? xs)\n    []\n    (let [s (sort xs)]\n      (reduce (fn [as a]\n        (if (> (- a (last (last as))) 1)\n            (conj as [a a])\n            (conj (vec (butlast as)) [(first (last as)) a])\n        )\n        )\n      [[(first s) (first s)]]\n      s)\n    )\n    )\n)","problem":"171","user":"504f191ae4b0e7ad84dbc4ba"},{"code":"(fn [xs]\n  (let [sxs (sort xs)\n        mark-gap (fn [[f s]] (if (< (- s f) 2) [s] [nil s]))]\n    (->>\n      (map vector (cons (first sxs) sxs) sxs)\n      (mapcat mark-gap)\n      (partition-by nil?) \n      (remove #(nil? (first %)))\n      (map (fn [grp] [(first grp) (last grp)])))))","problem":"171","user":"52015698e4b0d7096e99ddba"},{"problem":"171","code":"(fn [coll]\n  (letfn [(add [intervals i]\n            (if-let [[start end] (peek intervals)]\n              (condp = (- i end)\n                0 intervals\n                1 (-> intervals pop (conj [start i]))\n                (conj intervals [i i]))\n              (conj intervals [i i])))]\n    (reduce add [] (sort coll))))","user":"546ed28be4b00cfc9eacc1a5"},{"code":"#(if (seq %)\n     (let [[f & r] (sort %)]\n       (reverse (reduce (fn [[[a b] & l :as t] x]\n                          (if (<= a x (inc b))\n                            (conj l [a x])\n                            (conj t [x x])))\n                        [[f f]]\n                        r)))\n     %)","problem":"171","user":"4ee88bfb535d93acb0a66881"},{"code":"(fn intervals [v]\n  (let [vs (apply sorted-set v)\n        f (fn [m n] (if-let [v (get m (dec n))] (-> m (dissoc (dec n)) (assoc n (-> v pop (conj n)))) (assoc m n [n n])))]\n    (map #(nth % 1) (sort (reduce f {} vs)))))","problem":"171","user":"4e9519b4535dbda64a6f6b2d"},{"problem":"171","code":"(fn [coll] (if (empty? coll) [] (reduce (fn [a b] (conj a (last b))) [] (partition-by (fn [a] (first a))\n                                                                   (reduce (fn [a b] (if (= (inc (last (last a))) b)\n                                                                                       (conj a (into [] (reverse (conj (drop-last (last a)) b))))\n                                                                                       (conj a [b b])))\n                                                                           [[(first (sort coll)) (first (sort coll))]]\n                                                                           (rest (vec (sort (set coll)))))))))","user":"567f988be4b0feffd0d18ebe"},{"code":"(fn [x]\n(->> (sort x) distinct (interleave (range)) (partition 2)\n  (partition-by #(apply - %)) (map #(map second %))\n  (map (juxt first last))))","problem":"171","user":"528e64b7e4b0239c8a67aedd"},{"code":"(fn [s]\n  (let [[ft & rt :as ss] (sort s)]\n    (reduce \n     (fn [rt x]\n       (let [[a b] (last rt)]\n         (if (or (= x b) (= x (inc b)))\n           (conj (pop rt) [a x])\n           (conj rt [x x]))))\n     (if ft [[ft ft]] [])\n     ss)))","problem":"171","user":"51944aaae4b0142f60b4aedc"},{"problem":"171","code":"(fn intervals-v2 [s]\n  (letfn [(clean [s]\n            (distinct (sort s))\n            )]\n    (if (seq s) \n      (loop [tail (rest (clean s)) prev (first (clean s)) lowest prev res []]\n        (let [head (first tail)]\n          (if (nil? head)\n            (conj res [lowest prev]) \n            (if (= head (inc prev))\n              (recur (rest tail) head lowest res)\n              (recur (rest tail) head head (conj res [lowest prev]))\n              ))\n          )\n        )[]))\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":"171","code":"(fn intervals [coll]\n  (->> ((comp distinct sort) coll)\n       (map-indexed vector)\n       (partition-by #(- (first %) (last %)))\n       (map (partial map last))\n       (map #(vector (first %) (last %)))))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn [c]\n  (let [s (sort c) \n        gaps (filter (fn [[a b]] (> b (inc a))) (partition 2 1 s))\n        ivs (conj (vec (cons (first s) (flatten gaps))) (last s) )]\n        (if (empty? c) [] (partition 2 ivs) )))","problem":"171","user":"4fccdc75e4b0ee37620e186d"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs)\n    xs\n    (map\n     (fn [ry]\n       [(first ry) (last ry)])\n     (reverse\n      (reduce\n       (fn [rs x]\n         (let [r (first rs)\n               x0 (last r)]\n           (if (< (- x x0) 2)\n             (do\n               (cons (conj r x) (rest rs)))\n             (cons [x] rs))))\n       [[(first (sort xs))]]\n       (rest (sort xs)))))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":"171","code":"(fn [s]\n  ((fn [[h & t :as s]]\n    (if (seq s)\n        (->> (reduce #(if (< (inc (peek (peek %1))) %2)\n                     (conj %1 [%2])\n                     (conj (pop %1) (conj (peek %1) %2)))\n                [[h]] t)\n             (map #((juxt first peek) %)))            \n        s)) (sort s)))","user":"548b7db8e4b0e286459a11fd"},{"problem":"171","code":"(fn [coll]\n   (letfn [(contig [[a b]] (= b (inc a)))]\n     (let [pairs (->> (set coll)\n                      sort\n                      (partition 2 1)\n                      (partition-by contig)\n                      (filter #(every? contig %)))\n           main-intervals (->> pairs\n                           (map #(vector (first %) (last %)))\n                           (map (fn [[[a b] [c d]]] [a d])))\n           included (set (flatten pairs))\n           excluded (clojure.set/difference (set coll) included)\n           extras (map #(vector % %) excluded)]\n       (sort (concat main-intervals extras)))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":"171","code":"(fn f\n  ([[x & xs]] (f x xs []))\n  ([xs acc]\n   (let [cont (-> (filter\n             \t   #(or (= % (dec (apply min acc)))\n                        (= % (inc (apply max acc))))\n                   xs))\n         ys (remove (set cont) xs)]\n     (if (= ys xs)\n       acc\n       (f ys (concat acc cont)))))\n  ([x xs acc]\n   (if x\n     (let [cont     (f xs [x])\n           [y & ys] (remove (set cont) xs)]\n       (->> (conj\n             acc\n             [(apply min cont)\n              (apply max cont)])\n            (f y ys)))\n     (sort-by first acc))))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn intervals-via-reduce [coll]\n  (if (empty? coll)\n    []\n    (let [sorted-coll (sort coll)\n          [result curr-start last-elt]\n            (reduce\n              (fn [[result curr-start last-elt] curr-elt]\n                (if (> curr-elt (inc last-elt))\n                  [(conj result [curr-start last-elt]) curr-elt curr-elt]\n                  [result curr-start curr-elt]))\n              [[] (first sorted-coll) (first sorted-coll)] (rest sorted-coll))]\n    (conj result [curr-start last-elt]))))","problem":"171","user":"53070615e4b02e821686979e"},{"code":"(fn [a]\n  (let [a (sort (set a))\n        mi (map-indexed #(vector % %2) a)\n        vs (vals (group-by #(apply - %) mi))\n        is (map #(vector (last (first %)) (last (last %))) vs)]\n  is))","problem":"171","user":"5164867fe4b003cf19fdde3e"},{"code":"#(loop [[l & s] (sort (set %)) b l r []]\n      (cond (nil? l) [] \n            (nil? s) (conj r [b l]) \n            (= 1 (- (first s) l)) (recur s b r)\n            :else (recur s (first s) (conj r [b l]))))","problem":"171","user":"4dae916eedd6309eace4d155"},{"problem":"171","code":";; http://www.4clojure.com/problem/171\n(fn find-intervals\n  [coll]\n  (loop [in (sort (distinct coll))         \n         out []\n         current []]\n    (if (empty? in)\n      (if (empty? current)\n        out\n        (conj out current))      \n      (let [[next-num & rest-nums] in]\n        (if (empty? current)\n          (recur rest-nums out [next-num next-num])\n          (if (= (inc (second current)) next-num)\n            (recur rest-nums out [(first current) next-num])\n            (recur rest-nums (conj out current) [next-num next-num])))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":"171","code":"(fn\n  [coll]\n  (letfn [(r [b n coll]\n            (lazy-seq\n              (if (seq coll)\n                (let [h (first coll)\n                      t (rest coll)\n                      n' (inc n)]\n                  (cond\n                    (= n h)  (r b n t)\n                    (= n' h) (r b n' t)\n                    :else (cons [b n] (r h h t))))\n                (list [b n]))))]\n    (if (seq coll)\n      (let [sc (sort coll)\n            h (first sc)\n            t (rest sc)]\n        (r h h t))\n      []\n      )))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn intervals [coll]\n  (if (seq coll)\n    (let [coll (sort (distinct coll))\n          [y x rst] (reduce (fn [[at start res] nxt]\n                              (if (= 1 (- nxt at))\n                                [nxt start res]\n                                [nxt nxt (conj res [start at])]))\n                            [(first coll) (first coll) []]\n                            (rest coll))]\n      (conj rst [x y]))\n    coll))","problem":"171","user":"50645e12e4b007509339a58a"},{"problem":"171","code":"(fn interval [coll]\n  (letfn [(interval-maker [coll start previous results]\n            (cond \n              (empty? coll)\n                (conj results [start previous])\n              (or (= (first coll) previous) (= 1(- (first coll) previous)))\n                (recur (rest coll) start (first coll) results)\n              :else\n                (recur (rest coll) (first coll) (first coll) (conj results [start previous]))))]\n    (if (empty? coll)\n      coll\n      (let [sorted-coll (sort coll)]\n        (interval-maker (rest sorted-coll) (first sorted-coll) (first sorted-coll) [])))))","user":"57c0917be4b05aa3c4741c95"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs)\n    []\n    (let [sorted (sort (set xs))]\n     (map (fn [xs] [(first xs) (last xs)])(reduce #(if (= (inc (last (last %))) %2)\n                                                     (update-in % [(dec (count %))] (fn [z](conj z %2)))\n                                                     (conj % [%2])) [[(first sorted)]] (rest sorted))))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn [c] (let [c2 (sort (distinct c))] (map (fn [d] (let [m (map second d)] [(first m)(last m) ]  )) (partition-by first (map vector (map-indexed #(- %1 %2) c2) c2))))\n)","problem":"171","user":"4ede8789535d10e5ff6f5337"},{"problem":"171","code":"(fn [s]\n    (let [S (for [x (range (count (distinct s)))] [x ((vec (distinct (sort s))) x)])]\n        (map #(vector (second (first %)) (second (last %)))  (partition-by #(- (first %)(second %)) S))\n      )\n )","user":"5649615be4b0284900eef641"},{"code":"(fn f [s]\n  (if (empty? s) []\n   (let [mx (apply max s) mn (apply min s)]\n    (let [[d] (remove (set s) (range mn mx))]\n     (if (nil? d) [[mn mx]]\n         (cons [mn (dec d)] (f (filter #(> % d) s))))))))","problem":"171","user":"52f818a6e4b047fd55836fcc"},{"problem":"171","code":"(fn find-intervals [list]\n  (reverse\n    (let [sortedList (sort (distinct list))]\n      (loop [sortedList sortedList previous (first sortedList) result []]\n        (if (empty? sortedList)\n          result\n          (let [currentElement (first sortedList)]\n            (if (= (+ previous 1) currentElement)\n              (recur (rest sortedList) currentElement\n                     (conj\n                       (rest result)\n                       (conj [(first (first result))] currentElement)))\n              (recur (rest sortedList) currentElement\n                     (conj result [currentElement currentElement])))))))))","user":"575683aee4b02ea1147992dc"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs)\n    []\n    (let [lo (apply min xs)\n          hi (apply max xs)\n          m (vec (repeat (+ 2 hi) false))\n          a (reduce #(assoc %1 %2 true) m xs)]\n      (loop [i (inc lo), beg lo, out []]\n        (cond\n          (= 2 (- i hi)) out\n          (not= (a i) (a beg))\n            (if (a i)\n              (recur (inc i) i out)\n              (recur (inc i) i (conj out [beg (dec i)]))) \n          :else (recur (inc i) beg out))))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":"171","code":"#(if (empty? %)\n   []\n   (reduce (fn [coll n]\n         (let [[x y] (last coll)]\n           (if (< (- n y) 2)\n             (conj (vec (butlast coll))\n                   [x n])\n             (conj coll [n n]))))\n  \t[[1 1]]\n    (sort %)))","user":"54848141e4b0e286459a119e"},{"problem":"171","code":"(fn [c]\n  (let [c (-> c sort distinct)]\n    (map #(vector (first %) (last %))\n         (map (partial map first)\n              (partition-by second\n                            (map list c (reductions not= true (map (fn [a b] (> (- b a) 1)) c(rest c)))))))))","user":"5541fa50e4b0a04f79299515"},{"problem":"171","code":"(fn [s]\n (letfn [(already-inside [n ranges] (some (fn [[a b]] (<= a n b)) ranges))\n         (adjoining [n ranges] (set (take 2 (filter (fn [[a b]] (some #(= n %) [(dec a) (inc b)])) ranges))))\n         (combine   [ranges n]\n           (if (already-inside n ranges)\n               ranges\n               (let [to-remove (adjoining n ranges)]\n                 (if (seq to-remove)\n                   (conj (apply disj ranges to-remove) [(apply min n (flatten (seq to-remove)))\n                                                  (apply max n (flatten (seq to-remove)))])\n                   (conj ranges [n n])))))]\n   (sort-by first (vec (reduce combine #{} s)))))","user":"545e9cf1e4b01be26fd7467f"},{"code":"(comp (fn is [[l & xs]] (if l\n                          (loop [h l xs xs]\n                            (cond (= (first xs) h) (recur h (rest xs))\n                              (= (first xs) (inc h)) (recur (inc h) (rest xs))\n                              :else (cons [l h] (is xs))))\n                          []))\n      sort)","problem":"171","user":"4e8612f8535db62dc21a62f2"},{"problem":"171","code":"(fn [coll]\n  (reduce (fn [acc e] \n        (if (and (first acc) (= (inc e) (first (first acc))))\n          (cons [e (second (first acc))] (rest acc))\n          (cons [e e] acc)\n       \t))\n     [] (reverse (distinct (sort coll))))\n)","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn [coll]\n             (if (seq coll)\n               (let [data (->> coll set sort)]\n                 (apply conj\n                        (reduce (fn [[ranges [s x]] n]\n                                  (if (= (inc x) n)\n                                    [ranges [s n]]\n                                    [(conj ranges [s x]) [n n]]))\n                                [[] [(first data) (first data)]]\n                                (rest data))))\n               []))","problem":"171","user":"4fdec88fe4b05e33b9224f8e"},{"code":"(fn n171 [coll]\n  ( letfn [(find-inteval [a n]\n                        (loop [a (map-indexed vector a) p []]\n                          (if (empty? a)\n                            p\n                            (recur (rest a) \n                                   (cond \n                                     (= n (dec (first (second (first a))))) [(ffirst a) 0]\n                                     (= n (inc (second (second (first a))))) [(ffirst a) 1]\n                                     :else p)))))\n          (check-cc [a]\n                    (loop [c (rest a) r [] curr (first a)]\n                      (if (empty? c)\n                        (if (nil? curr) r (conj r curr))\n                        (let [con? (= (inc (last curr)) (ffirst c))]\n                          (recur (rest c) \n                                 (if con? r (conj r curr))\n                                 (if con?\n                                   [(first curr) (second (first c))]\n                                   (first c)))))))]\n    (check-cc (sort-by first (loop [c (set coll) a []]\n                               (if (empty? c)\n                                 a\n                                 (let [n (first c) p (find-inteval a n)]\n                                   (recur (rest c) \n                                          (if (empty? p) \n                                            (conj a [n n])\n                                            (assoc-in a p n))))))))))","problem":"171","user":"52b43468e4b0c58976d9ad1b"},{"problem":"171","code":"(fn interv ([c d] (let [a (vec c) b (vec d)]\n                       (if (empty? b) \n                       a \n                       (if (<  (- (first b) (last (last a))) 2) \n                           (interv (concat (butlast a) [(conj (last a) (first b))] ) (next b))\n                           (interv (concat a [[(first b)]]) (next b))))))\n              ([x] (let [sx (sort x)] (if (empty? x) [] (map #(vector (first %) (last %)) (interv [ [(first sx)]] (next sx)))))))","user":"5576e78de4b05c286339e075"},{"problem":"171","code":"(fn [ins]\n    (let [onerange (fn [s]\n                     (let [contig (fn [s] (every? #{1} (map - (rest s) s)))\n                           subseqs (fn [s] (map first\n                                                (map #(split-at %1 s)\n                                                     (range 1 (inc (count s))))))\n                           sd (distinct (sort s))\n                           ltw (last (take-while #(contig %) (subseqs sd)))\n                           rv (if (empty? ltw) [] [(first ltw) (last ltw)])]\n                       [rv (drop (count ltw) sd)]))]\n      (loop [rs [] in ins]\n        (let [[x y] (onerange in)]\n          (if (empty? y)\n             (if (= x []) [] (conj rs x))\n            (recur (conj rs x) y))))))","user":"4e8768f6535dceadca469850"},{"problem":"171","code":"(fn __ [xs]\n  (letfn [(f [xs]\n            (if (empty? xs)\n              nil\n              (lazy-seq\n               (cons (first xs)\n                     (if (= (inc (first xs)) (second xs))\n                       (f (rest xs))\n                       (cons nil (f (rest xs))))))))]\n    (map (fn [xs] [(apply min xs) (apply max xs)])\n         (filter (complement #{'(nil)}) (partition-by (complement nil?) (f (distinct (sort xs)))))))\n  )","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn [y]\r\n(let [x (-> y distinct sort)]\r\n  (vec (reverse (reduce (fn [[[l u] & r :as p] n]\r\n                     (if (= n (inc u))\r\n                       (cons [l n] r)\r\n                       (cons [n n] p)))\r\n                        (if-let [f (first x)]\r\n                          [[f f]]\r\n                          []\r\n                          )\r\n                   (drop 1 x))))))","problem":"171","user":"50ad7888e4b0a40c9cfb08c7"},{"code":"(fn [[h & t :as s]]\n  (reverse\n   (reduce\n    (fn [[[a z] & t :as is] e]\n      (if (and z (<= (- e z) 1))\n        (conj t [a e])\n\t(conj is [e e])))\n    ()\n    (sort s))))","problem":"171","user":"51b9d1f0e4b0e871ca49590b"},{"problem":"171","code":"(fn [coll]\n          (let [gap (fn [[x y]] (> (- y x) 1))\n                collapse-good (fn [v] [[(first (first v)) (last (last v))]])\n                collapse-bad (fn [v] (distinct (apply concat v)))\n                clean (fn [v]\n                        (map-indexed (fn [i t]\n                                       (if (coll? t) t\n                                         (cond\n                                           (zero? i) [t t]\n                                           (= (inc i) (count v)) [t t]\n                                           (coll? (nth v (dec i))) :skip\n                                           (coll? (nth v (inc i))) :skip\n                                           :else [t t]))) v))\n                first-pass (->> coll sort distinct (partition 2 1 '()))]\n            (if (= 1 (count first-pass))\n              [[(ffirst first-pass) (ffirst first-pass)]]\n              (->> first-pass\n                   drop-last\n                   (partition-by gap)\n                   (reduce (fn [sink part]\n                             (concat sink (if (some gap part)\n                                            (collapse-bad part)\n                                            (collapse-good part)))) [])\n                   clean\n                   (filter #(not= :skip %))))))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":"171","code":"(fn f\n  [s]\n  (let [seed    (distinct (sort s))\n        inner-f (fn [[fe & r]]\n                  (if (nil? fe)\n                    []\n                    (reduce (fn [p q]\n                              (if (= q (inc (last (last p))))\n                                (conj (into [] (drop-last p)) (conj (last p) q))\n                                (conj p [q])))\n                            [[fe]] r)))]\n    (map #(vector (first %) (last %)) (inner-f seed))))","user":"54a11042e4b09f271ff37c49"},{"problem":"171","code":"(fn ranga [ls] (let [reor (distinct (sort ls))] (loop [cap [(first reor)] n (first reor) ls reor acc []] (if (empty? ls) acc (if (= (inc n) (second ls)) (recur cap (inc n) (rest ls) acc) (recur [(second ls)] (second ls) (rest ls) (conj acc (conj cap (first ls)))))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":"171","code":"(letfn\n  [(collapse\n     [v]\n     (if (= (count v) 1) (vector (first v) (first v)) (vector (first v) (last v))))\n   (itvl\n     [col]\n     (if (empty? col)\n       col\n       (loop\n       [c (sort col)\n        curr []\n        res []]\n       (let [m? (or\n                  (and (last curr)\n                       (= (inc (last curr)) (first c)))\n                  (= (last curr) (first c)))]\n         (if\n           (seq c)\n           (recur\n             (rest c)\n             (if (empty? curr)\n               (conj curr (first c))\n               (if m?\n                 (conj curr (first c))\n                 [(first c)]))\n             (if (empty? curr)\n               res\n               (if (not m?)\n                 (conj res curr)\n                 res)))\n           (mapv collapse (conj res curr)))))))]\n  itvl)","user":"5e53f8e0e4b027a2e10ac0e7"},{"code":"(fn [col]\n   (let [s (sort col)\n         rs (rest s)]\n     (map #(vector (first (reverse %)) (last (reverse %))) \n          (reduce #(if (or (= 1 (second %2)) (zero? (second %2))) \n                     (concat (butlast %) [(cons (first %2) (last %))]) \n                     (concat % [[(first %2)]])) \n                  [] \n                  (map #(vector % %2) s (concat [1] (map - rs s)))))))","problem":"171","user":"506d5e4ce4b0a302964c5493"},{"code":"(fn [xs]\n  (partition 2 (reduce\n                (fn [acc y]\n                  (cond (empty? acc) [y y] \n                        (= y (inc (last acc))) (concat (drop-last acc) [y])\n                        (= y (last acc)) acc\n                        :else (concat acc [y y])))\n                [] (sort xs))))","problem":"171","user":"510acd6ee4b078ea719210f4"},{"problem":"171","code":"(fn [coll]\n     (if-not (seq coll)\n       []\n       (let [xs (distinct (sort coll))\n             first-num (first xs)]\n         (remove nil?\n                 (map (fn [d]\n                        (cond\n                          (= \"|\" (first d)) nil\n                          (= 1 (count d)) [(first d) (first d)]\n                          :else [(first d) (last d)])\n                        )\n                      (partition-by #(= \"|\" %)\n                                    (:nums\n                                      (reduce\n                                        (fn [{nums :nums\n                                              last :last} b]\n                                          (if (= (inc last) b)\n                                            {:nums (conj nums b) :last b}\n                                            {:nums (conj nums \"|\" b) :last b}))\n                                        {:nums [first-num] :last first-num}\n                                        (rest xs))))))))\n     )","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":"171","code":"(fn intervals [coll]\n  \"Return the sequence of intervals found in coll.\"\n  (let [last-seen (atom -1)\n        coll (sort coll)\n        last-seen (atom (first coll))\n        switch (atom true) ;; Should partition-by partition? We don't care about its value, just the value change.\n        inc-or-identity (fn [x]\n                          (if (> (- x @last-seen) 1)  ;; Previous isn't equal or 1 less: partition.\n                            (reset! switch (not @switch)))\n                          (reset! last-seen x)\n                          @switch)\n        to-intervals (fn [coll] [(first coll) (last coll)])]\n    (map to-intervals (partition-by inc-or-identity coll))))","user":"500900dee4b0144d4f561e42"},{"code":"#(let [s (sort (set %))]\n        (partition 2 (remove nil? (sort (list* (first s) (last s)\n                                              (flatten (filter (fn [[a b]] (> (- b a) 1))\n                                                               (partition 2 1 s))))))))","problem":"171","user":"52593207e4b0cb4875a45cd3"},{"problem":"171","code":"(fn [v]\n   (if (empty? v) []\n       (let [sV (sort v)\n             fv (first sV) \n             [start last groups] \n             (reduce (fn [[start last groups] next]\n                       (if (or (= last next) (= next (inc last)))\n                         [start next groups]\n                         [next next (conj groups [start last])]))\n                     [fv fv []] (rest sV))]\n         (conj groups [start last]))))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":"171","code":"(fn [coll]\n\t(let [s (sort (set coll))\n\t\t  f (flatten (filter #(not= (inc (first %)) (second %)) (partition 2 1 s)))]\n      (if (empty? coll) []\n\t\t  (partition 2 2 (concat [(first s)] f [(last s)])))))","user":"562d869be4b0a45d2ff8301f"},{"problem":"171","code":"#(let [s (map first (partition-by identity (sort %)))\n        n (first s)]\n    (if (empty? s) []\n      (reduce \n        (fn [v n]\n          (if (= (inc (second (last v))) n)\n            (replace {(last v),[(first (last v)) n]} v)\n            (conj v [n n])))           \n        (vector [n n]) \n        (rest s))))","user":"5138d08be4b0a5db03d727db"},{"problem":"171","code":"(fn intervals [xs]\n  (->> xs\n       sort\n       (partition-all 2 1)\n       (#(cons [(ffirst %)] %))\n       (remove (fn [[a b]] (and a b (< (- b a) 2))))\n       flatten\n       (partition 2)\n       ))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":"171","code":"(fn [col]\n  (map #(-> [(second (first %)) (second (last %))]) \n       (partition-by \n         (fn [[x y]] (- y x)) \n         (map vector (range) (sort (distinct col))))))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn [nv] \n    (letfn [(int-recur [coll-remaining int-start int-last accumulated]\n                       (if (empty? coll-remaining)\n                         (conj accumulated (vector int-start int-last))\n                         (let [item (first coll-remaining)]\n                           (if (or (= (dec item) int-last) (= item int-last))\n                             (int-recur \n                               (next coll-remaining) \n                               int-start \n                               item \n                               accumulated)\n                             (int-recur \n                               (next coll-remaining) \n                               item \n                               item \n                               (conj accumulated (vector int-start int-last)))))))]\n      (if (seq nv)\n        (let [_ (type nv)\n              sorted (sort nv)\n              item (first sorted)]\n          (int-recur (next sorted) item item []))\n        [])))","problem":"171","user":"4f43b992e4b0d7d3c9f3fd2c"},{"code":"(fn [ls]\n  (->> (distinct ls)\n    (sort)\n    (reduce\n      (fn [[a i d] x]\n        (if (= (- x d) i)\n            [(conj a (- x d)) i (inc d)]\n            [(conj a x) x 1 ])) \n      [[] 0 0])\n    (first) \n    (frequencies)\n    (map (fn [[e n]] [e (dec (+ e n))]))\n    (vec)))","problem":"171","user":"4fd96694e4b05e33b9224f37"},{"problem":"171","code":"(fn [xs]\n  (loop [[start & _ :as nums] (vec (sort (distinct xs)))\n         intervals []]\n    (if (empty? nums)\n      intervals\n      (let [i (some #(if (not= (get nums %) (+ start %)) %)\n                    (range 1 (inc (count nums))))]\n        (recur (subvec nums i)\n               (conj intervals [start (+ start i -1)]))))))","user":"573d58c8e4b05c31a32c0811"},{"problem":"171","code":"(fn incseqs\n  ([raw] \n   (if (empty? raw)\n     '()\n     (let [[head & tail] (sort raw)]\n         (incseqs head head tail))))\n  ([start cur [head & tail]]\n   (cond\n     (nil? head) [[start cur]]\n     (<= head (inc cur)) (incseqs start head tail)\n     :else (cons [start cur] (incseqs head head tail)))))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn intervals [x]\n  (let [x (set x)\n        parts (fn left [s]\n                (let [point (some #(if (not (contains? s %)) %) (range (first s) (+ 2 (last s))))\n                      cut (partition-by #(> % point) s)]\n                  (if (-> cut count (= 1)) cut\n                    (conj (-> cut second set left) (-> cut first)))))]\n    (if (empty? x) [] (apply vector (map #(vector (first %) (last %)) (parts x))))))","problem":"171","user":"52084f75e4b01ce6bbf31dde"},{"problem":"171","code":"(letfn [(intervals [coll]; assume that collection is sorted\n            (lazy-seq         \n              (when (seq coll)\n                 (let [[hd tl] (split-inc coll)] \n                   (cons [(first hd) (last hd)] (intervals tl)))))\n            )\n          (split-inc [coll]\n               (let [pairs (map vector coll (cons (dec (first coll)) coll))\n                     ps (split-with #(some #{(- (first %) (second %))} [0 1]) pairs)]\n                 (map (partial map first) ps)\n                 ))\n          ]\n    (fn [coll] (intervals (sort coll))))","user":"50eddbc4e4b06330c1f87c4b"},{"problem":"171","code":"(fn intv [c]\n  (let [c (distinct (sort c))\n        red (reduce (fn [[ [x & y :as a] & z :as b] e]\n                      (if (or  (nil? x) (= (dec e) x))\n                        (conj z (conj a e))\n                        (conj b (list e))))\n                    (list (list)) c)]\n    (->> (reverse red)\n         (filter seq)\n         (map (fn [e] [(apply min e) (apply max e)])))))","user":"512b07f7e4b078b06821febb"},{"problem":"171","code":"(fn [ccoll] \n   ((fn [coll] (map (fn [x] [(first x) (last x)])\n                 (filter (fn [x] (number? (first x)))\n                         (partition-by #(= % :split)\n                                       (reduce #(conj (if (> 2 (- %2 (last %))) % (conj % :split)) %2)\n                                               [(first coll)] coll))))) (sort ccoll)))","user":"56f15eade4b04a395b9a048e"},{"problem":"171","code":"(fn [s]\n  (->>\n   s\n   sort\n   (reduce \n    #(if (or (= %2 (last (last %1))) (= (dec %2) (last (last %1))))\n       (conj (vec (butlast %1)) (conj (last %1) %2))\n       (conj %1 [%2])) [])\n  (map (juxt first last))\n  distinct ))","user":"52f0ea04e4b05e3f0be25ee6"},{"problem":"171","code":"(fn [xs]\n  (if (empty? xs) []\n    (let [[x & xs] (sort (set xs))]\n      (reduce (fn [a v]\n                (let [[y z] (last a)]\n                  (if (= v (inc z))\n                    (conj (vec (butlast a)) [y v])\n                    (conj a [v v]))))\n              [[x x]] xs))))","user":"5e3e23d9e4b01d43a70e8e20"},{"code":"(fn [s]\n  (reduce #(if (and (not (empty? %1)) (= (last (last %1)) (dec %2)))\n             (conj (vec (drop-last %1)) [(first (last %1)) %2])\n             (conj %1 [%2 %2]))\n          [] (sort (set s))))","problem":"171","user":"50b668dde4b08fb537db98f2"},{"code":"(fn [l] \n  (reverse\n     (reduce\n        (fn [[[a b] & l :as all] n] \n          (if (or (nil? a) (not= (inc b) n))\n            (cons [n n] all)\n            (cons [a n] l)))\n       nil (sort (set l)))))","problem":"171","user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn intervals [int-seq]\n\t(if (= [] int-seq)\n\t\t[]\n\t\t(let [sorted-int-seq (sort int-seq) f (first sorted-int-seq)\n\t\t\tcomp-res (reduce (fn [result el] \n\t\t\t\t\t\t(let [int-list (first result) last-int (last result) [int-start int-end] last-int]\n\t\t\t\t\t\t\t(if (= 1 (- el int-end))\n\t\t\t\t\t\t\t\t; expanding the interval\n\t\t\t\t\t\t\t\t[int-list [int-start el]]\n\t\t\t\t\t\t\t\t(if (not= el int-end)\n\t\t\t\t\t\t\t\t\t; starting the new-interval\n\t\t\t\t\t\t\t\t\t[(conj int-list last-int) [el el]]\n\t\t\t\t\t\t\t\t\t; no new interval\n\t\t\t\t\t\t\t\t\tresult\t\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t [ [] [f f] ]\n\t\t\t\t\t(rest sorted-int-seq))]\n\t\t\t\t\t(let [[res-int-list last-el] comp-res ]\n\t\t\t\t\t\t(conj res-int-list last-el)\n\t\t\t\t\t)\t\t\n\t\t)\n\t)\n)","problem":"171","user":"52763696e4b03e8d9a4a74d7"},{"problem":"171","code":"(fn intervals [xs]\n  (if (empty? xs) []\n      (let [sorted-xs (distinct (sort xs))\n            partitioned (reduce #(let [last-number (last (last %1))\n                                       interval (- %2 last-number)]\n                                   (if (> interval 1) (conj %1 [%2]) (update-in %1 [(dec (count %1))] conj %2)))\n                                [[(first sorted-xs)]] (rest sorted-xs))]\n        (map (fn [[x & more]] (if (nil? more) [x x] [x (last more)])) partitioned))))","user":"53504fe6e4b084c2834f4ada"},{"problem":"171","code":"(fn [coll]\n  (letfn [(f [[[y & _ :as ys] & yss :as xs] x]\n            (if (or (empty? xs)\n                    (< 1 (- x y)))\n              (cons [x] xs)\n              (cons (cons x ys) yss)))]\n    (->> (sort coll)\n      (reduce f [])\n      (map (juxt last first))\n      (reverse))))","user":"605b7a90e4b079a07f8593fc"},{"problem":"171","code":"(fn [v] (reduce (fn [r e] (let [li (last r)] (if (and li (= (inc (li 1)) e)) (conj (pop r) [(li 0) e]) (conj r [e e])))) [] (distinct (sort v))))","user":"5abe2fc2e4b073f17744271e"},{"problem":"171","code":"(fn intervals\n  [alist]\n  (loop [new-list (sort alist)\n         res []]\n    (cond\n      (empty? (rest new-list)) (mapv (fn [x] [(first x) (last x)]) res)\n      (empty? new-list) (mapv (fn [x] [(first x) (last x)]) res)\n      (or (= 1 (- (second new-list) (first new-list)))\n          (= 0 (- (second new-list) (first new-list)))) (recur (rest new-list)\n                                                               (conj (vec (butlast res))\n                                                                     (concat (last res)\n                                                                             [(first new-list)(second new-list)])))\n      :else (recur (rest new-list) (conj res [(second new-list)])))))","user":"550d9452e4b06e50f9beb15d"},{"problem":"171","code":"(fn intervals [coll]\n  (letfn [(intervals* [start end res [x & more :as coll]]\n            (if (seq coll)\n              (if (= x (inc end))\n                (recur start x res more)\n                (if (= end x)\n                  (recur start end res more)\n                  (recur x x (conj res [start end]) more)))\n              (conj res [start end])))]\n    (let [sorted-coll (sort coll)\n          init (first sorted-coll)]\n      (if (seq coll)\n        (intervals* init init [] (rest sorted-coll))\n        []))))","user":"53fd66a4e4b0de5c418485e3"},{"code":"(fn [c] (if (empty? c) c \n\t          (let [s (sort c)\n\t                res (reduce #(if (or (= (inc (last (last %1))) %2)\n                                       (= (last (last %1)) %2))\n\t                               [(first %1) (conj (last %1) %2)]\n\t                               [(conj (first %1) (last %1)) [%2]])\n\t                      [[] [(first s)]]\n\t                      (rest s))]\n             (map #(vector (first %) (last %)) (conj (first res) (last res))))))","problem":"171","user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn [col]\n       \n       (map #(vec [(first %) (last %)])\n   (reduce (fn [res cur]\n                (let [l (last res)]\n                  (if (and (not-empty l)\n                           (= (inc (last l)) cur))\n                   \n                   (conj (vec (drop-last res)) (conj l cur))\n                   (conj res [cur])))) [] (set (sort col))))\n      \n       )","problem":"171","user":"525ed5f4e4b0cb4875a45db8"},{"problem":"171","code":"(fn [numbers]\n            (->> (reduce\n                   (fn [result val]\n                     (let [prev-group (last result)\n                           prev-val (when prev-group (last prev-group))\n                           is-inc-by-1? (when prev-val (<= (- val prev-val) 1))]\n                       (if is-inc-by-1?\n                         (assoc result (dec (count result)) (conj prev-group val))\n                         (conj result [val]))))\n                   []\n                   (sort numbers))\n                 (map (fn [coll] [(first coll) (last coll)]))))","user":"53f891eee4b0de5c4184856d"},{"problem":"171","code":"#(if-let [[f & ls] (seq (sort %))]\n     (->> (reduce (fn [acc x]\n                    (let [[f & xs] acc]\n                      (if (or (= (inc (last f)) x) (= (last f) x))\n                        (conj xs (conj f x))\n                        (conj acc [x])))) (list [f]) ls)\n          (map (fn [xs] [(first xs) (last xs)]))\n          reverse)\n     [])","user":"5d29c06be4b01671435dbc6b"},{"problem":"171","code":"(fn intervals [coll]\n  (if-not (seq coll)\n    []\n    (let [sorted-coll (sort coll)]\n      (loop [s       (rest sorted-coll)\n             result  []\n             begin   (first sorted-coll)\n             end     begin]\n        (cond (not (seq s)) (conj result [begin end])\n              (< (inc end) (first s))   (recur (rest s) (conj result [begin end]) (first s) (first s))\n              :else                     (recur (rest s) result begin (first s)))))))","user":"562268dce4b03f08ee9a9224"},{"problem":"171","code":"(fn [xs]\n    (->> xs\n         distinct\n         sort\n         (reduce (fn [ret e]\n                   (if-let [curr (ffirst ret)]\n                     (if (= (inc curr) e)\n                       (conj (rest ret) (conj (first ret) e))\n                       (conj ret (list e)))\n                     (conj ret (list e))))\n                 '())\n         reverse\n         (map (juxt (partial apply min) (partial apply max)))))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn rangeify [sq]\n    (if (empty? sq)\n      sq\n      (reduce\n        (fn [building inval]\n          (let [lastelt (last building)\n                elt-to-match (last lastelt)]\n            (cond\n              (= elt-to-match inval) building\n              (= elt-to-match (dec inval)) (conj\n                                             (subvec building 0 (dec (count building)))\n                                             [(first lastelt) inval])\n              :else (conj building [inval inval]))))\n        [[(first (sort sq)) (first (sort sq))]] (rest (sort sq)))))","problem":"171","user":"515737f0e4b0b0b4b87062d0"},{"problem":"171","code":"(fn f\n  ([list] (f (sort (distinct list)) []))\n  ([list intervals]\n   (if (empty? list)\n     intervals\n     (f list intervals [(first list) (first list)])))\n  ([list intervals interval]\n   (if (= (second list)\n          (inc (second interval)))\n     (f (rest list) intervals (assoc interval 1 (second list)))\n     (f (rest list) (conj intervals interval)))))","user":"52e1c276e4b09f7907dd142b"},{"code":"(fn [l]\r\n  (if (empty? l)\r\n\t\t[]\r\n\t\t(let [[f & r] (sort (set l))]\r\n\t\t\t(first (reduce (fn [[i a b] x] (if (= (- x b) 1) [i a x] [(conj i [a b]) x x])) [[] f f] (conj (vec r) f))))))","problem":"171","user":"4f8c5f4fe4b02e764a0a5198"},{"code":"(fn f [l]\n  (loop [result [] l (sort l)]\n    (if (seq l)\n      (if (and (seq result)\n               (or (= (-> result last second) (first l))\n                   (= (-> result last second inc) (first l))))\n        (recur (conj (pop result) [(-> result last first) (first l)]) (rest l))\n        (recur (conj result [(first l) (first l)]) (rest l)))\n      result)))","problem":"171","user":"50b1d166e4b03ea880433554"},{"problem":"171","code":"(fn [s]\n  (let [s (apply sorted-set s)\n        mi (vec (map-indexed - s))]\n    (for [r (partition-by #(mi (first %)) (map-indexed vector s))]\n      [(second (first r)) (second (last r))])))","user":"5405ae2be4b0addc1aec6671"},{"problem":"171","code":"(fn [ns] (letfn [(iv' [x xs] (if-not (= (inc x) (first xs)) (list x xs) (iv' (first xs) (rest xs))))\n        (iv [xs] (if (empty? xs) []\n            (let[x (first xs) [x' xs'] (iv' x (rest xs))] \n              (cons (vector x x') (iv xs')))))] (iv (sort (distinct ns)))))","user":"58e7229fe4b056aecfd47cc4"},{"code":"(fn [l]\n  (loop [[h & t] (seq (apply sorted-set l))\n           buf []\n           start nil\n           end nil]\n      (if (nil? h)\n        (if (and start end)\n          (conj buf [start end])\n          buf)\n        (if (nil? end)\n          (recur t buf h h)\n          (if (not= 1 (- h end))\n            (recur t (conj buf [start end]) h h)\n            (recur t buf start h))))))","problem":"171","user":"4e7f4147535db966e863cc3d"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (let [[x & xs] (sort (distinct coll))]\n      (reduce (fn [acc v]\n                (if (= (- v (last (last acc))) 1)\n                  (conj (pop acc) (conj (pop (last acc)) v))\n                  (conj acc [v v]))) [[x x]] xs))))","user":"54ddb556e4b024c67c0cf798"},{"problem":"171","code":"(fn [coll]\n  (if (seq coll)\n    (let [[sorted-first & sorted-rest] (sort coll)\n          [res si li] (reduce (fn [[acc si li] i]\n                                (if (or (= i li) (= (inc li) i))\n                                  [acc si i]\n                                  [(conj acc [si li]) i i]))\n                              [[] sorted-first sorted-first]\n                              sorted-rest)]\n      (conj res [si li]))\n    []))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn f ([s] \n       (f (set s) []))\n      ([s acc]\n      \t(if (empty? s) acc\n          (let [pairs \n                (take-while (partial apply =) (partition 2 (interleave s (iterate inc (first s)))))\n                n_s (drop (count pairs) s)\n                n_acc (conj acc [(ffirst pairs) (first (last pairs))])]\n            (f n_s n_acc)))\n       ))","problem":"171","user":"4f0da4e4535d0136e6c22319"},{"problem":"171","code":"(fn [s] (reduce #(let [x (last %)] (if (or (nil? x) (> (- %2 (last x)) 1)) (conj % [%2 %2]) (conj (into [] (butlast %)) [(first x) %2]))) [] (sort (set s))))","user":"56c08696e4b060a8e693e3aa"},{"problem":"171","code":"(fn [coll]\n    (let [sorted (sort coll)\n          ff (fn ff [coll]\n               (lazy-seq\n                (when (seq coll)\n                  (if (next coll)\n                    (let [distance (- (first (rest coll))\n                                      (first coll))]\n                      (if (>= distance 2)\n                        (cons (first coll)\n                              (cons :distance\n                                    (ff (rest coll))))\n                        (cons (first coll)\n                              (ff (rest coll)))))\n                    (cons (first coll)\n                          (ff (rest coll)))))))\n          inserted (ff sorted)\n          partitioned (partition-by keyword? inserted)\n          no-keywords (remove #(keyword? (first %))\n                              partitioned)\n          intervals (map #(vector (first %)\n                                  (last %))\n                         no-keywords)]\n      intervals))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":"171","code":"(fn [coll]\n  (let [[x & xs] (-> coll set sort)]\n    (if-not x\n      []\n      (->>  (loop [[x' & xs'] xs \n                   interval [x]\n                   intervals []]\n              (cond\n               (not x') (conj intervals interval)\n               (= 1 (- x' (last interval))) (recur xs' (conj interval x') intervals)\n               :else (recur xs' [x'] (conj intervals interval))))\n            (map #((juxt first last) %))))))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn intervals \r\n   ([input] (if (empty? input) [] (intervals (sort (distinct input)) [])))\r\n   ([input result] (intervals (rest input) result (first input) (first input)))\r\n   ([input result head tail] (if (empty? input)\r\n                               (conj result (vector head tail))\r\n                               (let [current (first input)]\r\n                                 (if (= current (inc tail)) \r\n                                   (intervals (rest input) result head current) \r\n                                   (intervals input (conj result (vector head tail)))))))\r\n   )","problem":"171","user":"4eb13d60535d7eef3080733f"},{"problem":"171","code":"(fn [col]\n  (let [xs (sort (distinct col))\n        pairs (map list xs (rest xs))\n        bounds (filter #(> -1 (apply - %)) pairs)\n        ex-bounds (flatten [(take 1 xs) bounds (last xs)])]\n    (partition 2 ex-bounds)))","user":"567d132ee4b05957ce8c61c3"},{"problem":"171","code":"(letfn [(partition-by-continuous\n         [coll]\n         (reduce (fn [r x]\n                   (if-let [l-vec (last r)]\n                     (if (>= (inc (last l-vec)) x)\n                       (assoc r (dec (count r)) (conj l-vec x))\n                       (conj r [x]))\n                     (conj r [x])))\n                 []\n                 coll))]\n  (fn [coll]\n    (mapv (fn [rng] [(first rng) (last rng)])\n          (partition-by-continuous (sort coll)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":"171","code":"(fn [v] (map #(vector (first %) (last %)) \n     (remove #(= '(nil) %) \n             (partition-by nil? (reduce #(if (or (empty? %1) (= %2 (inc (last %1)))) (conj %1 %2) (conj %1 nil %2)) [] (sort (distinct v)))))))","user":"551c66dae4b07993ea3788de"},{"problem":"171","code":"(fn [nums]\n  (let [[x & xs] (sort nums)]\n    (if x\n      (reverse\n       (reduce\n        (fn [[[a b] & r :as intervals] nxt]\n          (if (<= a nxt (+ 1 b))\n            (conj r [a nxt])\n            (conj intervals [nxt nxt])))\n        [[x x]]\n        xs))\n      nums)))","user":"5472d919e4b094393f72dd7b"},{"code":"(fn [x]\n\t(partition 2\n               (keep #({} % %)\n                     (let [[a] (sort x)]\n                       (reduce #(if (#{0 1} (- %2 (last %)))\n                                  (conj (pop %) %2)\n                                  (conj % %2 %2))\n                               [a a] (sort x))))))","problem":"171","user":"528a3e14e4b0239c8a67ae72"},{"problem":"171","code":"(fn [coll]\n  (if-not (seq coll) []\n    (let [sorted-coll (sort coll)]\n      (reduce (fn [intervals x]\n                (let [last-interval-end (second (last intervals))]\n                  (cond (= x last-interval-end) intervals\n                        (= x (inc last-interval-end)) \n                        (assoc-in intervals [(dec (count intervals)) 1] x)\n                        :else (conj intervals [x x]))))\n              [[(first sorted-coll) (first sorted-coll)]]     \n              (rest sorted-coll)))))","user":"529e3a4fe4b04e0c58e87b92"},{"problem":"171","code":"(fn intervals [nums]\n  (if (empty? nums)\n    []\n    (let [s (set nums)\n          max-nums (apply max nums)\n          min-nums (apply min nums)\n          run (take-while #(s %) (range min-nums (inc max-nums)))]\n      (cons [min-nums (last run)] (intervals (drop (count run) (sort s)))))))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"#(let [[y & z] (sort (set %))]\n     (if y\n       (reverse\n         (reduce\n           (fn [[[a b & _] & d] c]\n             (if (= (inc b) c)\n               (cons\n                 [a c]\n                 d)\n               (list*\n                 [c c]\n                 [a b]\n                 d)))\n           [[y y]] z))\n       []))","problem":"171","user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn intervals2 [xs] \n\t(let [intvs (fn intvs ([s f x & xs] \n\t\t(let [step2 (- x f)]\n\t\t      (if (= 1 step2)\n\t\t\t(apply intvs (concat [s x] xs))\n\t\t\t(let [nxt (if (= step2 1) [f x] [x x])\n\t\t\t      results (apply intvs (concat nxt xs))]\n\t\t\t      (cons [s f] results)))))\n\t     ([s f] [[s f]])\n\t     ([f] [])\n\t     ([] []))] \n\t     \t(apply intvs (#(cons (first %) %) (sort (set xs))) )))","problem":"171","user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [s]\n    (loop [[i & is] (sort s)\n           r ()]\n      (if i\n        (recur is (if (empty? r)\n                    [[i i]]\n                    (let [a (ffirst r)\n                          b (second (first r))]\n                      (cond\n                       (<= i b) r\n                       (= (+ 1 b) i) (conj (rest r) [a i])\n                       :else (conj r [i i])))))\n        (reverse r))))","problem":"171","user":"521b9f92e4b0c4ef0be8304c"},{"problem":"171","code":"(fn f[coll]\n  (let [\n        inc-last (fn[v] ( update-in v [(dec(count v)) 1] inc ))\n        reducer (fn [acc el] \n                  (let [\n                        l (last acc)\n                        leaf (conj acc [el el])\n                        ]\n                    (if (nil? l) \n                      leaf \n                      (if (= (inc(last l)) el)\n                        (inc-last acc)\n                        leaf ))))\n                  ]\n                  (reduce reducer [] (sort(set coll)))))","user":"5307e4ece4b02e82168697a9"},{"problem":"171","code":"(fn [L]\n  (loop [cur [], [x & xs :as L] (into [] (set L))]\n    (print L)\n    (cond (nil? x) cur\n          (empty? cur) (recur [[x x]] xs)\n          (= (last (last cur)) (dec x)) (recur (conj (vec (drop-last cur)) [(first (last cur)) x]) xs)\n          true (recur (conj cur [x x]) xs))))","user":"57015a1de4b08d47c97781d4"},{"code":"#(->> % sort distinct (map-indexed (fn [i c] [(- c i) c]))\n             (group-by first) sort\n             (map\n               (fn [x] (->> x second\n                            (map second) (apply (juxt min max))))))","problem":"171","user":"519b2570e4b0ac1b7dced6a3"},{"problem":"171","code":"(fn [a]\n  (if (empty? a)\n    []\n    (let [r (range (apply min a) (inc (apply max a)))]\n      (->> (partition-by #(.contains a %) r)\n           (take-nth 2)\n           (map #(list (first %) (last %)))))))","user":"541ddadbe4b01498b1a71a84"},{"problem":"171","code":"#(if-let [sorted (seq (sort %))]\n\t(loop [nums (rest sorted), prev (first sorted), interval [prev], result []]\n\t\t(if\t(empty? nums)\n\t\t\t(conj result (conj interval prev))\n\t\t\t(let [n0 (first nums), nums' (rest nums)]\n\t\t\t\t(if (or (= prev n0) (= (inc prev) n0))\n\t\t\t\t\t(recur nums' n0 interval result)\n\t\t\t\t\t(recur nums' n0 [n0] (conj result (conj interval prev)))))))\n\t[])","user":"5370b386e4b0fc7073fd6e9b"},{"problem":"171","code":"(fn intervals [coll]\n  (cond\n    (empty? coll) []\n    (= 1 (count coll)) [[(first coll) (first coll)]]\n    :else (let [adjacent-pairs (partition 2 1 (sort coll))\n                [close-pairs rst-pairs] (split-with (fn [[x y]] (<= (- y x) 1)) adjacent-pairs)\n                span (if (empty? close-pairs)\n                       [(ffirst rst-pairs) (ffirst rst-pairs)]\n                       [(ffirst close-pairs) (last (last close-pairs))])\n                rst (map last rst-pairs)]\n            (cons span (intervals rst)))))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn intervals [v]\n  (if (empty? v) []\n      (let [sv (sort v)\n\n            fv (first sv)\n            rv (rest sv)\n\n            [a,i,i2] (reduce \n                      \n                      (fn [[a,i,i2] x]\n                        (if (> (- x i2) 1) \n                          [(conj a [i,i2]),x,x]\n                          [a,i,x]))\n\n\n                      [[],fv,fv]\n                      rv )]\n\n        (conj a [i,i2]) )))","problem":"171","user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [c]\n  (let [s (set c)]\n    (map (juxt first last)\n      (take-nth 2 (partition-by #(contains? s %)\n                     (and (seq s)\n                       (range (apply min s) (inc (apply max s)))))))))","problem":"171","user":"4e8f1ac6535d65386fec2146"},{"problem":"171","code":"#(reverse (reduce (fn [[[s e] & r :as res] v] \n                     (if (= (- v 1) e)\n                       (cons [s v] r)\n                       (cons [v v] res)))\n                   '()\n                   (distinct (sort %))))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":"171","code":"(fn [xs]\n  (reverse\n   (reduce \n    #(if (empty? %1)\n       (cons (vector %2 %2) %1)\n       (let [[ch & re] %1 ]\n         (if (= (last ch) (dec %2))\n           (cons (vector (first ch)  %2)  re)\n           (cons (vector %2 %2) %1))\n         )\n       ) \n    [] \n    (distinct (sort xs))))\n  )","user":"4ec4d723535dcc7ae8597d65"},{"problem":"171","code":"(letfn\n    [(collect-interval [intervals x]\n       (let [prev-interval (or (first intervals) [x x])\n             intervals (rest intervals)\n             [a b] prev-interval]\n         (cond (> x (inc b)) (cons [x x] (cons [a b] intervals))\n               (> x b) (cons [a x] intervals)\n               :else (cons prev-interval intervals))))]\n    (fn intervals [xs]\n      (reverse (reduce collect-interval '() (sort xs)))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn interval\n  ([xs] (interval (sort (distinct xs)) nil))\n  ([xs run]\n     (if (seq xs)\n       (let [x (first xs)\n             start-run #(interval (rest xs) (take 2 (repeat x)))]\n         (if (nil? run)\n           (start-run)\n           (if (= 1 (- x (second run)))\n             (interval (rest xs) [(first run) x])\n             (cons run (start-run)))))\n       (if (nil? run) [] [run]))))","problem":"171","user":"50d93c53e4b0fd36a4b89223"},{"problem":"171","code":"(fn\n  [xs]\n  (let [reducer (fn [acc v]\n                  (let [r (:result acc)\n                        i (:initial acc)\n                        l (:last acc)]\n                    (cond\n                        (nil? i) {:result r :initial v :last v}\n                        (>= (inc l) v) {:result r :initial i :last v}\n                        :else {:result (conj r [i l]) :initial v :last v})))]\n    (->> xs\n      sort\n      (reduce reducer {:result []})\n      ((fn [acc]\n        (if (nil? (:initial acc))\n          [] \n          (conj (:result acc) [(:initial acc) (:last acc)])))))))","user":"566ff0a1e4b0a866af6896ec"},{"problem":"171","code":"(fn [xs]\n(->>\n  xs\n  (sort)\n  (distinct)\n  (reduce (fn [ret v]\n                (cond \n                  (empty? ret)             [v v]\n                  (= v (+ 1 (last ret)))  (conj (vec (butlast ret)) v)\n                  :else                         (conj ret v v)))\n              [])\n  (partition 2)\n)\n)","user":"593f95d8e4b069cdc2982be3"},{"problem":"171","code":"(fn [s]\n    (letfn [(findone [s]\n              (let [r (range (first s) (+ (first s) (count s)))]\n                (seq (map first (take-while (fn [[s r]] (= s r)) (map (fn [s r] [s r]) s r))))))\n           (f [s]\n             (if (empty? s) []\n                 (let [s1 (findone s)]\n                   (cons s1 (f (drop (count s1) s))))))]\n     (let [r (-> s set sort)]\n       (map (fn [s] [(first s) (last s)]) (f r)))))","user":"4f3ec266e4b0e243712b1f8c"},{"problem":"171","code":"(fn solve [xs]\n  (if (empty? xs)\n    []\n    (let [to-ranges (fn to-ranges [start stop [h & more]]\n                      (cond\n                        (nil? h) [[start stop]]\n                        (= (inc stop) h) (recur start h more)\n                        :else (cons [start stop] (to-ranges h h more))))\n          [x & more] (distinct (sort xs))]\n      (to-ranges x x more))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":"171","code":"(fn fc\n   ([l] \n    (if (empty? l)\n      []\n      (let [l (apply sorted-set l)] \n        (fc (rest l) (first l) (first l) []))))\n   ([[f & l] s p r]\n    (cond\n      (nil? f) (conj r [s p])\n      (= (inc p) f) (recur l s (inc p) r)\n      :else (recur l f f (conj r [s p])))))","user":"57d9f603e4b0bd073c20240a"},{"problem":"171","code":"(fn [a]\n   (let [a  (sort a) \n         b  (map #(> %1 (inc %2)) (rest a) a) \n         s  (conj b true)\n         e  (concat b [true])\n         f  (fn [ind xs] (remove nil? (map #(if %1 %2) ind xs) ))\n         ]  \n        (map vector (f s a) (f e a)) \n    ))","user":"55896a0ce4b059ccff29b204"},{"code":"(fn get-intervals [lst]\n  (if (empty? lst)\n      []\n      (let [values (set lst)\n            min-val (apply min lst)\n            max-val (apply max lst)]\n        (map #(vector (first %) (last %))\n             (filter #(not (or (empty? %) (nil? (first %))))\n                     (partition-by nil?\n                                   (map values (range min-val (inc max-val)))))))))","problem":"171","user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn [lst]\n  (if (empty? lst) []\n    (let [s (sort lst)]\n      ((fn [l res now n]\n         (if (empty? l) (conj res (conj now n))\n           (let [a (first l)]\n             (if (or (= a n) (= a (+ n 1)))\n               (recur (rest l) res now a)\n               (recur (rest l) (conj res (conj now n)) (vector a) a)))))\n       (rest s) [] (vector (first s)) (first s)))))","problem":"171","user":"51da631be4b02ceefd947766"},{"problem":"171","code":"(fn intervals [w]\n     (let [helper (fn [v y]\n                    (if (empty? (peek v))\n                      (assoc v (- (count v) 1) (vector y y))\n                    (if (= y (peek (peek v)))\n                      v\n                      (if (= y (inc (peek (peek v))))\n                        (assoc v (- (count v) 1) (assoc (peek v) 1 y))\n                        (conj v (vector y y))))))]\n       (remove empty? (reduce helper [[]] (sort w)))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":"171","code":"(fn f [xs]\n  (->> (sort xs)\n       (distinct)\n       (map #(vector % %2) (range))\n       (partition-by #(- (last %) (first %)))\n       (map #(map last %))\n       (map #(vector (first %) (last %)))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn[sq] \n    (loop[s (sort sq) r []] \n      (if(empty? s) \n        r \n        (let[e (first s) ss (rest s) rl (count r)] \n          (if(empty? r) \n            (recur ss (conj r [e e])) \n            (recur \n              ss \n              (loop[i 0 rr r fnd? false] \n                (if(= i rl) \n                  (if(boolean fnd?) \n                    rr \n                    (conj rr [e e])) \n                  (let[re (nth r i) re-min (nth re 0) re-max (nth re 1)] \n                    (cond \n                      (and (>= e re-min) (<= e re-max)) (recur rl rr true) \n                      (= (dec re-min) e) (recur rl (assoc rr i (assoc re 0 e)) true) \n                      (= (inc re-max) e) (recur rl (assoc rr i (assoc re 1 e)) true) \n                      :else (recur (inc i) rr false)\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )","problem":"171","user":"52e68e61e4b09f7907dd1479"},{"problem":"171","code":"(fn [coll]\n  (let [coll0 (->> coll distinct sort)\n        coll1 (map vector coll0 (concat (rest coll0) [nil]))\n        f (fn [m [cur nxt]]\n            (let [{:keys [start res]} m]\n              (if (or (nil? nxt) (< (inc cur) nxt))\n                (assoc m :res (conj res [start cur]) :start nxt) m)))]\n    ((reduce f {:res [] :start (ffirst coll1)} coll1) :res)))","user":"5f82609ae4b0c071e6c840f9"},{"problem":"171","code":"(fn [coll]\n  (let [sor (->> coll distinct sort)\n        pa (partition 2 1 [nil] sor)\n        pa2 (filter (fn [[a b]] (not= (+ a 1) b)) pa)\n        nn (cons (first sor) (drop-last (flatten pa2)))\n        tt (partition 2 nn)]\n    tt))","user":"56fbf83de4b07572ad1a88da"},{"problem":"171","code":"; The following solution is probably not the most efficient one...\n(fn [xs]\n  (reverse\n    (reduce\n      #(if %1\n        (let [[a b] (first %1)]\n          (cond\n            (= b %2) %1\n            (= (inc b) %2) (conj (rest %1) [a %2])\n            :else (conj %1 [%2 %2])))\n        `(~[%2 %2]))\n      nil\n      (sort xs))))","user":"567b39b6e4b05957ce8c61a3"},{"problem":"171","code":"(fn [s] (if (empty? s) []\n          (let [[x & xs] (sort s)]\n            (reduce (fn [ints x] (if (>= (last (last ints)) (dec x))\n                                   (assoc-in ints [(dec (count ints)) 1] x)\n                                   (conj ints [x x])))\n                    [[x x]]\n                    xs))))","user":"5db92996e4b010eb3c36cd50"},{"problem":"171","code":"(fn ord1[coll](loop[coll (sort (set coll))\n                     ret []\n                     vvv []\n                     ant 0\n                      c 0]\n                 (prn coll ret vvv ant)\n                 (cond\n                   (empty? coll) ret\n                   (and(= 0 c)\n                       (= 1 (count coll))) [[(first coll)(first coll)]]\n                   :else(recur(rest coll)\n                              (cond\n                                (= (inc ant) (first coll)) (cond\n                                                             (= 1 (count coll))(conj ret (conj vvv (first coll)))\n                                                             :else ret)\n                                (and(= 1 (count coll))\n                                    (< (inc ant) (first coll)))(conj ret (conj vvv ant)[(first coll)(first coll)])\n                                (= ant (first coll))ret\n                                :else(conj ret (conj vvv ant)))\n                              (cond\n                                (empty? vvv)(conj vvv (first coll))\n                                (= (inc ant)(first coll)) vvv\n                                :else[(first coll)])\n                              (first coll)\n                              (inc c)))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":"171","code":"(fn intervals [coll]\n  (loop [acc [] v [] coll (sort coll)]\n    (cond\n      (and (empty? coll) (empty? v))\n      acc\n\n      (empty? coll)\n      (conj acc ((juxt first last) v))\n\n      (empty? v)\n      (recur acc (conj v (first coll)) (rest coll))\n\n      (= (first coll) (inc (last v)))\n      (recur acc (conj v (first coll)) (rest coll))\n\n      (some #{(first coll)} v)\n      (recur acc v (rest coll))\n\n      :else\n      (recur (conj acc ((juxt first last) v)) [(first coll)] (rest coll))\n      )\n    )\n  )","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn interval [s]\n  (let [s (sort (distinct s))\n        f (fn [i x] (if (= (inc x) (nth s (inc i) (inc x))) x [x nil]))]\n    (->> (map-indexed f s) flatten (partition-by nil?)\n         (remove #(nil? (first %))) (map #(vector (first %) (last %))))))","problem":"171","user":"50783762e4b0fc74642bff67"},{"problem":"171","code":"#(let [[v w] (reduce (fn[[[a b] t] i]\n            (cond (nil? a) [[i i] []]\n                  (= i b) [[a b] t]\n                  (= i (inc b)) [[a i] t]\n                  1 [[i i] (conj t [a b])]))\n          [[] []]\n          (sort %))] (if (seq v) (conj w v) []))","user":"56824e1be4b0945ebc182a91"},{"problem":"171","code":"(fn intervals [c]\n  (let [c (vec (sort (set c)))\n        d (vec (#(map - (rest %) %) c))\n        v (flatten\n           (map-indexed \n            #(if (= 1 %2) \n               [(c %1) (c (inc %1))]\n               nil) \n            d))]\n    (loop [o (vec (map #(into [%] [%])\n                       (clojure.set/difference\n                        (set c)\n                        (set v))))\n           v (drop-while nil? v)]\n      (if-let [a (first v)]\n        (recur (conj o [a (last (take-while (complement nil?) v))])\n               (drop-while nil? (drop-while (complement nil?) v)))\n        (sort-by first o)))))","user":"57533bc1e4b02ea1147992a6"},{"code":"(fn [s]\n  (let [sss (apply sorted-set s)\n        leftb? #(not (contains? sss (dec %)))\n        rightb? #(not (contains? sss (inc %)))\n        bounds (filter #(or (leftb? %) (rightb? %)) sss)]\n    (loop [a bounds r []]\n      (if (empty? a)\n        r\n        (if (and (leftb? (first a)) (rightb? (first a)))\n            (recur (next a) (conj r [(first a) (first a)]))\n            (if (leftb? (first a))\n                (recur (next a) (conj r [(first a) (fnext a)]))\n                (recur (next a) r)))))))","problem":"171","user":"503e7f06e4b06c4e0e1fa268"},{"problem":"171","code":"(fn intervals [v]\n  (reduce\n   (fn [lst x]\n     (if (empty? lst) [[x x]]\n         (let [hd (last lst)\n               tl (subvec lst 0 (dec (count lst)))\n               a  (first hd)\n               b  (second hd)]\n           (prn lst)\n           (cond\n            (= b x)        (conj tl [a b])\n            (= (inc b) x)  (conj tl [a x])\n            :else          (conj tl [a b] [x x])))))\n   []\n   (sort v))\n  )","user":"530bf87ee4b02e82168697d5"},{"code":"(fn [coll]\n  (let [coll (sort coll)]\n    (if (not (seq coll))\n      []\n      (loop [begin (first coll)\n             end (first coll)\n             coll coll\n             result []]\n        (if (not (seq coll))\n          (conj result [begin end])\n          (if (> 2 (- (first coll) end))\n            (recur begin\n                   (first coll)\n                   (next coll)\n                   result)\n            (recur (first coll)\n                   (first coll)\n                   (next coll)\n                   (conj result [begin end]))))))))","problem":"171","user":"531d34cfe4b08068f379edac"},{"code":"(fn [s]\n   (if (empty? s)\n     []\n     (let [[a & r] (sort s)]\n       (reduce (fn [ints x]\n                 (if (<= x (inc (last (last ints))))\n                   (conj (vec (butlast ints)) [(first (last ints)) x])\n                   (conj ints [x x])))\n               [[a a]] r))))","problem":"171","user":"53224d45e4b09d4e7a9b54c0"},{"problem":"171","code":"(fn I\n  ([coll] \n   (if (empty? coll) [] (I (sort (distinct coll)) [])))\n  ([coll accum] \n   (I (first coll) (next coll) (list [(first coll)])))\n  ([prev [f & nxt] [fa & na :as accum]]\n   (if f\n     (if (= (inc prev) f)\n       (recur f nxt (conj na (conj fa f)))\n       (recur f nxt (conj accum [f])))\n     (map #(vector (first %) (last %)) (reverse accum)))))","user":"5712854ce4b07c98581c3a89"},{"problem":"171","code":"(fn intervals\n  ([coll] (intervals (distinct (sort coll)) []))\n  ([coll acc]\n    (println \"coll\" coll)\n    (cond\n      (and (empty? coll) (not-empty acc)) [[(first acc) (last acc)]]\n      (empty? coll) []\n      (empty? acc) (intervals (next coll) [(first coll)])\n      (= (inc (last acc)) (first coll)) (intervals (next coll) (conj acc (first coll)))\n      :else (concat [[(first acc) (last acc)]] (intervals coll [])))))","user":"5412ef7ee4b01498b1a719da"},{"problem":"171","code":"(fn [coll]\n  (letfn [(f ([result coll]\n              (if (empty? coll)\n                result\n                (f result coll (first coll) (first coll))))\n            ([result coll start end]\n             (if (empty? coll)\n               (conj result [start end])\n               (let [n (first coll)]\n                 (if (> n (inc end))\n                   (recur (conj result [start end]) (rest coll) n n)\n                   (recur result (rest coll) start n))))))]\n    (f [] (sort coll))))","user":"564c7c95e4b0284900eef672"},{"problem":"171","code":"(fn intervals [s]\n  (reduce (fn [memo e]\n            (let [memo (if (empty? memo) [[e e]] memo)\n                  [l h] (nth memo (dec (count memo)))]\n              (cond\n               (= e h) memo\n               (= e (inc h)) (assoc-in memo [(dec (count memo)) 1] e)\n               :else (conj memo [e e])))) \n          [] (distinct (sort s))))","user":"539c736ce4b0b51d73faaf2b"},{"code":"#(if (empty? %) [] (-> (reduce \n       (fn [[r c l] n]\n            (if \n                (= (dec n) l)\n                [(assoc r c n) c n]\n               [(assoc r n n) n n]))\n        [(sorted-map) (first %) (first %)]\n         (into (sorted-set) %)) first seq))","problem":"171","user":"4dc78527535d8a4b2fd7428f"},{"code":"(fn [s]\n  (map\n   ; take the first (min) and last (max) values from each sequential group\n   (juxt (comp second first) (comp second last))\n   ; generate indexes for each item in sorted list, \n   ; partition by difference between index & value yields sequential groups\n   (partition-by (partial apply -) (map-indexed list (distinct (sort s))))))","problem":"171","user":"52039e12e4b0fb7e47ea51ff"},{"problem":"171","code":"(fn [c]\n  (reduce\n   #(if (empty? %)\n      (conj % [%2 %2])\n      (if (= (last (last %)) (dec %2))\n        (conj (vec (butlast %))\n              (vector (first\n                      (last %))\n                    %2) )\n        (conj % [%2 %2])))\n   []\n   (sort (set c))))","user":"5835cb06e4b089d5ab817cea"},{"problem":"171","code":"(fn intervals\n  [coll]\n  (let [[f & r]\n        (->> coll\n             (distinct)\n             (sort <))]\n    (if-not (nil? f)\n     (reduce (fn [c n]\n               (let [[s e] (last c)\n                     unchanged (butlast c)]\n                 \n                 (cond\n                   (<= n e)\n                   c\n\n                   (= n (inc e))\n                   (conj (vec unchanged) [s (inc e)])\n\n                   :else\n                   (conj (vec c) [n n]))))\n             [[f f]] r)\n     [])))","user":"5b759ca8e4b047b03b2036d0"},{"problem":"171","code":"(fn [v] (loop [r [] c (distinct (sort v))] (if (empty? c) r (let [i (first c)] (recur (if (empty? r) [[i i]] (if (= i (inc (second (last r)))) (conj (pop r) [(first (last r)) i]) (conj r [i i]))) (next c))))))","user":"58987ee9e4b00487982d52d2"},{"code":"#(reduce (fn [ivs x]\n           (if-let [iv (peek ivs)]\n              (let [[lo hi] iv]\n               (if (<= hi x (inc hi))\n                 (conj (pop ivs) [lo x])\n                 (conj ivs [x x])))\n             [[x x]]))\n         [] (sort %))","problem":"171","user":"4ed188c8535d44c135fd68cf"},{"problem":"171","code":"(fn interval [c]\n  (reduce (fn ih [acc c]\n    (if (seq acc)\n      (let [[lo hi] (peek acc)]\n        (cond (= c (inc hi))\n              (conj (pop acc) [lo c])\n          (= c hi) acc\n          :else (conj acc [c c])))\n        (conj acc [c c])))\n  [] (sort c)))","user":"538e29d1e4b0b51d73faae80"},{"code":"(fn [s]\n    (letfn [(f [lst]\n             (loop [[f & xs] (sort lst)\n                    r []\n                    i []]\n               (cond (nil? f) r\n                     (and xs (>= f (dec (first xs)))) (recur xs r (conj i f))\n                     :else (recur xs (conj r (conj i f)) []))))]\n      (map #(apply (juxt min max) %) (f s))))","problem":"171","user":"4f58d92fe4b0a7574ea71858"},{"problem":"171","code":"(fn [s]\n    (map\n      #(list (first %) (last %))\n      (filter #(not= [\"X\"] %)\n              (partition-by #(= \"X\" %)\n                            (reduce (fn [col x]\n                                      (if (= (last col) (- x 1))\n                                        (conj col x)\n                                        (conj col \"X\" x)))\n\n                                    []\n                                    (sort (distinct s)))))))","user":"563cce5be4b0bfe05bf1183f"},{"code":"(fn intervals\n   ([n]\n      (if (empty? n)\n        []\n        (let [n (sort (distinct n))]\n          (intervals (first n) (first n) [] (rest n)))))\n   ([x y i n]\n      (cond\n       (empty? n) (conj i [x y])\n       (= (first n) (inc y)) (intervals x (inc y) i (rest n))\n       :else (intervals (first n) (first n) (conj i [x y]) (rest n)))))","problem":"171","user":"4e89f46c535d3e98b8023288"},{"problem":"171","code":"(fn [coll]\n  (letfn [(interval-end [start coll]\n            (cond (empty? coll) start\n                  (== (first coll) (inc start)) (recur (inc start) (next coll))\n                  :else start))\n          (next-interval [coll]\n            (let [interval-start (first coll)]\n              [interval-start\n               (interval-end interval-start (next coll))]))\n          (get-intervals [coll]\n            (println coll)\n            (if (seq coll)\n              (let [[_ end :as interval] (next-interval coll)]\n                (lazy-seq\n                 (cons interval\n                       (get-intervals (drop-while #(<= % end) coll)))))\n              []))]\n    (get-intervals (sort (distinct coll)))))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":"171","code":"(fn intervals [ns]\n  (let [inner (fn inner [ns s c]\n                (if (empty? ns)\n                  (cons (vector s c) nil)\n                  (if (= (first ns) (inc c))\n                      (lazy-seq (inner (rest ns) s (first ns)))\n                      (cons (vector s c) (lazy-seq (inner (rest ns) (first ns) (first ns)))))))\n        sorted (vec (apply sorted-set ns))]\n    (if (empty? ns)\n      '()\n  (inner (rest sorted) (first sorted) (first sorted)))))","user":"55934bebe4b0c79f6e1db93b"},{"problem":"171","code":"(fn my-fn [xs]\n  (if (empty? xs)\n    []\n    (let [sorted-xs (sort (distinct xs))\n          grouped-xs (reduce (fn [acc x]\n                               (if (= (inc (last (last acc))) x)\n                                 (into [] (concat (butlast acc) [(conj (last acc) x)]))\n                                 (conj acc [x])))\n                             [[(first sorted-xs)]]\n                             (rest sorted-xs))]\n      (map (fn [ys]\n             [(apply min ys) (apply max ys)])\n           grouped-xs))))","user":"5d669613e4b0db5d338d15ea"},{"code":"(fn f [coll]\n  (let [split-inc (fn [x]\n                    (loop [result [[]] current [] y (map vector x (cons 0 x ))]\n                      (let [[[a b] & r] y]\n                        (cond\n                          (nil? a) (conj result current)\n                          (= a (+ 1 b)) (recur result (conj current a) r)\n                          :else (recur (conj result current) [a] r)\n                          )))\n                    )]\n  (->>\n    (sort coll)\n    distinct\n    split-inc\n    rest\n    (map sort)\n    (filter #(first %))\n    (map #(vector (first %) (last  %)))\n    )))","problem":"171","user":"518c5236e4b087e178201de0"},{"code":"(fn [xs] (reduce\n          (fn [intervals a]\n            (let [[x y] (last intervals)]\n              (if (or (nil? x) (> a (inc y)))\n                (conj intervals [a a])\n                (conj (vec (butlast intervals)) [x a]))))\n          []\n          (apply sorted-set xs)))","problem":"171","user":"51307b84e4b08c712d3fae39"},{"problem":"171","code":"(fn [coll]\n  (let [xs      (sort (distinct coll))\n        pairs   (map list xs (rest xs))\n        no-cons (filter #(> -1 (apply - %)) pairs)\n        bounds  (flatten [(take 1 xs) no-cons (last xs)])]\n    (partition 2 bounds)))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"#(letfn [(f [[a b & c]]\n            (let [acc []]\n              (cond \n               (nil? a) acc\n               (= a b) (concat acc (f (cons b c)))\n               (and a b) (if (= (inc a) b)\n                           (concat acc (f (cons b c)))\n                           (concat [a] [b] (f (cons b c))))\n               a (cons a acc))))]\n   (partition 2 (cons (first (sort %)) (f (sort %)))))","problem":"171","user":"5371167fe4b0fc7073fd6ea7"},{"problem":"171","code":"(fn [s]\n  (reduce\n   (fn [a e] \n     (let [[e1 e2] (last a)]\n       (cond \n        (or (nil? e1)  (> e (inc e2))) (conj a [e e]) \n        (= e e2)       a\n        (= e (inc e2)) (assoc-in a [(dec (count a)) 1] e))))\n   []\n   (sort s)))","user":"4f1ef6a0535d64f60314649b"},{"code":"(fn [nums]\n    (if-not (seq nums)\n      nums\n      (let [[n & ns] (sort nums)]\n        (loop [xs ns, low n, high n, ivals []]\n          (if (seq xs)\n            (let [[x & more] xs]\n              (if (<= x (inc high))\n                (recur more low x ivals)\n                (recur more x x (conj ivals [low high]))))\n            (conj ivals [low high]))))))","problem":"171","user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn [n]\n(if (empty? n) n\n(reverse\n(map #(vector (last %) (first %))\n(reduce\n (fn [[[ff & _ :as f ] & r :as l] d]\n   (if (>(- d (or ff 0)) 1) (cons [d]  l) (cons (cons d f) r)))\n [[]]  (into #{} n ) )))))","problem":"171","user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn interval [xs]\n  (let [s-xs (sort (set xs))]\n    (map #(vector (first %) (last %))\n      (filter #(not (nil? (first %))) \n        (partition-by nil? \n          (reduce \n            #(if (= (inc (last %1)) %2) \n              (conj %1 %2) \n              (conj %1 nil %2)) \n            [(first s-xs)] (rest s-xs)))))))","problem":"171","user":"501c1492e4b086d93747d180"},{"problem":"171","code":"#(let [[f & r] (distinct (sort %))]\n   (if (nil? f)\n     []\n     (reduce (fn [acc i] (if (= (last (last acc)) (dec i)) \n                         (conj (vec (butlast acc)) [(first (last acc)) i]) \n                         (conj acc [i i]))) \n           [[f f]] r)))","user":"563dfc02e4b0da801c4e4662"},{"problem":"171","code":"(fn intervals\n  ([xs] (if (empty? xs) [] (intervals (sort xs) nil nil [])))\n  ([xs start current acc]\n   (if (empty? xs) (conj acc [start current])\n       (let [[x & xs'] xs]\n         (cond\n           (nil? start) (recur xs' x x acc)\n           (<= x (inc current)) (recur xs' start x acc)\n           :else (recur xs nil nil (conj acc [start current])))))))","user":"55fbc657e4b0f488688e0666"},{"code":"(fn [s]\n  (let [s (apply sorted-set s)]\n    (map vector \n     (remove #(s (dec %)) s)\n     (remove #(s (inc %)) s))))","problem":"171","user":"4f08b15b535dcb61093f6c40"},{"problem":"171","code":"#(reduce\n     (fn [[[f l] & r :as a] e]\n       (if (and\n            f\n            (> e (- f 2))\n            (< e (+ l 2)))\n           (cons [(min e f) (max e l)] r)\n           (cons [e e] a)))\n     []\n     (sort-by - %))","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn [coll]\n  (if (= [] coll)\n  []\n  (let [l (sort coll)]\n    (loop [head-seq [[(first l) (first l)]] tail-seq (rest l)]\n      (if (= [] tail-seq) \n        head-seq\n        (recur \n          (concat\n            (drop-last head-seq)\n            (let [[x y] (last head-seq)\n                  z (first tail-seq)]\n              (if (or (= y z) (= z (inc y)))\n                [[x z]]\n                [[x y] [z z]])))\n           (rest tail-seq)))))))","problem":"171","user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn intervall [x] \n  (let [x (distinct (sort x))] \n    ((fn f \n  ([x](let [[x & xs] x](if x (f xs x x) []))) \n  ([x l h] \n   (if-let [[x & xs] x] \n     (if (= (inc h) x) \n       (f xs l x) \n       (lazy-seq (cons [l h] (f xs x x)))) \n     [[l h]])))x)))","problem":"171","user":"51b793d3e4b0d906fcd71d38"},{"problem":"171","code":"(fn f171 [coll]\n   (let [clean (->> (sort coll)\n               (distinct))]\n     (->>\n       (map list clean (range))\n       (partition-by #(apply - %) )\n       (map #(do [(first (first %)) (first (last %))])))))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":"171","code":";;#(if (empty? %) []\n;;\t (apply reduce \n;;              (fn [[[f s] & rs :as r] e]\n;;                (if (= e (dec f)) (cons [e s] rs) (cons [e e] r)))\n;;              ((fn [[f & rs]] [[[f f]] rs]) (sort > (set %)))))\n\n#(if (empty? %) []\n     (->> (range (apply min %) (inc (apply max %)))\n          (map (set %))\n          (partition-by nil?)\n          (filter first)\n          (map (fn [[f :as s]] [f (last s)]))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [? v]\n    (#(map vector (? % dec) (? % inc)) (set v)))\n(fn [s f] (remove #(s (f %)) (sort s)))","problem":"171","user":"4f296a80e4b0d6649770a02a"},{"problem":"171","code":"(fn [coll]\n  (let [groups (reduce #(if (= (last (last %)) (- %2 1))\n                            (assoc-in % [(- (count %) 1) (count (last %))] %2) \n                            (assoc-in % [(count %)] [%2])) \n                       [] (distinct (sort coll)))]\n    (for [s groups]\n      [(first s) (last s)])\n    ))","user":"534fa9dae4b084c2834f4acf"},{"code":"#(->> % sort\n      (reduce\n       (fn [[i & is] x]\n         (if (nil? i) \n           [[x x]]\n           (let [[s e] i]\n             (if (<= (Math/abs (- e x)) 1)\n               (cons [s x] is)\n               (apply list [x x] i is)))))\n       [])\n      reverse)","problem":"171","user":"4f06dcad535dcb61093f6c16"},{"problem":"171","code":"(fn [xs]\n  (let [sorted (sort (set xs))                            ;; sort and remove duplicates\n        pairs (map list sorted (range))                   ;; pair values with a count\n        grouped (partition-by #(apply - %) pairs)]        ;; split where the diff in the pair changes\n    (map #(vector (ffirst %) (first (last %))) grouped))) ;; pull out the grouped values","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn [col]\n  (if (empty? col)\n    []\n\t(loop [c (sort col) mb (first c) me (last c) r [[mb mb]]]\n      (let [[b e] (last r)]\n        (if (>= e me)\n          r\n          (let [n (+ 1 e)\n                r (if (some (partial = n) c)\n                    (conj (vec (drop-last r)) [b n])\n                    (conj r [(some #(if (> % n) %) c) (some #(if (> % n) %) c)]))]\n            (recur c mb me r)))))))","problem":"171","user":"514721c6e4b0d520409ed392"},{"code":"(fn [coll]\n  (letfn [(split-interval [coll]\n            (let [l (first coll)]\n              (loop [r    l\n                     more (rest coll)]\n                (if (or (empty? more)\n                        (> (first more) (inc r)))\n                  [[l r] more]\n                  (recur (inc r) (rest more))))))]\n    (loop [acc  []\n           coll (distinct (sort coll))]\n      (if (empty? coll)\n        acc\n        (let [[inter more] (split-interval coll)]\n          (recur (conj acc inter) more))))))","problem":"171","user":"50586354e4b06522596eba78"},{"problem":"171","code":"(fn [l] (let [s (set l)] (partition 2 (sort (concat\n                                            (filter (fn [i] (not (contains? s (inc i)))) s)\n                                            (filter (fn [i] (not (contains? s (dec i)))) s)\n                                            )))))","user":"584dadebe4b0b7285a6f4e44"},{"problem":"171","code":"(fn[zs]\n(if (empty? zs)\n    []\n    (\n      (fn [xs]\n        (loop [acc [] ys xs tempr [] el 0]\n           (if (empty? ys)\n                (vec (map (fn [k] [(first k) (last k)]) acc))\n                (recur   (if (= (first ys) (inc el))\n                            acc\n                            (into acc [tempr])\n                         )\n                         (rest ys)\n                         (if (= (first ys) (inc el))\n                            (conj tempr (first ys))\n                            (conj [] (first ys))\n                         )\n                         (first ys)\n                )\n            )\n       )\n      )\n     (sort (distinct (conj zs 1003001)))\n   )\n\n  )\n  )","user":"55d7312ee4b0e31453f64a9f"},{"code":"#(reduce (fn [r x] (if-let [e (last r)]\n                     (let [[a b] e]\n                      (cond (<= x b) r\n                            (= (inc b) x) (assoc r (dec (count r)) [a x])\n                            :e (conj r [x x])))\n                     [[x x]]))\n  [] (sort %))","problem":"171","user":"4ee7d177535d93acb0a6686f"},{"code":"(fn f[xs]\n  (let [xs (distinct (sort xs))\n        last-el (last xs)\n        xs (conj (into [] xs) last-el)\n    \tpairs (partition 2 1 xs)\n        pairs (map (fn [[a b]] [a (= (inc a) b)]) pairs)]\n    (loop [ax [] bx [] [[x p] & xs :as xxs] pairs]\n      (if (empty? xxs)\n        (map #(-> [(first %)(last %)]) ax)\n        (let [bx (conj bx x)\n              new-bx (if p bx [])\n              new-ax (if p ax (conj ax bx))]\n          (recur new-ax new-bx xs))))))","problem":"171","user":"51efd397e4b0249c592fbdeb"},{"code":"(fn intervals [x]\n      (let [sorted-x (sort x)\n            filtered-x (map #(first %) (partition-by identity sorted-x))\n            ]\n        (if (empty? x)\n          []\n          (reverse\n            (reduce (fn [acc i]\n                      (if (= (second (first acc)) (dec i))\n                        (conj (rest acc) [(first (first acc)) i])\n                        (conj acc [i i])\n                      )\n                    )\n                    (list [(first filtered-x) (first filtered-x)])\n                    (rest filtered-x)\n            )\n          )\n        )\n      )\n    )","problem":"171","user":"5272d4b7e4b03e8d9a4a7453"},{"problem":"171","code":"(fn [c]\n    (letfn [(spl [cl]\n               (loop [[f & r] cl res []]\n                 (cond\n                  (nil? f) (partition-by #{:s} res)\n                  (or (empty? res) (= f (last res)) (= (dec f) (last res))) (recur r (conj res f))\n                  :e (recur r (conj res :s f)))))]\n      (->> c\n           sort\n           spl\n           (filter #(not= % (seq #{:s})))\n           (map #(vector (first %) (last %)))\n           )))","user":"586615e6e4b0f14aab7c8858"},{"problem":"171","code":"(fn [s]\n  (->> s\n       distinct\n       sort\n       reverse\n       (#(interleave % (range)) )\n       (partition 2)\n       (map #(list (first %) (+ (first %) (second %))))\n       (partition-by #(second %))\n       (map (fn [i-list]\n              (map #(first %) i-list))\n            )\n       (map #(list (last %) (first %)) )\n       reverse\n       ))","user":"53c1ce3ee4b00fb29b221268"},{"problem":"171","code":"#(->> %\n      set\n      sort\n      (reduce (fn [[[a b] & t :as s] c] (if (= b (dec c)) (cons [a c] t) (cons [c c] s))) ())\n      reverse)","user":"53908e6be4b0b51d73faae9a"},{"code":"(fn intervals [coll]\n  (letfn [(collapse-if [pred coll]\n                       (loop [chain [] res [] remaining coll]\n                         (if-let [s (seq remaining)]\n                           (let [x (first s)\n                                 xs (next s)]\n                             (if (not-empty chain)\n                               (if (pred (peek chain) x)\n                                 (recur (conj chain x) res xs)\n                                 (recur [x] (conj res chain) xs))\n                               (recur [x] res xs)))\n                           (if (not-empty chain)\n                             (conj res chain)\n                             res))))]\n    (->> coll\n         sort\n         (collapse-if #(<= (- %2 %1) 1))\n         (map (juxt first last)))))","problem":"171","user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":"171","code":"(fn interval [v]\n  (reduce (fn [res item]\n            (let [[fst lst] (last res)]\n              (if (or (empty? res) (> item (inc lst)))\n                (concat res [[item item]])\n                (concat (drop-last res) [[fst item]]))\n              )) [] (vec (sort v))))","user":"54f09599e4b024c67c0cf89d"},{"problem":"171","code":"(fn [nums]\n  (if (empty? nums)\n    []\n    (let [[initial-num & rest-nums] (sort nums)]\n      (loop [nums rest-nums\n             interval-initial initial-num\n             prev-num initial-num\n             accum []]\n        (if nums\n          (let [next-num (first nums)]\n            (if (< (- next-num prev-num) 2)\n              (recur (next nums) interval-initial next-num accum)\n              (recur (next nums) next-num next-num (conj accum [interval-initial prev-num]))))\n          (conj accum [interval-initial prev-num]))))))","user":"53527551e4b084c2834f4af0"},{"problem":"171","code":"(fn [coll]\n  (loop [[x & xs] (sort coll)\n         acc []\n         s x\n         e x]\n    (cond (and (nil? x) (nil? s)) acc\n          (nil? x) (conj acc [s e])\n          (= x e) (recur xs acc s e)\n          (= x (inc e)) (recur xs acc s x)\n          :else (recur xs (conj acc [s e]) x x))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":"171","code":"(fn [coll]\n  (if (empty? coll)\n    coll\n    (let [[value & as-vector] (->> coll (sort) (distinct) (apply vector))]\n      (loop [result [], acc [value], [nxt & others :as from] as-vector]\n        (let [expected-next (inc (last acc))\n              interval ((juxt first last) acc)\n              result-with-interval (conj result interval)]\n          (if (empty? from)\n            result-with-interval\n            (if (= nxt expected-next)\n              (recur result (conj acc nxt) others)\n              (recur result-with-interval [nxt] others))))))))","user":"5c13da47e4b01240ff5671a6"},{"problem":"171","code":"(fn [coll]\n  (reduce\n   (fn [prev el]\n     (let [lp (last prev)]\n       (if (or (nil? lp) (> (- el (second lp)) 1))\n         (conj prev [el el])\n         (conj (into '[] (butlast prev)) [(first lp) el]))))\n   []\n   (map first (partition-by identity (sort coll)))))","user":"5514a60fe4b055c2f668d4d7"},{"problem":"171","code":"(fn [nums]\n  (if (empty? nums) []\n  \t(let [normalized-nums (into [] (sort (into #{} nums)))\n    \t    splits (map #(= %1 (dec %2)) normalized-nums (drop 1 normalized-nums))\n        \tcombined (conj (into [] (interleave normalized-nums splits))\n                \t       (last normalized-nums))\n        \tpartitioned (filter (partial not= '(false))\n            \t                (partition-by (partial = false) combined))\n        \tcleaned (map (partial filter number?) partitioned)]\n    \t(map #(list (first %) (last %)) cleaned))))","user":"5553b924e4b0deb715856e06"},{"problem":"171","code":"(fn find-intervals\n  [coll]\n  (if (empty? coll)  []\n      (let [tt (fn [coll]\n                 (loop [coll coll res []]\n                   (if ( or (empty? coll) (nil? (second coll)))\n                     (conj res (first coll))\n                     (if (= (- (second coll) (first coll)) 1)\n                       (recur (rest coll) (conj res (first coll) (second coll)))\n                       (recur (rest coll) (conj res (first coll) :a))))))]\n        (->> (tt (-> coll sort distinct))\n             (partition-by #(= % :a))\n             (map (fn [x] (when (not= :a (first x)) [(first x) (last x)] )) )\n             (filter #(not= % nil))))))","user":"55079e55e4b021ccfedb96aa"},{"problem":"171","code":"(fn [x]\n  (let [a (distinct (sort x))\n        b (reduce #(if (= (- %2 (last %)) 1) (conj % %2) (conj % nil %2)) (vector (first a))  (rest a))\n        c (partition-by nil? b)\n        d (filter #(not (= (first %) nil)) c)]\n    (map #(vector (first %)(last %)) d)))","user":"566d71b1e4b0a866af6896ca"},{"problem":"171","code":"(fn [xs]\n  (if (seq xs)\n    (->> (conj (vec (sort xs)) :end)\n         (reduce (fn [[intervals start prev] n]\n                   (cond\n                     (= :end n) (conj intervals [start prev])\n                     (nil? start) [intervals n n]\n                     (= prev n) [intervals start n]\n                     (= (inc prev) n) [intervals start n]\n                     :else [(conj intervals [start prev]) n n]))\n                 [[] nil nil]))\n    []))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn intervals [v]\n  (if (empty? v) []\n  (map #(list (first %1) (last %1))\n       (let [s (distinct (sort v))]\n         (loop [a (rest s) l (first s) res [] curr [l]]\n           (if (empty? a) \n             (conj res curr)\n             (if (= (inc l) (first a))\n               (recur (rest a) (first a) res (conj curr (first a)))\n               (recur (rest a) (first a) (conj res curr) [(first a)])\n               )\n             )\n           )\n         ))))","problem":"171","user":"5094057fe4b097f48cc38593"},{"code":"#(if (seq %)\n   (let [n (set %), a (apply min %), b (+ 1 (apply max %))]\n     (for [l (take-nth 2 (partition-by (comp boolean n) (range a b)))]\n       [(first l) (last l)]))\n   [])","problem":"171","user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [xs]\n  (if (empty? xs) []\n  (loop [is [] c [] xs (sort xs)]\n    (if (empty? xs)\n      (map #(vector (apply min %) (apply max %)) (conj is c))\n      (if (or (zero? (count c))\n              (= (last c) (first xs))\n              (= (last c) (dec (first xs))))\n        (recur is (conj c (first xs)) (rest xs))\n        (recur (conj is c) [(first xs)] (rest xs))\n        )))))","problem":"171","user":"4ea365e2535d7eef308072c5"},{"code":"(fn [xs]\n  (let [sset (apply sorted-set xs)\n        parts (reduce (fn [parts x]\n                        (if-let [last-num (last (last parts))]\n                          (if (or (= (inc last-num) x) (= last-num x))\n                            (concat (or (butlast parts) []) [(conj (or (last parts) []) x)])\n                            (concat parts [[x]]))\n                          (concat parts [[x]])))\n                      []\n                      sset)]\n    (map (juxt first last) parts)))","problem":"171","user":"51281b25e4b03a34742b4304"},{"problem":"171","code":"(fn [xs]\n   (partition 2 (reduce \n      (fn [a x] \n         (if (and (seq a) (= x (inc (last a))))\n            (conj (vec (butlast a)) x)\n            (conj a x x)))\n   [] (sort (distinct xs)))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [s]\n  (reduce\n    (fn [r v]\n      (let [[s e] (last r)]\n        (if (= e (dec v))\n          (conj (vec (butlast r)) [s v])\n          (conj r [v v]))))\n    []\n    (sort (set s))))","problem":"171","user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn get-ranges [xs]\n  (letfn [(longest-common-prefix [xs ys]\n            (->> ys\n                 (map vector xs)\n                 (take-while (fn [[x y]] (= x y)))\n                 (map first)))\n          (find-a-range [xs]\n            (let [ys (iterate inc (first xs))\n                  lcp (longest-common-prefix xs ys)]\n              [(first lcp) (last lcp)]))\n          (find-all-ranges [xs]\n            (if (empty? xs) (list)\n                (let [[f l :as a-range] (find-a-range xs)\n                      rs (drop (- l f -1) xs)]\n                  (conj (find-all-ranges rs) a-range))))]\n    (let [sorted-xs (->> xs set seq sort)]\n      (find-all-ranges sorted-xs))))","problem":"171","user":"51ac6360e4b09397d510976c"},{"code":"(fn interval [s]\n  (let [ss (-> s sort distinct)\n        iv (fn [v x] \n\t        (if (= (dec x) (-> v peek peek)) \n\t\t\t  (conj (pop v) [(-> v peek first) x]) \n\t\t      (conj v [x x])))]\n\t(if (empty? s) s\n      (reduce iv [[(first ss) (dec (first ss))]] ss) )))","problem":"171","user":"50d0d4c8e4b00b15ecee976a"}]