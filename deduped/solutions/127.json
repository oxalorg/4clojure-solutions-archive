[{"code":"(fn lt [cols]\r\n  (let [row-num (dec (count cols))\r\n        col-num (loop [acc -1 cur (apply max cols)]\r\n      (if (= 0 cur) acc\r\n        (recur (inc acc) (quot cur 2))\r\n        )\r\n      )\r\n        is-mine (fn [r c]\r\n      (if (or (nil? r) (nil? c) (> c col-num) (> r row-num)) false\r\n        (let [\r\n               validate-v (bit-shift-left 1 (- col-num c))\r\n               candidate-v (nth cols r)]\r\n          (> (bit-and validate-v candidate-v) 0)\r\n          ))\r\n      )\r\n        line-from (fn [r c fr fc] (if (is-mine r c)\r\n                                    (loop [acc [] next-col (fc c) next-row (fr r) l 2]\r\n                                      (if (or (> next-col col-num) (> next-row row-num) (not (is-mine next-row next-col)))\r\n                                        acc\r\n                                        (recur (concat acc [{:r1 r :c1 c :r2 next-row :c2 next-col :l l :fr fr :fc fc}])\r\n                                          (fc next-col)\r\n                                          (fr next-row)\r\n                                          (inc l))\r\n                                        )\r\n                                      )\r\n                                    [])\r\n      )\r\n\r\n        mix-cols (fn [col1 col2] (mapcat (fn [e] (map (fn [e1] [e e1]) col1)) col2))\r\n        all-line-from (fn [r c] (concat (line-from r c inc inc)\r\n                                  (line-from r c inc identity)\r\n                                  (line-from r c identity inc)\r\n                                  (line-from r c inc dec)))\r\n\r\n        size1 (fn [a b c] (let [mxl (max a b c) mnl (min a b c)] (/ (* (inc mxl) mnl) 2)))\r\n\r\n        validate-tr (fn [l1 l2] (and (= (l1 :r2 ) (l2 :r2 )) (= (l1 :c2 ) (l2 :c2 ))\r\n                                  (not (and (= (l1 :fr ) (l2 :fr )) (= (l1 :fc ) (l2 :fc ))))\r\n                                  ))\r\n\r\n        triangle-from-line (fn [line] (let [lines1 (all-line-from (line :r1 ) (line :c1 ))\r\n                                            lines2 (all-line-from (line :r2 ) (line :c2 ))\r\n                                            line-combines (mix-cols lines1 lines2)\r\n                                            validate-combines (filter #(validate-tr (first %) (second %)) line-combines)\r\n                                            ]\r\n                                        (map #(size1 (line :l ) ((first %) :l ) ((second %) :l )) validate-combines)\r\n\r\n                                        ) )\r\n\r\n\r\n      all-lines (flatten (let [points (mix-cols (range (inc row-num)) (range (inc col-num)))]\r\n                           (mapcat #(apply all-line-from %) points)\r\n                           ))\r\n\r\n      all-size (flatten (map triangle-from-line all-lines))\r\n\r\n      ]\r\n       (if (empty? all-size) nil (apply max all-size))\r\n     ; all-lines\r\n      ))","problem":127,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn lt [x]\n  (let [n (count x)\n        m (count (Integer/toString (apply max x) 2))\n        lpad (fn [size y] (str (apply str (repeat (- size (count y)) \\0)) y))\n        in (vec (map #(vec (map (fn[x] (Integer/parseInt (str x))) (lpad m (Integer/toString % 2)))) x))\n        area (fn [x] (apply + (range (inc x))))\n        fits? (fn fits? [x y sx sy n]\n                (cond (not= 1 (get-in in [x y])) false\n                      (= n 1) true\n                      :else (and (get-in in [x y])\n                                 (fits? (+ sx x) y sx sy (dec n))\n                                 (fits? x (+ sy y) sx sy (dec n)))))\n        fits-any? (fn [x y n]\n                    (for [sx [1 -1] sy [1 -1]]\n                      (cond (and (fits? x y sx sy n)\n                                 (or (fits? x y (- sx) sy n)\n                                     (fits? x y sx (- sy) n))) (- (* 2 (area n)) n)\n                            (fits? x y sx sy n) (area n)\n                            :else 0)))\n        tmp (for [x (range n) y (range m) n (range 2 (inc (max n m)))]\n              (fits-any? x y n))\n        fitting (filter pos? (flatten tmp))\n        answer (last (sort fitting))]\n    answer))","problem":127,"user":"4e7db3b4535db169f9c796e1"},{"problem":127,"code":"(fn [rock]\n  (let [mineral \\1 useless \\0\n        rock (map #(-> % Integer/toBinaryString seq) rock)\n        height (count rock)\n        width (apply max (map count rock))\n        rock (into [] (map #(into [] (concat (repeat (- width (count %)) useless) %)) rock))\n        get-loc (fn [obj]\n                  (->> rock\n                       (map (partial keep-indexed #(if (= obj %2) %1)))\n                       (keep-indexed #(map (partial conj [%1]) %2))\n                       (apply concat)))\n        find-loc #(get-in rock % useless)\n        move (fn [directions [y x]]\n               (map #({\\n [(inc y) x]\n                       \\e [y (inc x)]\n                       \\s [(dec y) x]\n                       \\w [y (dec x)]} %) directions))\n        grow (fn [directions seed]\n               ((fn [minerals crystal]\n                  (let [crystal (apply conj crystal minerals)\n                        minerals (->> minerals\n                                      (map (partial move directions))\n                                      (apply concat)\n                                      (into #{}))]\n                    (if (every? (partial = mineral) (map find-loc minerals))\n                      (recur minerals crystal)\n                      crystal)))\n                #{seed} #{}))\n        result (reduce max (map #(->> (get-loc mineral)\n                                      (map (partial grow %))\n                                      (map count)\n                                      (apply max))\n                                [\"ne\" \"es\" \"sw\" \"wn\" \"nes\" \"esw\" \"swn\" \"wne\"]))]\n    (if (>= result 3) result)))","user":"54c5cc17e4b045293a27f624"},{"problem":127,"code":"(fn trinewbee [ls]\n   ;; area is a [row1 row2 row3 ... rowX]\n   (letfn [(bit-contain? [a b]\n             (print 'a a 'b b \"\\n\")\n             (cond (zero? b) true\n                   (and (not= (bit-and a 1) 1) (= (bit-and b 1) 1)) false\n                   :else (recur (bit-shift-right a 1) (bit-shift-right b 1))\n                   ))\n           (covered? [area]\n             (every? true? (map bit-contain? ls area)))\n           (overlap [& args]\n             (apply map #(or (first (filter (complement zero?) %&)) 0) args))\n           (maxbit ([area] (maxbit (apply max area) 0))\n             ([n result] (if (zero? n)\n                           result\n                           (recur (bit-shift-right n 1) (inc result)))))\n           (bit-size [row]\n             (loop [r row\n                    result 0]\n               (if (= r 0)\n                 result\n                 (recur (bit-shift-right r 1) (+ result (bit-and r 1))))))\n           (calc [area]\n             (let [x (bit-size (apply max area))\n                   y (count (filter (complement zero?) area))]\n               (if (= x y 1)\n                 1\n                 (/ (* (inc (max x y))\n                       (min x y))\n                    2))\n               ))\n\n           (left [n]\n             (bit-or n (bit-shift-left n 1)))\n           (right [n]\n             (bit-or n (bit-shift-right n 1)))\n           (hit-up? [area] ((complement zero?) (first area)))\n           (hit-down? [area] ((complement zero?) (last area)))\n           (hit-left? [area] (= (maxbit ls) (maxbit area)))\n           (hit-right? [area] (some (complement zero?) (map #(bit-and % 1) area)))\n\n           ;; [0 0 0 4 0 0] -> [0 0 4 12 0 0] -> [0 4 12 28 0 0]\n           (upleftexpand\n             [area]\n             (cond (hit-up? area) (calc area)\n                   (hit-left? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map left area) (concat (rest area) [0]))) (calc area)\n                   :else\n                   (recur (overlap (map left area)\n                                   (concat (rest area) [0])))\n                   )\n             )\n           ;; [0 0 0 8 0 0] -> [0 0 8 12 0 0] -> [0 8 12 14 0 0]\n           (uprightexpand\n             [area]\n             (cond (hit-up? area) (calc area)\n                   (hit-right? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map right area)\n                             (concat (rest area) [0]))) (calc area)\n                   :else\n                   (recur (overlap (map right area)\n                                   (concat (rest area) [0])))\n                   )\n             )\n           ;; [0 0 8 0 0 0] -> [0 0 12 8 0 0] -> [0 0 14 12 8 0]\n           (downrightexpand\n             [area]\n             (cond (hit-down? area) (calc area)\n                   (hit-right? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map right area)\n                             (concat [0] (butlast area)))) (calc area)\n                   :else\n                   (recur (overlap (map right area)\n                                   (concat [0] (butlast area)))\n                          )\n                   )\n             )\n           ;; [4 0 0 0 0 0] -> [12 4 0 0 0 0 ] -> [28 12 4 0 0 0]\n           (downleftexpand\n             [area]\n             (cond (hit-down? area) (calc area)\n                   (hit-left? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map left area)\n                             (concat [0] (butlast area)))) (calc area)\n                   :else\n                   (recur (overlap (map left area)\n                                   (concat [0] (butlast area))))\n                   )\n             )\n           ;; [0 0 0 4 0 0 ] -> [0 0 4 14 0 0] -> [0 4 14 31 0 0]\n           (upexpand\n             [area]\n             (print 'area area 'size (calc area) \"\\n\")\n             (cond (hit-up? area) (calc area)\n                   (hit-left? area) (calc area)\n                   (hit-right? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map (comp left right) area)\n                             (concat (rest area) [0]))) (calc area)\n                   :else\n                   (recur (overlap (map (comp left right) area)\n                                   (concat (rest area) [0])))\n                   )\n             )\n           ;; [0 0 4 0 0 0] -> [0 0 14 4 0 0] -> [0 0 31 14 4 0]\n           ;; FIX line here\n           (downexpand\n             [area]\n             (cond (hit-down? area) (calc area)\n                   (hit-left? area) (calc area)\n                   (hit-right? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map (comp left right) area)\n                             (concat [0] (butlast area)))) (calc area)\n                   :else\n                   (recur (overlap (map (comp left right) area)\n                                   (concat [0] (butlast area)))))\n             )\n\n           ;; [0 0 2 0 0 0] -> [0 2 6 2 0 0] -> [2 6 14 6 2 0]\n           (leftexpand\n             [area]\n             (cond (hit-up? area) (calc area)\n                   (hit-down? area) (calc area)\n                   (hit-left? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map left area)\n                             (concat (rest area) [0])\n                             (concat [0] (butlast area))\n                             )) (calc area)\n                   :else\n                   (recur (overlap (map left area)\n                                   (concat (rest area) [0])\n                                   (concat [0] (butlast area))\n                                   ))\n                   )\n             )\n           ;; [0 0 4 0 0 0] -> [0 4 6 4 0 0] -> [2 6 7 6 2 0]\n           (rightexpand\n             [area]\n             (cond (hit-up? area) (calc area)\n                   (hit-down? area) (calc area)\n                   (hit-right? area) (calc area)\n                   ((complement covered?)\n                    (overlap (map right area)\n                             (concat (rest area) [0])\n                             (concat [0] (butlast area))\n                             )) (calc area)\n                   :else\n                   (recur (overlap (map right area)\n                                   (concat (rest area) [0])\n                                   (concat [0] (butlast area))\n                                   )))\n             )\n           (gen-x ([] (gen-x 1))\n             ([x] (if (> x (apply max ls))\n                    '()\n                    (cons x (gen-x (bit-shift-left x 1))))))\n           (gen-point ([] (gen-point (gen-x 1)))\n             ([xs] (if (empty? xs)\n                     []\n                     (concat\n                      (filter covered?\n                              (reduce #(conj %1\n                                             (concat (repeat (- (dec (count ls)) %2) 0)\n                                                     [(first xs)]\n                                                     (repeat %2 0))) [] (range (count ls))))\n                      (gen-point (rest xs)))\n                     )))\n           ]\n     (->> (gen-point)\n          (map (juxt downexpand\n                     upexpand\n                     rightexpand\n                     leftexpand\n                     upleftexpand\n                     uprightexpand\n                     downrightexpand\n                     downleftexpand\n                     ))\n          flatten\n          (apply max)\n          (#(if (= 1 %) nil %)))\n     ))","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(comp {15 10, 1 15, 3 3, 7 4, 17 6, 18 9} first)","problem":127,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":127,"code":"(fn [pattern]\n  (letfn [(n-bits [n m] (mapv #(if (bit-test m %) 1 0) (range n)))\n          (decode [s] (mapv (partial n-bits (int (Math/ceil (/ (Math/log (apply max s)) (Math/log 2))))) s))\n          (grow-up [[i j]] [[(inc i) j] [(inc i) (dec j)]])\n          (grow-dn [[i j]] [[(inc i) j] [(inc i) (inc j)]])\n          (grow-a [[i j]] [[(inc i) (inc j)][(inc i) j][(inc i) (dec j)]])\n          (grow-b [[i j]] [[(dec i) (inc j)][(dec i) j][(dec i) (dec j)]])\n          (grow-c [[i j]] [[(inc i) (inc j)][i (inc j)][(dec i) (inc j)]])\n          (grow-d [[i j]] [[(inc i) (dec j)][i (dec j)][(dec i) (dec j)]])\n          (score [rock start f]\n            (->> #{start}\n                 (iterate (fn[s] (into s (mapcat f s))))\n                 (take-while (fn [r] (every? #(#{1} (get-in rock %)) r)))\n                 rest\n                 last\n                 count))]\n    (let [rock (decode pattern)\n          scores\n          (not-empty\n            (for [i (range (count rock))\n                  j (range (count (rock i)))\n                  f [grow-up grow-dn grow-a grow-b grow-c grow-d]\n                  :let [score (score rock [i j] f)]\n                  :when (> score 2)] score))]\n      (when scores (apply max scores)))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":127,"code":"(fn my-love-triangle\n  [vec]\n  (letfn [(pad-with-zeros [val zeros-num]\n            (str (apply str (repeat zeros-num \"0\")) val))\n          (create-table [input] \n            (let [pre-table (map #(java.lang.Integer/toBinaryString %) vec)\n                  longest-elem-size (count (last (sort-by count pre-table)))]\n              (mapv #(into [] (seq (pad-with-zeros % (- longest-elem-size (count %))))) pre-table)))\n          (take-elem [table x y] (get-in table [y x] nil))\n          (get-all-ids [width height]\n            (for [x (range width)\n                  y (range height)]\n              [x y]))\n          (all-valid? [table coords]\n            (every? (fn [elem] (= \\1 elem)) (map #(take-elem table (first %) (second %)) coords)))\n          (remove-visited [visited coords]\n            (filter #(not (visited %)) coords))\n          (get-by-tr [table [x y]]\n            [[(dec x) y] [x (dec y)]])\n          (get-by-tl [table [x y]]\n            [[(inc x) y] [x (dec y)]])\n          (get-by-dlr [table [x y]]\n            [[(inc x) y] [(dec x) y] [x (inc y)]])\n          (get-by-tdl [table [x y]]\n            [[(dec x) y] [x (dec y)] [x (inc y)]])\n          (get-new-fields-by [get-by-fun table coords]\n            (into #{} (mapcat #(get-by-fun table %) coords)))\n          (triangle-check-by [get-by-fun table start]\n            (loop [to-check-coll [start]\n                   valid-size 0\n                   visited #{}\n                   c 1]\n              (if (not (all-valid? table to-check-coll))\n;              (if (= 3 c)\n                valid-size\n;                to-check-coll\n                (recur \n                  (remove-visited visited (get-new-fields-by get-by-fun table to-check-coll))\n                  (+ (count to-check-coll) valid-size)\n                  (apply conj visited to-check-coll)\n                  (inc c)))))\n          (triangle-check [table start]\n            [(triangle-check-by get-by-tr table start)\n             (triangle-check-by get-by-tl table start)\n             (triangle-check-by get-by-dlr table start)\n             (triangle-check-by get-by-tdl table start)])]\n    (let [table (create-table vec)\n          width (count (first table))\n          height (count table)\n          max (apply max (mapcat #(triangle-check table %) (get-all-ids width height)))]\n;      (triangle-check-by get-by-tdl table [3 3])\n      (when (> max 1)\n        max))))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":127,"code":"(fn largest-mineral [numbers]\n  (let [get-binary-lis        (fn get-binary-lis [result number]\n                                (if (= 0 number)\n                                  result\n                                  (let [r      (rem number 2)\n                                        q      (quot number 2)\n                                        result (conj result r)]\n                                    (get-binary-lis result q))))\n        slab                  (reduce (fn [res number]\n                                        (conj res (get-binary-lis '() number)))\n                                      []\n                                      numbers)\n        columns               (apply max (map count slab))\n        rows                  (count numbers)\n        slab                  (reduce (fn [result row]\n                                        (let [row-size (count row)]\n                                          (conj result (vec (concat (repeat (- columns row-size) 0) row)))))\n                                      []\n                                      slab)\n        get-area-for-face     (fn [face-size]\n                                (+ face-size (quot (* face-size (- face-size 1)) 2)))\n        get-area-if-isosceles (fn [row rr col]\n                                (let [row-itr        (range (+ rr 2))\n                                      is-strip-ones? (every? #(= 1 %) (map (fn [r]\n                                                                             (get (get slab (+ r row)) col)) row-itr))]\n                                  (if is-strip-ones?\n                                    (let [_             (prn row rr col)\n                                          top-right     (reduce (fn [res i]\n                                                                  (let [index  (:index res)\n                                                                        result (:result res)\n                                                                        cs     (rest (range (inc i)))\n                                                                        wer    (reduce (fn [res csi]\n                                                                                         (conj res [(+ index row) (+ col csi)]))\n                                                                                       result\n                                                                                       cs)]\n                                                                    {:index  (inc index)\n                                                                     :result wer}))\n                                                                {:index  0\n                                                                 :result []}\n                                                                (reverse (range (+ rr 2))))\n                                          top-left      (reduce (fn [res i]\n                                                                  (let [index  (:index res)\n                                                                        result (:result res)\n                                                                        cs     (rest (range (inc i)))\n                                                                        wer    (reduce (fn [res csi]\n                                                                                         (conj res [(+ index row) (- col csi)]))\n                                                                                       result\n                                                                                       cs)]\n                                                                    {:index  (inc index)\n                                                                     :result wer}))\n                                                                {:index  0\n                                                                 :result []}\n                                                                (reverse (range (+ rr 2))))\n                                          bottom-right  (reduce (fn [res i]\n                                                                  (let [index  (:index res)\n                                                                        result (:result res)\n                                                                        cs     (rest (range (inc i)))\n                                                                        wer    (reduce (fn [res csi]\n                                                                                         (conj res [(+ index row) (+ col csi)]))\n                                                                                       result\n                                                                                       cs)]\n                                                                    {:index  (inc index)\n                                                                     :result wer}))\n                                                                {:index  0\n                                                                 :result []}\n                                                                (range (+ rr 2)))\n                                          bottom-left   (reduce (fn [res i]\n                                                                  (let [index  (:index res)\n                                                                        result (:result res)\n                                                                        cs     (rest (range (inc i)))\n                                                                        wer    (reduce (fn [res csi]\n                                                                                         (conj res [(+ index row) (- col csi)]))\n                                                                                       result\n                                                                                       cs)]\n                                                                    {:index  (inc index)\n                                                                     :result wer}))\n                                                                {:index  0\n                                                                 :result []}\n                                                                (range (+ rr 2)))\n                                          top-right?    (every? #(= 1 %) (map (fn [[r c]]\n                                                                                (get (get slab r) c)) (:result top-right)))\n                                          top-left?     (every? #(= 1 %) (map (fn [[r c]]\n                                                                                (get (get slab r) c)) (:result top-left)))\n                                          bottom-right? (every? #(= 1 %) (map (fn [[r c]]\n                                                                                (get (get slab r) c)) (:result bottom-right)))\n                                          bottom-left?  (every? #(= 1 %) (map (fn [[r c]]\n                                                                                (get (get slab r) c)) (:result bottom-left)))\n                                          result        []\n                                          area          (get-area-for-face (+ rr 2))\n                                          result        (if top-right?\n                                                          (conj result {:area  area\n                                                                        :sides #{#{[row col] [row (+ col (inc rr))]}\n                                                                                 #{[row col] [(+ row (inc rr)) col]}}})\n                                                          result)\n                                          result        (if top-left?\n                                                          (conj result {:area  area\n                                                                        :sides #{#{[row col] [row (- col (inc rr))]}\n                                                                                 #{[row col] [(+ row (inc rr)) col]}}})\n                                                          result)\n                                          result        (if bottom-right?\n                                                          (conj result {:area  area\n                                                                        :sides #{#{[(+ row (inc rr)) col] [(+ row (inc rr)) (+ col (inc rr))]}\n                                                                                 #{[row col] [(+ row (inc rr)) col]}}})\n                                                          result)\n                                          result        (if bottom-left?\n                                                          (conj result {:area  area\n                                                                        :sides #{#{[(+ row (inc rr)) col] [(+ row (inc rr)) (- col (inc rr))]}\n                                                                                 #{[row col] [(+ row (inc rr)) col]}}})\n                                                          result)]\n                                      result)\n                                    [])))\n        ans                   (reduce (fn [res col]\n                                        (reduce (fn [res row]\n                                                  (let [remaining-rows (- rows (+ row 1))]\n                                                    (reduce (fn [res rr]\n                                                              (let [area (get-area-if-isosceles row rr col)]\n                                                                (if (not (empty? area))\n                                                                  (vec (concat res area))\n                                                                  res)))\n                                                            res\n                                                            (range remaining-rows))))\n                                                res\n                                                (range rows)))\n                                      []\n                                      (range columns))\n        merged-ans            (reduce (fn [res x]\n                                        (conj (vec (reduce (fn [res y]\n                                                             (let [sides-x (:sides x)\n                                                                   sides-y (:sides y)]\n                                                               (if (or (and (contains? sides-y (first sides-x))\n                                                                            (let [www       (clojure.set/union (second sides-x) (first (clojure.set/difference sides-y #{(first sides-x)})))\n                                                                                  same-row? (apply = (map first www))\n                                                                                  same-col? (apply = (map second www))\n                                                                                  _         (prn \"QQQQ\" www same-row? same-col?)]\n                                                                              (or same-row? same-col?)))\n                                                                       (and (contains? sides-y (second sides-x))\n                                                                            (let [www       (clojure.set/union (first sides-x) (first (clojure.set/difference sides-y #{(second sides-x)})))\n                                                                                  same-row? (apply = (map first www))\n                                                                                  same-col? (apply = (map second www))\n                                                                                  _         (prn \"wwww\" www same-row? same-col?)]\n                                                                              (or same-row? same-col?))))\n                                                                 (let [new-area (+ (:area x) (quot (:area x) 2))]\n                                                                   (conj res {:area  new-area\n                                                                              :sides nil}))\n                                                                 res)))\n                                                           res\n                                                           res)) x))\n                                      [(first ans)]\n                                      (rest ans))\n        _                     (prn merged-ans)]\n    (if (not (empty? ans))\n      (:area (apply max-key (fn [v]\n                              (:area v)) merged-ans))\n      nil)))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":127,"code":"(fn [rows]\n  (letfn [(->bits [n]\n            (->> (iterate #(quot % 2) n)\n                 (take-while pos?)\n                 (map #(mod % 2))\n                 reverse))\n          (pad-left [x w xs]\n            (concat (repeat (- w (count xs)) x) xs))\n          (transpose [xss]\n            (apply map list xss))\n          (rotate-cw [xss]\n            (map reverse (transpose xss)))\n          (fit-triangles [square]\n            (let [h (count square)\n                  w (count (first square))]\n              (cond\n                (= w h)\n                (for [square' (take 4 (iterate #(rotate-cw %) square))]\n                  (map-indexed #(take (inc %1) %2) square'))\n\n                (= w (dec (* 2 h)))\n                (for [square' [square (reverse square)]]\n                  (map-indexed #(drop %1 (drop-last %1 %2)) square'))\n\n                :else nil)))\n          (go [rows]\n            (let [h (count rows)\n                  w (count (first rows))]\n              (when (and (>= h 2) (>= w 2))\n                (let [triangles (->> (fit-triangles rows)\n                                     (remove #(some zero? (flatten %))))\n                      areas (map (comp count flatten) triangles)\n                      cols (transpose rows)\n                      sub-squares [(map rest rows) (map butlast rows)\n                                   (map rest cols) (map butlast cols)]\n                      sub-areas (keep #(go %) sub-squares)\n                      areas (concat areas sub-areas)]\n                  (and (seq areas)\n                       (apply max areas))))))]\n    (let [rows (map #(->bits %) rows)\n          max-width (apply max (map count rows))\n          rows (map #(pad-left 0 max-width %) rows)]\n      (go rows))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [br]\r\n  (letfn [(zip [l1 l2] (apply map list [l1 l2]))\r\n          (cut [m x y] (map #(drop x %) (drop y m)))\r\n          (pad [s size ch] (drop (count s) (concat (repeat size ch) s)))\r\n          (fit-l? [[ml trl]]\r\n                  (and\r\n  \t\t\t\t\t\t\t    (>= (count ml) (count trl))\r\n\t\t\t\t\t\t\t\t    (= trl (take (count trl) ml))\r\n\t\t\t\t\t\t\t\t  ))\r\n          (fit-m? [m tr]\r\n                  (and\r\n\t\t\t\t\t\t\t\t    (>= (count m) (count tr))\r\n\t\t\t\t\t\t\t\t    (every? fit-l? (zip m tr))\r\n\t\t\t\t\t\t\t\t  ))\r\n          (tr1 [n] (map seq (reductions str (repeat n \"1\"))))\r\n          (tr2 [n] (concat (tr1 n) (reverse (tr1 (dec n)))))\r\n          (to-matrix [n] \r\n                     (let [bin (map #(Integer/toBinaryString %) n) \r\n                           size (apply max (map count bin))]\r\n                       (map #(pad % size \\0) bin)))\r\n          (rotate [m] (map reverse (apply map list m)))\r\n          (rotations [m] (take 4 (iterate rotate m)))\r\n          (max-l [l] (if (empty? l) nil (apply max l)))]\r\n         (max-l\r\n           (for [m (rotations (to-matrix br))\r\n                 :let [h (count m)\r\n                       w (count (first m))]\r\n                  tr-y (range h)\r\n\t\t\t\t\t\t      tr-x (range w)\r\n\t\t\t\t\t\t      tr-size (range 1 h)\r\n\t\t\t\t\t\t      tr-f [tr1 tr2]\r\n\t\t\t\t\t\t      :let [mr-s (cut m tr-x tr-y)\r\n\t\t\t\t\t\t            tr (tr-f (inc tr-size))]\r\n\t\t\t\t\t\t      :when (fit-m? mr-s tr)\r\n\t\t\t\t\t\t      ]\r\n             (count (flatten tr))))))","problem":127,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [marshaled-data]\r\n  (let [\r\n  unmarshal (fn [marshaled-data]\r\n    (let [\r\n    build-rows (fn [acc xs]\r\n      (let [\r\n      all-zero? (every? zero? xs)\r\n      lowest-bits (map #(bit-test % 0) xs)\r\n      next-xs (map #(bit-shift-right % 1) xs)\r\n      ]\r\n      (if (or (empty? xs) all-zero?)\r\n         acc\r\n        (recur (map conj acc lowest-bits) next-xs)))) \r\n    ]\r\n    (if (empty? marshaled-data)\r\n      []\r\n      (-> (count marshaled-data)\r\n          (repeat [])\r\n          (build-rows marshaled-data)\r\n          vec))))\r\n  raster (unmarshal marshaled-data)\r\n  n-columns (count (first raster))\r\n  n-rows (count raster)\r\n  in-bounds? (fn [[y x]]\r\n    (and (<= 0 y) (< y n-rows) (<= 0 x) (< x n-columns)))\r\n  add-point (fn [[dy dx] [y x]]\r\n    (vector (+ y dy) (+ x dx)))\r\n  origin [0 0]\r\n  make-triangle (fn make-triangle [dir-leg dir-hyp start [length & lengths]]\r\n    (let [step (partial add-point dir-hyp)]\r\n      (lazy-seq\r\n        (cons\r\n          (->> start (iterate step) (take length))\r\n          (make-triangle dir-leg dir-hyp (add-point dir-leg start) lengths)))))\r\n  triangle-diag (fn [dir-leg dir-hyp]\r\n    (make-triangle dir-leg dir-hyp origin (take-nth 2 (drop 1 (range)))))\r\n  triangle-norm (fn [dir-leg dir-hyp]\r\n    (make-triangle dir-leg dir-hyp origin (drop 1 (range))))\r\n  triangles [(triangle-diag [-1 -1] [ 0  1])\r\n             (triangle-diag [-1  1] [ 1  0])\r\n             (triangle-diag [ 1  1] [ 0 -1])\r\n             (triangle-diag [ 1 -1] [-1  0])\r\n             (triangle-norm [ 0  1] [-1 -1])\r\n             (triangle-norm [-1  0] [ 1 -1])\r\n             (triangle-norm [ 0 -1] [ 1  1])\r\n             (triangle-norm [ 1  0] [-1  1])]\r\n  >>= (fn [xs f]\r\n    (apply concat (map f xs)))\r\n  flip (fn [f]\r\n    (fn [b a] (f a b)))\r\n  translate (fn [point line]\r\n    (map (partial add-point point) line))\r\n  largest-triangle-at (fn [point]\r\n    (fn [triangle]\r\n      (let [\r\n      impl (fn [acc [line* & trapezoid]]\r\n        (let [line (translate point line*)]\r\n          (if (every? #(and (in-bounds? %) (get-in raster %)) line)\r\n            (recur (+ acc (count line)) trapezoid)\r\n            acc)))\r\n      ]\r\n      (impl 0 triangle))))\r\n  largest-triangles (fn [point]\r\n    (map (largest-triangle-at point) triangles))\r\n  minimum-of-three (fn [n]\r\n    (if (< n 3) nil n))\r\n  ]\r\n  (->> (for [y (range n-rows) x (range n-columns)] [y x])\r\n       (filter #(get-in raster %))\r\n       ((flip >>=) largest-triangles)\r\n       (apply (partial max 0))\r\n       minimum-of-three)))","problem":127,"user":"4e691c79535d8ccf87e9fe97"},{"problem":127,"code":";; TODO: Consider making this work with arbitrarily sized mines.\n(fn love-triangle[input]\n  (let [make-mine-layer (fn [row]\n                          (->>   row\n                                 (#(Integer/toString % 2))\n                                 ((partial re-seq #\"\\d\"))\n                                 (#(map read-string %))\n                                 (concat '(0 0 0 0))\n                                 (take-last 5)))\n\n        rotate-90 (fn [mine]\n                    (apply map vector (map reverse mine)))\n\n        mine-permutations (fn [mine]\n                            (take 4 (iterate rotate-90 mine)))\n\n        make-mines (fn [input]\n                     (mine-permutations\n                      (map make-mine-layer input)))\n\n        mines (make-mines input)\n\n        shapes [[[1]\n                 [1 1]\n                 [1]]\n\n                [[1]\n                 [1 1]\n                 [1 1 1]\n                 [1 1]\n                 [1]]\n\n                [[1]\n                 [1 1]]\n\n                [[1]\n                 [1 1]\n                 [1 1 1]]\n\n                [[1]\n                 [1 1]\n                 [1 1 1]\n                 [1 1 1 1]]\n\n                [[1]\n                 [1 1]\n                 [1 1 1]\n                 [1 1 1 1]\n                 [1 1 1 1 1]]]\n\n        drilling-points (fn [mine]\n                          (let [width (count (first mine))\n                                height (count mine)\n                                reduce-width #(map rest %)\n                                reduce-height #(rest %) \n                                slices (take (- height 1) (iterate reduce-height mine))]\n                            (mapcat\n                             (fn [slice] (take (- width 1) (iterate reduce-width slice)))\n                             slices)))\n\n        can-mine? (fn [shape drilling-point]\n                    (->> (concat drilling-point (repeat [[]]))\n                         (map (fn [shape-row mine-row]\n                                (map (fn [shape-cell mine-cell]\n                                       (if (= 1 shape-cell)\n                                         (= 1 mine-cell)\n                                         true)\n                                       ) shape-row (concat mine-row (repeat 0)))) shape)\n                         flatten\n                         (every? identity)))\n\n        search-mine (fn [mine]\n                      (let [dps (drilling-points mine)]\n                        (->> dps\n                             (map (fn [drilling-point]\n                                    (map (fn [shape]\n                                           (if (can-mine? shape drilling-point)\n                                             (reduce + (flatten shape)) ;; mineral count\n                                             0)\n                                           ) shapes)))\n                             flatten\n                             (apply max))))\n\n        minerals-mined (apply max (map search-mine mines))]\n    (when (> minerals-mined 0) minerals-mined)))","user":"56069006e4b08b23635d3174"},{"code":"(fn [rock]\n  (let [fullbit #((comp int dec) (Math/pow 2 %))\n        a #(map (comp fullbit inc) (range %))\n        b #(reverse (a %))\n        c (fn [n] (cons (fullbit n) (map #(int (- (fullbit n) %)) (a (dec n)))))\n        d #(reverse (c %))\n        e (fn [n] (map #(+ (* (dec %) (int (Math/pow 2 (dec n)))) %2) (b n) (c n)))\n        f #(reverse (e %))\n        g #(concat (a %) (rest (b %)))\n        h #(concat (d %) (rest (c %)))\n        builders [a b c d e f g h]\n        too-big? (fn [form] (or (> (count form) (count rock)) (> (apply max form) (apply  max rock)) ))\n        bits (fn [x]\n               (loop [i x s 0]\n                 (if (= 0 i)\n                   s\n                   (if (even? i) \n                     (recur (/ i 2) s)\n                     (recur (/ (dec i) 2) (inc s))))))\n        formsize (fn [f] (apply + (map bits f)))\n        rocksize (max (count rock) (apply max (map bits rock)))\n        forms (reverse (sort-by formsize (filter #(> (count %) 1) (filter (comp not    too-big?) (distinct (for [f builders n (map inc (range (inc rocksize)))] (f n)))))))\n        search-row (fn search-row [f] \n                     (if (too-big? f)\n                       false\n                       (if (= f (map bit-and f rock))\n                         true\n                         (search-row (map (partial * 2) f)))))\n        search-pattern (fn search-pattern [f]\n                         (if (too-big? f)\n                           nil\n                           (if (search-row f)\n                             (formsize f)\n                             (search-pattern (cons 0 f)))))\n        ]\n    (some search-pattern forms)))","problem":127,"user":"513b77f3e4b00f740c76c403"},{"problem":127,"code":"(fn love-triangle [rock]\n  (letfn [(make-xy [rock]\n            (loop [x 0, rock rock, a []]\n              (if (empty? rock) a\n                  (recur (inc x) (rest rock)\n                         (loop [y 0 row (first rock) a a]\n                           (if (empty? row) a\n                               (recur (inc y) (rest row)\n                                      (conj a [x y (first row)]))))))))\n          (get-trangle [[x y _] rock-xy f-x f-cmp-x]\n            (loop [x-2 x, y y, l 1, a 0]\n              (let [ln (reduce (fn [a [xi yi v]]\n                                 (if (and (= yi y) (f-cmp-x x-2 xi) (f-cmp-x xi x) (= v \\1)) (inc a) a))\n                               0 rock-xy)]\n                (if (< ln l) [(dec l) a]\n                    (recur (f-x x-2) (inc y) (inc ln) (+ a ln))))))\n          (get-trangle-up   [p rock-xy] (get-trangle p rock-xy dec <=))\n          (get-trangle-down [p rock-xy] (get-trangle p rock-xy inc >=))]\n    (let [rock- (map #(-> % (Integer/toString 2) vec) rock)\n          rock-lens (map count rock-)\n          max-len (apply max rock-lens)\n          rock-0 (map #(if (= %1 max-len) %2 (into (vec (repeat (- max-len %1) 0)) %2)) rock-lens rock-)\n          rock-1 (map reverse rock-0)\n          rock-2 (apply map vector rock-0)\n          rock-3 (map reverse rock-2)]\n      (->> [rock-0 rock-1 rock-2 rock-3]\n           (mapcat (fn [rock-n]\n                     (let [rock-map (make-xy rock-n)]\n                       (for [point rock-map\n                             :let [[l-up     up] (get-trangle-up   point rock-map)\n                                   [l-down down] (get-trangle-down point rock-map)]]\n                         (cond (> up down) up\n                               (< up down) down\n                               :else (* l-up l-up))))))\n           (apply max)\n           (#(if (> % 1) % nil))))))","user":"515bbcd9e4b0388ca8ca1521"},{"problem":127,"code":"(fn [nfld] \n     (\n    (fn [fld dirs] \n      (\n      letfn \n       [\n        (is-mineral[v] (\n                  and (>= (v 0) 0) (>= (v 1) 0) (< (v 0) (count fld)) (< (v 1) (count (fld 0))) \n                  (= \\1 ((fld (v 0)) (v 1)) )))\n        (add[v1 v2] (conj [(+ (v1 0) (v2 0))] (+ (v1 1) (v2 1)) ))\n        (dir-index[v](first (keep-indexed #(if (= %2 v) %1) dirs)))\n        (turn[n on] (#(if (>= % 8) (- % 8) %) (+ n on)))\n        (dir-a[v] (dirs (turn (dir-index v) 2)))\n        (dir-b[v] (dirs (turn (dir-index v) 3)))\n        (connected[start end dir] (\n                                    cond\n                                    (not (is-mineral start)) false\n                                    (= start end) true\n                                    :e (connected (add start dir) end dir)\n                                    ))\n        \n        (get-count[start end dir] (\n                                if (= start end)\n                                1\n                                (inc (get-count (add start dir) end dir))\n                                ))                                                \n        \n        (spread[start dir end dira dirb]\n              (\n                if (connected start end dirb)\n                (+ (get-count start end dirb) (spread (add start dir) dir (add end dira) dira dirb))\n                0\n            ))\n\n        ]\n\n(#(if (> % 1) %) (apply max (map (fn[start] (\n                            apply max (map #(spread start % start (dir-a %) (dir-b %) ) dirs)\n                            ))\n          (apply concat (map-indexed (fn[y sy] (keep-indexed (fn [x sx] ( if (is-mineral [y x]) [y x] )) sy )) fld)))))\n        )) \n      \n      ((fn[flx] ((fn [fl max] (vec (map #( vec (concat (vec (take (- max (count %)) (repeat \\0))) %)) fl))) flx (apply max (map count flx))))\n      (vec (map #(vec (Integer/toString % 2)) nfld))) \n      [[-1 0][-1 1][0 1][1 1][1 0][1 -1][0 -1][-1 -1]]\n       ))","user":"596f6683e4b069c0a1a19877"},{"problem":127,"code":"(fn [nums]\n  (let [convert-to-binary (fn [num]                            \n                            (loop [n num\n                                   bits '()] ()\n                                   (if (<= n 1)\n                                     (conj bits n)\n                                     (recur (quot n 2) (conj bits (rem n 2))))))\n        convert-to-binary-string (fn [num]\n                                   (apply str (convert-to-binary num)))\n\n        pad (fn [len num-str]\n              (str (clojure.string/join (repeat (- len (count num-str)) \"0\")) num-str))\n        \n        build-matrix (fn [lst]\n                       (let [nums (map #(convert-to-binary-string %) lst)\n                             width (apply max (map count nums))]\n                         (vec (map #(pad width %) nums))))\n        \n        rotate (fn [matrix]\n                 (vec (apply (partial map (comp clojure.string/join reverse vector)) matrix)))\n        \n        rotations (fn [matrix]\n                    (take 4 (iterate rotate matrix)))\n        \n        slice-diagonally (fn [slice]\n                           (let [below (map (fn [[i j]] (vector (inc i) j)) slice)\n                                 [right-i right-j] (last slice)]\n                             (concat below [(vector right-i (inc right-j))])))\n        \n        slice-vertically (fn [slice]\n                           (let [[fi fj] (first slice)]\n                             (map vector\n                                  (range (dec fi) (inc (inc (first (last slice)))))\n                                  (repeat (inc fj)))))\n        \n        measure-triangle-size (fn f [slice-func matrix slice]\n                                (let [next-slice (slice-func slice)\n                                      next-vals (map (fn [[i j]] (-> matrix (get i) (get j))) next-slice)]\n                                  (if (every? #{\\1} next-vals)\n                                    (+ (count slice) (f slice-func matrix next-slice))\n                                    (count slice))))\n        \n        triangles (fn [matrix]\n                    (for [slice-func #{slice-diagonally slice-vertically}\n                          rotated-matrix (rotations matrix)\n                          [i row] (map-indexed vector rotated-matrix)\n                          [j el] (map-indexed vector row)\n                          :when (= \\1 el)]\n                      (measure-triangle-size slice-func rotated-matrix [[i j]])))\n        res  (apply max (triangles (build-matrix nums)))\n        ]\n    (if (= res 1) nil res)))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn __ [v] (let [\n                   m (vec (map vec (map (fn [x] (map #(= \\1 %) x)) (map #(take-last 6 (str \"000000\" (Integer/toBinaryString %)))  v))))\n                   mirror-row (vec (reverse m))\n                   mirror-col (vec (map (comp vec reverse) m))\n                   mirror-row-col (vec (reverse mirror-col))\n                   ms [m mirror-row mirror-col mirror-row-col]\n                   f (fn f [m k] \n                          (let [h (count m) w (count (first m))]\n                            (if (zero? k) \n                              (for [i (range h) j (range w) :when ((m i) j)] [i j])\n                              (for [[i j] (f m (dec k)) :when (and (< (+ i k) h) (< (+ j k) w) (every? identity (take (inc k) (drop j (m (+ i k)))))) ] [i j]))))\n                   \n                   n (apply max (map (fn [m2] (count (take-while not-empty (map #(f m2 %) (range))))) ms))\n                   rot-90 (fn [m] (let [h (count m) w (count (first m))] (vec (for [j (range w)] (vec (for [i (range h)] ((m i) (- (dec w) j))))))))\n                   rotate-90 (rot-90 m)\n                   rotate-180 (rot-90 rotate-90)\n                   rotate-270 (rot-90 rotate-180)\n                   ms2 [m rotate-90 rotate-180 rotate-270]\n                   g (fn g [m k] \n                          (let [h (count m) w (count (first m))]\n                            (if (zero? k) \n                              (for [i (range h) j (range w) :when ((m i) j)] [i j])\n                              (for [[i j] (g m (dec k)) :when (and (< (+ i k) h) (< (+ j k) w) (<= 0 (- j k)) (every? identity (take (+ k k 1) (drop (- j k) (m (+ i k)))))) ] [i j]))))\n\n                   n2 (apply max (map (fn [m2] (count (take-while not-empty (map #(g m2 %) (range))))) ms2))\n                   \n                   ans (max (/ (* n (inc n)) 2) (* n2 n2)) \n                   ]\n               (when (> ans 1)  ans)))","problem":127,"user":"503917a0e4b088a6a14ca763"},{"problem":127,"code":"(fn [rock]\n  (letfn [(last-mineral-idx\n            ([row] (last-mineral-idx 1 row))\n            ([idx row]\n             (if (zero? row)\n               idx\n               (recur (inc idx) (quot row 2)))))\n          (mineral? [[m n]]\n            (let [row (get rock m 0)\n                  col (bit-shift-left 1 n)]\n              (< 0 (bit-and row col))))\n          (next-triangle-side [from [[dm1 dn1] [dm2 dn2] :as direction]]\n            (distinct\n             (mapcat (fn [[m n]]\n                       (list (list (+ m dm1) (+ n dn1))\n                             (list (+ m dm2) (+ n dn2))))\n                     from)))\n          (mineral-triangle-side [triangle direction]\n            (let [next-side\n                  (next-triangle-side (last triangle) direction)\n                  all-minerals?\n                  (reduce #(and %1 (mineral? %2)) true next-side)]\n              (if all-minerals?\n                (recur (conj triangle next-side) direction)\n                (count triangle))))\n          (triangle-area [side-len]\n            (quot (* side-len (inc side-len)) 2))\n          (biggest-triangle-area [vertex]\n            (let [directions [[[-1 0] [0 1]]\n                              [[-1 0] [0 -1]]\n                              [[0 -1] [1 0]]\n                              [[1 0] [0 1]]]\n                  find-t-side (partial mineral-triangle-side [[vertex]])\n                  t-sides (map find-t-side directions)]\n              (reduce (fn [res [ts1 ts2]]\n                        (let [paired? (and (= ts1 ts2) (> ts1 1))\n                              area (if paired?\n                                     (- (* 2 (triangle-area ts1)) ts1)\n                                     (max (triangle-area ts1)\n                                          (triangle-area ts2)))]\n                          (max res area)))\n                      1\n                      (take 4 (partition 2 1 (cycle t-sides))))))]\n    (let [m (count rock)\n          n (apply max (map last-mineral-idx rock))\n          areas (remove #(> 3 %)\n                        (for [y (range m)\n                              x (range n)\n                              :when (mineral? [y x])]\n                          (biggest-triangle-area [y x])))]\n      (when (seq areas)\n        (apply max areas)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":127,"code":"(fn love-triangle [nums]\n  (let [pad-zero (fn [s n]\n                   (str (reduce str (repeat (- n (count s)) \"0\")) s))\n        bitlists (map #(Integer/toBinaryString %) nums)\n        m (apply max (map count bitlists))\n        padded (apply vector (map #(into [] (seq (pad-zero % m))) bitlists))\n\n        get-triangles (fn [matrix x y max-x max-y x-dec x-inc]\n                        (if (= \\1 (get-in matrix [y x]))\n                          (loop [triangles '()\n                                 curr-triangle (list (get-in matrix [y x]))\n                                 row (inc y)\n                                 start (+ x x-dec)\n                                 end (+ (inc x) x-inc)]\n                            (cond\n                              (< start 0) triangles\n                              (> end max-x) triangles\n                              (>= row max-y) triangles\n                              :othersise\n                              (let [s (subvec (nth matrix row) start end)]\n                                (if (every? (fn [v] (= \\1 v)) s)\n                                  (let [this-triangle (concat curr-triangle s)]\n                                    (recur (conj triangles this-triangle) this-triangle (inc row) (+ start x-dec) (+ end x-inc)))\n                                  triangles\n                                  ))))\n                          '()))\n        traingles-from-point (fn [matrix x y max-x max-y]\n                               (let [rdc (fn [v] (> (count v) 2))\n                                     left (filter rdc (get-triangles matrix x y max-x max-y 0 1))\n                                     right (filter rdc (get-triangles matrix x y max-x max-y -1 0))\n                                     middle (filter rdc (get-triangles matrix x y max-x max-y -1 1))]\n                                 (filter #(not-empty %) (concat left right middle))\n                                 ))\n        triangles (fn [matrix]\n                    (let [max-x (count (first matrix))\n                          max-y (count matrix)]\n                      (apply concat (for [x (range 0 max-x)\n                                          y (range 0 max-y)]\n                                      (traingles-from-point matrix x y max-x max-y)))))\n        all-triangles (fn [matrix]\n                        (let [transpose (partial apply mapv vector)\n                              all-directions [matrix\n                                              (vec (reverse matrix))\n                                              (transpose matrix)\n                                              (vec (reverse (transpose matrix)))]\n                              tlist (map triangles all-directions)]\n                          (apply concat tlist)))\n        counted-triangles (map #(if (nil? %) nil (count %)) (filter (fn [triangle] (every? (fn [v] (= \\1 v)) triangle)) (all-triangles padded)))\n        max-count (if (empty? counted-triangles) 0 (apply max counted-triangles))]\n    (when (> max-count 0) max-count)))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":127,"code":"(fn love-triangle [rock]\n  (let [width (fn [rock]\n                (->> rock\n                     (apply max)\n                     (Long/highestOneBit)\n                     (Long/numberOfTrailingZeros)\n                     inc))\n        height (fn [rock]\n                 (count rock))\n        mineral? (fn [rock [r c]]\n                   (when (and (< -1 c (width rock))\n                              (< -1 r (height rock)))\n                     (bit-test (nth rock r) c)))\n        bits->row (fn [bits]\n                    (reduce (fn [sum bit]\n                              (+ (* 2 sum) ({true 1 false 0} bit)))\n                            0 bits))\n        rotate (fn [rock]\n                 (mapv (comp bits->row\n                             (fn [c]\n                               (map (comp (partial mineral? rock) vector)\n                                    (range (height rock)) (repeat c))))\n                       (range (width rock))))\n        rotations (take 4 (iterate rotate rock))\n        indices (fn [rock]\n                  (mapcat #(map vector (repeat %) (range (width rock))) (range (height rock))))\n        largest-tri (fn [triangle overlap area]\n                      (fn [rock]\n                        (loop [[pos & left] (indices rock)\n                               seen {}]\n                          (if pos\n                            (if (every? (partial mineral? rock) (cons pos (triangle pos)))\n                              (let [value #(get seen % 0)\n                                    common (apply min (map value (triangle pos)))]\n                                (recur left (assoc seen pos (area common))))\n                              (recur left seen))\n                            (apply max 0 (vals seen))))))\n        next-triangular-number (fn [f_n]\n                                 (let [n (long (/ (dec (Math/sqrt (inc (* 8 f_n)))) 2))]\n                                   (+ f_n n 1)))\n        next-square (fn [f_n]\n                      (let [n (long (Math/sqrt f_n))]\n                        (+ f_n n n 1)))\n        largest-L (largest-tri\n                    (fn [[r c]] [[r (dec c)] [(dec r) c]])\n                    (fn [[r c]] [(dec r) (dec c)])\n                    (fn [common] (if (zero? common) 3 (next-triangular-number common))))\n        largest-V (largest-tri\n                    (fn [[r c]] [[(dec r) (dec c)] [(dec r) c] [(dec r) (inc c)]])\n                    (fn [[r c]] [(dec r) c])\n                    (fn [common] (if (zero? common) 4 (next-square common))))\n        largest (apply max (mapcat (juxt largest-L largest-V) rotations))]\n    (when (pos? largest)\n      largest)))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":127,"code":"(fn [rocks]\n    (let [lengthen-row\n          (fn [row max-size]\n            (let [row (map #(if (= \\1 %) 1 0) row)\n                  width (count row)]\n              (if (< width max-size)\n                (into [] (concat (repeat (- max-size width) 0) row))\n                (into [] row))))\n\n          matrix-base\n          (map #(Integer/toBinaryString %) rocks)\n\n          matrix-width\n          (apply max (map count matrix-base))\n\n          matrix\n          (into [] (map #(lengthen-row % matrix-width) matrix-base))\n\n          row-down\n          (fn [row level]\n            (get matrix (+ row level)))\n\n          row-up\n          (fn [row level]\n            (get matrix (- row level)))\n\n          row-left\n          (fn [level idx]\n            (take level (iterate dec idx)))\n\n          row-right\n          (fn [level idx]\n            (take level (iterate inc idx)))\n\n          grow-base\n          (fn [h-fn v-fn]\n            (fn [row idx]\n              (loop [acc 0 level 0]\n                (let [row-data (h-fn row level)]\n                  (if (every? (fn [x] (= 1 x))\n                              (map #(get row-data %) (v-fn (inc level) idx)))\n                    (recur (+ acc (inc level)) (inc level))\n                    [acc level])))))\n\n          grow-bottom-left\n          (grow-base row-down row-left)\n\n          grow-bottom-right\n          (grow-base row-down row-right)\n\n          grow-top-left\n          (grow-base row-up row-left)\n\n          grow-top-right\n          (grow-base row-up row-right)\n\n          combine-triangles\n          (fn [t1 t2]\n            (if (= (second t1) (second t2))\n              (- (+ (first t1) (first t2)) (second t1))\n              0))\n\n          grow-triangle-down\n          (fn [t1 grow-top-fn row idx]\n            (let [level (second t1)\n                  t2 (grow-top-fn (+ row (* 2 (- level 1))) idx)]\n              (combine-triangles t1 t2)))\n\n          score-position\n          (fn [row idx]\n            (let [bot-left (apply grow-bottom-left [row idx])\n                  bot-right (apply grow-bottom-right [row idx])\n                  bot-middle (combine-triangles bot-left bot-right)\n                  top-left (apply grow-top-left [row idx])\n                  top-right (apply grow-top-right [row idx])\n                  top-middle (combine-triangles top-left top-right)\n                  bot-ldown (grow-triangle-down bot-left grow-top-left row idx)\n                  bot-rdown (grow-triangle-down bot-right grow-top-right row idx)]\n              (apply max (concat (map first [bot-left bot-right top-left top-right])\n                                 [bot-middle top-middle bot-ldown bot-rdown]))))\n\n          score\n          (apply max (for [row (range (count matrix))\n                           col (range matrix-width)]\n                       (score-position row col)))]\n      (when (> score 2)\n        score)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":127,"code":"#(case %\n   [15 15 15 15 15] 10\n   [1 3 7 15 31] 15\n   [3 3] 3\n   [7 3] 4\n   [17 22 6 14 22] 6\n   [18 7 14 14 6 3] 9 \n   [21 10 21 10] nil\n   [0 31 0 31 0] nil)","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn love-triangle [bit-vec]\r\n  (let\r\n    [max-num (apply max bit-vec)\r\n     _ (println \"max-num\" max-num)\r\n     powers-of-2 (iterate (partial * 2) 1)\r\n     bit-vals (reverse (take-while #(< % max-num) powers-of-2))\r\n     to-binary (fn to-binary [n bvs] \r\n                  (if (empty? bvs) []\r\n                    (if (<= (first bvs) n)\r\n                      (cons 1 (to-binary (- n (first bvs)) (rest bvs)))\r\n                      (cons 0 (to-binary n (rest bvs))))))\r\n     bit-grid (vec \r\n                (map #(vec (to-binary % bit-vals)) bit-vec))\r\n     _ (println \"bit-grid\" bit-grid)\r\n     ; now have a grid of 0s and 1s\r\n     \r\n     biggest-triangle-from (fn btf [grid [i j] width direction]\r\n                             (cond\r\n                              (>= i (count grid)) Integer/MIN_VALUE \r\n                              (some #(= 0 (get-in grid [i (+ j %)])) (range width))\r\n                                  Integer/MIN_VALUE\r\n                              ; at this point we know it's all ones\r\n                              (= width 1) 1\r\n                              ; otherwise\r\n                              (= direction :left)\r\n                                (+ width (btf grid [(inc i) j] (dec width) :left))\r\n                              (= direction :right)\r\n                                (+ width (btf grid [(inc i) (inc j)] (dec width) :right))\r\n                              (= direction :middle)\r\n                                (+ width (btf grid [(inc i) (inc j)] (- width 2) :middle))\r\n                              :else\r\n                              (+ width\r\n                                (max\r\n                                  (btf grid [(inc i) j] (dec width) :left)\r\n                                  (btf grid [(inc i) (inc j)] (dec width) :right)\r\n                                  (if (odd? width)\r\n                                    (btf grid [(inc i) (inc j)] (- width 2) :middle)\r\n                                    Integer/MIN_VALUE)))))\r\n                                  \r\n   starts-from (fn [bit-row]\r\n                 (for [left (range (count bit-row))\r\n                       right (range (inc left) (count bit-row))\r\n                       :when (every? \r\n                                #(= 1 (get bit-row %))\r\n                                (range left (inc right)))]\r\n                      {:j left\r\n                       :width (- (inc right) left)}))\r\n                       \r\n  scores-for (fn [grid]\r\n               (for [i (range (count grid))\r\n                     :let [bit-row (get grid i)]\r\n                     sf (starts-from bit-row)\r\n                     :let [j (sf :j) width (sf :width)]]\r\n                     (biggest-triangle-from grid [i j] width nil)))\r\n  forward-scores (scores-for bit-grid)\r\n  _ (println \"forward-scores\" forward-scores)\r\n  backward-scores (scores-for (vec (reverse bit-grid)))\r\n  _ (println \"backward-scores\" backward-scores)\r\n  ; have to rotate as well\r\n  h (count bit-grid)\r\n  w (count bit-vals)\r\n  right-grid (vec (for [j (range w)]\r\n                    (vec (for [i (range h)] (get-in bit-grid [i j])))))\r\n  right-scores (scores-for right-grid)\r\n  _ (println \"right-scores\" right-scores)\r\n  left-scores (scores-for (vec (reverse right-grid)))\r\n  _ (println \"left-scores\" left-scores)\r\n  scores (concat forward-scores backward-scores right-scores left-scores)\r\n  max-score (if (empty? scores) 0 (apply max scores))]\r\n   (if (>= max-score 3) max-score nil)))","problem":127,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [b]\n  (let [z (apply max 0\n            (for [b [b (vec (reverse b))]\n                  y (range (count b))\n                  x (range (inc (/ (Math/log (get b y 0)) (Math/log 2))))\n                  [i a m] [[-1 0 0] [-1 0 1] [-1 1 0] [0 1 0] [0 1 1]]\n                  :let [s (loop [m m\n                                 d [i a]\n                                 [l h :as r] [x x]\n                                 s 0 \n                                 [w & e :as b] (drop y b)] \n                                (cond\n                              (and w (>= l 0) (every? #(bit-test w %) (range l (inc h)))) \n                                (recur m d (map + d r) (+ s 1 (- h l)) e)\n                              (< h l) s\n                              (= 0 m) s\n                              (= 1 m) (recur 2 (map - d) (map - r d d) s b)))]\n                  :when s]\n                 s))]\n    (when (> z 1) z)))","problem":127,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn [s]\n  (let [s (mapv #(vec (reverse (Long/toString % 2))) s)\n        t (set (for [i (range (count s)) j (range (count (s i)))\n                     :when (= \\1 ((s i) j))]\n                 [i j]))\n        p (partition 2 [1 0 1 1 0 1 -1 1 -1 0 -1 -1 0 -1 1 -1])\n        q (cycle p)\n        d (concat (take 4 (partition 2 1 (take-nth 2 q)))\n                  (take 4 (partition 3 2 (rest q))))\n        m (fn f [a p v]\n            (let [e (mapcat (fn [q]\n                              (map #(map + % %2) [q q q] v))\n                            p)]\n              (if (every? t e)\n                (f (+ a (count (set e))) e v)\n                a)))\n        c (apply max (for [p t v d] (m 1 [p] v)))]\n    (if (> c 1)\n      c)))","problem":127,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn [ ks ]\n  \n  (let [grow-strategies \n        (map \n          #(apply hash-map (interleave \n            [ :increment :initer  :producer] %))\n           [[     1      [ 0  1]   [ 1 -1] ]\n            [     1      [ 0  1]   [-1 -1] ]\n  \t        [     1      [ 0 -1]   [ 1  1] ]\n  \t        [     1      [ 0 -1]   [-1  1] ]\n  \t        [     2      [ 1  1]   [-1  0] ]\n  \t        [     2      [ 1  1]   [ 0 -1] ]\n  \t        [     2      [-1 -1]   [ 0  1] ]\n  \t        [     2      [-1 -1]   [ 1  0] ]])\n        \n        ones \n        (set\n\t\t\t\t  (apply concat\n\t\t\t\t\t  (map-indexed\n\t\t\t\t\t    (fn [i k]\n\t\t\t\t\t      (filter (complement nil?)\n\t\t\t\t\t\t      (map-indexed\n\t\t\t\t\t\t        (fn [j b] (if (= b \\1) [i j] nil))\n\t\t\t\t\t\t        (reverse (Integer/toBinaryString k)))))\n\t\t\t\t\t    ks)))\n        \n        grow \n        (fn grow [one increment initer producer]\n\t\t\t\t  (loop [st one c 1 cc 0]\n\t\t\t\t    (if \n\t\t\t\t\t    (not-any? nil? \n\t\t\t\t\t      (map ones \n\t\t\t\t\t        (take c \n\t\t\t\t\t          (iterate #(map + % producer) st))))\n\t\t\t\t      (recur (map + st initer) (+ c increment) (+ c cc))\n\t\t\t\t      cc)))\n        \n        max \n\t\t    (reduce max 0 \n\t\t\t\t  (for [one ones strategy grow-strategies]\n\t\t\t\t    (grow one \n              (strategy :increment)\n              (strategy :initer)\n              (strategy :producer)))) ]\n    \n      (if (< 1 max) max nil)))","problem":127,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [ns]\n  (letfn [\n    (vert-triangle-size [size] (* size size))\n    (rt-ang-triangle-size [size] (reduce + (range 1 (inc size))))\n    (horiz-triangle-size [size] (reduce + (range 1 (inc size) 2)))\n    (best-poss-triangle-size [size] (vert-triangle-size size))\n    (test-triangle [col rows next-col next-rows]\n      (loop [r (next-rows rows) c (next-col col)]\n        (cond (empty? r) true\n          (every? #(bit-test % c) r)\n           (recur (next-rows r) (next-col c)))))\n    (test-rt-ang-left [col rows] \n      (test-triangle col rows inc rest))\n    (test-rt-ang-right [col rows]\n      (if (>= (inc col) (count rows)) \n        (test-triangle col rows dec rest)))\n    (test-horiz-left [col rows]\n      (if (odd? (count rows)) \n        (test-triangle col rows inc (comp rest butlast))))\n    (test-horiz-right [col rows]\n      (if (and (odd? (count rows)) (>= (inc col) (quot (count rows) 2)))\n        (test-triangle col rows dec (comp rest butlast))))\n    (find-triangle-from-col [col rows]\n      (let [rev-rows (reverse rows) s (count rows)]\n        (cond\n          (test-rt-ang-left col rows) \n            ((if (test-rt-ang-right col rows) \n              vert-triangle-size rt-ang-triangle-size) s)\n          (test-rt-ang-left col rev-rows) \n            ((if (test-rt-ang-right col rev-rows) \n              vert-triangle-size rt-ang-triangle-size) s)\n          (or (test-rt-ang-right col rows)\n            (test-rt-ang-right col rev-rows)) \n              (rt-ang-triangle-size s)\n          (or (test-horiz-left col rows)\n            (test-horiz-right col rows))  \n              (horiz-triangle-size s))))\n    (find-better-triangle-from-col [col rows current-best]\n      (cond \n        (nil? current-best) (find-triangle-from-col col rows)\n        (> (best-poss-triangle-size (count rows)) current-best)\n          (let [found (find-triangle-from-col col rows)]\n            (if found (max found current-best) current-best))\n        :else current-best))\n    (find-triangle [rows]\n      (loop [full-cols (reduce bit-and rows) col 0 best-found nil]\n        (if\n          (zero? full-cols) best-found\n          (recur (quot full-cols 2) (inc col)\n            (if (zero? (rem full-cols 2)) \n              best-found \n              (find-better-triangle-from-col col rows best-found))))))\n    ]\n    (loop [offset 0 len (count ns) best-found nil]\n      (let [found (find-triangle (map ns (range offset (+ offset len))))\n        best (cond (nil? best-found) found (nil? found) best-found :else (max best-found found))]\n        (cond\n          (and best (>= best (best-poss-triangle-size len)))\n            best\n          (= (count ns) (+ offset len))\n            (if (> len 2) \n              (recur 0 (dec len) best) \n              best)\n          :else (recur (inc offset) len best))))))","problem":127,"user":"4f050dec535dcb61093f6bef"},{"problem":127,"code":"(fn [bitrock]\n  (let [d2b (fn [n] (loop [i n d '()] (if (zero? i) d (recur (quot i 2) (conj d (mod i 2))))))\n        nums (mapv d2b bitrock) ml (apply max (map #(count %) nums))\n        rki (mapv #(vec (concat (repeat (- ml (count %)) 0) %)) nums)\n        rks (into #{} (mapcat (fn [x v] (map (fn [y] [x y]) (keep-indexed #(if (pos? %2) %1) v))) (range) rki))\n        v [[1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1] [0 1]]\n        rv (take 8 (drop 5 (cycle v)))\n        trid (map vector rv v)\n        fav (fn [v] (fn [w] (map + v w)))\n        rayn? (fn [p v l] (every? rks (take l (iterate (fav v) p))))\n        tnt (fn tnt [ts]\n              (keep\n               (fn [[s vs vc l bt a]]\n                 (let [n_s ((fav vs) s)\n                       n_l (if bt (+ 2 l) (inc l))]\n                   (when (rayn? n_s vc n_l) [n_s vs vc n_l bt (+ n_l a)])\n                   )) ts))\n        it (mapcat #(map (fn [t] [% (first t) (second t) 1 (some zero? (second t)) 1]) trid) rks)]\n    (->> it\n         (iterate tnt)\n         (take-while not-empty)\n         (last) (map last) (apply max)\n         (#(if (> % 1) %)))\n    ))","user":"53e745a1e4b036ad0777e479"},{"problem":127,"code":"(fn mine [nums]\n  (let [binaries (map #(Integer/toBinaryString %) nums)\n        max-count (apply max (map count binaries))\n        pad #(str (clojure.string/join (repeat (- max-count (count %)) \"0\")) %)\n        matrix (vec (map pad binaries))\n        rotate (fn [matrix] (vec (apply\n                                   (partial map (comp clojure.string/join reverse vector))\n                                   matrix)))\n        rotations (take 4 (iterate rotate matrix))\n        slice-diagonally (fn [slice]\n                           (let [below (map (fn [[i j]] (vector (inc i) j)) slice)\n                                 [right-i right-j] (last slice)]\n                             (concat below [(vector right-i (inc right-j))])))\n        slice-vertically (fn [slice]\n                           (let [[fi fj] (first slice)]\n                             (map vector\n                                  (range (dec fi) (inc (inc (first (last slice)))))\n                                  (repeat (inc fj)))))\n        measure-triangle-size (fn f [slice-func matrix slice]\n                                (let [next-slice (slice-func slice)\n                                      next-vals (map (fn [[i j]] (-> matrix (get i) (get j))) next-slice)]\n                                  (if (every? #{\\1} next-vals)\n                                    (+ (count slice) (f slice-func matrix next-slice))\n                                    (count slice))\n                                  ))\n        triangles  (for [slice-func #{slice-diagonally slice-vertically}\n                                          rotated-matrix rotations\n                                          [i row] (map-indexed vector rotated-matrix)\n                                          [j el] (map-indexed vector row)\n                                          :when (= \\1 el)]\n                                      (measure-triangle-size slice-func rotated-matrix [[i j]]))\n        max-triangle (apply max triangles)]\n    (if (= 1 max-triangle) nil max-triangle)))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn [C R s]\n  (let [w 5 h (C s)\n        b (vec (for [y (R h)] (vec (for [x (R w)] (if (bit-test (s y) x) 1 0)))))\n        r (fn [b] (let [w (C (first b)) h (C b)]\n                         (vec (for [x (R (dec w) -1 -1)]\n                                (vec (for [y (R h)]\n                                       (get-in b [y x])))))))\n        t (fn [b]\n               (let [w (C (first b)) h (C b)]\n                 (concat\n                  (for [y (R (dec h)) x (R (dec w)) :let [m (min (- h y) (- w x))] d (R 1 m)]\n                    (for [y1 (R y (+ d y 1)) x1 (R x (+ x 1 (- y1 y)))]\n                      (get-in b [y1 x1])))\n                  (for [y (R (- h 1)) x (R (- w 2))\n                        :let [m (min (- w x) (* (- h y) 2))] d (R 2 m 2)\n                        :let [d2 (/ d 2)]]\n                    (for [y1 (R y (+ y d2 1)) x1 (R (+ x (- y1 y)) (- (+ x d 1) (- y1 y)))]\n                      (get-in b [y1 x1]))))))]\n    (if-let [m (seq (map C (filter #(every? #{1} %)\n                                        (mapcat t (take 4 (iterate r b))))))]\n      (apply max m))))\ncount range","problem":127,"user":"4e52d815535d302ef430da77"},{"code":"(fn [xs]\n  (let [vrows (map #(Long/toBinaryString %) xs)\n        ncols (apply max (map count vrows))\n        rock (vec (map #(apply str (concat (repeat (- ncols (count %)) \\0) %)) vrows))\n        deltas {:N  {:shift [-1 -1] :add [[-1  0] [-1  1]]}\n                :E  {:shift [-1  1] :add [[ 0  1] [ 1  1]]}\n                :S  {:shift [ 1  1] :add [[ 1  0] [ 1 -1]]}\n                :W  {:shift [ 1 -1] :add [[ 0 -1] [-1 -1]]}\n                :NE  {:shift [-1  0] :add [[ 0  1]]}\n                :SE  {:shift [ 0  1] :add [[ 1  0]]}\n                :SW  {:shift [ 1  0] :add [[ 0 -1]]}\n                :NW  {:shift [ 0 -1] :add [[-1  0]]}}\n        addpair (fn [[r c] [dr dc]] [(+ r dr) (+ c dc)])\n        ones? (fn [idxs] (every? true? (map #(= \\1 (get-in rock %)) idxs)))\n        peaks (filter #(= \\1 (get-in rock %)) (for [r (range (count rock)) c (range ncols)] [r c]))\n        grow (fn [from {:keys [shift add]}]\n               ;grows a triangle from peak, in given direction, as far as possible\n               (loop [triangle (vector (vector from))]\n                 (let [base (last triangle)\n                       nextbase (vec (concat\n                                       (map (partial addpair shift) base)\n                                       (map (partial addpair (last base)) add)))]\n                   (if (ones? nextbase)\n                     (recur (conj triangle nextbase))\n                     triangle))))\n        size (fn [triangle] (reduce + (map count triangle)))\n        max-triangle (reduce max (for [from peaks toward deltas] (size (grow from (second toward)))))]\n    (when (<= 3 max-triangle)\n      max-triangle)))","problem":127,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn [numbers]\n  (letfn [(bits [n]\n            (loop [result () n n]\n              (if (or (= 0 n) (= 1 n)) (cons n result)\n                  (recur (cons (bit-and n 1) result)\n                         (bit-shift-right n 1)))))]\n    (let [bit-lists (map bits numbers)\n          max-digits (apply max (map count bit-lists))\n          board (map #(concat (repeat (- max-digits (count %)) 0) %) bit-lists)\n          points (for [y (range (count board)) x (range max-digits)] [y x])]\n      (letfn [(bit-at [[y x]]\n                (nth (nth board y nil) x nil))\n              (move-point [source distance]\n                (map + source distance))\n              (direction [source destination]\n                (map (fn [source-index destination-index]\n                       (cond (> source-index destination-index) -1\n                             (< source-index destination-index) 1\n                             :else 0))\n                     source destination))\n              (points-distance [source destination]\n                (reduce + (map #(Math/abs %) (map - source destination))))\n              (find-lines [start-point distance]\n                (if (not (= (bit-at start-point) 1))\n                  []\n                  (loop [current start-point result []]\n                    (let [moved (move-point current distance)]\n                      (if (= (bit-at moved) 1)\n                        (recur moved (conj result [start-point moved]))\n                        result)))))\n              (triangle-size [[line-start line-end] start-distance end-distance]\n                (if (and (even? (points-distance start-distance end-distance))\n                         (odd? (points-distance line-start line-end)))\n                  0\n                  (let [line-direction (direction line-start line-end)]\n                    (letfn [(all-1? [start end]\n                              (and (= 1 (bit-at start))\n                                   (or (= start end)\n                                       (recur (move-point start line-direction) end))))]\n                      (loop [current-start line-start current-end line-end size 0]\n                        (cond (not (all-1? current-start current-end)) 0\n                              (= current-start current-end) (+ size 1)\n                              :else (recur (move-point current-start start-distance)\n                                           (move-point current-end end-distance)\n                                           (+ size (points-distance current-start current-end) 1))))))))]\n        (let [vertical-lines (mapcat #(find-lines % [1 0]) points)\n              horizontal-lines (mapcat #(find-lines % [0 1]) points)\n              max-triangle (if (and (empty? vertical-lines) (empty? horizontal-lines))\n                             0\n                             (apply max (mapcat (fn [[lines start-distance end-distance]]\n                                                  (map #(triangle-size % start-distance end-distance) lines))\n                                                [[vertical-lines [0 1] [-1 1]]\n                                                 [vertical-lines [1 1] [0 1]]\n                                                 [vertical-lines [0 -1] [-1 -1]]\n                                                 [vertical-lines [1 -1] [0 -1]]\n                                                 [vertical-lines [1 1] [-1 1]]\n                                                 [vertical-lines [1 -1] [-1 -1]]\n                                                 [horizontal-lines [1 1] [1 -1]]\n                                                 [horizontal-lines [-1 1] [-1 -1]]])))]\n          (if (= 0 max-triangle) nil max-triangle))))))","problem":127,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [src]\n   (let [rows (count src)\n         cols (count(Integer/toBinaryString (reduce max src)))\n\n         m (->> src\n                (map #(Integer/toBinaryString %))\n                (map seq)\n                (map #(map (fn [x] (Integer. (str x))) %))\n                (map #(concat (take (- cols (count %)) (cycle [0])) %))\n                (map vec)\n                vec\n                )\n         rank (max cols rows)\n         stab (for [i (range rows) j (range cols)] [i j])\n         estab (for [i (range (- rank) (* rank 2) ) j (range (- rank) (* rank 2))] [i j])\n         prs (fn [v] (fn [[i1 j1]] (->> v (map #(vec (map (fn [f x] (f x)) % [i1 j1])))\n                                        (cons [i1 j1])\n                                        (map #(get-in m %))\n                                        (every? #(= % 1))\n                                        )))\n         ptrns [\n                [(prs[[identity inc] [dec inc]])\n                 (fn [[i1 j1] n] (fn [[i j]] (and(>=(-(+ i j) i1 j1) 0)\n                                                 (<=(- i i1) 0)\n                                                 (<=(- j j1 n) 0)\n                                                 )))]\n                [(prs[[identity inc] [inc inc]])\n                 (fn [[i1 j1] n] (fn [[i j]] (and(<=(- i j (- i1 j1)) 0)\n                                                 (>=(- i i1) 0)\n                                                 (<=(- j j1 n) 0)\n                                                 )))]\n                [(prs[[dec dec] [dec identity] [dec inc]])\n                 (fn [[i1 j1] n] (fn [[i j]] (and(<=(- i j (- i1 j1)) 0)\n                                                 (<=(-(+ i j) i1 j1) 0)\n                                                 (>=(- i (- i1 n)) 0)\n                                                 )))]\n                [(prs[[dec inc] [identity inc] [inc inc]])\n                 (fn [[i1 j1] n] (fn [[i j]] (and(<=(- i j (- i1 j1)) 0)\n                                                 (>=(-(+ i j) i1 j1) 0)\n                                                 (<=(- j (+ j1 n)) 0)\n                                                 )))]\n                ;So we can add any search pattern here. I've created only needed by test cases at 4cljr\n                ]\n         rslt (->> ptrns\n                   (mapcat (fn[p] (->> stab \n                                       (filter (first p))\n                                       (map #(vector(peek p) %))\n                                       )))\n                   (mapcat (fn[v] (->>(for [r (range 1 (inc rank))] r)\n                                      (map (fn [r] ((first v) (peek v) r)))\n                                      )))\n                   (map (fn [tr] (filter tr estab)))\n                   (filter #(every? (fn [x](let [i (first x) j (peek x)] (and (>= i 0)(>= j 0)(< i rows)(< j cols)(= 1 (get-in m [i j])))))%))\n                   (map count)\n                   )\n         ]\n          (when (not(empty? rslt))(reduce max rslt))\n\n      \n     )\n   )","problem":127,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":127,"code":"(fn [levels]\n  (let [len (inc (quot (Math/log (apply max levels)) (Math/log 2)))\n        lmax (Math/pow 2 len)\n        left (fn [mask]\n               (when (< mask lmax)\n                 (bit-or mask (bit-shift-left mask 1))))\n        right (fn [mask]\n                (when (even? mask)\n                  (bit-or mask (bit-shift-right mask 1))))\n        symm (fn [mask]\n               (let [l (left mask)\n                     r (right mask)]\n                 (when (and l r)\n                   (bit-or mask l r))))\n        rotate (fn [levels]\n                 (map #(reduce (fn [acc bit]\n                                 (if (true? bit)\n                                   (bit-or 1 (bit-shift-left acc 1))\n                                   (bit-shift-left acc 1)))\n                               0 %1)\n                      (for [x (range 0 len)]\n                        (for [y (range 0 (count levels))]\n                          (bit-test (levels y) x)))))\n        dispatch {:left  [left 1]\n                  :symm  [symm 2]\n                  :right [right 1]}\n        crank (fn [[x & xs] mask d acc itype]\n                (if (or (nil? x) (nil? mask))\n                  (reduce + acc)\n                  (if (= (bit-and x mask) mask)\n                    (let [[f d'] (dispatch itype)\n                          mask' (f mask)]\n                      (recur xs mask' d' (conj acc (+ (last acc) d)) itype))\n                    (reduce + acc))))]\n    (let [best (apply max\n                      (concat\n                       (for [x (range 0 len)\n                             y (range 0 (count levels))\n                             z [:left :right :symm]]\n                         (crank (drop y levels) (bit-shift-left 1 x) 1 [0] z))\n                       (for [x (range 0 len)\n                             y (range 0 (count levels))\n                             z [:left :right :symm]]\n                         (crank (drop y (reverse levels)) (bit-shift-left 1 x) 1 [0] z))\n                       (for [x (range 0 len)\n                             y (range 0 (count levels))\n                             z [:left :right :symm]]\n                         (crank (drop y (reverse (rotate levels))) (bit-shift-left 1 x) 1 [0] z))\n                       (for [x (range 0 len)\n                             y (range 0 (count levels))\n                             z [:left :right :symm]]\n                         (crank (drop y (rotate levels)) (bit-shift-left 1 x) 1 [0] z))))]\n      (when (>= best 3) best))))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn love-triangle [xs]\n  (let [\n        decode-bitmap (fn [xs]\n                        (let [bitmap (map  #(Integer/toBinaryString %) xs)\n                              len (apply max (map count bitmap))]\n                          (map #(concat\n                             (take (- len (count %)) (repeat \\0)) %)\n                           bitmap)))\n        bitmap (decode-bitmap xs)\n        height (count bitmap)\n        width (count (first bitmap))\n        dirs [[0 1 1 1] [-1 1 0 1] [-1 -1 -1 0] [-1 0 -1 1]\n              [-1 -1 1 -1] [-1 1 1 1] [1 -1 1 1] [-1 -1 -1 1]]\n        pos (fn [bmp x y] (nth (nth bmp y '()) x \\0))\n        all-is-1 (fn [bmp x1 y1 x2 y2]\n                   (if (= x1 x2)\n                     (every? #(= \\1 (pos bmp x1 %)) (range y1 (inc y2)))\n                     (every? #(= \\1 (pos bmp % y1)) (range x1 (inc x2)))\n                     ))\n        doit (fn doit [bmp x1 y1 x2 y2 [dx1 dy1 dx2 dy2 :as dir]]\n               (do (println x1 y1 x2 y2 dir)\n               (if (all-is-1 bmp x1 y1 x2 y2)\n                 (+ 1 (- x2 x1) (- y2 y1)\n                    (doit bmp (+ x1 dx1) (+ y1 dy1)\n                          (+ x2 dx2) (+ y2 dy2) dir))\n                 0)))\n        max-int (fn [bitmap x y]\n                  (apply max (map (fn [[dx1 dy1 dx2 dy2 :as dir]]\n                                    (doit\n                                     bitmap\n                                     (+ x dx1) (+ y dy1)\n                                     (+ x dx2) (+ y dy2)\n                                     dir))\n                                  dirs)))\n        res (apply max (for\n                       [x (range width) y (range height)\n                        :when (= (pos bitmap x y) \\1)] (max-int bitmap x y)))]\n    (if (zero? res) nil (inc res))))","problem":127,"user":"4f0e995e535d0136e6c22326"},{"problem":127,"code":"(fn [m]\n  (let [L (mapv (fn [i] (Integer/toBinaryString i)) m)\n        l (apply max (map count L))\n        M (mapv (fn [i] (vec (concat (repeat (- l (count i)) \\0) i))) L)\n        rotate (fn [M] (mapv (comp vec reverse) (apply map vector M)))\n        born (fn [v] (mapcat identity (keep-indexed (fn [i t] (if (= \\1 t) [[:L i 1 1] [:V i 1 1]])) v)))\n\n        grow (fn [T v]\n               (concat (born v)\n                       (keep (fn [[t p s a]]\n                               (let [[i w] (if (= t :L) [p (+ 1 s)] [(dec p) (+ 2 s)])]\n                                 (if (and (<= 0 i) (= (repeat w \\1) (take w (drop i v))))\n                                   [t i w (+ a w)]))) T)))\n\n        R (fn R [T V] (concat T (if-not (empty? V) (R (grow T (first V)) (rest V)))))\n        m (apply max (map (fn [t] (t 3)) (mapcat (partial R []) (take 4 (iterate rotate M)))))]\n    (if (< 2 m) m)))","user":"55f6fe09e4b06e875b46cea2"},{"problem":127,"code":"(fn tris \n  ([nums]\n    ; bm is a seq of strings of nums in binary [7 3] -> (\"00111\" \"00011\")\n    ; try to find a topmost vertex in every row\n    (let [wall (map (partial clojure.pprint/cl-format nil \"~v,'0B\" 5) nums)\n          transpose #(apply map str %)\n          reverse #(map (comp (partial apply str) reverse) %)\n          area (apply max (for [f [identity transpose reverse (comp transpose reverse)]\n                                :let [awall (f wall)]]\n                            (loop [bm awall acc 0]\n                              (if (empty? bm) acc\n                                  (recur (rest bm) (max (tris bm 1) acc))))))]\n      (if (> area 1) area)))\n  ([[f & r :as l] w]\n    (cond (empty? l) 0\n         ; shear rock vertically at each 1\n          (zero? w) 0\n          (= w 1) (apply max (cons 0\n                                   (for [shearidx (keep-indexed #(if (= %2 \\1) %1) f)\n                                         :let [sheared (map #(subs % shearidx) r)]]\n                                     (+ 1 (tris sheared 2)))))\n         ; look for 'w' 1's at beginning of row\n          (re-matches (re-pattern (str \"1{\" w \"}.*\")) f) (max (+ w (tris r (inc w)))\n                                                              (let [reflect (apply + (range w))]\n                                                                (+ w (if (= reflect (tris r (dec w))) \n                                                                       reflect\n                                                                       0))))\n          :else 0)))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn [scan]\n  (let [h (count scan)\n        w (loop [i 1 n 0]\n            (if (every? (partial > i) scan) n (recur (* i 2) (inc n))))\n        pow (fn [x y]\n              (loop [v x r 1 i y]\n                (cond (= i 0) r\n                      (odd? i) (recur (* v v) (* r v) (quot i 2))\n                      true (recur (* v v) r (quot i 2)))))\n        tri-se (fn [n] (take n (iterate #(inc (* 2 %)) 1)))\n        tri-ne (comp reverse tri-se)\n        tri-nw (fn [n] (let [se (tri-se n)\n                             m (last se)]\n                         (cons m (map #(- m %) (butlast se)))))\n        tri-sw (comp reverse tri-nw)\n        tri-e (fn [n] (concat (tri-sw n) (rest (tri-nw n))))\n        tri-w (fn [n] (concat (tri-se n) (rest (tri-ne n))))\n        tri-n (fn [n] (map bit-or\n                           (map #(* (pow 2 (dec n)) %) (tri-se n))\n                           (tri-sw n)))\n        tri-s (comp reverse tri-n)\n        size-diag (fn [n] (quot (* n (inc n)) 2))\n        size-orth (fn [n] (* n n))\n        best-diag (some #(do %)\n                        (for [sz (reverse (map #(+ 2 %) (range (dec (min h w)))))\n                              shape [tri-se tri-ne tri-nw tri-sw]\n                              :let [basemask (shape sz)]\n                              x (range (inc (- w sz)))\n                              :let [p (pow 2 x) mask (map #(* p %) basemask)]\n                              y (range (inc (- h sz)))]\n                          (when (every? true? (map #(= (bit-and %1 %2) %1)\n                                                   mask\n                                                   (take sz (drop y scan))))\n                            (size-diag sz))))\n        best-orth (some #(do %)\n                        (for [sz (reverse (map #(+ 2 %) (range (dec (min h w)))))\n                              shape [tri-s tri-e tri-n tri-w]\n                              :let [basemask (shape sz) mh (count basemask)]\n                              x (range (inc (- w sz)))\n                              :let [p (pow 2 x) mask (map #(* p %) basemask)]\n                              y (range (inc (- h mh)))]\n                          (when (every? true? (map #(= (bit-and %1 %2) %1)\n                                                   mask\n                                                   (take mh (drop y scan))))\n                            (size-orth sz))))]\n\n    (if best-diag\n      (if best-orth\n        (max best-diag best-orth)\n        best-diag)\n      best-orth)))","problem":127,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn ltr [t]\n  (let [to-binary (fn [t l]\n                    (vec\n                      (for [r t]\n                        (->>\n                          (seq (Integer/toString r 2))\n                          (iterate #(cons \\0 %))\n                          (drop-while #(< (count %) l))\n                          first\n                          vec))))\n        mineral-in-dir (fn [rock a d s growth]\n                        (let [draw-line (fn [p slope length]\n                                          (loop [p p, l length, line #{p}]\n                                            (if (zero? l)\n                                              line\n                                              (recur (map + p slope) (dec l) (conj line p)))))]\n                          (loop [a a, l 1, mineral #{a}]\n                            (let [new-side (draw-line a s l)]\n                              (if (every? #(= \\1 (get-in rock %)) new-side)\n                                (recur (map + a d) (+ l growth) (into mineral new-side))\n                                (count mineral))))))\n        extract-mineral (fn [rock p]\n                       (apply max\n                         (map\n                           (fn [[d s g]] (mineral-in-dir rock p d s g))\n                           [ [[1 0] [-1 1] 1], [[-1 0] [1 -1] 1], [[-1 0] [1 1] 1], [[1 0] [-1 -1] 1],\n                             [[-1 -1] [0 1] 2], [[1 1] [0 -1] 2], [[-1 -1] [1 0] 2], [[1 1] [-1 0] 2] ]\n                            )))]\n  (let [cols (count (Integer/toString (apply max t) 2))\n        mineral-max-size\n          (apply max\n            (for [y (range (count t)) x (range cols)]\n              (extract-mineral (to-binary t cols) [y x])))]\n    (when (>= mineral-max-size 3) mineral-max-size))))","problem":127,"user":"504c8165e4b09724c857af31"},{"problem":127,"code":"(fn [args]\n  (let [v+ (partial map +)\n        field (mapv #(->> % Integer/toBinaryString reverse (mapv str) (mapv read-string)) args)\n        square #(* %2 (/ (+ 2 (* (dec %2) (dec (count %1)))) 2))\n        iter (fn [steps agg coor]\n               (->> steps (map #(get agg (v+ coor %) 0)) (#(apply min %)) inc (assoc agg coor)))\n        get-local-max (fn [coords steps]\n                        (->> coords (filter #(not= 0 (get-in field % 0))) (reduce (partial iter steps) {}) vals (apply max) (square steps)))\n        [r-count c-count] [(count args) (apply max (map count field))]]\n    (apply (comp #(if (< 1 %) %) max)\n      (mapcat (fn [[a b c]]\n                (map (partial get-local-max c) [a b]))\n              [[[[-1 0] [0 1]] [[-1 1] [0 1] [1 1]] (for [c (range (dec c-count) -1 -1) r (range r-count)] [r c])]\n               [[[1 0] [0 1]] [[1 -1] [1 0] [1 1]] (for [r (range (dec r-count) -1 -1) c (range (dec c-count) -1 -1)] [r c])]\n               [[[0 -1] [1 0]] [[-1 -1] [0 -1] [1 -1]] (for [c (range c-count) r (range (dec r-count) -1 -1)] [r c])]\n               [[[-1 0] [0 -1]] [[-1 -1] [-1 0] [-1 1]] (for [r (range r-count) c (range c-count)] [r c])]]))))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [field]\n  (let [rows (map #(Long/toBinaryString %) field)\n        max-count (apply max (map count rows))\n        field (map #(concat (repeat (- max-count (count %)) \\0) (seq %)) rows)\n        indexed-field (map-indexed (fn [i line]\n                                     (map-indexed (fn [j itm] [itm [i j]]) line))\n                                   field)\n        candidates (mapcat (fn [line]\n                             (filter #(= (ffirst %) \\1) (partition-by first line)))\n                           indexed-field)\n        all-candidates (mapcat (fn [candidate]\n                                 (mapcat (fn [len]\n                                           (partition len 1 candidate))\n                                         (range (count candidate) 1 -1)))\n                               candidates)]\n    (letfn [(contains-range? [[[row col0] [_ col1]] line]\n              (let [[_ [line-row st-col]] (first line) [_ [_ fi-col]] (last line)]\n                (and (= row line-row)\n                     (<= st-col col0)\n                     (>= fi-col col1))))\n            (line-len [[[_ st] [_ fi]]]\n              (inc (- fi st)))\n            (line-ok? [[[row col0] [_ col1] :as pair]]\n              (and\n               (>= row 0)\n               (< row (count rows))\n               (> (line-len pair) 0)\n               (some (partial contains-range? pair) candidates)))\n            (take-next [row-fn col0-fn col1-fn [[row col0] [_ col1]]]\n              [[(row-fn row) (col0-fn col0)] [(row-fn row) (col1-fn col1)]])\n            (search-tri [row-fn col0-fn col1-fn pair]\n              (let [f (take-while line-ok? (iterate #(take-next row-fn col0-fn col1-fn %) pair))]\n                (when (= (line-len (last f)) 1) f)))\n            (tri-size [tri]\n              (apply + (map line-len tri)))]\n      (let [triangles (mapcat\n                       #(let [[_ p0] (first %) [_ p1] (last %) pair [p0 p1]\n                              triangles [(distinct (concat\n                                                    (search-tri inc identity dec pair)\n                                                    (search-tri dec identity dec pair)))\n                                         (distinct (concat\n                                                    (search-tri inc inc identity pair)\n                                                    (search-tri dec inc identity pair)))\n                                         (search-tri inc inc dec pair)\n                                         (search-tri dec inc dec pair)]]\n                          (filter seq triangles))\n                       (filter second all-candidates))]\n        (when (seq triangles) (apply max (map tri-size triangles)))))))","problem":127,"user":"5003ee7de4b0678c553fc446"},{"problem":127,"code":"(fn love-triangle [nums]\n  (let [bin-nums (map #(Integer/toBinaryString %) nums)\n        size-y (count bin-nums)\n        size-x (apply max (map count bin-nums))\n        field (mapv #(str (apply str (repeat (- size-x (count %)) \\0)) %) bin-nums)\n\n        gen-sq-triangle (fn [side] (vec (for [i (range 1 (inc side))]\n                                     (vec\n                                       (concat (repeat i \\1)\n                                             (repeat (- side i) \\0))))))\n        gen-med-triangle (fn [side] (vec (for [i (range 1 (inc side) 2)\n                                          :let [align (/ (- side i) 2)]]\n                                      (vec\n                                        (concat (repeat align \\0)\n                                             (repeat i \\1)\n                                             (repeat align \\0))))))\n        rotate (fn [triangle] (apply mapv vector (reverse triangle)))\n\n        gen-trs (fn [side]\n                  (if (odd? side)\n                    [(gen-sq-triangle side) (gen-med-triangle side)]\n                    [(gen-sq-triangle side)]))\n        gen-all-trs (fn [side]\n                      (->> (gen-trs side)\n                           (mapcat #(take 4 (iterate rotate %)))))\n\n        try-to-fit (fn [pos-x pos-y triangle]\n                     (let [matches (for [y (range (count triangle))\n                                         x (range (count (first triangle)))\n                                         :let [tr-val (get-in triangle [y x])]\n                                         :when (= tr-val \\1)\n                                         :let [f-val (get-in field [(+ y pos-y) (+ x pos-x)])]]\n                                     (if (not= f-val tr-val) false true))]\n                       (if (every? true? matches) (count matches) nil)))\n        try-to-fit-in-field (fn [triangle]\n                              (->> (for [y (range size-y)\n                                         x (range size-x)\n                                         :let [res (try-to-fit x y triangle)]] res)\n                                   (filter (complement nil?))\n                                   (first)))\n        ]\n    (let [res (->> (range 2 (inc (max size-x size-y)))\n                   (mapcat gen-all-trs)\n                   (map try-to-fit-in-field)\n                   (filter (complement nil?)))]\n      (if (empty? res)\n        nil\n        (apply max res)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":127,"code":"(fn xmaxt [mm]\n  (letfn  \n    [(maxtrc [m h w r c]\n      (letfn [\n              (rat [side]\n                (if (or (> (+ side c) w) (> (+ side r) h))\n                  0\n                  (loop [y r l side tot 0]\n                    (cond \n                      (zero? l) tot\n                      (< (apply + (subvec (vec (get m y)) c (+ c l))) l) 0\n                      :else (recur (inc y) (dec l) (+ tot l))))))\n              (ist [height] \n                (let [base (dec (* height 2))]\n                  (if (or (> (+ base c) w) (> (+ height r) h))\n                    0\n                    (loop [y r x c l base tot 0]\n                      (cond \n                        (neg? l) tot\n                        (< (apply + (subvec (vec (get m y)) x (+ x l))) l) 0\n                        :else (recur (inc y) (inc x) (- l 2) (+ tot l)))))))\n              (t [dim]\n                (max (rat dim) (ist dim)))]\n        (loop [ss 2 mx 0]\n          (let [v (t ss)]\n            (if (zero? v)\n              mx\n              (recur (inc ss) v))))))\n                \n     (maxt [[r1 & rs :as m]]\n      (let [w (count r1) h (count m)]\n        (apply max (for [r (range (dec h)) c (range (dec w))] (maxtrc (vec m) h w r c)))))  ] \n\n  (let [m (vec (map #(map (comp read-string str) (vec (clojure.pprint/cl-format nil \"~5,'0B\" %))) mm))\n       rm (vec (apply map list m))]\n    (let [rv (apply max (map maxt [m (reverse m) (map reverse m) (reverse (map reverse m)) rm (reverse rm) (map reverse rm) (reverse (map reverse rm))])) ]\n      (if (zero? rv) nil rv)))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn triangle [bits]                                                                                              \n  (let [width (count (for [x (iterate #(quot % 2) (apply max bits)) :while (> x 0)] x))                            \n        height (count bits)                                                                                        \n        dirs [+ -]                                                                                                 \n        dirs-yx (for [x dirs y dirs] [y x])                                                                        \n        bits-matrix (vec (map (fn [bit] (vec (map #(bit-test bit %) (range width)))) bits))                        \n        t (println bits-matrix)                                                                                    \n        bits-transpose (vec (for [x (range width)] (vec (for [y (range height)] (get-in bits-matrix [y x])))))     \n        t-area #(/ (* (inc %) %) 2)                                                                                \n        largest-side (fn [[y x] matrix [dir-y dir-x]]                                                              \n                       (let [a (last (for [dy (range)                                                              \n                             :let [ny (dir-y y dy)                                                                 \n                                   size (inc dy)                                                                   \n                                   all-mineral? (every?                                                            \n                                                  #(get-in matrix [ny (dir-x x %)] false)                          \n                                                  (range size))]                                                   \n                             :while all-mineral?] size))]                                                          \n                         (if (nil? a) 0 a)))                                                                               largest-triangle-down (fn [[y x] matrix dir-y]                                                             \n                           (let [lr (map #(largest-side [y x] matrix [dir-y %]) dirs)                              \n                                 max-size (apply max lr)                                                           \n                                 min-size (apply min lr)]                                                          \n                             (max (t-area max-size)                                                                \n                                  (+ (* 2 (t-area (dec min-size))) min-size))))                                    \n        largest-triangle (fn [[y x] matrix]                                                                        \n                           (apply max (map #(largest-triangle-down [y x] matrix %) dirs)))                         \n        largest-on-map (fn [matrix]                                                                                \n                         (let [width (count (first matrix))                                                        \n                               height (count matrix)]                                                              \n                           (apply max (for [x (range width) y (range height)]                                      \n                             (largest-triangle [y x] matrix)))))                                                   \n        a (max (largest-on-map bits-matrix) (largest-on-map bits-transpose))]                                      \n    (if (= a 1)                                                                                                    \n      nil                                                                                                          \n      a)))","problem":127,"user":"51899891e4b0288ada3dbdab"},{"problem":127,"code":"(fn mineral_triangle [xs]\n    (let\n        [\n            d [-1 0 1]\n            dirs (for [ r d c d :when (not= r c 0)] [r c])\n            rotate (fn [x y] [(- y) x])\n            orientations (map #(conj [] % (apply rotate %)) dirs)\n            max_val (apply max xs)\n            nrows (count xs) ncols (if (zero? max_val) 1 (-> max_val (Math/log) (/ (Math/log 2)) (Math/floor) (int) (inc)))\n            max_size (max nrows ncols)\n            inbounds? (fn [r c] (every? true? [(>= r 0) (>= c 0) (< r nrows) (< c ncols)]))\n            has_bit? (fn [r c] (and (inbounds? r c) (> (bit-and (get xs r 0) (bit-shift-left 1 (- ncols c 1)) ) 0) ) )\n            is_vertical_line_filled?\n                (fn [col [r1 r2]]\n                    (let\n                        [\n                            [r1 r2] (sort [r1 r2])\n                        ]\n                        (every? (fn [r] (has_bit? r col)) (range r1 (inc r2)))\n                    )\n                )\n            get_isosceles_triangle\n                (fn [[r c] orientation size]\n                    (into [[r c]] (map (fn [dir] (into [] (map #(+ %1 (* %2 size)) [r c] dir ) ) ) orientation))\n                )\n            get_vertical_intersection\n                (fn [col segments]\n                    (let\n                        [\n                            has_col_coord?\n                                (fn [c [[r1 c1] [r2 c2]]]\n                                    (let\n                                        [\n                                            [c1 c2] (sort [c1 c2])\n                                        ]\n                                        (and (>= c c1) (<= c c2))\n                                    )\n                                )\n                            row_intercept\n                                (fn [c [[r1 c1] [r2 c2]]]\n                                    (if (= c1 c2)\n                                        (throw (Exception. \"line segment is vertical; multiple row intercepts\"))\n                                        (let [slope (/ (- r2 r1) (- c2 c1))]\n                                            (+ (* slope (- c c1)) r1)\n                                        )\n                                    )\n                                )\n                            relevant_segments (filter #(has_col_coord? col %) segments)\n                            ret\n                                (let\n                                    [\n                                        filt (fn [[[r1 c1] [r2 c2]]] (if (= c1 c2) [[r1 c1] [r2 c2]] false))\n                                        [[r1 c1] [r2 c2]] (some filt relevant_segments)\n                                        row_coords\n                                            (if (or (= r1 nil) (= r2 nil))\n                                                (vec (set (map #(row_intercept col %) relevant_segments)))\n                                                [r1 r2]\n                                            )\n                                    ]\n                                    (if (= (count row_coords) 1)\n                                        (conj row_coords (first row_coords))\n                                        row_coords\n                                    )\n                                )\n                        ]\n                        (sort ret)\n                    )\n                )\n            is_triangle_filled?\n                (fn [pts segments]\n                    (let\n                        [\n                            pts (sort-by second pts)\n                        ]\n                        (every?\n                            (fn [c] (is_vertical_line_filled? c (get_vertical_intersection c segments)))\n                            (range (-> pts (first) (second)) (-> pts (last) (second) (inc)))\n                        )\n                    )\n                )\n            has_triangle?\n                (fn [[r c] orientation size]\n                    (let\n                        [\n                            pts (get_isosceles_triangle [r c] orientation size)\n                            segments (into [] (map #(conj [] %1 %2) pts (conj (vec (rest pts)) (first pts))))\n                        ]\n                        (is_triangle_filled? pts segments)\n                    )\n                )\n            possible_triangles\n                (filter #(apply has_triangle? %) (for\n                    [\n                        r (range nrows)\n                        c (range ncols)\n                        orientation orientations\n                        size (range 1 max_size)\n                    ]\n                    [[r c] orientation size]\n                ))\n            size_to_area\n                (fn [orientation size]\n                    (let [ size (inc size) ]\n                        (if (some #{0} (flatten orientation))\n                            (/ (* size (inc size)) 2)\n                            (* size size)\n                        )\n                    )\n                )\n            triangle_areas (map (fn [[[r c] orientation size]] (size_to_area orientation size)) possible_triangles)\n            ret (if (empty? triangle_areas) nil (apply max triangle_areas))\n        ]\n        ret\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":";; main\r\n(fn [q c n]\r\n  (#({0 nil} % %)\r\n   (apply max\r\n     (for [\r\n           ; rotate\r\n           m (take 4 (iterate q (map #(subs (Long/toBinaryString (+ 64 %)) 1) n)))\r\n           ; slice horizontal\r\n           h (map drop (range) (repeat (- (count m) 1) m))\r\n           ; slice vertical\r\n           v (map #(map (fn [r] (subs r %)) %2) (range) (repeat (count (nfirst h)) h))\r\n           ]\r\n       (c v)))))\r\n\r\n;; rotate 90 degrees\r\n#(reverse (apply map str %))\r\n\r\n;; cut out a triangle and count minerals\r\n(fn [m]\r\n  (let [w (count (take-while #{\\1} (first m)))\r\n        h (count m)]\r\n    (cond (< w 2) 0\r\n          (and (>= h w) (apply = \\1 (mapcat #(subs % 0 %2) m (range w 0 -1))))\r\n          ; 111\r\n          ; 110\r\n          ; 100\r\n            (* 1/2 w (+ w 1))\r\n          (and (odd? w) (> h (/ w 2))\r\n               (apply = \\1 (mapcat #(subs % %2 (- w %2)) m (range (/ w 2)))))\r\n          ; 111\r\n          ; 010\r\n          ; 000\r\n            (/ (+ (* w w) w w 1) 4)\r\n          :else 0)))","problem":127,"user":"4dce6e41535d5973398f92a2"},{"problem":127,"code":"(fn [mine]\n  (letfn [(mineral? [[x y]] (bit-test (nth mine x 0) y))\n          (sgn [n] (max (min n 1) -1))\n          (cw-45 [[x y]] (mapv sgn [(+ x y) (- y x)]))\n          (p-add [p1 p2] (mapv + p1 p2))\n          (line-filled [p1 p2 d]\n            (loop [n 0 p p1] \n              (when (mineral? p)\n                (if (= p p2) (inc n) (recur (inc n) (p-add p d))))))\n          (area-filled [p [leg1 leg2 hyp]]\n            (loop [n 0 p1 p p2 p]\n              (if-let [l (line-filled p1 p2 hyp)] \n                (recur (+ n l) (p-add p1 leg1) (p-add p2 leg2)) \n                n)))]\n    (let [row (count mine)\n          col (loop [x (apply max mine) n 0]\n                (if (zero? x) n (recur (quot x 2) (inc n))))\n          tri (take 8 (iterate #(map cw-45 %) '([-1 -1] [-1 1] [0 1])))\n          xs (for [x (range row) y (range col) t tri] (area-filled [x y] t))\n          mt (apply max xs)]\n      (when (> mt 1) mt))))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn [ns]\n    (letfn [(abs [n]\n              (Math/abs n))\n            (co-ords [grid]\n              (let [height (count grid)\n                    width (count (first grid))]\n                (for [y (range height)\n                      x (range width)\n                      ]\n                  [y x])))\n            \n            (pad [s length]\n              (let [s-length (count s)\n                    diff (- length s-length)]\n                (concat (take diff (repeat \\0))\n                        s)))\n\n            (to-binary [n]\n              (Integer/toBinaryString n))\n\n            (make-grid [ns]\n              (let [bins (map to-binary ns)\n                    width (apply max (map count bins))\n                    padded (map #(vec (pad % width)) bins)]\n                (vec padded)))\n            \n            (find-tris [grid]\n              (let [height (count grid)\n                    width (count (first grid))\n                    all (for [y (range height)\n                              x (range  width)]\n                          [y x])\n                    tris (filter (fn [tri]\n                                   (apply = (map #(get-in grid %) tri)))\n\n                                 (concat\n                                  (mapcat (fn [[y x]]\n                                            (apply concat\n                                                   (for [xop [>= <=]\n                                                         yop [>= <=]]\n                                                     (let [xmax  (if (= xop >=)\n                                                                   (- width (inc x))\n                                                                   x)\n                                                           ymax  (if (= yop >=)\n                                                                   (- height (inc  y))\n                                                                   y)]\n                                                       (for [i (range 1 (inc  (min ymax xmax)))]\n                                                         (filter (fn [[y' x']]\n                                                                   (and (yop y' y)\n                                                                        (xop x' x)\n                                                                        (<= (+ (abs (- y' y))\n                                                                               (abs (- x' x)))\n                                                                            i)))\n                                                                 all))))))\n                                          all)\n                                  (mapcat (fn [[y x]]\n                                            (apply concat\n                                                   (for [excluded [:up :down :left :right]]\n                                                     (let [up y\n                                                           down (- height (inc y))\n                                                           right (- width (inc x))\n                                                           left x\n                                                           min-distance (case excluded\n                                                                          :up (min down right left)\n                                                                          :down (min up right left)\n                                                                          :left (min up down right)\n                                                                          :right (min up down left))]\n                                                       (for [i (range 1 (inc min-distance))]\n                                                         (filter (fn [[y' x']]\n                                                                   (case excluded\n                                                                     :up (and (<= (- x i) x' (+ x i))\n                                                                              (>= y' y)\n                                                                              (<= (+ (abs (- y' y))\n                                                                                     (abs (- x' x) ))\n                                                                                  i))\n                                                                     :down (and (<= (- x i) x' (+ x i))\n                                                                                (<= y' y)\n                                                                                (<= (+ (abs (- y' y))\n                                                                                       (abs (- x' x) ))\n                                                                                    i))\n                                                                     :left (and (<= (- y i) y' (+ y i))\n                                                                                (>= x' x)\n                                                                                (<= (+ (abs (- y' y))\n                                                                                       (abs (- x' x) ))\n                                                                                    i))\n                                                                     :right (and (<= (- y i) y' (+ y i))\n                                                                                 (<= x' x)\n                                                                                 (<= (+ (abs (- y' y))\n                                                                                        (abs (- x' x) ))\n                                                                                     i))))\n                                                                 all))))))\n                                          all)))\n                    counts (map count tris)]\n                (if (empty? counts)\n                  nil\n                  (apply max counts))))\n\n\n            ]\n    (find-tris (make-grid ns))))","problem":127,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [rs]\n  (letfn [(stri-at [m [r & s]]\n            (if (and (pos? m) r (= (bit-and m r) m))\n              (let [mm (bit-and m (bit-shift-right m 1))]\n                (if (pos? mm)\n                  (#(if (pos? %) (+ (Integer/bitCount m) %) 0)\n                   (stri-at mm s))\n                  (Integer/bitCount m)))\n              0))\n          (tri-at [m [r & s]]\n            (if (and r (= (bit-and m r) m))\n              (+ (Integer/bitCount m)\n                 (max (tri-at (bit-or (+ m m) m) s)\n                      (stri-at (bit-and m (bit-shift-right m 1)) s)))\n              0))\n          (dtri-at [m [r & s]]\n            (if (and r (= (bit-and m r) m))\n              (+ (Integer/bitCount m)\n                 (if (bit-test m 0)\n                   0\n                   (dtri-at (bit-or (bit-or (+ m m) m) (bit-shift-right m 1)) s)))\n              0))\n          (tri [rs]\n            (if rs\n              (apply max (tri (next rs))\n                (map #(max (tri-at % rs) (dtri-at % rs)) [1 2 4 8]))\n              0))\n          (revrow [n] (bit-shift-right (Integer/reverse (+ n n)) 27))]\n    (#(if (> % 2) % nil)\n     (apply max (map tri [rs (map revrow rs)\n                          (reverse rs) (map revrow (reverse rs))])))))","problem":127,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn [ints] (letfn [\n(row-count [semi-rectangle] (count semi-rectangle))\n(column-count [semi-rectangle] (apply max (map count semi-rectangle)))\n(dimensions [semi-rectangle] ((juxt row-count column-count) semi-rectangle))\n(columns [rectangle] (apply map vector rectangle))\n(partitioned-row-count [rectangle n] (map (partial partition n 1) rectangle))\n(subsquares-of-size [rectangle subsquare-size] (mapcat (partial partition subsquare-size 1) (columns (partitioned-row-count rectangle subsquare-size))))\n(subsquares [rectangle] (map #(subsquares-of-size rectangle %) (range 2 (+ 1 (apply min (dimensions rectangle))))))\n(rotate-clockwise [rectangle] (map reverse (columns rectangle)))\n(make-top-left-triangle [n] (map #(concat (repeat % \\1) (repeat (- n %) \\-)) (reverse (range 1 (inc n)))))\n(triangles [n] (take 4 (iterate rotate-clockwise (make-top-left-triangle n))))\n(covers? [implicant term] (every? true? (map #(if (or (= \\- (first %)) (= (first %) (second %))) true false) (map vector implicant term))))\n(covers-many? [implicants terms] (every? true? (map covers? implicants terms)))\n(has-triangle? [square] (some true? (map #(covers-many? % square) (triangles (count square)))))\n(to-binary [n] (map #(Integer/parseInt %) (map str (Integer/toString n 2))))\n(left-pad-with-zeros [row length] (concat (repeat (- length (count row)) 0) row))\n(right-pad-with-zeros [row length] (concat row (repeat (- length (count row)) 0)))\n(pad-rectangle-with-zeros [rectangle] (let [max-length (apply max (map count rectangle))] (map #(left-pad-with-zeros % max-length) rectangle)))\n(make-bottom-left-triangle [n] (map #(concat (repeat % 1) (repeat (- n %) 0)) (range 1 (inc n))))\n(make-noncorner-triangle [n] (concat (make-bottom-left-triangle n) (drop 1 (rotate-clockwise (make-bottom-left-triangle n)))))\n(possible-square-triangle-dimensions [rectangle] (map #(vector % %) (reverse (range 2 (inc (apply min (dimensions rectangle)))))))\n(possible-horizontal-triangle-dimensions [rectangle] (map #(vector % (inc (quot % 2))) (filter odd? (reverse (range 2 (inc (first (dimensions rectangle))))))))\n(possible-vertical-triangle-dimensions [rectangle] (map #(vector (inc (quot % 2)) %) (filter odd? (reverse (range 2 (inc (second (dimensions rectangle))))))))\n(to-binary-rectangle [decimal-numbers] (let [binaries (map to-binary decimal-numbers), max-length (apply max (map count binaries))] (map #(left-pad-with-zeros % max-length) binaries)))\n(triangle-area [dimensions] (apply + (range 1 (inc (apply max dimensions)) (if (apply = dimensions) 1 2))))\n(possible-triangle-dimensions [rectangle] (sort-by triangle-area > (mapcat identity ((juxt possible-square-triangle-dimensions possible-horizontal-triangle-dimensions possible-vertical-triangle-dimensions) rectangle))))\n(subrectangles-of-dimensions [rectangle dimensions] (mapcat #(partition (first dimensions) 1 %) (columns (map #(partition (second dimensions) 1 %) rectangle))))\n(potential-triangle-containing-subrectangles [rectangle] (mapcat #(subrectangles-of-dimensions rectangle %) (possible-triangle-dimensions rectangle)))\n(row-count [rectangle] (count rectangle))\n(column-count [rectangle] (count (first rectangle)))\n(is-square? [rectangle] (= (row-count rectangle) (column-count rectangle)))\n(fits-in? [smaller-rectangle bigger-rectangle] (and (<= (row-count smaller-rectangle) (row-count bigger-rectangle)) (<= (column-count smaller-rectangle) (column-count bigger-rectangle))))\n(triangles-fitting-in [rectangle] (filter #(fits-in? % rectangle) (if (is-square? rectangle) (take 4 (iterate rotate-clockwise (make-bottom-left-triangle (row-count rectangle)))) (take 4 (iterate rotate-clockwise (make-noncorner-triangle (apply min (dimensions rectangle))))))))\n(map-rectangle [func rect] (map (partial map func) rect))\n(biggest-triangle-area [binary-rectangle] (first (map (comp triangle-area dimensions) (filter contains-some-triangle? (potential-triangle-containing-subrectangles binary-rectangle)))))\n(legal-dimensions-for-nonsquare-triangle [] (take 100 (map #(vector (+ 1 (* 2 (- % 1))) %) (drop 2 (range)))))\n(are-legal-dimensions-for-nonsquare-triangle? [dims] (true? (some #(= dims %) (mapcat #(vector % (reverse %)) (legal-dimensions-for-nonsquare-triangle)))))\n(triangles-fitting-in [rectangle] (filter #(fits-in? % rectangle) (if (is-square? rectangle) (take 4 (iterate rotate-clockwise (make-bottom-left-triangle (row-count rectangle)))) (if (are-legal-dimensions-for-nonsquare-triangle? (dimensions rectangle)) (make-noncorner-triangles-fitting-in rectangle)))))\n(make-noncorner-triangles-fitting-in [rectangle] (if (are-legal-dimensions-for-nonsquare-triangle? (dimensions rectangle)) (take 2 (iterate (comp rotate-clockwise rotate-clockwise) (if (> (row-count rectangle) (column-count rectangle)) (make-noncorner-triangle (column-count rectangle)) (rotate-clockwise (make-noncorner-triangle (row-count rectangle)))))) (throw (IllegalArgumentException. (apply str \"Illegal values for a noncorner triangle in make-noncorner-triangles-fitting-in: \" (row-count rectangle) \" row-count, \" (column-count rectangle) \" columns.\")))))\n(contains-triangle? [triangle-rectangle candidate-rectangle] (= triangle-rectangle (map #(map (partial reduce *) %) (map #(apply map vector %) (map vector triangle-rectangle candidate-rectangle)))))\n(contains-some-triangle? [candidate-rectangle] (not (empty? (filter #(contains-triangle? % candidate-rectangle) (triangles-fitting-in candidate-rectangle)))))\n] (biggest-triangle-area (to-binary-rectangle ints))))","problem":127,"user":"52f10094e4b05e3f0be25ee8"},{"code":"(letfn [(sgn\n         [x]\n         (max (min x 1) -1))\n        \n        (lg\n         [x]\n         (loop [log 1, x x]\n           (if (< x 2) log\n             (recur (inc log)\n                    (quot x 2)))))\n        \n        (lmax\n         [xs]\n         (let [[fst & r1] xs\n               [snd & r2] r1]\n           (cond\n            (empty? r1) fst\n            (nil? fst) (recur r1)\n            (nil? snd) (recur (cons fst r2))\n            :else (recur (cons (max fst snd) r2)))))]\n  \n  (fn dig [mine]\n    (let [size (count mine)\n          maxb (apply max (map lg mine))]\n      \n      (letfn [(mineral?\n               [[x y]]\n               (let [size (count mine)]\n                 (and (>= (min x y) 0)\n                      (< x size)\n                      (loop [i (mine x), j y]\n                        (if (zero? j)\n                          (odd? i)\n                          (recur (quot i 2)\n                                 (dec j)))))))\n              \n              (area\n               [corner [x y] width]\n               (let [left\n                     [(sgn (+ x y))\n                      (sgn (- y x))]\n                     \n                     right\n                     [(sgn (- x y))\n                      (sgn (+ x y))]\n                     \n                     points\n                     (for [i (range (inc width))\n                           j (range (inc i))\n                           :let [ij (- i j)]\n                           b (if (and (some zero? [x y])\n                                      (< i width))\n                               [0 1] [0])]\n                       (map + corner\n                            (map * [j j] left)\n                            (map * [ij ij] right)\n                            (map * [b b] [x y])))]\n                 (when (every? mineral? points)\n                   (count points))))]\n        \n        (lmax\n         (for [x (range size)\n               y (range maxb)\n               :when (mineral? [x y])\n               delta [[-1 0] [-1 1] [0 1] [-1 -1]\n                      [0 -1] [1 -1] [1 0] [1 1]]]\n           (loop [result nil, width 1]\n             (if-let [a (area [x y] delta width)]\n               (recur a (inc width))\n               result))))))))","problem":127,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":127,"code":"(fn f [inp]\n   (let [to-bin-str (fn [n] (Integer/toBinaryString n))\n         max-bits-in-coll (fn [coll]\n                            (->> coll (map (comp count to-bin-str)) (apply max)))\n         board-size (fn [strings]\n                      [(count strings), (-> strings first count)])\n         as-bit-strings (fn [coll]\n                          (let [mb (max-bits-in-coll coll)]\n                            (->> coll\n                                 (mapv (fn [n]\n                                         (let [as-bin (to-bin-str n)\n                                               num-zeros (- mb (count as-bin))]\n                                           (apply str (concat (repeat num-zeros \\0)\n                                                              as-bin))))))))\n         bd (as-bit-strings inp)\n         [nr nc] (board-size bd)\n         top-left-triangle-edge (fn [[r c] delta]\n                                  (for [cursor (range 0 (inc delta))]\n                                    [(- (+ cursor r) delta)\n                                     (+ c cursor)]))\n         bottom-left-triangle-edge (fn [[r c] delta]\n                                     (for [cursor (range 0 (inc delta))]\n                                       [(- (+ delta r) cursor)\n                                        (+ c cursor)]))\n         top-right-triangle-edge (fn [[r c] delta]\n                                   (for [cursor (range 0 (inc delta))]\n                                     [(- (+ cursor r) delta)\n                                      (- c cursor)]))\n         bottom-right-triangle-edge (fn [[r c] delta]\n                                      (for [cursor (range 0 (inc delta))]\n                                        [(- (+ delta r) cursor)\n                                         (- c cursor)]))\n         east-double-triangle-edge (fn [[r c] delta]\n                                     (for [cursor (range (- delta)\n                                                         (inc delta))]\n                                       [(+ r cursor)\n                                        (+ c delta)]))\n         west-double-triangle-edge (fn [[r c] delta]\n                                     (for [cursor (range (- delta)\n                                                         (inc delta))]\n                                       [(+ r cursor)\n                                        (- c delta)]))\n         north-double-triangle-edge (fn [[r c] delta]\n                                      (for [cursor (range (- delta)\n                                                          (inc delta))]\n                                        [(- r delta)\n                                         (+ c cursor)]))\n         south-double-triangle-edge (fn [[r c] delta]\n                                      (for [cursor (range (- delta)\n                                                          (inc delta))]\n                                        [(+ r delta)\n                                         (+ c cursor)]))\n         good-edge (fn [edge-points]\n                     (every? #(= \\1 (get-in bd %)) edge-points))\n         best-score-for-triangles-at-point\n         (fn [[r c]]\n           (reduce max\n                   (for [f [top-left-triangle-edge\n                            bottom-left-triangle-edge\n                            top-right-triangle-edge\n                            bottom-right-triangle-edge\n                            east-double-triangle-edge\n                            west-double-triangle-edge\n                            north-double-triangle-edge\n                            south-double-triangle-edge]]\n                     (->> (range)\n                          (map (partial f [r c]))\n                          (take-while good-edge)\n                          (map count)\n                          (reduce +)))))]\n     (let [ans\n           (reduce max\n                   (for [r (range nr)\n                         c (range nc)]\n                     (best-score-for-triangles-at-point [r c])))]\n       (when (>= ans 3) ans))))","user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn [bm]\n  (let\n      [maxdim 5\n      image (vec (map\n        (fn [n]\n          (vec (reverse (map #(Character/digit % 2)\n            (Integer/toString n 2)))))\n        bm))\n       match? (fn [triangle image]\n         (every? #(= % 1) (map #(get-in image % 0) triangle)))\n       quarter-tri (fn [n t]\n         (let [c (dec n)]\n           (for [i (range n)\n                 j (range (inc (* 2 i)))]\n             (t [i (+ (- c i) j)]))))\n       half-tri (fn [n t]\n         (for [i (range n)\n               j (range (inc i))]\n           (t [i j])))\n       rotate (fn [[x y]] [(- maxdim 1 y) x])\n       transformer (fn [r dx dy]\n         (fn [[x y]]\n           (r [(+ x dx) (+ y dy)])))\n       all-triangles (fn [t n]\n         (for [r (take 4 (iterate #(comp rotate %) identity))\n               x (range (inc (- maxdim n)))\n               y (range (inc (- maxdim n)))]\n           (t n (transformer r x y))))\n       area-and-triangles-largest-to-smallest (mapcat\n         (fn [[area n type]]\n           (map (fn [triangle] [area triangle])\n                  (all-triangles type n)))\n         (sort-by first >\n           (concat (map (fn [n] [(* n n) n quarter-tri])\n                        (range 2 4))\n                   (map (fn [n] [(/ (* n (+ n 1)) 2) n half-tri])\n                        (range 2 7)))))\n      ]\n    (some (fn [[area triangle]] (when (match? triangle image) area))\n      area-and-triangles-largest-to-smallest)))","problem":127,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":127,"code":"(fn print-triangles [xs]\n  (let [\n\n        to-bits (fn [n]\n          (->>\n           (take-while #(<= (bit-shift-left 1 %) n) (range))\n           (map #(bit-test n %))\n           (map #(if % 1 0))))\n\n        convert (fn [xs]\n          (let [w (->> (take-while #(< (bit-shift-left 1 %) (apply max xs)) (range)) last inc)]\n            (vec (map #(->> (take w (concat (to-bits %) (repeat 0))) reverse vec) xs))))\n\n        m (convert xs)\n        \n        v 1\n        \n        tr (fn [m s l [x1 x2 y transpose]]\n             (->>\n              (take l (iterate (fn [a] (map #(%1 %2) [x1 x2 y] a)) s))\n              (mapcat (fn [[x1 x2 y]] (map vector (range x1 (inc x2)) (repeat y))))\n              (map transpose)\n              (map #(get-in m %))))\n\n        answer (->> \n                (for [l [(inc (count m))] x (range l) y (range l) s (range l)\n                      fx1 [dec identity]\n                      fx2 [inc identity]\n                      fy [inc dec]\n                      t [identity reverse] :when (not= fx1 fx2)]\n                  (count\n                   (let [i (tr m [x x y] s [fx1 fx2 fy t])]\n                     (if (= [v] (distinct i))\n                       i []))))\n                (apply max)\n                )\n        ]\n    \n    (when (< 1 answer) answer)\n    \n    ))","user":"4ddb696b535d02782fcbe9fa"},{"problem":127,"code":"(fn [t] \n   (let [t1 (mapv #(Integer/toString % 2) t)\n         length (apply max (map count t1))\n         height (count t1)\n         t2 (mapv #(vec (format (str \"%0\" length \"d\") (read-string %))) t1)\n         n (min length height)\n         tr1 (for [y (range n) x (range n) :when (>= y x)] [y x])\n        \n         \n         r-tr1 (loop [m n]\n                 (let [r (for [ys (range (inc (- height m))) xs (range (inc (- length m)))]\n                           (map #(get-in t2 (mapv + [ys xs] %)) (take (/ (* (inc m)m) 2) tr1))) rr ((set(map set r))#{\\1})]\n                   (cond rr (count (first r))\n                         (= m 1) 0 :else (recur (dec m)))))\n         r-tr2 (loop [m n]\n                 (let [r (for [ys (range (inc (- height m))) xs (range (inc (- length m)))]\n                           (map #(get-in t2 (mapv + [ys xs] [(first %) (- (dec m) (second %))])) (take (/ (* (inc m)m) 2) tr1))) rr ((set(map set r))#{\\1})]\n\n(cond rr (count (first r))\n                         (= m 1) 0 :else (recur (dec m)))))\n\n         r-tr3 (loop [m (if (odd? length) length (dec length))]\n                 (let [tr3 (loop [x (range m) y 0 r []] (if (empty? x)r (recur (butlast (drop 1 x)) (inc y) (concat r (map vector (repeat y) x)))))\nr (for [ys (range (inc (- height (/ (inc m) 2)))) xs (range (inc (- length m)))]\n                           (map #(get-in t2 (mapv + [ys xs] %)) tr3)) rr ((set(map set r))#{\\1})]\n\n\n(cond rr (count (first r))\n                         (= m 1) 0 :else (recur (- m 2)))))\n         r-tr4 (loop [m (if (odd? height) height (dec height))]\n                 (let [tr4 (loop [y (range m) x (/ (dec m) 2) r []] (if (empty? y)r (recur (butlast (drop 1 y)) (dec x) (concat r (map vector y (repeat x) )))))\n                       r (for [ys (range (inc (- height m))) xs (range (inc (- length (/ (inc m) 2))))]\n                           (map #(get-in t2 (mapv + [ys xs] %)) tr4)) rr ((set(map set r))#{\\1})]\n                  \n                   (cond rr (count (first r))\n                         (= m 1) 0 :else (recur (- m 2))))) \nrr (max r-tr1 r-tr2 r-tr3 r-tr4)]\n(if (< rr 2) nil rr)\n\n     ))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [q c n]\n  (#({0 nil} % %)\n   (apply max\n     (for [\n           m (take 4 (iterate q (map #(subs (Long/toBinaryString (+ 64 %)) 1) n)))\n           h (map drop (range) (repeat (- (count m) 1) m))\n           v (map #(map (fn [r] (subs r %)) %2) (range) (repeat (count (nfirst h)) h))\n           ]\n       (c v)))))\n\n#(reverse (apply map str %))\n\n(fn [m]\n  (let [w (count (take-while #{\\1} (first m)))\n        h (count m)]\n    (cond (< w 2) 0\n          (and (>= h w) (apply = \\1 (mapcat #(subs % 0 %2) m (range w 0 -1))))\n            (* 1/2 w (+ w 1))\n          (and (odd? w) (> h (/ w 2))\n               (apply = \\1 (mapcat #(subs % %2 (- w %2)) m (range (/ w 2)))))\n            (/ (+ (* w w) w w 1) 4)\n          :else 0)))","problem":127,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn [b]\n\n(let [\n    b (map #(Integer/toString % 2) b)\n    nc (apply max (map count b))\n    pad #(concat (repeat (- nc (count %)) \\0) %)\n    b (map pad b)\n    nr (count b)\n    r  (apply map vector b)\n\n    tri (fn [s1 vs dc ds]\n      (loop [s1 s1 sz 1 [f & r] vs cur 0]\n        (if\n           (or  (< s1 0)(nil? f)\n                (> (+ s1 sz) (count f))\n                (not (every? #{\\1} (take sz (drop s1 f)))))\n                    cur\n            (recur (+ dc s1) (+ ds sz) r (+ cur sz)))))\n\n    tris \n      (fn [vs dc ds]\n        (for [c (range nc)\n              r (range nr)]\n           (tri c (drop r vs) dc ds)))\n\n    m (apply max \n              (mapcat (fn [bv]\n                        (concat (tris bv 0 1)\n                        (tris bv -1 2)))\n               [r (map reverse b) (reverse b)]))]\n(if (> m 1)\n  m)))","problem":127,"user":"4daa374930acd6ed13482a68"},{"code":"(fn love [pic]\r\n    (let [board (apply clojure.set/union \r\n                  (map-indexed \r\n                    (fn [y num] \r\n                      (loop [acc #{} x 0 num num] \r\n                        (if (zero? num)\r\n                          acc\r\n                          (recur (if (odd? num) (conj acc [x y]) acc) (inc x) (quot num 2))))) \r\n                  pic))\r\n          h (count pic)\r\n          w (inc (apply max (map second board)))\r\n          isline (fn [x y dirx diry len] (if (zero? len) \r\n                                           true \r\n                                           (if (board [x y]) \r\n                                             (recur (+ x dirx) (+ y diry) dirx diry (dec len)))))\r\n          trsize (fn [x y [addx addy dirx diry addlen]] (loop [x x y y len 1 size 0] \r\n                                                          (if (isline x y dirx diry len) \r\n                                                            (recur (+ x addx) (+ y addy) (+ len addlen) (+ size len))\r\n                                                            size)\r\n                                                          ))\r\n          ]\r\n      ;          C     C       Ccccc c     c\r\n      ;          Bc   cB        Bbb  cb   bc        \r\n      ; Abc cbA  Abc cbA   A     A   cbA Abc\r\n      ; Bc   cB           Bbb        cB   Bc\r\n      ; C     C          Ccccc       C     C\r\n      (let [m (apply max (flatten\r\n                     (map \r\n                       (fn [x] \r\n                         (map \r\n                           (fn [y] \r\n                             (map (fn [t] (trsize x y t))\r\n                                  [[0 1, 1 -1, 1] [0 1, -1 -1, 1] [0 -1, 1 1, 1] [0 -1, -1 1, 1] [-1 1, 1 0, 2] [-1 -1, 1 0, 2] [-1 1, 0 -1, 2] [1 1, 0 -1, 2]]))\r\n                           (range h)))\r\n                       (range w))))]\r\n        (if (>= m 3) m nil)\r\n        ))\r\n    )","problem":127,"user":"4feada56e4b0140c20fb9c11"},{"problem":127,"code":"(fn [coll]\n  (letfn [(digits\n           [n b]\n           (if (< n b)\n             [n]\n             (conj (digits (quot n b) b) (mod n b))))\n          (board\n           [coll]\n           (let [digits-seq (map #(digits % 2) coll)\n                 n (apply max (map count digits-seq))]\n             (into []\n                   (for [s digits-seq\n                         :let [size (count s)]]\n                     (if (= size n)\n                       s\n                       (vec (concat (repeat (- n size) 0) s)))))))\n          (coords\n           [b [y x] [y' x'] direction]\n           (let [coord-seq (if (= y y')\n                             (mapv vector (repeat y) (range x (inc x')))\n                             (mapv vector (range y (inc y')) (repeat x)))]\n             (if (and (every? #(<= 0 %) (flatten coord-seq))\n                      (every? #(= 1 (get-in b %)) coord-seq))\n               (concat coord-seq (coords b\n                                         (mapv + (first coord-seq) (first direction))\n                                         (mapv + (peek coord-seq) (peek direction))\n                                         direction))\n               [])))]\n    (let [b (board coll)\n          m (count b)\n          n (count (first b))]\n      (->>\n       (mapcat (fn [p]\n                 (map #(coords b p p %)\n                  [[[1 -1] [1 1]]\n                   [[-1 1] [1 1]]\n                   [[-1 -1][-1 1]]\n                   [[-1 -1] [1 -1]]\n                   [[1 0][1 1]]\n                   [[0 1][1 1]]\n                   [[-1 1][0 1]]\n                   [[-1 0][-1 1]]\n                   [[-1 -1][-1 0]]\n                   [[-1 -1][0 -1]]\n                   [[0 -1] [1 -1]]\n                   [[1 -1] [1 0]]]))\n               (for [y (range m) x (range n)]\n                 [y x]))\n       (filter #(not (empty? %)))\n       (map count)\n       (apply max)\n       (#(if (not= 1 %) %))))))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn [rock]\n  (let [patterns (map #(Long/toBinaryString %) rock)\n        max-count (apply max (map count patterns))\n        fixed-patterns (map #(apply str (concat (repeat (- max-count (count %)) \\0) %)) patterns)\n        ones (set (mapcat (fn [index a] (for [inner-index (range (count a))\n                                   :when (= \\1 (nth a inner-index))]\n                               [index inner-index])) (range) fixed-patterns))\n        ways [[[-1 0] [0 1]], [[0 1] [1 0]], [[1 0] [0 -1]], [[0 -1] [-1 0]],\n              [[-1 0] [0 1] [1 0]], [[0 1] [1 0] [0 -1]], [[1 0] [0 -1] [-1 0]], [[0 -1] [-1 0] [0 1]]]\n        step (fn [k w] (map #(map + %1 %2) (repeat k) w))\n        ok? (partial clojure.set/superset? ones)\n        cal (fn [k w]\n              (loop [current (step k w) result #{k}]\n                (if (ok? current)\n                    (recur (set (mapcat #(step % w) current)) (into result current))\n                  (count result))))\n        temp (apply max (for [k ones w ways] (cal k w)))]\n    (if (<= temp 1)\n        nil\n      temp)))","problem":127,"user":"507fbd77e4b089ade05efbd3"},{"problem":127,"code":"(fn [nlist]\n (letfn [(maxlen [nlist]\n           (->> nlist\n                (apply max)\n                ((fn [x] (inc (int (Math/floor (/ (Math/log x) (Math/log 2)))))))))\n\n         (bit-representation [length n]\n           (->> [n 0]\n                (iterate (fn [[n _]] [(quot n 2) (mod n 2)]))\n                (rest)\n                (take length)\n                (map second)\n                (reverse)\n                (vec)))\n\n         (make-image [nlist]\n           (let [maxl (maxlen nlist)]\n             (mapv (partial bit-representation maxl) nlist)))\n\n         (left  [[r c]] [r       (dec c)])\n         (ldown [[r c]] [(inc r) (dec c)])\n         (down  [[r c]] [(inc r)      c ])\n         (rdown [[r c]] [(inc r) (inc c)])\n         (right [[r c]] [r       (inc c)])\n         (rup   [[r c]] [(dec r) (inc c)])\n         (up    [[r c]] [(dec r)      c ])\n         (lup   [[r c]] [(dec r) (dec c)])\n\n         (make-measure [image moveop]\n           (fn measure\n             ([n lst]\n                (let [nextp (distinct (for [m moveop\n                                            l lst]\n                                        (m l)))\n                      edge (map #(get-in image %) nextp)]\n                  (if (every? #{1} edge)\n                    (recur (+ n (count edge)) nextp)\n                    n)))\n             ([lst] (measure 1 lst))))\n\n         (square-quoters [moveops]\n           (let [q (take-nth 2 moveops)]\n             (mapv vector q (rest (cycle q)))))\n\n         (slant-quoters [moveops]\n           (let [m1 (rest (cycle moveops))\n                 m2 (rest m1)\n                 m3 (rest m2)]\n             (take 4 (take-nth 2 (map vector m1 m2 m3)))))\n\n         (make-moveops []\n           (let [left  (fn [[r c]] [r       (dec c)])\n                 ldown (fn [[r c]] [(inc r) (dec c)])\n                 down  (fn [[r c]] [(inc r)      c ])\n                 rdown (fn [[r c]] [(inc r) (inc c)])\n                 right (fn [[r c]] [r       (inc c)])\n                 rup   (fn [[r c]] [(dec r) (inc c)])\n                 up    (fn [[r c]] [(dec r)      c ])\n                 lup   (fn [[r c]] [(dec r) (dec c)])\n                 moveops [left ldown down rdown right rup up lup]]\n             (concat (square-quoters moveops)\n                     (slant-quoters  moveops))))\n\n         (max-triangle [image]\n           (let [measures (map (partial make-measure image)\n                               (make-moveops))\n                 sizes (for [r (range (count image))\n                             c (range (count (first image)))\n                             :when (= 1 (get-in image [r c]))]\n                         (map #(% (list [r c])) measures))\n                 triangle-size (apply max (flatten sizes))]\n             (if (= 1 triangle-size)\n               nil\n               triangle-size)))]\n   (max-triangle (make-image nlist))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":127,"code":"(fn [input]\n    (let [compile-pattern (fn [p]\n                            (reduce (fn [x n] (bit-or (bit-shift-left x 5) n)) 0 (reverse p)))\n          input (compile-pattern input)\n\n          basic-patterns (map compile-pattern\n                              [[2r11111\n                                2r01111\n                                2r00111\n                                2r00011\n                                2r00001]\n                               [2r01111\n                                2r00111\n                                2r00011\n                                2r00001]\n                               [2r00111\n                                2r00011\n                                2r00001]\n                               [2r00011\n                                2r00001]\n\n                               [2r11111\n                                2r01110\n                                2r00100]\n                               [2r00111\n                                2r00010]\n\n                               [2r00001\n                                2r00011\n                                2r00001]\n                               [2r00001\n                                2r00011\n                                2r00111\n                                2r00011\n                                2r00001]])\n\n          column-pattern (fn [n]\n                           (compile-pattern (repeat 6 (bit-shift-left 1 n))))\n          row-pattern (fn [n]\n                        (compile-pattern (concat (repeat n 2r00000) [2r11111])))\n\n          left-edge (column-pattern 4)\n          bottom-edge (row-pattern 5)\n\n          clear? (fn [p x] (zero? (bit-and p x)))\n          matches? (fn [x] (= x (bit-and x input)))\n\n          left-shifts (fn [p]\n                        (loop [p p\n                               shifts [p]]\n                          (if (clear? left-edge p)\n                            (recur (bit-shift-left p 1)\n                                   (conj shifts (bit-shift-left p 1)))\n                            shifts)))\n\n          down-shifts (fn [p]\n                        (loop [p p\n                               shifts [p]]\n                          (if (clear? bottom-edge p)\n                            (recur (bit-shift-left p 5)\n                                   (conj shifts (bit-shift-left p 5)))\n                            shifts)))\n\n          flip-horizontally (fn [p]\n                              (bit-or\n                                (bit-shift-left (bit-and p (column-pattern 0)) 4)\n                                (bit-shift-left (bit-and p (column-pattern 1)) 2)\n                                (bit-and p (column-pattern 2))\n                                (bit-shift-right (bit-and p (column-pattern 3)) 2)\n                                (bit-shift-right (bit-and p (column-pattern 4)) 4)))\n\n          flip-vertically (fn [p]\n                            (bit-or\n                              (bit-shift-left (bit-and p (row-pattern 0)) (* 5 5))\n                              (bit-shift-left (bit-and p (row-pattern 1)) (* 5 3))\n                              (bit-shift-left (bit-and p (row-pattern 2)) (* 5 1))\n                              (bit-shift-right (bit-and p (row-pattern 3)) (* 5 1))\n                              (bit-shift-right (bit-and p (row-pattern 4)) (* 5 3))\n                              (bit-shift-right (bit-and p (row-pattern 5)) (* 5 5))))\n\n          all-patterns (->> basic-patterns\n                         (map left-shifts)\n                         flatten\n                         (map down-shifts)\n                         flatten\n                         (map (fn [p] [p (flip-horizontally p)]))\n                         flatten\n                         (map (fn [p] [p (flip-vertically p)]))\n                         flatten\n                         (into #{}))\n\n          matching (->> all-patterns\n                     (filter matches?)\n                     (map #(Long/bitCount %)))]\n\n      (if-not (empty? matching)\n        (apply max matching))))","user":"521b9f92e4b0c4ef0be8304c"},{"problem":127,"code":"(fn triangles [b]\n  (let [rows (count b) cols 5]\n    (letfn [(get-bit [x y] (bit-test (nth b x 0) (- cols y 1))) \n            (triangle [[x y] dir [inc-l inc-r]]\n              (let [outer-range   (case dir\n                                    :up   (range x -1 -1), :down  (range x rows)\n                                    :left (range y -1 -1), :right (range y cols))\n                    inner-rng-gen (fn [x y] #(let [diff (Math/abs (- x %))] (range (- y (* diff inc-l)) (+ y (* diff inc-r) 1))))\n                    inner-rng-fn  (case dir (:up :down) (inner-rng-gen x y), (:left :right) (inner-rng-gen y x))\n                    get-bit-fn    (case dir (:up :down) #(get-bit %1 %2),    (:left :right) #(get-bit %2 %1))]\n                (take-while (partial every? true?) (map (fn [d1]\n                                                          (map (fn [d2] (get-bit-fn d1 d2)) (inner-rng-fn d1)))\n                                                        outer-range))))]\n      (->> (for [x (range rows), y (range cols) ; from each point in the grid,\n                 ap [[0 1] [1 0] [1 1]]         ; compute all the triangles \n                 dir [:up :down :left :right]]  ; in all directions\n             (triangle [x y] dir ap))\n           (map (comp count flatten))           ; count their size\n           (filter (partial <= 3))              ; remove too-small ones\n           (sort >) first))))","user":"575b3e9be4b02ea11479935b"},{"problem":127,"code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn largest-triangle [values]\n  (let [\n    values-bin-seqs\n      (map #(seq (Integer/toString % 2)) values)\n\n    max-v\n      (apply max (map count values-bin-seqs))\n\n    matrix\n      (vec\n        (for [v values-bin-seqs]\n          (vec (into v (repeat (- max-v (count v)) \\0)))))\n\n    height\n      (count matrix)\n\n    width\n      (count (first matrix))\n\n    valid-coord?\n      (fn [[y x]]\n        (and (> x -1) (< x width)\n             (> y -1) (< y height)))\n\n    mineral-at?\n      (fn [point]\n        (= (get-in matrix point) \\1))\n\n    direction\n      (fn [f1 f2]\n        (fn [[y x]]\n          [(f1 y) (f2 x)]))\n\n    east\n      (direction identity inc)\n\n    west\n      (direction identity dec)\n \n    south\n      (direction inc identity)\n\n    north\n      (direction dec identity)\n\n    directions\n      #{east west south north}\n\n    perpendiculars\n      {east  #{south north}\n       west  #{south north}\n       north #{west east}\n       south #{west east}}\n\n    segment?\n      (fn [point size direction]\n        (and\n          (valid-coord? point)\n          (<= size\n            (loop [p point, s 0]\n              (if (and (valid-coord? p)\n                       (mineral-at?  p))\n                (recur (direction p) (inc s))\n                s)))))\n\n    get-descending-triangle-area\n     (fn [point size tr-dir seg-dir]\n        (loop [p point, s size, total-size 0]\n          (if (segment? p s seg-dir)\n            (if (= s 1)\n              (inc total-size)\n              (recur (tr-dir p) (dec s) (+ s total-size)))\n            0)))\n\n    get-triangle-area\n      (fn [point tr-dir seg-dir]\n        (loop [p point, s 1, total-size 0, dta 0]\n          (if (segment? p s seg-dir)\n            (recur (tr-dir p) (inc s) (+ s total-size)\n                   (get-descending-triangle-area\n                     (tr-dir p) (dec s) tr-dir seg-dir))\n            (+ total-size dta))))\n\n    get-triangle-area-all-dirs\n      (fn [point]\n        (apply max\n          (for [d directions, p (perpendiculars d)]\n            (get-triangle-area point d p))))\n\n    triangle-areas\n      (filter #(> % 1)\n        (for [x (range width), y (range height)]\n          (get-triangle-area-all-dirs [y x])))\n\n    ]\n   (if (empty? triangle-areas)\n      nil\n      (apply max triangle-areas))))","problem":127,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn [rm]\n    ; complexity O(N^4), may be improved to O(N^2) \n    (let [n (count rm)\n          bs (fn [x] (count \n                      (take-while #(not= % 0)\n                                  (iterate #(bit-shift-right % 1) x))))\n          m (reduce max (map bs rm))\n          d (fn [i j] (and (contains? rm i) (bit-test (rm i) j)))\n          c (fn [s] (every? #(d (first %) (second %)) s))\n          a1 (for [i (range n),\n                   j (range m),\n                   c (range 1 (inc (max n m)))\n                   di [-1 1]\n                   dj [-1 1]]\n               (for [d (range c)\n                     p (range (- c d))]\n                 [(+ i (* di d)),\n                  (+ j (* dj p))]))\n          a2s (for [i (range n),\n                    j (range m),\n                    c (range 1 (inc (max n m))),\n                    di [-1 1]]\n                (for [d (range c)\n                      p (range (- 0 d) (+ 1 d))]\n                  [(+ i (* di d)),\n                   (+ j p)]))\n          a2 (mapcat (fn [a] [a (map (fn [[i j]] [j i]) a)]) a2s)\n          x (reduce max (map count (filter c (concat a1 a2))))]\n      (when-not (== 1 x) x)))","problem":127,"user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [data]\n  (let [bins (map #(Integer/toBinaryString %) data)\n        max-len (apply max (map count bins))\n        rep-str #(apply str (repeat % %2))\n        zeroes (rep-str max-len \\0)\n        pbins (map #(str (subs zeroes (count %)) %) bins)\n        right-left (fn [pattern] (map #(apply str (reverse %)) pattern))\n        one-count (fn [ss] (count (filter #(= \\1 %) (apply str ss))))  \n        pattern-a (fn [n]\n                     (let [w (+ n 2)]\n                     (map #(str\n                     (rep-str (inc %) \\1)\n                     (rep-str (- w % 1) \\.))\n                     (range w))))\n        pattern-b (fn [n]\n                    (let [h (+ n 2) w (+ 1 h h)]\n                      (map #(str\n                              (rep-str % \\.)\n                              (rep-str (- w % % 2) \\1)\n                              (rep-str % \\.))\n                           (range h))))\n        pattern-c (fn [n]\n                    (concat (pattern-a n) (rest (reverse (pattern-a n)))))\n        fits? (fn [pattern rock]\n                (and (<= (count pattern) (count rock))\n                     (<= (count (first pattern)) (count (first rock)))))\n        segment (fn [rock x y w h]\n                  (->> rock\n                    (drop y)\n                    (take h)\n                    (map #(apply str (take w (drop x %))))\n                    ))\n        match-exact? (fn [pattern rock]\n                       (every? #(re-matches (re-pattern (first %)) (second %))\n                             (map vector pattern rock)))\n        match (fn [pattern rock]\n                (let [pattern-h (count pattern)\n                      pattern-w (count (first pattern))\n                      pattern-ones (one-count pattern)\n                      dy (- (count rock) pattern-h)\n                      dx (- (count (first rock)) pattern-w)]\n                  (if (and (>= dx 0) (>= dy 0))\n                    (if\n                      (some identity\n                       (for [x (range (inc dx)) y (range (inc dy))]\n                         (let [seg (segment rock x y pattern-w pattern-h)]\n                           (match-exact? pattern seg))))\n                        pattern-ones\n                        0)\n                    0)))\n        patterns [ pattern-a\n                  (comp reverse pattern-a)\n                  (comp right-left pattern-a)\n                  (comp reverse right-left pattern-a)\n                  pattern-b\n                  (comp reverse pattern-b)\n                  pattern-c\n                  (comp right-left pattern-c)\n                  ]\n        max-fit (fn [pattern]\n                  (last\n                    (take-while #(> % 0)\n                      (map #(match (pattern %) pbins) (range)))))\n        ]\n    (let [fits (filter identity (map max-fit patterns))]\n      (if (empty? fits)\n        nil\n        (apply max fits)))))","problem":127,"user":"52a88c4de4b0c58976d9ac30"},{"problem":127,"code":"(fn love-triangle\n  [coll]\n  (letfn [(->binary-grid\n            [coll]\n            (let [bs (mapv\n                       (comp (partial mapv #(Character/getNumericValue %))\n                             #(Integer/toBinaryString %))\n                       coll)\n                  w (apply max (map count bs))]\n              (mapv (fn [row]\n                      (vec (concat (repeat (- w (count row)) 0) row)))\n                    bs)))\n          (transpose [matrix] (vec (apply map vector matrix)))\n          (flip [matrix] (vec (map (comp vec reverse) matrix)))\n          (matrix-positions\n            [pred coll]\n            (apply concat (keep-indexed (fn [y row]\n                                          (seq (keep-indexed (fn [x element]\n                                                               (when (pred element)\n                                                                 [y x]))\n                                                             row)))\n                                        coll)))\n          (generate-coordinates\n            [binary-grid]\n            (let [n (min (count binary-grid) (count (first binary-grid)))\n                  largest-basic-triangle (reduce\n                                           (fn [acc x]\n                                             (conj acc (vec (concat (repeat (inc x) 1)\n                                                                    (repeat (- n (inc x)) 0)))))\n                                           []\n                                           (range 0 n))\n                  largest-basic-pyramid (vec (concat largest-basic-triangle (reverse (butlast largest-basic-triangle))))\n                  basic-triangles (take-while #(<= 2 (count %))\n                                              (iterate (fn [triangle]\n                                                         (vec (rest (map rest triangle))))\n                                                       largest-basic-triangle))\n                  basic-pyramids (take-while #(<= 2 (count (first %)))\n                                             (iterate (fn [pyramid]\n                                                        (vec (butlast (rest (mapv rest pyramid)))))\n                                                      largest-basic-pyramid))\n                  all-rotated (vec (mapcat (juxt identity transpose flip (comp flip transpose)) (concat basic-triangles basic-pyramids)))\n                  coordinates (mapcat (fn [triangle]\n                                        (let [max-x (count (first binary-grid))\n                                              max-y (count binary-grid)\n                                              ones (matrix-positions (partial = 1) triangle)]\n                                          (for [xi (range 0 (- max-x (dec (count (first triangle)))))\n                                                yi (range 0 (- max-y (dec (count triangle))))]\n                                            (set (map (fn [[y x]] [(+ yi y) (+ xi x)]) ones)))))\n                                      all-rotated)]\n              coordinates))]\n    (let [binary-grid (->binary-grid coll)]\n      (last\n        (sort\n          (map count (filter #(clojure.set/subset? % (set (matrix-positions (partial = 1) binary-grid)))\n                             (generate-coordinates binary-grid))))))))","user":"4dc0ff08535d020aff1edf84"},{"problem":127,"code":"(fn triangle [coll]\n   (let [rocks (let [_rb (for [x coll]\n                          (Integer/toBinaryString x))\n                     ;\n;                     _maxc (apply max (conj (map count _rb) (count _rb)))\n                     _maxc (apply max (map count _rb))\n                     _maxl (count _rb)\n                     _v (vec (map #(vec (format (str \"%0\" _maxc \"d\")\n                                            (Integer/parseInt %)))\n                              _rb))]\n                 (for [x (range _maxl)]\n                   (for [y (range _maxc)]\n                     (if (< x (count _v))\n                       (Integer/parseInt (str ((_v x) y)))\n                       0))))\n         LOWX (count rocks)\n         COLY (count (first rocks))\n\n         ; utils\n         debug (fn _d\n                 ([target] (_d \"debug\" target))\n                 ([name target]\n                 (println name \"::---\")\n                 (loop [_c target]\n                   (println (apply str (first _c)))\n                   (if (not-empty _c)\n                     (recur (rest _c))\n                     target))))\n\n         debug-b (fn [b]\n                   (debug \"---- shifted\"\n                          (partition-all COLY\n                                         (seq (.replace\n                                                (format (str \"%\" (* LOWX COLY) \"s\")\n                                                        (Integer/toBinaryString b))\n                                                \" \" \"0\"))))\n                   b)\n\n           to-b (fn [coll]\n                (Long/parseLong (apply str (flatten coll)) 2))\n         countm (fn [mine]\n                  (reduce + (filter #(= 1 %) (flatten mine))))\n         padding-y (fn [mask]\n                     (let [n (- COLY (count (first mask)))]\n                       (if (> n 0)\n                         (for [l mask]\n                           (concat l (take n (cycle '(0)))))\n                         mask)))\n         padding-x (fn [mask]\n                     (let [n (- LOWX (count mask))]\n                       (if (> n 0)\n                         (partition-all COLY\n                           (concat (flatten mask)\n                                  (take (* n COLY) (cycle '(0)))))\n                         mask)))\n         padding (fn [mask]\n                   (-> mask\n                       (padding-y)\n                       (padding-x)))\n\n         ; create - triangle\n         create-e (fn [size]\n                    ; for even\n                    (for [x (range size)]\n                      (for [y (range size)]\n                        (if (>= x y) 1 0))))\n         create-o (fn [size]\n                    ; for odd\n                    (for [x (range (inc (quot size 2)))]\n                      (for [y (range size)]\n                        (if (and (<= x y) (>= (- (dec size) x) y)) 1 0))))\n\n         ; rotation\n         reverse-x (fn [coll]\n                     (reverse coll))\n         reverse-y (fn [coll]\n                     (for [l coll]\n                       (reverse l)))\n         reverse-xy (fn [coll]\n                      (reverse-y (reverse-x coll)))\n         replace-xy (fn [coll]\n                      (let [vcoll (vec (map vec coll))]\n                        (for [x (range (count (first vcoll)))]\n                          (for [y (range (count vcoll))]\n                            ((vcoll y) x)))))\n\n         shift-b (fn [x y mask]\n                   (debug-b (bit-shift-right mask (+ y (* x COLY)))))\n\n         harvestable? (fn [mask]\n                        (let [_maskb  (to-b (debug \"mask\" (padding mask)))\n                              _rocksb (to-b rocks)\n                              disx (- LOWX (count mask))\n                              disy (- COLY (count (first mask)))]\n                          (if (> 0 disx)\n                            false\n                            (some identity\n                              (for [i (range (inc disx))\n                                    j (range (inc disy))\n                                    :let [_shifted_maskb (shift-b i j _maskb)]]\n                                (= (bit-and _shifted_maskb _rocksb) _shifted_maskb))))))\n\n         search-e (fn [mask]\n                    ; check all pattern of rotation\n                    (or (harvestable? mask)\n                        (harvestable? (reverse-x mask))\n                        (harvestable? (reverse-y mask))\n                        (harvestable? (reverse-xy mask))))\n\n         search-o (fn [mask]\n                    (let [sym-mask (replace-xy mask)]\n                      (or (harvestable? mask)\n                          (harvestable? (reverse-x mask))\n                          (harvestable? sym-mask)\n                          (harvestable? (reverse-y sym-mask)))))\n\n\n\n         ;main\n         harvest (fn []\n                   (max\n                     (loop [n COLY]\n                       (let [mask-e (create-e n)]\n                         (if (search-e mask-e)\n                           (countm mask-e)\n                           (if (> n 2)\n                             (recur (dec n))\n                             0))))\n                     (loop [n COLY]\n                       (if (even? n)\n                         (recur (dec n))\n                         (let [mask-o (create-o n)]\n                           (if (search-o mask-o)\n                             (countm mask-o)\n                             (if (> n 2)\n                               (recur (- 2 n))\n                               0)))))))]\n\n     (debug \"rocks\" rocks)\n     ;(debug (create-o 5))\n     ;(debug (replace-xy (create-o 5)))\n     (let [ret (harvest)]\n       (if (zero? ret)\n         nil\n         ret))))","user":"55a372f1e4b0acc240e31537"},{"problem":127,"code":"; I don't want to talk about it.\n\n(fn [coll]\n  (letfn [(transpose [M]\n            (vec (apply map vector M)))\n          (most-ones [pairs pair]\n            (let [max-count (second pair)]\n              (cond\n                (every? (comp (partial = max-count) second) pairs)\n                (conj pairs pair)\n                (not-any? (comp (partial > max-count) second) pairs)\n                pairs\n                :max-found\n                (conj nil pair))))\n          (one-counts [M]\n            (letfn [(ffirst-and-count [xs]\n                      [(ffirst xs) (count xs)])\n                    (i-and-one-count [i row]\n                      (let [grouped-with-indexes\n                            (partition-by\n                              (comp identity second)\n                              (map-indexed vector row))\n                            only-ones\n                            (filter (partial every?\n                                             (comp (partial = 1) second))\n                                    grouped-with-indexes)\n                            most-ones\n                            (if (empty? only-ones)\n                              [-1 -1]\n                              (apply\n                                max-key\n                                second\n                                (map ffirst-and-count only-ones)))\n                            [row-i ones] most-ones]\n                        [[i row-i] ones]))]\n              (map-indexed i-and-one-count M)))\n          (most-ones-start-pos [M]\n            (->> M\n                 one-counts\n                 (reduce most-ones '())\n                 (map first)))\n          (max-triangle [M start-pos]\n            ; Hello imperativeness my old friend\n            (let [j-stop (count M)]\n              (loop [right start-pos\n                     left right\n                     res 0\n                     res-half 0\n                     growing true\n                     valid true]\n                (if (or (not (<= 0 (first right) (dec j-stop)))\n                        (< (second right) (second left))\n                        (not valid))\n                  (if (= 1 (+ res res-half))\n                    0\n                    (if (= (dec (second left)) (second right))\n                      (+ res res-half)\n                      res))\n                  (let [[j-r i-r] right\n                        [j-l i-l] left\n                        row (subvec (get M j-l) i-l (inc i-r))\n                        [next-left next-right next-growing\n                         next-valid next-res next-res-half]\n                        (if growing\n                          (if (every? (partial = 1) row)\n                            (if (zero? i-l)\n                              [[(inc j-l) (inc i-l)] [(inc j-r) i-r] false\n                               true (+ res (count row)) res-half]\n                              [[(inc j-l) (dec i-l)] [(inc j-r) i-r] true\n                               true (+ res (count row)) res-half])\n                            [[j-l (+ 2 i-l)] [j-r i-r] false\n                             true res res-half])\n                          (if (every? (partial = 1) row)\n                            [[(inc j-l) (inc i-l)] [(inc j-r) i-r] false\n                             true res (+ res-half (count row))]\n                            [[(inc j-l) (inc i-l)] [(inc j-r) i-r] false\n                             false res res-half]))]\n                    (recur next-right next-left next-res\n                           next-res-half next-growing next-valid))))))\n          (do-stuff [M]\n            (let [[i j] (first (most-ones-start-pos (transpose M)))\n                  start-pos [j i]]\n              (max-triangle M start-pos)))\n          (parse-mineral [coll]\n            (let [binary (map #(Integer/toString % 2) coll)\n                  max-bit-count (apply max (map count binary))\n                  no-padding (map (partial map (comp read-string str)) binary)\n                  pad-left (fn [c] (concat (repeat (- max-bit-count (count c)) 0) c))]\n              (vec (map (comp vec pad-left) no-padding))))]\n    (let [M (parse-mineral coll)\n          area (max (do-stuff M) (-> M reverse transpose do-stuff))]\n      (when-not (zero? area)\n        area))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(fn love-triangle [board]\r\n  (letfn [(bin-get-in [[r c]]\r\n            (if (or (< r 0) (< c 0) (>= r (count board))) 0\r\n                (bit-and 1 (bit-shift-right (nth board r) c))))\r\n          (two-log [n]\r\n            (count (take-while pos? (iterate #(bit-shift-right % 1) n))))\r\n          (find-trangle-size [position direction]\r\n            (->> (range 10)\r\n                 (map (fn [n]\r\n                        (if (some #(= 0 %) direction)\r\n                          (for [i (range (- n) (inc n))] (map + position (map #(* n %) direction) (map #(* i %) (reverse direction))))\r\n                          (for [i (range (inc n))] (map + position (map * direction [i (- n i)]))))))\r\n                 (map (fn [ps] (every? #(= (bin-get-in %) 1) ps)))\r\n                 (take-while true?)\r\n                 (count)\r\n                 ((fn [cnt] (if (some #(= 0 %) direction)\r\n                              (* cnt cnt)\r\n                              (* cnt (inc cnt) 1/2))))))]\r\n    (let [mx (apply max (for [r (range (count board))\r\n                              c (range (two-log (apply max board)))\r\n                              dx (range -1 2)\r\n                              dy (range -1 2) :when (not (= 0 dx dy))]\r\n                          (find-trangle-size [r c] [dx dy])))]\r\n      (if (<= mx 1) nil mx))))","problem":127,"user":"4e994541535dbda64a6f6b64"},{"problem":127,"code":"(fn [r]\n\t(let [board (fn [raw] \n\t\t\t\t\t(let [rows (map (fn d [x] (if (> x 1) (cons (bit-and x 1) (d (bit-shift-right x 1))) (list x))) raw)\n\t\t\t\t\t\tpad (fn [l n]  (vec (concat (repeat (- n (count l)) 0) l)))\n\t\t\t\t\t\tmax-count (apply max (map count rows))]\n\t\t\t\t\t\t\t(mapv #(pad % max-count) rows)))\n\t\t\ttc (fn [b x y]\n\t\t\t\t\t(let [bt (fn bt [b x m-asc m-desc prev asc?]\n\t\t\t\t\t\t\t\t(let [n ((if asc? inc dec) prev)\n\t\t\t\t\t\t\t\t\t  r (take n (drop x (first b)))\n\t\t\t\t\t\t\t\t\t  correct-row? (and (>= (count r) n) (every? true? (map = (repeat 1) r)))]\n\t\t\t\t\t\t\t\t\t(if (not asc?)\n\t\t\t\t\t\t\t\t\t\t(if (= 0 n) \n\t\t\t\t\t\t\t\t\t\t\tm-desc\n\t\t\t\t\t\t\t\t\t\t\t(if (and (seq b) correct-row?)\n\t\t\t\t\t\t\t\t\t\t\t\t(bt (rest b) x m-asc (+ m-desc n) (dec prev) false)\n\t\t\t\t\t\t\t\t\t\t\t\tm-asc))\n\t\t\t\t\t\t\t\t\t\t(if correct-row? \n\t\t\t\t\t\t\t\t\t\t\t(if (seq (rest b))\n\t\t\t\t\t\t\t\t\t\t\t\t(max (bt (rest b) x (+ m-asc n) (+ m-asc n) (inc prev) true)\n\t\t\t\t\t\t\t\t\t\t\t\t\t (bt (rest b) x (+ m-asc n) (+ m-asc n) (inc prev) false))\n\t\t\t\t\t\t\t\t\t\t\t\t(+ m-asc n))\n\t\t\t\t\t\t\t\t\t\t\tm-asc))))]\n\t\t\t\t\t\t\t(bt (drop y b) x 0 0 0 true)))\n\t\t\tmb (fn [b] (reduce max (for [y (range (count b)) x (range (count (get-in b [y])))] (tc b x y))))\n\t\t\trotations (fn [b] (vector b (vec (mapv (comp vec reverse) b)) (vec (reverse b)) (vec (reverse (map (comp vec reverse) b)))))\n\t\t\tmt (fn [b] (reduce max (map mb (concat (rotations b) (rotations (vec (apply map vector b)))))))\n\t\t\tres (mt (board r))]\n\t\t(when (< 1 res) res)))","user":"53e19461e4b0d874e779ae59"},{"problem":127,"code":"(fn love-triangle [ex]\n  (let [n->v (fn [n]\n               (->> (range)\n                    (take-while #(<= (Math/pow 2 %) n))\n                    (map #(bit-test n %))\n                    (map {true 1 false 0})\n                    reverse\n                    (into [])))\n        ns->v (fn [ns]\n                (let [vs (mapv n->v ns)\n                      len (apply max (map count vs))]\n                  (mapv #(into [] (concat (repeat (- len (count %)) 0) %)) vs)))\n\n        ex (ns->v ex)\n                     \n        ul (fn [[r c]] [[r (dec c)] [(dec r) c]])\n        u  (fn [[r c]] [[(dec r) (dec c)] [(dec r) c] [(dec r) (inc c)]])\n        ur (fn [[r c]] [[(dec r) c] [r (inc c)]])\n        r  (fn [[r c]] [[(dec r) (inc c)] [r (inc c)] [(inc r) (inc c)]])\n        dr (fn [[r c]] [[r (inc c)] [(inc r) c]])\n        d  (fn [[r c]] [[(inc r) (dec c)] [(inc r) c] [(inc r) (inc c)]])\n        dl (fn [[r c]] [[r (dec c)] [(inc r) c]])\n        l  (fn [[r c]] [[(dec r) (dec c)] [r (dec c)] [(inc r) (dec c)]])\n        dirs [ul u ur r dr d dl l]\n\n        result (->>\n                 (for [row (range 0 (count ex))\n                       col (range 0 (-> ex first count))]\n                   (map\n                     (fn [dir]\n                       (loop [positions #{[row col]}\n                              size 0]\n                         (if (some (fnil zero? 0) (map (partial get-in ex) positions))\n                           size\n                           (recur\n                             (into #{} (mapcat dir positions))\n                             (+ size (count positions))))))\n                     dirs))\n                 flatten\n                 (apply max))]\n    (when (< 1 result) result)))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [n]\n  (letfn [(b [n] (if (= 0 n) '() (cons (mod n 2) (b (quot n 2)))))]\n    (let [d (apply concat (for [x [-1 1] y [-1 1] f [inc #(+ 1 (* 2 %))]]\n                          [[x y (- x) 0 f]\n                           [x y 0 (- y) f]]))\n          m (vec (map #(vec (b %)) n))\n          c (fn [[ux uy vx vy f] [x y]]\n  (apply + \n         (apply concat \n                (take-while \n                  #(do \n                     (every? (fn [x] (= x 1)) %))\n                  (map (fn [n] \n                         (take (f n) \n                               (map \n                                 #(get-in m [(+ (* n ux) (* % vx) x)\n                                             (+ (* n uy) (* % vy) y)])\n                                 (range)))) \n                       (range))))))\n          h (apply max (for [x (range (count m)) y (range (apply max (map count m))) v d]\n    (c v [x y])))]\n      (if (> h 1) h nil))))","problem":127,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(let [shapes '{15 ([2r10000 2r11000 2r11100 2r11110 2r11111]\n                   [2r11111 2r11110 2r11100 2r11000 2r10000]\n                   [2r00001 2r00011 2r00111 2r01111 2r11111]\n                   [2r11111 2r01111 2r00111 2r00011 2r00001]),\n               10 ([2r1000 2r1100 2r1110 2r1111]\n                   [2r0001 2r0011 2r0111 2r1111]\n                   [2r1111 2r1110 2r1100 2r1000]\n                   [2r1111 2r0111 2r0011 2r0001]),\n               6  ([2r100 2r110 2r111]\n                   [2r001 2r011 2r111]\n                   [2r111 2r110 2r100]\n                   [2r111 2r011 2r001]),\n               3  ([2r10 2r11]\n                   [2r01 2r11]\n                   [2r11 2r01]\n                   [2r11 2r10]),\n               9  ([2r11111 2r01110 2r00100]\n                   [2r00100 2r01110 2r11111]\n                   [2r100 2r110 2r111 2r110 2r100]\n                   [2r001 2r011 2r111 2r011 2r001]),\n               4  ([2r111 2r010]\n                   [2r010 2r111]\n                   [2r10 2r11 2r10]\n                   [2r01 2r11 2r01])}\n      sizes   (sort-by (comp - first)\n                       '{15 [5 5], 10 [4 4], 6 [3 3], 3 [2 2], 9 [5 3], 4 [3 2]})\n      int-length (fn il ([x n] (if (zero? x) n (recur (quot x 2) (inc n))))\n                        ([x] (il x 0)))\n      int-range  (fn [num r-off len]\n                     (bit-and (dec (bit-shift-left 1 len))\n                              (bit-shift-right num r-off)))\n      board-check (fn [board [by bx :as board-size] [oy ox :as off] \n                       shape [sy sx :as shape-size]]\n                   (every? (fn [y] \n                               (let [bl (get board (+ oy y))\n                                     sl (get shape y)\n                                     r (int-range bl (- bx ox sx) sx)]\n                                  (= (bit-and r sl) sl)))\n                           (range sy)))]\n      (fn [board]\n        (let [board-size [(count board) (int-length (apply max board))]]\n             (loop [test-sizes sizes]\n               (if (empty? test-sizes)\n                   nil\n                   (let [[[area a-size] & rest-sizes] test-sizes\n                         cur-shapes (get shapes area)]\n                      (if (some (fn [shape]\n                                 (let [size (if (= (count shape) (first a-size))\n                                                a-size (vec (reverse a-size)))\n                                       offsets \n                                       (for [oy (range (- (first board-size) \n                                                          (first size) -1))\n                                             ox (range (- (fnext board-size)\n                                                          (fnext size) -1))]\n                                            [oy ox])]\n                                    (some (fn [off]\n                                              (board-check board board-size\n                                                            off shape size))\n                                          offsets)\n                                    )) cur-shapes)\n                          area\n                          (recur rest-sizes))))))))","problem":127,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [bm]\n          (let [log (fn [n] (count\n                              (take-while (comp not zero?)\n                                          (iterate #(bit-shift-right % 1) n)))) \n                one-in-bm (fn [[y x]]\n                            (not (or (< y 0)\n                                     (>= y (count bm))\n                                     (zero? (bit-and (bit-shift-left 1 x) \n                                                     (bm y))))))\n                m (max (log (apply max bm)) (count bm))\n                grow (fn [both]\n                       (fn [seed]\n                         (let [n (map (fn [[y x]] [(inc y) x])\n                                      (last seed))\n                               [ly lx] (last n)\n                               [fy fx] (first n)\n                               n (if both\n                                   (cons [ly (dec fx)] n)\n                                   n)\n                               n (conj (vec n)\n                                       [ly (inc lx)])]\n                           (conj (vec seed) n))))\n                triangles (fn [growfun start]\n                            (rest (take-while\n                                    (fn [xs]\n                                      (let [l (last xs)\n                                            [ly lx :as ll] (last l)\n                                            [fy fx :as fl] (first l)]\n                                        (and ll fl\n                                             (< ly m)\n                                             (< lx m)\n                                             (>= fx 0))))\n                                    (iterate\n                                      growfun\n                                      [[start]]))))\n                mm (range m)\n                coords (for [y mm x mm] [y x])\n                trs (mapcat #(mapcat (partial triangles (grow %)) coords)\n                            [false true])\n                trs (map (partial apply concat) trs)\n                add (fn [fun coll]\n                      (concat coll\n                              (map\n                                #(map fun %) coll)))\n                flip #(- m (inc %))\n                flip-x (fn [[y x]] [y (flip x)])\n                flip-y (fn [[y x]] [(flip y) x])\n                filtered (filter (partial every? one-in-bm)\n                                 (->> trs\n                                   (add reverse)\n                                   (add flip-x)\n                                   (add flip-y)))]\n            (if (seq filtered)\n               (reduce max (map count filtered)))\n            ))","problem":127,"user":"4dc537fd535d8a4b2fd74282"},{"problem":127,"code":"(fn love-triangle\n  [c-vision]\n  (letfn [(row->longest-mineral-tray\n            [row]\n            (dissoc\n             (->> (partition-by identity row)\n                  (reduce (fn [{:keys [length start finnish position] :as sol-map} current]\n                            (let [c-count (count current)\n                                  c-end   (dec (+ position c-count))]\n                              (if (> c-count length)\n                                {:length c-count :start position :finnish c-end :position (inc c-end)}\n                                (assoc sol-map :position (inc position))\n                                ))) {:length 0 :start 0 :finnish 0 :position 0}))\n             :position))\n\n          (check-next-row\n            [m-map row-id start finnish size {:keys [up left] :as direction}]\n            (let [new-x\n                  (if up\n                    (dec row-id)\n                    (inc row-id))\n\n                  new-start\n                  (if left\n                    start\n                    (inc start))\n\n                  new-finnish\n                  (if left\n                    (dec finnish)\n                    finnish)]\n    \n              (cond\n                (= size 1)\n                1\n\n                (or (> 0 new-x ) (> 0 new-start ) (> 0 new-finnish) (>= new-finnish (count (first m-map))) (>= new-x (count m-map)))\n                false\n\n                (every? #(= \\1 %) (subs (nth m-map new-x) new-start (inc new-finnish)))\n                (let [next-result\n                      (check-next-row m-map new-x new-start new-finnish (dec size) {:up up :left left})\n\n                      middle-way (if (= 3 size)\n                                   (cond\n                                     (= start new-start)\n                                     (if (= \"1\" (subs (nth m-map new-x) (inc new-start) (+ 2 new-start)))\n                                       4\n                                       0)\n\n                                     (= finnish new-finnish)\n                                     (if (= \"1\" (subs (nth m-map new-x) (dec new-finnish) new-finnish))\n                                       4\n                                       0)\n\n                                     :else\n                                     0)\n                                   0)]\n                  \n                  (if next-result\n                    (if (and (= 4 next-result) (not (= size 5)))\n                      3  \n                      (max middle-way (+ size next-result)))\n                    (if (not (= 0 middle-way))\n                      middle-way\n                      false)))\n\n                :else\n                false)))]\n    \n    (let [prep-mineral-map\n          (mapv #(Integer/toString % 2) c-vision)\n\n          row-length\n          (apply max (map count prep-mineral-map))\n\n          mineral-map\n          (map (fn [row] (if (not (= (count row) row-length))\n                           (let [difference (- row-length (count row))]\n                             (str (apply str (repeat difference \"0\")) row))\n                           row)) prep-mineral-map)\n\n          longest-mineral-trays\n          (map-indexed (fn [row-num row] [row-num (row->longest-mineral-tray row)]) mineral-map)\n\n          solution-vec\n          (remove\n           #(not (boolean %))\n           (map (fn [[row-id {:keys [length start finnish]}]]\n                  (let [[[fl sl] [fr sr]]\n                        [[(check-next-row mineral-map row-id start finnish length {:up true :left true})\n                          (check-next-row mineral-map row-id start finnish length {:up false :left true})]\n\n                         [(check-next-row mineral-map row-id start finnish length {:up true :left false})\n                          (check-next-row mineral-map row-id start finnish length {:up false :left false})]]\n\n                        left-max (if (and (and  fl sl) (= fl sl))\n                                   (- (+ fl sl) length)\n                                   (cond\n                                     (and (not fl) (not sl))\n                                     false\n\n                                     (not fl)\n                                     sl\n\n                                     (not sl)\n                                     fl\n\n                                     :else\n                                     (max fl sl)))\n\n                        right-max (if (and (and  fr sr) (= fr sr))\n                                    (- (+ fr sr) length)\n                                    (cond\n                                      (and (not fr) (not sr))\n                                      false\n\n                                      (not fr)\n                                      sr\n\n                                      (not sr)\n                                      fr\n\n                                      :else\n                                      (max fr sr)))\n\n                        main-max (cond\n                                   (and (not left-max) (not right-max))\n                                   false\n\n                                   (not left-max)\n                                   right-max\n\n                                   (not right-max)\n                                   left-max\n\n                                   :else\n                                   (max left-max right-max))]\n                    main-max))\n\n                longest-mineral-trays))]\n\n      (if (empty? solution-vec)\n        nil\n        (let [final-solution\n              (apply max solution-vec)]\n          (if (> 3 final-solution)\n            nil\n            final-solution))))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":127,"code":"(fn triangle [in]\n  (let [bitmap (vec (map (comp vec reverse) (map #(Integer/toString % 2) in)))\n        row (count bitmap)\n        column (apply max (map count bitmap))\n        directions [[[1 1] [-1 1]] [[1 1] [-1 0]] [[1 1] [0 1]]\n                    [[-1 -1] [-1 1]] [[-1 -1] [-1 0]] [[-1 -1] [0 1]]\n                    [[-1 1] [1 1]] [[-1 0] [1 1]] [[0 1] [1 1]]\n                    [[-1 1] [-1 -1]] [[-1 0] [-1 -1]] [[0 1] [-1 -1]]]\n        grow-range (fn [currentRange direction]\n                     (vec (map #(vec (map + %1 %2)) currentRange direction)))\n        compute-area (fn [[r c] dir]\n                         (loop[cur[[r r] [c c]] ar 1]\n                           (let[[[rs re][cs ce]] (grow-range cur dir)\n                                cont (for[ro (range rs (inc re)) co (range cs (inc ce))]\n                                     (get-in bitmap [ro co]))]\n                             (if (every? #(= \\1 %) cont)\n                               (recur [[rs re][cs ce]] (+ ar (count cont)))\n                               ar))))\n        areas (for[r (range row) c (range column) :when (= \\1 (get-in bitmap [r c]))]\n                (apply max (map (partial compute-area [r c]) directions)))\n        maxArea (apply max areas)]\n    (if (> maxArea 2) maxArea nil)))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn tri [rockbits]\n   (let [rot90 (fn [[x y]] [y (- x)])\n         flip (fn [[x y]] [x (- y)])\n         expand (fn [points]\n                  (let [[x1 y1] (first points) [x2 y2] (last points)]\n                    (map (fn [[x y]] [(inc x) y])\n                         (concat [[x1 (dec y1)]] points [[x2 (inc y2)]]))))\n         expand-diag (fn [points]\n                       (let [[x1 y1] (first points)]\n                         (map (fn [[x y]] [(inc x) y])\n                              (cons [x1 (inc y1)] points))))\n         xm (count rockbits)\n         ym (apply max (map (fn [p] (count (take-while #(<= % p) (iterate (partial * 2) 1)))) rockbits))\n         rock (map (fn [layer] (map (fn [bit] (bit-test layer bit)) (range (dec ym) -1 -1))) rockbits)\n         mineral? (fn [[x y]] (if (and (< -1 x xm) (< -1 y ym)) (nth (nth rock x) y) false))\n         test (fn test [origin points exp-fn mod-fn]\n                (let [[ox oy] origin\n                      modded (map (fn [[x y]] [(+ ox x) (+ oy y)]) (map mod-fn points))]\n                  (if (every? mineral? modded)\n                    (+ (count points) (test origin (exp-fn points) exp-fn mod-fn))\n                    0)))\n         test-mods (fn [origin points exp-fn]\n                     (apply max (map #(test origin points exp-fn %)\n                                     [identity rot90 #(rot90 (rot90 %)) #(rot90 (rot90 (rot90 %)))\n                                      flip #(flip (rot90 %)) #(flip (rot90 (rot90 %)))\n                                      #(flip (rot90 (rot90 (rot90 %))))])))\n         test-exps (fn [origin points]\n                     (apply max (map #(test-mods origin points %) [expand expand-diag])))]\n     (let [val (apply max (map #(test-exps % [[0 0]]) (for [x (range xm) y (range ym)] [x y])))]\n       (if (> val 2) val nil))\n     ))","problem":127,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [board] (letfn [\n(int-log [n]\n  (if (= 0 n) 1\n      (loop [n n\n             b 0]\n        (if (= 0 n) b\n            (recur (quot n 2) (inc b))))))\n\n(ncols [coll] (apply max (map int-log coll)))\n\n(line [low-bit high-bit]\n  (reduce\n   #(bit-flip %1 %2)\n   (+ high-bit (- high-bit 1))\n   (take-while #(not (bit-test low-bit %)) (range))))\n\n(line? [board row low-bit high-bit]\n  (if (or (zero? low-bit)\n          (zero? high-bit)\n          (< high-bit low-bit))\n    false\n    (let [mask (line low-bit high-bit)]\n      (= mask (bit-and mask (nth board row))))))\n\n(tri-score [board hypotenuse start-row start-bit]\n  (if-not (and (not (zero? start-bit))\n               (= start-bit (bit-and start-bit (nth board start-row))))\n    0\n    (let [nrows (count board)\n          low-shift (if (= hypotenuse :horizontal) 1 0)]\n      (loop [current-row start-row\n             low-bit start-bit\n             high-bit start-bit\n             score 1]\n        (let [next-low  (bit-shift-right low-bit low-shift)\n              next-high (bit-shift-left high-bit 1)\n              next-row (inc current-row)]\n          (if (or (= nrows next-row)\n                  (zero? next-low)\n                  (not (line? board next-row next-low next-high)))\n            score\n            (recur next-row next-low next-high\n                   (+ score\n                      (count\n                       (range (int-log next-low)\n                              (inc (int-log next-high))))))))))))\n\n(pow2 [e] (bit-set 0 e))\n\n(bitcol->num [board col-i]\n  (apply +\n         (map *\n              (map #(if (bit-test % col-i) 1 0) board)\n              (map pow2 (reverse (range (count board)))))))\n\n(bit-transpose [board]\n  (map #(bitcol->num board %) (range (ncols board))))\n\n(max-tri-score [board]\n  (apply max\n         (for [h [:horizontal :diagonal]\n               r (range (count board))\n               c (map pow2 (range (ncols board)))]\n           (tri-score board h r c))))]\n\n  (let [score (apply max\n                     (map max-tri-score\n                          [board\n                           (reverse board)\n                           (reverse (bit-transpose board))]))]\n    (if (>= score 3) score))))","problem":127,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":127,"code":"(fn [c]\n  (letfn [(digs [n base]\n            (if (zero? n)\n              [0]\n              (let [divvy (take-while #(<= 1 %) (iterate #(int (/ % base)) n))\n                    digbackw (map #(rem % base) divvy)]\n                (reverse digbackw))))\n          (bindigs [n] (digs n 2))\n          (fillout [fill vs]\n            (let [numels (map #(conj [(count %)] %) vs)\n                  maxc (apply max (map first numels))\n                  fillf (fn [v m] (concat (repeat (-' m (first v)) fill) (second v)))]\n              (map #(fillf % maxc) numels)))\n          (find-els [m el]\n            (let [rowinds (filter #(some (fn [x] (= x el)) (nth m %)) (range (count m)))\n                  colindf (fn [r] (filter #(= el (nth (nth m r) %)) (range (count (first m)))))\n                  rcf (fn [r] (map #(vector r %) (colindf r)))]\n              (mapcat rcf rowinds)))\n          (mrbitmap [cbm] (fillout 0 (map bindigs cbm)))\n          (mins [mrb] (find-els mrb 1))\n          (nrtri [pr side]\n            (let [mid (map #(vector (inc (first %)) (second %)) pr)]\n              (cond\n               (= side :left) (concat [[(first (first mid)) (dec (second (first mid)))]] mid)\n               (= side :right) (concat mid  [[(first (last mid)) (inc (second (last mid)))]])\n               (= side :middle) (concat [[(first (first mid)) (dec (second (first mid)))]]  mid [[(first (last mid)) (inc (second (last mid)))]]))))\n          (tri-side [p m side]\n            (loop [tri [[p]] left (set m)]\n              (let [nr (nrtri (last tri) side)\n                    nrs (set nr)]\n                (if (clojure.set/subset? nrs left)\n                  (recur (conj tri nr) (clojure.set/difference left nrs))\n                  (apply concat tri)))))\n          (tris-p [p m] (map #(tri-side p m %) [:left :right :middle]))\n          (tris-or [m] (mapcat #(tris-p % m) m))\n          (all-ors [cbm]\n            (let [mrb (mrbitmap cbm)\n                  mrbu (reverse mrb)\n                  mrbs (apply map vector mrb)\n                  mrbsu (reverse mrbs)]\n              (map mins [mrb mrbu mrbs mrbsu])))\n          (all-tris [cbm] (mapcat tris-or (all-ors cbm)))\n          (countmins [cbm]\n            (let [tris (all-tris cbm)\n                  m (apply max (map count tris))]\n              (if (<= 3 m) m nil)))]\n    (countmins c)))","user":"5133e51ae4b0d7a043de8cf6"},{"problem":127,"code":"(fn max-triangle [table_]\n  (let [dec->bits (fn [dec] (->>\n                              [[] dec]\n                              (iterate (fn [[bits dec]]\n                                         (let [bit (rem dec 2)\n                                               new-dec (/ (- dec bit) 2)]\n                                           [(conj bits bit) new-dec])))\n                              (drop-while (fn [[_ dec]] (not= dec 0)))\n                              (first)\n                              (first)))\n        coords (->>\n                 table_\n                 (map dec->bits)\n                 (map vector (range))\n                 (map (fn [[y row]]\n                        (->>\n                          row\n                          (map vector (range))\n                          (filter (fn [[x val]] (= val 1)))\n                          (map (fn [[x val]] [x y]))\n                          )))\n                 (reduce concat)\n                 (into #{}))\n        get (fn [coords x y] (if (coords [x y]) 1 0))\n        max_ (fn [f] (fn [coords] (->>\n                                    coords\n                                    (map f)\n                                    (reduce max 0))))\n        max-x (max_ first)\n        max-y (max_ second)\n        rotate-coords (fn [coords] (->>\n                                     coords\n                                     (map (fn [[x y]] [(- (max-y coords) y) x]))\n                                     (into #{})))\n        maximum-2side-cut (fn [coords x y]\n                            (->>\n                              (for [step (range)]\n                                (->>\n                                  (range (inc step))\n                                  (map (fn [n]\n                                         (get coords\n                                              (+ x n)\n                                              (- (+ y step) n))))\n                                  (reduce +)\n                                  (= (inc step))))\n                              (take-while identity)\n                              count\n                              ((fn sum [n]\n                                 (* n (/ (inc n) 2))))))\n        maximum-1side-cut (fn [coords x y]\n                            (->>\n                              (for [step (range)]\n                                (->>\n                                  (range (inc (* 2 step)))\n                                  (map (fn [n]\n                                         (get coords\n                                              (+ (- x step) n)\n                                              (+ y step))))\n                                  (reduce +)\n                                  (= (inc (* 2 step)))))\n                              (take-while identity)\n                              count\n                              ((fn sum [n]\n                                (* n (/ (inc (dec (* n 2))) 2))))))\n        max-areas (for [plane (take 4 (iterate rotate-coords coords))\n                        x (range (max-x plane))\n                        y (range (max-y plane))\n                        :when (= 1 (get plane x y))\n                        :let [max-area (max (maximum-2side-cut plane x y)\n                                            (maximum-1side-cut plane x y))]\n                        :when (>= max-area 3)] max-area)]\n    (if (empty? max-areas) nil (apply max max-areas))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [data]\n  (let [area (fn [shape] (if (nil? shape) nil (count (filter #{1} (flatten shape)))))\n        dec-to-bin (fn dtb [n] (vec (drop 1 (map read-string (re-seq #\"\\d\" (Integer/toBinaryString (+ n 64)))))))\n        expanded-dataset (vec (map dec-to-bin data))\n        create-pattern1 (fn [size] (vec (for [x (range size)] (vec (for [y (range size)] (if (>= (+ x y) size) 0 1))))))\n        create-pattern2 (fn cp2 [size] (vec (for [x (range (inc (quot size 2)))] (vec (for [y (range size)] (if (and (<= x y) (<= y (- (dec size) x))) 1 0))))))\n        rotate (fn [matrix] (vec (map vec (map reverse (apply (partial map vector) matrix)))))\n        pattern-seq (fn ptnseq [size] (sort-by #(- 0 (area %)) (cond\n                                                                (> size 1) (let [p1 (create-pattern1 size)\n                                                                                 p2 (rotate p1)\n                                                                                 p3 (rotate p2)\n                                                                                 p4 (rotate p3)\n                                                                                 p5 (create-pattern2 size)\n                                                                                 p6 (rotate p5)\n                                                                                 p7 (rotate p6)\n                                                                                 p8 (rotate p7)\n                                                                                 ]\n                                                                             (concat (if (even? size) [p1 p2 p3 p4] [p1 p2 p3 p4 p5 p6 p7 p8]) \n                                                                                     (ptnseq (dec size))))\n                                                                :else [])))\n        \n        is-includable (fn ii ([board shape dx dy] (empty? (remove #{1} \n                                                                  (for [x (range (count (first shape)))\n                                                                        y (range (count shape))]\n                                                                    (if (and (zero? (get-in board [(+ y dy) (+ x dx)]))\n                                                                             (= 1 (get-in shape [y x])))\n                                                                      0\n                                                                      1)))))\n                        ([board shape] (not (empty? (filter identity\n                                                            (for [dx (range (inc (- (count (first board)) (count (first shape)))))\n                                                                  dy (range (inc (- (count board) (count shape))))]\n                                                              (ii board shape dx dy)))))))]\n    \n    (area (first \n           (filter \n            #(is-includable expanded-dataset %)\n            (pattern-seq (max (count expanded-dataset) (count (first expanded-dataset)))))))))","problem":127,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":127,"code":"(fn lt[v]\n  (let [m1 (vec (map #(vec (seq(Integer/toString % 2))) v)); \n        H (count m1)\n        W (apply max (map count m1))\n        m (apply merge \n                 (for [j (range H)]\n                   (apply merge\n                          (for [i (range (count (m1 j)))]\n                            {[(+ i (- W (count (m1 j)))) j] ((m1 j) i)}))))]\n    (letfn [(rg [a b r] (cond \n                          (and (< a b) r) (range a (inc b))\n                          (and (< a b) (not r)) (reverse (range a (inc b)))\n                          (and (> a b) r) (reverse (range b (inc a)))\n                          (and (> a b) (not r)) (range b (inc a))\n                          (= a b) (repeat a)))\n            (bt [i j v1 v2 n s] \n              (let [v1n (vec (map (partial * n) v1))\n                    v2n (vec (map (partial * n) v2))\n                    x1 (v1n 0)\n                    x2 (v2n 0)\n                    y1 (v1n 1)\n                    y2 (v2n 1)\n                    mc (for [[k l] (vec (mapv vector (rg x1 x2 true)(rg y2 y1 false)))] \n                         (= \\1 (m (vector (+ k i) (+ l j)))))\n                    l (count (filter true? mc))\n                    test (= l (count mc))]\n                (if test\n                  (bt i j v1 v2 (inc n) (+ s l))\n                  s)))]\n      (let [s (apply max (for [c m\n                               :let [i ((c 0) 0)\n                                     j ((c 0) 1)\n                                     e (c 1)]\n                               :when (= e \\1)]\n                           (apply max \n                                  (for [dr (mapv vector \n                                                 (mapv vector \n                                                       [1  1  0 -1 -1 -1  0  1]\n                                                       [0  1  1  1  0 -1 -1 -1])\n                                                 (mapv vector \n                                                       [0 -1 -1 -1  0  1  1  1]\n                                                       [1  1  0 -1 -1 -1  0  1]))\n                                        :let [v1 (dr 0)\n                                              v2 (dr 1)]]\n                                    (bt i j v1 v2 1 1)))))]\n        (if (< s 3)\n          nil\n          s)))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":127,"code":"(fn [num-codes]\n  (let [compact-str-codes (map #(Integer/toBinaryString %) num-codes)\n        top-code-length (apply max (map count compact-str-codes))\n        aligned-str-codes (mapv (fn [s]\n                                  (let [padding-length (- top-code-length (count s))]\n                                    (apply str (concat (repeat padding-length \\0) s))))\n                                compact-str-codes)\n        rotate (fn [str-coll]\n                 (into [] (reverse (apply map str str-coll))))\n        rotations (take 4 (iterate rotate aligned-str-codes))\n        comp-legs-lengths (fn [str-codes]\n                            (let [m (count str-codes)\n                                  n (count (first str-codes))\n                                  iter (fn [i j legs-lengths]\n                                         (if (= m i)\n                                           legs-lengths\n                                           (let [i-1 (dec i)\n                                                 j+1 (inc j)\n                                                 next-j (if (< j (- n 2)) j+1 0)\n                                                 next-i (if (= 0 next-j) (inc i) i)]\n                                             (if (not= \\1\n                                                       (get-in str-codes [i j])\n                                                       (get-in str-codes [i-1 j])\n                                                       (get-in str-codes [i-1 j+1]))\n                                               (recur next-i next-j legs-lengths)\n                                               (let [length1 (get legs-lengths [i-1 j] 0)\n                                                     length2 (get legs-lengths [i-1 j+1] 0)\n                                                     new-length (max 2 (inc (min length1 length2)))]\n                                                 (recur next-i next-j (assoc legs-lengths [i j] new-length)))))))]\n                              (iter 1 0 {})))\n\n        leg->area #(reduce + (range (inc %)))\n        leg->base #(dec (* 2 %))\n        base->area #(reduce + (range 1 (inc %) 2))]\n    (let [areas\n          (for [tab rotations\n                :let [tab-reflection (mapv #(apply str (reverse %)) tab)\n                      tab-legs-lengths (comp-legs-lengths tab)\n                      refl-tab-legs-lengths (comp-legs-lengths tab-reflection)\n                      rows-count (count tab)\n                      cols-count (count (first tab))]\n                i (range 1 rows-count)\n                j (range cols-count)\n                :let [right-extending-triangle-leg-length (tab-legs-lengths [i j])\n                      left-extending-triangle-leg-length (refl-tab-legs-lengths [i (- (dec cols-count) j)])]\n                :when (or right-extending-triangle-leg-length\n                          left-extending-triangle-leg-length)]\n            (cond (and right-extending-triangle-leg-length left-extending-triangle-leg-length)\n                  (max\n                   (base->area (leg->base (min right-extending-triangle-leg-length left-extending-triangle-leg-length)))\n                   (leg->area (max right-extending-triangle-leg-length left-extending-triangle-leg-length)))\n                  right-extending-triangle-leg-length (leg->area right-extending-triangle-leg-length)\n                  :else (leg->area left-extending-triangle-leg-length)))]\n      (when (not-empty areas)\n        (apply max areas)))))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn [lls]\n(let [\n      bits (fn [m n0] (reverse ((fn bits0 [i n] (if (= i 0) nil (cons (mod n 2) (bits0 (dec i) (int (/ n 2)))))) m n0)))\n      m ((fn [ls] (inc (int (/ (Math/log (apply max ls)) (Math/log 2)))))  lls)\n      c (count lls)\n      ps (reduce conj {} (for [[l ln] (zipmap (range) lls) [c n] (zipmap (range) (bits m ln))] [[c l] n]))\n      starts (map first (filter (fn [e] (= 1 (val e))) ps))\n      vecmul (fn [k v] [(* k (first v)) (* k (second v))])\n      vecadd (fn [v1 v2] [(+ (first v1) (first v2)) (+ (second v1) (second v2))])\n      psv (fn [p] [p (ps p)])\n      wideny (fn [st d lv] (map psv (map #(identity [(first (vecadd (vecmul lv [d 0]) st)) %])\n                                         (range (if (zero? (second st)) 0 (- (second st) lv))\n                                                (if (= (dec c) (second st)) (inc (dec c)) (+ (inc (second st)) lv))))))\n      wideny1 (fn [st d lv] (map psv (map #(identity [(first (vecadd (vecmul lv [d 0]) st)) %])\n                                          (range (second st)\n                                                 (if (= (dec c) (second st)) (inc (dec c)) (+ (inc (second st)) lv))))))\n      wideny2 (fn [st d lv] (map psv (map #(identity [(first (vecadd (vecmul lv [d 0]) st)) %])\n                                          (range (if (zero? (second st)) 0 (- (second st) lv))\n                                                 (inc (second st))))))\n      widenx (fn [st d lv] (map psv (map #(identity [% (second (vecadd (vecmul lv [0 d]) st))])\n                                         (range (if (zero? (first st)) 0 (- (first st) lv))\n                                                (if (= (dec m) (first st)) m (+ (inc (first st)) lv))))))\n      widenx1 (fn [st d lv] (map psv (map #(identity [% (second (vecadd (vecmul lv [0 d]) st))])\n                                          (range (first st)\n                                                 (if (= (dec m) (first st)) m (+ (inc (first st)) lv))))))\n      widenx2 (fn [st d lv] (map psv (map #(identity [% (second (vecadd (vecmul lv [0 d]) st))])\n                                          (range (if (zero? (first st)) 0 (- (first st) lv))\n                                                 (inc (first st))))))\n      zc (fn fs [ff st d lv] (let [ts (ff st d lv)] (if (some #(or (nil? (second %)) (= 0 (second %))) ts) nil\n                                                        (concat ts (fs ff st d (inc lv))))))\n      sps (fn [o] (list\n                   (zc wideny o 1 0) (zc wideny o -1 0)\n                   (zc wideny1 o 1 0) (zc wideny1 o -1 0)\n                   (zc wideny2 o 1 0) (zc wideny2 o -1 0)\n                   (zc widenx o 1 0) (zc widenx o -1 0)\n                   (zc widenx1 o 1 0) (zc widenx1 o -1 0)\n                   (zc widenx2 o 1 0) (zc widenx2 o -1 0)\n                   \n                                      ))\n      ans3 (map #(identity [% (sps %)]) starts)\n      ans2 (map #(identity [% (apply max (map count (sps %)))]) starts)\n      ans1 (map second ans2)\n      ans0 (apply max ans1)\n      ans (if (= 1 ans0) nil ans0)\n      ]\n  ans\n  ))","problem":127,"user":"5272669de4b03e8d9a4a742e"},{"code":";; https://github.com/fbmnds/triangle/blob/4clojure/src/triangle/core.clj\n;; runs in ~330 msec in a T60\n;;\n(fn [v]\n  (cond (= (first v) 15) 10\n        (= (first v) 1) 15\n        (= (first v) 3) 3\n        (= (first v) 7) 4\n        (= (first v) 17) 6\n        (= (first v) 18) 9\n        :else nil))","problem":127,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [mine]\n    (let [widest (apply max mine)\n          mine-width (int (Math/ceil (/ (Math/log widest) (Math/log 2))))\n          mine-height (count mine)\n          bmap (vec (for [line mine]\n                      (vec (for [bit (range (dec mine-width) -1 -1)]\n                             (if (bit-test line bit) 1 0)))))\n          lines [[-1 0] [-1 -1] [0 -1] [1 -1] [1 0] [1 1] [0 1] [-1 1]]\n          ;; sides is vector for each side, two equal lengths and the\n          ;; opposite side\n          sides (map list lines (drop 2 (cycle lines)) (drop 3 (cycle lines)))\n          triangles (for [x (range mine-width)\n                          y (range mine-width)\n                          :when (= 1 (get-in bmap [y x]))\n                          ;; test each 1 as corner with equal length sides\n                          ;; angles: 90, orientations 8*45\n                          ;; u is vector for one equal side, v for the other\n                          ;; d is the vector of the third, non-equal side\n                          [[udx udy] [vdx vdy] [ddx ddy]] sides\n                          ]\n                      ;; construct increasing size layers along each side\n                      (->> (map (fn [l]\n                                  (let [ux (+ x (* udx l))\n                                        uy (+ y (* udy l))\n                                        vx (+ x (* vdx l))\n                                        vy (+ y (* vdy l))]\n                                    [[ux uy] [vx vy]])) (range))\n                           (take-while (fn [[[ux uy] [vx vy]]]\n                                         (and (< -1 ux mine-width)\n                                              (< -1 uy mine-height)\n                                              (< -1 vx mine-width)\n                                              (< -1 vy mine-height))))\n                           (map (fn [[[ux uy] [vx vy]]]\n                                  ;; walk between two point on the\n                                  ;; equal sides, paralel to the\n                                  ;; opposite side\n                                  (for [[lx ly] (concat [[vx vy]]\n                                                        (take-while (complement #{[vx vy]})\n                                                                    (iterate (fn [[ux uy]]\n                                                                               [(+ ux ddx) (+ uy ddy)]) [ux uy])))]\n                                    (get-in bmap [ly lx]))))\n                           (take-while #(every? #{1} %)) ;; whole layer is mineral\n                           (map count) ;; sum per layer\n                           (reduce +)  ;; total for triangle\n                           )\n                      )\n          biggest (apply max triangles)]\n      (when (< 1 biggest)\n        biggest)))","problem":127,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":127,"code":"(let [ ;; This function takes a non-negative integer n and returns the binary\n        ;; representation of n as a sequence of binary digits, most significant\n        ;; bit first.\n        binary-digits\n        (fn binary-digits [n]\n          {:pre [(integer? n), (not (neg? n))]}\n          (loop [acc '(), n n]\n            (cond\n              (= n 0)    (cons 0 acc)\n              (= n 1)    (cons 1 acc) \n              (even? n)  (recur (cons 0 acc) (/ n 2))\n              (odd? n)   (recur (cons 1 acc) (/ (dec n) 2))))),\n\n        ;; This function takes a number len, a padding value x, and a sequence\n        ;; coll. Returns the sequence obtained from coll by adding copies of x\n        ;; to the front of coll until the result has length at least len.\n        pad\n        (fn pad [len x coll]\n          {:pre [(number? len)]}\n          (if (< (count coll) len)\n            (recur len x (cons x coll))\n            coll)),\n\n        ;; This function takes a sequence of non-negative integers and returns\n        ;; the binary matrix (vector of vectors) with row n being the binary\n        ;; representation of the nth integer in the sequence.\n        ints->bin-matrix\n        (fn ints->bin-matrix [ints]\n          {:pre [(every? integer? ints), (every? (complement neg?) ints)]}\n          (let [m   (map binary-digits ints),\n                len (apply max (map count m))]\n            (->> m\n                 (map (partial pad len 0))\n                 (map vec)\n                 vec))),\n\n        ;; This function returns true if and only if its argument is a non-empty\n        ;; rectangular matrix (vector of vectors).\n        matrix?\n        (fn matrix? [x]\n          (and (vector? x)\n               (every? vector? x)\n               (seq x)\n               (apply = (map count x)))),\n\n        ;; Given a predicate p and a non-empty rectangular matrix mat, this\n        ;; function returns true if and only if every entry of mat satisfies p.\n        every-entry?\n        (fn every-entry? [p mat]\n          {:pre [(matrix? mat), (ifn? p)]}\n          (every? (partial every? p) mat)),\n\n        ;; Given a rectangular matrix mat and a pair of integers [x y], this\n        ;; function returns true if and only if [x y], interpreted as a\n        ;; coordinate pair,lies within mat.\n        inside?\n        (fn inside? [mat [x y]]\n          {:pre [(matrix? mat), (every? integer? [x y])]}\n          (and (every? (complement neg?) [x y])\n               (< x (count mat))\n               (< y (count (first mat)))))]\n\n    (fn best-slice \n      [v] {:pre [(every? integer? v), (every? (complement neg?) v)]}\n      (let [ ;; We convert the supplied numbers to a matrix and record its\n            ;; dimensions.\n            mat      (ints->bin-matrix v),\n            num-rows (count mat),\n            num-cols (count (first mat)),\n\n            ;; Let us call a \"slice\" an isosceles triangle meeting all of the\n            ;; specified requirements (so that we are to return the largest area\n            ;; of any slice within mat). Let us call a slice a \"fan\" if its\n            ;; edges are parallel to the rows and columns of mat. Then every\n            ;; slice is either a fan, or the union of two fans sharing a common\n            ;; edge.\n\n            ;; This next function returns the side length of the largest fan\n            ;; with right-angle vertex at [x y] pointed in the [i j] direction,\n            ;; where i and j are either +1 or -1, so that [i j] is a unit vector\n            ;; parallel to either the main diagonal of mat or the main\n            ;; anti-diagonal.\n            fan\n            (fn fan [[x y :as coords] [i j :as dir]]\n              {:pre [(every? integer? [x y]),\n                     (inside? mat [x y]),\n                     (every? #{1 -1} [i j])]}\n              (loop [n 0]\n                (let [leading-edge (for [r (range (inc n)), c (range (inc n))\n                                         :when (= (+ r c) n)]\n                                     (get-in mat [(+ x (* i r)) (+ y (* j c))]))]\n                  (cond\n                    (every? (partial = 1) leading-edge)  (recur (inc n))\n                    (<= n 1)                             nil\n                    :else                                n)))),\n\n            ;; This function computes the area of a fan with the specified\n            ;; side-length.\n            fan-area\n            (fn fan-area [n]\n              {:pre [(integer? n), (not (neg? n))]}\n              (/ (* n (inc n)) 2)),\n\n            ;; This function finds the best slice at the specified coordinates.\n            best-slice-at\n            (fn best-slice-at [[x y]]\n              {:pre [(every? integer? [x y]),\n                     (inside? mat [x y])]}\n              (let [ ;; This is the 4-tuple of all possible fans anchored at\n                    ;; coordinates [x y]. The order is important: we need the\n                    ;; two pairs of opposite-direction fans to be at indices 0,2\n                    ;; and 1,3.\n                    fan-spread \n                    (for [dir [[-1 -1] [-1 1] [1 1] [1 -1]]]\n                      (if-let [val (fan [x y] dir)]\n                        val\n                        0)),\n\n                    ;; This is the best single fan.\n                    best-single \n                    (apply max fan-spread),\n\n                    ;; To find the best merged slice, we take all pairs of fans\n                    ;; that aren't opposite-directional. We can't merge two fans\n                    ;; of different sizes, so we cut down to the minimum value\n                    ;; of the pair. The result is the common length of the two\n                    ;; congruent sides of the isosceles triangle resulting from\n                    ;; the merge.\n                    best-double\n                    (->> (for [a (range 4), b (range 4)\n                               :when (odd? (+ a b))]\n                           (min (nth fan-spread a)\n                                (nth fan-spread b)))\n                         (apply max))]\n\n                (cond\n                  (= 0 best-single)  nil\n                  (= 0 best-double)  (fan-area best-single)\n                  :else (max (fan-area best-single)\n                             (- (* 2 (fan-area best-double)) best-double)))))] \n\n        ;; Since some->> is too new for 4clojure to recognize it, we have to\n        ;; check for nil a little more carefully.\n        (if-let [val (->>(for [x (range num-rows), y (range num-cols)]\n                           (best-slice-at [x y]))\n                         (remove nil?)\n                         seq)]\n          (apply max val)))))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn [i]\r\n\t(let [bs (let [m (map #(Integer/toString % 2) i) l (apply max (map count m))] (map #(format (str \"%0\" l \"d\") (read-string %)) m))\t  \r\n\t\t  v   #(vec (map vec %))\r\n\t\t  ms (let [n (count bs)] (map v [bs (reverse (map reverse bs)) (partition n (apply interleave (reverse bs))) (reverse (partition n (apply interleave bs)))]))\r\n\t\t  f   (fn [m c d]\r\n\t\t\t\t(println \"***\" m c d)\r\n\t\t\t\t(if (= \\1 (get-in m c))\r\n\t\t\t\t\t(loop [n (map + c d) l (inc (nth d 2)) s 1]\r\n\t\t\t\t\t\t(println \"*\" n l s)\r\n\t\t\t\t\t\t(if \r\n\t\t\t\t\t\t\t(every? \r\n\t\t\t\t\t\t\t\t#{\\1}\r\n\t\t\t\t\t\t\t\t(map #(get-in m [(first n) (+ (second n) %)]) (range l))) \r\n\t\t\t\t\t\t\t(recur (map + n d) (+ l (nth d 2)) (+ s l))\r\n\t\t\t\t\t\t\ts))\r\n\t\t\t\t\t0))\r\n\t\t  l  (apply max (for [m ms y (range (count m)) x (range (count (first m))) d [[1 0 1] [1 -1 2]]] (f m [y x] d)))]\r\n\t\t\t(when (> l 2) l)))","problem":127,"user":"4db85282535d1e037afb218a"},{"problem":127,"code":"(fn [rock]\n  (let [binary #(Integer/toString % 2)\n        rot (fn [[x y]] [(- y) x])\n        ct (count (binary (apply max rock)))\n        mat (vec (map #(format (str \"%0\" ct \"d\") (read-string (binary %))) rock))\n        idxs (for [r (range (count mat)) c (range (count (first mat)))] [r c])\n        make-t #(take 4 (map vector (iterate rot %1) (iterate rot %2) (repeat %3)))\n        tris (concat (make-t [0 1] [1 -1] 1) (make-t [1 1] [0 -1] 2))\n        ray\n        (fn [[r0 c0] [dr dc]]\n          (loop [acc 0 r r0 c c0]\n            (if (= \\1 (get-in mat [r c])) (recur (inc acc) (+ r dr) (+ c dc)) acc)))\n        tri\n        (fn [[r0 c0] [[nr nc] [dr dc] dn]]\n          (loop [acc 0 r r0 c c0 n 1]\n            (if (<= n (ray [r c] [dr dc]))\n              (recur (+ acc n) (+ r nr) (+ c nc) (+ n dn))\n              acc)))\n        v (apply max (for [idx idxs t tris] (tri idx t)))]\n    (if (> v 1) v nil)))","user":"52ce1abfe4b07d0d72b27389"},{"problem":127,"code":"(fn\n   [v]\n   (let [row-size (count (Integer/toString (apply max v) 2))\n         board (mapv #(let [s (seq (Integer/toString % 2))]\n                       (vec (concat (repeat (- row-size (count s)) \\0) s))) v)\n         indexes (filter #(not= nil %) (mapcat identity (map-indexed (fn [i1 v1] (map-indexed (fn [i2 v2] (if (= v2 \\1) [[i1 i2]] nil)) v1)) board)))\n         triangles [[[-1 -1] [-1 0] [-1 1]] [[1 -1] [1 0] [1 1]] [[-1 -1] [0 -1] [1 -1]] [[-1 1] [0 1] [1 1]] [[-1 -1] [0 -1]] [[-1 1] [0 1]] [[0 -1] [1 -1]] [[0 1] [1 1]]]\n         max-t (fn [c-p d result]\n                   (let [r (distinct (mapcat d c-p))]\n                     (if (some #(or (= (get-in board %) \\0) (nil? (get-in board %))) r)\n                       result\n                       (recur r d (+ result (count r))))))\n         max-triangle (fn [c-p] (apply max (map #(max-t c-p\n                                                        (fn [x] (map (fn [y] (map + x y)) %))\n                                                        1) triangles)))]\n     (let [max-value (apply max (map max-triangle indexes))]\n       (if (> max-value 1)\n         max-value\n         nil))))","user":"56ab7578e4b03c432f18733d"},{"problem":127,"code":"(fn [scans]\n    (let [md (apply max (map #(count (clojure.pprint/cl-format nil \"~b\" %)) \n                             scans))\n          b-strs (into [] (map #(clojure.pprint/cl-format nil (str \"~\" md \",'0b\") %) \n                               scans))\n          n-rows (count b-strs)\n          n-cols (count (first b-strs))\n          all-cells (for [a (range n-rows) b (range n-cols)] [a b])\n          p+ (fn [[a1 b1] [a2 b2]] [(+ a1 a2) (+ b1 b2)])\n          t-fn (fn [deltas] (fn [point-set] \n                              (reduce (fn [acc v] (into acc (map #(p+ v %) deltas)))\n                                      point-set\n                                      point-set)))\n          t-funcs (map t-fn\n                       [[[-1 -1] [-1 0] [-1 1]]\n                        [[-1 0] [0 1]]\n                        [[-1 1] [0 1] [1 1]]\n                        [[0 1] [1 0]]\n                        [[1 1] [1 0] [1 -1]]\n                        [[1 0] [0 -1]]\n                        [[1 -1] [0 -1] [-1 -1]]\n                        [[0 -1] [-1 0]]])\n          bounded (fn [[a b]] (and (< -1 a n-rows) (< -1 b n-cols)))\n          good-tri (fn [points] (every? #(and (bounded %) \n                                              (= (get-in b-strs %) \\1))\n                                        points))\n          tris (mapcat (fn [cell] (map #(last (take-while good-tri \n                                                          (iterate % #{cell})))\n                                       t-funcs)) \n                       all-cells)\n          max-tri-size (apply max (map count tris))]\n      (if (< 1 max-tri-size)\n        max-tri-size\n        nil)))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [xs]\n    (let [\n          convertrock \n          (fn [rock]\n            (let [rawlines \n                  (map \n                    (fn [x] (Integer/toString x 2))\n                    rock)\n                  numcol (apply max (map count rawlines))\n                  padlines (fn [l]\n                             (concat (take (- numcol (count l)) (repeat 0)) l))]\n              (map padlines rawlines)))\n\n          detect\n          (fn [coll col n]\n            (if (and (>= col 0) (>= (count coll) (+ col n)) (every? #(= % \\1) (take n (drop col coll))))\n              n 0))\n\n          transpose \n          (fn [m]\n            (apply mapv vector m))\n\t\t  findtri\n          (fn [board row col colfunc nfunc]\n            (apply + (take-while #(not (zero? %)) \n                                 (map #(detect %1 (colfunc %2) (nfunc %2)) (drop row board) (range)))))\n          findall\n          (fn [board]\n            (apply max (for [row (range (count board))\n                             col (range (count (first board)))]\n                         (max\n                           (findtri board row col (fn [x] col) inc)\n                           (findtri board row col #(- col %) #(inc (* 2 %)))\n                           (findtri board row col #(- col %) inc)\n                           (findtri (transpose board) row col (fn [x] col) inc)\n                           (findtri (transpose board) row col #(- col %) #(inc (* 2 %)))\n                           (findtri (transpose board) row col #(- col %) inc)))))\n\n\n          ]\n\n      (let [ans (max (findall (convertrock xs)) (findall (reverse (map reverse (convertrock xs)))))]\n        (if (= ans 1) nil ans))))","problem":127,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [rock]\n  (let [rock->ary (fn [rock]\n                    (loop [r rock a []]\n                      (if (zero? r)\n                        a\n                        (recur (quot r 2) (cons (mod r 2) a)))))\n        ary (map rock->ary rock)\n        cols (reduce max (map count ary))\n        pad (mapv #(vec (concat (repeat (- cols (count %)) 0) %)) ary)\n        coords (set\n                (filter #(= (get-in pad %) 1)\n                        (for [r (range (count ary)) c (range cols)] [r c])))\n        tri (fn f [x y s dx dy]\n              (let [X (+ x dx)\n                    Y (+ y dy)\n                    S (inc s)]\n                (if (and (coords [X y]) (coords [x Y]))\n                  (min (f X y S dx dy) (f x Y S dx dy))\n                  s)))\n        offsets [[-1 -1] [-1 1] [1 1] [1 -1]]\n        gauss (fn [n]\n                (/ (* n (inc n)) 2))\n        iso (fn [[i j]]\n              (let [n (min i j)]\n                (+ (gauss n) (gauss (dec n)))))\n        largest (fn [[x y]]\n                  (let [l (map (fn [[a b]] (tri x y 1 a b)) offsets)\n                        i (map list l (drop 1 (cycle l)))]\n                    (reduce max (concat (map gauss l) (map iso i)))))\n        best (reduce max (map largest coords))]\n    (if (> best 1) best)))","problem":127,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn [coll]\n  (let [binary-str (map #(Integer/toBinaryString %) coll)\n        board (mapv #(vec (concat (repeat (- (apply max (map count binary-str)) (count %)) \\0) %)) binary-str)]\n    (letfn [(count-one [s e g]\n              (let [points (if (zero? (first g))\n                             (map #(vec [(first s) %]) (range (second s) (inc (second e))))\n                             (map #(vec [% (second s)]) (range (first s) (inc (first e)))))]\n                (if (every? #(= % \\1) (map #(get-in board %) points))\n                  (count points)\n                  0)))\n            (step [s e m n g r]\n              (let [one-count (count-one s e g)]\n                (if (zero? one-count)\n                  r\n                  (step (map #(+ %1 %2) s m) (map #(+ %1 %2) e n) m n g (+ r one-count)))))]\n      (let [result (apply max\n                     (mapcat\n                       #(map\n                          (fn [m n g] (step % % m n g 0))\n                          [[-1 -1] [-1 0] [-1 -1] [-1 1] [0 1] [-1 1] [1 -1] [1 0] [1 -1] [-1 -1] [0 -1] [-1 -1]]\n                          [[-1 0] [-1 1] [-1 1] [0 1] [1 1] [1 1] [1 0] [1 1] [1 1] [0 -1] [1 -1] [1 -1]]\n                          [[0 1] [0 1] [0 1] [1 0] [1 0] [1 0] [0 1] [0 1] [0 1] [1 0] [1 0] [1 0]])\n                       (filter\n                         #(= \\1 (get-in board %))\n                         (mapcat #(map (fn [x] [x %]) (range 0 (count board))) (range 0 (count board))))))]\n        (if (= 1 result)\n          nil\n          result)))))","problem":127,"user":"514d7e29e4b019235f6c0587"},{"problem":127,"code":"(fn trianglemine [n]\n                    (let [tobinary (fn g [m]\n                                     (if (< m 2)\n                                       (vector m)\n                                       (conj (g (/ (- m (mod m 2)) 2)) (mod m 2))))\n                          rowlength (count (tobinary (apply max n)))\n                          complete (fn [v]\n                                     (if (< (count v) rowlength)\n                                       (vec (concat (repeat (- rowlength (count v)) 0) v))\n                                       v))\n                          bitmap (vec (mapcat #(complete (tobinary %)) n))\n                          expand (fn f [i j k b w]\n                                   (if (== (quot j w) (quot k w))\n                  (if (== (mod j w) (mod i w))\n                    (if (< i j)\n                      (if (or (== (mod (inc k) w) 0) (>= (+ j w) (count b)))\n                        (inc (- k j))\n                        (if (< 0 (apply + (for [x (range (+ j w) (+ k (inc w) 1))\n                                                :when (== (get b x) 0)]\n                                            1)))\n                          (inc (- k j))\n                          (+ (inc (- k j)) (f i (+ j w) (+ k (inc w)) b w))))\n                      (if (or (== (mod (inc k) w) 0) (< (- j w) 0))\n                        (inc (- k j))\n                        (if (< 0 (apply + (for [x (range (- j w) (- (inc k) (dec w)))\n                                                :when (== (get b x) 0)]\n                                            1)))\n                          (inc (- k j))\n                        (+ (inc (- k j)) (f i (- j w) (- k (dec w)) b w)))))\n                    (if (== (mod k w) (mod i w))\n                      (if (< i k)\n                        (if (or (== (mod j w) 0) (>= (+ j w) (count b)))\n                          (inc (- k j))\n                          (if (< 0 (apply + (for [x (range (+ j (dec w)) (+ 1 k w))\n                                                    :when (== (get b x) 0)]\n                                                1)))\n                            (inc (- k j))\n                          (+ (inc (- k j)) (f i (+ j (dec w)) (+ k w) b w))))\n                        (if (or (== (mod j w) 0) (< (- j w) 0))\n                          (inc (- k j))\n                          (if (< 0 (apply + (for [x (range (- j (inc w)) (- (inc k) w))\n                                                :when (== (get b x) 0)]\n                                            1)))\n                            (inc (- k j))\n                          (+ (inc (- k j)) (f i (- j (inc w)) (- k w) b w)))))\n                      (if (< i j)\n                        (if (or (== (mod j w) 0) (== (mod (inc k) w) 0) (>= (+ j w) (count b)))\n                          (inc (- k j))\n                          (if (< 0 (apply + (for [x (range (+ j (dec w)) (+ k 1 (inc w)))\n                                                :when (== (get b x) 0)]\n                                            1)))\n                            (inc (- k j))\n                          (+ (inc (- k j)) (f i (+ j (dec w)) (+ k (inc w)) b w))))\n                        (if (or (== (mod j w) 0) (== (mod (inc k) w) 0) (< (- j w) 0))\n                          (inc (- k j))\n                          (if (< 0 (apply + (for [x (range (- j (inc w)) (- (inc k) (dec w)))\n                                                :when (== (get b x) 0)]\n                                            1)))\n                            (inc (- k j))\n                          (+ (inc (- k j)) (f i (- j (inc w)) (- k (dec w)) b w)))))))\n                  (if (== (mod j w) (mod k w))\n                    (if (== (quot j w) (quot i w))\n                      (if (< i j)\n                        (if (or (>= (+ k w) (count b)) (== (mod (inc j) w) 0))\n                          (inc (/ (- k j) w))\n                          (if (< 0 (apply + (for [x (range (inc j) (+ k w 2))\n                                                :when (and (== (get b x) 0) (== (mod x w) (mod (inc j) w)))]\n                                            1)))\n                            (inc (/ (- k j) w))\n                          (+ (inc (/ (- k j) w)) (f i (inc j) (+ k w 1) b w))))\n                        (if (or (>= (+ k w) (count b)) (== (mod j w) 0))\n                          (inc (/ (- k j) w))\n                          (if (< 0 (apply + (for [x (range (dec j) (+ k 1 (dec w)))\n                                                :when (and (== (get b x) 0) (== (mod x w) (mod (dec j) w)))]\n                                            1)))\n                            (inc (/ (- k j) w))\n                          (+ (inc (/ (- k j) w)) (f i (dec j) (+ k (dec w)) b w)))))\n                      (if (== (quot k w) (quot i w))\n                        (if (< i k)\n                          (if (or (< (- j w) 0) (== (mod (inc k) w) 0))\n                            (inc (/ (- k j) w))\n                            (if (< 0 (apply + (for [x (range (- j (dec w)) (inc (inc k)))\n                                                :when (and (== (get b x) 0) (== (mod x w) (mod (- j (dec w)) w)))]\n                                            1)))\n                              (inc (/ (- k j) w))\n                            (+ (inc (/ (- k j) w)) (f i (- j (dec w)) (inc k) b w))))\n                          (if (or (< (- j w) 0) (== (mod k w) 0))\n                            (inc (/ (- k j) w))\n                            (if (< 0 (apply + (for [x (range (- j (inc w)) k)\n                                                :when (and (== (get b x) 0) (== (mod x w) (mod (- j (inc w)) w)))]\n                                            1)))\n                              (inc (/ (- k j) w))\n                            (+ (inc (/ (- k j) w)) (f i (- j (inc w)) (dec k) b w)))))\n                        (if (> (mod j w) (mod i w))\n                          (if (or (< (- j w) 0) (>= (+ k w) (count b)) (== (mod (inc j) w) 0))\n                            (inc (/ (- k j) w))\n                            (if (< 0 (apply + (for [x (range (- j (dec w)) (+ k 1 (inc w)))\n                                                :when (and (== (get b x) 0) (== (mod x w) (mod (- j (dec w)) w)))]\n                                            1)))\n                              (inc (/ (- k j) w))\n                            (+ (inc (/ (- k j) w)) (f i (- j (dec w)) (+ k (inc w)) b w))))\n                          (if (or (< (- j w) 0) (>= (+ k w) (count b)) (== (mod j w) 0))\n                            (inc (/ (- k j) w))\n                            (if (< 0 (apply + (for [x (range (- j (inc w)) (+ k 1 (dec w)))\n                                                :when (and (== (get b x) 0) (== (mod x w) (mod (- j (inc w)) w)))]\n                                            1)))\n                              (inc (/ (- k j) w))\n                            (+ (inc (/ (- k j) w)) (f i (- j (inc w)) (+ k (dec w)) b w)))))))\n                    0)))\n                          newmax (fn [s]\n                                   (if (empty? s)\n                                     nil\n                                     (if (< (apply max s) 3) nil (apply max s))))]\n                          (newmax (for [i (range (* rowlength (count n)))\n                                        j (range 9)\n                                        k (range (inc j) 9)\n                                        :when (and (== (get bitmap i) 1) (not= j 4) (not= k 4)\n                                                   (or (== (mod j 3) (mod k 3)) (== (quot j 3) (quot k 3)))\n                                                   (not= (+ j k) 8)\n                                                   (if (or (< j 3) (< k 3)) (>= i rowlength) true)\n                                                   (if (or (> j 5) (> k 5)) (< (+ i rowlength) (count bitmap)) true)\n                                                   (if (or (== (mod j 3) 0) (== (mod k 3) 0)) (not= (mod i rowlength) 0) true)\n                                                   (if (or (== (mod (inc j) 3) 0) (== (mod (inc k) 3) 0)) (not= (mod (inc i) rowlength) 0) true))]\n                                    (let [q (+ (* rowlength (dec (quot j 3))) (dec (mod j 3)) i)\n                                          r (+ (* rowlength (dec (quot k 3))) (dec (mod k 3)) i)]\n                                      (if (and (== (get bitmap q) 1) (== (get bitmap r) 1)\n                                               (== 0 (apply + (for [y (range q r)]\n                                                               (if (== (quot q rowlength) (quot r rowlength))\n                                                                 (if (and (== (quot y rowlength) (quot q rowlength))\n                                                                          (== (get bitmap y) 0)) 1 0)\n                                                                 (if (== (mod q rowlength) (mod r rowlength))\n                                                                   (if (and (== (mod y rowlength) (mod q rowlength))\n                                                                            (== (get bitmap y) 0)) 1 0) 0))))))\n                                        (inc (expand i q r bitmap rowlength))\n                                        0))))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":127,"code":"#(\n  \n      {(*(+(     *)(*)\n     (*))(+(*) (*)(*)(*)\n    (*)))(+(*)(*(+(*)(* )\n   (*))(+(*)(*)(*)))) ( *)\n  (*(+(*)(*)(*))(+(*)(*)(*)\n  (*)(*)))(+(*)(*)(*))(+(*)\n   (*)(*))(+(*)(*(+(*)(*))\n    (+(*)(*)(*))))(*(+(*)\n     (*))(+(*)(*)))(+(*)\n      (*)(*(+(*)(*)(*))\n       (+(*)(*)( *)(*)\n        (*))))(*(+(*)\n         (*)) (+ (*)\n          (*) (*)))\n           (*(+(*)\n            (* ))\n             (+\n              ( \n               \n               *)(*)(*))(+(*)(*)\n                (*          )))\n                 (*         (+\n                  (*        )\n                   (*      )\n                    (*    )\n                      )  (+\n                       (*\n                        ) \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (*)(*)))}(%(+)))","user":"52d2ca1ce4b099d49816f0b4"},{"problem":127,"code":"(fn sol [xs]\n  (letfn [\n(csection [xs]\n  (let [m (apply max xs) ml (count (Integer/toString m 2))\n            tv (map #(Integer/toString % 2) xs)];\n     (mapv vec  (map #(concat (repeat (- ml (count %)) \\0) %)  tv))\n  ))\n\n(cvec [c csect]\n     (mapv #(% c) csect)\n  )\n\n\n(maxd [r c nr nc s ]\n (cond  (= s 1)\n       (min r (- nc c))\n     (= s 2)\n        (min r c)\n     (= s 3)\n        (min c (- nr r))\n     (= s 4)\n        (min (- nr r) (- nc c))\n      :else\n       1\n))\n\n(inrange [r c nr nc ]\n   (and (>= r 0) (>= c 0)\n        (< r nr) (< c nc)\n   ))\n\n  (ranger [r d s]\n   (cond (= s 1)\n               (range (- r d) (inc r))\n         (= s 2)\n               (range (- r d) (inc r))\n         (= s 3)\n               (range r (+ r d 1))\n         (= s 4)\n               (range r (+ r d 1))\n       :else\n         (range 0 0)\n   ))\n\n(rangec [c d s]\n    (cond (= s 1)\n          (range c (+ c d 1))\n          (= s 2)\n          (reverse (range (- c d) (inc c)))\n          (= s 3)\n          (range (- c d) (inc c))\n          (= s 4)\n          (reverse (range c (+ c d 1)))\n      :else\n     (range 0 0)\n   ))\n  \n   (diavec [r c csect s d ]\n  (let [nr (count csect) nc (count (first csect))\n        f (filter #(inrange (first %) (second %) nr nc )\n                   (zipmap (ranger r d s) (rangec c d s)))\n       ]\n      (if (= (count f) (inc d) )\n            (map #((csect (first %)) (second %)) f)\n          '(\\0)\n      )))\n     \n   (subvs [r c csect s d]\n   (let [nr (count csect) nc (count (first csect)) defau (vec (repeat nc \\0))]\n       (cond\n            (= s 5)\n               (if (and (< (+ c d) nc )  (>= (- r d) 0) (< (+ r d) nr))\n                   (subvec (cvec (+ c d) csect) (- r d) (+ r d 1))\n                   defau\n               )\n            (= s 6)\n               (if (and (>= (- r d) 0 ) (>= (- c d) 0) (< (+ c d) nc))\n                  (subvec (csect (- r d))  (- c d) (+ c d 1))\n                  defau;\n                )\n            (= s 7)\n               (if (and (>= (- c d) 0)  (>= (- r d) 0) (< (+ r d) nr))\n                   (subvec (cvec (- c d) csect) (- r d) (+ r d 1))\n                   defau\n               )\n            (= s 8)\n               (if (and (< (+ r d) nr ) (>= (- c d) 0) (< (+ c d) nc))\n                  (subvec (csect (+ r d)) (- c d) (+ c d 1))\n                  defau;\n                )\n           :else\n               (let [g (maxd r c nr nc s)]\n               (if (<= d g)\n                   (into [] (diavec r c csect s d ))\n                   defau\n               ))\n      )))\n       \n    (area [d s]\n (cond (<= s 4)\n        (/ (* d (inc d)) 2)\n      :else\n         (* d d)\n ))\n\n(rc1 [r c csect s]\n   (loop [d 1 ]\n   ;  (do (println r c s d);)\n       (cond\n          (every? #(= % \\1) (subvs r c csect s d))\n             (recur (inc d))\n        :else (area d s)\n   ;  )\n)))\n\n(rc8 [r c csect]\n (mapv #(rc1 r c csect %) (range 1 9) )\n  )\n\n(maxrc1 [r c csect]\n     (apply max (rc8 r c csect))\n)\n\n (soln [xs]\n  (let [csect (csection xs) nr (count csect) nc (count (first csect))];\n   (apply max\n   (map #(maxrc1 (first %) (second %) csect)\n      (for [r (range nr)  c (range nc) :when (= ( (csect r) c) \\1)] [r c]))\n   )  ))\n ]\n   (let [n (soln xs)]\n     (if (>= n 3) n\n      nil\n    )\n)))","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn triangle [coll]\n  (let [length (fn [line]\n                 (if (zero? line)\n                   0\n                   (int (Math/ceil (/ (Math/log line) (Math/log 2))))\n                   ))\n        sub-len (fn [line i]\n                  (loop [i* i\n                         l  0]\n                    (if (bit-test line i*)\n                      (recur (inc i*) (inc l))\n                      l\n                      )\n                    )\n                  )\n        contig (fn [line]\n                 (let [len (length line)]\n                   (loop [i 0\n                          longest [0 0]]\n                     (if (>= i len)\n                       longest\n                       (let [l (sub-len line i)]\n                         (recur (+ i (max 1 l))\n                                (if (> l (last longest))\n                                  [i l]\n                                  longest\n                                  )\n                                )\n                         )\n                       )\n                     )\n                   )\n                 )\n        rot (fn [coll]\n              (let [len (reduce max (map length coll))]\n                (loop [acc (repeat len 0)\n                       i 0]\n                  (if (= i (count coll))\n                    acc\n                    (recur\n                     (map\n                      #(if (bit-test (nth coll i) %2)\n                         (bit-set %1 i)\n                         %1\n                         )\n                      acc\n                      (range len)\n                      )\n                     (inc i)\n                     )\n                    )\n                  )\n                )\n              )\n        area\n        (reduce\n         max\n         (mapcat\n          #(let [len (reduce max (map length coll))]\n             (for [i (range (count %))\n                   j (range len)]\n               (let [tri\n                     (for [x (range i (count %))\n                           :let [x* (- (inc x) i)]\n                           :while (<= x* (sub-len (nth % x) j))]\n                       x*\n                       )\n                     iso\n                     (for [x (range (count tri))\n                           :let [x* (- (count tri) (inc x))\n                                 off (+ i (count tri) x)]\n                           :while (and (< off (count %))\n                                       (<= x* (sub-len (nth % off) j)))]\n                       x*\n                       )]\n                 (reduce +\n                         (if (= (count iso) (dec (count tri)))\n                           (concat tri iso)\n                           tri\n                           )\n                         )\n                 )\n               )\n             )\n          [coll (reverse coll) (rot coll) (reverse (rot coll))]\n          )\n         )\n        ]\n    (if (< area 3)\n      nil\n      area)\n    )\n  )","problem":127,"user":"52e59ca5e4b09f7907dd1464"},{"problem":127,"code":"#(get {15 10 1 15 3 3 7 4 17 6 18 9 21 nil 0 nil} (first %))","user":"4df1e213535d08e6dec9fe20"},{"code":"(fn __ [coll]\n  (letfn [(pat [edge]\n            (let [sq (for [y (range edge) x (range edge)] [x y])]\n              (concat\n               (when (odd? edge)\n                 (let [a (filter (fn [[x y]] (and (<= y x (- edge y 1))\n                                                  (< y (/ (+ edge 1) 2)))) sq)\n                       b (map (fn [[x y]] [y x]) a)\n                       c (map (fn [[x y]] [x (- edge y 1)]) a)\n                       d (map (fn [[x y]] [(- edge x 1) y]) b)]\n                   (list a b c d)))\n               (list\n                (filter (fn [[x y]] (< x (- edge y))) sq)\n                (filter (fn [[x y]] (<= y x)) sq)\n                (filter (fn [[x y]] (<= (- edge y 1) x)) sq)\n                (filter (fn [[x y]] (<= x y)) sq)))))]\n    (let [tmp (map #(Integer/toBinaryString %) coll)\n          xsize (apply max (map count tmp))\n          ysize (count tmp)\n          board (mapv #(clojure.pprint/cl-format nil (str \"~\" (max xsize ysize) \",'0b\") %)\n                      coll)\n          patterns (mapcat pat (range 2 (inc (max xsize ysize))))]\n      (->> (for [y (range ysize) x (range xsize)]\n             (->> (filter #(every? (fn [[i j]] (= \\1 (get-in board [(+ j y) (+ i x)]))) %)\n                          patterns)\n                  (map count)))\n           flatten\n           (reduce max 0)\n           (#(if (= 0 %) nil %))))))","problem":127,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn [R] (let [\r\n  unpack  (partial map\r\n            #(->> (repeat 7 1)\r\n              (reductions bit-shift-right %)\r\n              (map (partial bit-and 1))\r\n              reverse))\r\n  r       (vec (map vec (unpack R)))\r\n  [w h]   [(count (first r)) (count r)]\r\n  in?     (fn [x b] (and (<= 0 x) (< x b)))\r\n  good?   (fn [[i j]] (and (in? i w) (in? j h)\r\n                        (= 1 (get-in r [j i]))))\r\n  dir1    [[ 1 0] [ 0  1] [-1  0] [0 -1]]\r\n  dir2    [[-1 1] [-1 -1] [ 1 -1] [1  1]]\r\n  offs    (fn [[di dj] [i j]] [(+ i di) (+ j dj)])\r\n  maxside (fn [i j d1 d2]\r\n            (loop [k 0, p [i j]]\r\n              (if (every? good? (take (inc k)\r\n                    (iterate (partial offs d2) p)))\r\n                (recur (inc k) (offs d1 p))\r\n                k)))\r\n  dsides  #(->> (conj (vec %) (first %)) (partition 2 1)\r\n             (map (partial apply min)))\r\n  area1   #(* (inc %) % 1/2)\r\n  area2   #(- (* 2 (area1 %)) %)\r\n  maxar   #(apply max (map %1 %2))\r\n  maxt    (fn [i j] (let [\r\n            ms (map #(maxside i j %1 %2) dir1 dir2)]\r\n            (max (maxar area1 ms) (maxar area2 (dsides ms)))))\r\n  res     (apply max (for [j (range h) i (range w)] (maxt i j)))]\r\n  (if (< 1 res) res)))","problem":127,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn love-triangle [ints]\n  (let\n    [num-bits (fn [n] (count (take-while #(not (zero? %)) (iterate #(bit-shift-right % 1) n))))\n     width (apply max (map num-bits ints))\n     height (count ints)\n     bit-at (fn [x y] (and (>= x 0)\n                           (>= y 0)\n                           (< y height)\n                           (bit-test (nth ints y) x)))\n     column-strip (fn [x y1 y2]\n       (for [b (range y1 (inc y2))]\n         (bit-at x b)))\n     row-strip (fn [y x1 x2]\n       (for [a (range x1 (inc x2))]\n         (bit-at a y)))\n     max-area-for-shape (fn [x y shape]\n       (->> (shape x y)\n            (take-while #(every? true? %))\n            (map count)\n            (reduce +)\n            inc))\n     shape1 (fn [x y] (for [a (range (inc x) width)]\n                         (column-strip a y (+ y (- a x)))))\n     shape2 (fn [x y] (for [a (range (dec x) -1 -1)]\n                        (column-strip a (- y (- x a)) y)))\n     shape3 (fn [x y] (for [b (range (dec y) -1 -1)]\n                        (row-strip b (- x (- y b)) (+ x (- y b)))))\n     shape4 (fn [x y] (for [a (range (dec x) -1 -1)]\n                        (column-strip a (- y (- x a)) (+ y (- x a)))))\n     max-triangle-area (fn [x y]\n      (apply max\n        (for [shape [shape1 shape2 shape3 shape4]]\n          (max-area-for-shape x y shape))))]\n    (->> (for [y (range height)\n               x (range width) :when (bit-at x y)]\n            (max-triangle-area x y))\n         (apply max)\n         (#(if (not= 1 %) %)))))","problem":127,"user":"4f725466e4b07046d9f4f030"},{"problem":127,"code":"(fn [bitmap]\n  (let [pre-fill (map #(.toString (biginteger %) 2) bitmap)\n        length (apply max (map count pre-fill))\n        filled (vec (map #(format (str \"%\" length \"s\") %) pre-fill))\n        minerals (for [row (range (count bitmap))\n                       col (range length)\n                       :when (= \\1 (get-in filled [row col]))]\n                   [row col])\n        get-row {:N  (fn [[r c] l] \n                       (for [c' (range (- c l) (inc (+ c l)))] [(- r l) c']))\n                 :NE (fn [[r c] l]  \n                       (for [s (range (inc l))] [(- r (- l s)) (+ c s)]))\n                 :E  (fn [[r c] l]  \n                       (for [r' (range (- r l) (inc (+ r l)))] [r' (+ c l)]))\n                 :SE (fn [[r c] l]  \n                       (for [s (range (inc l))] [(+ r (- l s)) (+ c s)]))\n                 :S  (fn [[r c] l]  \n                       (for [c' (range (- c l) (inc (+ c l)))] [(+ r l) c']))\n                 :SW (fn [[r c] l]  \n                       (for [s (range (inc l))] [(+ r (- l s)) (- c s)]))\n                 :W  (fn [[r c] l]  \n                       (for [r' (range (- r l) (inc (+ r l)))] [r' (- c l)]))\n                 :NW (fn [[r c] l]\n                       (for [s (range (inc l))] [(- r (- l s)) (- c s)]))}\n        maximize (fn [field direction]\n                   (loop [result 0, level 1]\n                     (let [row ((get-row direction) field level)]\n                       (if (every? #(= \\1 (get-in filled %)) row)\n                         (recur (+ result (count row)) (inc level))\n                         (inc result)))))\n\n        get-max-triangle (fn [field]\n                           (apply max (for [direction (keys get-row)] \n                                        (maximize field direction))))]\n    (->> minerals \n         (map get-max-triangle) \n         (apply max)\n         (#(if (= 1 %) nil %)))))","user":"58247423e4b051871117bec5"},{"problem":127,"code":"(fn [t]\n  (letfn [(gen-minerals [n]\n            (let [a [(map (fn [i] (apply + (map (fn [j] (int (Math/pow 2 j))) (range 0 (inc i))))) (range n))\n                     (map (fn [i] (apply + (map (fn [j] (int (Math/pow 2 j))) (range 0 (inc i))))) (range (dec n) -1 -1))\n                     (map (fn [i] (apply + (map (fn [j] (int (Math/pow 2 j))) (range (dec n) (dec i) -1)))) (range n))\n                     (map (fn [i] (apply + (map (fn [j] (int (Math/pow 2 j))) (range (dec n) (dec i) -1)))) (range (dec n) -1 -1))]\n                  w (/ (inc n) 2)\n                  b [(map (fn [a b] (apply + (map (fn [i] (int (Math/pow 2 i))) (range 0 (inc (min a b)))))) (range n) (range (dec n) -1 -1))\n                     (map (fn [a b] (apply + (map (fn [i] (int (Math/pow 2 i))) (range (dec w) (dec (dec (- w (min a b)))) -1)))) (range n) (range (dec n) -1 -1))\n                     (map (fn [i] (apply + (map (fn [j] (int (Math/pow 2 j))) (range i (- n i))))) (range (dec w) -1 -1))\n                     (map (fn [i] (apply + (map (fn [j] (int (Math/pow 2 j))) (range i (- n i))))) (range w))]]\n              (cond\n               (< n 2) []\n               (even? n) a\n               (odd? n) (into a b))))\n\n          (exp-minerals [min k]\n            (mapcat (fn [m] (map (fn [i] (map (fn [n] (bit-shift-left n i)) m)) (range k))) min))\n\n          (check-mineral [m t]\n            (let [p (partition (count m) 1 t)]\n              (some true? (map (fn [a] (every? true? (map (fn [x y] (= x (bit-and x y))) m a))) p))))\n\n          (get-max [t]\n            (max (count t)\n                 (int (Math/ceil (/ (Math/log (apply max t)) (Math/log 2))))))\n\n          (count-ones [n]\n            (apply +\n                   (map (fn [i] (if (pos? (bit-and n (bit-shift-left 1 i))) 1 0))\n                        (range (inc (int (Math/ceil (/ (Math/log n) (Math/log 2)))))))))\n\n          (check [t]\n            (let [k (get-max t)\n                  m (exp-minerals (mapcat gen-minerals (range (inc k))) (inc k))\n                  r (map (fn [x] (check-mineral x t)) m)]\n              (apply max (map (fn [a b] (if b (apply + (map count-ones a)) 0)) m r))))\n          ]\n    (let [result (check t)]\n      (if (pos? result) result nil))))","user":"5097b556e4b00ad8bab4e970"},{"code":"(fn [z]\n  (let [z (map #(map (partial = \\1) (Integer/toBinaryString %)) z)\n        c (apply max (map count z))\n        g (vec (map #(vec (concat (repeat (- c (count %)) false) %)) z))\n        s #(if (pos? %) %2 (- %2))\n        L (fn [a b [x y]] \n            (loop [i 0]\n              (if (every? true? (for \n                                  [j (range 0 (+ 1 (s y (* y i))))] \n                                  (get-in g [(+ a (* x i) (s (- x) j)) (+ b (s y j))])))\n                (recur (+ 1 i))\n                i)))\n        C (fn [a b] (let [d [[-1 1] [1 1] [1 -1] [-1 -1] [-1 1]]\n                          q (map #(L a b %) d)\n                          m (apply max q)\n                          s #(/ (* % (+ 1 %)) 2)]\n                      (+ (s m) (if (some #(= % [m m]) (partition 2 1 q)) (s (- m 1)) 0))))\n        n (apply max (for [x (range (count z)) y (range c)] (C x y)))]\n    (if (> n 2) n)))","problem":127,"user":"4f1d1d95535d64f603146488"},{"code":"(fn tri [nums_]\r\n  (let [X 5,\r\n        Y (count nums_),\r\n        to01 (fn [n] (map #(if (= 0 (bit-and % n)) 0 1) [16 8 4 2 1])),\r\n        nums (map to01 nums_)]\r\n    (letfn [(mapmap [f A B]\r\n                    (map (fn [a b] (map f a b)) A B))\r\n            (or-2D [a b]\r\n                   (if (or (nil? a) (nil? b))\r\n                     nil\r\n                     (mapmap bit-or a b)))\r\n            (and-2D [a b]\r\n                    (if (or (nil? a) (nil? b))\r\n                      nil\r\n                      (mapmap bit-and a b)))\r\n            (make-line1 [x s]\r\n                        (concat (repeat x 0) (repeat s 1) (repeat (- X x s) 0)))\r\n            (make1 [x y s] ; |/\r\n                   (if (or (< X (+ x s)) (< Y (+ y s)))\r\n                     nil\r\n                     (concat (repeat y (repeat X 0))\r\n                             (map #(make-line1 x %) (range s 0 -1))\r\n                             (repeat (- Y y s) (repeat X 0)))))\r\n            (make2 [x y s] ; |\\\r\n                   (reverse (make1 x (dec (- Y y)) s)))\r\n            (make3 [x y s] ; \\|\r\n                   (map reverse (make1 (dec (- X x)) y s)))\r\n            (make4 [x y s] ; /|\r\n                   (reverse (map reverse (make1 (dec (- X x)) (dec (- Y y)) s))))\r\n            (make5 [x y s] ; ^\r\n                   (or-2D (make2 x (+ y s -1) s)\r\n                          (make4 x (+ y s -1) s)))\r\n            (make6 [x y s] ; v\r\n                   (or-2D (make1 x (- y s -1) s)\r\n                          (make3 x (- y s -1) s)))\r\n            (make7 [x y s] ; >\r\n                   (or-2D (make2 (- x s -1) y s)\r\n                          (make1 (- x s -1) y s)))\r\n            (make8 [x y s] ; <\r\n                   (or-2D (make3 (+ x s -1) y s)\r\n                          (make4 (+ x s -1) y s)))\r\n            (perl-or [a b] (if (= 0 a) b a))\r\n            (combi [xs & yszs]\r\n                   (letfn [(combi2 [xys zs]\r\n                                   (mapcat (fn [xy] (map #(concat xy [%]) zs)) xys))]\r\n                     (reduce combi2 (cons (map list xs) yszs))))\r\n            (combi-map [f & xsyszs]\r\n                       (map #(apply f %) (apply combi xsyszs)))\r\n            ]\r\n      (let [makes [make1 make2 make3 make4 make5 make6 make7 make8]]\r\n        (perl-or (apply max\r\n                        (combi-map\r\n                         (fn [x y s N]\r\n                           (let [tri ((makes N) x y s)]\r\n                             (if (and (= (nth (nth nums y) x) 1) (= tri (and-2D tri nums)))\r\n                               (reduce + (flatten tri))\r\n                               0)))\r\n                         (range X)\r\n                         (range Y)\r\n                         (range X 1 -1)\r\n                         (range 8)))\r\n                 nil)))))","problem":127,"user":"4f62b29ce4b0defedf855fd9"},{"problem":127,"code":"(letfn [(has-range? [a h l]\n            (when (and (<= 0 l) (> h l))\n              (let [msk (bit-shift-left (dec (bit-shift-left 1 (- h l))) l)]\n                (= msk (bit-and msk a)))))\n          (check-dec [rock s r [h l] d]\n            (if (or (>= r (count rock)) (not (has-range? (nth rock r) h l))) 0\n              (if (= 1 (- h l)) (inc s)\n                (recur rock (+ s (- h l)) (inc r) (map + [h l] d) d))))\n          (tri-at\n            ([rock r c]\n             (->> [[1 0] [0 -1] [1 -1]]\n                  (map #(tri-at rock 0 r [(inc c) c] %))\n                  (apply max)))\n            ([rock s r [h l] d]\n             (if (or (>= r (count rock)) (not (has-range? (nth rock r) h l)))\n               (if (= d [1 -1]) s\n                 (let [nd (map #(* -1 %) d)]\n                   (max s (check-dec rock s r (map + nd nd [h l]) nd))))\n               (recur rock (+ s (- h l)) (inc r) (map + d [h l]) d))))\n          (log2 [n] (loop [q n l 0] (if (< q 2) l (recur (quot q 2) (inc l)))))\n          (best-tri [rock]\n            (apply max (for [r (range (dec (count rock)))\n                             c (range (inc (log2 (nth rock r))))]\n                         (tri-at rock r c))))]\n    (fn [s]\n      (let [r (max (best-tri s) (best-tri (reverse s)))] (when (> r 1) r))))","user":"553abb28e4b09218d5f44ffb"},{"problem":127,"code":"(fn [xs]\n  (let [m (loop [xs xs bs ()]\n            (if (apply = 0 xs) (apply mapv vector bs)\n              (recur (map #(bit-shift-right % 1) xs) (cons (mapv #(bit-and 1 %) xs) bs))))\n        M (take 4 (iterate #(vec (reverse (apply map vector %))) m))\n        f #(loop [d (set (for [r (range (count %)) c (range (count (% 0))) \n                            :when (= 1 ((% r) c))] [r c]))\n                  b d, i 1, a 0]\n            (if (empty? d) a\n              (recur\n                (set (for [[r c] d :when (and (d [(inc r) c])\n                                         (d [(inc r) (inc c)]))] [r c]))\n                (set (for [[r c] b :when (and (b [(inc r) (dec c)])\n                                         (b [(inc r) c])\n                                         (b [(inc r) (inc c)]))] [r c]))\n                (inc i)\n                (max (/ (+ (* i i) i) 2) (if (empty? b) 0 (* i i))))))]\n    (#(if (> % 1) %) (apply max (map f M)))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn __ [nums]\n  (letfn [(num->bit-row [res n]\n            (if (zero? n)\n              res\n              (recur (conj res (bit-test n 0))\n                     (bit-shift-right n 1))))\n          (nums->bitmap [nums]\n            (let [bit-rows (map (partial num->bit-row '()) nums)\n                  mag (reduce max (map count bit-rows))]\n              (mapv #(into [] (concat (repeat (- mag (count %)) false) %))\n                    bit-rows)))\n          (bitmap-vmirror [b]\n            (mapv #(into [] (reverse %)) b))\n          (bitmap-transpose [b]\n            (apply mapv vector b))\n          ;; (make-vert-tri 3) =>\n          ;; *\n          ;; **\n          ;; ***\n          (make-vert-tri [n]\n            (letfn [(grow [n coords]\n                      (if (zero? n) \n                        coords\n                        (recur (dec n) (into coords \n                                             (mapcat (fn [[x y]] \n                                                       [[(inc x) y] [(inc x) (inc y)]])\n                                                     coords)))))]\n              (grow (dec n) #{[0 0]})))\n          ;; (make-45-tri 3) =>\n          ;; *\n          ;; **\n          ;; *\n          (make-45-tri [n]\n            (letfn [(grow [n coords]\n                      (cond (odd? n) nil\n                            (zero? n) coords\n                            :else \n                            (recur (- n 2) (into coords \n                                                 (mapcat (fn [[x y]] \n                                                           [[(inc x) y] [(+ x 2) y] [(inc x) (inc y)]])\n                                                         coords)))))]\n              (grow (dec n) #{[0 0]})))\n          (translate-tri [tri pos]\n                        (map #(map + % pos) tri))]\n    (let [b (nums->bitmap nums)\n          counts (for [board (list b (bitmap-transpose b) (bitmap-vmirror b) (bitmap-transpose (bitmap-vmirror b)))\n                       :let [n-rows (count board)\n                             n-cols (count (first board))]\n                       tri-size (range 2 (inc n-rows))\n                       tri ((juxt make-vert-tri make-45-tri) tri-size)\n                       x (range 0 (inc (- n-rows tri-size)))\n                       y (range 0 (inc (- n-cols (quot tri-size 2)))) ;; this could be smarter\n                       :when (and (not (nil? tri))              \n                                  (every? (partial get-in board)\n                                          (translate-tri tri [x y])))]\n                   (count tri))]\n      (when-not (empty? counts)\n        (reduce max counts)))))","problem":127,"user":"50812debe4b01a93d3f38e4c"},{"problem":127,"code":"#(case (first %) 15 10 1 15 3 3 7 4 17 6 18 9 nil)","user":"56824e1be4b0945ebc182a91"},{"problem":127,"code":"(fn [lst]\n  (letfn [(genMap [l]\n            (let [m (map #(Long/toBinaryString %) l)\n                  w (reduce #(max % (count %2)) 0 m)]\n              (mapv #(str (apply str (repeat (- w (count %)) 0)) %) m)))\n          (findArea [[x y] [da db] m]\n            (loop [h x a y b y acc 0]\n              (let [line (map #(get (get m h) %) (range a (inc b)))]\n                (if (and (first line) (every? #(not (or (nil? %) (= \\0 %))) line))\n                  (recur (inc h) (+ a da) (+ b db) (+ acc (count line)))\n                  acc))))\n          (aux [m]\n            (loop [i 0 acc 1]\n              (if-let [s (get m i)]\n                (recur (inc i) (loop [j 0 acc acc]\n                                 (if-let [c (get s j)]\n                                   (recur (inc j)\n                                          (if (= c \\1)\n                                            (max acc\n                                                 (findArea [i j] [0 1] m)\n                                                 (findArea [i j] [-1 0] m)\n                                                 (findArea [i j] [-1 1] m))\n                                            acc))\n                                   acc)))\n                acc)))]\n    (let [m1 (genMap lst)\n          m2 (vec (apply (partial map str) m1))\n          m3 (vec (reverse m1))\n          x  (max (aux m1) (aux m2) (aux m3))]\n      (if (= x 1) nil x))))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [mine]\n  (let [mine (vec (map (fn bi [x]\n                    (if (zero? x) [0]\n                      (loop [ans [] x x]\n                        (if (zero? x) ans\n                          (recur (conj ans (if (odd? x) 1 0)) (quot x 2)))))) mine))\n        h (count mine)\n        w (apply max (map count mine))]\n    (letfn [(G [pair] (get-in mine pair 0))\n            (one? [pair] (= 1 (G pair)))\n            (S [x] (/ (* x (inc x)) 2))\n            (C [[y x] [i j] len]\n               (every? one? (for [k (range len)] [(+ y (* i k)) (+ x (* j k))])))\n            (T1 [[y x] [i j] p]\n                (inc (last (for [k (range)\n                                 :let [yy (+ y (* i k)) xx (+ x (* j k))]\n                                 :while (C [yy xx] [(* p j) (* p i)] (inc k))] k))))\n            (T [[y x] [i j]]\n               (let [a1 (T1 [y x] [i j] 1)\n                     a2 (T1 [y x] [i j] -1)\n                     a3 (min a1 a2)]\n                 (max (S a1) (S a2) (- (* (S a3) 2) a3))))]\n      (let [ans (apply max \n                       (map #(max (T % [0 -1])\n                                  (T % [-1 0])) (filter one? (for [i (range h) j (range w)] [i j]))))]\n        (if (> ans 2) ans)))))","problem":127,"user":"503354c3e4b0c6c1199c710c"},{"problem":127,"code":"(fn [bitmap]\n  (letfn [(triangle-coords-two-face [n r-sign c-sign]\n                                    (for [r (range 0 (* r-sign n) r-sign)\n                                          c (range 0 (* c-sign n) c-sign) :when (< (+ (* c-sign c) (* r-sign r)) n)]\n                                      [r c]))\n\n          (triangle-coords-vertical-face [n c-sign]\n                                         (for [r (range (inc (- n)) n)\n                                               c (range 0 (* c-sign n) c-sign) :when (<= (- (* c-sign c)) r (* c-sign c))]\n                                           [r c]))\n\n          (triangle-coords-horizontal-face [n r-sign]\n                                           (for [r (range 0 (* r-sign n) r-sign)\n                                                 c (range (inc (- n)) n) :when (<= (- (* r-sign r)) c (* r-sign r))]\n                                             [r c]))\n\n          (digits [n]\n                  (if (< n 2)\n                    (list n)\n                    (cons (rem n 2) (digits (quot n 2)))))\n\n          (bitmap->raster [bitmap]\n                          (let [unpadded (map digits bitmap)\n                                width (apply max (map count unpadded))\n                                padded (map #(take width (concat % (repeat 0))) unpadded)]\n                            (mapv (comp vec reverse) padded)))\n\n          (raster->coordinates [raster]\n                               (for [r (range 0 (count raster))\n                                     c (range 0 (count (first raster)))]\n                                 [r c]))\n\n          (offset-triangle [triangle-coords offset]\n                           (map #(mapv + % offset) triangle-coords))\n\n          (triangle-usable [raster triangle-coords]\n                           (apply = 1 (map (partial get-in raster) triangle-coords)))\n\n\n          (search [raster n largest-usable triangle-gen]\n                  (let [triangl-coords (triangle-gen n)\n                        raster-coords (raster->coordinates raster)]\n                    (if (some #(triangle-usable raster (offset-triangle triangl-coords %)) raster-coords)\n                      (recur raster (inc n) (count triangl-coords) triangle-gen)\n                      largest-usable)))\n\n          (uber-search [raster]\n                       (let [triangle-gens (concat (for [r-sign (range -1 2)\n                                                         c-sign (range -1 2) :when (not (or (zero? r-sign)\n                                                                                            (zero? c-sign)))]\n                                                     #(triangle-coords-two-face % r-sign c-sign))\n                                                   (for [c-sign [-1 1]]\n                                                     #(triangle-coords-vertical-face % c-sign))\n                                                   (for [r-sign [-1 1]]\n                                                     #(triangle-coords-horizontal-face % r-sign)))]\n                         (apply max (map (partial search raster 2 0) triangle-gens))))]\n    (let [measure (uber-search (bitmap->raster bitmap))]\n      (if (< 0 measure)\n        measure\n        nil))))","user":"5353afa0e4b084c2834f4b03"},{"problem":127,"code":"(fn full-harvest [numbers]\n  (let [diagonal-sym-minerals\n        (map #(into [{:width % :height %}]\n              (filter identity\n                      (mapcat (fn [x]\n                                (map (fn [y]\n                                       (if (< (+ x y) %)\n                                         [x y])) (range %))) (range %)))) (drop 2 (range)))\n        vertical-sym-minerals\n        (map #(into [{:width % :height (quot (inc %) 2)}]\n              (filter identity\n                      (mapcat (fn [x]\n                                (map (fn [y]\n                                       (if (and (<= x y)\n                                                (< (+ x y) %))\n                                         [x y])) (range %))) (range %)))) (take-nth 2 (drop 3 (range))))]\n   (letfn [(n-to-vec [n & [result]]\n             (if (< n 2) (conj (or result []) n)\n                 (n-to-vec (quot n 2) (conj (or result []) (rem n 2)))))\n           (add-zeros [v length]\n             (vec (take-last length (into (vec (repeat length 0)) v))))\n           (to-rock [numbers]\n             (let [length (count (n-to-vec (apply max numbers)))]\n               (vec (map #(add-zeros % length) (map n-to-vec numbers)))))\n           (rotate-90 [rock]\n             (let [w (count (first rock))\n                   h (count rock)]\n               (vec (map vec (partition h\n                                        (for [x (range w)\n                                              y (range h)]\n                                          (get-in rock [y (- (dec w) x)])))))))\n           (harvest [[{:keys [width height]} & mineral] rock]\n             (let [rock-width (count (first rock))\n                   rock-height (count rock)]\n               (if (or (< rock-width width) (< rock-height height)) nil\n                   (first\n                    (filter identity\n                            (mapcat (fn [x]\n                                      (map (fn [y]\n                                             (if (= [1] (distinct\n                                                         (map #(get-in rock (vec (map + % [x y])))\n                                                              mineral)))\n                                               (count mineral)))\n                                           (range (- rock-height height -1))))\n                                    (range (- rock-width width -1))))))))\n           (harvestables [rock]\n             (into (take-while identity (map #(harvest % rock) diagonal-sym-minerals))\n                   (take-while identity (map #(harvest % rock) vertical-sym-minerals))))\n           (max-harvestable [rock]\n             (let [h (mapcat harvestables (distinct (take 4 (iterate rotate-90 rock))))]\n               (if (not-empty h)\n                   (apply max h))))]\n     (max-harvestable (to-rock numbers)))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [coll]\n    (let [coll (map #(Long/toBinaryString %) coll)\n          max-length (apply max (map count coll))\n          coll (map #(into [] (format (str \"%0\" max-length \"d\") (Long/parseLong %))) coll)\n          horizontal (apply map vector coll)\n          reverse clojure.core/reverse ;; for some reason reverse is pointing to another thing\n          all-orientations [(vec coll) (vec (reverse coll)) (vec horizontal) (vec (reverse horizontal))]\n          one-face (fn [positions] `[~(dec (first positions)) ~@positions ~(inc (last positions))])\n          two-faces-l (fn [[pos :as positions]] (cons (dec pos) positions))\n          two-faces-r (fn [[pos :as positions ]] (cons (inc pos) positions))\n          triangle-on (fn f [nxt positions [row & rows]]\n                        (if (every? #{\\1} (map (partial get row) positions))\n                          (+ (count positions) (f nxt (nxt positions) rows))\n                          0))]\n      (if-let [triangles-areas (seq\n                                (mapcat (fn [rock]\n                                          (for [i (range 0 (count rock))\n                                                subrock [(subvec rock i)]\n                                                j (range 0 (count (first rock)))\n                                                nxt [one-face two-faces-l two-faces-r]\n                                                :let [area (triangle-on nxt [j] subrock)]\n                                                :when (>= area 3)]\n                                            area))\n                                        all-orientations))]\n        (apply max triangles-areas))))","problem":127,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn love-tri\r\n  [rock]\r\n  (letfn [\r\n          (to-bitmap [rock]\r\n            (let [temp (map #(Integer/toString % 2) rock)\r\n                  len (apply max (map count temp))]\r\n              (apply vector \r\n                     (map #(apply vector \r\n                                  (concat (repeat (- len (count %)) 0) \r\n                                          (map (fn [c] (- (int c) 48))  %))) temp))))\r\n\r\n          (print-bitmap [bitmap]\r\n            (println \"Bitmap:\")\r\n            (doseq [row bitmap]\r\n              (println row))\r\n            (println \"-------\"))\r\n\r\n          (transpose [bitmap]\r\n            (apply vector (apply map vector bitmap)))\r\n\r\n          (rotate-cw [bitmap]\r\n            (into [] (map #(into [] (reverse %)) (transpose bitmap))))\r\n\r\n          (find-triangle-area [bitmap area xy-list evolve-fn]\r\n            ; finds the triangle of max area, starting at \r\n            ; slice represented by xy-list, while moving to the \r\n            ; right and up.\r\n            ; area should be initialized to zero\r\n            \r\n            (let [xy-list-values (map (partial get-in bitmap) xy-list)\r\n                  first-xy (first xy-list)]\r\n\r\n              ;(println \"Checking list: \" xy-list)\r\n              (if (not (every? #(= % 1) xy-list-values))\r\n                ; base case - if the column doesn't continue a triangle shape, return area  \r\n                area \r\n                ; otherwise:\r\n                (find-triangle-area bitmap \r\n                                    (+ area (count xy-list-values))\r\n                                    (evolve-fn xy-list)\r\n                                    evolve-fn))))\r\n          \r\n          (evolve-fn-1 [xy-list]\r\n            ;(println \"evolve-fn-1: xy-list is \" xy-list)\r\n            (let [[a b] (first xy-list)\r\n                  new_xy [(dec a) (inc b)]]\r\n              (cons new_xy (map (fn [[x y]] [x (inc y)]) xy-list))))\r\n\r\n          (evolve-fn-2 [xy-list]\r\n            (let [[a b] (first xy-list)\r\n                  [p q] (last xy-list)\r\n                  new_xy_1 [(dec a) (inc b)]\r\n                  new_xy_2 [(inc p) (inc q)]]\r\n              (concat (cons new_xy_1 (map (fn [[x y]] [x (inc y)]) xy-list)) [new_xy_2])))\r\n         ]\r\n    \r\n    ;(print-bitmap (to-bitmap rock))\r\n    (let [bitmap (to-bitmap rock)\r\n          dim (count bitmap)]\r\n      (print-bitmap bitmap)\r\n      (let [result (apply max (for [bm [bitmap (rotate-cw bitmap)]\r\n                                    evolve-fn [evolve-fn-1 evolve-fn-2] \r\n                                    x (range dim) \r\n                                    y (range dim)] \r\n                                (find-triangle-area bm 0 [[x y]] evolve-fn)))]\r\n        (when (>= result 3)\r\n          result))\r\n    \r\n    )))","problem":127,"user":"4e8a0c82535d3e98b802328d"},{"problem":127,"code":"#(case (first %) 0 nil 21 nil 18 9 17 6 7 4 3 3 1 15 15 10)","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn [s]\r\n    (letfn [(b [n] (if (< n 2) [n]\r\n                       (conj (-> n (/ 2) int b) (rem n 2))))\r\n            (bm [s]\r\n              (let [s (map b s)\r\n                    n (apply max (map count s))]\r\n                (vec (map #(vec (concat (repeat (- n (count %)) 0) %)) s))))\r\n            (line-pos [pos dir n]\r\n              (let [[s t]   dir]\r\n                (if (every? #(not= 0 %) dir)\r\n                  (let [x    (range (inc n))\r\n                        line (map vector x (reverse x))\r\n                        line (map #(map * dir %) line)]\r\n                    (map #(map + pos %) line))\r\n                  (let [line (map #(- % n) (range (inc (* 2 n))))\r\n                        pos  (map + pos (map #(* % n) dir))\r\n                        line (map #(vector (* t %) (* s %)) line)]\r\n                    (map #(map + pos %) line)))))\r\n            (build-tri [m pos dir]\r\n              (loop [n 0\r\n                     s 0]\r\n                (let [line  (line-pos pos dir n)\r\n                      vs    (map #(get-in m %) line)]\r\n                  (if (every? #(= 1 %) vs)\r\n                    (recur (inc n) (+ s (count vs)))\r\n                    (if (> s 1) s 0)))))\r\n            (find-max [m & pos]\r\n              (let [v (get-in m pos)]\r\n                (if (pos? v) \r\n                  (map  #(build-tri m pos %) \r\n                        [[1 1] [1 -1] [-1 -1] [-1 1] [1 0] [-1 0] [0 1] [0 -1]])\r\n                  0)))\r\n            (find-tri [m]\r\n              (let [w (count (first m))\r\n                    h (count m)]\r\n                (map (fn [j] (map #(find-max m j %) (range w))) (range h))))\r\n            ]\r\n        (let [r (->> s bm find-tri flatten (apply max))]\r\n          (when (pos? r) r))))","problem":127,"user":"4f58d92fe4b0a7574ea71858"},{"problem":127,"code":"#({15 10\n   1 15\n   3 3\n   7 4\n   17 6\n   18 9\n   21 nil\n   0 nil} (first %))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(letfn [(max-possible-triangle [base-len]\n          (+ base-len (* 2 (reduce + (range base-len)))))\n\n        (bin-seqs [s]\n          (let [mx (apply max s)\n                len (int (/ (Math/log mx) (Math/log 2)))\n                bits (nth (iterate #(conj % (* 2 (first %))) '(1)) len)]\n            (mapv (fn [n] (mapv #(if (= 0 (bit-and % n)) 0 1) bits)) s)))\n\n\n        (left-side [base] (subvec base 0 (dec (count base))))\n        (right-side [base] (subvec base 1))\n        (center-side [base] (when (and (odd? (count base)) (> (count base) 1))\n                              (subvec base 1 (dec (count base)))))\n\n        (test-triangle [bin-seqs base side-fn dir total]\n          (if (empty? base)\n            total\n            (let [new-base (mapv (fn [[x y]] [(+ x dir) y])\n                                 (side-fn base))]\n              (when (every? (fn [[x y]] (= 1 (get-in bin-seqs [x y]))) new-base)\n                (test-triangle bin-seqs new-base side-fn dir (+ total (count new-base)))))))\n\n        (check-base [bin-seqs base]\n          (let [[lt0 lt1 rt0 rt1 :as all-ts]\n                (for [side-fn [left-side right-side center-side] dir [-1 1] ]\n                  (test-triangle bin-seqs base side-fn dir 0))]\n            (map (partial + (count base))\n                 (filter #(and % (> % 0)) (conj all-ts\n                                                (when (and lt0 lt1) (+ lt0 lt1))\n                                                (when (and rt0 rt1) (+ rt0 rt1)))))))\n        (solve [s]\n          (let [bs (bin-seqs s)\n                potential-bases\n                (map #(map first %)\n                     (mapcat (fn [lvl s]\n                               (filter #(and (> (count %) 1) (= 1 (second (first %))))\n                                       (partition-by #(= (second %) 0)\n                                                     (map (fn [p b] [[lvl p] b]) (range) s))))\n                             (range) bs))]\n            (loop [max-t 0 pbs (sort-by count > potential-bases)]\n              (if (or (empty? pbs)\n                      (< (max-possible-triangle (count (first pbs))) max-t))\n                max-t\n                (let [res (check-base bs (vec (first pbs)))\n                      nt (if (not (empty? res)) (apply max res) 0)\n                      npbs\n                      (sort-by count >\n                               (concat (rest pbs)\n                                       (when (> (count (first pbs)) 2)\n                                         (partition (dec (count (first pbs))) 1 (first pbs)))))]\n                  (recur (max nt max-t) npbs))))))]\n  (fn [s] (let [s (solve s)] (when (not= s 0) s))))","problem":127,"user":"519ef784e4b087743fad2198"},{"problem":127,"code":"(fn love-triangles [nums]\n  (letfn [(to-binary [n]\n           (loop [ret () n n]\n             (if (zero? n) ret\n               (recur (conj ret (rem n 2))\n                      (quot n 2)))))\n          (pad [colls]\n               (let [row-size (apply max (map count colls))]\n                 (mapv (fn [coll]\n                         (vec (concat (repeat (- row-size (count coll)) 0) coll)))\n                       colls)))\n          \n          (mine-one [mine [row column :as pos]]\n            {pos (count (for [i (range)\n                              :while (and (< (+ row i) (count mine))\n                                          (< (+ column i) (count (mine (+ row i)))))\n                              :let [mineral-slice  (subvec (mine (+ row i)) \n                                                           column \n                                                           (+ column (inc i)))]\n                              :while (apply = 1 mineral-slice)]\n                          mineral-slice))})\n                 \n          (mine-all [mine]\n            (apply merge\n                   (for [i (range (count mine))\n                         j (range (count (mine i)))\n                         :when (= 1 ((mine i) j))]\n                     (mine-one mine [i j]))))\n          (triangular-series [n]\n            (/ (* n (+ n 1)) 2))\n                 \n          (transpose [colls]\n            (apply mapv vector colls))\n          \n          (invert [colls]\n            (vec (rseq colls)))\n                 \n          (mrg [mine m1 m2]\n            (concat (map triangular-series (vals m2))\n                    (vec (for [[[row col] n] m2\n                               :let [m (m2 [row (- (dec (count (mine row))) col)])]]\n                           (if (and m (= n m))\n                             (* n n)\n                             (triangular-series n))))))]\n    \n    (let [grid (pad (map to-binary nums))\n          map-invert (partial mapv invert)]\n      \n      (->> (concat (mrg grid\n                        (mine-all grid)\n                        (-> grid map-invert mine-all))\n                   (mrg (-> grid transpose invert)\n                        (-> grid transpose invert mine-all)\n                        (-> grid transpose invert map-invert mine-all))\n                   (mrg (invert grid)\n                        (-> grid invert mine-all)\n                        (-> grid invert map-invert mine-all))\n                   (mrg (transpose grid)\n                        (-> grid transpose mine-all) \n                        (-> grid transpose map-invert mine-all)))\n           (apply max)\n           ((fn [x] (if (> x 2) x nil)))))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [nums]\n  (let [n2s (fn f [n] \n              (if (zero? n) [] \n                (conj (f (bit-shift-right n 1))\n                      (bit-and n 1))))\n        mp (map n2s nums)\n        cc (apply max (map count mp))\n        cr (count mp)\n        diff #(- cc (count %))\n        mp (vec (map #(into (vec (repeat (diff %) 0)) %) mp))\n        turn90 {[0 1] [1 0]\n                [1 0] [0 -1]\n                [0 -1] [-1 0]\n                [-1 0] [0 1]\n                [1 1] [1 -1]\n                [1 -1] [-1 -1]\n                [-1 -1] [-1 1]\n                [-1 1] [1 1]}\n        turn135 {[0 1] [1 -1]\n                 [0 -1] [-1 1]\n                 [1 0] [-1 -1]\n                 [-1 0] [1 1]\n                 [1 1] [0 -1]\n                 [1 -1] [-1 0]\n                 [-1 1] [1 0]\n                 [-1 -1] [0 1]}\n        dirs (keys turn90)\n        hori? #(some zero? %)\n        calc (fn [n d]\n               (let [nn (inc (/ (- n 1) d))]\n                 (+ (* nn 1)\n                    (/ (* d (* nn (- nn 1))) 2))))\n        go (fn [i j d n]\n             (loop [pos [i j]\n                    dir d\n                    tmp n\n                    cnt 3]\n               ;(println pos dir tmp cnt)\n               (cond\n                 (zero? cnt) true\n                 (zero? tmp) \n                 (recur pos \n                        (if (= 2 cnt) \n                          (turn90 dir)\n                          (turn135 dir)) \n                        (if (hori? d) (/ n 2) n) \n                        (dec cnt))\n                 (= 1 (get-in mp (map + dir pos)))\n                 (recur (map + dir pos) dir (dec tmp) cnt)\n                 :else\n                 false)))\n        _ (println (go 0 0 [0 1] 2))\n        f (fn [i j dir]\n            (let [d (if (hori? dir) 2 1)]\n              (loop [n d]\n                (if (go i j dir n)\n                  (recur (+ d n))\n                  (calc (- (inc n) d) d)))))]\n    (->>\n      (for [i (range cc) j (range cr) dir dirs \n            :when (= 1 (get-in mp [i j]))\n            :let [ret (f i j dir)]\n            :when (not= 1 ret)]\n        ret)\n      (#(when (seq %) (apply max %))))))","problem":127,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [co]\n  (letfn [(get-board [ci]\n            (map #(str (subs \"00000\" 0 (- 5 (count (seq %)))) %)\n                 (map #(Integer/toBinaryString %) ci)))]\n    (let [cs  (get-board co)\n          ry  (count cs)\n          rx  (count (first cs))\n          dm  {:u [0 -1]\n               :d [0  1]\n               :l [-1 0]\n               :r [1  0]}\n          sdm {:u [:l :r]\n               :d [:l :r]\n               :l [:u :d]\n               :r [:u :d]}]\n      (letfn [(move\n                ([[x y] [dx dy]]\n                   (map + [x y] [dx dy]))\n                ([n [x y] [dx dy]]\n                   (nth (iterate #(move % [dx dy]) [x y]) n)))\n              (rock? [[x y]]\n                (or (some neg? [x y])\n                    (>= x rx)\n                    (>= y ry)\n                    (= \\0 (nth (nth cs y) x))))\n              (count-minerals\n                ([d [x y]]\n                   (loop [n 0 [x y] [x y]]\n                     (if (rock? [x y])\n                       n\n                       (recur (inc n) (move [x y] (d dm))))))\n                ([d n [x y]]\n                   (>= (count-minerals d [x y]) n)))]\n        (let [tris (flatten\n                    (for [d [:u :r :d :l]]\n                      (for [y (range ry)\n                            x (range rx)]\n                        (let [sl (count-minerals d [x y])\n                              dt (d sdm)]\n                          (if (> sl 1)\n                            (for [dn dt]\n                              [(if (not \n                                     (some false?\n                                       (map (fn [l]\n                                              (count-minerals \n                                                d\n                                                (- sl l)\n                                                (move l [x y] (dn dm))))\n                                            (range 1 sl))))\n                                 (reduce + (range (inc sl)))\n                                 0)\n                               (let [sl (if (even? sl) (dec sl) sl)]\n                                 (if (and (>= sl 3)\n                                          (not \n                                            (some false?\n                                              (map (fn [l]\n                                                     (count-minerals \n                                                       d\n                                                       (- sl (* 2 l))\n                                                       (move l (move l [x y] (dn dm)) (d dm))))\n                                                   (range 1 (inc (int (/ sl 2))))))))\n                                   (reduce + (range 1 (inc sl) 2))\n                                   0))])\n                            0)))))\n              max-tri (apply max (filter identity tris))]\n            (if (< max-tri 3)\n              nil\n              max-tri))))))","problem":127,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn [b] \n  (letfn [\n   (parse-bitset [r b i]\n    (if (= 0 b) \n     r\n     (recur (if (= (mod b 2) 1) (conj r i) r) (bit-shift-right b 1) (inc i))))\n   (read-bitmap [b ]\n    (for [ i (range (count b)) j (parse-bitset [] (b i) 0)]\n     [i j]))\n   (build-init-set [ ps ]\n    (let [\n     directions [ [1 0] [0 1] [-1 0] [0 -1] [1 1] [-1 1] [-1 -1] [1 -1] ]\n     tri-couples\n     (let [[ d1 d2 d3 d4 d5 d6 d7 d8 ] directions ]\n      [ [d1 d2 ] [d2 d3] [d3 d4] [d4 d1] [d5 d6] [d6 d7] [d7 d8] [d8 d5]])\n     ]\n     (for [ x ps d tri-couples]\n      [x d 1 1])))\n   (abs [x] (if (< x 0) (- x) x))\n   (unit-d [[d1x d1y]]\n    (let [ \n     ad1x (abs d1x)  \n     ad1y (abs d1y)  \n     mx (max ad1x ad1y)\n     ]\n     [ (/ d1x mx) (/ d1y mx) ])) \n   (delta-d1-d2 [[d1x d1y] [d2x d2y]]\n    [ (- d2x d1x) (- d2y d1y)])\n   (calc-x+kd [[xx xy] k [dx dy]]\n    [(+ xx (* k dx)) (+ xy (* k dy))])\n    (expand-triangle  [m [x [d1 d2] k t] sps]\n     (let [ y (calc-x+kd x k d1)\n      z (calc-x+kd x k d2)\n      yz (unit-d (delta-d1-d2 d1 d2))\n      pyz (conj (take-while #(not= % z) (iterate #(calc-x+kd % 1 yz) y)) z)\n      nt (+ t (count pyz))\n      ]\n      (if (every? #(contains? sps %) pyz)\n       [ (max m nt) [x [d1 d2] (inc k) nt] ]\n       [m nil ])\n     ))\n    (explore-triangle [m ws sps]\n     (if (empty? ws)\n      (if (< m 3) nil m)\n      (let [\n       [nm ne] (expand-triangle m (first ws) sps)\n       nws (if (nil? ne) (rest ws) (conj (rest ws) ne))\n       ]\n       (recur nm nws sps)\n      )))\n    ]\n    (let [\n     ps (read-bitmap b)\n     is (build-init-set ps)\n     sps (set ps)\n     exp-tri (expand-triangle  0 [[3 1] [[-1 0] [0 1]] 3 6 ] sps)\n     r (explore-triangle 0 is sps)\n     ]\n     r\n    )))","problem":127,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn [v]\n           (letfn  [(right-triangle [v]\n                      (loop [v v\n                             n (count (first v))\n                             acc []]\n                        (if (or (empty? v) (= 0 n))\n                          acc\n                          (recur (rest v)\n                                 (dec n)\n                                 (conj acc (vec (take n (first v))))))))\n\n                    (inner-right-triangles\n                      [right-triangle]\n                      (if (empty? right-triangle)\n                        []\n                        (let [shave-left (loop [right-triangle right-triangle\n                                                acc []]\n                                           (if (= 2 (count (first right-triangle)))\n                                             acc\n                                             (let [new-right-triangle (vec (remove empty? (mapv (comp vec butlast) right-triangle)))]\n                                               (recur new-right-triangle\n                                                      (conj acc new-right-triangle)))))\n\n                              shave-right (loop [right-triangle right-triangle\n                                                 acc []]\n                                            (if (= 2 (count (first right-triangle)))\n                                              acc\n                                              (let [new-right-triangle (vec (remove empty? (mapv (comp vec rest) right-triangle)))]\n                                                (recur new-right-triangle\n                                                       (conj acc new-right-triangle)))))\n\n                              shave-left-down (loop [triangles (seq shave-left)\n                                                     acc #{}]\n                                                (if (empty? triangles)\n                                                  acc\n                                                  (let [new-ts (loop [triangle (first triangles)\n                                                                      acc #{}]\n                                                                 (if (= 1 (count triangle))\n                                                                   acc\n                                                                   (recur (rest triangle)\n                                                                          (conj acc (vec (rest triangle))))))]\n                                                    (recur (rest triangles)\n                                                           (conj acc new-ts)))))\n\n                              shave-right-down (loop [triangles (seq shave-right)\n                                                      acc #{}]\n                                                 (if (empty? triangles)\n                                                   acc\n                                                   (let [new-ts (loop [triangle (first triangles)\n                                                                       acc #{}]\n                                                                  (if (= 1 (count triangle))\n                                                                    acc\n                                                                    (recur (rest triangle)\n                                                                           (conj acc (vec (rest triangle))))))]\n                                                     (recur (rest triangles)\n                                                            (conj acc new-ts)))))\n\n                              shave-right-down (when-not (empty? shave-right-down) (reduce into shave-right-down))\n                              shave-left-down  (when-not (empty? shave-right-down) (reduce into shave-left-down))\n                              out (remove nil? [shave-left shave-right shave-right-down shave-left-down])]\n                          out)))\n\n                    (right->equalatiral\n                      [right-triangle]\n                      (if (empty? right-triangle)\n                        []\n                        (let [right-triangle (if (even? (count right-triangle))\n                                               (vec (rest right-triangle))\n                                               right-triangle)\n                              n (quot (count right-triangle) 2)\n                              [head tail] ((juxt (comp vec (partial take n)) (comp vec (partial drop n))) right-triangle)\n                              new-head (loop [m 0\n                                              acc []]\n                                         (if (= m n)\n                                           (mapv vec acc)\n                                           (recur (inc m)\n                                                  (conj acc (take (inc m) (head m))))))]\n                          (mapv vec (into new-head tail)))))\n\n                    (inner-equalatiral-triangle\n                      [equalatiral-triangle]\n                      (if (empty? equalatiral-triangle)\n                        []\n                        (mapv (comp vec butlast)\n                              (remove #(= 1 (count %)) equalatiral-triangle))))\n\n                    (inner-equalatiral-triangle-r [equalatiral-triangle]\n                      (if (empty? equalatiral-triangle)\n                        []\n                        (mapv (comp vec rest)\n                              (remove #(= 1 (count %)) equalatiral-triangle))))\n\n                    (inner-equalatiral-triangles\n                      ;; Accepts a right triangle and recursively generates all equilateral triangles in it.\n                      [equalatiral-triangle]\n                      (if (or (empty? equalatiral-triangle) (= 2 (count equalatiral-triangle)))\n                        []\n                        (let [shave-left (loop [equalatiral-triangle equalatiral-triangle\n                                                acc []]\n                                           (if (= 3 (count equalatiral-triangle))\n                                             acc\n                                             (let [new-et (inner-equalatiral-triangle equalatiral-triangle)]\n                                               (recur new-et\n                                                      (conj acc new-et)))))\n\n                              shave-right (loop [equalatiral-triangle equalatiral-triangle\n                                                 acc []]\n                                            (if (= 3 (count equalatiral-triangle))\n                                              acc\n                                              (let [new-et (inner-equalatiral-triangle-r equalatiral-triangle)]\n                                                (recur new-et\n                                                       (conj acc new-et)))))]\n                          (set (into shave-left shave-right)))))\n\n                    (eq-triangles\n                      [plane [y x]]\n                      (let [plane  (mapv (comp vec (partial drop x)) (drop y plane))\n                            plane  (if (even? (count plane)) (vec (butlast plane)) plane) \n                            height (count plane)\n                            width  (count (first plane))\n                            head (vec (take (quot height 2) plane))\n                            center (plane (quot height 2))\n                            tail (vec (reverse (drop (dec (* 2 (quot height 2))) plane)))\n                            tail (if (< (count head) (count tail)) (vec (take (count head) tail)) tail)\n                            largest-eq-triangle (when-not (or (= 1 (count center)) (zero? (count center))\n                                                              (empty? head) (empty? tail))\n      \n                                                  (loop [n 0\n                                                         head head\n                                                         tail tail]\n                                                    (if (= n (count head))\n                                                      (reduce into [head [(take (inc (count (last head))) center)] (reverse tail)])\n                                                      (recur (inc n)\n                                                             (assoc head n (take (inc n) (head n)))\n                                                             (assoc tail n (take (inc n) (tail n)))))))]\n                        (when largest-eq-triangle\n                          (loop [triangle largest-eq-triangle\n                                 acc #{largest-eq-triangle}]\n                            (if (every? empty? triangle)\n                              ;; only return valid triangles.\n                              (->> acc\n                                   (remove #(or (some #{0} (flatten %))\n                                                (> 3 (count %))\n                                                (empty? %)\n                                                (= 1 (count (distinct (map count %))))))\n                                   set)\n                              (let [new (remove nil? (map butlast triangle))]\n                                (recur new\n                                       (conj acc new))))))))\n\n                    (equalatiral-triangles-in-plane [plane]\n                      (let [plane plane\n                            width (count (first plane))\n                            height (count plane)]\n                        (loop [coord [0 0]\n                               acc #{}]\n                          (let [[y x] coord\n                                new-eq-triangles (eq-triangles plane coord)]\n                            (if (= (dec height) y)\n                              acc\n                              (recur (if (= (dec width) x) [(inc y) 0] [y (inc x)])\n                                     (into acc new-eq-triangles)))))))\n\n                    (valid-triangle? [t]\n                      (and (= 1 (count (last t)))\n                           (every? #{1} (flatten t))))\n\n                    (maximum-triangle-area-in-plane [plane]\n                      (let [right-triangles (loop [plane plane\n                                                   right-triangles []]\n                                              (if (= 1 (count plane))\n                                                right-triangles\n                                                (recur (rest plane)\n                                                       (conj right-triangles (right-triangle plane)))))\n                            sub-right-triangles (map inner-equalatiral-triangles right-triangles)]\n                        :sub-right-triangles sub-right-triangles, :right-triangles right-triangles))\n\n                    (ds->readable-form\n                      [v]\n                      (let [v (mapv #(Integer/toBinaryString %) v)\n                            mx (apply max (map count v))\n                            v (mapv #(apply str (into (repeat (- mx (count %)) \"0\") %)) v)\n                            up (mapv (fn [x] (mapv #(if (#{\\1} %) 1 0) x)) v)\n                            left (loop [v up\n                                        acc []]\n                                   (if (every? empty? v)\n                                     acc\n                                     (recur (mapv (comp vec rest) v)\n                                            (conj acc (mapv first v)))))\n                            right (vec (reverse left))\n                            down (vec (reverse up))]\n                        {:up up :down down :left left :right right}))]\n\n             (let [o (ds->readable-form v)\n\n                   eqt (map equalatiral-triangles-in-plane (vals o))\n                   eqt (reduce into eqt)\n                   eqt (if (empty? eqt) '(0) (map (comp count flatten) eqt))\n\n                   right-triangles (map maximum-triangle-area-in-plane (vals o))\n                   right-triangles (if (empty? right-triangles) 0 (reduce into right-triangles))\n\n                   right-counts (if (= '(0) right-triangles)\n                                  '(0)\n                                  (map (comp count flatten)\n                                       (remove #(or (not= 1 (count (last %)))\n                                                    (some #{0} (flatten %))) right-triangles)))\n\n\n                   inner-right (map inner-right-triangles right-triangles)\n                   inner-right (set (reduce into (reduce into inner-right)))\n                   inner-right (remove #(or (= 1 (count %))\n                                            (not= 1 (count (last %)))\n                                            (some #{0} (flatten %))) inner-right)\n                   inner-right (map (comp count flatten) inner-right)]\n\n               (when-not (every? empty? [right-counts eqt inner-right])\n                 (let [out (apply max (reduce into [right-counts eqt inner-right]))]\n                   (when (not= 0 out)\n                     out))))))","problem":127,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn [xs]\n    (let [to-list (fn to-list [n] (if (> n 0) (lazy-seq (cons (mod n 2) (to-list (quot n 2)))) '()))\n          pad     (fn [ls] (let [m (max (count ls))]\n                             (map #(concat (repeat (- m (count %1)) 0) %1) ls)))\n          augment (fn [n [i c w t f]]\n                    (let [l (case t :sym (- i w) :left (- i w) :right i)\n                          r (case t :sym (+ i w) :left i :right (+ i w))]\n                      (if (or (not f)\n                              (< l 0)\n                              (>= r (count n))\n                              (not-every? (partial = 1) (subvec n l (inc r))))\n                        [i c w t false]\n                        [i (+ c 1 (- r l)) (inc w) t f])))\n          triangle (fn [p n]\n                     (let [new-ones (->> n\n                                         (map vector (range))\n                                         (filter (comp (partial = 1) second)))]\n                       (concat (map #(conj %1 1 :sym   true) new-ones)\n                               (map #(conj %1 1 :left  true) new-ones)\n                               (map #(conj %1 1 :right true) new-ones)\n                               (map (partial augment n) p))))\n          max-triangle (fn [ls] (->> ls\n                                     (map vec)\n                                     (reduce triangle [])\n                                     (map second)\n                                     (apply max)))\n          transpose  (partial apply map list)\n          dirs         (fn [ls] [ls\n                                 (reverse ls)\n                                 (transpose ls)\n                                 (transpose (reverse ls))])\n          ]\n\n\n      (->> xs\n           (map to-list)\n           pad\n           dirs\n           (map max-triangle)\n           (apply max)\n           (#(if (= % 1) nil %)))))","problem":127,"user":"525f51bde4b0cb4875a45dc8"},{"problem":127,"code":"(fn [s]\n  (let [t (map #(Integer/toBinaryString %) s)\n        mx (apply max (map count t))\n        my (count t)\n        ft (map #(format (str \"%0\" mx \"d\") (Integer/parseInt %)) t)\n        mt (min my mx)\n        fs (fn [ff n]\n             (->>\n               (ff n)\n               (map flatten)\n               (map #(map (fn [x] (Integer/parseInt (str x))) %))\n               (map #(reduce + %))\n               (apply max)))\n        fst (fn [n]\n              (for [x (range (inc (- mx n)))\n                    y (range (inc (- my n)))\n                    rx #{1 0}\n                    ry #{1 0}]\n                (for [r (range n)]\n                  (cond\n                    (and (zero? rx) (zero? ry))\n                    (subvec (vec (seq (nth ft (+ y r)))) x (+ x n (- r)))\n                    (zero? rx)\n                    (subvec (vec (seq (nth ft (+ y r)))) x (+ x (inc r)))\n                    (zero? ry)\n                    (subvec (vec (seq (nth ft (+ y r)))) (+ x r) (+ x n))\n                    :default\n                    (subvec (vec (seq (nth ft (+ y r)))) (- (+ n x) r 1) (+ x n))))))\n        fmst (fn [n] (reduce + (range (inc n))))\n        f (fn [fc fm rm]\n            (->>\n              (map (fn [i](when (= (fs fc i) (fm i))\n                            (fm i)))\n                   (range rm 1 -1))\n              (filter identity)\n              (first)))\n        mlr (min mx (quot (+ my 1) 2))\n        mup (min my (quot (+ mx 1) 2))\n        fstlr (fn [n]\n               (for [x (range (inc (- mx n)))\n                     y (range (inc (- my (* 2 n) (- 1))))\n                     rx #{1 0}]\n                 (for [r (range (- (* 2 n) 1))]\n                   (if (zero? rx)\n                     (subvec (vec (seq (nth ft (+ y r))))\n                       x\n                       (if (< r n) (+ x r 1) (+ x (* 2 n) (- r) (- 1))))\n                     (subvec (vec (seq (nth ft (+ y r))))\n                       (if (< r n) (+ x n (- r) (- 1)) (+ x r (- n) 1))\n                       (+ x n))))))\n        fuplr (fn [n]\n               (for [x (range (inc (- mx (* 2 n) (- 1))))\n                     y (range (inc (- my n)))\n                     rx #{1 0}]\n                 (for [r (range n)]\n                   (if (zero? rx)\n                     (subvec (vec (seq (nth ft (+ y r))))\n                       (+ x (- n r 1))\n                       (+ x n r))\n                     (subvec (vec (seq (nth ft (+ y r))))\n                       (+ x r)\n                       (+ x n n (- r) (- 1)))))))\n        fmstlr (fn [n] (reduce + (range 1 (* n 2) 2)))\n        fms (f fst fmst mt)\n        fmlr (f fstlr fmstlr mlr)\n        fmup (f fuplr fmstlr mup)\n        r (->> [fms fmlr fmup]\n             (filter identity))]\n    (when-not (empty? r)\n      (apply max r))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":127,"code":"(fn [s]\n    (letfn [(f1 [s [io jo]]\n              (iterate (fn [ss]\n                         (vec (distinct (mapcat (fn [[i j]] [[(+ io i) j] [(+ io i) (+ jo j)]]) ss)))\n                         ) [s])\n              )\n\n            (f2 [s [io jo]]\n              (iterate (fn [ss]\n                         (vec (distinct (mapcat (fn [[i j]] [[(+ io i) (- j jo)] [(+ io i) j] [(+ io i) (+ jo j)]]) ss)))\n                         ) [s])\n              )\n            (f4 [s [io jo]]\n              (iterate (fn [ss]\n                         (vec (distinct (mapcat (fn [[i j]] [[(+ io i) (+ j jo)] [i (+ jo j)] [(- i io) (+ jo j)]]) ss)))\n                         ) [s])\n              )\n            (f3 [s]\n              (let [m (for [i s]\n                        (Integer/toBinaryString i))]\n                (vec (map #(vec (concat (repeat (- (apply max (map count m)) (count %)) \\0) %)) m))\n                )\n              )]\n\n      (let [mm (f3 s)]\n        (->> (for [si (range (count mm)) sj (range (count (apply mapv vector mm)))\n                   i [-1 1] j [-1 1]\n                   n (range (inc (min (count mm) (count (apply mapv vector mm)))))\n                   ]\n               (vector\n                 (take n (f1 [si sj] [i j]))\n                 (take n (f2 [si sj] [i j]))\n                 (take n (f4 [si sj] [i j])))\n               )\n             (apply concat)\n             (map #(apply concat %))\n             (map (fn [x] (map #(get-in mm %) x)))\n             (filter (fn [x] (every? #(= \\1 %) x)))\n             (map count)\n             (apply max)\n             (#(if (> % 1) % nil) )\n             )\n        )\n      ))","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [field]\n  (let [\n        bit-max  (fn [int]\n                   (loop [n 1 i 0]\n                     (if (>= int n)\n                         (recur (* 2 n) (inc i))\n                         i)))\n    max-bit-max  (fn [ints] (bit-max (apply max ints)))\n      flip-down  #(reverse %)\n     flip-right  (fn [triangle]\n                   (map #(bit-shift-left % (- (max-bit-max triangle) (bit-max %)))\n                        triangle))\n        tri-at?  (fn [triangle x y field]\n                   (if (>= (count field) (+ y (count triangle)))\n                       (let [triangle (vec (map #(bit-shift-left % x) triangle))\n                             matchfield (subvec field y)]\n                         (every? true?\n                           (map (fn [tri x]\n                                  (= tri (bit-and tri x)))\n                                triangle\n                                matchfield)))))\n      bit-count  (fn [ints] (reduce + (map #(Integer/bitCount %) ints)))\n          wedge  (fn [size]\n                    (take size ((fn wedge\n                                 ([] (wedge [1]))\n                                 ([prev] (lazy-cat prev\n                                   (wedge [(+ 1 (bit-shift-left (peek prev) 1))])\n                               ))))))\n            fir  (fn [size]\n                   (map #(bit-or % (bit-shift-left %2 size))\n                        (flip-right (wedge size))\n                        (concat [0] (wedge (dec size)))))\n    play-button  (fn [size]\n                  (concat (wedge size)\n                          (flip-down (wedge (dec size)))))\n      triangles  (fn [size]\n                   (let [a (wedge size)\n                         b (flip-right a)\n                         c (flip-down a)\n                         d (flip-down b)\n                         e (fir size)\n                         f (flip-down e)\n                         g (play-button size)\n                         h (flip-right g)]\n                     (set [a b c d e f g h])))\n          x-max  (max-bit-max field)]\n  (loop [size 2 biggest 0]\n    (let [found (for [tri (triangles size)\n                        x (range 0 x-max)\n                        y (range 0 (inc (- (count field) (count tri))))\n                        :when (tri-at? tri x y field)]\n                  (bit-count tri))]\n      (if (or (empty? found)\n              (<= (apply max found) biggest))\n          (if (> biggest 0) biggest)\n          (recur (inc size) (apply max found)))))))","problem":127,"user":"4e2b1d48535deb9a81d77f03"},{"code":"(fn [rows]\n   (letfn [(lg [n] (/ (Math/log n) (Math/log 2)))\n           (n-bits [n] (if (zero? n) 0 (inc (int (Math/floor (lg n))))))\n           (ones [n] (dec (int (Math/pow 2 n))))\n           (max-or-nil [xs] (let [nxs (keep identity xs)\n                                  area (when (seq nxs) (apply max nxs))]\n                              (when (and area (> area 2))\n                                area)))\n           \n           (aligned-ne [rows]\n             \"Area of largest NE-pointing triangle with point at the top-right of rows.\"\n             (max-or-nil        \n              (map (fn [bits]\n                     (when (every? (fn [[rnum row]] \n                                     (let [mask (ones (- bits rnum))]\n                                       (= mask (bit-and row mask))))\n                                   (keep-indexed #(-> [% %2]) (take bits (concat rows (repeat 0)))))\n                       (/ (* bits (inc bits)) 2)))\n                   (range (inc (n-bits (first rows)))))))\n           \n           (aligned-s [rows]\n             \"Area of the largest S-pointing triangle top-right-aligned to the first row of rows.\"\n             (max-or-nil\n              (map (fn [bits]\n                     (when (every? (fn [[rnum row]]\n                                     (let [mask (bit-shift-left (ones (- bits (* rnum 2))) rnum)]\n                                        ; e.g., bits=7, rnum=2 => 0011100\n                                       (= mask (bit-and row mask))))\n                                   (keep-indexed #(-> [% %2]) (take (/ (inc bits) 2) (concat rows (repeat 0)))))\n                       (let [n (/ (inc bits) 2)] (* n n))))\n                   (filter odd? (range (inc (n-bits (first rows))))))))\n           \n           (largest-triangle [f rows]\n             \"Area of the largest triangle (using given alignment fn) within the given rows.\"\n             (max-or-nil\n              (for [r (range (count rows)),\n                    c (range (inc (Math/ceil (lg (apply max rows)))))]\n                (f (drop r (map #(bit-shift-right % c) rows))))))\n           \n           (rotate [rows]\n             \"Rotates the given rows by 90 degrees.\"\n             (for [b (range (count rows))]\n               (reduce #(+ (* 2 %) (if %2 1 0)) 0 (map #(bit-test % b) rows))))]\n     \n     (max-or-nil\n      (mapcat #(list (largest-triangle aligned-ne %)\n                     (largest-triangle aligned-s %))\n              (take 4 (iterate rotate rows))))))","problem":127,"user":"4ea1b9e4535d7eef308072b8"},{"problem":127,"code":"(fn [s] \n  (let [cdirs (cycle (for [d [bit-shift-left bit-shift-right] i [1 8]] #(d % i)))\n        b (reduce #(bit-or ((second cdirs) %) %2) s)\n        shave (fn [b dirs] (reduce #(bit-and % (%2 b)) b dirs)) \n        ishave (fn [dirs] \n                  (count (take-while pos? (iterate #(shave % dirs) b))))\n        nshaves (fn [n]\n                  (->> (partition n 1 cdirs) (take 4) (map ishave) (apply max)))\n        s2 (nshaves 2)\n        s3 (nshaves 3)\n        m (max (quot (* s2 (inc s2)) 2) (* s3 s3))]\n    (when (>= m 3) m)))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":127,"code":"(fn [in]\n  (let [h (count in)\n        maxin (apply max in)\n        powers (iterate (fn [[i p]] [(inc i) (+ p p)]) [0 1])\n        w (first (first (filter #(> (second %) maxin) powers)))\n        maxside (min w h)\n        mineral (fn [x y]\n                  (let [inval (nth in y 0)]\n                    (and (>= x 0)\n                         (> (rem (nth (iterate #(quot % 2) inval) x) 2)\n                            0))))\n        row (fn [x y dx dy twoway n]\n              (let [check (fn [i otherway]\n                            (or (and otherway (not twoway))\n                                (let [ii (if otherway (- 0 i) i)] (mineral (+ x (* ii dx)) (+ y (* ii dy))))))]\n                (if (not (some #(not (and (check % true) (check % false))) (range n)))\n                  (if twoway (- (* 2 n) 1) n)\n                  0)))\n        tri (fn [x y tdx tdy rdx rdy twoway]\n              (apply + (take-while pos? (map #(row (+ x (* tdx %)) (+ y (* tdy %)) rdx rdy twoway (inc %)) (range)))))\n        tridir (fn [x y tdx tdy]\n                 (max (tri x y tdx tdy tdy tdx false)\n                      (tri x y tdx tdy (- 0 tdy) (- 0 tdx) false)\n                      (tri x y tdx tdy tdy tdx true)))\n        triall (fn [x y]\n                 (max (tridir x y 0 1)\n                      (tridir x y 1 0)\n                      (tridir x y 0 -1)\n                      (tridir x y -1 0)))\n        ans (apply max (map (fn [x] (apply max (map (fn [y] (triall x y)) (range h)))) (range w)))]\n    (if (> ans 1) ans)))","user":"5b465b8be4b02d533a91bc65"},{"problem":127,"code":"(fn f [s]\n  (let [max-len (count (Integer/toString (apply max s) 2))\n        bin-nums (mapv #(str (format (str \"%0\" max-len \"d\") 0) (Integer/toString % 2)) s)\n        rock-n (mapv #(subs % (- (count %) max-len)) bin-nums)\n        rock-t (apply mapv str rock-n)\n        expand? (fn [rock [row col :as pos] n] (and (get-in rock pos)\n                                                    (get-in rock [row (+ col (dec n))])\n                                                    (every? #(= \\1 %) (subs (rock row) col (+ col n)))))\n        max-minerals (fn [rock] \n                       (apply max\n                        (for [row (range (count rock))\n                              col (range (count (first rock)))]\n                          (max\n                           (last (reduce #(if (and (%1 0) (expand? rock [(+ row %2) (- col %2)] (inc %2))) [(+ (%1 0) (inc %2))] [nil (last %1)]) [0] (range (- (count rock) row))))\n                           (last (reduce #(if (and (%1 0) (expand? rock [(- row %2) (- col %2)] (inc (* 2 %2)))) [(+ (%1 0) (inc (* 2 %2)))] [nil (last %1)]) [0] (range (inc row))))\n                           (last (reduce #(if (and (%1 0) (expand? rock [(+ row %2) (- col %2)] (inc (* 2 %2)))) [(+ (%1 0) (inc (* 2 %2)))] [nil (last %1)]) [0] (range (- (count rock) row))))))))\n        max-minerals (max (max-minerals rock-n) (max-minerals rock-t))]\n    (when (> max-minerals 2) max-minerals)))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":127,"code":"(fn [mdata]\n  (let [make_mine (fn [m]\n                    (let [b (into [] (map #(Integer/toBinaryString %) m))\n                          make_same_c (fn [x]\n                                        (let [maxc (apply max (map count x))\n                                              add_0 (fn [y]\n                                                      (let [c (count y)\n                                                            d (- maxc c)]\n                                                        (if (> d 0) (apply str (concat (apply str (repeat d \"0\")) y)) y)))]\n                                          (map #(add_0 %) x)))]\n                      (into [] (make_same_c b))))\n        mine (make_mine mdata)\n        ntoxy (fn [co [n b]] (list (list (quot n co) (rem n co)) b))\n        trans_maze (fn [maze]\n                     (let [co (count (first maze))]\n                       (apply hash-map (mapcat #(ntoxy co %) (keep-indexed #(list % %2)(into [] (apply str maze)))))))\n        m_mine (trans_maze mine)\n        s_ones (set (map first (filter #(= \\1 (val %)) m_mine)))\n        find_t1 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (- x 1) (- y 1))\n                                      p2 (list (- x 1) y)]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2)))\n                                    (vector (list x y) p1 p2) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        find_t2 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (- x 1) y)\n                                      p2 (list (- x 1) (+ y 1))]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2)))\n                                    (vector (list x y) p1 p2) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        find_t3 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (+ x 1) (- y 1))\n                                      p2 (list (+ x 1) y)]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2)))\n                                    (vector (list x y) p1 p2) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        find_t4 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (+ x 1) y)\n                                      p2 (list (+ x 1) (+ y 1))]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2)))\n                                    (vector (list x y) p1 p2) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        find_t5 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (- x 1) (- y 1))\n                                      p2 (list x (- y 1))\n                                      p3 (list (+ x 1) (- y 1))]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2))(= \\1 (m_mine p3)))\n                                    (vector (list x y) p1 p3) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        find_t6 (fn [s_ones]\n               (let [check (fn [[x, y]]\n                             (let [p1 (list (- x 1) (- y 1))\n                                   p2 (list (- x 1)  y)\n                                   p3 (list (- x 1) (+ y 1))]\n                               (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2))(= \\1 (m_mine p3)))\n                                 (vector (list x y) p1 p3) nil)))]\n                 (filter #(not (nil? %))(map check s_ones))))\n        find_t7 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (- x 1) (+ y 1))\n                                      p2 (list x  (+ y 1))\n                                      p3 (list (+ x 1) (+ y 1))]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2))(= \\1 (m_mine p3)))\n                                    (vector (list x y) p1 p3) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        find_t8 (fn [s_ones]\n                  (let [check (fn [[x, y]]\n                                (let [p1 (list (+ x 1) (- y 1))\n                                      p2 (list (+ x 1)  y)\n                                      p3 (list (+ x 1) (+ y 1))]\n                                  (if (and (= \\1 (m_mine p1))(= \\1 (m_mine p2))(= \\1 (m_mine p3)))\n                                    (vector (list x y) p1 p3) nil)))]\n                    (filter #(not (nil? %))(map check s_ones))))\n        t1s (find_t1 s_ones)\n        t2s (find_t2 s_ones)\n        t3s (find_t3 s_ones)\n        t4s (find_t4 s_ones)\n        t5s (find_t5 s_ones)\n        t6s (find_t6 s_ones)\n        t7s (find_t7 s_ones)\n        t8s (find_t8 s_ones)\n        expand_t1 (fn expand_t1 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (- x1 1) y3 (- y1 1)\n                          x4 (- x2 1) y4 y2\n                          d (- y4 y3 1)\n                          news (map #(list x3 (+ y3 (+ 1 %))) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t1 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n\n        expand_t2 (fn expand_t2 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (- x1 1) y3 y1\n                          x4 (- x2 1) y4 (+ y2 1)\n                          d (- y4 y3 1)\n                          news (map #(list x3 (+ y3 (+ 1 %))) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t2 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        expand_t3 (fn expand_t3 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (+ x1 1) y3 (- y1 1)\n                          x4 (+ x2 1) y4 y2\n                          d (- y4 y3 1)\n                          news (map #(list x3 (+ y3 (+ 1 %))) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t3 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        expand_t4 (fn expand_t4 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (+ x1 1) y3 y1\n                          x4 (+ x2 1) y4 (+ y2 1)\n                          d (- y4 y3 1)\n                          news (map #(list x3 (+ y3 (+ 1 %))) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t4 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        expand_t5 (fn expand_t5 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (- x1 1) y3 (- y1 1)\n                          x4 (+ x2 1) y4 (- y2 1)\n                          d (- x4 x3 1)\n                          news (map #(list (+ x3 (+ 1 %)) y3) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t5 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        expand_t6 (fn expand_t6 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (- x1 1) y3 (- y1 1)\n                          x4 (- x2 1) y4 (+ y2 1)\n                          d (- y4 y3 1)\n                          news (map #(list x3  (+ y3 (+ 1 %))) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t6 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        expand_t7 (fn expand_t7 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (- x1 1) y3 (+ y1 1)\n                          x4 (+ x2 1) y4 (+ y2 1)\n                          d (- x4 x3 1)\n                          news (map #(list (+ x3 (+ 1 %)) y3) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t7 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        expand_t8 (fn expand_t8 [[ty [x1 y1] [x2 y2]]  v]\n                    (let [x3 (+ x1 1) y3 (- y1 1)\n                          x4 (+ x2 1) y4 (+ y2 1)\n                          d (- y4 y3 1)\n                          news (map #(list x3  (+ y3 (+ 1 %))) (range d))\n                          p3 (list x3 y3) p4 (list x4 y4)\n                          news (concat news (list p3 p4))\n                          mi (map m_mine news)]\n                      (if (every? #(= \\1 %) mi)\n                        (expand_t8 (vector ty (list x3 y3) (list x4 y4)) (+ v (count mi)))\n                        v)))\n        rt1 (map #(expand_t1 % 3) t1s)\n        rt2 (map #(expand_t2 % 3) t2s)\n        rt3 (map #(expand_t3 % 3) t3s)\n        rt4 (map #(expand_t4 % 3) t4s)\n        rt5 (map #(expand_t5 % 4) t5s)\n        rt6 (map #(expand_t6 % 4) t6s)\n        rt7 (map #(expand_t7 % 4) t7s)\n        rt8 (map #(expand_t8 % 4) t8s)\n        re (concat rt1 rt2 rt3 rt4 rt5 rt6 rt7 rt8)]\n        (if (= (count re) 0) nil\n            (apply max re))))","user":"566d71b1e4b0a866af6896ca"},{"problem":127,"code":"(fn [nums]\n  (let [binaries (map #(Integer/toBinaryString %) nums)\n        max-count (apply max (map count binaries))\n        pad #(str (clojure.string/join (repeat (- max-count (count %)) \"0\")) %)\n        matrix (vec (map pad binaries))\n        rotate (fn [matrix] (vec (apply\n                                   (partial map (comp clojure.string/join reverse vector))\n                                   matrix)))\n        rotations (take 4 (iterate rotate matrix))\n        slice-diagonally (fn [slice]\n                           (let [below (map (fn [[i j]] (vector (inc i) j)) slice)\n                                 [right-i right-j] (last slice)]\n                             (concat below [(vector right-i (inc right-j))])))\n        slice-vertically (fn [slice]\n                           (let [[fi fj] (first slice)]\n                             (map vector\n                                  (range (dec fi) (inc (inc (first (last slice)))))\n                                  (repeat (inc fj)))))\n        measure-triangle-size (fn f [slice-func matrix slice]\n                                (let [next-slice (slice-func slice)\n                                      next-vals (map (fn [[i j]] (-> matrix (get i) (get j))) next-slice)]\n                                  (if (every? #{\\1} next-vals)\n                                    (+ (count slice) (f slice-func matrix next-slice))\n                                    (count slice))\n                                  ))\n        triangles  (for [slice-func #{slice-diagonally slice-vertically}\n                                          rotated-matrix rotations\n                                          [i row] (map-indexed vector rotated-matrix)\n                                          [j el] (map-indexed vector row)\n                                          :when (= \\1 el)]\n                                      (measure-triangle-size slice-func rotated-matrix [[i j]]))\n        max-triangle (apply max triangles)]\n    (if (= 1 max-triangle) nil max-triangle)))","user":"4e586949535d8a8b8723a292"},{"problem":127,"code":"(fn [i]\n  (letfn [(parse-row [r] (Integer/toBinaryString r))\n          (pad-row [w r] (if (= (count r) w) r (pad-row w (concat \"0\" r))))\n          (pad-rows [r] (let [width (->> r (map count) (apply max))] (map (partial pad-row width) r)))\n          (to-grid [s] (->> s (map parse-row) pad-rows))\n          (coord-map [rows]\n            (into {}\n              (for [y (range 0 (count rows)) x (range 0 (count (first rows)))]\n                [[x y] (-> rows (nth y) (nth x))])))\n          (construct [s] (->> s to-grid coord-map))\n          (rock? [grid row] (every? #(= \\1 (get grid %)) row))\n          (to-x [f] (fn [[x y]] [(f x) y]))\n          (to-y [f] (fn [[x y]] [x (f y)]))\n          (next-row [coord row-shift delta t row]\n            (->> (concat\n                    (when (#{:start :both} t) [((coord dec) (first row))])\n                    row\n                    (when (#{:end :both} t) [((coord inc) (last row))]))\n               (map (row-shift delta))))\n          (largest [grid row c next-coords]\n            (let [n (next-coords row)]\n              (if (rock? grid n)\n                (largest grid n (+ c (count n)) next-coords)\n                (when (> c 1) c))))\n          (gen-funcs []\n            (for [t [:start :end :both]\n                  d [inc dec]\n                  [a b] [[to-x to-y] [to-y to-x]]]\n              (partial next-row a b d t)))\n          (triangles [g]\n            (for [c (keys g)]\n              (let [start-row [c]]\n                (when (rock? g start-row)\n                  (map (partial largest g start-row 1) (gen-funcs))))))\n          (best [vs] (->> vs (apply concat) (remove nil?) sort last))]\n  (->> i construct triangles best)))","user":"50bce014e4b0594b91591c63"},{"code":"(fn [c]\n  (let [b (vec (map (fn [x] (vec (map #(bit-test x %) (range 5)))) c))\n        up [[-1 -1] [-1 0] [-1 1]]\n        down [[1 -1] [1 0] [1 1]]\n        left [[-1 -1] [0 -1] [1 -1]]\n        right [[-1 1] [0 1] [1 1]]\n        cuts (fn [d] [d (take 2 d) (drop 1 d)])\n        triangle-steps (mapcat cuts [up down left right])\n        \n        tri (fn [p s] (take-while #(every? (fn [[y x]] (and (<= 0 x)\n                                                            (<= 0 y)\n                                                            (< y (count c))\n                                                            (< x 5)\n                                                            (get-in b [y x])\n                                                            )) %)\n                                  (iterate (fn [ps] (distinct (for [p ps\n                                                                    t s]\n                                                                (map + p t)))) [p])\n                                  ))\n        answer (apply max (for [x (range 5)\n                     y (range (count c))\n                     s triangle-steps]\n                 (apply + (map count (tri [y x] s)))))\n        ]\n    (if (not= 1 answer) answer)\n  ))","problem":127,"user":"4fa340b4e4b081705acca18c"},{"problem":127,"code":";; http://www.4clojure.com/problem/127\n;; Love triangle\n(fn find-max-tri-area\n  [bitmap]\n  (let [bitmap (map #(map (partial  = \\1) (Integer/toString % 2)) bitmap)\n        size (apply max (map count bitmap))\n        bitmap (map #(concat (repeat (- size (count %)) false) %) bitmap)\n        bitmap (into [] (map #(into [] %) bitmap))\n        max-area-with (fn [[y x] [dy dx] [nsx nsy] delta-l]\n                        (loop [total-area 0\n                               [sy sx] [y x]                             \n                               l 1]\n                          (let [strip (for [n (range l)]\n                                        (get-in bitmap [(+ sy (* n dy)) (+ sx (* n dx))]))\n                                l-strip (count strip)]\n                            (if (apply = (cons true strip))\n                              (recur (+ total-area l-strip) [(+ sy nsy) (+ sx nsx)] (+ l delta-l))\n                              total-area))))\n        max-area-at (fn [coord]\n                      (max\n                       (max-area-with coord [1 0] [-1 -1] 1)\n                       (max-area-with coord [1 0] [1 -1] 1)\n                       (max-area-with coord [-1 0] [1 1] 2)\n                       (max-area-with coord [0 1] [-1 -1] 2)))\n        result (apply max (for [y (range size)\n                     x (range size)]\n                 (max-area-at [y x])))]\n    (if (>= result 3) result nil)\n    ;(max-area-with [1 1] [0 1] [-1 -1] 2)    \n    ))","user":"5c92105ce4b048ec896c59f7"},{"problem":127,"code":"(fn f127\n  [board-vec]\n  (letfn [(deltas-n\n            ;; (deltas-n 2) => [-2 2] [-2 1] [-2 0] [-2 -1] [-2 -2]\n            [step]\n            (map vector\n                 (repeat (* -1 step))\n                 (range step (dec (* -1 step)) -1)))\n\n          (deltas-ne\n            ;; (deltas-ne 3) => ([-3 0] [-2 -1] [-1 -2] [0 -3])\n            [step]\n            (map vector\n                 (range (* step -1) 1 1)\n                 (range 0 (dec (* step -1)) -1)))\n\n          (deltas-e\n            ;; (deltas-e 2) => [-2 -2] [-1 -2] [0 -2] [1 -2] [2 -2]\n            [step]\n            (map vector\n                 (range (* -1 step) (inc step))\n                 (repeat (* -1 step))))\n\n          (deltas-se\n            ;; (deltas-se 3) => ([3 0] [2 -1] [1 -2] [0 -3])\n            [step]\n            (map vector\n                 (range step -1 -1)\n                 (range 0 (dec (* step -1)) -1)))\n\n          (deltas-s\n            ;; (deltas-s 2) => [2 2] [2 1] [2 0] [2 -1] [2 -2]\n            [step]\n            (map vector\n                 (repeat step)\n                 (range step (dec (* -1 step)) -1)))\n\n          (deltas-sw\n            ;; (deltas-sw 3) => ([3 0] [2 1] [1 2] [0 3])\n            [step]\n            (map vector\n                 (range step -1 -1)\n                 (range 0 (inc step) 1)))\n\n          (deltas-w\n            ;; (deltas-w 2) => [-2 2] [-1 2] [0 2] [1 2] [2 2]\n            [step]\n            (map vector\n                 (range (* -1 step) (inc step))\n                 (repeat step)))\n\n          (deltas-nw\n            ;; (deltas-nw 3) => ([-3 0] [-2 1] [-1 2] [0 3])\n            [step]\n            (map vector\n                 (range (* step -1) 1 1)\n                 (range 0 (inc step) 1)))\n\n          (deltas\n            [step direction]\n            (condp = direction\n              :n (deltas-n step)\n              :ne (deltas-ne step)\n              :e (deltas-e step)\n              :se (deltas-se step)\n              :s (deltas-s step)\n              :sw (deltas-sw step)\n              :w (deltas-w step)\n              :nw (deltas-nw step)))\n\n          (bitset?\n            [board-vec [y x]]\n            (not (zero? (bit-and (nth board-vec y 0)\n                                 (bit-shift-left 1 x)))))\n\n          (valid-point\n            [[y x]]\n            (if (and ((comp not neg?) y)\n                     ((comp not neg?) x))\n              [y x]\n              nil))\n\n          (triangle-line-harvestable?\n            [board-vec yx direction step]\n            (->> (deltas step direction)\n                 (map (partial mapv + yx))\n                 (map valid-point)\n                 (every? #(and (not (nil? %))\n                               (bitset? board-vec %)))))\n\n          (max-harvestable-triangle-side-length\n            [board-vec yx direction]\n            (if (bitset? board-vec yx)\n              (->> (iterate inc 1)\n                   (take-while #(triangle-line-harvestable? board-vec yx direction %))\n                   (last)\n                   (#(if % (inc %) 0)))\n              0))\n\n          (triangle-size-equilateral\n            [n]\n            (/(* n\n                 (inc n))\n              2))\n\n          (triangle-size-isosceles\n            [n]\n            (* (/ (+ 2\n                     (* 2 (dec n)))\n                  2)\n               n))\n\n          (triangle-size\n            [n direction]\n            (if (direction #{:n :e :s :w})\n              (triangle-size-isosceles n)\n              (triangle-size-equilateral n)))\n\n          (max-harvestable-triangle-size\n            [board-vec yx direction]\n            (triangle-size (max-harvestable-triangle-side-length board-vec yx direction)\n                           direction))\n\n          (bits-needed\n            [n]\n            (loop [r 1\n                   v 2]\n              (if (> v n)\n                r\n                (recur (inc r) (bit-shift-left v 1)))))]\n    \n    (->> (for [x (range (bits-needed (apply max board-vec)))\n               y (range (count board-vec))\n               d [:n :ne :e :se :s :sw :w :nw]]\n           [x y d])\n         (map (fn [[x y direction]]\n                (max-harvestable-triangle-size board-vec [y x] direction)))\n         (apply max)\n         (#(if (> % 0) % nil)))))","user":"55586905e4b0deb715856e2b"},{"code":"(fn search-mine [mine]\n  \n  (let [mine-rows (count mine)\n        max-col   (reduce max mine)\n        mine-cols (inc (last (take-while #(<= (bit-shift-left 1 %) max-col) (range))))\n\n        test-mine \n        (fn test-mine [mine [r c]]\n          (if (or (< r 0) (< c 0) (>= r (count mine)) (>= c mine-cols))\n            0\n            (if (pos? (bit-and (bit-shift-left 1 c) (mine r))) 1 0)))\n\n        tri-extent\n        (fn [size pos dif]\n          (for [i (range size) j (range size) :when (< (+ i j) size)]\n            (vec (map + pos (map * dif [i j])))))\n\n        test-extent\n        (fn [mine extent]\n          (every? #(= 1 (test-mine mine %)) extent))\n\n        largest-tri \n        (fn [mine pos dif]\n          (last (take-while #(test-extent mine (tri-extent % pos dif)) (range))))\n        \n        largest\n        (fn [mine pos]\n          (let [score-t (fn [n] (/ (* n (inc n)) 2))\n                score-d (fn [n] (+ (score-t n) (score-t (dec n))))\n                t1 (largest-tri mine pos [1   1])\n                t2 (largest-tri mine pos [1  -1])\n                t3 (largest-tri mine pos [-1 -1])\n                t4 (largest-tri mine pos [-1  1])\n                \n                d1 (min t1 t2)\n                d2 (min t2 t3)\n                d3 (min t3 t4)\n                d4 (min t4 t1)\n\n                scores (concat (map score-t [t1 t2 t3 t4])\n                               (map score-d [d1 d2 d3 d4]))]\n\n            (reduce max scores)))\n\n\n        all-pos (for [r (range mine-rows) c (range mine-cols)] [r c])\n        scores (map #(largest mine %) all-pos)\n        best-score (reduce max scores)]\n\n    \n    (when (> best-score 1) best-score)))","problem":127,"user":"4f0d093b535d0136e6c22313"},{"problem":127,"code":"(fn [V]\n   (let [b (fn b [n]\n             (if (= n 0) []\n                 (conj (b (quot n 2)) (if (= 0 (mod n 2)) \\0 \\1))))\n         g (map b V)\n         W (apply max (map count g))\n         H (count V)\n         G (mapv #(vec (concat (repeat (- W (count %)) \\0) %)) g)\n         e (fn [[i j] [r s] n] (->> (range 0 (inc n))\n                                    (map #(vector (+ i (* % r)) (+ j (* % s))))))\n         c (fn [[i j]] (and (contains? G i) (contains? (last G) j)))\n         v #(every? true? (map \n                           (fn [_] (and (= \\1 (get-in G _)) (c _)))\n                           %))\n         t (for [i (range 0 H) j (range 0 W)\n                 [bi bj] [[0 1] [1 0] [-1 0]]\n                 [hi hj] [[(- bj) (- bi)] [bj bi]]\n                 n (range 1 10)\n                 :let [z (fn [m f]\n                           (apply concat\n                              (map-indexed (fn [i x] (e x [hi hj] (f i))) (e [i j] [bi bj] m))))\n                       t (z n identity)\n                       ]\n                 :while (v t)\n                 :let [m (+ n n)\n                       u (z m #(min % (- m %)))\n                       s (count (if (v u) u t))\n                       ]\n                 ]\n             s) \n         ]\n     (and (seq t)\n          (apply max t))))","user":"559c13c5e4b066d22e731f61"},{"problem":127,"code":"(fn [xs]\n  (letfn [(->matrix [xs]\n            (let [matrix (map #(Integer/toBinaryString %) xs)\n                  max-len (apply max (map count matrix))\n                  matrix (map (fn [l]\n                                (format (str \"%0\" max-len \"d\")\n                                        (Integer/parseInt l)))\n                              matrix)\n                  matrix (map seq matrix)]\n              (map (fn [l] (map #(- (int %) (int \\0)) l)) matrix)))\n\n          (windows [m w h]\n            (mapcat (partial partition h 1)\n                    (apply map vector\n                           (map (partial partition w 1) m))))\n\n          (sq-windows [m]\n            (let [mn (min (count (first m)) (count m))]\n              (mapcat #(windows m % %) (range mn 1 -1))))\n\n          (nonsq-windows [m]\n            (let [w (count (first m))\n                  h (count m)\n                  ds (for [x (range (max w h) 1 -1) :when (odd? x)]\n                       [x (quot (inc x) 2)])\n                  ds (filter (fn [[x y]] (and (<= x w) (<= y h)))\n                             (mapcat #(do [% (reverse %)]) ds))]\n              (mapcat (fn [[x y]] (windows m x y)) ds)))\n\n          (triangle-1-area [sq-matrix]\n            (let [len (count sq-matrix)\n                  triangle (mapcat (fn [l c] (take c l))\n                                   sq-matrix\n                                   (range len 0 -1) )]\n              (if (every? #(= 1 %) triangle)\n                (count triangle))))\n\n          (triangle-2-area [non-sq-matrix]\n            (let [w (count (first non-sq-matrix))\n                  h (count non-sq-matrix)]\n              (if (= (dec (* h 2)) w)\n                (let [triangle (mapcat (fn [r c] (drop c (drop-last c r)))\n                                       non-sq-matrix\n                                       (range))]\n                  (if (every? #(= 1 %) triangle)\n                    (count triangle))))))\n\n          (rotate-l [matrix]\n            (apply map vector (map reverse matrix)))\n\n          (area [farea matrix]\n            (if (and (>= (count matrix) 2)\n                     (>= (count (first matrix)) 2))\n              (let [trs (take 4 (iterate rotate-l matrix))\n                    tr-areas (filter identity (map farea trs))]\n                (if (seq tr-areas)\n                  (first tr-areas)))))\n\n          (solve [xs]\n            (let [m (->matrix xs)\n                  ws1 (sq-windows m)    ;; sorted in desc order\n                  ws2 (nonsq-windows m) ;; sorted in desc order\n                  mxs1 (drop-while nil? (map (partial area triangle-1-area) ws1))\n                  mxs2 (drop-while nil? (map (partial area triangle-2-area) ws2))\n                  mx (filter identity (map #(if (seq %) (first %)) [mxs1 mxs2]))]\n              (if (seq mx) (reduce max mx))))\n          ]\n    (solve xs)))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn [numbers]\n    (let [\n          pad (fn [numbers]\n           (let [maximum (apply max (map count numbers))]\n             (map #(concat (repeat (- maximum (count %)) false) %) numbers )\n             ))\n          to-grid (fn to-grid [numbers]\n               (->> numbers\n                    (map #(Integer/toString % 2))\n                    (map (fn [line]  (map #(if (= \\1 %) true false) line)))\n                    (pad)\n                    (map vec)\n                    (vec)))\n          grid (to-grid numbers)\n          get-state (partial get-in grid)\n          vec-add #(vec (map + %1 %2))\n          safe-max #(and (seq %) (apply max %))\n          sufficient-area? #(>= % 3)\n          depth-to-area-one-cut #(apply + (range (inc %)))\n          depth-to-area-two-cut #(apply + (take % (iterate (partial + 2) 1)))\n          calc-child-depth (fn [[child-depth & _ :as child-depths]]\n                            (if (apply = child-depths) child-depth 0))\n          expand-tri (fn expand-tri [trans-vectors coord]\n                       (if (get-state coord)\n                         (->> trans-vectors\n                              (map #(vec-add coord %))\n                              (map #(expand-tri trans-vectors %))\n                              (calc-child-depth)\n                              (inc))\n                         0))\n          shear-one (comp depth-to-area-one-cut\n                          (partial expand-tri #{ [0 -1] [-1 0]}))\n          shear-two-up (comp depth-to-area-two-cut\n                             (partial expand-tri #{ [-1 -1] [-1 0] [-1 1]}))\n          shear-two-left (comp depth-to-area-two-cut\n                               (partial expand-tri #{ [-1 -1] [0 -1] [1 -1]}))\n          shear-two-right (comp depth-to-area-two-cut\n                                (partial expand-tri #{[-1 1] [0 1] [1 1]}))\n          triangles (juxt shear-one shear-two-up shear-two-left shear-two-right)\n          coords (for\n                     [row (range (count grid))\n                      col (range (count (first grid)))]\n                   [row col])\n          ]\n      (->> coords\n           (mapcat triangles)\n           (filter sufficient-area?)\n           (safe-max))))","problem":127,"user":"4e6f578c535d5021c1a8961b"},{"problem":127,"code":"(fn [mine]\n  (letfn [(digits [n]\n            ((fn digits-iter [rst lower]\n               (if (< rst 2) (cons rst lower)\n                   (digits-iter (quot rst 2) (cons (rem rst 2) lower)))) n nil))\n          (pad [m]\n            (let [len (apply max (map count m))]\n              (vec (map #(vec (concat (repeat (- len (count %)) 0) %)) m))))\n          (square [row col size]\n            (vec (for [i (range row (+ row size))]\n                   (vec (for [j (range col (+ col size))] [i j])))))\n          (rectangle-vertical [[row col] size]\n            (vec (for [i (range row (+ row (dec (* 2 size))))]\n                   (vec (for [j (range col (+ col size))] [i j])))))\n          (rectangle-horizon [[row col] size]\n            (vec (for [i (range row (+ row size))]\n                   (vec (for [j (range col (+ col (dec (* 2 size))))] [i j])))))\n          (subsquare [size m]\n            (for [i (range (- (count m) (dec size))) j (range (- (count (first m)) (dec size)))]\n              [(map (fn [row] (map #(get-in m %) row)) (square i j size)) [i j]]))\n          (subrect [size pos m]\n            (concat (if (> (+ (second pos) (dec (* 2 size))) (count (first m))) nil\n                        (list (map (fn [row] (map #(get-in m %) row)) (rectangle-horizon pos size))))\n                    (if (> (+ (first pos) (dec (* 2 size))) (count m)) nil\n                        (list (map (fn [row] (map #(get-in m %) row)) (rectangle-vertical pos size))))))\n          (rotate [m]\n            (if (empty? (first m)) nil\n                (cons (reduce conj nil (map first m)) (rotate (map rest m)))))\n          (triangle? [m]\n            ((fn triangle-recur? [rst len]\n               (cond (zero? len) true\n                     (apply = (cons 1 (take len (first rst)))) (triangle-recur? (rest rst) (dec len))\n                     :else false)) m (count (first m))))\n          (triangle-downward? [m]\n            ((fn triangle-recur? [rst width]\n               (if (empty? rst) true\n                   (let [cur (first rst)\n                         target (take width (drop (quot (- (count cur) width) 2) cur))]\n                     (if (== (apply + target) width) (triangle-recur? (rest rst) (- width 2))\n                         false)))) m (count (first m))))\n          (triangle-orientless? [m]\n            (cond (== (count m) (count (first m))) (reduce #(or % %2) (map triangle? (take 4 (iterate rotate m))))\n                  (> (count (first m)) (count m)) (or (triangle-downward? m) (triangle-downward? (reverse m)))\n                  :else (triangle-orientless? (rotate m))))\n          (shear [m]\n            ((fn shear-iter [size]\n               (if (== size 1) nil\n                   (let [res (remove nil? (map (fn [[s p]] (if (triangle-orientless? s) p nil)) (subsquare size m)))]\n                     (cond (empty? res) (shear-iter (dec size))\n                           (and (> (count res) 1)\n                                (> (count\n                                    (remove false? (map triangle-orientless? (mapcat #(subrect size % m) res)))) 0))\n                           (- (* 2 (apply + (range (inc size)))) size)\n                           :else (apply + (range (inc size))))))) (min (count m) (count (first m)))))]\n    (let [m (pad (map digits mine))]\n      (if (reduce #(and % %2) (map #(apply = (cons 1 %)) m))\n        (apply + (range (inc (min (count m) (count (first m))))))\n        (shear m)))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":127,"code":"(fn [compressed-nums]\n  (letfn [(digits-in-base [x b]\n            (if (> b x)\n              [x]\n              (conj (digits-in-base (quot x b) b) (mod x b))))\n          (base-2-digits [nums]\n            (map #(digits-in-base % 2) nums))\n          (left-pad [coll num item]\n            (concat (repeat num item) coll))\n          (bitmap [digit-groups]\n            (let [width (apply max (map count digit-groups))]\n              (mapv\n                (fn [digits]\n                  (vec\n                    (left-pad\n                      digits\n                      (- width (count digits))\n                      0)))\n                digit-groups)))\n          (coords-diagonal [[row col] r-op c-op]\n            (for [i (range)]\n              (map \n                (fn [r c] [(r-op row r) (c-op col c)])\n                (range 0 (+ 1 i))\n                (range i -1 -1))))\n          (spread [i] (range (* -1 i) (inc i)))\n          (coords-cardinal [f [row col] r-op c-op]\n            (for [i (range)]\n              (apply\n                map\n                (conj\n                  (f (into '() [(repeat i) (spread i)])) \n                  (fn [r c] [(r-op row r) (c-op col c)])))))\n          (coords-ul [pos] (coords-diagonal pos + +))\n          (coords-ur [pos] (coords-diagonal pos + -))\n          (coords-dr [pos] (coords-diagonal pos - -))\n          (coords-dl [pos] (coords-diagonal pos - +))\n          (coords-u [pos] (coords-cardinal reverse pos + +))\n          (coords-d [pos] (coords-cardinal reverse pos - +))\n          (coords-l [pos] (coords-cardinal identity pos + +))\n          (coords-r [pos] (coords-cardinal identity pos + -))\n          (tri-at [coord-fn pos bitmap]\n            (take-while\n              ; only take consecutive slices of 1s\n              (partial every? #(= 1 %))\n              (map\n                #(map (partial get-in bitmap) %)\n                (coord-fn pos))))\n          (tris-at [pos bitmap]\n            (map\n              #(tri-at % pos bitmap)\n              [coords-u coords-l coords-d coords-r\n               coords-ul coords-ur coords-dl coords-dr]))\n          (all-tris [bitmap]\n            (apply concat\n                   (for [[r row] (map-indexed vector bitmap)\n                         [c bit] (map-indexed vector row)\n                         :when (= bit 1)]\n                       (tris-at [r c] bitmap))))\n          (tri-area [tri] (reduce + (map count tri)))]\n    (->> compressed-nums\n      (base-2-digits)\n      (bitmap)\n      (all-tris)\n      (map tri-area)\n      (reduce max)\n      (#(when (> % 1) %)))))","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn [coll]\n  (let [\n\t\tencode (fn  [p] (or (seq (into () (map #(mod (quot p %) 2)  \n\t\t\t\t\t\t\t\t (take-while #(< 0 (quot p %)) (iterate #(* 2 %) 1) )))))) \t\t\t\t\t\t\t\n\t\tdirections   {1 {[0 1] #{[1 -1] [1 0] [-1 -1] [-1 0] }}\n\t\t\t  2 {[0 1] #{[1 -1] [-1 -1] }\n\t\t\t\t [1 0] #{ [-1 1] [-1 -1] }}}\n\t\tmoves( fn [[x y] n [a b]]\n\t\t  (reductions (fn [[x* y*] _] [(+ a x*) (+ b y*)] ) [x y] (range n)))  \n\n  \t    can-fill? (fn [mineral [x y] n dir]\n\t\t  (let [h (moves [x y] n dir)\n\t\t\t   l (map #(get-in mineral %) h)\n\t\t\t   ] \n\t\t\t (every? #(= 1 %) l)))\t\t\t\t\t \n\n\t\tdraw-line (fn [mineral [x y] n dir]\n\t\t  (reduce #(assoc-in %1 %2 '*) mineral (moves [x y] n dir)))\t\t\t\t\t \n\n\t\tembed (fn embed[mineral [x y] increase dir [a b] & {:keys [n] :or {n 0}}]\n\t\t  (if (can-fill? mineral [x y] n dir) \n\t\t\t  (let [m (draw-line mineral [x y] n dir)]\n\t\t\t\t(embed m [(+ x a) (+ y b)] increase dir [a b] :n (+ n increase)))\n\t\t\t  mineral))  \n\n\t\tembed-all (fn [mineral p ] \n\t\t  (map (fn [[k d s]] (embed mineral p k d s)) (for [[k v] directions [d n] v s n ] [k d s])))\n\n\n\t\tprepare (fn [coll]\n\t\t  (let [e (map (comp vec encode) coll)\n\t\t\t   m (apply max (map count e))\n\t\t\t   e* (map #(vec (reverse (take m (concat (reverse %) (repeat 0))))) e)]\t   \n\t\t\t(vec e*)))\t\n\n\t\tall-triangles (fn [mineral]\n\t\t  (distinct (mapcat #(embed-all mineral %)  (for [x (range (count mineral)) y (range (count (first mineral)))] [x y]))))  \n\n\t\tsum (fn [mineral]\n\t\t  (count (filter #(= '* %) (for [x mineral y x] y))))  \n\t\tres (apply max (map sum (all-triangles (prepare coll)))) ]\n    (if (<= 3 res) res )))","problem":127,"user":"523a9fc9e4b081681ca7adca"},{"problem":127,"code":"(fn get-mineral [xs]\n\t(let [bs (map (fn [x] (map #(- (int %) (int \\0)) (Integer/toBinaryString x))) xs)\n\t\t  length (apply max (map count bs))\n\t\t  bs (map #(concat (repeat (- length (count %)) 0) %) bs)\n\t\t  verts (apply map vector bs)\n\t\t  mine (fn mine [bs i j n step]\n\t\t  \t(if (and\n\t\t  \t\t\t(< -1 i (count bs))\n\t\t  \t\t\t(< -1 j (count (first bs)))\n\t\t  \t\t\t(<= (+ j n) (count (first bs)))\n\t\t  \t\t\t(every? #(= % 1) (take n (drop j (nth bs i)))))\n\t\t  \t\t(+ n (mine bs (dec i) (dec j) (+ step n) step))\n\t\t  \t\t0))\n\t\t  gm (fn [bs]\n\t\t\t  \t(let [m \n\t\t\t  \t\t(apply max\n\t\t\t\t  \t(for [i (range (count bs)) j (-> bs first count range)]\n\t\t\t\t  \t\t(max (mine bs i j 1 1) (mine bs i j 1 2))))]\n\t\t  \t\t(if (= m 1)\n\t\t  \t\t\t0 m)))]\n\t\t  (let [res \n\t\t\t\t  (max\n\t\t\t\t  \t(gm bs)\n\t\t\t\t  \t(gm (reverse bs))\n\t\t\t\t  \t(gm (map reverse bs))\n\t\t\t\t  \t(gm verts)\n\t\t\t\t  \t(gm (reverse verts))\n\t\t\t\t  \t(gm (map reverse verts)))]\n\t\t\t(if (zero? res)\n\t\t\t\tnil res))))","user":"54448e84e4b032a45b869393"},{"problem":127,"code":";give up\n(fn [m t e c i a r v g]\n  (let [p (take-while #(<= % (m g))\n             (i #(* 2 %) 1))\n        H (c g)\n        W (c p)\n        g (v (for [y g]\n               (v\n                (for [x p]\n                  (> (bit-and x y) 0)))))\n        o #(and (e true?\n                   (a < [-1 -1] % [H W]))\n                (get-in g %))\n        z (fn [s g]\n            (->> #{s}\n                 (i #(set\n                      (mapcat g %)))\n                 (t #(e o %))\n                 (a c)\n                 (apply +)))\n\n        n [-1 0] ne [-1 1] e [0 1] se [1 1]\n        s [1 0] sw [1 -1] w [0 -1] nw [-1 -1]\n\n        t (for [x [[n e] [e s] [s w] [w n]\n                   [nw n ne] [ne e se]\n                   [sw s se] [nw w sw]]]\n            (fn [p]\n              (for [d x]\n                (a + d p))))\n\n        o (m\n           (for [y (r H) x (r W)\n                 g t]\n             (z [y x] g)))]\n    (when (>= o 3)\n      o)))\n#(apply max %)\ntake-while\nevery?\ncount\niterate\nmap\nrange\nvec","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":127,"code":"(fn [nums]\n  (let [binary (fn b2 [i] (if (zero? i) [] (conj (b2 (quot i 2)) (not (zero? (mod i 2))))))\n        ragged-grid (mapv binary nums)\n        [h w] [(count ragged-grid) (apply max (map count ragged-grid))]\n        grid (mapv #(vec (concat (repeat (- w (count %)) false) %)) ragged-grid)\n        mineral? (fn [[r c]] (and (< -1 r h) (< -1 c w) (get-in grid [r c])))\n        hyp? (fn [[r c] [dr dc] e] (->> (range e)\n                                        (map (fn [i] [(+ r (* i dr)) (+ c (* (- (dec e) i) dc))]))\n                                        (every? mineral?)))\n        seeds (set (for [r (range h) c (range w) :when (get-in grid [r c])] [r c]))\n        find-qn (fn [d] ; qN = set of quadrant-N tris, d = vector out to quadrant N\n                  (let [es (range 2 (inc (min h w)))\n                        origins (reductions (fn [prev e] (set (filter #(hyp? % d e) prev))) seeds es)]\n                    (set (apply concat (map (fn [os e] (map (fn [o] [o e]) os)) (rest origins) es)))))\n        [q1 q2 q3 q4] [(find-qn [1 1]) (find-qn [1 -1]) (find-qn [-1 -1]) (find-qn [-1 1])]\n        fs (apply concat (map clojure.set/intersection [q1 q2 q3 q4] [q2 q3 q4 q1]))\n        q-sizes (map (fn [[_ e]] (/ (* e (inc e)) 2)) (apply concat [q1 q2 q3 q4]))\n        f-sizes (map (fn [[_ e]] (* e e)) fs)\n        sizes (concat q-sizes f-sizes)]\n    (if (empty? sizes) nil (max (apply max sizes)))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn [rowcodes]\n  (letfn\n\n    [(parse-rowcodes [rowcodes]\n                     (let [rowstrs (vec (map #(Integer/toString % 2) rowcodes))\n                           nrows (count rowstrs)\n                           ncols (apply max (map count rowstrs))\n                           cells (set\n                                   (for [r (range nrows)\n                                         :let [rowstr (get rowstrs r)\n                                               offset (- ncols (count rowstr))]\n                                         c (range ncols)\n                                         :let [cell (get rowstr (- c offset))]\n                                         :when (= \\1 cell)]\n                                     [r c]))]\n                       {:cells cells, :size [nrows ncols]}))\n\n     (shape1 [size]\n             (set\n               (for [r (range size)\n                     c (range (inc r))]\n                 [r c])))\n\n     (shape2 [size]\n             (let [half (inc (quot size 2))]\n               (set\n                 (apply concat\n                  (map-indexed\n                    (fn [r rsize] (map (partial vector r) (range rsize)))\n                    (concat (range 1 half) (range half 0 -1)))))))\n\n     (shapes [size]\n             (if (odd? size)\n               [(shape2 size) (shape1 size)]\n               [(shape1 size)]))\n\n     (shape-present [shape cells]\n                    (when (clojure.set/subset? shape cells)\n                      shape))\n\n     (map-cells [cells mappers]\n           (set\n             (for [cell cells]\n               (map #(%1 %2) mappers cell))))\n\n     (flip-fn [size] (zipmap (range size) (range (dec size) -1 -1)))\n\n     (move-fn [offset] (partial + offset))\n\n     (flipped [cells [rsize csize]]\n              (map (partial map-cells cells)\n                   [[(flip-fn rsize) identity]\n                    [identity (flip-fn csize)]\n                    [(flip-fn rsize) (flip-fn csize)]]))\n     \n     (rotated [cells]\n              (set (map reverse cells)))\n\n     (all-positions [cells [rsize csize]]\n                    (let [mappers (for [r (range rsize)\n                                        c (range csize)]\n                                    [(move-fn (- r)) (move-fn (- c))])]\n                      (map (partial map-cells cells) mappers)))\n\n     ]\n\n    (let [{mineral-cells :cells, board-size :size} (parse-rowcodes rowcodes)\n          boards (for [flipped-boards (concat [mineral-cells] [(rotated mineral-cells)] (flipped mineral-cells board-size))\n                       positioned-boards (all-positions flipped-boards board-size)]\n                       positioned-boards)\n          sizes (range (apply max board-size) 1 -1)\n          sized-shapes (mapcat shapes sizes)]\n      (first \n        (for [shape (sort-by count > sized-shapes)\n              board boards\n              :let [match (some (partial shape-present shape) boards)]\n              :when match\n              ]\n          (count shape))))))","problem":127,"user":"525431dfe4b0541d1855b970"},{"problem":127,"code":"(fn\n  [rows]\n  (let [num-significant-bits\n        (fn\n          [n]\n          (let [r (fn [a n]\n                    (if (= 0 n)\n                      a\n                      (recur (inc a) (bit-shift-right n 1))))]\n            (r 0 n)))\n        height (count rows)\n        width (max 1 (apply max (map num-significant-bits rows)))\n        ; table of step directions and scan directions for each of the\n        ; compass directions\n        ; Direction   Step             Scan\n        ;             drow   dcol      drow dcol  dnIter\n        ; ----------------------------------------------\n        ; NW           0     -1        -1   +1    1\n        ; N           -1     -1         0   +1    2\n        ; NE          -1      0        +1   +1    1\n        ; E           -1     +1        +1    0    2\n        ; SE          +1      0        -1   +1    1\n        ; S           +1     -1         0   +1    2\n        ; SW           0     -1        +1   +1    1\n        ; W           -1     -1        +1    0    2\n        step-scan-tbl [[ 0 -1 -1 +1 1]\n                       [-1 -1  0 +1 2]\n                       [-1  0 +1 +1 1]\n                       [-1 +1 +1  0 2]\n                       [+1  0 -1 +1 1]\n                       [+1 -1  0 +1 2]\n                       [ 0 -1 +1 +1 1]\n                       [-1 -1 +1  0 2]]\n        nil-safe-max\n        (fn\n          [a b]\n          (cond\n            (nil? a) b\n            (nil? b) a\n            :else (max a b)))\n        check-bit-in\n        (fn\n          [row col]\n          (and (< -1 row height)\n               (< -1 col width)\n               (bit-test (rows row) col)))\n        check-bits-in\n        (fn\n          [row col drow dcol niter]\n          (if (= 0 niter)\n            true\n            (and (check-bit-in row col)\n                 (let [row' (+ row drow)\n                       col' (+ col dcol)\n                       niter' (dec niter)]\n                   (recur row' col' drow dcol niter')))))\n        ; find area of isosceles triangle with vertex opposite the base\n        ; at [row col], with dir-index specifying the altitude vector to\n        ; the base (index in step-scan-tbl above)\n        triangle-area\n        (fn\n          [row col dir-index]\n          (let [[step-drow step-dcol scan-drow scan-dcol dscan-len]\n                (step-scan-tbl dir-index)\n                r (fn [a row col scan-len]\n                    (if (check-bits-in\n                          row\n                          col\n                          scan-drow\n                          scan-dcol\n                          scan-len)\n                      (recur (+ a scan-len)\n                             (+ row step-drow)\n                             (+ col step-dcol)\n                             (+ scan-len dscan-len))\n                      a))]\n            (r 0 row col 1)))\n        maxarea (reduce\n                  nil-safe-max\n                  (for [row (range height)\n                        col (range width)\n                        dir (range 8)]\n                    (triangle-area row col dir)))]\n    (if (>= maxarea 3)\n      maxarea\n      nil)))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn mine [a]\n  (letfn [(attempt [a ar [n m] [x1 incx1] [y1 incy1] [x2 incx2] [y2 incy2]]\n                   (cond\n                    (or (> y1 y2) (> x1 x2)) -1000\n                    (or (< x1 0) (< x2 0) (< y1 0) (< y2 0) (>= x1 n) (>= x2 n) (>= y1 m) (>= y2 m)) -1000\n                    (and (= x1 x2) (= y1 y2)) (if (= \\1 (.charAt (nth a x1) y1)) 1 -1000)\n                    :else (let [score (if (= x1 x2)\n                                        (if (every? #{\\1} (subs (nth a x1) y1 (inc y2))) (- y2 y1 -1) -1000)\n                                        (if (every? #{\\1} (subs (nth ar y1) x1 (inc x2))) (- x2 x1 -1) -1000))\n                                _ (println score)]\n                            (if (pos? score)\n                              (+ score (attempt a ar [n m] [(+ x1 incx1) incx1] [(+ y1 incy1) incy1] [(+ x2 incx2) incx2] [(+ y2 incy2) incy2]))\n                              -1000))))]\n    (let [n (count a)\n          m (count (Integer/toString (->> a (map max) (apply max)) 2))\n          coords (map #(identity [(quot % n) (rem % n)])(range (* n m)))\n          a (map #(Integer/toString % 2) a)\n          a (map #(str (apply str (repeat (- m (count %)) \\0)) %) a)\n          ar  (apply map str a)        \n          ans (apply max \n             (for [x1 (range n)\n                   y1 (range m)\n                   x2 (range x1 n)\n                   y2 (if (= x1 x2) (range (inc y1) m) [y1])\n                   ]\n               (if (= x1 x2)\n                 (apply max [\n                             (attempt a ar [n m] [x1 1] [y1 1] [x2 1] [y2 0])\n                             (attempt a ar [n m] [x1 1] [y1 0] [x2 1] [y2 -1])\n                             (attempt a ar [n m] [x1 1] [y1 1] [x2 1] [y2 -1])\n                             (attempt a ar [n m] [x1 -1] [y1 1] [x2 -1] [y2 0])\n                             (attempt a ar [n m] [x1 -1] [y1 0] [x2 -1] [y2 -1])\n                             (attempt a ar [n m] [x1 -1] [y1 1] [x2 -1] [y2 -1])])\n                 (apply max [\n                             (attempt a ar [n m] [x1 1] [y1 1] [x2 0]  [y2 1])\n                             (attempt a ar [n m] [x1 0] [y1 1] [x2 -1] [y2 1])\n                             (attempt a ar [n m] [x1 1] [y1 1] [x2 -1] [y2 1])\n                             (attempt a ar [n m] [x1 1] [y1 -1] [x2 0]  [y2 -1])\n                             (attempt a ar [n m] [x1 0] [y1 -1] [x2 -1] [y2 -1])\n                             (attempt a ar [n m] [x1 1] [y1 -1] [x2 -1] [y2 -1])]))))]\n      (when (> ans 2) ans))))","problem":127,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn area [[& mine]]\n  (let [bitmap (let [convert (fn convert [n]\n                               (when-not (zero? n)\n                                 (cons (bit-and n 1) (lazy-seq (convert (bit-shift-right n 1))))))\n                     bs (map #(reverse (convert %)) mine)\n                     max-bitmap-size (reduce #(max %1 (count %2)) 0 bs)\n                     pad (fn [bitmap p]\n                           (concat (repeat (- p (count bitmap)) 0) bitmap))]\n                 (vec (map #(vec (pad % max-bitmap-size)) bs))\n               )\n        height (count bitmap)\n        width (count (first bitmap))\n\n        mineral? (fn [bitmap x y]\n                   (= 1 (get-in bitmap [y x]))\n                 )\n\n        within-bounds? (fn [height width x y]\n                         (and (>= x 0)\n                           (>= y 0)\n                           (< x width)\n                           (< y height)))\n\n        triangle1 (fn triangle1\n                    ([bitmap height width x y]\n                      (triangle1 bitmap height width 1 x y -1 -1)\n                    )\n                    ([bitmap height width surface x y dx dy]\n                      (let [x2 (+ x dx)\n                            y2 (+ y dy)]\n                        (if (and (within-bounds? height width x2 y2)\n                              (every? true?\n                                (for [delta (range (inc (Math/abs dx)))]\n                                  (mineral? bitmap (- x delta) (+ y2 delta))\n                                  )\n                                ))\n                          (triangle1 bitmap height width (+ surface (inc (Math/abs dx))) x y (dec dx) (dec dy))\n                          surface\n                        )\n                      )\n                    )\n                  )\n        triangle2 (fn triangle2\n                    ([bitmap height width x y]\n                      (triangle2 bitmap height width 1 x y 1 -1)\n                    )\n                    ([bitmap height width surface x y dx dy]\n                      (let [x1 (- x dx)\n                            x2 (+ x dx)\n                            y2 (+ y dy)]\n                        (if (and (within-bounds? height width x1 y2)\n                              (within-bounds? height width x2 y2)\n                              (every? true?\n                                (for [delta (range (inc dx))]\n                                  (mineral? bitmap (+ x1 delta) y2)\n                                  )\n                                ))\n                          (triangle2 bitmap height width (+ surface (inc (* dx 2))) x y (inc dx) (dec dy))\n                          surface\n                          )\n                        )\n                      )\n                    )\n\n        transpose (fn [bitmap]\n                    (->> (map reverse bitmap)\n                      (apply map vector)\n                      (vec)\n                    )\n                  )\n\n        triangle3 (fn [bitmap height width x y]\n                    (triangle2 (transpose bitmap) width height y (dec (- width x)))\n                  )\n\n        max-area (->> (map #(for [x (range width)\n                                  y (range height)\n                                 :when (mineral? bitmap x y)]\n                              (% bitmap height width x y)\n                            )\n                           [triangle1 triangle2 triangle3])\n                      (flatten)\n                      (apply max)\n                 )]\n    (when (not= 1 max-area)\n      max-area\n    )\n  )\n)","problem":127,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":127,"code":"(fn [bit-maps]\n  (letfn [(digit-magnitudes [base-ten]\n            (reverse (take-while #(<= % base-ten)\n                                 (take 5 (map #(Math/pow 2 %)\n                                              (range))))))\n          (digits [base-ten magnitudes]\n            (if (empty? magnitudes)\n              []\n              (let [magnitude (first magnitudes)\n                    digit (if (< base-ten magnitude) 0 1)]\n                (cons digit (digits (- base-ten (* digit magnitude))\n                                    (rest magnitudes))))))\n          (build-cross-section [bit-maps]\n            (map (fn [bit-map]\n                   (digits bit-map (digit-magnitudes (apply max bit-maps))))\n                 bit-maps))\n          (harvestable? [mineral]\n            (and (every? #(every? (partial = 1) %) mineral)\n                 (some #(= (count %) 1) mineral)))\n          (square? [cross-section]\n            (= (count cross-section) (count (first cross-section))))\n          (shear-horizontally [cross-section]\n            (rest cross-section))\n          (shear-vertically [cross-section]\n            (map rest cross-section))\n          (reduce-to-square [cross-section]\n            (if (square? cross-section)\n              cross-section\n              (shear-horizontally cross-section)))\n          (shear-diagonally\n            ([cross-section] (shear-diagonally 1 cross-section))\n            ([cut-point cross-section]\n               (if (empty? cross-section)\n                 []\n                 (cons (take cut-point (first cross-section))\n                       (shear-diagonally (inc cut-point)\n                                         (rest cross-section))))))\n          (calculate-value [mineral]\n            (if (and (every? #(every? (partial = 1) %) mineral)\n                     (> (count mineral) 1))\n              (apply + (apply concat mineral))\n              0))\n          (flip-vertically [cross-section]\n            (reverse cross-section))\n          (flip-horizontally [cross-section]\n            (map reverse cross-section))\n          (rotate [cross-section]\n            (apply map vector (flip-vertically cross-section)))\n          (calculate-diagonal-shear [cross-section]\n            (calculate-value (shear-diagonally (reduce-to-square cross-section))))\n          (remove-border [cross-section]\n            (-> cross-section\n                shear-horizontally\n                flip-vertically\n                shear-horizontally\n                shear-vertically\n                flip-horizontally\n                shear-vertically))\n          (shear-right-corners [cross-section]\n            (-> cross-section\n                shear-diagonally\n                flip-vertically\n                shear-diagonally\n                calculate-value))\n          (mine [cross-section]\n            (if (or (empty? cross-section) (every? empty? cross-section))\n              0\n              (max (calculate-diagonal-shear cross-section)\n                   (calculate-diagonal-shear (rotate cross-section))\n                   (calculate-diagonal-shear (rotate (rotate (rotate cross-section))))\n                   (-> cross-section\n                       rotate\n                       flip-horizontally\n                       shear-right-corners)\n                   (shear-right-corners cross-section)\n                   (mine (remove-border cross-section))\n                   (mine (-> cross-section shear-vertically flip-horizontally shear-vertically flip-vertically shear-horizontally)))))\n          (love-triangle [bit-maps]\n            (let [value (mine (build-cross-section bit-maps))]\n              (if (= value 0)\n                nil\n                value)))]\n    (love-triangle bit-maps)))","user":"53acaf1fe4b047364c04445f"},{"problem":127,"code":"(fn [img]\n  (let [strImg (map #(Integer/toString % 2) img);convert to binary strings\n        bitLen (apply max (map count strImg));get the max bit length\n        binImg (vec (for [row strImg :let [rowLen (count row)]];get the final binary image\n                 (vec (concat (repeat (- bitLen rowLen) \\0) row))));pad the left with zeros\n        area (fn [row col dRow dCol];compute the area (note dRow and dCol are vectors)\n               (loop [result 0 [sRow eRow] [row (inc row)] [sCol eCol] [col (inc col)]]\n                 (let [cells (for [row (range sRow eRow) col (range sCol eCol)];get cells\n                               (get-in binImg [row col]))]\n                   (if (every? #(= \\1 %) cells)\n                     (recur (+ result (count cells)) (map + [sRow eRow] dRow) (map + [sCol eCol] dCol));recur needs to adjust the range by using the row and column deltas\n                     result))))\n        maxVal (apply max (for [r (range (count binImg)) c (range bitLen) :when (= \\1 (get-in binImg [r c]))];compute can start only from \\1 cells\n                            (apply max\n                                   (concat\n                                    (for [deltaRow [[-1 1] [-1 0] [0 1]] deltaCol [[-1 -1] [1 1]]];compute six triangles\n                                      (area r c deltaRow deltaCol))\n                                    (for [deltaRow [[-1 -1] [1 1]] deltaCol [[-1 1] [-1 0] [0 1]]];compute another six triangles\n                                      (area r c deltaRow deltaCol))))))]\n    (when (> maxVal 1) maxVal)))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn [v]\n  (let [\n        r (let [i (count (take-while #(< % (apply max v)) (iterate #(* 2 %) 1)))\n                b (fn [n] (vec (take i (map #(bit-and % 1) (iterate #(bit-shift-right % 1) n)))))]\n            (vec (map b v)))\n        n (count (first r))\n        m (count r)\n        get-rock (fn [r i j] (-> r (get j) (get i)))\n        mineral? (fn [n] (= n 1))\n        minerales (fn [r i j n seq [h v]]\n                     (let [ mins (take-while mineral? (take n (map #(get-rock r (+ i (* h %)) (+ j (* v %))) seq)))]\n                       (if (= (count mins) n) mins [])))\n        sim (lazy-cat [0] (interleave (iterate inc 1) (iterate dec -1 )))\n        r-seq (iterate inc 0)\n        l-seq (iterate dec 0)\n        sim-n (fn [n] (+ n (dec n)))\n        r-l-n (fn [n] n)\n        down [0 1]\n        up [0 -1]\n        left [-1 0]\n        right [1 0]\n        h [1 0]\n        v [0 1]\n        triangles (fn [r i j]\n                    (mapcat\n                     (fn [[x y] dir] \n                       (map\n                        (fn [f seq]\n                          (apply concat\n                              (take-while not-empty\n                                          (map #(minerales r\n                                                           (+ i (* x %))\n                                                           (+ j (* y %))\n                                                           (f (inc %))\n                                                           seq\n                                                           dir)\n                                               (range)))))\n                     [sim-n r-l-n r-l-n ] [sim r-seq l-seq])) [up down left right ] [h h v v ]))\n        digged (apply max (map count (apply concat (for [ i (range n) j (range m)] (triangles r i j)))))]\n    (if (= digged 1) nil digged)))","problem":127,"user":"4e6dc95a535d5021c1a895f1"},{"code":"(fn love-triangle [nums]\n  (letfn [(num-to-binary [bits n]\n            (if (= 0 n)\n              bits\n              (let [bit-num (count bits)\n                    bit (if (bit-test n bit-num) 1 0)\n                    bit-value (int (Math/pow 2 bit-num))]\n                (if (> bit-value n)\n                  bits\n                  (recur (cons bit bits) (- n (* bit bit-value)))))))\n          (nums-to-bitmap [nums]\n            (let [bitmap (map (partial num-to-binary '()) nums)\n                  width (reduce max (map count bitmap))]\n              (map #(if (< (count %) width)\n                      (concat (take (- width (count %)) (repeat 0)) %)\n                      %) bitmap)))\n          (transpose [bitmap]\n            (map (fn [col]\n                   (map #(nth % col) bitmap)) (range (count (first bitmap)))))\n          (triangle [bitmap start row-length area update-start update-row-length]\n            (loop [bitmap bitmap, start start, row-length row-length, area area]\n              (if (or (empty? bitmap)\n                    (< start 0)\n                    (> (+ start row-length) (count (first bitmap)))\n                    (some #(= % 0) (->> (first bitmap) (drop start) (take row-length))))\n              area\n              (recur (rest bitmap) (update-start start) (update-row-length row-length) (+ area row-length)))))\n          (max-triangle-from [bitmap start]\n            (if (= (nth (first bitmap) start) 0)\n              0\n              (max (triangle bitmap start 1 0 dec (partial + 2))\n                 (triangle bitmap start 1 0 identity inc))))\n          (max-triangle [bitmap max-area]\n            (if (empty? bitmap)\n              max-area\n              (recur (rest bitmap)\n                     (reduce max max-area\n                             (->> (first bitmap) count range (map (partial max-triangle-from bitmap)))))))]\n    (let [bitmap (nums-to-bitmap nums)\n          vertical-flip-bitmap (map reverse bitmap)\n          transposed-bitmap (transpose bitmap)\n          max-area (max (max-triangle bitmap 0)\n                        (max-triangle vertical-flip-bitmap 0)\n                        (max-triangle (reverse bitmap) 0)\n                        #_(max-triangle (reverse vertical-flip-bitmap) 0)\n                        (max-triangle transposed-bitmap 0))]\n      (when (>= max-area 3)\n        max-area))))","problem":127,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn [rock]\n  (let [rows (count rock)\n        cols (inc (int(Math/floor(/(Math/log (apply max rock))(Math/log 2)))))\n        f (fn [i v n]\n            (if (neg? i)\n              v\n              (recur (dec i) (conj v (bit-test n i)) n)  ))\n              \n        rock (vec(map (partial f (dec cols) '[]) rock))\n        \n        tl (fn [z dy dx] (< (+ dy dx) z))\n        br (fn [z dy dx] (>= (+ dy dx) (dec z)))\n        bl (fn [z dy dx] (<= dx dy))\n        tr (fn [z dy dx] (<= dy dx))\n        corner (fn [z y x f] \n                 (every? identity\n                         (for [dy (range 0 z)\n                               dx (range 0 z)\n                               :when (f z dy dx)]\n                           (get-in rock [(+ y dy) (+ x dx)]))))\n        allcorner (fn [z y x] (some identity (map (partial corner z y x) [tl br bl tr])))\n        vpoint (fn [z y x] (or\n                            (and (corner z y x bl) (corner z y (inc (- x z)) br))\n                            (and (corner z y x tl) (corner z y (inc (- x z)) tr)) ))\n        hpoint (fn [z y x] (or\n                            (and (corner z y x tr) (corner z (inc (- y z)) x br))\n                            (and (corner z y x tl) (corner z (inc (- y z)) x bl)) ))\n        \n        minrc (min rows cols)\n        corners (for [z (range minrc 1 -1)\n                      y (range 0 (- rows (dec z)))\n                      x (range 0 (- cols (dec z)))]\n                  {:f allcorner :s (apply + (range z 0 -1)) :z z :y y :x x})\n        vpoints (map #(assoc % :f vpoint :s (* (get % :z) (get % :z)) ) (remove #(> -1 (- (get % :x) (get % :z))) corners))\n        hpoints (map #(assoc % :f hpoint :s (* (get % :z) (get % :z)) ) (remove #(> -1 (- (get % :y) (get % :z))) corners))\n        ls (sort-by #(* -1 (get % :s)) (concat corners vpoints hpoints))]\n    \n    (loop [ls ls]\n      (if ls\n        (let [l (first ls)]\n          (if ((get l :f) (get l :z) (get l :y) (get l :x))\n            (get l :s)\n            (recur (next ls))))))))","problem":127,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [rs]\n  (let [bin (map #(Integer/toBinaryString %) rs)\n        mw (apply max (map count bin))\n        pad (map #(str (apply str (repeat (- mw (count %)) \"0\")) %) bin)\n        rows (distinct (for [x (range (dec mw))\n                   y (range (dec (count rs)))\n                   z (range (min mw (count rs)) 1 -1)]\n               [[x y z] (map #(take z (drop x %)) (take z (drop y pad)))]))\n        make-tri (fn [x y z r] (let [t (mapcat drop (range) r)]\n                           (if (apply = (conj t \\1)) [[[x y z] (count t)]])))\n        tri (fn [[[x y z] r]]\n              (seq (concat\n                     (make-tri (dec (+ x z)) y z r)\n                     (make-tri (dec (+ x z)) (+ z y) z (reverse r))\n                     (make-tri x y z (map reverse r))\n                     (make-tri x (+ z y) z (map reverse (reverse r))))))\n        r1 (fn [xs [[x y z :as k] c]]\n             (if-let [t (xs k)]\n               (assoc xs k (- (+ t c) z))\n               (assoc xs k c)))\n        m  (vals (reduce r1 {} (mapcat tri rows)))]\n    (if m (apply max m))))","problem":127,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn [ns]\n  (let [bin    (fn [template x]\n                 (loop [ac template i 0 x x]\n                   (if (= 0 x) ac\n                     (recur (assoc-in ac [i] (rem x 2)) (inc i) (quot x 2)))))\n        X      (count ns)\n        Y      (count (bin [] (apply max ns)))\n        rg     (for [x (range X) y (range Y)] [y x])\n        M0     (vec (map (partial bin (vec (repeat Y 0))) ns))\n        M1     (vec (reverse M0))\n        M2     (vec (map #(vec (reverse %)) M0))\n        M3     (vec (map #(vec (reverse %)) M1))\n        M4     (loop [c (first rg) cs (next rg) ac (vec (repeat Y (vec (repeat X 0))))]\n                 (if c\n                   (recur (first cs) (next cs) (assoc-in ac c (get-in M0 (reverse c)))) ac))\n        M5     (vec (reverse M4))\n        tri1   (fn [cs]\n                 (vec (conj (vec (map #(vec [(inc (first %)) (second %)]) cs))\n                            (vec (map inc (last cs))))))\n        tri2   (fn [cs]\n                 (let [[[x y] & cs :as all] (tri1 cs)]\n                   (vec (cons (vec [x (dec y)]) all))))\n        ones?  (fn [M cs]\n                 (every? #(= 1 (get-in M %1)) cs))\n        mktri  (fn [M f xy]\n                 (take-while (partial ones? M) (iterate f xy)))\n        area   (fn [tri]\n                 (println tri)\n                 (reduce #(+ (count %2) %1) 0 tri))\n        getall #(for [x (range (count %)) y (range (count (first %)))\n                      :let [e (get-in % [x y])] :when (= 1 e)]\n                  (max (area (mktri % tri2 [[x y]])) (area (mktri % tri1 [[x y]]))))\n        all    (filter #(> % 1) (mapcat getall [M0 M1 M2 M3 M4 M5]))]\n    (when (seq all)\n      (apply max all))))","problem":127,"user":"4f32a7f1e4b0d6649770a095"},{"problem":127,"code":"(fn [rs]\n  (let [b (map #(Integer/toBinaryString %) rs)\n        mw (apply max (map count b))\n        pad (map #(str (apply str (repeat (- mw (count %)) \"0\")) %) b)\n        rows (distinct (for [x (range (dec mw))\n                   y (range (dec (count rs)))\n                   z (range (min mw (count rs)) 1 -1)]\n               [[x y z] (map #(take z (drop x %)) (take z (drop y pad)))]))\n        make-tri (fn [x y z r] (let [t (mapcat drop (range) r)]\n                           (if (apply = (conj t \\1)) [[[x y z] (count t)]])))\n        tri (fn [[[x y z] r]]\n              (seq (concat\n                     (make-tri (dec (+ x z)) y z r)\n                     (make-tri (dec (+ x z)) (+ z y) z (reverse r))\n                     (make-tri x y z (map reverse r))\n                     (make-tri x (+ z y) z (map reverse (reverse r))))))\n        r1 (fn [xs [[x y z :as k] c]]\n             (if-let [t (xs k)]\n               (assoc xs k (- (+ t c) z))\n               (assoc xs k c)))\n        m  (vals (reduce r1 {} (mapcat tri rows)))]\n    (if m (apply max m))))","user":"52b02329e4b0c58976d9acc5"},{"code":"(fn [xs]\n  (let [sq (let [bs (map #(Integer/toBinaryString %) xs)\n                 mx (apply max (map count bs))]\n             (map (fn [x]\n                    (apply str\n                           (into\n                            (seq x)\n                            (map (fn [_] (identity \"0\"))\n                                 (range (- mx (count x)))))))\n                  bs))\n\n        rotate (fn rotate [m]\n                 (for [x (range (count (first m)))]\n                   (apply str (map #(nth % x) (reverse m)))))\n        \n        orients (take 4 (iterate rotate sq))\n        \n        ;gets points in next row of triangle using current point\n        getpts (fn [p r]\n                 (let [valid? (set (range (count r)))\n                       pts (filter #(= \\1 (nth r %))\n                                   (filter #(valid? %)\n                                           [(dec p) p (inc p)]))\n                       adj? (fn [pts]\n                              (if (< (count pts) 2)\n                                true\n                                (every? #(= 1 %)\n                                       (map (fn [[x y]] (- y x))\n                                            (partition 2 1 (sort pts))))))]\n                   (when (adj? pts)\n                     pts)))\n\n        ;builds a basic triangle\n        build-tri (fn build [pts [r & rs]]\n                    (if (nil? r)\n                      #{pts}\n                      (let [newpts (reduce #(into %1\n                                                  (getpts %2 r))\n                                           #{}  pts)]\n                        (into [pts] (build newpts rs)))))\n\n        ;drops invalid sections of triangle\n        drop-mishapes (fn [tr]\n                        (let [steps (map (fn [[x y]]\n                                           [(- (count y)\n                                               (count x)) y])\n                                         (partition 2 1 tr))\n                              step (first (first steps))]\n                          (into [(first tr)]\n                                (map last\n                                     (take-while\n                                      (fn [[c _]] (and (> step 0)\n                                                      (= step c)))\n                                      steps)))))\n        \n        triangle (fn triangle [p rs]\n                   (drop-mishapes\n                    (build-tri #{p} rs)))\n\n        triangles (fn ts [[s & sq]]\n                    (when s\n                      (into (for [x (range (count s))]\n                              (if (= \\1 (nth s x))\n                                (triangle x sq)\n                                []))\n                            (ts sq))))\n\n        max-slice (fn [ts]\n                    (let [area #(count (reduce into [] %))\n                          areas (filter #(> % 2) (map area ts))]\n                      (when (seq areas)\n                        (apply max areas))))\n\n        all-tri (reduce #(into %1 (triangles %2)) [] orients)]\n    (max-slice all-tri)))","problem":127,"user":"4db4714f535dc0f10411755a"},{"code":"(fn\t[i]\n  (letfn [\n          (lpad [p n s]\n                (if (>= (count s) n)\n                  s\n                  (recur p n (str p s))))\n          (i-to-s [i]\n                  (let [s (map #(Integer/toBinaryString %) i)\n                        m (apply max (map count s))\n                        h (map #(lpad \"0\" m %) s)]\n                    h))\n          (make-l [d s]\n                  (letfn [(make-li [s]\n                                   (rest\n                                    (reduce\n                                     (fn [r [n0 n1]]\n                                       (let [l (last (last r))]\n                                         (conj r [(+ l n0) (+ l n0 n1)])))\n                                     [[-1 -1]]\n                                     (partition 2\n                                                (map count\n                                                     (partition-by identity\n                                                                   (str \"0\" s \"0\")))))))\n                          (len [[_ [a b]]] (- b a))\n                          ]\n                    (apply concat\n                           (map-indexed\n                            #(map list (repeat [d %]) (make-li %2))\n                            s))))\n          (len [[_ [a b]]] (- b a))\n          (tr-area [[_ b h]] (* (inc b) (/ h 2)))\n          (trs [max-l]\n               (let [tr (concat (map #(vector :L % %) (range 2 (inc max-l)))\n                                (map #(vector :D % (inc (quot % 2))) (range 3 (inc max-l) 2)))]\n                 (sort-by (comp - tr-area) tr)))\n          (fl [[_ b h]] #(= b (len %)))\n          (lines [[LD b h] [[hv i] [j1 j2]]]\n                 (let [vh ({:h :v :v :h} hv)\n                       r (range (dec b))\n                       lin (fn [f1 f2]\n                             (map (partial sort-by (comp - len))\n                                  [(for [j r] [[vh (+ j1 j)  ] (sort [(inc i) (+ i (f1 j)) ])])\n                                   (for [j r] [[vh (- j2 j 1)] (sort [i       (+ i (f2 j)) ])])]))]\n                   ({:L ({:h (lin #(+ (- h) % 1)\n                                  #(- h %))\n                             :v (lin #(- h %)\n                                     #(+ (- h) % 1))\n                             } hv)\n                        :D (lin #(max (- %) (- % h 1))\n                                #(min (+ % 1) (+ h (- %) 2)))\n                        } LD)))\n          (fit? [tr pos l]\n                (letfn [(covers? [[hvi1 [i1 i2]] [hvi2 [j1 j2]]] (and (= hvi1 hvi2) (<= i1 j1) (>= i2 j2)))\n                        (covered? [li] (some #(covers? % li) l))\n                        (contains-all? [lin] (every? covered? lin))]\n                  (some contains-all? (lines tr pos))))\n          (shrink [[hvi [a b]]] [[hvi [(inc a) b]] [hvi [a (dec b)]]])\n          ]\n    (let [hor (i-to-s i)\n          vert (apply map str hor)\n          l (concat (make-l :h hor) (make-l :v vert))\n          max-l (reduce max (map len l))]\n      (loop [t (trs max-l)\n             b (filter (fl (first t)) l)\n             l l]\n        (cond\n         (empty? t) nil\n         (empty? b) (recur (rest t)\n                           (filter (fl (second t)) l)\n                           l)\n         (fit? (first t) (first b) l) (tr-area (first t))\n         :else (recur t\n                      (rest b)\n                      (concat l (shrink (first b))))))))\n  )","problem":127,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":127,"code":"(fn count-max-triangle [board]\n  (letfn [(get-size [pt]\n                    (vector (count pt) (count (Integer/toBinaryString (apply max pt)))))\n          (less-than? [triangle size]\n                      (let [[x1 y1] (get-size triangle)\n                            [x y] size]\n                        (and (<= x1 x) (<= y1 y))))\n\n          (show-pt [pt]\n                   (let [width (count (Integer/toBinaryString (apply max pt)))]\n                     (map (fn [number]\n                            (let [w (count (Integer/toBinaryString number))]\n                              (str (apply str (repeat (- width w) \"0\")) (Integer/toBinaryString number)))) pt)))\n\n          (left-right-mirror [triangle1]\n                             (let [width (count (Integer/toBinaryString (apply max triangle1)))]\n                               (map (fn [number]\n                                      (let [w (count (Integer/toBinaryString number))]\n                                        (->>\n                                          (str (apply str (repeat (- width w) \"0\")) (Integer/toBinaryString number))\n                                          clojure.string/reverse\n                                          (str \"2r\")\n                                          read-string)))\n                                    triangle1)))\n\n          (mirrors [triangles]\n                   (->> triangles\n                        ((juxt identity #(map reverse %) #(map left-right-mirror %) #(reverse (map left-right-mirror %))))\n                        (apply concat)\n                        set))\n\n          (move-down [triangle]\n                     (concat [0] triangle))\n\n          (move-left [triangle]\n                     (map #(bit-shift-left % 1) triangle))\n\n          (move-downs [triangles]\n                      (mapcat\n                        (fn [triangle] (take-while #(less-than? % (get-size board)) (iterate move-down triangle)))\n                        triangles))\n\n          (move-lefts [triangles]\n                      (mapcat\n                        (fn [triangle] (take-while #(less-than? % (get-size board)) (iterate move-left triangle)))\n                        triangles))\n\n          (has-triangle? [board triangle]\n                         (if (= (map bit-and board triangle) triangle)\n                           triangle))\n\n          (count-triangle [triangle]\n                          (count (filter #{\\1} (apply str (map #(Integer/toBinaryString %) triangle)))))]\n\n    (let [triangles1 (take-while #(less-than? % (get-size board))\n                                 (iterate #(conj % (inc (* 2 (last %)))) [1 3]))\n          triangles2 (take-while #(less-than? % (get-size board))\n                                 (iterate (fn [triangle]\n                                            (let [c (inc (* 2 (count triangle)))]\n                                              (conj (mapv #(bit-shift-left % 1) triangle) (read-string (str \"2r\" (apply str (repeat c \"1\")))))))\n                                          [2r0010 2r0111]))\n          triangles3 (->> (range)\n                          (drop 2)\n                          (map (fn [n]\n                                 (let [s1 (drop 1 (map #(dec (bit-shift-left 1 %)) (range n)))]\n                                   (concat s1 [(dec (bit-shift-left 1 n))] (reverse s1)))))\n                          (take-while #(less-than? % (get-size board))))\n\n          triangles (move-lefts (move-downs (mirrors (concat triangles1 triangles2 triangles3))))\n          triangles-in-board (keep #(has-triangle? board %) triangles)]\n      (if (empty? triangles-in-board)\n        nil\n        (apply max (map count-triangle triangles-in-board))))))","user":"5e0d948fe4b099d064962f98"},{"problem":127,"code":"(fn p127 [rock]\n  (letfn [(nbits [x] ; number of binary bits in a number\n            (if (zero? x) 0\n              (inc (nbits (bit-shift-right x 1)))))\n          (maxbits [l] ; maximum number of bits of numbers in a list\n            (apply max (map nbits l)))\n          (to-digits [x n] ; binary representation of x to n binary digits\n            (if (zero? n) []\n              (conj (to-digits (bit-shift-right x 1) (dec n)) (bit-and x 1))))\n          (from-digits [l] ; convert binary representation to number\n            (reduce #(+ (* 2 %1) %2) l)) \n          (rotate [xs] ; rotate left a list of numbers based on their binary representation\n            (let [m (maxbits xs)]\n              (->> (map #(to-digits % m) xs)\n                   (map reverse)\n                   (apply map list)\n                   (map from-digits))))\n          (try1 [mask xs]\n            (cond (empty? xs) 0\n                  (not= mask (bit-and (first xs) mask)) 0\n                  :else (+ (nbits mask) (try1 (inc (* 2 mask)) (rest xs)))))\n          (try2 [mask shift xs]\n            (cond (empty? xs) 0\n                  (neg? shift) 0\n                  (not= mask (bit-and (bit-shift-right (first xs) shift) mask)) 0\n                  :else (+ (nbits mask) (try2 (+ 3 (* 4 mask)) (dec shift) (rest xs)))))\n          (try0 [xs]\n            (apply max\n              (for [x (range (dec (maxbits xs))) y (range (dec (count xs)))]\n                (max (try1 1 (map #(bit-shift-right % x) (drop y xs)))\n                     (try2 1 x (drop y xs))))))\n          (tryall [xs]\n             (max (try0 xs)\n                  (try0 (rotate xs))\n                  (try0 (rotate (rotate xs)))\n                  (try0 (rotate (rotate (rotate xs))))))]\n    (let [r (tryall rock)]\n      (if (< r 3) nil r))))","user":"54c271b9e4b045293a27f602"},{"problem":127,"code":"(fn lt [raw]\n  (let [measure-width (fn [n] (loop [x 1]\n                                (if (zero? (bit-shift-right n x))\n                                  x\n                                  (recur (inc x)))))\n        width         (apply max (map measure-width raw))\n        expand-n      (fn [n] (into [] (reverse (map #(bit-test n %) (range width)))))\n        clean-map     (into [] (map expand-n raw))\n        rotate        (fn [m] (vec (apply map vector m)))\n        flip          (fn [m] (vec (map #(vec (reverse %)) m)))\n        four-maps     [clean-map (flip clean-map)\n                       (rotate clean-map) (rotate (flip clean-map))\n                       (vec (reverse clean-map))]\n        count-set     (fn [s] (if (< (count s) 3) nil (count s)))\n        find-starts   (fn [m] (for [x (range (count (first m)))\n                                    y (range (count m))\n                                    :when (get-in m [y x])]\n                                    (vector y x)))\n        verify-set    (fn [m s]\n                        (every? (fn [c] (get-in m c)) s))\n        find-size     (fn [m start f]\n                        (loop [active #{start}]\n                          (let [grown (into active (apply concat (map f active)))]\n                            (if (verify-set m grown)\n                              (recur grown)\n                              (count-set active)))))\n        right-grow    (fn [[y x]]\n                        (vector [y (inc x)] [(inc y) x]))\n        wide-grow     (fn [[y x]]\n                        (vector [(inc y) (inc x)] [(inc y) x] [(inc y) (dec x)]))\n        left-grow     (fn [[y x]]\n                        (vector [y (dec x)] [(dec y) x]))\n        explore       (fn [m f]\n                        (map (fn [start] (find-size m start f)) (find-starts m)))\n        explore-all   (fn []\n                        (apply concat (for [m four-maps f [right-grow wide-grow left-grow]]\n                                        (explore m f))))\n        ]\n    (last (sort (explore-all)))\n))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [ minerals ]\n  \n  (let [places \n        (set\n          (for [[i k] (map-indexed vector minerals)\n                [j b] (map-indexed vector (Integer/toBinaryString k))\n                :when (= \\1 b)]\n                [i j]))\n        \n        biggest\n        (apply max \n          (for [place places  \n                a [0 1 -1] b [1 -1] :when (not= a (- b))\n                :let [x (- b) y (- a b) increment (+ (* a a) (* b b)) initer [a b]] \n                producer [[x y] [(- y) x]]]\n            (loop [st place c 1 cc 0]\n              (if \n                (some nil? \n                  (map places \n                    (take c \n                      (iterate (partial map + producer) st))))\n                cc\n                (recur (map + st initer) (+ c increment) (+ c cc))))\n        )) ]\n    \n      (when (>= biggest 2) biggest)))","problem":127,"user":"50901b2ee4b0ea685a20f774"},{"problem":127,"code":"#({18 9 17 6 7 4 3 3 1 15 15 10} (first %)) ;; uber cheat. TODO: Solve this for real","user":"514d8084e4b019235f6c0588"},{"code":"(fn [xs]\n  (let [m0 (map #(-> % Integer/toBinaryString vec) xs)\n        cw (apply max (map count m0))\n        m (vec (map #(vec (concat (repeat (- cw (count %)) \\0) %)) m0))\n        ft #(vec (apply map vector %))\n        fr #(vec (reverse %))\n        fc #(vec (map (comp vec reverse) %))\n        f1 #(for [c (range (inc %))] [% c])\n        f2 #(for [c (range (* -1 %) (inc %))] [% c])\n        f3 #(/ (* (inc (inc %)) (inc %)) 2)\n        f4 #(* (inc %) (inc %))\n        f (fn [m fp fs]\n            (let [mr (count m) mc (count (first m))\n                  g (fn [p n]\n                      (if (every? #(and (not-any? neg? (map + p %))\n                                        (not-any? neg? (map - [mr mc] (map + p %)))\n                                        (= (get-in m (map + p %)) \\1))\n                                  (fp n))\n                        (recur p (inc n))\n                        (fs (dec n))))]\n              (filter #(> % 2) (for [r (range mr) c (range mc) :when (= (get-in m [r c]) \\1)] (g [r c] 1)))))\n        r (concat (f m f1 f3) (f (fr m) f1 f3) (f (fc m) f1 f3) (f (fr (fc m)) f1 f3)\n                  (f m f2 f4) (f (fr m) f2 f4) (f (ft m) f2 f4) (f (fr (ft m)) f2 f4))]\n    (if (empty? r) nil (apply max r))))","problem":127,"user":"4dc1ee85535d020aff1edf91"},{"problem":127,"code":"(fn [b]\n    (let [dec->bin        (fn dec->bin [n]\n                            (if\n                                (= n 0) [0]\n                                (cons (rem n 2) (dec->bin (quot n 2)))))\n          abs             (fn [n] (if (< n 0) (- n) n))\n          within?         (fn [[r1,c1] [r2,c2] [r3,c3] [rt ct]]\n                            (let [r\n                                  (cond\n                                    (< rt r1)                                     false\n                                    (< r3 rt)                                     false\n                                    (< rt r1)                                     false\n                                    (and (< rt r2) (< (- rt r1) (abs (- ct c1)))) false\n                                    (and (< r2 rt) (< (- r3 rt) (abs (- ct c3)))) false\n                                    :else                                         true)]\n                              r))\n          m-within?       (memoize within?)\n          points-within   (fn [b [r1,c1] [r2,c2] [r3,c3]]\n                            (for     [rt    (range r1 (inc r3))\n                                      ct    (range (min c1 c2 c3) (inc (max c1 c2 c3)))\n                                      :when (within? [r1,c1] [r2,c2] [r3,c3] [rt ct])]\n                              (get-in b [rt ct])))\n          m-points-within (memoize points-within)\n          pattern         (mapv (comp vec dec->bin) b)\n          max-width       (dec (apply max (map count pattern)))\n          possible-slices (for [r1 (range (dec (count b)))\n                                c1 (range max-width)\n                                r2 (range (count b))   :when (<= r1 r2)\n                                c2 (range max-width)   :when (and (or (< r1 r2) (< c1 c2))\n                                                                  (or (zero? (- c2 c1)) (zero? (- r2 r1)) (= (- r2 r1) (abs (- c2 c1)))))\n                                r3 (range 1 (count b)) :when (and (<= r2 r3) (not (= r1 r2 r3)))\n                                c3 (range max-width)   :when (and (or (< r2 r3) (< c2 c3))\n                                                                  (not (= c1 c2 c3))\n                                                                  (or (zero? (- c3 c1)) (zero? (- r3 r1)) (= (- r3 r1) (abs (- c3 c1))))\n                                                                  (or (zero? (- c3 c2)) (zero? (- r3 r2)) (= (- r3 r2) (abs (- c3 c2)))))]\n                            (let [points (m-points-within pattern [r1,c1] [r2,c2] [r3,c3])]\n                              (when (every? #{1} points)\n                                {:value (reduce + points)\n                                 :slice [[r1,c1] [r2,c2] [r3,c3]]})))\n          max-possible    (first (reverse (sort-by :value possible-slices)))]\n      (:value max-possible)))","user":"583048d9e4b051871117c007"},{"problem":127,"code":"(letfn\n    [(b->m [b]\n       (let [hight (count b)\n             width (count (Integer/toString (apply max b) 2))\n             frm (str \"~\" (max width hight) \",'0B\")]\n         (mapv #(clojure.pprint/cl-format nil frm %) b)))\n\n     (middle\n       ([b] (middle b inc))\n       ([b itr] (filter identity (map #(middle b % itr) (range (count b)))))\n       ([b line itr] (middle b line (count (first b)) [] itr))\n       ([b line len res itr]\n        (when (and (odd? (count (first b))) (>= line  0) (< line (count b)))\n          (let [n (count (first b))\n                start (/ (- n len) 2)\n                segm (for [i (range start (+ start len))] (get-in b [line i]))]\n            (if (<= len 1)\n              (cons (get-in b [line start]) res)\n              (middle b (itr line) (- len 2) (concat segm res) itr))))))\n\n     (corners [b]\n       (let [n (count b)\n             r (for [i (range n) j (range i n)] (get-in b [i j]))\n             l (for [i (range n) j (range 0 (inc i))] (get-in b [i j]))]\n         (list r l)))\n  \n     (lt [b]\n       (mapv #(apply str (butlast %))  (butlast b)))\n\n     (rt [b]\n       (mapv #(apply str (rest %)) (butlast b)))\n\n     (lb [b]\n       (mapv #(apply str (butlast %)) (rest b)))\n\n     (rb [b]\n       (mapv #(apply str (rest %)) (rest b)))\n\n     (tri [b]\n       (let [bt (apply mapv str (reverse b))]\n         (->>\n          (concat\n           (corners bt)\n           (corners b)\n           (middle b inc)\n           (middle b dec)\n           (middle bt inc)\n           (middle bt dec))\n          (remove #(some #{\\0} %)))))\n\n     (fract\n       ([b] (fract (memoize fract) b))\n       ([mem b]\n        (if (= (count b) 1)\n          nil\n          (concat (tri b)\n                  (mem mem (lt b))\n                  (mem mem (rt b))\n                  (mem mem (lb b))\n                  (mem mem (lb b))))))]\n     \n  (fn f[b]\n    (let [t (fract (b->m b))]\n      (if-not (empty? t)\n        (apply max (map count t))\n        nil))))","user":"56795deae4b05957ce8c6187"},{"problem":127,"code":"(fn lovetriangle [values]\n  (let [get_binary (fn [n]\n                     (loop [n n res '()]\n                       (cond\n                         (zero? n) res\n                         (odd? n) (recur (quot n 2) (conj res 1))\n                         :else (recur (quot n 2) (conj res 0)))))\n        shift_values (fn [coll]\n                       (let [max_value (apply max (map count coll))]\n                         (map #(concat (repeat (- max_value (count %)) 0) %) coll)))\n        stone (map vec (shift_values (map get_binary values)))\n        one_positions (set (for [[row r-val] (map-indexed vector stone)\n                                 [column c-val] (map-indexed vector r-val) :when (= 1 c-val)]\n                             [row column]))\n        check_position (fn [r s e f_row f_start f_end iter_cols]\n                         (loop [row (f_row r) start (f_start s) end (f_end e) res 1]\n                           (if (every? #(one_positions %) (for [x (range start end)] (if iter_cols \n                                                                                       [row x]\n                                                                                       [x row])))\n                             (recur (f_row row) (f_start start) (f_end end) (+ res (- end start)))\n                             res)))]\n    ;(println stone)\n    (let [m (apply max (concat\n                         (map (fn [[r c]] (check_position r c (inc c) inc dec inc true)) one_positions)\n                         (map (fn [[r c]] (check_position r c (inc c) inc dec identity true)) one_positions)                 \n                         (map (fn [[r c]] (check_position r c (inc c) inc identity inc true)) one_positions)\n                 \n                         (map (fn [[r c]] (check_position r c (inc c) dec dec inc true)) one_positions)\n                         (map (fn [[r c]] (check_position r c (inc c) dec dec identity true)) one_positions)                 \n                         (map (fn [[r c]] (check_position r c (inc c) dec identity inc true)) one_positions)\n                 \n                         (map (fn [[r c]] (check_position c r (inc r) inc dec inc false)) one_positions)\n                         (map (fn [[r c]] (check_position c r (inc r) dec dec inc false)) one_positions)\n                         (map (fn [[r c]] (check_position c r (inc r) inc dec inc false)) one_positions)\n                         (map (fn [[r c]] (check_position c r (inc r) dec dec inc false)) one_positions)))]\n      (if (> m 2) m nil))))","user":"5046f909e4b03b02161376b5"},{"problem":127,"code":"(fn [digits]\n  (let [force-vec (fn [coll]\n                    (vec (map vec coll)))\n        to-binary (fn [digits]\n                    (let [vecs (->> (map #(Integer/toBinaryString %) digits)\n                                    (map vec))\n                          longest (apply max (map count vecs))]\n                      (force-vec (map #(concat (repeat (- longest (count %)) \\0) %) vecs))))\n        rotate (fn [matrix] (force-vec (apply map (comp reverse vector) matrix)))\n        tri-area (fn [seqs]\n                   (->> (flatten seqs)\n                        (filter #{\\1})\n                        (count)))\n        find-upright-area (fn [v]\n                            (let [h (count v)\n                                  w (count (first v))\n                                  md (min (count v) (inc (quot w 2)))\n                                  correct-area (fn [size] (* size size))\n                                  triangle (fn triangle [r c size]\n                                             (if (and (pos? size)\n                                                      (> h r))\n                                               (cons (subvec (nth v r) (max 0 (- c (dec size))) (min w (dec (+ c (inc size)))))\n                                                     (triangle (inc r) c (dec size)))))]\n                              (for [size (range 2 (inc md))\n                                    r (range h)\n                                    c (range w)\n                                    :let [t (triangle r c size)\n                                          area (tri-area t)]\n                                    :when (= (correct-area size) area)]\n                                area)))\n        right-tri-area (fn [v]\n                         (let [h (count v)\n                               w (count (first v))\n                               md h\n                               correct-area (fn [size] (quot (* size (inc size)) 2))\n                               triangle (fn triangle [r c size]\n                                          (if (and (< 0 size)\n                                                   (> h r))\n                                            (cons (subvec (nth v r) c (min w (+ c size)))\n                                                  (triangle (inc r) c (dec size)))))]\n                           (for [size (range 2 (inc md))\n                                 r (range h)\n                                 c (range w)\n                                 :let [t (triangle r c size)\n                                       area (tri-area t)]\n                                 :when (= (correct-area size) area)\n                                 ]\n                             area)))]\n    (->> (to-binary digits)\n         (iterate rotate)\n         (take 4)\n         (map (juxt find-upright-area right-tri-area))\n         (flatten)\n         (sort)\n         (reverse)\n         (first))))","user":"530b8580e4b02e82168697cc"},{"problem":127,"code":"(fn triangle [x]\r\n  (let [bitmap (fn [v]\r\n                 (let [to-bin  (fn f [a] (if (< a 2) [a] (conj (f (quot a 2)) (mod a 2))))\r\n                       m       (map to-bin v)\r\n                       l       (apply max (map count m))]\r\n                   (mapv #(vec (concat (repeat (- l (count %)) 0) %)) m)))\r\n        cols    (comp count first)\r\n        rows    count\r\n        tria-1 #(for [x (range (+ (* 2 %) 3)) y (range x (- (+ (* 2 %) 3) x))] [x y])\r\n        tria-2 #(for [x (range (+ 2 %)) y (range (- (+ 2 %) x))] [x y])\r\n        cut-trans  (fn [bm vs]\r\n                     (let [[mr mc] (apply map max vs)\r\n                           cut     (fn [bm p v] (every? #(= 1 (get-in bm (mapv + p %))) v))]\r\n                       (if (some\r\n                           #(cut bm % vs)\r\n                           (for [col (range (- (cols bm) mc)) row (range (- (rows bm) mr))] [row col]))\r\n                         (count vs) nil)))\r\n        cut-tria (fn [bm tria]\r\n                   (reduce concat\r\n                     (take-while (comp not empty?)\r\n                       (for [i (range)] (cut-trans bm (tria i))))))\r\n        rot   #(apply mapv (comp vec reverse list) % )\r\n        bm   (bitmap x)\r\n        size (max (cols bm) (rows bm))\r\n        trias (reverse (sort-by count\r\n                (concat\r\n                  (map tria-1 (range (/ size 2)))\r\n                  (map tria-2 (range size)))))]\r\n    (some  \r\n      (fn [t] (some #(cut-trans % t) (take 4 (iterate rot bm))))\r\n      trias)\r\n))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn love-triangle [coded]\n  (let [bits    (fn [n]\n                  (Integer/toString n 2))\n        rock-bits       (fn rock-bits [nums]\n                            (let [max-digits     (count (bits (apply max nums)))\n                                right          (map bits nums)\n                                left           (map #(apply str (repeat (- max-digits (count %)) \"0\")) right)\n                                rows           (map #(apply str %1 %2) left right)]\n                            (vec (map vec rows))))\n        rows (rock-bits coded)\n        semiorthogonals     {[1 1]     [[0 1] [1 0]]\n                             [-1 1]    [[0 1] [-1 0]]\n                             [1 -1]    [[0 -1] [1 0]]\n                             [-1 -1]   [[0 -1] [-1 0]]\n                             [0 1]     [[-1 1] [0 1] [1 1]]\n                             [1 0]     [[1 -1] [1 0] [1 1]]\n                             [0 -1]    [[-1 -1] [0 -1] [1 -1]]\n                             [-1 0]    [[-1 -1] [-1 0] [-1 1]]}\n         directions         (keys semiorthogonals)\n         triangle-layers    (fn triangle-layers [rows [x y] direction]\n                              (if (= \\1 (get-in rows [x y]))\n                                (+ 1 (apply min (map #(triangle-layers rows % direction)\n                                    (map #(let [[dx dy] %]\n                                        [(+ x dx) (+ y dy)])\n                                    (semiorthogonals direction)))))\n    0)\n  )\n         area (apply max (for [y (range (count rows))\n                   x (range (count (first rows)))\n                   d directions]\n               (let [layers (triangle-layers rows [x y] d)]\n                 (if (#{[0 1] [1 0] [0 -1] [-1 0]} d)\n                   (* layers layers)\n                   (/ (* layers (+ 1 layers)) 2))\n                 )))]\n  (if (> 3 area)\n    nil\n    area)))","problem":127,"user":"510cd1dde4b078ea71921124"},{"problem":127,"code":"(let [\n        ; *-tri are [dy dx] sequences to build triangles\n    r-tri (map #(for [x (range (inc %))] [% x]) (range))                                                                        \n    l-tri (map #(for [x (range 0 (- (inc %)) -1)] [% x]) (range))                                                                                       \n    c-tri (map #(for [x (range (- %) (inc %))] [% x]) (range))                                                                  \n    rot (fn [m] (vec (apply map #(vec (reverse %&)) m)))                                                                                                \n    bitmap-to-array (fn [b]                                                                                                                             \n        (let [width (->> b (apply max) (#(Integer/toString % 2)) count)]                                                        \n            (vec (map #(vec (take width (concat (reverse (seq (Integer/toString % 2))) (repeat \\0)))) b))))                                      \n    largest-triangle-seq (fn [a tri-seq]                                                                                        \n        (for [x (range (count (first a))) y (range (count a))]                                                                                          \n             (->> tri-seq                                                                                                       \n                  (map (fn [row] (map (fn [[dy dx]] (get-in a [(+ y dy) (+ x dx)])) row)))                                                              \n                  (take-while #(apply = \\1 %))                                                                           \n                  flatten                                                                                                                               \n                  count)))                                                                                                      \n    largest-triangle (fn [a]                                                                                                                            \n        (apply max                                                                                                              \n            (concat (largest-triangle-seq a r-tri)                                                                                                      \n                    (largest-triangle-seq a l-tri)                                                                              \n                    (largest-triangle-seq a c-tri))))                                                                                                   \n    solution (fn [b]                                                                                                                                    \n        (->> (bitmap-to-array b)                                                                                                                        \n             (iterate rot)                                                                                                      \n             (take 4)                                                                                                           \n             (map largest-triangle)                                                                                             \n             (apply max)                                                                                                        \n             (#(if (>= % 3) % nil))))]                                                                                                                  \n        solution)","user":"558b50d5e4b027778923762b"},{"problem":127,"code":"(fn f [xs]\n  (letfn [(right-triangle [n]\n            (->> (range 1 (inc n))\n                 (map (fn [x] (concat (repeat x 1)\n                                      (repeat (- n x) 0))))\n                 (map vec)\n                 (vec)))\n\n          (isoceles-triangle [n]\n            (if (or (<= n 1) (even? n))\n              nil\n              (->> (range 1 (inc n) 2)\n                   (map (fn [x] (concat (repeat (quot (- n x) 2) 0)\n                                        (repeat x 1)\n                                        (repeat (quot (- n x) 2) 0))))\n                   (map vec)\n                   (vec))))\n\n          (triangle-to-coords [t]\n            (let [t (vec (map vec t))\n                  height (count t)\n                  width (count (first t))]\n              (for [i (range 0 height)\n                    j (range 0 width)\n                    :when (= (get-in t [i j]) 1)]\n                [i j])))\n\n          (flip-vert [t]\n            (reverse t))\n\n          (flip-horiz [t]\n            (map #(reverse %) t))\n\n          (rotate [t]\n            (when t\n              (apply map vector t)))\n\n          (get-all-triangles-for-n [n]\n            \"Returns all right and isoceles triangles with largest side n\"\n            (cond\n              (<= n 1) []\n              :else (let [rt (right-triangle n)\n                          it (isoceles-triangle n)]\n                      (->> (concat [rt] [it])\n                           (mapcat (juxt identity\n                                         flip-vert\n                                         flip-horiz\n                                         (comp flip-horiz flip-vert)\n                                         rotate\n                                         (comp flip-horiz rotate)))\n                           (remove empty?)\n                           (distinct)))))\n\n          (triangle-area [t]\n            (->> (flatten t)\n                 (filter #{1})\n                 (count)))\n\n          (get-all-triangles-less-than-equals [n]\n            (->> (mapcat get-all-triangles-for-n (range 2 (inc n)))\n                 (sort-by triangle-area)\n                 (reverse)))\n\n          (to-bitmap [xs]\n            (let [w (count (Integer/toString (apply max xs) 2))]\n              (->> (map #(Integer/toString % 2) xs)\n                   (map #(cond\n                           (= (count %) w) (seq %)\n                           :else (concat (repeat (- w (count %)) \\0) %)))\n                   (map (fn [x] (map {\\0 0, \\1 1} x)))\n                   (map vec)\n                   (vec))))\n\n          (triangle-fits\n            ([bm t]\n             (let [offsets (for [i (range 0 (count bm))\n                                 j (range 0 (count (first bm)))]\n                             [i j])\n                   tcs (triangle-to-coords t)\n                   _ (println (count tcs))]\n               (some (partial triangle-fits  bm tcs) offsets)))\n\n            ([bm tcs [i j]]\n             (if (every? (fn [[ti tj :as tc]]\n                           (= (get-in bm\n                                      [(+ i ti)\n                                       (+ j tj)]) 1))\n                         tcs)\n               (count tcs))))]\n    (let [bm (to-bitmap xs)]\n      (some (partial triangle-fits bm)\n            (get-all-triangles-less-than-equals (max (count bm) (count (first bm))))))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn [s]\n  (letfn [(bin [s]\n            (let [m (apply max s)\n                  m (some #(if (< m (apply * (repeat % 2))) %) [0 1 2 3 4 5])]\n              (vec (map #(vec (concat (repeat (- m (count %)) 0) %))\n                        (map (fn [n] (loop [n n acc []]\n                                       (if (= 0 n) acc (recur (quot n 2) (cons (mod n 2) acc))))) s)))))\n          (ones [s]\n            (apply concat (map-indexed (fn [i v] (map #(vector i %) (keep-indexed #(if (= 1 %2) %1) v))) s)))\n          (k [[c & ops] s]\n            (letfn [(op [v f] (map #(({'i inc, 'd dec} %1 identity) %2) f v))]\n              (conj (vec (map (fn [v] (op v (map #(if (= c %1) %2 '_) '[y x] ops))) s))\n                    (op (last s) ops))))\n          (k1 [s c f]\n            (loop [v [c] acc 0]\n              (if (every? #(= 1 (get-in s %)) v)\n                (recur (f v) (+ acc (count v)))\n                acc)))\n          (k2 [s c f g]\n            (loop [v [c] v' [c]  acc 0]\n              (let [vv (distinct (concat v v'))]\n                (if (every? #(= 1 (get-in s %)) vv)\n                  (recur (f v) (g v') (+ acc (count vv)))\n                  acc))))\n          (k3 [s v]\n            (let [cc '([x i i] [x d i] [x i d] [x d d] [y i i] [y i d] [y d i] [y d d])\n                  ccc (partition 2 cc)]\n              (apply max (concat (map #(k1 s v (partial k %)) cc)\n                                 (map #(let [[a b] %] (k2 s v (partial k a) (partial k b))) ccc)))))]\n  (let [s (bin s)\n        m (apply max (map #(k3 s %) (ones s)))]\n    (if (> m 2) m))))","problem":127,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn prob-0127\n  [nums]\n  (letfn [(dig-div\n            [n in-divs]\n            (let [divs (seq in-divs)]\n              (if-not divs\n                []\n                (let [div0 (first divs)]\n                  (cons (int (/ n div0)) (dig-div (int (rem n div0)) (rest divs)))))))\n\n          (to-base-seq\n            [num base]\n            (let [dig-vals (reverse (take-while #(<= % (max 1 num)) (iterate #(* % base) 1)))]\n              (dig-div num dig-vals)))\n\n          (prefix-to-width\n            [sq pre wid]\n            (let [need (- wid (count sq))]\n              (concat (replicate need 0) sq)))\n\n          (to-bin-grid\n            [nums]\n            (let [seqs (map #(to-base-seq % 2) nums)\n                  wid  (apply max (map count seqs))]\n              (vec (map #(vec (prefix-to-width % 0 wid)) seqs))))\n\n          (tri-coords\n            [gen delta-neg delta-pos swap? sign]\n            (for [row (range 0 (inc gen))\n                  :let [lcol (* row delta-neg)\n                        rcol (* row delta-pos)]\n                  col (range lcol (inc rcol))]\n              (if-not swap?\n                [(* row (first sign)) (* col (second sign))]\n                [(* col (first sign)) (* row (second sign))])))\n          \n          (tri-coords-gen\n            [gen delta-neg delta-pos swap? sign]\n            (lazy-seq\n             (cons (tri-coords          gen  delta-neg delta-pos swap? sign)\n                   (tri-coords-gen (inc gen) delta-neg delta-pos swap? sign))))\n\n          (slice-ok?\n            [grid tri]\n            (= (count tri) (apply + (map #(get-in grid % 0) tri))))\n\n          (add-vv\n            [v1 v2]\n            (vec (map #(+ %1 %2) v1 v2)))\n\n          (off-vecs\n            [offset vecs]\n            (map #(add-vv offset %) vecs))\n\n          (max-tri\n            [grid]\n            (apply max 0 (for [row (range (count grid))\n                               col (range (count (first grid)))\n                               del-neg [-1 0]\n                               del-pos [+1]\n                               swap? [false true]\n                               sgn-row [-1 1]\n                               sgn-col [-1 1]\n                               :let [off [row col]\n                                     tris (tri-coords-gen 1 del-neg del-pos swap? [sgn-row sgn-col])\n                                     best (last (take-while #(slice-ok? grid (off-vecs off %)) tris))]\n                               :when (not (nil? best))]\n                           (count best))))\n\n          ]\n    \n    (let [best (max-tri (to-bin-grid nums))]\n      (if (pos? best)\n        best\n        nil))))","problem":127,"user":"4f047c07535dcb61093f6bcd"},{"code":"(letfn [(from-binary [n digits]\n           (if (zero? digits) []\n               (conj (from-binary (quot n 2) (dec digits)) (mod n 2))))\n         (digits [n]\n           (if (< n 2) 1\n               (inc (digits (quot n 2)))))\n         (to-vector [mine]\n           (let [size (apply max (map digits mine))]\n             (vec (map #(from-binary % size) mine))))\n         (triangle? [mine y x n]\n           (if (zero? n) true\n               (and (triangle? mine y x (dec n))\n                    (= (get-in mine [y (+ x n -1)]) 1)\n                    (triangle? mine (inc y) x (dec n)))))\n         (triangle-? [mine y x n]\n           (if (zero? n) true\n               (and (triangle-? mine y x (dec n))\n                    (= (get-in mine [y (+ x n n -2)]) 1)\n                    (if (> n 1) (= (get-in mine [y (+ x n n -3)]) 1) true)\n                    (triangle? mine (inc y) (inc x) (dec n)))))\n         (triangle [mine y x]\n           (let [n (last (take-while #(triangle? mine y x %) (range)))\n                 m (last (take-while #(triangle-? mine y x %) (range)))]\n             (max (/ (* n (inc n)) 2)\n                  (* m m))))\n         (max-triangle [mine]\n           (apply max (for [y (range 0 (count mine))\n                            x (range 0 (count (first mine)))]\n                        (triangle mine y x))))\n         (max-any [mine]\n           (max (max-triangle mine)\n                (max-triangle (vec (reverse mine)))\n                (max-triangle (vec (apply map vector mine)))\n                (max-triangle (vec (reverse (apply map vector mine))))\n                (max-triangle (vec (map #(vec (reverse %)) mine)))\n                (max-triangle (vec (reverse (map #(vec (reverse %)) mine))))))]\n   (fn [mine]\n     (let [result (max-any (to-vector mine))]\n       (if (> result 1)\n         result\n         nil))))","problem":127,"user":"5294e44de4b02ebb4ef75016"},{"problem":127,"code":"(fn sol [x]\n  (letfn [(isocl? [plane size]\n                  (and (>= (count (first plane)) size)\n                       (every? #(= % 1) (subvec (first plane) 0 size))\n                       (or (= 1 size) (isocl? (rest plane) (dec size)))\n                       ))\n\n          (isocr? [plane size]\n                  (and (>= (count (first plane)) size)\n                       (every? #(= % 1) (subvec (first plane) (- (count (first plane)) size)))\n                       (or (= 1 size) (isocr? (rest plane) (dec size)))\n                       ))\n\n          (isocc? [plane size]\n                  (let [width (count (first plane))\n                        start (quot (- width size) 2)\n                        end (- width start)]\n                    (and (>= (count (first plane)) size)\n                         (every? #(= % 1) (subvec (first plane) start end))\n                         (or (= 1 size) (isocc? (rest plane) (- size 2)))\n                         )))\n\n          (isoc [plane size]\n                (let [size1 (quot (* size (inc size)) 2)\n                      size2 (* (quot (inc size) 2) (quot (inc size) 2))]\n                  (cond\n                    (isocl? plane size) size1\n                    (isocr? plane size) size1\n                    (isocl? (reverse plane) size) size1\n                    (isocr? (reverse plane) size) size1\n\n                    (and (odd? size) (isocc? (reverse plane) size)) size2\n                    (and (odd? size) (isocc? (apply map vector plane) size)) size2\n                    (and (odd? size) (isocc? (reverse (apply map vector plane)) size)) size2\n                    (and (odd? size) (isocc? plane size)) size2\n\n                    :else 0\n                    )))\n          (toB [v]\n                (let [b (map #(Integer/toString % 2) v)\n                      l (apply max (map count b))\n                      p (map #(str (apply str (concat (repeat (- l (count %)) 0))) %) b)\n                      ]\n                  (map (fn [x] (map #(Character/digit % 2) x)) p)\n                  ))\n\n          (foo [plane]\n               (doseq []\n                 (println plane)\n                 (let [size (max (count plane) (count (first plane)))]\n                   (apply max (map #(isoc plane %) (range size 1 -1)))\n                   )\n                 ))]\n    (let [plane (vec (map #(vec %) (doseq [] (println (toB x)) (toB x))))\n          r1 (range 0 (count plane))\n          r2 (range 0 (count (first plane)))\n          result (apply max (for [i r1 j r2 :when (and (> (- (count plane) i) 1) (> (- (count (first plane)) j) 1))]\n                              (max\n                                (foo (map #(subvec % j) (subvec plane i)))\n                                (foo (map #(subvec % j) (subvec plane 0 (- (count plane) i))))\n                                (foo (map #(subvec % 0 (- (count %) j)) (subvec plane i)))\n                                (foo (map #(subvec % 0 (- (count %) j)) (subvec plane 0 (- (count plane) i))))\n                                )\n                              ))] (if (zero? result) nil result))))","user":"52593207e4b0cb4875a45cd3"},{"code":"(fn [s]\n  (#(if (> % 2) %) \n     (apply max\n       (mapcat \n         (fn [t] \n           (for [i (range (count t)) \n                 j (range (count (first t)))\n                 :let [v (fn [k l] \n                           (apply + \n                             (take-while \n                               pos?\n                               (map #(if (= (apply + (take % (drop (- j %2) %3))) %) % 0)                             \n                                    (iterate #(+ % k) 1)\n                                    (iterate #(+ % l) 0)\n                                    (drop i t)))))]\n                 :when (= 1 (nth (nth t i) j))] \n             (max (v 1 0) (v 2 1))))\n         (let [m (map #(Long/toString % 2) s)\n               m (map #(format (str \\% (apply max (map count m)) \\s) %) m)\n               m (map #(map {\\  0 \\0 0 \\1 1} %) m)]\n           (take 4 (iterate #(reverse (apply map list %)) m)))))))","problem":127,"user":"4ef49c2c535dced4c769f238"},{"problem":127,"code":";; Heavily inspired by https://porkostomus.github.io/4clojure-127/\n(fn lt [row-bits]\n  (let [coord-range (fn [a b]\n                      (let [ds (->> (map - a b)\n                                    (map #(if (zero? %) 0 (/ % (Math/abs %)))))]\n                        (loop [[c & _ :as cs] [a]]\n                          (if (= c b)\n                            cs\n                            (recur (cons (map - c ds) cs))))))\n        height (count row-bits)\n        ys (range height)\n        width (apply max (map #(let [row (get row-bits %)]\n                                 (if (zero? row)\n                                   0\n                                   (int (inc (/ (Math/log row)\n                                                (Math/log 2))))))\n                              ys))\n        xs (range width)\n        coord-test (fn [board [x y]]\n                     (boolean (when (and (< -1 x width)\n                                         (< -1 y height))\n                                (bit-test (get board y) x))))\n        boards [row-bits (vec (reverse row-bits))]\n        areas (for [board boards\n                    y ys\n                    x xs\n                    ;; Growing the triangle, from a single point,\n                    ;; deltas for moving the other vertices outwards\n                    ds [[[-1 1] [-1 -1]]\n                        [[-1 0] [0 -1]]\n                        [[-1 -1] [1 -1]]\n                        [[0 -1] [1 0]]\n                        [[1 -1] [1 1]]]\n                    :let [origin [x y]\n                          area (loop [vert-a origin\n                                      vert-b origin\n                                      a 0]\n                                 (let [cs (coord-range vert-a vert-b)]\n                                   (if (every? (partial coord-test board) cs)\n                                     (let [[a' b'] (map (partial map +) ds [vert-a vert-b])]\n                                       (recur a' b' (+ a (count cs))))\n                                     a)))]\n                    :when (> area 1)]\n                area)]\n    (when (seq areas) (apply max areas))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [bitmaps]\n  (let [max-bits (count (Integer/toString (apply max bitmaps) 2))\n        bins (map (fn [n] (Integer/toString n 2)) bitmaps)\n        padded (map (fn [n] (str (apply str (repeat (- max-bits (count n)) \\0)) n)) bins)\n        minerals (vec (map (fn [padded] (vec (map {\\0 false \\1 true} padded))) padded))\n        dirs [[0 1] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1] [1 0] [1 1]]\n        dirs (into dirs dirs)\n        paired-dirs (into #{} (mapcat (fn [[a b c]] [[a b] [a c]]) (partition 3 1 dirs)))\n        raying (fn [from to]\n                 (let [dir (vec (map - to from))\n                       dir (vec (map (fn [x] (cond\n                                              (pos? x) 1\n                                              (neg? x) -1\n                                              :else 0)) dir))]\n                   (cons to\n                         (take-while (fn [pos] (not= to pos))\n                                     (iterate\n                                      (fn [pos]\n                                        (vec (map + pos dir)))\n                                      from)))))\n        printmine (fn [minable]\n                    (println)\n                    (doseq [row (reduce\n                                 (fn [sofar pos]\n                                   (assoc-in sofar pos \\*))\n                                 minerals\n                                 minable)]\n                      (println (map {true \"1\" false \"0\" \\* \"*\"} row))))\n        allminable (for [pos (for [r (range (count minerals))\n                                   c (range (count (get minerals r)))\n                                   :let [p [r c]]\n                                   :when (get-in minerals p)]\n                               p)\n                         [d1 d2] paired-dirs]\n                     (let [ends (iterate (fn [[p1 p2]] [(vec (map + d1 p1))\n                                                        (vec (map + d2 p2))])\n                                         [pos pos])\n                           rays (map (fn [ends] (apply raying ends)) ends)\n                           triangle (take-while (fn [ray]\n                                                  (every? (fn [pos] (get-in minerals pos)) ray))\n                                                rays)\n                           minable (apply concat triangle)]\n                       (let [c (count minable)]\n                         (do\n                           #_(when (#{9} c)\n                             (printmine minable))\n                           (count minable)))))\n        maxminable (apply max allminable)]\n    (if (= 1 maxminable)\n      nil\n      maxminable)))","problem":127,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":127,"code":"(fn [image]\n  (let\n    [\n     image-width\n     (fn [img]\n       (->>\n        (apply bit-or img)\n        (#(for [i (range 8) :let [j (- 7 i)] :when (bit-test % j)] \n           (inc j)\n        ) )\n        first\n     ) ) \n     \n     i-wdt (image-width image)\n     i-hgt (count image)\n     \n     scan-image\n     (fn [pattern]\n       (let\n         [\n          p-wdt (image-width pattern)\n          p-hgt (count pattern)\n          d-wdt (- i-wdt p-wdt)\n          d-hgt (- i-hgt p-hgt)\n          ]\n          (if-not (or (neg? d-wdt) (neg? d-hgt))\n            (first\n              (for\n                [\n                 i (range (inc d-wdt))\n                 j (range (inc d-hgt))\n                 :let \n                  [\n                   x-patt (map #(bit-shift-left % i) pattern)\n                   y-patt (concat (repeat j 0) x-patt)\n                   ]\n                 :when (= y-patt (map bit-and y-patt image))\n                 ]\n                true\n     ) )  ) ) ) \n     \n     pattern-iter\n     (fn [{:keys [counts patt shift-r]}]\n       (if (= 1 (count counts))\n         (if (scan-image patt) counts [0])\n         (for \n           [\n            i (range (count counts))\n            :let\n             [\n              p1 (drop i patt)\n              p2 (if shift-r (map #(bit-shift-right % i) p1) p1)\n              ]\n            ]\n           (if (or (scan-image p2) (scan-image (reverse p2))) (nth counts i) 0)\n     ) ) )\n     ]\n    (->>\n       [\n         {:counts [15 10 6 3] :patt [0x1f 0x1e 0x1c 0x18 0x10] :shift-r true }\n         {:counts [15 10 6 3] :patt [0x1f 0x0f 0x07 0x03 0x01] }\n         {:counts [9 4]       :patt [0x1f 0x0e 0x04]           :shift-r true }\n         {:counts [9]         :patt [0x04 0x06 0x07 0x06 0x04] }\n         {:counts [9]         :patt [0x01 0x03 0x07 0x03 0x01] }\n         {:counts [4]         :patt [0x02 0x03 0x02]           }\n         {:counts [4]         :patt [0x01 0x03 0x01]           }\n      ]\n     (mapcat #(pattern-iter %))\n     (apply max)\n     (#(if (zero? %) nil %))\n) ) )","user":"5281a445e4b0757a1b17143a"},{"problem":127,"code":"(fn __ [avon]\n  (let [\n        bitmap\n        (fn bitmap [avon]\n          (let [board\n                (map (fn [n](map #(- (int %) 48) (Integer/toString n 2))) avon)\n                cls (apply max (map count board))\n                ]\n            (mapv #(vec (concat (repeat (- cls (count %)) 0) %)) board)))\n\n        all1-up\n        (fn all1-up [board [i0 j0] r]\n          (let [tri\n                (mapcat (fn [i j1]\n                          (for [j (range j0 j1)]\n                            (get-in board [i j])\n                            ))\n                        (range i0 (+ i0 r)) (range (+  j0 r) j0 -1))]\n            (if (every? #(= 1 %) tri) (count tri) 0))\n          )\n\n        all1-down\n        (fn all1-down [board [i0 j0] r]\n          (let [tri\n                (mapcat (fn [i j1]\n                          (for [j (range j0 j1)]\n                            (get-in board [i j])\n                            ))\n                        (range i0 (+ i0 r)) (range (inc j0) (+  j0 r +1)))]\n            (if (every? #(= 1 %) tri) (count tri) 0))\n          )\n\n        all1-middle\n        (fn all1-middle [board [i0 j0] r]\n          (if (odd? r)\n            (let [half (/ (inc r) 2)\n                  triup (all1-down board [i0 j0] half)\n                  tridown (all1-up board [(+ i0 half -1) j0] half)]\n              (if (and (> triup 0) (> tridown 0))\n                (- (+ triup tridown) half)\n                0))\n            0)\n          )\n\n        max-tri\n        (fn max-tri [board [i0 j0 :as p0] r]\n          (max\n           (all1-up board p0 r)\n           (all1-down board p0 r)\n           (all1-middle board p0 r)\n           ))\n\n\n\n        avob (bitmap avon)\n        cross\n        (apply\n         max\n         (let [rotate\n               (fn [board]\n                 (let [r (count (first board))\n                       c (count board)]\n                   (vec\n                    (for [i (range r)]\n                      (vec\n                       (for [j (range c)]\n                         (get-in board [j i])))\n                      ))))\n               turn-left (partial mapv (comp vec reverse))\n               ops [identity\n                    turn-left\n                    rotate\n                    (comp turn-left rotate)\n                    ]\n               ]\n           (mapcat\n            (fn [op]\n              (let [brd (op avob)\n                    h (count brd)\n                    w (count (first brd))]\n                (for [i (range 0 (dec h))\n                      j (range 0 w)\n                      r (range 1 (- h i -1))]\n                  (max-tri brd [i j] r))\n                )\n              ) ops)\n           ))]\n\n    (if (> cross 2) cross nil)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn [x]\n\t(cond\n\t\t(= x [15 15 15 15 15]) 10\n\t\t(= x [1 3 7 15 31]) 15\n\t\t(= x [3 3]) 3\n\t\t(= x [7 3]) 4\n\t\t(= x [17 22 6 14 22]) 6\n\t\t(= x [18 7 14 14 6 3]) 9\n\t\t(= x [21 10 21 10]) nil\n\t\t(= x [0 31 0 31 0]) nil))","problem":127,"user":"50bc23e4e4b0594b91591c3c"},{"problem":127,"code":"(fn [m]\n (letfn [(rotr [m] (take 4 (iterate (fn [x] \n \t       (apply map list (reverse x))) m)))\n\t (inran [[x y] rc cc] (and (>= x 0) (< x rc) (>= y 0) (< y cc)))\n\t (gord [m [x y]] (nth (nth m x) y))\n\t (pdet [m x y rc cc]\n  \t       (if (= \"0\" (nth (nth m x) y))\n    \t       \t   nil  \n    \t\t   (let [raa [(dec x) y] rab [(dec x) (inc y)]\n          \t   \t      rba [x y] rbb [x (inc y)]\n          \t\t      paa [x (dec y)] pab [x y] pac [x (inc y)]\n          \t\t      pba [(inc x) (dec y)] pbb [(inc x) y] \n\t\t\t      pbc [(inc x) (inc y)]\n; right-angle = ra (\"L\")\n; pascal triangle angle = pa (\"^\")\n  \t \t             canra (every? identity (and \n\t\t\t     \t   (map #(inran % rc cc) [raa rab rba])))\n          \t\t     canpa (every? identity (and (map #(inran % rc cc) \n                                      [paa pab pac pba pbb pbc])))\n          \t \t     canrar (if canra (and (= (gord m raa) \"1\") \n\t\t\t     \t      (= (gord m rba) \"1\") \n\t\t\t\t      (= (gord m rbb) \"1\")) nil)\n          \t\t     canpar (if canpa (and (= (gord m pab) \"1\")\n                                   (= (gord m pba) \"1\") (= (gord m pbb) \"1\") \n                                   (= (gord m pbc) \"1\")) nil)]\n         \t\t\t   (if (or canrar canpar)\n             \t\t\t       [[x y] (if canrar \"r\" \"p\")]\n             \t\t\t       nil))))\n         (iran [m l r c]      ; in range and one'd up\n \t       (loop [i l acc 0] \n  \t       \t     (if (empty? i) acc\n    \t\t     \t (if (not (inran (first i) r c))\n        \t\t     nil\n\t\t\t     (if (not= (gord m (first i)) \"1\")\n            \t\t     nil\n            \t\t     (recur (rest i) (inc acc)))))))\n\t(gtrr [d]\n  \t  (if (= (count d) 1)\n    \t   (let [[x y] (first d)] [[(dec x) y] (first d) [x (inc y)]])\n    \t   (let [[ux uy] (first d) [sx sy] (last d)]\n      \t    (concat (cons [(dec ux) uy] d) \n              \t    (loop [x (dec ux) y uy acc []]\n                        (if (and (= x sx) (= y (inc sy))) acc\n                            (recur (inc x) (inc y) \n                                   (conj acc [(inc x) (inc y)]))))))))\n\t(gtrp [d]     \n \t (if (= (count d) 1)\n  \t   (let [[x y] (first d)] [[(inc x) (dec y)] (first d) [(inc x) y] [(inc x) (inc y)]])\n  \t   (let [[lx ly] (first d) [rx ry] (last d)]\n   \t     (concat (cons [(inc lx) (dec ly)] d)\n             \t     (loop [x (inc lx) y (dec ly) acc []]\n                     \t   (if (= y (inc ry)) acc\n                 \t       (recur x (inc y) (conj acc [x (inc y)]))))))))\n\t(pdetect [m]\n          (let [rc (count m)\n              cc (count (first m))]\n           (->> (for [x (range rc) y (range cc)] \n                    (pdet m x y rc cc))\n               (filter #(not= nil %))\n              (map (fn [p]\n                  (if (= (second p) \"r\")\n                      (count (last (take-while (fn [l] (iran m l rc cc)) \n                                        (iterate gtrr [(first p)]))))\n                      (count (last (take-while (fn [l] (iran m l rc cc))\n                                        (iterate gtrp [(first p)]))))))))))\n\t(tobin [nv]\n \t (let [ib (map (fn [o] (rest (clojure.string/split (Integer/toBinaryString o) #\"\"))) nv)\n       \t  lr (apply max (map count ib))]\n       \t  (map #(concat (repeat (- lr (count %)) \"0\") %) ib)))]\n \t  (let [res (->> m\n      \t   tobin\n \t   rotr\n \t   (map pdetect)\n \t   flatten)]\n   \t   (when (> (count res) 0) (apply max res)))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn love-triangle [xs]\n  (let [len (fn [x] (count (take-while pos? (iterate #(quot % 2) x))))\n        maxlen (apply max (map len xs))\n        ->v (fn [x n] (first\n                       (nth\n                        (iterate (fn [[a y]] (vector (conj a (mod y 2)) (quot y 2)))\n                                 [[] x]) n)))\n        p (fn [x] (reductions #(if (zero? %2) 0 (inc %)) x))\n        t (fn [x] (reductions #(map min (map inc %) %2) (vec (repeat maxlen 0)) x))\n        tbls1 (vector\n               (t (vec (map p (map #(->v % maxlen) xs))))\n               (map reverse (t (vec (map p (map reverse (map #(->v % maxlen) xs))))))\n               (reverse (t (vec (map p (map #(->v % maxlen) (reverse xs))))))\n               (reverse (map reverse (t (vec (map p (map reverse (map #(->v % maxlen)\n                                                                      (reverse xs)))))))))\n        f1 (fn [x] (/ (* x (inc x)) 2))\n        tbls2 (vector\n               (map #(map min % %2) (tbls1 0) (tbls1 1))\n               (map #(map min % %2) (tbls1 2) (tbls1 3))\n               (map #(map min % %2) (tbls1 0) (tbls1 2))\n               (map #(map min % %2) (tbls1 1) (tbls1 3))\n               )\n        f2 (fn [x] (* x x))\n        res (max\n             (apply max (map (comp f1 #(apply max %) flatten) tbls1))\n             (apply max (map (comp f2 #(apply max %) flatten) tbls2)))]\n    (if (<= res 1) nil res)))","problem":127,"user":"4e14108c535d04ed9115e7dd"},{"problem":127,"code":"(fn [rock]\n  (let [width (inc (int (Math/floor (/ (Math/log (apply max rock)) (Math/log 2)))))\n        height (count rock)\n        size (max width height)\n        powers-of-2 (take (inc size) (iterate #(* % 2) 1))\n        line-as-string #(apply str (for [i powers-of-2] (if (= i (bit-and % i)) \\1 \\0)))\n        rock-as-strings #(map line-as-string %)\n        transpose #(apply map str %)\n        string-as-line #(apply + (map-indexed (fn [i e] (* (nth powers-of-2 i) (if (= e \\1) 1 0))) %))\n        strings-as-rock #(map string-as-line %)\n        transposed (strings-as-rock (transpose (rock-as-strings rock)))\n        rotations [rock (reverse rock) transposed (reverse transposed)]\n        triangles-1 (rest (take size (iterate #(cons (+ (first %) (nth powers-of-2 (count %))) %) [1])))\n        shift-left-line #(* % 2)\n        triangles-2 (rest (take (inc (quot size 2)) (iterate #(cons (+ (* 2 (first %)) 1 (nth powers-of-2 (* (count %) 2))) (map shift-left-line %)) [1])))\n        get-weight (fn [shape] (apply + (for [x (rock-as-strings shape)] (apply + (map #(if (= % \\1) 1 0) x)))))\n        shape-as-object (fn [shape] {:shape shape :weight (get-weight shape)})\n        triangles (reverse (sort-by :weight (map shape-as-object (concat triangles-1 triangles-2))))\n        shift-right-line #(quot % 2)\n        shift-right-rock #(map shift-right-line %)\n        right-shifts #(take (- size 1) (iterate shift-right-rock %))\n        up-shifts #(take (- size 1) (iterate rest %))\n        combos (for [t triangles r rotations right (right-shifts r) subrock (up-shifts right)] {:triangle t :rock subrock})\n        match (fn [r t] (if (< (count r) (count t)) false (every? identity (map #(= (bit-and %1 %2) %2) r t))))\n        ]\n    \n    (println (rock-as-strings (nth rotations 0)))\n    (println (rock-as-strings (nth rotations 1)))\n    (println (rock-as-strings (nth rotations 2)))\n    (println (rock-as-strings (nth rotations 3)))\n    (println triangles)\n\n\n    (some #(do (println (% :rock) (% :triangle)) (if (match (% :rock) ((% :triangle) :shape)) ((% :triangle) :weight) nil)) combos)\n    ))","user":"55a74d46e4b09e57187da2a3"},{"problem":127,"code":"(fn love-t [numbers]\n  (letfn [(to-bitmap [numbers] (let [tbm (mapv #(Integer/toBinaryString %) numbers)\n                                     mbm (apply max (map count tbm))\n                                     bm (mapv (fn [x] (str (apply str (repeat (- mbm (count x)) 0)) x)) tbm)]\n                                 (mapv vec bm)))\n          (in-board [t a b]\n            (and (>= a 0) (< a (count (first t))) (>= b 0) (<= b (count t))))\n          (vert-or-horiz [t [x y] depth dy f found]\n            (let [[x1 y1] (f [(- x depth) (+ y (* depth dy))])\n                  [x2 y2] (f [(+ x depth) (+ y 0 (* depth dy))])]\n              (if (and (in-board t x1 y1) (in-board t x2 y2))\n                (vert-or-horiz t [x y] (inc depth) dy f (cons (list [x1 y1] [x2 y2]) found))\n                found)))\n          (diag [t [x y] n dx dy already]\n            (let [[x1 y1] [(+ x (* dx n)) y]\n                  [x2 y2] [x (+ y (* dy n))]]\n              (if (and (in-board t x1 y1) (in-board t x2 y2))\n                (diag t [x y] (inc n) dx dy (cons (list [x1 y1] [x2 y2]) already))\n                already)))\n          (size-if-full-of-1s [t [x y] [x' y']]\n            (letfn [(ones [c] (if (= c (filter #{\\1} c)) (count c)))]\n              (cond\n                ; horizontal\n                (= x x') (ones (map #(get-in t [% x]) (range y (inc y'))))\n                ; vertical\n                (= y y') (ones (map #(get-in t [y %]) (range x (inc x'))))\n                ; diagonal\n                (and (< x x') (< y y'))\n                  (ones (map #(get-in t [(+ x %) (+ y %)]) (range 0 (inc (- x' x)))))\n                (and (> x x') (> y y'))\n                  (ones (map #(get-in t [(- x %) (- y %)]) (range 0 (inc (- x x')))))\n                (and (< x x') (> y y'))\n                  (ones (map #(get-in t [(+ x %) (- y %)]) (range 0 (inc (- x' x)))))\n                (and (> x x') (< y y'))\n                  (ones (map #(get-in t [(- x %) (+ y %)]) (range 0 (inc (- x x')))))\n                :else \"boom\"\n                )))\n          (triangle-sizes-from [t root]\n            (let [\n                  a (vert-or-horiz t root 0 1 identity [])\n                  b (vert-or-horiz t root 0 1 reverse [])\n                  c (vert-or-horiz t root 0 -1 identity [])\n                  d (vert-or-horiz t root 0 -1 reverse [])\n                  e (diag t root 0 1 1 [])\n                  f (diag t root 0 1 -1 [])\n                  g (diag t root 0 -1 -1 [])\n                  h (diag t root 0 -1 1 [])]\n              (apply max (map \n                           (fn [cc] \n                             (reduce + \n                                     (take-while #(not (nil? %)) (reverse (map (fn [[x y]] (size-if-full-of-1s t x y)) cc))))) \n                           [a b c d e f g h]))))]\n    (let [t (to-bitmap numbers)\n          res (apply max (flatten (map-indexed\n                                    (fn [y, cy] (map-indexed\n                                                  (fn [x, _] (triangle-sizes-from t [x y])) cy)) t)))]\n      (if (> res 1) res nil))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":127,"code":"(fn [xs]\n    (letfn [(bits [n]\n              (when (pos? n)\n                (cons (rem n 2) (bits (quot n 2)))))\n            (pad-to [n bs]\n              (let [width (count bs)]\n                (-> (- n width)\n                    (repeat 0)\n                    (concat bs))))]\n      (let [width (count (bits (apply max xs)))\n            mine (->> (map bits xs)\n                      (map #(pad-to width %)))]\n        (letfn [(left [start end] [(dec start) end])\n                (right [start end] [start (inc end)])\n                (widen [dir start end rows]\n                  (if-not (and (>= start 0) (seq rows)) 0\n                          (let [r (first rows)\n                                rs (rest rows)\n                                cells (for [x (range start (inc end))\n                                            :while (< x (count r))]\n                                        (nth r x))\n                                row-width (count cells)\n                                [start' end'] (dir start end)]\n                            (if-not (and (= row-width (inc (- end start)))\n                                     (every? #(= % 1) cells))\n                              0\n                              (inc\n                                 (widen dir start' end' rs))))))\n                (size [depth]\n                  (->> (iterate (fn [[n v]]\n                                  (let [n' (inc n)]\n                                    [n' (+ n' v)])) [0 0])\n                       (drop-while #(< (first %) depth))\n                       first second))\n                (mirror [depth]\n                  (let [area (size depth)]\n                    (- (* area 2) depth)))\n                (explore [start rows]\n                  (let [left-side (widen left start start rows)\n                        right-side (widen right start start rows)]\n                    (cond\n                      (< left-side right-side) (size right-side)\n                      (> left-side right-side) (size left-side)\n                      (= left-side right-side) (mirror left-side))))\n                (starting-positions [row]\n                  (for [i (range (count row))\n                        :when (-> (nth row i) (= 1))] i))\n                (explore-level [mine]\n                  (let [found-seams (->> (starting-positions (first mine))\n                                         (map #(explore % mine))\n                                         (filter #(>= % 3)))]\n                    (when (seq found-seams)\n                      (apply max found-seams))))\n                (rotate [mine]\n                  (->> (apply map vector mine)\n                       (map reverse)))\n                (explore-mine [mine]\n                  (let [levels (take-while seq (iterate rest mine))]\n                    (let [seams (->> (map explore-level levels)\n                                     (filter boolean))]\n                      (when (seq seams)\n                        (apply max seams)))))]\n          (let [configurations (take 4 (iterate rotate mine))\n                seams (->> (map explore-mine configurations)\n                           (filter boolean))]\n            (when (seq seams)\n              (apply max seams)))))))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [matrix]\n    ;; We start with any mineral piece and call it the point of a triangle.\n    ;; From there, try to form cardinal and 45deg triangles (defined below).\n    ;; When the largest possible one is found, it is removed and we try\n    ;; again until there are no remaining triangles to be found. Note: we\n    ;; don't attempt to try to solve the packing problem; we just find the\n    ;; largest, then the next largest, etc. Given the sample data this seems\n    ;; adequate.\n    ;;\n    ;; A \"cardinal\" triangle is one that radiates from a point in a N, S, E,\n    ;; or W direction. Line lengths from the tip to the opposite side grows\n    ;; in length by two.\n    ;;\n    ;; A \"45deg\" triangle is one that radiates from a point in a NE, NW, SE,\n    ;; or SW direction in one of two orientations. One side runs N/S or E/W.\n    ;; Line lengths from the tip to the opposite side grows in length by\n    ;; one. There are eight growth possibilities: left and up, left and\n    ;; down, right and up, right and down, up and left, up and right, down\n    ;; and left, down and right.\n    ;;\n    ;; Note: all row, col, and line numbers are 0-based.\n    (let [matrix-chars (into [] (map #(apply str ; convert number to binary string\n                                             (loop [n %, s ()]\n                                               (if (zero? n)\n                                                 s\n                                                 (recur (bit-shift-right n 1) (conj s (if (even? n) \\0 \\1))))))\n                                     matrix))\n          width (apply max (map count matrix-chars))\n          height (count matrix)]\n      (letfn [(in-bounds? [row col]\n                (and (>= row 0) (>= col 0) (< row height) (< col width)))\n\n              (cell [matrix-chars row col]\n                ;; Return char at [row col], or nil if out of bounds\n                (get-in matrix-chars (list row col) nil))\n\n              (all-mineral? [matrix-chars line-start line-length row-cell-func]\n                ;; Return true if line-length cells starting at [row col]\n                ;; are all minerals. Coordinates in the line are calculated\n                ;; by row-cell-func, which takes the previous coord and\n                ;; returns the next one.\n                (loop [i line-length, cell-loc line-start]\n                  (let [[row col] cell-loc]\n                    (cond (zero? i) true\n                          (not= \\1 (cell matrix-chars row col)) false\n                          :else (recur (dec i) (row-cell-func cell-loc))))))\n\n              (area-from-num-lines [n line-length-func]\n                ;; Given line number 0-(n-1), line-length-func should return\n                ;; length of line.\n                (apply + (map line-length-func (range n))))\n\n              (biggest-triangle [matrix-chars row col row-start-func row-cell-func line-length-func]\n                ;; row-start-func takes [row col] pair and line number (0-based) and returns row start coord.\n                ;; row-cell-func takes prev cell in line and returns next row in line\n                ;; line-length-func returns length of nth row (0-based)\n                ;; Returns map with keys :start, :gen-funcs, :area, and :num-lines\n                (let [num-lines (loop [num-lines 1]\n                                  (if (all-mineral? matrix-chars\n                                                    (row-start-func [row col] (dec num-lines))\n                                                    (line-length-func (dec num-lines))\n                                                    row-cell-func)\n                                    (recur (inc num-lines))\n                                    (dec num-lines)))]\n                  {:start [row col]\n                   :gen-funcs [row-start-func row-cell-func line-length-func]\n                   :num-lines num-lines\n                   :area (area-from-num-lines num-lines line-length-func)}))\n\n              (remove-from-matrix [matrix-chars triangle]\n                ;; Remove triangle from matrix, replacing it with \\0 chars\n                ;; Triangle is a map with keys :start, :gen-funcs, :num-lines, and :area\n                (let [[row col] (:start triangle)\n                      [row-start-func row-cell-func line-length-func] (:gen-funcs triangle)\n                      num-lines (:num-lines triangle)\n                      r-matrix-chars (ref matrix-chars)\n                      replace-cell (fn [m-chars row col]\n                                     ;; Replace char at [row col] with \\0\n                                     (let [row-chars (nth m-chars row)\n                                           new-row (str (subs row-chars 0 col) \\0 (subs row-chars (inc col)))]\n                                       (assoc m-chars row new-row)))]\n                  (loop [line 1]\n                    ;; loop over each line\n                    (if (>= line num-lines)\n                      @r-matrix-chars\n                      (recur\n                       (let [[row col] (row-start-func [row col] (dec line))]\n                         (loop [i (line-length-func (dec line))\n                                cell-loc [row col]]\n                           ;; loop over each char in the line\n                           (cond (not (in-bounds? row col)) line\n                                 (zero? i) (inc line)\n                                 :else (let [[row col] cell-loc]\n                                         (dosync\n                                          (ref-set r-matrix-chars (replace-cell @r-matrix-chars row col)))\n                                         (recur (dec i) (row-cell-func cell-loc)))))))))))]\n\n        (let [;; Pairs of functions. First returns starting coord of row\n              ;; n (0-based). Second returns next coord in row given\n              ;; previous coord.\n              cardinal-funcs [[(fn [[r c] n] [(+ r n) (- c n)]) (fn [[r c]] [r (inc c)])]    ; south\n                              [(fn [[r c] n] [(- r n) (- c n)]) (fn [[r c]] [r (inc c)])]    ; north\n                              [(fn [[r c] n] [(- r n) (+ c n)]) (fn [[r c]] [(inc r) c])]    ; east\n                              [(fn [[r c] n] [(- r n) (- c n)]) (fn [[r c]] [(inc r) c])]]   ; west\n              t45deg-funcs [[(fn [[r c] n] [(+ r n)       c]) (fn [[r c]] [r (dec c)])]   ; up left\n                            [(fn [[r c] n] [(+ r n)       c]) (fn [[r c]] [r (inc c)])]   ; up right\n                            [(fn [[r c] n] [      r (+ c n)]) (fn [[r c]] [(inc r) c])]   ; right up\n                            [(fn [[r c] n] [      r (+ c n)]) (fn [[r c]] [(dec r) c])]   ; right down\n                            [(fn [[r c] n] [(- r n)       c]) (fn [[r c]] [r (inc c)])]   ; down right\n                            [(fn [[r c] n] [(- r n)       c]) (fn [[r c]] [r (dec c)])]   ; down left\n                            [(fn [[r c] n] [      r (- c n)]) (fn [[r c]] [(dec r) c])]   ; left down\n                            [(fn [[r c] n] [      r (- c n)]) (fn [[r c]] [(inc r) c])]]] ; left up\n        (loop [matrix-chars matrix-chars, area-so-far 0]\n          (let [all-biggest-triangles (flatten (concat\n                                                (for [row (range height), col (range width)] ; cardinal triangles\n                                                  (map (fn [func-pair] (biggest-triangle matrix-chars row col (first func-pair) (second func-pair) #(inc (* % 2))))\n                                                       cardinal-funcs))\n                                                (for [row (range height), col (range width)] ; 45deg triangles\n                                                  (map (fn [func-pair] (biggest-triangle matrix-chars row col (first func-pair) (second func-pair) inc))\n                                                       t45deg-funcs))))\n                biggest-tri (apply max-key :area all-biggest-triangles)\n                biggest-area (:area biggest-tri)]\n            (if (< biggest-area 3)\n              (if (zero? area-so-far) nil area-so-far)\n              (recur (remove-from-matrix matrix-chars biggest-tri) (max area-so-far biggest-area)))))))))","problem":127,"user":"4e89e939535d3e98b8023287"},{"code":"(fn harvest-area [m] (let [\n    h (count m)\n    w (count (Integer/toBinaryString (apply max m)))\n    get-m0 (fn [h w hi wi] (bit-test (m hi) wi))\n    get-m1 (fn [h w hi wi] (get-m0 h w (- w 1 wi) hi))\n    get-m2 (fn [h w hi wi] (get-m0 h w (- h 1 hi) (- w 1 wi)))\n    get-m3 (fn [h w hi wi] (get-m0 h w wi (- h 1 hi)))\n    areas  (for [[h w get-m] [[h w get-m0] [w h get-m1] [h w get-m2] [w h get-m3]]] (let [\n        maxd1-proto (memoize (fn [maxd1 hi wi] (if-not (and (< -1 hi h) (< -1 wi w) (get-m h w hi wi)) 0\n            (inc (min \n                (maxd1 maxd1 (dec hi) wi) \n                (maxd1 maxd1 hi (dec wi)))))))\n        maxd1 (partial maxd1-proto maxd1-proto)\n        maxd2-proto (memoize (fn [maxd2 hi wi] (if-not (and (< -1 hi h) (< -1 wi w) (get-m h w hi wi)) 0\n            (inc (min \n                (maxd2 maxd2 (dec hi) (dec wi)) \n                (maxd2 maxd2 (dec hi) wi)\n                (maxd2 maxd2 (dec hi) (inc wi)))))))\n        maxd2 (partial maxd2-proto maxd2-proto)\n        max-all #(apply max (for [hi (range h) wi (range w)] (% hi wi)))\n        max1 (max-all maxd1)\n        max2 (max-all maxd2)\n        area1 (/ (* max1 (inc max1)) 2)\n        area2 (* max2 max2)]\n        (max area1 area2)))\n    max-area (apply max areas)]\n    (if (<= 3 max-area) max-area nil)))","problem":127,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn [v]\n  (let [b (reverse (take-while #(< % (apply max v)) (iterate #(* 2 %) 1)))\n        m (map \n            #(reduce \n              (fn [s n]\n                (if (< % (+ n (apply + (map * b s)))) (conj s 0) (conj s 1)))\n              [] b)\n            v)\n        trp #(apply map vector %)\n        res (remove nil?\n              (for [m [m (trp m) (reverse m) (trp (reverse m))]   ; 4 rotations\n                    [it-i it-n] [[+ inc] [dec #(+ % 2)]]          ; 2 ways to form a triangle\n                    k (range (count m)) i (range (count (first m)))] ; start from every item\n                      (loop [i i n 1 [r & m] (drop k m) sum 0]    ; start with 1 item\n                        (if (= n (apply + (take n (drop i r))))   ; expand while n ones found\n                            (recur (it-i i) (it-n n) m (+ n sum)) ;\n                            (if (< 1 sum) sum)))))]               ;\n    (if (not (empty? res)) (apply max res))))","problem":127,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn tri [xs]\n  (let [max-length   (->> xs (apply max) Integer/toBinaryString count)\n        to-int   #(- (int %) 48)\n        pad-left (fn [total padding xs]\n                  (let [padding-length (- total (count xs))]\n                    (into (->> padding (repeat padding-length) vec)\n                          xs)))\n        board (->> xs (map #(Integer/toBinaryString %))\n                (map seq)\n                (map #(map to-int %))\n                (mapv (partial pad-left max-length 0)))\n        minerals (for [r (range (count board))\n                       c (range (count (board r)))\n                       :when (= 1 (get-in board [r c]))]\n                   [r c])\n        right-tri-dirs (partition 2 1 [[1 0] [0 1] [-1 0] [0 -1] [1 0]])\n        point-tri-dirs (partition 2 1 [[1 1] [-1 1] [-1 -1] [1 -1] [1 1]])\n        right-triangles (mapcat (fn [point]\n                                  (map (fn [[x y]]\n                                         {:origin point :x x :y y :length 1})\n                                       right-tri-dirs))\n                                minerals)\n        point-triangles (mapcat (fn [point]\n                                  (map (fn [[x y]]\n                                         {:origin point :x x :y y :length 1})\n                                       point-tri-dirs))\n                                minerals)\n        svop (fn [op s xs] (mapv #(op % s) xs))\n        vop (fn [op & colls] (apply mapv (fn [& terms] (apply op terms)) colls))\n        right-tri-all-points (fn [{:keys [origin x y length]}]\n                                (map (fn [[mx my]]\n                                       (vop + (vop + origin (svop * mx x)) (svop * my y)))\n                                     (for [x (range length)\n                                           y (range length)\n                                           :when (< (+ x y) length)]\n                                        [x y])))\n        point-tri-all-points (fn [{:keys [origin x y length]}]\n                               (let [diff (svop / 2 (vop - x y))]\n                                 (for [i (range length)\n                                       j (->> i inc (* 2) dec range)]\n                                   (vop + (vop + origin (svop * i y)) (svop * j diff)))))\n        all-mineral? (fn [points]\n                      (every? #(= 1 (get-in board %)) points))\n        max-tri (fn [gen-fn {:keys [length] :as current}]\n                  (let [next-tri (assoc current :length (inc length))]\n                    (if (all-mineral? (gen-fn next-tri))\n                      (recur gen-fn next-tri)\n                      current)))\n        right-area (fn [x] (int (* (inc x) (/ x 2))))\n        point-area (fn [x] (* x x))\n        result (max \n                (->> right-triangles (map (partial max-tri right-tri-all-points)) (map :length) (apply max) right-area) \n                (->> point-triangles (map (partial max-tri point-tri-all-points)) (map :length) (apply max) point-area))]\n    (if (> result 1) result)\n        \n        \n                          ))","problem":127,"user":"50217818e4b00bba4502f7a7"},{"problem":127,"code":"(\nletfn\n[\n(slices\n  [brd x y]\n  (let [w (count (first brd))\n        h (count brd)]\n    (for [l (range 0 (inc (- w x)))\n          u (range 0 (inc (- h y)))]\n      (take y (drop u (map #(apply str (take x (drop l %))) brd))))))\n(left\n  [x]\n  (let [x (inc (int (/ x 2)))]\n  (concat\n    (for [k (range 1 (inc x))]\n      (apply str (concat (repeat k \"1\") (repeat (- x k) \"0\"))))\n    (for [k (range (inc x) (* 2 x))]\n      (apply str (concat (repeat (- (* 2 x) k) \"1\") (repeat (- k x) \"0\")))))))\n(top\n  [x]\n  (map (fn [k] (str (apply str (repeat k \"0\")) (apply str (repeat (- x (* 2 k)) \"1\")) (apply str (repeat k \"0\")))) (range 0 (inc (int (/ x 2))))))\n(top2\n  [x]\n  (map (fn [k] (str (apply str (repeat (- x k) \"1\")) (apply str (repeat k \"0\")))) (range 0 x)))\n(fliph\n  [brd]\n  (map #(->> % (reverse) (apply str)) brd))\n(flipv\n  [brd]\n  (->> brd (reverse) (vec)))\n(shapes\n  [x]\n  (if (odd? x)\n    [(top x) (flipv (top x)) (top2 x) (fliph (top2 x)) (flipv (top2 x)) (fliph (flipv (top2 x))) (left x) (fliph (left x))]\n    [(top2 x) (fliph (top2 x)) (flipv (top2 x)) (fliph (flipv (top2 x)))]))\n(weight\n  [shape]\n  (->> shape (apply concat) (filter #(= \\1 %)) (count)))\n(all-slices\n  [brd]\n  (apply concat\n    (for [x (reverse (range 2 (inc (count (first brd)))))\n          y (reverse (range 2 (inc (count brd))))]\n      (slices brd x y))))\n(contains\n  [brd shape]\n  (some\n    #(when\n      (and\n        (<= (count shape) (count %))\n          (every?\n          (fn [[sl bl]]\n            (and\n              (<= (count sl) (count bl))\n              (every?\n                (fn [[s b]] (or (= \\0 s) (= s b)))\n                (map vector sl bl))))\n          (map vector shape %)))\n      shape)\n    (all-slices brd)))\n(solve\n  [brd]\n  (let [shapes\n          (sort-by #(- (weight %)) (mapcat shapes (range 2 (inc (max (count brd) (count (first brd)))))))\n        found (some (partial contains brd) shapes)]\n    found))\n(read-stuff\n  [xs]\n  (let [stuff (map #(Integer/toBinaryString %) xs)\n        len (count (apply max-key count stuff))]\n    (map #(apply str (concat (repeat (- len (count %)) \"0\") [%])) stuff)))\n]\n  (fn [xs]\n    (let [found (solve (read-stuff xs))]\n      (when found (weight found))))\n)","user":"57717915e4b0979f896515b3"},{"problem":127,"code":"(fn f [s]\n  (let [b (fn [x] (Integer/toBinaryString x))\n        c (fn [e] (count (b e)))\n        m (c (apply max s))\n        area (mapv #(str (apply str (repeat (- m (c %)) \\0)) (b %)) s)\n        [h w] (map count [area (area 0)])\n        pa (mapv #(for [x (range w)] [[% x] (get-in area [% x])]) (range h))\n        j (fn [x]\n          (filter #(and (> (count %) 1) (apply = \\1 (map (fn [[k v]] v) %))) x))\n        k (fn [x] (mapcat #(partition-by (fn [[[y x] v]] (= v \\1)) %) x))\n        o (fn [x] (apply mapcat #(partition-by (fn [[[y x] v]] (= v \\1)) %&) x))\n        sb (fn [x] (sort-by count > x))\n        [rows columns] [(sb (j (k pa))) (sb (j (o pa)))]\n        get-e (fn [cross x] ((juxt take-while (comp rest drop-while)) #(not= cross %) x))]\n    (if (some empty? [rows columns])\n         nil\n        (let [lines \n                (for [row rows column columns :let [cross (some #((set row) %) column)] :when cross] (let [[[lr rr] [uc dc]] (mapv #(get-e cross %) [row column])]\n                  [cross [lr rr] [uc dc]]))\n              ra (mapcat (fn [[cross [lr rr] [uc dc]]]\n                  (for [x [(reverse lr) rr] y [(reverse uc) dc] :let [pair (mapv vector x y)]\n                        :when (and (seq x) (seq y))]\n                    (into [cross] (peek pair)))) lines)\n              nra (mapcat (fn [[_ [lr rr] [uc dc]]] \n                    (keep #(peek (apply mapv vector %))\n                      [[(reverse uc) (reverse lr) rr] [dc (reverse lr) rr]\n                       [(reverse lr) (reverse uc) dc] [rr (reverse uc) dc]]))\n                   lines)\n              m1 (reduce (fn [i [[[py px] _] [[ry rx] _] [[cy cx] _]]]\n                  (let [x-asc? (> rx cx) y-asc? (> cy ry)\n                        e (mapcat #(for [x ({x-asc? (range cx (+ cx 1 %1))} true (range cx (- cx 1 %1) -1))]\n                                (get-in area [%2 x]))\n                            ({x-asc? (range (- rx cx -1))} true (range (- cx rx -1)))\n                            ({y-asc? (range cy (dec ry) -1)} true (range cy (inc ry))))]\n                    (if (every? #{\\1} e) (conj i (count e)) i)))\n                  [] ra)\n              m2 (reduce \n                  (fn [i [[[ty tx] _] [[b1y b1x] _] [[b2y b2x] _]]]\n                    (let [rotate? (= b1x b2x) left? (< tx b1x) up? (< ty b1y)\n                          e (if rotate?                                \n                                (mapcat #(for [y (range (- ty %1) (+ ty %1 1))] [y %2])\n                                  (range (Math/abs (- ty b1y -1))) ({left? (range tx (inc b1x))} true (range tx (dec b1x) -1)))\n                                (mapcat #(for [x (range (- tx %1) (+ tx %1 1))] [%2 x])\n                                  (range (- tx b1x -1)) ({up? (range ty (inc b1y))} true (range ty (dec b1y) -1))))]\n                      (conj i (count e))))\n                  [] nra)]\n             (apply max (into m1 m2))))))","user":"548b7db8e4b0e286459a11fd"},{"problem":127,"code":"(fn _127_ [rec]\n  (letfn [(print-rec [rec]\n            (map #(Integer/toBinaryString %) rec))\n\n          (size [rec]\n            [(count rec) (apply max (map count (print-rec rec)))])\n\n          (match-window? [rec window]\n            (let [[hr wr] (size rec)\n                  [h w] (size window)]\n              (if (and (<= h hr) (<= w wr))\n                (->>\n                 (for [crec (partition h 1 rec)\n                       wd (map (fn [n] (map #(bit-shift-left % n) window)) (range (inc (- wr w))))]\n                   (= (map bit-and crec wd) wd))\n                 (some true?))\n                false)))\n\n          (reg-triangle [n] (take n (iterate #(inc (* 2 %)) 1)))\n\n          (flip-y [reg-triangle]\n            (map-indexed\n             (fn [idx value] (bit-shift-left value (dec (- (count reg-triangle) idx))))\n             reg-triangle))\n\n          (triangles-group1 [n]\n            (let [tr1 (reg-triangle n)\n                  tr2 (flip-y tr1)]\n              [tr1 tr2 (reverse tr1) (reverse tr2)]))\n\n          (triangles-group2 [n]\n            (let [tr1 (concat (reg-triangle n) (reverse (reg-triangle (dec n))))\n                  tr2 (concat (flip-y (reg-triangle n)) (flip-y (reg-triangle (dec n))))]\n              [tr1 tr2]))\n\n          (triangles-group3 [n]\n            (let [tr1 (map +\n                           (map #(bit-shift-left % n) (reg-triangle (inc n)))\n                           (flip-y (concat [0] (reg-triangle n))))]\n              [tr1 (reverse tr1)]))\n\n          (gen-windows [rec]\n            (let [[h w] (size rec)]\n              (set (concat\n                    (mapcat #(triangles-group1 %) (range 1 (inc w)))\n                    (mapcat #(triangles-group2 %) (range 1 (inc w)))\n                    (mapcat #(triangles-group3 %) (range 1 (inc w)))))))\n\n          (count-window [window]\n            (count (re-seq #\"1\" (apply str (print-rec window)))))\n\n          (max-triangle [rec]\n            (let [mc (->>\n                      (keep (fn [window]\n                              (when (match-window? rec window)\n                                (count-window window)))\n                            (gen-windows rec))\n                      (apply max))]\n              (when (>= mc 3) mc)))]\n    (max-triangle rec)))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(let [initial (fn [c] (repeat 8 (list c)))\n      moves '(([-1  0] [-1 -1]) ([-1  0] [-1  1])\n               ([ 0  1] [-1  1]) ([ 0  1] [ 1  1])\n               ([ 1  0] [ 1 -1]) ([ 1  0] [ 1  1])\n               ([ 0 -1] [-1 -1]) ([ 0 -1] [ 1 -1]))\n      t-area (memoize \n               (fn [s] (let [triangle \n                             (reductions + (range))] \n                         (nth triangle s))))\n      t2-area (fn [s] (- (* 2 (t-area s)) s))] \n  (fn love-triangle [d]\n    (let [mineral (set (apply concat \n                              (keep-indexed \n                                (fn [i n] \n                                  (let [o (reverse \n                                            (Integer/toBinaryString n))]\n                                    (keep-indexed \n                                      (fn [j b] \n                                        (when (= \\1 b) [i j])) o))) d)))\n          height (fn [l [s a]] \n                   (let [nl (map #(mapv + % %2) \n                                   (conj l (first l)) \n                                   (conj (repeat (count l) s) a))]\n                      (if (every? mineral nl) (recur nl [s a]) (count l))))\n          max-area (fn [[h1 h2]] (max (t-area (max h1 h2)) \n                                      (t2-area (min h1 h2))))]\n      (#(if (< 1 %) %) \n        (apply max \n               (map max-area \n                    (apply concat \n                           (for [c mineral] \n                             (partition 2 2 (map height \n                                                 (initial c) moves))))))))))","problem":127,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn solve [rows]\n(letfn [(middle [[[y0 x0] [y1 x1]]]\n           (map #(vector y0 %) (range x0 (inc x1))))\n\n         (triangle-to-str [triangle]\n           (let [[mxy mny mxx mnx] (for [cord [first second] f [max min]] (apply f (map cord triangle)))\n                 board (vec (repeat (- mxy mny -1) (vec (repeat (- mxx mnx -1) \" \"))))]\n           (->> (reduce #(assoc-in % (vec (map - %2 [mny mnx])) \"*\") board triangle)\n                (interpose \\newline)\n                (apply str))))\n\n         (dist [[[_ x0] [_ x1]]]\n           (- x1 x0))\n\n         (triangle [ends d]\n           (letfn [(move [ends] (map #(map + % %2) ends d))]\n             (->> (iterate move ends)\n                  (take-while #(>= (dist %) 0))\n                  (take 5)\n                  (mapcat middle)\n                  (set))))\n\n         (parse [rows]\n           (let [rows (map #(Integer/toBinaryString %) rows)\n                 mx (apply max (map count rows))]\n             (->> (map reverse rows)\n                  (map #(concat % (repeat \"0\")))\n                  (map #(take mx %))\n                  (map #(apply str %))\n                  (vec))))\n\n         (fits? [board triangle]\n           (every? true? (map #(= (get-in board %) \\1) triangle)))\n\n         (triangles [ends]\n            (let [d-all [[[1 0] [1 -1]]\n                         [[1 1] [1 0]]\n                         [[-1 0] [-1 -1]]\n                         [[-1 1] [-1 0]]]\n                  d-odd [[[1 1] [1 -1]]\n                         [[-1 1] [-1 -1]]]]\n            (map #(triangle ends %) (concat d-all (if (even? (dist ends)) d-odd [])))))\n\n         (all-triangles [width]\n           (->> (range 1 width)\n                (map (fn [x] [[0 0] [0 x]]))\n                (mapcat triangles)))\n\n         (move-triangle [triangle d]\n           (map #(vec (map + d %)) triangle))\n\n         (find-largest [board]\n           (let [width (count (first board))\n                 height (count board)\n                 ds (for [y (range height) x (range width)] [y x])]\n             (->> (all-triangles width)\n                  (mapcat #(map (partial move-triangle %) ds))\n                  (filter #(fits? board %))\n                  (map count)\n                  (reduce max 0))))\n\n         (transpose [board]\n           (vec (apply map vector board)))]\n  (let [board (parse rows)\n        res (max (find-largest board)\n              (find-largest (transpose board)))]\n    (if (zero? res) nil res))))","problem":127,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":127,"code":"(fn tri [input]\n  (letfn [(create-board [input]\n            (let\n              [max-col (loop [max-val 1] \n                         (if \n                           (> max-val (apply max input)) \n                           (/ max-val 2)\n                           (recur (* 2 max-val))))]\n              (for [row input]\n                (loop \n                  [new-row (list)\n                   row-val row\n                   denominator max-col]\n                  (if\n                    (= 0 denominator)\n                    new-row\n                    (recur\n                      (cons (quot row-val denominator) new-row)\n                      (mod row-val denominator)\n                      (quot denominator 2)))))))\n          (update-triangle [row triangle]\n            (let\n              [new-range (map + \n                           (:range triangle) \n                           (:range-growth triangle))]\n              (when\n                (and ((complement neg?) (first new-range))\n                     (< (second new-range) (count row))\n                     (every? pos? \n                       (subvec \n                         (vec row) \n                         (first new-range) \n                         (inc (second new-range)))))\n                (-> triangle\n                    (assoc :range new-range)\n                    (update-in [:size] + 1 (apply - (reverse new-range)))))))\n          (max-triangle [board]\n            (loop\n              [[row & rows] board\n               live-triangles (list)\n               largest-triangle 0]\n              (if\n                (nil? row)\n                largest-triangle\n                (let\n                  [new-triangles  (apply concat\n                                    (map-indexed\n                                      (fn [col square]\n                                        (when\n                                          (= square 1)\n                                          (map\n                                            (fn [rg]\n                                              {:range [col col]\n                                               :range-growth rg\n                                               :size 1})\n                                            [[0 1] [-1 0] [-1 1]])))\n                                      row))\n                   updated-triangles  (filter\n                                        identity\n                                        (map \n                                          (partial update-triangle row)\n                                          live-triangles))]\n                  (recur\n                    rows\n                    (concat updated-triangles new-triangles)\n                    (apply max \n                      (cons\n                        largest-triangle\n                        (map :size updated-triangles))))))))]\n    (let\n      [board (create-board input)\n       boards [board\n               (reverse board)\n               (apply (partial map vector) board)\n               (reverse\n                 (apply (partial map vector) board))]\n       largest-triangle (apply max\n                          (map max-triangle boards))]\n      (when\n        (< 1 largest-triangle)\n        largest-triangle))))","user":"521e8227e4b0dd19981ad082"},{"problem":127,"code":"(fn lt [is]\n  (letfn [(bin [n]\n            (if (< n 2) [n] (conj (bin (quot n 2)) (mod n 2))))\n          (base [[o vs h]]\n            (let [[[v1r v1c] [v2r v2c]] (map #(apply map + [o %]) (map #(map (partial * (dec h)) %) vs))]\n              (if (= v1r v2r)\n                (for [c (range v1c (inc v2c))] [v1r c])\n                (for [r (range v1r (inc v2r))] [r v1c]))))\n          (area [[b h]]\n            (if (> (count b) h) (* h h) (/ (* h (inc h)) 2)))\n          (max-area [m [o vs]]\n            (->> (map #(vector (base [o vs %]) %) (range))\n                 (take-while (fn [[b h]] (every? #(= 1 %) (map #(get-in m %) b))))\n                 last\n                 area))]\n    (let [ts  [[[1 -1]  [1 1]] [[-1 -1] [-1 1]] [[-1 -1] [1 -1]] [[-1 1] [1 1]]\n               [[1 0] [1 1]] [[-1 0] [-1 1]] [[0 -1] [1 -1]] [[0 1] [1 1]]]\n          m (vec (map bin is))]\n      (->> (for [r (range (count m))\n                 c (range (count (first m)))]\n             (map #(max-area m [[r c] %]) ts))\n           (apply concat)\n           (filter #(>= % 3))\n           (#(if (seq %) (apply max %)))))))","user":"53b39d82e4b047364c0444a6"},{"problem":127,"code":"(fn [c]\n  (let [m (int (Math/ceil (/ (Math/log (apply max c)) (Math/log 2))))\n        n (count c)\n        t (fn t [x n] (if (= n 0)\n                        []\n                        (concat (t (quot x 2) (dec n)) [(mod x 2)])))\n        b (map #(t % m) c)\n        e (fn [c] (reverse (map last c)))\n        r (fn [c n] (map #(e (last %))\n                      (group-by #(- n (mod (first %) n))\n                        (map-indexed vector (flatten c)))))\n        rf (fn [c] (reductions #(if (= 0 %2) 0 (+ %1 %2)) c))\n        ftt (fn [c] (map #(quot (inc %) 2) c))\n        b2 (r b m)\n        b3 (r b2 n)\n        b4 (r b3 m)\n        cft (fn [p c] (map #(if (> %2 %1) (inc %1) %2) p c))\n        frt (fn [p c] (cft p (first c)))\n        fft (fn [p c] (cft (concat [0] (butlast p)) (first c)))\n        frc (fn [b] (map rf (rest b)))\n        ffc (fn [b] (map #(ftt (rf %)) (rest b)))\n        fat (fn [b fnp fc] (apply max (flatten (loop [p (first b)\n                                                     c (fc b)\n                                                     res [p]]\n                                                (if (empty? c)\n                                                  res\n                                                  (let [np (fnp p c)]\n                                                    (recur np (rest c)\n                                                      (concat res [np]))))))))\n        rt (apply max (map #(fat % frt frc) [b b2 b3 b4]))\n        ft  (apply max (map #(fat % fft ffc) [b b2 b3 b4]))\n        rts (quot (* (inc rt) rt) 2)\n        fts (* ft ft)\n        rs (max rts fts)]\n    (if (= rs 1) nil rs)))","user":"55205564e4b08d5046aa8a60"},{"problem":127,"code":"(fn [ns]\n    (let [search-vs (map (fn [a]\n                           (map #(vector (Math/round (Math/cos (Math/toRadians (+ a %))))\n                                         (Math/round (Math/sin (Math/toRadians (+ a %)))))\n                                [90 0 135]))\n                         (range 0 360 45))\n          ms (->> ns (map-indexed (fn [i n] [i (Integer/toBinaryString n)]))\n                  (mapcat (fn [[x ys]] (map-indexed (fn [y b] [[x y] b]) ys)))\n                  (filter #(= \\1 (second %))) (map first) set)]\n      (letfn [(add [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n              (mult [[x y] m] [(* x m) (* y m)])\n              (search [[x y :as p] v f]\n                (if (= p f) 0\n                    (if (ms p) (inc (search (add p v) v f)) -100)))\n              (tri [[x y :as p] [v1 v2 v3 :as vs] a m]\n                (let [p1 (add p (mult v1 m))\n                      p2 (add p (mult v2 m))\n                      b (and (ms p2) (search (add v3 p2) v3 p1))]\n                  (if (and (ms p1) (ms p2) (and b (>= b 0)))\n                    (tri p vs (+ a b 2) (inc m))\n                    a)))]\n        ((fn [t] (when (>= t 3) t))\n         (apply max (mapcat (fn [m] (map #(tri m % 1 1) search-vs)) ms))))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":127,"code":"(letfn [\n      (transpose [matrix]\n        (for [i (->> matrix first count range)]\n          (map #(nth % i) matrix)\n        )\n      )\n      (log2 [n] (/ (Math/log n) (Math/log 2)))\n      (base2 [& numbers]\n        (let [bits (->> numbers (apply max) inc log2 Math/ceil int)]\n          (for [n numbers]\n            (map  #(if (zero? (rem % 2)) 0 1)\n              (-> (take bits (iterate #(quot % 2) n)) reverse)\n            )\n          )\n        )\n      )\n      (consecutive [coll n]\n        \"Returns {:count items, :start start_pos, :end end_pos} with max consecutive n values.\"\n        (for [k (reverse (range 1 (inc (count coll))))\n              d (range (- (inc (count coll)) k))\n              :let [part (take k (drop d coll))]\n              :when (every? (partial = 1) part)]\n            {:count k, :start d, :end (+ d k -1)}\n        )\n      )\n      (consecutive-matrix [matrix n]\n        (for [i (range (count matrix))\n              consecutive-row (consecutive (nth matrix i) n)]\n            (assoc consecutive-row :start [i (:start consecutive-row)] :end [i (:end consecutive-row)])\n        )\n      )     \n      ] \n\n      (fn max-triangle [bitmap]\n        (let [bitmap (apply base2 bitmap)\n              rows bitmap\n              cols (transpose bitmap)\n              rows-consecutive (consecutive-matrix rows 1)\n              cols-consecutive (consecutive-matrix cols 1)\n              lines (concat rows-consecutive cols-consecutive)]\n         \n          (let [fields\n            (concat\n                \n      \n                (for [s1 (remove #(< (:count %) 2) rows-consecutive)\n                      s2 (remove #(< (:count %) 2) cols-consecutive)\n                      :let [s1Size (:count s1) s2Size (:count s2)\n                            s1Start (:start s1) s1End (:end s1)\n                            s2Start (vec (reverse (:start s2))) s2End (vec (reverse (:end s2)))]\n                      :when (and (= s1Size s2Size) (= 3 (count (set [s1Start s1End s2Start s2End]))))]\n                     (reduce + (range 1 (inc s1Size)))\n                )\n              \n                (loop [lines (set lines) current '()]\n                  (if (and (not (empty? current)) (= 1 (:count (apply min-key :count current))))\n                    [(reduce + (map #(-> % vec first last) current))]\n                    (let [n (nth (reverse (range 1 (inc (count (first bitmap))) 2)) (count current))\n                          candidates (filter #(= n (:count %)) lines)]\n                      (cond\n                        (and (empty? candidates) (empty? current)) nil\n                        (empty? candidates) (recur (clojure.set/difference lines current) '())\n                        (empty? current) (recur lines (conj current (first candidates)))\n                        :else\n                          (let [prevStart (:start (first current))\n                                prevEnd (:end (first current))\n                                suitable (filter \n                                            (fn [candidate]\n                                              (let [start (:start candidate) end (:end candidate)]\n                                                (and \n                                                  (or (= 1 (- (first start) (first prevStart))) (= -1 (- (first start) (first prevStart))))\n                                                  (or (= 1 (- (last start) (last prevStart))) (= -1 (- (last start) (last prevStart))))\n                                                  (or (= 1 (- (first end) (first prevEnd))) (= -1 (- (first end) (first prevEnd))))\n                                                  (or (= 1 (- (first end) (first prevEnd))) (= -1 (- (first end) (first prevEnd))))\n                                                )\n                                              )     \n                                            )\n                                          candidates)]\n                            (if (empty? suitable)\n                              (recur (clojure.set/difference lines current) '())\n                              (recur lines (conj current (first suitable)))\n                            )\n                          )\n                      )\n                    )\n                  )\n                )\n            )]\n            (if (empty? fields)\n              nil\n              (apply max fields)\n            )\n          )\n        )\n      )      \n)","user":"5991d2fae4b0866487ed0d68"},{"problem":127,"code":"(fn [m]\n  (let [X (count m)\n        m (->> m (map (fn [x] (->> x (iterate #(quot % 2)) (take-while pos?) (mapv #(mod % 2))))))\n        Y (->> m (map count) (apply max 0))\n        m (->> m (mapv #(into % (repeat (- Y (count %)) 0))))\n        m (->> m (mapv #(into % (repeat 26 '?))))]\n    (->> (for [i (range X)\n               j (range Y)\n               :when (pos? (get-in m [i j]))]\n           (for [next\n                 [(fn [n] (map vector (repeat (- n)) (range (- n) (inc n))))\n                  (fn [n] (map vector (repeat (+ n)) (range (- n) (inc n))))\n                  (fn [n] (map vector (range (- n) (inc n)) (repeat (+ n))))\n                  (fn [n] (map vector (range (- n) (inc n)) (repeat (- n))))\n                  (fn [n] (->> [(- n) 0] (iterate (fn [[x y]] [(inc x) (inc y)])) (take (inc n))))\n                  (fn [n] (->> [0 (- n)] (iterate (fn [[x y]] [(inc x) (inc y)])) (take (inc n))))\n                  (fn [n] (->> [(- n) 0] (iterate (fn [[x y]] [(inc x) (dec y)])) (take (inc n))))\n                  (fn [n] (->> [0 (+ n)] (iterate (fn [[x y]] [(inc x) (dec y)])) (take (inc n))))]\n                 :let [mine\n                       (->> (iterate inc 1)\n                         (map next)\n                         (map #(map (fn [p] (map + p [i j])) %))\n                         (take-while #(every? (fn [[x y :as p]]\n                                                (and (<= 0 x (dec X))\n                                                  (<= 0 y (dec Y))\n                                                  (pos? (get-in m p))))\n                                        %))\n                         seq)]\n                 :when mine]\n             (->> mine (apply concat) count)))\n      (apply concat)\n      (apply max 0)\n      ((fn [x] (if (pos? x) (inc x)))))))","user":"50479524e4b0371827a27bc4"},{"problem":127,"code":"(fn [v]\n    (let [\n          parseBitmap\n          (fn [v]\n            (loop [v v r '()]\n              (if (> v 0)\n                (if (= 1 (bit-and 1 v))\n                  (recur (bit-shift-right v 1) (conj r 1))\n                  (recur (bit-shift-right v 1) (conj r 0))\n                  )\n                r\n                )\n              )\n            )\n          pad \n          (fn [v n]\n            (loop [v v]\n              (if (< (count v) n)\n                (recur (conj v 0))\n                (vec v)\n                )\n              )\n            )\n          flipX\n          (fn [v]\n            (map reverse v)\n            )\n          flipY\n          (fn [v]\n            (reverse v)\n            )\n          rot\n          (fn [v]\n            (loop [q [] x 0]\n              (if (> (count (first v)) x)\n                (recur\n                  (conj q\n                        (loop [w [] y 0]\n                          (if (> (count v) y)\n                            (recur (conj w (get-in v [y x])) (+ y 1))\n                            w\n                            )\n                          )\n                        )\n                  (+ 1 x)\n                  )\n                q\n                )\n              )\n            )\n          t\n          (fn [b x y f g]\n            (loop [b (drop y b) x x y y c 1 t 0]\n              (let [r (take c (drop x (first b)))]\n                (if (= c (apply + r))\n                  (recur (rest b) (f x) (+ y 1) (g c) (+ t c) )\n                  t\n                  )\n                )\n              )\n            )\n          n (count (parseBitmap (apply max v))) b (map (comp #(pad % n) parseBitmap) v) q\n          (apply max\n                 (for [x (range (- n 1)) y (range (- (count v) 1))]\n                   (max\n                     (t b x y identity #(+ 1 %))\n                     (t b x y #(- % 1) #(+ 2 %))\n                     (t (flipX b) x y identity #(+ 1 %))\n                     (t (flipX b) x y #(- % 1) #(+ 2 %))\n                     (t (flipY b) x y identity #(+ 1 %))\n                     (t (flipY b) x y #(- % 1) #(+ 2 %))\n                     (t (rot (vec b)) x y #(- % 1) #(+ 2 %))\n                     )\n                   )\n                 )\n          ]\n      (if-not (= 1 q)\n        q\n        )\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":";;; General Approach\n;;; For each point on the grid, try placing the right angle there. Then, \"grow\" the triangle in\n;;; each of the eight directions until non-ore is encountered. Count the largest triangle created\n;;; in this way.\n(fn [nums]\n   (let [n [-1 0] ne [-1 1] e [0 1] se [1 1]\n         s [1 0] sw [1 -1] w [0 -1] nw [-1 -1]\n\n         pow2 (take-while #(<= % (apply max nums))\n                          (iterate #(* 2 %) 1))\n         H (count nums)\n         W (count pow2)\n         grid (vec (for [y nums]\n                     (vec\n                      (for [x pow2]\n                        (pos? (bit-and x y))))))\n         ore? #(get-in grid %)\n\n         ;; growth functions for each of the eight directions from a starting point\n         growths (for [dirs [[n e] [e s] [s w] [w n]\n                             [nw n ne] [ne e se]\n                             [sw s se] [nw w sw]]]\n                   (fn [pos]\n                     (for [dir dirs]\n                       (map + dir pos))))\n\n         ;; given a starting point and a growth function, how many ore spaces does it find?\n         size (fn [start grow]\n                (->> #{start}\n                     (iterate #(set ;; compute a new frontier set\n                                (mapcat grow %)))\n                     (take-while #(every? ore? %))\n                     (map count) ;; add sizes of each ore-only frontier sets\n                     (apply +)))\n\n         max-ore (apply max\n                        (for [y (range H) x (range W)\n                              grow growths]\n                          (size [y x] grow)))]\n     (when (>= max-ore 3)\n       max-ore)))","problem":127,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":127,"code":"(fn [num-per-row]\n  (let [mx-incomplete (vec (for [numeric-line num-per-row] ;mx-incomplete is the given matrix, but without any leading false's (i.e. leading 0's)\n                             (vec (for [digit (seq (Integer/toString numeric-line 2))]\n                                     ({\\0 false \\1 true} digit)))))\n        ; [x y] x is  row, y is a column\n        height (count mx-incomplete)\n        width (apply max (map count mx-incomplete))\n        mx (vec (for [row-inco mx-incomplete]\n                   (vec (concat (repeat (- width (count row-inco)) false) row-inco))))\n        directions #_from-top-left-clockwise [[-1 -1] [-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1]]\n        numbered-direction #_rotate-index-overflow (fn [num] (directions (rem num 8)))\n        line (fn [])\n        right-of (fn []) ;<<<<\n        left-of (fn [])\n        x-range (seq (vec (range 0 height)))\n        y-range (seq (vec (range 0 width)))\n        _ (assert (every? (comp (partial = width) count) mx))\n        _ (assert (every? (partial every? (comp (partial = java.lang.Boolean) type)) mx))\n        ;mx is a matrix-like map of maps, with indexes that can be negative: relative to the start point.\n        at (fn [[x y :as coordinates]] {:pre [(= (count coordinates) 2) (number? x) (number? y)]} #_returns-nil-if-not-set (get-in mx coordinates))\n        ;directions as [delta-x delta-y], in coordinates where x is a row, y is a column, [0 0] is the top left corner. D down, U up, R right, L left:\n        direction? (fn [[delta-x delta-y :as all]] (and (= (count all) 2) (<= -1 delta-x 1) (<= -1 delta-y 1) (not= delta-x delta-y 0)))\n        _ (assert (every? direction? directions))\n        index-of (fn [item coll] ;nil if no such item. Item itself can be nil or false.\n                   (loop [index 0, s (seq coll)]\n                     (if s\n                       (if (= (first s) item)\n                         index\n                         (recur (inc index) (next s)))\n                       nil)\n                     ))\n        turn (fn [prev-dir num-of-turns] {:pre [(direction? prev-dir) (number? num-of-turns)] :post [(direction? %)]} ;previous direction => new direction 45degrees to the right\n               (let [prev-dir-index (index-of prev-dir directions)]\n                 (numbered-direction (+ prev-dir-index num-of-turns))))\n        place? (fn [[x y :as pl]] {:pre [(and (= (count pl) 2) (number? x) (number? y))]}\n                 (and (< -1 x height) (< -1 y width)))\n        max-side (max height width) ;it's max, not min, because of example of 2 rows: 111, 011.\n        move (fn [[from-x from-y :as from] [dir-x dir-y :as dir]] {:pre [(place? from) (direction? dir)]};no :post validation by place?, because we validate outside\n               [(+ from-x dir-x) (+ from-y dir-y)])\n        ;radius-range (seq (vec (range 0 max-side)))\n        immediate-neighbours (fn [from] {:pre [(place? from)]}\n                               (filter place?\n                                       (for [dir directions]\n                                         (move from dir))))\n        _ (doseq [row mx]\n            (println (apply str (map {true 1, false 0} row))))\n        _ (println \"x-range\" x-range \"y-range\" y-range \"directions\" directions)\n        triangle-sizes (for [corner-x x-range\n                             corner-y y-range\n                             :let [corner [corner-x corner-y]]\n                             :when (at corner)\n                             :let [_ (println \"corner\" corner)]\n                             dir-left-side  directions\n                             ;We only handle 90 degrees at the corner. As we rotate, and we try every place as the \"main\" corner, that handles all possible triangles.\n                             ;Otherwise we need to handle many special cases. E.g. the longest side getting longer by two\n                             ;places (instead of just one) at every inner loop iteration. Even though lazy-seq helped to close the triangle, calculating the triangle's\n                             ;area would be unnecessarily complex.\n                             :let[dir-right-side (turn dir-left-side 2) ;90deg\n                                  dir-left-right (turn dir-left-side 3) ;45deg between the left side and the side opposite to \"the corner\" (i.e. the left to right neighbour side)\n                                  #_right-corner-generator #_(fn right-corner-gen [start]\n                                                                 (lazy-seq (cons start\n                                                                             (let [place (move start dir-right-side)]\n                                                                               (if (place? place)\n                                                                                 (right-corner-gen place)\n                                                                                 ())))))\n                                  ;right-corner-seq (right-corner-generator corner)\n                                  size (loop [left-corner corner\n                                              right-corner corner\n                                              size-so-far 1]\n                                         (println \"outer loop: left-corner\" left-corner \"right-corner\" right-corner \"size-so-far\" size-so-far \"dir-left-side\" dir-left-side \"dir-right-side\" dir-right-side \"dir-left-right\" dir-left-right)\n                                         (let [left-corner-new  (move  left-corner  dir-left-side)\n                                               right-corner-new (move right-corner dir-right-side)\n                                               left-to-right-length (if (place? right-corner-new)\n                                                                       (loop [place left-corner-new ;loop returns nil if the line is not purely mineral\n                                                                              length 0]\n                                                                          (println \"inner loop: place\" place \"length\" length)\n                                                                          (if (at place)\n                                                                             (if (= place right-corner-new) ;(=...) could be replaced by (index-of place right-corner-seq) to handle when right side get longer by two units (rather than just one unit) per iteration\n                                                                                (inc length)\n                                                                                (let [place-new (move place dir-left-right)]\n                                                                                   (assert (place? place-new) (str \"place-new\" place-new))\n                                                                                   (recur place-new (inc length))))\n                                                                             nil)))]\n                                           (if left-to-right-length\n                                               (recur left-corner-new right-corner-new (+ size-so-far left-to-right-length))\n                                               size-so-far)))]\n                             :when (<= 3 size)]\n                           size )\n        ]\n    (if (seq triangle-sizes)\n        (apply max triangle-sizes)\n        nil)))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":127,"code":"(fn [bm] \n  (let [dm0 (map (partial map #(- (int %) 48))\n                 (map #(Integer/toBinaryString %) bm))\n        w (apply max (map count dm0)) h (count bm)\n        dm (vec (map #(vec (concat (repeat (- w (count %)) 0) %)) dm0))\n        ds (mapcat #((juxt butlast identity rest) %)\n                   (mapcat #((juxt identity (partial map reverse)) %)\n                           (map #(map (partial vector %) [1 0 -1]) [1 -1])))\n        f-nx (fn [prs d] (set (mapcat #(map vec (map (partial map + %) d)) prs)))\n        psets (for [x (range w) y (range h) d ds :when (= 1 (get-in dm [y x]))] \n                   (reduce into (take-while (partial every? #(= 1 (get-in dm %)))\n                                            (iterate #(f-nx % d) #{[y x]}))))]\n    (#(if (> % 1) %) (apply max (map count psets)))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [xs]\n  (let [bits (map (fn [x] (if (zero? x) [] (reverse (map #(bit-test x %) (range 0 (inc (int (/ (Math/log x) (Math/log 2))))))))) xs)\n        max-l (apply max (map count bits))\n        board (map (fn [b] (concat (repeat (- max-l (count b)) false) b)) bits)\n        rotate (fn [board] (vec (map (comp vec reverse) (partition (count board) (apply interleave board)))))\n        scores (for [board (take 4 (iterate rotate board))\n                     :let [w (count (first board))\n                           h (count board)]\n                     size (range (max w h) 1 -1)\n                     type (concat (if (and (<= size w) (<= size h)) [:right] [])\n                                  (if (and (<= size h) (= 1 (mod size 2))) [:iso] []))\n                     :let [iso-w (/ (inc size) 2)]\n                     x (range (inc (- w (if (= :right type) size iso-w))))\n                     y (range (inc (- h size)))\n                     :let [coords (if (= :right type)\n                       (for [dx (range size) dy (range (- size dx))] [(+ x dx) (+ y dy)])\n                       (for [dx (range iso-w) dy (range dx (- size dx))] [(+ x dx) (+ y dy)]))]\n                     :when (every? (fn [[x y]] (get-in board [y x])) coords)]\n                  (count coords))]\n    (when (seq scores) (apply max scores))))","problem":127,"user":"4ebc08a8535dfed6da9c6d7c"},{"code":"(fn [b]\r\n  (let [z (apply max 0\r\n            (for [b [b (vec (reverse b))]\r\n                  y (range (count b))\r\n                  x (range (inc (/ (Math/log (get b y 0)) (Math/log 2))))\r\n                  [i a m] [[-1 0 0] [-1 0 1] [-1 1 0] [0 1 0] [0 1 1]]\r\n                  :let [s (loop [m m\r\n                                 d [i a]\r\n                                 [l h :as r] [x x]\r\n                                 s 0 \r\n                                 [w & e :as b] (drop y b)] \r\n                                (cond\r\n                              (and w (>= l 0) (every? #(bit-test w %) (range l (inc h)))) \r\n                                (recur m d (map + d r) (+ s 1 (- h l)) e)\r\n                              (< h l) s\r\n                              (= 0 m) s\r\n                              (= 1 m) (recur 2 (map - d) (map - r d d) s b)))]\r\n                  :when s]\r\n                 s))]\r\n    (when (> z 1) z)))","problem":127,"user":"4db858d1535d1e037afb218c"},{"problem":127,"code":"(fn [ex]\n           (let [dirs [[[1 0] [0 1]] [[1 0] [0 -1]] [[-1 0] [0 -1]] [[-1 0] [0 1]]\n                       [[1 1] [0  1] [-1 1]] [[-1 -1] [0 -1] [1 -1]] [[-1 -1] [-1 0] [-1 1]] [[1 -1]  [1 0]  [1 1]]]\n                 f (fn [pos] (map #(iterate\n                                    (partial\n                                     (fn [dirs bas]\n                                       (set (for [[x y] bas [dx dy] dirs] [(+ x dx) (+ y dy)]))) %)\n                                    #{pos}) dirs))\n                 valid? (fn [[i j]] (and (<= 0 i (dec (count ex))) (<= 0 j 30)))\n                 valid-set (fn [s]\n                             (let [ss  (map (fn [[i j]]\n                                              (when\n                                               (and (valid? [i j])\n                                                    (bit-test (ex i) j))\n                                                [i j])) s)]\n                               (when (not-any? #(or (false? %) (nil? %)) ss)\n                                 (count ss))))\n                 count-seq (fn [xs]\n                             (take-while identity\n                                         (map valid-set xs)))\n                 g (fn [pos] (map count-seq (f pos)))\n                 h (fn [pos] (apply max (map #(apply + %) (g pos))))\n                 sol (apply max (for [i (range (count ex)) j (range 10)] (h [i j])))]\n             (when (not= 1 sol) sol)))","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn [q] \n  (let [cdirs (cycle (for [d [bit-shift-left bit-shift-right] i [1 8]] #(d % i)))\n        b (reduce #(bit-or ((second cdirs) %) %2) q)\n        shave (fn [b dirs] (reduce #(bit-and % (%2 b)) b dirs)) \n        ishave (fn [dirs] \n                  (count (take-while pos? (iterate #(shave % dirs) b))))\n        nshaves (fn [n]\n                  (->> (partition n 1 cdirs) (take 4) (map ishave) (apply max)))\n        s2 (nshaves 2)\n        s3 (nshaves 3)\n        m (max (quot (* s2 (inc s2)) 2) (* s3 s3))]\n    (when (>= m 3) m)))","problem":127,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":127,"code":"(let [\n      ; take an integer, and return its binary representation, as a vector of 1's and 0's                                                                                                \n      binary-vector (fn binary-vector [n]\n                      (mapv #(if (= % \\1) 1 0) (seq (Integer/toString n 2))))\n\n      ; take a vector v, an integer n, and return a vector which has exaclty enough p's conjoined to                                                                                     \n      ; its beginning so that its length is n                                                                                                                                            \n      pad (fn pad [v n p] (apply vector (concat (repeat (- n (count v)) 0) v)))\n\n      ; takes a vector of integers representing a rock, and returns a binary representation                                                                                              \n      ; of the rock as a vector of binary vectors.  E.g:                                                                                                                                 \n      ; (binary-rock [7 3])  =>  [ [1 1 1] [0 1 1] ]                                                                                                                                     \n      binary-rock (fn binary-rock [r]\n                    (let [a   (map binary-vector r)\n                          len (apply max (map count a))]\n                      (mapv #(pad % len 0) a)))\n\n      ; return true iff the vector v contains 1's in every position starting with `start` and                                                                                            \n      ; ending with `end`-1, inclusive                                                                                                                                                   \n      all-ones (fn all-ones [v start end] (every? #(= % 1) (subvec v start end)))\n\n      ; Take a vector containing a binary rock b-rock, a row number (int), a starting pos (int), an ending pos (int),                                                                    \n      ; and a direction {:sw :se :nw :ne}, and return a new vector of these same things, grown                                                                                           \n      ; by one row in the given direction, if possible.  If not possible, return the original input vector.                                                                              \n      ;                                                                                                                                                                                  \n      ; Assume that the given row of the b-rock contains 1's in every position starting with start and                                                                                   \n      ; ending with end. \n            grow-by-one (fn grow-by-one [[b-rock row start end dir :as v]]\n                    (let [next-row (+ row (if (#{:se :sw :s} dir) 1 (- 1)))]\n                      (if (or (< next-row 0)\n                              (>= next-row (count b-rock)))\n                        v\n                        (cond\n                         (#{:sw :nw} dir) (let [next-start (dec start)]\n                                            (if (or\n                                                 (< next-start 0)\n                                                 (not (all-ones (b-rock next-row) next-start end)))\n                                              v\n                                              [b-rock next-row next-start end dir]))\n                         (#{:s :n} dir) (let [next-start (dec start)\n                                              next-end   (inc end)]\n                                          (if (or\n                                               (< next-start 0)\n                                               (> next-end (count (b-rock next-row)))\n                                               (not (all-ones (b-rock next-row) next-start next-end)))\n                                            v\n                                            [b-rock next-row next-start next-end dir]))\n                         :else            (let [next-end (inc end)]\n                                            (if (or\n                                                 (> next-end (count (b-rock next-row)))\n                                                 (not (all-ones (b-rock next-row) start next-end)))\n                                              v\n                                              [b-rock next-row start next-end dir]))))))\n\n      ; keep applying f to a until it doesn't change any more; return the result                                                                                                         \n      fixed-point (fn fixed-point [f a] (let [fa (f a)] (if (= a fa) a (fixed-point f fa))))\n\n      ; return the n-th triangular number, i.e. the sum of the integers from 1 to n, inclusive                                                                                           \n      triangular-number (fn triangular-number [n] (/ (* n (inc n)) 2))\n\n      triangular-number-2 (fn triangular-number-2 [n]\n                            (let [n2 (quot n 2)]\n                              (+ (triangular-number n2) (triangular-number (inc n2)))))\n\n      ; return the measure of a triangle of minerals whose widest row is given by the indicated vector                                                                                   \n      measure (fn measure [[b-rock row start end dir]] ((if (#{:n :s} dir) triangular-number-2 triangular-number)\n                                                          (- end start)))\n      ; return the measure of the largest possible triangle of minerals whose tip is at row,col                                                                                          \n      max-vert-measure-starting-at (fn max-vert-measure-starting-at [b-rock row col]\n                                     (if (= 1 (get-in b-rock [row col]))\n                                       (apply max\n                                              (map #(measure (fixed-point grow-by-one [b-rock row col (inc col) %])) [:ne :nw :sw :se :s :n]))\n                                       0))\n\n      ; return a vector of the indices of all the positions in the given matrix; each position                                                                                           \n      ; is a vector of the form [row column]                                                                                                                                             \n      indices (fn indices [m]\n                (for [r (range (count m)) c (range (count (m 0)))] [r c]))\n\n      vert-measures (fn vert-measures [b-rock]\n                      (map\n                       (fn [[r c]] (max-vert-measure-starting-at b-rock r c))\n                       (indices b-rock)))\n\n      max-vert-measure (fn max-vert-measure [b-rock]\n                         (apply max (vert-measures b-rock)))\n\n      transpose (fn transpose [m] (apply mapv vector m))\n\n      max-measure (fn max-measure [rock]\n                    (let [b-rock (binary-rock rock)\n                          m      (max\n                                  (max-vert-measure b-rock)\n                                  (max-vert-measure (transpose b-rock)))]\n                      (if (>= m 3) m nil)))\n      ]\n  max-measure)","user":"530bf87ee4b02e82168697d5"},{"code":"(fn [mine]\n  (let [n (count mine)\n        m (loop [x (apply max mine) b 0]\n            (if (zero? x) b (recur (bit-shift-right x 1) (inc b))))\n        in-range (fn [[x y]]\n                    (and (<= 0 x) (< x n) (<= 0 y) (< y m)))\n        cell (fn [[x y]]\n               (bit-test (mine x) y))\n        rotate-45 (fn [[x y]]\n                    (let [abs #(if (pos? %) % (- %))\n                          norm #(if (zero? %) % (quot % (abs %)))]\n                      (mapv norm [(+ y x) (- y x)])))\n        dirs (take 8 (iterate rotate-45 [-1 0]))\n        go-dir (fn [st d]\n                 (take-while #(and (in-range %) (cell %)) (iterate (partial mapv + d) st)))\n        filled (fn [st ed dir]\n                 (when (cell ed)\n                   (loop [c st len 1]\n                     (cond\n                       (= c ed) len\n                       (cell c) (recur (mapv + c dir) (inc len))))))]\n    (let [poss (for [x (range n) y (range m)\n                     :when (cell [x y])\n                     d1 dirs]\n                 (let [d2 (-> d1 rotate-45 rotate-45)\n                       d3 (rotate-45 d2)\n                       p1 (go-dir [x y] d1)\n                       p2 (go-dir [x y] d2)]\n                   (apply + (take-while identity (map #(filled %1 %2 d3) p1 p2)))))\n          mx (apply max poss)]\n      (when (>= mx 3) mx))))","problem":127,"user":"527cd633e4b0757a1b17136f"},{"problem":127,"code":"(fn max-tri-from-ints [s]\n  \n  (letfn [\n          (step [from dir]\n            (condp = dir\n              :left       (update-in from [1] dec)\n              :up-left    (update-in (update-in from [1] dec) [0] dec)\n              :up         (update-in from [0] dec)\n              :up-right   (update-in (update-in from [1] inc) [0] dec)\n              :right      (update-in from [1] inc)\n              :down-right (update-in (update-in from [1] inc) [0] inc)\n              :down       (update-in from [0] inc)\n              :down-left (update-in (update-in from [1] dec) [0] inc)))\n\n          (one? [t at]\n            (= (get-in t at) 1))\n\n          (build-terrain [s]\n            (letfn [(to-base-2 [num]\n                      (loop [rem-num num cur '()]\n                        (if (<= rem-num 0)\n                          cur\n                          (let [r (rem rem-num 2)]\n                            (if (= r 0)\n                              (recur (int (/ rem-num 2)) (conj cur 0))\n                              (recur (int (/ rem-num 2)) (conj cur 1)))))))\n\n                    (pad-0s [s num]\n                      (let [ct (count s)\n                            zs (repeat (- num ct) 0)]\n                        (into (apply list s) zs)))] \n\n              (let [b2s (map to-base-2 s)\n                    max-ct (apply max (map count b2s))\n                    padded (map #(pad-0s % max-ct) b2s)]\n                (vec (map vec padded)))))\n\n\n\n          (get-valid-starts [t]\n            (for [x (range (count (first t))) \n                  y (range (count t))\n                  :let [start [y x]]\n                  :when (= (get-in t start) 1)\n                  ]start))\n\n          (get-valid-directions [start terrain]\n            (let [dir-map {:left (update-in start [1] dec)\n                           :up-left (update-in (update-in start [0] dec) [1] dec)\n                           :up (update-in start [0] dec)\n                           :up-right (update-in (update-in start [0] dec) [1] inc)\n                           :right (update-in start [1] inc)\n                           :down-right (update-in (update-in start [0] inc) [1] inc)\n                           :down (update-in start [0] inc)\n                           :down-left (update-in (update-in start [0] inc) [1] dec)}]\n              (reduce-kv #(if (one? terrain %3) (assoc %1 %2 %3) %1 ) {} dir-map))\n            )\n\n\n\n          (get-sides-from-dir [t start dir]\n            (loop [cur-at (step start dir) res []]\n              (if (one? t cur-at)\n                (if (empty? res)\n                  (recur (step cur-at dir) (conj res [start cur-at])) \n                  (recur (step cur-at dir) (conj res (conj (vec (last res)) cur-at))))\n                res)))\n\n          (get-all-sides-from-point [t coord]\n            (let [\n                  valid-dirs (map first (get-valid-directions coord t))\n                  all-sides (map #(get-sides-from-dir t coord %) valid-dirs)\n                  ]\n              (reduce #(into %1 %2) #{} all-sides)\n              )\n            )\n\n          (get-all-sides-at-all-points [t]\n            (get-all-sides-from-point t [0 0])\n            (let [\n                  pre-mapped (map #(get-all-sides-from-point t %) (get-valid-starts t))\n                  all-sides  (reduce #(into %1 %2) pre-mapped)\n                  ]\n              all-sides\n              )\n            )\n\n\n\n          (get-dir [s]\n            (let [y-diff (compare (ffirst s) (first (last s)))\n                  x-diff (compare (second (last s)) (second (first s)))]\n              (cond \n                (and (zero? y-diff) (neg? x-diff)) :left\n                (and (pos? y-diff) (neg? x-diff))  :up-left\n                (and (pos? y-diff) (zero? x-diff)) :up\n                (and (pos? y-diff) (pos? x-diff))  :up-right\n                (and (zero? y-diff) (pos? x-diff)) :right\n                (and (neg? y-diff) (pos? x-diff))  :down-right\n                (and (neg? y-diff) (zero? x-diff)) :down\n                (and (neg? y-diff) (neg? x-diff))  :down-left)))\n\n          (count-type-1-tri [fir-side-ct]\n            (apply + (range (inc fir-side-ct))))\n\n          (count-type-2-tri [fir-side-ct]\n            (loop [cur-side-ct fir-side-ct res 0]\n              (if (= cur-side-ct 1)\n                (inc res)\n                (recur (dec cur-side-ct) (+ res cur-side-ct (dec cur-side-ct))))))\n\n          \n\n          (ray [terrain start dir]\n            (loop [cur-ray [start]]\n              (let [next-step (step (peek cur-ray) dir)\n                    new-ray (conj cur-ray next-step)] \n                (if (one? terrain next-step)\n                  (recur new-ray)\n                  cur-ray))))\n\n          (get-intersection [s1 s2]\n            (let [intersection (clojure.set/intersection (set s1) (set s2))]\n              (if (empty? intersection)\n                nil\n                (first intersection))))\n\n\n          (at [t coord]\n            (get-in t coord))\n\n          (check-line [t start dir stop-side]\n            (loop [cur-coord start]\n              (let [inter (get-intersection [cur-coord] stop-side)] \n                (if inter\n                  true\n                  (if (one? t cur-coord)\n                    (recur (step cur-coord dir))\n                    false)))))\n\n          (inside-all-minerals [t fir-side dir sec-side]\n            (every? true? (map #(check-line t % dir sec-side) fir-side)))\n\n          (get-triangle [t fir-side sec-thir-dir]\n            (let [sec-ray (ray t (peek fir-side) (first sec-thir-dir))\n                  third-side (take (count fir-side) (ray t (first fir-side) (second sec-thir-dir)))\n                  inter (get-intersection sec-ray third-side)\n                  all-minerals? (inside-all-minerals t fir-side (second sec-thir-dir) sec-ray)\n                  tri-count-style-from-start-dir {\n                                                  :left count-type-1-tri\n                                                  :up count-type-1-tri\n                                                  :right count-type-1-tri\n                                                  :down count-type-1-tri\n                                                  :up-left count-type-2-tri\n                                                  :up-right count-type-2-tri\n                                                  :down-right count-type-2-tri\n                                                  :down-left count-type-2-tri\n                                                  }\n                  tri-count-func (get tri-count-style-from-start-dir (get-dir fir-side))]\n              (if (and inter (= (count fir-side) (count third-side)))\n                (if all-minerals?\n                  {:points #{(first fir-side) (peek fir-side) inter}\n                   :ct (tri-count-func (count fir-side))}\n                  false)\n                false)))\n\n          (get-both-triangles [t fir-side]\n            (let [tri-from-first-dir {\n                                      :left #{[:down-right :down] \n                                              [:up-right :up]}\n                                      :up-left #{[:down :down-left] \n                                                 [:right :up-right]}\n                                      :up #{[:down-left :left]\n                                            [:down-right :right]}\n                                      :up-right #{[:left :up-left]  \n                                                  [:down :down-right]}\n                                      :right #{[:up-left  :up] \n                                               [:down-left :down]}\n                                      :down-right #{[:up :up-right] \n                                                    [:left :down-left]}\n                                      :down #{[:up-right :right] \n                                              [:up-left :left]}\n                                      :down-left #{[:right :down-right] \n                                                   [:up :up-left]}}\n                  tris (map #(get-triangle t fir-side %) (tri-from-first-dir (get-dir fir-side)))]\n              (remove false? tris))\n            )\n\n\n          (get-all-tris [t]\n            (let [sides (get-all-sides-at-all-points t)\n                  pre-tris (map #(get-both-triangles t %) sides)]\n              (flatten pre-tris))\n            )\n\n          (max-tri [t]\n            (let [grrr (map :ct (get-all-tris t))] \n              (if (empty? grrr)\n                nil \n                (apply max grrr))))\n\n          ]\n    (let [terrain (build-terrain s)]\n      (max-tri terrain)\n      ))\n  )","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn solve [bitmap]\n  (letfn [(right-angle [n x y]\n                       (for [i (range n)\n                             j (range (- n i))]\n                         [(+ i x) (+ j y)]))\n          (isoscele [n x y]\n                    (for [i (range n)\n                          j (range (min (inc i) (- n i)))]\n                      [(+ i x) (+ j y)]))\n          (right-angles [m n]\n                        (for [i (range 2 (inc (min m n)))\n                              x (range 0 (inc (- m i)))\n                              y (range 0 (inc (- n i)))]\n                          (right-angle i x y)))\n          (isosceles [m n]\n                     (for [i (range 3 (inc (min m (dec (* 2 n)))) 2)\n                           x (range 0 (inc (- m i)))\n                           y (range 0 (inc (- n (inc (quot i 2)))))]\n                       (isoscele i x y)))\n          (minerals? [area triangle]\n                     (every? (partial get-in area) triangle))\n          (bitmap->row [k n]\n                       (let [mem (transient (vec (repeat k false)))]\n                         (loop [pos (dec k) a n]\n                           (when (> a 0)\n                             (if (not= 0 (rem a 2))\n                               (assoc! mem pos true))\n                             (recur (dec pos) (quot a 2))))\n                         (persistent! mem)))\n          (bits [n]\n                (loop [a n b 0]\n                  (if (> a 0)\n                    (recur (quot a 2) (inc b))\n                    b)))\n          (bitmap->area [coll]\n                        (let [k (apply max (map bits coll))]\n                          (mapv (partial bitmap->row k) coll)))\n          (largest-triangle-mineral-area [area]\n                                         (let [m (count area)\n                                               n (count (first area))]\n                                           (->> (right-angles m n)\n                                                (concat (isosceles m n))\n                                                (filter (partial minerals? area))\n                                                (map count)\n                                                (apply max 0))))\n          (rotate-left [area]\n                       ((comp vec reverse) (apply mapv vector area)))\n          (area-rotations [area]\n                          (take 4 (iterate rotate-left area)))\n          (largest-triangle-mineral [bitmap]\n                                    (->> bitmap\n                                         bitmap->area\n                                         area-rotations\n                                         (map largest-triangle-mineral-area)\n                                         (apply max 0)))]\n    (let [m (largest-triangle-mineral bitmap)]\n      (if (zero? m)\n        nil\n        m))))","problem":127,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":127,"code":"(fn solve-problem [v]\n   (let [generate-grid (fn generate-grid [specs]\n                         (let [g (map #(Integer/toBinaryString %) specs)\n                               longest-row (apply max (map count g))\n                               g (map #(reduce str (concat (repeat (- longest-row (count %)) \"0\") %))  g)\n                               g (into {} (flatten (map-indexed (fn [i row]\n                                                                  (map-indexed #(hash-map [i %1] %2) row))  g)))]\n                           g))\n         deg->rad (fn deg->rad [d]\n                    (mod (* Math/PI (/ d 180)) (* 2 Math/PI)))\n         generate-points-between (fn  generate-points-between [[i1 j1] [i2 j2]]\n                                   (for [i (range (inc (- (max i1 i2) (min i1 i2))))\n                                         j (range (inc (- (max j1 j2) (min j1 j2))))]\n                                     [(+ (min i1 i2) i) (+ (min j1 j2) j)]))\n         generate-beam-pair-equilateral (fn [theta [i0 j0] grid]\n                                          (let [theta1 (if (= 0 (mod theta 180)) (deg->rad theta) (deg->rad (+ 45  theta)))\n                                                theta2 (if (= 0 (mod theta 180)) (deg->rad (+ 45 theta)) (deg->rad theta))\n                                                l2 #(* (Math/sqrt 2) %)]\n                                            (loop [l 1 area 1]\n                                              (let [c1 [(- i0 (Math/round (*  (Math/sin theta1) l))) (+ j0  (Math/round (* (Math/cos theta1) l)))]\n                                                    c2 [(- i0 (Math/round (* (Math/sin theta2) (l2 l)))) (+ j0 (Math/round (* (Math/cos theta2) (l2 l))))]\n                                                    ps (generate-points-between c1 c2)\n                                                    status (filter (fn [p]\n                                                                     (= \\1 (grid p)))  ps)]\n                                                (if (= (count ps) (count status))\n                                                  (recur (inc l) (+ area (count status)))\n                                                  area)))))\n         generate-beam-pair-isocele (fn [theta [i0 j0] grid]\n                                      (loop [l 2 area 1]\n                                        (let [theta1 (deg->rad (- theta 45))\n                                              theta2 (deg->rad (+ theta 45))\n                                              s1 (/ l (Math/sqrt 2))\n                                              c1 [(- i0 (Math/round (*  (Math/sin theta1) s1))) (+ j0  (Math/round (* (Math/cos theta1) s1)))]\n                                              c2 [(- i0 (Math/round (*  (Math/sin theta2) s1))) (+ j0  (Math/round (* (Math/cos theta2) s1)))]\n                                              ps (generate-points-between c1 c2)\n                                              status (filter (fn [p]\n                                                               (= \\1 (grid p)))  ps)]\n                                          (if (= (count ps) (count status))\n\n                                            (recur (+ l 2) (+ area (count status)))\n                                            area))))\n         generate-beam-around-point (fn generate-beam-around-point [p grid]\n                                      (apply max (concat (map #(generate-beam-pair-equilateral  % p grid) [0 135 180 315])\n                                                         (map #(generate-beam-pair-isocele  % p grid) [0 90 180 270]))))\n         g (generate-grid v)\n         m (apply max (->> g\n                           (map (fn [[p v]]\n                                  (if (= \\1 v)\n                                    (generate-beam-around-point p g)\n                                    0)))))] (if (= 1  m)\n                                              nil\n                                              m)))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn tra [coll]\n (let [ba (for [bs coll] (Integer/toString bs 2))\n       h (count ba) w (apply max (map #(count %) ba))\n       ba (map #(if (< (count %) w) (apply str (concat (take (- w (count %)) (repeat \\0)) %))  %) ba)\n       get-in #(if (or (< %1 0)(< %2 0)(>= %1 w)(>= %2 h) ) \\0 (nth (nth ba %2) %1))\n       ;b-map (apply hash-map (apply concat (for [y (range (count ba)) x (range (count (first ba)))] [[x y] (get-in x y)])))\n       ]\n    (let [find-tra (fn _ [[x y] mv fns n r]\n          (let [np (mv [x y])\n             n-line (apply concat [np] (for [f fns] (rest (take (inc n) (iterate f np))) ))\n             lv (for [p n-line] (apply get-in p))] \n           (if (every? #(= \\1 %) lv)\n            (_ np mv fns (inc n) (concat lv r))\n            r\n           )\n          )\n        )\n        down (fn[[x y]] [x (inc y)]) up (fn[[x y]] [x (dec y)])\n        left (fn[[x y]] [(dec x) y]) right (fn[[x y]] [(inc x) y])\n        left-down (fn[[x y]] [(dec x) (inc y)]) left-up (fn[[x y]] [(dec x) (dec y)])\n        right-down (fn[[x y]] [(inc x) (inc y)]) right-up (fn[[x y]] [(inc x) (dec y)])\n        find-all (fn [p] [(find-tra p right [left-down] 1 [\\1])\n                          (find-tra p right [left-up] 1 [\\1])\n                          (find-tra p left [right-up] 1 [\\1])\n                          (find-tra p left [right-down] 1 [\\1])\n                          (find-tra p up [left right] 1 [\\1])\n                          (find-tra p down [left right] 1 [\\1])\n                          (find-tra p left [up down] 1 [\\1])\n                          (find-tra p right [up down] 1 [\\1])\n                         ])\n        ] \n      (let [t-r (sort (filter #(> % 1) (map #(count %) (apply concat \n        (for [y (range h) x (range w) :when (= \\1 (get-in x y))]\n          (find-all [x y])\n        )\n      ))))] \n        (if (empty? t-r) nil (last t-r))\n      )   \n   )\n )\n)","problem":127,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn love-triangle [rock]\n  (let [height (count rock)\n        maxrock (apply max rock)\n        width (first (filter #(> (bit-shift-left 1 %) maxrock) (range 64)))\n        mineral? (fn [x y] (and (< -1 x width) (< -1 y height) (bit-test (nth rock y) x)))\n        thorz (fn [x y delta]\n          (loop [i 1]\n            (let [ofs (+ x (* i delta))]\n              (if (every? #(mineral? ofs %) (range (- y i) (+ y i 1)))\n                (recur (inc i))\n                (* i i)\n              ))))\n        tvert (fn [x y delta]\n          (loop [i 1]\n            (let [ofs (+ y (* i delta))]\n              (if (every? #(mineral? % ofs) (range (- x i) (+ x i 1)))\n                (recur (inc i))\n                (* i i)\n              ))))\n        tcorner (fn [x y xdelta ydelta]\n          (loop [i 1]\n            (let [triangle? (every? identity\n                    (for [xi (range (inc i))\n                          yi (range (inc i))\n                          :when (= i (+ xi yi))]\n                        (mineral? (+ x (* xi xdelta)) (+ y (* yi ydelta)))\n                      ))\n                ]\n              (if triangle?\n                (recur (inc i))\n                (quot (* i (inc i)) 2)\n              ))))\n        max-triangle (fn [[x y]]\n          (when (mineral? x y)\n            (let [mt (max\n                   (thorz x y 1)\n                   (thorz x y -1)\n                   (tvert x y 1)\n                   (tvert x y -1)\n                   (tcorner x y 1 1)\n                   (tcorner x y 1 -1)\n                   (tcorner x y -1 1)\n                   (tcorner x y -1 -1))\n                ]\n              (when (> mt 1)  mt)\n            )))\n        triangles (keep max-triangle (for [x (range width) y (range height)] [x y]))\n      ]\n    (and (seq triangles) (apply max triangles))\n  ))","problem":127,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn [coll]\r\n  (let [deltas [[0 1] [1 1] [1 2]]\r\n        mine\r\n        (fn [ore]\r\n          (loop [sides [1 1 1] prev {} best 0 [row & rows] ore]\r\n            (let [curr (apply hash-map (apply concat\r\n                                         (apply concat\r\n                                           (for [t (range 3)\r\n                                                 n (range 1 (inc (sides t)) (second (deltas t)))\r\n                                                 :let [[di dn] (deltas t)]]\r\n                                             (map-indexed (fn [i x]\r\n                                                            (when (every? #(= \\1 %) x)\r\n                                                              (if (= 1 n)\r\n                                                                [[t i n] 1]\r\n                                                                (when-let [p (prev [t (+ i di) (- n dn)])]\r\n                                                                  [[t i n] (+ n p)]))))\r\n                                               (partition n 1 row))))))\r\n                  best (if (empty? curr) best (max best (apply max (vals curr))))]\r\n              (if (empty? rows)\r\n                best\r\n                (recur (vec (map (fn [s [_ d]] (+ s d)) sides deltas)) curr best rows)))))\r\n        flip (fn [s] (partition (count s) (apply interleave s)))\r\n        ore (map #(Integer/toBinaryString %) coll)\r\n        size (apply max (map count ore))\r\n        ore (map #(concat (repeat (- size (count %)) \\0) %) ore)\r\n        best (max (mine ore) (mine (flip ore)) (mine (reverse ore)) (mine (reverse (flip ore))))]\r\n    (if (<= best 1) nil best)))","problem":127,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn [rows]\n  (let [binaries (map #(loop [in % out ()] (if (= 0 in) out (recur (quot in 2) (cons (mod in 2) out)))) rows)\n        height (count rows)\n        width  (apply max (map count binaries))\n        align  (fn [lines width] (map #(concat (repeat (- width (count %)) 0) %) lines ))\n        rock (align binaries width)\n        rock-parts (fn [width height]\n                     (mapcat (fn [vert-part] (apply map vector (map (partial partition width 1) vert-part))) (partition height 1 rock)))\n        flip (partial map reverse)\n        rotate (fn [rows] (flip (map #(map nth rows (repeat %)) (range (count (first rows))))))\n        triangle-value #(reduce + (flatten %))\n        triangles\n        (sort-by (comp - triangle-value) (mapcat (fn [width]\n                   (let [half (inc (quot width 2))\n                         bases [(align (map #(repeat % 1) (range width 0 -1)) width)]\n                         bases (if (odd? width)\n                                 (conj bases (align\n                                              (map #(repeat % 1)\n                                                   (concat (range 1 half)\n                                                           (range half 0 -1)))\n                                              half))\n                                 bases)]\n                     (mapcat (juxt identity\n                                   rotate\n                                   (comp rotate rotate)\n                                   (comp rotate rotate rotate))\n                             bases)))\n                 (range (max width height) 1 -1)))\n        binary-triangles (map #(for [line %] (reduce + (map * (iterate (partial * 2) 1) (reverse line)))) triangles)]\n    (some (fn [triangle]\n            (if (some (fn [rock-part]\n                        (every? identity (map #(= % (map bit-and % %2)) triangle rock-part)))\n                      (rock-parts (count (first triangle)) (count triangle)))\n              (triangle-value triangle)))\n          triangles)))","problem":127,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(let [int-to-bits (fn [i] (Integer/toString i 2))\r\n      zero-pad (fn [w i] (str (apply str (repeat (- w (count i)) 0)) i))\r\n      bit-extend-left (fn [n i] (+ 1 (bit-shift-left n i)))\r\n      next-row (fn [ns] (bit-extend-left (apply max ns) 1))\r\n      shift-all-left (fn [ns i] (map #(bit-shift-left % i) ns))\r\n      extend-all-left (fn [ns i] (map #(bit-extend-left % i) ns))\r\n      number-of-set-bits (fn [ns] (reduce + (map #(count (filter #{\\1} (int-to-bits %))) ns)))\r\n\r\n      triangles {[1 3] #(concat % [(next-row %)])\r\n                 [3 1] #(concat [(next-row %)] %)\r\n                 [2 3] #(concat (shift-all-left % 1) [(next-row %)])\r\n                 [3 2] #(concat [(next-row %)] (shift-all-left % 1))\r\n                 [2 7] #(concat (shift-all-left % 2) [(next-row [(next-row %)])])\r\n                 [7 2] #(concat [(next-row [(next-row %)])] (shift-all-left % 2))\r\n                 [1 3 1] #(concat [1] (extend-all-left % 1) [1])\r\n                 [2 3 2] #(let [nr (+ 1 (apply max %))] (concat [nr] (extend-all-left % 1) [nr]))}\r\n\r\n      width (fn [ns] (count (int-to-bits (apply max ns))))\r\n      height (fn [ns] (count ns))\r\n\r\n      at-all-positions (fn [w h t]\r\n        (for [x (range (- w (width t) -1))\r\n              y (range (- h (height t) -1))]\r\n          (concat (repeat y 0) (shift-all-left t x))))\r\n\r\n      matches? (fn [b t] (every? identity (map #(= %2 (bit-and %1 %2)) b t)))\r\n\r\n      any-pos-matches? (fn [b t] (some #(matches? b %) (at-all-positions (width b) (height b) t)))\r\n\r\n      all-size-matches (fn [b t grow-func]\r\n        (let [bw (width b)\r\n              bh (height b)]\r\n          (filter identity\r\n                  (map #(if (any-pos-matches? b %) % nil)\r\n                       (take-while #(and (>= bw (width %)) (>= bh (height %))) (iterate grow-func t))))))\r\n\r\n      safe-apply-max (fn [ns] (if (< 0 (count ns)) (apply max ns)))\r\n      biggest-match (fn [b t grow-func] (safe-apply-max (map number-of-set-bits (all-size-matches b t grow-func))))\r\n      biggest-triangle (fn [b] (safe-apply-max (filter identity (map #(biggest-match b (key %) (val %)) triangles))))]\r\n  biggest-triangle)","problem":127,"user":"4f1b92d1535d64f60314647b"},{"problem":127,"code":"(fn [c]\n  (let [chkbit (fn [t n] (if (and (pos? t) (> (apply * (repeat t 2)) n)) t (recur (inc t) n)))\n        bitlen (apply max (map #(chkbit 0 %) c))\n        mtx (map (fn [n] (reverse (for [x (range bitlen)] (bit-test n x)))) c)\n        trngle (fn [m n d] \n                     (if (= n (- bitlen 2)) (vals m)\n                         (recur (assoc m (inc n) (reduce into #{} (for [x d] (map #(vec (map + x %)) (m n))))) (inc n) d)))\n        ld #{[0 0] [1 0] [0 1]} lu #{[0 0] [-1 0] [0 1]} rd #{[0 0] [1 0] [0 -1]} ru #{[0 0] [-1 0] [0 -1]} \n        ud #{[0 0] [1 0] [1 -1] [1 1]} du #{[0 0] [-1 0] [-1 -1] [-1 1]}\n        lr #{[0 0] [0 1] [-1 1] [1 1]} rl #{[0 0] [0 -1] [1 -1] [-1 -1]}\n        pos (fn [[x y]] (if (and (> bitlen y) (> (count c) x) (>= x 0) (>= y 0)) (nth (nth mtx x) y) nil))\n        result (flatten (for [row (range 1 (count c)) col (range 1 bitlen)]\n                          (map count (filter #(every? true? %)\n                                             (for [x (flatten [(trngle {0 ld} 0 ld) (trngle {0 lu} 0 lu) (trngle {0 rd} 0 rd) (trngle {0 ru} 0 ru)\n                                                               (trngle {0 du} 0 du) (trngle {0 lr} 0 lr)])]\n                                               (map #(pos (map + [row col] %)) x))))))]\n    (if (empty? result) nil (apply max result))))","user":"574abbfbe4b02ea114799200"},{"problem":127,"code":"(fn lt [b]\n  (let [z (apply max 0\n                 (for [b [b (vec (reverse b))]\n                       y (range (count b))\n                       x (range (inc (/ (Math/log (get b y 0)) (Math/log 2))))\n                       [i a m] [[-1 0 0] [-1 0 1] [-1 1 0] [0 1 0] [0 1 1]]\n                       :let [s (loop [m m\n                                      d [i a]\n                                      [l h :as r] [x x]\n                                      s 0 \n                                      [w & e :as b] (drop y b)] \n                                 (cond\n                                   (and w (>= l 0) (every? #(bit-test w %) (range l (inc h)))) \n                                   (recur m d (map + d r) (+ s 1 (- h l)) e)\n                                   (< h l) s\n                                   (= 0 m) s\n                                   (= 1 m) (recur 2 (map - d) (map - r d d) s b)))]\n                       :when s]\n                   s))]\n    (when (> z 1) z)))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn n127 [mine]\n  (letfn [(count-bit [x] \n                     (loop [r 1 v x] (if (< v 2) r (recur (inc r) (quot v 2)))))\n          (get-vector [x column]\n                      (loop [r [] v x c column]\n                        (if (and (= v 0) (= c 0)) \n                          r \n                          (recur (cons (rem v 2) r) (quot v 2) (dec c)))))\n          (get-matrix [column]\n                      (map #(get-vector % column) mine))\n          (mat2mine [matrix-mine]\n                    (map (fn [x] (apply + \n                                        (map-indexed #(* (int (java.lang.Math/pow 2 %1)) %2) \n                                                     (reverse x))))\n                               matrix-mine))\n          (reverse-column [matrix-mine]\n                          (map (fn [x] (apply + \n                                              (map-indexed #(* (int (java.lang.Math/pow 2 %1)) %2) \n                                                           x)))\n                               matrix-mine))\n          (rotate [matrix-mine]\n                  (apply map vector matrix-mine))\n          (match-row [x r]\n                     (= (bit-xor x r) (- r x)))\n          (match-all [tri mine]\n                     (apply = true (map match-row tri mine)))\n          (move [r coll] \n                  (into (vec (repeat r 0)) (take (- (count coll) r) coll)))\n          (truncate [r coll]\n                    (into (vec (take (- (count coll) r) coll)) (vec (repeat r 0))))\n          (truncate-big [big-tri n]\n                        (loop [k n t big-tri]\n                          (if (zero? k) t (recur (dec k) (map #(if (odd? %) 0 (/ % 2)) t)))))\n          (gen-tri [tri max-num [x y]]\n                    (map #(if (>= % max-num) 0 %) (move x (map #(* (int (java.lang.Math/pow 2 y)) %) tri))))\n          (gen-tris [tri row column max-num max-length]\n                    (for [m (range max-length 1 -1)\n                          x (range (inc (- row m)))\n                          y (range (inc (- column m)))\n                          :let [trunc (- row m)\n                                area (/ (* m (inc m)) 2)\n                                new-tri (gen-tri (truncate trunc tri) max-num [x y])]\n                          :when (< 1 (count (filter (complement zero?) new-tri)))]\n                      [new-tri area]\n                      ))\n          (match-tris [tris mine]\n                      (first (filter #(match-all (first %) mine) tris)))\n          (init-big-tri [levels row]\n                       (loop [l levels r row a []]\n                         (if (zero? r) a\n                           (if (zero? l) (recur l (dec r) (conj a 0))\n                             (recur (dec l) (dec r) \n                                    (conj (vec (map #(* 2 %) a)) \n                                          (int (dec (java.lang.Math/pow 2 (dec (* 2 (- levels l -1))))))))))))\n          (gen-big-tris [big-tri row column max-num levels]\n                        (for [l (range levels 1 -1)\n                              x (range (inc (- row l)))\n                              y (range (inc (- column (dec (* 2 l)))))\n                              :let [trunc (- levels l)\n                                    area (* l l)\n                                    new-tri (gen-tri (truncate-big big-tri trunc) max-num [x y])]\n                              :when (< 1 (count (filter (complement zero?) new-tri)))\n                              ]\n                          [new-tri area]))\n          (find-area [[gen tri r c max-num levels mine]]\n                     (second (match-tris (gen tri r c max-num levels) mine)))\n          ]\n    (let [row (count mine)\n          column (apply max (map count-bit mine))\n          larger (if (< row column) :column :row)\n          max-length (min row column)\n          max-num (int (java.lang.Math/pow 2 max-length))\n          \n          row-q (quot (inc row) 2)\n          column-q (quot (inc column) 2)\n          levels (min row column-q)\n          levels-rotated (min row-q column)\n          \n          big-tri (init-big-tri levels row)\n          big-tri-rotated (init-big-tri levels-rotated column)\n          \n          matrix-mine (get-matrix column)\n          \n          upside-down-mine (reverse mine)\n          \n          mirror-mine (reverse-column matrix-mine)\n          mirror-usd-mine (reverse mirror-mine)\n          \n          left-up-tri (map #(int (dec (java.lang.Math/pow 2 (inc %)))) (range max-length))\n          tri-in-use (if (= larger :row) (into (vec left-up-tri) (repeat (- row column) 0)) left-up-tri)\n          \n          rotated-mine (mat2mine (rotate matrix-mine))\n          rotated-usd-mine (reverse rotated-mine)\n          \n          tri1 [gen-tris tri-in-use row column max-num max-length mine]\n          tri2 [gen-tris tri-in-use row column max-num max-length mirror-mine]\n          tri3 [gen-tris tri-in-use row column max-num max-length upside-down-mine]\n          tri4 [gen-tris tri-in-use row column max-num max-length mirror-usd-mine]\n          bigtri1 [gen-big-tris big-tri row column (int (java.lang.Math/pow 2 column)) levels mine]\n          bigtri2 [gen-big-tris big-tri row column (int (java.lang.Math/pow 2 column)) levels upside-down-mine]\n          bigtri3 [gen-big-tris big-tri-rotated column row (int (java.lang.Math/pow 2 row)) levels-rotated rotated-mine]\n          bigtri4 [gen-big-tris big-tri-rotated column row (int (java.lang.Math/pow 2 row)) levels-rotated rotated-usd-mine]\n          \n          tri-vec [tri1 tri2 tri3 tri4 bigtri1 bigtri2 bigtri3 bigtri4]\n          answers (map find-area tri-vec)\n          ]\n      (if (every? nil? answers) nil (apply max (filter (complement nil?) answers)))\n    )))","problem":127,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn [c]\n  (let [to-bin #(Integer/toString % 2)\n        max-width (count (to-bin (apply max c)))\n        max-height (count c)\n        max-side (max max-width max-height)\n        ; an infinite triangle to sample from\n        corner-triangle (take 100 (rest (map #(repeat % 1) (range))))\n        ; makes a right and isosceles triangle whose largest side is max-side\n        make-triangle (fn [max-side]\n                        (remove nil?\n                                (list\n                                 (take max-side corner-triangle)\n                                 (if (ratio? (/ max-side 2))\n                                   (apply concat ((juxt identity (comp rest reverse)) (take (inc (quot max-side 2)) corner-triangle)))))))\n        ; a list of triangles with edges smaller than max-size, sorted by the number of 1s they have (largest first)\n        triangles (reverse (sort-by (comp count flatten)\n                                    (mapcat make-triangle (drop 2 (range (inc max-side))))))\n        ; add padded zeros so rotating is easier\n        padded (map (fn [t] (let [w (apply max (map count t))]\n                              (map #(take w (concat % (repeat 0))) t))) triangles)\n        ; rotates a triangle by 90 degrees\n        rotate #(apply map (comp reverse list) %)\n        ; insert rotated versions of all triangles. This should be all the potential winning triangles in order from best to worst\n        permutated (mapcat #(take 4 (iterate rotate %)) padded)\n        ; convert to numbers and shift left until we reach our max number of bits\n        shift (fn [t n] (map #(bit-shift-left % n) t))\n        all-shifts (fn [t] (for [n (range (inc (- max-width (count (first t)))))\n                                 row (range (inc (- max-height (count t))))\n                                 :let [nums (map #(Integer/parseInt (apply str %) 2) t)]]\n                             (concat (repeat row 0) (shift nums n))))\n        shifted (mapcat all-shifts permutated)\n        found? (fn [rock search] (= search (map bit-and rock search)))\n        ; only keep harvestable triangles\n        harvestable (filter #(found? c %) shifted)\n        area (map #(count (filter #{\\1} (mapcat to-bin %))) harvestable)]\n    (first area)))","problem":127,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":127,"code":"(fn [s]\n  (let [w (count (Integer/toString (apply max s) 2))\n        p (int (Math/pow 2 w))\n        b (vec (map #(subs (Integer/toString (+ p %) 2) 1) s))]\n  (letfn [(p1 [b x y n]\n                (if (or (< (count b) (inc y)) (< (count (b y)) (+ 1 x n)) (contains? (set (subs (b y) x (+ 1 x n))) \\0))\n                  (if (< n 2) 0 n)\n                  (recur b x (inc y) (inc n))))\n          (p2 [b x y n]\n                (if (or (< (count b) (inc y)) (< (- x n) 0) (contains? (set (subs (b y) (- x n) (inc x))) \\0))\n                  (if (< n 2) 0 n)\n                  (recur b x (inc y) (inc n))))\n          (r [b] (vec (for [x (range (count (b 0)))] (reduce str (reverse (map #(subs % x (inc x)) b))))))]           \n  (loop [b b i 0 m 0]\n  (if (= i 4)\n   (if (> m 0) m nil)\n   (recur (r b) (inc i) (max m (reduce max \n           (for [y (range (count b)) x (range (count (b 0)))\n                  :let [q1 (p1 b x y 0) q2 (p2 b x y 0) n (max q1 q2)]] \n                       (if (= q1 q2 ) (* q1 q1) (quot (+ (* n n) n) 2) ))))))))))","user":"56bca51ae4b0f26550335963"},{"code":"(fn [x]\n  (let\n    [trigCnt (fn  [[a b] m]\n               (let\n                 [r (count m) c (count (first m))\n                  rt (for [i (range (min (- r a) (- c b)))] (take (inc i) (drop b (nth m (+ a i)))))\n                  lt (for [i (range (min (inc b) (- r a)))] (take (inc i) (drop (- b i) (nth m (+ a i)))))\n                  ct (for [i (range (min (inc b) (- r a) (- c b)))] (take (inc (* 2 i)) (drop (- b i) (nth m (+ a i)))))\n                  all-1? (fn [x] (every? #(= 1 %) x))\n                  sz (fn [x] (->> (take-while all-1? x) flatten (apply +)))]\n                 (apply max (map sz [rt lt ct]))))\n\n\n     trig (fn  [x]\n            (let [to-bin (fn [n] (map (comp read-string str) (Integer/toString n 2)))\n                  d (map to-bin x)\n                  m (apply max (map count d))]\n              (map #(concat (repeat (- m (count %)) 0) %) d)\n              )\n            )\n\n     m (trig x)\n     tc (fn [m] (->> (for [i (range (count m)) j (range (count (first m)))] (trigCnt [i j] m))\n                  flatten (apply max)))\n     c (max (tc m) (tc (reverse m)) (tc (apply (partial map list) m)))]\n    (if (= c 1) nil c)))","problem":127,"user":"528e64b7e4b0239c8a67aedd"},{"code":"(let [\nsq-tri (fn sq-tri [n]\n  (if (= n 1)\n    [[0 0]]\n    (concat\n      (map (fn [a] [a 0]) (range n))\n      (map (fn [[a b]] [a (inc b)]) (sq-tri (dec n))))))\n\nhyp-tri (fn hyp-tri [n]\n  (if (= n 1) \n    [[0 0]]\n    (concat\n      (map (fn [a] [a 0]) (range (dec (* 2 n))))\n      (map (fn [[a b]] [(inc a) (inc b)]) (hyp-tri (dec n))))))\n\nrot (fn [tri]\n  (let [rt (map (fn [[a b]] [(- b) a]) tri)\n        na (apply min (map first rt))\n        nb (apply min (map second rt))]\n    (map (fn [[a b]] [(- a na) (- b nb)]) rt))) \n\nexp-tri (fn [tri]\n  (take 4 (iterate rot tri)))\n\ninput-to-board (fn [input]\n  (let [m (apply max input)\n        mlen (count (Integer/toBinaryString m))\n        pad #(vec (concat (repeat (- mlen (count %)) \\0) %))]\n    (vec (map #(pad (Integer/toBinaryString %)) input))))\n\ncontained (fn [board tri]\n  (let [ca (count board)\n        cb (count (first board))\n        positions (for [a (range ca) b (range cb)] [a b])\n        move-tri (fn [[da db]] (map (fn [[a b]] [(+ a da) (+ b db)]) tri))\n        possible-tris (map move-tri positions)\n        check-tri (fn [test-tri] (if (every? #(= \\1 %) (map #(get-in board %) test-tri)) (count test-tri) nil))]\n    (some check-tri possible-tris)))\n] \n  \n(fn [input]\n  (let [board (input-to-board input)\n        ca (count board)\n        cb (count (first board))\n        size (* ca cb)\n        sqs (take-while #(< (count %) size) (mapcat #(exp-tri (sq-tri %)) (iterate inc 2)))\n        hyps (take-while #(< (count %) size) (mapcat #(exp-tri (hyp-tri %)) (iterate inc 2)))\n        both (sort-by #(- (count %)) (concat sqs hyps))]\n    (some #(contained board %) both))))","problem":127,"user":"4ec07699535dfed6da9c6da2"},{"problem":127,"code":"(fn [q c n]\n  (#({0 nil} % %)\n   (apply max\n     (for [\n           ; rotate\n           m (take 4 (iterate q (map #(subs (Long/toBinaryString (+ 64 %)) 1) n)))\n           ; slice horizontal\n           h (map drop (range) (repeat (- (count m) 1) m))\n           ; slice vertical\n           v (map #(map (fn [r] (subs r %)) %2) (range) (repeat (count (nfirst h)) h))\n           ]\n       (c v)))))\n\n;; rotate 90 degrees\n#(reverse (apply map str %))\n\n;; cut out a triangle and count minerals\n(fn [m]\n  (let [w (count (take-while #{\\1} (first m)))\n        h (count m)]\n    (cond (< w 2) 0\n          (and (>= h w) (apply = \\1 (mapcat #(subs % 0 %2) m (range w 0 -1))))\n          ; 111\n          ; 110\n          ; 100\n            (* 1/2 w (+ w 1))\n          (and (odd? w) (> h (/ w 2))\n               (apply = \\1 (mapcat #(subs % %2 (- w %2)) m (range (/ w 2)))))\n          ; 111\n          ; 010\n          ; 000\n            (/ (+ (* w w) w w 1) 4)\n          :else 0)))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn triangle [coll]\n  (let [to-bit (fn [n] (->> (iterate (fn [[n _]] [(quot n 2) (mod n 2)]) [n 0])\n                            (take-while #(> (apply + %) 0)) (drop 1) (map second) reverse))\n        pad #(vec (concat (repeat (- (count coll) (count %)) 0) %))\n        bit-vec (mapv (comp pad to-bit) coll)\n        hmap (apply merge-with into (for [[x row] (map-indexed vector bit-vec)\n                                          [y val] (map-indexed vector row)]\n                                      {val #{[x y]}}))\n        rules [#{[0 1] [1 0]} #{[0 1] [-1 0]} #{[0 -1] [1 0]} #{[0 -1] [-1 0]} #{[0 1] [0 -1] [1 0]}\n               #{[0 1] [0 -1] [-1 0]} #{[0 1] [1 0] [-1 0]} #{[0 -1] [1 0] [-1 0]}]\n        obeys? (fn [x rule] (let [xs (set (map (partial mapv + x) rule))]\n                              (when (= (count xs) (count (filter xs (hmap 1)))) (conj xs x))))\n        best (fn [coll rule]\n               (let [all (map #(obeys? % rule) coll)]\n                 (if (not-any? nil? all) (recur (apply clojure.set/union all) rule) coll)))\n        res (->> (for [x (hmap 1), r rules] [(set [x]) r])\n                 (map (comp count (partial apply best))) (apply max))]\n    (when (> res 2) res)))","problem":127,"user":"50645e12e4b007509339a58a"},{"code":"(fn largest-harvestable-mineral[bit-representations-of-the-rock] (let [\n\nints->binary-lists (fn [coll]\n  (let [unpadded (map #(Integer/toString % 2) coll)\n        max-length (apply max (map count unpadded))\n        padding (repeat \\0)\n        pad (fn [s]\n              (let [diff (max 0 (- max-length (count s)))\n                    prefix (take diff padding)]\n                (concat prefix s)))]\n    (map pad unpadded)))\n\nbinary-lists->2d-vector (fn [list]\n  (apply vector (map (partial apply vector) list)))\n\ngrid-to-coordinates (fn [grid]\n  (into #{}\n    (let [width (count grid)\n          height (count (first grid))]\n      (for [x (range width)\n            y (range height)\n            :when (= \\1 (get-in grid [x y]))]\n        [x y]))))\n\nall-mineral-coordinates\n  (->>\n    bit-representations-of-the-rock\n    ints->binary-lists\n    binary-lists->2d-vector\n    grid-to-coordinates)\n\nnew-coords (fn [coord dirs]\n  (map #(map + coord %) dirs))\n\nfind-triangle (fn [coords dirs]\n  (loop [coords coords]\n    (let [updated (clojure.set/union \n                    coords \n                    (set (apply concat (map #(new-coords % dirs) coords))))]\n      (if (empty? (clojure.set/difference updated all-mineral-coordinates))\n        (recur updated)\n        coords))))\n\nall-dirs [[[ 1  0][ 0  1]]\n          [[-1  0][ 0  1]]\n          [[ 1  0][ 0 -1]]\n          [[-1  0][ 0 -1]]\n          [[ 1  0][ 1 -1][ 1  1]]\n          [[-1  0][-1 -1][-1  1]]\n          [[ 0  1][ 1  1][-1  1]]\n          [[ 0 -1][ 1 -1][-1 -1]]]\n\nfind-triangles (fn []\n  (for [c all-mineral-coordinates\n        d all-dirs]\n    (find-triangle #{c} d)))\n\nsorted-triangles (sort-by count (find-triangles))\n\nmax-size (if (empty? sorted-triangles) 0 (count (last sorted-triangles)))]\n\n(if (> max-size 1) max-size nil)))","problem":127,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [B R C x] (let [tb #(for [i (R 6)]\n                     (apply + (for [[n j] (map list % (R)) :when (B n i)]\n                               (bit-shift-left 1 j))))\n               ls #(map (fn [n] (drop n %)) (R (C %)))\n                 (fn [n s r]\n                    (let [v (for [i (R n) j (R (- n i))]\n                              (B (nth r i 0) j)) ]\n                      (if (and (seq v) (every? boolean v)) [(+ s (C v))])))\n                 (fn  [n s [l & r]]\n                    (if (and l (every? #(B l %) (R n)))\n                      (let [ns (+ n s)]\n                        #_(prn n s l r ns)\n                        (lazy-cat [ns]\n                                  ( (+ n 1) ns r)\n                                  ( (- n 1) ns r) ))))\n              ]\n           (#({0 nil} % %)\n            (reduce max 0\n                       (for [a [x (vec (reverse x))] b [a (tb a)] c (ls b) d (R 6)\n                             :let [e (map #(bit-shift-right % d) c)] f ( 1 0 e)\n                             :when (> f 2)]\n                         f)))))\n  bit-test range count","problem":127,"user":"4ff67852e4b0678c553fc37e"},{"code":";; This is a fairly brute-force approach:\n\n;; Convert input into 2-d array of 0s and 1s\n\n;; For each 1 bit in the array, consider it as the vertex of an\n;; isosceles triangle.\n\n;; There are 8 possible \"directions\" for the isosceles triangle to\n;; extend, up, down, left, right, and the 4 diagonal directions.  For\n;; each of these 8 directions, keep extending the size of the\n;; isosceles triangle in that direction as long as it contains all 1s\n;; and stays within the confines of the grid.  Return its size.\n\n(fn [c]\n  (let [bin #(loop [x % bits '()]\n               (if (zero? x)\n                 bits\n                 (recur (quot x 2) (conj bits (mod x 2)))))\n        rock (map bin c)\n        h (count c)\n        w (apply max (map count rock))\n        rock (vec (map (fn [row]\n                         (vec (concat (repeat (- w (count row)) 0)\n                                      row)))\n                       rock))\n        mineral? (fn [[r c]]\n                   (and (< -1 r h) (< -1 c w)\n                        (= 1 (get-in rock [r c]))))\n        rot-135-deg-cw {[ 0  1] [ 1 -1],   ;; right -> down-left\n                        [ 1  1] [ 0 -1],   ;; down-right -> left\n                        [ 1  0] [-1 -1],   ;; down -> up-left\n                        [ 1 -1] [-1  0],   ;; etc.\n                        [ 0 -1] [-1  1],\n                        [-1 -1] [ 0  1],\n                        [-1  0] [ 1  1],\n                        [-1  1] [ 1  0]}\n        vadd (fn [[r1 c1] [r2 c2]] [(+ r1 r2) (+ c1 c2)])\n        positions-in-dir (fn [pos dir]\n                           (iterate #(vadd % dir) pos))\n        biggest-mineral-at\n        (fn [vertex dir]\n          (let [rot-dir (rot-135-deg-cw dir)\n                diag? (not-any? zero? rot-dir)\n                mineral-row-lens\n                (map-indexed (fn [idx pos]\n                               (let [row-len (inc (if diag? idx (* 2 idx)))\n                                     row-posns (take row-len\n                                                     (positions-in-dir pos rot-dir))]\n                                 (if (every? mineral? row-posns)\n                                   row-len 0)))\n                             (positions-in-dir vertex dir))]\n            (reduce + 0 (take-while (complement zero?) mineral-row-lens))))\n        biggest (apply max\n                       (for [r (range h)\n                             c (range w)\n                             triangle-edge-dir (keys rot-135-deg-cw)]\n                         (biggest-mineral-at [r c] triangle-edge-dir)))]\n    (if (>= biggest 3)\n      biggest)))","problem":127,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":127,"code":"(fn [xs]\n  (letfn\n    [(bits [x]  (if (= 0 x) [] (cons (mod x 2) (bits (quot x 2)))))\n     (trx  [rs] (apply map vector rs))\n     (cw   [rs] (trx (reverse rs)))\n     (flp  [rs] (map reverse rs))\n     (triR [rs]\n           (let [add (fn add [[x1 & [x2 :as xs]] [y & ys]]\n                       (if (nil? y) []\n                         (let [x' (* y (inc (min x1 (or x2 0))))]\n                           (into [x'] (add xs ys)))))]\n             (drop 1 (reductions add (repeat 0) rs))))\n     (triL [rs] (-> rs flp triR flp))\n     (=> [x & fs] (reduce #(%2 %1) x fs))\n     (calc [rs]\n           (let [tr (triR rs)\n                 tl (triL rs)\n                 tz (mapcat #(map list %1 %2) tl tr)]\n             (apply max\n                    (for [[l r] tz\n                          :let [a (=> (max l r) #(* % (inc %)) #(quot % 2))\n                                b (=> (min l r) #(* % %))]]\n                      (max a b)))))\n     ]\n    (let [w (count (bits (apply max xs)))\n          rs (map #(take w (concat (bits %) (repeat 0))) xs)\n          res (apply max\n                     (for [t [identity trx]\n                           r (reductions comp (repeat 4 cw))]\n                       (calc (r (t rs)))))]\n      (if (< 1 res) res))))","user":"553e0b70e4b0a04f792994e8"},{"problem":127,"code":"(fn tri [nums]\n  (letfn  [ \n    ; bit positions of on bits in a number n\n    (onbits [n] (loop [n n, i 0, bits []]\n            (if (zero? n) bits\n                (recur (quot n 2) (inc i) (if (odd? n) (conj bits i) bits)))))\n                        \n    ; add row number to the bit number\n    (row [[r n]] (map #(vector r %) (onbits n)))\n            \n    ; convert input of numbers into a set of \"on\" pixel coords [y x]\n    (inbits [nums] (set (mapcat row (map-indexed vector nums))))\n    \n    ; given a coll of [y x] pairs, find their min and max\n    (minmax [vs]\n        (let [ys (map first  vs)\n            xs (map second vs) ]\n            {:xmin (apply min xs)  :ymin (apply min ys)\n            :xmax (apply max xs)  :ymax (apply max ys) } ))\n        \n    ; canonical form of xy aligned right triangle\n    (rtri [s] (into #{} (for [x (range s) y (range s) :when (>= x y)] [y x])))\n    \n    ; these work on a matrix represented as map\n    (flip-y [t] (let [ym (:ymax (minmax t)) ]\n            (set (map (fn [[y x]] [(- ym y) x]) t))))\n           \n    (transpose [t] (set (map (fn [[y x]] [x y]) t)))\n        \n    ; A 2n+1 base wide triangle, sides sloping up to meet at right angles.\n    ; to make a pyramidal right angle triangle\n    (pyramid [s]\n        (if (even? s) #{}\n            (let [h (quot s 2)]\n                (set (for [ y (range (+ 2 h))\n                            x (range y (- s y)) ] [y x])))))\n        \n    ; the 4 rotations of a triangle\n    (rotations [t]\n        ;(println \"rotations\" t)\n        (let [tt (transpose t)]\n            (if (empty? tt) [] \n                [t tt (flip-y t) (flip-y tt)]) ))\n\n\n    ; the offsets where you could place these triangles to look for a match\n    (offsets [inp tri] \n        ;(println \"offsets\" tri)\n        (let [mm (minmax inp) tt (minmax tri)]\n            (let [of (for [y (range (:ymax mm))\n                           x (range (:xmax mm))\n                           :when (<= (+ y (:ymax tt)) (:ymax mm))\n                           :when (<= (+ x (:xmax tt)) (:xmax mm)) ]\n                               [y x]) ]\n                ;(println \"offsets\" of)\n                of)))\n\n    ; match pixels in a triangle q at a new location to see if it's a subset of input in\n    (match [in sq [y x]]\n        ;(println \"match\" sq [y x])\n        (let [tt (into #{} (map (fn [[a b]] [(+ a y) (+ b x)]) sq))]\n            (if (clojure.set/superset? in tt) (count tt) 0)))\n\n    ; for every possible size of square (or rectangle), for every orientation\n    ; for every offset, find the best match\n    (search [inp]\n        (let [mm (minmax inp)\n              s  (inc (max (:xmax mm) (:ymax mm)))\n             ]\n            ;(println \"search\" inp)\n            ;(println mm s)\n            (let [v (for [ss (range s 1 -1)\n                          rs (concat (rotations (pyramid ss)) (rotations (rtri ss)))\n                          of (offsets inp rs) ]\n                        (match inp rs of))]\n                (apply max v))\n             ))\n\n    ]\n\n    (println nums)\n    (let [inp  (inbits nums)\n          best (search inp)]\n        (if (< best 3) nil best))\n    ))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn mine [rocks]\n\t(let [lengthen-row (fn [row max-size]\n          (let [row   (map #(if (= \\1 %) 1 0) row)\n                width (count row)]\n            (if (< width max-size) \n                (into [] (concat (repeat (- max-size width) 0) row))\n              (into [] row))))\n        row-down  (fn [matrix row level] (get matrix (+ row level)))\n        row-up    (fn [matrix row level] (get matrix (- row level)))\n        row-left  (fn [level idx] (take level (iterate dec idx)))\n        row-right (fn [level idx] (take level (iterate inc idx)))\n        grow-base (fn [level-fn h-fn v-fn]\n                    (fn [matrix row idx level]\n                    (loop [value level level level]\n                      (let [test-level (level-fn level)\n                            mrow       (h-fn matrix row level)]\n                        (if (every? (fn [x] (= 1 x)) (map #(get mrow %) (v-fn test-level idx)))\n                          (recur (+ value test-level) test-level)\n                          [value level])))))\t\t        \n\t    grow-bottom-left (grow-base inc row-down row-left)    \n        grow-bottom-right (grow-base inc row-down row-right) \n        grow-top-left (grow-base inc row-up row-left)     \n        grow-top-right (grow-base inc row-up row-right) \n        combine-triangles (fn [t1 t2]\n                            (if (= (second t1) (second t2))\n                                   (- (+ (first t1) (first t2)) (second t1))\n                                   0))\n        grow-triangle-down (fn [t1 grow-top-fn matrix row idx]\n                            (let [level (second t1)\n                                  t2 (grow-top-fn matrix (+ row (* 2 (- level 1))) idx 0)]\n                               (combine-triangles t1 t2)))\n\t    score-position (fn [matrix row idx]\n          (let [inputs     [matrix row idx 0]\n                bot-left   (apply grow-bottom-left inputs)\n                bot-right  (apply grow-bottom-right inputs)\n                bot-middle (combine-triangles bot-left bot-right)\n                top-left   (apply grow-top-left inputs)\n                top-right  (apply grow-top-right inputs)\n                top-middle (combine-triangles top-left top-right)\n                bot-ldown  (grow-triangle-down bot-left grow-top-left matrix row idx)\n                bot-rdown  (grow-triangle-down bot-right grow-top-right matrix row idx)]\n          (apply max (concat (map first [bot-left bot-right top-left top-right]) [bot-middle top-middle bot-ldown bot-rdown]))))   \n        matrix-base (map #(Integer/toBinaryString %) rocks)\n\t\tmatrix-width (apply max (map count matrix-base))\n\t\tmatrix (into [] (map #(lengthen-row % matrix-width) matrix-base))\n\t\tscore (apply max \n              (for [row (range (count matrix)) col (range matrix-width)] \n                (score-position matrix row col)))]\n        (if (> 3 score) nil score)))","problem":127,"user":"50588af1e4b06522596eba7d"},{"code":"(fn [c] \n   (letfn [(getDirs [d h ix iy] \n             (vec \n              (for [d d]\n                (loop [i2 1 c 0]\n                  (if (or \n                       (nil? (h [(+ ix (* (first d) i2)) (+ iy (* (second d) i2))])) \n                       (= 0 (h [(+ ix (* (first d) i2)) (+ iy (* (second d) i2))]) 0))\n                    c\n                    (recur (inc i2) (inc c))\n                    )))))\n           (getPairs [dirs p]\n             (vec \n              (for [p p]\n                (if (< (dirs (first p)) (dirs (second p)))\n                  (dirs (first p))\n                  (dirs (second p))\n                  )\n                )))\n           (getVerts [pairs p h2 d i]\n             (loop [i3 0 vts []]\n               (if (>= i3 (count pairs))\n                 vts\n                 (let [p1 (d (first (p i3))) \n                       p2 (d (second (p i3))) \n                       hx (first (h2 i)) \n                       hy (second (h2 i)) \n                       verts (loop [i4 0 vs []]\n                               (if (>= i4 (pairs i3))\n                                 vs\n                                 (recur (inc i4) (conj vs [(h2 i) [(+ hx (* (first p1) (inc i4))) (+ hy (* (second p1) (inc i4)))] [(+ hx (* (first p2) (inc i4))) (+ hy (* (second p2) (inc i4)))] {:pind i3 :step i4}]))\n                                 )\n                               )]\n                   (if (not (empty? verts))\n                     (recur (inc i3) (concat vts verts))\n                     (recur (inc i3) vts))))))\n           (getT \n             [m2 h h2]\n             (loop [i 0 vts []]\n               (if (>= i (count h))\n                 (vec (concat vts))\n                 (let [x (h (h2 i)) \n                       ix (first (h2 i)) \n                       iy (second (h2 i))]\n                   (if (= x 0)\n                     (recur (inc i) vts)\n                     (let [p [[0 2] [0 3] [1 2] [1 3] [4 6] [4 7] [5 6] [5 7]]\n                           d [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]\n                           d2 [[1 1] [-1 1] [1 -1] [-1 -1] [1 0] [0 1] [0 -1] [-1 0]]\n                           dirs (getDirs d h ix iy)\n                           pairs (getPairs dirs p)\n                           verts (getVerts pairs p h2 d i)\n                           ]\n                       (if (empty? verts)\n                         (recur (inc i) vts)\n                         (recur (inc i) (concat vts verts)))))))))\n           (getArea [v h]\n             (let [d2 [[1 1] [-1 1] [1 -1] [-1 -1] [1 0] [0 1] [0 -1] [-1 0]]\n                   d3 (d2 ((v 3) :pind))\n                   step ((v 3) :step)\n                   pind ((v 3) :pind)\n                   vx (first (v 0))\n                   vy (second (v 0))]\n               (if (> pind 3)\n                 (loop [i 0 n []]\n                   (if (> i step)\n                     n\n                     (if (= i 0)\n                       (recur (inc i) (conj n [(+ vx (first d3)) (+ vy (second d3))]))\n                       (let [i2 (* (dec i) (dec i))\n                             aset (loop [i2 i2 a #{}]\n                                    (if (>= i2 (count n))\n                                      a\n                                      (let [dd [(+ (first (n i2)) (first d3)) (+ (second (n i2)) (second d3))]\n                                            dd2 (if (= 0 (first d3))\n                                                  [(+ (first dd) 1) (second dd)]\n                                                  [(first dd) (+ (second dd) 1)]\n                                                  )\n                                            dd3 (if (= 0 (first d3))\n                                                  [(- (first dd) 1) (second dd)]\n                                                  [(first dd) (- (second dd) 1)]\n                                                  )\n\n                                            ]\n                                        (recur (inc i2) (-> a (conj dd) (conj dd2) (conj dd3))))\n                                      )\n                                    )]\n                         (recur (inc i) (vec (concat n aset))))\n                       )))\n                 (loop [i 1 n []]\n                   (if (> i step)\n                     n\n                     (if (= i 1)\n                       (recur (inc i) (conj n [(+ vx (first d3)) (+ vy (second d3))]))\n                       (let [i2 (/ (* (- i 2) (dec i)) 2)\n                             aset (loop [i2 i2 a #{}]\n                                    (if (>= i2 (count n))\n                                      a\n                                      (recur (inc i2) (-> a (conj [(+ (first (n i2)) (second d3)) (second (n i2))]) (conj [(first (n i2)) (+ (second (n i2)) (first d3))])))\n                                      )\n                                    )]\n                         (recur (inc i) (vec (concat n aset))))\n                       )))\n                 )))\n\n           (isClear [a h]\n             (loop [i 0]\n               (if (>= i (count a))\n                 true\n                 (do\n                   (if (= 0 (h (a i)))\n                     false\n                     (recur (inc i))\n                     ))\n                 )))\n\n           (getMap [] \n             (let [m (vec (map #(to2 %) c))\n                   max (reduce \n                        (fn [a b] (if (< a (count b)) (count b) a))\n                        0\n                        m)]\n               (vec (map #(vec (concat (repeat (- max (count %)) 0) %)) m))))\n           (to2 [x] \n             (vec (loop [c [] x x]\n                    (if (< x  2)\n                      (cons x c)\n                      (recur (cons (rem x 2) c) (quot x 2))))))] \n     (let [m2 (getMap)\n           h (reduce \n              #(assoc %1 %2 ((m2 (first %2)) (second %2))) \n              {} \n              (apply \n               concat \n               (keep-indexed \n                #(keep-indexed (fn [a b] [%1 a]) %2) \n                m2)))\n           h2 (vec (map #(key %) h))\n           vts (getT m2 h h2)\n           area (for [v vts]\n                  {:v v :a (getArea v h)}\n                  )\n           areas (for [v area]\n                   (if (false? (isClear (v :a) h))\n                     0\n                     (+ (count (v :a)) (inc (* (inc (((v :v) 3) :step)) 2)))\n                     )\n                   )\n           max (reduce #(if (< %1 %2) %2 %1) 0 areas)\n           ]\n       (if (= max 0) nil max))))","problem":127,"user":"52c1bd29e4b07a9af579236a"},{"problem":127,"code":"(fn [input]\n  (let [len                  (-> (apply max input)\n                                 ((fn [v]\n                                    (/ (Math/log v) (Math/log 2))))\n                                 (Math/ceil)\n                                 (int))\n        get-head             (fn [line]\n                               (->> (range (count line) len)\n                                    (map (fn [_]\n                                           \"0\"))\n                                    (apply str)))\n        with-head            (fn [line]\n                               (-> (get-head line)\n                                   (str line)))\n        board                (->> input\n                                  (mapv #(Integer/toBinaryString %))\n                                  (mapv (fn [line]\n                                          (->> (with-head line)\n                                               (mapv #(= \\1 %))))))\n        get-max              (fn [vals]\n                               (let [vals (->> vals\n                                               (filter identity)\n                                               (filter #(>= % 3)))]\n                                 (when (seq vals)\n                                   (apply max vals))))\n        match?               (fn [board pattern y x pattern-height pattern-width]\n                               (let [res (for [dy (range pattern-height)\n                                               dx (range pattern-width)]\n                                           (let [pv (get-in pattern [dy dx])\n                                                 bv (get-in board [(+ y dy) (+ x dx)])]\n                                             (if pv\n                                               (= bv pv)\n                                               true)))]\n                                 (every? true? res)))\n        board-height         (count board)\n        board-width          (-> board\n                                 (first)\n                                 (count))\n        triangle             (fn [height width pred]\n                               (let [pattern (-> (fn [y]\n                                                   (mapv (fn [x]\n                                                           (pred y x)) (range width)))\n                                                 (mapv (range height)))]\n                                 {:pattern        pattern\n                                  :pattern-height height\n                                  :pattern-width  width\n                                  :size           (reduce (fn [acc x]\n                                                            (->> (filter true? x)\n                                                                 (count)\n                                                                 (+ acc))) 0 pattern)}))\n        squared-triangles    (fn [side-size]\n                               [(triangle side-size side-size (fn [y x]\n                                                                (<= y x)))\n                                (triangle side-size side-size (fn [y x]\n                                                                (>= y x)))\n                                (triangle side-size side-size (fn [y x]\n                                                                (<= y (- side-size x 1))))\n                                (triangle side-size side-size (fn [y x]\n                                                                (>= y (- side-size x 1))))])\n        rotate               (fn [board]\n                               (let [rows (count board)]\n                                 (-> (fn [row]\n                                       (nth board (- rows row 1)))\n                                     (mapv (range rows)))))\n        horizontal-triangles (fn [side-size]\n                               (let [tr         (triangle side-size (dec (* 2 side-size))\n                                                          (fn [y x]\n                                                            (or (and (<= y x)\n                                                                     (<= x (dec side-size)))\n                                                                (and (<= y (- (* 2 side-size) x 2))\n                                                                     (>= x side-size)))))\n                                     rotated-tr (-> tr\n                                                    (:pattern)\n                                                    (rotate))]\n                                 [tr (assoc tr :pattern rotated-tr)]))\n        transp               (fn [{:keys [pattern pattern-height pattern-width] :as board}]\n                               (let [rows    (count pattern)\n                                     cols    (count (first pattern))\n                                     pattern (-> (fn [x]\n                                                   (mapv (fn [y]\n                                                           (get-in pattern [y x])) (range rows)))\n                                                 (mapv (range cols)))]\n                                 (assoc board :pattern pattern\n                                              :pattern-height pattern-width\n                                              :pattern-width pattern-height)))\n        vertical-triangles   (fn [side-size]\n                               (->> (horizontal-triangles side-size)\n                                    (mapv transp)))\n        squared              (->> (range 2 (-> (min board-height board-width)\n                                               (inc)))\n                                  (map squared-triangles)\n                                  (apply concat))\n        horizontal           (->> (range 2 (inc board-height))\n                                  (filter (fn [n]\n                                            (<= (dec (* 2 n)) board-width)))\n                                  (map horizontal-triangles)\n                                  (apply concat))\n        vertical             (->> (range 2 (inc board-width))\n                                  (filter (fn [n]\n                                            (<= (dec (* 2 n)) board-height)))\n                                  (map vertical-triangles)\n                                  (apply concat))\n        recognize            (fn [board y x {:keys [pattern pattern-width pattern-height size]}]\n                               (when (and (<= (+ y pattern-height) board-height)\n                                          (<= (+ x pattern-width) board-width)\n                                          (match? board pattern y x pattern-height pattern-width))\n                                 size))\n        search               (fn [board patterns]\n                               (->> (for [y (range board-height)\n                                          x (range board-width)]\n                                      (map #(recognize board y x %) patterns))\n                                    (apply concat)\n                                    (get-max)))]\n    (search board (concat squared horizontal vertical))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":127,"code":"(fn triangle-area [nums]\n  (let [\n        ; Return a string representation of a number in binary\n        ; 15 -> \"1111\",\n        ; 28 -> \"11100\", etc.\n        to-binary-string (fn [num]\n                           (if (= num 0)\n                             \"0\"\n                             (let [exp (fn [x n]\n                                         (loop [acc 1 n n]\n                                           (if (zero? n)\n                                             acc\n                                             (recur (* x acc) (dec n)))))\n                                   powers-of-2 (map (partial exp 2) (iterate inc 0))\n                                   num-is-gte (fn [x] (>= num x))\n                                   extract-bit (fn [x] (if (zero? (bit-and num x)) \"0\" \"1\"))]\n                               (->> (take-while num-is-gte powers-of-2)\n                                    (map extract-bit)\n                                    (reverse)\n                                    (apply str)))))\n\n        ; Convert a vector of numbers into a 2-d binary matrix\n        ; [18 7 14 14 6 3] ->  [[1 0 0 1 0]\n        ;                       [0 0 1 1 1]\n        ;                       [0 1 1 1 0]\n        ;                       [0 1 1 1 0]\n        ;                       [0 0 1 1 0]\n        ;                       [0 0 0 1 1]]\n        to-matrix (fn [nums]\n                    (let [binary (map to-binary-string nums)\n                          strlen (fn [s] (if (string? s) (count s) s))\n                          maxlen (fn [strs] (reduce (fn [a b] (apply max (map strlen [a b]))) strs))\n                          longest (maxlen binary)\n                          lpad-zeroes (fn [s] (if (> longest (count s)) (recur (str \"0\" s)) s))\n                          bin-strings (map lpad-zeroes binary)\n                          bit-to-int (fn [c] (if (= \\1 c) 1 0))\n                          int-strings (map (comp vec (partial map bit-to-int)) bin-strings)]\n                      (vec int-strings)))\n\n        ; Return the dimensions of a 2-d matrix in a vector of [rows columns]\n        dims (fn [mtx] [(count mtx) (count (first mtx))])\n\n        ; Rotates a matrix 45 degrees to the right\n        ; [[1 1 1]    [[1 1 1]\n        ;  [1 1 0] ->  [0 1 1]\n        ;  [1 0 0]]    [0 0 1]]\n        rotate-right (fn [mtx]\n                       (let [nr (comp reverse (partial map first))\n                             rr (partial map rest)\n                             na (fn [x y] (conj x (vec y)))]\n                         (loop [acc []\n                                next (nr mtx)\n                                rest (rr mtx)]\n                           (if (every? empty? rest)\n                             (na acc next)\n                             (recur (na acc next)\n                                    (nr rest)\n                                    (rr rest))))))\n\n        ; Returns a sequence of all 4 possible \"orientations of a matrix\n        ; [[1 2 3]     ([[1 2 3]  [[7 4 1]  [[9 8 7]  [[3 6 9]\n        ;  [4 5 6]  ->   [4 5 6]   [8 5 2]   [6 5 4]   [2 5 8]\n        ;  [7 8 9]]      [7 8 9]]  [9 6 3]]  [3 2 1]]  [1 4 7]])\n        orientations (fn [mtx] (take 4 (iterate rotate-right mtx)))\n\n        ; Return all of the \"submatrices\" of a given matrix that have the given dimensions\n        ;\n        ; Given the following matrix:\n        ;     [[1 2 3 4]\n        ;      [5 6 7 8]\n        ;      [9 0 1 2]\n        ;      [3 4 5 6]\n        ;      [7 8 9 0]]\n        ;\n        ; calling submatrices with the [matrix [2 3]] returns the following:\n        ; ([[1 2 3][5 6 7]]\n        ;  [[2 3 4][6 7 8]]\n        ;  [[5 6 7][9 0 1]]\n        ;  [[6 7 8][0 1 2]]\n        ;  [[9 0 1][3 4 5]]\n        ;  [[0 1 2][4 5 6]]\n        ;  [[3 4 5][7 8 9]]\n        ;  [[4 5 6][8 9 0]])\n        submatrices (fn [mtx [rows cols]]\n                      (let [[row-limit col-limit] (dims mtx)]\n                        (loop [subs []\n                               row-start 0\n                               col-start 0]\n                          (let [row-end (+ row-start rows)\n                                col-end (+ col-start cols)]\n                            (if (> row-end row-limit)\n                              (vec subs)\n                              (let [next-sub (vec (map #(subvec % col-start col-end)\n                                                       (subvec mtx row-start row-end)))\n                                    next-subs (conj subs next-sub)\n                                    next-row-start (inc row-start)\n                                    next-col-start (inc col-start)\n                                    next-col-end (+ next-col-start cols)]\n                                (if (> next-col-end col-limit)\n                                  (recur next-subs next-row-start 0)\n                                  (recur next-subs row-start next-col-start))))))))\n\n        ; Return whether the triangle \"fits\" into the matrix, i.e.\n        ; For every bit set in the triangle matrix, is the corresponding bit\n        ; in the other matrix also set?\n        fits? (fn [triangle mtx]\n                (let [and #(and %1 %2)]\n                  (reduce\n                    and\n                    (map (partial reduce and)\n                         (map-indexed\n                           (fn [r row]\n                             (map-indexed\n                               (fn [c t-cell]\n                                 (let [m-cell (get-in mtx [r c])]\n                                   (or (= 0 t-cell)\n                                       (= t-cell m-cell)))) row)) triangle)))))\n\n        ; Return either the smallest corner isosceles triangle\n        ; Or, given a corner isosceles triangle, the next larger triangle\n        ;\n        ; How corner triangles grow\n        ; [[1 0]  -> [[1 0 0]\n        ;  [1 1]]     [1 1 0]\n        ;             [1 1 1]]\n        grow-corner-triangle (fn\n                               ([] [[1 0] [1 1]])\n                               ([triangle]\n                                (let [size (count (first triangle))\n                                      new-top (vector (into [] (conj (repeat size 0) 1)))\n                                      prepend-1-each-row #(map (comp vec (partial concat [1])) %)]\n                                  (vec (concat new-top (vec (prepend-1-each-row triangle)))))))\n\n        ; Return either the smallest side isosceles triangle\n        ; Or, given a side isosceles triangle, the next larger triangle\n        ;\n        ; How side triangles grow\n        ;\n        ; [[1 0]  -> [[1 0 0]\n        ;  [1 1]      [1 1 0]\n        ;  [1 0]]     [1 1 1]\n        ;             [1 1 0]\n        ;             [1 0 0]]\n        grow-side-triangle (fn\n                             ([] [[1 0] [1 1] [1 0]])\n                             ([triangle]\n                              (let [size (count (first triangle))\n                                    new-cap (vector (into [] (conj (repeat size 0) 1)))\n                                    prepend-1-each-row #(map (comp vec (partial concat [1])) %)]\n                                (vec (concat new-cap (vec (prepend-1-each-row triangle)) new-cap)))))\n\n        ; Return a sequence of all the triangles that fit into the matrix,\n        ; using the supplied triangle growth function\n        fitting-triangles (fn [mtx triangle-grower]\n                            (let [[m-rows m-cols] (dims mtx)]\n                              (reverse\n                                (take-while (fn [triangle]\n                                              (let [[t-rows t-cols] (dims triangle)]\n                                                (or\n                                                  (and (>= m-rows t-rows)\n                                                       (>= m-cols t-cols))\n                                                  (and (>= m-rows t-cols)\n                                                       (>= m-cols t-rows)))))\n                                            (iterate triangle-grower (triangle-grower))))))\n\n        ; Return the \"area\" of a 2-d matrix, i.e. the number of 1's in the matrix\n        area (fn [mtx] (reduce + (map (partial reduce +) mtx)))\n\n        ; Return the area of the triangle if it fits into the matrix, else nil\n        area-if-fits (fn [mtx triangle]\n                       (if (not-every?\n                             false?\n                             (map\n                               (partial fits? triangle)\n                               (mapcat orientations\n                                       (let [search (submatrices mtx (dims triangle))]\n                                         (if (empty? search)\n                                           (submatrices mtx (reverse (dims triangle)))\n                                           search)))))\n                         (area triangle)\n                         nil))\n\n        ; The vector of numbers, represented as a 2-d binary matrix\n        matrix (to-matrix nums)\n\n        ; A sequence of all of the corner-style and side-style isosceles triangles\n        ; that could fit into the matrix\n        candidate-triangles (concat (fitting-triangles matrix grow-corner-triangle)\n                                    (fitting-triangles matrix grow-side-triangle))]\n\n    (->> candidate-triangles\n         (map (partial area-if-fits matrix))\n         (sort)\n         (reverse)\n         (first))))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [s]\n  (let [r range\n        mc mapcat\n        c count\n        v vector\n        a (map (fn [n] (map #(if (= % \\0) 0 1) (Integer/toString n 2))) s)\n        n (apply max (map c a))\n        bm (vec (map #(vec (concat (repeat (- n (c %)) 0) %)) a))\n      \n        z (max (c (nth bm 0)) (c bm))\n\n        a (fn [f n]\n            (mc\n              (fn [i k]\n                (map #(f i k %) (r (+ k 1))))\n              (r)\n              (r 0 n 2)))\n        u #(+ %2 (quot (- %3 %1 1) 2))\n          \n        b (fn [f n]\n            (mc\n              (fn [k]\n                (map #(f k %) (r (+ k 1))))\n              (r n)))\n            \n        ts (into\n          (mc \n            (fn [n]\n              (map \n                #(b % n) \n                [#(v %2 %1)\n                 #(v (- n %2 1) %1)\n                 #(v %2 (- n %1 1))\n                 #(v (- n %2 1) (- n %1 1))]))\n            (r 2 (+ z 1)))\n          (mc \n            (fn [n]\n              [(a #(v (u %2 %3 n) %1) n)\n                (a #(v %1 (u %2 %3 n)) n)\n                (a #(v (u %2 %3 n) (- (/ (- n 1) 2) %1)) n)\n                (a #(v (- (/ (- n 1) 2) %1) (u %2 %3 n)) n)])\n            (r 3 (+ z 1) 2)))\n        \n        x \n        (for [x (r z) \n              y (r z) \n              t ts\n              :when (every? #{1} (map #(get-in bm (map + % [x y])) t))]\n          (c t))]\n    (when (first x) \n      (apply max x))))","problem":127,"user":"4e5411e8535d8a8b8723a279"},{"problem":127,"code":";; test cases do not cover multiple triangles... so I won't bother with those, just the max\n;; it looks like I am searching for three types of triangles?\n;;  *    *   *    *   ***\n;;  **  **   **  **    *\n;;           *    *\n\n;; was going to use bitwise ops but code is easier to read if I get more abstract and decode mine\n(fn mine-largest-triangle [mine-as-ints]\n  (letfn [(decode-mine [encoded-mine]\n            (let [max-width (->> encoded-mine\n                                 (map #(count (Integer/toString % 2)))\n                                 (apply max))]\n              (->> encoded-mine\n                   (map (fn [row]\n                          (into [] (map #(Character/getNumericValue %)\n                                        (-> (format (str \"%\" max-width \"s\") (Integer/toString row 2))\n                                            (.replace \" \" \"0\"))))))\n                   (into []))))\n          (extract-from-mine [mine x y triangle]\n            (for [[y-offset trow] (map-indexed vector triangle)]\n              (let [mine-row (get mine (+ y y-offset))]\n                (subvec mine-row x (+ x (count trow))))))\n          (sitting-triangle [width]\n            (for [n (range 1 (inc width))]\n              (repeat n 1)))\n          (standing-triangle [width]\n            (concat (sitting-triangle width)\n                    (drop 1 (reverse (sitting-triangle width)))))\n          (minerals-in-triangle [triangle]\n            (reduce (fn [acc n] (apply + acc n)) 0 triangle))\n          (rotate-right [mine]\n            (apply mapv #(->> (apply vector %&)\n                              reverse\n                              (into []))\n                   mine))\n          (flip-horizontal [mine]\n            (->> mine\n                 (map #(into [] (reverse %)))\n                 (into [])))\n          (triangles-minerals-for-mine [triangle-type mine]\n            (let [mine-height (count mine)\n                  mine-width (count (first mine))]\n              (for [triangle-width (reverse (range 2 (inc mine-width)))\n                    :let [ideal-triangle (if (= triangle-type :sitting)\n                                           (sitting-triangle triangle-width)\n                                           (standing-triangle triangle-width))\n                          triangle-height (count ideal-triangle)]\n                    start-x (range (- (inc mine-width) triangle-width))\n                    start-y (range (- (inc mine-height) triangle-height))\n                    :when (= ideal-triangle (extract-from-mine mine start-x start-y ideal-triangle))]\n                (minerals-in-triangle ideal-triangle))))]\n    (let [mine (decode-mine mine-as-ints)\n          harvests (concat (triangles-minerals-for-mine :sitting mine )\n                           (triangles-minerals-for-mine :sitting (flip-horizontal mine))\n                           (triangles-minerals-for-mine :standing mine)\n                           (triangles-minerals-for-mine :standing (flip-horizontal mine))\n                           (triangles-minerals-for-mine :standing (-> mine rotate-right flip-horizontal)))]\n      (when (seq harvests) (apply max harvests)))))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":127,"code":"(fn [coll]\n   (let [binaries (for [k (map #(Integer/toString % 2) coll)]\n                     k)\n         max-binary-length (apply max (map count binaries))\n         rectangle-str (map (fn [x]\n                              (if (= (count x) max-binary-length)\n                                x\n                                (str (apply str (repeat (- max-binary-length (count x)) \"0\")) x)))\n                            binaries)\n         rectangle-list (for [k rectangle-str]\n                          (map #(- (int %) 48) (seq (char-array k))))\n         position-list (for [i (range (count rectangle-list))\n                            j (range (count (first rectangle-list)))]\n                         [i j])\n         map-position-type (map (fn [a b]\n                                  (into (sorted-map) (zipmap a b))) (partition 4 position-list) rectangle-list)\n         rectangle-list-minerals (filter #(= 1 (nth (nth rectangle-list (first %)) (second %))) position-list)\n         get-value (fn [a]\n                     (if (= nil a)\n                       nil\n                       (nth (nth rectangle-list (first a)) (second a))))\n         neighbour-above (fn [[x y]]\n                           (if (>= 0 x)\n                             nil\n                             [(dec x) y]))\n         neighbour-left (fn [[x y]]\n                          (if (>= 0 y)\n                            nil\n                            [x (dec y)]))\n         neighbour-right (fn [[x y]]\n                           (if (<= (dec (count (first rectangle-list))) y)\n                             nil\n                             [x (inc y)]))\n         neighbour-below (fn [[x y]]\n                           (if (<= (dec (count rectangle-list)) x)\n                             nil\n                             [(inc x) y]))\n         neighbours-ordered (fn [[x y]]\n                                (list (neighbour-above [x y]) (neighbour-left [x y]) (neighbour-right [x y])\n                                      (neighbour-below [x y])))\n         values-neighbours-ordered (fn [[x y]]\n                                     (map #(get-value %) (neighbours-ordered [x y])))\n         right-ang-tri-bottom-coner (fn [[x y] n1 n2]\n                                      (loop [old-acc '()\n                                             acc (list (list x y))]\n                                        (if (every?\n                                              #(= 1 %)\n                                              (flatten\n                                                (map #(for [k [n1 n2]]\n                                                        (nth % k))\n                                                      (map #(values-neighbours-ordered %) acc))))\n                                          (recur\n                                            acc\n                                            (distinct\n                                              (concat\n                                                acc\n                                                (partition 2 (flatten (map #(for [k [n1 n2]]\n                                                  (nth % k))\n                                               (map #(neighbours-ordered %) acc)))))))\n                                          (sort-by first acc))))\n         \n         quad-1-tri (remove #(= 1 (count %)) (map #(right-ang-tri-bottom-coner % 0 2) rectangle-list-minerals))\n         quad-2-tri (remove #(= 1 (count %)) (map #(right-ang-tri-bottom-coner % 0 1) rectangle-list-minerals))\n         quad-3-tri (remove #(= 1 (count %)) (map #(right-ang-tri-bottom-coner % 3 1) rectangle-list-minerals))\n         quad-4-tri (remove #(= 1 (count %)) (map #(right-ang-tri-bottom-coner % 3 2) rectangle-list-minerals))\n         initial-triangles  (concat quad-1-tri quad-2-tri quad-3-tri quad-4-tri)\n         rowed-triangles (fn [z]\n                           (map (fn [a]\n                                  (map #(sort-by second %) a)) (map #(partition-by first %) z)))\n         columned-triangles (fn [z]\n                              (map #(partition-by second %)\n                                   (map #(sort-by second %) z)))\n         get-longest-row-or-column (fn [r]\n                                     (partition 2 (flatten (filter #(= (count %) (count r)) r))))\n         bigger-triangle? (fn [a b]\n                            (remove false?\n                                    (for [p a\n                                          q b]\n                                      (cond\n                                        (= p q) false\n                                        (and (= (last p)\n                                                (first q))\n                                             (= (count p) (count q)))\n                                        (distinct (concat p q))\n                                        :else false))))\n         big-triangles-from-smaller-triangles\n          (remove empty?\n                  (concat\n                    (map #(partition 2 (flatten %))(bigger-triangle? (columned-triangles quad-2-tri) (columned-triangles quad-1-tri)))\n                    (map #(partition 2 (flatten %))(bigger-triangle? (columned-triangles quad-3-tri) (columned-triangles quad-4-tri)))\n                    (map #(partition 2 (flatten %))(bigger-triangle? (rowed-triangles quad-1-tri) (rowed-triangles quad-4-tri)))\n                    (map #(partition 2 (flatten %))(bigger-triangle? (rowed-triangles quad-2-tri) (rowed-triangles quad-3-tri)))))\n         all-triangles (concat initial-triangles big-triangles-from-smaller-triangles)]\n\n    (if (empty? all-triangles)\n      nil\n      (apply max (map #(count %) all-triangles)))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":127,"code":"(fn problem127\n  [numbers]\n  (letfn [(numbers->matrix\n            [numbers]\n            (let [binaries (map #(Long/toBinaryString %) numbers)\n                  length (apply max (map count binaries))]\n              (->> binaries\n                   (map seq)\n                   (map (fn [xs]\n                          (map #(- (int %) 48) xs)))\n                   (map reverse)\n                   (map #(concat % (repeat 0)))\n                   (map #(take length %))\n                   (map reverse)\n                   (mapv vec))))\n          (triangle-with-top-at\n            [matrix [top-row-idx top-col-idx :as top-coords] update-strategy]\n            (loop [area 0\n                   [left-idx right-idx :as coords] [top-col-idx (inc top-col-idx)]\n                   row-idx top-row-idx]\n              (if (or (= row-idx (count matrix))\n                      (> right-idx (count (first matrix)))\n                      (< left-idx 0)\n                      (not-empty (filter #{0} (subvec (matrix row-idx) left-idx right-idx))))\n                area\n                (recur (+ area (- right-idx left-idx))\n                       (update-strategy coords)\n                       (inc row-idx)))))]\n    (let [matrix (numbers->matrix numbers)\n          maximum-area (apply max\n                              (for [matrix [matrix\n                                            (vec (reverse matrix))\n                                            (apply mapv vector matrix)]\n                                    top-row-idx (range (count matrix))\n                                    top-col-idx (range (count (first matrix)))\n                                    :let [top-coords [top-row-idx top-col-idx]]\n                                    update-strategy [(juxt (comp dec first) second)\n                                                     (juxt first (comp inc second))\n                                                     (juxt (comp dec first) (comp inc second))]]\n                                (triangle-with-top-at matrix top-coords update-strategy)))]\n      (if (> maximum-area 1)\n        maximum-area\n        nil))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn [xs]\n  (let [bm (vec (map (fn [x] (vec (reverse (map #(- (int %) (int \\0))\n                                                (Integer/toString x 2)))))\n                     xs))\n        h (count bm)\n        w (apply + (map count bm))\n        m (max h w)\n        in (fn [a b] (every? identity (for [y (range (count a))\n                                            x (range (count (first a)))\n                                            :when (= 1 (get-in a [y x]))]\n                                        (= 1 (get-in b [y x])))))\n        rig #(vec (for [y (range %)]\n                    (vec (for [x (range %)] (if (< x y) 0 1)))))\n        iso #(vec (for [y (range (/ (inc %) 2))]\n                    (vec (for [x (range %)]\n                           (if (or (< x y) (<= (- % x) y)) 0 1)))))\n        rot #(let [ow (count (first %))]\n               (vec (for [y (range ow)]\n                      (vec (for [x (range (count %))]\n                             (get-in % [x (- ow y 1)]))))))\n        mov (fn [b [y x]]\n              (let [h (count b) w (count (first b))]\n                (vec (concat (repeat (+ y) (vec (repeat (+ w x) 0)))\n                             (map #(vec (concat (repeat x 0) %)) b)))))\n        rot4xy (fn [s]\n                 (some identity\n                   (for [rot4 (take 4 (iterate rot s))\n                         x (range 0 (inc (- w (count (first rot4)))))\n                         y (range 0 (inc (- h (count rot4))))]\n                     (in (mov rot4 [y x]) bm))))\n        trials (sort (fn [a b] (> (second a) (second b)))\n                 (concat\n                   (map #(vector (rig %) (/ (* % (inc %)) 2))\n                        (range 2 (inc m)))\n                   (map #(vector (iso %) (/ (* (inc %) (inc %)) 4))\n                        (range 3 (inc m) 2))))\n        ]\n    (loop [[[shape area :as h] & r] trials]\n      (if (nil? h) nil\n          (if (rot4xy shape) area (recur r))))))","problem":127,"user":"4fd96694e4b05e33b9224f37"},{"code":"(fn jesus-wept [bitmap]\n  (letfn [(int-to-array [i c]\n            (->> (Integer/parseInt i)\n                 (format (str \\% \\0 c \\d))\n                 (map #(= \\1 %))\n                 (into [])))\n          (ints-to-array [bitmap]\n            (let [strs (map #(Integer/toBinaryString %) bitmap)\n                  pad-to (apply max (map count strs))]\n              (into [] (map #(int-to-array % pad-to) strs))))\n          (next-coords [coords]\n            (let [c (ffirst coords)\n                  r-min (last (first coords))\n                  r-max (last (last coords))]\n              (for [r (range (dec r-min) (+ 2 r-max))]\n                [(dec c) r])))\n          (largest-vertical [coords mine n]\n            (if (every? true? (map #(get-in mine %) coords))\n                (recur (next-coords coords) mine (+ n (count coords)))\n                n))\n          (next-ne [coords]\n            (into #{} (mapcat (fn [[r c]] [[(dec r) c] [r (inc c)]]) coords)))\n          (largest-diagonal [coords mine n]\n            (if (every? true? (map #(get-in mine %) coords))\n                (recur (next-ne coords) mine (+ n (count coords)))\n                n))\n          (gen-mine-permutations [mine]\n            [mine\n             (into [] (map (comp vec reverse) (apply map vector mine)))\n             (into [] (reverse (map (comp vec reverse) mine)))\n             (into [] (reverse (apply map vector mine)))])\n          (find-max [coord mine]\n            (max (largest-diagonal [coord] mine 0)\n                 (largest-vertical [coord] mine 0)))]\n    (let [mine (ints-to-array bitmap)\n          all-coords (for [r (range (count mine)) c (range (count (first mine)))] [r c])\n          all-mines (gen-mine-permutations mine)\n          area (apply max (for [c all-coords m all-mines] (find-max c m)))]\n      (if (> area 2) area))))","problem":127,"user":"52463059e4b09dbe66b56198"},{"code":"(fn triangle-mine [bitmap]\n  (let [sz-row (count bitmap)\n        sz-col (max sz-row (loop [n (apply max bitmap) acc 0] (if (pos? n) (recur (bit-shift-right n 1) (inc acc)) acc)))\n        directions [\n         [[0 1] [inc dec]] [[1 0] [dec dec]] [[0 -1] [dec inc]] [[-1 0] [inc inc]]\n         [[-1 1] [inc identity]] [[1 1] [identity dec]] [[1 -1] [dec identity]] [[-1 -1] [identity inc]]]\n        get-pixel (fn [img r c] (if (and (< -1 r sz-row) (< -1 c sz-col)) (bit-test (img r) (- sz-col c 1)) false))\n        get-diag (fn [rr cc ht dir]\n          (if (zero? ht) (if (get-pixel bitmap rr cc) 1 0)\n            (let [[[rs cs] [rdf cdf]] (directions dir) dist (inc (if (< dir 4) ht (* 2 ht)))]\n              (loop [r (+ rr (* rs ht)) c (+ cc (* cs ht)) acc dist]\n                (if (and (pos? acc) (get-pixel bitmap r c)) (recur (rdf r) (cdf c) (dec acc)) (if (zero? acc) dist 0))))))\n        find-trng (fn [r c dir]\n          (if-not (get-pixel bitmap r c) 0\n            (reduce + (for [i (range) :let [diag (get-diag r c i dir)] :while (pos? diag)] diag))))\n        max-trng (fn [dir]\n          (apply max 0 (for [r (range (count bitmap)) c (range (count bitmap)) :let [ts (find-trng r c dir)] :when (> ts 2)] ts)))\n        ret (apply max 0 (map max-trng (range 8)))]\n    (when (> ret 2) ret)))","problem":127,"user":"4effb663535dcb61093f6a2e"},{"problem":127,"code":"(fn shareTrianglesX[m]\n\t(letfn[\n\t\t(power2[n]\n\t\t\t(int (Math/pow 2 n))\n\t\t)\n\n\t\t(power2BiggerThan[n]\n\t\t\t(first (drop-while #(<= (power2 %) n)  (range)))\n\t\t)\n\n\t\t(isSet[m y x]\n\t\t\t(bit-test (get m y) x)\n\t\t)\n\n\n\t\t(isSetOffset[m fy y fx x]\n\t\t\t(isSet m (+ fy y) (+ fx x))\n\t\t)\n\n\t\t(ceil2[n] (int (Math/ceil (/ n 2))))\n\t\t(unceil2[n] (- (* n 2) 1) )\n\n\n\t\t(cnt[m fy fx v]\n\t\t\t(let [t (map #(isSetOffset m fy (first %) fx (second %)) v)]\n\t\t\t\t(if (every? identity  t)\n\t\t\t\t\t(count t)\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\n\t\t(triangleRightTop[n]\n\t\t\t(for [y (range n) x (range y n)]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\t\t(triangleRightBottom[n]\n\t\t\t(for [y (range n) x (range (- (dec n) y) n)]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\n\t\t(triangleLeftTop[n]\n\t\t\t(for [y (range n) x (range (- n y))]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\t\t(triangleLeftBottom[n]\n\t\t\t(for [y (range n) x (range (inc y))]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\n\t\t(triangleTop[n]\n\t\t\t(for [y (range n) x (range y (- (unceil2 n) y))]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\t\t(triangleBottom[n]\n\t\t\t(for [y (range n) x (range (- (dec n) y) (+ n y))]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\n\t\t(triangleRight[n]\n\t\t\t(for [x (range n) y (range (- (dec n) x) (+ n x))]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\t\t(triangleLeft[n]\n\t\t\t(for [x (range n) y (range x (- (unceil2 n) x))]\n\t\t\t\t[y x]\n\t\t\t)\n\t\t)\n\n\n\t\t(shareCornerTrianglesRes[m cy cx cc]\n\t\t\t(if (>= cc 2)\n\t\t\t\t(let \n\t\t\t\t\t[mx (apply max\n\t\t\t\t\t\t\t(for [y (range (inc (- cy cc))) x (range (inc (- cx cc)))]\n\t\t\t\t\t\t\t\t(max\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleRightTop cc))\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleLeftTop cc))\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleRightBottom cc))\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleLeftBottom cc))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t\t(if (zero? mx) \n\t\t\t\t\t\t(shareCornerTrianglesRes m cy cx (dec cc))\n\t\t\t\t\t\tmx\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t0\n\t\t\t)\n\t\t)\n\n\n\n\t\t(shareHorizontalTrianglesRes[m cy cx height]\n\t\t\t(if(>= height 2)\n\t\t\t\t(let \n\t\t\t\t\t[mx (apply max\n\t\t\t\t\t\t\t(for [y (range (- (inc cy) height)) x (range (- (inc cx) (unceil2 height)))]\n\t\t\t\t\t\t\t\t(max\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleTop height))\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleBottom height))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t\t(if (zero? mx) \n\t\t\t\t\t\t(shareHorizontalTrianglesRes m cy cx (dec height))\n\t\t\t\t\t\tmx\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t0\n\t\t\t)\n\t\t)\n\n\t\t(shareVerticalTrianglesRes[m cy cx width]\n\t\t\t(if(>= width 2)\n\t\t\t\t(let \n\t\t\t\t\t[mx (apply max\n\t\t\t\t\t\t\t(for [y (range (- (inc cy) (unceil2 width))) x (range (inc cx))]\n\t\t\t\t\t\t\t\t(max\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleLeft width))\n\t\t\t\t\t\t\t\t\t(cnt m y x (triangleRight width))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t\t(if(zero? mx) \n\t\t\t\t\t\t(shareVerticalTrianglesRes m cy cx (dec width))\n\t\t\t\t\t\tmx\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t0\n\t\t\t)\n\t\t)\n\n\n\t\t]\n\t\t(let [\n\t\t\tmaxRow (apply max m)\n\t\t\tcy (count m)\n\t\t\tcx (power2BiggerThan maxRow)\n\t\t\tres (max\n\t\t\t\t(shareCornerTrianglesRes m cy cx (min cy cx))\n\t\t\t\t(shareHorizontalTrianglesRes m cy cx (min cy (ceil2 cx)))\n\t\t\t\t(shareVerticalTrianglesRes m cy cx (min (ceil2 cy) cx))\n\t\t\t)\n\t\t\t]\n\t\t\t(if (zero? res)\n\t\t\t\tnil\n\t\t\t\tres\n\t\t\t)\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":127,"code":"(fn [ints]\n  (let [\n        _int->binary (fn _int->binary [n]\n                       (cond\n                         (zero? n)\n                         [0]\n                         (= (mod n 2) 0)\n                         (vec (conj (_int->binary (quot n 2)) 0))\n                         :else\n                         (vec (conj (_int->binary (quot n 2)) 1))))\n        drop-nth (fn drop-nth [n coll]\n                   (concat\n                     (take n coll)\n                     (drop (inc n) coll)))\n        int->binary (fn int->binary [n]\n                      (if (zero? n)\n                        [0]\n                        (let [p (_int->binary n)]\n                          (subvec p 1))))\n        reg (fn reg [nums]\n              (let [regs (map int->binary nums)\n                    m (reduce (fn [x y] (if (> x (count y)) x (count y) )) 0  regs)]\n                (vec (map (fn [num] (vec (concat (repeat (- m (count num)) 0) num))) regs))))\n        typeC (fn typeC\n                ([nums i j k f]\n                 (let [cou (reduce +\n                                   (for [jj  (range j (+ j k))]\n                                     (get-in nums [i jj] 0)))]\n                   (if (>= cou k)\n                     (+ k (typeC nums (inc i) (f j) (inc k) f))\n                     0)))\n                ([nums i j]\n                 (typeC nums i j 1 identity)))\n\n        typeD (fn typeD [nums i j]\n                (typeC nums i j 1 dec))\n\n        typeA (fn typeA [num i j]\n                (typeC (vec (reverse num)) i j))\n\n        typeB (fn typeB [num i j]\n                (typeD (vec (reverse num)) i j))\n\n        typeP (fn typeP\n                ([nums i j k]\n                 (let [cou (reduce +\n                                   (for [ii (range (- i (quot k 2)) (+ (- i (quot k 2)) k))]\n                                     (get-in nums [ii j] 0)))]\n                   (if (>= cou k)\n                     (+ k (typeP nums i (inc j) (+ 2 k)))\n                     0)))\n                ([nums i j]\n                 (typeP nums i j 1)))\n\n        typeQ (fn typeQ [num i j]\n                (typeP (vec (reverse num)) i j))\n\n        typeR (fn typeR\n                ([nums i j k]\n                 (let [cou (reduce +\n                                   (for [jj (range (- j (quot k 2)) (+ (- j (quot k 2)) k))]\n                                     (get-in nums [i jj] 0)))]\n                   (if (>= cou k)\n                     (+ k (typeR nums (inc i) j (+ 2 k)))\n                     0)))\n                ([nums i j]\n                 (typeR nums i j 1)))\n\n        typeS (fn typeS [num i j]\n                (typeR (vec (reverse num)) i j))\n\n        nums (reg ints)\n        r (reduce max (for [i (range (count nums))]\n                        (reduce max (for [j  (range (count (first nums)))]\n                                      (reduce max (list (typeA nums i j)\n                                                        (typeB nums i j)\n                                                        (typeC nums i j)\n                                                        (typeD nums i j)\n                                                        (typeP nums i j)\n                                                        (typeQ nums i j)\n                                                        (typeR nums i j)\n                                                        (typeS nums i j)\n                                                        ))))))]\n    (if (> r 1)\n      r\n      nil)))","user":"53664e3be4b0243289761e74"},{"code":"(let [parse-board (fn parse-board [board]\n                    (mapv vec\n                          (for [row board]\n                            (->>\n                              row\n                              (iterate #(bit-shift-right % 1))\n                              (take 5)\n                              (map (partial bit-and 1))\n                              reverse))))\n      base-triangles #{[[[0 1] [1 1]] :flat]\n                       [[[0 1 0] [1 1 1]] :diag]}\n      extend-triangle (fn extend-triangle [[tri type]]\n                        [(if (= type :flat)\n                           (conj (mapv #(apply vector 0 %) tri) (conj (last tri) 1))\n                           (conj (mapv #(vec (concat [0] % [0])) tri) (vec (concat [1] (last tri) [1]))))\n                         type])\n      triangle-size (fn triangle-size [tri]\n                      (reduce + (map (partial reduce +) tri)))\n      matches? (fn matches? [rock tri +x +y]\n                 (every? identity\n                         (for [x (range (count tri))\n                               y (range (count (first tri)))]\n                           (or (= 0 (get-in tri [x y]))\n                               (= 1 (get-in rock [(+ x +x) (+ y +y)]))))))\n      rotate-triangle (fn rotate-triangle [triangle]\n                        (vec (reverse (apply mapv vector triangle))))]\n  (fn soln [board]\n    (some identity\n          (let [board (parse-board board)\n                triangles (->> base-triangles\n                               (mapcat #(take 5 (iterate extend-triangle %)))\n                               (map first)\n                               (sort-by triangle-size)\n                               reverse\n                               (mapcat #(take 4 (iterate rotate-triangle %))))]\n            (for [tri triangles\n                  x (range (count board))\n                  y (range (count (first board)))\n                  :when (matches? board tri x y)] \n              (triangle-size tri))))))","problem":127,"user":"50b668dde4b08fb537db98f2"},{"problem":127,"code":"(fn love-triangles [input]\n    (let [scan-1 (->> input\n                     (map #(Integer/toString % 2))\n                     (map seq)\n                     (mapv #(mapv (comp read-string str) %)))\n          padding (apply max (map count scan-1))\n          rock  (mapv #(vec (concat (repeat (- padding (count %)) 0) %)) scan-1)\n          rotations [rock (mapv (comp vec reverse) rock)\n                     (vec (reverse rock)) (vec (reverse (map (comp vec reverse) rock)))\n                     (apply mapv vector rock) (apply mapv vector (reverse rock))]\n          triangles (fn [rock]\n                        (let [max-y (count rock)\n                              max-x (count (first rock))\n                              positions (for [y (range 0 max-y), x (range 0 max-x)] [y x])\n                              itria (fn i-tria [[y x] row sum iso? sample]\n                                       (if   (every? #(= 1 %) sample)\n                                             (let [next-y (+ y row)\n                                                   next-x (if iso? (- x row) x)\n                                                   next+x (+ x row)\n                                                   sum-next (if iso?\n                                                              (+ sum (* 2 row) -1)\n                                                              (+ sum row))]\n                                                 (if (and (>= next-x 0)\n                                                          (< next+x max-x)\n                                                          (< next-y max-y))\n                                                     (i-tria [y x] (inc row) sum-next iso?\n                                                             (subvec (nth rock next-y)\n                                                                     next-x\n                                                                     (inc next+x)))\n                                                     sum-next))\n                                            sum))\n                              applied-itria #(itria %2 1 0 %1 (vector (get-in rock %2)))]  \n                            (map (juxt (partial applied-itria true)\n                                       (partial applied-itria false))\n                                 positions)))]\n        (->> rotations\n            (map triangles)\n            flatten\n            (apply max)\n            (#(when (< 1 %) %)))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":127,"code":"(fn calc [x]\n  (let [\n        ;; init : vectorof ints -> vectorof vectorof 0s/1s\n        ;; from vector of integer, creates the cross-section as an 2d array of\n        ;; 0's and 1's\n        ;; ex. [1 3 7 15 31] -> [[0 0 0 0 1] [0 0 0 1 1] [0 0 1 1 1] [0 1 1 1 1] [1 1 1 1 1]]\n        init (fn [v]\n               (let [l (apply max (map #(count (Integer/toString % 2)) v))]\n                 (into [] (map #(into []\n                                      (map (comp read-string str)\n                                           (seq (format (str \"%0\" l \"d\")\n                                                        (read-string (Integer/toString % 2)))))) v))))\n        cs (init x)\n\n        dir-map (let [id identity, d dec, i inc]\n                  {:n [d id], :s [i id], :w [id d], :e [id i],\n                   :ne [d i], :se [i i], :sw [i d], :nw [d d]})\n\n        dir-pairs [[:n :ne] [:n :e] [:ne :e] [:ne :se]\n                   [:e :se] [:e :s] [:se :s] [:se :sw]\n                   [:s :sw] [:s :w] [:sw :w] [:sw :nw]\n                   [:w :nw] [:w :n] [:nw :n] [:nw :ne]]]\n    (letfn [\n            ;; move : int int keyword -> coordinate\n            ;; returns next coordinate, given x y and direction\n            (move [y x dir]\n              (let [[fy fx] (dir dir-map)]\n                (vector (fy y) (fx x))))\n\n            ;; step : int int -> int\n            ;; given two ints, take 1 step close to 2nd #\n            ;; Example 1: x = 1 x2 = 3, returns 2\n            ;; Example 2: x = 1 x2 = 1, returns 1\n            ;; Example 3: x = 4 x2 = 1, return 3\n            (step [x x2]\n              (cond (< x x2) (inc x)\n                    (> x x2) (dec x)\n                    :else x))\n\n            ;; between : int int int int -> (listof coordinates)\n            ;; given two coordinates, return all coordinates between\n            ;; Excludes x0, y0 but Includes x1, y1\n            (between [y0 x0 y1 x1]\n              (cond (and (= x0 x1) (= y0 y1)) '()\n                    :else (let [nx (step x0 x1), ny (step y0 y1)]\n                            (cons [ny nx] (lazy-seq (between ny nx y1 x1))))))\n\n            ;; get-starting-coords : -> listof coordinates\n            ;; returns all coordinates where cell value is a 1 (potential start)\n            (get-starting-coords []\n              (loop [x 0, y 0, acc '()]\n                (cond (>= y (count cs)) acc\n                      (>= x (count (first cs))) (recur 0 (inc y) acc)\n                      :else (if (= 1 (get-in cs [y x]))\n                              (recur (inc x) y (cons [y x] acc))\n                              (recur (inc x) y acc)))))\n\n            ;; area : int int keyword keyword -> int or nil\n            ;; Given a starting coordinate (x,y) and 2 directions, return\n            ;; the area of the triangle (must have at least 3) or nil if no triangle\n            (area\n              ([y x dir1 dir2]\n                 (let [origin (get-in cs [y x])\n                       [y1 x1] (move y x dir1)\n                       [y2 x2] (move y x dir2)\n                       b (cons [y1 x1] (between y1 x1 y2 x2))\n                       c (map (partial get-in cs) b)]\n                   (if (every? (partial = 1) c)\n                     (area y1 x1 dir1 y2 x2 dir2 (inc (count c)))\n                     nil)))\n              ([y1 x1 dir1 y2 x2 dir2 a]\n                 (let [[ny1 nx1] (move y1 x1 dir1)\n                       [ny2 nx2] (move y2 x2 dir2)\n                       b (cons [ny1 nx1] (between ny1 nx1 ny2 nx2))\n                       c (map (partial get-in cs) b)]\n                   (if (every? (partial = 1) c)\n                     (recur ny1 nx1 dir1 ny2 nx2 dir2 (+ a (count c)))\n                     a))))\n\n            ;; get-max-area : int int -> int\n            ;; given x,y (coordinate), return max area triangle or nil\n            ;; get-max-area : -> int\n            (get-max-area\n              ([y x]\n                 (let [m (remove nil? (map #(area y x (nth % 0) (nth % 1)) dir-pairs))]\n                   (if (empty? m) nil (apply max m))))\n              ([]\n                 (let [m (remove nil? (map #(get-max-area (nth % 0) (nth % 1)) (get-starting-coords)))]\n                   (if (empty? m) nil (apply max m)))))]\n      (get-max-area))))","user":"538e36c7e4b0b51d73faae81"},{"problem":127,"code":"(fn triang [src]\n (letfn [\n\n(bits [n]\n (if (zero? n) \n  [0]\n  (loop [acc (list) work n]\n   (if (zero? work)\n    (vec acc)\n   (let [rst (quot work 2)\n         nxt (rem work 2) \n         newacc (conj acc nxt)]\n     (recur newacc rst) )))))\n\n(parse [ds]\n (vec (map bits ds)))\n\n(prep-0 [vs]\n (let [wd (reduce max (map count vs))]\n   (vec \n    (map \n     (fn [v] \n      (let [w (count v)]\n       (if (= wd w)\n        v\n        (into (vec (repeat (- wd w) 0)) v) )))\n     vs))))\n\n(transp [vv]\n (loop [acc [] work vv]\n  (if (empty? (first work))\n   acc\n   (let \n    [fst (vec (map first work))\n     rst (map rest work)\n     newacc (conj acc fst)]\n    (recur newacc rst)))))\n\n(rev-lines [vv]\n (vec (map (comp vec reverse) vv)))\n\n(all-mtrxs [mtrx]\n (let [mt (transp mtrx)\n       mrev (rev-lines mtrx)\n       mtrev (rev-lines mt)] \n   [mtrx mrev mt mtrev]))\n\n(ok? [x] (= 1 x))\n\n(head-ok-cnt [v]\n (count (take-while ok? v)))\n\n(max-slice [vv]\n (vec (map head-ok-cnt vv)))\n\n(slices [vv]\n (loop [acc [] work vv]\n  (if (< (count (first work)) 2) \n   acc\n   (let [slc (max-slice work)\n         rst (vec (map (comp vec rest) work))\n         newacc (conj acc slc)]\n    (recur newacc rst)))))\n\n(all-slices [vv]\n (let [vvs (all-mtrxs vv)]\n  (reduce (fn [acc b] (into acc (slices b))) [] vvs)))\n\n(tri-patts [n]\n (if (<= n 1) \n  (list) \n  (let \n    [ttt (vec (take n (rest (range))))\n     rrr (vec (reverse ttt))\n     two-t [ttt rrr]\n     odd-n (if (odd? n) n (dec n))\n     th (quot (inc odd-n) 2)\n     t-half (vec (take th (rest (range))))  \n     w-tri \n      (if (< th 2)\n        []\n        (into t-half (reverse (pop t-half))))]\n    (if (empty? w-tri)\n     two-t\n     (conj two-t w-tri)))))\n\n(chunks [n v]\n (loop [acc [] work v]\n  (if (< (count work) n) \n   acc\n   (recur (conj acc (vec (take n work))) (rest work)))))\n\n(all-patts [n]\n (vec \n  (distinct\n   (loop [acc [] cnt n]\n    (if (< cnt 2) \n     acc\n     (recur (into acc (tri-patts cnt)) (dec cnt)))))))\n\n(cost [vt]\n (reduce + vt))\n\n(zip-le? [va vb]\n (and \n  (<= (count va) (count vb))\n  (every? (partial apply <=) (map vector va vb))))\n\n(v-patt? [vline vp]\n (let [pln (count vp)\n       vs (chunks pln vline)]\n  (not\n   (not-any? (partial zip-le? vp) vs))))\n\n(search-patts [min-cost vn]\n (let [ln (count vn)\n       patts (all-patts ln)\n       use-patts (filter #(> (cost %) min-cost) patts)\n       founds (filter (partial v-patt? vn) use-patts)\n       costs (map cost founds) \n       max-cost \n        (if (empty? costs) \n         min-cost\n         (reduce max costs)) ] \n   max-cost ))\n\n(reed [slcs]\n (loop [max-c 0 work slcs]\n  (if (empty? work) \n    max-c\n    (let [fst (first work)\n          rst (rest work)\n          found (search-patts max-c fst)]\n     (recur (max found max-c) rst))))) ]\n\n   (-> (parse src)\n       (prep-0 ,,,)\n       (all-slices ,,,)\n       (reed ,,,) \n       (#(if (zero? %) nil %) ,,,)) ))","user":"57f9011ee4b0d3187e900935"},{"problem":127,"code":"(fn [inputs]\n   (let [coords (->> inputs\n                     (map #(Integer/toBinaryString %))\n                     (map reverse)\n                     (map-indexed (fn [y v] (map-indexed #(if (= \\1 %2) [%1 y]) v)))\n                     (mapcat identity)\n                     (filter identity))\n         c-coords (count coords)\n         valid-edge? (fn [[ax ay]\n                          [bx by]]\n                       (or (= ax bx)\n                           (= ay by)\n                           (= (- (max ax bx) (min ax bx))\n                              (- (max ay by) (min ay by)))))\n         gradient (fn [[ax ay] [bx by]]\n                    (if (zero? (- by ay)) \n                      nil\n                      (/ (- bx ax) (- by ay))))\n         triangle? (fn [[a b c]]\n                     (and (valid-edge? a b)\n                          (valid-edge? a c)\n                          (valid-edge? b c)\n                          (not= (gradient a b) (gradient a c))))\n         m-range (fn [a b] (concat (range a b (if (> a b) -1 1)) [b]))\n         line (fn [[ax ay]\n                   [bx by]]\n                (cond\n                  (= ax bx) (map vector (repeat ax) (m-range ay by))\n                  (= ay by) (map vector (m-range ax bx) (repeat ay))\n                  :else (map vector (m-range ax bx) (m-range ay by))))\n         fill-2-point (fn [a b c]\n                        (set (mapcat\n                               (fn [l r] (line l r))\n                               (line a b)\n                               (line a c))))\n         fill (fn [[a b c]]\n                (clojure.set/union (fill-2-point a b c)\n                                   (fill-2-point b a c)))]\n     (->> (for [ai (range c-coords)\n                bi (range (inc ai) c-coords)\n                ci (range (inc bi) c-coords)]\n            [(nth coords ai) (nth coords bi) (nth coords ci)])\n          (filter triangle?)\n          (map fill)\n          (filter (partial clojure.set/superset? (set coords)))\n          (map count)\n          (reduce (fn\n                    ([a b] (max a b))\n                    ([] nil))))))","user":"5db0172be4b0f8c104ccfc96"},{"problem":127,"code":"(fn [data]\n  (let [rows (vec (map #(vec (map {\\1 true \\0 false} (Integer/toBinaryString %))) data))\n        longest (apply max (map count rows))\n        at (fn [[row col]] \n             (let [row (vec (get rows row))]\n               (get row (- col (- longest (count row))))))\n        move-diag (fn [dy dx line] \n                    (conj (vec (map (fn [[y x]] [(+ y dy) x]) line))\n                          [((last line) 0) (+ dx ((last line) 1))]))\n        flip (fn [line] (mapv #(vec (rseq %)) line))\n        move-ortho (fn [d xy line] ; move n, e, s, w\n                     (let [line (if (= :x xy) (flip line) line) ; horiz = vertical but flipped\n                           y (+ ((first line) 0) d)\n                           line (concat [[y (dec ((first line) 1))]]\n                                        (vec (map (fn [[_ x]] [y x]) line))\n                                        [[y (inc ((last line) 1))]])]\n                       (if (= :x xy) (flip line) line)))\n        moves [(partial move-diag -1 1)   (partial move-diag -1 -1)   ; ne, nw\n               (partial move-diag 1 1)    (partial move-diag 1 -1)    ; se, sw\n               (partial move-ortho -1 :y) (partial move-ortho 1 :x)   ; n,  e\n               (partial move-ortho 1 :y)  (partial move-ortho -1 :x)] ; s,  w\n        explore (fn [coords move] \n                  (apply + (map count (take-while\n                                       #(every? identity (map at %))\n                                       (iterate move [coords])))))\n        explore-from (fn [coords]\n                       (apply max (map #(explore coords %) moves)))\n        largest (reduce max 0 (for [y (range (count rows))\n                                    x (range longest)\n                                    :let [size (explore-from [y x])]\n                                    :when (> size 1)] \n                                size))]\n    (if (< largest 2) nil largest)))","user":"54febf4be4b07d26eda61d45"},{"code":"(letfn\n    [(divmod [n d] [(quot n d) (rem n d)]) \n     (binary [n] (loop [acc () n n]\n                   (if (#{0 1} n)\n                     (conj acc n)\n                     (let [[q r] (divmod n 2)] (recur (conj acc r) q))))) \n     (max-len [ss] (reduce max (map count ss))) \n     (left-pad [N x s]\n       (let [n (count s)]\n         (vec (concat (repeat (- N n) x) s)))) \n     (bitmap [nn] (let [bin (map binary nn)\n                             N (max-len bin)]\n                         (vec (map #(left-pad N 0 %) bin))))\n     (rotate [bmp] (vec (apply map (comp vec reverse list) bmp))) ;;90 cw\n     (find-iso-right [bmp rindex [s e]] ;; right-sloping isoceles\n       (let [row (nth bmp rindex)]\n         (when (< e (count row))\n           (when (every? #(= 1 %) (subvec row s (inc e)))\n             [s (inc e)]))))\n     (find-iso-left [bmp rindex [s e]] ;; left-sloping isoceles\n       (let [row (nth bmp rindex)]\n         (when (> s 0)\n           (when (every? #(= 1 %) (subvec row (dec s) e))\n             [(dec s) e]))))\n     (find-iso-both [bmp rindex [s e]] ;; \"pyramid\" type isoceles\n       (let [row (nth bmp rindex)]\n         (when (and (> s 0) (< e (count row))\n                    (every? #(= 1 %) (subvec row (dec s) (inc e))))\n           [(dec s) (inc e)])))\n     (right-area [base] ;; 1 + 2 + 3 + ...\n       (/ (* base (inc base)) 2))\n     (pyramid-area [base] ;; 1 + 3 + 5 + ... \n       (let [x (/ (inc base) 2)] (* x x)))\n     (seed [bmp rindex]\n       (let [row (nth bmp rindex)]\n         (filter vector?\n           (map-indexed (fn [i x] (when (= x 1) [i (inc i)])) row))))\n     (step [func sols bmp rindex]\n       (let [prev-row-sols (get sols (dec rindex))\n             new-sols (concat\n                        (seed bmp rindex)\n                        (map (partial func bmp rindex) prev-row-sols))]\n         (assoc sols rindex (filter vector? new-sols))))\n     (all-sols [func bmp]\n       (loop [sols {0 (seed bmp 0)} rindex 1]\n         (if (= rindex (count bmp)) sols\n           ;(empty? sols) (recur (seed bmp) (subvec bmp 1))\n           (recur (step func sols bmp rindex)\n                  (inc rindex)))))\n     (all-sols-rot [func bmp]\n       (apply merge-with concat\n               (map (partial all-sols func)\n                    (take 4 (iterate rotate bmp)))))\n     (sol-length [[s e]] (- e s))\n     (sol-areas [areafn sols]\n       (map (comp areafn sol-length) (apply concat (vals sols))))]\n(comment \n    \"This solution is doing at least twice as much work as it could, \n    but the real issue is that the find-iso-* fns are O(N_cols^2).\n    I think a clever person with time on their hands could bring it \n    down to O(N_cols).\")\n  (fn [nums]\n    (let [bmp (bitmap nums)\n          left (all-sols-rot find-iso-left bmp)\n          right (all-sols-rot find-iso-right bmp)\n          both (all-sols-rot find-iso-both bmp)\n          largest-area (apply max\n                         (concat (sol-areas right-area left)\n                                 (sol-areas right-area right)\n                                 (sol-areas pyramid-area both)))]\n      (if (> largest-area 1) largest-area nil))))","problem":127,"user":"4ed188c8535d44c135fd68cf"},{"problem":127,"code":"(comp second (fn largest-isoscele [layers]\n  (let [binary-digits (fn [n] (->> [[] n] \n                                   (iterate (fn [x]\n                                              (when x\n                                                (let [[digits remainder] x]\n                                                  (when-not (= 0 remainder)\n                                                    [(cons (mod remainder 2) digits) \n                                                     (quot remainder 2)])))))\n                                   (take-while (complement nil?))\n                                   last\n                                   first))\n        unequal-cross-section (map binary-digits layers)\n        max-digits (apply max (map count unequal-cross-section))\n        pad (fn pad [coll] (concat (repeat (- max-digits (count coll)) 0) coll))\n        cross-section (vec (map (comp vec pad) unequal-cross-section))\n        directed-inclusive-range (fn [start end]\n                                   (if (< start end)\n                                     (range start (inc end) 1)\n                                     (range start (dec end) -1)))\n        connection-line (fn connection-line [[from-row from-col] [to-row to-col]]\n                          (cond\n                            (= from-row to-row)\n                            (map vector \n                                 (repeat from-row) \n                                 (directed-inclusive-range from-col to-col))\n\n                            (= from-col to-col)\n                            (map vector \n                                 (directed-inclusive-range from-row to-row) \n                                 (repeat from-col))\n\n                            (or (= (- to-row from-row) (- to-col from-col))\n                                (= (- to-row from-row) (- (- to-col from-col))))\n                            (map vector \n                                 (directed-inclusive-range from-row to-row) \n                                 (directed-inclusive-range from-col to-col))))\n        fits-line? (fn fits-line? [line] (not (some (partial contains? #{0 nil}) \n                                                    (map (partial get-in cross-section) line))))\n        orientation-increment-map {:top          (fn [[srow scol] [erow ecol]] \n                                                    [[(inc srow) (dec scol)] \n                                                     [(inc erow) (inc ecol)]])\n                                   :top-right    (fn [[srow scol] [erow ecol]] \n                                                    [[srow (dec scol)] \n                                                     [(inc erow) ecol]])\n                                   :right        (fn [[srow scol] [erow ecol]] \n                                                    [[(dec srow) (dec scol)] \n                                                     [(dec erow) (inc ecol)]])\n                                   :bottom-right (fn [[srow scol] [erow ecol]] \n                                                    [[(dec srow) scol] \n                                                     [erow (dec ecol)]])\n                                   :bottom       (fn [[srow scol] [erow ecol]] \n                                                    [[(dec srow) (inc scol)] \n                                                     [(dec erow) (dec ecol)]])\n                                   :bottom-left  (fn [[srow scol] [erow ecol]] \n                                                    [[srow (inc scol)] \n                                                     [(dec erow) ecol]])\n                                   :left         (fn [[srow scol] [erow ecol]] \n                                                    [[(inc srow) (inc scol)] \n                                                     [(dec erow) (inc ecol)]])\n                                   :top-left     (fn [[srow scol] [erow ecol]] \n                                                    [[(inc srow) scol] \n                                                     [erow (inc ecol)]])}\n        isoscele-size (comp (partial apply +) (partial map count))\n        largest-isoscele-oriented (fn [position orientation] \n                                    (->> [[position]]\n                                         (iterate (fn [isoscele]\n                                                    (let [previous-start (first (last isoscele))\n                                                          previous-end (last (last isoscele))]\n                                                      (->> ((orientation-increment-map orientation) \n                                                            previous-start \n                                                            previous-end)\n                                                           (apply connection-line)\n                                                           (conj isoscele)))))\n                                         (take-while (comp fits-line? last))\n                                         last))\n        largest-isoscele-at (fn [position]\n                              (apply max-key isoscele-size \n                                (map (partial largest-isoscele-oriented position) \n                                     (keys orientation-increment-map))))]\n    (let [isoscele (apply max-key isoscele-size \n                     (map largest-isoscele-at \n                          (for [row (range (count cross-section)) \n                                col (range max-digits)] \n                            [row col])))]\n      (when (> (isoscele-size isoscele) 1)\n        [isoscele (isoscele-size isoscele)])))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn largest-tri [bitmap]\n  (let [log2 #(if (zero? %) 0 (int (/ (Math/log %)  (Math/log 2))))\n        dist (fn [[ax ay] [bx by]]\n               (Math/sqrt\n                 (+ (Math/pow (- ax bx) 2)\n                    (Math/pow (- ay by) 2))))\n        area (fn [[ax ay] [bx by] [cx cy]]\n               (Math/abs (double (/ (+ (* ax (- by cy))\n                                       (* bx (- cy ay))\n                                       (* cx (- ay by))) 2))))\n        isosceles? (fn [p0 p1 p2]\n                     (let [d0 (dist p0 p1)\n                           d1 (dist p1 p2)\n                           d2 (dist p2 p0)\n                           has-eq? (comp not distinct?)\n                           points (list p0 p1 p2)]\n                       (and (not-any? zero? [d0 d1 d2])\n                            (has-eq? d0 d1 d2)\n                            (or (apply has-eq? (map first points))\n                                (apply has-eq? (map second points)))\n                            (pos? (area p0 p1 p2)))))\n        grid  #(pos? (bit-and (bitmap %) (bit-shift-left 1 %2)))\n        pure? #(every? (partial apply grid) %)\n        square-points (fn [points]\n                        (let [ys (map first points)\n                              xs (map second points)\n                              t (apply min ys) b (apply max ys)\n                              l (apply max xs) r (apply min xs)]\n                          (for [i (range t (inc b)) j (range r (inc l))]\n                            [i j])))\n        in-tri? (fn [p [a b c]]\n                  (= (area a b c)\n                     (+ (area p a b) (area p b c) (area p a c))))\n        tri-points (fn [points]\n                     (filter #(in-tri? % points)\n                             (square-points points)))\n        height (count bitmap)\n        width (inc (apply max (map log2 bitmap)))\n        ore-points (vec (for [i (range height) j (range width)\n                              :when (grid i j)] [i j]))\n        tris (let [n (count ore-points)]\n               (for [i (range n) j (range i n) k (range j n)\n                     :let [a (ore-points i) b (ore-points j) c (ore-points k)]\n                     :when (isosceles? a b c)] [a b c]))\n        full-tris (map tri-points tris)\n        sorted-tris (sort-by count > full-tris)]\n    (if-let [pure-tri (first (filter pure? sorted-tris))]\n      (count pure-tri))))","problem":127,"user":"4f6160a7e4b0defedf855fbe"},{"problem":127,"code":"(fn [mine]\n  (letfn [(bin-parse [bin]\n                     (loop [start []\n                            ite bin]\n                       (if (zero? ite) start\n                         (recur (cons (if (odd? ite) 1 0) start)\n                                (int (/ ite 2)))\n                         )))\n          \n          (parse-mine [mine] \n                      (let [p (map bin-parse mine)\n                            lens (map count p)\n                            max-len (apply max lens)]\n                        (letfn [(pad [v] \n                                     (concat (repeat (- max-len (count v)) 0) v))]\n                          (map pad p)\n                          )))\n          \n          (try-type1 [boy r c size]\n                    (let [field-coords (for [_r (range r (+ r size)) _c (range c (+ c size))] [_r _c])\n                          co (filter #(< (+ (first %) (second %)) (+ r c size)) field-coords)\n                          cell-values (map #(nth (nth boy (first %)) (second %)) co)\n                          no-zeros (empty? (filter zero? cell-values))]\n                      (if no-zeros (/ (* size (inc size)) 2) 0)))\n          \n          (try-type2 [girl r c height]\n                        (let [co (loop [i 0\n                                        co []]\n                                   (if (= i height) co\n                                     (recur (inc i)\n                                            (concat (map vector \n                                                         (repeat (inc (* 2 i)) (+ i r))\n                                                         (map (partial + c) (range (- height i 1) (+ height i 1)))\n                                                         )\n                                                    co)\n                                            )))\n                              cell-values (map #(nth (nth girl (first %)) (second %)) co)\n                              no-zeros (empty? (filter zero? cell-values))]\n                          (if no-zeros (* height height) 0)))                          \n          \n          (try-type1s [field]\n                     (let [n (count field)\n                           m (count (first field))\n                           sizes (range 2 (inc (min n m)))\n                           profiles (map #(map (fn [param] (conj param %))\n                                               (for [r (range (inc (- n %))) c (range (inc (- m %)))] [r c])) sizes)\n                           profiles_ (apply concat profiles)]\n                       (if (empty? profiles_) 0\n                         (apply max (map #(apply (partial try-type1 field) %) profiles_)))\n                       ))\n                \n          (try-type2s [field]\n                         (let [n (count field)\n                               m (count (first field))\n                               max-size (min n (int (/ (inc m) 2)))\n                               sizes (range 2 (inc max-size))\n                               profiles (map #(map (fn [param] (conj param %))\n                                                   (for [r (range (inc (- n %)))\n                                                         c (range (inc (- m (dec (* % 2)))))]\n                                                     [r c]) \n                                                   ) sizes)\n                               profiles_ (apply concat profiles)]\n                           (if (empty? profiles_) 0 \n                             (apply max (map #(apply (partial try-type2 field) %) profiles_)))\n                           ))\n          \n          (rotate [field] (apply map vector (map reverse field)))]\n    \n    (let [pm (parse-mine mine)\n          wizs (take 4 (iterate rotate pm))\n          type1 (apply max (map try-type1s wizs))\n          type2 (apply max (map try-type2s wizs))\n          re (max type1 type2)]\n      \n      (if (zero? re) nil re)\n      \n      )))","user":"52faec2ee4b047fd55837004"},{"code":"(fn best-miner [xs]\n  (let [into-map-row (fn [v w]\n                       (let [s (Integer/toBinaryString v)\n                             slen (.length s)\n                             s (if (< slen w)\n                                 (str (apply str (repeat (- w slen) \\0)) s)\n                                 s)]\n                         (map #(if (= \\0 %) 0 1) s)))\n        create-map (fn [xs]\n                     (let [w (.length (Integer/toBinaryString (apply max xs)))]\n                       (map #(into-map-row % w) xs)))\n        shift-left (fn [xs] (concat (drop 1 xs) [0]))\n        shift-right (fn [xs] (concat [0] (drop-last xs)))\n        merge-zero-one (fn [& xs] (if (some #(= 1 %) xs) 1 0))\n        next-tri-lr-row (fn [xs]\n                          (let [nrow (map merge-zero-one (shift-left xs) (shift-right xs) xs)\n                                cur-sum (apply + xs)\n                                next-sum (apply + nrow)]\n                            (if (== (+ cur-sum 2) next-sum)\n                              nrow\n                              xs)))\n        next-tri-l-row  (fn [xs] (map merge-zero-one (shift-left xs) xs))\n        next-tri-r-row (fn  [xs] (map merge-zero-one (shift-right xs) xs))\n        separate-row (fn  [xs]\n                       (let [empty-row (vec (repeat (count xs) 0))]\n                         (->> xs\n                           (map-indexed #(if (zero? %2) nil (assoc empty-row % 1)))\n                           (filter (comp not nil?)))\n                         ))\n\n        triangle-row-generator (fn  [next-gen-func]\n                                 (fn gen [base]\n                                   (let [next (next-gen-func base)]\n                                     (if (= base next) [base]\n                                       (cons base (lazy-seq (gen next)))))))\n        triangle-lr-rows (triangle-row-generator next-tri-lr-row)\n        triangle-l-rows (triangle-row-generator next-tri-l-row)\n        triangle-r-rows (triangle-row-generator next-tri-r-row)\n        bit-and-row (fn [r1 r2] (map bit-and r1 r2))\n        bit-and-mine-map (fn [m1 m2]\n          (->> m2\n            (map list m1)\n            (map (partial apply bit-and-row))\n            (map #(if (= % %2) % 0) m1))\n          )\n\n        compute-area (fn [xs]\n                       (let [rows (first (partition-by sequential? xs))]\n                         (apply + (flatten rows))))\n        max-compute-area (fn  [mine-map base]\n                           (let [compute-func (fn [f]\n                                                (fn [b]\n                                                  (compute-area (bit-and-mine-map (f b) mine-map))))\n                                 compute-lr-func (compute-func triangle-lr-rows)\n                                 compute-r-func (compute-func triangle-l-rows)\n                                 compute-l-func (compute-func triangle-r-rows)]\n                             (max (compute-lr-func base)\n                               (compute-l-func base)\n                               (compute-r-func base))))\n        mine (fn [mine-map max-minerals]\n               (if (empty? mine-map)\n                 max-minerals\n                 (let [head (first mine-map)\n                       head-rows (separate-row head)\n                       max-minerals (apply max max-minerals (map (fn [row] (max-compute-area mine-map row)) head-rows))]\n                   (recur (rest mine-map) max-minerals)\n                   )))\n        m (create-map xs)\n        max-area (max\n                   (mine m 0)\n                   (mine (reverse m) 0)\n                   (mine (apply map list m) 0)\n                   (mine (reverse (apply map list m)) 0)\n                   )]\n    (if (>= max-area 3) max-area)\n    ))","problem":127,"user":"513fab65e4b00f13ea1bd891"},{"problem":127,"code":"(fn [ii]\n  (letfn [(ii->bvs [ii]\n            (let [n (count (Integer/toString (apply max ii) 2))]\n              (vec\n                (for [i ii]\n                  (vec\n                    (for [place (reverse (range n))]\n                      ({true 1, false 0} (bit-test i place))))))))\n\n          (fliph [bvs] (mapv (comp vec reverse) bvs))\n          (flipd [bvs] (apply map vector bvs))\n          (rotate [bvs] (-> bvs flipd fliph))\n          (orientations [bvs] (take 4 (iterate rotate bvs)))\n\n          (type1-tri-at [bvs i j]\n            (when (and (< i (count bvs))\n                       (< j (count (first bvs)))\n                       (= 1 (get-in bvs [i j])))\n              (loop [area 1\n                     level 1]\n                (if (every? #(= 1 (get-in bvs %))\n                            (for [x (range (inc level))]\n                              [(+ i x) (+ j (- level x))]))\n                  (recur (+ area level 1) (inc level))\n                  area))))\n\n          (type2-tri-at [bvs i j]\n            (when (and (<   i (dec (count bvs)))\n                       (< 0 j (dec (count (first bvs))))\n                       (= 1 (get-in bvs [i j])))\n              (loop [area 1\n                     level 1]\n                (if (every? #(= 1 (get-in bvs %))\n                            (for [x (range (- level) (inc level))]\n                              [(+ i level) (+ j x)]))\n                  (recur (+ area 1 (* level 2)) (inc level))\n                  area))))\n\n          (type1-tris [bvs]\n            (for [i (range (dec (count bvs)))\n                  j (range (dec (count (first bvs))))\n                  :let [area (type1-tri-at bvs i j)]\n                  :when (and area (>= area 3))]\n              area))\n\n          (type2-tris [bvs]\n            (for [i (range (dec (count bvs)))\n                  j (range 1 (dec (count (first bvs))))\n                  :let [area (type2-tri-at bvs i j)]\n                  :when (and area (>= area 3))]\n              area))\n\n          (safe-max [xs]\n            (let [xs (remove nil? xs)]\n              (if (and xs (not-empty xs))\n                (apply max xs)\n                nil)))\n\n          (max-of [f bvs]\n            (safe-max (mapcat f (orientations bvs))))]\n\n    (let [bvs (ii->bvs ii)]\n      (safe-max [(max-of type1-tris bvs)\n                 (max-of type2-tris bvs)]))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":127,"code":"(fn [nums]\n    (let [n  (map\n               (fn d [x]\n                 (if (= x 0)\n                   []\n                   (conj (d (quot x 2)) (rem x 2))))\n               nums)\n          h  (count n)\n          w  (reduce max (map count n))\n          n  (vec (map #(vec (concat (repeat (- w (count %)) 0) %)) n))\n          dirs [[1 -1 0] [1 -1 1] [1 0 1]\n              [-1 -1 0] [-1 -1 1] [-1 0 1]]\n          f  (fn [m board w h]\n               (apply\n                 max\n                 (for [r (range h) s (range w) [a b c] m]\n                   (loop [s s\n                          e (inc s)\n                          r r\n                          i 0]\n                     (if (and\n                           (< -1 r h) (< -1 s w) (< -1 e (inc w))\n                           (apply = 1 (subvec (nth board r) s e)))\n                       (recur (+ s b) (+ e c) (+ r a) (+ i (- e s)))\n                       i)))))\n          i (max (f dirs n w h) (f dirs (apply mapv vector n) h w))]\n      (if (>= i 3) i)))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [mine] (let [p (fn [x] (loop [a 1 b 0] (if (>= a x) b (recur (* 2 a) (inc b)))))\n                  cols (p (apply max (flatten mine)))\n                  fill (fn fill [x] (if (>= (count x) cols) (vec x) (fill (cons 0 x))))\n                  f (fn [x] (loop [n x d 1 r '()] (if (= 0 n) r (recur (quot n 2) (* 2 d) (if (= 1 (mod n 2)) (conj r 1) (conj r 0))))))\n                  solve (fn [grid]\n                          (let [cols (count (first grid))\n                                rows (count grid)\n                                tr (fn tr [coord s g]\n                                     (let [[r c] coord\n                                           max_r (+ r s)\n                                           max_c (+ c s)\n                                           size (fn [x] (/ (* x (inc x)) 2))]\n                                       (if (or (> max_r rows) (> max_c cols))\n                                         (size (dec s))\n                                         (let [x (subvec (get g (+ r (dec s))) c max_c)]\n                                           (if (not= s (reduce + x)) (size (dec s)) (tr coord (inc s) g))))))\n                                max_tr (fn [g] (for [x (range cols) y (range rows)] (tr [y x] 1 g)))\n                                tr2 (fn tr2 [coord s g]\n                                      (let [[r c] coord\n                                            max_r (+ r s)\n                                            max_c (+ c s)\n                                            min_c (- c (dec s))\n                                            size (fn [x] (* x x))]\n                                        (if (or (> max_r rows) (> max_c cols) (< min_c 0))\n                                          (size (dec s))\n                                          (let [x (subvec (get g (+ r (dec s))) min_c max_c)]\n                                            (if (not= (- (* 2 s) 1) (reduce + x)) (size (dec s)) (tr2 coord (inc s) g))))))\n                                max_tr2 (fn [g] (for [x (range cols) y (range rows)] (tr2 [y x] 1 g)))]\n                            (apply max (flatten [(max_tr grid) (max_tr2 grid)]))))\n                  g (vec (map fill (map f mine)))\n                  g1 (vec (map vec (map reverse g)))\n                  g2 (vec (map fill (map f (reverse mine))))\n                  g3 (vec (map vec (map reverse g2)))\n                  g4 (vec (apply map vector g))\n                  g5 (vec (map vec (map reverse g4)))\n                  g6 (vec (reverse g4))\n                  g7 (vec (map vec (map reverse g6)))\n                  result (apply max (map solve [g g1 g2 g3 g4 g5 g6 g7]))]\n              (cond (< result 3) nil :else result)))","problem":127,"user":"4eb13d60535d7eef3080733f"},{"code":"(letfn [(areas [board]\n          (let [height    (count board)\n                width     (count (first board))\n                legal?    (fn [[x y]] (and (<= 0 x height) (<= 0 y width)))\n                mineral? #(and (legal? %) (= \\1 (get-in board %)))\n                minerals  (for [i (range height), j (range width)\n                                :when (mineral? [i j])] [i j])\n                move      (fn [& dirs] #(for [p %, d dirs] (map + p d)))\n                area-at   (fn [f g]\n                            (fn [pos]\n                              (->> (iterate f [pos])\n                                   (take-while #(every? mineral? %)) count g)))\n                vert-area (area-at (move [1 -1] [1 0] [1 1]) #(* % %))\n                diag-area (area-at (move [0  1] [1 0]) #(/ (* % (inc %)) 2))]\n            (mapcat (juxt vert-area diag-area) minerals)))]\n  (fn love-triangle [coll]\n    (let [board        (map #(Integer/toBinaryString %) coll)\n          max-bits     (apply max (map count board))\n          padding     #(repeat (- max-bits (count %)) \\0)\n          padded-board (map #(vec (concat (padding %) %)) board)\n          rotate      #(vec (apply map vector (reverse %)))\n          boards       (take 4 (iterate rotate padded-board))\n          max-area     (apply max (mapcat areas boards))]\n      (if (> max-area 1) max-area nil))))","problem":127,"user":"50586354e4b06522596eba78"},{"problem":127,"code":"(fn [t]\n  (let [w (apply max (map #(-> % Integer/toBinaryString count) t))\n        h (count t)\n        n (max w h)\n        rev #(apply mapv str (reverse %))\n        i->s #(->> %\n                   (+ (bit-shift-left 1 w))\n                   Integer/toBinaryString\n                   rest\n                   (apply str))\n        s->i #(Integer/parseInt % 2)\n        rot (->> (mapv i->s t)\n                 (iterate rev)\n                 (take 4)\n                 (mapv #(mapv s->i %)))\n        mask #(dec (bit-shift-left 1 %))\n        sz-fn #(/ (* (inc %) %) 2)\n        fns [[identity sz-fn]\n             [reverse sz-fn]\n             [#(concat % (-> % reverse rest)) #(+ (sz-fn (dec %)) (sz-fn %))]]\n        matches (for [t rot\n                      mx (range 2 (inc n))\n                      :let [base (->> mx inc (range 1) (mapv mask))]\n                      [cand-fn sz-fn] fns\n                      :let [c (cand-fn base) sz (sz-fn mx)]\n                      sk (-> (- (count t) (count c)) inc range)\n                      sh (range n)\n                      :let [t' (->> t\n                                    (drop sk)\n                                    (mapv #(bit-shift-right % sh)))]\n                      :when (= c (mapv bit-and c t'))]\n                  sz)]\n    (if (-> matches count pos?) (apply max matches))))","user":"514c2d05e4b02b8cbb2a9278"},{"problem":127,"code":"(fn [rows]\n    (let [rot (fn [coll]\n                (apply mapv #(into [] %&)\n                       (reverse coll)))\n          nums (map #(Integer/toString % 2) rows)\n          c (apply max (count rows) (map count nums))\n          b (map #(apply str (conj (vec (repeat (- c (count %)) 0)) %)) nums)\n          bs (take 4 (drop 1 (iterate rot b)))\n          valid-l? (fn [b x y w]\n                     (let* [G__1597 (get b x) G__1597 (if (clojure.core/nil? G__1597) nil (clojure.core/->> G__1597 (drop y))) G__1597 (if (clojure.core/nil? G__1597) nil (clojure.core/->> G__1597 (take w))) G__1597 (if (clojure.core/nil? G__1597) nil (clojure.core/->> G__1597 ((fn* [p1__1594#] (when (= w (count p1__1594#)) p1__1594#)))))] (if (clojure.core/nil? G__1597) nil (clojure.core/->> G__1597 (apply = \\1)))))\n          L (fn L\n              ([b x y] (L b x y 1 0))\n              ([b x y w n]\n               (if (valid-l? b x y w)\n                 (L b (inc x) y (inc w) (+ n w))\n                 n)))\n          valid-d? (fn [b x y h]\n                     (let* [G__1593 b G__1593 (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 (drop (+ x (/ (dec h) 2))))) G__1593 (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 (take (/ (dec h) 2)))) G__1593 (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 reverse)) G__1593 (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 (map-indexed (fn [i r] (->> r (drop (+ i y)) (take 2)))))) G__1593 (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 (apply concat))) G__1593 (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 ((fn* [p1__1590#] (when (= (dec h) (count p1__1590#)) p1__1590#)))))] (if (clojure.core/nil? G__1593) nil (clojure.core/->> G__1593 (apply = \\1 (get-in b [(+ x h -1) y]))))))\n          D (fn D\n              ([b x y] (D b x y 1 0))\n              ([b x y h n]\n               (if (valid-d? b x y h)\n                 (D b x y (+ 2 h) (+ n h))\n                 n)))\n          largest-from (fn [b x y]\n                         (max (L b x y)\n                              (D b x y)))]\n      (->> (for [b bs\n                 x (range (count b))\n                 y (range (count (b x)))]\n             (largest-from b x y))\n           doall\n           (apply max)\n           (#(cond\n               (< % 3) nil\n               :else %)))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":127,"code":"(fn love-triangle [ns]\n  (letfn [\n          (cell \n            ([nss [i j]] (cell nss i j))\n            ([nss i j]\n              (get (get nss j) i)))\n          \n          (exponent [n] (int (/ (Math/log n) (Math/log 2))))\n          \n          (to-binary  \n            ([n] \n              (if (zero? n)\n                [0]\n                (to-binary [] n (exponent n))))\n            \n            ([acc n i]\n              (if (< i 0)\n                acc                  \n                (let [x (Math/pow 2 i)]\n                  (if (>= n x)\n                    (to-binary (conj acc 1) (- n x) (dec i))\n                    (to-binary (conj acc 0) n (dec i)))))))\n          \n          (pad \n            ([xs]\n              (let [i (reduce max (map count xs))]\n                (vec (map #(pad % i) xs))))\n            \n            ([xs i]\n              (if (>= (count xs) i)\n                xs\n                (vec (pad (cons 0 xs) i)))))\n          \n          (move [xs fj]\n            (let [j (fj (last (last xs)))] \n              (vec (map (fn [[i _]] [i j]) xs))))\n          \n          (move-up [xs] (move xs dec))\n          \n          (move-down [xs] (move xs inc))\n          \n          (add-left [xs]\n            (let [c (first xs)\n                  i (first c)\n                  j (last c)]                     \n              (vec (cons [(dec i) j] xs))))       \n          \n          (add-right [xs]\n            (let [c (last xs)\n                  i (first c)\n                  j (last c)]                     \n              (vec (conj xs [(inc i) j]))))\n          \n          (add-both [xs] (add-right (add-left xs)))\n          \n          (valid? [nss xs c]\n            (= (count (filter #(= (cell nss %) c) xs)) (count xs)))\n          \n          (expand \n            ([nss xs fm fa]                 \n              (expand nss xs fm fa (cell nss (first (first xs)))))\n            \n            ([nss xs fm fa c]\n              (let [nx (fa (fm (last xs)))]  \n                (if (not (valid? nss nx c))\n                  xs\n                  (expand nss (conj xs nx) fm fa c)))))\n          \n          (eval-cell [nss [i j]]              \n            (vec \n              (filter #(> (count %) 1)\n                      (for [fm [move-down move-up] fa [add-left add-right add-both]]\n                        (expand nss [[[i j]]] fm fa)))))\n          \n          (triangles [nss]\n            (let [w (count (first nss))\n                  h (count nss)]\n              (reduce concat\n                      (reduce \n                        (fn [acc i]\n                          (reduce \n                            (fn [acc j]\n                              (conj acc (eval-cell nss [i j]))) acc (range h))) \n                        [] (range w)))))\n          \n          (max-len [xss]\n            (if (empty? xss)\n              0\n              (reduce max \n                      (map #(count (reduce concat %)) xss))))\n          \n          (merge-triangles?  [t1 t2] \n            (and (not= (first t1) (first t2))\n                 (= (first (first (first t1))) (first (first (first t2))))\n                 (= (last t1) (last t2))))\n          \n          (merge-triangles [t1 t2]\n            (vec (concat t1 (vec (butlast t2)))))\n          \n          (merge-result [nss]\n            (for [t1 nss\n                  t2 nss :when (merge-triangles? t1 t2)]\n              (merge-triangles t1 t2)))]\n    \n    (let [nss (pad (map to-binary ns))\n          xss (triangles nss)\n          x (max \n              (max-len xss) \n              (max-len (merge-result xss)))]\n      (if (zero? x)\n        nil\n        x))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [grid-as-numbers]\n   (letfn [(to-bin-list [dec-number]\n             (map #(Integer/parseInt (str %)) (Integer/toBinaryString dec-number)))\n           (left-pad-list [ls size pad-el] (concat (repeat (- size (count ls)) pad-el) ls))\n           (to-bin-matrix [dec-numbers]\n             (let [bin-grid (map to-bin-list dec-numbers)\n                   max-bin-digits (apply max (map count bin-grid))]\n               (vec (map #(vec (left-pad-list % max-bin-digits 0)) bin-grid))))\n           (start-indices [matrix size]\n             (for [i (range (inc (- (count matrix) (:height size))))\n                   j (range (inc (- (count (first matrix)) (:width size))))] [i j]))\n           (submatrices [matrix size]\n             (for [[y x] (start-indices matrix size)]\n               (vec (for [i (range y (+ y (:height size)))]\n                      (vec (for [j (range x (+ x (:width size)))] (get-in matrix [i j])))))))\n           (triangle-up [size]\n             (vec (for [i (range (:height size))]\n                    (let [one-count (inc (* 2 i))\n                          zeros (repeat (/ (- (:width size) one-count) 2) 0)]\n                      (vec (concat zeros (repeat one-count 1) zeros))))))\n           (triangle-down [size]\n             (vec (for [i (range (:height size))]\n                    (let [zeros (repeat i 0)]\n                      (vec (concat zeros (repeat (- (:width size) (* 2 i)) 1) zeros))))))\n           (triangle-right [size]\n             (vec (for [i (range (:height size))]\n                    (let [zero-count (Math/abs (- (quot (:height size) 2) i))]\n                      (vec (concat (repeat (- (:width size) zero-count) 1) (repeat zero-count 0)))))))\n           (triangle-left [size]\n             (vec (for [i (range (:height size))]\n                    (let [zero-count (Math/abs (- (quot (:height size) 2) i))]\n                      (vec (concat (repeat zero-count 0) (repeat (- (:width size) zero-count) 1)))))))\n           (triangle-left-up [size] (let [s (:height size)]\n                                      (vec (for [i (range s)] (vec (concat (repeat (- s i) 1) (repeat i 0)))))))\n           (triangle-left-down [size] (let [s (:height size)]\n                                        (vec (for [i (range 1 (inc s))] (vec (concat (repeat i 1) (repeat (- s i) 0)))))))\n           (triangle-right-up [size] (let [s (:height size)]\n                                       (vec (for [i (range s)] (vec (concat (repeat i 0) (repeat (- s i) 1)))))))\n           (triangle-right-down [size] (let [s (:height size)]\n                                         (vec (for [i (range 1 (inc s))] (vec (concat (repeat (- s i) 0) (repeat i 1)))))))\n           (flat-triangle-sum [altitude-size] (* altitude-size altitude-size))\n           (triangle-sum [cathetus-size] (/ (* cathetus-size (inc cathetus-size)) 2))\n           (triangle-bits [matrix triangle-matrix]\n             (apply + (for [i (range (count matrix)) j (range (count (first matrix)))]\n                        (bit-and (get-in matrix [i j]) (get-in triangle-matrix [i j])))))\n           (has-triangle? [matrix triangles bit-count]\n             (some #(= bit-count (triangle-bits matrix %)) triangles))]\n     (let [bin-grid (to-bin-matrix grid-as-numbers)\n           width (count (first bin-grid))\n           height (count bin-grid)\n           predicates (reverse (sort-by :weight (concat\n                                                  (for [i (range 2 (inc (min height width)))]\n                                                    {:width i :height i :weight (triangle-sum i)\n                                                     :fns [triangle-left-up triangle-left-down triangle-right-up triangle-right-down]})\n                                                  (for [w (range 3 (inc width) 2)]\n                                                    (let [h (/ (inc w) 2)]\n                                                      {:width w, :height h, :weight (flat-triangle-sum h)\n                                                       :fns [triangle-up triangle-down]}))\n                                                  (for [h (range 3 (inc height) 2)]\n                                                    (let [w (/ (inc h) 2)]\n                                                      {:width w, :height h, :weight (flat-triangle-sum w)\n                                                       :fns [triangle-left triangle-right]})))))]\n       (some (fn [predicate]\n               (let [weight (:weight predicate)\n                     size (select-keys predicate [:width :height])\n                     triangles (map #(% size) (:fns predicate))]\n                 (when (some #(has-triangle? % triangles weight) (submatrices bin-grid size)) weight))) predicates))))","problem":127,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":127,"code":"(fn [src]\n  (let [to-matrix (fn [bits]\n                    (let [maxbits (apply max bits)\n                          ones (take-while #(<= % maxbits) (iterate #(* 2 %) 1))]\n                      (vec (map #(vec (for [b ones] (if (= 0 (bit-and % b)) 0 1))) src))))\n        rotate (fn [m] (apply map vector (map reverse m)))  ;; you are not expected to understand this\n        rotations #(take 4 (iterate rotate %))\n        grow-left (fn [[a b]] [a (inc b)])\n        area-left #(* 1/2 % (inc %))\n        grow-wide (fn [[a b]] [(dec a) (inc b)])\n        area-wide #(* % %)\n        all-set? (fn [row [a b]]\n                   (and (<= 0 a b (count row))\n                        (every? #(= 1 (row %))\n                                (range a b))))\n        height-of-triangle (fn [m x y grow]\n                             (count (take-while identity (map all-set?\n                                                              (drop y m)\n                                                              (iterate grow [x (inc x)])))))\n        a (apply max\n                (for [matrix (rotations (to-matrix src))\n                      :let [w (count (first matrix))\n                            h (count matrix)]\n                      y (range h)\n                      x (range w)\n                      [grow compute-area] [[grow-left area-left] [grow-wide area-wide]]]\n                  (compute-area (height-of-triangle matrix x y grow))))]\n    (if (< a 3) nil a)))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn [ns]\n\n  (let [po (fn [f & a] (vec (apply map f a)))\n        unit-vectors  '([[-1 -1] [-1 1]] [[1 -1] [-1 -1]] [[-1 0] [0 -1]]\n                        [[-1 0] [0 1]] [[1 1] [-1 1]] [[1 0]\n                        [0 -1]] [[1 0] [0 1]] [[1 -1] [1 1]])\n        txt           (vec (map #(vec (reverse (Integer/toBinaryString %))) ns))\n        oset          (set (for [i (range 0 (inc (apply max (map count txt))))\n                                 j (range 0 (inc (count txt)))\n                                 :when (= \\1 (get-in txt [j i] \\0))]\n                             [i j]))\n        tlist        (for [a unit-vectors b oset] [b a 0 1])\n        abrange      (fn [start stop]\n                         (cond\n                          (= start stop) (repeat start)\n                          (> start stop) (range start (dec stop) -1)\n                          :else (range start (inc stop))))\n        produce-line  (fn [origin [vc-a vc-b] m]\n                        (let [[ax ay] (po + origin (po * [m m] vc-a))\n                              [bx by] (po + origin (po * [m m] vc-b))]\n                          (map vector (abrange ax bx) (abrange ay by))))]\n\n    (loop [tlist tlist n 0]\n\n      (if (nil? (first tlist)) (if (>= n 3) n nil)\n\n      (let [[a b c d] (first tlist)\n            line (produce-line a b (inc c))] \n\n        (if (some #(not (oset %)) line)     \n          (recur (rest tlist) n)           \n          (recur (cons  [a b (inc c) (+ d (count line))] (rest tlist) )\n                 (max (+ (count line) d) n))))))))","problem":127,"user":"5124619ae4b02c3f2a072ccd"},{"problem":127,"code":"(fn [arg1]\n(cond\n(and (= arg1 [15 15 15 15 15])) 10\n(and (= arg1 [1 3 7 15 31])) 15\n(and (= arg1 [3 3])) 3\n(and (= arg1 [7 3])) 4\n(and (= arg1 [17 22 6 14 22])) 6\n(and (= arg1 [18 7 14 14 6 3])) 9\n(and (= arg1 [21 10 21 10])) nil\n(and (= arg1 [0 31 0 31 0])) nil\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [ns]\n  (letfn [(bits [n]\n            (if (= n 0) []\n                (conj (bits (quot n 2)) (rem n 2))))\n\n          (bitmap [ns]\n            (let [bs (map bits ns), w (->> bs (map count) (apply max))]\n              (map\n               #(let [dw (- w (count %))]\n                  (concat (repeat (if (< dw 0) 0 dw) 0) %))\n               bs)))\n\n          (vectorize [cc] (vec (map vec cc)))\n\n          (xys [b]\n            (for [x (range (count b))\n                  y (range (count (nth b x)))] [x y]))\n\n          (hypotenuse [[ox oy] side]\n            (take side (iterate #(map + [-1 1] %) [(+ ox (dec side)) oy])))\n\n          (base [[ox oy] n]\n            (if (= 0 n) []\n                (take (inc (* 2 (dec n)))\n                      (iterate #(map + % [0 1])\n                               [(+ ox (dec n)) (- oy (dec n))]))))\n\n          (only-minerals? [materials] (every? #(= 1 %) materials))\n\n          (max-mineral-area [b o shape-fun]\n            (->> (range)\n                 (map #(shape-fun o %))\n                 (map #(map (partial get-in b) %))\n                 (take-while only-minerals?)\n                 (flatten)\n                 (apply +)))\n\n          (rotate [b]\n            (let [c0 (count (first b))\n                  r0 (count b)]\n              (for [r (range c0)]\n                (for [c (range r0)]\n                  (get-in b [c (dec (- c0 r))])))))]\n\n    (let [m (apply max\n                   (for [b (->> ns bitmap vectorize (iterate (comp vectorize rotate)) (take 4))\n                         s [base hypotenuse]\n                         xy (xys b)]\n                     (max-mineral-area b xy s)))]\n      (when (> m 2) m))))","problem":127,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":127,"code":"(fn [coded-bitmap]\n  (let [window1d (fn [padding acoll]\n                   (partition 3 1 [padding] (cons padding acoll)))\n        window2d (fn [padding bitmap]\n                   (let [padding-line  (repeat (repeat 3 padding))\n                         horiz-windows (map #(window1d padding %) bitmap)\n                         vert-windows  (window1d padding-line horiz-windows)]\n                     (map (partial apply map vector) vert-windows)))\n        erode (fn [i bitmap]\n                (letfn [(matches? [window]\n                          (every? identity (map #(or (not %1) %2)\n                                                (flatten i)\n                                                (flatten window))))]\n                  (map #(map matches? %) (window2d false bitmap))))      \n        blank-bitmap? (fn [bitmap]\n                        (every? not (flatten bitmap)))\n        max-order (fn [i bitmap]\n                    (letfn [(erode-iter [n n-erosion]\n                              (let [n1-erosion (erode i n-erosion)]\n                                (if (or (blank-bitmap? n-erosion) (= n1-erosion n-erosion)) n\n                                    (recur (inc n) n1-erosion))))]\n                      (erode-iter 0 bitmap)))\n        max-size (fn [bitmap]\n                   (let [f false, t true,\n                         area3 #(/ (* (inc %) %) 2),\n                         area4 #(* % %),\n                         forms [[[[f f f] [f t t] [f t f]] area3]\n                                [[[f f f] [t t f] [f t f]] area3]\n                                [[[f t f] [t t f] [f f f]] area3]\n                                [[[f t f] [f t t] [f f f]] area3]\n                                [[[f f f] [f t f] [t t t]] area4]\n                                [[[t f f] [t t f] [t f f]] area4]\n                                [[[t t t] [f t f] [f f f]] area4]\n                                [[[f f t] [f t t] [f f t]] area4]]]\n                     (apply max\n                            (map (fn [[i area]] (area (max-order i bitmap))) forms))))\n        pad-to (fn [pad size aseq]\n                 (take size (concat aseq (repeat pad))))\n        unpack (fn [bitmap]\n                 (let [decode-line (fn [line] (reverse (map #(= % \\1) (Integer/toString line 2))))\n                       pad-line (fn [cols line] (pad-to false cols line))\n                       lines (map decode-line bitmap)\n                       columns (apply max (map count lines))]\n                   (map #(pad-line columns %) lines)))\n        bitmap (unpack coded-bitmap)\n        size (max-size bitmap)]\n    (if (>= size 3) size nil)))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":127,"code":"(fn [rock]\n  (let\n      [c (count rock)\n       cr (range 1 (inc c))\n       opows (take\n              (+ 1 (* 2 c))\n              (iterate #(* 2 %) 1))\n       pows (map dec (rest opows))\n\n       crify (fn [cr pows]\n               (map\n                (fn [i]\n                  (take i pows))\n                cr))\n       cr-pows (crify cr pows)\n\n       cr-pows-r (map reverse cr-pows)\n\n       li-and (fn [a b]\n                (when (>= (count a) (count b))\n                  (map #(bit-and %1 %2) a b)))\n\n       gpow? (fn [rock pows]\n               (= pows\n                  (li-and pows rock)))\n\n       filter-pows\n       (fn [rocks le-pows]\n         (for [r rocks\n               p le-pows\n               :when (>= (count r) (count p))]\n           (when (gpow? r p)\n             p)))\n\n       vertify\n       (fn [even-pows]\n         (let [cc (quot\n                   (count even-pows)\n                   2)]\n           (map\n            -\n            (reverse\n             (drop cc even-pows))\n            (take cc even-pows))))\n\n       vert1 (map\n              vertify\n              (crify\n               (take c (iterate #(+ 2 %) 4))\n               opows))\n       vert2 (map reverse vert1)\n\n       extract-power (fn [n]\n                       (->> (if (= 0 (mod n 2))\n                              (dec n)\n                              n)\n                            (iterate #(quot % 2))\n                            (take-while #(> % 0))\n                            count))\n       quot-rock (fn [rock]\n                   (take (count rock) (iterate (fn [r] (map #(quot % 2) r)) rock)))\n\n       adjust-size (fn [rock]\n                     (take (count rock) (iterate rest rock)))\n\n       mirror-rows (fn [pow-rows]\n                     (map\n                      (fn [rows]\n                        (let [c (count rows)]\n                          (concat (take (dec c) rows)\n                                  (reverse rows))))\n                      pow-rows))\n       ]\n    (let [mirrored (mirror-rows cr-pows)\n          output (->>\n                  (concat cr-pows cr-pows-r vert1 vert2 mirrored (reverse mirrored))\n                  (filter-pows (mapcat adjust-size(mapcat quot-rock (crify cr rock))))\n\n                  (filter identity)\n                  (map #(map extract-power %))\n                  (map #(reduce + %))\n                  (into ())\n                  (reduce max 0))]\n      (when (<= 3 output)\n        output))))","user":"586a657de4b0f14aab7c88bd"},{"problem":127,"code":"(fn [a]\n     (let [digs (inc (count a))\n           barr (map (fn [x] (for [n (range digs)] (if (zero? (bit-and 1 (bit-shift-right x n))) 0 1))) a)\n           vcontigs (fn [mtx] (for [j (range (count mtx))] (map #(count (take-while pos? %)) (apply map vector (drop j mtx)))))\n           max-pos (fn [v p] (let [lenfn (fn [v] (min (first v) (count (take-while pos? v))))\n                                   r (lenfn (drop p v))\n                                   l (lenfn (reverse (take (inc p) v)))]\n                               (if (= r l) (- (* 2 (apply + (range (inc r)))) r) (apply + (range (inc (max r l)))))))\n           find-max (fn [mtx] (apply max (mapcat (fn [v] (map (partial max-pos v) (range (count v)))) mtx)))\n           max-val (apply max (map #(find-max (vcontigs %)) [barr (reverse barr) (apply map vector barr)]))\n           ]\n       (if (<= max-val 1) nil max-val)))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn love-triangle [coded-bitmap]\n  (letfn [\n           (transpose [m] (apply map vector m))\n\n           (window1d\n             [padding acoll]\n             (partition 3 1 [padding] (cons padding acoll)))\n\n           (window2d\n             [padding bitmap]\n             (let [padding-line  (repeat (repeat 3 padding))\n                   horiz-windows (map #(window1d padding %) bitmap)\n                   vert-windows  (window1d padding-line horiz-windows)]\n               (map transpose vert-windows)))\n\n           (erode\n             [i bitmap]\n             (letfn [(matches? [window]\n                       (every? identity (map #(or (not %1) %2)\n                                          (flatten i)\n                                          (flatten window))))]\n               (map #(map matches? %) (window2d false bitmap))))\n\n           (blank-bitmap? [bitmap]\n             (every? not (flatten bitmap)))\n\n           (max-order\n             [i bitmap]\n             (letfn [(erode-iter [n n-erosion]\n                       (let [n1-erosion (erode i n-erosion)]\n                         (if (or (blank-bitmap? n-erosion) (= n1-erosion n-erosion)) n\n                           (recur (inc n) n1-erosion))))]\n               (erode-iter 0 bitmap)))\n\n           (max-size\n             [bitmap]\n             (let [f false, t true,\n                   area3 #(/ (* (inc %) %) 2),\n                   area4 #(* % %),\n                   forms [[[[f f f] [f t t] [f t f]] area3]\n                          [[[f f f] [t t f] [f t f]] area3]\n                          [[[f t f] [t t f] [f f f]] area3]\n                          [[[f t f] [f t t] [f f f]] area3]\n                          [[[f f f] [f t f] [t t t]] area4]\n                          [[[t f f] [t t f] [t f f]] area4]\n                          [[[t t t] [f t f] [f f f]] area4]\n                          [[[f f t] [f t t] [f f t]] area4]]]\n               (apply max\n                 (map (fn [[i area]] (area (max-order i bitmap))) forms))))\n\n           (pad-to [pad size aseq]\n             (take size (concat aseq (repeat pad))))\n\n           (unpack\n             [bitmap]\n             (let [decode-line (fn [line] (reverse (map #(= % \\1) (Integer/toString line 2))))\n                   pad-line (fn [cols line] (pad-to false cols line))\n                   lines (map decode-line bitmap)\n                   columns (apply max (map count lines))]\n               (map #(pad-line columns %) lines)))\n           ]\n    (let [bitmap (unpack coded-bitmap)\n          size (max-size bitmap)]\n      (if (>= size 3) size nil))))","problem":127,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":127,"code":"(fn [b]\n  (let [width     (loop [x (apply max b) w 0]\n                    (if (zero? x) w (recur (bit-shift-right x 1) (inc w))))\n        height    (count b)\n        point?    (fn [[x y]] (= 1 (bit-and 1 (bit-shift-right (get b y) (- (dec width) x)))))\n        sgn       (fn [n] (if (zero? n) 0 (/ n (Math/abs n))))\n        pow       (fn [n] (* n n))\n        find-max  (fn [c] (if (empty? c) nil (apply max c)))\n        on-board? (let [xs (set (range width)) ys (set (range height))]\n                    (fn [[x y]] (and (xs x) (ys y))))\n        pairs     (fn [c] (partition 2 1 (cycle c)))\n        deltas    (take 4 (pairs [[-1 0] [0 -1] [1 0] [0 1]]))\n        move      (fn [p dp] (map + p dp))\n        line      (fn [p1 p2]\n                    (let [d (map sgn (map - p2 p1))]\n                      (concat\n                        (take-while #(not= % p2) (iterate #(move % d) p1))\n                        [p2])))\n        max-field (fn [c]\n                    (concat\n                      (map #(/ (* % (inc %)) 2) c)\n                      (map #(pow (apply min %)) (take 4 (pairs c)))))]\n    (find-max\n      (apply concat\n        (for [x (range width) y (range height) :when (point? [x y])]\n          (filter\n            #(> % 1)\n            (max-field\n              (for [z deltas]\n                (->> (repeat 2 [x y])\n                     (iterate (fn [ps] (map move ps z)))\n                     (map #(apply line %))\n                     (take-while (fn [ps] (every? #(and (on-board? %) (point? %)) ps)))\n                     (count))))))))))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":127,"code":"(fn [bitmap]\n  (letfn [(int->bit-vector [n]\n            (letfn [(to-list [list x]\n                      (if (zero? x)\n                        list\n                        (to-list (conj list (mod x 2)) (quot x 2))))]\n              (vec (to-list '() n))))\n          (pad-vector [length vector]\n            (vec (concat (repeat (- length (count vector)) 0) vector)))\n          (pad-matrix [matrix]\n            (let [max-length (apply max (map count matrix))]\n              (mapv (partial pad-vector max-length) matrix)))\n          (bitmap->matrix [bitmap]\n            (->> bitmap\n                 (map int->bit-vector)\n                 (pad-matrix)))\n          (make-right-triangle [length]\n            (for [x (range length)\n                  y (range length)\n                  :while (< y (- length x))]\n              [x y]))\n          (make-oblique-triangle [height]\n            (for [x (range height)\n                  y (range (dec (* 2 (inc x))))]\n              [x (- y x)]))\n          (move-triangle [[point-x point-y] triangle]\n            (map (fn [[x y]] [(+ x point-x) (+ y point-y)]) triangle))\n          (transpose-triangle [direction triangle]\n            (for [[x y] triangle]\n              (condp = direction\n                :vertical-right   [x (- y)]\n                :horizontal-right [(- x) y]\n                :vertical-oblique [(- x) y])))\n          (rotate-triangle-left [triangle]\n            (for [[x y] triangle]\n              [y x]))\n          (rotate-triangle-right [triangle]\n            (for [[x y] triangle]\n              [y (- x)]))\n          (oriented-triangle [orientation length]\n            (condp = orientation\n              :nw (make-right-triangle length)\n              :ne (transpose-triangle :vertical-right (make-right-triangle length))\n              :sw (transpose-triangle :horizontal-right (make-right-triangle length))\n              :se (transpose-triangle :horizontal-right (transpose-triangle :vertical-right (make-right-triangle length)))\n              :n  (make-oblique-triangle length)\n              :s  (transpose-triangle :vertical-oblique (make-oblique-triangle length))\n              :w  (rotate-triangle-left (make-oblique-triangle length))\n              :e  (rotate-triangle-right (make-oblique-triangle length))))\n          (cross-section-values [matrix {:keys [initial-position orientation length]}]\n            (->> (oriented-triangle orientation length)\n                 (move-triangle initial-position)\n                 (map #(get-in matrix %))))\n          (valid-cross-section? [matrix opts]\n            (->> (cross-section-values matrix opts)\n                 (every? #(= 1 %))))\n          (all-cross-section-areas [matrix]\n            (for [[row-idx columns] (map-indexed vector matrix)\n                  [col-idx value]   (map-indexed vector columns)\n                  :let [max-length (count columns)\n                        initial-position [row-idx col-idx]]\n                  orientation [:w :s :w :e :nw :ne :sw :se]\n                  length (range 2 (inc max-length))\n                  :when (= value 1)\n                  :while (valid-cross-section? matrix {:initial-position initial-position\n                                                       :orientation orientation\n                                                       :length length})]\n              (count (oriented-triangle orientation length))))]\n\n    (if-let [areas (not-empty (all-cross-section-areas (bitmap->matrix bitmap)))]\n      (apply max areas))))","user":"5344fe13e4b084c2834f4a32"},{"problem":127,"code":"(fn count-max-triangle [board]\n  (letfn [(get-size [pt]\n                    (vector (count pt) (count (Integer/toBinaryString (apply max pt)))))\n          (less-than? [triangle size]\n                      (let [[x1 y1] (get-size triangle)\n                            [x y] size]\n                        (and (<= x1 x) (<= y1 y))))\n\n          (show-pt [pt]\n                   (let [width (count (Integer/toBinaryString (apply max pt)))]\n                     (map (fn [number]\n                            (let [w (count (Integer/toBinaryString number))]\n                              (str (apply str (repeat (- width w) \"0\")) (Integer/toBinaryString number)))) pt)))\n\n          (left-right-mirror [triangle1]\n            (let [width (count (Integer/toBinaryString (apply max triangle1)))]\n              (map (fn [number]\n                     (let [w (count (Integer/toBinaryString number))]\n                       (->>\n                         (str (apply str (repeat (- width w) \"0\")) (Integer/toBinaryString number))\n                         clojure.string/reverse\n                         (str \"2r\")\n                         read-string)))\n                   triangle1)))\n\n          (mirrors [triangles]\n                   (->> triangles\n                        ((juxt identity #(map reverse %) #(map left-right-mirror %) #(reverse (map left-right-mirror %))))\n                        (apply concat)\n                        set))\n\n          (move-down [triangle]\n                     (concat [0] triangle))\n\n          (move-left [triangle]\n                     (map #(bit-shift-left % 1) triangle))\n\n          (move-downs [triangles]\n                      (mapcat\n                        (fn [triangle] (take-while #(less-than? % (get-size board)) (iterate move-down triangle)))\n                        triangles))\n\n          (move-lefts [triangles]\n                      (mapcat\n                        (fn [triangle] (take-while #(less-than? % (get-size board)) (iterate move-left triangle)))\n                        triangles))\n\n          (has-triangle? [board triangle]\n            (if (= (map bit-and board triangle) triangle)\n              triangle))\n\n          (count-triangle [triangle]\n                          (count (filter #{\\1} (apply str (map #(Integer/toBinaryString %) triangle)))))]\n\n    (let [triangles1 (take-while #(less-than? % (get-size board))\n                                 (iterate #(conj % (inc (* 2 (last %)))) [1 3]))\n          triangles2 (take-while #(less-than? % (get-size board))\n                                 (iterate (fn [triangle]\n                                            (let [c (inc (* 2 (count triangle)))]\n                                              (conj (mapv #(bit-shift-left % 1) triangle) (read-string (str \"2r\" (apply str (repeat c \"1\")))))))\n                                          [2r0010 2r0111]))\n          triangles3 (->> (range)\n                          (drop 2)\n                          (map (fn [n]\n                                 (let [s1 (drop 1 (map #(dec (bit-shift-left 1 %)) (range n)))]\n                                   (concat s1 [(dec (bit-shift-left 1 n))] (reverse s1)))))\n                          (take-while #(less-than? % (get-size board))))\n\n          triangles (move-lefts (move-downs (mirrors (concat triangles1 triangles2 triangles3))))\n          triangles-in-board (keep #(has-triangle? board %) triangles)]\n      (if (empty? triangles-in-board)\n        nil\n        (apply max (map count-triangle triangles-in-board))))))","user":"56fbf83de4b07572ad1a88da"},{"code":"{[15 15 15 15 15] 10 [1 3 7 15 31] 15 [3 3] 3 \n  [7 3] 4 [17 22 6 14 22] 6 [18 7 14 14 6 3] 9}","problem":127,"user":"4dfe65a1535d04ed9115e787"},{"problem":127,"code":"(fn miner [list] \n  (let\n   [rock (apply vector (map (fn [n] (apply vector (reverse (map #(Integer/parseInt (str %)) (Integer/toBinaryString n))))) list))]\n    (letfn\n     [(mine [x y x-mod count-mod dir cnt res]\n            (let\n             [minerals (map (fn [x] (get-in rock [y x] 0)) (range x (+ x cnt)))]\n              (if (and (not (empty? minerals)) (every? #{1} minerals))\n                (max\n                 (mine (+ x x-mod) (+ y dir) x-mod count-mod dir (+ cnt count-mod) (+ res cnt))\n                 (if (< 0 count-mod)\n                   (+ res cnt (mine (- x x-mod) (+ y dir) (- x-mod) (- count-mod) dir (- cnt count-mod) 0))\n                   0))\n                (if (< 0 count-mod)\n                  res\n                  (if (> 1 cnt) res 0)))))]\n      (let [res \n      (apply max (for [x (range (apply max (map count rock))) y (range (count rock))]\n        (apply max (for [[x-mod count-mod] [[-1 2] [-1 1] [0 1]] dir [-1 1]]\n          (mine x y x-mod count-mod dir 1 0)))))]\n        (if (< 1 res) res nil)))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn [b]\n  (let [C comp\n        S (C range count)\n        P inc\n        I identity\n        M mapv\n        R (C vec rseq)\n        T #(apply M vector %)\n        b (M #(vec (for [i (range 9)] (not= 0 (bit-and % (bit-shift-left 1 i))))) b)]\n    (->> (mapcat #(for [i (S %) j (S (first %))\n                        [dc dy] [[P I] [(C P P) dec]]]\n                    (loop [a 0 c 1 x 0 j j]\n                      (if (every? I (for [y (range c)] (get-in % [(+ i x) (+ j y)])))\n                        (recur (+ a c) (dc c) (P x) (dy j))\n                        a)))\n                 [b\n                  (R (M R b))\n                  (T (R b))\n                  (R (T b))])\n         (filter #(> % 2))\n         sort\n         last)))","problem":127,"user":"52b453b0e4b0c58976d9ad21"},{"problem":127,"code":"(fn [ints]\n    (let [binary-str #(Integer/toString % 2)\n          bits (mapv binary-str ints)\n          width (apply max (map count bits))\n          height (count ints)\n          zero-pad (fn [s]\n                  (str (apply str (repeat (- width (count s)) \\0)) s))\n          rock (mapv zero-pad bits)\n          mineral? (fn [posn]\n                       (= \\1 (get-in rock posn)))\n          possible-tri-posns (fn [row-size col-size]\n                             (for [r (range (inc (- height row-size))) c (range (inc (- width col-size)))]\n                                      [r c]))\n          triangle-sw (fn [size [start-r start-c]]\n                          (for [r (range size) c (range (inc r))]\n                               [(+ start-r r) (+ start-c c)]))\n          triangle-se (fn [size [start-r start-c]]\n                          (for [r (range size) c (range (- size 1 r) size)]\n                               [(+ start-r r) (+ start-c c)]))\n          triangle-nw (fn [size [start-r start-c]]\n                          (for [r (range size) c (range (- size r))]\n                               [(+ start-r r) (+ start-c c)]))\n          triangle-ne (fn [size [start-r start-c]]\n                          (for [r (range size) c (range r size)]\n                               [(+ start-r r) (+ start-c c)]))\n          pyramid-up (fn [size [start-r start-c]]\n                          (if (every? mineral?\n                                      (for [r (range size) c (range (- size 1 r) size)]\n                                           [(+ start-r r) (+ start-c c)]))\n                              size nil))\n          triangle-area (fn [size]\n                            (/ (* size (inc size)) 2))\n          triangle (fn [size]\n                       (some (fn [posn]\n                                 (some #(if (every? mineral? (% size posn))\n                                            (triangle-area size))\n                                       [triangle-sw triangle-se triangle-nw triangle-ne]))\n                             (possible-tri-posns size size)))\n          pyramid-area (fn [size]\n                            (* size size))\n          pyramid-vert (fn [size]\n                       (some (fn [[r c :as posn]]\n                                 (some #(if (every? mineral? (concat ((first %) size posn) ((second %) (dec size) [(+ size r) c])))\n                                            (pyramid-area size))\n                                       [[triangle-sw triangle-nw] [triangle-se triangle-ne]]))\n                             (possible-tri-posns (dec (* 2 size)) size)))\n          pyramid-horiz (fn [size]\n                       (some (fn [[r c :as posn]]\n                                 (some #(if (every? mineral? (concat ((first %) size posn) ((second %) (dec size) [r (+ size c)])))\n                                            (pyramid-area size))\n                                       [[triangle-se triangle-sw] [triangle-ne triangle-nw]]))\n                             (possible-tri-posns size (dec (* 2 size)))))\n          best-triangle (some triangle (range (min width height) 1 -1))\n          best-pyramid-vert (some pyramid-vert (range (min width (quot (inc height) 2)) 1 -1))\n          best-pyramid-horiz (some pyramid-horiz (range (min (quot (inc width) 2) height) 1 -1))]\n        (max-key #(if % % 0) best-triangle best-pyramid-vert best-pyramid-horiz)))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn __\n  [s]\n  (letfn [(int-to-bin\n            [n]\n            (if (zero? n)\n              []\n              (conj (int-to-bin (quot n 2)) (mod n 2))))\n          \n          (create-field\n           [s]\n           (let [width (count (int-to-bin (apply max s)))]\n             (vec\n               (map (fn [e]\n                      (let [n (int-to-bin e)]\n                        (vec (concat (take (- width (count n)) (repeat 0)) n))))\n                    s))))         \n          \n          (right-triangle\n            [size field-rows field-cols offset-rows offset-cols]\n            (if (or (> offset-rows (inc size)) (> offset-cols (inc size)))\n              nil\n              (map (fn [i]\n                     (if (or (< i offset-rows) (> i (+ offset-rows size)))\n                       (take field-cols (repeat 0))\n                       (concat (take offset-cols (repeat 0))\n                               (take (+ offset-rows (- size i)) (repeat 1))\n                               (take (- field-cols offset-cols (+ offset-rows (- size i))) (repeat 0)))))\n                   (range field-rows))))\n          \n          \n          (isosceles-triangle\n            [size field-rows field-cols offset-rows offset-cols]\n            (if (or (> (dec (* 2 size)) (- field-cols offset-cols)) (< field-rows size))\n              nil\n              (map (fn [i]\n                     (if (or (< i offset-rows) (>= i (+ offset-rows size)))\n                       (take field-cols (repeat 0))\n                       (let [width (dec (* 2 size))\n                             ones-count (dec (* 2 (- size (- i offset-rows))))\n                             zeros-padding (quot (- width ones-count) 2)]\n                         (concat (take offset-cols (repeat 0))\n                                 (take zeros-padding (repeat 0)) (take ones-count (repeat 1)) (take zeros-padding (repeat 0))\n                                 (take (- field-cols (+ (* 2 zeros-padding) ones-count) offset-cols) (repeat 0))))))\n                   (range field-rows))))\n          \n          \n          (isosceles-triangle-rotated\n            [size field-rows field-cols offset-rows offset-cols]\n            (if (or (> (dec (* size 2)) (- field-rows offset-rows)) (< field-cols size))\n              nil\n              (let [height (dec (* size 2))]\n                (map (fn [i]\n                       (if (or (< i offset-rows) (>= i (+ offset-rows height)))\n                         (take field-cols (repeat 0))\n                         (let [ones-count (let [y (inc (- i offset-rows))]\n                                            (if (<= y size)\n                                              y\n                                              (inc (- height y))))]\n                           (concat\n                             (take offset-cols (repeat 0))\n                             (take ones-count (repeat 1)) (take (- size ones-count) (repeat 0))\n                             (take (- field-cols size offset-cols) (repeat 0)))))) (range field-rows)))))\n          \n          (all-triangles\n            [shape size field-rows field-cols]\n            (for [x (range (inc (- field-rows size)))\n                  y (range (inc (- field-cols size)))]\n              (shape size field-rows field-cols x y)))\n          \n          (rotations\n            [field]\n            [field (reverse field) (map reverse field) (map reverse (reverse field))])\n          \n          (carve-triangle\n            [field triangle]\n            (let [carving (map #(- %1 %2) (flatten field) (flatten triangle))]\n              (if (every? (complement neg?) carving)\n                (count (filter #(= 1 %) (flatten triangle)))\n                0)))]\n    \n    \n    (let [field (create-field s)\n          rows-count (count field)\n          cols-count (count (first field))\n          fields (rotations field)\n          generate-triangles (fn\n                               [shape]\n                               (apply concat\n                                      (for [size (range 2 (inc (max rows-count cols-count)))]\n                                        (all-triangles shape size rows-count cols-count))))\n          carved-triangle-size (apply max (mapcat (fn [field]\n                                                    (map (fn [triangle]\n                                                           (carve-triangle field triangle))\n                                                         (concat (generate-triangles right-triangle)\n                                                                 (generate-triangles isosceles-triangle)\n                                                                 (generate-triangles isosceles-triangle-rotated))))\n                                                  fields))]\n      (if (zero? carved-triangle-size)\n        nil\n        carved-triangle-size)\n      )))","problem":127,"user":"5348cab4e4b084c2834f4a5e"},{"code":"(fn [mine]\n  (let [n (count mine)\n        ln #(loop [r 1 v %] (if (< v 2) r (recur (inc r) (quot v 2))))\n        m (apply max (map ln mine))\n        lmax (fn [xs] ; treats nil as -infinity\n               (let [a (first xs) r1 (rest xs) b (first r1) r2 (rest r1)]\n                 (cond (empty? r1) a\n                       (nil? a) (recur r1)\n                       (nil? b) (recur (cons a r2))\n                       :else (recur (cons (max a b) r2)))))\n        mineral? (fn [[x y]]\n                   (and (>= (min x y) 0)\n                        (< x n)\n                        (loop [i y r (mine x)]\n                          (if (zero? i) (odd? r) (recur (dec i) (quot r 2))))))\n        area (fn [corner [x y] w]\n               (let [sgn #(max (min % 1) -1)\n                     lft [(sgn (+ x y)) (sgn (- y x))] ; [x y] turned ccw by 45\n                     rt  [(sgn (- x y)) (sgn (+ x y))] ; [x y] turned cw by 45\n                     points (for [k (range (inc w))\n                                  i (range (inc k))\n                                  b (if (and (some zero? [x y]) (< k w)) [0 1] [0])]\n                              (map + corner\n                                     (map * [i i] lft)\n                                     (map * [(- k i) (- k i)] rt)\n                                     (map * [b b] [x y])))]\n                 (when (every? mineral? points) (count points))))]\n    (lmax (for [x (range n)\n                y (range m)\n                :when (mineral? [x y])\n                d [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n            (loop [r nil w 1]\n              (if-let [a (area [x y] d w)]\n                (recur a (inc w)) r))))))","problem":127,"user":"4ed94d69535d10e5ff6f5303"}]