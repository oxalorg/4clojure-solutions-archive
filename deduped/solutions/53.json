[{"code":"(fn [coll]\n     (let [d (map-indexed - coll)\n  \t p (partition-by second (map list coll d))\n\t\t c (map (fn [c] [(map first c) (count c)]) p)\n\t\t [[i _] & _] (sort-by second > c)]\n\t\t  (if (> (count i) 1)\n          i\n          [])))","problem":53,"user":"4e399685535deb9a81d77f40"},{"problem":53,"code":"(fn liss [xs]\n  (let [tups (partition 2 1 xs) ; transform to sequence of tuples of adjacent values\n        incdec (partition-by (fn [[v1 v2]] (pos? (- v2 v1))) tups) ; partition by increasing/decreasing sequences\n        inconly (filter (fn [[[v1 v2]]] (pos? (- v2 v1))) incdec) ; keep only increasing sequences\n        incvec (rseq (vec inconly)) ; reverse and convert to vector (... \"use the one that occurs first\")\n        ]\n    (if (pos? (count incvec)) ; if there are no results, output empty vector\n      (let [longest (apply (partial max-key count) incvec) ; get longest increasing sequence\n            longestvals (map (fn [[v1 v2]] v2) longest) ; extract numbers from tuples\n            result (concat [(first (first longest))] (vec longestvals)) ; prepend with first element\n            ]\n        result)\n      [])))","user":"56fe665be4b08d47c97781af"},{"code":"(fn [x] \n  (loop [l [] c [] [x1 & r] x]\n    (let [ll (if (and (> (count c) 1) (> (count c) (count l))) c l)]\n      (if (nil? x1) ll\n        (if (= (last c) (dec x1))\n          (recur l (conj c x1) r)\n            (recur ll [x1] r))))))","problem":53,"user":"528e64b7e4b0239c8a67aedd"},{"problem":53,"code":"(fn longest-increasing [s]\n  (let [break-down (fn [s prev-element current-seq accum]\n                     (if s\n                       (let [[current-element & rest-elements] s]\n                         (if (and prev-element (= current-element (inc prev-element)))\n                           (recur rest-elements current-element (conj current-seq current-element) accum)\n                           (if (empty? current-seq)\n                             (recur rest-elements current-element [current-element] accum)\n                             (recur rest-elements current-element [current-element] (conj accum current-seq)))))\n                       (if (empty? current-seq)\n                         accum\n                         (conj accum current-seq))))]\n    (->> (break-down s nil [] [])\n         (sort-by count)\n         (filter #(< 1 (count %)))\n         (#(if (empty? %) [] (last %)))\n         )))","user":"53527551e4b084c2834f4af0"},{"problem":53,"code":"(fn [s]\n  (let [longer? (fn [data x]\n                  (let [[longest xs] data\n                        new-xs (conj xs x)]\n                    (if (> x (peek xs)) \n                      [(if (> (count new-xs) (count longest))\n                         new-xs\n                         longest) new-xs]\n                      [longest [x]])))\n        start (let [a (first s)]\n                [[] [a]])]\n    (first (reduce longer? start s))))","user":"5d929ceae4b0915913b1d412"},{"problem":53,"code":"(fn\n  [s]\n  (let [res (reduce (fn [[maxs c sub-maxs] i]\n                   (if (and (last sub-maxs) (= i (inc (last sub-maxs))))\n                     (if (= (count maxs) (count sub-maxs))\n                       [(conj sub-maxs i) (inc c) (conj sub-maxs i)]\n                       [maxs c (conj sub-maxs i)])\n                     [maxs c [i]])) [[(first s)] 1 [(first s)]] (rest s))]\n    (if (= 1 (count (first res)))\n      []\n      (first res))))","user":"54edc818e4b024c67c0cf865"},{"code":"(fn straights [x] (let [y (first (sort-by count > (filter #(not-any? nil? %) (partition-by #(nil? %) (map #(if (= -1 (apply - %)) (first %) nil) (partition 2 1 x))))))] (if (empty? y) [] (range (first y) (+ (first y) (inc (count y)))))))","problem":53,"user":"4f7b6f12e4b06e829148e1a5"},{"code":"(fn [x]\n             (let [add-iff-grt (fn [yy xx]\n                                (if (or\n                                     (empty? (first yy))\n                                     (< (last (first yy)) xx))\n                                  (conj (next yy) (conj (first yy) xx))\n                                  (conj yy [xx])) )\n                   ]\n               (reduce #(if (and (> (count %2) 1) (>= (count %2) (count %1))) %2 %1)\n                       [] (reduce #(add-iff-grt %1 %2) [[]] x))\n               ))","problem":53,"user":"4dcc5aff535d5973398f9293"},{"problem":53,"code":"(fn [[x & xs]]\n  (let [longest (second\n    (reduce\n      (fn [[current longest] x]\n        (if (> x (peek current))\n          [(conj current x) longest]\n          [[x] (if (> (count current) (count longest)) current longest)]))\n      [[x] []]\n      (conj (vec xs) -1)))]\n    (if (> (count longest) 1) longest [])))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn blah [v]\n  (apply (partial max-key count) []\n         (reverse (for [i (range 2 (inc (count v))) \n                        part (partition i 1 v)\n                        :when (apply < part)]\n                    part))))","problem":53,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":53,"code":"(fn [[x & xs]]\n(loop [x x, xs xs, xsave 0, curlen 0, maxlen 0,\ncurstart 0, curend 0, maxstart 0, maxend 0]\n(if-not x\n(if (> curlen maxlen)\n(range curstart (inc curend))\n(range maxstart (inc maxend)))\n(if (zero? curlen)\n(recur (first xs) (next xs) x 1 maxlen x 0 maxstart maxend)\n(if-not (= x (inc xsave))\n(recur (first xs) (next xs) x 1 maxlen x 0 maxstart maxend)\n(if (> curlen maxlen)\n(recur (first xs) (next xs) x (inc curlen) (inc curlen) curstart x curstart x)\n(recur (first xs) (next xs) x (inc curlen) maxlen curstart x maxstart maxend)))))))","user":"589f2cefe4b02bd94d917e75"},{"code":"(fn [xs]\n  (loop [xs xs, ys [], zs []]\n    (if (seq xs)\n      (if (or (empty? ys) (= (first xs) (inc (last ys))))\n        (recur (next xs) (conj ys (first xs)) zs)\n        (recur xs [] (if (> (count ys) (max 1 (count zs))) ys zs)))\n      (if (> (count ys) (max 1 (count zs))) ys zs))))","problem":53,"user":"511442d0e4b0e9c109bb74d5"},{"problem":53,"code":"(fn[z]\n      (->>(partition 2 1 z)\n       (partition-by \n       (fn[[v1 v2]](> v2 v1)))\n        (map #(conj (into [](map first %))(last (last %))))\n        (filter (fn [[a b]](> b a)))\n        (reduce (fn[a b]\n        (if (> (count b)(count a))b a))[])))","user":"52faf67ce4b047fd55837005"},{"problem":53,"code":"(fn find-max-increasing [coll]\n     (let [pred (fn [elem past] (or (empty? past) (> elem (first past))))\n           take-fn (fn [[x :as s]]\n                     (take-while identity (map #(#{%1} %2) s (iterate inc x))))\n           gather (fn gather [coll]\n                    (if-not (empty? coll)\n                      (cons (take-fn coll) (gather (rest coll)))))\n           increasing (gather coll)\n           largest (fn [a b] (if (> (count b) (count a)) b a))]\n       (reduce largest [] (filter #(> (count %) 1) increasing))))","user":"548ade6de4b0e286459a11f6"},{"problem":53,"code":"(fn [ints]\n   (let [r (reduce (fn [result val]\n                     (println result val)\n                     (if (or (= val (inc (or (-> result :current last) -999)))\n                             (empty? (:current result)))\n                       (assoc result :current (conj (:current result) val))\n                       (if (> (count (:current result))\n                              (count (:longest result)))\n                         (assoc result :current [val] :longest (:current result))\n                         (assoc result :current []))))\n                   {:longest []\n                    :current []}\n                   ints)]\n     (if (> (count (:current r))\n            (count (:longest r)))\n       (if (> (count (:current r)) 1) (:current r) [])\n       (if (> (count (:longest r)) 1) (:longest r) []))))","user":"5d5c2730e4b09db18d4482ea"},{"problem":53,"code":";\n; I knew while I wrote this horrible code that there would be (at least somewhat) better way.\n;\n; hypirion and cgrand proved me right.\n; chouser's solution shows me that I've got a good bit of Clojure syntax yet to learn.\n;\n\n(fn\n  [coll]\n  (let [subseqs (loop [acc []\n                       remaining (rest coll)\n                       prev -1\n                       curr (first coll)]\n                  (if (nil? curr)\n                    acc\n                    (recur\n                      ; acc\n                      (cond\n                        (empty? acc)\n                        (conj acc (vector curr))\n                        (<= curr prev)\n                        (conj acc (vector curr))\n                        :else\n                        (assoc acc (dec (count acc)) (conj (last acc) curr)))\n                      ; remaining\n                      (rest remaining)\n                      ; prev\n                      curr\n                      ; curr\n                      (cond\n                        (not (empty? remaining))\n                        (first remaining)\n                        :else\n                        nil))))\n        min-length-subseqs (filter #(>= (count %) 2) subseqs)\n        subseq-size-groups (group-by count min-length-subseqs)\n        max-size (if (empty? subseq-size-groups) -1 (apply max (keys subseq-size-groups)))]\n    (vec (first (get subseq-size-groups max-size)))))","user":"594266cfe4b060784b3b790b"},{"problem":53,"code":"(fn [v]\n  (let [reds (reductions (fn [vs i]\n                           (if (= i (inc (last vs)))\n                             (conj vs i)\n                             [i]))\n                         [(first v)]\n                         (rest v))\n        countm (mapv count reds)\n        maxc (apply max countm)\n        idx (.indexOf countm maxc)]\n    (if (> maxc 1)\n      (nth reds idx)\n      [])\n    ))","user":"57a9e274e4b0b8559636fc5d"},{"problem":53,"code":"#(loop [[e & r] %\n        acc [e]\n        cmax [e]]\n   (let [acc (if (< (last acc) e)\n               (conj acc e)\n               [e])\n         cmax (if (< (count cmax) (count acc))\n                acc\n                cmax)]\n     (cond \n      (seq r) (recur r acc cmax)\n      (< (count cmax) 2) []\n      :else cmax)))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn [l] \r\n  (map first (loop [m [] l\r\n            (map (fn [x y] [x (- x y)]) l (cons (first l) l))]\r\n  (if (empty? l) m\r\n      (let [[j k] (split-with #(not (= 1 (last %))) l)\r\n            [k r] (split-with #(= 1 (last %)) k)]\r\n        (recur (if (and (not (empty? k)) (>= (count k) (count m))) (cons (last j) k) m)\r\n               r))))))","problem":53,"user":"4ddbd934535d02782fcbe9fc"},{"problem":53,"code":"(fn max-sequence [col]\n  ((fn max-seq [col, res]\n    (if (empty? col)\n      (last (sort-by count res))\n      (recur (rest col) (conj res ((fn max-seq-acc [col, acc]\n        (if (= (second col) (inc (first col)))\n          (recur (rest col) (conj acc (when (empty? acc) (first col)) (second col)))\n          (remove nil? acc))) col []))))) col []))","user":"587a3babe4b01531a375eae2"},{"problem":53,"code":"(comp\n   #(if (or (nil? %) (> 2 (count %))) [] %)\n   first\n   #(sort-by count > \n     (reductions\n       (fn [acc itm]\n         (if (< (last acc) itm)\n           (conj acc itm)\n           (vector itm)))\n       (vector (first %))\n       (rest %))))","user":"5a01d8f6e4b01bb0ae8afd53"},{"code":"(fn ff [s]\n  (let [pairs (partition 2 1 s)\n        bigger? (map #(apply < %) pairs)\n        runs (partition-by second (map vector pairs bigger?))\n        runs (filter #(-> % first second) runs)\n        ord-runs (sort-by #(* -1 (count %)) runs)\n        best (first ord-runs)\n        ans (concat (-> best first first first vector) (map #(-> % first second) best))\n        ]\n    (if (first ans) (vec ans) [])\n    ))","problem":53,"user":"4fa340b4e4b081705acca18c"},{"problem":53,"code":"( fn[S]\n  \n (reduce #(if (< (count %1) (count %2)) %2 %1 )\n  \t(map #(if (< 1 (count %)) % [])(for [x (range (count S))]\n          (for [y (range x (count S)) :while (or (= x y) (< (S (dec y)) (S y)) )]\n    \t\n            (S y)  ) \n         \n    ))\n  )\n  \n )","user":"5649615be4b0284900eef641"},{"code":"(fn f\n  ([coll] (f coll [] []))\n  ([coll l r]\n     (if (empty? coll)\n       (if (> (count l) 1) l [])\n       (let [c (or (empty? r) (< (last r) (first coll)))\n             nr (if c (conj r (first coll)) [(first coll)])\n             nl (if (> (count nr) (count l)) nr l)]\n         (recur (rest coll) nl nr)))))","problem":53,"user":"51740b65e4b0d277d717bc67"},{"code":"(fn [ns]\r\n  (let [\r\n\t\t\treds\r\n\t\t\t\t(reductions\r\n\t\t\t\t\t(fn [coll it]\r\n\t\t\t\t\t\t(if (or (empty? coll) (> it (last coll)))\r\n\t\t\t\t\t\t\t(conj coll it)\r\n\t\t\t\t\t\t\t[it]))\r\n\t\t\t\t\t[]\r\n\t\t\t\t\tns)\r\n\t\t\tn (apply max (map count reds))\r\n\t\t\tans (first (filter #(= n (count %)) reds))]\r\n\t\t\t(if (> (count ans) 1) ans [])))","problem":53,"user":"4dfe65a1535d04ed9115e787"},{"problem":53,"code":"(fn liss [a-vec]\n  (#(if (> (count %) 1)\n      %\n      [])\n   (reduce #(max-key count %2 %1) (reduce (fn [accum curr-n]\n                                            (if (> curr-n (last (last accum)))\n                                              (conj accum (conj (last accum) curr-n))\n                                              (conj accum [curr-n])))\n                                          [[(first a-vec)]]\n                                          (rest a-vec)))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":53,"code":"(fn [xs]\n  (or (first (for [partition-size (range (count xs) 1 -1)\n                   increasing-xs (filter #(apply < %)\n                                         (partition partition-size 1 xs))]\n               increasing-xs))\n      []))","user":"5c3a896be4b0d62ef62d9f94"},{"problem":53,"code":"(fn [x] (let [s (reduce (fn [acc x]\n                          (let [l  (last acc)\n                                l* (last l)\n                                bl (into [] (butlast acc))]\n                            (cond (nil? l*) [[x]]\n                                  (= (dec x) l*) (into bl [(into l [x])])\n                                  :else (into bl [l [x]]))))\n                        [] x)\n              m (apply max (map count s))]\n          (if (= 1 m)\n            []\n            (first (filter #(= m (count %)) s)))))","user":"5ccca8e1e4b0ccb06196289c"},{"problem":53,"code":"(fn [x]\n  ((fn [remaining longest current]\n     (if-let [[c & rst] remaining]\n      (if (= (- c 1) (peek current))\n        (let [new-current (conj current c)\n              new-longest (if (< (count longest) (count new-current))\n                            new-current\n                            longest)]\n          (recur rst new-longest new-current))\n        (recur rst longest [c]))\n      (if (> (count longest) 1) longest [])))\n   x [] []))","user":"541475afe4b01498b1a719eb"},{"problem":53,"code":"(fn [v] (reduce \n  (fn longer [a b] (if (> (count b) (count a)) b a))\n  []\n  (filter #(apply < %)\n  (filter #(< 1 (count %))\n  (for [n [(count v)] i (range 0 n) j (range (inc i) n)] (take (- (inc j) i) (drop i v)))))))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"problem":53,"code":"(let [subseqs (fn [xs] (take-while not-empty (iterate #(rest %) xs)))\n      filter2 (fn [f xs]\n                (loop [ll (first xs) l [ll] [fr :as r] (rest xs)]\n                  (if (or (nil? ll)\n                          (nil? fr)\n                          (not (f ll fr)))\n                    l\n                    (recur fr (conj l fr) (rest r)))))\n      do-run (fn [xs] (map #(filter2 < %) xs))\n      do-long (fn [xs] (filter #(> (count %) 1) xs))\n      do-sort (fn [xs] (sort-by #(-' (count %)) xs))]\n  #(-> % subseqs do-run do-long (conj []) do-sort first))","user":"4edee6a2535d10e5ff6f533e"},{"code":"(fn [s]\n   (first\n    (reduce\n     (fn [[best-seq cand-seq] x]\n       (if (or (empty? cand-seq) (> x (last cand-seq)))\n         (if (and (>= (count cand-seq) (count best-seq))\n                  (>= (count cand-seq) 1))\n           [(conj cand-seq x) (conj cand-seq x)]\n           [best-seq (conj cand-seq x)])\n         [best-seq [x]]))\n     [[] []] s)))","problem":53,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn [xs]\n   (loop [c (rest xs) s (vector (first xs)) res []]\n     (cond\n      (empty? c) res\n      (> (first c) (last s)) (recur (rest c) (conj s (first c)) (if (> (+ (count s) 1) (count res)) (conj s (first c)) res))\n      :else (recur (rest c) (vector (first c)) res))))","problem":53,"user":"5370f8ede4b0fc7073fd6ea2"},{"code":"(fn [xs]\n  (#(if (< (count %) 2) () %)\n  (last\n  (sort-by count\n(filter #(every? pos? (map - (rest %) (butlast %)) )\n(mapcat (comp (partial take-while #(not= % ())) (partial iterate rest))\n              (take-while #(not= % nil) (iterate butlast xs)))\n        )))))","problem":53,"user":"53976599e4b0b51d73faaeea"},{"code":"(fn longest-increasing-sub-seq\r\n  ([x]\r\n    (longest-increasing-sub-seq (rest x) [(first x)] [(first x)]))\r\n  ([x y z]\r\n    (println z)\r\n  (if (= 0 (count x))\r\n    (if (> (count z) 1)\r\n      z\r\n      [])\r\n    (if (= (first x) (inc (last y)))\r\n      (if (= (count y) (count z))\r\n        (recur (rest x) (conj y (first x)) (conj y (first x)))\r\n        (recur (rest x) (conj y (first x)) z))\r\n      (recur (rest x) [(first x)] z)))))","problem":53,"user":"4e16bdef535d04ed9115e7e9"},{"problem":53,"code":"(fn xs [z]\n  (let [l (for [x (range 0 (inc (count z))) y (range 0 (inc (count z))) :when (> y x)] (subvec z x y))\n       m (filter #(= % (range (first %) (+ (first %) (count %)))) l)\n       k (group-by count m)\n       b (first (k (apply max (keys k))))] (if (> (count b) 1) b [])))","user":"602049b8e4b0bf4ca6b10961"},{"problem":53,"code":"(fn f1 [c]\n  (->> (map vector c (rest c))\n       (reduce (fn [[af & ar :as a] b]\n                 (if (apply < b)\n                   (if (empty? af)\n                     (conj ar (into af b))\n                     (conj ar (conj af (last b))))\n                   (conj a [])))\n               '([]))\n       (apply max-key count)))","user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":53,"code":"(fn [col]\n  (let [largest (apply\n                  max-key\n                  count\n                  (reduce\n                    (fn [acc curr]\n                      (if (and (seq acc) (= (inc (last (last acc))) curr))\n                       (conj (pop acc) (conj (peek acc) curr))\n                       (conj acc [curr])))\n                    []\n                    col))]\n    (if (> (count largest) 1)\n      largest\n      [])))","user":"5b99554ae4b0c0b3ffbd4ace"},{"problem":53,"code":"(\n\tfn [coll] \n\t(let [refinedSeq \n\t\t\t(first \n\t\t\t\t(remove #(= (count %1) 1) \n\t\t\t\t\t(val \n\t\t\t\t\t\t(last \n\t\t\t\t\t\t\t(group-by count \n\t\t\t\t\t\t\t\t(reduce (fn[p n] \n\t\t\t\t\t\t\t\t\t(if (empty? p) \n\t\t\t\t\t\t\t\t\t\t(conj p (vector n)) \n\t\t\t\t\t\t\t\t\t\t(if (= (- (last (last p)) n) -1) \n\t\t\t\t\t\t\t\t\t\t\t(conj p (conj (last p) n)) \n\t\t\t\t\t\t\t\t\t\t\t(conj p (vector n)))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) \n\t\t\t\t\t\t\t\t[] coll)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t]\n\t\t\t(if (nil? refinedSeq) \n\t\t\t\t[] \n\t\t\t\trefinedSeq \n\t\t\t)\n\t\t)\n\t)","user":"5a6170fde4b0512ff01cd975"},{"problem":53,"code":"(fn [[x & r]]\n  (->> (reduce (fn [coll n]\n                 (let [x (last (last coll))]\n                   (if (= n (inc x))\n                     (conj (vec (butlast coll))\n                           (conj (last coll) n))\n                     (conj coll [n]))))\n               [[x]]\n               r)\n       (sort-by count)\n       (filter #(> (count %) 1))\n       last\n       vec))","user":"54848141e4b0e286459a119e"},{"code":"(fn longest-subsequence [coll]\n  (apply (fn longest [& colls]\n  \t\t\t(if (empty? colls) ()\n\t\t\t  (reduce (fn longer [a b]\n              (if (>= (count a) (count b))\n                a b)) colls))) (filter #(apply < %) ((fn subsequences [coll]\n  (for [a (range (count coll))\n        b (range (count coll))\n        :when (and\n                (> 2 (- a b))\n                (< a b))]\n    (subvec coll a (inc b)))) coll))))","problem":53,"user":"5264301fe4b03e8d9a4a70ca"},{"code":"(fn [v] \n  (letfn [(red [[current longest], i]\n            (if (empty? current)\n              [(conj current i) longest]\n              (let [l (last current) \n                    cc (count current) \n                    cl (count longest)]\n                (if (>= l i)\n                  [[i] longest]\n                  (if (> (inc cc) cl)\n                    [(conj current i)(conj current i)] \n                    [(conj current i) longest])))))]\n  (second (reduce red [[][]] v))))","problem":53,"user":"4f29eb2ae4b0d6649770a037"},{"problem":53,"code":"(fn [xs]\n  (first (reduce (fn [[longest curlist prev] x]\n                   (let [working (if (or (not prev) (< prev x))\n                                     (conj curlist x)\n                                     [x])]\n                     (if (and (fnext working) (< (count longest) (count working)))\n                         [working working x]\n                         [longest working x])))\n                 [[] [] nil]\n                 xs)))","user":"5427962de4b01498b1a71b26"},{"code":"(fn [v]\n  (let [len (count v)\n        all-subvecs (mapcat\n                      (fn [start]\n                        (map #(subvec v start %) (range start (inc len))))\n                      (range len))\n        suitable-subvecs (filter #(> (count %) 1) all-subvecs)\n        increasing? (fn increasing? [seqn]\n                      (if (< (count seqn) 2)\n                        true\n                        (when (= (inc (first seqn)) (second seqn))\n                          (recur (rest seqn)))))]\n    (reduce #(max-key count %1 %2) [] (filter increasing? suitable-subvecs))))","problem":53,"user":"53834ed3e4b06839e8705edb"},{"problem":53,"code":"(fn liss\n    ([coll]\n     (liss [] [] coll))\n    ([maxx curr [head & tail :as coll]]\n     (if-not (seq coll)\n       (if (and (> (count curr) 1) (< (count maxx) (count curr))) curr  maxx)\n       (if (seq curr)\n         (if (= (inc (last curr)) head)\n           (recur maxx (conj curr head) tail)\n           (if (and (> (count curr) 1) (< (count maxx) (count curr)))\n             (recur curr [] coll)\n             (recur maxx [] coll)))\n         (recur maxx (conj curr head) tail)))))","user":"516db4f6e4b046df6fbb76a0"},{"code":"(fn [c]\n  (->> c\n       (map-indexed (fn [i v] [(- i v) v]))\n       (partition-by first)\n       (filter #(> (count %) 1))\n       (reduce (fn [a s] (if (> (count a) (count s)) a s)) [])\n       (map last)))","problem":53,"user":"5164867fe4b003cf19fdde3e"},{"problem":53,"code":"(fn longest-subseq [a-seq]\n  (reduce (fn [prev-longest next-seq]\n            (if (or (> 2 (count next-seq)) (>= (count prev-longest) (count next-seq)))\n              prev-longest\n              next-seq))\n          []\n          (map (comp (fn increasing-subseq [a-seq]\n                       (loop [prev []\n                              value (first a-seq)\n                              the-rest (next a-seq)]\n                         (if (or (empty? the-rest) \n                                 (>= value (first the-rest)))\n                           (conj prev value)\n                           (recur (conj prev value)\n                                  (first the-rest)\n                                  (next the-rest))))) \n                     #(drop % a-seq)) \n               (range (count a-seq)))))","user":"5235493ee4b05e80434a5064"},{"code":"(fn [x] (vec (first (sort-by #(* -1 (count %)) (map (comp distinct flatten) (filter #(apply < (first %)) (partition-by (partial apply <) (partition 2 1 x))))))))","problem":53,"user":"4ece9ca9535d23f03622770f"},{"code":"(fn [cl]\n   (vec\n     (last (sort-by count\n                    (filter #(> (count %) 1)\n                            (reduce \n                              (fn [memo i]\n                                (if (= (last (last memo)) (dec i)) \n                                  (conj (vec (butlast memo))  (conj (last memo) i))\n                                  (conj memo [i])\n                                  )\n                                )\n                              [[]]\n                              cl)\n                            )\n                    )\n           )\n     )\n   )","problem":53,"user":"51db9e1ee4b0e067a9bbadc9"},{"code":"(fn [s]\n  (let [prev (atom nil)\n        marker (atom 0)\n        liss\n    (last (sort-by count\n      (partition-by\n        #(if (or (nil? @prev) (= % (inc @prev)))\n          (do\n            (swap! prev (constantly %))\n            @marker)\n          (do\n            (swap! prev (constantly %))\n            (swap! marker inc)))\n        s)))]\n(if (< (count liss) 2) [] liss)))","problem":53,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [i] \n  (loop [a i l -9999999 t [] r []] \n    (if (empty? a) \n      (if (and (> (count t) (count r)) (> (count t) 1)) t r)\n      (if (> (first a) l) \n        (recur (rest a) (first a) (conj t (first a)) r) \n        (if (and (> (count t) (count r)) (> (count t) 1) )\n          (recur (rest a) (first a) [(first a)] t)\n          (recur (rest a) (first a) [(first a)] r)\n        )\n      )\n    )\n  )\n)","problem":53,"user":"513b77f3e4b00f740c76c403"},{"problem":53,"code":"(fn [n]\n    (loop [x n, acc [[(first n)]]]\n       (if (<= (count x) 1)\n            (reduce #(if (> (count %2) (count %1)) (if (> (count %2) 1) %2 []) (if (> (count %1) 1) %1 [])) acc)\n          (recur (rest x) (\n          \t\t\tif (= (inc (first x)) (second x)) \n          \t\t\t\t(conj acc (conj (last acc) (second x)))\n          \t\t\t\t(conj acc [(second x)])\n          \t\t  )\n          )\n       )\n    )\n  )","user":"53ed03f0e4b0d648e757f4bb"},{"code":"(fn [l]\n  (let [[a r] (reduce\n                #(let [[a r] %] \n                   (cond (empty? a)\n                         [[%2] r]\n                         (< (last a) %2)\n                         [(conj a %2) r]\n                         true\n                         [[%2] (conj r a)])) [[][]] l)\n        r (remove #(= 1 (count %)) (conj r a))\n        ne (not (empty? r))\n        ml (if ne (apply max (map count r)))]\n    (if ne\n      (some #(if (= ml (count %)) %) r) [])))","problem":53,"user":"4fa30027e4b081705acca187"},{"problem":53,"code":"(fn [xs]\n (let [xxs (reverse\n           (reduce\n            (fn [v x] (if (= 0 x) (conj v 1) (conj v (inc (last v)))))\n            [1]\n            (reverse\n             (map\n              #(if (= (inc %1) %2) 1 0)\n              (drop-last xs)\n              (rest xs)))))\n       m (apply max xxs)]\n   (if (< m 2)\n     []\n     (take m (drop (.indexOf xxs m) xs)))))","user":"53c1b787e4b00fb29b221266"},{"code":"(fn [%]\n  (let [get-max  (fn [a b] (if (> (count b) (count a)) b a))\n        norm-inc (fn [%] (if (= 1 (count %)) [] %))\n        inc-seq (fn inc-seq [%]\n                  (loop [s %\n                         v []]\n                    (cond\n                      (nil? s) (norm-inc v)\n                      (or (empty?  v)\n                          (= (first s) (inc (peek v)))) (recur (next s) (conj v (first s)))\n                      :else (norm-inc v))))]\n    (loop [s %\n           max-s  []]\n      (cond\n        (nil? s) max-s\n        :else (recur (next s) (get-max max-s (inc-seq s)))))\n  \n  )\n)","problem":53,"user":"4f3e6244e4b0e243712b1f85"},{"code":"(fn [coll]\r\n  (let [v (reduce #(if (>= (count %1) (count %2)) %1 %2)\r\n          (loop [n (first coll) cur [n] accum [] [x & xs] (next coll)]\r\n            (if x\r\n              (if (> x n)\r\n                (recur x (conj cur x) accum xs)\r\n                (recur x [x] (conj accum cur) xs))\r\n              (conj accum cur))))]\r\n    (if (> (count v) 1) v []) \r\n    ))","problem":53,"user":"4e79ff2a535db169f9c796a9"},{"code":"(fn sub-seq [l]\n  (loop [longest []\n         current []\n         in l]\n    (cond (empty? in) (cond (>= (count longest) (count current)) longest\n                            (> (count current) 1) current\n                            :else [])\n\n          (or (empty? current) (> (first in) (last current)))\n          (recur longest (conj current (first in)) (rest in))\n\n          (> (count current) (count longest))\n          (recur (if (> (count current) 1) current []) [(first in)] (rest in))\n\n          :else (recur (if (> (count current) (count longest)) current longest)\n                       [(first in)] (rest in)))))","problem":53,"user":"4f04f847535dcb61093f6beb"},{"code":"(fn [s]\r\n  (letfn [(max-by-count [xs ys] (if (> (count ys) (count xs)) ys xs))]\r\n\t\t(loop [tail s, longest-subseq [], this-subseq []]\r\n\t\t\t(if-let [[x & xs] (seq tail)]\r\n\t\t\t\t(if (or (empty? this-subseq) (> x (last this-subseq)))\r\n\t\t\t\t\t(recur xs longest-subseq                            (conj this-subseq x))\r\n\t\t\t\t\t(recur xs (max-by-count longest-subseq this-subseq) [x]))\r\n\t\t\t\t(let [longest (max-by-count longest-subseq this-subseq)]\r\n\t\t\t\t\t(if (>= (count longest) 2) longest []))))))","problem":53,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":53,"code":"#(reduce\n     (fn [a b]\n       (if (= [] a)\n         (reduce\n           (fn [c d]\n             (if (= [] c)\n               (if (apply < (subvec % d (+ b d)))\n                 (subvec % d (+ b d))\n                 []\n               )\n               c\n             )\n           )\n           []\n           (range 0 (- (count %) b -1))\n         )\n         a\n       )\n     )\n     []\n     (range (count %) 1 -1)\n   )","user":"5bb23cf1e4b0a20761a2350a"},{"problem":53,"code":"(fn [n] (->> (map (fn [a b] (let [c (get n b)] (if (and (not (nil? c)) (< a c)) [a c] []))) n (range 1 (inc (count n))))\n            (partition-by count)\n            (reduce (fn [a b] (if (> (count b) (count a)) b a)) [])\n            ((fn [m] (if (empty? (last m)) [] (concat (for [s (butlast m)] (first s)) (last m)))))\n            ))","user":"57b35a19e4b0fbc9809a277d"},{"problem":53,"code":"(fn longest [v] \n  (let [result \n    (first (reduce \n     (fn [vr vl] \n       (if (= vl (inc (or (last (last vr)) 0)))\n         ; sequence building\n         ; last seq vr stays same\n         ; new seq augmented with vl \n         (vector (first vr) (conj (last vr) vl))\n         ; flush sequence check which sequence is longest\n         (let [fvr (first vr) lvr (last vr)]\n           (if (>= (count fvr) (count lvr))\n             ; reset new sequence\n             (vector fvr [vl])\n             ; new sequence becomes last one\n             (vector lvr [vl]))))) [[][]] (conj v 0)))]\n      (if (= (count result) 1) [] result)))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn [xs]\n  (first\n   (reduce\n    (fn [[max-so-far cur-sub-seq] x]\n     (cond (= x nil) [max-so-far nil]\n           (= cur-sub-seq nil) [[] [x]]\n           (> x (last cur-sub-seq)) (let [extended-cur (conj cur-sub-seq x)]\n                                      [(max-key count extended-cur max-so-far)\n                                       extended-cur])\n           :else [max-so-far [x]]))\n    nil xs)))","problem":53,"user":"510acd6ee4b078ea719210f4"},{"problem":53,"code":"(fn lrs [s]\n  (let [only-bin (fn [e] (if (> (count (first e)) 1) e [[]]))\n        select-seq (fn [cs ls e] (if (> (count cs) (count ls)) [cs [e] e] [ls [e] e]) )]\n    (->>\n        (reduce (fn [[ls cs le] e]\n                         (if (= e (inc le)) [ls (conj cs e) e] (select-seq cs ls e)))\n                [[] [(first s)] (first s)]\n                (rest s))\n        (apply select-seq)\n        only-bin\n        first)))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":53,"code":"(fn inc-subsq\n  ([[x & xs]]\n   (let [sqs (inc-subsq xs [[x]])\n         sq (-> (sort (fn [x y]\n                        (> (count x) (count y)))\n                      sqs)\n                first)]\n     (if (> (count sq) 1)\n       sq\n       [])))\n  ([[x & xs] sqs]\n   (if-not x\n     sqs\n     (let [l (last (last sqs))]\n       (if (> x l)\n         (inc-subsq xs\n                    (concat (butlast sqs)\n                            [(concat (last sqs) [x])]))\n         (inc-subsq xs\n                    (concat sqs [[x]])))))))","user":"5bcddaeee4b0e9689409ee07"},{"code":"(fn [coll]\n  (reduce #(if (> (count %2) (count %)) %2 %) []\n    (map (comp distinct flatten)\n      (filter #(< (first (first %)) (last (first %)))\n        (partition-by (fn [[x y]] (> y x))\n          (partition 2 1 coll))))))","problem":53,"user":"515a6151e4b0394f658fe241"},{"code":"#(let [all_results \n  (map \n    (fn [[start end]]\n      (subvec % start (inc end))\n    )\n    (partition 2\n        (loop [c % n [] last_ false count_ 0]\n          (let [this (nth c 0 0.9) \n                next_ (nth c 1 1.1) \n                good (= (inc this) next_)]\n            (println this)\n            (if \n              (= (count c) 0)\n              n  \n              (if\n                (not= last_ good) \n                (recur (rest c) (conj n count_) good (inc count_))\n                (recur (rest c) n good (inc count_))\n              )\n            )\n          )\n      )\n    )\n  )]\n  (reduce (fn [a b] (if (> (count a) (count b)) a b)) [] all_results)\n  )","problem":53,"user":"52485723e4b05ef8e38e63d2"},{"problem":53,"code":"#(apply max-key count (remove (fn [z] (= 1 (count z))) (reverse (reductions (fn [x y] (if (> y (or (last x) 0))\n                            (conj x y)\n                            (vector y)))\n                []\n                %1))))","user":"578b140be4b0ebec4cfb7545"},{"code":"(fn [s] \n  (letfn [(subseq [s]\n          (for [i (range (count s))\n                j (range (+ i 2) (inc (count s)))]\n            (subvec s i j)))\n          (conseq [coll]\n          (= (range (apply min coll) (inc (apply max coll))) coll))]\n    (vec \n      (first\n        (sort-by count > \n               (filter conseq (subseq s)))))))","problem":53,"user":"52d39033e4b099d49816f0c6"},{"problem":53,"code":"#((fn [p] (if (> 2 (count p)) '() p)) (reverse (reduce (fn [a b] (if (> (count a) (count b)) a b)) (reduce (fn [res v] (if (and (not-empty (first res)) (== (dec v) (first (first res)))) (cons (cons v (first res)) (rest res)) (cons (list v) res))) %1 %2)))) '()","user":"52a90056e4b0c58976d9ac39"},{"problem":53,"code":"(\n \n fn \n k \n [x] \n (\n if \n (= 0 (count ( filter (fn [t] (< (first (first t)) (last (first t)) ))  (partition-by (fn [a] (if (< (first a) (second a)) true false)) (partition 2 1 x)) ) ) )\n []\n  \n (concat\n (\n    map first (reduce (fn [j t] (if (< (count j) (count t)) t j ) )  (filter (fn [t] (< (first (first t)) (last (first t)) ))  (partition-by (fn [a] (if (< (first a) (second a)) true false)) (partition 2 1 x))))\n  \n  \n  \n  )\n (\n    list (last (last (reduce (fn [j t] (if (< (count j) (count t)) t j ) )  (filter (fn [t] (< (first (first t)) (last (first t)) ))  (partition-by (fn [a] (if (< (first a) (second a)) true false)) (partition 2 1 x))))))\n  \n  \n  \n  )\n  \n  \n  )\n  \n  \n  \n  ) \n )","user":"53fdc4b8e4b0de5c418485ea"},{"problem":53,"code":"(fn [seq]\n  (let [switch (reductions = true (map < seq (rest seq)))\n        increasing-seqs (map (partial map first)\n                             (partition-by second (map list seq switch)))\n        seqs-longer-than-two (filter #(> (count %) 1) increasing-seqs)]\n    (reduce (fn [x y] (if (< (count x) (count y)) y x)) '()  seqs-longer-than-two)))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn [coll]\n  (let [result\n        (loop [mstreak '()\n               streak [(first coll)]\n               remaining (rest coll)]\n          (let [fst (first remaining)\n                rst (rest remaining)\n                scnt (count streak)\n                mcnt (count mstreak)]\n            (cond (empty? remaining) (if (> scnt mcnt) streak mstreak)\n                  (= (last streak) (dec fst)) (recur mstreak (conj streak fst) rst)\n                  (< scnt mcnt) (recur mstreak [fst] rst)\n                  :else (recur streak [fst] rst))))]\n    (if (< 1 (count result)) result [])))","problem":53,"user":"530cb5b8e4b02e82168697e0"},{"problem":53,"code":"(fn [input-list]\n  (let [sublists\n        (for [i (range (count input-list))] (drop i input-list))\n        get-sequential-list\n        (fn [[first-elem :as slist]]\n          (take-while identity (map #(#{%1} %2) slist (iterate inc first-elem))))\n        solution (first (sort-by count > (map get-sequential-list sublists)))]\n    (if (empty? (rest solution)) [] solution)))","user":"5acd235ae4b0e27600da7824"},{"code":"(fn sub-seq [ns]\r\n        (let [pairs (partition 2 1 ns)]\r\n             (loop [an () ps pairs]\r\n                (if (empty? ps)\r\n                    (let [ns (map first (butlast an))]\r\n                         (concat ns (last an)))\r\n                    (let [[fs rs] (split-with\r\n                                   #(< (first %) (second %)) ps)]\r\n                       (if (< (count an) (count fs))\r\n                           (recur fs (rest rs))\r\n                           (recur an (rest rs))))))))","problem":53,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn [coll]\n  (let [seqs (filter #(let [item (first %)] (< (first item) (last item)))\n                     (partition-by #(< (first %) (last %)) (partition 2 1 coll)))]\n    (if (empty? seqs)\n      []\n      (let [foo (apply max-key count (reverse seqs))]\n        (vec (set (apply concat foo)))\n        ))))","problem":53,"user":"52a55adee4b0c58976d9abe7"},{"problem":53,"code":"(fn longest [coll]  \n  (let [seqs (reduce #(if (= (+ 1 (last (last %))) %2) \n                          (assoc-in % [(- (count %) 1) (count (last %))] %2) \n                          (conj % (vector %2))) [[(first coll)]] (next coll))\n        max (apply max (map count seqs))\n        candidate (first (drop-while  #(not= max (count %)) seqs))]\n    (if (> (count candidate) 1)\n      candidate\n      [])))","user":"534fa9dae4b084c2834f4acf"},{"problem":53,"code":"(fn [coll]\n  (letfn [(streaks [[head :as coll]]\n            (if (empty? coll)\n              ()\n              (let [next-streak (->> (map (fn [a b]\n                                            [a (== a b)])\n                                          coll\n                                          (iterate inc head))\n                                     (take-while #(true? (second %)))\n                                     (map first))]\n                (conj (streaks (drop (count next-streak) coll))\n                      next-streak))))]\n    (->> (streaks coll) \n         (filter next)\n         ((fn [streaks]\n            (if (seq streaks)\n              (apply max-key count streaks)\n              []))))))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":53,"code":"(fn [coll]\n  (loop [lastidx 0\n         lastval (first coll) \n         subcoll (rest coll)\n         longest 1 \n         lidx 0 \n         current 1 \n         cidx 0]\n         \n    (if (empty? subcoll) (if (> longest 1) (take longest (drop lidx coll)) [])\n      (recur \n       (inc lastidx)\n       (first subcoll) \n       (rest subcoll)\n       (if (and (< lastval (first subcoll)) (= current longest)) (inc current) longest)\n       (if (and (< lastval (first subcoll)) (= current longest)) cidx lidx)\n       (if (< lastval (first subcoll)) (inc current) 1)\n       (if (< lastval (first subcoll)) cidx (inc lastidx))\n       )\n    )))","user":"53e76bb2e4b036ad0777e47d"},{"problem":53,"code":"(fn max-subseq [input] \n\n\n  (let [slicefn\n    (fn [acc s]\n      (if (nil? (last (last acc))) \n        (list (list s))\n        (if (> s (last (last acc)))\n          (concat (drop-last 1 acc) (list (concat (last acc) (list s))))\n          (concat acc (list (list s))))))\n    slices (reduce slicefn '(()) input)\n    maxlen (apply max (map count slices))\n    maxseqs (filter #(= maxlen (count %)) slices)\n          ]\n  (if (< maxlen 2) '() (first maxseqs))))","user":"5710140fe4b09c608db7042e"},{"code":"(fn [s]\n    (letfn [(addseqnum [x]\n              (loop [res []\n                     last nil\n                     lastnum 0\n                     todo x]\n                (if (empty? todo)\n                  res\n                  (let [f (first todo)\n                        r (next todo)]\n                    (if (or (nil? last) (<= f last))\n                      (recur (conj res [f (inc lastnum)]) f (inc lastnum) r)\n                      (recur (conj res [f lastnum]) f lastnum r))))))]\n      (let [decorated-seqs (partition-by second (addseqnum s))\n            seqs (map (partial map first) decorated-seqs)\n            sorted-seqs (sort-by #(- (count %)) seqs)\n            candidate (first sorted-seqs)]\n        (if (> (count candidate) 1)\n          candidate\n          []))))","problem":53,"user":"5165a235e4b079ad97ec44ac"},{"problem":53,"code":"(fn longest-increasing-seq\n  [sq]\n  (:longest (reduce (fn [{:keys [longest current] :as acc} elem]\n              (if ((fnil < 0 0) (last current) elem)\n                (assoc acc :current (conj current elem))\n                (if (and (< (count longest) (count current))\n                         (> (count current) 1))\n                  {:longest current :current [elem]}\n                  (assoc acc :current [elem]))))\n            {:longest [] :current []}\n            (conj sq -1))))","user":"5da94ccfe4b000c986472c2f"},{"problem":53,"code":"(fn [s]\n  (let [incs? (fn [[f s]] (= s (inc f)))\n        depart (fn [[f & r]] (concat f (map second r)))]\n    (->>\n      (partition 2 1 s)\n      (partition-by incs?)\n      (filter #(seq %))\n      (filter #(incs? (first %)))\n      (sort-by count >)\n      first\n      depart)))","user":"590b055ae4b047aa04b199c9"},{"problem":53,"code":"(fn [s]\r\n  (->>\r\n    (map list s (rest s))\r\n    (partition-by (partial apply #(= %1 (dec %2))))\r\n    (filter (fn [s] (apply #(= %1 (dec %2)) (first s))))\r\n    (filter #(> (count %) 0))\r\n    (sort-by #(- (count %)))\r\n    first\r\n    (map first)\r\n    ((fn [x] \r\n      (if (empty? x) \r\n        [] \r\n        (concat x (list (inc (last x)))))))))","user":"606e0a42e4b069485764de19"},{"code":"(fn [sq]\n  (letfn [\n          (x [sq]  (partition-by #(< (first %) (second %)) (map list sq (rest sq))))\n          (y [sq]  (filter #(< (first (first %)) (second (first %))) (x sq)))\n          (z [sq]  (sort #(- (count %2) (count %1)) (y sq)))\n          (t [sq]  (let [u (first (z sq))] (if (nil? u) '() (cons (first (first u)) (map second u)))))\n          ]\n    (t sq)))","problem":53,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":53,"code":"(fn longest [v]\n    (letfn [\n        (valid? [v s c]\n            (every? #(> (v %) (v (dec %))) (range (inc s)  (+ s c))))\n\n        (check [v]\n            (let [nv (count v)]\n                (for [ c (range nv 1 -1)\n                       s (range (inc (- nv c)))] [s c])))\n\n        (first-loc [v]\n            (let [[s c] (first (filter (fn [[s c]] (valid? v s c)) (check v)))]\n            (if (nil? s) [] (subvec v s (+ s c)))))\n        ]\n        (first-loc v)))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":53,"code":"(fn [sequence]\n   (let [sorted (->> sequence\n                     (partition 2 1)\n                     (partition-by #(apply < %))\n                     (filter (fn [[[n1 n2]]] (< n1 n2)))\n                     (sort-by count >)\n                     first)]\n     (concat (first sorted) (map last (rest sorted)))))","user":"5fa80c01e4b0fa27300f3de2"},{"code":"(fn [c]\n  (loop [n (count c)]\n    (let [y (some #(when (= % (-> % distinct sort)) %) (partition n 1 c))]\n      (cond\n        (< n 2) []\n        y y\n        1 (recur (- n 1))))))","problem":53,"user":"51b3f109e4b0f094dd986fa9"},{"code":"(fn [nums]\n  (let [res\n    (apply max-key count\n      (reverse\n        (reduce\n        (fn [runs [a b]]\n          (let [next-iter (update-in runs [(dec (count runs))] conj a)]\n          (if (< a b)\n            next-iter\n            (conj next-iter []))))\n      [[]]\n      (conj (vec (partition 2 1 nums)) [(last nums) Integer/MAX_VALUE]))))]\n\n  (if (> (count res) 1) res [])))","problem":53,"user":"526e5be8e4b03e8d9a4a731c"},{"problem":53,"code":"#(->> %\n    ((fn [xs]\n    (loop\n        [best []\n        tmp  []\n        rst  xs]\n        (let [best (max-key count tmp best)]\n        \n            (if (empty? rst)\n                best\n                (if (or\n                        (empty? tmp)\n                        (< (last tmp) (first rst)))\n                    (recur\n                        best\n                        (concat tmp [(first rst)])\n                        (rest rst))\n                    (recur\n                        best\n                        [(first rst)]\n                        (rest rst))))\n        ))))\n     ((fn [xs]\n        (if (>= (count xs) 2)\n            xs \n            [])))\n     )","user":"5ea2e6bfe4b00a66d4a95197"},{"code":"(fn [v] \n  (let [tf (comp true? first)\n        p (filter (comp tf first) (partition-by tf \n            (map #(vector (apply < %) %) (partition 2 1 v))))]\n      (if (empty? p) []\n        (let [r (reduce #(if (>= (count %) (count %2)) % %2) p)]\n          (concat (map #(first (second %)) (butlast r)) (second (last r)))))))","problem":53,"user":"4fb3b865e4b081705acca2a2"},{"code":"(fn [coll]\n  (let [zipped (map list coll (concat (drop 1 coll) (list -1)))]\n    (loop [best    nil\n           left    zipped]\n      (if (empty? left)\n        (if (> (count best) 0)\n          (if (apply < (last best))\n            (concat (map first best) (list (second (last best))))\n            (map first best))\n          (list))\n        (let [[best1 left]  (split-with\n                             #(apply < %) (second (split-with\n                                                   #(apply >= %) left)))\n              thebest       (if (> (count best1) (count best)) best1 best)]\n          (recur thebest left))))))","problem":53,"user":"4e71705e535d5021c1a89649"},{"code":"(fn [l]\n  (if (empty? l)\n    []\n    (let [go (fn [acc x]\n               (let [init (apply vector (butlast acc))\n                     l    (last acc)\n                     l'   (last l)]\n                 (if (< l' x)\n                   (conj init (conj l x))\n                   (conj acc [x]))))\n          subseqs (reduce go [[(first l)]] (rest l))\n          max-subseq (apply max-key count (reverse subseqs))]\n      (if (= 1 (count max-subseq)) [] max-subseq))))","problem":53,"user":"509c03f3e4b085ae113522a8"},{"problem":53,"code":"(fn [S] (or (first (filter (partial apply <) (mapcat (fn [l] (partition l 1 S)) (range (count S) 1 -1)))) []))","user":"55f6fe09e4b06e875b46cea2"},{"problem":53,"code":"(fn [v]\n  (letfn [(incr [prev accum rst]\n            (if (empty? rst) [accum]\n                (let [cur (first rst)]\n                  (cond (nil? prev) (incr cur [cur] (rest rst))\n                        (< prev cur) (incr cur (conj accum cur) (rest rst))\n                        :else (cons accum (incr cur [cur] (rest rst)))))))\n          (longest [a len]\n            (let [cur (first a)]\n              (if (= len (count cur)) cur\n                  (longest (rest a) len))))]\n    (let [accums (incr nil [] v)\n          max-len (reduce max (map count accums))]\n      (if (= max-len 1) []\n          (longest accums max-len)))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":53,"code":"(fn [col]\n  (let [\n    g2 (fn g2 [ & {:keys [data id] :or {id 0}}]\n        (let [[a & r] data, [b & _] r]\n          (cond\n            (empty? data)\n              '()\n            (= (inc a) b)\n              (lazy-seq (cons id (g2 :data r, :id id)))\n            :else\n              (lazy-seq (cons id (g2 :data r, :id (inc id))))\n          )))\n    ]\n    (->>\n      (map vector col (g2 :data col))\n      (partition-by second)\n      (filter #(> (count %) 1))\n      (map #(map first %))\n      (sort-by count)\n      (cons '()) ;; insert fallback element if no entries\n      (last)\n    )))","user":"5c219c0fe4b07e362c230581"},{"code":"(fn [col] (if (empty? col)\n            []\n            (let [res (apply max-key count (reverse ((fn [acc col]\n                                    (if (empty? col)\n                                      acc\n                                      (let [cur (last acc) a (last cur) b (first col)]\n                                        (if (< a b)\n                                          (recur (assoc acc (dec (count acc)) (conj cur b)) (rest col))\n                                          (recur (conj acc [b]) (rest col))\n                                         ))))\n                                   [[(first col)]] (rest col))))]\n              (if (> (count res) 1) res []))))","problem":53,"user":"4faf97d8e4b081705acca258"},{"problem":53,"code":"(fn [s]\n  (let [c (count s)\n        t (map - s (range c)) ;; Test cases only use consequtive integers!!\n        u (partition-by #(nth t %) (range c))\n        v (first (sort-by count > u))]\n    (if (> (count v) 1)\n      (map #(nth s %) v)\n      [])))","user":"58b26da4e4b0ebc645576d0a"},{"problem":53,"code":"(fn [elems] \n   (letfn [(first_is_greater [[a b]](= (inc a) b))]\n   (->>\n     (map list elems (concat (rest elems) [(first elems)]))\n     (partition-by first_is_greater)\n     (filter #(every? first_is_greater %))\n     (concat [[]])\n     (apply max-key count)\n     (flatten)\n     (distinct)\n   )))","user":"543f854fe4b032a45b86935b"},{"code":"(fn [numbers]\n    (loop [\n        longest-monotonic []\n        current-monotonic [(first numbers)]\n        rest-numbers (rest numbers)]\n\n        (let [\n            nxt (first rest-numbers)\n            append? (fn [number] (and (number? nxt) (> nxt (last current-monotonic))))\n            largest (fn [] (last (sort-by count [current-monotonic longest-monotonic])))]\n\n            (cond\n                (append? nxt)\n                    (recur longest-monotonic (conj current-monotonic nxt) (rest rest-numbers))\n                (number? nxt)\n                    (recur (largest) [nxt] (rest rest-numbers))\n                true\n                    (if (= 1 (count (largest))) [] (largest))))))","problem":53,"user":"504e2a3fe4b0f6ff3350c477"},{"problem":53,"code":"(fn[coll]\n  (loop [longest_coll [] temp_coll [(first coll)] rest_coll (rest coll)]\n    (if (empty? (seq rest_coll))\n      (if (and (< (count longest_coll) (count temp_coll)) (< 1 (count temp_coll)))\n        temp_coll\n        longest_coll)\n      (if (= (inc (last temp_coll)) (first rest_coll))\n        (recur longest_coll (conj temp_coll (first rest_coll)) (rest rest_coll))\n        (if (and (< (count longest_coll) (count temp_coll)) (< 1 (count temp_coll)))\n          (recur temp_coll [(first rest_coll)] (rest rest_coll))\n          (recur longest_coll [(first rest_coll)] (rest rest_coll)))))))","user":"56163cc1e4b06b1bb21829ff"},{"code":"(fn [input]\n  ;; these comments best read from bottom to top\n  ;; now we have a sequence of consecutive lists, so find the longest\n  ;; we could use (max) here instead \n  ;; but to make sure the first item encountered is the one selected we do it explicitly\n  ;; extra check for length 1 solutions -> use the initial solution (empty list) instead\n  (reduce #(cond \n            (= (count %2) 1) %1\n            (> (count %2) (count %1)) %2\n            :else %1) []\n    (map (fn [coll] \n           ;; each item we have at this point is actually  a matching [value expected-value] tuple, \n           ;; so drop the duplicte number\n           (map first \n                ;(remove #(zero? (count %))\n                ;; take the leading items where the value matches the expected-value (i.e. sequential numbers)\n                (take-while #(= (first %) (last %)) coll)))\n      ;; Create multiple mappings of {below} by iteratively dropping the leading list item\n      (for [offset (range 0 (count input))\n            :let [xs (drop offset input)]]\n        ;; Create a [value expected-value] pair for each number where expected-value isa?\n        ;; a range starting with the first value in the collection\n        ;; for example (1 5 7) -> ([1 1] [5 2] [7 3])\n        (map #(vector %1 %2) xs (range (first xs) (+ (first xs) (count xs))))))))","problem":53,"user":"534d5ab7e4b084c2834f4a9c"},{"problem":53,"code":"(fn [col]\n  (let [idxs (concat (map-indexed (fn [idx [x y]] (vector x y (< x y) idx)) (partition 2 1 col)))\n        parts (partition-by (fn [[_ _ x _]] x) idxs)\n        filt-parts (filter #(let [[_ _ x _] (first %)] x) parts)\n        max-cnt (apply max (map #(count %) parts))\n        best (some #(when (= max-cnt (count %)) %) filt-parts)\n        ]\n    (distinct (mapcat #(vector (first %) (second %)) best))))","user":"54c94376e4b045293a27f665"},{"problem":53,"code":"(letfn [\n\n  ;; One step in the process of constructing the increasing subsequences\n  (add-to-seq [r curr]\n\n    (let [\n          last-seq (last r),\n          last-el (last last-seq)]\n\n      (if (or\n            (nil? last-el)\n            (> curr last-el))\n\n        ;; Add to the last sequence\n        (conj (pop r) (conj last-seq curr))\n\n        ;; Start a new sequence\n        (conj r (vec (list curr))))))\n\n  ;; Compare two collections; bigger is greater\n  (by-count [a b]\n    (> (count a) (count b)))\n        \n  ;; Take the subsequence that meets the criteria\n  (extract-correct-subseq [coll]\n    (let [\n          candidate (first (sort by-count coll))]\n      (if (> (count candidate) 1)\n        candidate\n        [])))]\n  \n  ;; Take the first longest increasing subsequence that is greater than 2\n  ;; elements long.\n  ;; If not found, return []\n  (fn [coll] (extract-correct-subseq (reduce add-to-seq [[]] coll))))","user":"57300c19e4b0cd1946bd0fa1"},{"problem":53,"code":"(fn [xs]\n  (loop [[first & rest] xs\n         acc []\n         best []]\n    (cond\n      (nil? first) best\n      (> first (or (last acc) 0))\n      (let [new-acc (conj acc first)]\n        (recur rest\n               new-acc\n               (if (and (< 1 (count new-acc))\n                        (< (count best) (count new-acc))) new-acc best)))\n      :else (recur rest [first] best))))","user":"5687b6abe4b0dcc4269f4061"},{"problem":53,"code":"(fn [coll] (let [find-inc-seq (fn f1\n  [coll sub-coll] \n  (if (and (not= (first coll) nil) \n        (or (= (first sub-coll) nil) \n            (< (first sub-coll) (first coll)))) \n    (f1 (next coll) (cons (first coll) sub-coll)) \n    [coll sub-coll]))\n                 iter-find-inc-seq (fn \n                   [[coll sub-coll]] \n                   (let [[r s] (find-inc-seq coll ())]   \n                     [r s]))\n                 find-all-inc-seqs (fn \n                   [coll]\n                   (take-while #(or (not= (first %) nil) \n                                    (not= (first (last %)) nil))\n                     (iterate iter-find-inc-seq [coll ()])))\n                 find-longest-inc-seq (fn \n                   [coll]\n                   (reverse \n                     (last \n                       (reduce #(if (>= (count (last %1)) (count (last %2))) \n                                 %1\n                                 %2)\n                           (find-all-inc-seqs coll)))))\n                 r (find-longest-inc-seq coll)]\n             \t\t(if (>= (count r) 2) r ())\n            \n                 ))","user":"58edaa3be4b056aecfd47d89"},{"problem":53,"code":"(fn increasing-subseq [coll]\n\t(letfn [(max-of-seq [s1 s2] (if (> (count s1) (count s2)) s1 s2))\n\t\t\t(is-incr [v1 v2] (and (not (nil? v1)) \n\t\t\t\t\t\t\t\t  (not (nil? v2))\n\t\t\t\t\t\t\t\t  (= 1 (- v2 v1))))]\n\t\t\t(loop [remaining coll\n\t\t\t\t   sub-seq []\n\t\t\t\t   max-seq []]\n\t\t\t(cond\n\t\t\t\t(empty? remaining) (max-of-seq sub-seq max-seq)\n\t\t\t\t(is-incr (last sub-seq) (first remaining))\n\t\t\t\t\t(recur (rest remaining) (conj sub-seq (first remaining)) max-seq)\n\t\t\t\t(is-incr (first remaining) (second remaining))\n\t\t\t\t\t(recur (rest (rest remaining)) \n\t\t\t\t\t\t   [(first remaining) (second remaining)]\n\t\t\t\t\t\t   (max-of-seq sub-seq max-seq))\n\t\t\t\t:else (recur (rest remaining) [] (max-of-seq sub-seq max-seq))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":53,"code":"#(let [biggest (reduce (fn [m n] (println m n) (cond (or (empty? (m :current)) (> n (peek (m :current)))) {:biggest (m :biggest) :current (conj (m :current) n)}\n                                                              (<= n (peek (m :current))) (if (> (count (m :current)) (count (m :biggest))) {:biggest (m :current) :current (vector n)} {:biggest (m :biggest) :current (vector n)})\n                                                              ))\n                                { :biggest []  :current [] }\n                                %\n                                )] (let [check-size (if (>= (count (biggest :biggest )) (count (biggest :current))) (biggest :biggest) (biggest :current))] (if (> (count check-size) 1) check-size [] )))","user":"5b100648e4b0cc2b61a3be17"},{"code":"(fn inc-seq ([c] (inc-seq [(first c)] [(first c)] (rest c)))\r\n  ([c1 c2 c] (if (< (count c) 1) (if (> (count c1) 1) c1 [])\r\n    (if (not= (first c) (inc (peek c2))) (recur c1 [(first c)] (rest c))\r\n      (if (> (inc (count c2)) (count c1))\r\n        (recur (conj c2 (first c)) (conj c2 (first c)) (rest c))\r\n        (recur c1 (conj c2 (first c)) (rest c)))))))","problem":53,"user":"4fd29d7ce4b04c3a95aa0424"},{"problem":53,"code":"#(last (sort-by count\r\n                (for [b (range (count %))\r\n                      e (range (+ b 2) (inc (count %)))]\r\n                  (let [n (subvec % b e)]\r\n                    (if (= n (range (first n) (+ (first n) (count n))))\r\n                      n\r\n                      [])))))","user":"5f2c02d1e4b033932238a65f"},{"code":"#(loop [xs %, best-c 0, best-s '()]\n  (if (< (count xs) 2) best-s\n    (let [s (map second (take-while (fn [p] (< (first p) (second p))) (partition 2 1 xs)))\n          ss (if (empty? s) s (cons (first xs) s))\n          c (count ss)\n          [next-c next-s] (if (> c best-c) [c ss] [best-c best-s])]\n      (recur (rest xs) next-c next-s))))","problem":53,"user":"4f6160a7e4b0defedf855fbe"},{"problem":53,"code":"(fn [coll]\n  (loop [c (rest coll) r [(first coll)] max_r []]\n    (if (empty? c)\n      (if (< 1 (count max_r)) max_r [])\n      (let [r (if (< (last r) (first c)) (conj r (first c)) [(first c)])\n            max_r (if (> (count r) (count max_r)) r max_r)]\n        (recur (rest c) r max_r)))))","user":"606a70a5e4b069485764ddf2"},{"code":"(fn [s]\n  (loop [[x y & xs :as all] s r [] c [x]]\n    (let [size-c (count c) \n          new-r (if (and (> size-c 1) (> size-c (count r))) c r) \n          new-c (if (= (inc (last c)) y) (conj c y) [y])]\n      (if (and x y)\n        (recur (next all) new-r new-c)\n        new-r\n      )\n    )\n  )\n)","problem":53,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn [coll]\n  (let [max\n    ((fn max-range [coll curr-i curr-count max-i max-count]\n      (cond\n        (or (empty? coll) (nil? (second coll)))\n          (if (> curr-count max-count)\n            [(- curr-i (dec curr-count)) curr-count]\n            [max-i max-count])\n        (< (first coll) (second coll))\n          (if (> curr-count max-count)\n            (max-range (rest coll)\n                       (inc curr-i)\n                       (inc curr-count)\n                       (- curr-i (dec curr-count))\n                       curr-count)  \n            (max-range (rest coll)\n                       (inc curr-i)\n                       (inc curr-count)\n                       max-i\n                       max-count))\n        :else\n          (if (> curr-count max-count)\n            (max-range (rest coll)\n                       (inc curr-i)\n                       1\n                       (- curr-i (dec curr-count))\n                       curr-count)\n            (max-range (rest coll)\n                       (inc curr-i)\n                       1\n                       max-i\n                       max-count))))\n      coll 0 1 0 1)]\n    (if (< (max 1) 2)\n      (empty coll)\n      (into (empty coll) (take (max 1) (drop (max 0) coll)))))) ; wow, gins&tonic","problem":53,"user":"4fdb881ee4b05e33b9224f5e"},{"problem":53,"code":"(fn [coll]\n  (loop [best []\n         current []\n         coll coll]\n    (cond\n      (empty? coll) (if (and (> (count current) (count best))\n                             (> (count current) 1))\n                      current\n                      best)\n\n      (empty? current) (recur best [(first coll)] (rest coll))\n\n      (> (first coll) (last current))\n      (recur best (conj current (first coll)) (rest coll))\n\n      (and (< 1 (count current))\n           (> (count current) (count best)))\n      (recur current [] coll)\n\n      :else\n      (recur best [] coll))))","user":"5c633df2e4b0fca0c162265c"},{"code":"(fn [coll]\n        (let [loc-longest-match (fn [contender default]\n                                  (if (and (> (count contender) (count default))\n                                           (> (count contender) 1))\n                                    contender\n                                    default)\n                                  )]\n          (loop [c    coll\n                 curr []\n                 best []]\n            (cond\n             (empty? c) (loc-longest-match curr best)\n             (= (last curr) (dec (first c)))  (recur (rest c) (conj curr (first c)) best)\n             :else (recur (rest c) [(first c)] (loc-longest-match curr best))))\n          ))","problem":53,"user":"4efec33f535dcb61093f6a2a"},{"problem":53,"code":"(fn sseq [v]\n\t(loop [li (conj v (dec (first v))) cur '[] r '[]]\n\t\t(if (empty? li)\n\t\t\t(if (> (count r) 1) r [])\n\t\t\t(recur (rest li)\n\t\t\t\t\t\t (if (and (not (nil? (last cur))) (= (first li) (inc (last cur))))\n\t\t\t\t\t\t\t (conj cur (first li))\n\t\t\t\t\t\t\t (conj [] (first li)))\n\t\t\t\t\t\t (if (> (count cur) (count r))\n\t\t\t\t\t\t\t cur\n\t\t\t\t\t\t\t r)))))","user":"52979551e4b02ebb4ef75043"},{"problem":53,"code":"(fn [xs]\n  (let [[longest current] (reduce (fn [[longest [last-n :as all]] n]\n                                    (if (or (nil? last-n) (= (inc last-n) n))\n                                      [longest (conj all n)]\n                                      (if (and (> (count all) (count longest))\n                                               (> (count all) 1))\n                                        [all (list n)]\n                                        [longest (list n)])))\n                                  ['() '()] xs)]\n    (if (and (< (count longest) (count current))\n             (< 1 (count current)))\n      (reverse current)\n      (reverse longest))))","user":"5338387de4b0e30313ee6c91"},{"problem":53,"code":"(fn [coll]\n  (loop [c coll\n         r []\n         cu []]\n    (if (empty? c)\n      r\n      (let [v (first c)\n            p (if (seq cu) (last cu))\n            new-cu (if (or (empty? cu)\n                           (and p (= (inc p) v)))\n                     (conj cu v)\n                     [v])\n            ccu (count new-cu)]\n        (recur (rest c)\n               (if (and\n                     (> ccu (count r))\n                     (> ccu 1))\n                 new-cu\n                 r)\n               new-cu)))))","user":"5541fa50e4b0a04f79299515"},{"code":"(fn [coll]\n   (let [seqs (reverse (map #(concat (first %) (map (fn [i] (last i)) (rest %)))\n                        (filter #(every? (fn [ele] (< (first ele) (last ele))) %)\n                          (partition-by\n                            #(< (first %) (last %))\n                            (partition 2 1 coll)))))]\n    (if (empty? seqs)\n     []\n     (apply (partial max-key count) seqs))))","problem":53,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn [s]\n    (last\n      (sort-by count\n               ((fn [s n c r]\n                    (cond (empty? s) (conj r c)\n                          (= (inc n) (first s)) (recur (rest s) (first s)\n                                                       (apply conj c (if (empty? c) (vector n (first s)) (vector (first s)))) r)\n                          :else (recur (rest s) (first s) [] (conj r c))))\n                (rest s) (first s) [] []))))","problem":53,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":53,"code":"(fn [coll]\n  (->> (reduce #(if (empty? %)\n                  [[%2]]\n                  (if (> %2 (last (last %)))\n                    (conj (pop %) (conj (peek %) %2))\n                    (conj % [%2])))\n               []\n               coll)\n       (filter #(> (count %) 1))\n       (reduce #(if (> (count %2) (count %)) %2 %) [])))","user":"5d5166d9e4b0776584bd6f5e"},{"code":"(fn [xs]\n  (->> (partition 2 1 xs)\n       (partition-by #(apply < %))\n       (filterv #(apply < (first %)))\n       (mapv #(reduce (fn [v x] (conj v (second x))) [(first (first %))] %))\n       (reduce #(if (< (count %1) (count %2)) %2 %1) [])))","problem":53,"user":"50f9739ce4b0e7c80cb15a4d"},{"problem":53,"code":"(fn [s]\n  (let [suites (loop [[x & xs :as remaining] s\n         \t\t\t   suite []\n         \t\t\t   all-suites []]\n    \t\t\t (if (empty? remaining)\n        \t\t\t \t(conj all-suites suite)\n        \t\t\t\t(if (< (or (last suite) -1) x)\n\t\t\t            \t(recur xs (conj suite x) all-suites)\n            \t\t\t\t(recur xs [x] (conj all-suites suite)))))]\n   (reduce (fn [acc seq]\n             (if (and (> (count seq) (count acc))\n                      (> (count seq) 1))\n                 seq\n                 acc))\n           [] suites)))","user":"5afa9de0e4b0cc2b61a3bcf1"},{"problem":53,"code":"(fn [xs]\n  (loop [best-index 0\n         best-len 1\n         cur-len 1\n         i 1]\n    (if (= i (count xs))\n      (if (= 1 best-len)\n        []\n        (subvec xs best-index (+ best-index best-len)))\n      (let [new-len (if (< (get xs (- i 1)) (get xs i))\n                      (+ cur-len 1)\n                      1)\n            [best-len best-index] (if (> new-len best-len)\n                                    [new-len (+ i (- new-len) 1)]\n                                    [best-len best-index])]\n        (recur best-index best-len new-len (+ i 1)))\n      )\n    )\n  )","user":"5a7497d2e4b0512ff01cdaba"},{"code":"(fn longestIncSubseq[coll] (let [\n  incmap (group-by count (filter #(> (count %) 1) (\n    reductions #(if (> %2 (first %1)) (cons %2 %1) [%2]) [(first coll)] coll)\n      )), maxkey (if (empty? incmap) -1 (reduce max (keys incmap)))  \n    ] (reverse (first (get incmap maxkey [])))\n  )  \n)","problem":53,"user":"4fce75cfe4b03432b189f400"},{"problem":53,"code":"(fn [items]\n  (loop [seq-items(rest items) current [(first items)] result []]\n    (let [item (first seq-items) last-item (last current) valid? (and (not (nil? item)) (= (inc last-item) item))]                                                                      \n      (if (nil? item) \n        result      \n        (recur (rest seq-items) \n               (if valid?\n                 (conj current item)\n                 [item])\n               (if (and valid? (>= (count current) (count result)))\n                 (conj current item)\n                 result))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [x] (first ((fn [a] (reduce \n         #(let [p (first %) q (last %) r (conj q %2)] (if (> %2 (last q)) \n            (if (<= (count p) (count q)) \n              (cons r [(vec r)]) \n              (cons p [(vec r)])) \n            (cons p [[%2]])) ) [[][9]] a)  ) x)))","problem":53,"user":"52c6a0abe4b0c2d177d62111"},{"problem":53,"code":"(fn linc-subseq [coll]\n  (loop [acc []\n         res []\n         [head & more :as all] coll]\n    (cond\n      (nil? head) (->> (conj res acc)\n                       (filter #(>= (count %) 2))\n                       (sort-by count)\n                       (last)\n                       (vec))\n      (or (empty? acc)\n          (= head (inc (peek acc)))) (recur (conj acc head) res more)\n      :else (recur [] (conj res acc) all))))","user":"58a2b57fe4b02bd94d917ede"},{"problem":53,"code":"(fn [coll] \n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter #(< (ffirst %) (last (last %))) a)]\n    (distinct (flatten (first (sort-by count > b))))))","user":"5456e4e7e4b080a794c2c883"},{"problem":53,"code":"(fn [in]\n    (let [switch (reductions = true (map #(= (inc %1) %2) in (rest in)))]\n      (->> (map list switch in)\n           (partition-by first)\n           (map (partial map last))\n           (apply max-key count)\n           (#(if (= 1 (count %)) [] %)))))","user":"5602bdf9e4b04bb52996e1a7"},{"problem":53,"code":"(fn longest-increasing-subsequence [s]\n\t(loop [[a b & _ :as all] s\n\t\t\tcurrent []\n\t\t\tresult []]\n\t\t(if (nil? a) \n\t\t\t;return longest result\n\t\t\t(let [r (first (sort #(> (count %1) (count %2)) (filter #(> (count %1) 1) result)))]\n\t\t\t\t(if (nil? r) [] r)\n\t\t\t)\n\t\t\t(if (and (not (nil? b)) (< a b))\n\t\t\t\t(recur (rest all) (conj current a) result)\n\t\t\t\t(recur (rest all) [] (conj result (conj current a)))\n\t\t\t)\n\t\t)\n\t)\n)","user":"57a9db97e4b0b8559636fc5b"},{"code":"(fn [col]\n   \t(:best (reduce \n\t\t\t(fn [dict x]\n\n              (let [best (:best dict) \n\t\t\t\t\tprev (:current dict) \n\t\t\t\t\tcurrent (if (or (empty? prev)(> x (last prev))) \n\t\t\t\t\t\t\t\t(conj prev x)   \n\t\t\t\t\t\t\t\t[x])]\n\t\t\t\t(if (and (> (count current) (count best)) (> (count current) 1))\n                       {:best current\n                        :current current}\n                       {:best best\n                       :current current})))\n            {:best []\n             :current [] }\n            col)))","problem":53,"user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [x]\r\n    (letfn\r\n      [(keep [[a b & r :as l]]\r\n             (if (or (nil? b) (empty? l)) [a]\r\n               (if (< b a)\r\n                 (concat [a] (keep (rest l)))\r\n                 [a])))]\r\n      (let [result (reverse (reduce #(if (> (count %1) (count %2)) %1 %2)\r\n              (map #(keep (drop % (reverse x))) (range 0 (count x)))))]\r\n           (if (> (count result) 1) result ()))))","problem":53,"user":"4fea08a9e4b0547ebccb2484"},{"code":"(fn [sq]\n  (loop [current-sq (vector (first sq))\n         longest-sq []\n         rest-sq    (rest sq)]\n    (cond (empty? rest-sq)\n          (cond (and (< (count longest-sq) 2)\n                     (< (count current-sq) 2))\n                []\n                (< (count longest-sq) (count current-sq))\n                current-sq\n                true\n                longest-sq)\n          (= (first rest-sq) (inc (last current-sq)))\n          (recur (conj current-sq (first rest-sq))\n                 longest-sq\n                 (rest rest-sq))\n          true\n          (recur (vector (first rest-sq))\n                 (if (< (count longest-sq)\n                        (count current-sq))\n                   current-sq\n                   longest-sq)\n                 (rest rest-sq)))))","problem":53,"user":"4fdbc075e4b05e33b9224f61"},{"problem":53,"code":"(fn [coll]\n  (letfn [(one? [coll] (= 1 (count coll)))\n          (consec? [a b] (= (inc a) b))\n          (collect-runs [[[prev & _ :as run] & more :as runs] x]\n            (if (consec? prev x)\n              (conj more (conj run x))\n              (conj (if (> (count run) 1) runs more) (list x))))]\n    (->> coll\n        (reduce collect-runs (list (list Long/MIN_VALUE)))\n        (drop-while one?)\n        (sort-by count >)\n        (first)\n        (reverse))))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn [coll]\n  (->> \n    (range 2 (inc (count coll)))\n    (mapcat #(partition % 1 coll))\n    (filter #(apply < %))\n    (cons [])\n    (sort-by count >)\n     first))","problem":53,"user":"4fb1d907e4b081705acca282"},{"code":"(fn find-seq\n  [data]\n  (last \n   (sort-by \n    count\n    (filter \n     (fn [e] (not (= (count e) 1)))\n     (reduce \n      #(if (= (last (last %1)) (dec %2))\n         (conj %1 (conj (last %1) %2))      \n         (conj %1 [%2]))\n      [[]] \n      data)))))","problem":53,"user":"51e780dae4b0730ab87cf353"},{"problem":53,"code":"( fn [coll]\n  \n(let [ \n     sequences (reduce\n                 (fn [ [run maxrun] x ]\n                   (let [\n                         run    (if (= (last run) (dec x))\n                                  (conj run x)\n                                  [x])\n                         maxrun (if (> (count run) (count maxrun)) run maxrun )\n                         ]\n                     [run maxrun]\n                   )\n                  )\n  \t\t\t\t\t[[] []]\n                  coll\n               )\n      ]\n (if (>= (count (last sequences)) 2) (last sequences)  []    )\n))","user":"5ac85708e4b0e27600da77ac"},{"problem":53,"code":"(fn longest-asc [coll]\n  (or (->> coll\n       (partition 2 1)\n       (partition-by #(< (first %) (last %)))\n       (filter #(let [f (first %)] (< (first f) (last f))))\n       (map #(conj (vec (map first %)) (last (last %))))\n       (sort-by #(- (count %)))\n       first) ()))","user":"5dc40814e4b02f9375f4e1ae"},{"code":"(fn lgsub\n  ([[a b :as ls]] (lgsub ls [a] [a]))\n  ([[a b :as ls] curacc acc]\n     (cond (or (nil? ls) (nil? b)) (if (>= (count acc) 2) acc [])\n           (= (inc a) b)\n           (lgsub (rest ls) (conj curacc b)\n                  (if (>= (count curacc) (count acc))\n                    (conj curacc b)\n                    acc))\n           :else (lgsub (rest ls) [b] acc))))","problem":53,"user":"5301157ae4b0d8b024fd3717"},{"problem":53,"code":"(fn [xs]\n  (let [{:keys [longest current]}\n        (reduce\n         (fn [{:keys [longest current] :as acc} next]\n           (let [lc (last current)]\n             (cond\n               (empty? current) (assoc acc :current [next])\n               (< lc next) (assoc acc :current (conj current next))\n               :else (if (< (count longest) (count current))\n                       {:longest current :current [next]}\n                       (assoc acc :current [next]))))) {:longest [] :current []} xs)\n        longest (if (= (count longest) 1) [] longest)\n        current (if (= (count current) 1) [] current)]\n\n    (if (< (count longest) (count current)) current longest)))","user":"5fb46916e4b08cb800c85b46"},{"code":"(fn [sq]  \r\n     (let [f\r\n   (fn f \r\n     ([sq] (f (rest sq) (list (first sq)) (list (first sq))))\r\n     ([sq acc lns] \r\n       (let [longest #(if (> (count %1) (count %2)) %1 %2)]\r\n         (if (empty? sq) \r\n           lns\r\n           (let [nacc (if (> (first sq) (first acc))\r\n                        (cons (first sq) acc)\r\n                        (list (first sq)))]\r\n             (f (rest sq) nacc (longest nacc lns))\r\n             )))))\r\n     result (f sq)]\r\n     (if (= 1 (count result)) '() (reverse result))      \r\n    ))","problem":53,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [coll]\r\n  (->> (partition 2 1 coll) \r\n    (partition-by #(- (second %) (first %))) \r\n    (filter #(= 1 (- (second (first %)) (ffirst %)))) \r\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\r\n    (flatten)\r\n    (distinct)))","problem":53,"user":"4dd579b5535dae65d5c462ea"},{"problem":53,"code":"(let [runs (fn runs [xs0]\n               (if-let [[x & xs] xs0]\n                 (loop [x x xs xs acc []]\n                   (if-let [[y & ys] xs]\n                     (if (> y x)\n                       (recur y ys (conj acc x))\n                       (cons (conj acc x) (runs (conj ys y))))\n                     [(conj acc x)]))\n                 []))]\n    (fn [a] (let [out (apply max-key count (reverse (runs a)))]\n              (if (<= (count out) 1)\n                []\n                out))))","user":"5fa416ece4b0f0ebd91b7803"},{"code":"(fn [lst]\r\n  (let\r\n    [f53\r\n      (fn f\r\n        ([[s e cs ce]]\r\n          (let [[is ie] (if (>= (- e s) (- ce cs)) [s e] [cs ce])]\r\n            (if (< (- ie is) 1)\r\n              []\r\n              (filter number?\r\n                (map-indexed \r\n                  (fn [n v] \r\n                    (if (and (>= n is) (<= n ie)) v nil))\r\n                  lst)))))\r\n        ([[s e cs ce] xs]\r\n          (if (= xs []) (f [s e cs ce])\r\n          (if (< (nth lst ce) (first xs))\r\n            (f [s e cs (inc ce)] (rest xs))\r\n            (if (>= (- e s) (- ce cs))\r\n              (f [s e (inc ce) (inc ce)] (rest xs))\r\n              (f [cs ce (inc ce) (inc ce)] (rest xs)))))))]\r\n    (f53 [0 0 0 0] (rest lst))))","problem":53,"user":"50c9ece0e4b0a409464667d8"},{"code":"(fn [s]\n  (let [x (->>\n    (range (count s) 1 -1)\n    (mapcat #(partition % 1 s))\n    (filter #(apply < %))\n    reverse\n    )\n  ] (if (seq x) (apply max-key count x) '())))","problem":53,"user":"4f9d8083e4b0dcca54ed6d23"},{"problem":53,"code":"(fn lon-inc-subseq\n  [coll]\n  (let [longest (apply max-key count\n                        (reduce (fn [y x]\n                                  (if (= (inc (last (first y))) x)\n                                    (conj (rest y) (conj (first y) x))\n                                    (conj y [x])))\n                                (list [(first coll)])\n                                (rest coll)))]\n    (if (> 2 (count longest)) [] longest)))","user":"56f15eade4b04a395b9a048e"},{"problem":53,"code":"(fn [xs]\n   (->> (interleave (partition-all 2 2 xs)\n               (partition-all 2 2 (rest xs)))\n        (filter (fn [ns] (> (count ns) 1)))\n        (partition-by (fn [[a b]] (> b a)))\n        (filter (fn [[[a b]] & _] (> b a)))\n        (sort-by count)\n        reverse\n        (partition-by count)\n        first\n        last\n        flatten\n        set\n        sort))","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":53,"code":"#(letfn [(max-seq [[as bs]] (if (< (count as) (count bs)) bs as))]\n   (when-let\n     [lis (max-seq (reduce\n                     (fn [[xs' xs :as xss] x]\n                       (if (and (seq xs) (> x (peek xs)))\n                         [xs' (conj xs x)]\n                         [(max-seq xss) [x]]))\n                     [[] []] %))]\n     (if (< 1 (count lis)) lis [])))","user":"53dfdf01e4b0d874e779ae46"},{"problem":53,"code":"#(apply max-key count (filter (fn [x] (not= (count x) 1)) (reduce (fn inner [r v] (if \n\t(= (last (last r)) (dec v))\n\t(conj (vec (drop-last r)) (conj (last r) v))\n\t(conj r (vector v))\n\t)) [[]] %)))","user":"5587d8b3e4b059ccff29b1e8"},{"code":"(fn [xs]\n   (let [increasing? #(apply < %)\n         sub-seqs (mapcat #(partition % 1 xs) (range 2 (inc (count xs))))]\n     (->> sub-seqs\n          (filter increasing?)\n          (cons [])\n          (sort-by count >)\n          first)))","problem":53,"user":"521679e9e4b0bf4bffd29cca"},{"problem":53,"code":"(fn [col]\n    (let [seqs  (let [lastseen (atom (dec (first col)))\n                      counter  (atom 1)]\n                  (partition-by (fn [v]\n                                  (if-not (= (inc @lastseen) v)\n                                    (reset! counter (inc @counter)))\n                                  (reset! lastseen v)\n                                  @counter) col))\n          longest (first (sort-by count > seqs))]\n      (if (> (count longest) 1)\n        longest\n        []))\n    )","user":"57aa290de4b0b8559636fc65"},{"problem":53,"code":"#(let [increasing? (fn [[x y]] (> y x))]\n   (->> (partition 2 1 %)                 ;; get pairs\n        (partition-by increasing?)        ;; partition by increasing/not-inc.\n        (filter (comp increasing? first)) ;; keep increasing pairs\n        (sort-by count >)                 ;; longest increasing sequence\n        first                             ;; \"\"\n        flatten                           ;; flatten and dedupe (not in 1.4)\n        (partition-by identity)\n        (map first)))","user":"56ff45e5e4b08d47c97781bb"},{"code":"#(reverse\n  (last\n   (filter (fn [l] (<= 2 (count l)))\n    (sort (fn [l1 l2] (- (count l1) (count l2) ) ) \n  \t(\n     reduce\n     (fn [a i]\n      (\n     \t  if (= (inc (first (first a))) i)     \n       \t\t (cons  (cons i (first a))  (rest a))\n       \t\t (cons (list i) a)\n       )\n      )\n    (list (list (first %)) )  (rest %) \n     )\n        )\n   )\n  )\n  )","problem":53,"user":"51e1c176e4b06a68e693eafb"},{"problem":53,"code":"(fn [x]\n  (reduce #(if (and (< 1 (count %2)) (< (count %1) (count %2))) %2 %1) []\n          (reduce (fn [a s]\n                    (if (and (last (last a)) (< (last (last a)) s))\n                      (conj (pop a) (conj (last a) s))\n                      (conj a [s]))) [] x)))","user":"58844d43e4b0f1effa3b7696"},{"code":"(fn [xs] \n  (loop [xs (seq xs) l [] ll l]\n    (if xs\n      (if (or\n\t     (and (empty? l) (next xs))\n\t     (= (peek l) (dec (first xs))))\n\t  (recur (next xs) (conj l (first xs)) ll)\n\t  (recur (next xs) [(first xs)] (if (> (count l) (count ll)) l ll)))\n      (cond\n\t  (and (> (count l) (count ll)) (> (count l) 1)) l\n\t  (and (> (count ll) (count l)) (> (count ll) 1)) ll\n\t  :default []))))","problem":53,"user":"4ef9c8f9535dced4c769f26b"},{"code":"(fn [xs]\n    (loop [xs xs\n           acc1 []\n           acc2 []]\n      (let [l1 (count acc1)\n            l2 (count acc2)\n            x (first xs)]\n        (cond\n         (= (count xs) 0)\n         (cond\n          (< (max l1 l2) 2) []\n          (> l1 l2) acc1\n          (< l1 l2) acc2)\n\n         (= l1 0)\n         (recur (rest xs) (conj acc1 x) acc2)\n         (= (-> acc1 last inc) x)\n         (recur (rest xs) (conj acc1 x) acc2)\n         :else\n         (if (> l1 l2)\n           (recur (rest xs) [x] acc1)\n           (recur (rest xs) [x] acc2))))))","problem":53,"user":"504e90bae4b069badc5a33b8"},{"problem":53,"code":"(fn [coll]\n  (:longest (reduce\n             (fn [acc curr]\n               (let [prev (:prev acc)\n                     sub (:sub acc)\n                     longest (:longest acc)\n                     sub (if (= (- curr prev) 1) (conj sub curr) [curr])\n                     longest (if (> (count sub) (count longest)) sub longest)\n                     longest (if (< (count longest) 2) [] longest)\n                     prev curr]\n                 {:prev prev :sub sub :longest longest}))\n             {:prev -9999 :sub [] :longest []}\n             (vec coll))))","user":"6020365ae4b0bf4ca6b10960"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n    (reduce\n      (fn [acc x]\n        (let [f (first acc)]\n          (if (= (last f) (dec x))\n            (conj acc (conj f x))\n            (conj acc [x]))))\n      '())\n    (filter #(> (count %) 1))\n    (#(if (empty? %)\n        []\n        (apply max-key count %)))))","user":"5bd7b8b8e4b0ed4b8aab4bc6"},{"problem":53,"code":"(fn foo [coll]\n  (let [ascending-subs\n        (loop [prev []\n               curr [(first coll)]\n               coll (rest coll)]\n          (if (seq coll)\n            (if (< (last curr) (first coll))\n              (recur prev (conj curr (first coll)) (rest coll))\n              (recur (conj prev curr) [(first coll)] (rest coll)))\n            (conj prev curr)))\n     s (->> ascending-subs (reduce (fn red [x y] (if (> (count y) (count x)) y x))) )]\n        \n    (if (> (count s) 1) s [])\n        ))","user":"563e1c0ee4b0da801c4e4665"},{"problem":53,"code":"#(loop [seq (rest %)\n        acc [(first %)]\n        res []]\n   (if (empty? seq)\n     (if (> (count acc) (count res) 1) acc res)\n     (if (= (+ 1 (last acc)) (first seq))\n       (recur (rest seq) (conj acc (first seq)) res)\n       (recur (rest seq) [(first seq)]\n              (if (> (count acc) 1 (count res)) acc res)))))","user":"57155980e4b07c98581c3ad7"},{"code":"(fn [x]\n  (loop [data x cur-data [] max-data []]\n    (if-not (first data)\n      (if (= 1 (count max-data))\n  '()\n\t(reverse max-data))\n      (if (= (inc (first data)) (fnext data))\n\t(recur (rest data) (cons (first data) cur-data) max-data)\n\t(if (>= (count cur-data) (count max-data))\n\t  (recur (rest data) '() (cons (first data) cur-data))\n\t  (recur (rest data) '() max-data))))))","problem":53,"user":"4eb0afed535d7eef3080733e"},{"problem":53,"code":"(fn f53 [vec]\n  (nth (reduce\n     (fn [[pre-num curr-vec max-vec] curr-num]\n       (if (= curr-num (inc pre-num))\n         (if (not (< (count curr-vec) (count max-vec)))\n           [curr-num (conj curr-vec curr-num) (conj curr-vec curr-num)]\n           [curr-num (conj curr-vec curr-num) max-vec])\n         [curr-num [curr-num] max-vec]))\n     [-1 [] []]\n     vec) 2))","user":"5c76577ae4b0fca0c16227ea"},{"code":"(fn [a] (let[\n            b (map vector a (next a))\n            c (partition-by #(apply >= %) b)\n            g (for [lst c] (concat (map first lst) [(-> lst last last)]))\n            h (filter (fn [[f s]] (< f s)) g)]\n            (if (seq h) (apply max-key count (reverse h))[])))","problem":53,"user":"4e599577535d8a8b8723a29f"},{"code":"(fn [v] (let \n[ls (partition-by (fn [x] (first x)) (map vector (map - v (range)) v))]\n(let [ma (apply max (map count ls)) ] (if (= ma 1) []\n(some #(if (= ma (count %)) (map  second %)) ls)))))","problem":53,"user":"517945dce4b0684c1c981a43"},{"problem":53,"code":"(fn [vect]\n  (loop [vect vect\n         longest []]\n        ; ugly as hell...how do I assign to more than one local identifier in a let from a function call?\n        (let [current (((fn [vect]\n                            (loop [acc [(first vect)]\n                                   vect (into [] (drop 1 vect))]\n                                  (if (or (empty? vect) (>= (last acc) (first vect)))\n                                    [acc (into [] vect)]\n                                    (recur (conj acc (first vect)) (drop 1 vect))))) vect) 0)\n              vect (((fn [vect]\n                        (loop [acc [(first vect)]\n                               vect (into [] (drop 1 vect))]\n                              (if (or (empty? vect) (>= (last acc) (first vect)))\n                                [acc (into [] vect)]\n                                (recur (conj acc (first vect)) (drop 1 vect))))) vect) 1)]\n             (if (> (count current) (count longest))\n               (if (not (empty? vect))\n                 (recur vect current)\n                 (if (> (count current) 1) current []))\n               (if (not (empty? vect))\n                 (recur vect longest)\n                 (if (> (count longest) 1) longest []))))))","user":"56cc34aee4b0ea9b8538f73c"},{"problem":53,"code":"(fn [coll]\n  (let [options (map #(drop % coll) (range (dec (count coll))))\n      \toptions1 (filter #(= (second %) (inc (first %))) options)\n        result (first\n                (sort-by count >\n                         (map (fn [coll]\n                                (let [options2 (map #(take % coll)\n                                                    (reverse (range 2 (inc (count coll)))))]\n                                  (first (filter #(= % (range (first %) (+ (first %) (count %)))) options2)))) options1)))]\n    (if (nil? result) '() result)))","user":"57299c57e4b0c6e51e0d2b1e"},{"code":"(fn [lst]\n  (let [x\n        (reverse\n         ((fn [l res m sub n]\n            (if (empty? l) (if (> n m) sub res)\n              (if (> (first l) (first sub))\n                (recur (rest l) res m (conj sub (first l)) (+ n 1))\n                (if (> n m)\n                  (recur (rest l) sub n (list (first l)) 1)\n                  (recur (rest l) res m (list (first l)) 1)))))\n          (rest lst) '() 0 (list (first lst)) 1))]\n    (if (= (count x) 1) '() x)))","problem":53,"user":"51da631be4b02ceefd947766"},{"problem":53,"code":"(fn [nums]\n  (->> (range (count nums) 1 -1)\n       (mapcat #(partition % 1 nums))\n       (filter #(apply < %))\n       first\n       vec))","user":"5e909685e4b0cb016954634d"},{"problem":53,"code":"(fn [x]\n  (let [sub-seq  (partition-by identity (map (partial > 0) (map - x (drop 1 x))))\n        trues    (map #((comp count filter) true? %) sub-seq)\n        alls     (map count sub-seq)\n        ind-true (map-indexed vector trues)\n        maximum  (apply max trues)]\n       (if (= 0 maximum)\n           []\n       (take (inc maximum) (drop (reduce + (take (first (some #(when ((comp (fn [x] (= maximum x)) second) %) %) (map-indexed vector trues))) alls)) x)))))","user":"544e8369e4b0e39780006987"},{"code":"(fn [xs]\r\n          (let [r\r\n                (loop [[head & tail] (rest xs)\r\n                       streak [(first xs)]\r\n                       output []]\r\n                  (cond\r\n                   (nil? head) (if (> (count streak) (count output)) streak output)\r\n                   (> head (peek streak)) (recur tail (conj streak head) output)\r\n                   true (if (> (count streak) (count output))\r\n                          (recur tail [head] streak)\r\n                          (recur tail [head] output))))]\r\n            (if (> (count r) 1) r [])))","problem":53,"user":"503d129fe4b06c4e0e1fa254"},{"problem":53,"code":"(fn [ls]\n  (letfn [\n          (increasing\n            ([ls] (increasing (rest ls) [(first ls)]))\n            ([ls acc]\n             (if (and (not-empty ls) (> (first ls) (last acc)))\n               (increasing (rest ls) (conj acc (first ls)))\n               acc)))\n\n          (sublists [ls] (map #(drop % ls) (range (count ls))))\n\n          (first-or-empty [ls] (if (empty? ls) [] (first ls)))\n          ]\n    (->> ls\n         (sublists)\n         (map increasing)\n         (filter #(> (count %) 1))\n         (sort-by #(/ 1 (count %)))\n         (first-or-empty))))","user":"5d672bd7e4b0db5d338d15f1"},{"code":"(fn [z] (letfn [(helper [[h & t] current longest]                                                                                                                                                                                     \n                        (let [current1 (if (= ((fnil inc 0) (peek current)) h)                                                                                                                                                                \n                                         (conj current h)                                                                                                                                                                                     \n                                         [h])                                                                                                                                                                                                 \n                              longest1 (max-key count current1 longest)]                                                                                                                                                                      \n                          (if (seq t) (recur t current1 longest1)                                                                                                                                                                             \n                              longest1)))]                                                                                                                                                                                                    \n                (let [result (helper z [(first z)] [])] (if (< (count result) 2) [] result))))","problem":53,"user":"52265e41e4b04e78ff2e1981"},{"code":"(fn [s]\n   (letfn [(incr-subseq [xs] \n              (loop [r (rest xs) acc [(first xs)]] ; fails on empty seq\n                (cond\n                  (empty? r) acc\n                  (<= (first r) (last acc)) acc ;decreased\n                  :else (recur (rest r) (conj acc (first r))))))\n           (incr-subseq-at [i xs] (incr-subseq (drop i xs)))\n           (better? [xs ys] (and (> (count xs) 1) (> (count xs) (count ys))))\n           ]\n     (reduce \n       (fn [curr poss] (if (better? poss curr) poss curr)) \n       []\n       (map incr-subseq-at (range (count s)) (repeat s)))))","problem":53,"user":"4ed188c8535d44c135fd68cf"},{"problem":53,"code":"(fn liss\n  [xs]\n  (let [ordered? (fn [xs] \n                   (and (= (sort xs) xs)\n                        (= (count xs) (count (set xs)))))]\n    (if (ordered? xs)\n      (if (< (count xs) 2)\n        '()\n        xs)\n      (let [xs1 (liss (drop-last xs))\n            xs2 (liss (rest xs))]\n        ;; first in first out\n        (if (> (count xs2) (count xs1))\n          (liss xs2)\n          (liss xs1)))\n      )))","user":"50ec409ce4b04edc33777045"},{"code":"(fn sub [s] (\n              let [ subb (fn [s curs maxs] (let [r (rest s)\n                                                 x (first s)\n                                                 ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\n                                                 nmax (max-key count ncurs maxs)\n                                                 ]\n                                             (if (seq r) (recur r ncurs nmax) nmax))) \n                   longest (subb s [(first s)] [])]\n              (if (< 1 (count longest)) longest [])))","problem":53,"user":"51cec7b1e4b0e42293a2255b"},{"problem":53,"code":"(fn fifty-three [is]\n  (reduce #(if (and (>= (count %2) 2) (> (count %2) (count %1))) %2 %1) []\n   (map reverse\n        (reverse\n          (loop [xs (rest is)\n                 ps (list (list (first is)))]\n            (cond\n              (empty? xs)\n               ps\n              (< (first (first ps)) (first xs))\n               (recur (rest xs) (cons (cons (first xs) (first ps)) (rest ps)))\n              :else\n               (recur (rest xs) (cons (list (first xs)) ps))))))))","user":"5d46fbc6e4b07c84aa5ae6af"},{"problem":53,"code":"(fn [coll]\n  (loop [x coll\n         y (vec (drop 1 x))\n         tmp (vector (first coll))\n         res []]\n    (cond\n      (= [] y) (if (> (count res) (count tmp))\n                 res\n                 (if (= 1 (count tmp)) [] tmp))\n      (= (inc (first x)) (first y)) (recur\n                                     (rest x)\n                                     (rest y)\n                                     (conj tmp (first y))\n                                     res)\n      (not= (inc (first x)) (first y)) (recur\n                                        (rest x)\n                                        (rest y)\n                                        [(first (rest x))]\n                                        (if (> (count res) (count tmp)) res tmp)))))","user":"52a3c66ce4b04e0c58e87c04"},{"code":"(fn [v]\n (loop [L 1\n        V []\n        a [(first v)]\n        r (rest v)]\n   (cond\n     (empty? r)\n       (if (> (count a) L)\n         a\n         V)\n     (< (last a) (first r))\n       (recur L V (conj a (first r)) (rest r))\n     (> (count a) L)\n       (recur (count a) a [(first r)] (rest r))\n     :e\n       (recur L V [(first r)] (rest r)))))","problem":53,"user":"51f28a64e4b0210f90e7454e"},{"problem":53,"code":"(fn max-increasing-sub-seq [xs]\n  (->> xs\n       (map-indexed (fn [i x] [(- i x) x]))\n       (partition-by first)\n       (filter #(> (count %) 1))\n       (reduce (fn [r cs] (if (> (count cs) (count r)) (map second cs) r)) [])))","user":"5383668ee4b06839e8705edd"},{"code":"(fn [coll]\n  (let [res (group-by count (reduce (fn [[h & t] n]\n                                      (if (and h (== (dec n) (last h)))\n                                        (cons (conj h n) t)\n                                        (list* (vector n) h t)))\n                              [] coll))\n        max-length (apply max (keys res))]\n    (if (> max-length 1)\n      (last (res max-length))\n      [])))","problem":53,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn [coll]\n  (vec (loop [c (partition 2 1 coll)\n              longest []]\n         (let [[a b] (split-with (partial apply <) c)\n               run (concat (map first (butlast a)) (last a))\n               cnt (count run)]\n           (cond (not (or (seq a) (seq b))) longest\n                 (zero? cnt) (recur (rest b) longest)\n                 (< (count longest) cnt) (recur b run)\n                 :else (recur b longest))))))","problem":53,"user":"4ee8b9c9535d93acb0a66884"},{"problem":53,"code":"(fn [digits]\n  (->> digits\n       (cons nil)\n       reverse\n       (reduce\n         (fn [{c :current b :best :as agg} d]\n           (cond\n             (nil? c) (assoc agg :current [d])\n             (-> c last dec (= d)) (update-in agg [:current] conj d)\n             (= 1 (count c)) {:best b :current [d]}\n             (> (count b) (count c)) {:best b\n                                      :current [d]}\n             :else {:best c\n                    :current [d]}))\n         {:best []})\n       :best\n       reverse))","user":"5db0172be4b0f8c104ccfc96"},{"code":"(fn [c1]\n  (loop [c (rest c1)\n         s []\n         curr-s [(first c1)]]\n    (if (not (seq c))\n      s\n      (let [x (first c)]\n        (if (= (inc (last curr-s)) x)\n          (let [ncurr-s (conj curr-s x)]\n            (if (> (count ncurr-s) (count s))\n              (recur (rest c) ncurr-s ncurr-s)\n              (recur (rest c) s ncurr-s)))\n          (recur (rest c) s [x]))))))","problem":53,"user":"4dc1e1e4535d020aff1edf90"},{"code":"(fn [s]\n (->> (reduce #(if (> %2 (ffirst %1))\n     (cons (cons %2 (first %1)) (rest %1))\n     (cons [%2] %1)\n   ) [[(first s)]] (rest s)) (filter #(> (count %) 1)) (sort-by count) last reverse))","problem":53,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":53,"code":"(fn sub-seq \n  [v]\n  (let [rf (fn [coll n]\n             (let [t (last coll)\n                   p (last t)]\n               (if (and p (not= (inc p) n))\n                 (conj coll [n])\n                 (conj (pop coll) (conj t n)))))]\n    (if-let [res (apply max-key count (reduce rf [[]] v))]\n      (if (< 1 (count res))\n        res\n        [])\n      [])))","user":"5884f77ee4b0f1effa3b76a9"},{"problem":53,"code":"(fn [coll]\n  (let [len-subs (range (count coll) 1 -1)\n        all-subs (mapcat #(partition % 1 coll) len-subs)\n        max-sub  (some #(when (apply < %) %) all-subs)]\n    (if max-sub max-sub [])))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"#([0 1 2 3 [] [3 4 5] [5 6] 7 [0 1 2 3]] (count %))","problem":53,"user":"538d8bb8e4b0b51d73faae71"},{"problem":53,"code":"(fn [xs]\n  (let\n    [result\n      (->>\n        xs\n        (reduce\n          (fn\n            [[best-so-far current] now]\n            (if (or (empty? current) (>= (last current) now))\n              [best-so-far [now]]\n              (if (>= (count current) (count best-so-far))\n                [(conj current now) (conj current now)]\n                [best-so-far (conj current now)])))\n        [[][]]\n      )\n      first)]\n    (if (< (count result) 2) [] result)))","user":"57717915e4b0979f896515b3"},{"code":"(fn [v]\n  (let [max-seq (first (sort-by (comp - count) (filter (fn [[[i v]] & _] (= 1 v)) (partition-by (fn [[i v]] v) (map-indexed #(identity [% %2]) (map #(- % %2) v (concat [0] v)))))))]\n    (if (nil? max-seq) []\n      (let [idx (map (fn [[i v]] i) max-seq)\n            idx2 (range (dec (first idx)) (inc (last idx)))]\n         (map #(nth v %) idx2)))))","problem":53,"user":"50ebd63ce4b04edc3377703c"},{"problem":53,"code":"(fn lis [l]\n  (let [lis1\n        (fn lis1 [l acc longest]\n          (cond (empty? l) (if (> (count acc) (count longest)) acc longest)\n                (and (not (empty? acc)) (> (first l) (first acc)))\n                (lis1 (rest l) (conj acc (first l)) longest)\n                (and (not (empty? (rest (rest l))))\n                     (> (second l) (first l)))\n                (lis1 (rest (rest l)) (list (second l) (first l))\n                      (if (> (count acc) (count longest)) acc longest))\n                true (lis1 (rest l) '() (if (> (count acc) (count longest)) acc longest))))]\n    (reverse (lis1 l '() '()))))","user":"5b3f2ba9e4b02d533a91bc09"},{"code":"(fn [s]\n  (let [longest\n        (->> (map-indexed vector s)\n          (partition-by (fn [[i x]] (- x i)))\n          (apply max-key count)\n          (map second))]\n    (if (< 1 (count longest))\n      longest\n      [])))","problem":53,"user":"4f1b0ab3535d64f603146474"},{"code":"(fn increasing [xs]\n      (let [inc-sub-seqs (reduce (fn [sub-seqs x]\n                                   (if (> x (last (last sub-seqs)))\n                                       (concat (butlast sub-seqs) [(concat (last sub-seqs) [x])])\n                                       (concat sub-seqs [[x]]))) [[(first xs)]] (rest xs))]\n        (let [best-count (apply max (map count inc-sub-seqs))]\n          (if (= best-count 1)\n              []\n              (first (filter #(= best-count (count %)) inc-sub-seqs))))))","problem":53,"user":"5186134ce4b0da5a5be3bac7"},{"problem":53,"code":"(fn [coll]\n  (->> (reduce (fn [acc item]\n                 (if (= (last (last acc)) (dec item))\n                   (conj (vec (drop-last acc)) (conj (last acc) item))\n                   (conj acc [item])))\n               []\n               coll)\n       (sort-by count >)\n       (map #(if (> (count %) 1) % []))\n       first))","user":"5d6f063de4b04d129b00f2d1"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll) \n    (partition-by #(- (second %) (first %))) \n    (filter #(= 1 (- (second (first %)) (ffirst %)))) \n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n    flatten\n    distinct))","problem":53,"user":"4e2f377a535deb9a81d77f10"},{"code":"(fn [[f & v]]\n  (loop [v v\n         res [f]\n         tops []]\n    (if (empty? v)\n      (vec (->> (conj tops res) (filter #(>= (count %) 2)) (sort-by count) last))\n      (if (= (first v) (+ 1 (last res)))\n        (recur (rest v) (conj res (first v)) tops)\n        (recur (rest v) [(first v)] (conj tops res))))))","problem":53,"user":"4dbecb06535d020aff1edf6a"},{"code":"(fn [-seq]\n   (->> (map\n         (fn [it index]\n           (loop [next-items (next (last (split-at index -seq))) stock [it]]\n             (if (= (first next-items) (inc (last stock)))\n               (recur (rest next-items) (conj stock (first next-items)))\n               stock\n               )))\n         -seq (range (count -seq))\n         )\n        (map  #(if (= 1 (count %)) [] %))\n        (sort #(compare (count %2) (count %1)))\n        (first)\n       )\n\n   )","problem":53,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":53,"code":"(fn long-sub-sqn [s]\n  \n  \n  (loop [result [] tail (rest s) temp-seq [(first s)]]\n    \n    (let [head (first tail)]\n      \n      (if (nil? head)\n        (if (or (> (count temp-seq) 1) (> (count result) 1))\n          (if (> (count temp-seq) (count result)) temp-seq result)\n          []\n        )\n        \n        \n        \n        (if (> head (last temp-seq))\n          \n          (recur result (rest tail) (conj temp-seq head))\n          \n          ; Decide if temp-seq is bigger than the current result or not\n          \n          (if (> (count temp-seq) (count result))\n            \n            ; I don't have a conditional for empties, so I'm rest-resting and first-resting\n            \n            ;; (recur temp-seq (rest (rest tail))  [(first (rest tail))])\n            \n            ;; (recur result (rest (rest tail))  [(first (rest tail))])\n            ;; (recur temp-seq head  [(rest tail)])\n            \n            ;; (recur result head  [(rest tail)])\n            (recur temp-seq (rest tail) [head])\n            \n            (recur result (rest tail) [head])\n            \n            ) ; if end\n          \n          ) ; if end\n        \n        \n        \n        \n        ) ; if (base case) end\n      \n      \n      ) ; let end\n    \n    \n    ) ; loop end\n  \n  \n  ) ; fn end","user":"5ff676a9e4b06df49cee1497"},{"problem":53,"code":"(fn linc [coll]\n  (letfn [(inc? [c]\n            (and (= c (range (first c) (+ (first c) (count c)))) c))]\n    (loop [n (count coll)]\n      (if (= 1 n)\n          []\n          (if-let [ans (some inc? (partition n 1 coll))]\n            ans\n            (recur (dec n))\n          ))\n      )\n    )\n  )","user":"5a90395ce4b05369db4d254a"},{"problem":53,"code":"(fn [coll](let [\n len (count coll)\n slicer (fn[from, to] (->> coll (drop from) (take (- to from)) ))\n breaks (for[\n   [n a b] (map list*\n     (range 0 len)\n     (partition 2 1 coll)\n   )\n   :when (>= a b)]\n   (+ n 1))\n ]\n (->>\n  (partition 2 1 (concat [0] breaks [len]))\n  (map #(apply slicer %))\n  (filter #(> (count %) 1))\n  (cons '())\n  (reverse)\n  (apply max-key count)\n )\n))","user":"54c9f165e4b045293a27f687"},{"problem":53,"code":"(fn\n  [s]\n  (let\n    [check-inc (fn [s] (when (= s (sort (distinct s))) s))\n     get-subseqs (fn [n s]\n                   (loop [s s, res []]\n                     (if (< (count s) n)\n                       res\n                       (recur (drop 1 s) (conj res (take n s))))))\n     the-subseqs (conj (vec (mapcat #(get-subseqs % s) (range (count s) 1 -1))) '())\n     ]\n    (first (filter check-inc the-subseqs))))","user":"5f5df0bfe4b02876ed9fcfeb"},{"code":"(fn [S]\n  (if\n    (empty? S)\n    []\n    (loop [s (rest S), cs [(first S)], cl 1, cm (first S), bs [], bl 1]\n      (if (empty? s)\n          bs\n          (if (> (first s) cm)\n              (let [cs (conj cs (first s)), cl (inc cl), cm (first s)]\n                (if (> cl bl)\n                    (recur (rest s) cs cl cm cs cl)\n                    (recur (rest s) cs cl cm bs bl)))\n              (recur (rest s) [(first s)] 1 (first s) bs bl))))))","problem":53,"user":"4f03d0fe535dcb61093f6b6d"},{"problem":53,"code":"(fn [coll]\n   (let [v  (->> coll\n                 (reduce (fn [seqs x]\n                           (let [pid (dec (count seqs))\n                                 pre (last (nth seqs pid))]\n                             (if (or (nil? pre) (> x pre))\n                               (conj (vec (drop-last seqs)) (conj (last seqs) x))\n                               (conj seqs [x]))))\n                         [[]])\n                 reverse\n                 (apply max-key count))]\n\n     (if (> (count v) 1) v [])))","user":"60537cd1e4b04c8f2157d152"},{"problem":53,"code":"(fn\n  [seq]\n  (loop [s [] r [(nth seq 0)] i 1]\n    (if (< i (count seq))\n      (if (= (nth seq i) (+ (last r) 1))\n        (recur s (conj r (nth seq i)) (inc i))\n        (recur (if (and (< 1 (count r)) (< (count s) (count r))) r s) [(nth seq i)] (inc i)))\n      (if (and (< 1 (count r)) (< (count s) (count r))) r s))))","user":"5b5e7953e4b0c6492753e6d9"},{"problem":53,"code":"#(letfn [(continuous? [[n m]] (= (inc n) m))]\n  (loop [coll % result []]\n    (if-not (seq coll)\n      result\n      (let [ps (partition 2 1 coll)\n            result' (vec (set (apply concat (take-while continuous? ps))))]\n        (recur (rest coll) (if (< (count result) (count result')) result' result))))))","user":"5213d7aae4b0961f15ac4d72"},{"problem":53,"code":"(fn longest-increasing-subseq [xs]\n  (let [[y & ys] (seq xs)]\n    (if-not (or y ys)\n      []\n      (let [subseq-indexes (reduce (fn [[[start end] & others :as indexes] i]\n                                     (if (> (nth xs i) (nth xs end))\n                                       (conj others [start i])\n                                       (conj indexes [i i])))\n                                   '([0 0])\n                                   (range 1 (count xs)))\n            [start end] (reduce (fn [[start end] [candidate-s candidate-e]]\n                                  (if (>= (- candidate-e candidate-s)\n                                          (- end start))\n                                    [candidate-s candidate-e]\n                                    [start end]))\n                                subseq-indexes)]\n        (if (>= (- end start) 1)\n          (subvec xs start (inc end))\n          [])))))","user":"5d47fa13e4b07c84aa5ae6b6"},{"code":"(fn [s] \n  (reduce \n   (fn [t,i] (if (and (> (count i) 1) (> (count i) (count t))) i t)) \n   []\n   (map #(loop [x %] (if (apply < x) x (recur (butlast x)))) \n        (partition-all (count s) 1 s))))","problem":53,"user":"4ef77edb535dced4c769f254"},{"code":"(fn [input]\r\n  (if (seq input)\r\n    ((fn [input subresult result]\r\n      {:pre [(seq subresult)]}\r\n      (if (seq input)\r\n        ;; nonempty input: compare first in input with the last in subresult and recur\r\n        (if (> (first input) (last subresult))\r\n          (recur (rest input) (conj subresult (first input)) result)\r\n          (recur (rest input) [(first input)] (if (> (count subresult) (count result)) subresult result)))\r\n        ;; empty input: return result or subresult depending on which one is larger\r\n        (let [r (if (> (count subresult) (count result)) subresult result)]\r\n          (if (< 1 (count r)) r [])))) (rest input) [(first input)] [])\r\n    []))","problem":53,"user":"4de877f6535d08e6dec9fdfd"},{"code":"(fn [xs]\r\n  (let [>1 (fn [x y] \r\n             (let [lec (last x) lem (last lec)]\r\n               (if (> y lem) \r\n                 (conj (apply vector (butlast x))\r\n                       (conj lec y)) \r\n                 (conj x [y]))))\r\n        start [[(first xs)]]\r\n        collie (vec (rest xs))\r\n        rcmp (fn [x y] (if (>= (count x) (count y)) x y))\r\n        fcmp #(>= (count %) 2)\r\n        firstpass (reduce >1 start collie)\r\n        filtpass (filter fcmp firstpass)]\r\n    (if (empty? filtpass)\r\n      []\r\n      (reduce rcmp filtpass))))","problem":53,"user":"5376966ae4b06839e8705e27"},{"problem":53,"code":"(fn [xss]\n  (\n    let [\n      take-while-increasing #(\n                              cons\n                                (first %)\n                                (->> %\n                                  (map vector (rest %))\n                                  (take-while (fn [[x y]] (> x y)))\n                                  (map first)\n                                )\n                            )\n    ]\n    (->> xss\n      (iterate rest)\n      (take-while (partial not= '()))\n      (map take-while-increasing)\n      (#(map vector (map count %) (map (partial * -1) (range)) %))\n      (filter (fn [[x & _]] (> x 1)))\n      sort\n      reverse\n      first\n      (#(nth % 2))\n      (#(if (nil? %) '() %))\n    )\n  ) \n)","user":"516ee939e4b06aac486e5b34"},{"problem":53,"code":"(fn [xs] \n  (letfn [\n    (take-while-inc' [acc xs]\n      (if (seq xs)\n        (let [x (first xs)]\n          (if (= x (inc (last acc)))\n            (take-while-inc' (conj acc x) (rest xs))\n            acc))\n        acc))\n    (take-while-inc [xs]\n      (take-while-inc' [(first xs)] (rest xs)))\n    (longest-inc-seq' [result xs]\n      (if (seq xs)\n        (let [current (take-while-inc xs)]\n          (if (and (< (count result) (count current)) (> (count current) 1))\n            (longest-inc-seq' current (rest xs))\n            (longest-inc-seq' result (rest xs))))\n        result))]\n    (longest-inc-seq' [] xs)))","user":"5545eebee4b0a04f79299539"},{"problem":53,"code":"(fn longest-seq\n  ([lst] (longest-seq (rest lst) (list (first lst)) nil))\n  ([lst acc longest]\n    (cond (empty? lst)\n            (let [result (reverse (if (> (count acc) (count longest)) acc longest))]\n              (if (> 2 (count result)) '() result))\n          (= (inc (first acc)) (first lst))\n            (recur (rest lst) (cons (first lst) acc) longest)\n          true\n            (recur (rest lst) (list (first lst))\n                   (if (> (count acc) (count longest)) acc longest)))))","user":"546c1f73e4b00cfc9eacc175"},{"code":"#(apply max-key %\n(reverse\n(for [x (%2 (% %3)) % (%2 x (- (% %3) 1))\n:let [% (subvec %3 x (+ % 2))]]\n(if (apply < %) % []))))\ncount range","problem":53,"user":"4f10175e535d64f603146411"},{"code":"(fn [l]\n  (let [res (reduce (fn [res i]\n            (if (empty? res)\n              (list (list i))\n              (let [f (first res)\n                    r (rest res)]\n                (cond \n                 (empty? f) (cons (cons i f) r)\n                 (> i (first f)) (cons (cons i f) r)\n                 :else (cons (list i) res))))) \n          '() l)\n        longest (fn longest [l]\n                  (let [f (first l) \n                        r (rest l)]\n                    (if (empty? r)\n                      f\n                      (let [rm (longest r)]\n                        (if (> (count f) (count rm))\n                          f\n                          rm)))))]\n    (let [r (reverse (longest res))]\n          (if (<= (count r) 1)\n            '() r))))","problem":53,"user":"5348236ee4b084c2834f4a54"},{"code":"(fn [x] \n   (let [longest-rev (fn ls [s newl old] \n    (let [bigger (fn [l1 l2] (if (> (count l1) (count l2)) l1 l2))] \n      (cond \n       (empty? s) (bigger newl old) \n       (or (empty? newl) (> (first s) (first newl))) (ls (rest s) (cons (first s) newl) old)\n       :else (ls (rest s) (list (first s)) (bigger newl old))\n       )\n      )\n    )\n    longest (reverse (longest-rev x '() '()))]\n     (if(> (count longest) 1) longest '()))\n )","problem":53,"user":"535197f2e4b084c2834f4ae4"},{"problem":53,"code":"(fn [coll]\n  (let [partitioned (partition-by #(apply < %) (partition 2 1 coll))\n        filtered (filter (fn [[[a b]]] (< a b)) partitioned)\n        sorted (first (sort-by count > filtered))]\n    (concat (first sorted) (map last (rest sorted)))))","user":"5f90aeefe4b0715f5002d799"},{"code":"(fn [lst]\n  ((reduce (fn [[f rv res] e]\n             (let [newrv (conj rv e)]\n               [#(= % (inc e))\n                (if (f e) newrv [e])\n                (if (and (f e) (> (count newrv) 1) (> (count newrv) (count res)))\n                  newrv\n                  res)]))\n           [#(not (nil? %)) [] []]\n           lst) 2))","problem":53,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"#(let [res (second (reduce (fn [r x] \r\n          (let [[cur long] r] \r\n            (if (or (empty? cur) (= x (inc (last cur))))\r\n              (let [new (conj cur x)]\r\n                (if (> (count new) (count long))\r\n                  [new new]\r\n                  [new long]))\r\n              [[x] long])\r\n            )) [[] []] %))] \r\n  (if (>= (count res) 2) res []))","problem":53,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn [col]\n  (letfn [(bounds [xs]\n            (map-indexed #(cond (zero? %) 0\n                                (<= %2 (nth xs (dec %))) %) xs))\n          (pieces [xs]\n            (partition 2 1 (concat (remove nil? (bounds xs)) [(count xs)])))\n\n          (limits [xs]\n            (reduce #(if (< (apply - %2) (apply - %)) %2 %) (pieces xs)))\n\n          (target [xs]\n            (apply subvec xs (limits xs)))]\n\n    (let [result (target col)]\n      (if (<= 2 (count result)) result []))))","problem":53,"user":"51f55bdae4b0abb92f97f9d0"},{"code":"(fn [x]\n  (let [m (zipmap (range) x)\n        f (fn [[a :as c] b] (if-let [p (last a)]\n                              (if (= (inc p) b)\n                                (conj (rest c) (conj a b))\n                                (conj c (vector b)))\n                              (conj c (vector b))))\n        c (fn [a] (> (count a) 1))\n        s (filter c (reduce f () x))]\n    (reduce #(if (> (count %2) (count %1)) %2 %1) [] s)))","problem":53,"user":"5201572be4b0d7096e99ddbb"},{"problem":53,"code":"(fn [coll]\n  (let [pairs (partition-by #(apply < %) (partition 2 1 coll))\n        removed-dec-pairs (filter (fn [[[x y]]] (< x y)) pairs)\n        longest-pairs (first (sort-by count > removed-dec-pairs))]\n    (concat (first longest-pairs) (map last (rest longest-pairs)))))","user":"54f2a1b8e4b024c67c0cf8cb"},{"problem":53,"code":"(comp (fn [s] (if (> (count s) 1) s [])) vec reverse last (partial sort-by count) (partial reduce (fn [col v]\n  (if (empty? col)\n    (list (list v))\n    (if (< (ffirst col) v)\n      (cons (cons v (first col)) (rest col))\n      (cons (list v) col)))) '()))","user":"58ec8c7ae4b056aecfd47d64"},{"problem":53,"code":"(fn [l]\n  (letfn [(incr? [sub] (apply < sub))]\n    (loop [se (rest l)\n           subse [(first l)]\n           bigs []]\n      (if-not (empty? se)\n        (let [newss (conj subse (first se))]\n          (cond\n            (and (incr? newss) (> (count newss) (count bigs)) (> (count newss) 1))\n            (recur (rest se) newss newss)\n            (and (incr? newss) (<= (count newss) (count bigs)))\n            (recur (rest se) newss bigs)\n            :else\n            (recur (rest se) [(first se)]  bigs)))\n        bigs))))","user":"5a8fd113e4b05369db4d2542"},{"problem":53,"code":"(fn longest-inc-subseq [coll]\n  (->> coll\n       (reduce (fn [work elem]\n                 (let [last-inc-seq (peek work)\n                       last-elem (peek last-inc-seq)]\n                   (if (and last-elem (> elem last-elem))\n                     (conj (pop work) (conj last-inc-seq elem))\n                     (conj work (vector elem)))))\n               [])\n       (filter #(>= (count %) 2))\n       (reduce #(if (> (count %2) (count %1)) %2 %1)\n               [])))","user":"608256d7e4b0736b099e42da"},{"code":"(fn f2 [xs]\n  (let [f (fn [xs i] (flatten (reduce \n              #(if (= (last %) (dec %2)) (conj % %2) [%]) (vector (nth xs i)) (drop (inc i) xs))))\n\t\t    r (apply max-key count (for [x (range (count xs))] (f xs x)))]\n\t(if (> (count r) 1) r [])))","problem":53,"user":"501d52a8e4b066e56b9d0b20"},{"code":"#(let [s (loop [x [] y [] z %]\n          (if (empty? z)\n            (if (> (count x) (count y)) x y)\n            (if (or (empty? x) (= (last x) (- (first z) 1)))\n              (recur (conj x (first z)) y (rest z))\n              (recur [] (if (> (count x) (count y)) x y) z))))]\n  (if (<= (count s) 1) [] s))","problem":53,"user":"522eb5cce4b01cdb292c5f0c"},{"code":"(fn lis [coll]\n  (let [s (reduce (fn [[x y] z]\n            (print x y z)\n            (cond\n             (= 1 (- z (last y))) [x (conj y z)]\n             (= 1 (count y)) [x [z]]\n             :else (if (> (count y) (count x)) [y [z]] [x [z]])))\n          [[] [(first coll)]]\n          (rest coll)) ]\n    (cond\n     (<= (count (last s)) 1) (first s)\n     :else (if (> (count (first s))\n                  (count (second s)))\n             (first s) (second s)\n             ))))","problem":53,"user":"52140b53e4b0961f15ac4d7e"},{"problem":53,"code":"(fn [c]\n    (->>\n    (reduce\n      (fn [coll elem]\n        (let [current (first coll)\n              first-el (first current)]\n          (if (= (inc first-el) elem)\n            (conj (rest coll) (conj current elem))\n            (conj coll (list elem)))))\n      (list (list (first c)))\n      (rest c)\n\n    )\n    (remove #(< (count %) 2))\n    (sort-by count)\n    (last)\n    (reverse))\n  )","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":53,"code":"(fn [[f & c]]\n  (let [sseq (fn [t v] (if (= v (inc (last t))) (conj t v) [v]))\n        newc (reduce \n               #(if (= (count %1) (count %2)) %2 %1) \n               (reverse (sort-by count (reductions sseq [f] c))))]\n    (if (> (count newc) 1) newc [])))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn f \n  ([x]\n   (f x [] [])\n   )\n  ([x y b]\n   (if (seq x)\n     (let [newy \n           (if (or (empty? y) (= (first x) (inc (last y))))\n             (conj y (first x))\n           [(first x)])\n           ]\n     (f (rest x) \n        newy\n        (if (> (count newy) (count b))\n          newy\n          b\n        )\n     )\n     )\n     ;else return\n     (if (> (count b) 1)\n      b\n      []\n      )\n     )\n   )\n  \n )","problem":53,"user":"5191045ee4b0f8ef0be96bf3"},{"problem":53,"code":"(fn [xs]\n    (let [longer (fn [a b] (if (> (count a) (count b)) a b))]\n      (loop [[h & t :as xs] xs\n             curr []\n             longest []]\n        (cond\n          (empty? xs) (if (> (count longest) 1) longest [])\n          (empty? curr) (recur t [h] (longer [h] longest))\n\n          (> h (last curr))\n          (let [new-curr (conj curr h)]\n            (recur t new-curr (longer new-curr longest)))\n\n          :else\n          (recur t [h] (longer [h] longest))))))","user":"559622cee4b0c79f6e1db975"},{"problem":53,"code":"(fn [seq]\n   (let [seqs (filter \n               #(> (count %) 1)\n               ((fn longest\n                  ([[x & xs]] (longest [x] xs []))\n                  ([p [x & xs] ret]\n                   (if (nil? x)\n                     (conj ret p)\n                     (if (< (last p) x)\n                       (longest (conj p x) xs ret)\n                       (longest [x] xs (conj ret p)))))) seq))]\n     (if (empty? seqs)\n       []\n       ((fn [[x & xs] cur]\n          (if x\n            (if (> (count x) (count cur))\n              (recur xs x)\n              (recur xs cur))\n            cur)) (rest seqs) (first seqs)))))","user":"554b7056e4b0a04f79299583"},{"problem":53,"code":"(fn [list] \n  (let [sequences (filter (fn [[[x y]]] (< x y)) (partition-by (partial apply <) (partition 2 1 list)))\n        \n        longest (first (sort-by count > sequences))\n       ]\n    (concat (first longest) (map last (rest longest)))\n    )\n  )","user":"5a12dea3e4b04bbd27e6da44"},{"problem":53,"code":"(fn longest-increasing-subseq\n  [coll]\n  (letfn [(take-peek-while\n            [f coll]\n            (letfn [(step [f i coll]\n                      (lazy-seq\n                        (when-let [s (seq coll)]\n                          (let [x (first s)]\n                            (when (f i x)\n                              (cons x (step f x (rest s))))))))]\n              (cons (first coll)\n                (step f (first coll) (rest coll)))))\n          (partition-peek-by\n            [f coll]\n            (lazy-seq\n              (when-let [s (seq coll)]\n                (let [run (take-peek-while f s)]\n                  (cons run (partition-peek-by f (drop (count run) s)))))))]\n    (->> coll\n       (partition-peek-by <)\n       (filter #(> (count %) 1))\n       (reduce #(if (>= (count %) (count %2))\n                 % %2) []))))","user":"594880ade4b07ddc2dafadc2"},{"problem":53,"code":"(fn [col]\n  (:result (reduce (fn [res e]\n                     (let [last-match (:last-match res)\n                           le (if (-> last-match count pos?) (last last-match) -1000)\n                           diff (- e le)\n                           new-match (if (= 1 diff) (conj last-match e) [e])\n                           last-result (:result res)\n                           new-count (count new-match)\n                           new-result (if (and (> new-count 1) (> new-count (count last-result))) new-match last-result)]\n                       {:result new-result :last-match new-match}\n                       )) {:result [] :last-match []} col)))","user":"56df254be4b0ca2494a095ea"},{"code":"(fn [ints]\n  (let [to-seq (fn [pairs]\n                (if (empty? pairs)\n                  []\n                  (conj (vec (map first pairs)) (last (last pairs)))))]\n    (to-seq (reduce (fn [result xs] (if (> (count xs) (count result)) xs result)) []\n              (reduce (fn [result xs]\n                        (conj result (take-while #(= (inc (first %)) (last %)) xs)))\n                      []\n                      (map #(map vector (drop % ints) (drop (inc %) ints)) (range (count ints))))))))","problem":53,"user":"50e3ddd4e4b01912b3285c47"},{"code":"#((fn longest-subseq \n  ([v] (longest-subseq (rest v) [(first v)] []))\n  ([v p b]\n    (let [f (first v)\n          r (rest v)\n          l (last p)\n          cp (count p)\n          cb (count b)]\n      (cond (empty? v) \n              (if (> cp cb)\n                (if (> cp 1) p [])\n                (if (> cb 1) b []))\n            (> f l) (longest-subseq r (conj p f) b)\n            (> (count p) (count b)) (longest-subseq r [f] p)\n            :else (longest-subseq r [f] b))))) %)","problem":53,"user":"4edd038c535d10e5ff6f5327"},{"problem":53,"code":"(fn growing-sub [s]\n  (letfn [(get-max-sub [ss]\n            (reduce #(if (and (> (count %1) (count %2)) (> (count %1) 1)) %1 %2)\n                    []\n                    ss))\n          (growing-subs [s]\n            (reduce\n             #(cond (empty? (first %1)) (conj %1 (vector %2))\n                    (>= (last (first %1)) %2) (conj %1 (vector %2))\n                    :else (conj (rest %1) (conj (first %1) %2)))\n             '([])\n             s))]\n    (get-max-sub (growing-subs s))))","user":"5578c67fe4b05c286339e08d"},{"problem":53,"code":"(fn [coll] (loop [elems coll largeseq []]\n              (if (empty? elems)\n                (reverse (second (first (sort #(compare (first %2) (first %1)) (filter #(> (first %) 1)\n                                                                                       (map #(vector (count %1) %1) largeseq))))))\n                (if (empty? largeseq)\n                  (recur (rest elems)\n                         (list (list (first elems))))\n                  (recur (rest elems)\n                         (if (= 1 (- (first elems) (first (first largeseq))))\n                           (conj (rest largeseq) (conj (first largeseq)\n                                                       (first elems)))\n                           (conj largeseq (list (first elems)))))))))","user":"584917a1e4b089d5ab817ec9"},{"code":"(fn lis [s]\n   (if (= 1 (count s))\n     '()\n     (if (apply < s)\n       s\n       (let [a (lis (rest s))\n             b (lis (butlast s))]\n         (if (> (count a) (count b))\n           a\n           b)))))","problem":53,"user":"52586d24e4b0cb4875a45cb0"},{"problem":53,"code":"(fn [x]\n  (loop [cx (rest x), lsub [], csub (vector (first x))]\n    (if (empty? cx)\n      (if (>= (count lsub) (count csub))\n        (if (>= (count lsub) 2)\n          lsub\n          [])\n        csub\n      )\n      (if (= (first cx) (inc (last csub)))\n          (recur (rest cx) lsub (conj csub (first cx)))\n          (if (<= (count lsub) (count csub))\n            (recur (rest cx) csub (vector (first cx)))\n            (recur (rest cx) lsub (vector (first cx)))\n           )\n       )\n     )\n   )\n  )","user":"588fb3a7e4b00487982d51b9"},{"problem":53,"code":"(fn [coll]\n  (loop [[r & more :as all] (vec coll)\n         n 0\n         acc '[]]\n    (if all\n      (if (= nil (first acc))\n        (recur more n (conj acc [r]))\n        (if (= (+ (last (last acc)) 1) r)\n          (recur more n (assoc acc n (conj (acc n) r)))\n          (recur more (inc n) (conj acc [r]))))\n      (if (= (count (last (sort acc))) 1)\n        []\n        (last (sort acc))))))","user":"5c718e6ce4b0fca0c1622796"},{"code":"(fn [x]\n  (let [search (fn [[[abest bbest] [acur bcur] lastval] [i n]]\n                 (if (> n lastval)\n                   (cond\n                    (= abest -1)\n                    , (if (= acur -1)\n                        [[(- i 1) i] [(- i 1) i] n]\n                        [[acur i] [acur i] n])\n                    (= acur -1)\n                    , [[abest bbest] [(- i 1) i] n]\n                    (>= (- bcur acur) (- bbest abest))\n                    , [[acur i] [acur i] n]\n                    :else\n                    , [[abest bbest] [acur i] n])\n                   [[abest bbest] [-1 -1] n]))\n        enumerated (map-indexed #(vector %1 %2) x)\n        init       [[-1 -1] [-1 -1] (first x)]\n        [fst lst]  (first (reduce search init (rest enumerated)))]\n    (if (= fst -1)\n      []\n      (subvec x fst (+ lst 1)))))","problem":53,"user":"5095f761e4b0ba05ca7aebfd"},{"code":"#(apply max-key %\n        (into ()\n              (for [x (%2 (% %3)) y (%2 (+ 2 x) (+ 1 (% %3)))\n                    :let [l (subvec %3 x y)]]\n                (if (apply < l) l []))))\ncount range","problem":53,"user":"4e52d815535d302ef430da77"},{"problem":53,"code":"(fn f [v]\n  (cond (< (count v) 2) []\n\t\t(apply < v) v\n    \t1 (if (> (count (f (rest v)))\n            \t (count (f (butlast v))))\n\t\t\t(f (rest v))\n\t \t\t(f (butlast v)))))","user":"51ab70c3e4b04e3dc0c27b33"},{"problem":53,"code":"(fn [coll]\n  (let [[x y] (reduce\n                (fn [a b]\n                  (let [[x y] a\n                        z (last y)]\n                    (if (nil? z)\n                      [x [b]]\n                      (if (= 1 (- b z))\n                        [x (conj y b)]\n                        (if (> (count x) (count y))\n                          [x [b]]\n                          [y [b]])))))\n                [[] []]\n                coll)]\n    (let [z (if (> (count x) (count y)) x y)]\n      (if (< (count z) 2)\n        []\n        z))))","user":"58bb218be4b0888cdc949cf4"},{"problem":53,"code":"(fn [ss]\n    (let [diffs (map - (rest ss) (drop-last 1 ss))\n          incs (map #(= 1 %) diffs)\n          pairs (map vector incs (range))\n          hunks (partition-by first pairs)\n          hunks-valid (filter #(first (first %)) hunks)\n          longest (sort-by count hunks-valid)]\n      (if (empty? longest)\n        longest\n        (let [winner (last longest)\n              start (last (first winner))]\n          (take (inc (count winner)) (drop start ss))\n          )\n        )\n      ))","user":"54965534e4b0b312c081ff65"},{"code":"(fn largest-subseq [input]\n  (let \n    [is-increasing (fn[subseq]\n                    (reduce #(and % %2) (map < subseq (rest subseq))))\n     size (count input)]\n  \n    (loop [subsize size\n           offset  0]\n         (if (= 1 subsize)\n             []\n             (let [end-drop (- size subsize offset)\n                subseq (drop offset (drop-last end-drop input))]\n                (if (is-increasing subseq)\n                    subseq\n                    (if (zero? end-drop)\n                        (recur (dec subsize) 0)\n                        (recur subsize (inc offset)))))))))","problem":53,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":53,"code":"(fn longincsubsq [v]\n  (let [partition-between \n        (fn [pred? coll] \n          (let [switch (reductions not= true (map pred? coll (rest coll)))] \n            (map (partial map first) (partition-by second (map list coll switch)))))\n        getsubsq (fn [n] (into [] (partition-between (fn [a b] (not (= (- b a) 1))) n)))\n        longsub (fn [n] (into [] (key (apply max-key val (reduce conj {} (for [x (getsubsq n)] [x (count x)]))))))\n]\n    (if (< (count (longsub v)) 2)\n      (vector)\n      (longsub v))))","user":"59368efbe4b02506e01a297d"},{"problem":53,"code":"(letfn [\n        ;; returns 1st subset, regardless of count\n        (x [s]\n          (loop [rm (rest s), acc (vector (first s))]\n            (if (empty? rm) (if (>= 1 (count acc)) [] (list acc rm))\n                (let [n (first rm), m (last acc)]\n                  (cond (= n (inc m)) (recur (rest rm) (conj acc n))\n                        (>= (count acc) 2) (list acc rm)\n                        :else (recur (rest rm) (vector n)))))))\n        ;; returns largest subset\n        (y [s]\n          (let [[a r] (x s)]\n            (loop [rm r, acc a]\n              (cond (empty? rm) (if (nil? acc) [] acc)\n                    :else (let [[a r] (x rm)]\n                            (if (> (count a) (count acc))\n                              (recur r a)\n                              (recur r acc)))))))]\n  y)","user":"538e36c7e4b0b51d73faae81"},{"problem":53,"code":"(fn longest-asc-sub [s]\n  (let [\n        [longest current _ :as result] \n        (reduce\n         (fn [[longest current last-element] i]\n           (println longest current last-element)\n           (if (and (not (nil? last-element)) (> i last-element))\n             (let [new-current (conj current i)]\n               (if (> (count current) (count longest))\n                 [new-current new-current i]\n                 [longest new-current i]))\n             [longest [i] i]))\n         [[] [] nil]\n         s)\n        final (if (>= (count longest) (count current))\n                longest\n                current)]\n    (if (>= (count final) 2) \n      final \n      [])))","user":"5654e024e4b0f9d632dd848d"},{"problem":53,"code":"(fn get-longest [s]\n  (->> (range (count s))\n       (map (fn [x] ((fn get-subseq-from\n  ([s pos] (get-subseq-from (nth s pos) s (inc pos)))\n  ([v s pos]\n      (if (or (>= pos (count s))\n              (not= (nth s pos) (inc v)))\n            [v]\n            (cons v (get-subseq-from (nth s pos) s (inc pos)))))) s x)))\n       (reduce (fn [z h] (if (> (count h) (count z)) h z)) [])\n       ((fn [j] (if (< (count j) 2) [] j)))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":53,"code":"(fn [s]\n  (reduce #(if (> (count %2) (count %1)) %2 %1)\n          []\n          (filter\n            #(> (count %) 1)\n            (reduce (fn [r e]\n                      (if (and (not= (last r) nil) (> e (last (last r))))\n                        (conj (apply vector (drop-last r)) (conj (last r) e))\n                        (conj r [e])))\n                    []\n                    s))))","user":"5d05fdece4b0cc9c915881e8"},{"problem":53,"code":"(fn [v]\n  (->> v\n       (partition 2 1)\n       (partition-by (partial apply <))\n       (filter (fn [[[a b]]] (< a b)))\n       (reduce (fn [m s] (if (> (count s) (count m)) s m)) [])\n       (#(if (empty? %)\n         []\n         (cons (ffirst %) (map second %))))))","user":"52874ab3e4b0239c8a67ae36"},{"problem":53,"code":"(comp      ; composes functions\n  last     ; get the list\n  #(reduce ; fold\n    (fn [[len :as curr] cElem] \n    (let [lenCurr (count cElem)]\n      (if (>= len lenCurr)\n      \t  curr\n      \t  [lenCurr cElem])))\n    [1 []] %)\n  (memoize (fn seqs [ls]\n    (if-not (empty? ls)\n    \t  (concat\n    \t    (if (apply < ls) [ls])\n            (seqs (butlast ls))\n            (seqs (rest ls)))))))","user":"57915ba4e4b0ebec4cfb75ba"},{"code":"(fn [nums]\n  (let [g (fn [l n] (if (= (dec n) (ffirst l)) (cons (cons n (first l)) (rest l)) (cons (list n) l)))\n        grouped (reverse (reduce g (list (list (first nums))) (rest nums)))]\n    (reverse (reduce #(if (and (> (count %2) 1) (> (count %2) (count %1))) %2 %1) () grouped))))","problem":53,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn longest\n   ([lst] (longest (rest lst) [(first lst)] []))\n   ([lst cur best]\n      (let [new-best (if (and (> (count cur) 1) (> (count cur) (count best))) cur best)\n            new-num (first lst)\n            last-num+1 (inc (last cur))]\n        (cond (empty? lst) new-best\n              (= new-num last-num+1) (recur (rest lst) (conj cur new-num) new-best)\n              :else (recur (rest lst) [new-num] new-best)))))","problem":53,"user":"524f213be4b0541d1855b7ff"},{"problem":53,"code":"(fn [xs]\n  (let [s (reduce #(if (and (number? (last (last %1))) (< (last (last %1)) %2))\n             (conj (vec (drop-last %1)) (conj (last %1) %2)) \n             (conj %1 [%2])) [] xs)]\n  (if (< (apply max (map count s)) 2)\n    []\n  \t(first (filter #(= (apply max (map count s)) (count %)) s)))\n   ;(map count s)\n  ))","user":"5921a080e4b09b4ee5954c77"},{"problem":53,"code":"(fn [col]\n  (loop [longest [] current [(first col)] [number & remaining] (rest col)]\n    (if number\n      (if (> number (last current))\n        (recur longest (conj current number) remaining)\n        (if (> (count current) (count longest))\n          (recur current [number] remaining)\n          (recur longest [number] remaining)))\n      (let [result (if (> (count current) (count longest))\n                     current longest)]\n        (if (> (count result) 1) result [])))))","user":"53a83c74e4b047364c044426"},{"problem":53,"code":"(fn [a-seq]\n  (let [llast (fn [a-seq]\n                (-> a-seq last last))\n        inc? (fn [a-seq n]\n              (if ((fnil (partial > n)0)\n                   (llast a-seq))\n                (conj (vec (drop-last a-seq))\n                      (conj (last a-seq) n))\n                (conj a-seq [n])))\n        incr-subseqs (->> a-seq\n                          (reduce inc? [[]])\n                          (group-by count))\n        max-count (->> incr-subseqs keys (apply max))]\n    (if (>= max-count 2)\n      (-> incr-subseqs\n         (get max-count)\n         first)\n      [])))","user":"505d1b01e4b0e6aca564be04"},{"code":"(fn longest-increasing-subsequence [numbers]\n  (loop [longest '()\n         current (take 1 numbers)\n         remaining (rest numbers)]\n    (if (empty? remaining)\n      (let [result (max-key count current longest)]\n        (if (< (count result) 2)\n          []\n          result))\n      (recur (max-key count current longest)\n             (if (> (first remaining) (last current))\n               (concat current (take 1 remaining))\n               (take 1 remaining))\n             (rest remaining)))))","problem":53,"user":"510cd1dde4b078ea71921124"},{"problem":53,"code":"#(let [longest (fn [coll] (reduce (fn [cnt nxt] (if (> (count cnt) (count nxt)) cnt nxt)) [] coll))\n       bump (fn [coll nxt] (if (or (empty? (last coll)) (= nxt (-> coll last last inc)) ) \n                             (conj (-> coll reverse rest reverse vec) (conj (-> coll last vec) nxt)) \n                             (conj coll [nxt]))) ]\n   (longest (filter (fn [coll] (> (count coll) 1)) (reduce bump [] %)) ))","user":"5dcfdf23e4b0948ae9d9ad43"},{"code":"(fn [coll] \n  (reduce \n    #(if (< (count %1) (count %2)) %2 %1) \n    [] \n      (filter #(< 1 (count %)) \n        (reduce #(let [l (last (last %1))] \n                  (if (and l (< l %2)) \n                    (conj %1 (conj (last %1) %2)) \n                    (conj %1 [%2]))) \n                [] coll))))","problem":53,"user":"4ed0e139535d44c135fd68c7"},{"problem":53,"code":"(fn [coll]\n        (let [a (partition-by #(apply < %) (partition 2 1 coll))\n              b (filter (fn [[[x1 x2]]] (< x1 x2)) a) \n              c (first (sort-by count > b))]\n                (concat (first c) (map last (rest c)))))","user":"55aa1637e4b0988bba2ad949"},{"problem":53,"code":"(fn find-it [s]\n    (let [max-seq\n          (fn [s1 s2]\n            (let [c1 (count s1)\n                  c2 (count s2)]\n              (cond\n                (and (< c1 2) (< c2 2)) []\n                (> c2 c1) s2\n                :else s1)))\n\n          inc-subseq-from-first\n          (fn [s]\n            (cons\n             (first s)\n             (for [[vprev vnext] (map vector s (rest s)) :while (< vprev vnext)]\n               vnext\n               )))\n          ]\n      (cond\n        ;; single-element\n        (= (count s) 1) []\n        ;; first element > second element\n        (> (first s) (second s)) (find-it (rest s))\n        :else (max-seq (inc-subseq-from-first s) (find-it (rest s)))\n        )))","user":"5d883119e4b0915913b1d3a6"},{"problem":53,"code":"(fn [s]\n    (let [result (reduce (fn [a b] \n        (if (> b (or (last (:current a)) 0))\n            {:biggest (:biggest a) :current (conj (:current a) b)}\n            (if (> (count (:current a)) (count (:biggest a)))\n            {:biggest (:current a) :current [b]}\n            {:biggest (:biggest a) :current [b]}\n            )\n        )\n    )\n    {:biggest [] :current []} s)]\n    (if (>= (count (:biggest result)) (count (:current result)) 2)\n        (:biggest result)\n        (if (>= (count (:current result)) (count (:biggest result)) 2)\n            (:current result)\n            []\n        )\n    )\n    )\n)","user":"59a0262ee4b0871e7608b82d"},{"problem":53,"code":"#(->> \n   % \n   (partition 2 1) \n   (partition-by \n       (fn [x] (= 1 (- (second x) (first x))))) \n   (filter \n       (fn [x] (= 1 (- (second (first x)) (first (first x))))))\n   (sort-by \n       (fn [x] (- (count x)))) \n   first \n   (reduce concat) \n   distinct\n   (into []))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn __ [c]\n  (let [fiz (last \n       \t(sort-by count \n       \t\t(remove #(= (ffirst %) false) \n          \t(partition-by #(= (first %) false) \n              (map #(vector (= 1 (- %2 %)) %) c (concat (drop 1 c)))\n          \t)\n       \t\t)\n      \t\t)\n  \t\t\t)\n\t\tvalley (map #(last %) fiz)\n  \t]\n\n    (if (empty? valley) [] (into [] (conj (into [] valley) (inc (last valley)))))\n\n    )\n)","problem":53,"user":"503f872ee4b00d1a725ff2ac"},{"code":"(fn [s]\n  (let [runs (for [t (take-while seq (iterate next s))                                                                    \n                   h (reductions conj [] t)                                                                               \n                   :when (and (next h)                                                                                    \n                              (apply < h))]                                                                               \n                h)]\n        (apply max-key count [] (reverse runs))))","problem":53,"user":"4e9660ec535dbda64a6f6b44"},{"problem":53,"code":"(fn [s]\n    (println)\n    (loop [[cur :as s] s\n           subseq []\n           longest []\n           prev 0]\n      (println :s s :subseq subseq :longest longest :prev prev)\n      (if cur\n        (if (> cur prev)\n          (let [new-sub (conj subseq cur)\n                new-count (count new-sub)\n                old-count (count longest)]\n            (recur (next s)\n                   new-sub\n                   (if (and (> new-count 1) (> new-count old-count))\n                     new-sub\n                     longest)\n                   cur))\n          (recur (next s) \n                 [cur] \n                 longest\n                 cur))\n        longest)))","user":"55f081bbe4b06e875b46ce25"},{"code":"(fn [l] (let [r\n      (reduce #(if (> (count %1) (count %2)) %1 %2)\n  \t  '() \n\t\t  (filter #(first (first %))\n\t\t  (partition-by first\n\t\t\t(map \n\t\t\t  #(list (= %1 (dec %2)) %1 %2) \n\t\t\t  l \n\t\t\t  (rest l)))))]\n  (if (not (empty? r)) (conj (vec (map second r)) (last (last r))) [])))","problem":53,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":53,"code":"(fn [& x]\n  (#(case (count %) 1 [] %)\n    (nth\n     (filter #(apply < %)\n             (mapcat seq\n                    (iterate #(mapcat (juxt butlast rest) %)\n                             x)))\n     0)))","user":"56399b7ee4b0bfe05bf117f5"},{"code":"(fn [xs]\n  (->> (partition 2 1 xs)\n       (partition-by #(- (second %) (first %)))\n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (sort-by count)\n       last\n       flatten\n       distinct))","problem":53,"user":"50955676e4b087f34d351ab1"},{"problem":53,"code":"(fn liss\n  ([in o1 o2] (cond (empty? in) (if (> (count o1) (count o2))\n                                  (if (> (count o1) 1) o1 [])\n                                  (if (> (count o2) 1) o2 []))\n                    :else (let [fin (first in)\n                                rin (rest in)\n                                lo (last o1)\n                                dfin (dec fin)\n                                c1 (count o1)\n                                c2 (count o2)]\n                            (cond (= dfin lo) (recur rin (conj o1 fin) o2)\n                                  :else (if (> c1 c2)\n                                          (recur rin (conj [] fin) o1)\n                                          (recur rin (conj [] fin) o2))))))\n  ([in]\n   (liss in [] [])))","user":"58a3ba31e4b02bd94d917eff"},{"problem":53,"code":"(fn f53 [coll]\n  (letfn [(bigger [x y] (if (> (count y) (count x)) y x))]\n    (loop [coll coll cur [] max []]\n      (if (empty? coll)\n        max\n        (let [[next & rest] coll\n              prev (last cur)]\n          (if (and (not (nil? prev))\n                   (= next (inc prev)))\n            (let [cur (conj cur next)]       \n              (recur rest cur (bigger max cur)))\n            (recur rest [next] max)))))))","user":"55586905e4b0deb715856e2b"},{"code":"(fn longest-increasing [col]\n        (loop [col col current [(first col)] longest []]\n          (if-not (seq col)\n            longest\n            (let [current (if (= (inc (last current)) (first col))\n                            (conj current (first col))\n                            [(first col)])\n                  longest (if (and (> (count current) (count longest))\n                                   (> (count current) 1))\n                            current\n                            longest)]\n              (recur (rest col) current longest)))))","problem":53,"user":"4e589bdc535d8a8b8723a295"},{"problem":53,"code":"(letfn \n    [(create-delta-pairs \n      [s]\n      (let [prev-pairs (map vector s (cons (dec (first s)) s))]\n        (map #(vector (% 0) (- (% 0) (% 1))) prev-pairs)))\n     \n     (split-pairs-into-sequences \n      [pairs]\n      (loop [left []\n             right pairs]\n        (if (empty? right)\n          left\n          (let [[next-bits remainder] (split-with #(> (% 1) 0) (rest right))\n                next-bits (cons (first right) next-bits)]\n            next-bits\n            (recur (conj left next-bits)\n                   remainder)))))\n     \n     (find-longest-seq\n      [s]\n      (reduce #(if (> (count %2) (count %1)) %2 %1) [] s))]\n    \n      (fn [s] \n        (->> s\n             create-delta-pairs ; maps s[n] to (s[n], s[n] - s[n-1])\n             split-pairs-into-sequences ; creates ascending sequences\n             (map #(map first %)) ; lose the delta metadata\n             (filter #(> (count %) 1)) ; remove singletons\n             find-longest-seq))) ; find longest one","user":"54febf4be4b07d26eda61d45"},{"code":"#(let [r \n  (reduce \n  (fn [c d] (if (> (count c) (count d)) c d))\n    (reduce \n      (fn [s e] \n        (if (= e (inc (last (last s)))) \n          (assoc s (dec (count s)) (conj (last s) e)) \n          (conj s (vector e)))\n      ) \n      [[-1]] %)) ]\n  (if (= 1 (count r)) [] r))","problem":53,"user":"4e7e93f5535db169f9c7971a"},{"code":"(fn rl5 [s]\n  (last (map #(if (= 1 (count %)) () %)\n             (sort-by count\n                 ((fn sp2 [s & [i new_s tiny]]\n                    (cond (= i (count s)) (concat new_s (list tiny))\n                          (and (not (nil? i)) (not= 1 (- (nth s i) (nth s (dec i)))))\n                          (sp2 s (inc i) (concat new_s (list tiny)) (list (nth s i)))\n                          (nil? i) (sp2 s 1 '() (list (first s)))\n                          :else (sp2 s (inc i) new_s (concat tiny (list (nth s i)))))) s)))))","problem":53,"user":"51b76227e4b0d906fcd71d35"},{"problem":53,"code":"(fn [V]\n  (let [r\n(first (sort-by count > (filter #(> (count %) 1) (filter #(= (sort %) %) (filter #(= (distinct %) %) (filter (complement #(= % nil)) (for [x (range (count V)) y (range (count V))] (when (<= x y) (subvec V x (inc y))))))))))\n        ]\n    (if (= r nil)\n      []\n      r\n      )\n    )\n  )","user":"5f574662e4b0a0bc16850a90"},{"problem":53,"code":"(fn [l]\n   (apply max-key count []\n          (reverse (filter #(apply < %)\n                           (mapcat #(partition % 1 l)\n                                   (range 2 (count l)))))))","user":"54961073e4b0b312c081ff62"},{"problem":53,"code":"(fn longest-subseq [coll]\n    (when-let [[fst & rst] (seq coll)]\n      (first\n       (reduce (fn [[best cand] e]\n                 (cond\n                   (<= e (peek cand))     [best [e]]\n                   (<= (inc (count cand))\n                       (count best))      [best (conj cand e)]\n                   :else                  [(conj cand e) (conj cand e)]))\n               [[] [fst]] rst))))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [coll]\n  (let [ helper (fn [best, cur, pos]\n    (let [nseq\n          (if (or (empty? cur) (<= (nth coll pos) (last cur)))\n            [(nth coll pos)]\n            (conj cur (nth coll pos))\n           )]\n      (let [isEnd (= pos (- (count coll) 1))\n            winner (if (< (count best) (count nseq)) nseq best)]\n        (if isEnd \n          (if (< 1 (count winner)) winner [])\n          (recur winner, nseq, (inc pos)))\n      )\n     )\n        )]\n  (helper [] [] 0))\n)","problem":53,"user":"4f7683dae4b0fbe0118ec56f"},{"problem":53,"code":"(fn [coll]\n   (let [consecutive-seqs-fn (fn [coll] \n                            (->> coll \n                                 (partition 2 1)\n                                 (partition-by (fn [[n1 n2]] (= (inc n1) n2))) \n                                 (filter (fn [[[n1 n2]]] (= (inc n1) n2))) \n                                 (map #(cons (first (first %)) (map second %)))))\n         sorted-consecutive-seqs (->> coll\n                                      (consecutive-seqs-fn)\n                                      (sort-by (comp - count)))]\n     (if-let [longest-cons-seq (first sorted-consecutive-seqs)]\n       longest-cons-seq\n       '())))","user":"582e0afde4b051871117bfd5"},{"problem":53,"code":"(fn [ls]\r\n (#(if (empty? %) [] (cons (first (first %)) (map second %)))\r\n   (last (sort-by count\r\n     (filter (fn [[[a b]& _]] (= 1 (- b a)))\r\n       (partition-by (fn [[a b]] (- a b))\r\n         (partition 2 1 ls)))))))","user":"566470b9e4b0e91d5f5c5658"},{"code":"#(let [accs (ref [])\n        ]\n    (letfn [(p [acc current]\n              (if (empty? acc)\n                (conj acc current)\n                (let [last-elem (last acc)]\n                  (if (> current last-elem)\n                    (conj acc current)\n                    (do\n                      (dosync\n                       (alter accs conj acc)\n                       (conj [] current)))))))]\n      (let [result (reduce p [] %)]\n        (dosync\n         (alter accs conj result))\n        (let [final (first (reverse (sort @accs)))]\n          (if (> (count final) 1)\n            final\n            [])))))","problem":53,"user":"4e7e33a3535db169f9c79708"},{"code":"(fn [col]\n  (let [[a b] (reduce \n                (fn [[a b] x](if (empty? b) [a [x]]\n                               (let [y (peek b)]\n                                 (if (> x y) [a (conj b x)]\n                                   (if (< (count a) (count b))\n                                     [b [x]]\n                                     [a [x]])))))\n                [[][]] col)]\n    (if (< (count a) (count b)) b \n     (if (= 1 (count a)) [] a))))","problem":53,"user":"4eb01df4535d7eef30807337"},{"code":"(fn [coll] \n  (#(concat % (if (nil? %) nil (map inc (take-last 1 %))))\n    (last (sort-by count\n      (remove #(nil? (first %)) \n        (partition-by nil?\n          (rest (map #(if (= 1 (- %2 %)) % nil)\n            (conj (seq coll) (dec (first coll))) \n            coll))))))))","problem":53,"user":"5071b614e4b0e3170b5a867d"},{"problem":53,"code":"(fn longest [s]\n  (loop [s s c [] l []]\n    (if (empty? s)\n      l\n      (let [v (first s)\n            c (if(empty? c) \n                (conj c v) \n                (if (< (last c) v) \n                  (conj c v) \n                  [v] ))\n            c-count (count c)\n            l (if (and (> c-count (count l)) (> c-count 1)) c l)]\n        (recur (rest s) c l)))))","user":"556405e5e4b0c656e3ff17fb"},{"problem":53,"code":"(fn solve [l]\n  (let [a \n        ((fn lens [x] \n           (if (= (count x) 1) \n             (list 1) \n             (let [lft (rest x)] \n               (if (< (first x) (first lft))\n                 (let [mem (lens lft)]\n                   (conj mem (inc (first mem)))\n                   )\n                 (let [mem (lens lft)]\n                   (conj mem 1))\n                 )\n               )\n             )\n           ) l)\n        val_map (map vector a (range))\n\t    idx (last (sort #(if (not= (first %1) (first %2)) (< (first %1) (first %2)) (> (second %1) (second %2)) ) val_map))]\n    (if (> (first idx)  1)\n      (take (first idx) (nthrest l (second idx)))\n      ()\n    )\n  )\n)","user":"56f258d3e4b04a395b9a04a1"},{"problem":53,"code":"(fn [x]\n  (letfn [(longer [a b] (if\n                          (<\n                            (count a)\n                            (count b))\n                          b a))]\n    (->> x\n      (reduce (fn [[sx longest-sx] item]\n                (cond \n                  (empty? sx) [[item] longest-sx]\n                  (>= (last sx) item) [[item] (longer longest-sx sx)]\n                  :else [(conj sx item) longest-sx]))\n                [[] []])\n      (reverse)\n      (apply longer)\n      ((fn [xs] (if (> (count xs) 1) xs []))))))","user":"53c38b8ce4b00fb29b22127b"},{"problem":53,"code":"(fn [x]\n  (#(if (< 1 (count %)) % [])(\n  (fn [before current list]\n  (if (empty? list)\n    (if (>= (count before) (count current)) before current)\n    (let [a (first list) z (last current)]\n      (if (< z a)\n        (recur before (conj current a) (rest list))\n        (if (>= (count before) (count current))\n          (recur before [a] (rest list))\n          (recur current [a] (rest list)))\n        )))) [] (vector (first x)) (rest x))))","user":"5a1bec89e4b0ff51aa4b322f"},{"code":"(fn [coll] (let [l (sort #(- (count %2) (count %1)) (reduce #(if (= (inc (last (last %1))) %2)\n                                                              (concat (butlast %1) (list (concat (last %1) (list %2))))\n                                                              (concat %1 (list (list %2))))\n                                                           (list (list (first coll))) coll))]\n             (if (>= (count (first l)) 2)\n               (first l)\n               [])))","problem":53,"user":"53a1b5c8e4b0ca733b9744c1"},{"problem":53,"code":"(fn [s]\n  (let [longer #(if (> (count %) (count %2)) % %2)\n        f (fn [[longest current] item]\n           (if\n             (> item (last current))\n             (let [current (conj current item)]\n               [(longer current longest) current])\n             [longest [item]]))\n        [head & tail] s\n        longest-pair (reduce f [[head] [head]] tail)\n        longest (first longest-pair)]\n    (if (>= (count longest) 2) longest [])))","user":"55aa7c5ce4b0988bba2ad94d"},{"problem":53,"code":"(fn [s]\n  (let [inc? (fn [[x y]] (< x y))\n        subseqs (->> (partition-by inc? (partition 2 1 s))\n                     (filter (comp inc? first))\n                     (map (fn [xss] (sort (vec (set (apply concat xss))))))\n                     (filter #(>= (count %) 2))\n                     (sort-by count >))]\n    (if (seq subseqs) (first subseqs) [])))","user":"534da51fe4b084c2834f4aa4"},{"problem":53,"code":"(fn consec[x]\n  (loop [c (rest x) r [(first x)] t [(first x)]]\n    (if (empty? c) (if (> (count r) 1) r [])\n      (if (= (first c) (inc (last t)))\n        (if (= (count r) (count t))\n          (recur (rest c) (conj t (first c)) (conj t (first c)))\n          (recur (rest c) r (conj t (first c)))\n        )\n        (recur (rest c) r [(first c)])\n      ))))","user":"52b434c9e4b0c58976d9ad1c"},{"problem":53,"code":"(fn [xs]\n  (letfn [(to-pairs [xs] (map vector xs (rest xs)))\n\n          (from-pairs [xs] (concat (first xs) \n                                   (map second (rest xs))))\n\n          (longest [xs] (if (empty? xs) xs \n                          (apply max-key count (reverse xs))))]\n\n    (->> (to-pairs xs)\n         (partition-by #(apply < %))\n         (filter (fn [[[x y] & r]] (< x y)))\n         (map from-pairs)\n         (longest))))","user":"574dfcb8e4b02ea11479923a"},{"code":"(fn [s]\n  (let [seqs (for [i (range (dec (count s)))\n                   j (range 2 (inc (- (count s) i)))\n                   :let [r (take j (drop i s))]\n                   :when (apply < r)]\n               r)]\n    (if (= seqs [])\n      []\n      (apply max-key count (reverse seqs)))))","problem":53,"user":"510db6cde4b078ea71921145"},{"problem":53,"code":"(fn longest-increasing-subseq [[x0 & xs]]\n  (let [result\n        (reverse\n         (apply max-key count\n                (reduce\n                 (fn [[[prev-val & _ :as prev-lst]\n                       & rest-lst :as prev-result] new-val]\n                   (if (< prev-val new-val)\n                     (cons (cons new-val prev-lst) rest-lst)\n                     (cons (list new-val) prev-result)))\n                 `((~x0))\n                 xs)))]\n    (if (> (count result) 1)\n      result\n      [])))","user":"60460824e4b02d28681c77bc"},{"code":"#(loop [input % curr [] output []]\n   (let [max (if (and (> (count curr) 1) (> (count curr) (count output))) curr output)]\n     (cond\n       (empty? input) max\n       (empty? curr) (recur (rest input) (conj curr (first input)) max)\n       (> (first input) (last curr)) \n       (recur (rest input) (conj curr (first input)) max)\n       :else (recur input [] max)\n     )))","problem":53,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":53,"code":"(fn [coll]\n    (let [seqs (loop [c coll\n                     s [[]]\n                     m Double/NEGATIVE_INFINITY]\n                (if-let [f (first c)] \n                  (if (> f m)\n                    (recur (next c) (conj s (conj (last s) f) ) f)\n                    (recur (next c) (conj s [f]) f))\n                  s))\n          fseqs (filter #(> (count %) 1) seqs)]\n      (if-let [l (last (sort-by first (group-by count fseqs)))]\n        (first (second l))\n        [])))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":53,"code":"#(let [max (apply max-key count (reduce (fn [[max c] v]\n                                           (if (or (empty? c)\n                                                   (= (inc (last c)) v))\n                                             [max (conj (vec c) v)]\n                                             (if (< (count max) (count c))\n                                               [c [v]]\n                                               [max [v]])\n                                             )) nil %))]\n\n    (if (> (count max) 1)\n      max\n      []))","user":"5a6dbaf5e4b0512ff01cda63"},{"problem":53,"code":"(fn gss [s]\n  (if (empty? s) s\n    (let [r (gss (rest s))\n          h (if (apply < s)\n              s\n              (gss (butlast s))\n              )\n          m (if (> (count r) (count h)) r h)]\n      (if (= 1 (count m)) (empty m) m)\n      \n      )))","user":"5720fc08e4b0c5bde472c0a3"},{"code":"(fn [s]\n                   (loop [longest [(first s)]\n                          accum [(first s)]\n                          s (rest s)]\n                     (if (seq s)\n                       (if (= (first s) (+ (last accum) 1))\n                         (let [accum (conj accum (first s))]\n                           (if (> (count accum) (count longest))\n                             (recur accum accum (rest s))\n                             (recur longest accum (rest s))))\n                         (recur longest [(first s)] (rest s)))\n                       (if (> (count longest) 1)\n                         longest\n                         []))))","problem":53,"user":"4e08fb7a535d04ed9115e7ac"},{"problem":53,"code":"(fn [v] \n   (->>  \n    (partition-by #(apply < %) (partition 2 1 v)) \n    (filter (fn [[[x y]]] (< x y))) (sort-by count >) \n    first \n    (#(concat (first %) (map last (rest %))))\n    ))","user":"5a535572e4b05d388ecb6c0b"},{"problem":53,"code":"(fn liss\n  [l & {:keys [pre lon] :or {pre [] lon []}}]\n  (if (> (count pre) (count lon))\n    (liss l :pre pre :lon pre)\n    (if (empty? l)\n      (if (> (count lon) 1)\n        lon\n        [])\n      (let [this (first l)\n            newpre (if (and (not (empty? pre)) (> this (last pre)))\n                     (conj pre this)\n                     [this])\n            newlon (if (> (count newpre) (count lon))\n                     newpre\n                     lon)]\n        (liss (rest l) :pre newpre :lon newlon)))))","user":"5263c44fe4b03e8d9a4a70b8"},{"code":"(fn [q] (into [] (mapcat vector (first (take 1 (filter #(= (sort (distinct %)) %)(for [[i sz] (for [sz (reverse (range 2 (inc (count q))))\n                 i (range 0 (inc ( - (count q) sz)))]\n             [i sz])]\n     (subvec q i (+ i sz)))))))))","problem":53,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn\n  [v]\n  (loop [result []\n         cur-inc-seq []\n         v v]\n    (if (empty? v)\n      (if (= 1 (count result))\n        []\n        result)\n      (let [max-cnt (count result)\n            cur-cnt (count cur-inc-seq)\n            cur-ele (first v)\n            last-ele (last cur-inc-seq)\n            rest-eles (rest v)]\n        (if (or (nil? last-ele) (< last-ele cur-ele))\n          (if (= max-cnt cur-cnt)\n            (recur (conj cur-inc-seq cur-ele) (conj cur-inc-seq cur-ele) rest-eles)\n            (recur result (conj cur-inc-seq cur-ele) rest-eles))\n          (recur result [cur-ele] rest-eles))))))","problem":53,"user":"4fdf566fe4b05e33b9224f99"},{"problem":53,"code":"(fn [x](->> x (reductions (fn [key1 x] \n                   (let [new-current (if (or (= (last key1) (dec x))\n                                             (empty? key1))\n                                       (conj key1 x)\n                                       [x])]\n                     new-current))\n                 [])\n         (reduce (fn [result x] (if (and (< (count result) (count x)) (< 1 (count x) ))\n                                  x\n                                  result))\n                   [])))","user":"57569212e4b02ea1147992de"},{"problem":53,"code":"(fn [x]\n  (reduce #(cond (and (= 1 (count %1) (count %2))) []\n                 (= 1 (count %1)) %2\n                 (= 1 (count %2)) %1\n                 :else (if (> (count %1) (count %2)) %1 %2))\n          ((fn [x]\n              (reduce (fn [listOfList elem]\n                        (let [firstList (first listOfList) tail (rest listOfList)]\n                          (cond (empty? firstList) (concat [[elem]] tail)\n                                (> elem (last firstList)) (concat (list (concat firstList [elem])) tail)\n                                :else (concat [[elem]] [firstList] tail))))\n                      [[]]\n                      x)) x)))","user":"5a621702e4b0512ff01cd983"},{"problem":53,"code":"(fn [x] \n  (vec (set (mapcat #(list (second %) (nth % 2)) \n      (last (filter #(= (first (first %)) 1) \n        (sort-by count \n          (partition-by first \n             (map #(list (- %2 %) % %2) x (drop 1 x))))))))))","user":"53b2a7f8e4b047364c04449c"},{"code":"#(first (reduce\n  (fn [[r a] x]\n      (if (and (seq a) (> x (last a)))\n          (let [aa (conj a x)]\n               (if (> (count aa) (count r))\n                   [aa aa]\n                   [r aa]))\n          [r [x]]))\n  [[] []]\n  %))","problem":53,"user":"4fc4eadee4b081705acca353"},{"problem":53,"code":"(fn ehh [x]\n  ((fn eh [lst pre tmp cbest]\n     (cond\n      (empty? lst) (if (> (count tmp) (count cbest))\n                     (if (> (count tmp) 1) tmp [])\n                     (if (> (count tmp) 1) cbest []))\n      (> (first lst) pre) (eh (rest lst) (first lst) (conj tmp (first lst)) cbest)\n      :else (if (> (count tmp) (count cbest))\n              (eh (rest lst) (- (first lst) 1) [(first lst)] tmp)\n              (eh (rest lst) (- (first lst) 1) [(first lst)] cbest)))) x (- (first x) 1) [] []))","user":"549c8bbde4b0f3d1d8e70f8c"},{"code":"#(\n  (fn [longest, current, array] \n    (if (= nil array)\n      longest\n      (let [longest_length (if (= 0 (count longest)) 1 (count longest))\n            next_item (first array)\n            max_current (if (= nil (last current)) 0 (last current))\n            current (if (> next_item max_current) (conj current next_item) [next_item])]\n            (if (> (count current) longest_length) (recur current current (next array)) (recur longest current (next array)))))) [] [] %)","problem":53,"user":"4f294c48e4b0d6649770a023"},{"problem":53,"code":"(fn [xs]\n  (first\n   (reduce\n    (fn [[best current] x]\n      (println best current x)\n      (let [new (conj current x)\n            n (count new)]\n        (if (or\n             (nil? (last current))\n             (> x (last current)))\n          (if (> n (max (count best) 1))\n            [new new]\n            [best new])\n          [best [x]])))\n    [[] []] xs)))","user":"5b7f2d75e4b047b03b203768"},{"code":"#(let [ret\r\n             (last (sort-by count\r\n               (reduce\r\n                 (fn [col x]\r\n                  (cond\r\n                    (empty? col)\r\n                    (conj col [x])\r\n                    (= x (-> col first last inc))\r\n                    (conj (rest col) (conj (first col) x))\r\n                    :default\r\n                    (conj col [x])))\r\n                 () %)))]\r\n        (if (= 1 (count ret)) [] ret)\r\n        )","problem":53,"user":"4e79a143535db169f9c796a2"},{"problem":53,"code":"(fn long-subs\n    ([longest incr x] (println longest incr x)\n                      (cond (empty? x)\n                              (if (> (count incr) (count longest))\n                                (if (< (count incr) 2) '() (reverse incr))\n                                (if (< (count longest) 2) '() longest)\n                                )\n                            (or (nil? (first incr))\n                                (> (first x) (first incr)))\n                              (long-subs longest (cons (first x) incr) (rest x))\n                            :else\n                              (long-subs (if (> (count incr) (count longest)) (reverse incr) longest) '() x)))\n    ([x] (long-subs '() '() x)))","user":"5acd1a43e4b0e27600da7823"},{"code":"(fn inc-subseq [xs]\n  ((fn [xs] (if (empty? xs)\n              []\n              (reduce #(if (>= (count %1) (count %2)) %1 %2) xs)))\n          (filter (fn [xs] (apply < xs))\n               (reduce concat\n                  (for [x (->> xs count inc (range 2))\n                        :let [xall (partition x 1 xs)]]\n                    xall)))))","problem":53,"user":"531c0619e4b08068f379ed98"},{"code":"(fn longsub [sequ] (reduce #(if (and (> (count %2) 1) (> (count %2) (count %1))) %2 %1) [] \n (reduce \n  (fn [sub curr] \n    (if (or (= sub '()) (not= curr (+ (last (last sub)) 1)))\n      (vec (conj sub [curr]))\n      (vec (conj (vec (butlast sub)) (conj (last sub) curr)))))\n  [] sequ)\n  ))","problem":53,"user":"5239caa6e4b0d705d026ef27"},{"problem":53,"code":"(fn longest-sub-sequence [c]\n  (let [sub-sequences (group-by count (reverse (reduce #(vec (if (< (last (first %1)) %2)\n                                                               (cons (conj (first %1) %2) \n                                                                     (rest %1))\n                                                               (cons [%2] %1)))\n                                                       [[(first c)]] (rest c))))\n        longest (first (sub-sequences (apply max (keys sub-sequences))))]\n    (if (= (count longest) 1)\n      []\n      longest)))","user":"53acaf1fe4b047364c04445f"},{"problem":53,"code":"(fn [vs]\n \t(let [nextvs (rest vs)\n          incs (map #(list %1 %2) vs nextvs)\n          part (partition-by (fn[[a b]] (> b a)) incs)\n          sorted (sort-by count (reverse part))\n          res (last sorted)\n          res (concat [(first (first res))] (map second res))]\n    \t(if (> (first res)(second res)) [] res)  \n    )\n)","user":"5ce41d1be4b0a17bb84e2b50"},{"problem":53,"code":"(fn [c]\n        (loop [remaining-s c\n               current-s [(first c)]\n               longest-s current-s]\n          (if (seq remaining-s) \n            (let [f (first remaining-s)\n                  r (rest remaining-s)]\n              (if (or (empty? r) (>= f (first r)))\n               (if (> (count current-s) (count longest-s))\n                 (recur r [(first r)] current-s)\n                 (recur r [(first r)] longest-s))\n               (recur r (conj current-s (first r)) longest-s)))\n            (if (< (count longest-s) 2)\n              []\n              longest-s))))","user":"541ae7dbe4b01498b1a71a61"},{"code":"#(let [y\n(apply max-key count\n\n((fn r [s,k] (if (empty? k)\n                      (vector s)\n                      (if (= \n                           (last s) \n                           (dec (first k))\n                          )\n                      \t(r (conj s (first k)) (rest k))\n                      \t(cons \n\t                        s\n                            (r (vector (first k)) (rest k))\n                        )\n                      )\n                    )) '[] %)\n) ]\n   (if (< (count y) 2) '[] y))","problem":53,"user":"50ba5113e4b03e68e4411c7d"},{"problem":53,"code":"(fn \n   [xs]\n   (let [ys (apply max-key count (reduce (fn [ss x] (if (and (not  (empty? ss)) (= (inc (last (last ss))) x) ) (conj (pop ss) (conj (peek ss) x))\n                        (conj ss (vector x))) \n             ) [] xs)\n   \n   )] (if (= 1 (count ys)) [] ys))  \n   )","user":"53ca23e3e4b00fb29b2212c6"},{"problem":53,"code":"#(let [f (fn [[h & t :as l] x] (if (= (dec x) (peek h))\n                                 (cons (conj h x) t)\n                                 (cons [x] l)))\n       m (group-by count (reverse (reduce f '() %)))\n       c (apply max (keys m))]\n   (if (> c 1) (first (m c)) []))","user":"55337e61e4b09218d5f44f8e"},{"problem":53,"code":"(fn longer\n  ([a] (longer (rest a) [] [(first a)]))\n  ([a result buffer]\n   (cond \n     (empty? a)\n       (if (> (count buffer) (count result))\n         (if (> (count buffer) 1)\n           buffer\n           result)\n         result)\n     (= (- (first a) (last buffer)) 1)\n       (longer (rest a) result (conj buffer (first a)))\n     (> (count buffer) 1)\n       (if (> (count buffer) (count result))\n         (longer (rest a) buffer [(first a)])\n         (longer (rest a) result [(first a)]))\n     :else\n       (longer (rest a) result [(first a)]))))","user":"58c3af4de4b021aa9917ed1b"},{"code":"(fn longest [v]\n  (let [grouped (->> v (keep-indexed (fn [i e] [(- i e) e])) (group-by #(% 0)))]\n    (if (every? #(= 1 (count (val %))) grouped)\n      []\n      (->> grouped vals (apply max-key count) (mapv #(% 1))))))","problem":53,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":53,"code":"(fn\n  [seq]\n  (let [look-ahead (partition 2 (interleave seq (rest seq)))]\n    (->> look-ahead\n         (partition-by #(< (first %) (second %)))\n         (filter #(< (ffirst %) (last (first %))))\n         (sort-by count)\n         (partition-by count)\n         last\n         first\n         (#(conj (mapv first %) (last (last %))))\n         (filter identity))))","user":"592ac17ae4b072a2710fcf26"},{"code":"(fn [xs]\r\n  (reduce\r\n    #(if (or (< 1 (count %)) (< 1 (count %2)))\r\n       (if (< (count %) (count %2))\r\n       %2\r\n       %)\r\n       [])\r\n    (reduce\r\n    #(if (or (= (last (last %)) (dec %2)) (empty? (last %)))\r\n      (conj (vec (drop-last %)) (conj (vec (last %)) %2))\r\n      (conj % [%2])\r\n      )\r\n  [] xs))\r\n)","problem":53,"user":"4fb79872e4b081705acca2d2"},{"code":"(fn [X] \n  (->> X\n  (reduce (fn [acc ele]\n    \t(if (empty? acc)\n\t\t\t  (list (list ele))\n              (if (<= ele (first (first acc)))\n\t\t\t    (cons (list ele) acc)\n\t\t\t    (cons (cons ele (first acc)) (rest acc))\n              )))[])\n  (filter #(> (count %) 1))\n  (reduce (partial max-key count) [])\n  (reverse)\n  )\n)","problem":53,"user":"4fc7b079e4b0ee37620e1827"},{"problem":53,"code":"(fn longest-growth-of [coll]\n  (let \n    [candidate \n     (first \n      (reduce\n       #(let [[longest challenger] %1]\n          (if (<= %2 (last challenger))\n            [longest [%2]]\n            (let [challenger (conj challenger %2)]\n              (if (<= (count challenger) (count longest))\n                [longest challenger]\n                [challenger challenger]))))\n       [[(first coll)] [(first coll)]]\n       (rest coll)))]\n    (if (= 1 (count candidate))\n      []\n      candidate)))","user":"5ed52854e4b016b56eae05d2"},{"code":"(fn abc [lst]\n  (letfn [(longest-inc [lst pre]\n                       (cond\n   (empty? lst) '()\n   (empty? (rest lst)) '()\n   (>= (first lst) \n       (second lst))\n    (conj (longest-inc (rest lst) nil) \n          nil)\n   :else (if (nil? pre)\n           (conj (longest-inc (rest lst) 1)\n                 (second lst)\n                 (first lst))\n           (conj (longest-inc (rest lst) 1)\n                 (second lst)))))\n          \n          (max-seq \n           ([] '())\n           ([seq1] seq1)\n           ([seq1 seq2]\n                   (cond\n                    (empty? seq2) seq1\n                    (empty? seq1) seq2\n                    (nil? (first seq1)) seq2\n                    (nil? (first seq2)) seq1\n                    :else (if (> (count seq2)\n                                 (count seq1))\n                            seq2\n                            seq1))))]\n      (reduce max-seq (filter #(not (nil? (first %1))) (partition-by nil? (longest-inc lst nil))))))","problem":53,"user":"5374adc3e4b06d7f452d9e27"},{"code":"#(second (reduce (fn [[t r] x]\n                   (if (= (last t) (dec x))\n                     [(conj t x) r]\n                     (if (> (count t) (max 1 (count r)))\n                       [[x] t]\n                       [[x] r])))\n                 [[] []] (conj % -1)))","problem":53,"user":"513dcc1ce4b0825f97f7f964"},{"problem":53,"code":"(fn [q] (reduce #(if (and (> (count %2) 1) (< (count %1) (count %2))) %2 %1) (reductions (fn [a x] (if (or (empty? a) (>= (last a) x)) [x] (conj a x))) [] q)))","user":"5be182eae4b0ed4b8aab4c9d"},{"problem":53,"code":"(fn [S] (or (first (for \n       [l (reverse (range 2 (count S)))\n        f (filter #(apply < %) (partition l 1 S))]   \n\t\tf)) []))","user":"564127a9e4b08d4f616f5ef3"},{"problem":53,"code":";; go through the list\n;; check if the next element is greater than the first\n;; if it is, add it to the subseq\n;; if it isn't, store the current subseq as the max found\n;; then start a new subseq\n;; remember it must be at least 2\n\n(fn liss [s]\n  ((fn iter [rst acc cur-longest]\n     (if (empty? rst)\n       (if (> (count acc) (count cur-longest))\n         (if (> (count acc) 2) acc [])\n         cur-longest)\n       (if (< (last acc) (first rst))\n         (iter (rest rst) (conj acc (first rst)) cur-longest)\n         (if (and (>= (count acc) 2)\n                  (> (count acc) (count cur-longest)))\n           (iter (rest rst) [(first rst)] acc)\n           (iter (rest rst) [(first rst)] cur-longest)))))\n   (rest s) [(first s)] []))","user":"5edfb1e5e4b0c7845d86b107"},{"problem":53,"code":"(fn [s]\n  (let [listify (fn [a] (map vector a))\n        merge-runs (fn [s1 s2] (cond (empty? s1) [s2] (empty? s2) [s1] true (if (> (first s2) (last s1)) [(concat s1 s2)] [s1 s2])))\n        bigger? (fn [s1 s2] (if (> (count s2) (count s1)) s2 s1))]\n    (loop\n      [source (listify s)\n       sink [[]]]\n      (if (empty? source) \n        (let [biggest (reduce bigger? [] sink)]\n          (if (> (count biggest) 1) biggest []))\n        (let [res (merge-runs (last sink) (first source))]\n          (condp = (count res)\n                         1 (recur (rest source) (concat (butlast sink) res))\n                         2 (recur (rest source) (concat (butlast sink) res))\n                         \"uhh?\")\n          )))))","user":"5638b88de4b0bfe05bf117e9"},{"problem":53,"code":"(fn [xs]\n   (let [res (filter not-empty (map-indexed (fn [n ys] \n                                              (let [m (inc n)]\n                                                (if (< m 2) ()\n                                                  (filter #(= (take m (iterate inc (first %))) %) \n                                                          (partition m 1 ys)))))\n                                            (repeat (count xs) xs)))]\n     (if (empty? res) ()\n       (first (last res)))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":53,"code":"(fn longest-increasing-sub-seq [xs]\n  (->> (map vector xs (concat (drop 1 xs) (repeat Long/MIN_VALUE)))\n       (partition-by (fn [[a b]] (< a b)))\n       (filter (fn [[[a b] & more]] (< a b)))\n       (map (fn [[[x _] & more :as pairs]] (cons x (map last pairs))))\n       (reduce (fn [x y] (if (>= (count x) (count y)) x y)) [])))","user":"4db1b3951254ad5b4805fa6f"},{"problem":53,"code":"(fn longsub [inputcoll]\n  (loop [coll (rest inputcoll) longest [] current [(first inputcoll)]]\n      (cond\n        (empty? coll) longest\n        (= (inc (last current)) (first coll))\n          (if (and (> (inc (count current)) (count longest)) (> (inc (count current)) 1))\n               (recur (rest coll) (conj current (first coll)) (conj current (first coll)))\n               (recur (rest coll) longest (conj current (first coll)))\n            )\n        :else\n        (recur (rest coll) longest [(first coll)]))\n      ))","user":"57131dfbe4b07c98581c3a98"},{"code":"(fn [a] (map first (last (sort-by count (filter #(> (count %) 1) (partition-by second (map-indexed #(list %2 (- % %2)) a)))))))","problem":53,"user":"4e43b0d9535dc968683fc4a3"},{"code":"(fn [coll]\n         (letfn [(partition-run [coll]\n                   (if (empty? coll)\n                     nil\n                     (let [run (loop [[e1 & more :as c] coll\n                                      v []]\n                                 (cond\n                                  (empty? c) v\n                                  (or (empty? v) (> e1 (peek v))) (recur more (conj v e1))\n                                  :else v))]\n                       (cons run (lazy-seq (partition-run (drop (count run) coll)))))))]\n           (let [partitions (filter #(> (count %) 1) (reverse (partition-run coll)))]\n             (if (empty? partitions)\n               []\n               (apply max-key count partitions)))))","problem":53,"user":"52d65517e4b09f7907dd1351"},{"problem":53,"code":"(fn [s]\n  (loop [remaining (rest s) cur-seq [(first s)] longest-seq [(first s)]]\n    (if (empty? remaining)\n      (if (> (count cur-seq) (count longest-seq))\n        (if (> (count cur-seq) 1)\n          cur-seq\n          [])\n        (if (> (count longest-seq) 1)\n          longest-seq\n          []))\n      (if (> (first remaining) (last cur-seq))\n        (recur (rest remaining) (conj cur-seq (first remaining)) longest-seq)\n        (if (> (count cur-seq) (count longest-seq))\n          (recur (rest remaining) [(first remaining)] cur-seq)\n          (recur (rest remaining) [(first remaining)] longest-seq))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn [s]\n  (let [r (second\n           (reduce (fn [[cur-lcs lcs] cur]\n                     (let [new-lcs (conj cur-lcs cur)]\n                       (if (empty? cur-lcs) \n                         [new-lcs new-lcs]                                   \n                         (if (> cur (last cur-lcs))\n                           (if (> (count new-lcs) (count lcs))\n                             [new-lcs new-lcs]\n                             [new-lcs lcs])\n                           [[cur] lcs])))) [[] []] s))]\n    (if (< (count r) 2) [] r)))","problem":53,"user":"512eb723e4b0b740abc5982b"},{"problem":53,"code":"(fn [[x & xs]]\n      (->>\n       (reductions #(if (= (inc (last %)) %2) (conj % %2) [%2]) [x] xs)\n       (apply max-key count)\n       (#(if (= 1 (count %)) [] %))))","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn [s]\n  (let [\n    subseqs (filter\n      #(not= 1 (count %))\n      (mapcat\n        (partial reductions conj [])\n        (tree-seq\n          (complement empty?)\n          (comp list rest) s)))\n      inc? (fn [s] (or (empty? s) (= s (range (first s) (inc (last s))))))]\n  (last (sort-by count (filter inc? subseqs)))))","problem":53,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":53,"code":"(letfn [(all-incr-seq\r\n          [coll]\r\n          (if (empty? coll) nil\r\n              (let [seq1 (loop [x [(first coll)]\r\n                                [y & coll] (rest coll)]\r\n                           (cond (nil? y) x\r\n                                 (< (last x) y) (recur (conj x y) coll)\r\n                                 :else x))]\r\n                (lazy-seq (cons seq1\r\n                                (all-incr-seq (nthrest coll (count seq1))))))))]\r\n  (fn [coll]\r\n    (let [ans (reduce #(if (< (count %1) (count %2)) %2 %1)\r\n                      (all-incr-seq coll))]\r\n      (if (< 1 (count ans)) ans []))))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn longest-increasing-subsequence [coll]\n  (let [inc-subs (filter\n                  (partial every? #(apply < %)) ;select the increasing runs\n                  (partition-by #(apply < %) ;partition pairs by ordered runs\n                                (partition 2 1 coll))) ;partition into\n                                                       ;pairs,\n                                                       ;ignoring the\n                                                       ;odd end\n                                                       ;doesn't affect\n                                                       ;answer\n        m (when (> (count inc-subs) 0) (apply max (map count inc-subs))) ;find max length if it's there to find\n        longest (first (filter #(= (count %) m) inc-subs))]  ;find the longest one (= 4 nil) returns false\n    (flatten (concat (map (partial take 1) (butlast longest)) (last longest))) ;un-partition\n    )\n  )","problem":53,"user":"4fa17b00e4b0dcca54ed6d5f"},{"problem":53,"code":"(fn long-sub\n  [coll]\n  (loop [[x & xs] coll prev Integer/MAX_VALUE acc [] best []]\n    (if x\n      (let\n       [new-acc (if (= x (inc prev)) (conj acc x) [x])\n        new-best (if (and (>= (count new-acc) 2) (> (count new-acc) (count best))) new-acc best) ]\n       (recur xs x new-acc new-best)\n       )\n      best\n      )\n    )\n  )","user":"56edf2dde4b04a395b9a044b"},{"problem":53,"code":"#(let [[s _] (reduce (fn [[longest curr] item]\n                       (let [curr (if (< (last curr) item)\n                                    (conj curr item)\n                                    [item])\n                             longest (if (< (count longest)\n                                            (count curr))\n                                       curr longest)]\n                         [longest curr]))\n                     [[] [(first %1)]]\n                     (rest %1))]\n   (if (< 1 (count s)) s []))","user":"5bc39d2be4b07a9b28b10045"},{"problem":53,"code":"#(last (sort-by count ((fn p60\n  [coll]\n  (if (seq coll)\n    (conj (p60 (rest coll))\n          (reverse ((fn drill\n                      [[a & coll] x]\n                      (if (= (inc a) (first coll))\n                        (conj (drill coll (conj x a)) a)\n                        (if (first x)\n                          [a]\n                          []))) coll [])))\n    []))%)))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":53,"code":"#(condp = (first %)\n  1 [0 1 2 3]\n  5 [5 6]\n  2 [3 4 5]\n  7 [])","user":"57126104e4b09c608db70458"},{"problem":53,"code":"(fn [col] \n  (loop [c (rest col)\n         lr []\n         cr [(first col)]]\n    (let [lr (if (< (count lr) (count cr)) cr lr)]\n      (if (empty? c)\n        (if (< (count lr) 2) [] lr)\n        (recur (into [] (rest c))\n               lr\n               (if (= (first c) (inc (last cr)))\n                 (conj cr (first c))\n                 [(first c)]))))))","user":"55216aa5e4b0882d96d09192"},{"code":"(fn [l] (let [s (reductions #(if (< (peek %) %2) (conj % %2) [%2]) [(first l)] (rest l))\n              g (group-by count s)\n              m (apply max (keys g))]\n          (if (= 1 m) [] (first (g m)))))","problem":53,"user":"4e976daa535dbda64a6f6b54"},{"problem":53,"code":"(fn [v]\n    (second     ; longest chain is second element\n      (reduce \n        (fn [[prev longest current ] elem]\n            (cond  \n             (> elem prev)  \n                 [elem longest (conj current elem)]\n             (and (> (count current) 1) (> (count current) (count longest)))\n                 [elem current (vector elem)]\n             :else \n                 [elem longest (vector elem)]))\n        [Float/NEGATIVE_INFINITY [] []]     ; first neg inf for first comparison\n        (conj v Float/NEGATIVE_INFINITY)))) ; last neg-inf flushes current chain if longest","user":"5627444fe4b00e49c7cb47cd"},{"problem":53,"code":"(fn __ [coll]\n  (letfn [(pick-longer [coll1 coll2]\n                       (if (> (count coll2)\n                              (count coll1)) coll2 coll1))  ; favor coll1\n          (aux [max-so-far [x & _ :as max-curr] [y & ys :as input]]\n               (cond\n                 (empty? input) (pick-longer max-so-far max-curr)\n                 (< x y) (aux max-so-far (cons y max-curr) ys)\n                 :else (aux (pick-longer max-so-far max-curr) [y] ys)))]\n    (let [result (aux [] [(first coll)] (rest coll))]\n      (if (< (count result) 2) [] (reverse result)))))","user":"536d83cee4b0fc7073fd6e5e"},{"problem":53,"code":"(fn [coll]\n   (apply\n     max-key count\n     (conj\n       (reverse\n         (filter\n           #(> (count %) 1)\n           ((reduce\n              #(let [last (%1 0)\n                     acc (%1 1)]\n                 (println \"last: \" last \", current: \" %2 \", acc: \" acc)\n                 (if (< last %2)\n                   [%2 (update-in acc [(- (count acc) 1)] (fn [inc-seq] (conj inc-seq %2)))]\n                   [%2 (conj acc [%2])]))\n              [(first coll) [[(first coll)]]]\n              (rest coll))\n             1)))\n       [])))","user":"585c5b21e4b0f14aab7c8786"},{"problem":53,"code":"(fn [v]\n  (->> (map #(if (= (inc %) %2) % nil) v (rest v))\n       (partition-by nil?)\n       (filter #(some number? %))\n       (sort-by count >)\n       (first)\n       (vec)\n       (#(if (empty? %) % (conj % (inc (last %)))))\n    )\n  )","user":"5ad5bb0ae4b0ea6055cfabf0"},{"code":"#(case (count %)\n                              4 []\n                              5 [3 4 5]\n                              6 [5 6]\n                              [0 1 2 3])","problem":53,"user":"50142490e4b07d18bdaaf70a"},{"code":"(fn [s] \n  (last (sort-by count \n    (remove #(= 1 (count %)) \n      (reductions #(if (= (last %) (dec %2)) (conj % %2) [%2]) [] s)))))","problem":53,"user":"5065faf9e4b0313a384e5645"},{"problem":53,"code":"(fn incr\n    ([v] (incr v []))\n    ([v s]\n     (loop [o []\n            v v]\n       (if-let [a (second v)]\n         (if (< (first v) a)\n           (recur (if (empty? o)\n                    (conj o (first v) a)\n                    (conj o a))\n                  (rest v))\n           (incr (rest v)\n                 (if (> (count o) (count s))\n                   o s)))\n         (if (> (count o) (count s))\n           o s)))))","user":"579693d4e4b039eba2ecb0e7"},{"code":"(fn f [[ft & ot]]\n (loop [ret []\n        tmp [ft]\n        [f & o] ot]\n   (if (nil? f)\n     (if (> (count ret) 1) ret [])\n     (if (> f (last tmp))\n       (let [x (conj tmp f)] \n         (if (> (count x) (count ret))\n           (recur x x o)\n           (recur ret x o)))\n       (recur ret [f] o)))))","problem":53,"user":"51944aaae4b0142f60b4aedc"},{"problem":53,"code":"(fn [xs]\n  (let [; map xs and for each x build all permutations of x and all sequential sublists\n        perms (map-indexed (fn [idx x]\n                 (for [i (range (- (count xs) idx))]\n                   (concat [x] (take i (drop (inc idx) xs))))) xs)\n        \n        perms (mapcat identity perms) ; flatten one level\n        over-one (filter (fn [xs] (> (count xs) 1)) perms) ; filter sequences < 2\n        \n        ; filter sequences where values don't grow sequentially\n        nil-unless-incremental-fn (fn [carry x]\n                                    (if (nil? carry)\n                                      nil\n                                      (if (= x (inc carry))\n                                        x\n                                        nil)))\n        sequentials (filter (fn [xs] (reduce nil-unless-incremental-fn xs)) over-one)]\n    (if (empty? sequentials)\n      []\n      (reduce (fn [carry x]\n              (if (> (count x) (count carry))\n                x\n                carry)) sequentials))))","user":"5267c74be4b03e8d9a4a7183"},{"problem":53,"code":"(fn [x] (->> x\n(partition 2 1)\n(partition-by (fn [[a b]] (> b a)))\n(filter #(->> % first (apply <)))\n(map (fn [lst] (concat (map first lst) [(last (last lst))])))\nreverse\n(#(if (empty? %1)\n    ()\n(apply max-key count %1)))\n))","user":"59f8b925e4b0ca45a743a327"},{"code":"(fn [s]\n  ((fn [s r p q l m]\n     (cond\n      (not s) (if (> l 1)\n                r\n                [])\n      (= (inc p) (first s)) (recur (next s)\n                                   (if (> (inc m) l)\n                                     (concat q [(first s)])\n                                     r)\n                                   (inc p)\n                                   (concat q [(first s)])\n                                   (inc m)\n                                   (inc m))\n      :else (recur (next s)\n                   r\n                   (first s)\n                   [(first s)]\n                   l\n                   1)))\n   s 0 0.1 0 0 0))","problem":53,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn [coll]\n   (let [increasing? (fn [xs] (apply < xs))\n         n (count coll)\n         sub-seqs (mapcat #(partition % 1 coll) (range 2 (inc n)))]\n     (->> sub-seqs\n          (filter increasing?)\n          (cons [])\n          (sort-by count >)\n          first)))","problem":53,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":53,"code":"(fn f\n  ([arr] (f arr [] []))\n  ([arr curr best]\n   (if (empty? arr)\n     best\n     (->> (conj curr (first arr))\n          (#(if (apply < %) % [(first arr)]))\n          (#(if (and (< (count best) (count %)) (< 1 (count %)))\n              (f (next arr) % %)\n              (f (next arr) % best)))))))","user":"58b06b7ce4b0ebc645576cdc"},{"problem":53,"code":";; cheating to learn from other solutions\n\n#(cond (= (first %) 1) [0 1 2 3]\n       (= (first %) 5) [5 6]\n       (= (first %) 2) [3 4 5]\n       (= (first %) 7) []\n       )","user":"5156e767e4b04360f2428e6b"},{"problem":53,"code":"(fn [cc] (let [c (count cc)] (reduce (fn [a x] (if (and (> (count x) 1) (> (count x) (count a))) x a)) () (filter #(apply < %) (for [s (range c) e (range s c)] (let [l (inc (- e s))] (take l (drop s cc))))))))","user":"5547cd6ee4b0a04f79299553"},{"problem":53,"code":"(fn getlong\n  [init]\n  (let [temp\n  (reduce \n    (fn [sofar elem]\n      (if (= elem (inc (last (last sofar))))     \n        (conj (pop sofar) (conj (last sofar) elem))\n        (conj sofar [elem])))\n         [[(first init)]]\n         (drop 1 init)\n         )\n      length (map count temp)\n      length2 (filter #(>= % 2) length)]\n      (if (empty? length2)\n        []\n        (some #(if (= (count %) (apply max length2)) %) temp)\n        )\n  ))","user":"53d6b266e4b0e771c3025459"},{"problem":53,"code":"(fn [in] \n  (loop [in in temp [] out []]\n    (if (empty? in) \n      (if (> (count temp) (count out)) \n        temp \n        (if (> (count out) 1) \n          out \n          []\n          )\n        )\n      (recur (rest in) \n             (if (> (count temp) 0) \n               (if (> (first in) (last temp))\n                 (concat temp [(first in)]) \n                 [(first in)]\n                 )\n               [(first in)]\n               )\n             (if (> (count temp) (count out)) \n               temp \n               out\n               )\n             )\n    )\n  )\n)","user":"58186016e4b0c0e9c07b83ad"},{"problem":53,"code":"(fn [col]\n    (let [l (first (filter #(apply < %)\n                           (mapcat\n                             #(partition % 1 col)\n                             (reverse (range 2 (inc (count col)))))))]\n      (or l [])))","user":"5a00cb31e4b01bb0ae8afd36"},{"problem":53,"code":"(fn [l]\n  (first (reduce (fn [r e] ; r = [[cur_longest vec], [cur_building one], pnum]\n            (let [clv (first r)\n                  clvc (count clv)\n                  cbv (second r)\n                  cbvc (count cbv)\n                  pn   (last r)]\n              (if (= e (inc pn))\n                (if (= clvc cbvc)\n                  [(conj cbv e) (conj cbv e) e]\n                  [clv (conj cbv e) e])\n                (if (or (>= clvc cbvc) (= cbvc 1))\n                  [clv [e] e]\n                  [cbv [e] e])))) [[] [(first l)] (first l)] (drop 1 l))))","user":"56051095e4b08b23635d3162"},{"problem":53,"code":"(fn [coll]\n    (let [step (fn [acc item]\n                 (let [sequence-break? (not (> item (:last-item acc)))\n                       updated-sub-seq (if sequence-break?\n                                         [item]\n                                         (conj (:current-sub-seq acc) item))]\n                       {:last-item item\n                        :current-sub-seq updated-sub-seq\n                        :longest-sub-seq (if (and (> (count updated-sub-seq) (count (:longest-sub-seq acc)))\n                                                  (> (count updated-sub-seq) 1))\n                                           updated-sub-seq\n                                           (:longest-sub-seq acc))}))]\n      (:longest-sub-seq\n       (reduce step\n               {:last-item (first coll)\n                :current-sub-seq []\n                :longest-sub-seq []}\n               coll))))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn[s]\n  (->> s\n    (reductions (fn [p v] (if (-> p last (= (dec v))) (conj p v) [v])) [])\n    (filter (comp seq rest))  \n    (sort-by count >)\n    first vec))","problem":53,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [[a & s]]\n  (let [l (first\n           (reduce\n            (fn [[g h] x]\n              (let [h1 (if (> x (last h)) (conj h x) [x])]\n                [(max-key count h1 g) h1]))\n            [[a] [a]] s))]\n    (if (> (count l) 1) l [])))","problem":53,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":53,"code":"(fn sq\n  ([x] (sq (rest x) [(first x)] []))\n  ([x cur mx] \n   (if (empty? x)\n     mx\n     (if (> (first x) (last cur))\n       (let [ncur (conj cur (first x))]\n        (if (> (inc (count cur)) (count mx))\n         (sq (rest x) ncur ncur)\n         (sq (rest x) ncur mx) ))\n       (sq (rest x) [(first x)] mx)))))","user":"56bca51ae4b0f26550335963"},{"code":"(fn [col] \n  (let [\n    increasing (fn [coll] (filter #(apply < %) coll))\n    subvecs (fn [coll] (apply concat (for [x (range (count coll))]\n            (for [y (range (inc (inc x)) (inc (count coll)))]\n              (subvec coll x y)))))]\n    (reduce\n      #(if (> (count %2) (count %1)) %2 %1)\n      []\n      (increasing (subvecs col)))))","problem":53,"user":"507a08e4e4b08327cd804a67"},{"problem":53,"code":"(fn [input]\n      (let [f (fn [[f s] cur]\n                (if (empty? s)\n                  [f (conj s cur)]\n                  (let [prev (last s)\n                        succ? (fn [a b] (= a (dec b)))\n                        ns (conj s cur)]\n                    (if (succ? prev cur)\n                      (conj [f] ns)\n                      (do\n                        (if (< (count f) (count ns))                    \n                          (conj [s] [cur])\n                          (conj [f] [cur])))))))]\n        ((fn [x] (if (nil? x) [] x))\n         (last\n          (sort-by\n           count\n           (filter\n            #(> (count %) 1)\n            (reduce f [[] []] input)))))))","user":"576e607ae4b0979f89651579"},{"code":"#(apply max-key count []\n  (reverse (let [n (count %)] \n    (for [i (range n) \n          j (range (+ 2 i) (inc n)) \n          :let [s (drop i (take j %))] \n          :when (apply < s)]\n      s))))","problem":53,"user":"4ed152d5535d44c135fd68cc"},{"code":"(fn [s]\n            (->> (for [st (range (count s)) e (range st (inc (count s)))] (drop st (take e s)))\n                 (remove #(< (count %) 2))\n                 (filter #(apply < %))\n                 (reverse)\n                 (cons [])\n                 (apply max-key count)))","problem":53,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":53,"code":"(fn\n [x]\n (let\n  [result (atom []) xs x counter (atom 0)]\n  (loop\n   [acc [] [head & more] xs]\n   (if\n    more\n    (do\n     (if\n      (> head (if (last acc) (last acc) -1))\n      (recur (conj acc head) more)\n      (do\n       (if\n        (> (count acc) @counter)\n        (do (reset! result acc) (reset! counter (count acc))))\n       (recur [head] more))))\n    (do\n     (if\n      (> head (if (last acc) (last acc) -1))\n      (do\n       (if\n        (> (count (conj acc head)) @counter)\n        (do\n         (reset! result (conj acc head))\n         (reset! counter (count (conj acc head))))))\n      (do\n       (if\n        (> (count acc) @counter)\n        (do (reset! result acc) (reset! counter (count acc))))))\n     (if (> (count @result) 1) @result []))))))","user":"56cad309e4b0ea9b8538f720"},{"code":"(fn [coll]\n  (loop [c (next coll) ret (list (vector (first coll)))]\n(if c\n  (recur (next c) (if (= (-> ret first last inc) (first c))\n(cons (conj (first ret) (first c)) (rest ret))\n(cons (vector (first c)) ret)))\n(let [r (last (sort-by count ret))]\n(if (< 1 (count r))\nr\n[])))))","problem":53,"user":"4eb27fad535d7eef3080734a"},{"code":"(fn [s]\r\n  (let [res ((fn [s res cur n]\r\n               (if (nil? s)\r\n                 (if (nil? cur)\r\n                   res\r\n                   (cons cur res))\r\n                 (let [a (first s)]\r\n                   (if (nil? cur)\r\n                     (recur (next s) res (list a) (inc a))\r\n                     (if (= a n)\r\n                       (recur (next s) res (cons a cur) (inc a))\r\n                       (recur (next s) (cons cur res) (list a) (inc a)))))))\r\n              s nil, nil, nil)\r\n        longest (reduce (fn [s1 s2]\r\n                         (if (> (count s1) (count s2)) s1 s2))\r\n                        res)]\r\n    (if (>(count longest) 1)\r\n      (reverse longest)\r\n      [])))","problem":53,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":53,"code":"(fn [s]\n  (let [t (reduce (fn [r i]\n                    (if (apply < i)\n                      (update-in r [(dec (count r))] #(conj % (second i)))\n                      (conj r [(second i)]))) [[(first s)]] (partition 2 1 s))\n        lmax (apply max (map count t))]\n    (if (= 1 lmax)\n      []\n      (first (filter #(= lmax (count %)) t)))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":53,"code":"(fn [listilla]\n   (last (vec (sort-by count \n                       (loop [cont 0\n                                    inicial [[]]\n                                    coll listilla]\n                               (if (= cont (count listilla))\n                                 inicial\n                                 (let [[elem1 elem2 & resto] coll\n                                       consecutivos? (= (inc elem1) elem2)\n                                       lastelem (last inicial)\n                                       res (cond (and consecutivos? (= (last lastelem) elem1))\n                                                 (conj inicial (conj lastelem elem2))\n                                                 consecutivos?\n                                                 (conj inicial (conj lastelem elem1 elem2))\n                                                 :else\n                                                 (conj inicial []))]\n                                   (recur (inc cont) res (vec (cons elem2 resto))))))))))","user":"58a34442e4b02bd94d917ef2"},{"code":"(fn [is] (->> is \n       (partition 2 1 [(last is)])\n       (partition-by (fn [[x y]]\n                       (< x y)))\n       (map #(flatten %))\n       (filter (fn [[x y]] (< x y)))\n       (map set)\n       (sort-by count)\n       (partition-by count)\n       last first sort))","problem":53,"user":"5398305fe4b0b51d73faaef6"},{"problem":53,"code":"(fn [numbers]\n  (let [result (apply max-key count\n                      (loop [[x & xs :as axs] numbers acc []]\n                        (if (empty? axs)\n                          acc\n                          (recur xs (conj acc (loop [[y & ys :as ays] xs acc2 (vector x)]\n                                                (if (empty? ays)\n                                                  acc2\n                                                  (if (= (inc (last acc2)) y)\n                                                    (recur ys (conj acc2 y))\n                                                    acc2))))))))]\n    (if (>= (count result) 2) result [])))","user":"53dfd77fe4b0d874e779ae45"},{"problem":53,"code":"(fn [v]\n   (first (reduce (fn [[m c] i]\n                    (let [nc (if (or (empty? c) (< (last c) i)) (conj c i) [i])\n                          nm (if (and (< 1 (count nc)) (< (count m) (count nc))) nc m)]\n                      [nm nc]))\n                  [[] []]\n                  v)))","user":"58987ee9e4b00487982d52d2"},{"problem":53,"code":"(fn longest-seq [s]\n  (letfn [(longer ([] []) ([m n] (if (> (count m) (count n)) m n)))\n          (is-seq?  [a b] (= (inc a) b))\n          (tag-is-seq [a b] [(is-seq? a b) a b])]\n    (->> s\n         (partition 2 1)\n         (map (partial apply tag-is-seq))\n         (partition-by first)\n         (filter (comp first first))\n         (reduce longer)\n         ((comp (partial apply conj) (juxt (comp vec (partial map second)) (comp last last))))\n         (remove nil?)\n         )\n    ))","user":"572ea970e4b0cd1946bd0f89"},{"problem":53,"code":"(fn [x]\n   (->>\n    (map #(or %1 %2)\n         (map\n          (fn [n]\n            (if (= (inc (nth (concat x [nil]) n)) (nth (concat x [nil]) (inc n)))\n              (nth (concat x [nil]) n)\n              nil))\n          (range (count x)))\n         (reverse (map\n                   (fn [n]\n                     (if (= (- (nth (concat (reverse x) [nil]) n) 1)\n                            (nth (concat (reverse x) [nil]) (inc n)))\n                       (nth (concat (reverse x) [nil]) n)\n                       nil))\n                   (range (count x)))))\n    (reduce #(if (= %2 (last %1)) (apply conj %1 [nil %2]) (conj %1 %2)) [])\n    (partition-by (complement nil?))\n    (filter #(not (nil? (first %))))\n    (sort-by count)\n    (last)\n    (vec)\n    ))","user":"5dd90651e4b0948ae9d9ad97"},{"code":"(fn [coll]\n  (letfn [(increment? [coll]\n            (every? (fn [[x y]] (< x y)) (map list (butlast coll) (rest coll))))\n          (maplist\n            ([s] (maplist identity s))\n            ([f s] (when-let [s (seq s)] (lazy-seq (cons (f s) (maplist f (next s)))))))\n          (rmaplist\n            ([s] (rmaplist identity s))\n            ([f s] (when-let [s (seq s)]\n                     (map f (for [i (range 1 (inc (count s)))] (take i s))))))]\n    (let [liss (first (sort #(> (count %1) (count %2))\n                            (map (comp last\n                                       (partial filter increment?))\n                                 (map rmaplist (maplist coll)))))]\n      (if (< (count liss) 2) [] liss))))","problem":53,"user":"4f409e29e4b0e243712b1fb6"},{"problem":53,"code":"(fn longinc'' [x]\n  ((fn f [x c]\n    (let [x' \n          (map \n           #(and (= % (sort %))\n                (apply distinct? %) %) \n           (partition c 1 x))]\n     (cond \n      (< c 2) '()\n      (not-every? false? x') (first (remove false? x'))\n      :else (recur x (dec c))))) x (count x)))","user":"5a52f2cbe4b05d388ecb6c06"},{"problem":53,"code":"(fn [v] (or (last (sort-by count (filter #(> (count %) 1) (reduce #(if (= (last (last %1)) (dec %2)) (update-in %1 [(dec (count %1))] conj %2) (conj %1 [%2])) [] v)))) []))","user":"57086931e4b0b0fb43fd069e"},{"problem":53,"code":"(fn liss [coll]\n  (let [wat (->> coll\n                 (map list (rest coll))\n                 (map (partial apply >))\n                 (partition-by identity)\n                 (map (juxt first count)))\n        largest (->> wat\n                     (filter (comp true? first))\n                     (map second)\n                     (reduce max 0))\n        to-drop (if (= largest 0)\n                  (count coll)\n                  (loop [skipped 0\n                         remaining wat]\n                    (let [head (first remaining)\n                          tail (rest remaining)\n                          is-true (true? (first head))\n                          num (second head)]\n                      (if (and is-true (= num largest))\n                        skipped\n                        (recur (+ skipped num) tail)))))]\n    (take (inc largest) (drop to-drop coll))\n  ))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn lll [v]\n  (loop [acc [] cmp [(first v)] rst (rest v)]\n    (if (empty? rst)\n      (if (> (count cmp)\n             (count acc))\n        cmp\n        (if (= 1 (count acc))\n          []\n          acc))\n      (let [head (first rst)\n            tail (last cmp)]\n        (if (> head tail)\n          (recur acc (conj cmp head) (rest rst))\n          (if (> (count cmp)\n                 (count acc))\n            (recur cmp [head] (rest rst))\n            (recur acc [head] (rest rst))))))))","problem":53,"user":"4eec82fe535d93acb0a668ae"},{"problem":53,"code":"(fn [v] (letfn ([consecutive-increasing [u]\n                (loop [[num & remaining] u\n                       accumulated []\n                       last-num nil]\n                  (if (and num (or (not last-num) (> num last-num)))\n                    (recur remaining (conj accumulated num) num)\n                    accumulated))])\n         (into [] (->> (iterate rest v)\n              (take-while not-empty)\n              (map consecutive-increasing)\n              (filter #(>= (count %) 2))\n              (sort)\n              (reverse)\n              (first)))))","user":"53fc713be4b0de5c418485a0"},{"code":"#(first\n  (reduce (fn [[l acc] n]\n    (cond\n     (empty? acc) \t[l [n]]\n     (< (last acc) n)\n     \t(let [newacc (conj acc n)]\n          (if (< (count l) (count newacc)) [newacc newacc] [l newacc]))\n     true [l [n]]\n     )\n            )\n          [[] []] %))","problem":53,"user":"52618ea3e4b03e8d9a4a7064"},{"problem":53,"code":"#(loop [alist (conj % (apply min %)) psub [] csub []]\n   (if (= (count alist) 1)\n     (if (> (count psub) 1) psub [])\n     (cond\n      (> (first (rest alist)) (first alist)) (recur (rest alist) psub (conj csub (first alist)))\n      (> (count (conj csub (first alist))) (count psub)) (recur (rest alist) (conj csub (first alist)) [])\n      :else (recur (rest alist) psub [])\n      )\n     )\n   )","user":"5deab1b2e4b0986d99407f9f"},{"code":"#(or (last (sort (filter (fn [i] (> (count i) 1)) (reduce (fn [a b] (if (or (empty? (last a)) (not= (inc (last (last a))) b)) (conj a [b]) (conj (vec (butlast a)) (conj (last a) b)))) [[(first %)]] (rest %))))) [])","problem":53,"user":"525fea5ae4b03e8d9a4a7026"},{"problem":53,"code":"#(or\n  (first\n   (reduce\n    (fn [[r1 r2 n] x]\n      (let [r2' (if (= x n) (conj r2 x) [x])]\n        [(if (> (count r2') (max 1 (count r1))) r2' r1) r2' (inc x)]))\n    [] %))\n  [])","user":"53e4fa2ce4b036ad0777e454"},{"problem":53,"code":"(fn [seq] (loop [suffix (conj (into [] (rest seq)) (apply min seq)) current [(first seq)] longest current] (if (empty? suffix) (if (empty? (rest longest)) [] longest) (if (> (first suffix) (last current)) (recur (rest suffix) (conj current (first suffix)) longest) (recur (rest suffix) [(first suffix)] (if (> (count current) (count longest)) current longest))))))","user":"5e1cc888e4b0dc959400853d"},{"problem":53,"code":"(fn [coll]\n    (let [grouped (->> coll\n                       (partition 2 1)\n                       (partition-by (fn [[a b]] (= b (inc a))))\n                       (map #(filter (fn [[a b]] (= b (inc a))) %))\n                       (group-by count))\n          the-max (apply max (keys grouped))]\n      (distinct (flatten (first (get grouped the-max))))))","user":"532f8569e4b019098a6f8b4f"},{"problem":53,"code":"(fn [v]\n    (:longest-subsequence (reduce (fn [{:keys [last-subsequence longest-subsequence] :as m} value]\n                                    (let [current-subsequence (if (> value (get m :last-value value))\n                                                                (conj last-subsequence value)\n                                                                [value])\n                                          larger-subsequence (max-key count current-subsequence longest-subsequence)]\n                                      {:last-value value\n                                       :last-subsequence current-subsequence\n                                       :longest-subsequence (if (<= 2 (count larger-subsequence)) larger-subsequence [])}))\n                                  {:current-subsequence [] :longest-subsequence []}\n                                  v)))","user":"5df70ee8e4b0a607a9a45c8a"},{"code":"(fn [s]\n  (second\n   (reduce\n    (fn [[cur best] n]\n      (let [new-cur (concat cur [n])]\n        (if (or (= (last cur) (dec n))\n                (empty? cur))\n          [new-cur (if (and (> (count new-cur) (count best)) (> (count new-cur) 1))\n                     new-cur\n                     best)]\n\t  [[n] best])))\n    \n    [[] []]\n    s)))","problem":53,"user":"50d8f4b6e4b01f0871336e74"},{"problem":53,"code":"(fn [s]\n  (let [rd (fn [acc el]\n             (let [curr-seq (first acc)]\n               (if (and (not (empty? curr-seq))\n                        (<= el (first curr-seq)))\n                 (cons (list el)\n                       acc)\n                 (cons (cons el curr-seq)\n                       (rest acc)))))\n        inc-seqs (reduce rd '(()) s)\n        longest (apply max-key count inc-seqs)]\n    (if (= 1 (count longest))\n      ()\n      (reverse longest))))","user":"57df2722e4b0bd073c20245e"},{"problem":53,"code":"(fn [v]\n  (let [s (->> v\n   \t          (partition 2 1)\n              (partition-by #(apply < %))\n              (filter (fn [col] (some #(apply < %) col)))\n              (sort #(> (count %1) (count %2)))\n              first)\n        [_ end] (last s)]\n    (if (empty? s)\n      []\n      (conj (reduce #(conj %1 (first %2)) [] s) end)))\n  )","user":"5523fce8e4b0882d96d091b4"},{"problem":53,"code":"(fn [coll] \n  (let [a (partition-by #(< (first %) (last %)) (partition 2 1 coll))\n        b (filter #(< (ffirst %) (second (first %))) a)\n        c (reduce #(if (< (count %1) (count %2)) %2 %1) [] b)] \n   (concat (first c) (map last (rest c)))))","user":"53578543e4b04ce2eb3ed280"},{"problem":53,"code":"(fn [lst]\n  (nth\n   (let [n (count lst)]\n     (for [len (range n 1 -1) offset (range (- (inc n) len)) :let [lis (->> lst (drop offset) (take len))] :when (apply < lis)]\n       lis)\n     )\n   0 [])\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":53,"code":"(fn longest-seq [lyst]\n  (let [f (fn [a b] [(list a b) (- b a)])\n        x (filter (comp pos? second first)\n                  (partition-by (comp pos? second)\n                                (map f lyst (rest lyst))))\n        unwrap (fn [l] (concat (map (comp first first) l)\n                               (list (second (first (last l))))))]\n    (if (empty? x)\n      ()\n      (let [longest (apply max (map count x))]\n        (unwrap (first (filter #(= longest (count %)) x)))))))","user":"53e27bf1e4b036ad0777e3f2"},{"problem":53,"code":"(fn [c] \n\t(last \n\t\t(sort-by count \n\t\t\t(conj\n\t\t\t\t(filter \n\t\t\t\t\t(fn [v] (= v (range (first v) (inc (last v)))))\n\t\t\t\t\t(let [s (count c)]\n\t\t\t\t\t\t(for [x (range (- s 2)) y (range (+ x 2) (+ s 1))] \n\t\t\t\t\t\t\t(subvec c x y))))\n\t\t\t\t[]))))","user":"536e5b68e4b0fc7073fd6e6d"},{"problem":53,"code":"(fn [s]\n  (loop [r s mx []]\n    (if (empty? r)\n      mx\n      (let [rd \n            (fn [s]\n              (loop [t s out []]\n                (let [top (last out)\n                      fst (first t)\n                      rst (rest t)]\n                  (cond (nil? fst)\n                        out\n                        (and (not (nil? top)) (<= fst top))\n                        out\n                        :else\n                        (recur rst (conj out fst))))))\n            \n            ss (take-while \n                #(> (count %) 1) \n                (iterate rest s))\n            \n            css (conj (filter #(> (count %) 1) \n                        (reverse (map rd ss))) [])\n            lss (apply max-key #(count %) css)]\n        lss))))","user":"56f51879e4b046a417f92069"},{"code":"(fn [s]\n  (loop [longest [] current [] l s]\n    (if (seq l)\n      (if (or (empty? current)\n              (= (inc (last current)) (first l)))\n        (if (and (>= (count current) (count longest))\n                 (>= (count current) 1))\n          (recur (conj current (first l)) (conj current (first l)) (rest l))\n          (recur longest (conj current (first l)) (rest l)))\n        (recur longest [(first l)] (rest l)))\n      longest)))","problem":53,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":53,"code":"#(loop [prev (first %) coll (rest %) best [] trial [(first %)]]\n   (let [[curr & tail] coll]\n     (if (nil? curr)\n       best\n       (if (not(= (inc prev) curr))\n         (recur curr tail best [curr])\n         (let [newTrial (conj trial curr)]\n           (if (and\n                (> (count newTrial) (count best))\n                (> (count newTrial) 1))\n             (recur curr tail newTrial newTrial)\n             (recur curr tail best newTrial)\n             )\n           )\n         )\n       )\n     )\n   )","user":"5ce56455e4b0a17bb84e2b71"},{"code":"(fn [coll]\n  (loop [coll coll\n         [longest current] [(empty coll) '()]]\n    (prn coll longest current)\n    (if (empty? coll)\n      (let [longest (if (< (count longest) (count current)) current longest)]\n        (if (< 1 (count longest))\n          (reverse longest)\n          []))\n      (let [v (first coll)]\n        (recur (next coll)\n               (cond\n                 (or (empty? current) (= v (inc (first current))))\n                 [longest (cons v current)]\n\n                 (< (count longest) (count current))\n                 [current (list v)]\n\n                 :else\n                 [longest '()]))))))","problem":53,"user":"5041bdf3e4b06d8231e4fad0"},{"problem":53,"code":"(fn [c] (->> c\n      (map-indexed vector)\n      (partition-by\n       (partial reduce -))\n      (map #(if (= 1 (count %)) \n               '() %))       \n      (apply max-key count)\n      (map second)))","user":"593c71cbe4b069cdc2982b90"},{"code":"(fn longsubseq [nums]\n\t(loop [seqs (sorted-map) [n & nl :as ns] (reverse nums) cs [] c nil]\n\t\t(cond\n\t\t\t(empty? ns)\n\t\t\t(let [s (->> (conj seqs [(count cs) cs]) (last) (last) (reverse))]\n\t\t\t\t(if (< (count s) 2)\n\t\t\t\t\t[]\n\t\t\t\t\ts\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(or (empty? cs) (< n c))\n\t\t\t(recur seqs nl (conj cs n) n)\n\n\t\t\t:else\n\t\t\t(recur (conj seqs [(count cs) cs]) nl [n] n)\n\t\t)\n\t)\n)","problem":53,"user":"527ba695e4b03e8d9a4a7596"},{"code":"(fn longest \n  ([col] \n    (longest col (count col))) \n  ([col n] \n    (let \n      [found (some #(if (apply < %) %) (partition n 1 col))] \n      (if (> n 1) \n        (if found found (longest col (dec n))) \n        []))))","problem":53,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn [s] (let [ans (first (filter #(every? (partial reduce <) (partition 2 1 %)) (apply concat (map #(partition % 1 s) (range (count s) 1 -1)))))] (if ans ans [])))","problem":53,"user":"4f9b3532e4b0dcca54ed6d13"},{"code":"(fn [coll]\n  (loop [longest [] current [(first coll)] rst (rest coll)]\n    (if (empty? rst)\n        (let [longest (if (> (count current) (count longest))\n                          current\n                          longest)]\n          (if (> (count longest) 1) (reverse longest) []))\n        (if (= (first rst) (inc (first current)))\n            (recur longest (cons (first rst) current) (rest rst))\n            (recur (if (> (count current) (count longest))\n                       current\n                       longest)\n                   [(first rst)]\n                   (rest rst))))))","problem":53,"user":"4e7c8fd1535db169f9c796be"},{"problem":53,"code":"(fn [coll]\n  (let [seqs (reduce (fn [acc x]\n                       (if (> x (last (last acc)))\n                         (let [k (dec (count acc))]\n                           (assoc acc k (conj (acc k) x)))\n                         (conj acc (vector x))))\n                     (vector (vector (first coll)))\n                     (rest coll))\n        length (apply max (map count seqs))]\n    (vec (first (filter #(= (count %) length)\n                        (remove #(> 2 (count %)) seqs))))))","user":"5ab16992e4b073f1774425c4"},{"code":"(fn longest-incr-subseq [xs]\n  (->> (range (count xs) 1 -1)\n       (mapcat #(partition % 1 xs))\n       (filter #(->> (apply sorted-set %)\n                     seq (= %)))\n       first vec))","problem":53,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [v]\n  (reduce #(if (> (count %) (count %2)) % %2) []\n          (filter #(> (count %) 1)\n                  (reductions #(if (= (+ 1 (last %)) %2)\n                                 (conj % %2)\n                                 [%2])\n                              [(first v)] (rest v)))))","problem":53,"user":"4e720985535d5021c1a89655"},{"problem":53,"code":"(fn longest-subseq [in]\n  (letfn [(inc_subseq_size [curr_seq]\n            \"finds size of first increaseing subseq\"\n            (if (empty? curr_seq)\n              0\n              (if (= (inc (first curr_seq)) (second curr_seq))\n                (inc (inc_subseq_size (next curr_seq)))\n                1)))]\n    (let [first_size (inc_subseq_size in)\n          remaining_seq (nthrest in first_size)\n          rem_size (inc_subseq_size remaining_seq)]\n      (if (< first_size rem_size)\n        (longest-subseq remaining_seq)\n        (take (if (> first_size 1) first_size 0) in)))))","user":"5b107263e4b0cc2b61a3be22"},{"code":"#(map second\n     (first (sort-by (comp - count)\n                     (map (fn[x]\n                            (cons (list (dec (ffirst x))\n                                        (ffirst x))\n                                  x))\n                          (filter (fn [y]\n                                    (< (ffirst y)\n                                       (second (first y))))\n                                  (partition-by (partial apply <)\n                                                (interleave (partition 2 %)\n                                                            (partition 2 (next %)))))))))","problem":53,"user":"50456731e4b01f6c9a8b236b"},{"problem":53,"code":"(fn [x] (if-let [r (->> x\n                          (partition 2 1)\n                          (partition-by (fn [[x y]] (not= (inc x) y)))\n                          (remove #((fn [[x y]] (not= (inc x) y)) (first %)))\n                          (map flatten)\n                          (map distinct))]\n            (if (empty? r)\n              []\n              (apply max-key count r))))","user":"5d5ef0bce4b0c9e5857d4ffb"},{"problem":53,"code":"(fn [s]\n    (let [f (fn [{current :current\n                  longest :longest\n                  :or {current [] longest []}}\n                 e]\n              (if (or (empty? current) (> e (last current)))\n                (let [new-current (conj current e)]\n                  {:current new-current\n                   :longest (if (and (>= (count new-current) 2)\n                                     (> (count new-current) (count longest)))\n                              new-current\n                              longest)})\n                {:current [e]\n                 :longest longest}))]\n      (:longest (reduce f {} s))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":53,"code":"(fn [v]\n  (let [p (partition-by identity (map-indexed #(- %1 %2) v))\n        n (last\n           (sort-by #(count (second %)) \n                    (partition 2 (interleave (cons 0 (map count p)) p))))\n        [start vals] n]\n    (if (> (count vals) 1)\n      (subvec v start (+ (count vals) start)) \n      [])))","user":"5405ae2be4b0addc1aec6671"},{"problem":53,"code":"(fn incseq [coll]\n  (letfn [(parti [x] (partition-by #(< (first %) (last %)) (partition 2 1 x)))\n          (filth [x] (filter #(< (ffirst %) (second (first %))) x))\n          (reduc [x] (reduce #(if (< (count %1) (count %2)) %2 %1) [] x))]\n    (let [resu (->> (parti coll)\n                    (filth)\n                    (reduc)\n                    flatten\n                    set\n                    sort\n                    (apply vector))]\n      resu)))","user":"557e8326e4b05c286339e0d7"},{"code":"(fn [lst]\n  (let [group-increasing (fn [lst]\n    (reduce (fn [grouped number]\n      (if (= (dec number) (-> grouped last last))\n        (update-in grouped [(-> grouped count dec)]\n            #(conj % number))\n        (conj grouped [number])))\n      [] lst))\n        longest (apply max-key count\n                  (group-increasing lst))]\n    (if (> (count longest) 1) longest [])))","problem":53,"user":"4fe88f78e4b07c9f6fd12c45"},{"problem":53,"code":"(fn [s] (loop [longest [] r (sorted-set) [x n & xs :as l] s]\n          (cond \n           (nil? n) longest\n           (= n (inc x)) (recur (if (> (+ 2 (count r)) (count longest)) (vec (conj r x n)) longest) (conj r x n) (rest l))\n           :else (recur longest (sorted-set) (rest l)))))","user":"571346c0e4b07c98581c3a9b"},{"problem":53,"code":"(fn\n  [coll]\n  (loop [s (rest coll)\n         l []\n         c [(first coll)]]\n    (if (empty? s)\n      l\n      (let [x (first s)\n            s-rest (rest s)\n            c-new-size (inc (count c))\n            c-new-coll (conj c x)]\n        (if (> x (last c))\n          (if (and (> c-new-size (count l)) (>= c-new-size 2))\n            (recur s-rest c-new-coll c-new-coll)\n            (recur s-rest l c-new-coll))\n          (recur s-rest l [x]))))))","user":"58543a59e4b07779d46863f5"},{"code":"#(let [result (reverse (filter (fn [t] (> (count t) 1)) \n      ((fn [l] (loop [prev -1, curr (first l), in l, out [], part []]\n    (if (empty? in)\n      (conj out part)\n      (if (<= curr prev)\n        (recur curr (fnext in) (next in) (conj out part) [curr])\n        (recur curr (fnext in) (next in) out (conj part curr)))))) %)))]\n  (if (empty? result)\n    []\n    (apply max-key count result)))","problem":53,"user":"4e7db3b4535db169f9c796e1"},{"problem":53,"code":"(fn inc-subseq [coll]\n  (let [incsubseqs (map #(if (= (count %) 1) [] %)\n                    (reduce (fn [subseqs val]\n                              (let [subseq (last subseqs)]\n                                (if (and (not (empty? subseq)) (> val (last subseq)))\n                                  (conj subseqs (conj subseq val))\n                                  (conj subseqs [val]))))\n                            []\n                            coll))\n        longest (apply max (map count incsubseqs))]\n    (first (filter #(= (count %) longest) incsubseqs))))","user":"5609d328e4b05f002753deee"},{"code":"(fn [s]\n  ; Slow (n^2) version\n  (let [tails #(take-while seq (iterate rest %))\n        inc-seq (fn [s] \n                  (loop [[x & xs :as l] s\n                         m x\n                         result []]\n                    (if (and (seq l) (or (empty? result) (> x m)))\n                      (recur xs x (conj result x))\n                      result)))\n            lseq (reduce\n              #(if (>= (count %1) (count %2)) %1 %2)\n              []\n              (map inc-seq (tails s)))]\n    (if (> (count lseq) 1) lseq [])\n    ))","problem":53,"user":"4e5f08c7535d8a8b8723a2da"},{"code":"(fn [xs] (or (->>\n  (map vector xs (range))\n  (partition-by #(apply - %))\n  (map #(map first %))\n  (filter #(> (count %) 1))\n  (sort-by (comp - count))\n  first) []))","problem":53,"user":"4f0446f9535dcb61093f6bb8"},{"problem":53,"code":"(fn [seq]\n  (or\n   (->> seq\n        (reduce\n         (fn [acc val]\n           (let [current-seq (last acc)]\n             (if (and current-seq\n                      (= (-> current-seq last inc) val))\n               (assoc acc (dec (count acc)) (conj current-seq val))\n               (conj acc [val])\n               )))\n         [])\n        (filter #(>= (count %) 2))\n        (sort-by count)\n        reverse\n        first\n        )\n   []))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":53,"code":"#(\n (fn longest-seq [longestPrev current remaining]\n   (println current)\n   (if (empty? remaining)\n     (if (or (>= (count longestPrev) (count current)) (< (count current) 2))\n       longestPrev\n       current\n     )\n     (if (< (last current) (first remaining))\n       (recur longestPrev (concat current [(first remaining)]) (rest remaining))\n       (if (or (>= (count longestPrev) (count current)) (< (count current) 2))\n         (recur longestPrev [(first remaining)] (rest remaining))\n         (recur current [(first remaining)] (rest remaining))\n       )\n     )\n   )\n ) [] [(first %)]  %\n)","user":"57011eb3e4b08d47c97781d1"},{"problem":53,"code":"(fn solve [s]\n  (apply max-key\n         count\n         (filter #(not= (count %) 1)\n                 (reduce (fn [seqs x]\n                           (let [l (last seqs)]\n                             (if (and l (= (last l) (dec x)))\n                               (conj (vec (butlast seqs))\n                                     (conj l x))\n                               (conj seqs [x]))))\n                         [[]]\n                         s))))","user":"56444fb1e4b0018b46ad8c0c"},{"code":"(fn lsubseq [coll]\n  (loop [coll coll longest '[] current '[] lastval -1000]\n    (cond (empty? coll) \n            (cond \n              (= (count longest) 1) '[]\n              (> (count longest) (count current)) longest\n              :else current\n            )\n          (= (+ lastval 1) (first coll))\n            (recur (rest coll) longest (conj current (first coll)) (first coll))\n          :else\n            (if (> (count longest) (count current))\n                (recur (rest coll) longest (vector (first coll)) (first coll))\n                (recur (rest coll) current (vector (first coll)) (first coll))\n            )\n    )     \n  )\n)","problem":53,"user":"50588af1e4b06522596eba7d"},{"problem":53,"code":"#(case (first %) 5 [5 6] 2 [3 4 5] 7 [] [0 1 2 3])","user":"5507cfd3e4b021ccfedb96ad"},{"code":";(fn [in]\n;    (let [pairs (partition-all 2 1 in)\n;          find-incs (for [[a b] pairs] [a b (= (inc a) b)])\n;          find-mono (partition-by #(nth % 2) find-incs)\n;          mono-only (filter #(nth (first %) 2) find-mono)\n;          lengthmap (group-by count mono-only)\n;          longest (if-not (seq lengthmap) 0 (apply max (keys lengthmap)))\n;          best (first (lengthmap longest))]\n;      (if-not best [] (cons (ffirst best) (map second best)))))\n\n(fn [s] (let [deltas (map (fn [[a b]] [(- b a) a b]) (partition 2 1 s))\n              series (partition-by first deltas)\n              longest-length (->> series\n                                  (group-by count)\n                                  keys\n                                  (apply max))\n              desired-sequence (->> series\n                                    (filter #(= (count %) longest-length))\n                                    first)\n              start (second (first desired-sequence))\n              end (int (nth (last desired-sequence) 2))]\n           (range start (inc end))))","problem":53,"user":"4ee26f01535d10e5ff6f5368"},{"code":"#(first\n  (reduce\n    (fn [[max_seq curr_seq] item]\n      (cond\n        (empty? curr_seq)\n          [[] [item]]\n        (> item (last curr_seq))\n          (if (and (> (count curr_seq) 0)\n                   (>= (count curr_seq) (count max_seq)))\n            [(conj curr_seq item) (conj curr_seq item)]\n            [max_seq (conj curr_seq item)])\n        :else\n          [max_seq [item]]))\n  [[] []]\n  %))","problem":53,"user":"4f725466e4b07046d9f4f030"},{"problem":53,"code":";; 4Clojure - problem 53\n(fn subsequence \n    ([input]\n        (if (empty? input)\n            '()\n            ;; if the first two items are not sequential, \n            ;; ignore first element and continue\n            (if (= (inc (first input)) (first (rest input)))\n                (subsequence (list (first input)) (rest input)) \n                (subsequence (rest input))\n            ) \n        )\n    )\n    ([lista listb]\n        (if (empty? listb) \n            lista\n            (if (= (inc (last lista)) (first listb)) \n                ;; If the next item is sequential, then move it to my \n                ;; current list, and continue\n                (subsequence \n                    (concat\n                        lista \n                        (list (first listb))\n                    )\n                    (rest listb)\n                )\n                ;; If the next item is not sequential, compare count with\n                ;; recursive call\n                (if (> (count lista) (count (subsequence listb))) \n                    lista\n                    (subsequence listb)\n                )\n            )\n        )\n    )\n)","user":"5c59b1d3e4b01df32ab73261"},{"code":"(fn [v]\n  (->> (count v)\n       (range 2)\n       (map #(->> (partition % 1 v) (filter (partial apply <)) first))\n       (remove nil?)\n       last\n       vec))","problem":53,"user":"50fd4838e4b033b9c38d78ce"},{"code":"(fn lsi [cs]\n  (let [sqs (reduce \n             (fn [seqs val]\n               (if (> val ((comp last last) seqs))\n                 (conj (vec (butlast seqs)) (conj (last seqs) val))\n                 (conj seqs [val])))\n             [[(first cs)]]\n             (rest cs))\n        longest (first (second (apply max-key key (group-by count sqs))))]\n    (if (== 1 (count longest))\n      []\n      longest)))","problem":53,"user":"51a768e0e4b0da5f497bde84"},{"code":"(fn\n  [x]\n  (let [r (map second \n               (reduce #(let [l (last %)\n                              i (first l)\n                              o (second l)\n                              nv (if (> %2 i)\n                                  (list %2 (+ o 1))\n                                  (list %2 0))]\n                          (conj % nv))\n                          [(list 0 -1)] x))\n        m (apply max r)\n        pr (map-indexed #(list % %2) r)\n        p (first (filter #(= m (second %)) pr))\n        s (- (first p) m 1)]\n    (if (>= m 1)\n      (take (+ 1 m) (drop s x))\n      [])))","problem":53,"user":"510d1ff4e4b078ea7192112f"},{"code":"#(->> %3\n      (reductions % nil)\n      (sort-by count)\n      last\n      %2)\n\n#(if (and % (= 1 (- %2 (peek %)))) (conj % %2) [%2])\n\n#(if (second %) % [])","problem":53,"user":"4e823ed7535db62dc21a62c7"},{"problem":53,"code":"(fn [x] (let [v (apply max-key count (reverse (reductions (fn [y z] (if (< (last y) z) (concat y (list z)) (list z))) '(100) x)))] (if (= 1 (count v)) [] v)))","user":"53fc8424e4b0de5c418485b3"},{"problem":53,"code":"(fn [x]\n   (let [var (reduce (fn [ac e]\n                       (if (= 1 (- e (last (:curr ac))))\n                         {:curr (conj (:curr ac) e) :max (:max ac)}\n                         (if (= 1 (count (:curr ac)))\n                           {:curr (conj (pop (:curr ac)) e) :max (:max ac)}\n                           {:curr [e] :max (:curr ac)})))\n                     {:curr [(first x)] :max []} x)]\n     (if (> (count (:max var)) (count (:curr var))) (:max var) (if (= 1 (count (:curr var))) [] (:curr var)))))","user":"60b3b375e4b0e0fa5f1b4232"},{"problem":53,"code":"(fn lis [v]\n  ( let [cv (count v)\n         ls (for [x (range cv) y (range cv x -1) ] [x y] )\n         subseqs (filter #(> (count %) 1) (map (fn [[a b]] (subvec v a b)  ) (into [] ls)))  \n         ]\n     \n    (let [res (last (sort-by count (reverse (filter #(apply < %) subseqs ))))]\n      (if  (nil? res)\n        []\n        res))))","user":"56f2611fe4b04a395b9a04a2"},{"problem":53,"code":"(fn [ss]\n  (->> (partition 2 1 ss)                                       ;  \n    (partition-by #(= -1 (apply - %)))                   ; \n    (map #(concat (first %) (map last (rest %))))   ; \n    (filter #(apply < %))                                       ; \n    (apply max-key count [])))","user":"593f95d8e4b069cdc2982be3"},{"code":"(fn [xs]\n  (let\n    [candidates\n     (reverse (filter #(and (apply < %) (> (count %) 1))\n      (mapcat (fn [y] (map #(take (inc %) (drop y xs)) (range (count xs)))) (range (count xs)))))]\n    (if (empty? candidates)\n      []\n      (apply max-key count candidates))))","problem":53,"user":"4f03641a535dcb61093f6a9b"},{"problem":53,"code":"(fn [s]\n  (let [n (count s)]\n    (loop [i 0\n           s_i (get s i)\n           lis []]\n      (if (= i n)\n        lis\n        (let [lis_i (loop [j (+ i 1)\n                           prev s_i\n                           s_j (get s j)\n                           j_plus_1 (+ 1 j)\n                           s_j_plus_1 (get s j_plus_1)\n                           curr (if (and (not (nil? s_j)) (> s_j prev)) [prev, s_j] [])]\n                      (if (>= j n)\n                        curr\n                        (if (and (not (nil? s_j_plus_1)) (< s_j s_j_plus_1))\n                          (recur j_plus_1 s_j s_j_plus_1 (+ 1 j_plus_1) (get s (+ 1 j_plus_1)) (conj curr s_j_plus_1))\n                          curr)))]\n          (if (< (count lis) (count lis_i))\n            (recur (+ 1 i) (get s (+ 1 i)) lis_i)\n            (recur (+ 1 i) (get s (+ 1 i)) lis)))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":53,"code":"(fn [c]\n    (let [all-subs (mapcat #(partition % 1 c) (reverse (range 2 (inc (count c)))))\n          find-first (first (filter #(apply < %) all-subs))]\n      (vec find-first)))","user":"52166e50e4b0bf4bffd29cc6"},{"problem":53,"code":"#(letfn \n   [(get-at-least [n xs] \n      (if (>= (count xs) n) xs []))\n    (next [[longest probe prev] curr]\n      (let [p (if (or (empty? probe) (> curr prev))\n                (conj probe curr)\n                [curr])]\n        [(if (> (count p) (count longest)) p longest) p curr]))]\n   (->> % \n        (reduce next [[] [] 0]) \n        first \n        (get-at-least 2)))","user":"4fad9da0e4b081705acca23c"},{"code":"(fn solve [coll]\n  (letfn [\n        (renzoku[[first second & _ :as coll]]\n          (if  (= second (inc first))\n            (cons first (renzoku (rest coll)))\n            (cons first nil)))\n        (partition-renzoku[coll]\n          (when-let [s (seq coll)]\n            (let [ren (renzoku s)\n                  count-ren (count ren)\n                  aa (if (= 1 count-ren ) [] ren )]\n              (cons aa (partition-renzoku (drop count-ren s))))))]\n    (apply max-key count (partition-renzoku coll))))","problem":53,"user":"4f4ec77ae4b03ad3f0c10cd0"},{"code":"(fn [lst] \n  (let [\n    sufs  (map #(take (+ 1 %) lst) (range (count lst))) \n    prefs (fn [lst] (map #(drop % lst) (range (count lst)))) \n    sups  (mapcat prefs sufs) \n    asc   (filter #(apply < %) sups) \n    longest (apply max-key count (reverse asc))\n    atleast2 (if (< 1 (count longest)) longest [])] \n  atleast2))","problem":53,"user":"4f1fd734535d64f6031464a5"},{"problem":53,"code":"(fn [xs]\n  (->> (mapcat (fn [a b] (if (and a (= (inc a) b)) [b] [nil b])) (cons nil xs) xs)\n       (partition-by nil?)\n       (remove #{[nil]})\n       (group-by count)\n       ((fn[m] (cond\n                 (and (seq m) (some #(not= 1 %) (keys m))) (first (m (apply max (keys m))))\n                 (seq m) [])))))","user":"5d764e52e4b02e6b30c93524"},{"problem":53,"code":"(fn\n  [x]\n  (let [[chains last-chain] (reduce (fn [[chains current-chain previous-value] v]\n                                        (if previous-value\n                                          (if (= (- v previous-value) 1)\n                                            [chains (conj current-chain v) v]\n                                            [(conj chains current-chain) [v] v])\n                                          [chains [v] v]))\n                                      [[] [] nil]\n                                      x)]\n    (or (last (sort-by count (remove #(< (count %) 2) (conj chains last-chain)))) [])))","user":"4daeabf6edd6309eace4d15c"},{"code":"(fn [numbers]\n  (loop [longest [] current [(first numbers)] nums (rest numbers)]\n    (if-let [[n & tail] (seq nums)]\n      (if (> n (last current))\n        (recur longest (conj current n) tail)\n        (recur (if (> (count current) (count longest)) current longest) [n] tail))\n      (let [longest-for-real (if (> (count current) (count longest)) current longest)]\n        (if (> 2 (count longest-for-real)) [] longest-for-real)))))","problem":53,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":53,"code":"(fn [coll]\n  ((letfn \n    [; Extract the first increasing sequence of coll (acc must not be empty)\n     (inc-sub-seq [coll acc]\n                  ; Base case: emtpy input\n                  (if (empty? coll) acc\n                    ; Other case: current increasing sequence (acc) ended \n                    (if (<= (first coll) (last acc)) acc\n                      ; If not, add head to current sub-sequence\n                      (inc-sub-seq (rest coll) (concat acc [(first coll)])))))]\n    \n    ; Longest increasing sub-sequence (aux)\n    (fn [coll acc]\n      ; Base case: empty input\n      (if (empty? coll) \n        (if (> (count acc) 1) acc [])\n        ; Compute next sub-sequence\n        (let [next-sub-seq\n              (inc-sub-seq (rest coll) [(first coll)] )]\n          ; Choose longest and iterate\n          (if (> (count next-sub-seq) (count acc))\n            (recur (drop (count next-sub-seq) coll) next-sub-seq)\n            (recur (drop (count acc) coll) acc))))))\n  coll []))","user":"53065acbe4b02e8216869792"},{"code":"#(let [result (second (reduce (fn [[acc longest] elm]\r\n  \t\t\t (if (= (inc (last acc)) elm)\r\n\t\t\t\t   (if (>= (inc (count acc)) (count longest))\r\n\t\t\t\t     [(conj acc elm) (conj acc elm)]\r\n\t\t\t\t     [(conj acc elm) longest])\r\n\t\t\t\t   (if (> (count acc) (count longest))\r\n\t\t\t\t     [[elm] acc]\r\n\t\t\t\t     [[elm] longest])))\r\n\t\t\t       [[(first %)] []]\r\n\t\t\t       %))]\r\n    (if (= 1 (count result))\r\n      []\r\n      result))","problem":53,"user":"4dd6d7ee535d2dad7130b5cb"},{"problem":53,"code":"(fn [[x & coll]]\n  (loop [r [] rc 1\n         c [x] cc 1\n         [x & xs] coll]\n    (cond (nil? x) (if (and (< rc cc)) c r)\n          (< (last c) x) (recur r rc (conj c x) (inc cc) xs)\n          :else (recur (if (< rc cc) c r) (max rc cc) [x] 1 xs))))","user":"563799f8e4b0bfe05bf117db"},{"code":"(fn [coll]\r\n  (letfn ((inc? [[a b]] (= a (dec b))))\r\n    (distinct\r\n     (apply concat\r\n            (first\r\n             (sort #(> (count %1) (count %2))\r\n                   (filter #(inc? (first %))\r\n                           (partition-by inc?\r\n                                         (partition 2 1 coll)))))))))","problem":53,"user":"4dd7d040535d2dad7130b5d6"},{"code":"(fn lis [x]\n  (let [lsub ((fn flis [max maxn li sub la n]\n                (if (empty? li)\n                  (if (> n maxn)\n                    sub\n                    max)\n                  (if (<= (first li) la)\n                    (if (> n maxn)\n                      (flis sub n (rest li) [(first li)] (first li) 1)\n                      (flis max maxn (rest li) [(first li)] (first li) 1))\n                    (if (> (first li) la)\n                      (flis max maxn (rest li) (conj sub (first li)) (first li) (+ n 1))))))\n               [] 0 (rest x) [(first x)] (first x) 1)]\n    (if (or (empty? lsub) (empty? (rest lsub)))\n      []\n      lsub)))","problem":53,"user":"5110b8bae4b04c71fce993f4"},{"code":"(fn ! \n  ([l]\n  (! l [] []))\n  \n  ([l c b]\n   \n   (cond \n      (empty? l)\n\n      (let [candidate (last (sort-by #(count %) [b c]))]\n        (if (= 1 (count candidate))\n          []\n          candidate\n          ))\n   \n      (or (empty? c) (= (first l) (+ 1 (last c)) ))\n      (let [n-c (conj c (first l))] \n        (! (rest l) n-c b))\n     \n      :else\n      (let [n-b (last (sort-by #(count %) [b c])) ]\n        (! (rest l) [(first l)] n-b ))\n   \n    )\n  )\n)","problem":53,"user":"5323f4c6e4b09d4e7a9b54d4"},{"code":"(fn [l]\n(let\n  [tails (fn [xs]\n   (take-while not-empty (iterate rest xs)))\n   ls (fn [xs]\n     (take-while first\n      (map\n        (juxt = (fn [a b] a))\n        xs\n        (drop (first xs) (range)))))\n   answer #(map second (apply max-key count (map ls (tails %))))]\n  (if (< (count (answer l)) 2) [] (answer l))\n))","problem":53,"user":"503de5aae4b06c4e0e1fa259"},{"problem":53,"code":"(fn increasing\n  ([xs]\n   (increasing 2 xs))\n  ([n xs]\n   (let [incs (->> (partition n 1 xs)\n                   (filter #(= (sort < %) %))\n                   (filter #(apply distinct? %)))]\n     (if (empty? incs) []\n         (let [next (increasing (inc n) xs)]\n           (if (seq next) next\n               (first incs)))))))","user":"54d2892fe4b0e8a36923e5f7"},{"problem":53,"code":"#(loop [lst %\n       prev (first lst)\n       acc []\n       result []]\n  (cond (empty? lst) (if (and (> (count acc) 1) (> (count acc) (count result))) acc result)\n        (= (first lst) (inc prev)) (recur (rest lst)\n                                          (first lst)\n                                          (conj acc (first lst))\n                                          result)\n        :else (recur (rest lst)\n                     (first lst)\n                     [(first lst)]\n                     (if (and (> (count acc) 1) (> (count acc) (count result))) acc result))\n        ))","user":"5c62979fe4b0fca0c162264c"},{"problem":53,"code":"(fn tst\n  [[i & in]]\n  (loop [[x & xs :as tx] in\n         best []\n         run [i]\n         l 1]\n    (if (not tx)\n      (if (> (count run) l)\n        run\n        best)\n      (if (> x (last run))\n      \t(recur xs best (conj run x) l)\n        (if ( > (count run) l)\n          (recur xs run [x] (count run))\n          (recur xs best [x] l))))))","user":"597d0e43e4b0dbe32238d095"},{"problem":53,"code":"(fn [xs]\n  (let [res (first (sort #(- (count %2) (count %1))\n               (reductions (fn [l r]\n                             (if (= (last l) (dec r))\n                               (conj l r)\n                               [r]))\n                           [] xs)))]\n    (if (> (count res) 1)\n      res\n      [])\n    )\n  )","user":"541168dee4b01498b1a719c3"},{"code":"(fn lis [s]\n  (let [helper (fn [[sofar ss] e]\n                 (let [new-ss (if (empty? ss)\n                                  [e]\n                                                        (if (> e (last ss))\n                                  (conj                 ss e)\n                                  [e]))]\n                   [\n                    (if (> (count new-ss) (count sofar)) new-ss sofar)\n                    new-ss\n                    ]\n                 )\n                 )\n                 ss     ((reduce helper [[] []] s) 0)\n\t]\n    (if (> (count ss) 1) ss [])))","problem":53,"user":"530bf87ee4b02e82168697d5"},{"problem":53,"code":"(fn [xs]\n  (or (first (filter #(> (count %) 1) (sort-by count > (reductions \n    (fn [x y]\n      (if (> y (last x))\n        (conj x y) [y])) [(first xs)] (rest xs))))) []))","user":"55597b84e4b0deb715856e36"},{"problem":53,"code":"(fn f1 [xs]\n   ((fn f2 [cs rs]\n      (if (empty? rs)\n        cs\n        (if (< (last cs) (first rs))\n          (f2 (conj cs (first rs)) (rest rs))\n          (let [rs (f1 rs)]\n            (if (< (count cs) (count rs))\n              rs\n              (if (= (count cs) 1)\n                []\n                cs))))))\n    [(first xs)] (rest xs)))","user":"5e41b679e4b01d43a70e8e58"},{"code":"(fn [coll]\n    (->> (partition 2 1 coll)\n      (partition-by #(- (second %) (first %)))\n      (filter #(= 1 (- (second (first %)) (ffirst %))))\n      (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n      flatten\n      distinct))","problem":53,"user":"4ff50604e4b0678c553fc365"},{"problem":53,"code":"(fn [s] (last (sort-by count \n                       (remove #(= 1 (count %)) \n                               (reduce \n                                #(if (= (dec %2) (last (first %1))) \n                                   (conj (rest %1) (conj (first %1) %2)) \n                                   (conj %1 [%2])) '([]) s)))))","user":"573ce277e4b05c31a32c080b"},{"code":"(fn [s] (let [deltas (map (fn [[a b]] [(- b a) a b]) (partition 2 1 s))\n                     series (partition-by first deltas)\n                     longest-length (->> series\n                                         (group-by count)\n                                         keys\n                                         (apply max))\n                     desired-sequence (->> series\n                                           (filter #(= (count %) longest-length))\n                                           first)\n                     start (second (first desired-sequence))\n                     end (int (nth (last desired-sequence) 2))]\n                 (range start (inc end))))","problem":53,"user":"52c4fe42e4b0c2d177d620e9"},{"code":"(fn [s]\n   (last (sort-by count (map #(if (= (count %) 1) '() %)\n     (map\n        ; This function returns the monotonic subsequence startign at the start of its input sequence\n        ; first it converts the list into adjecent pairs, e.g. '(1 2 3 4) => '((0 1) (1 2) (2 3) (3 4))\n        ; then it takes pairs until one does not satisfy (apply < '(a b))\n        ; finally each pair is mapped to its second element, recovering the sequence that we're interested in\n        (fn [s]\n          (map second\n               (take-while (partial apply <)\n                           (reductions #(list (last %) %2) (list (dec (first s)) (first s)) (rest s)))))\n        ; The above function is mapped onto this sequence, which is successively shorter tails of the target sequence\n        ; e.g. '(1 2 3 4 5) => '((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5))\n        (map #(take-last % s) (range 1 (inc (count s)))))))))","problem":53,"user":"4fa3f91fe4b081705acca196"},{"code":"(fn [xs]\n    (reverse (loop [xs xs t (list (first xs))  winner '()]\n               (cond\n                (empty? xs) winner\n                (>= (first t) (first xs))\n                (recur (rest xs) (list (first xs)) winner)\n                :else \n                (recur (rest xs) (cons (first xs) t)\n                       (if (>= (count winner) (count (cons (first xs) t)))\n                         winner\n                         (cons (first xs) t)))))))","problem":53,"user":"526302eee4b03e8d9a4a70a2"},{"problem":53,"code":"#(let [l (fn [[a b]]\n            (let [c (if (> (count a) (count b)) a b)]\n              (if (> (count c) 1) c [])))]\n    (l (reduce (fn [[b c] v]\n                 (if (= (last b) (dec v))\n                   [(conj b v) c]\n                   [[v] (l [b c])])) [[] []] %)))","user":"588fbb39e4b00487982d51bd"},{"problem":53,"code":"#(let [res \n      (loop [input %, longest [], acc []]\n            (cond (empty? input) (if (< (count longest) (count acc)) \n                                     acc \n                                     longest),\n                  (or (empty? acc) (< (last acc)(first input))) \n                  (recur (rest input) \n                         longest\n                         (conj acc (first input))),\n                  (< (count longest) (count acc)) \n                  (recur input acc []),\n                  :else (recur (rest input) \n                        longest \n                        (vector (first input)))))] \n      (if (nil? (next res)) [] res) )","user":"53fcdd1ae4b0de5c418485dd"},{"problem":53,"code":"(fn liseq [ls] \n  (loop [max-seq-so-far [] \n         current-seq []\n         left-items ls]\n    (cond\n     (empty? left-items) max-seq-so-far\n     (empty? current-seq) (let [starting-seq [(first left-items)]] (recur max-seq-so-far starting-seq (subvec left-items 1)))\n     (<= (first left-items) (last current-seq)) (recur max-seq-so-far [(first left-items)] (subvec left-items 1))\n     :else\n     (let [updated-current (conj current-seq (first left-items))\n           updated-max (if (> (count updated-current) (count max-seq-so-far)) updated-current max-seq-so-far)]\n       (recur updated-max updated-current (subvec left-items 1)))\n  )))","user":"516064e5e4b009fba0926e26"},{"code":"(fn longest [col]\n  (letfn [(increasing [col]\n          (loop [col col tot []]\n            (cond\n             (empty? col) tot\n             \n             (empty? tot)\n             (recur (rest col) (conj tot (first col)))\n             \n             (> (first col) (last tot))\n             (recur (rest col) (conj tot (first col)))\n\n             :else\n             tot)))]\n    (let [groups\n          (group-by count\n                    (map increasing \n                         (loop [c col acc []]\n                           (if (empty? c) acc\n                               (recur (rest c)\n                                      (conj\n                                       acc c))))))\n          max-key (apply max (keys groups))\n          ]\n      (if (= max-key 1)\n        []\n        (first (get groups max-key))\n    ))))","problem":53,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"(fn [coll] (let [res (filter #(> %1 -100) (last (sort #(< (count %1) (count %2)) (reductions #(if (< (last %1) %2) (conj %1 %2) [%2]) [-999] coll))))] (if (> (count res) 1) res [])))","problem":53,"user":"51da52dbe4b02ceefd947763"},{"problem":53,"code":"(fn [s]\n  (loop [window (count s)\n         start   0]\n    (if (< window 2)\n      []\n      (let [curr-vec (subvec s start (+ start window))]\n        (if (or (empty? curr-vec) (apply < curr-vec))\n          curr-vec\n          (if (= (+ start window ) (count s))\n            (recur (dec window) 0)\n            (recur window (inc start))))))))","user":"572722c4e4b0c5bde472c134"},{"code":"(fn longest-incr-subseq [nums]                                                  \n  (letfn [(pair-less? [pair]                                                    \n            (let [[a b] pair] (< a b)))                                         \n          (flatten-pairs [coll]                                                 \n            (concat (first coll) (map second (rest coll))))]                    \n    (->> nums                                                                   \n      (partition 2 1)                                                           \n      (partition-by pair-less?)                                                  \n      (filter (fn [coll] (every? pair-less? coll)))                             \n      (map flatten-pairs)                                                       \n      ((fn get-longest [coll]                                                   \n         (filter #(= (count %) (apply max (map count coll))) coll)))            \n      (first)\n      (vec))))","problem":53,"user":"530e9729e4b08068f379ecbc"},{"code":"(fn [i o p x]\n  (#(if (= 1 (i %)) [] %)\n    (#(first (sort (fn [x y] (> (i x) (i y))) %))\n      (loop [h [] c [] [t & r :as z] x]\n        (if (o z) (p h c)\n          (if (o c)\n            (recur h (p c t) r)\n            (if (= (inc (peek c)) t)\n              (recur h (p c t) r)\n              (recur (p h c) [t] r)\n))))))) count empty? conj","problem":53,"user":"52bf29fde4b07a9af579232e"},{"problem":53,"code":"(fn [thing]\n  (let [[[_ len start] & _] (->> thing \n                                 (partition 2 1)\n                                 (map (partial apply -))\n                                 (partition-by identity)\n                                 (reduce (fn [arr curr] (conj arr [curr (count curr) (reduce + 0 (map second arr))])) [])\n                                 (filter #(= (ffirst %) -1))\n                                 (sort-by second >))]\n\n    (if start\n      (subvec thing start (+ start len 1))\n      [])\n    ))","user":"56018dd4e4b04bb52996e18f"},{"problem":53,"code":"(fn [col]\r\n  (or (last (sort (filter #(>= (count %) 2) (map-indexed (fn [n v]\r\n                                                           (loop [c (drop (inc n) col)\r\n                                                                  s (vector v)]\r\n                                                             (if (not= (inc (last s)) (first c))\r\n                                                               s\r\n                                                               (recur (rest c) (conj s (first c)))))) col)))) []))","user":"5dbd51cfe4b09f47823971bb"},{"problem":53,"code":"(fn [coll]\n  (let [s (reduce\n            (fn [acc a]\n              (if (or (empty? (last acc))\n                      (> a (last (last acc))))\n                (vec (conj (vec (butlast acc)) (conj (last acc) a)))\n                (conj acc [a])))\n            [[]]\n            coll)\n        m (apply max (map count s))]\n    (if (> m 1) (first (filter #(= m (count %)) s)) [])))","user":"554680cbe4b0a04f7929953e"},{"problem":53,"code":"#(->> \n     (for [r (range (dec (count %)))] (if (= (- (% r) (% (+ 1 r))) -1) [(% r) (% (+ 1 r))] ))\n     (partition-by type)\n     (map (comp distinct flatten (fn [f] (remove nil? f))))\n     (sort-by count)\n     last\n)","user":"54db33f1e4b024c67c0cf75d"},{"code":"(fn [coll]\n (let [data (filter #(= 2 (count %))(partition-all 2 1 coll))\n       is_inc (fn [[a b]] (= 1 (- b a)))]\n    (loop [r [] d (drop-while #(not (is_inc %)) data)]\n     (if (empty? d) (if (empty? r) [](let [r_list (apply concat r) start (first r_list) end (last r_list)] (range start (inc end)))\n)      (let [inc_seq (take-while #(is_inc %) d)]\n        (recur (if (> (count inc_seq) (count r)) inc_seq r)  (drop-while #(not (is_inc %)) (drop-while #(is_inc %) d)) )\n      )\n     )\n    )\n )\n)","problem":53,"user":"522eba30e4b01cdb292c5f0e"},{"problem":53,"code":"(fn longestIncSubSeq [c]\n    (loop [c1 c\n           , test [(first c)]\n           , best [] ]\n      (if (empty? c1)\n          (if (> (count best) 1)\n            best\n            []\n          )\n           (let [ n1 (first c1)\n                , n2 (first (rest c1))\n                , t1 (if (and (number? n1) (number? n2) (< n1 n2) )\n                        (conj test n2)\n                        [n2] )\n                , b1 (if (> (count t1) (count best))\n                          t1\n                         best )\n                ]\n             ;b1\n            (recur\n              (rest c1)\n              t1\n              b1\n            )\n           )\n\n      )\n    )\n  )","user":"571aae1fe4b07c98581c3b5a"},{"problem":53,"code":"(fn [coll] (let [size (count coll)\n                  largest (->> (for [n (range 1 size)\n                                     offset (range 1 size)]\n                                 (partition n offset coll)\n                                 )\n                               (apply concat)\n                               (filter #(apply < %))\n                            \tlast)]\n              (if (> (count largest) 1)\n                largest\n                []\n                )\n              ))","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn liss [s]\n  ((fn liss-sub [[s & ss] acc cur]\n     (let [new-acc\n           (if (> (count cur) (count acc)) cur acc)]\n       (if (nil? s)\n         (if (> (count new-acc) 1) new-acc [])\n           (if (or (empty? cur) (not (= s (inc (last cur)))))\n             (liss-sub ss new-acc [s])\n             (liss-sub ss new-acc (conj cur s)))))) s [] []))","problem":53,"user":"529ce629e4b04e0c58e87b6e"},{"problem":53,"code":"(fn [alist]\n  (->>\n   ;;get all the subsequences\n   (for [x (range (count alist)) y (range (inc (count alist)))\n         :when (< x y)]\n     (take (- y x) (drop x alist)))\n   ;;filter out all the non-increasing seqs\n   (filter #(= % (sort %)))\n   ;;filter out seqs with repeats\n   (filter (fn [alist]\n             (cond\n               (= 1 (count alist)) true\n               (= (first alist) (second alist)) false\n               :else (recur (rest alist)))))\n   ;;group the results by size\n   (group-by count)\n   ;;get the largest seqs\n   (#(% (apply max (keys %))))\n   ;;empty list if biggest list(s) only 1 item long\n   ;;else, grab first from list\n   (#(if (= 1 (count (first %))) [] (first %)))))","user":"5705e404e4b0b0fb43fd0676"},{"problem":53,"code":"(fn [xs]\n  (let [seqs \n        (reductions\n         (fn [a b] (if (> b (last a)) (conj a  b ) [b]))\n         [(first xs)] (rest xs))\n        sorted-seqs (sort-by #(count %) seqs)\n        matches (filter\n                 #(and\n                   (= (count %) (count (last sorted-seqs)))\n                   (> (count (last sorted-seqs) ) 1)\n                   )\n                 sorted-seqs )]\n    (if (empty? matches) matches (first matches)  )\n    )\n  )","user":"564a560ae4b0284900eef654"},{"problem":53,"code":";; I like nothsaevets's solution. He uses a map for the accum\n(fn longest-consecutive-sub-sequence-of-increasing-number [s] \n    (first\n     (reduce (fn [[longest accum-seq] item]    \n               (println longest accum-seq item)\n               (if (> item (last accum-seq))\n                 (let [new-accum-seq  (conj accum-seq item)]\n                   (if (> (count new-accum-seq) (count longest))\n                     [new-accum-seq new-accum-seq] \n                     [longest new-accum-seq]))    \n                ;; else\n                 [longest [item]]))\n\n             [[] [(first s)]]\n\n             (rest s))))","user":"539f9f79e4b0ca733b97449e"},{"problem":53,"code":"(fn [vc]\n  (->> vc count range drop-last vec\n       ((fn [t]\n         (filter\n          #(>= (get vc %)\n              (get vc (inc %)))\n          t)))\n       (map inc)\n       (#(list\n          (concat (list 0) %)\n          (concat % (list (count vc)))))\n       (#(map list (first %) (second %)))\n       reverse vec\n       (apply max-key #(- (second %) (first %)))\n       (apply range)\n       (map #(get vc %))\n       (#(if (<(count %) 2) [] %))))","user":"5649542fe4b0284900eef63f"},{"problem":53,"code":"(fn [coll]\n  (->>\n   coll\n   (reduce #(let [current (last %1)]\n              (if (and (seq current) (= (inc (last current)) %2))\n                (assoc-in %1 [(dec (count %1)) (count current)] %2)\n                (conj %1 [%2])))\n           [])\n   (reduce #(if (and (> (count %2) 1) (> (count %2) (count %1)))\n              %2 %1) [])))","user":"532ecd44e4b019098a6f8b49"},{"problem":53,"code":"(fn [s]\n  (reduce #(if (< (count %1) (count %2)) %2 %1)\n          []\n          (filter #(< 1 (count %))\n                  (reductions #(if (< (last %) %2) (conj % %2) [%2]) [Double/POSITIVE_INFINITY] s))))","user":"5baba1ece4b0a20761a23482"},{"problem":53,"code":"(fn [[x & xn]]\n   (last (sort-by count (conj (filter #(< 1 (count %)) (reduce #(if\n                                                              (= (dec %2) (last (last %)))\n                                                            (conj (vec (drop-last %)) (conj (last %) %2))\n                                                            (conj % [%2])) [[x]] xn)) []))) )","user":"542f574be4b0dad94371f2d0"},{"problem":53,"code":"(fn gg [s]\n  (loop [now []\n         max []\n         i 1\n         ]\n    (if (>= i (count s))\n      max\n      (if (> (s i) (s (dec i)))\n        (recur\n         (if (empty? now)\n           (vector (s (dec i)) (s i))\n           (concat now [(s i)]))\n         (if (> (count max) (count now))\n           max\n           (if (empty? now)\n             (vector (s (dec i)) (s i))\n             (concat now [(s i)])))\n         (inc i))\n        (recur  [] max (inc i))\n        )\n      )\n    )\n  )","user":"589e704ae4b02bd94d917e5e"},{"problem":53,"code":"(fn [c]\n  (letfn [(incr? [s i] (or (zero? i) (> (nth s i) (nth s (dec i)))))\n          (chk [s]\n            (when-not (empty? s)\n              (let [i (loop [i 1] (if (and (< i (count s)) (incr? s i)) (recur (inc i)) i))]\n                (cons (take i s) (chk (drop i s))))))]\n    (let [sqs (chk c)\n          m (apply max (map count sqs))]\n      (if (> m 1) (first (filter #(= (count %) m) sqs))\n                  ()))))","user":"54055aa9e4b0addc1aec6665"},{"code":"#(letfn [(lcs [x i]\n         (conj (map last (take-while (fn [[a b]] (< a b)) (map vector (drop i x) (drop (inc i) x)))) (x i)))]\n  (reduce (fn [x y] (if (and (< 1 (count y)) (< (count x) (count y))) y x)) (list) (map (partial lcs %) (range (count %)))))","problem":53,"user":"4ed94d69535d10e5ff6f5303"},{"problem":53,"code":"(fn [s] (loop [s s\n               sub []\n               result {}]\n          (do\n          (prn \"here is result\" result sub)\n          (if (nil? (next s))\n            (do\n            (let [final (conj result {sub (count sub)})]\n            (prn final)\n            (key (apply max-key val final))))\n           (let [a (first s) \n                 b (second s)\n                 isSeq? (= (inc a) b)]\n            (recur (rest s) \n                   (if isSeq?\n                     (if (empty? sub)\n                       \t[a b]\n                        (conj sub b))\n                     [])\n                   (if isSeq?\n                     result\n                     (do\n                       (prn result sub)\n                       (conj result {sub (count sub)})))))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":53,"code":"(fn [coll]\n    (let [inc-strs (reductions\n                    (fn [acc val]\n                      (if (or (empty? acc) (> val (last acc))) (conj acc val) [val]))\n                    [] coll)\n          max-strs (reduce (fn [acc val]\n                             (if (and (> (count val) 1) (> (count val) (count acc))) val acc))\n                           [] inc-strs)]\n      max-strs))","user":"5e0d948fe4b099d064962f98"},{"problem":53,"code":"#((fn [c l t]\n  (if (empty? t) (if (<= 2 (count l)) l [])\n    (let [\n      h (first t)\n      T (rest t)\n      A (if (empty? c) [h] c)\n      C (if (> h (last A)) (conj A h) [h])\n      L (if (> (count C) (count l)) C l)\n      ]\n      (recur C L T)\n    )\n  )\n) [] [] %)","user":"57c7a8b5e4b05aa3c4741d09"},{"problem":53,"code":"(fn incsub [data]\t\n  (last (sort-by count\n  (loop [input data, subs '()]\n    (cond (empty? input) subs\n    :else (recur (next input) (conj subs\n        ((fn [d, n]\n    (reverse\n      (loop [in (next d), out (list (first d)) ]\n        (cond\n          (or (empty? in) (<= (first in) (first out))) (if (= 1 (count out)) '() out)\n          :else (recur (next in) (conj out (first in)) )\n        )\n      )\n    )\n  ) input 1) ))\n)\n)\n))\n)","user":"568513c4e4b04eec3ec5cfc5"},{"problem":53,"code":"(fn [v]\n  (->> v\n       (partition 2 1)\n       (partition-by (partial apply <))\n       (filter (fn [[[x y]]] (= x (dec y))))\n       (sort-by #(count %))\n       (last)\n       (#(if %\n           (cons (ffirst %) (map second %))\n           []))))","user":"5724a4dae4b0c5bde472c0fe"},{"code":"(fn LI-subseq [x]\n  (loop [current (vector (first x))\n         rst (rest x)\n         longest current]\n    (if (empty? rst)\n      (do (prn current longest)\n        (if (> (count current) (count longest)) current\n          (if (>= (count longest) 2) longest [])))\n      (if (< (last current) (first rst)) (recur (conj current (first rst)) (rest rst) longest)\n        (do (prn current longest)\n          (recur (vector (first rst)) (rest rst) (if (> (count current) (count longest)) current longest)))))))","problem":53,"user":"52084f75e4b01ce6bbf31dde"},{"problem":53,"code":"(fn [orig-coll]\n                      (let\n                         [result (reduce (fn [longest subseq]\n                                    (if (> (count subseq) (count longest))\n                                      subseq\n                                      longest))\n                                  []\n                                  (reduce (fn [coll x]\n                                            (println coll x)\n                                            (if (last coll)\n                                              (if (> x (last (last coll)))\n                                                (into [] (concat (butlast coll) [(conj (last coll) x)]))\n                                                (conj coll [x]))\n                                              (conj coll [x]))) [] orig-coll))]\n                        (if (> (count result) 1)\n                          result\n                          [])))","user":"56c792ace4b0ed865f9758c4"},{"code":"(fn [x]\n   (let [\n     n (first\n         (sort-by #(- (count %))\n           (filter ffirst\n             (partition-by first\n               (map (fn [a b] [(apply < a), b]) (partition 2 1 x) (iterate inc 0))))))]\n     (if n\n       (take (inc (count n)) (drop (second (first n)) x))\n       [])))","problem":53,"user":"4ff201d7e4b0678c553fc330"},{"code":"(fn liss [s]\n  (letfn [(iss [s]\n    (loop [rv [(first s)] tmp (rest s)]\n      (if (= (first tmp) (inc (last rv)))\n        (recur (conj rv (first tmp)) (rest tmp))\n        rv)))]\n    (let [ss (map iss (take (count s) (iterate rest s)))\n          m (apply max (map count ss))\n          l (first (filter #(= (count %) m) ss))]\n      (if (> (count l) 1)\n        l\n        []))))","problem":53,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn sub-seq\n  ([s](sub-seq s 2 [] [] -1))\n  ([s len p c ps]\n    (if s\n      (let [x (first s) more (next s) cur (conj c x)]\n        (if (> x ps)\n          (recur more len p cur x)\n          (if (and (>= (count c) len) (> (count c) (count p)))\n            (recur s len c [] -1)\n            (recur s len p [] -1))\n        ))\n      (if (>= (count c) len) (if (> (count c) (count p)) c p) [])))\n  )","problem":53,"user":"4e44358f535dc968683fc4a8"},{"problem":53,"code":"(fn longest-increasing-sub-seq\n   [coll]\n   (loop [coll coll\n          temp []\n          result []]\n     (let [new-result\n           (if (and (>= (count temp) 2) (> (count temp) (count result)) true)\n             temp\n             result)]\n       (if (empty? coll)\n         new-result\n         (cond\n           (or (empty? temp) (= (- (first coll) (last temp)) 1) false)\n            (recur (rest coll) (conj temp (first coll)) new-result)\n           :else (recur coll [] new-result))))))","user":"60631c2ee4b069485764ddbd"},{"code":"(fn [the-vector]\n  (let [\n        lt        ; Given a pair (a b), returns (< a b).\n                  (partial apply <)\n\n        pairs     ; List of lists of pairs of integers. The pairs in a\n                  ; contained list are all consecutive in the-vector and are\n                  ; increasing pairs. So if the-vector is [... 9 2 3 6 8 1 ...],\n                  ; then pairs is (... ((2 3) (3 6) (6 8)) ...).\n                  (->> (partition 2 1 the-vector)\n                       (partition-by lt)\n                       (filter (comp lt first)))\n\n        max-count ; Returns the list in pairs and its count if bigger than the\n                  ; :count in max-so-far. Else returns max-so-far.\n                  (fn [max-so-far sequence-pairs]\n                    (let [ct (count sequence-pairs)]\n                      (if (> ct (:count max-so-far))\n                        {:pairs sequence-pairs, :count ct}\n                        max-so-far)))\n\n        [first-pair & rest-pairs]\n                  ; The pairs of the biggest sequence\n                  (->> pairs (reduce max-count {:count 0}) :pairs)\n        ]\n\n    ; Reconstitute the longest sequence from its pairs.\n    (concat first-pair (map second rest-pairs))))","problem":53,"user":"533b57c3e4b0e30313ee6ccc"},{"problem":53,"code":"(fn [coll]\n  (loop [[x & xs] coll\n         curr [x]\n         longest [x]]\n    (if (empty? xs)\n      (if (second longest) longest [])\n      (let [y (first xs)\n            curr (if (< x y) (conj curr y) [y])\n            longest (max-key count curr longest)]\n        (recur xs curr longest)))))","user":"552a793ee4b0ffed3738f955"},{"problem":53,"code":"(fn long-sub [sq]\n  (let [beg (dec (first sq))\n        ret (reduce (fn [[best curr prev] e]\n              (if (= (inc prev) e)\n                [best (conj curr e) e]\n                (if (> (count best) (count curr))\n                  [best [e] e]\n                  [curr [e] e]))) [[] [] beg] sq)]\n    \n    (let [best (if (> (count (first ret)) (count (second ret)))\n      (first ret)\n      (second ret))]\n      (if (< (count best) 2)\n        []\n        best))\n  ))","user":"5edd6eb7e4b0c7845d86b0f7"},{"code":"(fn [a](if-let [x (first(sort-by count > (filter #(apply < %) (mapcat #(partition % 1 a) (range 2 (count a))))))] x []))","problem":53,"user":"5307e4ece4b02e82168697a9"},{"problem":53,"code":"(fn [xs]\n  ((fn [x] (if (< (count x) 2) [] x))     ; have a length of 2 or greater\n   (apply max-key count\n          (reverse                      ; to make sure get the first\n           (reductions\n            #(if (or (empty? %1) (>= (last %1) %2))\n               [%2]\n               (conj %1 %2)) [] xs)))))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":53,"code":"(fn [coll]\n  (let [pivot   (fn pivot [pred coll]\n                  (cond (nil? coll) 0\n                        (pred (first coll)) 0\n                        :else (inc (pivot pred (next coll)))))\n        segment (fn segment [coll]\n                  (if-not (empty? coll)\n                    (let [n (pivot (complement neg?)\n                                   (map #(apply - %)\n                                        (partition-all 2 1 coll)))]\n                      (when-not (neg? n)\n                        (cons (take (inc n) coll)\n                              (segment (drop (inc n) coll)))))))\n        segs    (segment coll)\n        logest  (first (sort #(> (count %1) (count %2)) segs))]\n    (if (>= (count logest) 2)\n      logest [])))","user":"5b073c34e4b0cc2b61a3bda4"},{"problem":53,"code":"(fn [input]\n (let [decreasing-partition-sizes (range (count input) 1 -1)\n      power-set (mapcat #(partition % 1 input) decreasing-partition-sizes)\n      increasing (filter (partial apply <) power-set)]\n  (or (first increasing) [])))","user":"59496129e4b07ddc2dafadd7"},{"problem":53,"code":"(fn [s]\n    (loop [left (rest s)\n           current [(first s)]\n           previous []]\n      (println (str left \" \" (vec current) \" \" (vec previous)))\n      (if (= (count left) 0)\n        (let [result (if (> (count current) (count previous))\n                       current\n                       previous)]\n          (if (= (count result) 1)\n            []\n            result))\n        (if (= (first left) (inc (last current)))\n          (recur (rest left)\n                 (concat current [(first left)])\n                 previous)\n          (let [next-prev (if (> (count current) (count previous))\n                            current\n                            previous)]\n            (recur (rest left)\n                   [(first left)]\n                   next-prev))))))","user":"586b6753e4b01531a375e956"},{"problem":53,"code":"(fn [s]\n    (->> (partition 2 1 s)\n         (partition-by (fn [[a b]] (< a b)))\n         (map #(conj (vec (map first %)) (last (last %))))\n         (filter (fn [[a b]] (< a b)))\n         (reduce (fn [a b] (if (>= (count a) (count b)) a b)) [])))","user":"5617db88e4b06b1bb2182a16"},{"problem":53,"code":"(fn [coll]\n  (let [longest-seq (->> (reduce (fn [acc item]\n                                     (cond\n                                         (= (ffirst acc) nil) (conj (rest acc) (conj (first acc) item))\n                                         (= (inc (ffirst acc)) item) (conj (rest acc) (conj (first acc) item))\n                                         :else (conj acc (list item))))\n                                 '(())\n                                 coll)\n                         (sort-by count)\n                         last\n                         reverse\n                         vec)]\n     (if (> (count longest-seq) 1)\n       longest-seq\n       [])))","user":"592518cde4b072a2710fce66"},{"problem":53,"code":"(fn [xs] (let [ans (remove #(= (first %) nil) (partition-by nil? (flatten (for [ i (range (count xs))]\n              (if (and (not(= i (-(count xs) 1))) (= (inc(nth xs i)) (nth xs (+ i 1) )) )\n                (nth xs i)\n                (when (and (not (= i 0)) (= (inc(nth xs (- i 1))) (nth xs i ))) (conj [] (nth xs i) nil))\n        )))))]\t\n  (if (not(empty? ans)) (reduce #(if (> (count %1) (count %2)) %1 %2) ans) '())\n))","user":"598588f2e4b021a7a535fe65"},{"problem":53,"code":"(letfn [(f [m mc c cc l]\n           (cond\n            (and (empty? l) (> cc mc)) (reverse c)\n            (empty? l) (reverse m)\n            (> (first l) (first c)) (recur m mc \n                                           (cons (first l) c)\n                                           (inc cc) (rest l))\n            (> cc mc) (recur c cc (list (first l)) 1 (rest l))\n            :else (recur m mc (list (first l)) 1 (rest l))))]\n       (fn [l] (let [a (f '() 0 (list (first l)) 1 \n                          (rest l))]\n                 (if (< (count a) 2) [] a))))","user":"5800edaae4b0a837a8b30c48"},{"code":"(fn [coll]\n  (let [collect-growing-number \n        (fn [coll x]  \n          (if (or (empty? coll) (= (dec x) (first coll))) \n            (cons x coll) \n            (list x)))]\n    (reverse (first\n      (sort-by count >\n        (filter (fn [coll] (>= (count coll) 2))\n          (reductions collect-growing-number (list) coll)))))))","problem":53,"user":"4ded27db535d08e6dec9fe0a"},{"code":"(fn [coll]\n  (reduce\n   (fn ([] []) ([a b] (if (> (count a) (count b)) a b)))   \n   (filter\n    (complement nil?)\n    (map\n     (fn f\n       ([coll] (f coll nil))\n       ([coll hn] \n          (when (seq coll)\n            (if (= (inc (first coll)) (second coll))\n              (cons (first coll)\n                    (lazy-seq (f (rest coll) true)))\n              (and hn (cons (first coll) nil))))))\n     (loop [coll coll acc []]\n       (if (seq coll)\n         (recur (rest coll) (conj acc coll))\n         acc))))))","problem":53,"user":"52cc582ae4b07d0d72b27362"},{"problem":53,"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n       (partition-by (fn [[a b]] (< a b)))\n       (map #(conj (into [] (map first %)) (last (last %))))\n       (filter (fn [[a b]] (< a b)))\n       (reduce (fn [a b] (if (< (count a) (count b)) b a)) [])))","user":"5756f7d7e4b02ea1147992e9"},{"code":"(fn p53 [xs]\n  (letfn [(tails [xs] (if (empty? xs) nil\n  \t\t  (lazy-seq (cons xs (tails (drop 1 xs))))))\n\t  (increasing-seq [xs] (loop [r [] xs xs l -1]\n\t\t\t\t (cond (empty? xs) r\n\t\t\t\t       (<= (first xs) l) r\n\t\t\t\t       :else (recur (conj r (first xs)) (rest xs) (first xs))\n\t\t\t\t   )))]\n    (loop [longest [] seqs (filter #(> (count %) 1) (tails xs))]\n      (if (empty? seqs) (if (> (count longest) 1) longest [])\n\t  (let [s (increasing-seq (first seqs))]\n\t    (recur (if (> (count s) (count longest)) s longest)\n\t\t   (rest seqs)))))))","problem":53,"user":"4e513ecf535dc968683fc4f6"},{"problem":53,"code":"(fn longest-increasing-sub-seq [numbers]\n  (get\n  (vec\n  (sort-by count #(compare %2 %1)\n  (filter #(> (count %) 1)\n    (reduce\n      (fn [coll number]\n        (if (> number (last (last coll)))\n          (assoc coll (dec (count coll)) (conj (last coll) number))\n          (conj coll [number])\n        )\n      \n      )\n    [[(first numbers)]] (rest numbers))\n  )\n  )\n  )\n  0 [])\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [x] (let [y (apply subvec x (#(list (first %) (reduce + %)) (last (sort-by second (sort-by first (map #(list (first (first %)) (count %)) (partition-by #(identity (val %)) (apply sorted-map (flatten (map-indexed #(list % (- % %2)) x))))))))))] (if (< 1 (count y)) y [])))","problem":53,"user":"50223ee2e4b0846bc458ae48"},{"problem":53,"code":"(fn [coll] \n  (->> (range 2 (inc (count coll)))\n      (mapcat #(partition % 1 coll))\n      (filter #(apply < %))\n      (cons [])\n      (sort-by count >)\n      first\n  )\n)","user":"5405885ee4b0addc1aec6668"},{"code":"(fn [main-coll]\n  (let [increasing? (fn [coll] (every? (fn [[a b]] (= (inc a) b)) (partition 2 1 coll)))\n        subsequences (fn [coll] (mapcat #(partition % 1 coll) (range 2 (inc (count coll)))))\n        increasing-subsequences (filter increasing? (subsequences main-coll))]           \n    (if (< (count increasing-subsequences) 2)\n      (flatten increasing-subsequences)\n      (reduce #(if (> (count %2) (count %1)) %2 %1) (filter #(increasing? %) (subsequences main-coll)))))\n  )","problem":53,"user":"4f43b992e4b0d7d3c9f3fd2c"},{"problem":53,"code":"#(loop [r % i 2 o []] \n    (if (> i (count r)) \n      o \n      (let [t (take i r)\n            m (apply < t)\n            a (if m r (drop (dec i) r)) \n            b (if m (inc i) 2)\n            c (if (and m (< (count o) (count t))) t o)]\n        (recur a b c))))","user":"54c97a56e4b045293a27f676"},{"problem":53,"code":"#(first\n    (reduce\n     (fn [[longest current] next]\n       (if (or (empty? current)\n               (>= (last current) next))\n         [longest\n          (vector next)]\n         (let [new-current (conj current next)]\n           [(if (> (count new-current)\n                   (count longest))\n              new-current\n              longest)\n            new-current])))\n     [[] []]\n     %))","user":"5b8f0861e4b0c0b3ffbd49f4"},{"code":"#(loop [m [] n [] s %] (if (empty? s) m (let [ele (first s) n (if (or (empty? n) (> ele (last n))) (conj n ele) [ele]) c (count n) d (count m)] \n                                                   (recur (if (and (> c d) (> c 1)) n m) n (rest s)))))","problem":53,"user":"51b90b88e4b050a1176cd6a2"},{"problem":53,"code":"(fn\n  [col]\n  (let [res (loop [left (rest col)\n                                context {:current-index   1\n                                         :previous-number (first col)\n                                         :longest-sub     [0 0]\n                                         :current-sub     [0 0]}]\n                           (println \"col: \" left)\n                           (println \"ctx: \" context)\n                           (cond\n                             (empty? left)\n                             (if (> (- (second (:current-sub context)) (first (:current-sub context)))\n                                    (- (second (:longest-sub context)) (first (:longest-sub context))))\n                               (:current-sub context)\n                               (:longest-sub context))\n                             (< (:previous-number context) (first left))\n                             (recur\n                               (rest left)\n                               {:current-index   (inc (:current-index context))\n                                :previous-number (first left)\n                                :current-sub     [(first (:current-sub context)) (inc (second (:current-sub context)))]\n                                :longest-sub     (:longest-sub context)})\n                             :else\n                             (recur\n                               (rest left)\n                               {:current-index   (inc (:current-index context))\n                                :previous-number (first left)\n                                :current-sub     [(:current-index context) (:current-index context)]\n                                :longest-sub     (if (> (- (second (:current-sub context)) (first (:current-sub context)))\n                                                        (- (second (:longest-sub context)) (first (:longest-sub context))))\n                                                   (:current-sub context)\n                                                   (:longest-sub context))})))]\n    (if (= (first res) (second res))\n      []\n      (subvec col (first res) (inc (second res))))))","user":"5a58d8a0e4b05d388ecb6c8a"},{"problem":53,"code":"(fn [s]\n  (loop [acc [] win [] rst s]\n    (if\n      (empty? rst)\n      win\n      (let [a (last acc)\n            r (first rst)\n            acc (if (or (nil? a) (> r a))\n                  (conj acc r)\n                  [r])\n            win (if (> (count acc) (max 1 (count win)))\n                  acc\n                  win)]\n        (recur acc win (rest rst))))))","user":"5d45749be4b07c84aa5ae6a2"},{"problem":53,"code":"(fn longest-increasing-sub-seq [coll]\n  (loop [current-coll (rest coll)\n         current-longest-seq [(first coll)]\n         longest-seq []]\n    (if (seq current-coll)\n      (let [current-element (first current-coll)\n            sub-seq-last-element (last current-longest-seq)]\n        (if (> current-element sub-seq-last-element)\n          (recur (rest current-coll)\n                 (conj current-longest-seq current-element)\n                 longest-seq)\n          (recur (rest current-coll)\n                 [current-element]\n                 (if (and (not= (count current-longest-seq) 1)\n                          (> (count current-longest-seq) (count longest-seq)))\n                   current-longest-seq\n                   longest-seq))))\n      (if (and (not= (count current-longest-seq) 1)\n               (> (count current-longest-seq) (count longest-seq)))\n        current-longest-seq\n        longest-seq))))","user":"54d0cedde4b0e8a36923e5d2"},{"code":"(fn [xs]\n  (let [rfn\n        (fn [[max curr] x]\n          (let [new-curr\n                (if (or\n                      (empty? curr)\n                      (= (last curr) (dec x)))\n                  (conj curr x) [x])\n\n                new-max\n                (if (> (count new-curr) (count max))\n                  new-curr max)]\n\n            [new-max new-curr]))\n        ans (first (reduce rfn [[] []] xs))]\n    (if (> (count ans) 1) ans [])))","problem":53,"user":"4edecdae535d10e5ff6f533c"},{"problem":53,"code":"(fn longest-asc-seq\n  [coll]\n  (loop [longest []\n         source coll]\n    (println source)\n    (if (empty? source)\n      longest\n      (let [delta (map - source (next source))\n            n (inc (count (take-while #(= -1 %) delta)))]\n        (cond\n          (= n 1)\n          (recur longest (next source))\n          \n          (> n (count longest))\n          (recur (take n source) (drop n source))\n\n          :else\n          (recur longest (drop n source)))))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn [c]\n           (->> (partition 2 1 c)\n                (partition-by #(< (first %) (second %)))\n                (map #(concat (first %) (mapcat (fn [[a b]] [b]) (rest %)))) \n                (filter #(and (> (count %) 1) (< (first %) (second %))))\n                (reduce #(if (< (count %1) (count %2)) %2 %1) ())))","problem":53,"user":"4f34eb87e4b0e243712b1eba"},{"problem":53,"code":"(fn\n  [seq]\n  (loop [seq seq newseq (vector (vector (first seq)))]\n    (if (empty? (rest seq))\n      ((fn\n  [seqs]\n  (let [x (apply max (map count seqs))]\n    (if (> x 1)\n      (loop [seqs seqs]\n        (if (= (count (first seqs)) x)\n         (first seqs)\n         (recur (rest seqs)))\n        )\n      []))) newseq)\n      (if (< (first seq) (second seq))\n        (recur (rest seq) (assoc newseq (- (count newseq) 1) (conj (last newseq) (second seq))))\n        (recur (rest seq) (conj newseq (vector (second seq)))))))\n  )","user":"5772ddb0e4b0979f896515d4"},{"problem":53,"code":"(fn [data]\n   (->> (reductions\n          (fn [ret lst]\n            (if (> lst (last ret))\n              (conj ret lst)\n              [lst]))\n          [(first data)]\n          (rest data))\n        (filter #(< 1 (count %)))\n        sort\n        (apply max-key count [])))","user":"5b86462de4b047b03b2037df"},{"problem":53,"code":"(fn [seq1]\n  (->> seq1 (reduce (fn [acc a]\n                     (let [la (last acc)\n                           lla (last la)]\n                       (cond\n                         (nil? la) [[a]]\n                         (= 1 (- a lla)) (conj (vec (drop-last acc)) (conj la a))\n                         :else (conj acc [a]))))\n                   [])\n       (reduce #(if (> (count %1) (count %2)) %1 %2))\n       (#(if (= (count %) 1) [] %))))","user":"562ab73ce4b00e49c7cb482e"},{"problem":53,"code":"(fn [coll]\n  (loop [coll coll\n         longest []\n         acc []]\n    (cond\n     (empty? coll) (cond\n                     (< 1 (count longest) (count acc)) (reverse acc)\n                     (< 1 (count longest)) (reverse longest)\n                     :else [])\n     (empty? acc) (recur (rest coll) longest (cons (first coll) acc))\n     (> (first coll) (first acc)) (recur (rest coll) longest (cons (first coll) acc))\n     (< (count longest) (count acc)) (recur (rest coll) acc [(first coll)])\n     :else (recur (rest coll) longest [(first coll)]))))","user":"571cd9dce4b0145328a76271"},{"code":"(fn [c]\n             (letfn [(increase [c]\n                       (lazy-seq\n                        (loop [s (seq c)\n                               result '()\n                               flag -1]\n                          (cond\n                           (empty? s) (cons (reverse result) '())\n                           (<= (first s) flag) (cons (reverse result) (increase s))\n                           :else (recur (next s) (cons (first s) result) (first s))))))]\n               (let [result (reduce (fn [max e]\n                            (if (< (count max) (count e)) e max))\n                                    (increase c))]\n                 (if (= (count result) 1)\n                   '()\n                   result))))","problem":53,"user":"52f8f4d1e4b047fd55836fde"},{"problem":53,"code":"#((reduce (fn [[l c] x]\n        (let [s (peek c) n count\n              c (conj c x)]\n          (if (< (or s 0) x)\n            [(if (and (< (n l) (n c))\n                       (< 1 (n c)))\n               c\n               l) c]\n            [l [x]])))\n         [[] []] %) 0)","user":"5412c32ce4b01498b1a719d8"},{"problem":53,"code":"(fn longest [ls] \n  (let [div (->> (map vector ls (range))\n                (partition-by #(- (first %1)(second %1))))\n          most (apply max 2 (map count div))]\n  (->> (filter #(= most (count %)) div)\n         first\n        (map first)\n        (into []))))","user":"56903cb9e4b0dcc4269f40eb"},{"problem":53,"code":"(fn [input]\n    (let [partition-while\n          (fn [f in]\n            (loop [all      []\n                   current  [(first in)]\n                   items    (rest in)]\n                (if (empty? items)\n                    (conj all current)\n                    (if (f (peek current) (first items))\n                        (recur all (conj current (first items)) (rest items))\n                        (recur (conj all current) [(first items)] (rest items))))))]\n            \n        (let [partitions (remove #(=(count %) 1)\n                                 (partition-while #(< %1 %2) input))]\n            (apply max-key count (reverse (conj partitions [])))))) ;empty vector added to make max-key work when there's no partitions left","user":"5ff93da9e4b06df49cee14af"},{"problem":53,"code":"(fn [ss]\n  (let [mf #(if (> (count %1) (count %2)) %1 %2)\n        sf #(if (> (count %) 1) % '())]\n    (loop [ls '() cs (list (first ss)) [x & xs] (next ss)]\n      (cond (nil? x) (reverse (sf (mf ls cs)))\n            (= x (inc (first cs))) (recur ls (cons x cs) xs)\n          :else (recur (mf cs ls) (list x) xs)))))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [xs]\r\n  (let [ms (->> xs\r\n           (partition 2 1)\r\n           (partition-by #(> 0 (apply - %)))\r\n           (map #(apply concat %)))]\r\n    (reduce #(if (>= (count %) (count %2)) % %2) []\r\n      (map distinct (for [m ms :when (pos? (- (last m) (first m)))] m)))))","problem":53,"user":"502d4ea0e4b02fc10c6c6e46"},{"problem":53,"code":"(fn [seq]\n   (let [m (for [i (range (count seq))]\n     (let [arr (drop i seq)]\n       (count (take-while true? (map = \n              (reduce #(if (< (last %1) %2) (conj %1 %2) %1) [(first arr)] arr) arr)))))\n         i (.indexOf m (apply max m))]\n     (if (< (nth m i) 2) '()\n      (drop-last (- (count seq) i (nth m i)) (drop i seq)))\n ))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn [bl]\n  (apply max-key count '()\n         (filter #(> (count %) 1)\n                 (reductions\n                  (fn [l i]\n                    (if (= (last l) (dec i))\n                      (concat l (list i))\n                      (list i)))\n                  '() bl))))","problem":53,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":53,"code":"(fn [col]\n  (->> col\n       (partition 2 1)\n       (partition-by #(< (first %) (second %)))\n       (filter #(< (first (first %)) (last (last %))))\n       (map #(conj (map second %) (first (first %))))\n       (map vector (range))\n       (sort-by identity (fn [[index1 subseq1] [index2 subseq2]]\n                           (or (> (count subseq1) (count subseq2))\n                               (and (= (count subseq1) (count subseq2))\n                                    (< index1 index2)))))\n       first\n       second\n       (into [])))","user":"56b965d9e4b0f26550335931"},{"problem":53,"code":"(fn [x]\n   (let [seq-map\n         (->> ((fn gen-seq\n                 ([s] (gen-seq s 1))\n                 ([s t] (cond\n                          (empty? s) nil\n                          (= (count s) t) (cons s (lazy-seq (gen-seq (rest s) 1)))\n                          :else (cons (take t s) (lazy-seq (gen-seq s (inc t))))))) x)\n              (filter (fn [e] (> (count e) 1)))\n              (filter (fn [e] (apply < e)))\n              (group-by count))\n         m-key (if (seq seq-map)\n                 (apply max (keys seq-map))\n                 nil)]\n     (vec (first (seq-map m-key)))))","user":"5853582fe4b0b7285a6f4ec5"},{"problem":53,"code":"(fn partition-by-increasing\n  [col]\n  (letfn [(partition-increasing\n            [col]\n            (loop [part-col []\n                   cur-subseq []\n                   col col]\n              (let [prev (last cur-subseq)\n                    x (first col)]\n                (cond\n                  (not x) (conj part-col cur-subseq) ; last element\n                  (not prev) (recur part-col [x] (next col)) ; first element\n                  (> x prev) (recur part-col (conj cur-subseq x) (next col)) ;\n                  :else (recur (conj part-col cur-subseq) [x] (next col))))))\n          (longest-seq [col]\n            (let [lens (map count col)\n                  max-len (apply max lens)]\n              (->>\n               (map vector col lens)\n               (filter #(and (>= (count (first %)) 2) (= (second %) max-len)))\n               (map first)\n               first\n               vec\n               )))]\n    (-> col\n        partition-increasing\n        longest-seq)))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(partial(fn f[b c r](let[l(fn[a b](if(>(count a)(max 1(count b)))a b))](if(empty? r)(l c b)(if(or(empty? c)(>(first r)(last c)))(f b(conj c(first r))(rest r))(f(l c b)[(first r)](rest r))))))[][])","problem":53,"user":"50ed4626e4b01236b1d4983c"},{"code":"(fn [p] \n  (let [t (reverse (filter (comp first vals)\n                     (for [i (range 9) j (reverse (range 9))]\n                       (let [r (drop i (take j p)) c (count r)]\n                         {r (and (> c 1) (= r (take c (drop (first r) (range)))))}))))] \n    (if (empty? t) t (first (keys (apply max-key (comp count first keys) t))))))","problem":53,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(letfn [(f [c] (reductions #(conj % %2) [] (reverse c)))]\r\n (fn [y] (last (sort (remove #(= 1 (count %)) (map \r\n  (fn [x]  (last (filter #(or (empty? %) (apply < %)) (f x))))\r\n  (f y)))))))","problem":53,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":53,"code":"(fn [s] (or (first (last (vals (group-by count (sort-by #(count %) (filter #(or (<= (count %) 1) (< (first %) (second %))) (map #(concat (map first %) (list (last (last %))))\n                              (partition-by #(< (first %) (second %)) (map list s (rest s))))))))))\n                             []))","user":"56baab13e4b0f26550335948"},{"code":"(fn [a] (let [b (filter #(= (inc (first (first %))) (second (first %))) (partition-by #(= (inc (first %)) (second %)) (partition 2 (interleave a (rest a))))) ] (if (empty? b) [] (#(cons (first (first %)) (map second %))  (apply max-key count (reverse b )) ))  ))","problem":53,"user":"4e6e6630535d5021c1a89609"},{"problem":53,"code":"(fn longest [s]\n  (second (reduce (fn [acc n]\n                    (let [c (first acc)\n                          m (second acc)\n                          newcurr (if (> n (last c)) (conj c n) [n])\n                          newmax (if (and (> (count newcurr) (count m)) (> (count newcurr) 1)) newcurr m)]\n                      [newcurr newmax]))\n                  [[(first s)][]] (rest s))))","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(comp #(if (< 1 (count %)) % [])\n       #(map first\n          (first (sort-by count >\n                   (partition-by last \n                      (map list % (reductions + (cons 0 (map \n                        (fn [[x1 x2]] (if (< x1 x2) 0 1)) (partition 2 1 %))))))))))","problem":53,"user":"528652fbe4b0239c8a67ae14"},{"problem":53,"code":"(fn liss [sq]\n  (let [lengths (reduce\n                 (fn [acc v]\n                   (if (empty? acc)\n                     [[0 v 0]]\n                     (let [[lastix lastv lastlen] (last acc)]\n                       (concat acc [[(inc lastix) v (if (> v lastv) (inc lastlen) 0) ]] ))))\n                 [] sq)\n        maxacc (reduce (fn [acc cur] (if (>= (nth acc 2) (nth cur 2)) acc cur)) lengths)\n        end (nth maxacc 0)\n        len (nth maxacc 2)\n        start (- end (nth maxacc 2))]\n    (if (> len 0)\n      (subvec sq start (inc end))\n      [])))","user":"5ecc0831e4b016b56eae058c"},{"problem":53,"code":";(vec (\n(fn [coll] (->> coll \n                      (partition 2 1) \n                      (partition-by (partial apply <))\n                      (filter (fn [[[a b]]]  (< a b)))\n                      (reduce (fn [m s] (if (> (count s) (count m)) s m)) [])\n                      (#(if-not (empty? %) (cons (ffirst %) (map second %)) %))\n                      ))\n;      [2 3 3 4 5]))","user":"573632b7e4b0cd1946bd102f"},{"problem":53,"code":"(fn longest-ss [s]\n  (loop [s s\n         max-len 0\n         long-ss []]\n    (let [[next-ss rest-s] \n          ((fn [s]\n  (loop [ss [(first s)]\n         s (rest s)]\n    (if (or (empty? s) (<= (first s) (last ss)))\n      [ss s]\n      (recur (conj ss (first s)) (rest s))))) s)\n          next-len (count next-ss)\n          long-ss (if (> next-len max-len) next-ss long-ss)\n          max-len (max next-len max-len)]\n      (if (empty? rest-s)\n        (if (> (count long-ss) 1) long-ss [])\n        (recur rest-s max-len long-ss)))))","user":"56f9392ae4b07572ad1a88ac"},{"problem":53,"code":"(fn [s]\n  (let [lg (not-empty (->> s\n                           (partition 2 1)\n                           (partition-by (partial apply <))\n                           (filter #(apply < (first %)))\n                           (group-by count)))]\n    (if lg\n      (->> (get lg (apply max (keys lg)))\n           first\n           (#(concat (first %) (map second (rest %)))))\n      '())))","user":"57023e92e4b08d47c97781da"},{"problem":53,"code":"(fn [[x & xs]]\n  (loop [ys xs last x current [last] best [last]]\n    (cond (empty? ys) (if (= 1 (count best))\n                        []\n                        best)\n          (= (inc last) (first ys)) (recur (next ys) (first ys) (conj current (first ys)) (if (= (count current) (count best))\n                                                                                            (conj current (first ys))\n                                                                                            best))\n          :else (recur (next ys) (first ys) [(first ys)] best))))","user":"58ebae90e4b056aecfd47d44"},{"code":"(fn solution [coll]\n  (->> (partition 2 1 coll)\n       (partition-by #(- (second %) (first %)))\n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (reduce #(if (> (count %1) (count %2)) %1 %2) [])\n       flatten\n       distinct))","problem":53,"user":"4f6fd91ae4b07046d9f4efed"},{"problem":53,"code":"(fn l [s]\n  (let [seqs (reduce (fn [c n]\n                       (if (> n (last (last c)))\n                         (conj (vec (drop-last c))\n                               (conj (last c) n))\n                         (conj c [n])))\n                     [[(first s)]]\n                     (rest s))\n        maxlen (apply max (map count seqs))]\n    (if (< maxlen 2)\n      []\n      (first (filter #(= maxlen (count %)) seqs)))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn inc-sub-seq [xs]\n  (let [next-up? (fn [a b] (= (inc a) b))\n        longest-run (fn [runs]\n                      (let [the-runs (filter #(> (count %1) 1) runs)]\n                        (if (zero? (count the-runs))\n                          []\n                          (apply max-key count the-runs))))\n        inc-sub-seq (fn [xs runs curr]\n                      (if (zero? (count xs))\n                        (longest-run (conj runs curr))\n                        (if (next-up? (last curr) (first xs))\n                          (recur (rest xs) runs (conj curr (first xs)))\n                          (recur (rest xs) (conj runs curr) [(first xs)]))))]\n    (inc-sub-seq (rest xs) [] [(first xs)])))","problem":53,"user":"4ef9b021535dced4c769f269"},{"problem":53,"code":"(fn [xs]\n    (let [max-seq\n          (loop [x (rest xs)\n                 max []\n                 cur [(first xs)]]\n            (cond\n              (empty? x) (if (< (count max) (count cur)) cur max)\n              (= (first x) (inc (last cur)))\n              (recur (rest x)\n                     max\n                     (conj cur (first x)))\n              :else\n              (recur (rest x)\n                     (if (< (count max) (count cur)) cur max)\n                     [(first x)])))]\n      (if (> (count max-seq) 1)\n        max-seq\n        [])))","user":"51c116d4e4b0c9c822882942"},{"code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (loop [prev-item (first coll)\n           rest-coll (rest coll)\n           cur-subseq [prev-item]\n           cur-longest []]\n      (if (empty? rest-coll)\n        (if (> (count cur-subseq) (count cur-longest))\n          (if (> (count cur-subseq) 1)\n            cur-subseq\n            [])\n          (if (> (count cur-longest) 1)\n            cur-longest\n            []))\n        (let [next-item (first rest-coll)]\n          (if (> next-item prev-item)\n            (recur\n              next-item\n              (rest rest-coll)\n              (conj cur-subseq next-item)\n              cur-longest)\n            (if (> (count cur-subseq) (count cur-longest))\n              (recur\n                next-item\n                (rest rest-coll)\n                [next-item]\n                cur-subseq)\n              (recur\n                next-item\n                (rest rest-coll)\n                [next-item]\n                cur-longest))))))))","problem":53,"user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":53,"code":"#(loop[v (rest %) preVal (first %) longestSeq [] trackedSeq [preVal]]\n  (if (seq v)\n    (let[curVal (first v)]\n      (if (> curVal preVal) (recur (rest v) curVal longestSeq (conj trackedSeq curVal))\n        (if (> (count trackedSeq) (count longestSeq)) (recur (rest v) curVal trackedSeq (vector curVal))\n          (recur (rest v) curVal longestSeq (vector curVal)))))\n    (let[result (if (> (count trackedSeq) (count longestSeq)) trackedSeq longestSeq)]\n      (if (<= (count result) 1) [] result))))","user":"541619e8e4b01498b1a719f9"},{"problem":53,"code":"(fn longest-sub-seq [s]\n     (let [longest (->>\n                     (partition 2 1 s)\n                     (partition-by (fn [[x y]] (< x y)))\n                     (remove (fn [[[x y]]] (> x y)))\n                     (map flatten)\n                     (map #(partition-by identity %))\n                     (map #(map first %))\n                     (sort-by #(count %) >)\n                     (first)\n                     )\n           ]\n     (if (nil? longest) [] longest)))","user":"594ea2a4e4b07ddc2dafaeb6"},{"code":"(fn [v]\r\n       (letfn [(good-pair? [p] (= (inc (p 0)) (p 1)))\r\n               (groups [coll] (partition-by good-pair? (map vector coll (rest coll))))\r\n                (good-runs [colls] (filter #(good-pair? (first %)) colls))\r\n                (longest [colls] (reduce #(if (> (count %1) (count %2)) %1 %2) [] colls))\r\n                (regroup [colls] (conj (reduce #(conj %1 (first %2)) [] colls) (last (last colls))))\r\n                ]\r\n               (let [r (regroup (longest (good-runs (groups v))))]\r\n                 (if (nil? (first r)) [] r)\r\n                 \r\n                 )))","problem":53,"user":"4df407c3535d08e6dec9fe2e"},{"problem":53,"code":"(fn [l]\n  (let [subs (map #(drop %2 l) l (range))\n        take-while-ordered (fn [l] (first (reduce #(if (and (second %1) (or (empty? (first %1)) (> %2 (apply max (first %1))))) (list (conj (first %1) %2) true) (list (first %1) false)) '([] true) l)))\n        ordered-subs (filter #(> (count %) 1) (map take-while-ordered subs))\n        max-size (apply (partial max 0) (map count ordered-subs))\n        ]\n    (if (= max-size 0)\n      []\n      (first (filter #(= max-size (count %)) ordered-subs))\n    )\n    ))","user":"594263cbe4b060784b3b790a"},{"problem":53,"code":"(fn [coll] \n    (loop [[head & tail] coll\n           current []\n           longest []]\n          (if (nil? head)\n              (if (> (count longest) 1) longest [])\n              (let [ascending (or (empty? current) (= head (inc (last current))))\n                    ncurrent (if ascending (conj current head) [head])\n                    nlongest (if (> (count ncurrent) (count longest)) ncurrent longest)]\n                   (recur tail ncurrent nlongest)))))","user":"57b9f35be4b0fbc9809a27f9"},{"problem":53,"code":"(fn\n  [coll]\n  (loop [result [] curr-seq [] targ-coll coll]\n    (let [val (first targ-coll)]\n      (cond\n        (nil? val) (or (first (sort-by count > (filter #(< 1 (count %)) (conj result curr-seq)))) [])\n        (empty? curr-seq) (recur result (conj curr-seq val) (rest targ-coll))\n        (= val (inc (last curr-seq))) (recur result (conj curr-seq val) (rest targ-coll))\n        :else (let [new-result (conj result curr-seq) new-seq [val]]\n                (recur new-result new-seq (rest targ-coll)))))))","user":"5aa4a1ffe4b0d174b936c886"},{"problem":53,"code":"(letfn [(increasing-prefix [coll]\n          (loop [acc [], todo coll]\n            (if (empty? todo)\n              acc\n              (let [[head & tail] todo]\n                (if (or (empty? acc) (> head (last acc)))\n                  (recur (conj acc head) tail)\n                  acc)))))]\n  (fn longest-incr-subseq [coll]\n    (loop [longest (increasing-prefix coll), todo (rest coll)]\n      (if (empty? todo)\n        (if (> (count longest) 1)\n          longest\n          [])\n        (let [subseq (increasing-prefix todo)]\n          (recur (if (> (count subseq) (count longest))\n                   subseq\n                   longest)\n                 (rest todo)))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [s] (reduce #(if (> (count %2) (count %1)) %2 %1) [] (map (comp vec set flatten)\n              (filter (fn [[[e d] & _]] (< e d))                                 \n                      (partition-by (fn [[x y]] (< x y))                         \n                                    (partition 2 1 s))))))","problem":53,"user":"5167d60de4b0c5a4140a3098"},{"problem":53,"code":"(fn [x]\n  (->> (partition 2 1 x)\n       (map #(if (= (- (second %) (first %)) 1)\n               % nil))\n       (partition-by nil?)\n       (remove #(nil? (first %)))\n       (map #(concat (first %) (map second (rest %))))\n       (reduce (fn [best cur]\n                 (if (> (count cur) (count best))\n                   cur best))\n               ())))","user":"5d431c77e4b07c84aa5ae68f"},{"problem":53,"code":"(fn [s]\n      (let [f (fn [sub] (loop [[x & xs] sub]\n                              (cond (or (nil? x) (nil? xs)) true\n                                    (= x (- (first xs) 1)) (recur xs)\n                                    (not= x (first xs)) false)))]\n      (loop[i 2]\n           (let[subsequences (partition i 1 s) filterd-seq (filter #(f %) subsequences)]\n               (if (and (empty? filterd-seq) (= i 2)) [] (if (empty? filterd-seq)\n                                                        (first  (filter #(f %) (partition (dec i) 1 s)))\n                                                        (recur (inc i))))))))","user":"560331dee4b04bb52996e1b5"},{"problem":53,"code":"(fn longest [coll]\n  (let [s (first coll)\n        red (fn [[xs x] y]\n              (let [len (count xs)]\n                (if (= (inc x) y)\n                  [(update-in xs [(dec len)] #(conj % y)) y]\n                  [(update-in xs [len] (constantly [y])) y])))]\n    (->> (reduce red [[[s]] s] (rest coll))\n         (first)\n         (sort-by count)\n         (last)\n         (#(if (> (count %) 1) % [])))))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [inp]\n  (let [push-back (fn[col x] (reverse (cons x (reverse col))))\n        addl (fn [ccoll, x]\n          (if (= 1 (count ccoll))\n            (list (push-back (first ccoll) x))\n            (concat (butlast ccoll) (list (push-back (last ccoll) x))  )))\n        partition-seq (fn [l]\n  \t\t\t  (reduce \n\t\t\t\t    #(if (= (dec %2) (last(last %)))\n\t\t\t\t      (addl % %2)\n\t\t\t\t      (reverse (cons (list %2) (reverse %) )))\n\t\t\t\t    '(()) l))\n        run (apply max-key count (partition-seq inp))]\n    (if (= 1 (count run)) [] run)))","problem":53,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":53,"code":"(fn [xs]\n  (letfn [(maxsubseq [xs ys] (if (or (>= (count xs) (count ys)) (> 2 (count ys))) xs ys))]\n    (apply maxsubseq (reduce\n                       (fn [[max curr] x]\n                         (if (< (last curr) x)\n                           [max (conj curr x)]\n                           [(maxsubseq max curr) [x]]))\n                       [[] [(first xs)]]\n                       (rest xs)))))\n\n; hypirion's solution:\n#_(fn [coll]\n    (->> \n      (range 2 (inc (count coll)))\n      (mapcat #(partition % 1 coll)) ; take all sequences of length 2 or more\n      (filter #(apply < %)) ; pick the ones which are increasing sub-sequences\n      (cons []) ; make them into an array\n      (sort-by count >) ; sort by length\n      first)) ; pick the first","user":"55e7d06ee4b050e68259b496"},{"problem":53,"code":"; This is a clever way to do this. I did not come up with this.\n; Break it into tuples. File out the ones that are not (< 1 2). Put them together. REVERSE??? Look for the largest.\n\n(fn [coll] \n   (let [seqs (reverse (map #(concat (first %) (map (fn [i] (last i)) (rest %))) \n                         (filter #(every? (fn [ele] (< (first ele) (last ele))) %) \n                           (partition-by \n                             #(< (first %) (last %)) \n                             (partition 2 1 coll)))))] \n     (if (empty? seqs) \n       [] \n       (apply (partial max-key count) seqs))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":53,"code":"#(first\n  (reduce\n   (fn [[m c] x]\n     (let [t count\n           a (if (> x (or (last c) -1)) (conj c x) [x])\n           b (if (and (> (t a) 1) (> (t a) (t m))) a m)]\n       [b a]))\n   [[][]] %))","user":"50548ce8e4b0b1b9d1860ead"},{"problem":53,"code":";;Given a vector of integers, find the longest consecutive sub-sequence of increasing numbers.\n;; If two sub-sequences have the same length, use the one that occurs first. \n;; An increasing sub-sequence must have a length of 2 or greater to qualify.\n\n(fn [coll]\n  (let \n    [x (apply max-key count\n         (reduce \n           (fn [mem curr]\n            (if (= curr (inc ( last (last mem) )))\n              (assoc mem (count mem) (conj (last mem) curr))\n              (conj mem [curr])))   \n           [[(first coll)]] coll))]\n    (if (> (count x) 1) x [])))","user":"542c2de0e4b0dad94371f29f"},{"code":"(fn largest-increasing-subsequence [sq]\n    (let [split-seq\n          (fn split-seq [sq]\n            (reduce\n              (fn [sofar newval]\n                (cond\n                  (empty? sofar) [[newval]]\n                  (>= (last (last sofar)) newval) (conj sofar [newval])\n                  :else (conj (vec (butlast sofar))\n                        (conj (last sofar) newval))))[] sq))]\n       (let [candidate\n         (first (second (last (sort (group-by count (split-seq sq))))))]\n         (if (< (count candidate) 2) [] candidate))))","problem":53,"user":"515737f0e4b0b0b4b87062d0"},{"problem":53,"code":"(fn [coll]\n  (letfn [(take-while-increasing [coll]\n             (loop [acc [(first coll)]\n                    coll (rest coll)]\n               (let [f (first coll)]\n                 (cond\n                   (nil? f) acc\n                   (> f (first acc)) (recur (cons f acc) (rest coll))\n                   :else (reverse acc)))))]\n\n    (loop [coll coll\n           acc []]\n      (if (empty? coll)\n        acc\n        (let [c (take-while-increasing coll)\n              c (if (= (count c) (count coll)) coll c)]\n          (cond\n            (nil? c) acc\n            (and (< 1 (count c)) (> (count c) (count acc))) (recur (rest coll) c)\n            :else (recur (rest coll) acc)))))))","user":"55fbc657e4b0f488688e0666"},{"problem":53,"code":"(fn\n  [coll]\n  (let [is-next? #(or (nil? %1)\n                     (= (inc %1) %2))]\n    (loop [[b & more] coll\n           inc-seq []\n           a nil\n           sub-colls []]\n      (if b\n        (if (is-next? a b)\n          (recur more\n                 (conj inc-seq b)\n                 b\n                 sub-colls)\n          (recur more\n                 [b]\n                 b\n                 (if (>= (count inc-seq) 2)\n                   (conj sub-colls inc-seq)\n                   sub-colls)))\n        (reduce (fn\n                  ([]\n                   [])\n                  ([c1 c2]\n                   (if (>= (count c1) (count  c2)) c1 c2)))\n                (if (>= (count inc-seq) 2)\n                  (conj sub-colls inc-seq)\n                  sub-colls))))))","user":"5c9a638fe4b048ec896c5aae"},{"problem":53,"code":"(fn [s] (->> (partition 2 1 s)(partition-by #(apply - %))(filter #(= -1 (apply - (first %))))(sort-by count)last(#(when % (cons (ffirst %) (map last %)))) vec))","user":"4db1fe241254ad5b4805fa77"},{"problem":53,"code":"(fn [seqcoll]\n  (let [end (rest seqcoll)\n        mix (interleave seqcoll end)\n        in-parts (partition 2 mix)\n        grp (partition-by (fn [[x y]] (> y x)) in-parts)\n        counter (map (fn [x]\n                       (let [[a b & r :as all] x\n                             c (count all)]\n                         (if (> (nth a 1)\n                                (nth a 0))\n                           c 0))) grp)\n        max (reduce\n              #(if (> %1 %2) %1 %2)\n              counter)\n        max-index (.indexOf counter max)]\n    (if (zero? max)\n      []\n      (subvec seqcoll max-index (+ max-index max 1)))))","user":"5842d06be4b089d5ab817e22"},{"code":"(fn [s]\n  (letfn [(ixes [f]\n                (fn [s]\n                  (map #(f % s) (take (inc (count s)) (range)))))\n          (strictly-increasing? [s]\n                                (= s (seq (apply sorted-set s))))]\n    (let [suffixes (ixes drop)\n          prefixes (ixes take)]\n      (->> (mapcat #(prefixes %) (suffixes s))\n           (filter strictly-increasing?)\n           (filter #(> (count %) 1))\n           (cons ())\n           (sort-by count >)\n           first))))","problem":53,"user":"50e4b066e4b0cb9ec68fbca6"},{"code":"(fn [xs] \n  (let [longest-sub-seq (first \n   (sort-by #(- (count %)) \n            (reduce (fn [acc x]\n                      (if (and\n                           (last acc)\n                           (< ((comp last last) acc) x))\n                        (conj (pop acc) (conj (last acc) x))\n                        (conj acc [x]))) [] xs)))]\n    (if (> (count longest-sub-seq) 1)\n      longest-sub-seq\n      [])))","problem":53,"user":"51aab611e4b04e3dc0c27b2d"},{"problem":53,"code":"(fn [xs]\n  (letfn [(sequences [xs]\n            (loop [xs xs a [] c [] l nil]\n              (let [n (first xs)]\n                (cond\n                  (not (seq xs)) (conj a c)\n                  (nil? l) (recur (rest xs) a [n] n)\n                  (<= n l) (recur (rest xs) (conj a c) [n] n)\n                  :else (recur (rest xs) a (conj c n) n)))))] \n    (reduce \n      (fn [xs ys]\n        (if (and (>= (count ys) 2 ) (> (count ys) (count xs)))\n          ys\n          xs))\n      [] \n      (sequences xs))))","user":"540e17c3e4b0addc1aec6719"},{"code":"(fn [s]\n  (let [choose (fn [s t]\n                 (if (>= (count s) (count t))\n                   s\n                   t))]\n  (loop [s s\n         lis []\n         cs []]\n    (cond\n      (empty? s)\n        (if (> (count lis) 1)\n          lis\n          [])\n      (empty? cs)\n        (recur (rest s)\n               (choose lis [(first s)])\n               [(first s)])\n      (> (first s) (last cs))\n        (recur (rest s)\n               (choose lis (conj cs (first s)))\n               (conj cs (first s)))\n      :else\n        (recur (rest s)\n               (choose lis [(first s)])\n               [(first s)])))))","problem":53,"user":"4f2b0951e4b0d6649770a045"},{"code":"(fn longest-inc-sub-seq\n  [xs]\n  (let [increasing? (fn [[a b]] (= (inc a) b))]\n    (->> xs\n         (partition 2 1)\n         (map #(if (increasing? %) % (second %)))\n         (partition-by type)\n         (map #(when (seq? (first %)) ((comp flatten) %)))\n         (filter seq?)\n         (map distinct)\n         (filter #(> (count %) 1))\n         (reduce #(if (> (count %2) (count %)) %2 %) '()))))","problem":53,"user":"524f4256e4b0541d1855b808"},{"problem":53,"code":"(fn [se] (\n\nlet [ret\n((fn find-lon [s cur best] (if (empty? s)\n                            best\n                            (let [fs (first s) rs (rest s)]\n                             (if (> fs (first cur))\n                              (if (= (count cur) (count best))\n                                (find-lon rs (cons fs cur) (cons fs cur))\n                                (find-lon rs (cons fs cur) best))\n                              (find-lon rs (list fs) best)))))\n          \n          (rest se) (list (first se)) (list (first se)))]\n          \n          (if (> (count ret) 1) (reverse ret) '())\n          ))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":53,"code":"(fn [lst]\n  (letfn [(split-find [pred? lst]\n            (cond (< (count lst) 2) (list lst)\n                  :else\n                  (let [[h t] (split-find pred? (next lst))]\n                    (if (pred? (first lst) (fnext lst))\n                      (list (list (first lst)) (next lst))\n                      (list (cons (first lst) h)\n                            t)))))\n          (seqs [lst]\n            (if (empty? lst)\n              '()\n              (let [[h t] (split-find (fn [a b]\n                                        (not= (- b a) 1))\n                                      lst)]\n                (cons h\n                      (seqs t)))))]\n    (let [result (first (sort #(> (count %1) (count %2))\n                              (seqs lst)))]\n      (if (> 2 (count result))\n        []\n        result))))","user":"5895477fe4b00487982d527c"},{"problem":53,"code":"#(loop [i 0\n         group []\n         groups []\n         ]\n    (if (< i (count %))\n      (let [current (% i)]\n        (prn i current group groups)\n        (if (empty? group)\n          (recur (inc i) (conj group current) groups)\n          (if (> current (last group))\n            (recur (inc i) (conj group current) groups)\n            (recur i [] (conj groups (if (> (count group) 1)  group [])))\n            )\n          )\n        )\n      (last (sort-by count (reverse (conj groups (if (> (count group) 1) group [])))))\n      )\n    )","user":"5896ade8e4b00487982d52a9"},{"problem":53,"code":"(fn [x]\n     (sequence (some #(when (= % (range (first %) (inc (last %)))) %) (for [len (range (count x) 0 -1) frst (range 0 (- (count x) len))] (subvec x frst (+ frst len 1))))))","user":"583c8bd4e4b089d5ab817d81"},{"problem":53,"code":"#(letfn\n   [(longer-than-one [x]\n      (if (< 1 (count x)) x [])\n      )\n    (select-longer [x y]\n      (if (< (count x) (count y)) y x)\n      )\n    (longest [[ifirst & irest] tmp tmp-long]\n      (cond\n        (nil? ifirst) (select-longer tmp-long tmp)\n        (< (last tmp) ifirst) (recur irest (conj tmp ifirst) tmp-long)\n        :else (recur irest [ifirst] (select-longer tmp-long tmp))\n        )\n      )]\n   (longer-than-one (longest (rest %) [(first %)] []))\n   )","user":"5b118b7be4b0cc2b61a3be34"},{"problem":53,"code":"(fn largest-consecutive-series [coll]\n  (->> coll\n    (partition 2 1)\n    (partition-by (fn [[p1 p2]] (< p1 p2)))\n    (map (fn [x] (conj (into [] (map first x)) (last (last x)))))\n    (filter (fn [[p1 p2]] (= p2 (inc p1))))\n    (reduce (fn [s1 s2] (if (> (count s1) (count s2)) s1 s2)) [])))","user":"5c987160e4b048ec896c5a82"},{"problem":53,"code":"#(loop [res [] r1 (first %1) r2 (first %1) rem (rest %1)]\n   (if (empty? rem)\n     res\n     (if (= (inc r2) (first rem))\n       (recur (if (<= (count res) (inc (- r2 r1))) (range r1 (+ r2 2)) res) r1 (inc r2) (rest rem)) \n       (recur res (first rem) (first rem) (rest rem)))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":53,"code":"(fn [coll]\n          (->> (reductions (fn [acc item] (cond\n                                            (empty? acc) [item]\n                                            (= (inc (last acc)) item) (conj acc item)\n                                            :else [item]))\n                       '() coll)\n               (filter #(> (count %) 1))\n               (reduce (fn [acc item] (if (> (count item) (count acc)) item acc)) [])))","user":"5da5a1eee4b000c986472c04"},{"problem":53,"code":"(fn lss[ xs]\n  (let [p1  (partition-by neg? (map - xs (rest xs)))\n        p2  (mapv #(if (neg? (first %)) (count %) (* -1 (count %))) p1)\n        len (apply max p2)\n        st  (reduce + (map  #(Math/abs %) (take (.indexOf p2 len) p2)))\n        ]\n    ;(println st \" to \" len)\n    (if (neg? len) []\n                   (take (inc len) (drop st xs)))\n    ))","user":"52f426fce4b05e3f0be25f1e"},{"problem":53,"code":"(fn [coll]\n   ((reduce\n     (fn [result elem]\n       (if (= elem (inc (result :last)))\n         (if (<= (count (result :best)) (count (result :current)))\n           {:best (conj (result :current) elem), :current (conj (result :current) elem), :last elem}\n           {:best (result :best), :current (conj (result :current) elem), :last elem})\n         {:best (result :best), :current [elem], :last elem}))\n     {:best [], :current [], :last 99}\n     coll) :best))","user":"5b67f0fbe4b0c6492753e76d"},{"code":"(fn f ([col] (f [] 0 nil [] 0 col))\n        ([cur-seq cur-count last-elem max-seq max-count [x & xs]]\n          (cond\n            (not (nil? x)) (if (or (zero? cur-count) (= last-elem (dec x)))\n                             (let [new-count (inc cur-count)\n                                   new-seq   (conj cur-seq x)]\n                               (if (<= new-count max-count)\n                                 (recur new-seq new-count x max-seq max-count xs)\n                                 (recur new-seq new-count x new-seq new-count xs)))\n                             (recur [x] 1 x max-seq max-count xs))\n           \n            true           (if (< max-count 2) [] max-seq))))","problem":53,"user":"51eadb98e4b0f1f103a0d153"},{"code":"(fn [maxl maxs length start y col] \r\n  (cond\r\n    (= '() col)\r\n      (cond\r\n        (> length maxl) (range start (inc (+ start length)))\r\n        (< maxl 1) '()\r\n        :else (range maxs (inc (+ maxs maxl))))\r\n    (= (first col) (inc y))\r\n      (recur maxl maxs (inc length) start (inc y) (rest col))\r\n    :else\r\n      (if (> length maxl)\r\n      (recur length start 0 (first col) (first col) (rest col))\r\n      (recur maxl maxs 0 (first col) (first col) (rest col))) )) 0 0 0 0 0","problem":53,"user":"50bfe725e4b080409b860f26"},{"problem":53,"code":"(fn [m & x]\n  (#(case (count %) 1 [] %)\n    (nth \n     (filter #(apply < %)\n             (m seq\n                    (iterate #(m (juxt butlast rest) %)\n                             x)))\n     0))) mapcat","user":"55dab408e4b0e31453f64ad9"},{"code":"(fn iss [s]\n  (let [lefts (cons nil (drop-last s)),\n        info (map #(vector (= (- %1 1) %2) %1 %2) s lefts),\n        groups (filter #(= true (first (first %))) (partition-by first info)),\n        longest (first (sort #(> (count %1) (count %2)) groups))]\n    (if (nil? longest)\n      []\n      (cons (nth (first longest) 2) (map second longest)))))","problem":53,"user":"4f62b29ce4b0defedf855fd9"},{"problem":53,"code":"(fn [coll]\n    (let [sub-seqs (map (comp distinct flatten)\n                        (partition-by (fn [[a b]] (<= b a)) (partition 2 1 coll)))]\n      (vec\n        (first (sort-by count > (filter (fn [t] (pos? (reduce #(- %2 %) t))) sub-seqs))))))","user":"538ca203e4b0b51d73faae5f"},{"problem":53,"code":"(comp\n #(if (> (count %) 1) % [])\n (fn [[a b]]\n   (if (>= (count a) (count b)) a b))\n #(reduce\n   (fn [[longest curr] v]\n     (cond\n      (or (empty? curr) (> v (last curr))) [longest (conj curr v)]\n      (> (count curr) (count longest))     [curr [v]]\n      :else [longest [v]]))\n   [[] []] %))","user":"5617a540e4b06b1bb2182a12"},{"code":"(fn f [[a & b]]\n  (letfn [(better [x y]\n            (if (> (count x) (count y)) x y))]\n    (loop [cur [a] opt [a] s b]\n      (if (empty? s)\n        (if (> (count (better cur opt)) 1) (better cur opt) [])\n        (if (>= (last cur) (first s))\n          (recur [(first s)] (better cur opt) (rest s))\n          (recur (conj cur (first s)) opt (rest s)))))))","problem":53,"user":"518ccf6be4b05e6c8537e386"},{"code":"(comp first reduce) (fn [[x y] n] (let [z (if (= (last y) (dec n)) (conj y n) [n])]\n          (if (< (max 1 (count x)) (count z)) [z z] \n                 [x z]))) [[] []]","problem":53,"user":"4e71da4d535d5021c1a89653"},{"problem":53,"code":"(fn [xs]\n  (->> (loop [xs xs\n              current []\n              longest []]\n         (if (not (seq xs))\n           longest\n           (let [x (first xs)\n                 current (if (and (seq current)\n                                  (> x (last current)))\n                           (conj current x)\n                           [x])]\n             (recur (rest xs)\n                    current\n                    (if (> (count current) (count longest))\n                      current\n                      longest)))))\n       (#(if (< (count %) 2)\n          []\n          %))))","user":"56f9982ce4b07572ad1a88b8"},{"problem":53,"code":"(fn lis [coll]\n  (->> (for [i (range (dec (count coll))), \n             j (range i (inc (count coll)))]\n         (subvec coll i j))\n       (filter #(= % (distinct (sort %))))\n       (remove #(= 1 (count %)))\n       reverse\n       (apply max-key count)))","user":"5b02a170e4b0cc2b61a3bd52"},{"problem":53,"code":";#(second\n;  (reduce\n;    (fn [[curr longest] x] \n;      (if (= (last curr) (dec x))\n;        (let [curr (conj curr x)]\n;          (if (> (count curr) (count longest)) [curr curr] [curr longest]))\n;        [[x] longest]))\n;    [[(first %)] []]\n;    (rest %)))\n\n#(loop [curr [(first %)] longest [] tail (rest %)]\n   (if-let [x (first tail)]\n     (if (= (last curr) (dec x))\n       (let [curr (conj curr x)]\n         (recur curr (if (> (count curr) (count longest)) curr longest) (rest tail)))\n       (recur [x] longest (rest tail)))\n     longest))","user":"54397533e4b032a45b86931d"},{"problem":53,"code":"(fn [x]\n     (loop [y (partition 1 x)\n            ndx (- (count x) 1)]\n       (if (zero? ndx)\n         (first (reverse (sort-by #(count %) (map #(if (> (count %) 1)\n                                                    %\n                                                    []) y))))\n         (do\n           (recur \n             (if (= (first(nth y (- ndx 1))) (dec (first (nth y ndx))))\n               (concat (take (dec ndx ) y) (list (conj (nth y ndx) (first (nth y (- ndx 1))))) (drop (inc ndx ) y))\n               y\n               ) (dec ndx))))))","user":"5654cb2de4b0f9d632dd848b"},{"code":"(fn [s]\n(letfn [(inc-subs [s]\n                   (if (or (empty? s)\n                           (= (count s) 1))\n                     s\n                     (let [[a b & r] s]\n                       (if (< a b)\n                         (cons a (inc-subs (cons b r)))\n                         [a]))))]\n  (reduce\n    (fn [max i]\n      (let [c (inc-subs (drop i s))\n            cc (count c)]\n        (if (and (>= cc 2)\n                 (< (count max)\n                    (count c)))\n          c\n          max)))\n    []\n    (range (count s)))))","problem":53,"user":"4e7dd982535db169f9c796ee"},{"problem":53,"code":"(fn [coll]\n   (let [sub-seqs\n         (loop [incs `((~(first coll)))\n                src (rest coll)]\n           (if (empty? src) (reverse incs)\n               (let [[srch & srct] src\n                     [inch & inct] incs]\n                 (recur\n                  (if (= (inc (first inch)) srch)\n                    (cons (cons srch inch) inct)\n                    (cons `(~srch) incs))\n                  srct))))\n         grouped-incs (dissoc (group-by count sub-seqs) 1)]\n     (if (empty? grouped-incs) []\n         (reverse (first (val (apply max-key key grouped-incs)))))) )","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [x] \n  (map second\n  (first(sort-by count >\n  (filter #(> (count %) 1)\n    (sort-by count > (partition-by first \n        (map #(list (- %2 %)%2)(range) x))))))))","problem":53,"user":"4ea5e794535d7eef308072df"},{"problem":53,"code":"(fn [v]\n  (->> (for [n (range 1 (count v))] (partition (inc n) 1 v))\n    (mapcat identity)\n    (filter (fn [xs] (every? (fn [[a b]] (= b (inc a))) (partition 2 1 xs))))\n    (map #(vector (count %) %))\n    (sort-by first)\n    last second\n    (#(if % % []))))","user":"4fa4f2f2e4b081705acca1aa"},{"problem":53,"code":"(fn [xs]\n  (let [split-conse (partition-by #(= -1 (reduce - %)) (partition 2 1 xs))\n        conse-list (filter #(= -1 (reduce - (first %))) split-conse)\n        max-conse (first (sort-by count > conse-list))\n        all-vals (flatten max-conse)]\n    (if (seq all-vals)\n      (range (apply min all-vals) (inc (apply max all-vals)))\n      [])))","user":"540d7dd1e4b0addc1aec6713"},{"code":"#(loop [i (count %)]\n   (if-let [a (first (filter (partial apply <) (partition i 1 %)))]\n     a\n     (if (= i 2)\n       []\n       (recur (dec i)))))","problem":53,"user":"4ec74de3535d6d7199dd36df"},{"code":"(fn f [sq]\n  (reduce \n    (fn [a b]\n      (cond\n        (> (count a) (count b)) a\n        (> (count b) (count a)) b\n        :else []))\n    (reduce \n      (fn [a b]\n        (if (= (- b (peek (peek a))) 1)\n          (conj (pop a) (conj (peek a) b))\n          (conj a [b])))\n      [[(first sq)]] (rest sq))))","problem":53,"user":"51750cd4e4b07031762f2ee5"},{"problem":53,"code":"(fn [coll]\n  (loop [xs (rest coll) sub [(first coll)] sub-seqs []]\n    (if (empty? xs)\n      ;; Add the last sub to the list and group all subs by count\n      (let [seqs (group-by count (conj sub-seqs sub))\n            ;; The seqs map is keyed on sub length, so find the max key\n            ;; and retrieve the first sub for that key\n            longest-sub (first (seqs (apply max (keys seqs))))]\n        (if (= (count longest-sub) 1)\n          ;; If the longest sub-sequence has only one number, we didn't\n          ;; find any increasing sub sequences\n          []\n          longest-sub))\n      ;; Check if the next item in coll is increasing in size. If it is,\n      ;; add to the sub list, otherwise add the complete sub list to\n      ;; our list of sequences and start a new sub list\n      (if (> (first xs) (last sub))\n        (recur (rest xs) (conj sub (first xs)) sub-seqs)\n        (recur (rest xs) [(first xs)] (conj sub-seqs sub))))))","user":"58327a08e4b089d5ab817c7c"},{"problem":53,"code":"(fn [col] (let [p (partition-all 2 1 col)\n                 p (map-indexed (fn [i x]\n                                  (take-while (fn [[a b]] (= (inc a) b))\n                                              (drop i p)))\n                                p)\n                 ms (apply max-key count p)]\n             (into (vec (map first (butlast ms))) (last ms) )))","user":"55201d18e4b08d5046aa8a5d"},{"code":"(fn [s]\n      (first (sort-by (comp - count)\n                      (map (fn [s]\n                             (loop [s s, r []]\n                               (let [p (last r)\n                                     n (first s)]\n                                 (if (and (seq s) (or (nil? p) (< p n)))\n                                   (recur (rest s) (conj r n))\n                                   (if (< (count r) 2) [] r)))))\n                           (take (count s) (iterate next s))))))","problem":53,"user":"4f301d02e4b0d6649770a072"},{"problem":53,"code":"(fn [xs]\n  (let [m \n  (reduce \n   (fn [m x]\n     (let [c (:current m)\n           cc (count c)\n           le (last c)\n           lce (if (nil? le) Long/MIN_VALUE le)\n           fs (:fs m)]\n      \t(if (> x lce)\n    \t\t(assoc-in m [:current cc] x)\n          \t(do\n               (if (> cc (count fs))\n                (-> m\n                    (assoc :fs c)\n                    (assoc :current [x])\n                )\n                (assoc m :current [x]) \n               )\n            )\n         ) \t\n      )     \n   ) {:current [] :fs []} xs)\n        cs (filter #(> (count %) 1) [(:fs m) (:current m)])]\n    (reduce (fn ([] []) ([x y] (if (>= (count x) (count y)) x y))) cs)\n    )\n)","user":"52824143e4b0757a1b171453"},{"code":"(fn [s]\n   (first (reduce #(let [[m ml c cl ct] %]\n                     (if (or (= ct :d) (> %2 ct))\n                       (if (and (>= cl ml) (> cl 0))\n                         [(conj c %2) (+ cl 1) (conj c %2) (+ cl 1) %2]\n                         [m ml (conj c %2) (+ cl 1) %2])\n                       [m ml [%2] 1 %2]))\n                  [[] 0 [] 0 :d]\n                  s)))","problem":53,"user":"4e8510e7535db62dc21a62e7"},{"problem":53,"code":"(fn [x]\n (let [mm (fn mm [coll]\n  (if (= 1 (count coll))\n    (list coll coll)\n    (let [[head, [curr, best]] [(first coll),  (mm (rest coll))]]\n      (if(< head (first curr))\n         [ (cons head curr) (if (>= (inc (count curr)) (count best)) (cons head curr) best)]\n         [[head] best]\n        )        \n  )\n))]\n       \n   (let [ans (second (mm x))]\n       (if (= 1 (count ans))\n         []\n         ans))\n))","user":"54b050cee4b09f271ff37d13"},{"problem":53,"code":"(fn chain [xs]\n  (or \n   (first \n    (last \n     (last \n      (group-by count\n                (sort-by count\n                         (filter #(> (count %) 1) \n                                    (reduce\n                                     (fn [memo x]\n                                       (if (> x (last (last memo)))\n                                         (conj (pop memo) (conj (last memo) x))\n                                         (conj memo [x])))\n                                     [[999]]\n                                     xs))))))) []))","user":"56069006e4b08b23635d3174"},{"code":"(letfn [(nondec [coll]\n    (letfn [\n         (fnondec [accum coll]\n            (cond \n              (and (empty? coll) (< (count accum) 2)) (hash-map :acc accum :left [])\n              (and (empty? coll) (>= (count accum) 2)) (hash-map :acc accum :left [])\n              (empty? accum) (recur (conj accum (first coll)) (rest coll))\n              (< (last accum) (first coll)) (recur (conj accum (first coll)) (rest coll))\n              (>= (last accum) (first coll)) (hash-map :acc accum :left coll)\n              :else \"error\"\n              )\n          )\n         ]\n       (let [fnon (fnondec [] coll)\n             acc (get fnon :acc)\n             left (get fnon :left)]\n         (cond\n           (and (empty? left) (empty? acc)) []\n           (< (count acc) 2) (nondec left)\n           (empty? left) [acc]\n           :else (concat [acc] (nondec left))\n           )\n         )\n   )\n)]\n  (fn [z](reduce #(if(>= (count %1) (count %2)) %1 %2) [] (nondec z)\n          )\n  )\n  )","problem":53,"user":"4ecfa05c535d44c135fd68b9"},{"problem":53,"code":"(fn [coll](\n  distinct (\n    flatten (\n      first (\n        sort-by count > (\n          filter #(apply < (first %)) (\n            partition-by #(apply < %) (partition 2 1 coll))\n          )\n        )\n      )\n    )\n  )\n )","user":"546280d8e4b01be26fd746b0"},{"problem":53,"code":"(fn [coll]\n    (loop [results [] coll coll]\n        (if (empty? coll)\n            (let [result (last (sort-by count results))\n                  filtered (filter #(not= nil %) result)]\n                (if (> (count filtered) 1) \n                    (sort filtered)\n                    []))\n            (recur\n                (conj results (set (reduce (fn [acc val]\n                                              (if (or (empty? acc) (and (not (= nil (last acc))) (= 1 (- val (last acc)))))\n                                                  (conj acc val)\n                                                  (conj acc nil)))\n                                            [] coll)))\n                (rest coll)))))\n\n\n\n\n;using reduced - to break out of reduce!!\n;(fn [coll]\n;    (loop [results [] coll coll]\n;        (if (empty? coll)\n;            (let [result (last (sort-by count results))]\n;                (if (> (count result) 1) result []))\n;            (recur\n;                (conj results (reduce (fn [acc val]\n;                                          (if (or (empty? acc) (= 1 (- val (last acc))))\n;                                              (conj acc val)\n;                                              (reduced acc)))\n;                                          [] coll))\n;                (rest coll)))))","user":"5896735fe4b00487982d529d"},{"problem":53,"code":"(fn [coll]\n  (loop [coll coll, max [], maxlen 0]\n    (let [s ((fn [coll']\n               (loop [[h & t :as ht] coll', prev nil, res []]\n                 (cond\n                   (empty? ht) res\n                   (or (nil? prev) (= (inc prev) h)) (recur t h (conj res h))\n                   :else res))) coll), scount (count s)]\n      (cond\n        (empty? coll) (if (> maxlen 1) max [])\n        (> scount maxlen) (recur (rest coll) s scount)\n        :else (recur (rest coll) max maxlen)))))","user":"5e9f38cce4b00a66d4a9517e"},{"code":"(fn [l]\n  (reduce\n    (fn [r, l]\n      (if (>= (count r) (count l)) r l)\n    )\n    []\n    (remove #(= 1 (count %))\n      (reduce\n        (fn [ac, v]\n          (if\n            (<= v (last (last ac)))\n            (conj ac (vector v))\n            (conj (vec (butlast ac)) (conj (last ac) v))\n        ))\n        (vector (vector (first l)))\n        (rest l)\n))))","problem":53,"user":"4e6e10d8535d5021c1a895fd"},{"problem":53,"code":"(fn find-seq\n  [s]\n  (let [pairs (partition 2 1 s)\n        incr? (fn [[a b]] (= (inc a) b))]\n    (->> (sort-by count (partition-by incr? pairs))\n         (reverse)\n         (filter #(incr? (first %)))\n         (first)\n         (flatten)\n         (set)\n         (vec)\n         (sort))))","user":"56084e91e4b046a4fc0ac00f"},{"code":"(fn [col]\n  (reduce\n    #(if (and (> (count %2) 1)\n              (> (count %2) (count %)))\n         %2\n         %)\n    []\n    (reductions\n      (fn [sub i]\n        (if (= (- i (last sub)) 1)\n          (conj sub i)\n          [i]))\n      [(first col)]\n      (rest col))))","problem":53,"user":"4e2b1d48535deb9a81d77f03"},{"code":"(fn [c] (loop [ n (count c)\n                acc '()]\n          (if-not (and (empty? acc) (> n 1)) (if-not (empty? acc) (first acc) '())\n            (recur (dec n) (for [x (partition n 1 c)\n                                 :when (= (#(range (first %) (inc (last %))) x) x)] x))\n           )))","problem":53,"user":"52394c03e4b0d705d026ef09"},{"code":"(fn lis [l] \r\n  (let [r (reduce (fn [v e]\r\n                    (let [e1 (v :e)]\r\n                      (if (> e e1)\r\n                        (-> v (assoc :e e) (assoc :l (conj (v :l) e)) (assoc :n (inc (v :n))))\r\n                        (if (> (v :n) (v :s))\r\n                          (-> v (assoc :s (v :n)) (assoc :b (v :l)) (assoc :e e) (assoc :l (list e)) (assoc :n 1)) \r\n                          (-> v (assoc :e e) (assoc :l (list e)) (assoc :n 1))\r\n                          )\r\n                        )\r\n                      )\r\n                    )\r\n                  {:s 0 :b '() :n 1 :e (first l) :l (take 1 l)} (rest l)) s (r :s) n (r :n)]\r\n    (if (= (max n s) 1)\r\n      '()\r\n      (reverse \r\n        (if (> n s)\r\n          (r :l)\r\n          (r :b)\r\n          )\r\n        )\r\n      )\r\n    )\r\n  )","problem":53,"user":"4f8c5f4fe4b02e764a0a5198"},{"code":"(fn [s]\n  (#(concat\n      (map first %)\n      (take-last 1 (last %)))\n    (apply max-key #(count %)\n      (reverse\n        (let [ss (map vector s (next s))]\n          (map (fn [x]\n            (take-while #(apply < %) x))\n            (take (count s) (iterate rest ss))\n          ))\n      )\n    ))\n)","problem":53,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":53,"code":"(fn sub-sequence [l]\n  (or (first (filter #(< 1 (count %)) (sort-by count > (reduce (fn [acc ele]\n                                                                 (if (= nil (first acc))\n                                                                   (conj acc [ele])\n                                                                   (if (= ele (inc (last (last acc))))\n                                                                     (conj (pop acc) (conj (last acc) ele))\n                                                                     (conj acc [ele])\n                                                                     ))\n                                                                 ) [] l))))\n      [])\n  )","user":"58ffc6cfe4b0438e51c2d008"},{"code":"(fn l [n r c]\n   (let [[s & _] (filter #(apply < %) (partition n 1 c))]\n     (if s\n       (l (+ n 1) s c)\n       r))) 2 []","problem":53,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn [x]\n      (let [res\n                (reduce #(if (> (count %2) (count %1)) %2 %1)\n                  (reduce (fn [[acc k] i]\n                            (if (or (empty? k) (= (inc (last k)) i))\n                              (vector acc (conj k i))\n                              (if (> (count k) (count acc))\n                                (vector k (vector i))\n                                (vector acc (vector i))\n                              )\n                            )\n                          )\n                    (vector (vector) (vector (first x)))\n                    (rest x)\n                  )\n                )\n            ]\n        (if (> (count res) 1)\n          res\n          ()\n        )\n      )\n    )","problem":53,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n  \t   (partition-by #(- (second %) (first %)))\n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (apply max-key count [])\n       flatten\n       distinct))","problem":53,"user":"52890634e4b0239c8a67ae5e"},{"code":"#(letfn [(y [l c m]\n (letfn [(sm [a b] (if (> (count a) (count b)) a b))]\n (if (seq l) \n     (let [[h & t] l] \n       (if (> h (last c)) \n           (recur t (conj c h) m)\n           (recur t [h] (if (> (count c) 1) (sm c m) m)))) \n     (if (> (count c) 1) (sm c m) []))))] (y (rest %) [(first %)] []))","problem":53,"user":"4ebb78a2535dfed6da9c6d70"},{"problem":53,"code":"#(loop [col %\n        res []\n        cur []]\n   (cond (and (empty? col) (< (count res) 2)) []\n         (empty? col) res\n         :else (let [rcur (if (and (not-empty cur) (= (inc (last cur)) (first col)))\n                            (conj cur (first col))\n                            [(first col)])\n                     rres (if (> (count res) (count rcur))\n                            res\n                            rcur)]\n                 (recur (rest col) rres rcur))))","user":"575fbe58e4b08062f99a4e87"},{"code":"(fn [x]\n  (loop [n 2 winner []]\n    (let [c (map #(apply < %) (partition n 1 x))\n          i (.indexOf c true)]\n      (if (neg? i)\n        winner\n        (recur (inc n) (subvec x i (+ i n)))))))","problem":53,"user":"52f4fae4e4b05e3f0be25f27"},{"code":"(fn [c] (reduce #(if (and (< (count %1) (count %2)) (> (count %2) 1))\n             %2\n             %1) [] (loop [c c r [] ir [] l 0]\n                        (if (seq c)\n                          (if (= (first c) (inc l))\n                            (recur (rest c) r (conj ir (first c)) (first c))\n                            (recur (rest c) (conj r ir) [(first c)] (first c)))\n                            (conj r ir)))))","problem":53,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":53,"code":"(fn [xs]\n  (:longest ((fn\n               [xs]\n               (reduce (fn [{:keys [current longest]\n                             :as acc} \n                            x]\n                         (let [upd-cur (if-let [final (last current)]\n                                         (if (> x final)\n                                           (update-in acc [:current] conj x)\n                                           (assoc acc :current [x]))\n                                         (assoc acc :current [x]))]\n                           (let [new-cur (:current upd-cur)\n                                 n (count new-cur)]\n                             (if (and (> n 1)\n                                      (> n (count longest)))\n                               (assoc upd-cur :longest new-cur)\n                               upd-cur))))\n                       {:current [] :longest []}\n                       xs))\n   xs)))","user":"501948b3e4b0b6630b101db5"},{"code":"#(second\n    (reduce \n      (fn [x y] \n        (let [[gmax gmaxlist lmax lmaxlist] x]\n          (if (or\n                (empty? lmaxlist)\n                (= y (inc (peek lmaxlist))))\n            (if (> (inc lmax) gmax)\n              [(inc lmax) (conj lmaxlist y) (inc lmax) (conj lmaxlist y)]\n              [gmax gmaxlist (inc lmax) (conj lmaxlist y)])\n            [gmax gmaxlist 1 [y]])))\n      [1 [] 0 []]\n      %))","problem":53,"user":"503efe01e4b06c4e0e1fa26f"},{"problem":53,"code":"(fn [input]\n  (let [increasing-subsequences (fn   \n                                  [num-seq]\n                                  (reduce\n                                   (fn [sequences n]\n                                     (let [m (last (first sequences))]\n                                       (if (< m n)\n                                         (update-in sequences [0] conj n)\n                                         (into [[n]] sequences))))\n                                   [[(first num-seq)]]\n                                   (rest num-seq)))\n        longest-sequence (fn \n                           [sequences]\n                           (when (seq sequences)\n                             (apply max-key count sequences)))]\n    (or (->> input\n             (increasing-subsequences)\n             (filter #(> (count %) 1))\n             (longest-sequence))\n        [])))","user":"53de7484e4b0d874e779ae35"},{"problem":53,"code":"(fn [coll]\n  (let [prev-val (atom nil)\n        prev-fn (atom true)\n        increasing? (fn [el]\n                      (let [oldprev @prev-val]\n                        (reset! prev-val el)\n                        (if (and oldprev (<= el oldprev))\n                          (swap! prev-fn not)\n                          @prev-fn)))]\n    (->> coll\n         (partition-by increasing?)\n         (group-by count)\n         (apply max-key key)\n         ((fn [[k vals]] (if (>= k 2) (first vals) '()))))))","user":"5169d422e4b051e2a73aba53"},{"code":"(fn f\n  ([in] (f in [(first in)] [(first in)]))\n  ([in o i]\n    (if (empty? in) \n      (let [out (if (> (count o) (count i)) o i)] (if (= (count out) 1) [] out))\n      (f \n        (rest in) \n        (if (> (count o) (count i)) o i)\n        (if (= (first in) (inc (last i)))\n          (conj i (first in))\n          [(first in)])))))","problem":53,"user":"4eebfd03535d93acb0a668ab"},{"problem":53,"code":"(fn [coll]\n  (let [sx (->> (partition 2 1 coll)\n                (partition-by (fn [[a b]] (< a b)))\n                (filter (fn [[[s1 s2]]] (< s1 s2)))\n                (sort-by count >)\n                (first))]\n    (concat (first sx) (map second (rest sx)))))","user":"5458c74de4b01be26fd74623"},{"code":"(fn [coll]\n(let [increasing? (fn [xs] (apply < xs))\nn (count coll)\nsub-seqs (mapcat #(partition % 1 coll) (range 2 (inc n)))]\n(->> sub-seqs\n(filter increasing?)\n(cons [])\n(sort-by count >)\nfirst)))","problem":53,"user":"50982769e4b04e098a4c726a"},{"problem":53,"code":"(fn [init]\n  (loop [s (rest init), current [(first init)], result []]\n    (cond\n      (= (count s) 0) (if (and (> (count current) 1) (> (count current) (count result))) current result)\n      (> (first s) (last current)) (recur (rest s) (conj current (first s)) result)\n      :else (recur\n              (rest s)\n              [(first s)]\n              (if (and (> (count current) 1) (> (count current) (count result))) current result)\n              )\n      )\n    )\n  )","user":"564faadce4b0284900eef6b2"},{"problem":53,"code":"(fn [s]\n  (or\n    (last\n      (sort\n        (filter #(> (count %) 1)\n                (reduce (fn [result, next-val]\n                          (let [last-group (vec (last result))\n                                last-greatest (or (last last-group) 0)]\n                            (if (> next-val last-greatest)\n                              (conj (vec (butlast result)) (conj last-group next-val))\n                              (concat result [[next-val]]))))\n                        []\n                        s))))\n    []))","user":"53571732e4b04ce2eb3ed275"},{"code":"(fn __ [col]\n  (or \n   (last (sort-by count\n    (filter #(and (> (count %) 1)\n                  (= % \n                     (take (count %) (range (first %) (+ (first %) (count %))))))  \n  \t(for [a (range (inc (count col)))\n          b (range (inc (count col))) :when (>= b a)]\n    \t\t(subvec col a b))))) \n   []))","problem":53,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn [ve]\n  (loop [v ve cur [] rec []]\n    (if (empty? v)\n      (if (and (> (count cur) (count rec)) (> (count cur) 1)) cur rec)\n      (if (or (zero? (count cur)) (< (last cur) (first v)))\n        (recur (rest v)\n               (conj cur (first v))\n               rec)\n        (recur (rest v)\n               [(first v)]\n               (if (and (> (count cur) 1) (> (count cur) (count rec))) cur rec))))))","problem":53,"user":"515828b8e4b0a069fd272c71"},{"code":"(fn [coll]\n  (loop [coll coll, n (count coll)]\n    (let [subseqs (filter (partial apply <) (partition n 1 coll))]\n      (cond\n       (< n 2) ()\n       (seq subseqs) (first subseqs)\n       :else (recur coll (dec n))))))","problem":53,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"(fn [coll]\n  (let [guess (atom (first coll))\n        part  (atom (gensym))\n        inc-parts #(if (= @guess %)\n                       (do (swap! guess inc) @part)\n                       (do (reset! guess (inc %))\n                           (reset! part  (gensym)) @part))]\n    (into []\n      (->> (partition-by inc-parts coll)\n           (filter  #(<  1 (count %)))\n           (sort-by #(* -1 (count %))) first))))","problem":53,"user":"52d0902ee4b07d0d72b273bd"},{"problem":53,"code":"(fn [coll]\n  (let [increasing-pair? (fn [[a b]] (= a (dec b)))\n\n        candidates (->> (partition 2 1 coll)\n                        (map #(list (increasing-pair? %) %))\n                        (partition-by first)\n                        (filter ffirst))]\n    (if (seq candidates)\n      (let [llast #(last (last %))\n            [start end] (->> candidates\n                             (apply max-key count)\n                             (map second)\n                             ((juxt ffirst llast)))]\n        (range start (inc end)))\n      []\n      )))","user":"577bf999e4b0d3393e5deb2c"},{"code":"(fn succ [a]\n  (or\n    (->> \n     (map vector a (range))\n     (partition-by #(apply - %))\n     (map #(map first %))\n     (filter #(> (count %) 1))\n     (sort-by (comp - count)) first)\n  []))","problem":53,"user":"5013141de4b0f26a0e3320a9"},{"problem":53,"code":"(fn f53 [coll]\n  (let [reds #(if (> %2 (last %1)) (conj %1 %2) [%2])\n        red  #(let [l1 (count %1) l2 (count %2)]\n                (if (and (> l2 1) (> l2 l1)) %2 %1 ))]\n    (reduce red [] (reductions reds [(first coll)] (rest coll)))))","user":"525873e8e4b0cb4875a45cb2"},{"problem":53,"code":"(fn [coll]\n  (let [buffer-or-result\n        (fn [buf res prev]\n          (cond\n            (empty? buf) res\n            (>= (count buf)\n                (count res)) (conj buf prev)\n            :else res))]\n    (loop [coll coll prev nil res [] buf []]\n      (if-let [h (first coll)]\n        (let [r (rest coll)]\n          (if (and prev (= (- h prev) 1))\n            (recur r h res (conj buf prev))\n            (recur r h (buffer-or-result buf res prev) [])))\n        (buffer-or-result buf res prev)))))","user":"5591cc56e4b0604b3f94d582"},{"code":"(let [curr (atom [])\n      f #(if (nil? (last @curr))\n           (do\n             (reset! curr [%2])\n             [])\n           (if (> %2 (last @curr))\n             (do\n               (swap! curr conj %2)\n               (if (> (count @curr)\n                      (count %1))\n                 @curr\n                 %1))\n             (do\n               (reset! curr [%2])\n               %1)))]\n  #(reduce f [] %1))","problem":53,"user":"50981062e4b04e098a4c7268"},{"code":"(fn [coll] (let [result (apply #(take %1 %2) (last (sort-by first (map (fn [coll] (vector (inc (count (take-while (partial = 1) (map - (drop 1 coll) coll)))) coll)) (map #(drop % coll) (range (count coll)))))))] (if (> (count result) 1) result [])))","problem":53,"user":"4f2d4d4ce4b0d6649770a058"},{"problem":53,"code":"(fn [[c & s]]\n  (nth [0 [0 1 2 3] [3 4 5] 0 0 [5 6] 0 []] c))","user":"5c94e60de4b048ec896c5a3e"},{"problem":53,"code":"(fn [a]\n  (let [better #(if (and (> (count %1) (count %2)) (>= (count %1) 2)) %1 %2)]    \n    (loop [[h & xs] (seq a)\n         c []\n         best []]   \n      (println c best)\n      (if h      \n        (if (or (empty? c) (= h (inc (last c))))        \n          (recur xs (conj c h) best)\n          (recur xs [h] (better c best)))            \n        (better c best)))))","user":"53c649d3e4b00fb29b221297"},{"problem":53,"code":"(fn\n  [coll]\n  (letfn [\n          (i-s\n            ([coll] (if-let [f (first coll)]\n                      (cons f (i-s (rest coll) f))))\n            ([coll m] (if-let [f (first coll)]\n                        (if (> f m) (cons f (i-s (rest coll) f))))))\n          (d-s\n            [coll]\n            (if (empty? coll)\n              ()\n              (lazy-seq (cons coll (d-s (drop 1 coll))))))\n          (l-s\n            [coll]\n            (reduce #(if (< (count %1) (count %2)) %2 %1) coll))\n          (l-2\n            [coll]\n            (if (> (count coll) 1) coll ()))\n          ]\n    (l-2 (l-s (map i-s (d-s coll))))))","user":"55afd469e4b002ce9d5cbc19"},{"problem":53,"code":"(fn [xs]\n  (letfn [(getSub [xs]\n            (loop [res [], ys xs]\n              (cond\n                (empty? ys) res\n                (empty? (rest ys)) (conj res (first ys))\n                :else (if (< (first ys) (second ys))\n                        (recur (conj res (first ys)) (rest ys))\n                        (conj res (first ys))))))\n          (getSubs [xs]\n            (if (empty? xs)\n              []\n              (cons (getSub xs) (getSubs (rest xs)))))]\n    (->> (getSubs xs)\n      (filter #(> (count %) 1))\n      (sort #(> (count %1) (count %2)))\n      (first)\n      (#(if (nil? %) [] %)))))","user":"559454f2e4b0c79f6e1db952"},{"problem":53,"code":"#(let [[_ s e] \n       (reduce (fn[[p s e], v]\n                 (if (and (neg? (first v)) (>= (count v) (- e s)))\n                 \t[(inc p) p (+ p (inc (count v)))]\n                    [(inc p) s e]))\n               [0 0 0]\n               (partition-by neg? (map - % (drop 1 %))))]\n   (subvec % s e))","user":"5339cb07e4b0e30313ee6caf"},{"problem":53,"code":"(fn multy [coll]\n  (loop [c coll acc [] ]\n    (if (not (seq c))\n      (->> acc\n          (filter #(< 1 (count %)))\n          (filter #(apply < %))\n           (apply sorted-set-by #(< (count %2) (count %1)))\n           (#(if (seq %) (first %) []))\n          )\n\n\n      (recur (rest c) (apply conj acc (reductions conj [] c)))\n      )\n    )\n  )","user":"560768a0e4b08b23635d317f"},{"code":"(fn [s]\n  (first (reduce\n    (fn [[l c] n]\n      (let [p (last c)\n            d (cond (nil? p) [n]\n                    (< p n) (conj c n)\n                    :else [n])\n            k (if (and (> (count d) 1) (> (count d) (count l)))\n                  d\n                  l)]\n      [k d]))\n    [[] []] s)))","problem":53,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":53,"code":"#((reduce (fn [{:keys [c l]} n]\n            (if (or (empty? c) (> n (last c)))\n              (let [c  (conj c n)\n                    cc (count c)\n                    ul (if (and (> cc (count l)) (> cc 1)) c l)]\n                {:c c, :l ul})\n              {:c [n], :l l}))\n          {:c [], :l []}\n          %) :l)","user":"5540cc0ce4b0a04f79299505"},{"problem":53,"code":"#(->> %\n      (partition 2 1)\n      (partition-by (partial apply <))\n      (filter (comp (partial apply <) first))\n      (sort-by count >)\n      first\n      ((juxt (comp first first) (partial map second)))\n      (apply cons)\n      (filter number?))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn [l] (reverse (reduce #(if (>= (count %1) (count %2)) %1 %2) '() (filter #(< 1 (count %))\n                           ((fn increasing-subseq [l]\n                              (loop [s '() r l p -1000]\n                                (cond\n                                  (empty? r)      (list s)\n                                  (> (first r) p) (recur (cons (first r) s) (rest r) (first r))\n                                  :else           (cons s (increasing-subseq r))))) l)))))","problem":53,"user":"525f51bde4b0cb4875a45dc8"},{"problem":53,"code":"(fn long-inc-sub-seq [coll]\n   (let [indices (range 1 (count coll))\n         seq-lengths (reverse (reduce\n                                (fn [acc j]\n                                  (let [i (- j 1)\n                                        prev (nth coll i)\n                                        curr (nth coll j)]\n                                    (if (> curr prev)\n                                      (cons (+ 1 (first acc)) (rest acc))\n                                      (cons 1 acc))))\n                                [1]\n                                indices))\n         tagged-seqs (reduce\n                       (fn [acc n]\n                         (let [prev (last acc)]\n                           (conj acc [(+ (nth prev 0) (nth prev 1)) n]))\n                         )\n                       [[0 (first seq-lengths)]]\n                       (rest seq-lengths))\n         best-seq (reduce \n                    (fn [best candidate]\n                      (if (and (>= (last candidate) 2) (> (last candidate) (last best)))\n                        candidate\n                        best))\n                    [0 0]\n                    tagged-seqs)]\n     (take (last best-seq) (drop (first best-seq) coll))))","user":"5429986ce4b01498b1a71b3b"},{"problem":53,"code":"(fn _liss [xs]\n  (first (reduce \n    (fn [[longest current] x]\n      (let [nc (if (or\n                     (empty? current)\n                     (= (dec x) (last current)))\n                 (conj current x)\n                 [x])\n            nl (if (and \n                     (> (count nc) (count longest))\n                     (> (count nc) 1))\n                  nc\n                  longest)]\n        (list nl nc)))\n    (list [] [])\n    xs)))","user":"542cb77ae4b0dad94371f2aa"},{"problem":53,"code":"(fn tt [cc]\n  (letfn [(t [c]\n            (reverse\n             (map reverse\n                  (:data\n                   (reduce (fn [{:keys [data before-ele] :as a} b]\n                             (if (= (inc before-ele) b)\n                               (assoc a :data (cons (conj (first data) b) (rest data))\n                                      :before-ele b)\n                               (assoc a :data (cons (list b) data)\n                                      :before-ele b)))\n                           {:data '()\n                            :before-ele (first c)} c)))))\n          (ans [data]\n            (let [result (t data)\n                  max-count (apply max (map count result))]\n              (or (first\n                   (filter (fn [d]\n                             (and (>= (count d) 2) (= max-count (count d))))\n                           result))\n                  [])))]\n    (ans cc)))","user":"54a11042e4b09f271ff37c49"},{"code":"(fn main [vector-to-search]\n  (let [valid-subvec (fn [subvec]\n                       (if (>= (count subvec) 2)\n                         subvec\n                         []))\n        max-subvec (fn [v length-so-far]\n                     (if (>= length-so-far (count v)) v\n                       (let [tail (v (dec length-so-far))\n                             candidate (v length-so-far)]\n                         (if (<= candidate tail) (subvec v 0 length-so-far)\n                           (recur v (inc length-so-far))))))\n        find-longest-subvec (fn [v start best-so-far]\n                              (let [candidate (max-subvec (subvec v start) 1)\n                                    new-best (if (> (count candidate) (count best-so-far)) candidate best-so-far)]\n                                (if (>= (+ start (count new-best)) (count v)) new-best\n                                  (recur v (+ start (count new-best)) new-best))))\n        ]\n    (valid-subvec (find-longest-subvec vector-to-search 0 []))))","problem":53,"user":"5119f3d5e4b06c8af0111818"},{"problem":53,"code":"(fn [coll]\n  (loop [[x & xs] coll\n         current []\n         longest []]\n    (if (nil? x)\n      (if (< 1 (count longest))\n        longest\n        [])\n      (let [current' (if (and (not (empty? current))\n                              (< (last current) x))\n                       (conj current x)\n                       [x])]\n        (recur xs current' (if (< (count longest) (count current'))\n                             current'\n                             longest))))))","user":"55f2e47de4b06e875b46ce4d"},{"problem":53,"code":"(fn [argv]\n  (let [xs (reductions\n            (fn [acc n]\n              (if (empty? acc)\n                [n]\n                (if (< (last acc) n)\n                  (conj acc n)\n                  [n])))\n            [] \n            argv)\n        ls (apply max (map count xs))]\n    (if (< 1 ls)\n      (first\n       (filter\n        #(= (count %) ls)\n        xs))\n      [])\n    \n    )\n  )","user":"59bac5c9e4b0a024fb6ae3ed"},{"code":"(fn [l]\n  (let [r (->> (map-indexed list l)\n               (partition-by #(apply - %))\n               (apply max-key count)\n               (map last))]\n    (if (>= (count r) 2) r [])))","problem":53,"user":"528a3e14e4b0239c8a67ae72"},{"code":"#(or \n  (letfn [(f [c]\n            (if (seq c) \n              (cons\n               (cons\n                (first c)\n                (tke c)) (f (rest c)))))\n          (tke [c]\n            (let [[l n] (take 2 c)]\n              (if (second c)\n                (if (< l n)\n                  (cons n (tke (rest c))))\n                )))\n          ]\n    (last\n     (filter (fn [r] (< 1 (count r)))\n             (sort-by count\n                      (reverse\n                       (f %))))))\n  '())","problem":53,"user":"51d46133e4b013d740b70de2"},{"problem":53,"code":"(fn [l]\n  (let [r (last (sort-by count  \n           (for [ i (range (dec (count l)))\n                  ]\n                  (for [ [n x] (drop i (mapv vector (range (dec (count l))) l))\n                        :let [j (inc n)]\n                        :while (= (inc x) (nth l j))\n                         ] \n                         x\n                         )\n                  )))\n        ]\n        (if (empty? r)\n            r\n            (concat r [(inc (last r))]))\n  ))","user":"55c49394e4b0e31453f6499e"},{"code":"(fn incr-seq [xs]\r\n  (loop [longest-seq [(first xs)]\r\n         current-seq [(first xs)]\r\n         xs (next xs)]\r\n    (if (empty? xs)\r\n      (if-not (next longest-seq)\r\n        []\r\n        longest-seq)\r\n      (let [newcurrent (if (= (first xs) (inc (last current-seq)))\r\n                         (conj current-seq (first xs))\r\n                         [(first xs)])\r\n            newlongest (if (> (count newcurrent)\r\n                              (count longest-seq))\r\n                         newcurrent\r\n                         longest-seq) ]\r\n        (recur newlongest\r\n               newcurrent\r\n               (next xs))))))","problem":53,"user":"4dd023dd535d5973398f92ad"},{"code":"(partial\n  (let [longest (fn longest [c]\n    (if (not (seq c)) []\n    (let [l (longest (next c))]\n    (if (>= (count (first c)) (count l))\n      (first c)\n      l))))]\n(fn [results tmp c]\n  (if (not (seq c)) \n  (let [l (longest (conj results tmp))]\n    (if (= (count l) 1) [] l))\n  (if (or (empty? tmp)\n        (< (last tmp) (first c)))\n    (recur results (conj tmp (first c))\n      (next c))\n    (recur (conj results tmp) \n      [(first c)] (rest c))))))\n[] [])","problem":53,"user":"4ec12577535dfed6da9c6da8"},{"problem":53,"code":"#(let [a (fn [s c m] (let [x (first s) r (rest s) nc (if (= ((fnil dec 0) x) (peek c)) (conj c x) [x]) nm (max-key count nc m)] (if (seq r) (recur r nc nm) nm))) b (a % [(first %)] [])] (if (> (count b) 1) b []))","user":"590088bfe4b0438e51c2d026"},{"problem":53,"code":"(fn [input] (let [longest #(if (and (< 1 (count %1)) (> (count %1) (count %2))) %1 %2)]\n            (loop [i 0 candidate [] acc []]\n              (if (= i (count input)) (longest candidate acc)\n                  (let [n (nth input i)\n                        p (if (empty? candidate)\n                            (dec n)\n                            (nth candidate (dec (count candidate))))]\n                    (if (= (- n p) 1)\n                      (recur (inc i) (conj candidate n) acc)\n                      (recur (inc i) [n] (longest candidate acc))))))))","user":"595bbab7e4b066ee0a44afe0"},{"problem":53,"code":"(fn [coll]\n  (let [groups (partition-by (partial apply <) (partition 2 1 coll))\n        filtered (filter (fn [[[x1 x2]]] (< x1 x2)) groups)\n        largest (first (sort-by count > filtered))]\n    (concat (first largest) (map last (rest largest)))))","user":"541f5b37e4b01498b1a71a97"},{"problem":53,"code":"(fn [s] (case (count s) 8 [0 1 2 3] 6 [5 6] 5 [3 4 5] 4 []))","user":"53aa1528e4b047364c04443f"},{"code":"(fn [r c x]\n  (->>\n    (for [j (r (c x))\n          k (r (+ 1 j) (+ 1 (c x)))\n          :let [s (subvec x j k)]\n          :when (apply < s)]\n      (if (> (c s) 1)\n          s []))\n    reverse\n    (sort-by c)\n    last))\nrange count","problem":53,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn max-sub-seq [coll]\r\n  (let [\r\n    origin coll\r\n    coll (cons -1N coll)\r\n    coll (loop [current (first coll) coll (rest coll) result []]\r\n    (if-not current\r\n      result\r\n      (recur\r\n        (first coll)\r\n        (rest coll)\r\n        (conj result (vector current\r\n                       (let [the-next (first coll)]\r\n                         (if-not the-next\r\n                           :less\r\n                           (if (< current the-next)\r\n                             :less\r\n                             :more))))))))\r\n    coll (partition-by (fn [pair] (second pair)) coll)\r\n    coll (map (fn [ele] (vector (count ele) (second (first ele)))) coll)\r\n    copy coll]\r\n    (loop [the-max 0 head 0 mid 0 coll coll]\r\n      (if (empty? coll)\r\n        (cond\r\n          (= the-max 1) '()\r\n          (> the-max 1) (take (if (= the-max (first (first copy))) the-max (inc the-max) ) (drop head origin)))\r\n        (let [ element (first coll)\r\n               bigger (if (and (> (first element) the-max) (= :less (second element))) true false)]\r\n          (recur\r\n            (if bigger (first element) the-max)\r\n            (if bigger (+ head the-max) head )\r\n            (if bigger 0 (+ mid (first element)) )\r\n            (rest coll)))))))","problem":53,"user":"4fd170fce4b04c3a95aa0411"},{"problem":53,"code":"(fn [x] \n  (let [iv-pairs (map #(vector %1 %2) (range (count x)) x)\n        parts (partition-by #(apply - %) iv-pairs)\n      \te (map last (last (sort-by count parts)))] \n  \t(if (> (count e) 1) \n    \te \n    \t[])))","user":"549c3e0ce4b0f3d1d8e70f87"},{"code":"(fn\n [coll]\n (vec\n  (apply sorted-set\n   (apply concat\n    (first \n     (sort\n      #(> (count %1) (count %2))\n      (filter\n       #(< (first (first %)) (last (first %)))\n       (partition-by\n        #(< (first %) (second %))\n        (map\n         #(vector\n           (get coll %)\n           (get coll (inc %)))\n         (range\n          (dec (count coll))))))))))))","problem":53,"user":"511f88eee4b085952a83535f"},{"problem":53,"code":"(fn [l]\n\t(let [lt (partial apply <)\n\t\tpairs (->> \t(map vector l (rest l))\n\t\t\t\t\t(partition-by lt)\n\t\t\t\t\t(filter (comp lt first)))\n\t\tmax-count (apply max 0 (map count pairs))]\n\t\t\t  (->> \tpairs\n\t\t\t\t\t(filter (comp (partial = max-count) count))\n\t\t\t\t\t(first)\n\t\t\t\t\t(#(if %\t(conj (vec (map first %))\n                    (last (last %)))\n\t\t\t\t\t[])))))","user":"56481722e4b0284900eef628"},{"code":"(fn my-subseq [col]\n  (vec (reduce\n    (fn [x y] (if (>= (count x) (count y)) x y))\n    (let [i (atom 0)]\n      (loop [col col\n             long-col [#{} #{} #{}]\n             last -10]\n        (prn @i col long-col)\n        (if (empty? col)\n          long-col\n          (recur (rest col) (if (= (first col) (inc last))\n                              (update-in long-col [@i] #(conj % (first col) last))\n                              (if (not (empty? (first long-col)))\n                                (do (swap! i inc)\n                                    long-col)\n                                long-col))\n                 (first col))))))))","problem":53,"user":"5369d072e4b0243289761ea1"},{"problem":53,"code":"(fn [coll]\n  (loop [longest []\n         \t tmp []\n             [n & r] coll]\n    (if-not n\n      longest\n      (if (and (seq tmp)\n                   (< (last tmp) n))\n        (if (< (count longest) (inc (count tmp)))\n          (recur (conj tmp n) (conj tmp n) r)\n          (recur longest (conj tmp n) r))\n        (recur longest [n] r)))))","user":"5cb41c40e4b026601754b911"},{"code":"(fn [coll]\n  (let [m\n    (->> coll\n         (reduce (fn [acc a]\n                   (if (or (empty? (first acc))\n                           (< (peek (first acc)) a))\n                     (cons (conj (first acc) a) (rest acc))\n                     (cons [a] acc)))\n                 '([]))\n         (group-by count))\n    k (apply max (keys m))]\n    (or (and (< k 2) [])\n        (peek (m k)))))","problem":53,"user":"50ba4b9ee4b03e68e4411c7b"},{"code":"(fn [x] \n  (loop [l [] c [] [x1 & r] x]\n    (let [ll (if (and (> (count c) 1) (> (count c) (count l))) c l)]\n      (if (nil? x1) ll\n        (if (= (last c) (dec x1))\n          (recur l (conj c x1) r)\n          (recur ll [x1] r))))))","problem":53,"user":"51929214e4b08962174cf74c"},{"code":"(fn blah [coll]\n    (loop [[x & more :as remaining] coll\n           longest '()\n           current '()]\n      (if (nil? x)\n        (cond (= (count longest) (count current) 1) (vector)\n              (> (count current) (count longest)) (reverse current)\n              true (reverse longest))\n        (cond (empty? current) (recur more longest (list x))\n              (> x (first current)) (recur more longest (cons x current))\n              (> (count current) (count longest)) (recur remaining current (list))\n              true (recur remaining longest (list))))))","problem":53,"user":"4f17aa97535d64f603146456"},{"problem":53,"code":"(fn longseq [s]\n  ((fn lon [main best-sub sub]\n    (if (second main)\n      (if (< (first main) (second main))\n        (let [sub (conj sub (second main))]\n          (lon (rest main) (if (> (count sub) (count best-sub)) sub best-sub) sub)\n        )\n        (lon (rest main) best-sub [(second main)])\n      )\n      best-sub\n    )\n  ) s [] [(first s)])\n)","user":"50e3cf55e4b01912b3285c45"},{"problem":53,"code":"(fn [col]\n  (let [m (reduce (fn [{:keys [last seq found] :as acc} it]                    \n                    (if (> it last)\n                      {:last it :seq (conj seq it) :found found}\n                      (if (> it (first seq))                        \n                            {:last it :seq [it] :found found}\n                            {:last it :seq [it] :found (if (> (count seq) (count found)) seq found)})))\n                  {:last -1\n                   :seq []\n                   :found []}\n                  col)\n        v (get m :found)\n        v* (get m :seq)\n        v (if (> (count v*) (count v)) v* v)\n        show (<= 2 (count v))]\n    (if show v [])))","user":"53b05a75e4b047364c044482"},{"problem":53,"code":"(fn [collection]\n  (let [streaks\n        (loop [coll (rest collection) acc [] streak [] curr (first collection)]\n          (if (nil? curr)\n            (conj acc streak)\n            (if (empty? streak)\n              (recur (rest coll) acc (conj streak curr) (first coll))\n              (if (= (last streak) (- curr 1))\n                (recur (rest coll) acc (conj streak curr) (first coll))\n                (recur (rest coll) (conj acc streak) [curr] (first coll))))))\n        valid-streaks (filter #(> (count %) 1) streaks)]\n    (reduce\n     (fn [acc curr]\n       (if (> (count curr) (count acc))\n         curr\n         acc)) [] valid-streaks)))","user":"5fac50f4e4b08cb800c85ae5"},{"problem":53,"code":"(fn [coll] \n  (->> coll\n      (reduce #(if (= (last (last %1)) (dec %2))\n             (conj (into [] (drop-last %1)) (conj (last %1) %2))\n             (conj %1 [%2]))\n           [])\n      (filter #(< 1 (count %)))\n      (reduce #(if (< (count %1) (count %2)) \n               %2\n               %1)\n           [])))","user":"60ab1536e4b00e9e6653c47e"},{"code":"(fn [s]\n   (letfn [(long-head-seq [x] (take-while identity (map #(#{%1} %2) x (iterate inc (first x)))))]\n     (loop [nextbit s longest [] next-head (long-head-seq s)]\n       ;(println nextbit longest)\n       (if-not nextbit\n         longest\n         (recur\n           (next nextbit)\n           (if (and (> (count next-head) 1)\n                    (> (count next-head) (count longest) ))\n               (vec next-head) (vec longest) )\n           (long-head-seq nextbit)\n           )))))","problem":53,"user":"4f089f1a535dcb61093f6c3c"},{"problem":53,"code":"(fn [s] \n  (->> s\n       (reductions #(if (= (dec %2)(last %))\n                      (conj % %2)\n                      [%2]) [])\n       (filter #(< 1 (count %)))\n       (apply max-key count [])))","user":"548b8a50e4b0e286459a11ff"},{"code":"(fn liss [seq]\r\n           (let [res (first (reduce (fn [[longest curr] e] \r\n                     (if (or (empty? curr) (> e (last curr)))\r\n                         (if (= (count longest) (count curr))\r\n                             [(conj curr e) (conj curr e)]\r\n                             [longest (conj curr e)])\r\n                         [longest [e]]))\r\n                   [[] []] seq))]\r\n             (if (< (count res) 2) [] res)))","problem":53,"user":"4f13047d535d64f60314642c"},{"code":"(fn\n  [cs]\n  (let [ps (partition 2 1 cs)\n        f (fn [[a b]] (> (- b a) 0))\n        getps (fn [ps]\n                (->> ps\n                     (take-while f)))\n        qs (loop [rs [], p ps]\n             (let [p (drop-while (complement f) p)]\n               (if (seq p)\n                 (recur\n                  (conj rs (getps p))\n                  (drop-while f p))\n                 rs)))]\n    (loop [qs qs, rs nil]\n      (if (seq qs)\n        (if (> (count (first qs)) (count rs))\n          (recur (rest qs) (first qs))\n          (recur (rest qs) rs))\n        (if (seq rs)\n          (conj (vec (map first rs)) (last (last rs)) )\n          [])))))","problem":53,"user":"51852961e4b0da5a5be3babb"},{"code":"(fn [c]\r\n       (->> c\r\n       (partition 2 1)\r\n       (reductions (fn [id [prev curr]] (if (> curr prev) id (+ id 1))) 0)\r\n       (map vector c)\r\n       (partition-by second)\r\n       (map (partial map first))\r\n       (remove #(= 1 (count %)))\r\n       ((fn [x] (if (empty? x)\r\n  \t    x\r\n\t\t    (let [n (sort-by count x)\r\n  \t                  f (count (first n))\r\n\t\t          l (count (last n))]\r\n  \t            (if (and (= f l) (= n x)) \r\n\t\t\t(first x) \r\n\t\t\t(last n))))))))","problem":53,"user":"4ff8a89de4b0678c553fc39d"},{"problem":53,"code":"(fn longest-inc-seq\n  ([sq]\n   (let [longest (longest-inc-seq sq [] [] #(if (> (count %2) (count %1)) %2 %1))]\n     (if (> (count longest) 1) longest [])))\n  ([sq acc mx max-len-fn]\n   (if (empty? sq)\n     (max-len-fn mx acc)\n     (let [[x & xs] sq]\n       (if (or (empty? acc) (= x (inc (last acc))))\n         (longest-inc-seq xs (conj acc x) mx max-len-fn)\n         (longest-inc-seq xs [x] (max-len-fn mx acc) max-len-fn))))))","user":"55815973e4b05c286339e0f6"},{"problem":53,"code":"#(let [res (apply max-key count (reduce (fn [co ky] (if (and (last co)\n                  (= (-> co last last inc) ky))\n           (let [item ky\n                 col co]\n             (conj (-> col butlast vec)\n                   (-> col\n                       last\n                       (conj item))))\n           (conj co [ky])))\n        []\n        %))]\n(if (> (count res) 1)\n  res\n  [])\n   )","user":"60ac91c5e4b00e9e6653c485"},{"code":"(fn longest-increasing [list]\n     (let [find-incseq-from (fn [list]\n       (take-while (complement nil?) (map #(if (= %1 %2) %1 nil) list (iterate inc (first list)))))\n                   longest-subseq (if (empty? list)\n                                                              []\n                                                              (longest-increasing (rest list)))\n                   longest-seq (if (empty? list)\n                                                           []\n                                                           (find-incseq-from list))]\n           (if (and (>= (count longest-seq) (count longest-subseq)) (> (count longest-seq) 1))\n                     longest-seq\n                     longest-subseq)))","problem":53,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":53,"code":"#(reduce (fn [a b] (if (and (> (count b) 1) (> (count b) (count a))) b a)) [] (reductions (fn [a b] (if (or (= a []) (> b (last a))) (conj a b) [b])) [] %))","user":"569c40cee4b0542e1f8d1462"},{"code":"(fn [s]\n  (loop [ss (rest s) largest [] working [(first s)]]\n    (let [cw (count working) cl (count largest)]\n      (if (empty? ss)\n        (if (and (> cw 1) (> cw cl))\n          working\n          largest)\n        (let [n (first ss)]\n          (recur (rest ss) \n                 (if (and (> cw 1) (> cw cl))\n                    working\n                    largest)\n                 (if (> n (last working)) (conj working n) [n])))))))","problem":53,"user":"4dd9d299535d2dad7130b5dd"},{"code":"(fn [x] (let [z (->> (partition 2 1 x)\n                     (drop-while #(> (first %) (second %)))\n                     (partition-by #(= 1 (- (second %) (first %))))\n                     (take-nth 2)\n                     (group-by #(count %)))]\n          (if (seq z)\n            (let [k (apply max (keys z))\n                  p (first (z k))\n                  l (->> p last second)]\n              (map inc (range (- l (count p) 1) l)))\n            [])))","problem":53,"user":"4db29f98535df7e46ed9b6c1"},{"problem":53,"code":"(fn [seqs] \n   (->> seqs\n        (partition 2 1)\n        (partition-by (fn [[a b]] (< a b)))\n        (filter (fn [[[a b]]] (< a b)))\n        (sort-by count >)\n        first\n        ((fn [x] (concat (first x) (map second (rest x)))))))","user":"55c1eb52e4b0e31453f64970"},{"problem":53,"code":"(fn incrun [col]\n  (loop [lastone (first col)\n         col (rest col)\n         result [lastone]\n         best []]\n    (if (empty? col)\n      best\n      (let [thisone (first col)]\n        (if (= (inc lastone) thisone)\n          (recur\n           thisone\n           (rest col)\n           (conj result thisone)\n           (if (>= (count result) (count best))\n             (conj result thisone)\n             best))\n          (recur thisone\n                 (rest col)\n                 [thisone]\n                 best))))))","user":"5b250773e4b063e2438bcc21"},{"problem":53,"code":"(fn [input]\n  (let [get-subsequences    (fn [acc x]\n                              (if (empty? acc)\n                                [x]\n                                (if (= (inc (peek acc)) x)\n                                  (conj acc x)\n                                  [x])))\n        longest-subsequence (apply max-key count (reductions get-subsequences [] input))]\n    (if (> (count longest-subsequence) 1)\n      longest-subsequence\n      [])))","user":"567d51dbe4b05957ce8c61c6"},{"problem":53,"code":"(fn [v]\n  (let [ans (filter\n             #(every? (fn [[x y]] (= (+ 1 x) y)) (partition 2 1 %))\n             (for [start (range 0 (- (count v) 1))\n                   end (range (+ start 2) (+ (count v) 1))]\n               (subvec v start end)))]\n    (if (empty? ans) []\n        (last (sort-by count ans)))))","user":"53f053ebe4b0742d9025b0d3"},{"problem":53,"code":"(fn longest-increasing-subseq [xs]\n  (let [\n\n        increasing-subseqs (fn increasing-subseqs [[x & xs]]\n                             (loop [res [], trans [x], [x & xs] xs]\n                               (cond (nil? x) (conj res trans)\n                                     (<= x (last trans)) (recur (conj res trans) [x] xs)\n                                     :else (recur res (conj trans x) xs))))\n        filter-l2 (fn filter-l2 [xs]\n                    (filter #(> (count %) 1) xs))\n        filter-longest-subseq (fn filter-longest-subseq [[x & xs]]\n                                (if (nil? x) []\n                                  (loop [res x, [x & xs] xs]\n                                    (cond (nil? x) res\n                                          (< (count res) (count x)) (recur x xs)\n                                          :else (recur res xs)))))\n        ]\n    (-> xs increasing-subseqs filter-l2 filter-longest-subseq)))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"code":"(fn [coll]\n    (let [x\n          (loop [c coll acc []]\n            (if (empty? c)\n              (apply max-key count (reverse acc))\n              (recur (next c)\n                (let [x (first c)]\n                  (if (and (not-empty acc) (> x (last (last acc))))\n                    (conj (vec (butlast acc)) (conj (last acc) x))\n                    (conj acc [x]))))))]\n      (if (= (count x) 1) [] x))\n    )","problem":53,"user":"504e1abee4b0f6ff3350c45d"},{"problem":53,"code":"(fn [coll]\n  (let [less? (fn [[a b]] (< a b))\n        m (first (sort-by #(- (count %))\n                          (filter #(-> % first less?)\n                                  (partition-by less?\n                                                (partition 2 1 coll)))))]\n    (if (nil? m) []\n        (conj (vec (map first m)) (-> m last last)))))","user":"55101237e4b06e50f9beb181"},{"problem":53,"code":"(fn [coll]\n  (let [slices (for [i (range (count coll))] (drop i coll))\n        monotone (fn monotone [coll]\n                   (reverse\n                    (loop [coll coll prev nil result []]\n                      (cond\n                        (empty? coll) result\n                        (neg? (compare prev (first coll))) (recur (rest coll) (first coll) (cons (first coll) result))\n                        :else result\n                        ))))\n        ]\n    (let [longest (vec (apply max-key count (reverse (map monotone slices))))]\n      (if (< 1 (count longest)) longest []))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"#(loop [v (next %)\n       d []\n       c [(first %)]\n       ]\n  (if (not v)\n    (if (> (count d) 1) d [])\n    (let [nc (if (= (+ (last c) 1) (first v))\n                (conj c (first v))\n                [(first v)])]\n    (recur (next v) \n           (if (> (count nc) (count d)) nc d)\n           nc))))","problem":53,"user":"4e5bdc2b535d8a8b8723a2bb"},{"code":"(fn get-answer [l]\n\t(let [longest-seq (fn [l]\n\t\t(let [increasing-pairs (take-while #(apply < %) (partition 2 1 l))]\n\t\t\t(if (empty? increasing-pairs)\n\t\t\t\t[]\n\t\t\t\t(conj (vec (map first increasing-pairs)) (second (last increasing-pairs))))))]\n\t\t(loop [curr-list l\n\t\t   \t\tres []]\n\t\t   (if (empty? curr-list)\n\t\t   \t\tres\n\t\t   \t\t(recur (rest curr-list)\n\t\t   \t\t\t   (if (> (count (longest-seq curr-list)) (count res))\n\t\t   \t\t\t   \t   (longest-seq curr-list)\n\t\t   \t\t\t   \t   res))))))","problem":53,"user":"51d49b75e4b013d740b70de6"},{"code":"(fn [coll]\r\n  (->> (partition 2 1 coll) \r\n    (partition-by #(- (second %) (first %))) \r\n    (filter #(= 1 (- (second (first %)) (ffirst %)))) \r\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\r\n    flatten\r\n    distinct\r\n    ))","problem":53,"user":"4ff07688e4b0678c553fc324"},{"code":"(fn [coll]\n  (let\n    [len (count coll)\n     data\n     ;; data[i] is the len of longest subseq starting at i\n      (loop [index (dec len)\n             data (vec (repeat len 1))]\n        (if (> index 0)\n          (let [cur-idx (dec index)\n                cur-val (coll cur-idx)\n                nxt-idx index\n                nxt-val (coll nxt-idx)]\n            (if (> nxt-val cur-val)\n              (recur cur-idx\n                (assoc data cur-idx (inc (data nxt-idx))))\n              (recur cur-idx data)))\n          data))\n\n     ;; Have the data, now find the longest subseq\n     [max-idx max-len]\n      (loop [index 0, max-idx 0, max-len 1]\n        (if (< index len)\n          (if (> (data index) max-len)\n            (recur (inc index) index (data index))\n            (recur (inc index) max-idx max-len))\n          [max-idx max-len]))]\n\n    (if (> max-len 1)\n      (subvec coll max-idx (+ max-idx max-len))\n      [])))","problem":53,"user":"4f28c979e4b0d6649770a01a"},{"problem":53,"code":"(fn [xs]\n    (loop [seq [(first xs)]\n           longest []\n           xs (rest xs)]\n      (if (empty? xs)\n        longest\n        (if (= (inc (last seq)) (first xs))\n          (let [newseq (conj seq (first xs))]\n            (if (> (count newseq) (count longest))\n              (recur newseq newseq (rest xs))\n              (recur newseq longest (rest xs))))\n          (recur [(first xs)] longest (rest xs))))))","user":"54be792ee4b0ed20f4ff6eeb"},{"code":"(fn [v]\n           (let\n               [g (group-by\n                   count\n                   (filter #(apply < (first %))\n                           (partition-by\n                            #(apply < %)\n                            (map vector v (drop 1 v)))))\n                  ks (keys g)]\n             (if ks (let\n                        [m (apply max ks),\n                           bs (first (g m)),\n                           as (reduce\n                               #(into %1 [%2])\n                               [(ffirst bs)]\n                               (map last bs))] as)\n               [])))","problem":53,"user":"515cf9b5e4b00901442db1d4"},{"code":";; Find all increasing sub-sequences, creating a sequence of them.\n;; Group by their lengths into a map, find the maximum length\n;; (i.e. key), and return the first of all sequences with that length.\n\n(fn [s]\n  (let [lt (fn [[a b]] (< a b))\n        ge (complement lt)\n        all-increasing-seqs\n        (->> (take-while #(seq (first %))\n                         (rest\n                          (iterate #(split-with lt (drop-while ge (second %)))\n                                   (list 0 (partition 2 1 s)))))\n             (map first)\n             (map #(cons (ffirst %) (map second %))))\n        by-length (group-by count all-increasing-seqs)\n        lengths (keys by-length)]\n    (if (seq lengths)\n      (first (by-length (apply max lengths)))\n      [])))","problem":53,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [coll]\n  (let [sub-seqs (reduce (fn [[curr-seq & r :as all] v]\n                           (if (and (last curr-seq) (< (last curr-seq) v))\n                             (cons (conj curr-seq v) r)\n                             (cons [v] all)))\n                         [[]]\n                         coll)]\n    (vec (last (sort #(compare (count %) (count %2)) (filter #(> (count %) 1) sub-seqs))))))","problem":53,"user":"4eccb190535d23f0362276fe"},{"code":"(fn [coll]\n  (\n    (fn [res]\n      (concat (take 1 (map first res)) (map second res))) \n    (reduce (fn [x y] \n              (if (> (count y) (count x)) y x)) \n            [] \n            (filter (fn [[[a b]]] \n                      (< a b)) \n                    (partition-by (partial apply >=) \n                                  (partition 2 1 coll))))))","problem":53,"user":"50630247e4b05ac47bc68d6b"},{"code":"(fn supsubseq\n  [xxs]\n  (let [v ((fn subseq [xs] \n  (reduce #(if (> (count %2) (count %)) %2 %) \n   (reduce \n  #(if \n    (< (last (last %1)) %2)\n    (concat (butlast %) [(conj (last %) %2)])\n    (concat % [[%2]]))\n    [[(first xs)]]\n    (rest xs)))) xxs)]\n    (if (< (count v) 2) [] v)))","problem":53,"user":"536aa86de4b0243289761eb1"},{"code":"(fn [coll] (reduce\n            (fn [a b] (let [n (count b)] (if (and (> n 1) (> n (count a))) b a)))\n            []\n            (reductions (fn [a b] (conj (if (or (empty? a) (> b (last a))) a []) b)) [] coll)))","problem":53,"user":"51307b84e4b08c712d3fae39"},{"problem":53,"code":"(fn [s]\n    (:best\n     (reduce (fn [m e]\n               (let [prev (last (:curr m))\n                     next-curr (if (or (nil? prev)\n                                       (> e prev))\n                                 (conj (or (:curr m) []) e)\n                                 [e])]\n                 {:curr next-curr\n                  :best (if (and (> (count next-curr)\n                                    (count (:best m)))\n                                 (> (count next-curr) 1))\n                          next-curr\n                          (or (:best m) []))}))\n             {}\n             s)))","user":"5a5d0726e4b0512ff01cd91b"},{"code":"(fn [l]\n  (letfn \n    [(inf \n      [l cseq]\n      (if (empty? l) cseq\n        (let [rl (rest l) fl (first l)]\n          (if (or (empty? cseq) (< (last cseq) fl))\n            (inf rl (concat cseq [fl]))\n            (let [nseq (inf rl [fl])]\n              (if (>= (count cseq) (count nseq)) cseq nseq)\n              )))))]\n    (let [sq (inf l [])]\n      (if (> (count sq) 1) sq [])\n      )))","problem":53,"user":"52faec2ee4b047fd55837004"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll) \n    (partition-by #(- (second %) (first %))) \n    (filter #(= 1 (- (second (first %)) (ffirst %))))\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n    flatten\n    distinct))","problem":53,"user":"51a9dbc9e4b04e3dc0c27b1e"},{"problem":53,"code":"(fn increasing-sub-seq [s]\n  (let [is-increasing?\n        (fn [s n]\n          (if (= (count s) 0)\n            true\n            (if (= (last s) (- n 1))\n              true\n              false)))]\n    (loop [s s\n           cur []\n           res []]\n      (if (seq s)\n        (if (is-increasing? cur (first s))\n          (recur (rest s) (conj cur (first s)) res)\n          (recur (rest s) [(first s)] (if (>= (count cur) 2)\n                                        (conj res cur)\n                                        res)))\n        (reduce #(if (> (count %2) (count %1))\n                   %2\n                   %1)\n                []\n                (if (>= (count cur) 2) (conj res cur) res))))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":53,"code":"(fn p53 [xs]\n ( let [stepfn (fn [[x1 count] x2] (vector x2 (if (< x1 x2) count (inc count))))\n        steps (drop 1 (reductions stepfn [0 0] xs))] ;; tuples of [xi step]\n    \n    (->> steps\n         (partition-by second) ;; partion by step\n         (map #(map first %)) ;; extract original values\n         (filter #(< 1 (count %)))\n         (sort #(> (count %1) (count %2))) ;; sort by length\n         (first)\n         (sequence))))","user":"4fc4eb1ee4b081705acca354"},{"code":"(fn [coll]\n  (let [a (last (sort-by #(count %)(filter #(< 1 (count %))\n    (reduce (fn [col x](if (= (last (last col))(dec x))\n  \t  (conj (vec (drop-last col))(conj (last col) x))\n\t\t\t(conj col [x])))[] coll))))]\n        (if (nil? a) [] a)))","problem":53,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":53,"code":"(fn [x] \n  (distinct \n   (apply concat \n          (first \n           (sort #(> (count %) (count %2)) \n                 (filter #(= -1 (apply - (first %))) \n                         (partition-by #(apply - %)\n                                       (partition 2 \n                                                  (interleave x \n                                                              (rest x))))))))))","user":"56992162e4b0542e1f8d143c"},{"code":"(fn [list]\n\t(let [x (first \t(sort-by count > (reduce\n\t#(cond\n\t\t(= (last (last %1)) (dec %2)) (conj (vec (butlast %1)) (conj (last %1) %2))\n\t\t:else (conj %1 [%2]))\n\t[[(first list)]]\n\tlist)))]\n\t(cond\n\t\t(> (count x) 1) x\n\t\t:else [])))","problem":53,"user":"51dd9370e4b0c33a4e1da40c"},{"code":"(fn longest-sequence- [coll]\n  \"53. Given a vector of integers, find the longest consecutive sub-sequence of increasing numbers.\"\n  (->> coll\n       (partition 2 1) ; split into overlapping pairs                                                                                                                   \n       (partition-by #(let [[l r] %] (> r l))) ; split into ascending and descending runs                                                                               \n       (filter #(let [[l r] (first %)] (> r l))) ; remove descending runs                                                                                               \n       (map flatten) ; join ascending runs into a flat sequence of pairs                                                                                                \n       (map #(concat (take-nth 2 %) (list (last %)))) ; remove the overlaps from the pairs                                                                              \n       (group-by count) ; map by length of run                                                                                                                          \n       (sort) ; order by length                                                                                                                                         \n       (last) ; take the longest set of runs                                                                                                                            \n       (second) ; take the runs themselves                                                                                                                              \n       (first) ; take the first of the longest runs                                                                                                                     \n       (vec) ; convert it to a vector                                                                                                                                   \n       ))","problem":53,"user":"4e5eb843535d8a8b8723a2d4"},{"code":"(fn [x]\n  (map second\n       (last\n        (remove #(= 1 (count %))\n                (sort-by count\n                         (partition-by #(apply - %)\n                                       (map-indexed\n                                        #(list % %2)\n                                        x)))))))","problem":53,"user":"529b44afe4b02ebb4ef7509d"},{"code":"(fn [col]\n  (loop [i 0\n         last-zero-index 0\n         result []]\n    (if (< i (dec (count col)))\n      (if (< (nth col i) (nth col (inc i)))\n        ; ith < i+1th\n        (if (> (- (inc (inc i)) last-zero-index) (count result))\n          ; len changed\n          (recur (inc i) last-zero-index (take (- (inc (inc i)) last-zero-index) (drop last-zero-index col)))\n          ; len not changed\n          (recur (inc i) last-zero-index result)\n          )\n        ; ith > i+1th\n        (recur (inc i) (inc i) result)\n        )\n      ; end loop\n      result\n      )))","problem":53,"user":"534815bde4b084c2834f4a53"},{"problem":53,"code":"(fn [coll]\n  (let [pack (fn [res] (conj (mapv first res) (last (last res))))\n        res (->> coll\n                (partition 2 1)\n                (partition-by (partial apply <))\n                (map pack)\n                (sort-by (comp - count))\n                first)]\n    (if (= coll res) [] res)))","user":"50310713e4b05b7df5a0b84c"},{"problem":53,"code":"(fn answer-53 [_list]\n  (first \n    (reverse \n      (sort-by count \n               (mapv #(vec (distinct %)) \n                     (loop [[h & t] _list _acc [] superacc []]\n                       (cond \n                         (nil? t) \n                            (conj superacc _acc)\n                         (= 0 (- (first t) h))\n                            (recur t [] superacc)      \n                         (= 1 (- (first t) h))\n                            (recur t (conj _acc h (first t)) superacc) \n                         :else \n                            (recur t [] (conj superacc _acc)))))))))","user":"53ef235de4b0d648e757f4d4"},{"problem":53,"code":"(fn longest [col]\n  (let \n    [r (:longest (reduce \n      (fn [c x]\n        (if (or (empty? (:current c)) (= x (inc (last (:current c)))))\n          (if (>= (count (:current c)) (count (:longest c))) \n            (assoc c :current (conj (:current c) x) :longest (conj (:current c) x))\n            (assoc c :current (conj (:current c) x)))\n          (assoc c :current [x]))) \n      {:longest [] :current []} \n      col))]\n    (if (> (count r) 1) r [])))","user":"55536a8ae4b0deb715856e03"},{"code":"(fn [l]\n  (let [s (partition-by identity (map - (rest l) l))\n        f (filter #(= 1 (first %)) s)]\n    (if (seq f)\n      (let [m (first (sort #(> (count %) (count %2)) f))\n            i (.indexOf s m)]\n        (take (inc (count m)) (drop (count (apply concat (take i s))) l)))\n      [])))","problem":53,"user":"51cc5cb3e4b02254fc79486f"},{"code":"(fn longest-ss\n  [s]\n  (let [sub-seqs (reduce (fn [r e]\n                           (let [p (last r)]\n                             (if (> e (last p))\n                               (conj (vec (drop-last r)) (conj p e))\n                               (conj r [e]))))\n                         [[(first s)]] (rest s))\n        longest-len (reduce (fn [r e]\n                              (if (> (count e) (count r))\n                                e\n                                r))\n                            (first sub-seqs) (rest sub-seqs))]\n    (if (< (count longest-len) 2)\n      []\n      (first (filter #(= longest-len %) sub-seqs)))))","problem":53,"user":"5348cab4e4b084c2834f4a5e"},{"problem":53,"code":"(fn longest-increasing-subseq\n  [input]\n  (let [result (first (reduce (fn [[best current] next]\n                                (let [new-current (if (> next (last current))\n                                                    (conj current next)\n                                                    [next])]\n                                  (let [new-best (if (> (count new-current) (count best))\n                                                   new-current\n                                                   best)]\n                                    [new-best new-current])))\n                              [[(first input)] [(first input)]]\n                              (into [] (rest input))))]\n    (if (= (count result) 1) [] result)))","user":"58152157e4b0f478707a0631"},{"problem":53,"code":"(fn longest-sub [xs]\n  (let [is-sub (fn [num prev-num] (= (- num prev-num) 1))\n        partition-by-subsequences\n        \t(fn [yx]\n              (reduce (fn [prev num]\n                        (let [curr (last prev)]\n                          (if (is-sub num (last curr))\n                            (conj (pop prev) (conj curr num))\n                            (conj prev [num]))))\n                      [(vector (first yx))]\n                      (drop 1 yx)))]\n    (->> xs\n         (partition-by-subsequences)\n         (filter #(> (count %) 1))\n         (#(conj % []))\n         (apply max-key count))))","user":"5483d59fe4b0e286459a1194"},{"problem":53,"code":"#((fn [mas act col]\n           (let [fcol (first col)\n\t\t\t\t actfcol (conj act fcol)\n                 rcol (rest col)\n                 prev (first act)]\n             (if (empty? col)\n               (reverse mas)\n               (if (> fcol prev)\n                 (if (>= (count act) (count mas))\n                   (recur actfcol actfcol rcol)\n                   (recur mas actfcol rcol))\n                 (recur mas (conj '() fcol) rcol)))))\n         '() (conj '() (first %)) (rest %))","user":"56d6c18ee4b0ea9b8538f7d1"},{"code":"(fn [my-list]\r\n    (let [sequences ((fn find-seq\r\n            ([i-list] (find-seq [] i-list))\r\n            ([result i-list]\r\n                (if (zero? (count i-list))\r\n                    result\r\n                    (let [current (first i-list) next (rest i-list) head (drop-last result) tail (last result)]\r\n                        (if (or (zero? (count result)) (not= (inc (last tail)) current))\r\n                            (find-seq (conj (apply vector result) (vector current)) next)\r\n                            (find-seq (conj (apply vector head) (conj tail current)) next))))))\r\n        my-list)]\r\n        (let [sequence-max (apply max (map count sequences))]\r\n            (let [filtered-sequence (filter\r\n                (fn [sequence]\r\n                    (let [sequence-count (count sequence)]\r\n                        (and (>= sequence-count 2)\r\n                            (= sequence-count sequence-max))))\r\n                sequences)]\r\n                (if (zero? (count filtered-sequence)) [] (first filtered-sequence))))))","problem":53,"user":"4dddf817535d08e6dec9fdd3"},{"code":"(fn [xs]\n   (let [seqs (reduce (fn [{:keys [all want]} i]\n                        (let [cur (peek all)\n                              prev (pop all)]\n                          {:all (if (= i want)\n                                  (conj prev (conj cur i))\n                                  (conj all [i]))\n                           :want (inc i)}))\n                      {:all [[]] :want nil}\n                      xs)]\n     (apply max-key count\n            (remove #(= 1 (count %))\n                    (:all seqs)))))","problem":53,"user":"4f1b92d1535d64f60314647b"},{"problem":53,"code":"(fn [coll]\n  (let \n    [r\n    ((fn rec [coll res curr]\n      (if (empty? coll)\n        (max-key count curr res)\n        (if (> (first coll) (last curr))\n          (rec (rest coll) res (conj curr (first coll)))\n          (rec (rest coll) (max-key count curr res) [(first coll)])))) (rest coll) [] [(first coll)])]\n    (if (= 1 (count r)) [] r))\n  )","user":"5550bcece4b00713264bd9ae"},{"code":"(fn [icoll]\n  (reduce #(if (> (max 2 (count %1)) (count %2)) (identity %1) (identity %2)) []  \n    (loop [coll (rest icoll) current-seq [(first icoll)] maxs []]\n      (if (empty? coll)\n        (conj maxs current-seq)\n        (if (= (first coll) (inc (last current-seq)))\n          (recur (rest coll) (conj current-seq (first coll)) maxs)\n          (recur (rest coll) [(first coll)] (conj maxs current-seq))\n        )\n      )\n    )\n  )                        \n)","problem":53,"user":"50e8a340e4b0ebbe794eb7ed"},{"problem":53,"code":"(fn [coll]\n  (->> (reduce (fn [acc v]\n                 (if (= (last (last acc)) (dec v))\n                   (conj (pop acc) (conj (peek acc) v))\n                   (conj acc [v])))\n               [] coll)\n       (filter #(> (count %) 1))\n       (reverse)\n       (apply max-key count [])))","user":"50bdd4fee4b0594b91591c84"},{"problem":53,"code":"#(let [x (reduce (fn [a b] (if (and (pos? (first b)) (> (count b) (second a))) [(+ (first a) (count b)) (count b) (+ (first a) (count b))] [(+ (first a) (count b)) (second a) (last a)])) [0 0 0] (partition-by pos? (map - (rest %) (butlast %))))] (if (pos? (second x)) (subvec % (- (last x) (second x)) (inc (last x))) []))","user":"5776385fe4b0979f89651632"},{"code":"(fn [s]\r\n  (let\r\n\t\t[rises (fn [start]\r\n\t\t\t\t\t(loop [end start]\r\n\t\t\t\t\t\t(if (and (< end (dec (count s))) (> (s (inc end)) (s end)))\r\n\t\t\t\t\t\t\t(recur (inc end))\r\n\t\t\t\t\t\t\t[start end])))\r\n\t\t[start end] (apply max-key #(- (% 1) (% 0)) (reverse (map rises (range (count s)))))\r\n\t\tsub (map s (range start (inc end)))]\r\n\t\t\t(if (next sub)\r\n\t\t\t\tsub\r\n\t\t\t\t[])))","problem":53,"user":"503e7f06e4b06c4e0e1fa268"},{"code":"(fn lis ([x] (lis x [] [])) ([x p c] (let [lgr #(if (>= (count %1) (count %2)) %1 %2)] (cond (empty? x) (if (> (count p) 1) p []) :else (let [n (cond (empty? c) [(first x)] (> (first x) (last c)) (conj c (first x)) :else [(first x)])](recur (rest x) (lgr p n) n))))))","problem":53,"user":"52b5edd1e4b0c58976d9ad3c"},{"problem":53,"code":"#(:longest (reduce (fn [{:keys [longest current]} y]\n    (let [nextCurrent (if (= (last current) (dec y))\n                          (conj current y)\n                          [y])\n          nextLongest (if (and (> (count nextCurrent) 1) (> (count nextCurrent) (count longest)))\n                          nextCurrent\n                          longest)]\n    {:longest nextLongest :current nextCurrent})) {:longest [] :current [(first %)]} (rest %)))","user":"5a84cf8de4b00b71e582a095"},{"code":"(fn [coll]\n   (let [f (first coll)]\n     ((fn [longest now lst r]\n        (if (empty? r)\n          (if (= (count longest) 1) [] longest)\n          (if (= (first r) (+ lst 1))\n            (let [cc (conj now (first r))]\n              (if (= (count longest) (count now))\n                (recur cc cc (first r) (rest r))\n                (recur longest cc (first r) (rest r))))\n            (recur longest [(first r)] (first r) (rest r)))))\n      [f] [f] f (rest coll))))","problem":53,"user":"4eb02674535d7eef30807338"},{"problem":53,"code":"(fn [x] (or (first (sort-by (comp - count) (filter #(> (count %) 1) (map #(map first %) (partition-by #(apply - %) (map vector x (range))))))) []))","user":"5d62ce13e4b0c9e5857d501f"},{"problem":53,"code":"#(reduce (fn [accum, x]\n           (if (>= (count x) (max 2 (count accum)))\n             x\n             accum))\n         []\n         (reduce (fn [accum, x]\n                   (if (or (empty? (first accum)) (> x (last (first accum))))\n                     (conj (rest accum) (conj (first accum) x))\n                     (conj accum [x])))\n                 '([])\n                 %))","user":"56a38a4ce4b0542e1f8d14cc"},{"problem":53,"code":"(fn [data1]\n   (let [twos   (partition 2 1 data1)\n         threes (partition 3 1 data1)\n         fours  (partition 4 1 data1)\n         all    (concat twos threes fours)]\n     (loop [coll  all\n            elem  (first coll)\n            res   []]\n       (if (empty? coll)\n         (if (empty? res)\n           []\n           (let [felem (first res)\n                 lelem (first (reverse res))\n                 flen  (count felem)]\n             (if (every? #(= (count %) flen) res) felem lelem)))\n         (if (apply < elem)\n           (recur (drop 1 coll)\n                  (first (drop 1 coll))\n                  (conj res elem))\n           (recur (drop 1 coll)\n                  (first (drop 1 coll))\n                  res))))))","user":"56372c3ce4b0bfe05bf117d1"},{"problem":53,"code":"(fn [col]\n    (let [arr (last (sort-by count (loop [p nil\n           c col\n           current []\n           potentials []]\n      (let [f (first c)\n            s (second c)]\n        ; (Thread/sleep 2000)                                                                                                                         \n        ; (println \"p\" p \"c\" c \"current\" current \"potentials\" potentials \"f\" f \"s\" s)\n        (cond \n          (nil? f) (conj potentials current)\n\n          (nil? s) (if (= (- f p) 1)\n                     (recur (first c) (rest c) (conj current f) potentials)\n                     (recur (first c) (rest c) [] (conj potentials (conj current f))))\n\n          (= (- s f) 1)\n          (recur (first c) (rest c) (conj current f) potentials)\n\n          :else\n          (recur (first c) (rest c) [] (conj potentials (conj current f))))))))]\n      (if (= (count arr) 1) [] arr))\n  )","user":"59932f49e4b0b211ea3aaaae"},{"problem":53,"code":"(fn [coll]\n          (loop [rs []\n                 cs []\n                 coll coll]\n            (println \"\\nrs: \" rs \"\\ncs: \" cs \"\\ncoll: \" coll)\n            (if (empty? coll)\n              (or (first (sort-by #(- (count %)) (filter #(> (count %) 1) (conj rs cs)))) [])\n              (let [val (first coll)]\n                (if (or (empty? cs) (< (last cs) val))\n                  (recur rs (conj cs (first coll)) (rest coll))\n                  (recur (conj rs cs) [] coll))))))","user":"531c6e72e4b08068f379eda0"},{"problem":53,"code":"(fn tf [s]\n  (loop [best [] curr [(first s)] restt (rest s)]\n    (let [a (last curr) b (first restt)]\n      (if b\n        (if (< a b)\n          (let [curr_n (conj curr b)]\n            (recur (max-key count curr_n best) curr_n (rest restt)))\n          (recur best [b] (rest restt))\n        )\n        best\n        )\n      )\n    ))","user":"53e745a1e4b036ad0777e479"},{"problem":53,"code":"(fn longest [xs]\n  (let [monotonic?\n        (fn [[a b]] (= a (- b 1)))\n        monotonics\n        (->> xs\n             (partition 2 1)\n             (partition-by monotonic?)\n             (map (juxt (comp monotonic? first) count identity))\n             (filter (comp true? first)))\n        gin\n        (if (seq monotonics)\n          (->> monotonics\n               (filter (comp (partial = (apply max (map second monotonics))) second))\n               first\n               last)\n          monotonics)]\n    (if (seq gin)\n      (range (first (first gin)) (inc (last (last gin))))\n      gin)))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn long-ss [xs]\n  (letfn [(ss [xs]\n              (loop [out (take 1 xs)\n                     in  (drop 1 xs)]\n                (letfn [(done []\n                              (if (< (count out) 2)\n                                []\n                                out))]\n                  (if (empty? in)\n                    (done)\n                    (if (= (inc (last out)) (first in))\n                      (recur\n                       (concat out (list (first in)))\n                       (rest in))\n                      (done))))))]\n    (loop [xs xs\n           m []]\n      (if (empty? xs)\n        m\n        (let [m' (ss xs)]\n          (recur\n           (rest xs)\n           (if (> (count m') (count m))\n             m'\n             m)))))))","problem":53,"user":"51365524e4b04ac1f358dd52"},{"problem":53,"code":";(vec (\n(fn [xs]\n  (->> (interleave xs (rest xs))\n       (partition 2)\n       (partition-by\n        (fn [[x y]] (> y x)))\n       (remove\n        (fn [[[x y] & _]]\n          (> x y)))\n       (map (fn [[ys & yys]]\n              (concat\n               ys\n               (map last yys))))\n       (sort-by count\n                #(compare %2 %1))\n       first\n       concat\n       ))\n;[4 3 2 1]))","user":"55d87324e4b0e31453f64ab4"},{"problem":53,"code":"(fn [coll]\n   (let [partitioned (partition-by #(apply < %) (partition 2 1 coll))\n         filtered (filter (fn [[[x1 x2]]] (< x1 x2)) partitioned)\n         sorted (first (sort-by count > filtered))]\n     (concat (first sorted) (map last (rest sorted)))))","user":"5bed84b1e4b0a6d31fed2120"},{"problem":53,"code":"(fn longest-asc [[f s & r]]\n  (loop [max_length 0\n         max_seq []\n         prev_elem f\n         cur_elem s\n         counter 0\n         cur_seq [prev_elem]\n         tail r]\n    (if (nil? cur_elem)\n      (if (> counter max_length)\n        cur_seq\n        max_seq)\n      (let [new_cur_elem (first tail)\n            new_tail (rest tail)]\n        (if (> cur_elem prev_elem)\n          (let [new_counter (inc counter)\n                new_cur_seq (conj cur_seq cur_elem)]\n            (if (> new_counter max_length)\n              (recur new_counter new_cur_seq cur_elem new_cur_elem new_counter new_cur_seq new_tail)\n              (recur max_length max_seq cur_elem new_cur_elem new_counter new_cur_seq new_tail)))\n          (recur max_length max_seq cur_elem new_cur_elem 0 [cur_elem] new_tail))))))","user":"571d063ee4b0145328a76272"},{"code":"(fn h [s]\n  (letfn [\n    (f [[a b & r]]\n      (cons a\n            (when (and b (< a b))\n              (f (cons b r)))))    \n    (g [s]\n      (when (seq s)\n        (let [a (f s)]\n          (cons a\n                (g (nthrest s (count a))))\n          )))]\n    (let [x (first (sort-by #(- 0 (count %)) (g s)))]\n      (if (> (count x) 1)\n        x\n        []))))","problem":53,"user":"523ed522e4b057c4b7cd0a78"},{"problem":53,"code":"(fn [lst]\n  (let [result (first (sort-by (comp - count) (map #(map last %) (map #(take-while (partial apply <) %) (map #(map list (cons (dec (first %)) %) %) (take (count lst) (iterate rest lst)))))))]\n    (if (= 1 (count result)) ; ...uhhhh why do we do this?\n      []\n      result)))","user":"4f29d9abe4b0d6649770a034"},{"code":"(fn [l]\r\n  (letfn [(split-seq [l]\r\n            (if (empty? l) nil\r\n                (let [r (split-seq (rest l))]\r\n                  (if (empty? r)\r\n                    (cons (list (first l)) nil)\r\n                    (if (< (first l) (first (first r)))\r\n                      (cons (cons (first l) (first r)) (rest r))\r\n                      (cons (list (first l)) r))))))]\r\n    (let [r (apply max-key count (reverse (split-seq l)))]\r\n      (if (<= (count r) 1)\r\n        []\r\n        r))))","problem":53,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":53,"code":"(fn [initial-sequence]\n  (loop [vecseq initial-sequence current-longest []]\n    (cond\n      (= (second vecseq) nil) current-longest\n      (<= (second vecseq) (first vecseq)) (recur (rest vecseq) current-longest)\n      :else (recur (rest vecseq)\n        (loop [vecseq2 (rest vecseq)\n               prospective-longest (vec (list (first vecseq) (second vecseq)))]\n          (if\n            (or (= (second vecseq2) nil) (<= (second vecseq2) (first vecseq2)))\n            (if\n              (> (count prospective-longest) (count current-longest))\n              prospective-longest\n              current-longest)\n            (recur (rest vecseq2) (conj prospective-longest (second vecseq2)))))))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":53,"code":"(fn liss\n  [v]\n  (if (< (count v) 2)\n    []\n    (let [lis      \n          (loop [i 1 subv [(first v)] subvs [] ]\n            (if (= i (count v))\n              (if (= 1 (count subv))  subvs (conj subvs subv))\n              (if (> (nth v i) (last subv))\n                (recur (inc i) (conj subv (nth v i)) subvs )\n                (recur (inc i) (vector (nth v i)) (conj subvs subv)))))\n          result\n          (first (val (first (sort #(> (key %1) (key %2)) (group-by count lis)))))]\n      (if (< (count result) 2) [] result))))","user":"57235dc4e4b0c5bde472c0e2"},{"problem":53,"code":"(fn [xs]\n  (loop [last-item nil\n         origin-pairs xs\n         incs '()]\n    (if (empty? origin-pairs)\n      (let [ret (->> incs\n                     vec\n                     reverse\n                     (filter #(< 1 (count %))))]\n        (if (empty? ret)\n          []\n          (reduce #(if (< (count %1) (count %2)) %2 %1)\n                  ret)))\n      (let [head (first origin-pairs)]\n        (recur head\n               (rest origin-pairs)\n               (if (or (nil? last-item)\n                       (not= head (inc last-item)))\n                 (conj incs [head])\n                 (->> head\n                      (conj (first incs))\n                      (conj (rest incs)))))))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":53,"code":"(fn longest_inc_subseq_2 [s]\n  ((fn at_least_two [seq_b]\n    (if (> (count seq_b) 1)\n      (reverse seq_b)\n      []\n    )\n  )\n  ((fn get_longest_subseq [seqs]\n    (reduce\n      (fn is_longest [lst1 lst2]\n        (if (< (count lst1) (count lst2))\n          lst2\n          lst1\n        )\n      ) '() seqs\n    )\n  )\n  ((fn get_increasing_subseqs [seq_a] \n    (reduce\n      (fn place [lst item]\n        (if (= (first (first lst)) (- item 1))\n          (conj (rest lst) (conj (first lst) item))\n          (conj lst (conj nil item))\n        )\n      ) '() seq_a\n    )\n  )s)))\n)","user":"600b385ce4b074f607df668d"},{"code":"(fn [coll]\n    (let [geti (fn [z]\n    (loop [result []\n           progress []\n           elts z]\n        (cond\n            (empty? elts) (conj result progress)\n            (or (empty? progress) (< (last progress) (first elts)))\n                (recur result (conj progress (first elts)) (rest elts))\n            :else\n                (recur (conj result progress) [(first elts)] (rest elts)))))    \n          ls (filter #(< 1 (count %)) (geti coll))\n          _ (map count ls)\n          m (if (not (empty? _)) (apply max _) 0)]\n      (if (= 0 m) []\n        (first (filter #(= m (count %)) ls)))))","problem":53,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":53,"code":"(fn p-53 [s]\n  (let [p-53-helper\n        (fn prob-53-helper [biggest-seq current-seq s]\n          (if (empty? s)\n            biggest-seq\n            (let [next-elt (first s)\n                  rest-elts (rest s)\n                  last-current-elt (last current-seq)\n                  augmented-current (concat current-seq (list next-elt))]\n              (if (<= next-elt last-current-elt)\n                (prob-53-helper biggest-seq (list next-elt) rest-elts)\n                (if (< (count current-seq) (count biggest-seq))\n                  (prob-53-helper biggest-seq augmented-current rest-elts)\n                  (prob-53-helper augmented-current augmented-current rest-elts))))))\n        r (p-53-helper (list (first s)) (list (first s)) (rest s))]\n    (if (> (count r) 1) r [])))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(letfn [\n(increasing-tails [lst]\n  (let [fst (first lst)\n        snd (second lst)\n        rst (rest lst) ]\n    (cond\n      (nil? snd) (list fst)\n      (nil? fst) '()\n      (< fst snd) (cons fst\n        (increasing-tails rst))\n      :else (list fst))))\n\n(get-suffixes [lst]\n  (if (empty? lst) '()\n    (cons lst\n      (get-suffixes (rest lst)))))\n\n(longest-lst [a b]\n  (let [len-a (count a)\n        len-b (count b) ]\n    (cond\n      (and\n        (> 2 len-a) (> 2 len-b)) '()\n      (< len-a len-b) b\n      :else a)))\n]\n(fn longest-increasing-sub-seq [lst]\n  (reduce longest-lst\n    (map increasing-tails\n      (get-suffixes lst)))))","problem":53,"user":"4e356d2b535deb9a81d77f2d"},{"problem":53,"code":"(fn [col]\n  (let [windowed (partition 2 1 col)\n        inc? (fn [pair] (= (inc (first pair)) (last pair)))\n        get-longer (fn \n                     ([] '()) \n                     ([a b] (if (> (count b) (count a)) b a)))\n        longest (reduce get-longer (filter #(inc? (first %)) (partition-by inc? windowed)))]\n    \n    (if (empty? longest) [] (conj (apply vector (map first longest)) (last (last longest))))))","user":"5af4446de4b0cc2b61a3bc93"},{"problem":53,"code":"(fn liss [lst]\n  (first (reduce #(let [prev-val (last %1)\n                        max-liss (first %1)\n                        curr-liss (if (< prev-val %2)\n                                    (conj (second %1) %2)\n                                    (vector %2))]\n                    (if (> (count curr-liss) (max 1 (count max-liss)))\n                      [curr-liss curr-liss %2]\n                      [max-liss curr-liss %2]))\n                 [[] [] (first lst)] lst)))","user":"5733e4aee4b0cd1946bd0ffe"},{"code":"(fn longestsubseq [x]\n  (let [result\n        (last\n          (sort-by\n            count\n            (loop [x x\n                   out []]\n              (if (> (count x) 0)\n                (let [conseq-sub-seq\n                      (loop [y (rest x)\n                             subout [(first x)]]\n                        (if (and (> (count y) 0) (= (+ (last subout) 1) (first y)))\n                          (recur (rest y) (conj subout (first y)))\n                          subout))]\n                  (recur\n                    (apply vector (drop (count conseq-sub-seq) x))\n                    (conj\n                      out\n                      conseq-sub-seq)))\n                out))))]\n    (if (> (count result) 1)\n      result\n      [])))","problem":53,"user":"52dad8bde4b09f7907dd13be"},{"problem":53,"code":"#(->> %\n        (reduce (fn [[cur & rst :as r] nr]\n                  (if (or (empty? cur)\n                          (= (inc (last cur)) nr))\n                    (conj rst (conj cur nr))\n                    (conj r [nr])))\n                [[]])\n        (filter (fn [i] (> (count i) 1)))\n        (sort-by count)\n        last\n      \tvec)","user":"5ae0b67fe4b0837691e92c44"},{"code":"#(->> ((fn f [c]\n           (loop [run [(first c)]\n                  last (first c)\n                  c (next c)]\n             (cond\n              (empty? c) [run]\n              (< last (first c)) (recur (conj run (first c)) (first c) (rest c))\n              :else (concat [run] (f c))))) %)\n        (reverse)\n        (filter (fn [c] (>= (count c) 2)))\n        (apply max-key count []))","problem":53,"user":"52d6a9c2e4b09f7907dd1365"},{"code":"(fn [col]\n   (:longest (reduce (fn[{:keys [longest current-streak] :as ret} cur]\n                       (cond \n                        (empty? current-streak)(assoc ret :current-streak [cur])\n                        :else (if (= (inc (last current-streak)) cur)\n                                (let [new-streak (conj current-streak cur)]\n                                  (if (> (count new-streak) (count longest))\n                                    {:longest new-streak :current-streak new-streak}\n                                    (assoc ret :current-streak new-streak)))\n\n                                (assoc ret :current-streak [cur])\n                                ))\n                       ) {:longest [] :current-streak []} col)))","problem":53,"user":"525ed5f4e4b0cb4875a45db8"},{"code":"(fn [coll]\n (let [ my-find (fn my-find [colle]\n   (if (empty? colle) nil\n     (loop [coll (rest colle), startv (first colle), max-times 1, tmp (first colle), tmp-times 1 ]\n       (if (empty? coll) \n         (take max-times (iterate inc startv))\n         (let [x (first coll)]\n           (if (= x (+ tmp-times tmp))\n             (if (> (inc tmp-times) max-times)\n               (recur (rest coll) tmp (inc tmp-times) tmp (inc tmp-times))\n               (recur (rest coll) startv max-times tmp (inc tmp-times)))\n             \n             (recur (rest coll) startv max-times, x, 1)))))))]\n   (let [res (my-find coll)]\n    (if (< 1(count res) )\n      res\n      []))))","problem":53,"user":"5224a46ce4b01819a2de42e5"},{"code":"(fn [coll]\n    (->> coll\n      ; 1st. Make tails of coll.\n      (#(take-while identity (iterate next %)))\n      ; 2nd. Take only consecutive elements from the head for each list.\n      (map (fn [[c & cs]]\n             (loop [[x & xs] cs acc [c] z c]\n               (if (= (inc z) x) (recur xs (conj acc x) x) acc))))\n      ; 3rd. Take only vectors having 2 or more elements.\n      (filter #(< 1 (count %)))\n      ; 4th. Take the longest. Take the one appearing first if 2 or more have a same length.\n      (reduce #(if (< (count %2) (count %)) % %2) [])\n    ))","problem":53,"user":"4fd96694e4b05e33b9224f37"},{"problem":53,"code":"(fn [ xs ]\n  (loop [ xs xs longest [] current [] ]\n    (letfn [\n              (next-longest [longest current]\n                (if (and\n                      (>= (count current) 2)\n                      (> (count current) (count longest)))\n                 current\n                 longest))\n              (next-current [current c]\n                (if (and (last current) (> c (last current)))\n                  (conj current c)\n                  [c]))                                     ]\n      (if (empty? xs)\n        longest\n        (let [ [c & r] xs \n               n-c        (next-current current c)\n               n-l        (next-longest longest n-c)]\n          (recur r n-l n-c))))))","user":"54d6f22de4b0a52adc2e2023"},{"problem":53,"code":"(fn [x] (letfn [\n(split [x] (loop [ [f & r :as x] x, c [], ans [[]] ]\n    (cond (empty? x) (conj ans c)\n     (or (empty? c) (< (last c) f)) (recur r (conj c f) ans)\n     :else (recur r [f] (conj ans c))\n)))\n(max [x] (loop [ [f & r :as x] x, c [], n 0]\n          (cond (empty? x) c\n           (< n (count f)) (recur r f (count f))\n           :else (recur r c n))))\n] (let [ maxseq (max (split x))] (if(< 1 (count maxseq)) maxseq []))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn lisq [xs]\n  (letfn [(increasing? [xs]\n            (apply < xs))\n          (tails [xs] \n            (take-while seq (iterate rest xs)))\n          (prefices [xs]\n            (drop 2 (reductions conj [] xs)))]\n    (let [subseqs\n           (for [tl   (tails xs)\n                 pref (prefices tl)\n                 :when (increasing? pref)]\n             pref)\n          max-count\n            (apply max 0 (map count subseqs))]\n      (into [] (first (filter #(= (count %) max-count) subseqs))))))","problem":53,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn [xs]\n   (loop [i (count xs)]\n     (let [ t (->  (filter #(apply < %)  (partition  i 1 xs))\n               first\n               flatten\n               vec)]\n       (if (< i 2) []\n           (if  (= t [])\n             (recur (dec i))\n             t)))))","problem":53,"user":"52a04f0ee4b04e0c58e87bc1"},{"problem":53,"code":"(fn last-sub-seq [coll]\n  (let [a (reduce #(if (< (count %1) (count %2)) %2 %1)\n                  []\n                  (filter\n                    (fn [[[x1 x2]]] (< x1 x2))\n                    (partition-by\n                      #(apply < %)\n                      (partition 2 1 coll))))]\n    (concat (first a) (rest (map second a)))))","user":"565654dae4b0f9d632dd849f"},{"problem":53,"code":"(fn [sequence]\n     (loop [current-subseq []\n            longest-subseq []\n            rest-subseq sequence]\n       (if (empty? rest-subseq)\n         (if (>= (count longest-subseq) 2) longest-subseq [])\n         (let [current-item (first rest-subseq)\n               prev-item (last current-subseq)\n               is-increasing? (or (nil? prev-item) (< prev-item current-item))]\n           (if is-increasing?\n             (let [new-current-subseq (conj current-subseq current-item)\n                   new-longest-subseq (if (> (count new-current-subseq) (count longest-subseq)) new-current-subseq longest-subseq)]\n               (recur new-current-subseq new-longest-subseq (rest rest-subseq)))\n             (recur [] longest-subseq (cons current-item (rest rest-subseq))))))))","user":"53f891eee4b0de5c4184856d"},{"code":"(fn [l]\n    (let [foo (fn [x, l]\n                (loop [i x, j l, v []]\n                  (cond\n                    (and (= [] v) (not (= (inc i) (first j)))) v                   \n                    (= (inc i) (first j)) (recur (first j) (rest j) (conj v i))\n                    :else (conj v i)\n                    )))]\n      (last (sort #(compare (count %1) (count %2))\n                  (loop [s (first l), r (rest l), v []]\n                    (if (= '() r) v\n                      (recur (first r) (rest r) (conj v (foo s r)))))\n                  ))\n      )\n    )","problem":53,"user":"4f038567535dcb61093f6b0c"},{"problem":53,"code":"(fn [s]\n  ((fn [k] (if (empty? k) [] (first k)))\n   (sort-by\n    #(- (count %))\n    (filter\n     #(> (count %) 1)\n     (partition-by\n      #(= % :s)\n      (second (reduce\n               (fn [[a b] c] (vector c (conj (if (> c a) b (conj b :s)) c)))\n               (vector (first s) (vector (first s)))\n               (rest s))))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":53,"code":"(fn [x]\n    (->> (partition 2 1 x)\n          (partition-by (fn [[p1 p2]] (> p2 p1)))\n          (map #(conj (into [] (map first %)) (last (last %))))\n          (filter (fn [[a b]] (> b a)))\n          (reduce (fn [a b] (if (> (count b) (count a)) b a)) [])\n          )\n    )","user":"5950f0bfe4b066ee0a44ae9f"},{"problem":53,"code":"(fn [col]\n   (concat []\n           (last\n    (filter #(< 1 (count %) )\n     (sort-by count\n             (reduce (fn [element element2]\n                       (println element element2)\n                       (if (empty? element)\n                         (conj [] (vector element2))\n                         (if (= (inc (last (last element))) element2)\n                           (conj element (concat (last element) (vector element2)))\n                           (conj element (vector element2)))))\n                     [] col))))))","user":"55b0d315e4b002ce9d5cbc26"},{"code":"(fn longest-increasing-subseq [coll] \n  (let [ best (:best (reduce\n                        (fn [{:keys [best cur]} x]\n                          (let [cur (if (or (empty? cur) (> x (last cur)))\n                                      (conj cur x)  ; keep x if it's increasing\n                                      [x])]         ; else restart sequence with x\n                          {:best (if (> (count cur) (count best)) cur best) \n                           :cur cur}))\n                        {:best [] :cur []} \n                        coll))] \n    (if (<= 2 (count best)) best [])))","problem":53,"user":"4f6bab49e4b07046d9f4efb1"},{"code":"(fn [s]\n  (->\n   (reduce (fn [[current longest] item]\n             (if (and (not-empty current) (> item (peek current)))\n               (if (>= (count current) (count longest))\n                 [(conj current item) (conj current item)]\n                 [(conj current item) longest])\n               [[item] longest])); not setting longest when current was empty\n                                 ; covers the < length 2 case\n           [[] []]\n           s)\n   (second)))","problem":53,"user":"51a3b135e4b0e77c4ca60bf6"},{"code":"(fn [nums]\n       (let [zs (filter #(< 1 (count %))\n                        ((fn lis [[x & xs]]\n                           (let [[a b] (reduce (fn [[ms ns] n]\n                                                 (if (< (last ns) n)\n                                                   [ms (conj ns n)]\n                                                   [(conj ms ns) [n]]))\n                                               [[] [x]] xs)]\n                             (conj a b))) nums))]\n         (if (empty? zs)\n           []\n           (reduce #(if (< (count %1) (count %2)) %2 %1) zs))))","problem":53,"user":"4ee82223535d93acb0a66877"},{"problem":53,"code":"(fn [input]\n  (let [next? (fn [x y] (= y (inc x)))\n        longest (fn [xs ys] (if (> (count xs) (count ys)) xs ys))\n        collect (fn [[x & xs] acc curr]\n                  (cond (nil? x) (longest acc curr)\n                        (empty? curr) (recur xs acc [x])\n                        (next? (last curr) x) (recur xs acc (conj curr x))\n                        :else (recur xs (longest acc curr) [x])))\n        output (collect input [] [])]\n    (if (>= (count output) 2) output [])))","user":"5d80fa37e4b0915913b1d374"},{"problem":53,"code":"(fn [coll] \n  (let [ partitioned (partition 2 1 coll)\n      computation (reduce (fn [a v] \n            (let [current-seq (first a)\n                  max-seq (second a)\n                  next-seq (if (-> current-seq count (= 0)) \n                             v\n                             (concat current-seq [(last v)]))\n                  next-max-seq (if (<= (count max-seq) (count current-seq))\n                            next-seq\n                            max-seq)\n                  ]\n              (if (< (first v) (second v))\n                [ next-seq next-max-seq]\n                [ [] max-seq]\n                )\n              )) [[] []] partitioned) ]\n(second computation)\n))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn longest [s]\n  (let [incseqs (fn [s]\n                  (loop [s s cr {:curr [] :result []}]\n                    (println cr)\n                    (if (not (seq s)) (cond (empty? (:curr cr)) (:result cr)\n                                            :else (conj (:result cr) (:curr cr)))\n                        (recur (rest s) (cond (empty? (:curr cr)) (conj cr {:curr [(first s)]})\n                                              (= (inc (last (:curr cr))) (first s)) (conj cr {:curr (conj (:curr cr) (first s))})                              \n                                              :else {:curr [(first s)] :result (conj (:result cr) (:curr cr))})))))]\n    (let [tmp (first (sort-by #(- (count %)) (incseqs s)))]\n      (if (= (count tmp) 1) []\n          tmp))))","problem":53,"user":"4f0ef874535d0136e6c22328"},{"problem":53,"code":"(fn sub-s [sqn]\n  (letfn [(group-sequential [lsqn] \n            (loop [cel (first lsqn) sq (rest lsqn) ss [] res []]\n                  (if (nil? cel) \n                    (conj res ss)\n                    (if (= (last ss) (- cel 1))\n                      (recur (first sq) (rest sq) (conj ss cel) res)\n                      (recur (first sq) (rest sq) [cel] (conj res ss))))))]\n         (let [res (sort-by count (filter #(> (count %) 1) (group-sequential sqn)))]\n           (if (= nil (last res)) \n             []\n             (last res)))))","user":"5b11449ce4b0cc2b61a3be2d"},{"problem":53,"code":"(fn [arg]\n   (let [res (->> arg\n                  (reductions (fn [[acc prev] x]\n                                (if (< prev x)\n                                  [(conj acc x) x]\n                                  [[x] x])) [[] Integer/MIN_VALUE])\n                  (map first)\n                  sort\n                  last)]\n     (if (< (count res) 2) [] res)))","user":"560ee566e4b05f002753df57"},{"problem":53,"code":"(fn sub-seq [coll] (let [take-seq (fn [n pred coll]\n                                    (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n                                      (take (+ n hits -1) coll)))\n                         chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n                         parts (chop coll)\n                         seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n                         longest (apply max-key count seqs)]\n                     (if (< (count longest) 2)\n                       []\n                       longest)))","user":"5739c2fee4b0cd1946bd107a"},{"problem":53,"code":"(fn longest-increase [coll]\n    (loop [c (rest coll) previous-item (first coll) longest '() current-coll (cons (first coll) '())]\n      (if (empty? c)\n        (into [](reverse longest))\n        (let [current-item (first c)\n              increasing (> current-item previous-item)\n              cons-coll (if increasing (cons current-item current-coll) (cons current-item '()))\n              new-longest (if (and increasing (> (count cons-coll) (count longest))) cons-coll longest)]\n          (recur (rest c) current-item new-longest cons-coll)))))","user":"56f4cedce4b046a417f92063"},{"problem":53,"code":"(fn [xs]\n         (let [poop (map #(subvec xs %) (range (dec (count xs))))\n               subs (fn [xs] (map #(take % xs)\n                                  (range 2 (inc (count xs)))))\n               incr-subs (filter (partial apply <) (mapcat  subs poop))\n               ]\n           (if (seq incr-subs)\n             (let [longest-len (apply max (map count incr-subs))]\n               (first (filter #(= longest-len (count %)) incr-subs)))\n             [])))","user":"4db3393e535df7e46ed9b6cc"},{"problem":53,"code":"(fn longest-inc\n  ([s longest current] (cond\n                        (empty? s) longest\n                        (> (first s) (last current)) (let [new-current (conj current (first s))]\n                                                       (if\n                                                         (> (count new-current) (count longest))\n                                                         (recur (rest s) new-current new-current)\n                                                         (recur (rest s) longest new-current)))\n                        :else (recur (rest s) longest [(first s)])))\n  ([s] (let [result (longest-inc (rest s) [(first s)] [(first s)])]\n         (if (> (count result) 1) result []))))","user":"5ee93720e4b029a2061bbeb7"},{"code":"#(->> (map < % (cycle (rest %)))\n      (interleave %)\n      (partition-by not)\n      (filter (fn [x] (> (count x) 2)))\n      (sort-by (comp - count))\n      first\n      (filter integer?))","problem":53,"user":"52c69672e4b0c2d177d62110"},{"problem":53,"code":"(fn [xs]\n\n\n\n(let [res\n      (->>\n        (interleave xs (rest xs))\n        (partition 2)\n        (partition-by #(apply < %))\n        (filter #(apply < (first %)))\n        (reverse)\n        (cons ())\n        (apply max-key count)\n        )]\n  (if (empty? res) []\n                   (concat [(first (first res)) (second (first res))] (map second (rest res))))\n  ;res\n  )\n\n  )","user":"53ef3adfe4b0742d9025b0c9"},{"problem":53,"code":"#((fn [arg] (if (< 1 (second arg)) (first arg) []))\n    ((comp (juxt identity count) (partial apply max-key count) reverse)\n     (loop [x % coll [] scurr []]\n       (if (empty? x)\n         (if (seq scurr) (conj coll scurr) coll)\n         (let [curr (first x) last (last scurr)]\n           (if (= curr (if (nil? last) nil (inc last)))\n             (recur (rest x) coll  (conj scurr (first x)))\n             (recur (rest x) (if (seq scurr) (conj coll scurr) coll) [(first x)])))))))","user":"564b1ff8e4b0284900eef663"},{"problem":53,"code":"(fn largestSeq [coll]\n  (loop [c coll candidate [] currentHighest []]\n    (let [newHighest (if (and (> (count candidate) (count currentHighest)) (> (count candidate) 1)) candidate currentHighest)\n          fst (first c)]\n        (if (empty? c)\n        newHighest\n        (if (empty? candidate)\n          (recur (rest c) (vector fst) newHighest)\n          (if (< (last candidate) fst)\n            (recur (rest c) (conj candidate fst) newHighest)\n            (recur (rest c) (vector fst)\n              newHighest)))))))","user":"55e01f4ee4b050e68259b406"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n    ;; pair up the ith element with (i+1)th element\n    (rest)\n    (map vector coll)\n    ;; get increasing subsequences, if there are any\n    (partition-by #(let [[a b] %] (< a b)))\n    (filter #(let [[a b] (first %)] (< a b)))\n    ;; find the longest increasing subsequence, if there are any\n    (reduce #(if (>= (count %1) (count %2)) %1 %2) [])\n    ;; turn pairs back into a regular sequence, if there are any\n    (#(if (empty? %) % (cons (ffirst %) (map last %))))\n  )\n)","user":"5d2e5065e4b01671435dbcae"},{"problem":53,"code":"(fn [seq]\n  (->> (rest seq)\n       (reduce\n        (fn [acc val]\n          (let [last-subseq (last acc)\n                last-val (last last-subseq)]\n            (if (> val last-val)\n              (conj (vec (drop-last acc)) (conj last-subseq val))\n              (conj acc [val]))))\n        [[] [(first seq)]])\n       (remove #(= (count %) 1))\n       (sort)\n       (last)))","user":"60849bd6e4b0736b099e42f2"},{"code":"(fn [v]\n  (let [inc-pairs (filter #(<= (first %) (second %)) (partition 2 1 v))\n        iter (fn [results sub list-of-pairs]\n               (if (empty? list-of-pairs)\n                 results\n                 (let [fp (first list-of-pairs)\n                       rp (rest list-of-pairs)]\n                   (cond\n                     (and (seq rp) (apply = (first rp)))\n                       ; Dumping the pair that is a duplicate\n                       (recur results sub (rest rp))\n\n                     (or (empty? rp) (> (second fp) (ffirst rp)))\n                       ; Need to finish this sub, add it to the results\n                       (recur (conj results (concat sub fp)) '() rp)\n\n                     :else\n                       ; Continue building this sub-seq\n                       (recur results (concat sub (list (first fp))) rp)))))]\n\n    (vec (last (sort-by count (iter '() '() inc-pairs))))))","problem":53,"user":"4eed26af535d93acb0a668bb"},{"problem":53,"code":"(fn [v]\n  ((fn [[x [n]]] (if (zero? n) [] (take (inc n) x)))   \n   (last (sort-by (fn [[_ [n]]] n) \n                  (for [x (map #(drop % v) (range (count v)))                  \n                        y (map-indexed vector x)                  \n                        :when (= (+ (first x) (first y)) (second y))]                  \n                    [x y])))))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn [x]  \n  (let [part-by-diff (fn [f arr] (reduce \n                                  #(let [lastval (fn [da] (last (last da)))]\n                                     (if (f (lastval %1) %2)\n                                       (conj (vec (butlast %1)) (conj (last %1) %2))\n                                       (conj %1 [%2])\n                                     )\n                                   ) [] arr\n                                 ))]\n    (let [differ #(= %2 (+ (if (= %1 nil) -9999999 %1) 1))]\n      (let [parts #(part-by-diff differ x)]\n        (let [maxcount #(apply max (map count (parts)))]\n          (let [null-or-empty #(if (= % nil) [] %)]\n          (null-or-empty (first (filter #(and (= (count %) (maxcount)) (> (count %) 1)) (parts))))\n        ))\n      )\n    )\n  )\n)","problem":53,"user":"505caadfe4b0bcb5664c3d3e"},{"problem":53,"code":"(fn [coll]\n      (let [x (last (sort-by count (reduce #(if (= (last (last %1)) (dec %2))\n                                             (conj (pop %1) (conj (last %1) %2))\n                                             (conj %1 (vector %2)))\n                                           [] coll)))]\n        (if (= 1 (count x)) [] x)))","user":"55a372f1e4b0acc240e31537"},{"problem":53,"code":"#(reduce\n   (fn [last current]\n     (if (< (count last) (count current))\n       current\n       last))\n   '()\n   (filter\n    (fn [x]\n      (>= (count x) 2))\n    (reduce\n     (fn [xs x]\n       (let [last-list (peek xs) prevx (peek last-list)]\n         (cond (empty? last-list) (vector (vector x))\n               (= prevx (dec  x)) (assoc-in xs [(dec (count xs)) (count last-list)] x)\n               :else (assoc xs (count xs) (vector x)))))\n     []\n     %)))","user":"580e7761e4b0849f6811b753"},{"code":"(fn [input-seq]\n  (let [longest-subseq (fn [acc curr]\n                         (if (and (< 1 (count curr))\n                                  (< (count acc) (count curr)))\n                           curr acc))\n        all-subseqs (loop [input-seq input-seq\n                           last-seen (dec (first input-seq))                          \n                           acc-seqs []\n                           curr-seq []]\n                      (if (seq input-seq)\n                        (let [[head & tail] input-seq]\n                          (if (= head (inc last-seen))\n                            (recur tail head acc-seqs (conj curr-seq head))\n                            (recur tail head (conj acc-seqs curr-seq) [head])))\n                        (conj acc-seqs curr-seq)))]\n    (reduce longest-subseq [] all-subseqs)))","problem":53,"user":"4f45c72be4b0d56e7bb92b8a"},{"code":"(fn longest-subseq [xs]\n  (letfn [(aux [xs cur chl]\n            (let [a (first  xs)\n                  b (second xs)\n                  t (rest   xs)]\n              (cond\n               (not a)         (if (<= (count cur) 1) [] cur)\n               (and b (< a b)) (if (empty? chl)\n                                 (recur t cur [a b])\n                                 (recur t cur (conj chl b)))\n               (> (count chl)\n                  (count cur)) (recur t chl [])\n               :else           (recur t cur []))))]\n    (aux xs [] [])))","problem":53,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":53,"code":"(fn\n  [s]\n  (let [increasing-runs (loop [result [] remaining s]\n                          (if (empty? remaining)\n                            (identity result)\n                            (if (empty? result)\n                              (recur [(take 1 remaining)] (drop 1 remaining))\n                              (if (> (first remaining) (last (last result)))\n                                (recur (concat (drop-last 1 result) [(concat (last result) (take 1 remaining))]) (drop 1 remaining))\n                                (recur (concat result [(take 1 remaining)]) (drop 1 remaining)))))),\n        lengths-to-runs (group-by count increasing-runs),\n        first-and-longest (first (get lengths-to-runs (apply max (keys lengths-to-runs))))]\n    (if (< (count first-and-longest) 2) [] first-and-longest)))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"problem":53,"code":"(fn [coll]                                                                                                                                                      \n  (let [longest-seq (->> (reduce (fn [acc item]                                                                                                                              \n                                   (cond                                                                                                                                     \n                                     (= (ffirst acc) nil) (conj (rest acc) (conj (first acc) item))                                                                          \n                                     (= (inc (ffirst acc)) item) (conj (rest acc) (conj (first acc) item))                                                                   \n                                     :else (conj acc (list item))))                                                                                                          \n                                 '(())                                                                                                                                       \n                                 coll)                                                                                                                                       \n                         (sort-by count)                                                                                                                                     \n                         last                                                                                                                                                \n                         reverse                                                                                                                                             \n                         vec)]                                                                                                                                               \n    (if (> (count longest-seq) 1)                                                                                                                                            \n      longest-seq                                                                                                                                                            \n      [])))","user":"5410499de4b01498b1a719a6"},{"problem":53,"code":"#(loop \n      [s %1, l [], c []]\n      (if (empty? s) \n          l\n          (if (= c []) \n              (recur (rest s) l (conj c (first s))) \n              (if (= (inc (last c)) (first s))\n                  (if (> (inc (count c)) (count l))\n                      (recur (rest s) (conj c (first s)) (conj c (first s)))\n                      (recur (rest s) l (conj c (first s)))\n                  )\n                  (recur (rest s) l [(first s)])\n              )\n          )\n  \n      )\n  )","user":"5e79fcb9e4b085ba37836e08"},{"code":"(fn [out-coll]\n  (let\n    [all-subseqs-from (fn [start coll]\n                        (map #(subvec coll (first %) (second %))\n                             (map #(vector start %)\n                                  (take (- (count coll) start)\n                                        (iterate inc (inc start))))))\n     generate-subseqs (fn [coll]\n                        (mapcat #(all-subseqs-from % coll)\n                                (range (count coll))))\n     up-longer? (fn [orig new]\n                  (if (and (apply < new) \n                           (> (count new) (count orig))\n                           (not= 1 (count new)))\n                    new\n                    orig))\n     result (atom [])]\n    (do\n    \t(doseq [ss (generate-subseqs out-coll)]\n      \t\t(swap! result up-longer? ss))\n      \t@result)))","problem":53,"user":"52d340ebe4b099d49816f0c1"},{"code":"(fn [coll]\n  (apply max-key count\n         (reverse (conj (map (fn [s] (cons (ffirst s) (map #(last %) s)))\n                             (remove (fn [[[a b]]] (> a b))\n                                     (partition-by (fn [[a b]] (< a b))\n                                                   (partition 2 1 coll))))\n                        []))))","problem":53,"user":"51b38769e4b026427ecf067f"},{"problem":53,"code":"(fn max-seq [xs]\n  (letfn [(ss\n            ([xs] (ss xs []))\n            ([xs results]\n             (if (seq xs)\n               (if (or  (empty? results) (<= (first xs) (last (last results))))\n                 (ss (rest xs) (conj results [(first xs)]))\n                 (ss (rest xs)\n                     (conj (pop results) (into [] (concat (last results) [(first xs)])))))\n               results)))]\n    (->> (ss xs)\n         ((fn [results]\n            (let [maxcount (apply max (map count results))]\n              (filter #(and (= (count %) maxcount) (> (count %) 1)) results))))\n         (#(if (empty? %) [] (first %))))))","user":"5ec3a13ae4b08d0ec38692b9"},{"code":"(fn [s]\r\n    (->> (map #(vector %1 (- %2 %1)) s (range))\r\n         (partition-by second)\r\n         (reduce (fn [[best len] item]\r\n                   (let [c (count item)]\r\n                     (if (> c len) [item c] [best len]))) '([] 1))\r\n         first\r\n         (map first)))","problem":53,"user":"4f047177535dcb61093f6bc6"},{"problem":53,"code":";(print (\n(fn [coll]\n  (loop [[f & r] coll\n         temp (vector f)\n         res []]\n    (if (nil? r)\n      (if (not (and (< (count temp) 2) (< (count res) 2)))\n        (if (> (count temp) (count res))\n          temp\n          res)\n        [])\n      (if (= (inc f) (first r))\n        (recur r\n               (concat [] temp (vector (first r)))\n               res)\n        (recur r\n               (vector (first r))\n               (if (> (count temp)\n                      (count res))\n                 temp\n                 res))))))\n;[1 3 2 4 3 6 3]))\n;[1 2 3 4 5 1 2 3 3 4 5 6 7 8 9]))\n#_(print (concat [] (vector 4)))\n#_(let [[f & r] [1 2 3 4]]\n  r)\n#_(count [])","user":"5c5d2e90e4b01df32ab732af"},{"problem":53,"code":"(fn longest-subseq [s]\n  (let [l (count s)]\n    (or (first\n         (sort-by count >\n                  (filter #(every? (partial apply <) (partition 2 1 %))\n                          (apply concat (map (fn [n] (map #(take % (drop n s))\n                                                          (range 2 (inc (- l n)))))\n                                             (range (dec l))))))) [])))","user":"575b3e9be4b02ea11479935b"},{"problem":53,"code":"(fn [coll]\n  (loop [greatest-sub-seq []\n         current-sub-seq []\n         coll coll]\n    (let [current (first coll)\n          greatest (last current-sub-seq)]\n      (cond\n        (empty? coll) (if (>= (count greatest-sub-seq) 2) greatest-sub-seq [])\n        (or (nil? greatest) (= (dec current) greatest))\n          (recur\n            (if (<= (count greatest-sub-seq) (count current-sub-seq)) (conj current-sub-seq current) greatest-sub-seq)\n            (conj current-sub-seq current)\n            (rest coll))\n        :else (recur greatest-sub-seq [current] (rest coll))))))","user":"55842c7ee4b05c286339e11d"},{"problem":53,"code":"#(loop [s (rest %), acc [(first %)] ,longest []]\n    (let [head (first s), tail (rest s)]\n      (cond (empty? s) (if (= 1 (count longest)) []\n                           (if (> (count acc) (count longest))\n                             acc longest))\n            (= (last acc) (dec head)) (recur tail\n                                             (conj acc head)\n                                             longest)\n            (> (count acc) (count longest)) (recur tail\n                                                   [head]\n                                                   acc)\n            :else (recur tail [head] longest))\n      ))","user":"57035ccfe4b08d47c97781ef"},{"problem":53,"code":"(fn longest-consec-subseq [coll]\n  (loop [res []\n         curr []\n         els coll]\n    (if (not (seq els)) (if (>= (count res) 2) res [])\n      (let [f (first els)\n            updated-curr (if (or (empty? curr)\n                                 (> f (last curr))) \n                           (conj curr f)\n                           [f])\n            ]\n        (if (> (count updated-curr) (count res))\n          (recur updated-curr updated-curr (rest els))\n          (recur res updated-curr (rest els))\n          )\n        )\n      )\n    )\n  )","user":"57ca95f2e4b05aa3c4741d3b"},{"code":"(fn [s]\n    (let [g\n          (filter (fn [[x y]] (< x y))\n                  (reduce #(if (< (count %) (count %2)) %2 %)\n                          (partition-by \n                            (fn [[a b]] (< a b))\n                            (partition 2 1 s))))]\n      (if (empty? g)\n        []\n        (into [(first (first g))] (map (fn [[a b]] b) g)))))","problem":53,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"code":"(fn x [s] \n  (last \n    (reduce \n     (fn al [[cur max], el]\n      (let [is-greater? (pos? (compare el (last cur)))\n            cur (if is-greater? (conj cur el) [el])\n            max (if (and (> (count cur) (count max)) (> (count cur) 1)) cur max)]\n      [cur max]))\n     [[] []] s)))","problem":53,"user":"51aefceee4b09397d5109797"},{"problem":53,"code":"(fn myfunc [x] \n  (->> (reductions #(if (< (last %1) %2) (conj %1 %2) [%2]) [(inc (first x))] x)\n  \t   (reduce #(if (>= (count %1) (count %2)) %1 %2)) \n       (#(if (= 1 (count %)) [] %))))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(fn inc-subseq [x]\n    (loop [x x best []]\n        (if (zero? (count x))\n            best\n            (let [inc-seq (reduce #(concat (drop-last %1) %2) [] (take-while #(< (first %) (second %)) (partition 2 1 x))) \n                length (count inc-seq)]\n                (recur (drop (max 1 length) x) (if (> length (count best)) inc-seq best))))))","problem":53,"user":"521249f5e4b06aa6d1666ba2"},{"problem":53,"code":"(fn [s] \n  (let [a (partition 2 1 s)\n        b (partition-by #(apply < %) a)\n        c (filter (fn [[[x1 x2]]] (< x1 x2)) b)\n        d (sort-by count > c)\n        e (first d)]\n    (concat (first e) (map last (rest e)))))","user":"555a5731e4b0deb715856e44"},{"problem":53,"code":"(fn longest-subseq [coll] \n          (->> (reduce (fn [[acc1 acc2] item]               \n          (if (= (count acc1) 0) [(conj [] item) acc2]  \n          (if (= item (+ (last acc1) 1))       \n          [(conj acc1 item) acc2]                      \n          (if (> (count acc1) 1) [(conj [] item)  (conj acc2 acc1)] \n          [(conj [] item) acc2]   ))))                  \n          [[] []] coll)\n          (map #(flatten % ))\n          (sort-by count)\n          (filter #(< 1 (count %)))\n          (last)\n          (into [])))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"problem":53,"code":"(fn [s]\n      (loop\n        [x s, result [], longest []]\n        (let [c (first x), sr (count result), sl (count longest)]\n             (if (empty? x)\n               (if (> sr sl) (if (= sr 1) [] result) (if (= sl 1) [] longest))\n               (recur\n                 (rest x)\n                 (if (= (last result) (- c 1)) (conj result c) [c] )\n                 (if (> sr sl) result longest)\n               ))\n             )\n        )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":53,"code":"(fn [y] (letfn [(lgst [x] (loop [m [] h [] coll x] (let [y (first coll) rst (rest coll)]\n          (cond \n           (not y) (if (> (count h) (count m)) h m)\n           (or (empty? h) (> y (peek h))) (recur m (conj h y) rst)\n           (> (count h) (count m)) (recur h [y] rst)\n           :else (recur m [y] rst)\n          )\n        )))] (let [a (lgst y)] (if (= 1 (count a)) [] a))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"#(let [start-seq %]\n    (loop [c-seq start-seq\n           longest-seq []\n           current-seq []]\n      (if (empty? c-seq)\n        (if (and (> (count current-seq) 1) (> (count current-seq) (count longest-seq)))\n          current-seq\n          longest-seq)\n        (let [smallest (first c-seq)\n              rest-seq (rest c-seq)]\n          (if (or  (empty? current-seq)  (= (last current-seq) (- smallest 1)))\n            (recur rest-seq longest-seq (conj current-seq smallest))\n            (if (and (> (count current-seq) 1 ) (> (count current-seq) (count longest-seq)))\n              (recur rest-seq current-seq [smallest])\n              (recur rest-seq longest-seq [smallest])))))))","problem":53,"user":"523288fee4b035af41902a88"},{"problem":53,"code":"#(first (reduce\n (fn [[longest current] x]\n   (let [\n       next_current (if (> x (last current)) (conj current x) [x])\n       next_longest (if (> (count next_current) (count longest)) next_current longest)\n       next_longest (if (> (count next_longest) 1) next_longest [])\n     ]\n       [next_longest next_current]\n   )\n )\n [ [ ] [ Double/POSITIVE_INFINITY ] ]\n %))","user":"53fcb8f7e4b0de5c418485d4"},{"problem":53,"code":"(fn [v]\n  (let [vs (->> v\n                (partition 2 1)\n                (partition-by (partial apply <))\n                (filter #(< (ffirst %) (second (first %))))\n                reverse\n                (apply max-key count []))]\n    (into (mapv first (butlast vs)) (last vs))))","user":"554b8572e4b0a04f79299589"},{"problem":53,"code":"(fn longest-subseq [coll]\n  (let [take-seq (fn [n pred coll]\n                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n        parts (chop coll)\n        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (< (count longest) 2)\n      []\n      longest)))\n\n;; https://webcache.googleusercontent.com/search?q=cache:5F-HYDOTqlcJ:https://gist.github.com/SegFaultAX/3607101+&cd=1&hl=en&ct=clnk&gl=us&client=safari","user":"5897dda4e4b00487982d52c8"},{"problem":53,"code":"(fn [x] (loop [a x b [0]]\n           (if (< (count a) 2) \n             (take (if (= 0 (apply max b)) 0 (inc (apply max b))) \n                   (drop (- (first (some #(if (= (apply max b) (second %)) %) (map-indexed vector b))) (apply max b)) x))\n                          (if (< (first a) (first (rest a)))\n                            (recur (rest a) (conj b (inc (last b))))\n                            (recur (rest a) (conj b 0))))))","user":"5910a43de4b0163c97b36ebf"},{"code":"(fn [lst]\n  (or (last (apply sorted-set (filter #(>= (count %) 2) (reduce\n  \t(fn [lsts el]\n    \t(let [\n          current-list (first lsts)\n          prev-el (last current-list)\n          ]\n\t\t\t(if (< prev-el el)\n\t\t\t\t(cons (conj current-list el) (rest lsts))\n      \t\t\t(cons [el] lsts))))\n  [[(first lst)]] (rest lst))))) [] )\n)","problem":53,"user":"522d3a16e4b0e26240291d50"},{"problem":53,"code":"(fn [xs1]\n  (loop [xs (rest xs1)\n         result []\n         collect [(first xs1)]]\n    (if (empty? xs)\n      (reduce #(if (>= (count %1)(count %2)) %1 %2) [] (filter #(>= (count %) 2) (conj result collect)))\n      (if (< (last collect)\n           (first xs))\n        (recur (rest xs) result (conj collect (first xs)))\n        (recur (rest xs) (conj result collect) [(first xs)]))\n      )\n    ))","user":"54187e84e4b01498b1a71a1b"},{"problem":53,"code":"(fn inc-subsequence [s]\n    ((fn help [remaining\n               global-longest\n               current-subseq]\n       (if (empty? remaining)\n         (if (or (>= (count current-subseq) 2)\n                 (>= (count global-longest) 2))\n           (if (> (count current-subseq)\n                  (count global-longest))\n             current-subseq\n             global-longest)\n           [])\n         (help (rest remaining)\n               (if (> (count current-subseq)\n                      (count global-longest))\n                 current-subseq\n                 global-longest)\n               (if (> (first remaining)\n                      (last current-subseq))\n                 (conj current-subseq\n                       (first remaining))\n                 [(first remaining)]))))\n     (rest s)\n     []\n     [(first s)]))","user":"54d26316e4b0e8a36923e5f2"},{"problem":53,"code":"#(->> %\n       (reduce (fn [[current longest] nextVal]\n         (let \n           [newCurrent \n             (if (empty? current)\n               [nextVal]\n               (if (= (last current) (dec nextVal))\n                 (do\n                   (println (conj current nextVal))\n                   (conj current nextVal))\n                 [nextVal]))\n            newLongest \n              (do\n                (println (str \"count longest \" (count longest) \", count newCurrent \" (count newCurrent)))\n                (if (>= (count longest) (count newCurrent))\n                  longest\n                  (if (> 2 (count newCurrent))\n                    longest\n                    newCurrent)))]\n           (do\n             (println (str \"newLongest now \" newLongest))\n             [newCurrent newLongest])))\n         [[][]])\n      (last))","user":"5dd90e4fe4b0948ae9d9ad99"},{"code":"(fn max-con-seq [coll]\n  (let [[acc, cur] (reduce\n                    (fn [[acc cur lst] item]\n                     (cond\n                      (nil? lst)                  [acc (conj cur item) item]\n                      (= (inc lst) item)          [acc (conj cur item) item]\n                      (> (count cur) (count acc)) [cur, [item], item]\n                      :else                       [acc, [item], item]))\n                    [[] [] nil]\n                    coll)\n        sub-res (if (> (count cur) (count acc)) cur acc)\n        res (if (= 1 (count sub-res)) [] sub-res)]\n    res))","problem":53,"user":"5245fbbbe4b09dbe66b56183"},{"code":"(fn [input]\n\t\t(->> input\n\t\t\t(partition 2 1)\n\t\t\t(map #(if (< (first %) (second %)) % []))\n\t\t\t(partition-by empty?)\n\t\t\t(reduce #(if (< (count %1) (count %2)) %2 %1) [] )\n\t\t\t(apply concat)\n\t\t\t(distinct)\n\t\t))","problem":53,"user":"52bf6946e4b07a9af5792334"},{"problem":53,"code":"(fn longest-subseq\n   [s]\n   (loop [rem-s (rest s)\n          max-len 1\n          max-len-seq nil\n          curr [(first s)]\n          curr-len 1]\n     (println [rem-s max-len max-len-seq curr curr-len])\n     (cond\n      (empty? rem-s)\n      (if (> curr-len max-len)\n        curr\n        (or max-len-seq []))\n      \n      (> (first rem-s) (last curr))\n      (if (> (inc curr-len) max-len)\n      \t(recur (rest rem-s) \n               (inc curr-len) \n               (conj curr (first rem-s)) \n               (conj curr (first rem-s)) \n               (inc curr-len))\n        (recur (rest rem-s) \n               max-len \n               max-len-seq \n               (conj curr (first rem-s)) \n               (inc curr-len)))\n      \n      :else\n      (recur (rest rem-s) \n             max-len \n             max-len-seq \n             [(first rem-s)] \n             1))))","user":"5ce6f93be4b0a17bb84e2b99"},{"code":"(fn [xs]\n  (letfn [(tails [xs]\n            (if (seq xs)\n              (cons xs (tails (rest xs)))\n              ()))\n          (longest-prefix [xs]\n            (if (seq xs)\n              (let [x (first xs)\n                    paired (map vector xs (iterate inc x))\n                    paired-prefix (take-while (fn [[a b]] (= a b))\n                                              paired)]\n                (map first paired-prefix))))]\n    (let [p (->> xs tails (map longest-prefix) (apply max-key count))]\n      (if (> (count p) 1)\n        p\n        ()))))","problem":53,"user":"52487654e4b05ef8e38e63dc"},{"code":"#(first (reduce (fn [[l c] x]\n          (if (and (seq c) (> x (last c)))\n            (let [nc (conj c x)]\n              (if (> (count nc) (count l))\n                [nc nc]\n                [l nc]\n                )\n              )\n            [l (vector x)]\n            )\n          )\n        [() ()]\n        %))","problem":53,"user":"522f483ce4b032bbe342415a"},{"problem":53,"code":"(fn[s](let [c count d (c s)]\n    (apply max-key c\n              (remove\n               #(= (c %) 1)\n               (map\n                (fn [n]\n                   (keep-indexed\n                    #(#{%2}(- %1 n)) s))\n                (range (- d) d))))))","user":"5e042dede4b0a607a9a45d69"},{"problem":53,"code":"(fn longest-subseq [vct]\n  (loop [acc (list (first vct))\n         stored []\n         vct (rest vct)]\n    (if (empty? vct)\n      (let [ret (first (sort #(> (count %1) (count %2)) (conj stored acc)))]\n        (if (>= (count ret) 2)\n          ret\n          []))\n      (recur (if (> (first vct) (last acc))\n               (concat acc (list (first vct)))\n               (list (first vct)))\n             (if (> (first vct) (last acc))\n               stored\n               (conj stored acc))\n             (rest vct)))))","user":"54084784e4b0addc1aec66c9"},{"code":"(fn [l]\n\t(loop [biggest '() sorted (list (first l)) l (rest l)]\n\t\t(if (empty? l)\n\t\t\t(let [ret (last (sort-by count (conj biggest (reverse sorted))))]\n\t\t\t\t(if (< (count ret) 2)\n\t\t\t\t\t'()\n\t\t\t\t\tret))\n\t\t\t(if (= (first sorted) (- (first l) 1))\n\t\t\t\t(do (println biggest sorted l) (recur biggest (conj sorted (first l)) (rest l)))\n\t\t\t\t(do (println biggest sorted l) (recur (conj biggest (reverse sorted)) (list (first l)) (rest l)))))))","problem":53,"user":"51757af0e4b085adf681d873"},{"problem":53,"code":"(fn f [c]\n  (let [seq-inc (fn [c]\n                  (first\n                   (reduce\n                    (fn [[so-far p] c]\n                      (if (< p c)\n                        [(update-in so-far [(dec (count so-far))] conj c) c]\n                        [(conj so-far [c]) c]))\n                    [[[(first c)]] (first c)]\n                    (rest c))))]\n    (apply max-key count [] (filter #(not= 1 (count %)) (reverse (seq-inc c))))))","user":"4ec1923f535dfed6da9c6db2"},{"problem":53,"code":"(fn longest-inc-sub-seq [colls]\n  (let [res (->> (range 1 (count colls))\n                 (reduce #(if (<= (nth colls %2) (nth colls (dec %2)))\n                            (conj %1 {:start %2 :end %2 :length 1})\n                            (conj (rest %1) (-> %1\n                                                first\n                                                (update-in [:end] inc)\n                                                (update-in [:length] inc))))\n                         '({:start 0 :end 0 :length 1}))\n                 (filter #(not= 1 (:length %)))\n                 (sort-by (juxt :length #(- (count colls) (:start %))))\n                 last)]\n    (if res\n      (subvec colls (:start res) (inc (:end res)))\n      [])))","user":"5a67cedbe4b0512ff01cd9ee"},{"problem":53,"code":"(fn[xs]\n\n\t(loop [ys xs  hm {} acc [0]]\n\n\t\t(if (empty? ys)\n;;\t\t\tacc\n;;\t\t\t(val (apply max-key val hm))\n\t\t\t;hm\n\t\t\t;(into hm { (.length acc) acc})\n\t\t\t;(#(get % (apply max ( keys %))) hm)\n\t\t\t(#(get % (apply max ( keys %))) (into hm { (.length acc) (if (= (.length acc) 1) []  acc )}))\n\t\t\t(\n\t\t\t\trecur (rest ys)\n\t\t\t\t      (if (= (inc (last acc)) (first ys))\n\t\t\t\t      \t  hm\n\t\t\t\t      \t  ;(into hm { (.length acc) acc})\n\t\t\t\t      \t  (into hm { (.length acc) (if (= (.length acc) 1) []  acc )})\n\t\t\t\t      )\n\t\t\t\t      (if (= (inc (last acc)) (first ys))\n\t\t\t\t      \t(conj acc (first ys))\n\t\t\t\t      \t(conj [] (first ys))\n\t\t\t\t      )\n\t\t\t)\n\t\t\t)\n\t)\n\t\t\n )","user":"55d7312ee4b0e31453f64a9f"},{"problem":53,"code":"(fn [xs] (let [pairs\n                 (->> xs\n                      (partition-all (count xs) 1)\n                      (map (fn [ys]\n                             (->> ys\n                                  (partition 2 1)\n                                  (take-while\n                                   (fn [[a b]] (< a b))))))\n                      (reduce #(if (< (count %1) (count %2)) %2 %1) []))\n               result (reduce #(conj %1 (second %2)) [(ffirst pairs)] pairs)]\n  (if (>= (count result) 2) result [])))","user":"5fe0d4d4e4b05ac5b16ea164"},{"problem":53,"code":"(fn longest-subseq [coll]\n  (let [take-seq (fn [n hh coll]\n                   (let [hits (count (take-while #(apply hh %) (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n        parts (chop coll)\n        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (< (count longest) 2)\n      []\n      longest)))","user":"5cd4e1b2e4b0ccb061962927"},{"problem":53,"code":"(fn[a]\n  (reduce #(if (> (count %2) (count %1)) %2 %1)\n          []\n          (filter #(> (count %) 1)\n                  (reductions #(if (> %2 (or (last %1) Integer/MIN_VALUE)) (conj %1 %2) [%2])\n                              []\n                              a))))","user":"58d96bdce4b0a4d5acaab638"},{"problem":53,"code":"(fn lseq\n  ([coll] (lseq coll []))\n\n  ([[head & [nxt :as tail]] result]\n   (if tail\n     (if (= (inc head) nxt)  \n       (lseq (rest tail) result [head nxt])\n       (recur tail result))\n     (if (empty? result)\n       result\n       (first (sort-by count > result)))))\n\n  ([[head & [nxt :as tail] :as coll] result acc]\n   (if (= (inc (last acc)) head)  \n     (recur tail result (conj acc head))\n     (lseq coll (conj result acc)))))","user":"5b632851e4b0c6492753e72d"},{"problem":53,"code":"(fn [coll]\n  (loop [c (rest coll)\n         n (first coll)\n         r [[n]]]\n    (if (seq c)\n      (recur\n        (rest c)\n        (first c)\n        (if (= (inc n) (first c))\n          (cons (cons (first c) (first r)) (rest r))\n          (cons [(first c)] r)))\n      (let [res (reverse (last (sort-by count r)))]\n        (if (< 1 (count res)) res [])\n        )\n      )\n    )\n  \n  )","user":"529dfc6de4b04e0c58e87b8a"},{"code":"(fn [coll]\n  (let [increasing? (fn [c] (apply < c))]\n    (loop [ret [] current [] c coll]\n      (cond\n       (and (empty? c) (< (count ret) 2))\n       []\n       (empty? c)\n       ret\n       (and (increasing? (conj current (first c))) (< (count ret) (inc (count current))))\n       (recur (conj current (first c)) (conj current (first c)) (rest c))\n       (increasing? (conj current (first c)))\n       (recur ret (conj current (first c)) (rest c))\n       :else\n       (recur ret [(first c)] (rest c))))))","problem":53,"user":"4e89ff3d535d3e98b802328a"},{"problem":53,"code":"(fn [coll]\n  (let [candidates \n         (->> (range (count coll))\n          (drop 2)\n          (mapcat #(partition % 1 coll))\n          (filter (partial apply <))\n          reverse)]\n    (if (empty? candidates)\n      []\n      (apply max-key count candidates))))","user":"585d9558e4b0f14aab7c879c"},{"code":"(fn [coll]\n  (loop [coll coll curr [] longest []]\n    (if (seq coll)\n      (if (empty? longest)\n        (recur (next coll) [(first coll)] [(first coll)])\n        (if (> (first coll) (if (last curr) (last curr) -1))\n          (let [curr (conj curr (first coll))]\n            (recur (next coll) curr (if (> (count curr) (count longest)) curr longest)))\n          (recur (next coll) [(first coll)] longest)))\n      (if (>= (count longest) 2)\n        longest\n        []))))","problem":53,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":53,"code":"(fn [c]\n  (let [f #(first %)\n        m (map vector c (rest c))\n        p (partition-by #(< (f %) (last %)) m)\n        r (fn [c] (reduce #(concat %1 [(last %2)]) (f c) (rest c)))\n        a (filter #(< (f %) (last %)) (map r p))]\n    (if (empty? a) '() (apply max-key count (reverse a)))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn f [l]\n   (letfn [(increasing [[h & t]]\n             (if (and t (< h (first t)))\n               (cons h (increasing t))\n               (list h)))]\n     (let [longest (reduce\n            (fn [max cand] (if (< (count max) (count cand)) cand max))\n            (map increasing (take-while (comp not empty?) (iterate rest l))))]\n       (if (> (count longest) 1) longest []))))","problem":53,"user":"4fc8c8d8e4b0ee37620e183b"},{"problem":53,"code":"(fn [col] (reduce (fn [maxsofar, current] \n          (if \n            (and (> (count current) (count maxsofar)) (> (count current) 1))\n            current\n            maxsofar\n          )\n         )\n        []\n        (reduce \n   (fn [agg item] \n     (if (or\n          (= nil (last (last agg)))\n          (> item (last (last agg)))\n          )\n       (concat \n        (butlast agg) \n        [(conj (last agg) item)]\n        )\n       (concat agg [[item]])\n       )        \n    )\n\t  [[]]\n    col\n)\n))","user":"53d5e45ae4b0e771c302544e"},{"problem":53,"code":"(fn [coll]\n  (->> (mapcat #(partition % 1 coll) (range 2 (inc (count coll))))\n       (filter (partial apply <))\n       (cons [])\n       (sort-by count >)\n       first))\n;; alternate version (or instead of keeping them all and sorting them, we could keep the longest so far, and the current candidate (either in a map, or in a vector))\n;(fn [coll]\n;  (or (first\n;       (sort-by\n;        (comp - count)\n;        (filter\n;         #(> (count %) 1)\n;         (reduce (fn [result elem]\n;                   (if (> elem (or ((comp last last) result) 0))\n;                     (conj (vec (butlast result)) (conj (vec (last result)) elem))\n;                     (conj (vec result) [elem])))\n;                 []\n;                 coll))))\n;      []))","user":"60794173e4b0a637ed78035d"},{"code":"(fn [x]\n  (loop [my-x x\n         acc []]\n    (if (empty? my-x)\n      (let [result (first (filter #(= (count %) (apply max (map count acc))) acc))]\n        (if (> (count result) 1)\n          result\n          []\n        )\n      )\n      (let [new-acc (loop [current-x my-x\n                           index 0\n                           continue true]\n                      (do\n                        (if (not continue)\n                          (do\n                            (println acc)\n                            (println index)\n                            (println (take (+ 1 index) my-x))\n                            (concat acc (list (take (+ 1 index) my-x)))\n                          )\n                          (let [this-obj (first current-x)\n                                next-obj (fnext current-x)\n                                still-continue (if (nil? next-obj)\n                                                 false\n                                                 (= (+ 1 this-obj) next-obj))\n                                next-index (if still-continue\n                                             (+ index 1)\n                                             index\n                                           )]\n                            (recur (rest current-x) next-index still-continue)\n                          )\n                        )\n                      )\n                    )\n            ]\n        (recur (rest my-x) new-acc)\n      )\n    )\n  )\n)","problem":53,"user":"5303a027e4b0d8b024fd3745"},{"problem":53,"code":"(fn\n  [xs]\n  (loop [all xs\n         longest []\n         temp []]\n    (cond\n      (and (seq all) (< (first all) (or (second all) (Integer/MAX_VALUE))))\n        (recur (rest all) longest (conj temp (first all)))\n      (and (seq all) (> (first all) (or (second all) (Integer/MIN_VALUE))))\n        (if (> (count (conj temp (first all))) (count longest))\n          (recur (rest all) (conj temp (first all)) [])\n          (recur (rest all) longest []))\n      (and (seq all) (= (first all) (second all)))\n        (if (> (count longest) (count temp))\n          (recur (rest all) longest [])\n          (recur (rest all) temp []))\n      :else \n          (cond\n            (and (< (count longest) 2) (< (count temp) 2)) []\n            (>= (count longest) (count temp)) longest\n            :else temp))))","user":"5574c172e4b05c286339e059"},{"code":"(fn [coll]\n  (let [monotones (partition-by #(apply < %) (partition 2 1 coll))\n        increases (filter #(apply < (first %)) monotones)]\n    (if (empty? increases) []\n      (let [by-count (group-by count increases)\n            best (first (by-count (apply max (keys by-count))))]\n        (concat (map first best) [(last (last best))])))))","problem":53,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [c]\n  ((fn [coll rs max]\n    (if (empty? coll) max\n      (let [pre (last rs)\n            cur (first coll)\n            matched? (= (+ pre 1) cur)\n            new-rs (conj rs cur)\n            new-max (if (and (> (count new-rs) 1) (>= (count rs) (count max))) \n                      new-rs \n                      max)\n          ]\n        (if matched?\n            (recur (rest coll) new-rs new-max)\n            (recur (rest coll) [cur] max)))))\n  (rest c) [(first c)] []))","problem":53,"user":"4f3242bae4b0d6649770a08f"},{"problem":53,"code":"(fn [s]\n  (if-let [longest\n         (last\n           (sort-by count\n             (filter #(= 1 (ffirst %))\n               (partition-by first\n                 (conj (map (fn [prev next index]\n                               [(- prev next) index])\n                            (drop 1 s) s (range 1 1000)) [0 0])))))]\n  (let [longest-len (+ 1 (count longest))\n        second-number (last (first longest))\n        start (- second-number 1)\n        result (take longest-len (drop start s))]\n    result)\n  []))","user":"571543bbe4b07c98581c3ad4"},{"problem":53,"code":"(fn maxSub [coll]\n(let [maxSeq\n(apply max-key count\n(reduce \n  (fn [seqs n]\n    (let [lastSeq (get seqs 1)\n          curSeq (get seqs 0)\n          prev (last curSeq)]\n        (if (or (= prev nil )(= (inc prev) n))\n          (assoc seqs 0 (conj curSeq n))\n          (assoc (assoc seqs 1 (apply max-key count (list curSeq lastSeq))) 0 [n])))) \n  [[] []] \n  coll))] \n  (if (= (count maxSeq) 1)\n    []\n    maxSeq)))","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn [s] \n  (let [\n    inord #(< (first %) (second %))\n    pairs \n      (reduce #(if (< (count %) (count %2)) %2 %) '() \n        (filter #(inord (first %))\n          (partition-by inord\n            (map #(list % %2) s (rest s)))))\n        ]\n  (if (empty? pairs) '() \n    (cons (first (first pairs)) (map last pairs)))))","problem":53,"user":"4f569218e4b0a7574ea71826"},{"problem":53,"code":"(fn [c]\n  (let [l (apply max-key count (reverse (partition-by #(>= (first %) (second %)) (map list c (rest c)))))\n        x (first l)]\n    (if (< (second x) (first x))\n      []\n      (cons (first x) (map second l)))))","user":"563b1553e4b0bfe05bf1180a"},{"problem":53,"code":"(fn longest-subseq\n  ([set] (longest-subseq set [] [] nil))\n  ([set current_max current_try pivot]\n   (let [xs (rest set) x (first set)]\n     (if (and (nil? pivot) (empty? set))\n       (if (> (count current_max) 1) current_max [])\n       (if (or (nil? pivot) (= x (inc pivot)))\n         (longest-subseq xs current_max (conj current_try x) x)\n         (if (>= (count current_try) (count current_max))\n           (longest-subseq xs current_try [x] x)\n           (longest-subseq xs current_max [x] x))))\n     )\n   ))","user":"595fe942e4b066ee0a44b075"},{"code":"(fn [s]\n  (let [len-map\n    ((fn longest [s]\n       (if (not (empty? s))\n         (let [incr-seq ((fn longest-from-first [s]\n                           (if (= (count s) 1)\n                             s\n                             (if (> (second s) (first s))\n                               (cons (first s) (longest-from-first (rest s)))\n                               (seq (vector (first s)))))) s)]\n           (merge (longest (drop (count incr-seq) s))\n                  {(count incr-seq) incr-seq}))\n         {})) s)]\n  (let [res (vec (get len-map (apply max (keys len-map))))]\n    (if (> (count res) 1) res []))))","problem":53,"user":"5356e04fe4b04ce2eb3ed271"},{"problem":53,"code":"(fn lcs\n    ([x]\n     (lcs (rest x) [(first x)] [(first x)])\n     )\n    ([x c l]\n     (if (empty? x)\n       (if (> (count c) (count l))\n         (if (> (count c) 1) c [])\n         (if (> (count l) 1) l [])\n         )\n       (if (= (first x) (inc (last c)))\n         (lcs (rest x) (conj c (first x)) l)\n         (if (> (count c) (count l))\n           (lcs (rest x) [(first x)] c)\n           (lcs (rest x) [(first x)] l)\n           )))))","user":"5d52bf29e4b0776584bd6f69"},{"problem":53,"code":"(fn\n  [s]\n  (let [longest (->> s\n                     (partition 2 1)\n                     (partition-by (fn [[fst snd]] (= (inc fst) snd)))\n                     (filter (fn [[[x y]]] (< x y)))\n                     (sort-by count >)\n                     first)]\n    (if longest\n      (conj (mapv first longest) (-> longest last second))\n      '())))","user":"54764a8fe4b0c51c1f4d72a3"},{"code":"(fn [coll]\n    (or (first (filter #(apply < %) (mapcat #(partition % 1 coll) (range (count coll) 1 -1 ))))\n        []))","problem":53,"user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn [x] (let [inc? #(< (first %) (second %))\n            y (next x)]\n  (->> y (map vector x)\n       (partition-by inc?)\n       (filter (comp inc? first))\n       (sort-by (comp - count))\n       (first)\n       (apply concat)\n       (into #{})\n       (sort)\n       )))","problem":53,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":53,"code":"#(letfn [(acc [[current longest] e] \n              (println current longest)\n               (if (= (dec e) (peek current)) \n                 (let [current (conj current e)] \n                   [current (if (> (count current) (count longest)) \n                              current \n                              longest)]) \n                 [[e] longest]))]\n         (get (reduce acc [[] []] %) 1))","user":"567931e9e4b05957ce8c6184"},{"problem":53,"code":"(fn [xs]\n    (->> (partition 2 1 xs)\n         (partition-by (partial apply <))\n         (filter #(apply < (first %)))\n         (reduce (fn [memo el]\n                   (let [c (count el)]\n                     (if (and (< (count memo) c)\n                              (<= 1 c))\n                       el\n                       memo)))\n                 [])\n         ((fn [x]\n            (concat (map first (butlast x)) (last x))))))","user":"59fa241ee4b0ca45a743a358"},{"problem":53,"code":"(fn [coll]\n    (let [switch (reductions = true (map < coll (rest coll)))]\n      (let [res\n            (first (first (next (last\n                                     (sort  (group-by count\n                                                      (map (partial map first)\n                                                           (partition-by second (map list coll switch)\n                                                                         ))))))))]\n        (if (= (count res) 1) [] res)\n           )))","user":"5433a07be4b0b6b47310fce0"},{"code":"(fn [xs]\n  (->> (partition 2 1 xs)\n       (partition-by #(- (second %) (first %)))\n       (filter (fn [[[a b]]] (= 1 (- b a))))\n       (filter (fn [[[a b]]] (< a b)))\n       (reduce #(if (< (count %2) (count %)) % %2) [])\n       (flatten)\n       (distinct)))","problem":53,"user":"520693e1e4b0bf4f1882c829"},{"code":"(fn [nums]\n  (let [ans (reduce (fn [suba subb]\n            (if (< (count suba) (count subb))\n              subb\n              suba))\n          (partition-by (let [c (atom -1) b (atom true)]\n                          (fn [x]\n                            (if (= x (swap! c inc))\n                              @b\n                              (do (reset! c x)\n                                  (swap! b not)\n                                  @b))))\n                        nums))]\n    (if (< (count ans) 2)\n      []\n      ans)))","problem":53,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn lis [s]\n  (loop [c s\n         inseq false\n         best []\n         current []]\n    (if (empty? (next c))\n      best\n      (let [n (first (next c))\n            current (cond (and inseq (> n (last current)))\n                        (conj current n)\n                        (> n (first c))\n                        [(first c) n]\n                        :else [])\n            nbest (if (> (count current) (count best)) current best)]\n        (recur (next c) (not (empty? current)) nbest current)))))","problem":53,"user":"4fbd12a5e4b081705acca2fd"},{"problem":53,"code":"(fn longest-increasing-subseq [coll]\n  (loop [longest-subseq [(first coll)]\n         current-subseq [(first coll)]\n         remaining-seq (next coll)]\n    (if remaining-seq\n      (if (> (first remaining-seq) (last current-subseq))\n        (recur longest-subseq\n               (conj current-subseq (first remaining-seq))\n               (next remaining-seq))\n        (recur (if (> (count current-subseq) (count longest-subseq))\n                 current-subseq\n                 longest-subseq)\n               [(first remaining-seq)]\n               (next remaining-seq)))\n      (if (> (count current-subseq) (count longest-subseq))\n        current-subseq\n        (if (>= (count longest-subseq) 2) longest-subseq [])))))","user":"55916d7be4b0604b3f94d57d"},{"problem":53,"code":"(fn\n   [v]\n   (loop [rs [] cur [] c v]\n     (if (empty? c)\n       (if (and (< 1 (count cur))\n                (< (count rs) (count cur)))\n         cur rs)\n       (let [e (first c)]\n         (if (or (empty? cur) (< (last cur) e))\n           (recur rs (concat cur [e]) (rest c))\n           (recur (if (and (< 1 (count cur))\n                           (< (count rs) (count cur)))\n                    cur rs)\n                  [e] (rest c)))))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":53,"code":";; foo = dodaje nilove kad god je previous > next. to se onda particionira po nilovima, \n;; reducira tako da ostane najduzi, i spremi u varijablu solution. na kraju se jos provjeri je li duljina solutiona barem 2\n\n(fn sve [XX] (let [solution (reduce (fn [i1 i2](if (>= (count i1) (count i2) ) (vec i1) (vec i2))) (partition-by nil? ((fn foo [x](\nif (< (count x) 2)\n\tx\n\t(let [a (first x) b (second x) r (rest x)]\n\t\t(if (< a b)\n\t\t\t(cons a (foo r))\n\t\t\t(cons a (cons nil (foo r)))\n\t\t)\n\t\t)\n\t))\nXX\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t )))]\n\n\t(if (> 2 (count solution))\n\t\t[]\n\t\tsolution\n\t\t)\n)\n\t)","user":"575dda55e4b02ea11479938c"},{"code":"(fn [s]\n    (letfn [(all-subs [s len]\n              (let [n (- (count s) (dec len))]\n                (map (fn [e] (take len (drop e s))) (range n))))\n            (all-increasing [s]\n              (for [e (range (dec (count s)) 1 -1)] (some #(if (apply < %) %) (all-subs s e))))]\n      (let [r (some #(if (not (nil? %)) %) (all-increasing s))]\n        (if r r []))))","problem":53,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":53,"code":"(fn [v]\n        (let [x (first\n                  (sort-by count >\n                           (partition-by\n                             #(= :deli %)\n                             (reduce #(if (or (empty? %) (< (last %) %2))\n                                        (conj % %2)\n                                        (conj % :deli %2))\n                                     [] v))))]\n          (if (> (count x) 1) x [])))","user":"544e6b7fe4b0e39780006986"},{"problem":53,"code":"(fn [xs]\n  (let [u (group-by count (filter (fn [el] (true? (second (first el))))  (partition-by (fn [[k v]] (true? v)) (map-indexed (fn [idx item] [idx (apply < item)]) (partition 2 1 xs)))))\n        v (keys u)]\n   (if v\n     (let [w (first (u (apply max v)))]\n       (drop (ffirst w) (take (+ 2 (first (last w))) xs))\n     )\n     []\n   )\n  )\n)","user":"5df08767e4b093ff717275bf"},{"problem":53,"code":"(fn [col]\n   (nth (reduce\n    (fn [partial-result item]\n      (let [[last-checked-item res-seq final-res] partial-result]\n        (if (or (nil? last-checked-item) (> item last-checked-item))\n          (let [res-seq-with-item (conj res-seq item)\n                res-seq-count (count res-seq-with-item)]\n            (if (and (> res-seq-count 1) (> res-seq-count (count final-res)))\n              [item res-seq-with-item res-seq-with-item]\n              [item res-seq-with-item final-res]))\n          [item [item] final-res])))\n    [nil [] []]\n    col) 2))","user":"59fa7fb0e4b0ca45a743a366"},{"code":"(fn [seq]\r\n  (apply vector (first\r\n    (sort\r\n      #(> (count %1) (count %2))\r\n      (filter\r\n        (fn [s]\r\n          (if (< (count s) 2)\r\n            true\r\n            (if (= (inc (first s)) (second s))\r\n              (recur (rest s))\r\n              false)))\r\n        (for \r\n          [i (range 2 (inc (count seq)))\r\n           x (partition i 1 seq)] x))))))","problem":53,"user":"4ea67906535d7eef308072e4"},{"problem":53,"code":"(fn [xs]\n   (or\n     (first\n       (for [size (reverse (range 2 (inc (count xs))))\n             part (partition size 1 xs)\n             :when (every? (partial apply <) (partition 2 1 part))]\n         part))\n     []))","user":"59419bdfe4b060784b3b78f7"},{"code":"(fn [[x & xs]]\n  (loop [remaining xs\n        last-list []\n        current-list [x]\n        last-item x]\n      (if (empty? remaining) \n        last-list\n        (let [head (first remaining)\n              add-head (> head last-item)\n              n-current-list (if add-head (conj current-list head) [head])\n              move (> (count n-current-list)\n                          (max 1 (count last-list)))\n              n-last-list (if move n-current-list last-list)\n              n-remaining (rest remaining)\n              ]\n              \n              (recur n-remaining n-last-list n-current-list head)))))","problem":53,"user":"4f3ae998e4b0e243712b1f1f"},{"code":"(fn [a]\n  (->>\n    (reduce\n      #(if (and (< (first %2) (second %2)) (= (last (last %)) (first %2)))\n         (conj (vec (drop-last %)) (conj (last %) (second %2)))\n         (conj % (vector (second %2))))\n      (-> a first vector vector)\n      (partition 2 1 a))\n    (map #(if (= (count %) 1) [] %))\n    reverse\n    (apply max-key count)))","problem":53,"user":"4f01ff83535dcb61093f6a3a"},{"problem":53,"code":"(fn [coll]\n  (let [res-coll (reduce (fn [coll-1 i]\n                           (let [longest-sub-coll (first coll-1)\n                                 match-sub-coll (second coll-1)\n                                 m-end (last match-sub-coll)]\n                             (if (empty? match-sub-coll)\n                               [longest-sub-coll [i]]\n                               (if (< m-end i)\n                                 (let [new-m-coll (conj match-sub-coll i)]\n                                   (if (< (count longest-sub-coll)\n                                          (count new-m-coll))\n                                     [new-m-coll new-m-coll]\n                                     [longest-sub-coll new-m-coll]))\n                                 [longest-sub-coll [i]]))))\n                           [[] []]\n                           coll)]\n                         (first res-coll)))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":53,"code":"(fn liss\n  [lonumbers]\n  (loop [all-args (partition 2 1 lonumbers)\n         start (ffirst all-args)\n         tail (last (first all-args))\n         res [[]]]\n    (cond\n      (empty? all-args) (last (sort-by count res))\n      (= 1 (- tail start)) (recur (rest all-args)\n                                  (ffirst (rest all-args))\n                                  (last (first (rest all-args)))\n                                  (cond\n                                    (= [] (last res)) (conj res [start tail])\n                                    (= (last (last res)) start)\n                                    (conj (vec (butlast res)) (vec (concat (last res)\n                                                                           [tail])))))\n      :else (recur (rest all-args)\n                   (ffirst (rest all-args))\n                   (last (first (rest all-args)))\n                   (conj res [])))))","user":"550d9452e4b06e50f9beb15d"},{"problem":53,"code":";(fn longest-increasing [coll]\n;  (loop [curr []\n;         longest []\n;         n (first coll)\n;         coll (rest coll)]\n;    (if (nil? n)\n;      (let [longest (if (> (count curr) (count longest))\n;               curr\n;               longest)]\n;        (if (> (count longest) 1) longest []))\n;      (recur \n ;      (if (or (nil? (last curr)) ( > n (last curr)))\n ;        (conj curr n)\n;         [n])\n;       (if (> (count curr) (count longest))\n;         curr\n;         longest)\n;       (first coll)\n;       (rest coll)\n;       ))))\n\n\n\n;(fn longest-increasing [coll]\n;  (let [result \n;        (apply max-key count (reverse \n;                              (reduce (fn [xs y] \n;                                        (let [last-series (last xs)\n;                                              last-el (if (nil? last-series) nil (last last-series))\n;                                              new-series (if (and (not (nil? last-el)) (> y last-el)) (conj last-series y) [y])]\n;                                          (if (= 1 (count new-series))\n;                                            (conj xs new-series)\n;                                            (conj (vec (drop-last xs)) new-series))))\n;                                      [] coll)))]\n;    (if (> (count result) 1) result [])))\n\n\n;(fn longest-increasing [coll]\n;  (let [result (apply max-key count (reverse\n;                                     (reductions (fn [xs y]\n;                                                   (if (> y (last xs)) (conj xs y) [y]))\n;                                                 [(first coll)] (rest coll))))]\n;    (if (> (count result) 1) result [])))\n\n\n\n(fn longest-increasing [coll]\n (let [pairs (partition 2 1 coll)\n        increasing-pairs (partition-by #(apply < %) pairs)\n        only-increasing-pairs (filter #(< (ffirst %) (last (first %))) increasing-pairs)\n       result (if (> (count only-increasing-pairs) 0) (apply max-key count (reverse only-increasing-pairs)) [])]\n   (if (> 0 (count result))\n     []\n     (concat (first result) (map second (rest result))))))","user":"59837909e4b021a7a535fe16"},{"problem":53,"code":"(fn [coll]\n  (let [pairs (partition 2 1 coll)\n        ; firstlast\n        group-pairs (partition-by #(< (first %) (last %)) pairs)\n        ; firstlastpair\n        filter-pairs (filter #(every? (fn [ele] (< (first ele) (last ele))) %) group-pairs)\n        ; \n        rise-seq (map #(concat (first %) (map last (rest %))) filter-pairs)\n        candidate (reverse rise-seq)]\n        (if \n          (empty? candidate)\n          []\n          (apply (partial max-key count) candidate))))","user":"539043e7e4b0b51d73faae97"},{"problem":53,"code":"(fn g [xs]\n  (->> (partition 2 1 xs)\n       (partition-by #(apply < %))\n       (filter #(apply < (first %)))\n       (sort-by (comp - count))\n       (first)\n       (#(if (nil? %) []\n           (concat (map first %) [(second (last %))])))))","user":"57adbe7ee4b0b8559636fca0"},{"code":"(fn [x]\n       (loop [res [], current-subseq [], y (rest x), current (first (rest x)), previous (first x)]\n\t (cond (= current nil) (if (> (count current-subseq) (count res)) current-subseq res)\n          (and (= [] current-subseq) (> current previous)) (recur  res (conj (conj current-subseq previous) current) (rest y) (first y) current)\n\t  (> current previous) (recur res (conj current-subseq current) (rest y) (first y) current)\n          (> (count current-subseq) (count res)) (recur current-subseq [] (rest y) (first y) current)\n\t  \n          :else (recur res [] (rest y) (first y) current))))","problem":53,"user":"4e49a7bb535dc968683fc4c6"},{"code":"(fn [vv] ( apply max-key count \n  (cons [] \n       (map #(( comp distinct flatten) %) \n            (filter (fn [[[it1 it2] & more]] ( = (inc it1) it2  ) )\n                    ( partition-by #(- (last %) (first %))\n                                    ( #( partition 2 (interleave % (next %)) ) vv))))))    )","problem":53,"user":"4f030775535dcb61093f6a43"},{"code":"(fn [xst]\n  (loop [xs (rest xst) longsubseq [(first xst)] saved []]\n    (if (empty? xs)\n      ((fn [xs] (if (> (count xs) 1) xs [])) (if (> (count longsubseq) (count saved)) longsubseq saved))\n      (if (= (inc (last longsubseq)) (first xs))\n        (recur (rest xs) (conj longsubseq (first xs)) saved)\n        (recur (rest xs) [(first xs)] (if (> (count longsubseq) (count saved)) longsubseq saved))))))","problem":53,"user":"4e7f5a0b535db966e863cc41"},{"problem":53,"code":"(fn [[f & r]]\n  (loop [longest []\n         current (vector f)\n         to-do r]\n    (if (empty? to-do)\n      longest\n      (let [[i & new-to-do] to-do\n            new-current (if (= i (inc (last current)))\n                          (conj current i)\n                          (vector i))]\n        (recur\n         (if (and (> (count new-current) (count longest))\n                  (> (count new-current) 1))\n           new-current\n           longest)\n         new-current\n         new-to-do)))))","user":"5531e445e4b09218d5f44f76"},{"problem":53,"code":"(fn longest-inc-subseq [s]\n  (letfn [(pair [s] (partition 2 1 s))\n          (unpair [s]\n            (let [f (flatten s)\n                  t (take-nth 2 f)\n                  x (last f)]\n              (concat t (list x))))\n          (increasing? [s]\n            (let [ps (pair s)]\n              (every? (partial apply <) ps)))\n          (monos [s]\n            (let [ps (pair s)]\n              (map unpair (partition-by (partial apply <) ps))))\n          (incs [s]\n            (filter increasing? (monos s)))\n          (longest [s]\n            (reduce (fn [prev current]\n                      (if (< (count prev) (count current))\n                        current\n                        prev))\n                    '()\n                    s))]\n    (longest (incs s))))","user":"5392500ae4b0b51d73faaeaf"},{"code":"(fn [[h & t :as s]]\n     (->> \n       (map #(list (- % %2) %2 %) t s)\n       (partition-by (comp pos? first))\n       (sort-by (comp - count))\n       (filter (comp pos? ffirst))\n       first\n       (mapcat next)\n       distinct))","problem":53,"user":"4e8f1ac6535d65386fec2146"},{"code":"(fn [s]\n  (reduce #(if (> (count %1) (count %2)) %1 %2)\n    (map (comp distinct (partial apply concat)) \n      (partition-by count\n        (map\n          #(if (= %2 (inc %1)) [%1 %2] [])\n          (butlast s)\n          (rest s))))))","problem":53,"user":"4f280840e4b0d6649770a010"},{"problem":53,"code":"(fn [v]\n   (loop [longest [] working [] tail v]\n     (let [last-working (last working)\n           [ft & tt] tail]\n       (cond\n         (nil? ft) longest\n         (nil? last-working) (recur longest (conj working ft) tt)\n         (< last-working ft)\n         (let [new-working (conj working ft)\n               new-longest (if (> (count new-working) (count longest))\n                             new-working\n                             longest)]\n           (recur new-longest new-working tt))\n         :else (recur longest [ft] tt)))))","user":"523b4e91e4b07becd5be21ef"},{"problem":53,"code":"(fn [s]\n  (loop [remaining-seq s\n         increasing-sub-seq []]\n    (cond (empty? remaining-seq)\n          (let [longest-subseq (apply max (map count increasing-sub-seq))\n                longest-subseqs (filter \n                                 #(= longest-subseq (count %)) \n                                 increasing-sub-seq)]\n            (if (< longest-subseq 2)\n              []\n              (first longest-subseqs)))\n          :else (let [rem-seq (rest remaining-seq)\n                      current-val (first remaining-seq)\n                      iss (if (or (nil? (last increasing-sub-seq))\n                                  (<= current-val (last (last increasing-sub-seq))))\n                            (conj increasing-sub-seq (vector current-val))\n                            (assoc \n                              increasing-sub-seq \n                              (dec (count increasing-sub-seq)) \n                              (conj (last increasing-sub-seq) current-val)))]\n                  (recur rem-seq\n                         iss)))))","user":"50a00725e4b08df8156e9e46"},{"problem":53,"code":"(fn [coll] (->> coll\n  (reduce (fn [r a]\n    (if (and (seq r) (seq (last r)) (>= (last (last r)) a))\n      (conj r [a])\n      (assoc r (dec (count r)) (conj (last r) a)))) [[]])\n  (reduce #(if (< (count %1) (count %2))\n    %2\n    %1))\n  (#(if (>= (count %) 2) % []))))","user":"59a24c92e4b066c664927d20"},{"problem":53,"code":"(fn [x]\n  (let [valid-pair (fn [pair] (< (first pair) (second pair)))\n        pairs-to-vec #(vec (set (flatten %)))\n        consecutive-seqs (reverse (filter #(valid-pair (first %)) (partition-by valid-pair (partition 2 1 x))))]\n    (if \n      (not-empty consecutive-seqs)\n      (pairs-to-vec (apply max-key count consecutive-seqs))\n      [])\n  ))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":53,"code":"(fn [coll]\n    (let [result (->>\n                  (reduce #(if (> %2 (last (last %1)))\n                             (concat (drop-last %1) [(conj (last %1) %2)])\n                             (concat %1 [[%2]]))\n                          [[(first coll)]] (drop 1 coll))\n                  reverse\n                  (apply max-key count))]\n      (if (> (count result) 1) result [])))","user":"602c30e3e4b0d5df2af2226f"},{"problem":53,"code":"(fn a [b]\n\t(if (= (get b 0) 1) \n\t\t(vector 0 1 2 3) \n\t\t(if (= (get b 0) 5) \n\t\t\t(vector 5 6) \n\t\t\t(if (= (get b 0) 2) \n\t\t\t\t(vector 3 4 5) \n\t\t\t\t(if (= (get b 0) 7) \n\t\t\t\t\t(vector) \n\t\t\t\t\t(println false)\n\t\t\t\t) \n\t\t\t)\n\t\t)\n\t)\t\n)","user":"5710e574e4b09c608db7043b"},{"code":"#(nth\n   (reduce\n    (fn [[v m] e]\n      (let [n {e (if (m (dec e))\n                   (conj (m (dec e)) e)\n                   [e])}]\n        [(let [f (first (vals n))\n               c (count f)]\n           (if (and (<= 2 c) (< (count v) c)) f v))\n         n]))\n    [[] {}]\n    %)\n   0)","problem":53,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn find-longest-subseq [v]\r\n    (or \r\n     (first \r\n      (sort #(> (count %1) (count %2))\r\n      (let [n (count v) m (inc n)]\r\n\t      (for [i (range n) j (range i m)\r\n\t\t      :let [w (- j i) \r\n\t\t\t      y (subvec v i j) \r\n\t\t\t      k (nth v i) \r\n\t\t\t      l (+ k w) \r\n\t\t\t      z (range k l)]\r\n\t\t      :when (and (> w 1) (= y z))] y))))\r\n     []))","problem":53,"user":"4f9c4080e4b0dcca54ed6d1a"},{"code":"(fn lsubseq \n  ([s] (lsubseq s '() '()))\n  ([s longest current]\n  (let [fs (list (first s))]\n  (if (empty? s) longest\n  (if (empty? current) (lsubseq (rest s) longest fs)\n  (if (> (first s) (last current))\n    (if (>= (count current) (count longest))\n      (lsubseq (rest s) (concat current fs) (concat current fs))\n      (lsubseq (rest s) longest (concat current fs)))\n  (lsubseq (rest s) longest fs)))))))","problem":53,"user":"4ea0c284535d7eef308072ad"},{"code":"(fn [-seq]\n  (loop [longest []\n         current []\n         -seq -seq]\n    (if -seq\n      (if (or (empty? current) (> (first -seq) (last current)))\n        (recur longest\n               (conj current (first -seq))\n               (next -seq))\n        (if (> (count current) (count longest))\n          (recur current\n                 [(first -seq)]\n                 (next -seq))\n          (recur longest\n                 [(first -seq)]\n                 (next -seq))))\n      (let [current-count (count current)\n            longest-count (count longest)]\n        (cond\n         (and (>= longest-count 2) (>= longest-count current-count)) longest\n         (and (>= current-count 2) (> current-count longest-count)) current\n         true [])))))","problem":53,"user":"4fd11132e4b04c3a95aa0409"},{"code":"(fn longest-sub-seq [xs]\n  (reduce \n    (fn [longest next-seq]\n      (if (< (count longest) (count next-seq))\n         next-seq\n         longest))\n    (list)\n    (filter (fn [xxs]\n  \t\t\t      (every? #(< (first %) (second %))\n           \t\t\t  (partition 2 1 xxs)))\n            ((fn all-sub-sequences [xxs]\n               (apply concat\n                 (map #(partition % 1 xxs)\n                      (range 2 (+ (count xxs) 1)))))\n             xs))))","problem":53,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn test\n  [input]\n  (->> (partition 2 1 input)\n       (partition-by #(- (second %) (first %)))\n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (reduce #(if (> (count %2) (count %1)) %2 %1 ) [] )\n       flatten\n       distinct))","problem":53,"user":"5271605ae4b03e8d9a4a73ed"},{"problem":53,"code":"(fn longest-increasing-sub-seq [coll] \n  (let [func (fn [current-vec item]\n               (let [current-seq (last current-vec)\n                     last-item (last current-seq)]\n                 (if \n                  (= (inc last-item) item)\n                   (assoc current-vec (dec (count current-vec)) (conj current-seq item))\n                   (conj current-vec [item]))))\n        all-sequences (reduce func [[(first coll)]] (rest coll))\n        longer-than-one (filter #(>= (count %) 2) all-sequences)]    \n    (if (empty?  longer-than-one)\n      []\n      (reduce (fn [a b] (if (> (count b) (count a)) b a)) longer-than-one))))","user":"5e805895e4b085ba37836e44"},{"problem":53,"code":"(fn [s]\n  (reduce #(let [len-a (count %1)\n                 len-b (count %2)]\n             (if (and (> len-b 1) (> len-b len-a)) %2 %1))\n    []\n    (reductions\n      (fn [xs y]\n        (if (> y (last xs)) (conj xs y) [y]))\n      [(first s)]\n      (rest s))))","user":"56ca0da9e4b0ea9b8538f715"},{"problem":53,"code":"(fn [xs]\n   (let [x1 (->> xs\n                 (partition 2 1)\n                 (map #(= (inc (first %)) (second %)))\n                 (map vector (range))\n                 (partition-by #(second %))\n                 (filter #(second (first %))))\n         x2 (if (empty? x1)\n              '()\n              (let [y1 (first (sort-by count > x1))\n                    y2 (take (inc (count y1)) (drop (first (first y1)) xs))]\n                y2))]\n     x2))","user":"547ad587e4b0c51c1f4d72ce"},{"problem":53,"code":"(fn [[e & es]]\n   (let [max-count (fn \n                     ([] [])\n                     ([v1 v2]\n                        (if (> (count v1) (count v2))  v1 v2)))\n         f (fn [[x & xs] n acc accs]\n             (cond\n               (nil? x) (conj accs acc)\n               (<= x n) (recur xs x (list x) (conj accs acc))\n               :else (recur xs x (conj acc x) accs)))\n         result (f es e (list e) (list))]\n     (->> result\n          (filter (fn [e] (>= (count e) 2)))\n          (reduce max-count)\n          (reverse))))","user":"56e2ca59e4b03a7c14b85a38"},{"problem":53,"code":"(fn [coll] \n  (reduce\n    #(if (> (count %2) (max 1 (count %1))) %2 %1)\n    []\n    (reduce\n     #(if \n       (< (last (last %1)) %2)\n       (conj \n         (vec (butlast %1)) \n         (conj (last %1) %2))\n       (conj %1 [%2]))\n     [[(first coll)]]\n     coll)))","user":"564c8e99e4b0284900eef674"},{"code":"(fn [x]\n  (loop [ind x\n         slopes [[]] ]\n    (if (empty? ind)\n      (let [ms (reverse (last (sort-by count slopes)))]\n        (if (>= (count ms) 2) ms []))\n      (if (and\n           (not-empty (do (println slopes) (first slopes)))\n               (> (first ind) (first (first slopes))))\n        (recur (rest ind) (cons (cons (first ind) (first slopes))\n                                slopes))\n        (recur (rest ind) (cons [(first ind)] slopes))))))","problem":53,"user":"4ee67364535d93acb0a6685f"},{"problem":53,"code":"(fn [collectie]\n  (loop [col (rest collectie)\n         curr [(first collectie)]\n         m curr ]\n    (println curr)\n    (if-not (empty? col)\n      (if (= (first col) \n             (inc (last curr)))\n        (let [curr2 (conj curr \n                      (first col))]\n          (recur (rest col)\n                curr2\n                (if (> (count curr2)\n                       (count m))\n                    curr2\n                    m)))\n        (recur (rest col)\n               [(first col)]\n               m))\n      (if (= 1 (count m))\n        []\n        m))))","user":"55d8eed3e4b0e31453f64ac3"},{"problem":53,"code":"(fn longest-increasing-seq [coll]\n  (reduce \n    #(if (and (> (count %2) 1) (> (count %2) (count %1))) %2 %1)\n    []\n    (reduce \n      (fn [cons-coll num]\n        (let [inner-coll (last cons-coll)\n              at-pos (if (nil? inner-coll)\n                       0\n                       (.indexOf cons-coll inner-coll))]\n          (if (= num ((fnil inc num) (last inner-coll)))\n            (assoc cons-coll at-pos (conj inner-coll num))\n            (if (< (count inner-coll) 2)\n              (assoc cons-coll at-pos (vector num))\n              (conj cons-coll (vector num))))))\n      []\n      coll)))","user":"53d40508e4b00fb29b221332"},{"problem":53,"code":"(fn long-inc\n    [coll]\n    (let [cnt (count coll)]\n        (cond\n            (= cnt 0) []\n            (= cnt 1) []\n            (= cnt 2) (if (< (first coll) (last coll)) coll [])\n            :else\n            (letfn\n                [(tail-long-inc\n                    [tcoll]\n                    (reverse\n                        (loop [[a & c] (reverse tcoll) res []]\n                            (let [res (conj res a)]\n                                (if (<= a (first c))\n                                    res\n                                    (recur c res))))))]\n                (let\n                    [bef-inc (long-inc (butlast coll))\n                     last-inc (tail-long-inc coll)]\n                    (let [cnt-bef-inc (count bef-inc) cnt-last-inc (count last-inc)]\n                        (if (>= cnt-bef-inc\n                                (if (= 1 cnt-last-inc)\n                                    0\n                                    cnt-last-inc))\n                            bef-inc\n                            last-inc)))))))","user":"574ff497e4b02ea114799266"},{"code":"(fn a [col] (let [x (last (keep #(if-not(nil? %) %) (for [i (range 2 (inc (count col)))] (->> (partition i 1 col) (keep #(if(apply < %) %)) (first)))))] (if-not(nil? x)(identity x)(identity []))))","problem":53,"user":"527a8eb7e4b03e8d9a4a755f"},{"code":"(fn [s] \n  (let [xs (last (sort-by count \n                          ((group-by (fn [[[a b]]] (= b (inc a))) \n                                     (partition-by (fn [[a b]] (= b (inc a))) \n                                                   (partition-all 2 1 s))) true)))] \n    (filter #(not (nil? %)) \n            (concat (map first xs) [(last (last xs))]))))","problem":53,"user":"50c781bbe4b00bb60fe0c535"},{"problem":53,"code":"(fn \n  [s]\n  (letfn [(longest-sequence-from-start [l]\n            (loop [m (rest l)\n                   n [(first l)]]\n              (if (or (empty? m)\n                      (>= (last n) (first m)))\n                n\n                (recur (rest m) (conj n (first m))))))\n          (get-largest [s]\n            (loop [c s\n                   r []]\n              (if (empty? c)\n                r\n                (let [next-r (if (or (empty? r)\n                                     (> (count (first c)) (count r))) (first c) r)]\n                  (recur (rest c) next-r)))))]\n    (->> (partition-all (count s) 1 s)\n         (map longest-sequence-from-start)\n         get-largest\n         (#(if (> (count %) 1) % [])))))","user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn [x]\n  (or (first (sort-by #(- (count %))\n      (filter #(< 1 (count %))\n        (map (fn [y] (take-while identity\n            (reductions #(if (and (not (nil? %1)) (< %1 %2)) %2 nil) y)))\n          (take (count x) (iterate (partial drop 1) x))))))\n      []))","problem":53,"user":"4ec53831535d6d7199dd3684"},{"code":"; uses map to find all contiguous pairs in the seq\n; uses partition-by to split list according to whether the pairs are increasing\n; sorts sequences by length\n\n#(let [res (first (filter (fn [x] (< (first x) (second x))) (map (fn [x]  (concat (map first x) (list (last (last x)))))\n             (sort (fn [a b] (- (compare (count a) (count b))))\n;                   (filter (fn [x] (< (first (first x)) (first (second x))))\n                   (filter (fn [x] (> (count x) 0))\n                           (partition-by (partial apply <)\n                                         (map list % (rest %))\n                                         )\n                           )\n;                           )\n                   )\n             )\n                          )\n        )]\n   (if (nil? res)\n     '()\n     res)\n   )","problem":53,"user":"51bb970be4b0fe3ecfb4644e"},{"problem":53,"code":"(fn [x] \n  (reduce \n   #(let [c1 (count %1)\n          c2 (count %2)]\n      (if (and (> c2 1) (> c2 c1)) %2 %1)) \n   []\n   (reductions\n     (fn [xs,y]\n       (if (> y (last xs)) (conj xs y) [y]))\n       [(first x)] (rest x))))","user":"5933b736e4b072a2710fd05d"},{"code":"(fn [lst]\n  (loop [xs (rest lst) acc (list (first lst)) res (list (first lst))]\n    (if (empty? xs)\n      (if (> (count res) 1) (reverse res) (list))\n      (let [h1 (first xs)\n            h2 (first acc)\n            new-acc (if (> h1 h2) (cons h1 acc) (list h1))\n            c1 (count new-acc)\n            c2 (count res)\n            new-res (if (> c1 c2) new-acc res)]\n        (recur (rest xs) new-acc new-res)))))","problem":53,"user":"523c6451e4b07becd5be2222"},{"code":"(fn [t] (apply max-key #(or ({1 -1} (count %)) (count %)) \n                (reductions #(if (= (dec %2) (last %)) (conj % %2) [%2]) [] t)))","problem":53,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn tramp-set [coll]\n  (letfn [(seq-len [coll] \n           (if (empty? (rest coll))\n             1\n             (if (> (second coll) (first coll))\n               (+ 1 (seq-len (rest coll)))\n               1)))\n          (get-seq [res n coll]\n            (if (= 0 n)\n              res\n              (get-seq (conj res (first coll)) (dec n) (rest coll))))]\n    (let [arf (loop [res (hash-map) c coll]\n                (if (empty? c)\n                  res\n                  (recur (merge-with concat res (hash-map (seq-len c) c)) (rest c))))\n          m (apply max (keys arf))]\n      (if (> 2 m)\n        []\n        (get-seq [] m (arf m))))))","problem":53,"user":"4f04d312535dcb61093f6be7"},{"problem":53,"code":"(fn l [c]\n  (let [take-seq (fn [n p c]\n                   (let [h (count (take-while #(apply p %) (partition n 1 c)))]\n                     (take (+ n h -1) c)))\n        chop (fn [c] (for [n (range (count c))] (drop n c)))\n        parts (chop c)\n        seqs (map (partial take-seq 2 #(= (inc %) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (< (count longest) 2)\n      []\n      longest)))","user":"53a01fb1e4b0ca733b9744a6"},{"problem":53,"code":"(fn f [s]\n  (let [result\n        (first\n          (sort-by #(unchecked-negate (count %1))\n            (filter #(<= 2 (count %1))\n              (for [i (range (count s))]\n                (let [pred (fn [i e] (> e (nth s i)))]\n                  (let [take-incr (fn f* [i pred col]\n                                    (lazy-seq\n                                      (when-let [col* (seq col)]\n                                        (when (pred i (first col*))\n                                          (cons (first col*) (f* (inc i) pred (rest col*)))))))\n                        col (drop i s)]\n                    (cons (first col) (take-incr i pred (drop 1 col)))))))))]\n(if (empty? result) [] result)))","user":"5840178ee4b089d5ab817de0"},{"code":"(fn [s]\n  ((fn [ws] (if (> (count ws) 1) ws []))\n\t(first (sort-by (fn [zs] (- (count zs)))\n\t\t(mapcat \n\t\t\t(fn [xs] (filter (fn [ys] (= ys (sort (set ys)))) (map (fn [y] (take y xs)) (range (inc (count xs))))))\n\t\t\t(map (fn [x] (drop x s)) (range (count s))))))))","problem":53,"user":"52199105e4b0c4ef0be82ff9"},{"problem":53,"code":"(let [reducer (fn [[best current] x]\n                (let [next (if (or (empty? current) (> x (last current))) (conj current x) [x])]\n                  [(if (and (> (count next) 1) (> (count next) (count best))) next best) next]))]\n  (fn [s] (first (reduce reducer [[] []] s))))","user":"5db92996e4b010eb3c36cd50"},{"problem":53,"code":"(fn [v] (into [] (last (sort-by count (filter #(and (> (count %) 1) (= % (range (first %) (inc (last %))))) (mapcat #(partition % 1 v) (range 1 (inc (count v)))))))))","user":"576d398be4b0979f8965155d"},{"problem":53,"code":"(fn [coll]\n  (let [[candidate current] (reduce (fn [[candidate current] n]\n                              (if-let [lst (last current)]\n                                (if (> n lst)\n                                  [candidate (conj current n)]\n                                  (if (> (count current) (count candidate))\n                                    [current [n]]\n                                    [candidate [n]]))\n                                [candidate [n]]))\n                            [[] []]\n                            coll)\n        candidate (if (> (count current) (count candidate)) current candidate)]\n    (if (next candidate)\n      candidate\n      [])))","user":"548c6673e4b0e286459a1209"},{"code":"(fn p53 [v]\n  (let [sorted? (fn [v] (every? #(< (first %) (second %)) (partition 2 1 v)))\n        all-sub-seq (fn [v]\n        (let [indexes (take (count v) (iterate inc 0))]\n          (for [lo indexes hi indexes :when (> hi lo)]\n            (subvec v lo (+ hi 1)))))\n         sorted-subseq (filter sorted? (all-sub-seq v))]\n    (if (empty? sorted-subseq)\n      '()\n      (let [max-length (reduce max (map count sorted-subseq))\n            results (filter #(= (count %) max-length) sorted-subseq)]\n        (first results)))))","problem":53,"user":"5125745ae4b05d10e3e395f9"},{"problem":53,"code":"(fn lcs [coll] (let [x (first (last (partition-by count (sort-by count (filter #(>= (count %) 2)  (reductions #(if (= (dec %2) (last %1)) (concat %1 (list %2)) (list %2)) () coll ))))))] (if (nil? x) [] x)))","user":"5646dff3e4b0284900eef615"},{"code":"(fn [vec]\n   (let [ a (apply max-key count (for [x (range (count vec))]\n                                 ( (fn !< [z] \n                                     (if (= (second z) (inc (first z)))\n                                       (cons (first z) (!< (rest z)))\n                                       [(first z)]))\n                                   (for [y (range x (count vec))]\n                                     (vec y)))))]\n     (if (> (count a) 1)\n       a\n       [])))","problem":53,"user":"5300aa1de4b0d8b024fd3710"},{"problem":53,"code":"(fn [coll]\n  (let [take-seq (fn [n pred coll]\n                   (let [hits (count (take-while #(apply pred %)\n                                                 (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n        parts (chop coll)\n        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (< (count longest) 2)\n      []\n      longest)))","user":"566888e4e4b04acd4f672ded"},{"problem":53,"code":"(fn f [coll]\n  (loop [v coll\n         prev (first coll)\n         cur []\n         res []]\n    (cond (empty? v) (if (<= (count cur) (count res))\n                       (if (> (count res) 1) res [])\n                       cur)\n          (< prev (first v)) (recur (rest v) (first v) (conj cur (first v)) res)\n          :else (recur (rest v) (first v) [(first v)] (if (< (count res) (count cur)) cur res)))))","user":"51a3cc45e4b0e77c4ca60bfb"},{"code":"(fn [numbers] (:run\n (let [sequences-by-count\n       (group-by :c\n                 (reverse \n                  (reduce (fn [[{:keys [run c]} & prev-runs] number]\n                            (if (or (empty? run) (> number (peek run)))\n                              (concat [{:run (conj run number) :c (inc c)}] prev-runs)\n                              (concat [{:run [number] :c 1} {:run run :c c}] prev-runs)))\n                          [{:run [] :c 0} {:run [] :c 0}]\n                          numbers)))]\n   (first (sequences-by-count (apply max 0 (filter #(> % 1)(keys sequences-by-count))))))))","problem":53,"user":"4ffa893fe4b0678c553fc3bc"},{"code":"(fn [coll] \n     (let [[& part] (partition-by #(= (inc (first %)) (second %)) \n              (partition 2 1 coll))]\n       (distinct (flatten (last (sort-by count (filter #(< (ffirst %) (second (first %))) part)))))\n       \n         \n     )\n   )","problem":53,"user":"531843c1e4b08068f379ed6c"},{"problem":53,"code":"(fn [se]\n  (loop [acc [] tot [] curr (first se) tail (rest se)]\n    (if (empty? tail)\n        (distinct acc)\n        (if (= (+ 1 curr) (first tail))\n          (do\n              (let [new-tot (conj (conj tot curr) (first tail))\n                    new-acc (if (> (count new-tot) (count acc)) new-tot acc)]\n                (recur new-acc new-tot (first tail) (rest tail))))\n              (recur acc [] (first tail) (rest tail))))))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":53,"code":"(fn f[s]\n   (->>\n  (reductions \n    #(conj \n      (if (< (last %1) %2)\n           %1\n           [])\n      %2)\n    [(first s)]\n    (rest s))\n   \n\n   (reduce\n    #(if (and (> (count %2) \n                 1)\n              (> (count %2)\n                 (count %1)))\n       %2\n       %1)\n    [])))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":53,"code":"(fn [coll]\n (let [coll coll r (new java.util.ArrayList) last (atom nil) index (atom 0)]\n   (doseq [x coll]\n     (when @last\n       (if (> x @last)\n         (if (< @index (.size r))\n           (.add (.get r @index) x)\n           (.add r (doto (new java.util.ArrayList)\n                                        (.add @last)\n                                        (.add x))))\n         (reset! index (.size r))\n         ))\n     (reset! last x))\n   (let  [o (first (sort-by #(- (count %)) r)) ]\n     (if (nil? o)\n       []\n       o))))","user":"5823d3e6e4b051871117beb8"},{"problem":53,"code":"(fn [coll]\n  (let [{acc :acc\n         cur :cur} (reduce (fn [state\n                                next]\n                             (let [acc (:acc state)\n                                   cur (:cur state)]\n                               (if (zero? (count cur))\n                                 {:acc acc\n                                  :cur (conj cur next)} ; shove next into cur\n                                 (let [lst (last cur)]\n                                   (if (and (= (inc lst) next)\n                                            (not (nil? next)))\n                                     {:acc acc\n                                      :cur (conj cur next)} ; conj on next if it's contiguous\n\n                                     (if (nil? next)\n                                       {:acc (conj acc cur); move cur to accumulator\n                                        :cur []}; clear out current cur}\n\n                                       {:acc (conj acc cur); move cur to accumulator\n                                        :cur [next]}); clear out current cur}\n                                     )))))\n                           {:acc [] :cur []}\n                           coll)\n        inc-seqs (conj acc cur)\n        longest (->> inc-seqs\n                     (filter #(>= (count %) 2))\n                     (sort-by count)\n                     (last)) ]\n    (or longest [])\n    )\n  )","user":"605f5c69e4b03746e80ebf5e"},{"code":"(fn longest-inc-seq [v]\n  (letfn [(takes [v] (map #(take % v) (range 2 (inc (count v)))))\n          (drops [v] (map #(drop % v) (range (count v))))\n          (differences [v] (map #(reduce - %) (partition 2 1 v)))\n          (consecutive? [v] (every? (partial = -1) (differences v)))\n          (combos [v] (apply concat (map takes (drops v))))]\n    (apply (partial max-key count) (cons [] (filter consecutive? (combos v))))))","problem":53,"user":"50c2fbebe4b00e537d00253c"},{"code":"(fn [s]\n  (let [larger (fn [a b] (if (>= (count a) (count b)) a b))\n        next? (fn [a b] (if (nil? b) true (= a (inc b))))\n        find (fn [[x & rst] [c & _ :as C] L ]\n               (cond (nil?  x  ) (reverse (larger L C))\n                     (next? x c) (recur rst (cons x C) L)\n                     :else       (recur rst (list x) (larger L C))))\n        ll (find s '() '())]\n    (if (> (count ll) 1) ll [])))","problem":53,"user":"50fa01bce4b07934dda8b0ba"},{"problem":53,"code":"(comp #(if (< 1 (count %)) % [])\n         (fn lcss [m-seq] (loop [x (first (rest m-seq))\n                        xs (rest (rest m-seq))\n                        acc [(first m-seq)]\n                        highest (first m-seq)]\n              (if (= () xs)\n                (if (= x (inc highest)) (conj acc x) acc)\n                (if (= x (inc highest))\n                  (recur (first xs) (rest xs) (conj acc x) x)\n                  (max-key count (lcss (cons x xs)) acc))))) )","user":"5de051bfe4b0948ae9d9ade5"},{"problem":53,"code":"#(loop [value (first %) a (rest %) current [value] longest []]\n    (if (empty? a)\n      (if (> (count current) (count longest))\n        (if (> (count current) 1) current [])\n        (if (> (count longest) 1) longest [])\n        )\n      (if (= (inc value) (first a)) \n        (recur (first a) (rest a) (conj current (first a)) longest)\n        (recur (first a) (rest a) [(first a)] (if (> (count current) (count longest)) current longest))\n        )\n      )\n    )","user":"5763818ae4b0994c1922fbc7"},{"code":"(fn [s]\n    (loop [s s c [] l []]\n      (if (empty? s)\n        (if (> (count l) 1)\n          l\n          [])\n        (if (> (first s) (or (last c) -1))\n          (let [c* (conj c (first s))]\n            (recur (rest s) c* (if (> (count c*) (count l)) c* l)))\n          (recur s [] l)))))","problem":53,"user":"4ed292ac535d44c135fd68d9"},{"problem":53,"code":"(fn [xs]\n  (letfn [(increasing? ([[a b]] (< a b)))]\n    (->> xs\n         (iterate rest)\n         (take-while seq)\n         (map #(partition 2 1 [0] (cons -1 %)))\n         (map #(take-while increasing? %))\n         (map #(map second %))\n         (sort-by #(* -1 (count %)))\n         (filter #(> (count %) 1))\n         first\n         vec)))","user":"58ec1e63e4b056aecfd47d54"},{"problem":53,"code":"(fn [s]\n  (loop [ longest []\n          current []\n          n (first s)\n          left (rest s)\n          ]\n    (cond\n     (nil? n) (if (> (count current) (count longest) 1) current longest) \n     (>  n (or (last current) -1)) (recur longest (conj current n) (first left) (rest left))\n     (> (count current) (max (count longest) 1)) (recur current [n] (first left) (rest left))\n     :else (recur longest [n] (first left) (rest left))\n     )\n    )\n  )","user":"5ec819b4e4b08d0ec38692e2"},{"code":"(fn [col] (or (->> (map vector col (range)) (partition-by #(apply - %)) (map #(map first %)) (filter #(> (count %) 1)) (sort-by (comp - count)) first) []))","problem":53,"user":"4fe1a734e4b0dd6cd5ce3637"},{"code":"(fn [coll]\n  (or (first (filter #(apply < %)\n                     (#(let [n (inc (count %))]\n                         (for [l (reverse (range 2 n))\n                               i (range 0 (- n l))]\n                           (take l (drop i %))))\n                       coll))) []))","problem":53,"user":"4e4ad154535dc968683fc4d1"},{"problem":53,"code":"(fn [v]\n  (let [pairs (map (juxt identity (partial apply <))(map vector (butlast v) (rest v)))\n        increasing (filter #(second (first %)) (partition-by second pairs)) ]\n    (if (empty? increasing)\n      []\n      (let [longest (apply max-key count (reverse increasing))]\n      (concat (map ffirst longest) [(second (first (last longest)))]))\n  )))","user":"54e345a1e4b024c67c0cf7db"},{"problem":53,"code":"(fn me [v]\n\n\t(let [\n\t\t\tm-fn (fn  [my-v]\n\n\t\t\t\t(let [\n\t\t\t\t\t\tr-fn (fn [res arg]\n\n\t\t\t\t\t\t\t(if (empty? (first res))\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t[(concat (first res) [arg]) (concat (second res) [arg])]\n\n\t\t\t\t\t\t\t\t(if (and (>= (count (second res)) 1)  (= 1 (- arg (last (first res)))))\n\t\t\t\t\t\t\t\t\t[(concat (first res) [arg]) (concat (second res) [arg])]\n\t\t\t\t\t\t\t\t\t[(first res) []]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t)\n\t\t\t\t]\n\n\t\t\t\t(first (reduce r-fn [[] []] my-v))\n\n\t\t\t\t)\n\t\t\t)\n\n\t\tvv (take (count v) (iterate #(rest %) v) )\t\n\n\t\tres  (last (sort-by count (map m-fn vv)))\t\n\t\t\t\n\t\t]\n\n\t\n\n\t\t(if (<= (count res) 1)\n\t\t\t[]\n\t\t\tres\n\t\t)\n\n\t)\n\n)","user":"55897fe2e4b059ccff29b205"},{"code":"(fn inc-subseq [l]\n  (loop [ll l ;the seq\n         i 0 ;temp counter length\n         j 0 ;counter longest subseq so far\n         ss '() ;temp longest subseq\n         fin '()] ;final longest subseq\n    (if (empty? ll)\n      fin\n      (if (> (or (second ll) -1) (first ll)) ;increasing cont.\n      \t(recur (rest ll) (+ i 1) j\n          \t\t(concat ss (list (first ll)))  fin)\n      \t(if (> i j) ;last found seq is the longest\n        \t(recur (rest ll) 0 i \n                '() \n               (concat ss (list (first ll)))) ;new longest seq\n        \t(recur (rest ll) 0 j '() fin))))))","problem":53,"user":"50c84ba2e4b00bb60fe0c53e"},{"code":"(fn longest-sequence                                                         \n  [coll]                                                                       \n  (let [succ? (fn [a b] (= (+ 1 a) b))                                         \n        myconj (fn [c a] (if (> (count a) 1) (conj c a) (conj c [])))          \n        ]                                                                      \n        (loop [prev-seqs [] curr [] [item & more] coll]                        \n          (if (nil? item)                                                      \n            (first (sort #(> (count %1) (count %2)) (myconj prev-seqs curr)))  \n            (if (or (empty? curr)                                              \n                    (succ? (last curr) item))                                  \n              (recur prev-seqs (conj curr item) more)                          \n              (recur (myconj prev-seqs curr) [item] more)                      \n              )                                                                \n            )                                                                  \n      ))                                                                       \n  )","problem":53,"user":"50573ed8e4b0012181721987"},{"code":"(fn [c]\n  ((fn [best-inc curr-inc c]\n      (if (empty? c)\n          best-inc\n        (let [curr-inc (if (or (empty? curr-inc) (> (first c) (last curr-inc)))\n                            (conj curr-inc (first c))\n                          [(first c)])\n              best-inc (if (and (> (count curr-inc) 1) (> (count curr-inc) (count best-inc)))\n                            curr-inc\n                          best-inc)]\n          (recur best-inc curr-inc (rest c)))))\n      [] [] c))","problem":53,"user":"4ead6418535d7eef3080731f"},{"problem":53,"code":"(fn [xs]\n  (loop [maxseq [] cur [] xs xs]\n    (if (empty? xs)\n      (if (>= (count cur) (count maxseq))\n        (if (> (count cur) 2)\n          cur\n          []\n        )\n        maxseq\n      )\n      \n      (if (empty? cur)\n        (recur maxseq [(first xs)] (rest xs))\n        (if (= (inc (last cur)) (first xs))\n          (recur maxseq (concat cur [(first xs)]) (rest xs))\n          (if (>= (count cur) (count maxseq))\n            (recur cur [(first xs)] (rest xs))\n            (recur maxseq [(first xs)] (rest xs))\n          )\n        )\n      )\n    )\n  )\n)","user":"583dacc2e4b089d5ab817d9f"},{"problem":53,"code":"(fn [elems]\n    (let [increasing (filter (fn [elems] (every? (fn [[x y]] (> y x)) elems))\n                             (partition-by (fn [[x y]] (> y x)) (partition 2 1 elems)))\n          longest (reduce (fn [x y] (if (> (count y) (count x)) y x)) [] increasing)]\n      (concat (map first (butlast longest))\n              (last longest))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":53,"code":"(fn\n  longest-inc-seq\n  [lst]\n  (let [longest-inc-seq'' (fn longest-inc-seq'\n                            [prevele seq1 cntvec]\n                            (cond\n                              (empty? seq1) cntvec\n                              (empty? cntvec) (longest-inc-seq' (first seq1) (rest seq1) (conj cntvec 0))\n                              (< prevele (first seq1)) (longest-inc-seq' (first seq1) (rest seq1)\n                                                                         (conj cntvec (inc (last cntvec))))\n                              :else (longest-inc-seq' (first seq1) (rest seq1) (conj cntvec 0))))\n        longest-inc-seq-cnt-vec (longest-inc-seq'' nil lst [])\n        longest-seq-len (apply max longest-inc-seq-cnt-vec)\n        posn-max-ele (.indexOf longest-inc-seq-cnt-vec longest-seq-len)]\n    (if (< longest-seq-len 1)\n      []\n      (drop (- posn-max-ele longest-seq-len) (take (inc posn-max-ele) lst)))))","user":"506f0968e4b09350ab4199f5"},{"problem":53,"code":"#(let [size (count %)]\n    (or (first\n         (sort-by (comp - count)\n           (for [a (range size)\n                 z (range (- (inc size) a))\n                 :let [ss (take z (drop a %))]\n                 :when (and (> (count ss) 1)\n                            (= ss (range (first ss) (inc (last ss)))))]\n             ss)))\n        []))","user":"550f1c99e4b06e50f9beb171"},{"problem":53,"code":"(fn li [s]\n    (let [incseq (reduce (fn [v x]\n                             (if (or (empty? v) (not= (last (last v)) (dec x)))\n                             (conj v [x])\n                             (update-in v [(dec (count v))] conj x)))\n                          []\n                          s)\n          incseq (filter #(> (count %) 1) incseq)]\n        (if (empty? incseq) [] (apply max-key count (reverse incseq)))))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn longest\n  ([l] (longest [] [] nil l))\n  ([ge now lst l]\n   (if (empty? l) (let [as (if (< (count ge) (count now)) now ge)] (if (< 1 (count as)) as []))\n     (if (and ((complement nil?) lst) (= (inc lst) (first l)))\n       (longest ge (conj now (first l)) (first l) (next l))\n       (longest (if (< (count ge) (count now)) now ge) [(first l)] (first l) (next l))))))","problem":53,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [x]\n   (letfn [(choose-best [a b]\n                        (if (> (count a) (count b)) a b))]\n          (loop [coll (rest x) solution [(first x)] best (vec solution)]\n            (let [prev (peek solution) next (first coll)]\n              (cond\n                (empty? coll) (if (> (count best) 1) best [])\n                (= (+ prev 1) next)\n                  (recur (rest coll) (conj solution next) (choose-best (conj solution next) best))\n                :else (recur (rest coll) [next] best))))))","problem":53,"user":"4fe9ef2fe4b0547ebccb2479"},{"code":"#(first \n   (sort-by count (fn [a b] (compare b a)) \n            (map (fn [l] (if (> (count l) 1) l '() ))\n                 (partition-by type\n                               (reduce \n                                (fn [m x]\n                                  (if (> x (last m))\n                                    (conj m x)\n                                    (conj m false x)))\n                                [(first %)]\n                                (rest %)\n                                )))))","problem":53,"user":"51e58e02e4b0efabf93c02d0"},{"problem":53,"code":"(fn lis [s]\n  (letfn [(inc-count [s]\n            (count (take-while identity\n                               (map < s (rest s)))))]\n    (let [init-cut (apply max-key\n                          inc-count\n                          (map #(drop % s)\n                               (reverse (range (count s)))))\n          term-cut (take (inc (inc-count init-cut))\n                         init-cut)]\n      (if (< (count term-cut) 2) []\n        term-cut))))","user":"5b47874be4b02d533a91bc70"},{"problem":53,"code":"(fn longest-subseq [s]\n   (loop [prev-elem Double/NEGATIVE_INFINITY\n          current-elem (first s)\n          max-subseq []\n          current-subseq []\n          remainder (rest s)]\n          (if (nil? current-elem)\n              (cond (>= (count max-subseq) (count current-subseq) 2) max-subseq\n                    (>= (count current-subseq) (count max-subseq) 2) current-subseq\n                    :else []\n              )\n              (recur\n                ; prev-elem\n                current-elem\n                ; current-elem\n                (first remainder)\n                ; max-subseq\n                (if (> (count current-subseq) (count max-subseq))\n                    current-subseq\n                    max-subseq\n                )\n                ; current-subseq\n                (if (> current-elem prev-elem)\n                    (conj current-subseq current-elem)\n                    [current-elem]\n                )\n                ; remainder\n                (rest remainder)\n              )\n          )\n   )\n)","user":"5990fcb9e4b0866487ed0d5b"},{"problem":53,"code":"(fn [xs] (loop [tail xs best [] acc []]\n   (cond\n    (empty? tail) (let [res (if (>= (count best) (count acc)) best acc)]\n                    (if (empty? (rest res)) [] res))\n    (or (empty? acc) (= (first tail) (inc (last acc)))) (recur (rest tail) best (conj acc (first tail)))\n    :else (recur tail (if (>= (count best) (count acc)) best acc) []))))","user":"5d5e0259e4b0c9e5857d4fef"},{"code":"(fn [coll] (let [c (filter #(and (apply < %) (> (count %) 1))\r\n  (for [x (range 0 (count coll)) y (range 1 (inc (- (count coll) x)))] (take y (drop x coll))))]\r\n              (if (empty? c) [] (let [n (apply max (map #(count %) c))] (first (filter #(= n (count %)) c))))))","problem":53,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn [s]\n  (letfn [(chunk-into-increasing-seq [s]\n            (let [[a b] (map vec (split-at 1 s))]\n              (loop [a a, b b]\n                (if (seq b)\n                  (if (< (last a) (first b))\n                    (recur (conj a (first b)) (rest b))\n                    (cons a (chunk-into-increasing-seq b)))\n                  [a]))))]\n    (let [chunks (chunk-into-increasing-seq s)\n          good-sized-chunks (filter #(> (count %) 1) chunks)]\n      (if (seq good-sized-chunks)\n        (let [sizes (map count good-sized-chunks)\n              longest (apply max sizes)\n              longest-chunks (filter #(= longest (count %)) good-sized-chunks)]\n          (first longest-chunks))\n        []))))","problem":53,"user":"4e80aa10535db62dc21a62b1"},{"code":"(fn [in]\n  (let [reducer (fn [acc x]\n    (if\n      (not (seq (first acc))) (list (list x))\n      (let [[a & as] acc\n            [b & bs] a\n            nxt (inc b)]\n        (if (= nxt x) (cons (cons x a) as)\n          (cons (list x) acc)))))\n        runs (reduce reducer (list (list)) in)]\n    (reverse (last (vals (sort-by first (dissoc (apply merge (map (fn [s] {(count s) s}) runs)) 1)))))\n    ))","problem":53,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":53,"code":"(fn [coll]\n  (loop [[one two & rest] coll\n         current [(first coll)]\n         longest []]\n    (if (nil? two)\n      longest\n      (let [carry (cons two rest)\n            cur-conj (conj current two)]\n      \t(if (= (inc one) two)\n          (recur carry cur-conj (if (> (count longest) (count cur-conj))\n            \t                    longest\n                \t                cur-conj))\n          (recur carry [two] longest))))))","user":"5561d2c2e4b0c656e3ff17cd"},{"problem":53,"code":"(fn lngst [coll]\n  (->> coll\n    (reduce \n      (fn [acc el] \n        (cond \n         (empty? acc) (cons (vector el) acc)\n         (= (first (first acc)) (dec el)) (cons (cons el (first acc)) (rest acc))\n         :else (cons (vector el) acc)\n        )\n       ) \n      '())\n    (reduce \n      (fn [acc el]\n       (if (< (count acc) (count el))\n        el\n        acc \n       )) '())\n    (reverse)\n    (#(if (> (count %1) 1) %1 []))\n  ))","user":"5df75fd8e4b0a607a9a45c92"},{"problem":53,"code":"(fn [xs1]\n   (reduce\n    #(if\n         (and\n           (not= (count %2) 1)\n           (< (count %1) (count %2)))\n       %2\n       %1)\n    []\n    ((fn [xs]\n       (map\n        (fn [coll]\n          (loop [cl coll rs []]\n            (if (= (inc (first cl)) (second cl))\n              (recur (next cl) (conj rs (first cl)))\n              (conj rs (first cl)))))\n        (take (count xs) (iterate next xs))))\n     xs1)))","user":"5b37a3b4e4b02d533a91bba9"},{"code":"(fn [x]\n    ((fn proc [longest currentSeq lst]\n      (println longest currentSeq lst)\n      (cond\n        (empty? lst) longest\n        (empty? currentSeq) (recur [] (vector (first lst)) (rest lst))\n        (> (first lst) (last currentSeq))\n          (if (>= (count currentSeq) (count longest))\n            (recur (conj currentSeq (first lst)) (conj currentSeq (first lst)) (rest lst))\n            (recur longest (conj currentSeq (first lst)) (rest lst)))\n        :else (recur longest [(first lst)] (rest lst)))) [] [] x\n    ))","problem":53,"user":"50ed5d1be4b06330c1f87c37"},{"problem":53,"code":"(fn[n]\n    (loop [v n acc [] max []]\n       (if (empty? v)\n            max\n            (if (and (not (empty? acc)) (= (apply int (take 1 v)) (+ 1 (last acc)))) \n\t\t(if (> (count (conj acc (apply int (take 1 v)))) (count max))\n \t\t\t(recur (rest v) (conj acc (apply int (take 1 v))) (into [] (conj acc (apply int (take 1 v)))))\n\t\t\t(recur (rest v) (conj acc (apply int (take 1 v))) max)\n\t\t)\n\t\t(recur (rest v) (into [] (take 1 v)) max)\n            )\n       )\n    )\n)","user":"54d2829ce4b0e8a36923e5f6"},{"problem":53,"code":"(fn [vec]\n     (->> vec\n          (reduce\n              (fn [acc n]\n                  (let [lastVec (last acc)]\n                      (cond\n                          (nil? lastVec)\n                          (conj acc [n])\n                          (= (- n (last lastVec)) 1)\n                          (assoc-in acc [(- (count acc) 1)] (conj lastVec n))\n                          :else (conj acc [n])))) [])\n          (filter #(> (count %) 1))\n          (sort-by count)\n          (last)\n          (#(if (nil? %) [] %))))","user":"566812f0e4b04acd4f672de1"},{"code":"(fn gg \n    ([res] (gg res [] []))\n    ([res best curr]\n    (println res best curr)\n    (if (empty? res)\n      (if (and (< (count best) 2) (< (count res) 2))\n        []\n      (if (< (count best) (count curr)) curr best))\n      (if (or (empty? curr) (< (last curr) (first res)))\n        (gg (rest res) best (conj curr (first res)))\n        (if (< (count best) (count curr))\n          (gg (rest res) curr [(first res)])\n          (gg (rest res) best [(first res)])\n          )\n        )\n      )\n    )\n    )","problem":53,"user":"4f2004a1535d64f6031464a7"},{"code":"(fn [s] (letfn [(gen-subseq [s] (mapcat (fn [s] (map #(subvec s 0 %) (range 0 (inc (count s)))))\n                                      (map #(subvec s %) (range 0 (inc (count s))))))]\n                (last (sort #(< (count %1) (count %2)) (reverse (filter #(not (= (count %) 1)) (filter #(= % (vec (apply sorted-set %))) (gen-subseq s))))))))","problem":53,"user":"5294e44de4b02ebb4ef75016"},{"problem":53,"code":"(fn t12 [coll]\n  (let [l #(loop [res [(first %)] c (rest %)]\n             (if (or (empty? c) (not= (last res) (- (first c) 1)))\n               (if (= (count res) 1)\n                 []\n                 res)\n               (recur (conj res (first c))(rest c))))]\n    (reduce #(if (< (count %2) (count %1))\n               %1\n               %2)\n            (loop [res [] c coll]\n              (if (empty? c)\n                res\n                (recur (conj res (l c)) (rest c)))))))","user":"5046f909e4b03b02161376b5"},{"code":"(fn [x] \n  (-> (filter\n        #(> (count %) 1)\n        (reductions #(conj (if (> %2 (last %)) % []) %2)\n                    [(first x)] (rest x)))\n    sort last (or [])))","problem":53,"user":"518696c1e4b0c40be512d708"},{"code":"(fn sub [s]\n  (let [subb (fn [s curs maxs]\n               (let [x (first s)\n                     r (rest s)\n                     ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x)\n                               [x])\n                     nmax (max-key count ncurs maxs)]\n                 (if (seq r)\n                   (recur r ncurs nmax)\n                   nmax)))\n        longest (subb s [(first s)] [])]\n    (if (> (count longest) 1) longest [])))","problem":53,"user":"50705072e4b07bd6ad9b9f27"},{"code":"(fn [xs]\n  (let [ranges (for [i (range (+ 1 (count xs)))\n                     j (range (+ 1 (count xs)))\n                     :when (< i (- j 1))]\n                 [i j])\n        subseqs (map (fn [[i j]] (subvec xs i j)) ranges)\n        increasing (filter (partial apply <) subseqs)]\n    (apply (partial max-key count) (conj (reverse increasing) []))))","problem":53,"user":"528a2de7e4b0239c8a67ae71"},{"problem":53,"code":"(fn longSeq [coll]\n  (->> \n   (partition 2 1 coll)\n   (partition-by #(- (second %) (first %)))\n   (filter #(= 1 (- (second (first %)) (ffirst %))))\n   (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n   (flatten)\n   (distinct)))","user":"57ee9ffbe4b0bfb2137f5bc2"},{"problem":53,"code":"(fn\n  [s-in]\n  (let [longer (fn [a b] \n                 (let [l (if (> (count b) (count a)) b a)]\n                   (if (> (count l) 1)\n                     l\n                     [])))]\n    (loop [longest []\n           ss []\n           f (first s-in)\n           r (rest s-in)]\n      (if f\n        (if (or (not (seq ss))\n                (> f (last ss)))\n          (recur longest (conj ss f) (first r) (rest r))\n          (recur (longer longest ss) [f] (first r) (rest r)))\n        (longer longest ss)))))","user":"5408ec4de4b0addc1aec66d0"},{"code":"(fn [lst]\n    (reduce\n      #(if (> (count %2) (count %)) %2 %)\n      ()\n      (filter\n\t      #(and (apply < %) (> (count %) 1))\n\t\t    (for [s (range (count lst))\n\t\t          n (range 1 (inc (- (count lst) s)))]\n\t\t      (take n (drop s lst))))))","problem":53,"user":"4fba7d1ee4b081705acca2e0"},{"code":"(fn l-sub-seq-- [coll]\n  (reduce #(let [c (count %2)\n                 s (sort %2)]\n             (if (and (> c 1)\n                      (> c (count %1))\n                      (and (= %2 s)\n                           (= s (distinct s))))\n               %2\n               %1))\n          '() (mapcat #(take (count %1) (iterate butlast %1))\n                      (take (count coll) (iterate rest coll)))))","problem":53,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn lis [lt]\n  (letfn [(split [lt u bs acc]\n                 (if (seq lt)\n                   (let [ltf (first lt)\n                         ltr (rest lt)]\n                     (if (<= ltf u)\n                       (split\n                         ltr ltf [] (conj acc [(inc (count bs))\n                                               (conj bs u)]))\n                       (split\n                         ltr ltf (conj bs u) acc)))\n                   (conj acc [(inc (count bs)) (conj bs u)])))\n          (max-len [lt m ml]\n                   (if (seq lt)\n                     (let [f (first lt), r (rest lt), fl (first f)]\n                       (if (> fl ml)\n                         (max-len r (rest f) fl)\n                         (max-len r m ml)))\n                     (first m)))]\n    (let [res-split (split (rest lt) (first lt) [] [])\n          ls (max-len (rest res-split) (rest (first res-split)) (first (first res-split)))]\n      (if (= (count ls) 1)\n        []\n        ls))))","problem":53,"user":"4e1b2cd9535d04ed9115e7fd"},{"code":"#(last (cons []\n  (sort-by count \n    (for[x (filter (fn[a](> (count a) 1)) \n      (for[a (range 1 (+ 1 (count %)))  b (range (count %))] \n        (take a (drop b %)))) \n          :when (= (range (first x) (+ (count x) (first x))) x)] x))))","problem":53,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":53,"code":"#(let [append-to-first (fn [acc x] (concat [(conj (first acc) x)] (vec (rest acc))))\n       sub-seqs (reduce (fn [acc x]\n                          (vec (if-not (and (seq acc) (< (last (first acc)) x))\n                                (cons [x] acc)\n                                (append-to-first acc x))))\n                       [] %)]\n  (reduce (fn [s1 s2]\n            (let [c1 (count s1)\n                  c2 (count s2)]\n              (cond\n               (and (< c1 2) (< c2 2)) []\n               (< c2 c1) s1\n               :else s2)))\n          sub-seqs))","user":"55868660e4b059ccff29b1d4"},{"code":"(fn lis [x]\n  (loop [ls (rest x)\n         run []\n         cand [(first x)]]\n    (if (empty? ls)\n      (if (> (count run) 1)\n        run\n        [])\n      (if (> (first ls)\n             (last cand))\n        (recur (rest ls) \n               (if (> (count (concat cand (list (first ls)))) (count run))\n                 (concat cand (list (first ls)))\n                 run)\n               (concat cand (list (first ls))))\n        (recur (rest ls) \n               (if (> (count cand) (count run))\n                 cand\n                 run)\n               [(first ls)])))))","problem":53,"user":"52e17e66e4b09f7907dd1423"},{"problem":53,"code":"(fn solution [coll]\n  (loop [result [(first coll)] x (rest coll) longest []]\n    (if (seq x)\n      (if (< (last result) (first x))\n        (recur (conj result (first x)) (rest x) longest)\n        (recur [(first x)] (rest x) (conj longest result)))\n      (vec (first (sort-by (comp - count) (filter #(> (count %) 1) (conj longest result))))))))","user":"5b3ef412e4b02d533a91bc06"},{"code":"(fn [coll]\n   ((comp vec set flatten) \n      ((comp (partial apply max-key count) #(if (empty? %) [[]] %)) \n         (filter #(= (first (first %)) (dec (last (first %))))\n                 (partition-by #(= (first %) (dec (last %)))\n                               (map vector coll (drop 1 coll)))))))","problem":53,"user":"533ee560e4b085b17e897d98"},{"code":"(fn lets-go [big-ol-seq] \n\n  (let [increasing-subseq (fn increasing-subseq [so-far to-do]\n                            (cond (empty? to-do) [so-far to-do]\n\n                                  (< (last so-far) (first to-do))\n                                  (increasing-subseq (conj so-far (first to-do)) (rest to-do))\n\n                                  :else [so-far to-do]))\n\n        longer (fn [xs ys]\n                 (cond (> (count ys) (count xs)) ys\n                       :else xs))\n\n        longest-increasing-subseq (fn longest-increasing-subseq [coll]\n                                    (cond (empty? coll) []\n                                          :else (let [[first-seq rest-seq] \n                                                      (increasing-subseq [(first coll)] (rest coll))]\n                                                  (longer first-seq (longest-increasing-subseq rest-seq)))))\n        not-too-short (fn [coll]\n                        (cond (empty? (rest coll)) []\n                              :else coll))]\n\n    (not-too-short (longest-increasing-subseq big-ol-seq))))","problem":53,"user":"4f7250cce4b07046d9f4f02a"},{"problem":53,"code":"(fn [v] (or (->> (range (count v) 1 -1)\n                 (mapcat #(partition % 1 v))\n                 (some #(when (= (rest %) (butlast (map inc %))) %)))\n            []))","user":"559b2ad1e4b066d22e731f4e"},{"code":"(fn f [l]\n  (letfn [(longest [l i]\n            (cond\n              (= '() l) '()\n              (<= (first l) i) '()\n              :else (cons (first l) (longest (rest l) (first l)))))]\n    (if (= '() l)\n      '()\n      (let [here (longest l (dec (first l)))\n            later (f (rest l))\n            chere (count here)\n            clater (count later)]\n        (cond\n          (< (max chere clater) 2) '()\n          (>= chere clater) here\n          :else later)))))","problem":53,"user":"50b668dde4b08fb537db98f2"},{"problem":53,"code":"(fn [numbers]\n  (->> numbers\n    (partition 2 1)\n    (partition-by (partial apply <))\n    (filter (fn [[[a b & rest]]] (< a b)))\n    (reduce (fn [longestSoFar current] \n      (if (> (count current) (count longestSoFar)) \n        current \n        longestSoFar)) \n      [])\n    (#(if (empty? %) [] (cons (ffirst %) (map second %))))\n    ))","user":"59738d98e4b01722bebd4ca1"},{"code":"(fn longest-liszt [sq]\n  (let [liszt-reduce\n        (fn liszt-reduce [f initial-stretch base sq]\n          ((fn [stretch redval sq]\n             (if-not (empty? sq)\n               (let [[lhbs rhbs new-redval]\n                     (f (> stretch (count sq)) redval (take stretch sq))]\n                 (if-not (= lhbs rhbs 0) \n                   (recur\n                    (-> stretch (- lhbs) (+ rhbs)) new-redval (drop lhbs sq))\n                   new-redval))\n               redval))\n           initial-stretch base sq))\n        assoc-iff-none\n        (fn [redval k v]\n          (if-not (contains? redval k)\n               (assoc redval k v)\n               redval))\n        out\n        (liszt-reduce\n         (fn [fin redval sbsq]\n           (let [l (count sbsq)]\n             (if-not fin\n               (if (apply < sbsq)\n                 [0 1 redval]\n                 (do\n                   (println (str (first sbsq)))\n                   [(- l 1) 0 (assoc-iff-none redval (- l 1) (butlast sbsq))]))\n               [0 0 (assoc-iff-none redval l sbsq)])))\n         1 {} sq)]\n    (let [max-length (-> out keys sort last)]\n      (if (>= max-length 2)\n        (get out max-length)\n        []))))","problem":53,"user":"51b24defe4b02f8f128bb963"},{"problem":53,"code":"(fn [s]\n        (loop [[x & xs] (rest s) cs [(first s)] ss []]\n          (cond\n            (nil? x) (reduce (fn [ms s] (if (and (> (count s) 1)\n                                                 (> (count s) (count ms)))\n                                          s\n                                          ms))\n                             []\n                             (conj ss cs))\n            (> x (last cs)) (recur xs (conj cs x) ss)\n            :else (recur xs [x] (conj ss cs)))))","user":"546c4377e4b00cfc9eacc177"},{"code":"(fn longest-chain-inline\n  [coll]\n  (let [chains ((fn [coll]\n                  (for [i (range 1 (count coll))\n                        :let [x (coll (dec i))\n                              xx (coll i)]]\n                    (if (= 1 (- xx x)) [x xx] nil))) coll)]\n    (or (->>  chains\n          flatten\n          (reduce #(if (= (last %) %2) % (conj % %2)) [])\n          (partition-by nil?)\n          (remove #(= % [nil]))\n          (sort-by count >)\n          first)\n        [])))","problem":53,"user":"5170ea06e4b0d70c8bbbf235"},{"code":"(fn [v] (let [x (last (sort-by count (filter #(second (first %)) (partition-by #(second %) (map-indexed (fn [a b] [b (= b (inc (nth v a))) a]) (rest v)))))) i (last (first x))] (if x (subvec v i (+ i (inc (count x)))) [])))","problem":53,"user":"4eb13d60535d7eef3080733f"},{"problem":53,"code":"(letfn [(p [[x y]] (= y (inc x)))\n        (q [xs ys] (if (< (count xs) (count ys)) ys xs))]\n  (fn [xs]\n    (->> xs\n         (partition 2 1)\n         (partition-by p)\n         (filter #(p (first %)))\n         (reduce q [])\n         (flatten)\n         (distinct))))","user":"54acf5c7e4b09f271ff37cdd"},{"problem":53,"code":"(fn momo\n  [sekuen]\n  (loop [[x & xs] sekuen res []]\n    (if (nil? xs)\n      (if (some #(true? (first %)) res)\n        (let [nres (partition-by #(identity (first %)) res)\n              fres (filter #(true? (first (first %))) nres)]\n          (let [[f] (take-last 1 (sort-by count fres))]\n            (if (= 1 (count f))\n              (second (first f))\n              (let [[x & xs] (map second f)]\n                (concat x (map second xs))))))\n        [])\n      (recur xs\n             (let [xn (first xs)\n                   pair [x xn]\n                   inc? (= (inc x) xn)]\n               (conj res [inc? pair]))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [l]\n  (->>  \n    (partition 2 1 l) ; make pairs \n    (partition-by (fn [[a b]] (- b a)))\n    (filter (fn [[[a b]]] (> b a)))\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n    flatten\n    distinct \n    ))","problem":53,"user":"509c2c55e4b085ae113522ab"},{"problem":53,"code":"(fn [v]\n  (letfn [(update-res [res s e]\n            (if (> (- e s) (count res))\n              (subvec v s e)\n              res))]\n    (loop [i 0, s 0, res []]\n      (if (>= i (count v))\n        (let [res' (update-res res s i)]\n          (if (> (count res') 1) res' []))\n        (if (and (> i 0) (= (nth v i) (inc (nth v (dec i)))))\n          (recur (inc i) s res)\n          (recur (inc i) i (update-res res s i)))))))","user":"4db2903f535df7e46ed9b6bf"},{"code":"(fn compl [q] (let [ conq (fn conq [l]\n                              (if (and (not(empty? l)) (not(nil? (first (next l)))))\n                                (let [f (first l) n (first (next l)) z (conq (rest l))]\n                                  (if (= n (+ f 1))\n                                    (cons f (if (or (empty? z) (nil? z)) [n] z) )))))\n\n                       aseq (fn aseq [l] (if (empty? l) [] (let [z (conq l)] (if (nil? z) (aseq (rest l)) (cons z (if (> (count z) 0) (aseq (take-last (- (count l) (count z)) l)) [])  )))))\n\n                       res (aseq q)\n\n                       fin (first (reverse(sort-by count res)))\n                       ] (if (nil? fin) [] fin)  ))","problem":53,"user":"5245d29ae4b09dbe66b56174"},{"problem":53,"code":"(fn [mycoll]\n  (loop [longest [] result [] data mycoll]\n    (if (empty? data) (if (and (> (count result) 1) (> (count result) (count longest))) result longest)\n      (if (empty? result)\n        (recur longest (conj result (first data)) (rest data))\n        (if (> (first data) (last result))\n          (recur longest (conj result (first data)) (rest data))\n          (if (and (> (count result) 1) (> (count result) (count longest)))\n            (recur result [] data)\n            (recur longest [] data)))))))","user":"53d977f1e4b0e771c302547a"},{"problem":53,"code":"(fn [coll]\n   (or\n    (first\n     (filter\n      #(>= (count %) 2 )\n      (sort #(apply > (map count %&))\n            (map\n             (fn [pos]\n               (rest\n                (filter #(and (not (nil? %)))\n                        (reduce\n                         (fn [%1 %2]\n                           (if (last %1)\n                             (if (> %2 (last %1))\n                               (conj %1 %2)\n                               (conj %1 nil)\n                               )\n                             %1)\n                           )\n                         [-1]\n                         (drop pos coll)))))\n             (range (count coll))))))\n    []\n    )\n\n\n   )","user":"58db48a5e4b0a4d5acaab679"},{"code":"(fn [[h & r]]\n  (let [[_ & y :as w] (first\n                        (sort-by count >\n                          (reductions\n                            (fn [a e]\n                              (if (< (last a) e)\n                                (conj a e)\n                                [e]))\n                            [h]\n                            r)))]\n                                               \n    (if y w [])))","problem":53,"user":"52bacfa8e4b07a9af57922d6"},{"problem":53,"code":"(fn [i]\n    (let [[acc cur]\n          (reduce (fn [[acc cur] n] \n                    (if (= (last cur) (dec n)) [acc (conj cur n)] [(conj acc cur) [n]])) \n                  [[] [(first i)]] (rest i))\n\n          largest (first (reverse (sort-by count (conj acc cur))))]\n      (if (< 1 (count largest)) largest []))\n    )","user":"58d27bcae4b03c36ff7e58fe"},{"problem":53,"code":"(fn [coll]\n    (letfn [(state-continue-subseq [curr acc results]\n              {:prev curr :acc (conj acc curr) :results results})\n            (state-new-subseq [curr acc results]\n              {:prev curr :acc [curr] :results (conj results acc)})\n            (result-extract [state]\n              (if (seq (:acc state))\n                (conj (:results state) (:acc state))\n                (:results state)))\n            (inc-subseq-reducer [state curr]\n              (let [prev (:prev state)\n                    acc (:acc state)\n                    results (:results state)]\n                (if (> curr prev)\n                  (state-continue-subseq curr acc results)\n                  (state-new-subseq curr acc results))))]\n      (let [state-initial {:prev (first coll)\n                           :acc [(first coll)]\n                           :results []}\n            last-state (reduce inc-subseq-reducer\n                               state-initial\n                               (rest coll))\n            inc-subseqs (result-extract last-state)\n            longest-arg (partial max-key count)\n            first-longest #(apply longest-arg (reverse %))\n            longest-subseq (first-longest inc-subseqs)]\n        (if (> (count longest-subseq) 1)\n          longest-subseq\n          []))))","user":"5515b138e4b055c2f668d4ed"},{"problem":53,"code":"(fn [coll] (first (conj (filterv (fn asc? [coll1] (every? true? (map #(< % %2) (drop-last coll1) (rest coll1)))) \n                                 (mapcat #(partition % 1 coll) (range (count coll) 1 -1)))\n                        ())))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn [a-vec] \n  (let [result-vec (reduce \n    (fn [max a] (if (> (count max) (count a)) max a))\n    (reduce (fn [result data] \n              (if (= (dec data) (last (first result)))\n                  (conj (rest result) \n                        (conj (first result) data))\n                  (conj result [data])))\n              '() a-vec))]\n    (if (= 1 (count result-vec)) [] result-vec)))","problem":53,"user":"4e6dc95a535d5021c1a895f1"},{"code":"(fn lng[c]\r\n  (loop [acc [[]] l c]\r\n    (if (empty? l)\r\n      (if (= 1 (count(last(sort-by count acc))))\r\n        []\r\n        (last(sort-by count acc)))\r\n      (recur (if (= (last(last acc)) (- (first l) 1))\r\n               (conj acc (concat (last acc) [(first l)]))\r\n               (conj acc [(first l)])) (rest l)))))","problem":53,"user":"4e9def6b535dbda64a6f6b8f"},{"problem":53,"code":"(fn [coll]\n   (let [f (fn [acc n]\n             (cond\n              (empty? acc) [n]\n              (= (dec n) (peek acc)) (conj acc n)\n              :else [n]))\n         ret (filter #(> (count %) 1)\n                     (reductions f [] coll))]\n     (if (empty? ret)\n       ret\n       (apply max-key count ret))))","user":"56ae214ce4b03c432f18735a"},{"problem":53,"code":"(fn my-lis[c]\n(->> c\n     (partition 2 1)\n     (partition-by #(< (first %) (second %)))\n     (map (fn [c] (filter #(= (inc (first %)) (second %)) c)))\n     (map (partial reduce concat))\n     (map distinct)\n     (sort-by count)\n     (distinct)\n     (last)))","user":"58988cbbe4b00487982d52d7"},{"code":"(fn [s]\n  (let [[pos len]\n    (apply max-key second\n      (reverse (map list\n                    (range)\n                    (reductions (fn [memo int]\n                                  (if (> int 0) (inc memo) 0))\n                                0\n                                (map - (rest s) s)))))]\n    (if (> len 0)\n      (take (inc len) (drop (- pos len) s))\n      '())))","problem":53,"user":"4f9a0064e4b0dcca54ed6d03"},{"code":"#(->> % \n     (partition 2 1) \n     (partition-by (fn [a] (apply < a)))\n     (filter (fn [a] (apply < (first a))))\n     (group-by count) \n     (sort-by key >) \n     first \n     second \n     first \n     ((juxt (partial map first) (comp last last))) \n     flatten\n     (filter (comp not nil?)))","problem":53,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn longest-increasing-sub-seq [coll]\n  (let [sub-seqs-increasing   (filter #(= % (sort (set %)))\n  \t\t\t      (for [i (range (count coll))\n\t\t\t\t\t    j (range (inc i) (count coll))]\n\t\t\t\t\t(take (- (inc j) i) (drop i coll))))\n\tmax-size              (if (not (empty? sub-seqs-increasing)) \n\t\t\t\t(apply max (map count sub-seqs-increasing))\n\t\t\t\t0)\n\tcandidates            (filter #(= (count %) max-size) sub-seqs-increasing)\n\tbig-enough-candidates (filter #(>= (count %) 2) candidates)\n\t]\n    (vec (first big-enough-candidates))\n    ;big-enough-candidates\n    ;sub-seqs-increasing\n    ;max-size\n    ;candidates\n    ))","problem":53,"user":"4dc54eb2535d8a4b2fd74284"},{"code":"(fn [s]\n  (let [c (reductions #(if %2 (inc %1) 0) 0 \n             (map > (rest s) s))\n        a (apply max c)\n        i (.indexOf c a)]\n    (if (> a 0)\n      (map s (range (- i a) (+ i 1)))\n      [])))","problem":53,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":53,"code":"; THIS LOOKS TERRIBLE, refactor! + I misunderstood the problem because I actually find the longest increasing (by 1) sub-seqs but this just so happens to match the example tests. \n(fn [coll]\n(let [res \n(last (sort (filter (complement nil?) (map (fn t [coll]\n(last (filter #(= % (range (first %) (inc (last %)))) (filter #(> (count %) 1) (reductions conj [] coll))))) (take (count coll)\n(iterate #(vec (rest %)) coll))))))\n]\n(if (nil? res) [] res)))","user":"589b98fae4b00487982d533c"},{"code":"#((fn i [s p u h]\n    (if (empty? s)\n      (get h (last (sort (keys h))) [])\n      (let [f (first s)\n            n (conj u f)\n            r (rest s)]\n        (if (> f p)\n          (i r f n (merge {(count n) n} h))\n          (i r f [f] h))))) (rest %) (nth % 0) [(nth % 0)] {})","problem":53,"user":"507ef25ce4b0f753b6f9788e"},{"problem":53,"code":"(fn [xs]\n  (let [parts \n        (reduce (fn [acc x]\n                  (if (> x (last (last acc)))\n                    (conj (pop acc) (conj (last acc) x))\n                    (conj acc [x]))) [ [(first xs)] ] (rest xs))\n        parts-adj (map #(if (= 1 (count %)) [] %) parts)\n        top-size (apply max (map count parts-adj))]\n    (first (filter #(= top-size (count %)) parts-adj))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":53,"code":"(fn longest-subsequence\n  ([_seq] (let [rec-call (longest-subsequence _seq [] [])]\n            (if (< (count rec-call) 2) [] rec-call)))\n  ([_seq currseq bestseq]\n   (if\n     (empty? _seq) \n     (max-key count currseq bestseq)\n     (let \n       [rec-seq \n        (if(or (empty? currseq) (> (first _seq) (last currseq)))\n          (concat currseq (vector (first _seq)))\n          (vector (first _seq)))]\n       (recur \n         (rest _seq) \n         rec-seq\n         (max-key count currseq bestseq))))))","user":"5606a4ace4b08b23635d3175"},{"problem":53,"code":"(fn [seq]\n    ((fn [seq start ctr best]\n      (prn seq start ctr best)\n      (if (empty? seq)\n        best\n        (let [cur (first seq)]\n          (if (= (+ start ctr) cur)\n            (if (> (inc ctr) (count best))\n              (recur (rest seq) start (inc ctr) (range start (inc cur)))\n              (recur (rest seq) start (inc ctr) best)\n            )\n            (recur (rest seq) cur 1 best)\n          )\n        )\n      )\n      ) seq 0 0 []))","user":"5681afaae4b0945ebc182a87"},{"problem":53,"code":"(fn [coll]\n   (letfn [(find-asc-seqs [coll]\n             (letfn [(asc-seq [coll]\n                       (lazy-seq\n                         (when-let [s (seq coll)]\n                           (let [x (first s)\n                                 y (second s)]\n                             (if (and x y (> y x))\n                               (cons x (asc-seq (rest s)))\n                               (list x))))))]\n               (if (empty? (rest coll)) (list (asc-seq coll))\n                                        (cons (asc-seq coll) (find-asc-seqs (rest coll))))))]\n     (let [seqs (filter #(> (count %) 1) (reverse (find-asc-seqs coll)))]\n       (if (seq seqs) (apply max-key count seqs) ()))))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":53,"code":"#(loop [n (count %)]\n   (if (< n 2)\n     []\n     (or (some (fn [a] (if (apply < a) a)) (partition n 1 %)) (recur (dec n)))\n   )\n)","user":"5b99a0a3e4b0c0b3ffbd4ad7"},{"problem":53,"code":"(fn[xs] \n  (let [longest (loop [pairs (partition 2 1 xs)\n         result []]\n    (let [[head tail] (split-with (fn [[a b]] (= (inc a) b)) pairs)\n          result (if (> (count head) (count result)) head result)\n          ]\n      (if (seq tail) (recur (if (seq head) tail (rest tail)) result) result)))]\n    (if (seq longest)\n      (concat (vector (ffirst longest)) (map second longest))\n      longest)))","user":"534d1173e4b084c2834f4a98"},{"code":"(fn max-conseq [coll]\n  (loop [coll coll \n         res []\n         acc []]\n    (if (empty? coll)      \n      (let [a (apply max-key count res)]\n        (if (>= (count a) 2)\n          a\n          []))\n      (recur (rest coll)\n             (if (= (inc (first coll)) (second coll))\n               res\n               (conj res (conj acc (first coll))))\n             (if (= (inc (first coll)) (second coll))\n               (conj acc (first coll))\n               [])))))","problem":53,"user":"53886d2fe4b0640c7a9a589d"},{"problem":53,"code":"(fn [startArray]\n  \t(loop [x startArray currentGrowthVec '() maxGrowthVec '()]\n\t\t(if (> (count x) 1)\n\t\t\t(if (< (first x) (second x))\n\t\t\t\t\t  (recur (drop 1 x) (distinct (concat currentGrowthVec (take 2 x))) maxGrowthVec)\n\t\t\t\t\t    (recur (drop 1 x) '()\n\t\t\t\t\t\t\t\t(if (> (count currentGrowthVec) (count maxGrowthVec)) \n\t\t\t\t\t\t\t\t\t\t\tcurrentGrowthVec\n\t\t\t\t\t\t\t\t\t\t\tmaxGrowthVec\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t)\n\t\t\t(vec (if (> (count currentGrowthVec) (count maxGrowthVec)) \n\t\t\t\t\t\t\t\t\t\t\tcurrentGrowthVec\n\t\t\t\t\t\t\t\t\t\t\tmaxGrowthVec\n\t\t\t\t\t\t\t\t))\n\t\t)\n\t)\n\t)","user":"55253799e4b0882d96d091cf"},{"code":"(fn [coll]\n    (->>\n     (partition 2 1 coll)\n     (partition-by #(- ( second %) (first %))  )\n     (filter #(= 1 (- (second (first %)) (ffirst %))) )\n     (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n     flatten\n     distinct))","problem":53,"user":"510528a0e4b0730a5f55ad85"},{"code":"(let [longer (fn [[xs xn :as x] [ys yn :as y]]\n               (if (> yn xn) y x))\n      append (fn [[xs n] x]\n               [(concat xs [x]) (max 2 (inc n))])\n      f (fn [[y lng cur] x]\n          (if (> x y)\n            [x lng (append cur x)]\n            [x (longer lng cur) [[x] 0]]))]\n  (fn [[x & xs]]\n    (let [[_ x y] (reduce f [x [[] 0] [[x] 0]] xs)]\n      (first (longer x y)))))","problem":53,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"#(apply max-key %\r\n  (reverse (for [x (%2 (% %3)) % (%2 x (- (% %3) 1))\r\n  \t   :let [% (subvec %3 x (+ % 2))]]\r\n\t     (if (apply < %) % []))))\r\ncount range","problem":53,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [coll]\r\n               (loop [r (conj coll 0) c [] l []]\r\n                 (if (empty? r)\r\n                   (if (> (count l) 1) l [])\r\n                   (recur\r\n                     (rest r)\r\n                     (if (empty? c) (vector (first r)) (if (> (first r) (last c)) \r\n                                                         (conj c (first r)) (vector (first r))))\r\n                     (if (> (count c) (count l))\r\n                       c\r\n                       l\r\n                       )))))","problem":53,"user":"4fdf4e2be4b05e33b9224f96"},{"code":"(fn\r\n  [ls]\r\n  (->>\r\n   (loop [subs []\r\n          cur []\r\n          [x & xs :as all] ls]\r\n     (cond\r\n         (empty? all) (conj subs cur)\r\n         (empty? cur) (recur subs [x] xs)\r\n         :else\r\n         (if (> x (last cur))\r\n           (recur subs (conj cur x) xs)\r\n           (recur (conj subs cur) [x] xs))))\r\n   (filter #(> (count %) 1))\r\n   (sort #(> (count %1) (count %2)))\r\n   (#(if (empty? %) [] (first %)))))","problem":53,"user":"50427899e4b0add3005c0fc2"},{"problem":53,"code":"(comp #(distinct\n                        (reduce\n                          (fn [acc curr]\n                            (if (and (> (count curr) (count acc)) (not (nil? (first curr))))\n                              (apply vector curr)\n                              acc))\n                          []\n                          %))\n                   #(partition-by\n                        nil?\n                        (flatten\n                          (reduce\n                            (fn [acc curr]\n                              (if (< (first curr) (last curr))\n                                (conj acc curr)\n                                (conj acc nil)))\n                            []\n                            (partition 2 1 %)))))","user":"5d1c14cde4b02ea6f0fb698a"},{"code":"(fn [v]\n  (loop [v_ v ret '() ret_c 0 cand '() cand_c 0]\n    (let [a (first v_) n (next v_)]\n      (cond\n        (and (> cand_c ret_c) (>= cand_c 2))\n          (recur v_ cand cand_c cand cand_c)        \n        (empty? v_) \n          (into '() ret)\n        (or (empty? cand) (> a (first cand)))\n          (recur n ret ret_c (conj cand a) (inc cand_c))\n        :else\n          (recur n ret ret_c (list a) 1)))))","problem":53,"user":"4f050dec535dcb61093f6bef"},{"problem":53,"code":"(fn [s]\n  (let [f (fn [s]\n            (filter (complement nil?)\n                    (map #(if (= %1 %2) %1 nil)\n                         s\n                         (range (first s) (+ (first s) (count s) 1)))))\n        r (loop [s s\n                 a []]\n            (if (seq s)\n              (recur (next s) (conj a (f s)))\n              a))\n        ]\n    (->> r\n         (sort-by count)\n         last\n         seq\n         (#(if (> (count %) 1) % ())) \n         )))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn longest-increasing-sub-section\n  [coll]\n  (letfn [(next? [coll n]\n  \t (= (dec n) (peek coll)))\n\t  (improve [[best current] n]\n\t\t   (if (next? current n)\n\t\t     (let [new-current (conj current n)\n\t\t\t   new-best (if (> (count new-current) (count best))\n\t\t\t\t      new-current\n\t\t\t\t      best)]\n\t\t       [new-best new-current])\n\t\t     [best [n]]))]\n    (first (reduce improve [[] []] coll))))","problem":53,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":53,"code":"(fn [ss]\n   (let [consecutive-pair? (fn [[a b]] (= 1 (- b a)))]\n     (->> ss\n          (partition 2 1)\n          (map #(hash-map :pair % :con? (consecutive-pair? %)))\n          (partition-by :con?)\n          (filter (comp :con? first))\n          (sort-by (comp - count))\n          first\n          (map :pair)\n          (apply concat)\n          distinct)))","user":"4e89dbce535d3e98b8023283"},{"problem":53,"code":"(fn subseq [coll]\n  (when (seq coll)\n    (loop [current [(first coll)]\n           longest []\n           coll (rest coll)]\n      (if (empty? coll)\n        longest\n        (if (> (first coll) (peek current))\n          (let [current (conj current (first coll))]\n            (recur current (max-key count current longest) (rest coll)))\n          (recur [(first coll)] longest (rest coll)))))))","user":"546ed28be4b00cfc9eacc1a5"},{"problem":53,"code":"(fn increasing-sub-seq [elements]\n  (let [seqs (reduce #(let [holders %1\n                            holder (first %1)\n                            tail (rest %1)\n                            holder-elem (first holder)\n                            elem %2\n                            safe-holder-elem (if (nil? holder-elem) (- elem 1) holder-elem)]\n                           (if (> elem safe-holder-elem)\n                             (cons (cons elem holder) tail)\n                             (cons (list elem) holders)))\n                     (list(list)) elements)\n        max-seq (apply vector (reverse (reduce #(if (> (count %1) (count %2)) %1 %2) seqs)))]\n    (if (> (count max-seq) 1) max-seq (vector))))","user":"5dc4719ae4b02f9375f4e1b5"},{"code":"(fn longest-inc\n  ([coll]\n     (if-let [[x & xs] (seq coll)]\n       (longest-inc (list x) (list x) xs)\n       '()))\n  ([best curr coll]\n     (if-let [[x & xs] (seq coll)]\n       (if (< (first curr) x)\n         (let [new-curr (cons x curr)\n               new-best (if (> (count new-curr) (count best))\n                          new-curr\n                          best)]\n           (longest-inc new-best new-curr xs))\n         (if (> (count curr) (count best))\n           (longest-inc curr (list x) xs)\n           (longest-inc best (list x) xs)))\n       (if (< (count best) 2)\n         '()\n         (reverse best)))))","problem":53,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":53,"code":"(fn f [coll]\n  (let [bigger? (fn [pair] (< (first pair) (second pair)))\n        coll (partition 2 1 coll)\n        coll (partition-by bigger? coll)\n        coll (filter #(bigger? (first %)) coll)\n        coll (sort-by count > coll)\n        pairs  (first coll)]\n    (distinct (apply concat pairs))))","user":"577c3da9e4b0c8d87281f6b9"},{"code":"(fn longest-subseq [coll]\n\t(reverse (last (sort-by count (filter #(> (count %) 1) (reduce (fn [[x & xs :as s] e] \n\t\t\t\t(if (= (first x) (dec e)) (cons (cons e x) xs)\n\t\t\t\t\t(cons (list e) s))) \n\t\t\t[()] \n\t\t\tcoll))))))","problem":53,"user":"52e657e4e4b09f7907dd1472"},{"code":"(fn longest [xs] (->> xs\n                      (reduce (fn [[h & hs :as hss] x]\n                                (if (and h (= 1 (- x (last h))))\n                                  (cons (conj h x) hs)\n                                  (cons [x] hss))) '())\n                       (filter #(> (count %) 1))\n                      (reduce #(if (> (count %2) (count %1)) %2 %1) [])\n                      ) )","problem":53,"user":"52dc2bc8e4b09f7907dd13ca"},{"code":"#(let [tmp \n  (loop [max [(first %)] acc [(first %)] remaining (rest %)]\n    ;(println max acc remaining)\n    (if (empty? remaining) max\n      (let [nextacc (if (> (first remaining) (last acc)) (conj acc (first remaining)) (vector (first remaining)))]\n      (let [nextmax (if (> (count nextacc) (count max)) nextacc max)]\n      (let [nextrem (rest remaining)]\n        (recur nextmax nextacc nextrem))))))]\n  (if (< (count tmp) 2) [] tmp))","problem":53,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn longest-increasing-subseq [lst]\r\n  (let [group-seq (partition-by #(apply < %) (partition 2 1 lst))\r\n        inc-seq (map #(distinct (apply concat %)) group-seq)\r\n        count-seq (apply max (map count inc-seq))\r\n        fin (first (filter #(and (= (count %) count-seq) (> (second %) (first %))) inc-seq))]\r\n    (if (seq? fin)\r\n      fin\r\n      []\r\n    )))","problem":53,"user":"4ef0f1a1535dced4c769f212"},{"problem":53,"code":"(let\n  [xfer (fn xfer [src dest] (if\n                              (and (first src) (or (not (first dest)) (> (first src) (last dest))))\n                              (xfer (rest src) (conj dest (first src)))\n                              [src dest]))\n   better (fn [a b] (if (> (count b) (max 1 (count a))) b a))]\n  (let\n    [best (fn best\n            [sofar coll]\n            (let\n              [data (xfer coll [])]\n              (let\n                [newbest (better sofar (second data)) newcoll (first data)]\n                (if (first newcoll) (best newbest newcoll) newbest))))]\n    #(best [] %)))","user":"5b465b8be4b02d533a91bc65"},{"problem":53,"code":"(fn [s]\n  (loop [mlist s\n         c []\n         r []]\n    (if (empty? mlist)\n      (if (> (count r) 1) r [])\n      (let [h (first mlist)\n            t (rest mlist)]\n        (if (empty? c)\n          (recur t [h] (if (empty? r) [h] r))\n          (if (< (last c) h)\n            (recur t (conj c h) (if (> (inc (count c)) (count r))\n                                  (conj c h)\n                                  r))\n            (recur t [h] (if (> (count c) (count r))\n                           c\n                           r))))))))","user":"5866b999e4b0f14aab7c886b"},{"code":"#(reduce (fn [acc elem] (if (and (< (count acc) (count elem)) (< 1 (count elem))) elem acc)) []\n        (reduce (fn [acc elem] (if (empty? (first acc)) [[elem]]\n                                      (let [prev (if (= (count acc) 1) [] (vec (butlast acc))) current (last acc)]\n                                        (if (= (+ 1 (last current)) elem) \n                                          (conj prev (conj current elem))\n                                          (conj (conj prev current) [elem])\n                                        )\n                                      )\n                                    )\n                   )\n                   [[]]\n                   %\n            ))","problem":53,"user":"521f24ebe4b0e6c71e0c0bcd"},{"code":"(fn [v]\r\n  (loop [vv [] v v tv []]\r\n    (cond\r\n      (empty? v) (let [a (last (last (apply sorted-map (mapcat (juxt count identity) (conj vv tv)))))]\r\n        (if (= (count a) 1) [] a))\r\n      (= (last tv) nil) (recur vv (rest v) (conj tv (first v)))\r\n      (= (first v) (+ 1 (last tv))) (recur vv (rest v) (conj tv (first v)))\r\n      :else (recur (conj vv tv) (rest v) [(first v)]))))","problem":53,"user":"50843a4ae4b0c98812d0788b"},{"problem":53,"code":"(fn [v]\n    (let [subseqs>1 (fn [v] (for [start (range (- (count v) 1))\n                                  end (range (+ start 2) (+ (count v) 1))]\n                              (subvec v start end)))\n          ascending (fn [v] (apply < v))\n          longest (fn [vv] (reduce #(if (> (count %2) (count %1)) %2 %1) [] vv))\n          count>1 (fn [v] (>= (count v) 2))]\n      (->> (subseqs>1 v)\n           (filter ascending)\n           (filter count>1)\n           longest)))","user":"5fae84b3e4b08cb800c85afd"},{"code":"#((reduce (fn[acc i]\n              (let [cur (:current acc)\n                    lng (:longer acc)\n                    add? (> i (last cur))\n                    new (conj cur i)\n                    rep? (and (>= (count new) 2) (> (count new) (count lng)))\n                    restart [i]]\n                  (cond\n                      (and add? rep?) {:current new :longer new}\n                      add? {:current new :longer lng}\n                      :else {:current restart :longer lng})))\n          {:current [(first %)] :longer []}  (rest %)) :longer)","problem":53,"user":"52bc6cb2e4b07a9af57922f5"},{"problem":53,"code":"(fn [myseq] \n  (loop [currentSeq (next myseq) \n         currentMax (list (first myseq)) \n         prevMax '()] \n    (if (nil? currentSeq) \n        (reverse (if (and (> (count currentMax) 1) (> (count currentMax) (count prevMax)))\n            currentMax\n            prevMax\n        ))\n      (recur (next currentSeq)\n             (if (> (first currentSeq) (first currentMax)) (conj currentMax (first currentSeq)) (list (first currentSeq)))\n             (if (> (first currentSeq) (first currentMax)) prevMax\n               (if \n                 (and (> (count currentMax) 1) (> (count currentMax) (count prevMax)))\n                 currentMax\n                 prevMax\n               )\n             )\n      )\n    )\n  )\n)","user":"5439c3cee4b032a45b869323"},{"code":"(fn [s]\n  (let [res (loop [record [], curr [], remain s]\n     (letfn [(better [] (if (>= (count record) (count curr)) record curr))]\n       (cond\n         (and (> (count curr) 0)\n              (or (= (count remain) 0)\n\t              (>= (last curr) (first remain)))) \n         (recur (better) [] remain)\n\n         (= (count remain) 0)\n         record\n\n         (or (= (count curr) 0) (< (last curr) (first remain)))\n         (recur record (conj curr (first remain)) (rest remain))\n\n         true\n         (recur (better) [] remain))))]\n    (if (>= (count res) 2) res [])))","problem":53,"user":"5196568fe4b04c0af7ff3c1c"},{"code":"(fn [s] \n  (let [f #(conj % \n            (if \n              (some (partial <= %2) (last %))\n              [%2]\n              (conj (last %) %2)))\n        a (reduce f [[]] s)\n        b (apply max-key count (reverse a))]\n  (if (> (count b) 1) b [])))","problem":53,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn [coll]\n(let [ordered? #(apply < %)\n      pairs (partition-by ordered?\n             (rest (partition-all 2 \n               (interleave (cons 0 coll) coll))))\n      filtered (filter #(ordered? (first %)) pairs)\n      max-size (count (last (sort-by count filtered)))\n      goal (some #(if (= (count %) max-size) %) filtered)]\n   (if (pos? max-size)\n    (cons (ffirst goal) (map last goal)) [])))","problem":53,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn [xs] (reduce (fn [l r] (if (and (< \n                         (count l)\n                         (count r)) (> (count r) 1)) r l))\n          []\n   (loop [xs xs\n          flush []\n          temp []]\n      (if (next xs)\n        (if (< (first xs)\n               (second xs))\n          (recur (rest xs) flush (conj temp (first xs)))\n          (recur (rest xs) \n                 (conj flush (conj temp (first xs))) \n                 []))\n        (conj flush (conj temp (first xs)))))))","problem":53,"user":"5287f34ee4b0239c8a67ae43"},{"problem":53,"code":"(fn longest-sub-seq [in-coll]\n      (let [inc-sub-seq (filter #(not (nil? %)) (apply concat (for [coll (take-while seq (iterate #(drop 1 %) in-coll))]\n                                                               (for [c (take-while seq (iterate drop-last coll))]\n                                                                 (if (and (> (count c) 1) (apply < c))\n                                                                   c)))))]\n        (if (seq inc-sub-seq)\n          (reduce #(if (> (count %2) (count %1)) %2 %1) inc-sub-seq)\n          inc-sub-seq)))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn [xs]\n  (let [crunch #(concat (map first %) (list (second (last %))))\n        parted (partition-by #(< (first %) (second %)) (partition 2 1 xs))\n        filtered (filter (fn [[[x y] & r]] (< x y)) parted)\n        sorted (sort-by #(- (count %)) filtered)]\n    (if (seq sorted)\n      (crunch (first sorted))\n      [])))","problem":53,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn [v]\n    (let [t (partition-by identity ((fn [s] (map #(< %1 %2) s (drop 1 s))) v))\n          [i l b] (reduce \n                        (fn [[i l b] c] \n                            (let [k (count c)\n                                  j (+ i k)]\n                                (if (and (first c) (> k l))\n                                    [ j k i ]\n                                    [ j  l b ])))\n                        [0 -1 0] t)]\n        (subvec v b (+ b l 1))))","problem":53,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn [coll]\n  (first (reduce\n          #(let [diff (- %2 (last (last %1)))\n                 current (if (> diff 0) (conj (last %1) %2) [%2])\n                 too-short? (= 1 (count current))\n                 longest (if (->> (count current) (>= (count (first %1))) (or too-short?))\n                           (first %1)\n                           current)]\n             (vector longest current))\n          [[] [(first coll)]] (rest coll))))","problem":53,"user":"533b1dc4e4b0e30313ee6cc7"},{"problem":53,"code":"(fn !\n  ([coll] (! coll []))\n  ([c1 c2]\n   (if (empty? c1)\n     (reduce #(if (>= (count %1) (count %2)) %1 %2) [] (filter #(>= (count %) 2) c2))\n     (recur (rest c1) (conj c2 (map first (take-while #(= (first %1) (second %1)) (map vector c1 (take (count c1) (iterate inc (first c1)))))))))))","user":"5640b135e4b08d4f616f5ee8"},{"problem":53,"code":"(fn longest-subseq [coll]\n  (loop [c (rest coll)\n         accum [(first coll)]\n         longest []]\n    (if (empty? c)\n      (if (and (< (count accum) 2) (< (count longest) 2))\n        []\n        (if (> (count accum) (count longest))\n          accum\n          longest))\n      (if (= (inc (last accum)) (first c))\n        (recur (rest c) (conj accum (first c)) longest)\n        (if (< (count accum) 2)\n          (recur (rest c) [(first c)] longest)\n          (recur (rest c) [(first c)] accum))))))","user":"542c026ae4b0dad94371f29a"},{"problem":53,"code":"(fn sub [s]\n  (let [subb (fn [s curs maxs]\n               (let [x (first s)\n                     r (rest s)\n                     ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\n                     nmax (max-key count ncurs maxs)]\n                 (if (seq r)\n                   (recur r ncurs nmax)\n                   nmax)))\n        longest (subb s [(first s)] [])]\n    (if (> (count longest) 1) longest [])))","user":"57b4779de4b0fbc9809a279a"},{"problem":53,"code":"(fn [x]\n    (->> (interleave (butlast x) (rest x))\n         (partition 2)\n         (partition-by (fn [[x y]] (< x y)))\n         (filter (comp (fn [[x y]] (< x y)) first))\n         (#(if (empty? %) [%] %))\n         reverse\n         (apply max-key count)\n         (#(cons (ffirst %) (map second %)))\n         (filter #(not (nil? %)))\n         (apply sorted-set)\n         vec))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":53,"code":"(fn\n [li]\n (into\n  []\n   (let\n    [parts (partition-by\n           (fn\n            [[a b] & part]\n            (< a b))\n            (partition 2 1 li))\n     seqs (map \n    (fn\n     [lii]\n      (cons\n       (first (first lii))\n       (apply\n       (fn\n        [& lee]\n        (take-nth\n         2\n         (drop\n          1\n          (apply concat lee))))\n       lii)))\n    parts)\n    out (->>\n     seqs\n     (sort \n      (fn \n       [a b] \n       (> \n        (count a)\n        (count b))))\n     (filter \n      #(and\n         (not\n          (=\n           1\n           (count %)))\n         (<\n          (first %)\n          (nth % 1))))\n         first)]\n    out)))","user":"586a657de4b0f14aab7c88bd"},{"problem":53,"code":"(fn [xx]\n  (reduce\n    (fn [s1 s2]\n      (let [c2 (count s2)]\n        (if (and (> c2 1) (> c2 (count s1))) s2 s1)))\n    ()\n    ((fn ss [xs]\n       (if (empty? xs)\n         ()\n         (let [x ((fn g\n                    ([vs] (if (empty? vs) () (cons (first vs) (g (first vs) (rest vs)))))\n                    ([n vs] (if (not= (inc n) (first vs))\n                              ()\n                              (cons (first vs) (g (first vs) (rest vs))))))\n                  xs)]\n           (cons x (ss (drop (count x) xs))))))\n     xx)))","user":"564a5a09e4b0284900eef656"},{"problem":53,"code":"(fn [col]\n  (let [iseqs ((fn liss [col]\n                 (when-let [s (seq col)]\n                   (let [fs (loop [cs  s\n                                   acc [(first s)]]\n                      (if (or (nil? (second cs)) (>= (first cs) (second cs)))\n                 \t\tacc\n                 \t\t(recur (rest cs) (conj acc (second cs)))))]\n      \t\t\t\t  (cons fs (liss (drop (count fs) col)))))) \n               col)]\n    (or (->> iseqs\n         \t(filter #(> (count %) 1))\n         \t(sort-by count >)\n         \tfirst)\n        [])))","user":"542c22bde4b0dad94371f29e"},{"problem":53,"code":"(fn [xs]\n  (first\n    (reduce\n      (fn [[best curr] x]\n        (let [curr (cond\n                     (empty? curr)      [x]\n                     (>= (peek curr) x) [x]\n                     :else              (conj curr x))\n              cnt (count curr)\n              best (cond\n                     (<= cnt 1)            best\n                     (<= cnt (count best)) best\n                     :else                 curr)]\n          [best curr]))\n        [[] []]\n        xs)))","user":"50fbf811e4b0d10d794c19f1"},{"problem":53,"code":"#( reduce \n   (fn [a b] \n     (if \n       (or \n        (= (count b) 1) \n        (> (count a) (count b))) \n       a b)) \n   [] \n   (reductions \n    (fn [a b] \n      (cond \n       (= a []) [b] \n       (= (last a) (dec b) ) (concat a [b]) \n       :else [b] ) ) \n    [] % ))","user":"567798afe4b05957ce8c6169"},{"code":"(fn [mylist]\n  (loop [l mylist, curseq [], seqs []]\n\t\t(if (= l '())\n\t\t\t; l empty, return longest seq\n\t\t\t(if (= curseq [])\n\t\t\t\t(reduce (fn [a1 a2] (if (> (count a2) (count a1)) a2 a1 )) [] seqs)\n\t\t\t\t(reduce (fn [a1 a2] (if (> (count a2) (count a1)) a2 a1 )) [] \n\t\t\t\t\t(conj seqs curseq)) )\n\t\t\t;seqs\n\t\t\t; not empty, look for seqs\n\t\t\t(if (= curseq []) ; curseq empty, try to find new seq\n\t\t\t\t(if (= (inc (first l)) (fnext l))\n\t\t\t\t\t(recur (drop 2 l), [(first l) (fnext l)], seqs)\n\t\t\t\t\t(recur (rest l), [], seqs))\n\t\t\t\t; not empty, check if next element fits\n\t\t\t\t(if (= (dec (first l)) (last curseq))\n\t\t\t\t\t; fits, add to curseq\n\t\t\t\t\t(recur (rest l), (conj curseq (first l)), seqs)\n\t\t\t\t\t; doesn't fit, add seq to seqs\n\t\t\t\t\t(recur l, [], (conj seqs curseq))\n\t\t\t\t)) )))","problem":53,"user":"4f2965ffe4b0d6649770a029"},{"code":"(fn [s]\r\n  (loop [x s\r\n         l []\r\n         b []\r\n         c nil]\r\n    (if x\r\n      (let [h (first x)]\r\n        (if (= (dec h) c)\r\n          (recur (next x) l (conj b h) h)\r\n          (if (> (count b) (count l))\r\n            (recur (next x) b [h] h)\r\n            (recur (next x) l [h] h))))\r\n      (let [out (if (> (count b) (count l))\r\n                  b\r\n                  l)]\r\n        (if (> (count out) 1)\r\n          out\r\n          [])))))","problem":53,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn n-seq [coll]\n  (let [r1 \n        (->> (map - (rest coll) coll)\n             (map-indexed (fn [i e] [(inc i) e]) )\n             (partition-by second)\n             (remove #(not= 1 (second (first %))))\n             (group-by count)\n             )\n        r2 (if (empty? r1) [] (first (get r1 (apply max (keys r1)))))]\n    (if (empty? r2) [] (subvec coll (dec (first (first r2))) (inc (first (last r2)))))\n    ))","problem":53,"user":"4fc0221ce4b081705acca322"},{"problem":53,"code":"(fn [coll]\n  (second\n    (reduce #(if (and (not (empty? (first %1))) (= %2 (inc (peek (first %1)))))\n               (let [new-potential (conj (first %1) %2)\n                     best-so-far (second %1)]\n                 (if (> (count new-potential) (count best-so-far))\n                   (vector new-potential new-potential)\n                   (vector new-potential best-so-far)))\n                 (vector [%2] (second %1)))\n               [[][]]\n               coll)))","user":"540e8d13e4b0addc1aec671e"},{"problem":53,"code":"(fn __ [xs]\n  (letfn [(f [y & ys]\n             (if (empty? ys)\n               (list y)\n               (cons y\n                     (if (< y (first ys))\n                       (apply f ys)\n                       '()))))]\n    (let [r (->> (range (count xs))\n                 (map #(apply f (drop % xs)))\n                 (reduce #(if (>= (count %1) (count %2)) %1 %2)))]\n      (if (= 1 (count r)) [] r))))","user":"54c271b9e4b045293a27f602"},{"problem":53,"code":"(fn [xs]\n(reduce \n  (fn [r x]\n      (if (> (count r) (count x))\n        r\n        x\n      )\n  )\n []\n (filter (fn [x] (not= (count x) 1))\n    (reduce \n      (fn [r x]\n        (if (empty? (first r))\n          [[x]]\n          (if (< (last (first r)) x) \n            (cons (concat (first r) [x]) (rest r))\n            (cons [x] r)\n          )\n        )\n      )\n      [[]]\n      xs\n    )\n  )\n)\n )","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [coll]\n          (:champ (reduce (fn [{prev :prev :as results} current]\n                            (-> results\n                                (update-in [:current] (if (> current prev)\n                                                        conj\n                                                        (fn [_ x] [x])) current)\n                                (assoc :prev current)\n                                ((fn [{:keys [current champ] :as results}]\n                                   (assoc results :champ (if (and (> (count current)\n                                                                     (count champ))\n                                                                  (> (count current) 1))\n                                                           current\n                                                           champ))))))\n                          {:prev Double/NEGATIVE_INFINITY\n                           :current []\n                           :champ []}\n                          coll)))","problem":53,"user":"4daef21cedd6309eace4d169"},{"problem":53,"code":"(fn longest-increasing [v]\n  (let [subseqs (for [i (range (count v)) \n                      j (range (+ 2 i) (inc (count v)))]\n                 (subvec v i j))]\n    (->> subseqs\n         (filter #(apply < %))\n         reverse\n         (apply max-key count []))))","user":"4dad76588e77d6ed63f12a44"},{"problem":53,"code":"(fn [coll]\n  (let [steps (map vector coll (drop 1 coll))\n        increasing? #(and (> (count %) 1) (> (second %) (first %)))\n        step-groups (partition-by increasing? steps)\n        runs (map #(cons (first (first %)) (map second %)) step-groups)\n        increasing-runs (filter increasing? runs)]\n    (if (empty? increasing-runs) [] (reduce (fn [a b] (if (> (count b) (count a)) b a)) increasing-runs))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn stiga [c]\n  (remove #(= % \"bajs\")\n    (distinct\n   (flatten\n\t     (loop [col (map #(if (= (first %) (dec (last %))) % \"bajs\")\n   (partition 2 1 c)) ]\n    (if (not-empty (partition 2 1 (remove #(= % \"bajs\") col)))\n      (recur (map\n       #(if (= (last (first %)) (first (last %))) % \"bajs\")\n       (partition 2 1 col)))\n      col))))))","problem":53,"user":"4e218464535d04ed9115e816"},{"problem":53,"code":"(fn\n  [v]\n  (let [sub-seqs (for [i (range (count v))\n                       j (range (+ 2 i) (inc (count v)))]\n                   (subvec v i j))]\n    (reduce #(if (< (count %) (count %2)) %2 %)\n            []\n            (filter #(apply < %) sub-seqs))))","user":"5ddb8a6ee4b0948ae9d9adb2"},{"problem":53,"code":"#(loop[longest [0 0] current [(first %) (first %)] remaining (rest %)]\n   (if-let [item (first remaining)]\n     (if (= (inc (second current)) item)\n       (recur longest (assoc current 1 item) (rest remaining))\n       (if (> (- (second current) (first current)) (- (second longest) (first longest)))\n         (recur current [item item] (rest remaining))\n         (recur longest [item item] (rest remaining))))\n     (let [[start end] (if (> (- (second current) (first current)) (- (second longest) (first longest)))\n                         current\n                         longest)]\n       (if (= start end) []\n         (range start (inc end))))))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn [coll]\n    (loop [coll coll\n           prev nil\n           answer []\n           running []]\n      (cond\n       (nil? coll) (let [v (if (> (count answer) (count running)) answer running)]\n                     (if (> (count v) 1) v []))\n       (or (nil? prev) (= (inc prev) (first coll))) (recur (next coll) (first coll) answer (conj running (first coll)))\n       (> (count running) (count answer)) (recur (next coll) (first coll) running [(first coll)])\n       :else (recur (next coll) (first coll) answer running))))","problem":53,"user":"4e89e939535d3e98b8023287"},{"problem":53,"code":"(fn this\n  ([coll] (this (rest coll) [] [(first coll)]))\n  ([r c] (if (> (count c) (count r)) c r))\n  ([coll r c] (cond\n             (not (seq coll)) (let [f (this r c)] (if (> (count f) 1) f []))\n             (> (first coll) (last c)) (this (rest coll) r (conj c (first coll)))\n             :else (this (rest coll) (this r c) [(first coll)]))))","user":"58923efce4b00487982d521c"},{"problem":53,"code":"(fn [coll] \n  (loop [coll coll longest [] actual []]\n  (if (empty? coll)\n    (let [result (if (> (count longest) (count actual))  longest actual)]\n      (if (< 1 (count result)) result [])\n      )\n    (if (or (nil? (last actual)) (= 1 (- (first coll) (last actual) )))\n      (recur (rest coll) longest (conj actual (first coll)))\n      (if (>= (count actual) (count longest))\n        (recur (rest coll) actual [(first coll)])\n        (recur (rest coll) longest [])\n        )\n      )\n    )))","user":"583f1533e4b089d5ab817dc8"},{"code":"(fn [lst]\n  (let [res (filter #(> (count %) 1)\n                    (reduce #(if (or (empty? (first %))\n                                     (not (= (inc (last (first %))) %2)))\n                               (cons [%2] %)\n                               (cons (conj (first %) %2) (rest %)))\n                            []\n                            lst))]\n    (apply max-key count (or (seq res) [[]]))))","problem":53,"user":"5005b57de4b0678c553fc46a"},{"problem":53,"code":"(fn [x]\n  (let [a (->> x\n               (map-indexed vector)\n               (partition-by #(apply - %)))\n        m (apply max (map count a))\n        z (->> (filter #(= (count %) m) a)\n               (first)\n               (map second))]\n    (if (= 1 m) [] z)))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":53,"code":"#(loop [leftover % current [] longest []]\n\t(cond\n\t\t(and (> (count current) 1) (> (count current) (count longest))) (recur leftover current current)\n\t\t(empty? leftover) longest\n\t\t(or (empty? current) (> (first leftover) (last current))) (recur (rest leftover) (conj current (first leftover)) longest)\n\t\t:else (recur leftover [] longest)))","user":"56bb9ccce4b0f26550335959"},{"problem":53,"code":"(fn my-subseq [coll]\n  (let [add-to-last-list (fn [l e] (concat (butlast l) (list (conj (last l) e))))]\n    (loop [f (first coll)\n           r (rest coll)\n           result [[f]]]\n      (cond\n        (empty? r) (let [filtered (filter #(> (count %) 1) result)] (if (empty? filtered) filtered (apply max-key count filtered)))\n        (= (inc f) (first r)) (recur (first r) (rest r) (add-to-last-list result (first r)))\n        :else (recur (first r) (rest r) (concat result (list [(first r)])))\n        ))\n    )\n  )","user":"5630fd6fe4b0bfe05bf1178b"},{"problem":53,"code":"(fn [sq]\n    (->> sq\n         (partition 2 1)\n         (partition-by #(= (inc (first %)) (second %)))\n         (filter #(every? (fn [[a b]] (= (inc a) b)) %))\n         (map #(concat (first %) (map last (rest %))))\n         (#(if (empty? %) [] (apply (partial max-key count) %)))\n         ))","user":"4f867b25e4b033992c121c51"},{"problem":53,"code":"(fn [coll] (let [m (filter #(neg? (first (first %))) (partition-by #(neg? (first %)) (map #(conj % (apply - %)) (partition 2 1  coll))))]\n             \n             (if (empty? m) m\n               \n               (let\n                 \t\t[maxct (apply max (map count m))\n             \ttarget (first (drop-while #(< (count %) maxct) m))] \n                  \n               (concat (rest (first target)) (map last (rest target)))))))","user":"52e5f810e4b09f7907dd1468"},{"problem":53,"code":"(fn [xs]\n  (let [x (butlast xs) \n        y (rest xs)\n        xy (map #(vector (- %2 %) %) x y) \n        grps (->> xy\n                  (partition-by #(= 1 (first %)))\n                  (filter #(= 1 ((first %) 0)))\n                  (#(if (empty? %) \n                      [] \n                      (apply max-key count %))))]\n    (if (empty? grps)\n      []\n      (let [start ((first grps) 1) cnt (count grps)]\n        (range start (+ start (inc cnt))))\n    )))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn [coll]\n  (let [l (count coll)\n        tails (take l (iterate rest coll))\n        gatherFn (fn gather [[n1 n2 & _ :as coll]]\n                   (cond\n                     (empty? coll) nil\n                     (or (nil? n2) (> n1 n2)) (list n1)\n                     (< n1 n2) (cons n1 (lazy-seq (gather (rest coll))))))\n        pick-longest (fn [coll] (reduce #(let [l1 (count %1) l2 (count %2)] (if (>= l1 l2) %1 %2)) coll))]\n    (let [longest (pick-longest (map gatherFn tails))] (if (>= (count longest) 2) longest []))))","problem":53,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":53,"code":"(fn lis\n  [s]\n  (letfn [(increasing\n            [s]\n            (loop [p (first s)\n                   [head & rest] (rest s)]\n              (if (nil? head)\n                true\n                (if (> head p)\n                  (recur head rest)\n                  false))))]\n    (loop [start  0\n           end    2\n           winner []]\n      (println \"> start: \" start)\n      (println \"> end: \" end)\n      (println \"> winner: \" winner)\n      (println \"> -----\")\n      (cond\n        (> end (count s)) winner\n        :else\n        (let [v (subvec s start end)]\n          (if (increasing v)\n            (if (and (> (count v) 1) (> (count v) (count winner)))\n              (recur start (inc end) v)\n              (recur start (inc end) winner))\n            (recur (inc start) (+ (max 2 (count winner)) start) winner)))))))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":53,"code":"(fn [xs] \n  (let\n    [ tagged (map-indexed vector xs) ]\n    (->> (rest tagged)\n      (reduce\n        #(let [ index (%2 0) prev (%1 (dec index)) ]\n           (if (> (%2 1) (prev 1))\n             (assoc %1 index [ (prev 0) (%2 1) ])\n             %1))\n        (vec tagged))\n      (group-by first)\n      vals\n      (map #(map second %))\n      (filter #(> (count %) 1))\n      (reduce #(if (>= (count %1) (count %2)) %1 %2) [])\n    )))","user":"5d123457e4b02c15ef021996"},{"problem":53,"code":"(fn [nv]\n  (loop [pairs (partition 2 1 nv) result ()]\n    (if (seq pairs)\n      (let [[h t] (split-with #(= (inc (first %)) (second %)) pairs)]\n        (if (> (count h) (count result))\n          (recur t h)\n          (recur (rest t) result)))\n      (if (seq result)\n        (cons (ffirst result) (map second result))\n        result))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":53,"code":"(fn lis [xs]\n  (if (empty? xs)\n    []\n    (loop [max_l [] curr_l [(first xs)] lst (rest xs)]\n      (if (empty? lst)\n        (if (= (count max_l) 1)\n          []\n          (reverse (if (< (count max_l) (count curr_l)) \n            curr_l\n            max_l)))\n        (if (> (first lst) (first curr_l))\n          (recur max_l (cons (first lst) curr_l) (rest lst))\n          (recur (if (< (count max_l) (count curr_l)) curr_l max_l) [(first lst)] (rest lst)))))))","user":"570eeb66e4b0b0fb43fd06fa"},{"problem":53,"code":"(fn [x]\n    (->>\n        (partition 2 1 x)\n        (partition-by #(- (second %) (first %)))\n        (filter #(= (- (second (first %)) (ffirst %)) 1))\n        (reduce #(if (< (count %2) (count %1)) %1 %2) [])\n        flatten\n        distinct\n    )\n  )","user":"5e9e8648e4b00a66d4a95178"},{"problem":53,"code":"(fn f [m]   \n  (let [r ((fn hlpr [lst res longest]\n    (if (empty? lst) longest\n      (let [ln (count longest)\n        \t  alive (or (empty? res) (= (first lst) (+ (last res) 1)))\n            newres (concat (if alive res []) [(first lst)])]\n      \t(hlpr (rest lst) newres (if (>= (count newres) (count longest)) newres longest))))) m [] [])]\n    (if (> (count r) 1) r [])))","user":"53e2b212e4b036ad0777e3f4"},{"problem":53,"code":"(fn [s]\n  (second \n    (reduce\n  \t  (fn [[u v] head]\n \t    (if (= (last u) (dec head))\n    \t  (if (>= (count u) (count v))\n        \t[(conj u head) (conj u head)]\n  \t   \t    [(conj u head) v])\n    \t  [[head] v]))\n   \t[[][]]\n    s)))","user":"598e7998e4b02b9968b84d34"},{"problem":53,"code":"(fn[l] (loop [input (rest l)\n              seq (list (first l))\n              res []]\n         (println \"start\" input seq)\n         (if (empty? input)\n           (if (and (> (count seq) 1) (> (count seq) (count res)))\n             (vec seq)\n             (vec res))\n           (if (= (first input) (+ (last seq) 1))\n             (recur (rest input) (concat seq (list (first input))) res)\n             (if (and (> (count seq) 1) (> (count seq) (count res)))\n               (recur (rest input) (list (first input)) seq)\n               (recur (rest input) (list (first input)) res)\n               )\n             )\n           )\n         )\n   )","user":"541074f1e4b01498b1a719ac"},{"problem":53,"code":"(fn longest-increasing-subsequence [sq]\n  (loop [last-value nil                                     ;; Last value seen, or nil if first time\n         enumerated-sq (into [] (map vector (range) sq))    ;; This is [[index_0, val_0] ... [index_n, val_n]]\n         best-start 0                                       ;; Location of current best starting subsequence\n         current-start 0                                    ;; Location of current starting subsequence\n         longest-so-far 0]                                  ;; Length of current best subsequence\n    (let [[current-index current-value] (first enumerated-sq)\n          rest-of-sequence (rest enumerated-sq)]\n      (if (empty? enumerated-sq)                            ;; We're at the end of the seq, so clean up\n        (if (zero? longest-so-far)\n          []                                                ;; In case we never found an increasing subseq, return []\n          (subvec sq best-start (+ best-start 1 longest-so-far))) ;; Otherwise return the best slice\n        (if (nil? last-value)                               ;; first time through\n          (recur current-value rest-of-sequence best-start 0 longest-so-far)\n          (if (> current-value last-value)                  ;; We've got an increasing sequence at index > 0\n            (let [length (- current-index current-start)\n                  new-best-start (if (> length longest-so-far)\n                                   current-start\n                                   best-start)\n                  new-longest-so-far (max length longest-so-far)]\n              (recur current-value rest-of-sequence new-best-start current-start new-longest-so-far))\n            ;; Otherwise number value went down, so we have a new start point\n            (recur current-value rest-of-sequence best-start current-index longest-so-far)))))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":53,"code":"(fn [s] (let [m (fn [a] (let [c (:c a) r (:r a)] (if (> (count c) (count r)) c r)))\n              a (reduce (fn [a x] (if (or (empty? (:c a)) (= (last (:c a)) (dec x)))\n                                      (assoc a :c (conj (:c a) x))\n                                      (assoc (assoc a :r (m a)) :c [x])\n                                      )) {:r [], :c []} s)\n              r (m a)]\n  (if (< (count r) 2) [] r)))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":53,"code":"(fn [coll]\n  (let [getIncSub (fn [coll] ;;Function gets increasing subsequence starting from the first element\n                  ((fn inner [acc [head & more]]\n                     (cond (nil? head) acc\n                           (>= (last acc) head) acc\n                           :else (inner (conj acc head) more)))\n                   [(first coll)] (rest coll)))]\n    (->> coll\n         count\n         dec\n         range\n         (map #(drop %1 coll))\n         (map getIncSub)\n         (filter #(>= (count %1) 2))\n         (concat [[]])\n         (sort-by count >)\n         first)))","user":"5666500ee4b0e91d5f5c566d"},{"problem":53,"code":"(fn [v]\n\t(let [table (reduce conj {} (reverse (map #(hash-map (count %)  (conj (map last %) (first (first %)))     ) (filter #(and (> (count %) 0) (apply < (first %))) (partition-by #(apply < %)  (partition 2 1 v)) ))))]\n\t\t(if (empty? table) [] (table (apply max (keys table))))\n\t)\n)","user":"56979bb7e4b0e0b3d3318cac"},{"code":"(fn [xs]\n  (->> (partition 2 1 xs)\n       (partition-by (fn [[a,b]] (< a b)))\n       (filter (fn [ys] (< (first (first ys)) (second (first ys)))))\n       (map (fn [i ys] [(- (count ys)) i ys]) (range))\n       (sort)\n       first\n       ((fn [[_ _ ys]]\n          (if-not ys []\n            (apply vector (first (first ys)) (map second ys)))))))","problem":53,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn\n  [s]\n  (\n    (fn inner [longest cur sub-seq]\n      (if (> (count sub-seq) 1)\n        (if (> (first sub-seq) (last cur))\n          (let [new-cur (conj cur (first sub-seq))]\n            (if (> (count new-cur) (count longest))\n              (if (>= (count new-cur) 2)\n                (inner new-cur new-cur (rest sub-seq))\n                (inner longest new-cur (rest sub-seq))\n              )\n              (inner longest new-cur (rest sub-seq))\n            )\n          )\n          (inner longest [(first sub-seq)] (rest sub-seq))\n        )\n        (if (> (first sub-seq) (last cur))\n          (if (> (+ (count cur) 1) (count longest))\n            (conj cur (first sub-seq))\n            longest\n          )\n          longest\n        )\n        \n        \n       )\n     ) [] [(first s)] (rest s))\n )","problem":53,"user":"4e333091535deb9a81d77f25"},{"problem":53,"code":"(fn foo\n  [coll]\n  (drop 2 (reduce\n     (fn [[run lst & lseq] v]\n       (if (= (- v 1) lst)\n         (let [nseq (conj run v)]\n           (if (> (count nseq) (count lseq))\n             (concat [nseq v] nseq)\n             (concat [nseq v] lseq)))\n         (concat [[v] v] lseq)))\n     [[[] nil]]\n     coll)))","user":"54864662e4b0e286459a11b8"},{"code":"#(reverse \r\n    (nth\r\n      (reduce\r\n        (fn [[s c] e]\r\n          (if (empty? c)\r\n            [s (cons e c)]\r\n            (let \r\n              [x (nth c 0)\r\n               d (if (= (+ 1 x) e) (cons e c) [e])\r\n               t (if (> (count d) (count s)) d s)\r\n               n (if (> (count t) 1) t [])]\r\n                [n d])))\r\n        [[][]]\r\n        %)\r\n      0))","problem":53,"user":"4e03c616535d04ed9115e796"},{"code":"(fn [l]\n  (let [ps (partition-by #(- % (nth l %)) (range (count l)))\n  lss (apply max-key count ps)]\n    (if (> (count lss) 1) (map #(nth l %) lss) [])))","problem":53,"user":"4ecaaa25535d6d7199dd3708"},{"problem":53,"code":"(fn [se]\n   (loop [s se\n          longest []\n          acc []\n          ]\n     (println s \" - \" longest \" - \" acc)\n     \n     (if (> (count s) 0)\n       (if (> (count acc) (count longest))\n\n         (recur s acc acc)  \n\n         (let [f (first s)\n               r (rest s)]\n           (if (or (empty? acc) (> f (last acc)))\n             (recur r longest (conj acc f))\n             (if (> (count acc) (count longest))\n               (recur r acc [])\n               (recur s longest [])\n               )\n             )))\n       (if (> (count acc) (count longest))\n         acc\n         (if (> (count longest) 1)\n           longest\n           [])\n         )\n       )\n     ))","user":"54bbba99e4b0ed20f4ff6ec2"},{"problem":53,"code":"#(loop [l (rest %) m [] c [(first %)]]\n   (let [f (first l) r (rest l)]\n     (if (seq l)\n       (if (> f (last c))\n         (if (>= (count c) (count m))\n           (recur r (conj c f) (conj c f))\n           (recur r m (conj c f))\n           )\n         (recur r m [f])\n         )\n       m\n       )\n     )\n  )","user":"52503747e4b0541d1855b828"},{"problem":53,"code":"(fn longest-inc-seq [items]\n  ((fn [[l1 l2]]\n     (if (> 2 (max (count l1) (count l2)))\n       []\n       (if (> (count l2) (count l1))\n         l2 l1))) (reduce (fn [[best-so-far parts] h]\n                                (if (empty? parts)\n                                  [best-so-far [h]]\n                                  (if (> h (last parts))\n                                    [best-so-far (conj parts h)]\n                                    (if (> (count parts) (count best-so-far))\n                                      [parts [h]]\n                                      [best-so-far [h]]))))\n                              [[] []] items)))","user":"56897739e4b0dcc4269f407d"},{"problem":53,"code":"(fn [s]\n   (loop [n (count s)]\n      (if (<= n 1)\n        []\n        (let [res (drop-while #(not (apply < %)) (partition n 1 s))]\n          (if (not (empty? res))\n            (first res)\n            (recur (dec n)))))))","user":"5da71eaee4b000c986472c15"},{"code":"(fn [s]\n   (let [\n         p (remove #(< (count %) 2) (partition-by #(apply - %) (map vector (range) s)))\n         ]\n        (if (empty? p) [] \n          (map peek (apply max-key count p)))))","problem":53,"user":"530e5469e4b08068f379ecb7"},{"problem":53,"code":"(fn longest-inc-sub-seq [seq]\n  (loop [start 0, res [], res-cnt 0]\n    (if (< start (- (count seq) 2))\n      (let [tmp-res (let [[f & r] (subvec seq start)]\n                        (loop [sub-seq [f],r r]\n                          (if (and (not-empty r) (< (last sub-seq) (first r)))\n                            (recur (conj sub-seq (first r)) (rest r))\n                            sub-seq)))\n            tmp-cnt (count tmp-res)]\n        (if (> tmp-cnt res-cnt)\n          (recur (+ start res-cnt) tmp-res tmp-cnt)\n          (recur (+ start res-cnt) res res-cnt)))\n      (if (= res-cnt 1)\n        []\n        res))))","user":"5d247902e4b02ea6f0fb6a24"},{"problem":53,"code":"(fn longest [coll]\n  (let [longest-arr (first\n                      (reduce (fn [[longest current] ele]\n                                (let [new-current (if (and (last current) (< (last current) ele))\n                                                    (conj current ele)\n                                                    [ele])]\n                                  (if (< (count longest) (count new-current))\n                                    [new-current new-current]\n                                    [longest new-current])))\n                              [[] []]\n                              coll))]\n       (if (>= (count longest-arr) 2)\n         longest-arr\n         [])))","user":"5f29837ee4b033932238a64f"},{"problem":53,"code":"(fn longest-inc-subseq\n  [coll]\n  (let [pairs\n        (first (sort\n                #(> (count %1) (count %2))\n                (filter\n                 #(apply < (first %))\n                 (partition-by\n                  #(apply < %)\n                  (partition 2 (rest (flatten (map #(list  % %) coll)))))\n                        )))]\n    (filter (complement nil?) (cons (first (first pairs)) (for [pair pairs]\n                                                            (last pair))))))","user":"56449e4de4b0284900eef5f9"},{"problem":53,"code":"(fn [in]\n   (let [increasing? (fn [s] (reduce #(and % %2)\n                                     true\n                                     (map (fn [[a b]] (< a b))\n                                          (partition 2 1 s))))\n         seqs (for [s (range 0 (inc (count in)))\n                    e (range 0 (inc (count in)))\n                    :when (> e s)\n                    :let [se (subvec (vec in) s e)]]\n                se)]\n     (or (first (sort-by (comp - count)\n                         (filter #(> (count %) 1)\n                                 (filter increasing? seqs))))\n         [])))","user":"51e3a549e4b0c611d6113e47"},{"problem":53,"code":"(fn [s] (->> (concat s [nil])\n             (iterate rest)\n             (take (count s))\n             (map (fn [x] (->> (interleave x (iterate inc (first x)) (range))\n                               (partition 3)\n                               (some (fn [[a b c]] (and (not= a b) (take c x)))))))\n             (reduce #(if (and (> (count %2) 1) (> (count %2) (count %))) %2 %) () )))","user":"5960a1a6e4b066ee0a44b08e"},{"code":"(fn [s]\n  (if (empty? s) []\n    (letfn [(f [[x & c]]\n              (let [y (first c)]\n                (if (nil? y) [x]\n                  (if (< x y)\n                    (into [x] (f c))\n                    [x]))))] \n      (let [c (keep-indexed\n          (fn [idx v]\n            (when-let [c (subvec s idx)]\n              (let [r (f c)]\n                (when (> (count r) 1)\n                r))))\n          s)\n            m (if (empty? c) 0 (count (apply max-key count c)))]\n        (if (= m 0) []\n          (reduce #(if (= (count %) m) % %2) c))))))","problem":53,"user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn [s]\n  (reverse (apply max-key count (cons [] (remove #(= 1 (count %)) ((fn seq-crescente [[[primeiro-elemento-resp-corrente \n                                                                                        & _ \n                                                                                        :as resp-corrente] \n                                                                                       & resto-resp \n                                                                                       :as resp] \n                                                                                      [primeiro-coll \n                                                                                       & resto-coll \n                                                                                       :as coll]]\n                                                                     (if (empty? coll)\n                                                                       resp\n                                                                       (seq-crescente\n                                                                         (if (= primeiro-elemento-resp-corrente (dec primeiro-coll))\n                                                                           (conj resto-resp (conj resp-corrente primeiro-coll))\n                                                                           (conj resp (list primeiro-coll)))\n                                                                         resto-coll))) \n                                                                    ()\n                                                                    s))))))","problem":53,"user":"52c8758be4b0c2d177d62135"},{"problem":53,"code":"(fn [s]\n  (letfn [(to-consec-seqs \n           [acc i]\n           (if (= (dec i) (ffirst acc))\n             (update-in acc [0] #(cons i %))\n             (vec  (cons [i] acc))))]\n    (->> s\n         (reduce to-consec-seqs [[]])\n         (apply max-key count)\n         (reverse)\n         (#(if (< 1 (count %)) % [])))))","user":"52f0ea04e4b05e3f0be25ee6"},{"problem":53,"code":"#(first (reduce (fn [[m l] x]\n           (cond\n            (empty? l) [m [x]]\n            (> x (last l))\n             (let [ll (conj l x)]\n               (if (and (> (count ll) (count m))\n                        (> (count ll) 1))\n                 [ll ll]\n                 [m  ll]))\n            :else [m [x]]))\n         [[] []]\n         %))","user":"53dcf474e4b0d874e779ae25"},{"problem":53,"code":"(fn [coll]\n  (let [n (count coll)]\n    (->> (for [i (range n)\n               l (range 2 (inc (- n i)))]\n           (take l (drop i coll)))\n         (filter #(apply < %))\n         (sort (comparator (fn [x y] (< (count y) (count x)))))\n         first\n         vec)))","user":"54485749e4b032a45b8693c7"},{"code":"(fn [coll]\n  (letfn [(amax-key [k colls] (when (seq colls) (apply max-key k colls)))\n          (increasing? [[x1 x2]] (> x2 x1))\n          (take-while-increasing [[x :as coll]]\n            (if (empty? coll)\n              coll\n              (cons x (map second (take-while increasing?\n                                              (map list coll (rest coll)))))))\n          (partition-into-increasing [coll]\n            (loop [acc (list)\n                   coll coll]\n              (if (empty? coll)\n                acc\n                (let [part (take-while-increasing coll)]\n                  (recur (conj acc part) (drop (count part) coll))))))]\n    (let [largest (amax-key count (partition-into-increasing coll))]\n      (if (> (count largest) 1)\n        largest\n        []))))","problem":53,"user":"507b7dbee4b09034bfeeb71e"},{"problem":53,"code":"(fn [v]\n  (let [t (->> v\n               count\n               inc\n               (range 0)\n               (#(for [x % \n                       y % \n                       :when (< x y)]\n                   [x y]))\n               (map (fn [[x y]] (subvec v x y)))\n               (filter #(apply < %))\n               (reduce #(if (>= (count %) (count %2)) % %2)))]\n    (if (< 1 (count t))\n      t\n      [])\n    )\n  )","user":"52ae886de4b0c58976d9acab"},{"problem":53,"code":"(fn f53 [coll]\n  (let [pre(->>\n             (partition 2 1 coll)\n             (partition-by #(apply < %))\n             (sort-by count))\n        cnt (map count pre)\n        res (if (and (= 1 ((comp count distinct) cnt)) (= 1 ((comp first distinct) cnt)))\n              (->>\n                (filter #(= ((comp inc ffirst) %) ((comp last first) %)) pre)\n                flatten\n                vec)\n              (->>\n                pre\n                last\n                (apply concat)\n                (distinct)\n                vec))]\n    (if (= res coll)\n      []\n      res)))","user":"57bbc9bde4b05aa3c4741c31"},{"code":"(fn [s]\n  (loop [[a b & s] s m [] r []]\n    (let [n (conj m a)]\n      (letfn [(k [m n r] (if (or (empty? m) (< (count n) (count r))) r n))]\n        (if b\n          (if (= (inc a) b)\n            (recur (cons b s) n r)\n            (recur (cons b s) [] (k m n r)))\n          (if a\n            (k m n r)))))))","problem":53,"user":"4fdb02aae4b05e33b9224f56"},{"problem":53,"code":"(fn [x]\n    (reduce\n     #(if (and (< (count %1) (count %2)) (not= (count %2) 1)) (vec %2) %1)\n     []\n     (partition-by\n     nil?\n     (reduce\n      (fn [lis num] \n        (if \n            (> (first lis) num)\n            (cons num lis)\n            (cons num (conj lis nil))\n          ))\n      (list (get x (- (count x) 1)))\n      (rest (reverse x))))))","user":"54d2c4c5e4b0e8a36923e5fa"},{"code":"(fn [l]\n  (let [result (last \n                 (sort-by\n                   #(count %)\n                   (filter \n                     #(= 1 (ffirst %))\n                     (partition-by \n                       #(first %)\n                       (map-indexed \n                         #(list %2 %) \n                         (map - (rest l) (drop-last l)))))))]\n    (if (nil? result) '()\n      (take (inc (count result)) (drop (second (first result)) l)))))","problem":53,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"#_(let [c count\n  test #(and (> (c %1) 1)\n                 (> (c %1) (c %2)))]\n  #(loop [s % t [] r []]\n    (if (seq s)\n      (if (seq t)\n        (if (< (last t) (first s))\n          (recur (rest s) (conj t (first s)) r)\n          (if (test t r)\n            (recur s [] t)\n            (recur s [] r)))\n        (recur (rest s) [(first s)] r))\n      (if (test t r) t r))))\n\n#_(fn [s]\n      (letfn [(subseqs [s]\n                (if (seq s) (concat (subseqs (rest s))\n                                    (reductions conj [] s))))\n              (big-enough? [s] (> (count s) 1))\n              (increasing? [s] (apply < s))]\n        (apply max-key count (conj (filter (every-pred big-enough? increasing?) (subseqs s)) []))))\n(fn [s]\n  (apply max-key count (conj (filter #(and (> (count %) 1) (apply < %))\n                                     (loop [s s r []]\n                                       (if (seq s)\n                                         (recur (rest s) (concat (reductions conj [] s) r))\n                                         r))) [])))","problem":53,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn [c]\n  (letfn [(sub-seqs [col cur a]\n  (if (empty? col)\n    (if (empty? cur)\n      (reverse (map reverse a))\n      (reverse (map reverse (cons cur a))))\n    ;; not empty so lets see if this \n    (let [nxt (first col)\n          rst (rest col)]\n      (if (empty? cur)\n        ;; start a new sequence\n        (sub-seqs rst [nxt] a)\n        (if (= (dec nxt) (first cur))\n          ;; we have a sequence people\n          (sub-seqs rst (cons nxt cur) a)\n          ;; we don't have a sequence. \n          (sub-seqs rst [nxt] (cons cur a))\n          )\n        ))\n    ))]\n    (let [xs (sub-seqs c [] [])]\n    \n    (into [] (first (reverse (sort-by count (filter #(> (count %) 1) xs))))))))","problem":53,"user":"4ffa8affe4b0678c553fc3bd"},{"problem":53,"code":"#(vec (first (for [l (range (count %) 1 -1)\n                   p (partition l 1 %) :when (apply < p)] p)))","user":"595eba88e4b066ee0a44b04e"},{"problem":53,"code":"#(let [inc-seqs\n         (for [f [(fn [[a b]] (< a b))]\n               p (partition-by f (map list % (next %)))\n               :let [r `[~@(map first p) ~(last (last p))]]\n               :when (f r)]\n           r)]\n     (->> (cons [] inc-seqs)\n          (reverse)\n          (apply max-key count)))","user":"55568a7de4b0deb715856e1c"},{"problem":53,"code":"(fn foo-sub [sequ]\n  (letfn [(m-func [sequ] (loop[sequ sequ\n        temper []\n        result []\n        prev nil\n        ]\n    (let [current (first sequ)]\n      (cond\n        (empty? sequ) (cons temper result);;(last (sort-by count (cons temper result)))\n        (nil? prev) (recur (rest sequ) [current] result current)\n        (= 1 (- current prev)) (recur (rest sequ)\n                                      (conj temper current) result current)\n        :else (recur (rest sequ) [current] (cons temper result) current)))))\n          ]\n    (let [res (last (sort-by count (m-func sequ)))]\n      (if (= 1 (count res)) []\n          res))))","user":"6038b6b4e4b0d5df2af222ef"},{"code":"#(loop [c % r [] cr []]\n  (let [rl (count r) crl (count cr) fc (first c)]\n  (if (and (empty? c) (not (< rl crl)))\n      (if (= 1 rl) [] r)\n      (if (< rl crl)\n        (recur c cr cr)\n        (if (or \n                (nil? (last cr))\n                (= (last cr) (dec fc)))\n          (recur (next c) r (conj cr fc))\n          (recur (next c) r [fc])\n        )\n      )  \n  )\n  )\n)","problem":53,"user":"50921f9ae4b09a7d0b586de1"},{"problem":53,"code":"(fn foo [coll]\n  (let [matches #(->> (map-indexed (fn [i n] [i n]) %)\n                      (every? (fn [[i n]] (if (= i 0) true (< 0 (- n (nth % (dec i))))))))]\n    (->> (range (- (count coll) 2))\n         (map #(drop % coll))\n         (map #(reductions conj [] %))\n         (map #(take-while matches %))\n         (map #(vec [(count %) %]))\n         (filter (fn [[c n]] (> c 2)))\n         (reduce (fn [[ac an] [c n]] (if (> c ac) [c n] [ac an])) [0 [[]]])\n         (second)\n         (last))))","user":"56a51f26e4b0542e1f8d14e0"},{"code":"(fn [C [s & z]] \n  ((fn g [a [h & t]]\n    (if h \n      (if (< (last a) h)\n        (g (conj a h) t)\n        (let [q (g [h] t)]\n          (if (next a) \n            (if (< (C a) (C q)) q a)          \n            q)))\n      []))\n   [s] `(~@z 0)))\ncount","problem":53,"user":"4ef49c2c535dced4c769f238"},{"problem":53,"code":"(fn subseq [in]\n  (loop [longest []\n         [x & left] in\n         acc []]\n    (let [y (first left)]\n      (cond\n        (nil? x)\n        longest\n\n        (or (nil? y) (>= x y)) \n        (let [acc' (conj acc x)]\n          (if (and (> (count acc') (count longest))\n                   (>= (count acc') 2))\n           (recur acc' left [])\n           (recur longest left [])))\n\n        :else\n        (recur longest left (conj acc x))))))","user":"605b49b7e4b079a07f8593f8"},{"problem":53,"code":"(fn longest-sub-seq [candidate acc coll]\n  (println candidate acc coll)\n  (if (empty? coll) candidate\n                    (let [\n                          new-acc       (conj acc (first coll))\n                          new-candidate (if (and (> (count new-acc) 1) (< (count candidate) (count new-acc))) new-acc candidate)]\n                      (if (or (empty? acc) (< (last acc) (first coll)))\n                        (recur new-candidate new-acc (rest coll))\n                        (recur candidate [] coll))))) [] []","user":"5a91988ae4b002d099cae6f9"},{"code":"#(reduce \n   (fn [m n]\n     (if (= 1 (count n))\n       m\n       (if (> (count n) (count m))\n         n\n         m)))\n   []\n   (reduce\n    (fn[xs x]\n      (let [t (last (last xs))]\n        (if (> x t)\n          (conj (vec (butlast xs)) (conj (last xs) x))\n          (conj xs [x]))))\n    [[(first %)]]\n    (next %)))","problem":53,"user":"522454f4e4b01819a2de42d3"},{"code":"(fn [n] (let \n      [p (fn g [& c] \n          (if (empty? (last c))\n            (drop-last c)\n            (if (= (count c) 1)\n              (g [(first (first c))] (rest (first c)))\n              (let [y  (last (drop-last c)) z (last c)]\n                (if (< (last y) (first z))\n                  (apply g (conj (vec (drop-last 2 c)) (conj y (first z)) (rest z)))\n                  (apply g (conj (vec (drop-last 2 c)) y  [(first z)] (rest z))))))))\n      result (reduce #(if (> (count %2) (count %)) %2 %) (p n))]\n  (if (= (count result) 1) ()result)))","problem":53,"user":"512f06c5e4b0762be4c7aad7"},{"code":"(fn [source]\n     (letfn [(incr-seqs [[num & source]]\n                        (lazy-seq (apply cons (loop [current [num] [num & tail :as source] source]\n                                                (if num\n                                                  (if (< (peek current) num)\n                                                    (recur (conj current num) tail)\n                                                    [current (incr-seqs source)])\n                                                  [current []])))))]\n\n     (let [r (reduce (fn [a b] (if (> (count b) (count a)) b a)) (incr-seqs source))]\n       (if (< 1 (count r)) r []))))","problem":53,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":53,"code":"(fn [col] \n  (let [longest-asc (atom []) \n      temp-asc (atom [])]\n    \n    (reduce \n        (fn [acc i] \n              (do \n                  (if (< acc i) \n                      (do \n                          (reset! temp-asc (conj @temp-asc i))\n                          (when (> (count @temp-asc) (count @longest-asc)) \n                                (reset! longest-asc @temp-asc)))\n                (reset! temp-asc [i])) \n              i))\n          0 col) \n       \n        (if (< (count @longest-asc) 2) \n            [] \n            @longest-asc)))","user":"5976da27e4b01722bebd4ce3"},{"problem":53,"code":"(fn [s]\n (letfn [(m-insert [x ys]\n    ;;(println ys)\n    (if (= ys '()) (list (list x))\n        (if (< (last (last ys)) x) (concat (drop-last ys) (list (concat (last ys) (list x))))\n                                   (concat ys (list (list x))))))\n  (m-split [sin]\n   (loop [s_in  sin \n          s_out '()]\n     (if (== (count s_in) 0) s_out\n         ;; else\n         (recur (rest s_in) (m-insert (first s_in) s_out)))))\n  (m-choose [sa sb]\n       (if (> (count sb) (count sa)) sb\n            sa))]\n    (let [sin (filter #(> (count %) 1) (m-split s))]\n    (loop [s_act (first sin)\n           s_in  (rest  sin)]\n      (if (== (count s_in) 0) \n          (into [] s_act)\n          (recur  (m-choose s_act (first s_in)) (rest s_in)))))))","user":"56fa2905e4b07572ad1a88be"},{"problem":53,"code":"#(loop [idx 1\n         result [[(first %)]]]\n    (if (= (count %) idx)\n      (nth (reverse (filter (fn [el] (and (= (count el) (apply max (map count result)))\n                                          (> (count el) 1))) result)) 0 [])\n      #_(apply max (map count result))\n      (recur (inc idx) (if (= (dec (nth % idx)) (nth % (dec idx)))\n                         (cons (conj (first result) (nth % idx)) (rest result))\n                         (cons [(nth % idx)] result)))))","user":"5a4d656fe4b05d388ecb6ba9"},{"problem":53,"code":"#(letfn [(asc-subs [seq]\n          (lazy-seq\n            (loop [chunk []\n                   seq   seq]\n              (if (empty? (next seq))\n                (cons (into chunk seq) nil)\n                (let [[head & tail] seq]\n                  (if (= (inc head) (first tail))\n                    (recur (conj chunk head) tail)\n                    (cons (conj chunk head) (asc-subs tail))))))))]\n  (reduce (fn ([] []) ([a] a) ([a b] (max-key count a b)))\n          (filter next (asc-subs %))))","user":"512700c4e4b083bb8f88cf14"},{"problem":53,"code":"(fn incrementos [v] \n(let [ q (loop [r [] c [] s v]\n    (if (> (count s) 0) \n         (let [a (first s)] \n                (if (or (= 0 (count c)) (= a (+ (last c) 1)))\n                  (recur r (conj c a) (subvec s 1))\n                  \n                       (recur (conj r c) [a] (subvec s 1))\n                       \n                 ))\n         (conj r c))) n (apply max (map count q)) uu (first (filter #(and (> (count %) 1) (= n (count %)) )q)) ] (if (nil? uu) [] uu)))","user":"55ac16a0e4b03311e7b73291"},{"problem":53,"code":"(fn longest-increasing-subseq\n  [coll]\n  (apply max-key count\n         (reverse (map (fn [n]\n                         (let [partitions (take-while (partial apply <)\n                                                      (partition 2 1\n                                                                 (drop n coll)))]\n                           (if (seq partitions)\n                             (conj (vec (map first partitions))\n                                   (second (last partitions)))\n                             [])))\n                       (range (count coll))))))","user":"56180d83e4b06b1bb2182a18"},{"problem":53,"code":"(fn [coll]\n\t(first \n\t\t(concat\n\t\t\t(sort-by #(- (count %))\n\t\t\t\t(filter #(> (count %) 1)\n\t\t\t\t\t(reduce \n\t\t\t\t\t\t(fn [accum n] \n\t\t\t\t\t\t\t(if (empty? accum) \n\t\t\t\t\t\t\t\t[[n]] \n\t\t\t\t\t\t\t\t(if (> n (last (last accum)))\n\t\t\t\t\t\t\t\t\t(concat \n\t\t\t\t\t\t\t\t\t\t(butlast accum) \n\t\t\t\t\t\t\t\t\t\t[(concat (last accum) [n])]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t(concat accum [[n]])\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t[]\n\t\t\t\t\t\tcoll\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t[[]]\n\t\t\t)\n\t\t)\n\t)","user":"54c11fdae4b0ed20f4ff6f1b"},{"problem":53,"code":"(fn longest-inc-seq\n  ([coll] (longest-inc-seq [] [(first coll)] (rest coll)))\n  ([lng curr [x & c]]\n   (letfn [(select-longest\n            [longest current]\n            (if (and (< (count longest) (count current))\n                     (< 1 (count current)))\n              current\n              longest))]\n     (if (nil? x)\n       (select-longest lng curr)\n       (if (> x (last curr))\n         (longest-inc-seq lng (conj curr x) c)\n         (longest-inc-seq (select-longest lng curr) [x] c))))))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [xs]\n  (let [subseqs (reduce concat (map #(partition % 1 xs) (range 2 (count xs))))\n        inc-subseqs (filter #(= % (take (count %) (iterate inc (first %)))) subseqs)]\n    (if (empty? inc-subseqs)\n      '()\n      (apply max-key count inc-subseqs))))","problem":53,"user":"5312cdaae4b08068f379ed03"},{"problem":53,"code":"(fn [coll]\n  (let [m\n        (apply max-key count\n               (let [n (partition-by (fn [[x y]] (> y x)) (partition 2 1 coll))]\n                 (reverse (filter #(> (count %1) 1) (map (fn [item] (cons (first (first item)) (map last item))) n)))))]\n    (if (= (sort m) m) m [])))","user":"57131a8ee4b07c98581c3a97"},{"problem":53,"code":"(fn [v] \n  (let [ inc-length \n    (fn [v start]                                                                                                                    \n    (let [cnt (count v)]                                                                                                                        \n      (loop [i start                                                                                                                            \n             prev (get v i)                                                                                                                     \n             len 1]                                                                                                                             \n        (let [nxt (inc i)]                                                                                                                      \n          (if (< nxt cnt)                                                                                                                       \n            (let [x (get v nxt)]                                                                                                                \n              (if (< prev x)                                                                                                                    \n                (recur nxt x (inc len))                                                                                                         \n                len                                                                                                                             \n              )                                                                                                                                 \n            )                                                                                                                                   \n            len                                                                                                                                 \n          )                                                                                                                                     \n        )                                                                                                                                       \n      )                                                                                                                                         \n    )\n    )\n    inc-seqs \n      (fn [v]                                                                                                                            \n      (let [cnt (count v)]                                                                                                                        \n        (loop [seqs []                                                                                                                            \n              i 0]                                                                                                                                \n          (if (< i cnt)                                                                                                                           \n            (let [len (inc-length v i)]                                                                                                           \n              (recur (conj seqs [i, len]) (+ i len))                                                                                              \n            )                                                                                                                                     \n            (reverse seqs)                                                                                                                                  \n          )                                                                                                                                       \n        )                                                                                                                                         \n      )                                                                                                                                      \n    )\n    inc-seqs (inc-seqs v)                                                                                                                 \n    [start len] (apply max-key second inc-seqs)                                                                                           \n    end (+ start len)                                                                                                                     \n    ]                                                                                                                                     \n    (if (< len 2)                                                                                                                             \n      []                                                                                                                                      \n      (subvec v start end)                                                                                                                    \n      )                                                                                                                                       \n  )                                                                                                                                                    \n)","user":"56fbe0cce4b07572ad1a88d8"},{"problem":53,"code":"(fn f [s] (loop[h (first s) t (rest s) r () crnt ()]\n            (if (= h nil) (if (= (count r) 1) '() (reverse r)) (let[b (if (empty? crnt) (cons h ()) (if (= h  (inc (last (reverse crnt)))) (cons h crnt) (cons h ()) ) ) ]\n                              (recur (first t) (rest t) (if (empty? r) b (if (< (count r) (count b)) b r ) ) b ) ) ) ))","user":"53b3ea79e4b047364c0444ab"},{"problem":53,"code":";(fn [list]\n;  (reduce (fn [x y]\n;            (let [cx (count x) cy (count y)]\n;              (if (> cx cy)\n;                (if (> cx 1) x [])\n;                (if (> cy 1) y []))))\n;          (map-indexed (fn [idx o_O]\n;                         (remove (fn [x] (= x 123456789))\n;                                 (reduce #(if (empty? %)\n;                                            (vector %2)\n;                                            (if (= (inc (last %)) %2)\n;                                              (conj % %2)\n;                                              (if (= (last %) 123456789)\n;                                                % (conj % 123456789)))\n;                                            ) [] (nthrest list idx)))) list)))\n(fn [x]\n  (letfn [(take-while-inc [col]\n            (when-let [s (seq col)]\n              (cons (first s) (twi (rest s) (first s)))))\n          (twi [s last]\n            (lazy-seq\n             (when (= (+ 1 last) (first s))\n               (cons (first s) (twi (rest s) (first s))))))\n          (build [col]\n            (when (not-empty col)\n              (concat (vector (take-while-inc col)) (build (next col)))))\n          (longest-increasing-seq [col]\n            (let [erg (into [] (reduce #(if (> (count %) (count %2)) % %2) (build col)))]\n              (if (> (count erg) 1) erg [])))]\n    (longest-increasing-seq x)))","user":"55b22c33e4b0da326a65cf79"},{"problem":53,"code":"(fn [coll0]\n  (loop [coll coll0\n         result []\n         sub-seq [(first coll)]]\n    (if-let [[a & others] (seq coll)]\n      (if (= a (inc (peek sub-seq)))\n        (recur others result (conj sub-seq a))\n        (if (and (> (count sub-seq) 1) (> (count sub-seq) (count result)))\n          (recur others sub-seq [a])\n          (recur others result [a])))\n      (if (and (> (count sub-seq) 1) (> (count sub-seq) (count result)))\n        sub-seq result))))","user":"5f82609ae4b0c071e6c840f9"},{"problem":53,"code":"(fn [coll]\n  (loop [s coll r1 [] l1 0 r2 [] l2 0]\n    (if (empty? s)\n      (let [res (if (> l1 l2) r1 r2)]\n        (if (empty? (rest res)) [] res)\n        )\n      (recur (rest s)\n        (if (or (empty? r1) (> (first s) (peek r1))) (conj r1 (first s)) [(first s)])\n        (if (or (empty? r1) (> (first s) (peek r1))) (inc l1) 1)\n        (if (and (not (empty? r1)) (<= (first s) (peek r1)) (> l1 l2)) r1 r2)\n        (if (and (not (empty? r1)) (<= (first s) (peek r1)) (> l1 l2)) l1 l2)\n        )\n      )\n    )\n  )","user":"5471f2fbe4b094393f72dd70"},{"problem":53,"code":"(letfn [(subseqs\n           ([xs] (subseqs xs (count xs)))\n           ([xs i]\n            (if (= i 1) [[]]\n                (lazy-cat (partition i 1 xs)\n                          (subseqs xs (dec i))))))\n         (increasing? [xs] (every? (fn [[a b]] (< a b)) (partition 2 1 xs)))\n         (longest-inc-sub [xs]\n           (->> (subseqs xs)\n                (filter increasing?)\n                (first)))]\n   longest-inc-sub)","user":"5d4b2155e4b0776584bd6f28"},{"code":"(fn lseq [xs]\n  (reduce \n   #(if (> (count %2) (count %1)) %2 %1)\n   (loop [curr-seq [(first xs)], seqs #{[]}, ys (rest xs)]\n     (let [fst (first ys), rst (rest ys), prev (last curr-seq)]\n       (cond (= (count ys) 0) (if (> (count curr-seq) 1) (conj seqs curr-seq) seqs)\n             (= fst (inc prev)) (recur (conj curr-seq fst) seqs rst)\n             :else (recur [fst] (if (> (count curr-seq) 1) (conj seqs curr-seq) seqs) rst))))))","problem":53,"user":"534941d1e4b084c2834f4a60"},{"problem":53,"code":"(fn [xs] \n(let [val (first \n           (sort-by \n            #(* -1 (count %)) \n                    (remove nil? \n                            (map \n                             #(if (= 1 (count %)) \n                                      (do (if (> (apply second %) (apply first %)) \n                                              (flatten %) )) \n                                    (concat \n                                     (map first %) \n                                     (list (second (last %))))) \n                                 (partition-by \n                                  #(if (< (first %) (second %)) \n                                       true \n                                     (first %)) \n                                  (partition 2 1 xs))))))] \n  (if (nil? val) [] val)))","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":53,"code":"(fn longest-incr-subseq\n  [l]\n  (loop\n    [i 1\n     longest-begin 0\n     longest-end 0\n     cur-begin 0]\n    (cond (>= i (count l)) (let [longest-len (- longest-end longest-begin)\n                                 cur-len (- i cur-begin)]\n                             (cond (< (max longest-len cur-len) 2) []\n                                   (>= longest-len cur-len) (subvec l longest-begin longest-end)\n                                   :else (subvec l cur-begin)))\n          (> (nth l i) (nth l (dec i))) (recur (inc i) longest-begin longest-end cur-begin)\n          (> (- i cur-begin) (- longest-end longest-begin)) (recur (inc i) cur-begin i i)\n          :else (recur (inc i) longest-begin longest-end i))))","user":"551afdf8e4b07993ea3788cb"},{"problem":53,"code":"(fn [v]\n  (let [\n        pairs (partition 2 1 v)\n        partioned-by-LT (partition-by (fn [[a b]] (< a b)) pairs)\n        increasing-partitions (filter (fn [x] (< (ffirst x) (second (first x)))) partioned-by-LT)\n        \n        longest-increasing-partition (reduce (fn [a b] (if (> (count b) \n                                                              (count a))\n                                                            b\n                                                            a)) \n                                              []\n                                              increasing-partitions )\n        head (ffirst longest-increasing-partition)\n        tail (map last longest-increasing-partition)\n        ]\n    (if (nil? head)\n      []\n      (cons head tail))))","user":"557e56aae4b05c286339e0d5"},{"code":"(fn [s]\n (remove #(= -2 %) (last (last (last (sort (group-by count \n   (reduce (fn [[f & r :as l]  i] (if (= i (inc (last f))) (cons (conj f i) r) (cons [i] l)))\n           '([-2]) s))))))))","problem":53,"user":"4f1d1d95535d64f603146488"},{"problem":53,"code":"(fn [xs]\n  (first\n   \t(let [longer (fn [xs ys] (if (< (max 1 (count xs)) (count ys)) ys xs))]\n      (reduce\n        (fn [[longest current] e]\n          (cond\n            (empty? current) [longest [e]]\n            (= (inc (last current)) e) [(longer longest (conj current e)) (conj current e)]\n            :else [longest [e]]))\n        [[] []]\n        xs))))","user":"5e98e8a9e4b0157ca96647dc"},{"problem":53,"code":"(fn lis [a]\n\n  (letfn [(lis-from [a j]\n  (let [n (count a)]\n    (loop [out [(get a j)] j j]\n      (cond (= j (dec n)) out\n            (>= (get a j) (get a (inc j))) out\n            :else (recur (conj out (get a (inc j))) (inc j))))))]\n\n  (let [n (count a)]\n  ;; get a list of all valid subseqs starting from a_j\n  (let [subseq-list (for [j (range n)] (lis-from a j))]\n    ;; get the max index, picking first in a tie\n    (let [max-val (reduce max (map count subseq-list))]\n      (let [arg-max (.indexOf (map count subseq-list) max-val)]\n        ;; follow instructions and discard length 1 max vals\n        (if (= 1 max-val)\n          []\n          ;; otherwise, return the max count subseq\n          (get (vec subseq-list) arg-max))))))))","user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn x [list]\r\n(let [gt (fn [[a b]] (< a b))]\r\n(->> list\r\n        (partition 2 1)\r\n        (partition-by gt)\r\n        (filter (comp gt first))\r\n  \t(map #(cons (ffirst %) (map second %)))\r\n\t\t(cons [])\r\n        reverse\r\n\t\t(apply max-key count)\r\n\t\t)))","problem":53,"user":"504e07f3e4b078edc5f593a4"},{"code":"(fn [coll]\n  (let [z (filter #(> (count %) 1)\n            (reduce (fn [c e]\n                      (let [z (last c)]\n                        (if (= (inc (last z)) e)\n                          (conj (subvec c 0 (dec (count c))) (conj z e))\n                          (conj c [e]))))\n                    [[(first coll)]] (rest coll)))]\n        (if (empty? z) () (apply max-key count z))))","problem":53,"user":"51780f88e4b03d69594194c9"},{"problem":53,"code":"#(let [res (first (reduce (fn [acc e]\n\n                  (let [current (if (= (dec e) (last (second acc))) (concat (second acc) [e]) [e])] \n                  \t[(if (> (count current) (count (first acc))) current (first acc)) current]\n                  )) [[] []] %))] (if (second res) res []))","user":"55a74d46e4b09e57187da2a3"},{"problem":53,"code":"(fn [q]\n  (letfn [(partition-pair [f s]\n     (cond \n      (empty? s) nil \n      (empty? (rest s)) (list s)\n      :else (let [l \n             (loop [el (first s)\n              bl [el]\n              rl (rest s)]\n               (if (or (empty? rl) (not (f el (first rl))))\n                 bl\n                 (recur (first rl) (conj bl (first rl)) (rest rl))))]\n         (cons l\n               (lazy-seq (partition-pair f (drop (count l) s))))))\n     )]\n    (let [res (partition-pair < q)\n         ans (first (filter #(= (count %) (apply max (map count res))) res))]\n      (if (= 1 (count ans)) () ans)\n    ))\n)","user":"53f6d555e4b0db01ade6f9e5"},{"problem":53,"code":"(fn result [items]\n  (let [result (reduce \n   (fn [coll1 coll2] \n     (if (>= (count coll1) (count coll2)) \n      coll1 \n      coll2)) \n   (reduce (fn my-add [memo item]\n  (if (> item (last (last memo))) \n    (conj \n     (if (nil? (butlast memo)) [] (vec (butlast memo)))\n     (conj (last memo) item)) \n    (conj memo [item])))\n [[(first items)]] (rest items)))]\n    (if (> (count result) 1) result [])))","user":"54980edae4b0b312c081ff79"},{"problem":53,"code":"(fn liss [xs]\n  ((fn f [result input]\n     (if (empty? input)\n       (->> (reverse result)\n            (filter #(> (count %) 1)) ;; not interest seq of length 1\n            (group-by count) ;; values can occur several times \n            (sort) ;; we want the max value\n            (last) ;; sort on map are per default ascending\n            (second) ;; get the value, which should be a coll\n            (first) ;; first element is the one the appeared first in source\n            (reverse) ;; reverse as we store in opposite direction\n            )\n       \n       \n\n       (f\n        ;; determine the result based on the case\n        (if (and (not-empty result) (> (first input) (ffirst result)))\n          ;; take first result, append first input, prepend to rest result\n          (conj (rest result)\n                (conj (first result) (first input)))\n\n          ;; create a new list and prepend that list to result\n          (conj result (list (first input))))\n        \n        ;; \n        (rest input)\n        )\n       )) () xs))","user":"5641296de4b08d4f616f5ef4"},{"code":"(fn [a] \n  (let [all \n        (#(if (empty? %3)\n            (conj % %2)\n            (let [f (first %3)\n                  e (= (inc (last %2)) f)] \n\n              (recur (if e % (conj % %2))\n                     (if e (conj %2 f) [f])\n                     (rest %3)))) \n\n          [] [(first a)] (rest a))]\n\n    (let [r (-> (apply max-key count all))]\n      (if (seq (rest r)) r []))))","problem":53,"user":"50e7dd5de4b077ad597af36b"},{"problem":53,"code":"(fn __ [coll]\n   (let [xs (first (sort-by count >\n                            (filter (fn [[[x y]]]\n                                      (= (inc x) y))\n                                    (partition-by (fn [[x y]] (= (inc x) y))\n                                                  (partition 2 1 coll)))))]\n     (concat (first xs) (map last (rest xs)))))","user":"56706f01e4b0a866af6896f2"},{"problem":53,"code":"#(first\n  (reduce \n   (fn [res el]\n     (if (empty? res)\n       (list (list) (list el))\n       (if\n         (> el (last (last res)))\n         (let\n           [l (concat (last res) (list el)) cl (count l) fr (first res)]\n           (if\n             (and (< (count fr) cl) (> cl 1))\n             (list l l)\n             (list fr l)\n             )\n           )\n         (list (first res) (list el))\n         )\n       )) () %))","user":"56a75810e4b0542e1f8d14fc"},{"problem":53,"code":"(fn [coll]\n   (let [inc-list (reductions\n                    (fn [m x]\n                      (if (or\n                            (empty? m)\n                            (> x (last m)))\n                        (conj m x)\n                        [x]))\n                    []\n                    coll)\n         max-list (reduce (fn [m x]\n                            (if (> (count x) (count m))\n                              x\n                              m))\n                          []\n                          inc-list)]\n     (if (>= (count max-list) 2)\n       max-list\n       [])))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn f [s]\n  (if (next s)\n    (let [p (f (butlast s))\n          q (f (next s))]\n      (if (apply < s)\n        s\n        (if (> (count q) (count p))\n          q\n          p)))\n    []))","problem":53,"user":"536e0930e4b0fc7073fd6e66"},{"problem":53,"code":"(fn [coll]\n  (let [partitions (partition-by #(< (first %) (last %)) (partition 2 1 coll))\n        filtered (filter #(< (ffirst %) (last (first %))) partitions)\n        largest-part (reduce #(if (< (count %1) (count %2)) %2 %1) [] filtered)\n        ans (flatten (conj (vector (map first largest-part)) (last (last largest-part))))]\n    (if (nil? (first ans)) [] ans)))","user":"5a4e1c81e4b05d388ecb6bb6"},{"problem":53,"code":"(fn long-seq [s]\n  (->> (partition 2 1 s)\n       (partition-by (fn [[p1 p2]] (> p2 p1)))\n       (map #(conj (into [] (map first %)) (last (last %))))\n       (filter (fn [[a b]] (> b a)))\n       (reduce (fn [a b] (if (> (count b) (count a)) b a)) [])))","user":"5fb68f09e4b08cb800c85b58"},{"problem":53,"code":"(fn [seq]\n  (letfn [(longest [seq current so-far]\n                   (cond \n                    (empty? seq) (if (> (count current) (count so-far)) current so-far)\n                    (empty? current) (recur (rest seq) (list (first seq)) so-far)\n                    true (if (> (first seq) (first current))\n                           (recur (rest seq) (cons (first seq) current) so-far)\n                           (if (> (count current) (count so-far))\n                             (recur seq (list) current)\n                             (recur seq (list) so-far)))))\n          (ensure-length [seq] (if (> (count seq) 1) seq (list)))]\n    (reverse (ensure-length (longest seq (list) (list))))))","user":"5553b924e4b0deb715856e06"},{"problem":53,"code":"(fn thing [lst] \n  ; Partition into (first lst) and (rest lst)\n  (first \n    (let [sub (first lst)\n        rst (rest lst)]\n        (reduce \n          (fn [\n             ; A is tuple (last subseq, current subseq)\n            A\n            ; nxt is the next number in the list\n            nxt]\n            ; End is end of current subseq\n            (let [\n              lastSub (first A)\n              currSub (last A)\n              end (last currSub)]\n              ; If the next num is larger than the end\n              (do (println lastSub currSub nxt))\n              (if (> nxt end) \n                ; Add to current subseq \n                (let [current (conj currSub nxt)]\n                  ; Check if time to override\n                  (if (> (count current) (count lastSub))\n                    (list current current)\n                    (list lastSub current)\n                  )\n                )\n                ; Else, start a new subseq\n                (list lastSub [nxt])\n              )\n            )\n          )\n          ;; #(println %1 %2)\n          (list [] [sub])\n          rst\n        )\n    )\n  )\n)","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":53,"code":"(fn [s]\n    (->  \n  (for [x (range (count s) 1 -1)\n  :let [r (\n            (fn [x s]\n               (let [n (count s)]\n                   (for [y (range (- n x -1))\n                         :let [a (subvec s y (+ x y))\n                               b (first a)\n                               c (range b (+ b x))]\n                         :when (= a c)]\n                     c))) x s)]\n  :when ((comp not empty?)  r)]\n   r) \n   first \n   (nth 0 []))\n)","user":"5464a536e4b01be26fd746cf"},{"problem":53,"code":";; this is horrific! fix me!\n(fn subseqs [col]\n  (loop [longest []\n         cur col\n         cur-sub []\n         prev nil]\n    (if (seq cur)\n      (if (or (nil? prev)\n              (= (first cur) (inc prev)))\n        (let [new-cur-sub (conj cur-sub (first cur))]\n          (recur (if (> (count new-cur-sub) (count longest))\n                   new-cur-sub\n                   longest)\n                 (rest cur) new-cur-sub (first cur)))\n        (recur longest\n               (rest cur) [(first cur)] (first cur)))\n      (if (> (count longest) 1)\n        longest\n        []))))","user":"5d231255e4b02ea6f0fb69fe"},{"code":"#_ ;; alternate take, but I like the reduced based slightly better\n(fn longest-increasing [l]                                                      \n  (letfn [(tails [s] (take-while seq (iterate rest (concat s [nil]))))         \n          (adj [[a b]] (= (inc a) b))                                           \n          (these-and-1 [[a b]] (concat a (take 1 b)))                           \n          (take-run [nums]                                                      \n            (->> nums                                                           \n                 (partition 2 1)                                                \n                 (split-with adj)                                               \n                 (these-and-1)                                                  \n                 (map first)))                                                  \n          (lonely [l] (= 1 (count l)))]                                         \n    (apply max-key count                                                        \n      (->> (tails l)                                                            \n           (map take-run)                                                       \n           (cons [])                                                            \n           (remove lonely)))))\n#(first                                                                         \n  (reduce (fn [[longest current] el]                                            \n           (if (= el (inc (peek current)))                                      \n             (let [current' (conj current el)                                   \n                   longest' (max-key count current' longest)]                                         \n               [longest' current'])                                             \n             [longest [el]]))                                                   \n         [[] [(first %)]]                                                       \n         (rest %)))","problem":53,"user":"51f9527fe4b09be9c177e549"},{"problem":53,"code":"(fn [coll]\n  (reduce\n    (fn [acc e]\n      (if (> (count acc) (count e))\n        acc\n        e))\n    []\n    (loop [result [] [n & rest-coll] coll result-coll\n    []]\n      (cond\n        (or (empty? result) (= (last result) (dec (or n 0))))\n        (recur (conj result n) rest-coll result-coll)\n        (and (not= (last result) (dec (or n 0))) (< (count result) 2) (not (empty? rest-coll)))\n        (recur [] (into [n]\n        rest-coll)\n                  (if (< 1 (count result))\n                    (conj result-coll result)\n                    result-coll))\n        (and (not= (last result) (dec (or n 0))) (not (empty? rest-coll)))\n        (recur [] (into [n]\n        rest-coll)\n                  (if (< 1 (count result))\n                    (conj result-coll result)\n                    result-coll))\n        (> (count result) (inc (count rest-coll)))\n        (if (< 1 (count result))\n          (conj result-coll result)\n          result-coll)\n        :else\n        (if (< 1 (count result))\n          (conj result-coll result)\n          result-coll)))))","user":"58a413b5e4b02bd94d917f07"},{"code":"(fn [coll]\n  (let [llen (fn [coll] (reductions\n      (fn [xs y]\n        (if (= y (inc (last xs))) (conj xs y) [y]))\n      [(first coll)]\n      (rest coll)))]\n  (vec (last (filter #(< 1 (count %)) (sort-by count (llen coll)))))))","problem":53,"user":"4f1c2a3a535d64f603146480"},{"code":"(fn [col]\n  (let [diffs (partition-by (partial apply -) (partition 2 1 col))\n        seqs  (filter\n                 (fn [s]\n                   (and (>= (count s) 1)\n                        (= -1 (apply - (first s)))))\n                 diffs)]\n    (if (seq seqs)\n      (let [longest (->> seqs reverse (apply max-key count))]\n        (range (ffirst longest) (inc (second (last longest)))))\n      [])))","problem":53,"user":"525431dfe4b0541d1855b970"},{"problem":53,"code":"(fn [s] (reverse (apply max-key count (map #(if (< (count %) 2) [] %) (reduce (fn [[[x :as t] :as s] y] (if (and x (= 1 (- y x))) (cons (cons y t) (rest s)) (cons (list y) s))) [[]] s)))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn f [b c l [h & t]]\n  (let [C count\n        d (if (< (C b) (C c)) c b)]\n    (cond\n      h\n        (if (> h l)\n          (f d (conj c h) h t)\n          (f d [h] h t))\n      (> (C d) 1)\n        d\n      1\n        [])))\n[] [] 9","problem":53,"user":"4ee82539535d93acb0a66878"},{"problem":53,"code":"(fn [coll]\n  (:best\n   (reduce\n    (fn [{:keys [best prev n*] :as acc} n]\n      (let [pass? (= (dec n) n*)\n            trial (conj prev n)\n            ct    (count trial)]\n        (assoc acc\n          :n* n\n          :best (if (and pass? (> ct (count best)) (> ct 1))\n                  trial\n                  best)\n          :prev (if pass? (conj prev n) [n]))))\n    {:best [] :prev [(first coll)] :n* (first coll)}\n    (rest coll))))","user":"505aa653e4b021387fb89857"},{"problem":53,"code":"(fn [xs] (first (reduce (fn [[r vs] [l g]]\n                            (if (> g l)\n                              [r (conj vs l)]\n                              (if (and (> (count vs) 0)\n                                       (> (+ 1 (count vs)) (count r)))\n                                [(conj vs l) []]\n                                [r []])\n                              ))\n                          [[] []]\n                          (map vector xs (concat (rest xs) [(- (last xs) 1)])))))","user":"54c641f8e4b045293a27f628"},{"problem":53,"code":"(fn [coll]\n  (let [max-seq (apply max-key count (reduce #(let [last-item (last (last %1))]\n                                   (if (= (inc last-item) %2)\n                                     (conj ((comp vec drop-last) %1)\n                                           (conj (last %1) %2))\n                                     (conj %1 [%2])))\n                                [[(first coll)]]\n                                (rest coll)))]\n    (if (> (count max-seq) 1)\n      max-seq\n      [])))","user":"60b1add0e4b0e0fa5f1b4227"},{"problem":53,"code":"(fn [coll]\n   (let [nil-result (for [[a b] (partition 2 1 coll)] (if (>= a b) nil [a b]))]\n     (keep-indexed #(if (or (odd? %1) (= 0 %1)) %2)\n                   (first (sort-by #(- (count %))\n                                   (map flatten\n                                        (filter #(not (some nil? %)) (partition-by nil? nil-result))))))))","user":"57147cd9e4b07c98581c3abf"},{"problem":53,"code":"(fn longest-subsequence [v]\n  (let [f       (fn [acc x] (if (= (dec x) (peek acc)) (conj acc x)[x]))\n        longest (apply max-key count (reductions f [] v))]\n    (if (> (count longest) 1) longest [])))","user":"569ac634e4b0542e1f8d144b"},{"code":"(fn longest-increasing-subseq [coll]\n  (letfn [(suffixes [coll] (take-while not-empty (iterate rest coll)))\n          (lis-from-head [coll]\n            (loop [acc  (list (first coll))\n                   coll (rest coll)]\n              (if (or (empty? coll) (>= (first acc) (first coll)))\n                (if (< (count acc) 2) [] (reverse acc))\n                (recur (cons (first coll) acc) (rest coll)))))]\n    (->> coll\n         suffixes\n         (map lis-from-head)\n         (sort-by count >)\n         first)))","problem":53,"user":"50586354e4b06522596eba78"},{"problem":53,"code":"(fn longseq [s & sub?]\n  (let \n    [candidates  \n         (if (< (count s) 2) [] (concat (list  s) (longseq (butlast s) true) (longseq (rest s) true)))]\n    (if sub? \n\t    candidates \n        (let [slist (sort #(compare (count %2) (count %1)) \n\t\t\t\t\t     (filter (fn [cs] (apply < cs)) candidates))] \n        (if (seq slist) (vec (first slist)) [] )))))","user":"579d9601e4b05b1deef9ae18"},{"code":"(fn [x]\n   (let [ss (map (comp distinct flatten)\n\t\t (partition-by (fn [[a b]] (<= b a)) (partition 2 1 x)))]\n\t\t (concat (first (sort-by #(count %) >\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(filter (fn [t] (pos? (reduce #(- %2 %) t))) ss)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)) [])))","problem":53,"user":"504f44cfe4b0a02f9cffde65"},{"problem":53,"code":"(fn longest-inc-subseq\n  [sequence]\n  (loop [subsequences '[]\n         current-seq '[]\n         remaining-seq sequence\n         max-length 0]\n    (let [next-element (first remaining-seq)\n          last-element (last current-seq)\n          last-element (if (nil? last-element) 0 last-element)\n          ;; prevents number operations by substituting\n          ;; a nil first element in current-seq with 0\n          current-seq' ;; keep cojoining the subsequence if the next element is larger\n                          ;; otherwise make a new sequence containing the next element \n            (if (and (not (nil? next-element))\n                     (> next-element last-element))\n                (conj current-seq next-element)\n                [next-element])\n          current-seq-length\n            (count current-seq')\n          max-length'\n            (if (> current-seq-length max-length)\n              current-seq-length\n              max-length)\n          subsequences' ;; add every subsequence to this sequence of sequences\n            (conj subsequences current-seq')\n          remaining-seq' (rest remaining-seq)]\n      (if (empty? remaining-seq)\n        (let\n            [longest-inc-subsequence\n             (first (filter #(= max-length (count %)) subsequences'))]\n          (if (< (count longest-inc-subsequence) 2) ;; if the longest subsequence\n            ;; is less than two elements long, return an empty sequence\n            '[]\n            longest-inc-subsequence))\n        (recur subsequences' current-seq' remaining-seq' max-length')))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn longest [coll]\n  (loop [result [] current [] coll coll]\n    (cond (empty? coll)\n          (reverse\n            (if (and (> (count current) 1)\n                     (> (count current) (count result)))\n                current\n                result))\n          (or (empty? current)\n              (= (first coll) (inc (first current))))\n          (recur result\n                (cons (first coll) current)\n                (next coll))\n          :else (recur (if (and (> (count current) 1)\n                                (> (count current) (count result)))\n                          current\n                          result)\n                      []\n                      coll))))","problem":53,"user":"4e4b4564535dc968683fc4d3"},{"code":"(fn [l] (->> (map #(drop % l) (range (count l)))\n             (map #(cons (first %)\n                         (map second (take-while (fn [[a b]] (= a (dec b)))\n                                                 (map list % (next %))))))\n             (filter #(< 1 (count %)))\n             (reduce #(last (sort-by count [% %2])) [])))","problem":53,"user":"534bde26e4b084c2834f4a81"},{"problem":53,"code":"(fn longest [s]\n  (let [[x y]\n    (reduce #(let [[a b] %1]\n               (if (or (empty? b) (> %2 (peek b)))\n                 [a (conj b %2)]\n                 (if (> (count b) (count a))\n                   [b [%2]]\n                   [a [%2]]\n                 )\n               )\n             ) [[][]] s)\n      ]\n    (let [m (if (> (count y) (count x)) y x)] (if (>= (count m) 2) m []))\n  )\n)","user":"53ecac57e4b0d648e757f4b3"},{"problem":53,"code":"(fn [s]\n         (let [seqs    (loop [seqs        []\n                              current-seq []\n                              [x & tail]  s]\n                         (if (nil? x)\n                           (conj seqs current-seq)\n                           (if (= (dec x) (last current-seq))\n                             (recur seqs (conj current-seq x) tail)\n                             (recur (conj seqs current-seq) [x] tail))))\n               max-seq (apply max-key count seqs)]\n           (if (> (count max-seq) 1)\n             max-seq\n             [])))","user":"5beadeb5e4b0f319e2d7ec88"},{"problem":53,"code":"(fn [xs]\n   (let [p (partition 2 1  xs)\n         counter (map (fn [[x y]] (= y (inc x))) p)\n         counter2  (partition-by identity counter)\n         only-trues (filter #(true? (first %)) counter2)\n         count-nrs (map count only-trues)\n         max-seq (last (sort count-nrs))\n         idx (map #(list % %2 (count %))  counter2 (range))\n         [[_ idx2]] (filter (fn [[f]] (and (true? (first f)) (= (count f) max-seq)))  idx)    ]\n     (if (nil? max-seq)\n       []\n       (let [start (reduce + (map (fn [[_ _ x]] x) (take idx2 idx)))]\n         (subvec xs start (+ start max-seq 1)))))\n   )","user":"5a8e9a7ae4b05369db4d2528"},{"code":"(fn [l] \n  (->> \n    (map #(list %1 %2) (rest l) (butlast l))\n    (map (fn [[x y]] (= x (inc y))))\n    (partition-by identity)\n    (reduce \n      (fn [pl l] \n        (let [len1 (count l)\n              len2 (if (first l) len1 0)\n              [[_ ps pe] & _] pl]\n          (cons [len2 pe (+ len1 pe)] pl))) '([0 0 0]))\n    (sort-by #(- (first %)))\n    first\n    ((fn [v]\n       (if (zero? (first v))\n         []\n         (take (inc (first v)) (drop (second v) l)))))))","problem":53,"user":"4ff5744ae4b0678c553fc36a"},{"problem":53,"code":"(fn\n  [vect]\n  (let\n  \t[a (partition-by #(< (first %) (last %)) (partition 2 1 vect))\n     b (sort-by #(- (* (count a) (count %)) (.indexOf a %)) a)\n     c (drop 1 b)]\n    (-> c\n        last\n        flatten\n        distinct\n        vec)))","user":"59733c91e4b01722bebd4c9b"},{"problem":53,"code":"(fn [numbers]\n  (loop [numbers numbers\n         acc '()\n         res '()]\n    (if (seq numbers)\n      (let [next-number (first numbers)\n            last-number (first acc)]\n        (if (or (nil? last-number) (= next-number (inc last-number)))\n          (recur (rest numbers) (conj acc next-number) res)\n          (if (> (count acc) (count res))\n            (recur (rest numbers) (list next-number) (reverse acc))\n            (recur (rest numbers) (list next-number) res))))\n      (let [rc (count res)\n            ac (count acc)]\n        (vec\n         (cond\n           (< (max rc ac) 2) nil\n           (> rc ac) res\n           :else (reverse acc)))))))","user":"500e6ddee4b04a05d36fcc06"},{"problem":53,"code":"(fn longest-seq [[first-n & s]]\n  (let [result\n        (reduce (fn [m n]\n                  (cond (= (dec n) (last (:current-seq m)))\n                        (assoc m :current-seq (conj (:current-seq m) n)) ;current seq\n                        (> (count (:current-seq m)) (count (:longest-seq m)))\n                        (assoc {:current-seq [n]}\n                               :longest-seq\n                               (:current-seq m))\n                        :else (assoc  m :current-seq [n])))\n                {:current-seq [first-n]\n                 :longest-seq [first-n]}\n                s)]\n    (cond (> (count (:current-seq result)) (count (:longest-seq result)))\n          (:current-seq result)\n          (= 1 (count (:longest-seq result))) []\n          :else (:longest-seq result))))","user":"51a3be77e4b0e77c4ca60bf8"},{"code":"(fn [l]\n  (let [f (fn [a i]\n                     (if (= 1 (- i (last (last a))))\n                       (concat (butlast a) [(concat (last a) [i])])\n                       (concat a [[i]]))\n                     )\n        p (reduce f [[(first l)]] (rest l))\n        m (apply max (map count p))]\n    (into [] (some #(if (and (< 1 m) (= m (count %))) %) p))\n))","problem":53,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn [xs]\n        (loop [xs xs, seq [], seqs []]\n          (cond (empty? xs)\n                (loop [seqs (cons seq seqs), longest []]\n                  (cond (empty? seqs)\n                        (reverse longest)\n\n                        (and (>= (count (first seqs)) 2)\n                             (>= (count (first seqs)) (count longest)))\n                        (recur (rest seqs) (first seqs))\n\n                        :else\n                        (recur (rest seqs) longest)))\n                \n\n                (or (empty? seq)\n                    (> (first xs) (first seq)))\n                (recur (rest xs) (cons (first xs) seq) seqs)\n                \n                :else\n                (recur (rest xs) [(first xs)]\n                       (cons seq seqs)))))","problem":53,"user":"5055e7f4e4b0ce54f56f0401"},{"code":"(fn [coll] (reduce\n\t\t   #(let [max (if (> (count %1) (count %2)) %1 %2)]\n\t\t      (if (> (count max) 1)\n\t\t\tmax\n\t\t\t[]))\n\t\t   (reduce\n\t\t    #(let [n (last (last %1))]\n\t\t       (if (and n (= (inc n) %2))\n\t\t\t (update-in %1 [(dec (count %1))] conj %2)\n\t\t\t (conj %1 [%2])))\n\t\t    [] coll)))","problem":53,"user":"51937eb3e4b04df54c098022"},{"problem":53,"code":"#(loop [ arr (rest %) cur [(first %)] lon [] ]\n   (if (empty? arr)\n     (if (> (count cur) (max (count lon) 1))\n         cur\n         lon\n         )\n     (if (> (first arr) (last cur))\n       (recur (rest arr) (conj cur (first arr)) lon)\n       (if (> (count cur) (max (count lon) 1))\n         (recur (rest arr) [(first arr)] cur)\n         (recur (rest arr) [(first arr)] lon)\n         )\n       )\n     )\n   )","user":"5b3aa98be4b02d533a91bbca"},{"code":"(fn [x]\n\t(let \n\t[l\n\t\t(map (fn [w] (last w))\n\t\t\t(last\n\t\t\t\t(sort-by count\n\t\t\t\t\t(filter (fn [z] (= (first (first z)) 1))\n\t\t\t\t\t\t(partition-by \n\t\t\t\t\t\t\t(fn [z] (= 1 (first z))) \n\t\t\t\t\t\t\t(map \n\t\t\t\t\t\t\t\t(fn [y] (vector (- (second y) (first y)) (second y))) \n\t\t\t\t\t\t\t\t(partition 2 (interleave (conj (drop-last x) (first x)) x))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t]  (if (empty? l) [] (conj  l (dec (first l))) )\n\t)\n)","problem":53,"user":"5296008fe4b02ebb4ef7502a"},{"code":"(fn [coll]\n  (letfn [(aux [[hcoll & tcoll :as coll] [[hssq :as hssqs] & tssqs :as ssqs]]\n               (if (and (empty? ssqs)\n                        (empty? coll))\n                 (empty coll)\n                 (if (empty? coll)\n                   (let [subseq (reverse (first (reverse (sort-by #(count %) ssqs))))]\n                     (if (>= (count subseq) 2)\n                       subseq\n                       (empty coll)))\n                   (if (or (empty? ssqs)\n                           (< hcoll (first hssqs))\n                           (= hcoll (first hssqs)))\n                     (recur (rest coll) (cons (cons hcoll (empty coll)) ssqs))\n                     (if (> hcoll (first (first ssqs))) \n                       (recur tcoll (cons (cons hcoll hssqs) tssqs)))))\n                 ))]\n    (aux coll (empty coll))))","problem":53,"user":"505b9084e4b032b709c81371"},{"problem":53,"code":"(fn conse_inc([_seq]\n\t(conse_inc _seq [] []))\n\t([_seq running _max]\n\t\t(if (empty? _seq)\n\t\t\t_max\n\t\t\t(if (and (not (nil? (second _seq)))(< (first _seq) (second _seq)))\n\t\t\t\t(recur (rest _seq) (conj running (first _seq)) _max)\n\t\t\t\t(recur (rest _seq) [] \n\t\t\t\t\t(let [new_running (conj running (first _seq))]\n\t\t\t\t\t(if (and (> (count new_running) 1)(< (count _max)(count new_running)))\n\t\t\t\t\t\tnew_running\n\t\t\t\t\t\t_max)))))))","user":"5954eef0e4b066ee0a44af17"},{"problem":53,"code":"(fn[o](\n(fn[z](if(> (count z)1) z [] ))        \n(apply max-key count(\n                     map-indexed  \n                           (fn[idx itm](\n                                         (fn[s](\n                              loop [ s2 [(first s)] i 1 ](\n                                                           if(= i (count s)) s2\n                                                           (if (= (nth s i) (inc(last s2)) ) \n                                                                                                   (recur (conj s2 (nth s i)) (inc i) )\n                                                                                                   s2\n                                                                                )\n                                                           ))\n                                         )\n                                         (take-last (- (count o) idx) o)\n                                         ))\n                           o\n))\n\n))","user":"56039843e4b04bb52996e1be"},{"problem":53,"code":"(fn [ls]\n           (:best\n             (reduce (fn [acc v]\n                       (let [{:keys [best curr]} acc\n                             curr (if (or (empty? curr)\n                                          (= v (inc (last curr))))\n                                    (conj curr v)\n                                    [v])\n                             best (if (and (> (count curr) (count best))\n                                           (> (count curr) 1))\n                                    curr\n                                    best)]\n                         {:best best :curr curr})\n                       ) {:best [] :curr []} ls)))","user":"530b8580e4b02e82168697cc"},{"problem":53,"code":"#(distinct(flatten (apply max-key count '()\n           (reverse (take-nth 2 \n             (partition-by \n               (partial apply <) \n               (drop-while \n                 (partial apply >) \n                 (map vector % (rest %)))))))))","user":"57b1b8c8e4b0fbc9809a2756"},{"problem":53,"code":"(fn [s] ((fn [cv rs] (if (empty? rs) cv (let [nv (mapv (fn [p] (p 0)) (take-while (fn [p] (= (p 0) (p 1))) (map (fn [e i] [e i]) rs (iterate (fn [e] (inc e)) (first rs))))) nvc (count nv) cvc (count cv)] (recur (if (and (> nvc 1) (> nvc cvc)) nv cv) (drop nvc rs))))) [] s))","user":"5abe2fc2e4b073f17744271e"},{"problem":53,"code":"(fn [s]\n      (loop [lng []\n             cur []\n             s s]\n        (let [x (first s)\n              non-inc? #(and (not (empty? cur))\n                             (<= x (last cur)))\n              new-lng  #(if (> (count cur) (count lng)) cur lng)]\n          (cond\n            (empty? s) (let [longest (new-lng)]\n                         (if (< (count longest) 2) [] longest))\n            (non-inc?) (recur (new-lng)\n                              [x]\n                              (rest s))\n            :else      (recur lng\n                              (conj cur x)\n                              (rest s))))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":53,"code":"(fn [l]\n  (if (->> l count (> 2))\n    [] \n    (loop [[fir & rest] (next l) cnt 0 accu [(first l)] longest []]\n      (if (nil? fir)\n        longest\n        (if (> fir (last accu))\n          (if (->> accu count inc (< (count longest)))\n            (recur rest (inc cnt) (conj accu fir) (conj accu fir))\n            (recur rest (inc cnt) (conj accu fir) longest))        \n          (recur rest (inc cnt) [fir] longest))))))","user":"581e61b0e4b04b46fc4b0f28"},{"problem":53,"code":"(fn _53_ [coll] \n  (letfn [(acsubs [coll]\n            (reductions (fn [iter v]\n                          (cond\n                            (empty? iter) [v]\n                            (<= v (last iter)) [v]\n                            :else (conj iter v)))\n                        [] coll))\n          (max-subs [acsubs]\n            (apply max-key count (reverse acsubs)))\n          (over2 [sub]\n            (if (>= (count sub) 2) sub []))]\n    (over2 (max-subs (acsubs coll)))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":53,"code":"(fn [coll]\n  (let [sub-coll (loop [orig coll, current [], result []]\n                   (if (empty? orig)\n                       (conj result current)\n                       (let [[h & t] orig, l (last current)]\n                              (if (or (nil? l) (< l h))\n                                  (recur t (conj current h) result)\n                                  (recur t (vector h) (conj result current)))))),\n        subseq-coll (filter #(> (count %) 1) sub-coll)]\n    (if (empty? subseq-coll)\n        []\n        (->> subseq-coll\n             (group-by count)\n             (sort-by key)\n             last\n             val\n             first))))","user":"567695c2e4b05957ce8c6157"},{"problem":53,"code":"(fn [xs]\n   (let [fst-biggest (fn [new [oldc oldv]]\n                       (if (> (count new) oldc) [(count new) new] [oldc oldv]))\n         [len seq]   (loop [acc      [0 []]\n                            curr     []\n                            prev     nil\n                            [x & xs] xs]\n                       (cond\n                         (nil? x)      (fst-biggest curr acc)\n                         (empty? curr) (recur acc [x] x xs)\n                         (< prev x)    (recur acc (conj curr x) x xs)\n                         :else         (recur (fst-biggest curr acc) [x] x xs)))]\n         (if (>= len 2)\n           seq\n           [])))","user":"57a4bb65e4b0a966079561eb"},{"code":"(fn li [input]\n  (let [res \n        (loop [subLists \n               (loop [input input acc []]\n                 (if (empty? input) \n                   acc\n                   (recur (rest input) \n                          (conj acc ((fn [lis res]\n                                       (if (= (second lis) (+ (first lis) 1))        \n                                         (recur (rest lis) (conj res (second lis)))      \n                                         res)) input [(first input)]))\n                          )                              \n                   )                 \n                 ) longest (first subLists)] \n          (if (empty? subLists) \n            longest\n            (if (> (count (first subLists))  (count longest))           \n              (recur (rest subLists) (first subLists))           \n              (recur (rest subLists) longest))\n     \n            ))] \n    ( if (< (count res) 2) [] res)             \n    )\n)","problem":53,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn [col]\n  (loop [coll (next col) largest [] current [(first col)]]\n    (if (seq coll)\n      (let [x (first coll)]\n      (if (= (dec x) (last current))\n        (let [nxt-current (conj current x)] \n        (recur (next coll) (last (sort-by count [largest nxt-current])) nxt-current))\n        (recur (next coll) largest [x])))\n      largest)))","problem":53,"user":"5084c43be4b0fb8f40674bfa"},{"problem":53,"code":"(fn [coll]\n    (loop [c (rest coll) cur-IS [(first coll)] longest-IS []]\n      ;(println c cur-IS longest-IS)\n      (if (empty? c)\n        longest-IS\n        ; Invariants:\n        ; c is the remains of the input collection we're looking at.\n        ; cur-IS is the current increasing subsequence.\n        ; longest-IS is the longest increasing subsequence we've seen so far.\n        (let [cur-item (first c)\n              last-seen (last cur-IS)]\n          (if (or (nil? last-seen) (= cur-item (inc last-seen)))\n            ; Now cur-IS is one longer, but check if it should be passed as\n            ; longest-IS as well.\n            (if (>= (count cur-IS) (count longest-IS))\n              (recur (rest c) (conj cur-IS cur-item) (conj cur-IS cur-item))\n              (recur (rest c) (conj cur-IS cur-item) longest-IS))\n            ; Not increasing, so reset cur-IS.\n            (recur (rest c) [cur-item] longest-IS))))))","user":"56eaad95e4b04a395b9a040f"},{"code":"(fn [arg]\n  (letfn [(fits? [s x]\n            (= (inc (last s)) x))\n          (longest [acc curr a-seq]\n            (cond\n             (empty? a-seq) (conj acc curr)\n             (fits? curr (first a-seq)) (recur acc (conj curr (first a-seq)) (rest a-seq))\n             :default (recur (conj acc curr) [(first a-seq)] (rest a-seq))))]\n    (reduce #(if(and (> (count %2) 1) (< (count %) (count %2))) %2 %) [] (longest [] [(first arg)] (rest arg)))))","problem":53,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":53,"code":"(fn [x]\n   (let [seq-map\n         (->> ((fn gen-seq\n               ([s] (gen-seq s 1))\n               ([s t] (cond\n                        (empty? s) nil\n                        (= (count s) t) (cons s (lazy-seq (gen-seq (rest s) 1)))\n                        :else (cons (take t s) (lazy-seq (gen-seq s (inc t))))))) x)\n            (filter (fn [e] (> (count e) 1)))\n            (filter (fn [e] (apply < e)))\n            (group-by count))\n         m-key (if (seq seq-map)\n                 (apply max (keys seq-map))\n                 nil)]\n     (vec (first (seq-map m-key)))))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [a]\n   (let\n       [lst ((fn [lst]\n               ((fn [candidate rest-vec candidates]\n                  (if (empty? rest-vec)\n                    (if (> (count candidate) 1)\n                      (conj candidates candidate)\n                      candidates)\n                    (if (> (first rest-vec) (last candidate))\n                      (recur (conj candidate (first rest-vec)) (rest rest-vec) candidates)\n                      (recur [(first rest-vec)]\n                             (rest rest-vec)\n                             (if (> (count candidate) 1)\n                               (conj candidates candidate)\n                               candidates))\n                      )\n                    )\n                  )\n                [(first lst)] (rest lst) []\n                  )\n               )\n             a)]\n     (or (some\n      #(if (= (apply max (for [x lst] (count x)))\n              (count %))\n         % false) lst)\n         [])\n    )\n   )","problem":53,"user":"52213426e4b0e6a83c8925c4"},{"problem":53,"code":"(fn longest-increasing-subsequence [[x & xs]]\n  (->> xs\n       (reduce #(if (>= (last %) %2) (conj % nil %2) (conj % %2)) [x])\n       (partition-by nil?)\n       (filter (comp not nil? first))\n       (filter #(< 1(count %)))       \n       (group-by count )       \n       (#(if-not (empty? %) (get % (apply max (keys %)))))\n       (first)\n       (vec)))","user":"58e37946e4b005f69f193cae"},{"problem":53,"code":"(fn [i] \n    (vec (last (sort (filter #(< 1 (count %))\n        (reduce \n            (fn [o n] \n                (if (= (dec n) (last (last o)))\n                    (assoc o (dec (count o)) (conj (last o) n))\n                    (conj o [n])))\n            []\n            i))))))","user":"5578f292e4b05c286339e08f"},{"problem":53,"code":"(fn [s]\n  (loop [s s\n         sub-vecs (vector (vector))]\n    (if (empty? s)\n      (let [longest (last (sort sub-vecs))]\n        (if (< (count longest) 2)\n          (vector)\n          longest))\n      (let [lv (last sub-vecs)\n            lvi (dec (count sub-vecs))]\n        (if (or (nil? (last lv)) (= (first s) (inc (last lv))))\n          (recur (rest s) (assoc sub-vecs lvi (conj lv (first s))))\n          (recur (rest s) (conj sub-vecs (vector (first s)))))))))","user":"5530b827e4b076ab5578f818"},{"problem":53,"code":"(fn\n  [coll]\n   (let [parts (for [n (range (count coll))] (drop n coll))\n        take-seq (fn [n pred coll]\n                   (let [hits (count (take-while #(apply pred %)\n                                                 (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        seqs (map (partial take-seq 2 #(< %1 %2)) parts)\n        longest-count (count (apply max-key count seqs))\n        longest (first (filter #(= (count %) longest-count) seqs))]\n    (if (< (count longest) 2)\n      []\n      longest)))","user":"57283dbce4b0c5bde472c154"},{"problem":53,"code":"(fn [coll] \n    (let [r (last (sort-by count (reduce \n    (fn [acc i] \n      (let [current (first acc)]\n      (if \n        (empty? current) (cons [i] (rest acc))\n        (if (> i (last current)) (cons (conj current i) (rest acc)) (cons [i] acc))\n        ) \n      ))\n    [[]] \n    coll)))]\n      (if (> (count r) 1) r []))\n  )","user":"55f2c898e4b06e875b46ce4b"},{"problem":53,"code":"(fn [s]\n  (let [red (reduce \n                (fn [acc item]\n                 (if (> item (last (:seq acc)))\n                   (if (> (inc (count (:seq acc))) (:max acc))\n                     ; new MAX\n                     {:seq (conj (:seq acc) item)\n                      :max (inc (count (:seq acc)))\n                      :best (conj (:seq acc) item)}\n                     ; not max yet\n                     (assoc acc :seq (conj (:seq acc) item)))\n                   ; reset\n                   (assoc acc :seq [item])))\n                {:seq [(first s)] :max 0 :best []}\n                s)]\n    (:best red)))","user":"55170dd9e4b06a49daca83bd"},{"problem":53,"code":"(fn inc-subseq [l]\n  (loop [head (first l),\n         tail (rest l),\n         prev (dec head),\n         items []\n         retval []]\n    (if (nil? head)\n      (let [final (conj retval items),\n            p (apply max-key count () (reverse final))]\n        (if (>= (count p) 2)\n           p\n           []))\n      (if (<= head prev)\n        (recur\n          head\n          tail\n          (dec head)\n          []\n          (conj retval items))\n        (recur\n          (first tail)\n          (rest tail)\n          head\n          (conj items head)\n          retval)))))","user":"561f9110e4b064ca9f4b16ce"},{"code":"(fn [s]\n  (letfn \n    [(by-count [a b]\n       (let [ca (count a)\n             cb (count b)]\n         (cond\n         (< (max ca cb) 2) []\n         (= ca cb) a\n         (< ca cb) b\n         (> ca cb) a)))]\n    (loop [longest []\n           cand    []\n           [h & t :as l] s]\n      (if (empty? l)\n         (by-count longest cand)\n         (if (or (empty? cand)\n                (< (last cand) h))\n            (recur longest (conj cand h) t)\n            (recur (by-count longest cand)\n                   [h]\n                    t))))))","problem":53,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":53,"code":";; This is the most obscure way ever, sorry\n(fn [input] (let [x (sort (set (flatten (reduce (fn [acc v] (if (>= (count acc) (count v)) acc v))  (partition-by #(>= (first %) (second %)) (partition 2 1 input))))))] (if (= x (sort input)) [] x)))","user":"54c13b87e4b0ed20f4ff6f20"},{"code":"(fn [s]\n  (let [all-subseqs (take-while #(not (empty? %)) (iterate rest s))\n        ideal-increasing-seq (fn [s] (take (count s) (iterate inc (first s))))\n        increasing-part (fn [s]\n                          (map first\n                               (take-while (fn [[a b]] (= a b)) (map vector s (ideal-increasing-seq s)))))\n        increasing-subseqs (filter #(> (count %) 1) (map increasing-part all-subseqs))]\n    (or (last (sort-by count increasing-subseqs)) [])))","problem":53,"user":"4db86aee535d1e037afb2193"},{"problem":53,"code":"(fn [coll]\n  (let \n    [max-chain (fn [pred coll]\n        (->> [(loop [acc [(first coll)] coll (rest coll)]\n          (let [head (first coll)\n                prev (last acc)]\n            (if head\n              (if (pred prev head)\n                (recur (conj acc head) (rest coll))\n                acc)\n            acc)))] (filter #(> (count %) 1)) flatten vec))\n     longest (fn [colls] (->> colls\n        (sort-by #(- (count %)))\n        first))\n     chains (->> (-> coll count range)\n       (map #(drop % coll))\n       (map #(or (max-chain < %) [])))]\n  (longest chains)))","user":"540e97f9e4b0addc1aec671f"},{"code":"(fn [lst] (last (sort-by count\n\t((fn lis [xs] (concat \n\t\t(let [re []]\n \t\t\t(for [lg (range (count xs) 1 -1)]\n\t\t\t\t(if (= (take lg xs) (range (first xs) (+ (first xs) lg)))\n\t\t \t\t\t(take lg xs)\n\t\t\t\t\t[])))\n\t\t(if (not (empty? (rest xs))) (lis (rest xs)))) \n\t) lst))))","problem":53,"user":"51c09719e4b0c9c82288293c"},{"problem":53,"code":"(fn [coll]\n   (->> (map #(- %1 (dec %2)) coll (rest coll))\n       (reductions + 0)\n       (map list coll)\n       (partition-by second)\n       (map (partial map first))\n       (filter #(> (count %) 1))\n       (group-by count)\n       (into (sorted-map-by >))\n       first\n       second\n       first\n       vec))","user":"54b972bbe4b0ed20f4ff6ead"},{"code":"(fn long-incr-subseq [c]\n  (loop [coll c best [] cur []]\n    (cond (empty? coll) (if (> (count cur) (count best))\n                          (if (>= (count cur) 2) cur [])\n                          (if (>= (count best) 2) best []))\n          (empty? cur) (recur (rest coll) best (conj cur (first coll)))\n          (>= (last cur) (first coll))\n          (if (> (count cur) (count best))\n            (recur (rest coll) cur [(first coll)])\n            (recur (rest coll) best [(first coll)]))\n          :else\n          (recur (rest coll) best (conj cur (first coll))))))","problem":53,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn [xs]\n    (loop [l xs c [(first xs)] m []]\n      (let [e (first l)\n            p (last c)\n            new (conj c e)]\n        (if (empty? l)\n          m\n          (if (< p e)\n            (recur (rest l) new (if (and (> (count new) 1) (> (count new) (count m))) (conj c e) m))\n            (recur (rest l) [e] m))))))","problem":53,"user":"52b9c62ce4b07a9af57922c3"},{"code":"(fn [x]\n(or\n (->>\n   (take-while seq (iterate rest x))\n   (mapcat #(take-while seq (iterate butlast %)))\n   (filter #(and (apply < %) (next %)))\n   (sort-by (comp - count))\n   (first))\n []))","problem":53,"user":"502952c9e4b0b33e9bf6fdf1"},{"code":"(fn ! [s]\r\n  (let [a (map-indexed #(hash-map %1 %2) s)\r\n        b (group-by #(- (first (keys %)) (first (vals %))) a)\r\n\t      c (sort-by #(count (fnext %)) b)\r\n\t      d (fnext (last c))\r\n\t      e (reverse (reduce into (map vals d)))]\r\n\t     (if (= (count e) 1) [] e)))","problem":53,"user":"4e8a460e535d65386fec2109"},{"problem":53,"code":"(fn [coll]\n  (let [longest-subseq (:best-so-far\n                         (reduce\n                           (fn [{:keys [candidate-in-progress best-so-far]} i]\n                             (if (or (empty? candidate-in-progress) (> i (peek candidate-in-progress)))\n                               (let [new-candidate (conj candidate-in-progress i)\n                                     new-best-so-far (if (> (count new-candidate)\n                                                            (count best-so-far))\n                                                       new-candidate\n                                                       best-so-far)]\n                                 {:best-so-far new-best-so-far\n                                  :candidate-in-progress new-candidate})\n                               {:best-so-far best-so-far\n                                :candidate-in-progress [i]}))\n                           {:best-so-far, []\n                            :candidate-in-progress, []}\n                           coll))]\n    (if (>= (count longest-subseq) 2)\n      longest-subseq\n      [])))","user":"4dd88803535d2dad7130b5d9"},{"code":"(fn [coll]\n    (let [is-increasing? (fn [coll] (every? #(< (first %) (last %)) (map vector coll (drop 1 coll))))\n          drop-count (fn [n] (take (dec n) (iterate inc 0)))\n          max-vec (fn [coll]\n                    (reduce #(max % (count %2)) 0 coll))\n          subsequences (fn [coll]\n                        (apply concat (let [c (count coll)]\n                          (for [d (drop-count c)]\n                            (filter #(>= (count %) 2) (take (- c d) (iterate pop (vec (drop d coll)))))))))]\n    \n    (or (let [subseqs (filter is-increasing? (subsequences coll))\n          max-n (max-vec subseqs)]\n      (first (filter #(= (count %) max-n) subseqs))) [])))","problem":53,"user":"52c61564e4b0c2d177d62109"},{"problem":53,"code":"(fn xx [coll]\n  (loop [ll []\n         cl [(first coll)]\n         nc (next coll)]\n    (if-not nc\n      (if (> (count cl) (count ll) 1) cl ll)\n      (if (= (inc (last cl)) (first nc))\n        (recur ll (conj cl (first nc)) (next nc))\n        (if (and (> (count cl) 1) (> (count cl) (count ll)))\n          (recur cl [(first nc)] (next nc))\n          (recur ll [(first nc)] (next nc)))))))","user":"56102f50e4b05f002753df6b"},{"problem":53,"code":"(fn [lst]\n  (let [\n    ; Generating all subsequences of the list,\n    ; and leaving ordered sequences only\n    subpartitions (for [i (range (inc (count lst)) 1 -1)]\n                    (filter #(apply < %) (partition i 1 lst)))\n    ; Grouping them by their respective size\n    seqs (group-by #(count %) (map first subpartitions))\n    ; Finally, selecting the longest ordered subsequence\n    max-seq (last (get seqs (apply max (keys seqs))))]\n    (if (> (count max-seq) 1)\n      max-seq\n      [])))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn [s]\r\n  (letfn \r\n    [(reducer [[largest current] n]\r\n      (if (> n (or (first current) 0))\r\n        [largest (cons n current)]\r\n        (if (> (or (count current) 0) (or (count largest) 0))\r\n          [current (list n)]\r\n          [largest (list n)])))]\r\n    (reverse\r\n      (let [[one two :as r] (reduce reducer [[][]] s)]\r\n        (cond\r\n          (and (> 2 (or (count one) 0)) (> 2 (or (count two) 0))) '()\r\n          (>= (count one) (count two)) one\r\n          :else two)))))","problem":53,"user":"4e02bee8535d04ed9115e791"},{"problem":53,"code":"(fn [c]\n  (let [s (reduce (fn [m o]\n            (if (< (last (m :r)) o)\n              (update-in m [:r] conj o)\n              (update-in (update-in (update-in m [:w] conj (m :r)) [:r] empty) [:r] conj o)\n              )\n            ) {:w [] :r [(first c)]} (rest c))]\n    (reduce (fn [m o]\n              (if (and (> (count o) 1) (> (count o) (count m)))\n                o\n                m\n                )\n              ) [] (conj (s :w) (s :r)))\n    )\n  )","user":"53ae16e2e4b047364c044472"},{"problem":53,"code":"(fn [coll]\n  (let [increasing? (fn [xs] (apply < xs))\n        n (count coll)\n        sub-seqs (mapcat #(partition % 1 coll) (range 2 (inc n)))]\n    (->> sub-seqs\n      (filter increasing?)\n      (cons [])\n      (sort-by count >)\n      first)))","user":"54d70bbfe4b0a52adc2e2026"},{"code":"(fn seqs [coll] (let [long-seqs ; Map of longest sub-seqs against longest length\r\n  (first (sort\r\n\t\t(fn [x y] (compare (key y) (key x))) ; Reverse comparison for largest length 1st\r\n\t\t(group-by count ; Map against length\r\n\t\t\t(reduce ; Get a list of the sequences\r\n\t\t\t\t(fn [result node]\r\n\t\t\t\t\t(cond \r\n\t\t\t\t\t  (empty? result) (vector (vector node)) ; 1st sequence\r\n\t\t\t\t\t  (> node (last (last result))) (conj (pop result) (conj (last result) node)) ; Add to current sequence\r\n\t\t\t\t\t  :default (conj result (vector node)))) ; Start new sequence\r\n\t\t\t  []\r\n\t\t\t  coll))))]\r\n\t(cond\r\n\t\t(< (first long-seqs) 2) []\r\n\t\t:default (first (second long-seqs)))))","problem":53,"user":"4f1abbfb535d64f60314646e"},{"problem":53,"code":"(fn [coll]\n  (reverse\n  (loop [c (drop 1 coll), winner [], challenger (take 1 coll)]\n    (if (empty? c)\n      winner\n      (if (> (first c) (first challenger))\n        (let [next-challenger (conj challenger (first c))\n              next-winner (max-key count next-challenger winner)]\n            (recur (rest c) next-winner next-challenger))\n        (recur (rest c) winner (take 1 c)))))))","user":"56174d86e4b06b1bb2182a0e"},{"problem":53,"code":"(fn [s]\n    (letfn [(increasing? [s] (apply < s))\n\n            (increasing-subseq\n              [s]\n              (loop [s s]\n                (if (seq s)\n                  (if (increasing? s)\n                    (vec s)\n                    (recur (take (dec (count s)) s)))\n                  [])))\n\n            (all-increasing-subseqs\n              [s]\n              (loop [s s\n                     acc []]\n                (if (seq s)\n                  (recur (rest s)\n                         (conj acc (increasing-subseq s)))\n                  acc)))\n\n            (best-increasing-subseq\n              [s]\n              (loop [qualifiers (all-increasing-subseqs s)\n                     best nil]\n                (if (seq qualifiers)\n                  (recur (rest qualifiers)\n                         (if (> (count (first qualifiers))\n                                (count best))\n                           (first qualifiers)\n                           best))\n                  (if (> (count best) 1)\n                    best\n                    []))))]\n      (best-increasing-subseq s)))","user":"52485f02e4b05ef8e38e63d3"},{"problem":53,"code":"(letfn [(all-increasing-subsequences\n          [coll]\n          (lazy-seq\n            (when (seq coll)\n              (let [[next-result remainder] (->> (map vector (concat [Integer/MIN_VALUE] coll) coll)\n                                                 ;; Split the sequence whenever the next item isn't greater than the former\n                                                 (split-with (fn [[x y]] (< x y)))\n                                                 ;; Unpair every item\n                                                 (map (partial map second)))]\n                (cons next-result (all-increasing-subsequences remainder))))))]\n  (fn [items]\n    (let [subs (->> items\n                    ;; Get all the increasing sequences\n                    all-increasing-subsequences\n                    ;; Sort them in descending length\n                    (sort-by (comp (partial * -1) count))\n                    ;; Exclude those of length 1 or less\n                    (filter (comp (partial < 1) count)))]\n      (if (seq subs)\n        (first subs)\n        []))))","user":"51f01925e4b0249c592fbdfc"},{"code":"(fn [s] (let [a (apply max-key count\n    (reverse (rest (reduce\n        #(let [p (last (flatten %1))]\n           (if (> %2 p)\n             (apply vector\n                    (concat (butlast %1) [(conj (last %1) %2)]))\n             (conj %1 [%2])))\n        [[99]]\n        s))))]\n  (if (= 1 (count a)) [] a)\n))","problem":53,"user":"50361b6be4b0fbe0a74d26be"},{"problem":53,"code":"(fn [coll]\n  (let [next? (fn [[x y]]\n                (= (- y x) 1))\n        sequences (fn [xs]\n                    (loop [xs xs\n                           acc []]\n                      (if (empty? xs)\n                        acc\n                        (recur (drop-while (complement next?) (drop-while next? xs)) (conj acc (take-while next? xs))))))]\n    (distinct (mapcat identity (apply max-key count (sequences (partition 2 1 coll)))))))","user":"5a250b86e4b07f18be40aa19"},{"problem":53,"code":"(fn [seq]\r\n  (loop [seq seq\r\n         current []\r\n         longest []]\r\n    (if (empty? seq)\r\n      (if (>= (count longest) 2) longest [])\r\n      (let [[head & tail] seq\r\n            new-current (if (or\r\n                (empty? current)\r\n                (> head (last current)))\r\n              (conj current head)\r\n              [head])]\r\n          (recur tail new-current\r\n            (if (> (count new-current)\r\n              (count longest))\r\n              new-current longest))))))","user":"555bd27ae4b0b056612e2244"},{"code":"; not proud of this code - take-while looks promising\n(fn [coll] \n  (first \n   (filter #(not= (count %) 1) \n           (sort #(> (count %1)(count %2)) \n                 (reduce (fn [res new] \n                           (println res new) \n                           (conj res (if (= (dec new) (last (last res))) (conj (last res) new) [new]))) \n                         [[]] coll)))))","problem":53,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn longest [xs] (let [seqs (reductions\n                                (fn [lst, x] (if (empty? lst)\n                                     \t\t\t [x]\n                                                 (if (> x (last lst))\n                                                     (conj lst x)\n                                                     [x]\n                                                 )\n\t\t\t                                 )\n           \t                    )\n                                []\n                                xs\n                            )\n                       my-max (reduce #(if (> (count %2) (count %1)) %2 %1) seqs)\n                       ]\n                       (if (< (count my-max) 2) [] my-max)\n                        \n                   )\n  )","problem":53,"user":"52bf8e35e4b07a9af579233a"},{"code":"#(loop [sres 0 eres 0 sbuffer 0 ebuffer 1]\n\t\t (cond (and (= ebuffer (count %1)) (= 1 (max (- ebuffer sbuffer)(- eres sres))))  [] \n\t\t\t   (= ebuffer (count %1)) (if (> (- ebuffer sbuffer)(- eres sres)) (subvec %1 sbuffer ebuffer) (subvec %1 sres eres))\t\t \t       \n\t\t       (= (nth %1 ebuffer)  (+ 1 (nth %1 (- ebuffer 1)))) (recur sres eres sbuffer (inc ebuffer))  \n   \t\t       (> (- ebuffer sbuffer) (- eres sres) )    \t\t  (recur  sbuffer ebuffer ebuffer (inc ebuffer))       \n\t\t       :else                                              (recur sres eres ebuffer (inc ebuffer))))","problem":53,"user":"52f5eefbe4b09b582c12c9cb"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n       (#(let [switch (reductions not= true (map (fn [a b] (not= b (inc a))) % (rest %)))]\n          (map (partial map first) (partition-by second (map list % switch)))))\n       (filter (fn [a] (>= (count a) 2)))\n       (reduce\n        (fn [cur next]\n          (if (> (count next) (count cur))\n              next\n              cur))\n        [])))","user":"56677192e4b04acd4f672dd5"},{"code":"(fn [x]\n  (let [x2 (into [-1] x) \n        grp (atom 0)\n        ss (partition-by #(if (< (x2 (% 0)) (x2 (inc (% 0)))) @grp (reset! grp (inc @grp))) (map-indexed #(vec [% %2]) x))\n        os (sort-by count > (filter #(> (count %) 1) ss))]\n    (map #(% 1) (first os))))","problem":53,"user":"5093ca51e4b097f48cc38585"},{"code":"(fn longest [s]\n  (let [monotonic-sequences (partition-by (partial apply <) (partition 2 1 s))\n        increasing-sequences (filter #(apply < (first %)) monotonic-sequences)\n        max-length (if (empty? increasing-sequences) 0 (apply max (map count increasing-sequences)))\n        first-longest (first (filter #(= max-length (count %)) increasing-sequences))]\n    (if (seq? first-longest) (cons (first (first first-longest)) (map second first-longest)) '())))","problem":53,"user":"51729002e4b044b2ef48a850"},{"problem":53,"code":"(fn [xs]\n              (loop [xs xs best [] cur [] prev nil]\n                (let [i (first xs)\n                      next (rest xs)\n                      now (if (> (count cur) (count best)) cur best)\n                      now (if (> (count now) 1) now [])]\n                  (cond\n                    (empty? xs) now\n                    (or (nil? prev) (> i prev)) (recur next best (conj cur i) i)\n                    :default (recur next now [i] i)))))","user":"4f9aa2a6e4b0dcca54ed6d0c"},{"problem":53,"code":"(fn longest-conseq [s]\n  (let [best (atom [])]\n    (doseq [[i e] (map vector (range) s)] \n      (loop [cur [e]\n             r (drop (inc i) s)] \n        (if (and r \n                 (= (inc (last cur))\n                    (first r)))\n          (recur (conj cur (first r))\n                 (next r))\n          (if (and\n               (> (count cur) 1)\n               (> (count cur) (count @best)))\n            (reset! best cur)))))\n    @best))","user":"523578efe4b0a643f2dcb74c"},{"code":"(fn [x] (->> \n\t(partition 2 1 x) \n\t(partition-by #(apply - %))\n\t(filter (fn [a] (every? #(= (apply - %) -1) a)))\n\t(reduce #(if (> (count %2) (count %1)) %2 %1) '())\n\t(flatten)\n\t(distinct)\n\t))","problem":53,"user":"52cdb7efe4b07d0d72b2737c"},{"problem":53,"code":"(fn\n  [coll]\n  (second (reduce (fn [[current longest] num]\n                    (if current\n                      (if (> num (last current))\n                        (let [new-current (conj current num)]\n                          [new-current (if (and (> (count new-current) (count longest))\n                                                (> (count new-current) 1))\n                                         new-current\n                                         longest)])\n                        [[num] longest])\n                      [[num] []]))\n                  nil coll)))","user":"559fb147e4b0acc240e314ea"},{"problem":53,"code":"(fn [ar]\n  (let [sub (loop [ret []\n                   last-ret nil\n                   leftover ar\n                   max-ret nil]\n              (if (not (seq leftover))\n                max-ret\n                (if (nil? max-ret)\n                  (let [beg (first leftover)\n                        first-run (conj ret beg)]\n                    (recur first-run beg (rest leftover) first-run))\n                  (let [curr (first leftover)\n                        ret (if (= (inc last-ret) curr)\n                              (conj ret curr)\n                              [curr])\n                        max-ret (if (> (count ret) (count max-ret))\n                                  ret\n                                  max-ret)]\n                    (recur ret curr (rest leftover) max-ret)))))]\n    (if (>= (count sub) 2)\n      sub\n      [])))","user":"5cf48f04e4b087f62be35a86"},{"problem":53,"code":"(fn [s] (reduce #(if (and (> (count %2) 1) (> (count %2) (count %))) %2 %) [] (reduce #(if (= (inc (last (last %))) %2) (conj (pop %) (conj (last %) %2)) (conj %  (vector %2))) [[9]] s)))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [s]\r\n  (loop [max-seq [(first s)] current-seq [(first s)] i 1]\r\n    (if (= i (count s))\r\n      (if (< 1 (count max-seq)) \r\n          max-seq\r\n          [])\r\n      (let [num (nth s i)]\r\n        (if (= (inc (last current-seq)) num)\r\n          (if (= (count max-seq) (count current-seq))\r\n            (recur (conj current-seq num) (conj current-seq num) (inc i))\r\n            (recur max-seq (conj current-seq num) (inc i)))\r\n          (recur max-seq [num] (inc i)))))))","problem":53,"user":"4df3df8a535d08e6dec9fe2d"},{"code":"(fn myfun2 [lst]\n  (letfn [(consecutive? [[a b]] (= (- b a) 1))]\n             (->> (partition 2 1 lst)\n                  (drop-while (comp not consecutive?))\n                  (partition-by consecutive?)\n                  (take-nth 2)\n                  (sort-by (comp - count))\n                  (first)\n                  (flatten)\n                  (distinct))))","problem":53,"user":"527236d4e4b03e8d9a4a741f"},{"problem":53,"code":"(fn [col]\n    (let [pairs (partition 2 1 col)\n          chunks (partition-by (fn [[x y]] (> y x)) pairs)\n          mapped (map (fn [[x y]] (> y x)) pairs )\n          sorted (sort (fn [x y] (compare (count y) (count x))) chunks)\n          best-chunk (first sorted)\n          ]\n      (if (empty? (filter true? mapped))\n        []\n        (concat (map first best-chunk) [(second (last best-chunk))]))))","user":"5d89427ae4b0915913b1d3b5"},{"code":"(fn [a]\n  (vec (first (sort-by count > (remove #(< (count %) 2)\n                                  (loop [a (seq a) b [] c []]\n                                    (if a\n                                      (let [d (first a)]\n                                        (if (= (dec d) (peek b))\n                                          (recur (next a) (conj b d) c)\n                                          (recur (next a) [d] (conj c b))))\n                                      (conj c b))))))))","problem":53,"user":"4e68be01535d8ccf87e9fe88"},{"problem":53,"code":"(fn [xs] (->> (map - (rest xs) (butlast xs))\n                    (map #(if (= 1 %) 1 0))\n                    reverse\n                    (reduce #(conj %1 (if (= 1 %2)\n                                        (if (last %1) (inc (last %1)) 1) 0)) [])\n                    reverse\n                    ((fn [x] (map #(if (= % (apply max x)) % 0) x)))\n                    (reduce #(if (seq? %1) %1\n                             (if-not (zero? %2) (take (inc %2) (drop %1 xs)) (inc %1))) 0)\n              \t\t((fn [x] (if (seq? x) x [])))\n                    ))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":53,"code":"(fn [xs]\n    (let [f1 (fn f1 [xs]\n          (if (= xs '())\n            '()\n            (cons (list (first xs)) (map (partial cons (first xs)) (f1 (rest xs))))))\n        f2 (fn f2 [xs]\n          (if (= xs '())\n            '()\n            (concat (f1 xs) (f2 (rest xs)))))\n        f3 (fn f3 [xs]\n          (filter #(and (apply < %1) (< 1 (count %1))) (f2 xs)))\n        f4 (fn f4 [xs]\n          (first (sort #(compare (count %2) (count %1)) (f3 xs))))\n          ans (f4 xs)]\n      (if (nil? ans) '() ans)))","user":"56761ab1e4b05957ce8c6154"},{"problem":53,"code":"(fn increasing-sub-seq [xs]\n  (letfn [(fn1 [xs] (partition 2 1 xs))\n          (fn2 [xs]\n            (partition-by #(= 1 (- (last %) (first %))) xs))\n          (fn3 [xs]\n            (filter #(every? (partial apply <) %) xs))\n          (fn4 [xs]\n            (reduce\n             #(if (> (count %) (count %2)) % %2)\n             []\n             xs))\n          ;;((6 7)(7 8))\n          (fn5 [xs]\n            (if (empty? xs) [] (-> xs first first\n                                   (cons (map last xs)))))]\n    (-> xs fn1 fn2 fn3 fn4 fn5)))","user":"5a4443cae4b0447ef91cc60f"},{"code":"(fn [s]\n  (let\n      [subvecs (for [x (range (inc (count s)))\n                     y (reverse (range (inc x) (inc (count s))))]\n                 (subvec s x y))\n       increasing-subvecs (filter #(and (apply < %) (> (count %) 1)) subvecs)\n       max-count (apply max 2 (map count increasing-subvecs))\n       biggest-increasing-subvecs (filter (comp (partial = max-count)\n                                                count)\n                                          increasing-subvecs)]\n    (if (empty? biggest-increasing-subvecs) [] (first biggest-increasing-subvecs))))","problem":53,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"#(letfn [(bestv [v1 v2]\n           (if (and (>= (count v1) 2)\n                    (> (count v1)\n                       (count v2)))\n             v1\n             v2))]\n   (loop [[x & tail] %\n          v1 (if x [x] [])\n          v2 []]\n     (if tail\n       (if (> (first tail) x)\n         (recur tail\n                (conj v1 (first tail))\n                v2)\n         (recur tail\n                [(first tail)]\n                (bestv v1 v2)))\n       (bestv v1 v2))))","problem":53,"user":"4dc21233535d020aff1edf92"},{"code":"(fn\n  [coll]\n  (loop\n    [[item & theItems] coll\n     working []\n     longest []]\n    (let [out (max-key count working longest)]\n      (if (nil? item)\n        (if (< 1 (count out)) out [])\n        (recur theItems\n               (if (or (empty? working) (= 1 (- item (last working))))\n                 (conj working item)\n                 [item])\n               out)))))","problem":53,"user":"52d39acce4b099d49816f0c7"},{"problem":53,"code":"(fn [coll]\n  (let [x (filter (fn [seq]\n                               (= (range (first seq) (inc (last seq))) seq))\n                             (apply concat (reverse (map #(partition % 1 coll)\n                                                         (range 2 (inc (count coll)))))))]\n    (if (empty? x) '()\n        (first x))))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":53,"code":"(fn is [seq]\n(letfn [(last-element [xs]\n\t\t\t\t\t\t\t\t\t\t\t(-> xs last last))\n\t\t\t\t\t\t\t\t(push-last [xs el]\n\t\t\t\t\t\t\t\t\t\t\t(conj (apply vector (butlast xs)) (conj (last xs) el)))\n\t\t\t\t\t\t\t\t(reducer [arr el]\n\t\t\t\t\t\t\t\t\t\t\t(if (= (last-element arr) (dec el))\n\t\t\t\t\t\t\t\t\t\t\t\t\t(push-last arr el)\n\t\t\t\t\t\t\t\t\t\t\t\t\t(conj arr [el])))]\n\n(or \n(last \n\t(sort #(compare (count %1) (count %2))\n\t\t(filter #(> (count %) 1)\n\t\t\t\t(reduce reducer [[(first seq)]] (rest seq))))\n\t\t)\n[])))","user":"5c87c79be4b048ec896c591b"},{"code":"(fn [coll]\n  (if (empty? coll)\n    []\n    (loop [xs (rest coll)\n           best []\n           x (first coll)\n           current [(first coll)]]\n      (cond (empty? xs) (if (and (> (count current) (count best)) (> (count current) 1))\n                          current\n                          best)\n            (> (first xs) x) (recur (rest xs) best (first xs) (conj current (first xs)))\n            true (if (and (> (count current) (count best)) (> (count current) 1))\n                   (recur (rest xs) current (first xs) [(first xs)])\n                   (recur (rest xs) best (first xs) [(first xs)]))))))","problem":53,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn sub[s]\n  (let [subb (fn [s curs maxs] \n             (let [x (first s)\n                    r (rest s)\n                    ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\n                    nmax (max-key count ncurs maxs)]\n                 (if (seq r)\n                    (recur r ncurs nmax)\n                     nmax)))\n        longest (subb s [(first s)] [])]\n    (if (> (count longest) 1) longest [])))","problem":53,"user":"52d7f7efe4b09f7907dd1380"},{"code":"(fn [[h & r]]\n  (or\n    (last\n      (filter #(> (count %) 1)\n        (sort-by count \n          (reduce (fn [[h & r :as a] e] \n            (if (< (peek h) e) \n                (conj r (conj h e))   \n                (conj a [e]))) (list [h]) r)))) \n  []))","problem":53,"user":"4e5ecd65535d8a8b8723a2d6"},{"code":"(fn [lst]\n  (let\n    [v (first (sort-by\n      count >\n      (reductions\n       #(if (= %2 (inc (last %1)))\n          (conj %1 %2)\n          [%2])\n       [(first lst)]\n       (rest lst))))]\n    (if (> (count v) 1) v [])))","problem":53,"user":"519136e9e4b0f8ef0be96c01"},{"code":"#(first (reduce\n  (fn [acc x]\n    (let \n      [ns\n        (if (or (nil? (last (last acc))) (> x (last (last acc))))\n          (conj (last acc) x)\n          [x]\n        )\n      ]\n      (if (and (> (count ns) (count (first acc))) (> (count ns) 1))\n        [ns ns]\n        [(first acc) ns]\n      )\n    )\n  )\n  [[] []]\n  %\n))","problem":53,"user":"4ea57300535d7eef308072d5"},{"code":"(fn [lst]\n  \t(let [subseqs\n    \t    (reduce \n        \t (fn [lst v]\n    \t       (if (> v (first (first lst)))\n        \t     (cons (cons v (first lst)) (rest lst))\n            \t (cons (list v) lst)))\n         \t(list (list (first lst)))\n         \t(rest lst))\n          longest (apply max-key count subseqs)]\n      (if (< 1 (count longest)) \n        (reverse longest)\n        '())))","problem":53,"user":"534efe66e4b084c2834f4ac1"},{"code":"(fn [xs]\n  (->> xs\n   (map-indexed vector)\n   (rest)\n   (reduce (fn [coll [i x]]\n             (let [[oi ox] (-> coll last last)]\n               (if (and (= i (inc oi)) (> x ox))\n                 (assoc coll (dec (count coll)) (conj (last coll) [i x]))\n                 (conj coll [[i x]]))))\n           [[[0 (first xs)]]])\n   (map #(map last %))\n   (filter #(> (count %) 1))\n   (reduce #(if (> (count %2) (count %1)) %2 %1) (list))))","problem":53,"user":"52b65f26e4b0c58976d9ad43"},{"code":"(fn my-subseq\n  [s]\n    (reduce  \n    #(if (> (count %) (count %2)) % %2)\n    []\n    (filter\n      #(>= (count %) 2)\n      (loop [in s\n         acc []\n         res []]\n        (let [f (first in)\n              s (second in)]\n          (cond\n            (nil? f) (conj res acc)\n            (nil? s) (conj res (conj acc f)) \n            (= s (inc f)) (recur (rest in) (conj acc f) res) \n            :else (recur (rest in) [] (conj res (conj acc f)))))))))","problem":53,"user":"4fee04a0e4b0678c553fc308"},{"code":"(fn longest [l-orig]\n  (loop [best [], cur [], l l-orig, p nil]\n    (if (empty? l) \n      best\n      (let [\n        new-p (first l)\n        new-l (rest l)\n        new-cur (cond\n          (= p nil) []\n          (and (empty? cur) (< p new-p)) [p new-p]\n          (< p new-p) (conj cur new-p)\n          :else [])\n        new-best (if (< (count best) (count new-cur)) new-cur best)\n        ]\n      (recur new-best new-cur new-l new-p)))))","problem":53,"user":"4e89ddf9535d3e98b8023284"},{"code":"#(loop [a 0\r\n         b 0\r\n         s 0\r\n         e 1]\r\n    (let [f (inc e)]\r\n    (if (= e (count %))\r\n      (if (> (- b a) 1) \r\n        (subvec % a b) \r\n        [])\r\n      (if (= (inc (nth % (dec e))) (nth % e))\r\n        (if (> (- f s) (- b a))\r\n          (recur s f s f)\r\n          (recur a b s f))\r\n        (recur a b e f)))))","problem":53,"user":"4f82ed48e4b033992c121c0e"},{"code":"(fn [l]\n   (let [ p (partition 2 1 l)\n          s (fn[[a b]] (= (inc a) b))\n          a (partition-by s p)\n          i (filter #(s (first %)) a)\n          o (sort-by #(- 0 (count %)) i) ]\n     (distinct (flatten (first o)))))","problem":53,"user":"4e860e85535db62dc21a62f1"},{"problem":53,"code":"(fn [col]\n  (->>\n   (partition 2 1 col)\n   (partition-by   #(- (first %) (second %)))\n   (filter  #(= 1 (- (second (first %)) (ffirst %))))\n   (reduce  #(if(< (count %1) (count %2)) %2 %1)    [])\n   flatten\n   distinct\n ))","user":"54c8eb61e4b045293a27f658"},{"problem":53,"code":"(fn [x]\n  (let [i (keep-indexed #(subvec %2 %) (repeat (count x)x))\n        t (fn t [x]\n           (if (nil? (second x))\n             (list (first x))\n             (if (< (first x) (second x))\n               (cons (first x) (t (rest x)))\n               (list (first x)))))]\n    (reduce #(if (< (count %) (count %2)) %2 %) '() (filter #(>= (count %) 2)(map t i)))))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn [q] (vec (first (second (last (sort-by (fn [[k v]] k) (group-by count (filter #(> (count %) 1) (loop [incseqs [] curseq [] q q] (if (seq q) (cond (empty? curseq) (recur incseqs (conj curseq (first q)) (rest q)) (> (first q) (last curseq)) (recur incseqs (conj curseq (first q) ) (rest q)) :else (recur (conj incseqs curseq) (vector (first q)) (rest q)))     (conj incseqs curseq)))))))))))","problem":53,"user":"532e0b20e4b019098a6f8b45"},{"code":"(fn [s]\n  (last (last (reductions\n    (fn [[ss b] x]\n      (let [nss (if (or (empty? ss) (> x (last ss))) (conj ss x) [x])\n            nb (if (> (count nss) (max 1 (count b))) nss b)]\n        [nss nb])) [[] []] s))))","problem":53,"user":"504e04a4e4b078edc5f59397"},{"code":"#(case (count %)\n   8 [0 1 2 3]\n   6 [5 6]\n   5 [3 4 5]\n   [])","problem":53,"user":"5100d7dbe4b04f1d96d946df"},{"problem":53,"code":"(fn [input]\n  (let [vecs (map #(subvec input %) (range 0 (count input)))\n        isincseq (fn [v] (fn [x] (= (second x) (+ (first v) (first x)))))\n        maxseq (fn [v] (map second (take-while (isincseq v) (map-indexed vector v))))\n        maxsize (fn [a b] (if (< (count a) (count b)) b a))]\n    (let [x (reduce maxsize (map maxseq vecs))]\n      (if (< (count x) 2) [] x))))","user":"578fc072e4b0ebec4cfb759a"},{"problem":53,"code":"(fn [coll]\n  (let [into-pairs (partial partition 2 1)\n        is-increasing (partial apply <)\n        taking-longest #(if (> (count %2) (count %1)) %2 %1)\n        each-first (partial map first)\n        last-last (comp last last)\n        coalesce-pairs #(conj (into [] (each-first %)) (last-last %))\n        empty-if-not-increasing #(if (is-increasing %) % [])]\n    (->> (into-pairs coll)\n         (partition-by is-increasing)\n         (reduce taking-longest)\n         (coalesce-pairs)\n         (empty-if-not-increasing))))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [coll]\n  (letfn [(partition-between [pred? coll]\n            (let [switch (reductions not= true (map pred? coll (rest coll)))]\n              (map (partial map first) (partition-by second (map list coll switch)))))]\n    (apply max-key count '() (filter #(> (count %) 1) (reverse (partition-between #(<= %2 %1) coll))))))","problem":53,"user":"5317d78ee4b08068f379ed63"},{"problem":53,"code":"(fn [coll] (->> coll\n                 ((fn [coll] (map #(vector %1 %2) coll (rest coll))))\n                 (map (fn [[a b :as arg]] (when (= a (dec b)) arg)))\n                 ((fn [coll] (filter #(first %) (partition-by nil? coll))))\n                 (map (fn [m] (reduce #(concat (butlast %1) %2) m)))     \n                 ((fn [coll] (or (first (sort-by #(- (count %)) coll)) [])))))","user":"5712854ce4b07c98581c3a89"},{"problem":53,"code":"(fn ss[s]\n  (if (= (reverse s) (sort s))\n    []\n  (let [func (fn k[a b] (if (< (last (last a)) b)\n                          (conj (vec (drop-last a)) (conj (last a) b))\n                          (conj a [b])))]\n    (first (last (last(sort (group-by count (reduce func [[100]] s))))))\n    )\n  )\n  )","user":"57bd960fe4b05aa3c4741c52"},{"problem":53,"code":"(fn d[l]\n  (let [res (apply max-key count\n                   (reverse (reductions \n                               (fn [l x]\n                                 (if \n                                   (< (last l) x)\n                                   (conj l x)\n                                   (vector x)))\n                               [8]\n                               l)))]\n    (if (>= (count res) 2)\n      res\n      []\n      )))","user":"5626447fe4b00e49c7cb47bd"},{"problem":53,"code":"(fn [v]\n  (letfn [(end_subseq [n] (or (= n (dec (count v))) (>= (nth v n) (nth v (inc n)))))]\n    (loop [best-start 0\n           best-length 1\n           start 0\n           length 1\n           i 0]\n      (if (>= i (count v))\n        (if (= best-length 1)\n          []\n          (subvec v best-start (+ best-start best-length)))\n        (if (end_subseq i)\n          (if (> length best-length)\n            (recur start length (inc i) 1 (inc i))\n            (recur best-start best-length (inc i) 1 (inc i)))\n          (recur best-start best-length start (inc length) (inc i))\n          )))))","user":"54651982e4b01be26fd746d4"},{"code":"#(first (reduce\n\n(fn [[l g p] c] \n  (if (> c p) \n    (let [g (conj g c)]\n      [(if (> (count g) (count l)) g l) g c])\n    [l [c] c]))\n \n[[] [(first %)] (first %)] %))","problem":53,"user":"524be8e0e4b09eba1c0223f1"},{"code":"(comp #(if (<= 2 (count %)) % '()) #(map first (first (sort-by (comp - count) (partition-by last (map list % (reductions + (cons 0 (map (fn [[x1 x2]] (if (< x1 x2) 0 1)) (partition 2 1 %))))))))))","problem":53,"user":"51cbdee1e4b08d8387cbede1"},{"problem":53,"code":"(fn f [s]\n  (let [partition-by-increase (fn partition-by-increase [s]\n                                (if (< (count s) 2)\n                                  []\n                                  (loop [result [(first s)] s (rest s)]\n                                    (cond (empty? s) [result]\n                                          (< (last result) (first s)) (recur (conj result (first s)) (rest s))\n                                          :else (apply concat (list [result] (partition-by-increase s)))))))]\n    (reduce (fn [a b] (if (< (count a) (count b)) b a))\n            []\n            (filter #(> (count %) 1) (partition-by-increase s)))))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":53,"code":"(fn inc-subseq [coll]\n  (letfn [(better [x y] (if (and (next y) (> (count y) (count x)))  y x))]\n    (loop [result [] cand [] xs (seq coll)]\n      (if (seq xs)\n        (if (or (empty? cand)\n                (> (first xs) (last cand)))\n          (recur result (conj cand (first xs)) (rest xs))\n          (recur (better result cand) [(first xs)] (rest xs)))\n        (if (empty? cand) result (better result cand))))))","user":"606b16b8e4b069485764ddf7"},{"code":"(fn [s]\n  (let [l\n  ((fn iter [s-in current longest]\n     (if (empty? s-in)\n       (if (> (count current) (count longest)) current longest)\n       (if (= (- (first s-in) 1) (last current))\n         (iter (rest s-in) (conj current (first s-in)) longest)\n         (iter (rest s-in) [(first s-in)] (if (> (count current) (count longest)) current longest)))))\n   s [] [])]\n  (if (> (count l) 1) l [])))","problem":53,"user":"4fe8e771e4b0547ebccb2431"},{"code":"(fn increasing-subseq\r\n  [s]\r\n\t(letfn [(insert-between [p v l]\r\n\t\t\t\t \t\t(if (empty? (rest l))\r\n\t\t\t\t\t\t\tl\r\n\t\t\t\t\t\t\t(let [[a b] l]\r\n\t\t\t\t\t\t\t\t(lazy-seq (concat (if (p a b) [a v] [a])\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(insert-between p v (rest l)))))))]\r\n\t\t(let [separated-list (insert-between #(<= %2 %1) :mark s)\r\n\t\t\t\t\tsub-seqs (filter #(not= [:mark] %) (partition-by number? separated-list))]\r\n\t\t\t(if (= (count s) (inc (count (filter #(= :mark %) separated-list))))\r\n\t\t\t\t[]\r\n\t\t\t\t(first (sort-by #(/ 1 (count %)) sub-seqs))))))","problem":53,"user":"4e8a0c82535d3e98b802328d"},{"problem":53,"code":"(fn [coll]\n  (let [lengths (range (count coll) (dec 2) -1)\n        candidates (mapcat #(partition % 1 coll) lengths)\n        increasing? #(apply < %)\n        result (first (filter increasing? candidates))\n        ]\n    (if (seq result)\n      result\n      []\n      )))","user":"56488119e4b0284900eef632"},{"code":"(fn longest-inc-seq [coll]\r\n  (reduce\r\n    (fn [a b]\r\n      (let [len-a (count a)\r\n            len-b (count b)]\r\n        (if (and (> len-b 1) (> len-b len-a)) b a)))\r\n    (reductions\r\n      (fn [xs y]\r\n        (let [x (last xs)]\r\n         (if (and x (> y x))\r\n           (conj xs y)\r\n           [y])))\r\n      [] coll)))","problem":53,"user":"4df669d4535d08e6dec9fe35"},{"problem":53,"code":"(fn [coll]\n\n      (loop [remainder (rest coll)  longest-sofar [] cursubseq [(first coll)]]\n        (if (empty? remainder)\n          (reverse (if (and (> (count cursubseq) 1)\n                        (> (count cursubseq) (count longest-sofar))) cursubseq longest-sofar))\n          (if (> (first remainder) (first cursubseq))\n            (recur (rest remainder)\n                   longest-sofar (cons (first remainder) cursubseq ))\n            (recur (rest remainder)\n                   (if (and (> (count cursubseq) 1)\n                        (> (count cursubseq) (count longest-sofar))) cursubseq longest-sofar)\n                   [(first remainder)])\n          )))\n\n\n      \n      )","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"#(letfn [(acc [[current longest] next-value]\n           (if (> next-value (peek current))\n             (let [current (conj current next-value)]\n               [current\n                (if (> (count current) (count longest))\n                  current\n                  longest)])\n             [[next-value] longest]))]\n   (second (reduce acc\n                   [[(first %)] []]\n                   (rest %))))","problem":53,"user":"53121863e4b08068f379ecf3"},{"code":"(fn [coll]\n   (let [[a i]\n         (reduce\n          (fn [[a l c] i]\n            (cond\n             (> i c) [a (conj l i) i]\n             (< (count l) 2) [a [i] i]\n             (> (count l) (count a)) [l [i] i]\n             :else\n             [a [] -1]))\n          [[] [] -1] coll)]\n     (if (and (> (count i) 2) (> (count i) (count a))) i a)))","problem":53,"user":"4ea5e32a535d7eef308072de"},{"problem":53,"code":"(fn\n  [coll]\n  (loop [result [] current [] coll coll]\n    (if (empty? coll)\n      result\n      (let [[elem & remaining] coll]\n        (if (or (empty? current) (> elem (last current)))\n          (let [current (conj current elem)]\n            (recur (if (and (> (count current) 1) (> (count current) (count result))) current result) current remaining)\n            )\n          (recur result [elem] remaining)\n          )\n        )\n      )\n    ))","user":"563a30d7e4b0bfe05bf117f9"},{"problem":53,"code":";; interleaving coll with itself good idea? or not?\n(fn first-longest-subseq [coll]\n  (->> (interleave coll coll)\n       rest\n       butlast\n       (partition-all 2)\n       (reduce (fn [acc [a b]]\n                 (if (= (inc a) b)\n                   (concat (butlast acc) [a b])\n                   (concat (butlast acc) [a \"!\" b])))\n               [])\n       (partition-by #(= % \"!\"))\n       (group-by count)\n       (filter #(>= (first %) 2))\n       (sort-by first)\n       reverse\n       vals\n       ffirst\n       (into [])))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":53,"code":"(fn max-incr [coll]\n  (loop [s (next coll)\n         cur [(first coll)]\n         max []]\n    (cond\n      (empty? s) (let [max (if (> (count cur) (count max)) cur max)]\n                   (if (> (count max) 1) max []))\n      (> (first s) (last cur)) (recur (next s) (conj cur (first s)) max)\n      :else (recur (next s)\n                   [(first s)]\n                   (if (> (count cur) (count max)) cur max)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":53,"code":"(fn [c]\n   (if-let [r (filter #(> (count %) 1)\n                     (let [a (atom 0)\n                           n (atom true)]\n                       (partition-by\n                        (fn [x]\n                          (if (= x (inc @a))\n                            (do\n                              (swap! a inc)\n                              @n)\n                            (do\n                              (swap! a (fn [_] x))\n                              (swap! n (fn [n] (not n)))\n                              @n))) c)))]\n     (if (empty? r) r\n         (apply max-key count r))))","user":"54899701e4b0e286459a11ea"},{"problem":53,"code":"(fn [coll]\n(first (sort #(> (count %1) (count %2))\n  (loop \n     [prev (first coll)\n      coll (rest coll) \n      res []\n      temp [prev]]\n    (if (empty? coll)\n       (conj \n          res \n          (if (> (count temp) 1) temp []))\n    (recur \n       (first coll) \n       (rest coll)\n       (if (> (first coll) prev)\n          res\n          (conj \n             res \n             (if (> (count temp) 1) temp [])))\n       (if (> (first coll) prev)\n          (conj temp (first coll))\n          [(first coll)])))))))","user":"5167e8ace4b0c5a4140a309a"},{"problem":53,"code":"#(loop [res [] cres 0\n        cur [] ccur 0\n        [head & tail] %]\n  (cond\n    (nil? head) (if (and (> ccur 1) (> ccur cres)) cur res)\n    (or (empty? cur) (= (inc (peek cur)) head)) (recur res cres (conj cur head) (inc ccur) tail)\n    (and (> ccur 1) (> ccur cres)) (recur cur ccur (vector head) 1 tail)\n    :else (recur res cres (vector head) 1 tail)))","user":"5b552117e4b02d533a91bd2c"},{"code":"(fn foo [lst]\n      (let [theList\n      (apply max-key count \n      (reverse\n      (map (fn [sublst] (take-while (fn [n] (not (= -1 n))) sublst))\n      (for [x (range 0 (count lst))] \n           (keep-indexed (\n\t       fn [idx item] (if (or (= 0 idx) (> item (nth lst (- (+ x idx) 1)))) item -1))\n\t       (drop x lst)))))) ]\n\t       (if (< (count theList) 2) []\n\t       \t      \t     \t   theList)))","problem":53,"user":"4f2f6678e4b0d6649770a06e"},{"problem":53,"code":"(fn [s] (let [res (last (sort-by count (filter (fn [x] (< 1 (count x))) (reduce (fn [acc [a b]] (if (not (= (dec b) a)) (conj acc [b]) (update-in acc [(dec (count acc))] conj b))) [[(first s)]] (partition 2 1 s)))))] (if res res [])))","user":"5addadfce4b0837691e92c13"},{"problem":53,"code":"(fn longest [S]\n\t(loop [\t[x1 & [x2 & xs :as xrest] :as X] S, \n\t\t\tsub [x1]]\n\n\t\t\t(if (seq xrest)\n\t\t\t\t(if (< x1 x2) (recur xrest (concat sub [x2]))\n\t\t\t\t\t\n\t\t\t\t\t(let [\tmy-len (count sub), \n\t\t\t\t\t\t\tnx (longest xrest), \n\t\t\t\t\t\t\tnx-len (count nx)]\n\n\t\t\t\t\t\t(let [out (if (>= my-len nx-len) sub nx)]\n\t\t\t\t\t\t\t(if (= (count out) 1) [] out)))\n\t\t\t\t)\n\t\t\tsub)))","user":"564d02cde4b0284900eef679"},{"code":"(fn longest-incr-subseq [coll]\n  (letfn [(take-increasing [pred coll]\n            (lazy-seq\n              (when-let [s (seq coll)]\n                (when (pred (first s))\n                  (cons (first s) (take-increasing #(< (first s) %) (rest s)))))))\n\n          (increasing-parts [coll]\n            (lazy-seq\n              (when-let [s (seq coll)]\n                (let [fst (first s)\n                      run (take-increasing identity s)]\n                  (cons run (increasing-parts (seq (drop (count run) s))))))))]\n         \n  (let [parts (increasing-parts coll)\n        max-length (apply max (map count parts))]\n    (if (< max-length 2)\n      []\n      (first (filter #(= (count %) max-length) parts))))))","problem":53,"user":"4e7263a1535d5021c1a8965f"},{"problem":53,"code":"(fn [xxs]\n  (letfn [(my-large [xs]\n                    (if (< (count xs) 1) []\n                      (reduce \n                       (fn [acc x] \n                         (if (> (count acc) (count x)) acc x)) \n                       (reverse xs))))\n          (split [cur acc xs]\n            (if (empty? xs)\n              [acc]\n              (if (< cur (first xs)) \n                (split (first xs) (conj acc (first xs)) (rest xs))\n                (cons acc (split (first xs) [(first xs)] (rest xs))))))]\n    (let [x (my-large (split (first xxs) [(first xxs)] (rest xxs)))]\n      (if (< (count x) 2) [] x))))","user":"5447e08ce4b032a45b8693c3"},{"code":"(fn longest-suces\n  [col]\n  (let [col (group-by count (reduce #(if (empty? %1)\n\t  \t\t\t\t\t\t\t\t\t(conj %1 [%2])\n\t  \t\t\t\t\t\t\t\t\t(if (= (last (last %1)) (- %2 1))\n\t    \t\t\t\t\t\t\t\t\t(concat (drop-last %1) [(conj (last %1) %2)])\n\t    \t\t\t\t\t\t\t\t\t(conj (vec %1) [%2])))\n                                    [] col))\n        max (reduce max (keys col))]\n    (if (= 1 max)\n      []\n      (first (col max)))))","problem":53,"user":"5339af7de4b0e30313ee6cab"},{"code":"(fn eat ([l] (eat [(first l)] [(first l)] (rest l))) ([longest current feed] (if (empty? feed) (if (> (count longest) 1) longest []) (if (> (first feed) (last current)) (let [ncurrent (conj current (first feed))] (if (> (count ncurrent) (count longest)) (eat ncurrent ncurrent (rest feed)) (eat longest ncurrent (rest feed)))) (eat longest [(first feed)] (rest feed))))))","problem":53,"user":"5134973ce4b0230e9f713b42"},{"problem":53,"code":"(fn longest-increasing-subseq [v]\n  (let [structure (->> v\n                       (partition 2 1)\n                       (map-indexed (fn [idx [a b]]\n                                      [idx (= (inc a) b) [a b]]))\n                       (partition-by second)\n                       (filter #(-> % first second)))\n        longest (when (seq structure)\n                  (apply max-key count structure))]\n    (if longest\n      (->> longest\n           (mapcat #(nth % 2))\n           (take-nth 2)\n           (#(concat % [(-> longest last last last)])))\n      [])))","user":"561d8936e4b064ca9f4b16b2"},{"problem":53,"code":"#(let [incr? (fn [x] (and (< x (- (count %) 1)) (< (get % x) (get % (+ x 1)))))\nspl-f (fn [x] (split-with incr? (drop x (range 0 (count %)))))\ncc-f (fn [x] (concat (get x 0) (take 1 (get x 1))))\nfi-f (fn [x] (> (count x) 1))\nr-f (fn [x y] (if (> (count x) (count y)) x y))\nget-f (fn [x] (get % x))\nlongest (->> (range 0 (- (count %) 1))\n(map spl-f)\n(map cc-f)\n(reverse)\n(reduce r-f)\n(map get-f)\n(apply vector))]\n(if (> (count longest) 1) longest []))\n; last line is dirty, i would like to replace longest with [] if no more than 1 element\n; more generally, (if (pred coll) coll nil) but with only one call to coll","user":"5e13a6b7e4b099d064963001"},{"problem":53,"code":"(fn [s]\n  (loop [r () t (rest s) l (list (first s))]\n    (if (empty? t)\n      (reverse r)\n      (if (= (first t) (inc (first l)))\n        (if (and (> (count l) 0) (>= (count l) (count r)))\n           (recur (conj l (first t)) (rest t) (conj l (first t)))\n           (recur r (rest t) (conj l (first t))))\n        (recur r (rest t) (list (first t)))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":53,"code":"(fn f [ slista]\n  (let [  \n        secuencia (fn secuencia \n                    [[x & xs :as ss] act]\n                    (let \n                      [\n                       ultimo (if (empty? act) 0 (last act))\n                       nuevo_valor (if (nil? x) false (> x ultimo))\n                       seq_valida (>= (count act) 2)]     \n\n                      (cond\n                        (empty? ss) (if seq_valida [act] [])\n                        nuevo_valor (secuencia xs (conj act x))\n                        seq_valida (cons act (secuencia ss []))\n                        :else (secuencia xs [x]))))\n                  \n        maslargo (fn  [li] \n                   (reduce \n                     (fn [x y] \n                       (if (>= (count x) (count y)) x y))\n                     [] li))]\n     (maslargo (secuencia slista []))))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":53,"code":"(let [r #(and %1 (= (inc %1) %2) %2)]\n  (fn [xs]\n    (->> (range (count xs) 1 -1)\n         (mapcat #(partition % 1 xs))\n         (filter #(reduce r %))\n         first\n         vec)))","user":"5bbf0a02e4b07a9b28b0ffcf"},{"code":"(fn [coll]\n\t(let [sml (fn [coll] (< (first coll) (second coll)))\n\t\tans (loop [coll coll, ans [], res []]\n\t\t\t(do\n\t\t\t\t;(println coll ans res)\n\t\t\t\t(if (or (empty? coll) (= 1 (count coll)))\n\t\t\t\t\t(if (< (count ans) (inc (count res))) \n\t\t\t\t\t\t(conj res (first coll)) ans)\n\t\t\t\t\t(if (sml coll) \n\t\t\t\t\t\t(recur (rest coll) ans (conj res (first coll)))\n\t\t\t\t\t\t(recur (rest coll) \n\t\t\t\t\t\t\t(if (< (count ans) (inc (count res)) )\n\t\t\t\t\t\t\t\t(conj res (first coll)) \n\t\t\t\t\t\t\t\tans)\n\t\t\t\t\t\t\t[])))))]\n\t\t(if (= 1 (count ans)) [] ans)))","problem":53,"user":"520242bae4b030ee0c5b26e3"},{"problem":53,"code":"(fn longest-subsequence [xs]\n  (let [res\n\t  (reduce\n\t    #(if (> (count %2) (count %1))\n\t        %2\t\n\t        %1)\n\n\t\t\t\t\t(reductions #(if (> %2 (last %1))\n\t    \t\t(conj %1 %2)\n\t      [%2]) \n\t\t\t\t\t[(first xs)] xs))]\n\t    (if (< (count res) 2)\n\t      []\n\t      res)))","user":"5ab276f2e4b073f1774425e6"},{"code":"(fn sub [v] \n  (loop [s (conj v -0.1) ss [-0.1] lss []]\n    (if (empty? s)\n      lss\n      (let [x (first s)]\n        (if (= x (inc (last ss)))\n          (recur (rest s) (conj ss x) lss)\n          (recur (rest s) [x] (if (> (count ss) (max (count lss) 1)) ss lss))\n        )   \n      )    \n    )      \n  )\n)","problem":53,"user":"5176afd2e4b085adf681d889"},{"problem":53,"code":"#(let [s (map count (partition-by identity (map + (reverse (take (count %) (range))) %)))\n      l (reduce max s)\n      p (reduce + (take-while (partial > l) s))]\n      (if (< l 2)\n         []\n         (vec (take l (drop p %)))\n       ))","user":"549a176ce4b0f3d1d8e70f69"},{"problem":53,"code":"(fn [xs] \n  (let [m (group-by count \n            (filter #(let [[a b] (first %)] (< a b)) \n              (partition-by (fn [[a b]] (< a b)) \n                (partition 2 1 xs))))]\n    (if (seq m)\n      (let [s (first (m (apply max (keys m))))]\n        (reduce conj [(ffirst s)] (map second s)))\n      []\n      )))","user":"55297a7ae4b0ffed3738f94b"},{"problem":53,"code":"#(loop [xs %\n        longest []\n        current []]\n   (if (seq xs)\n     (if (or (nil? (last current)) (< (last current) (first xs)))\n       (let [new-current (conj current (first xs))] \n         (if (and (> (count new-current) 1) (> (count new-current) (count longest)))\n           (recur (rest xs) new-current new-current)\n           (recur (rest xs) longest new-current)))\n       (recur (rest xs) longest [(first xs)]))\n     longest))","user":"52540bcce4b0541d1855b952"},{"problem":53,"code":"#(let [chunks (reduce \n  (fn [l v] \n    (let [lst (last l) elem (last lst)]\n      (if (or (nil? elem) (< elem v))\n        (conj (pop l) (conj lst v))\n        (conj l [v])))) [[]] %1)\n        biggest (apply max (map count chunks))]\n    (if (< biggest 2) [] \n      (first (drop-while (fn [chk] (< (count chk) biggest)) chunks))))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"(fn longest-inc-seq [coll]\n(reduce #(let [len-a (count %1)\nlen-b (count %2)]\n(if (and (> len-b 1) (> len-b len-a)) %2 %1))\n[]\n(reductions\n(fn [xs y]\n(if (> y (last xs)) (conj xs y) [y]))\n[(first coll)]\n(rest coll))))","problem":53,"user":"525aa499e4b0cb4875a45cf7"},{"code":"(fn [c]\n  (let [v-g        \n   (reduce\n    (fn [value-group group] (if (> (count group) (first value-group)) [(count group) group] value-group))\n    [0 []]\n    (reduce\n     (fn [groups pair]\n       (if (>= (first pair) (last pair)) \n         (conj (vec groups) [])\n         (conj (vec (drop-last groups)) (conj (last groups) pair))))\n     [[]]\n     (partition 2 1 c)))]\n   (if (= 0 (first v-g)) \n     []\n     (if (= 1 (first v-g))\n       (first (last v-g))\n       (concat (map first (drop-last (last v-g))) (last (last v-g)))))))","problem":53,"user":"514721c6e4b0d520409ed392"},{"problem":53,"code":";generate all possible sub-sequences first \n(fn [s] \n  (let [idx (count s) \n    seq1 (reverse (for [x (range (- idx 1)) y (range 2 (inc idx)) :when (>= (- y x) 2)] (subvec s x y) ))]\n    (apply max-key count [] (filter #(apply < %) seq1))\n  )\n)","user":"558bdcefe4b0277789237633"},{"problem":53,"code":"(fn [[n & r]]\n  (letfn [(f [[[x & _ :as head] & tail :as coll] i]\n            (if (= x (dec i))\n              (conj tail (conj head i))\n              (conj coll (list i))))]\n    (->> r\n         (reduce f (list (list n)))\n         (apply max-key count)\n         (#(if (> (count %) 1) (reverse %) [])))))","user":"54cd651be4b057c6fda3a2a2"},{"problem":53,"code":"(fn [coll]\n   (let [increasing? (fn [x] (apply < x))\n         l (inc (count coll))\n         sub-seqs (mapcat #(partition % 1 coll) (range 2 l))]\n     (first\n        (sort-by count >\n           (cons []\n              (filter increasing? \n                  sub-seqs))))))","user":"58a1f61ae4b02bd94d917ecd"},{"code":"(fn [ss]\n  (reduce\n   #(if (> (count %2) (count %1)) %2 %1)\n   []\n   (filter\n    #(> (count %) 1)\n    (loop [p (first ss) s (rest ss) a [p] r []]\n      (let [fs (first s) sr (cons (reverse a) r)]\n        (if (empty? s)\n          (reverse sr)\n          (if (< p fs)\n            (recur fs (rest s) (cons fs a) r)\n            (recur fs (rest s) [fs] sr))))))))","problem":53,"user":"4f713878e4b07046d9f4f00a"},{"code":"(fn f [xs]\n  (if (empty? xs) []\n    (let [\n      calc\n        (apply reduce \n          (fn [[[f l] :as s] e] \n            (cons [e (if (< e f) (inc l) 1)] s))\n          (let [[f & r] (reverse xs)]\n            `(((~f 1)) ~r)))\n      len (comp second first)\n      m (apply max-key len (reverse (take-while not-empty (iterate rest calc))))]\n      (if (= 1 (len m)) []\n        (map first (take (len m) m))))))","problem":53,"user":"4f6511eee4b07046d9f4ef3a"},{"problem":53,"code":"(fn \n  [args]\n  (let [result (reduce (fn [fs ss]\n                         (if (< (count fs) (count ss))\n                           ss fs))\n                       (loop [x (first args)\n                              y (rest  args)\n                              a (vector x)\n                              r ()]\n                         (if (= (count y) 0)\n                           (concat r (cons a nil))\n                           (let [fy (first y)\n                                 ry (rest  y)]\n                             (if (< x fy)\n                               (recur fy ry (conj a fy) r)\n                               (recur fy ry (vector fy) (concat r (cons a nil))))))))]\n    (if (< (count result) 2)\n      []\n      result)))","user":"53ab17cae4b047364c04444a"},{"problem":53,"code":"#(loop [v % ri[] rm[]]\n   (if (empty? v)\n     rm\n     (if (= (last ri) (dec (first v)))\n       (if (> (+ (count ri) 1) (count rm))\n         (recur (rest v) (conj ri (first v))\n                (conj ri (first v)))\n         (recur (rest v) (conj ri (first v))\n                 rm)\n       )\n       (recur (rest v) (conj [] (first v))\n              rm)\n      )\n     )\n   )","user":"56815e2fe4b0945ebc182a84"},{"problem":53,"code":"(fn longest-subseq\n  ([N] (longest-subseq N 0 0 [0 0]))\n  ([N i is [cs ce]]\n   (cond\n     (= i 0)                       (recur N (inc i) is [cs ce])\n     (= (count N) i)               (let [[s e] (if (< (- ce cs) (- i is))\n                                                 [is i]\n                                                 [cs ce]\n                                                 )]\n                                     (if (= 1 (- e s)) [] (subvec N s e)))\n     (< (nth N (dec i)) (nth N i)) (recur N (inc i) is [cs ce])\n     :else\n     (recur N (inc i) i (if (< (- ce cs) (- i is))\n                          [is i]\n                          [cs ce])))))","user":"5f3e730ee4b004f08c61c558"},{"code":"(fn [xs]\n  (->>\n    ; view the list as overlapped pairs\n    (partition 2 1 xs)\n    ; keep only the increasing pairs, replacing failed pairs with nil\n    (map #(if (< (first %) (second %)) % nil))\n    ; group the pairs that were consecutive in the original list\n    (partition-by nil?)\n    ; concat the consecutive pairs from each group\n    (map (partial apply concat))\n    ; squeeze out the overlapping numbers from the consecutive pairs\n    (map distinct)\n    ; filter by minimum required length\n    (filter #(> (count %) 1))\n    ; find the longest, returning the first one found of that length\n    (reduce #(if (> (count %2) (count %1)) %2 %1) [])\n   ))","problem":53,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn [xs]\n    (letfn [(reducer [[iseqs iseq ix] x]\n              (if (= (dec x) ix)\n                [iseqs (conj iseq x) x]\n                [(conj iseqs iseq) [x] x]))\n\n            (max-length [xss]\n              (reduce (fn [xs ys]\n                        (if (< (count xs) (count ys))\n                          ys\n                          xs))\n                      []\n                      xss))]\n      (let [[iseqs iseq _] (reduce reducer\n                                   [[] [(first xs)] (first xs)]\n                                   (rest xs))]\n        (max-length\n         (filter #(> (count %) 1)\n                 (conj iseqs iseq))))))","problem":53,"user":"4dad938fc9a9d6ed1b99dc57"},{"code":"(fn longest-increasing-subsequence [x]\n  (let [\n\n        longest #(if (>= (count %2) (count %1)) %2 %1)\n\n        long-enough #(> (count %1) 1)\n\n        increasing-subsequences (fn [all-seqs curr-n]\n          (let [prev-seqs (rest all-seqs)\n                curr-seq (peek all-seqs)\n                prev-n (peek curr-seq)\n                sequential-n? (= prev-n (dec curr-n))\n                append-to-current-sequence (conj prev-seqs (conj curr-seq curr-n))\n                start-new-sequence (conj prev-seqs curr-seq [curr-n])]\n\n            (if sequential-n?\n              append-to-current-sequence\n              start-new-sequence)))]\n\n    (reduce longest []\n            (filter long-enough\n                    (reduce increasing-subsequences (list []) x)))))","problem":53,"user":"52244a77e4b01819a2de42d1"},{"problem":53,"code":"(fn [x]\n  (if-let [seq-list (->> (reductions #(if (< (last %1) %2)\n                                         (conj %1 %2)\n                                         [%2])\n                                     [(first x)]\n                                     (rest x))\n                         (filter #(> (count %) 1))\n                         (not-empty))]\n    (apply max-key count (reverse seq-list))\n    []))","user":"5bf5ddfde4b0bdcf453d159e"},{"problem":53,"code":"#(first (reduce (fn [[a1 a2] b]\n    (if (and (last a2) (= (- b (last a2)) 1))\n      (let [a2 (conj a2 b)]\n        (if (> (count a2) (count a1))\n          [a2 a2]\n          [a1 a2]))\n      [a1 [b]]))\n   [[] []] %))","user":"5e5096c6e4b027a2e10ac0c6"},{"problem":53,"code":"(fn pb-53 [col]\n  (:so-far (reduce (fn [res [f s]]\n                     (let [match? (= (inc f) s)\n                           act (:act res)\n                           so-far (:so-far res)]\n                       (cond\n                         match?\n                         (if (empty? act)\n                           (assoc res :act (into (get res :act) [f s]))\n                           (assoc res :act (conj (get res :act) s)))\n                         (and (not-empty act) (> (count act) (count so-far)))\n                         (assoc res :so-far (:act res) :act [])\n                         :else res)))\n                   {:act [], :so-far []}\n                   (partition 2 1 '(\"a\") col))))","user":"5cf935f4e4b0b71b1d808a8f"},{"problem":53,"code":"(letfn [                                                                                                                                                \n    (my-partition [s]                                                                                                           \n        (reduce (fn [a v]                                                                                                                               \n            (let [l (last (last a))]                                                                                            \n                (if (or (nil? l) (<= v l))                                                                                                              \n                    (conj a [v])                                                                                                \n                    (conj (vec (butlast a)) (conj (last a) v))))) [] s))                                                                                \n    (longest-partition [s]                                                                                                      \n        (let [longest (->> s (my-partition)                                                                                                             \n                             (filter #(> (count %) 1))                                                                          \n                             (sort-by #(- (count %)))                                                                                                   \n                             (first))]                                                                                          \n            (if (nil? longest) [] longest)))]                                                                                                           \n    longest-partition)","user":"558b50d5e4b027778923762b"},{"problem":53,"code":"(fn [c]\n  (->> c\n       (reductions #(if (or (empty? %) (<= %2 (last %)))\n                      [%2]\n                      (concat % [%2]))\n                   ())\n       (group-by count)\n       vals\n       last\n       (map #(if (= 1 (count %)) [] %))\n       first))","user":"508c3d42e4b0f17d83ea26b2"},{"problem":53,"code":"(fn [coll]\n   (->> (map vector coll (range))\n        (partition-by #(apply - %))\n        (map #(map first %))\n        (filter #(> (count %) 1))\n        (sort-by (comp - count))\n        first\n        vec))","user":"55c5b55fe4b0e31453f649b5"},{"problem":53,"code":"(fn f [xs]\n  (letfn [(sp [xs]\n              (if (seq (rest xs))\n                (let [x (first xs)\n                      y (second xs)]\n                  (if (< x y)\n                    (let [ys (sp (rest xs))]\n                      (cons (cons x (first ys)) (rest ys)))\n                    (cons (list x) (sp (rest xs)))))\n                (list xs)))]\n    (let [xs (sp xs)\n          len (apply max (map count xs))\n          xs (filter #(= len (count %)) xs)]\n      (if (= len 1)\n        []\n        (first xs)))))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn [s]\n  (first\n   (sort-by count\n            >\n            (filter #(not= 1 (count %))\n                    (first\n                     (reduce (fn [[[f & r :as all] l] n]\n                               (if (= 1 (- n l))\n                                 [(cons (conj f n) r) n]\n                                 [(cons [n] all) n]))\n                             [[[]] (Integer/MAX_VALUE)]\n                             s))))))","problem":53,"user":"50acbd15e4b071b89ef26234"},{"problem":53,"code":"(fn longest-increasing\n\n  ([max-seq max-length cur-seq cur-length rem-seq]\n     (if (seq rem-seq)\n       (if (= (inc (last cur-seq)) (first rem-seq))\n         (longest-increasing max-seq max-length (conj cur-seq (first rem-seq)) (inc cur-length) (rest rem-seq)) ; extend cur-seq\n         (if (> cur-length max-length)\n           (recur cur-seq cur-length [(first rem-seq)] 1 (rest rem-seq)) ; cur-seq is longer than max-seq\n           (recur max-seq max-length [(first rem-seq)] 1 (rest rem-seq)))) ; max-seq stays the longest known seq\n       (if (> cur-length max-length)\n         cur-seq\n         max-seq)))\n\n  ([coll]\n     (let [longest (longest-increasing [] 0 [(first coll)] 1 (rest coll))]\n       (if (>= (count longest) 2)\n         longest\n         ()))))","user":"5776e21de4b0979f89651642"},{"problem":53,"code":"#(loop [best [], accum [], prev nil, [a & d :as remaining] %]\n     (cond\n       ;; Game over\n       (empty? remaining) best\n       ;; Restart accumulated\n       (or (not prev) (<= a prev))\n       (recur best [a] a d),\n       ;; (a > prev): Extend the longest sequence\n       (>= (count accum) (count best))\n       (let [best+ (conj accum a)]\n         (recur best+ best+ a d)),\n       ;; (a > prev): Extend accum only\n       :else\n       (let [accum+ (conj accum a)]\n         (recur best accum+ a d))))","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":53,"code":"(fn [col]\n   (let [ seqs (reduce (fn [ac itm]\n                         (let [current (first ac) lastnum (last current)]\n                           (if (or (not lastnum) (= (inc lastnum) itm))\n                             (conj (drop-last ac) (conj current itm)) (conj ac [itm] )))) [[]] col)]\n (or (->> seqs\n          (filter #(> (count %) 1))\n          (sort-by count)\n          (last)) [])\n     ))","user":"5d5eb086e4b0c9e5857d4ff7"},{"problem":53,"code":"(fn [coll]\n   (let [longest (atom [(first coll)])\n         current (atom [(first coll)])]\n     (doseq [x (drop 1 coll)] \n       (if (> x (peek @current))\n         (swap! current conj x)\n         (swap! current (fn [_] [x])))\n       (if (> (count @current) (count @longest))\n         (swap! longest (fn [_] @current))))\n     (if (> (count @longest) 1) @longest [])))","user":"5935b010e4b04f87174def55"},{"code":"(fn [sq]\n  (reverse\n    ((fn lss [l c sq]\n       (if (empty? sq)\n         l\n         (if (and (number? (first c)) (> (first sq) (first c)))\n           (let [cn (cons (first sq) c)]\n             (lss (if (> (count cn) (max (count l) 1))\n                    cn l)\n                  cn (rest sq)))\n           (lss l (list (first sq)) (rest sq)))))\n      () () sq)))","problem":53,"user":"4e8f5eba535d65386fec214c"},{"code":"(fn [coll]\n  (loop [idx 0 c [] l []]\n    (if (= idx (count coll))\n      (if (> (count l) 1) l [])\n      (let [prev (if (> idx 0) (coll (dec idx)) -1) cur (coll idx)]\n        (if (> cur prev)\n          (let [nc (conj c cur)] (recur (inc idx) nc (if (> (count nc) (count l)) nc l)))\n          (recur (inc idx) [cur] (if (> (count l) 1) l [cur])))))))","problem":53,"user":"5007f751e4b0b17c647f522b"},{"code":"(fn [s] (-> (last (sort-by count (map (fn [[s c]] (map second (take-while #(= (second %) (get c (first %))) (keep-indexed vector s)))) (map (fn [s] [s (into [] (range (first s) (+ (first s) (count s))))]) (take-while          \r\n  not-empty (iterate rest s)))))) (#(if (= 1 (count %)) [] %))))","problem":53,"user":"4ddbf54e535d02782fcbe9ff"},{"problem":53,"code":"(fn [col]\n   (let [longer-fn (fn [col-a col-b]\n                   (if (< (count col-a) (count col-b))\n                     col-b\n                     col-a)) \n         filter-res-fn (fn [col]\n                         (if (< 1 (count col))\n                           col []))\n         solv-fn (fn [col longest current]\n                   (let [ff (first col)\n                         ll (last current)]\n                     (if (nil? ff) \n                       (filter-res-fn (longer-fn longest current))                       (if (or (nil? ll) (> ff ll)) \n                       (recur (rest col) \n                              longest \n                              (conj current ff))\n                       (recur (rest col) \n                              (longer-fn longest current) \n                              [ff])))))]\n         (solv-fn col  [] [])))","user":"50856bd1e4b004985b776e4c"},{"code":"(fn longest-seq [s]                                                                                              \n  (loop [remaining s                                                                                               \n         longest []                                                                                                \n         cur-seq []]                                                                                               \n    (if (empty? remaining)                                                                                         \n      (if (>= (count longest) 2) longest [])                                                                       \n      (let [x (first remaining)                                                                                    \n            l (last cur-seq)                                                                                       \n            consecutive? (or (nil? l) (= x (inc l)))                                                               \n            new-seq (if consecutive? (conj cur-seq x) [x])                                                         \n            new-seq-len (count new-seq)                                                                            \n            new-longest (if (> new-seq-len (count longest)) new-seq longest)]                                      \n        (recur (rest remaining) new-longest new-seq)))))","problem":53,"user":"51899891e4b0288ada3dbdab"},{"problem":53,"code":"(fn [x]\n  (let [v (last \n           (sort \n            (filter \n             (fn [x] (> (count x) 1)) \n             (reduce #(if (= (inc (last (last %))) %2) (conj % (conj (last %) %2)) (conj % [%2])) [[(first x)]] (rest x)))))]\n    (if (nil? v) [] v)))","user":"562d869be4b0a45d2ff8301f"},{"problem":53,"code":"(fn [xs] \n  (let [difs (map - (rest xs) xs)\n        bylen \n        (reduce \n         (fn [acc el] \n           (if (> (:dif el) 0) \n             (assoc acc :current (conj (:current acc) (:el el))) \n             (if (and (> (count (acc :current)) 1) (not (contains? (acc :bylen) (count (acc :current))))) \n               (assoc acc :bylen (assoc (acc :bylen) (count (acc :current)) (acc :current) ) :current [(:el el)])\n               (assoc acc :current [(:el el)])) )) \n         {:bylen {} :current [(first xs)]} \n         (map #(assoc {} :el %1 :dif %2) (rest xs) difs))\n        current (bylen :current)]\n    (if (empty? (bylen :bylen))\n      (if (> (count current) 1)\n        current\n        [])\n      (let [maxkey (reduce max (keys (bylen :bylen)))\n            longest (if (> (count current) (int maxkey)) current ((bylen :bylen) maxkey))] \n        longest))\n    ))","user":"56b35565e4b0982f16b37e16"},{"problem":53,"code":"(fn my53 [s]\n  (loop [x 0 m [(first s)]]\n    (if (< x (count s))\n      (let [nm\n        (loop [y (inc x) mx [(nth s x)]]\n          (if (and (< y (count s))\n               (> (nth s y) (last mx)))\n            (let [nmx (conj mx (nth s y))]\n              (recur (inc y) nmx))\n            mx))]\n        (recur (inc x) (if (> (count nm) (count m)) nm m)))\n        (if (< (count m) 2) [] m))))","user":"576844cde4b0a07e8fc180ce"},{"problem":53,"code":"(fn n53\n  [s]\n  (->> (partition 2 1 s)\n       (partition-by #(< (first %) (last %)))\n       (map flatten)\n       (map distinct)\n       (filter #(< (first %) (last %)))\n       (reduce #(if (>= (count %) (count %2)) % %2) [])))","user":"55bf6dbce4b01b9910ae2a12"},{"code":"(comp #(if (> (count %) 1) % [])\n      #(->> %\n            (map-indexed list)\n            (partition-by (partial apply -))\n            (apply max-key count)\n            (map second)))","problem":53,"user":"536973e5e4b0243289761e9e"},{"problem":53,"code":"(fn [v]\n  (reduce \n    (fn [acc n] (if (> (count n) (count acc)) n acc))\n    []\n  (filter #(> (count %) 1)\n    ; can't use `reduced` fn before clojure 1.5\n    (map first\n      (map (fn [ss]\n        (reduce\n          (fn [[acc reduced] n]\n            (if (and (not reduced) (> n (last acc)))\n              [(conj acc n) false]\n              [acc true]\n            ))\n        [[(first ss)] false] (rest ss))\n    )\n    (map (fn [i] (subvec v i)) (range (count v)))\n  ))))\n)","user":"5aa998c6e4b0d174b936c8e5"},{"problem":53,"code":"(fn longest-incr-subseq' [coll]\n  (letfn\n   [(dedup' [acc [x & xs :as coll]]\n      (if-not (seq coll)\n        acc\n        (recur (if (= (last acc) x) acc (conj acc x)) xs)))\n    (subseqs [c]\n             (->>\n              (map #(if (< %1 %2) (list %1 %2))\n                   c (rest c))\n              flatten\n              (dedup' [])\n              (partition-by nil?)\n              (group-by count)))\n    (longest-subseqs [s-map]\n                     (when-let [k (keys s-map)]\n                       (s-map (apply max k))))]\n    (if-let [k (longest-subseqs (subseqs coll))]\n      (first k)\n      (rest nil))))","user":"5e976fa8e4b0157ca96647cf"},{"problem":53,"code":"(fn ls\n  ([lst] (ls [(first lst)] (rest lst) [])) \n  ([cur lst best]\n    (let [n (first lst)\n          r (rest lst)\n          c (count cur)\n          b (if (and (> c (count best)) (> c 1)) cur best)]\n      (cond\n        (empty? lst) b\n        (= n (inc (last cur))) (ls (conj cur n) r b)\n        :else (ls [n] r b)\n      ))))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn sseq [l]\n  (let [ls (apply max-key count ((fn spart [l]\n                                   (if (= (count l) 1)\n                                     l\n                                     (when-let [[f & r] (seq l)]\n                                       (if (sequential? f)\n                                         (if (= (inc (last f)) (first r))\n                                           (spart (cons (concat f (list (first r))) (rest r)))\n                                           (concat (list f) (spart r)))\n                                         (if (= (inc f) (first r))\n                                           (if (= (count r) 1)\n                                             (list (concat (list f) (list (first r))))\n                                             (spart (cons (concat (list f) (list (first r))) (rest r))))\n                                           (if (= (count r) 1)\n                                             (list (list f) r)\n                                             (cons (list f) (spart r)))))))) l))]\n    (if (< (count ls) 2)\n      []\n      ls)))","problem":53,"user":"5368a275e4b0243289761e8f"},{"code":"(fn [s]\n  (let [[start len] (->> (partition 2 1 s)\n                         (map (partial apply <))\n                         (map vector (range))\n                         (partition-by second)\n                         (filter (comp second first))\n                         (map (juxt (comp first first) count))\n                         (reverse)\n                         (cons [0 0])\n                         (apply (partial max-key second)))]\n    (if (pos? len)\n      (take (inc len) (drop start s))\n      [])))","problem":53,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":53,"code":"(fn maxasc [coll]\n                  (if  (< (count coll) 2)\n                    []  ;else\n                   (if (> (first coll)  (second coll)) ;if coll[0]> coll[1] then search in rest coll\n                      ( maxasc (rest coll))\n                      ;else\n                       (let [head (into [] (list (first coll)  (second coll)))\n                             tail (drop 2 coll) ]\n                         (loop [result head\n                                t tail]\n                           (if(empty? t)\n                             result\n                             (if (< (last result) (first t)) ;if first element of current tail greater than\n                               ;  last element of result then add it to the end of result and return to loop\n                                 (recur(into result (vector (first t))) (rest t))\n                                 ;else get head and tail\n                                 (if(>= (count result) (count (maxasc t))) ;compare length of result and\n                                   ;longest increasing consequtive subseq in current tail\n                                   result\n                                   ;else\n                                   (maxasc t)\n                                   )\n                                 )\n                               )\n                             );loop\n                         );let\n                       ))\n                   )","user":"5b9d3913e4b0c0b3ffbd4b37"},{"code":"(fn ss [l]\n  (let [p (vals (group-by identity\n                         (map-indexed #(- %1 %2) l)))\n        i (first (last (sort-by count p)))\n        m (map #(if (= i %1) %2 nil) (flatten p) l)\n        r (filter #(not (nil? %)) m)]\n       (if (> (count r) 1)\n           r\n           [])))","problem":53,"user":"4faac363e4b081705acca200"},{"code":"(fn [coll]\n  (let [a (partition-by (fn [[a b]] (< a b)) (partition 2 1 coll))\n        b (first (sort-by #(* -1 (count %)) a))\n        c (concat (map first (butlast b)) (last b))]        \n    (if (and (> (count c) 1) (< (first c) (second c)))\n      c\n      [])))","problem":53,"user":"50d93c53e4b0fd36a4b89223"},{"problem":53,"code":"(fn [c] \n  (let [[x & y] (->> (partition-by #(< (first %) (last %)) (partition 2 1 c))\n                     (filter #(< (ffirst %) (second (first %))))\n                     (reduce #(if (< (count %1) (count %2)) %2 %1) []))] \n   (concat x (map last y))))","user":"567c63f6e4b05957ce8c61bb"},{"problem":53,"code":"#(first (sort\n (comparator (fn [x y] (> (count x) (count y))))\n   (take (count %1)\n     ((fn rec [grid]\n       (let [stack ((fn [grd]\n  (loop [grid grd\n          result ()]\n      (let [\n          n (first grid)\n          y (second grid)]\n          (if (= (+ 1 n) y)\n            (recur (drop 1 grid) (cons n result))\n            (if (= (count result) 0) (list)\n            (reverse (cons n result)))))))\n grid)]\n         (cons stack (lazy-seq (rec (drop 1 grid)))))) %1))))","user":"53a5c7ffe4b0ef122a8689c4"},{"problem":53,"code":"(fn [col]\n  (let [r (filter\n            #(< 1 (count %))\n            (reduce (fn [r n]\n                      (if-not r\n                        [[n]]\n                        (let [last-seq (last r)\n                              l (last last-seq)]\n                          (if (= l (dec n))\n                            (assoc-in r [(dec (count r)) (count last-seq)] n)\n                            (assoc r (count r) [n])))))\n                    nil col))]\n    (if (empty? r)\n      []\n      (reduce\n        (fn [p n]\n          (if (> (count n) (count p)) n p))\n        r))))","user":"53403cf8e4b085b17e897da7"},{"problem":53,"code":"(fn [xs]\n  (let [xs1 (flatten (cons (first xs) (map (fn [d1 d2] (if (< d1 d2) d2 (list nil d2))) xs (rest xs))))]\n     (let [xs2 (partition-by nil? xs1)]\n       (let [xs3 (filter (fn [x] (not (nil? (first x)))) xs2)]\n         (let [xs4 (reduce (fn [acc v]\n                   \t(let [ac (count acc), vc (count v)]\n                     (if (< ac vc)\n                            v\n                            acc))) '() xs3)]\n           (if (< (count xs4) 2)\n             []\n             xs4))))))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":53,"code":"(fn longest-incr-subseq \n  ([l]\n   (longest-incr-subseq l 2 [])\n  )\n  ([l n myseq]\n   (if (> n (count l))\n   \t myseq\n     (let [sub (take n l)]\n       (if (apply < sub)\n         (longest-incr-subseq l (inc n) sub)\n         (longest-incr-subseq (drop (dec n) l) n myseq)\n       )\n     )\n    )\n  )\n)","user":"54c82b27e4b045293a27f645"},{"problem":53,"code":"(let [\n\ntake-while-inc (fn [s]\n   (loop [prev (first s) remaining (rest s) res [prev]]\n     (let [n (first remaining)]\n      (if (or (empty? remaining) (>= prev n))\n           res\n           (recur n (rest remaining) (conj res n))\n        )\n       )\n     )\n  )\n\nlongest-inc-subseq (fn [s]\n  (loop [sub (take-while-inc s) remaining (drop (count sub) s)]\n    (if (empty? remaining)\n      sub\n\n    (let [n (take-while-inc remaining)]\n      (if (> (count n) (count sub))\n        (recur n (drop (count n) remaining))\n        (recur sub (drop (count n) remaining))\n      )\n      )\n\n    )\n    )\n  )\n]\n(fn [s]\n  (let [longest (longest-inc-subseq s)]\n    (if (< 1 (count longest)) longest [])\n    )\n  )\n)","user":"54924f64e4b0b312c081ff42"},{"problem":53,"code":"(fn [s]\n  (let [increase-subsequences (fn [subsequences i]\n                                (conj (mapv\n                                      (fn [[variant-tag subsequence :as ts]]\n                                        (condp = variant-tag\n                                          :frozen ts\n                                          :growing\n                                          (if (< (last subsequence) i)\n                                            [:growing (conj subsequence i)]\n                                            [:frozen subsequence])))\n                                      subsequences)\n                                      [:growing [i]]))]\n    (or (->> (reduce increase-subsequences [] s)\n             (mapv second)\n             (filterv #(> (count %) 1))\n             (sort-by (comp - count))\n             first)\n        [])))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"#(distinct \n   (flatten \n     (apply \n       (partial max-key count []) \n       (filter \n         (comp (partial = -1) (partial apply -) first)\n         (partition-by (fn [[x y]] (if (= 1 (- y x)) 0)) (partition 2 1 %))))))","problem":53,"user":"4e929dd0535dbda64a6f6b05"},{"problem":53,"code":"(fn [coll]\r\n  (let [longest (apply max-key count\r\n                       (reduce\r\n                        (fn [result n]\r\n                          (if (and (not-empty result) (= n (inc (last (last result)))))\r\n                            (assoc-in result [(dec (count result)) (count (last result))] n)\r\n                            (conj result [n])))\r\n                        []\r\n                        coll))]\r\n    (if (= 1 (count longest)) [] longest)))","user":"56f514cee4b046a417f92068"},{"code":"(fn [coll] (loop [c (rest coll) longest [] acc [(first coll)]] \n             (if (= [nil] acc) (if (= 1 (count longest)) [] longest)\n             (if (= (inc (last acc)) (first c))\n               (recur (rest c) longest (conj acc (first c)))\n               (recur (rest c) (if (> (count acc) (count longest))\n                                 acc longest) [(first c)])))))","problem":53,"user":"50e0d5a3e4b061dbdced723d"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n       (reduce (fn [acc e]\n                 (let [ret (:ret acc)\n                       curr (:curr acc)\n                       curr (if (or (empty? curr) (= e (inc (last curr))))\n                              (conj curr e) [e])\n                       ret (if (and (> (count curr) 1) (> (count curr) (count ret)))\n                             curr ret)]\n                   (assoc (assoc acc :ret ret) :curr curr)))\n               {:ret [] :curr []})\n       :ret))","user":"5b9357b7e4b0c0b3ffbd4a46"},{"problem":53,"code":"(fn [xs]\n  (let [ys (mapcat (fn [val index prev] (if (>= prev val) [index] [])) \n                  (rest xs)\n                  (range 1 (count xs))\n                  (drop-last xs)) \n        zs (map list (cons 0 ys) (conj (vec ys) (count xs)))\n        ts (map (partial apply subvec xs) zs)\n        longest (first (second (apply max-key first (group-by count ts))))]\n    (if (> (count longest) 1) longest [])))","user":"5f247827e4b0f565ad998292"},{"problem":53,"code":"(fn [c0]\n  (letfn \n   [(inc? [[x0 x1]]\n          (= 1 (- x1 x0)))\n    (acc [[b0 b1 c0 c1] p]\n         (let \n          [nc0 (if p c0 c1)\n           nc1 (inc c1)\n           nb (< (- b1 b0) \n                 (- nc1 nc0))\n           nb0 (if nb nc0 b0)\n           nb1 (if nb nc1 b1)]\n          (vector nb0 nb1 \n                  nc0 nc1)))]\n   (let [c1 (partition 2 1 c0)\n         c2 (map inc? c1)\n         [b0 b1 _ _]\n           (reduce acc \n                   [0 0 0 1] \n                   c2)]\n     (if (> (- b1 b0) 1)\n       (subvec c0 b0 b1)\n       []))))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":53,"code":"(fn [v-in]\n  (:max (reduce (fn [m x]\n                  (cond\n                    (nil? (:working m)) (assoc m :max [] :working [x])\n                    (not= x (inc (last (:working m)))) (assoc m :working [x])\n                    :else (let [wrk (conj (:working m) x)]\n                            (if (and (>= (count wrk) 2) (> (count wrk) (count (:max m))))\n                              (assoc m :max wrk :working wrk)\n                              (assoc m :working wrk)))))\n                {}\n                v-in)))","user":"56a79eb0e4b07966d5a8a05d"},{"code":"(fn [xs]\n  (let [cnt (count xs)]\n    (if (>= 1 cnt)\n      xs\n      (let [is-inc #(< (xs (dec %)) (xs %))\n            release #(if (< (count %) 2) '() %)\n            subvec #(subvec xs %1 %2)\n            last (dec cnt)]\n        (loop [start 0 end 0\n              curstart 0 curend 1]\n          (if (== curend last)\n            (if (is-inc curend)\n              (if (< (- end start) (- curend  curstart))\n                (release (subvec curstart (inc curend)))\n                (release (subvec start    (inc end))))\n              (if (< (- end start) (- (dec curend) curstart))\n                (release (subvec curstart curend))\n                (release (subvec start (inc end)))))\n            (if (is-inc curend)\n              (recur start end curstart (inc curend))\n              (if (< (- end start) (- curend 1 curstart))\n                 (recur curstart (dec curend) curend (inc curend))\n                 (recur start end curend (inc curend))))))))))","problem":53,"user":"4e593dac535d8a8b8723a29c"},{"problem":53,"code":"(fn [c] (->> (reduce #(if (= (peek (peek %)) (dec %2))\n                                   (conj % (conj (peek %) %2))\n                                   (conj % [%2]))\n                                [] c)\n                        (map #(if (= (count %) 1) [] %))\n                        (sort-by count)\n                        last))","user":"4e6961f0535d8ccf87e9fe9b"},{"problem":53,"code":"(fn [input] \n  (let [candidates \n        (filter (fn [s] (every? #(= (inc (first %)) (second %)) \n                                (map list s (rest s))))\n                (filter #(> (count %) 1) \n                        (for [length (range 2 (inc (count input))) \n                              offset (range (count input))] \n                          (take length (drop offset input)))))]\n    (if (empty? candidates) [] (apply max-key count candidates))))","user":"5d3ae729e4b01671435dbd5d"},{"problem":53,"code":"(fn \n      [l]\n      ( into []\n        ( reverse \n          (apply max-key count '()\n            (filter #(> (count %) 1) \n              (reduce (fn [acc x]( if ( empty? acc)\n                ( cons (list x) acc)\n                ( if ( #( if (= % (inc %2 )) true false)  x ( first ( first acc))) \n                  ( cons ( cons x ( first acc) ) (rest acc) )\n                  ( cons (list x) acc)\n                  )\n                )) '() l ) \n              ) \n            ) \n          ) \n        ) \n      )","user":"54fc7d89e4b07d26eda61d2b"},{"code":"(fn [xs] (loop [part-size (dec (count xs))]\n    (if (= part-size 1)\n      []\n      (let [part (partition part-size 1 xs)\n            subseq-part (filter (fn [p1] (not= nil (reduce #(if (and % (= (inc %) %2)) %2 nil) p1))) part)]\n        (if (= 1 (count subseq-part))\n          (first subseq-part)\n          (recur (dec part-size)))))))","problem":53,"user":"513fab65e4b00f13ea1bd891"},{"problem":53,"code":"(fn f\n  ([src]\n    (f src [] []));javaoverload\n  ([src result temp]\n    (let [sizeT (count temp) sizeR (count result) item (first src) others (rest src)]\n      (cond (empty? src) (if (> sizeT sizeR 1) temp result);#1 #5\n            (empty? temp) (recur others result [item])\n            (> item (last temp)) (recur others result (conj temp item));#3\n            (< sizeT 2) (recur others result [item]);#5\n            (< sizeR sizeT) (recur others temp [item]);#4\n            :else (recur others result [item]))));#4\n)","user":"544b699ce4b0e39780006964"},{"problem":53,"code":"(fn [xs]\n  (let [acc (reduce (fn [acc x] (->> acc\n                (#(if (or (empty? (:c %)) (> x (last (:c %)))) (assoc % :c (conj (:c %) x)) (assoc % :c [x])))\n                (#(if (> (count (:c %)) (count (:l %))) (assoc % :l (:c %)) %)))) {:l [] :c []} xs)]\n    (if (> (count (:l acc)) 1) (:l acc) [])))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":53,"code":"(fn [coll] \n  (let [a (partition-by #(< (first %) (last %)) (partition 2 1 coll))\n        b (filter #(< (first (first %)) (second (first %))) a)\n        c (reduce #(if (< (count %1) (count %2)) %2 %1) [] b)] \n   (concat (first c) (map last (rest c)))))","user":"5691ef12e4b0dcc4269f40f8"},{"code":"(fn [s]\n  (loop [max-seq [] s s]\n    (if (empty? s)\n      (if (>= (count max-seq) 2)\n        max-seq\n        [])\n      (let [cur-best (loop [cur -1 cur-longest [] s s]\n                       (if (or (empty? s) (<= (first s) cur))\n                         cur-longest\n                         (recur (first s) (conj cur-longest (first s)) (rest s))))]\n        (if (> (count cur-best) (count max-seq))\n          (recur cur-best (rest s))\n          (recur max-seq (rest s)))))))","problem":53,"user":"4fb4f42ae4b081705acca2b4"},{"problem":53,"code":"(fn longest-sub-seq [xs]\n  (let [res (reduce\n             (fn [m x]\n               (if (< (last (:c m)) x)\n                 (assoc m :c (conj (:c m) x))\n                 (if (< (count (:p m)) (count (:c m)))\n                   (assoc m :p (:c m) :c [x])\n                   (assoc m :c [x]))))\n             {:p [] :c [(first xs)]} (rest xs))]\n    (let [r (if (>= (count (:p res)) (count (:c res))) (:p res) (:c res))]\n      (if (> (count r) 1) r []))))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn [coll]\n   (loop [res []\n          tres []\n          curr (first coll)\n          rst (rest coll)]\n     (if (nil? curr)\n       (if (nil? (next res)) [] res)\n       (let [f (fn [x y] (= x (dec y)))\n             val (f (last tres) curr)\n             tr (if val\n                  (conj tres curr)\n                  [curr])\n             r (if (> (count tr) (count res)) tr res)]\n         (recur\n          r\n          tr\n          (first rst)\n          (rest rst)\n          )))))","problem":53,"user":"506c0a02e4b0eda3100c090d"},{"code":"(fn [s]\n      (->>(count s)\n      ((fn [n]\n          (reduce into\n          (map (fn [x y] (map (partial vector x) y))\n            (range 1 (inc n))\n            (map (constantly (range 1 (inc n)))\n              (range n)))))\n          )\n      (filter (fn [[x y]] (< x y) ))\n      (map (fn [[x y]] (->> s (take y) (drop (dec x)))))\n      (reduce conj ())\n      (filter #(= % (sort %)) )\n      (filter #(apply distinct? %))\n      (group-by count)\n      (#(get % (apply max -1 (keys %))))\n      (first)\n      (vec)\n      )\n)","problem":53,"user":"4f4a34b2e4b0d56e7bb92c09"},{"problem":53,"code":"(fn longest-increasing-sub-seq\n  ([sqn]\n    (if (< (count sqn) 2)\n      []\n      (if (>= (first sqn) (second sqn))\n        (recur (rest sqn))\n        (longest-increasing-sub-seq (vec (take 2 sqn)) (drop 2 sqn)))))\n  ([chain remaining]\n    (if (empty? remaining)\n      chain\n      (if (< (last chain) (first remaining))\n        (recur (conj chain (first remaining)) (rest remaining))\n        (let [nextchain (longest-increasing-sub-seq remaining)]\n          (if (> (count nextchain) (count chain))\n            nextchain\n            chain))))))","user":"569f99cce4b0542e1f8d1497"},{"problem":53,"code":"#(let [ss \n(reduce\n (fn [s x]\n  (if (empty? s)\n   [[x]]\n   (let [l (last s)]\n    (if (= x (inc (last l)))\n     (conj (vec (butlast s))\n           (conj l x))\n     (conj s [x])))))\n []\n %)\n       m (apply max \n          (map count ss))]\n   (if (= m 1)\n    []\n    (first\n     (filter\n      (fn [x]\n       (= (count x) m))\n      ss))))","user":"51e5a627e4b0efabf93c02db"},{"problem":53,"code":"(fn [seq] (->> seq (reduce \n                    (fn [[r t] i]\n                      (if (empty? t)\n                        [r (conj t i)]\n                        (if (= (last t) (- i 1))\n                          [r (conj t i)]\n                          (if (> (inc (count t)) (count r)) \n                            [t [i]]\n                            [r [i]]))))\n                    [[] []])\n               ((fn [[r t]]\n                  (if (> (count t) (count r))\n                    t\n                    r)))\n               ((fn [s]\n                  (if (= 1 (count s))\n                    []\n                    s)))\n               ))","user":"5ad002f2e4b0ea6055cfab87"},{"problem":53,"code":"(fn longest-increasing-sub-seq [ms]\n  (letfn [(first-increaseing-seq [xs ys len y]\n                                  (let [[x & r] xs]\n                                    (cond\n                                     (nil? x) [ys len y]\n                                     (nil? y) (recur r [x] 1 x)\n                                     (> x y) (recur r (concat ys [x]) (inc len) x)\n                                     :else [ys len y])))\n          (get-longest [xs ys len]\n                        (if (nil? xs)\n                          [ys len]\n                          (let [[new-ys new-y-len new-y] (first-increaseing-seq xs nil 0 nil)]\n                            (cond\n                               (= 0 new-y-len) [ys len]\n                               (> new-y-len len) (recur (drop new-y-len xs) new-ys new-y-len)\n                               :else (recur (drop new-y-len xs) ys len)))))]\n    (let [[ys len] (get-longest ms nil 0)]\n      (if (> len 1) ys []))))","user":"5688a01be4b0dcc4269f406d"},{"problem":53,"code":"(fn [s]\n\n  (loop [longest []\n         work []\n         s s]\n    (if-not (seq s)\n      (-> (sort-by count [longest work])\n                     last\n                     ((fn [s] (if (<= (count s) 1) [] (if (= (count s) (count longest)) longest s)))))\n      (if-not (seq work)\n        (recur longest (conj work (first s)) (rest s))\n        (if-not (apply < (conj work (first s)))\n          (recur (-> (sort-by count [longest work])\n                     last\n                     ((fn [s] (if (<= (count s) 1) [] (if (= (count s) (count longest)) longest s)))))\n                 [(first s)]\n                 (rest s))\n          (recur longest (conj work (first s)) (rest s))))\n      )\n    ))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [s]\n  (let [up (fn [x] (<= (last x) (first x))),\n        onlypos (fn [x] (filter #(<= 0 %) x)),\n        gtz (fn [x] (if (< 1 (count x)) x [])),\n        recover (fn [x] (-> x\n                            flatten\n                            set\n                            onlypos\n                            sort\n                            gtz)),\n        find (fn [x] (last (sort-by count x)))]\n    (recover\n      (find\n        (remove\n        #(up (first %))\n        (partition-by up\n          (map\n            #(vector % %2)\n            (conj\n              (apply list s) -1)\n              (apply list s))))))))","problem":53,"user":"4ec56b5b535d6d7199dd369f"},{"problem":53,"code":"(fn [xs0]\n  (loop [xs xs0\n         longest-subseq []\n         current-subseq []]\n    (if-let [[x & more] xs]\n      (if-let [last-x (last current-subseq)]\n        (if (> x last-x)\n          (recur more longest-subseq (conj current-subseq x))\n          (if (and (>= (count current-subseq) 2)\n                   (> (count current-subseq) (count longest-subseq)))\n            (recur xs current-subseq [])\n            (recur xs longest-subseq [])))\n        (recur more longest-subseq [x]))\n      (if (and (>= (count current-subseq) 2)\n               (> (count current-subseq) (count longest-subseq)))\n        current-subseq\n        longest-subseq))))","user":"4ff24a1ae4b0678c553fc337"},{"code":"(fn [ l ] \n  (let [\n        s (cons (vector (first l)) (rest l))\n        m (reduce #(concat %1 (if (< (last %1) %2 ) (list %2) (list :a %2) ) ) s )\n        k (reduce #(if (< (count %1) (count %2) ) %2 %1 ) (partition-by #(= :a %) m))\n      ] \n    ( if (< (count k) 2 ) [] k ) ))","problem":53,"user":"4fc43a8ee4b081705acca346"},{"problem":53,"code":"(fn [xs] \n    (->> (reduce #(if(= (last %1) (dec %2)) (conj %1 %2) (conj %1 \"|\" %2)) [] xs)\n         (partition-by #(= \"|\" %))\n         (filter #(> (count %) 1))\n         (concat [[]]) ;; to preverent (first []) -> nil\n         (apply max-key count)\n         ))","user":"55c6fd60e4b0e31453f649c9"},{"problem":53,"code":"(fn [xs] \n  (reduce #(if (< (count %1) (count %2)) %2 %1) []\n          (filter #(apply < %) \n                  ((fn subseqs [coll] \n                     (when-let [s (seq coll)] \n                       (let [n (inc (count coll))] \n                         (concat\n                           (map take (range 2 n) (repeat s)) \n                           (subseqs (rest s)))))) \n                    xs))))","user":"50cf94bde4b0abc485cb9bb2"},{"problem":53,"code":"#(last\n (map\n  (fn [a]\n    (if (= (count a) 1)\n      []\n      a))\n  (sort\n   (reduce\n    (fn [a b]\n      (if (= (last (last a)) (- b 1))\n        (assoc-in a [(- (count a) 1) (count (last a))] b)\n        (conj a [b])))\n    [[]]\n    %))))","user":"5d5c6675e4b09db18d4482ec"},{"code":"(fn longest-inc-seq [coll]\n  (reduce #(let [len-a (count %1)\n                 len-b (count %2)]\n             (if (and (> len-b 1) (> len-b len-a)) %2 %1))\n    []  \n    (reductions\n      (fn [xs y]\n        (if (> y (last xs)) (conj xs y) [y]))\n      [(first coll)]\n      (rest coll))))","problem":53,"user":"5020d2aee4b0cb6ebc0a42fb"},{"problem":53,"code":"(fn [[l & ls]]\n  (reverse\n   (first\n    (reverse\n     (sort-by\n      count\n      (filter\n       #(> (count %) 1)\n       (reduce\n        (fn [[a & acc] x]\n          (if (= (inc (first a)) x)\n            (cons (cons x a) acc)\n            (cons (list x) (cons a acc))))\n        [[l]]\n        ls)))))))","user":"56050f06e4b08b23635d3161"},{"code":"(letfn [(s [l] (let [c (count l)] (for [a (range (- c 2)) n (range 2 (+ 1 c))] (take n (drop a l)))))\n        (i [l] (every? #{1} (map - (rest l) (butlast l))))]\n  #(if-let [c (seq (filter i (s %)))]\n    (apply max-key count c)\n    []))","problem":53,"user":"4e82f85d535db62dc21a62ce"},{"problem":53,"code":"(fn grow [c]\n  (let [max-list\n        (fn [s t]\n          (if (> (count t) (count s))\n            t\n            s))\n        step\n        (fn [c res acc]\n          (if-let [s (seq c)]\n            (if (second s)\n              (if (< (first s) (second s))\n                (recur (rest c) res (cons (second s) acc))\n                (recur (rest c) (max-list res acc) (list (second s))))\n              (max-list res acc))\n            (max-list res acc)))\n        or-empty\n        (fn [c]\n          (if (seq (rest c))\n            c\n            ()))]\n    ((comp or-empty reverse) (step c () (list (first c))))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":53,"code":"(fn lcs\n    ([x]\n     (lcs (rest x) [(first x)] [(first x)])\n     )\n    ([x c l]\n     (if (empty? x)\n       (if (> (count c) (count l))\n         (if (> (count c) 1) c [])\n         (if (> (count l) 1) l [])\n         )\n       (if (= (first x) (inc (last c)))\n         (lcs (rest x) (conj c (first x)) l)\n         (if (> (count c) (count l))\n           (lcs (rest x) [(first x)] c)\n           (lcs (rest x) [(first x)] l)\n           )\n         )\n       )\n     )\n    )","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":53,"code":"(fn best-subseq [nums]\n  (let [subseqs\n        (loop [acc []\n               current [(first nums)]\n               remaining (rest nums)]\n          (let [x (last current)\n                [y & remaining'] remaining]\n            (cond\n              (empty? remaining) (if (empty? current) acc (conj acc current))\n              (< x y) (recur acc (conj current y) remaining')\n              :else (recur (conj acc current) [y] remaining'))))\n        candidates (remove #(<= (count %) 1) subseqs)\n        best (last (sort-by count (map first (vals (group-by count candidates)))))]\n    (if (nil? best) [] best)))","user":"5e17bb46e4b00200644e3d5a"},{"problem":53,"code":"#(reduce (fn [g h]\n (if (and (> (count h) 1)\n          (> (count h)\n             (count g)))\n  h g)) []\n((fn group\n ([l] (if (empty? l)\n       (list)\n       (group\n        (vector (first l))\n        (rest l))))\n ([g l]\n  (if (empty? l)\n   (list g)\n   (if (= (inc (last g))\n          (first l))\n    (group\n     (conj g (first l))\n     (rest l))\n    (conj\n     (group\n      (vector (first l))\n      (rest l))\n     g))))) % ))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn longest-inc-seq [coll]\n  (reduce #(let [len-a (count %1)\n                 len-b (count %2)]\n             (if (and (> len-b 1) (> len-b len-a)) %2 %1))\n    []\n    (reductions\n      (fn [xs y]\n        (if (> y (last xs)) (conj xs y) [y]))\n      [(first coll)]\n      (rest coll))))","problem":53,"user":"4fcf763de4b03432b189f413"},{"problem":53,"code":"(fn increasing-sub-seq [s] (->>\n                              s\n                              (partition 2 1)\n                              (partition-by (fn[[f s]] (- s f) ))\n                              (filter #(= (inc (first (first %)))\n                                          (second (first %))))\n                              (sort-by count #(compare %2 %1))\n                              (first)\n                              (flatten)\n                              (partition-by identity)\n                              (map first)))","user":"5ed6030de4b016b56eae05db"},{"code":"(fn [coll]\n  (let [sb (first (reduce\n                   (fn [[r1 c1] e]\n                     (let [c2 (if (< (last c1) e) (conj c1 e) [e])\n                           r2 (if (< (count r1) (count c2)) c2 r1)]\n                       [r2 c2]))\n                   [[][(first coll)]]\n                   (rest coll)))]\n    (if (< 1 (count sb)) sb [])))","problem":53,"user":"4e8c1d97535d65386fec2127"},{"problem":53,"code":"(fn [v]\n  (let [[_ longest] (reduce\n                     (fn [[current longest] x]\n                       (if (or (empty? current) (<= x (last current)))\n                         [[x] longest]\n                         (let [current (conj current x)\n                               longest (if (> (count current) (count longest)) current longest)]\n                           [current longest])))\n                     [[] []]\n                     v)]\n    (if (> (count longest) 1) longest [])))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":53,"code":"(fn [[h & t]]\n  (loop [longest [], cur [h], s t]\n    (let [[h & t] s\n          longest (if (>= (count longest) (count cur)) longest cur)\n          cur (if (= h (inc (peek cur))) (conj cur h) [h])]\n      (if (empty? s)\n        (if (>= (count longest) 2) longest [])\n        (recur longest cur t)))))","user":"5879d577e4b01531a375ead8"},{"problem":53,"code":"(fn [s] (->> (partition 2 1 s)\n          (partition-by #(pos? (- (second %) (first %))))\n          (reduce #(if (< (count %1) (count %2)) %2 %1))\n          (remove #(< (second %) (first %)))\n          flatten\n          distinct))","user":"5501a1e1e4b07d26eda61d75"},{"problem":53,"code":"(fn longest [coll]\n   (letfn [(length [ss] (let [cnt (count ss)] (if (> cnt 1) cnt Long/MIN_VALUE)))]\n     (loop [[x1 & [x2 & _ :as xs]] coll ss [x1] res []]\n       (if x2\n         (if (< x1 x2)\n           (recur xs (conj ss x2) res)\n           (recur xs [x2] (max-key length ss res)))\n         (max-key length ss res)))))","user":"5f300f28e4b033932238a682"},{"problem":53,"code":"(fn [coll]\n  (first (sort-by #(- 0 (count %)) (loop [[a b & c] coll s [] r []]\n    (if (nil? b)\n      (map #(if (= (count %) 1) [] %) (conj r (conj s a)))\n      (if (< a b)\n        (recur (cons b c) (conj s a) r)\n        (recur (cons b c) [] (conj r (conj s a)))))))))","user":"600cb742e4b074f607df6696"},{"code":"(fn [coll]\n   (let [subseqs (loop [last-found -1;Integer/MIN_VALUE\n                        [head & tail :as coll] coll\n                        current []\n                        all-found []]\n                   (cond (empty? coll)\n                         (conj all-found current)\n                         \n                         (> head last-found)\n                         (recur head\n                                tail\n                                (conj current head)\n                                all-found)\n\n                         :else\n                         (recur -1 ; Integer/MIN_VALUE\n                                coll\n                                []\n                                (conj all-found current))))\n         subseqs-by-count (->> subseqs\n                               (map (juxt count identity))\n                               (filter #(> (first %) 1))\n                               (map (partial apply assoc {}))\n                               (apply merge-with (fn [a b] a)))]\n     (if (empty? subseqs-by-count)\n       []\n       (subseqs-by-count (apply max (keys subseqs-by-count)))\n  )))","problem":53,"user":"4e9fd521535d7eef3080729a"},{"problem":53,"code":"(fn filter-inc-lists [x]\n    (let [inc-lists ((fn get-inc-list [sq] (reduce (fn [res ele] \n             (let [last-sq (last res) last-ele (last last-sq)]\n                 (if (or (empty? last-sq) (= (- ele 1) last-ele))\n                     (conj res (conj last-sq ele))\n                     (conj res [ele]))))\n         [[]] sq)) x) ]\n        (reduce #(if (and (>= (count %2) 2)\n                        (> (count %2) (count %1)))\n        %2 %1) [] inc-lists)))","user":"59d4a160e4b0ef0a1e9b5be7"},{"code":"(fn [s]\n  (let [differences (map - (rest s) (butlast s))  \n        coorddiffs  (map list differences (range))\n        runs (partition-by #(< 0 (first %)) coorddiffs)\n        upruns (filter #(< 0 (first (first %))) runs)\n        takeends (fn [eg] [(last (last eg)) (last (first eg))])\n        endstarts (map takeends upruns)\n        bylen (group-by #(apply - %) endstarts)\n        longest (if (= bylen {})\n                  [nil nil]\n                  (first (bylen (apply max (keys bylen)))))\n        [lend lstart] longest\n        ]   \n    (if lend\n      (take (- (+ 2 lend) lstart) (drop lstart s))\n      ())\n    ))","problem":53,"user":"4fbfe9a4e4b081705acca31f"},{"problem":53,"code":"(fn\t[array]\n\t(loop [cur-len (count array)\n\t\t   unuse-array array\n\t\t   origin-array array]\n\t\t(if (= cur-len 0)\n\t\t\t[]\n\t\t\t(if ((fn [array]\n\t\t\t\t\t(loop [a (first array)\n\t\t\t\t\t\t   b (rest array)\n\t\t\t\t\t\t   newest nil\n\t\t\t\t\t\t   flag true]\n\t\t\t\t\t\t(if (empty? b)\n\t\t\t\t\t\t\t(if (and (not (nil? newest)) (= (inc newest) a) flag)\n\t\t\t\t\t\t\t\tflag\n\t\t\t\t\t\t\t\tfalse)\n\t\t\t\t\t\t\t(if (false? flag)\n\t\t\t\t\t\t\t\tflag\n\t\t\t\t\t\t\t\t(recur (first b) (rest b) a (if (and (not (nil? newest)) (= (inc newest) a))\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t(if (nil? newest)\n\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\tfalse))))))) (take cur-len unuse-array))\n\t\t\t\t(take cur-len unuse-array)\n\t\t\t\t(recur \n\t\t\t\t\t(if (= cur-len (count unuse-array))\n\t\t\t\t\t\t(dec cur-len)\n\t\t\t\t\t\tcur-len)\n\t\t\t\t\t(if (= cur-len (count unuse-array))\n\t\t\t\t\t\torigin-array\n\t\t\t\t\t\t(rest unuse-array))\n\t\t\t\t\torigin-array)))))","user":"59b9e669e4b0a024fb6ae3db"},{"code":"(fn [xs]\n    (let [ys (map first\n               (first\n                 (sort-by #(- (count %))\n                   (partition-by second (map (fn [x r] [x (- x r)]) xs (range))))))]\n      (if (> (count ys) 1) ys ())))","problem":53,"user":"52a88c4de4b0c58976d9ac30"},{"problem":53,"code":"(fn [s]\n    (let [increasing? (fn [[x y]] (= x (dec y)))\n          subseqs (map #(set (apply concat %)) \n                    (filter #(increasing? (first %)) \n                            (partition-by #(increasing? %) (partition 2 1 s))))]\n      (if (empty? subseqs)\n        []\n        (vec (apply max-key count subseqs)))))","user":"5d1231dde4b02c15ef021995"},{"problem":53,"code":"(fn [rando-seq]\n  (loop [x (rest rando-seq) y [(first rando-seq)] z []]\n    (if (empty? x)\n      ;;(conj z y)\n      (let [result (reverse (sort-by count (conj z y)))]\n        (cond (= (count (first result)) 1) []\n              (= (count (first result)) (count (last result))) (last result)\n              :else (first result)))\n      (if (> (first x) (last y))\n        (recur (rest x) (conj y (first x)) z)\n        (recur (rest x) [(first x)] (conj z y))))))","user":"607d6bc1e4b03d835a6eaecc"},{"code":"(fn [x] (let [x (reverse x)\n              y (filter ffirst (partition-by first \n                      (map (juxt > list) x (rest x))))]\n              (if-not (empty? y) \n               (let [l (apply max-key count  y) m (map second l) f (ffirst m)]\n                  (vec (reverse (cons f (map second m)))))\n                [])))","problem":53,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn sub-seq [x]\n  (letfn [(do-divide [x y]\n            (cond (empty? y) [x []]\n                  (empty? x) (do-divide [(first y)] (vec (drop 1 y)))\n                  (< (last x) (first y)) (do-divide (conj x (first y)) (vec (drop 1 y)))\n                  :else [x y]))\n          (do-parts [x]\n            (let [[a b] (do-divide [] x)]\n              (if (empty? b)\n                [a]\n                (concat [a] (do-parts b)))))\n          (monoton-dec? [x]\n            (cond (< (count x) 2) true\n                  (< (first x) (second x)) false\n                  :else (monoton-dec? (rest x))))]\n    (if (monoton-dec? x)\n      []\n      (((reduce #(if (< (%1 0) (%2 0)) %2 %1) (group-by count (do-parts x))) 1) 0))))","problem":53,"user":"50733b31e4b0e3170b5a869a"},{"problem":53,"code":"(fn [seq]\n               ; Both rv and curseq are vectors\n               (let [fun (fn [[rv curseq] elem]\n                                      (if (> elem (last curseq))\n                                        [rv (conj curseq elem)]\n                                        (if (> (count curseq) (count rv))\n                                          [curseq [elem]]\n                                          [rv [elem]])))\n                            parts (reduce fun [[(first seq)] [(first seq)]] (rest seq))\n                            p1 (first parts)\n                            p2 (second parts)]\n                 (if (and (= (count p1) 1) (= (count p2) 1))\n                   []\n                   (if (> (count p2) (count p1))\n                     p2\n                     p1))))","user":"5a813b90e4b00b71e582a065"},{"problem":53,"code":"(fn f\n   ([coll]\n    (f coll [] []))\n   ([coll ans tmp]\n    (let [size_ans (count ans) size_tmp (count tmp) cur (first coll) oth (rest coll)]\n      (cond\n        (empty? coll) (if (> size_tmp size_ans 1) tmp ans)\n        (empty? tmp) (recur oth ans [cur])\n        (> cur (last tmp)) (recur oth ans (conj tmp cur))\n        (< size_tmp 2) (recur oth ans [cur])\n        (< size_ans size_tmp) (recur oth tmp [cur])\n        :else (recur oth ans [cur])))))","user":"5dfa1c67e4b0a607a9a45cc5"},{"code":"(fn max-inc [seq] \n(let [x\n(apply max-key count\n(reverse \n    ((fn break-when-decreasing\n        [seq]\n        ((fn go [vec seq] \n            (cond \n                (empty? seq) vec\n                (<= (first seq) (peek (peek vec))) (go (conj vec [(first seq)]) (rest seq))\n                :else (go (conj (pop vec) (conj (peek vec) (first seq))) (rest seq))\n            )\n          )\n          [[(first seq)]]\n          (rest seq)\n        )\n    )\n    seq)))] (if (= (count x) 1) [] x)))","problem":53,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":53,"code":"(fn [coll]\n  (let [enumseq #(for\n                   [i (range 0 (- (count %) 1))\n                    j (range 2 (inc (- (count %) i)))]\n                   (take j (drop i %))\n                   )\n        incseq? #(= % (sort %))\n        consec? #(= (dec (count %)) (- (last %) (first %)))]\n    (last (conj (sort-by count (filter (and incseq? consec?) (enumseq coll))) []))\n    )\n  )","user":"589a8dace4b00487982d5311"},{"code":"(fn [s]\n  (cond (zero? (count s)) []\n        (= 1 (count s)) [] ;; don't count length 1\n        :else (loop [ce (first s)\n                     s (rest s)\n                     cs [ce]\n                     stored []\n                     ]\n                (println [ce s cs stored])\n                (if (empty? s)\n                  (if (< (count stored) 2) [] stored)\n                  (let [n (first s)\n                        ncs (conj cs n)]\n                    (if (> n ce)\n                      (recur (first s) (rest s) ncs (if (< (count stored) (count ncs))  ncs  stored))\n                      (recur (first s) (rest s) [(first s)] stored)))))))","problem":53,"user":"4fb4b798e4b081705acca2af"},{"code":"#(reduce (fn [v sq] (if(>  (count sq)  (max (count v) 1)) sq v)) [] (reduce (fn [sos elt] (let [l (last (last sos))] (\n       if (nil? l) (conj (vec (butlast sos)) [elt]) \n                   (if (= 1 (- elt l)) (conj (vec (butlast sos)) (conj (last sos) elt))\n                                       (conj sos [elt]))))) [[]] %))","problem":53,"user":"5301a13ae4b0d8b024fd371e"},{"problem":53,"code":"(fn longest-increasing-sub-seq\n  [coll]\n  (let [candidates (reduce (fn [sub-seqs x]\n                             (println sub-seqs)\n                             (println x)\n                             (let [last-sub-seq (last sub-seqs)\n                                   last-element (last last-sub-seq)]\n                               (if (and last-element (< last-element x))\n                                 (conj (vec (drop-last sub-seqs)) (conj last-sub-seq x))\n                                 (conj sub-seqs [x]))))\n                           []\n                           coll)\n        longest-seq (reduce #(if (< (count %) (count %2))\n                               %2\n                               %) candidates)]\n    (if (< 1 (count longest-seq))\n      longest-seq\n      [])))","user":"51c8f1d8e4b07ef393169e5d"},{"problem":53,"code":"(fn longest [s0]\n  (let [sub-seq (fn [s]\n                  (if (empty? s)\n                    []\n                    (loop [acc [] x (first s) s1 (rest s)]\n                      (if (and (seq s1) (= x (dec (first s1))))\n                        (recur (conj acc x) (first s1) (rest s1))\n                        (conj acc x)))))\n        find-max (fn find-max [curr n]\n                   (if (or (empty? n) (> (count curr) (count n)))\n                     curr\n                     (let [sn (sub-seq n)]\n                       (if (>= (count curr) (count sn))\n                         (find-max curr (rest n))\n                         (find-max sn (rest n))))))\n        result (find-max (sub-seq s0) (rest s0))]\n    (if (<= (count result) 1)\n      []\n      result)))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":53,"code":"(fn omg [xs]\n  (let [foo (fn f [ys]\n              (if (= 0 (count ys))\n                []\n                (let [y (first ys) ymore (rest ys)]\n                  (if (= (inc y) (first ymore))\n                    (vec (concat [y] (f ymore)))\n                    [y]))))\n        bar (fn f [ys]\n              (if (= 0 (count ys))\n                nil\n                (let [v (foo ys)]\n                  (concat []\n                          [v]\n                          (f (drop (count v) ys))))))\n        vv (bar xs)\n        nn (map count vv)\n        mm (apply max nn)]\n    (if (= mm 1)\n      []\n      (first (for [xx vv\n                   :when (= mm (count xx))] xx)))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":53,"code":"(fn ([c] (:m (reduce\n         #(let [{:keys [m s l]} %1 n (conj s %2)]\n           (if (= l (dec %2))\n             (assoc %1\n               :s n\n               :m (if (> (count n) (count m)) n m)\n               :l %2)\n             (assoc %1\n               :s (vector %2)\n               :m m\n               :l %2)\n           ))\n         {:m [] :s []} c))))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"(fn longest [lst]\r\n  (loop [ls (rest lst) xs '() ys (list (first lst))]\r\n    (if (= (first ls) nil)\r\n      (if (> (count xs) (count ys))\r\n  (if (= (count xs) 1) [] (reverse xs))\r\n\t(if (= (count ys) 1) [] (reverse ys)))\r\n      (if (or (= (first ys) nil)\r\n\t      (= (+ (first ys) 1) (first ls)))\r\n\t(recur (rest ls) xs (conj ys (first ls)))\r\n\t(if (> (count xs) (count ys))\r\n\t  (recur (rest ls) xs (list (first ls)))\r\n\t  (recur (rest ls) ys (list (first ls))))))))","problem":53,"user":"4ddc620d535d02782fcbea06"},{"problem":53,"code":"(fn [col]\n  (->> col\n       (reduce (fn [acc x] (conj (map #(conj % (if (= (last %) (dec x)) x :x)) acc) [x])) [])\n       (mapv (fn [reslist] (filter #(not= % :x) reslist)))\n       (filter #(> (count %) 1))\n       (sort-by count)\n       last\n       vec))","user":"5d51377be4b0776584bd6f5d"},{"problem":53,"code":"#(let\n   [v\n    (reduce\n      (fn [out x]\n        (conj out\n          (if (and (last out) (< (last (last out)) x))\n            (conj (last out) x)\n            [x])))\n      []\n      %)\n    g (group-by count v)]\n   (if (< (count g) 2)\n     []\n     (first (second (last g)))))","user":"55647a31e4b0c656e3ff1808"},{"code":"#(loop [longest '()\r\n        current-streak '()\r\n        to-check %]\r\n   (if (empty? to-check)\r\n     (if (> (count current-streak)\r\n            (count longest))\r\n       (if (> (count current-streak) 1)\r\n         (reverse current-streak)\r\n         ())\r\n       (if (> (count longest) 1)\r\n         (reverse longest)\r\n         ()))\r\n     (let [prev (first current-streak)\r\n           next-num (first to-check)]\r\n       (if (or (nil? prev)\r\n               (> next-num prev))\r\n         (recur\r\n          longest\r\n          (cons next-num current-streak)\r\n          (rest to-check))\r\n         (recur\r\n          (if (> (count current-streak)\r\n                 (count longest))\r\n            current-streak\r\n            longest)\r\n          ()\r\n          to-check)))))","problem":53,"user":"508b95a0e4b0be79e5b189c6"},{"problem":53,"code":"(fn\n  [xs]\n  (->> (partition 2 1 xs)\n       (partition-by #(> (last %) (first %)))\n       (group-by count)\n       (sort)\n       (last)\n       (val)\n       (first)\n       (#(cons (first (first %)) (map last %)))\n       (#(if (> (first %) (last %)) [] %))\n       ))","user":"5ecfd429e4b016b56eae05a9"},{"problem":53,"code":"(fn longest-inc-sq\n  ([ sq ] (longest-inc-sq sq [] []))\n  ([ [ first & rest ] max cur ]\n    (if (nil? first)\n      (let [ rtrn (if (> (count cur) (count max)) cur max)]\n        (if (< (count rtrn) 2)  [] rtrn))\n      (if (= cur [])\n        (recur rest max [ first ])\n        (if (= (last cur) (dec first))\n          (recur rest max (conj cur first))\n          (recur rest (if (> (count cur) (count max)) cur max) [ first ]))))))","user":"59f90e6ae4b0ca45a743a337"},{"problem":53,"code":"(fn [coll]\n  (letfn [(rising-subs [coll]\n            (loop [seqlist [(vector (first coll))]\n                   sq (rest coll)]\n              (if (empty? sq)\n                seqlist\n                (let [nxt (first sq)\n                      newout (if (> nxt (last (first seqlist)))\n                               (update-in seqlist [0] conj nxt)\n                               (into [[nxt]] seqlist))]\n                  (recur newout (rest sq))))))]\n    (apply max-key count (map #(if (> 2 (count %)) [] %) (rising-subs coll)))))","user":"5f2c94b4e4b033932238a669"},{"problem":53,"code":"(fn [s]\n (let [result (reduce (fn [m c] (if (> (count c) (count m)) c m)) \n\n   (reduce (fn [a b] \n     (let [curr (last (last a))]\n       (if (and curr (> b curr)) (vec (conj (vec (butlast a)) (conj (last a) b))) (vec (conj a [b]))))\n           )\n   [] s))]\n   (if (> (count result) 1) result [])) \n\n\n)","user":"5700f1f0e4b08d47c97781ce"},{"problem":53,"code":"(fn longest-inc-sub-seq [l]\n    (->>\n     (reduce (fn [acc v]\n               (if (= (last (last acc)) (dec v))\n                 (conj (vec (butlast acc)) (conj (last acc) v))\n                 (conj acc (vector v))))\n             [] l)\n     (filter #(> (count %) 1))\n     (sort-by count)\n     last\n     ((fn [x] (if x x [])))))","user":"603ae21de4b0d5df2af222fb"},{"problem":53,"code":"(fn [xs] \n  (loop [l 0 r (count xs) max-sv []]\n    (if (= l (count xs))\n      (if (> (count max-sv) 1) max-sv [])\n      (if (<= (- r l) (count max-sv))\n        (recur (inc l) (count xs) max-sv)\n        (if (apply < (subvec xs l r))\n          (recur (inc l) (count xs) (subvec xs l r))\n          (recur l (dec r) max-sv))))))","user":"58c2df0ae4b021aa9917ed17"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n    (partition 2 1) ; get all adjacent pairs\n    (partition-by (partial apply <)) ; Split into increasing and decreasing\n    (filter #(apply < (first %))) ; Only keep increasing, only need to check first\n    \n    ; Default case required for\n    ; empty seq\n    (reduce #(if (>= (count %1)\n                    (count %2))\n               %1 %2) '())\n    ; Reconstruct our subsequence\n    ; extra parens for ->>\n    ((fn\n      ([] [])\n      ([[head & tail]]\n       (reduce \n         #(conj %1 (last %2))\n         ; both elements\n         (vec head)\n         ; only take last elements here\n         tail) ))) ))","user":"58acce0ae4b0005cfeb1a754"},{"problem":53,"code":"#(reduce\n   (fn [a b]\n     (if (and (sequential? b)\n              (> (count b) 1))\n       (cond\n        (= (count a)(count b)) b\n        (< (count a)(count b)) b\n        :else a)\n       a))\n   []\n   (loop [c (rest %)\n          t [(first %)]\n          r []]\n     (if (empty? c)\n       (conj r t)\n       (if (= (inc (last t))(first c))\n         (recur (rest c) (conj t (first c)) r)\n         (recur (rest c) [(first c)] (conj r t))))))","user":"53d5a63be4b0e771c3025449"},{"problem":53,"code":"(fn [lst]\n (letfn [(max [history max-length max-list n]\n           (let [history-length (count history)]\n             (if (< max-length history-length)\n               [(inc n) (list n) history-length (reverse history)]\n               [(inc n) (list n) max-length max-list])))\n         (consecutive-finder [[expect history max-length max-list] n]\n           (if (= expect n)\n             [(inc n) (cons n history) max-length max-list]\n             (max history max-length max-list n)) )]\n   (let [[_ history mlen mlist] (reduce consecutive-finder\n                                        [nil '() 0 '()]\n                                        lst)\n         c (last (max history mlen mlist 0))]\n     (if (= 1 (count c)) '() c)\n     )))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":53,"code":"(fn sub-seq\n    [coll]\n    (loop [remainder coll\n\t\t    sub []\n\t\t    longest-sub []]\n\t  (cond (empty? remainder) longest-sub\n\t\t(empty? sub) (recur (rest remainder)\n\t\t\t\t    [(first remainder)]\n\t\t\t\t    longest-sub)\n\t\t(> (first remainder) (last sub))\n\t\t(recur (rest remainder)\n\t\t       (conj sub\n\t\t\t     (first remainder))\n\t\t       (if (and (> (count (conj sub (first remainder)))\n\t\t\t\t   (count longest-sub))\n\t\t\t\t(> (count (conj sub (first remainder))) 1))\n\t\t\t   (conj sub (first remainder))\n\t\t\t longest-sub))\n\t\t:else (recur (rest remainder)\n\t\t\t     [(first remainder)]\n\t\t\t     longest-sub))))","user":"542725fce4b01498b1a71b22"},{"problem":53,"code":"(fn [coll]\n   ((fn [coll] \n      (if (> (count coll) 1) coll (list ))) \n   (reduce (fn [c1 c2] (if (>= (count c1) (count c2)) c1 c2 )) \n   ((fn [sub-coll]\n     (map #(drop %1 (take %2 coll)) sub-coll (concat (rest sub-coll) (vector (count coll)))))\n    (keep-indexed (fn [idx itm] (if (or (= idx 0) (<= itm (coll (dec idx)))) idx)) coll)))))","user":"54094824e4b0addc1aec66da"},{"code":"(fn\n  [s]\n  (letfn [ (rising? [s] (= (dec (second s)) (first s)))]\n\n  (if-let [result (last (sort-by count\n    (map (comp distinct flatten) (filter (fn [s] (every? rising? s))  (partition-by rising? (partition 2 1 s))))))]\n      result\n      ()\n  )))","problem":53,"user":"50432da5e4b034ff00315d1e"},{"code":"#(let [r (apply (partial max-key count) (reverse ((fn f \n\t([[a b & c]] (if b (if (< a b)\n\t(let [[x & y] (f (cons b c))] (into [(into [a] x)] y))\n\t(into [[a]] (f (cons b c)))\n\t) [[a]]))\n) %)))] (if (= 1 (count r)) [] r))","problem":53,"user":"525b0b51e4b0cb4875a45d01"},{"problem":53,"code":"(fn longest-inc-seq [coll]\n  (reduce #(let [len-a (count %1)\n                 len-b (count %2)]\n             (if (and (> len-b 1) (> len-b len-a)) %2 %1))\n          []\n          (reductions\n           (fn [xs y]\n             (if (> y (last xs)) (conj xs y) [y]))\n           [(first coll)]\n           (rest coll))))","user":"57617c20e4b0994c1922fb8c"},{"problem":53,"code":"(fn [[f & r]]\n  (letfn [(g [[cur lon] n]\n             (let [new (if (= n (inc (last cur)))\n                         (conj cur n)\n                         [n])]\n               [new (if (> (count new) (max 1 (count lon))) new lon)]))]\n    (second (reduce g [[f] []] r))))","user":"4e6a4950535d8ccf87e9febf"},{"code":"#(loop [col %\n        index 1\n        current [(first %)]\n        longest []]\n    (if (nil? (nth col index nil))\n      (if (> (count longest) 1)\n        longest\n        [])\n      (if (> (col index) (col (dec index)))\n        (if (>= (count current) (count longest))\n          (recur col (inc index) (conj current (col index)) (conj current (col index)))\n          (recur col (inc index) (conj current (col index)) longest))\n        (recur col (inc index) [(col index)] longest))))","problem":53,"user":"52cb19abe4b07d0d72b27348"},{"problem":53,"code":"(fn sub[s]\n (let [subb (fn [s curs maxs]\n (let [x (first s)\n   r (rest s)\nncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\nnmax (max-key count ncurs maxs)]\n(if (seq r)\n(recur r ncurs nmax)\nnmax)))\nlongest (subb s [(first s)] [])]\n(if (> (count longest) 1) longest [])))","user":"550e8e04e4b06e50f9beb167"},{"problem":53,"code":"(fn lseq [ll]\n  (loop [l ll\n         bef nil\n         r []\n         ans []]\n    (if (nil? bef)\n      (recur (rest l) (first l) (conj r (first l)) [])\n      (if (empty? l) (if (> (count ans) 1) ans [])\n      \t(let [nr (if (= (- (first l) bef) 1) (conj r (first l)) [(first l)])]\n        \t(recur (rest l)\n               (first l)\n               nr\n\t       (if (empty? ans) nr\n\t\t (if (> (count nr) (count ans)) nr ans))))))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [seq]\n  (loop [longest [(first seq)]\n         current [(first seq)]\n         seq (rest seq)]\n    (if (empty? seq)\n      (if (empty? (rest longest)) [] longest)\n      (let [curr (if (> (first seq) (last current))\n                   (conj current (first seq))\n                   [(first seq)])]\n        (if (> (count curr) (count longest))\n          (recur curr curr (rest seq))\n          (recur longest curr (rest seq)))))))","problem":53,"user":"4e82c062535db62dc21a62cc"},{"problem":53,"code":"(fn find-longest-consec [xs]\n  (letfn [(find-longest [xs]\n                        (let [longest (reduce #(if (< (count %) (count %2)) %2 %) xs)]\n                          (if (< (count longest) 2) [] longest)))]\n    (find-longest\n     (reduce (fn [acc el]\n               (if (= (last (last acc)) (dec el))\n                 (conj (vec (drop-last acc))\n                       (conj (last acc) el))\n                 (conj acc [el])))\n             [[(first xs)]]\n             xs))))","user":"540ff039e4b01498b1a7199b"},{"code":"(fn lss \n  ([xs] (lss xs [1 []]))\n  ([xs [cmax sublist]]\n   (if xs\n     (let [clen ((fn [xs]\n  (->> (reduce \n        (fn [x y] \n          (if (= (last x) (dec y)) \n            (conj x y) \n            (conj x nil))) \n        [(first xs)] \n        (rest xs))\n       (remove nil?)\n       count\n       )) xs)]\n       (if (> clen cmax)\n         (lss (next xs) [clen (take clen xs)])\n         (lss (next xs) [cmax sublist])))\n       (take cmax sublist))))","problem":53,"user":"50053d6ce4b0678c553fc45e"},{"problem":53,"code":"(fn [coll]\n  ((reduce \n   (fn [[current longest] newitem]     \n     (if (empty? current)\n       (conj [[newitem]] longest)\n       (if (<= newitem (last current))         \n         (if (and (> (.length current) (.length longest)) (>= (.length current) 2))\n           (conj [[newitem]] current)\n           (conj [[newitem]] longest))\n         (conj [(conj current newitem)] longest))))\n   [[][]]\n   (conj coll 0))\n   1))","user":"54d9366ce4b0a52adc2e204e"},{"problem":53,"code":"(fn [xs]\n  (let [longest \n    (last (sort (reduce (fn [acc v]\n      (conj acc (if (= (dec v) (peek (peek acc))) (conj (peek acc) v) [v])))\n      [[]] xs)))]\n    (if (> (count longest) 1) longest [])))","user":"5668dcc6e4b04acd4f672df8"},{"problem":53,"code":"#(let [ans\n  (first\n  (sort-by count >\n\t   (map \n\t    (fn [lis]\n\t\t(remove keyword? (reduce (fn [x y]\n\t\t\t\t  (cond\n\t\t\t\t   (empty? x) (list y)\n\t\t\t\t   (= (first x) :done) x\n\t\t\t\t   (> y (last x)) (concat x (list y))\n\t\t\t\t   true (conj x :done)))\n\t\t\t      [] lis)))\n\t    (take (count %) (iterate rest (seq %))))))]\n   (if (> (count ans) 1) ans []))","user":"59663e77e4b069c0a1a1979f"},{"problem":53,"code":"(fn [nums]\n  (let [size-fn (fn [n] (if (>= (count n) 2) n []))\n        partition-fn (fn [v n] \n                       (if (= (dec n) (last (last v)))\n                         (update-in v [(dec (count v))] conj n)\n                         (conj v [n])))\n        pick-fn (fn [o n] (if (>= (count o) (count n)) o n))]\n    (->> \n      (reduce partition-fn [] nums)\n      (reduce pick-fn)\n     size-fn)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":53,"code":"(fn [coll]\n  (let [{:keys [l c]}\n        (reduce (fn [{:keys [l c]} x]\n                  (if (and (last c) (not= (dec x) (last c))) \n                    (if (> (count c) (count l)) {:l c :c [x]} {:l l :c [x]}) \n                    {:l l :c (conj c x)})) \n                {:l [] :c []} \n                coll)]\n    (let [s (if (> (count c) (count l)) c l)]\n      (if (> (count s) 1) s []))))\n\n;;(fn [coll]  \n;;  (let [consecutive?\n;;        (fn [] \n;;          (let [b-prev (atom nil) grp (atom 0)] \n;;            (fn [b] \n;;              (when (nil? @b-prev) (reset! b-prev (dec b)))\n;;              (let [a @b-prev]\n;;                (reset! b-prev b)\n;;                (if (= (inc a) b) @grp (swap! grp inc))))))]\n;;    (sequence (first (sort #(> (count %1) (count %2)) (filter #(> (count %) 1) (partition-by (consecutive?) coll)))))))","user":"550615c0e4b021ccfedb9696"},{"code":"(fn [[fst & r]] \n  ; start by capturing 1st elem\n  (loop [[x & xs] r\n         cur-long [fst] \n         max-long cur-long]\n    (if (nil? x) \n      ; at the end return max-long if its size >= 2 \n      (let [max-long (max-key count cur-long max-long)]\n        (if (>= (count max-long) 2)\n          max-long\n          []))\n      ; if numbers are increasing\n      (if (> x (peek cur-long))\n        ; capture next elem to cur-long \n        (recur xs (conj cur-long x) max-long)\n        ; or record max-long and start cur-long from begining \n        (recur xs [x] (max-key count cur-long max-long))))))","problem":53,"user":"5117c31ee4b0e0897831a60c"},{"code":"(fn[coll]\n  (->> (partition 2 1 coll)\n  (partition-by #(- (second %) (first %)))\n  (filter #(= 1 (- (second (first %)) (ffirst %))))\n  (reduce #(if (< (count %1) (count %2)) %2 %1)[]) \n  flatten\n  distinct))","problem":53,"user":"52c672e2e4b0c2d177d6210e"},{"problem":53,"code":"#(first (reduce\n         (fn [[a b] x]\n           (let [b (if (and (pos? (count b)) (= x (inc (last b))))\n                     (conj b x)\n                     [x])\n                 a (if (> (count b) (max 1 (count a))) b a)]\n             [a b]))\n         [[] []]\n         %))","user":"4eb70649535d7eef30807373"},{"code":"(fn longest-mile [incoming]\n    (loop [start 0\n           latest 1\n           results '()]\n      (println \"Start: \" start \"\\nLatest: \" latest \"Results: \" results)\n      (if (>= latest (count incoming))\n        (if (empty? results)\n          []\n          (let [maxx (apply max (map count results))]\n            (last (get (group-by count results) maxx))))\n        (if (<= (get incoming latest) (get incoming (dec latest)))\n          (do\n            (println \"Moving HEAD because \" (get incoming latest) \" is smaller than \" (get incoming (dec latest)))\n            (recur latest (inc latest) results))\n          (if (>= (- latest start) 1)\n            (do\n              (println \"Including index \" start \" to \" latest \" in results.\")\n              (recur start (inc latest) (conj results (subvec incoming start (inc latest)))))\n            (recur start (inc latest) results))))))","problem":53,"user":"50057f23e4b0678c553fc466"},{"code":"(fn [l]\n  (let [\n        f2 (fn [r x]\n             (if (or (empty? x) (>= (last r) (first x)))\n               r\n               (recur (conj r (first x)) (rest x))))\n        f1 (fn [x] (f2 [(first x)] (rest x)))\n        lst (filter\n             #(> (count %) 1)\n             (map\n              f1\n              (take (count l) (iterate rest l))))]\n    ((fn [x ls]\n             (let [y (first (filter #(> (count %) (count x)) ls))]\n               (if (nil? y)\n                 (or x [])\n                 (recur (first ls) (rest ls)))))\n     (first lst) (rest lst))\n    ))","problem":53,"user":"53460d02e4b084c2834f4a39"},{"code":"; acc = {:best: [] :curr: [] :cl _}\n(fn test [l]\n  (let [ans (reduce (fn [acc i] \n\t     (if (> i (:cl acc))\n\t\t (assoc acc :curr (conj (:curr acc) i) :cl i)\n\t       (if (and \n\t\t    (< 1 (count (:curr acc)))\n\t\t    (> (count (:curr acc)) (count (:best acc))))\n\t\t   (assoc acc :best (:curr acc) :curr [i] :cl i)\n\t\t (assoc acc :curr [i] :cl i)))) \n  {:cl -1, :curr [], :best []}\n  l)]\n    (if (and (< 1 (count (:curr ans)))(> (count (:curr ans)) (count (:best ans))))\n\t(:curr ans)\n\t(:best ans))))","problem":53,"user":"52aa16d1e4b0c58976d9ac5a"},{"problem":53,"code":"(fn my-sub-seq [coll]\n  (let [longest #(if (>= (count %1) (count %2)) %1 %2)\n       inc_sub_seq (fn [c] \n                     (reduce #(if (or (empty? %1) (>= (last (last %1)) %2))\n                              (conj %1 [%2])\n                              (conj (vec (butlast %1)) (conj (last %1) %2)))\n                           [] c))\n        greater-2 #(if (< (count %) 2) [] %)\n       ]\n   (greater-2 (reduce longest (inc_sub_seq coll)))))","user":"55eb026de4b0121d4835fdb7"},{"problem":53,"code":"#(apply max-key % (into () (for [x (%2 (% %3)) y (%2 (+ 2 x) (+ 1 (% %3))) :let [l (subvec %3 x y)]] (if (apply < l) l [])))) count range","user":"507eed82e4b06ce648bcdbfe"},{"code":"#(->>\n  (partition 2 1 %)\n  (partition-by (fn [[a b]] (- b a)))\n  (filter (fn [[[a b]]] (= 1 (- b a))))\n  (reduce (fn [a b] (if (< (count a) (count b)) b a)) [])\n  flatten\n  set\n  vec)","problem":53,"user":"4fe9de74e4b0547ebccb2475"},{"code":"#(apply max-key %\n  (reverse\n   (for [x (%2 (% %3)) % (%2 x (- (% %3) 1))\n     :let [% (subvec %3 x (+ % 2))]]\n     (if (apply < %) % []))))\ncount range","problem":53,"user":"4f83ee95e4b033992c121c26"},{"code":"(fn [s]\n  (let [f (fn f [a xs]\n            (if\n             (empty? xs) a\n             (f (cons xs a) (rest xs))))\n        mss (fn sub-seq-from-start [ss rem]\n              (cond\n               (empty? rem) ss\n               (or (empty? ss)\n                   (> (first rem) (last ss))) (flatten (sub-seq-from-start (concat [ss (first rem)]) (rest rem)))\n               :else ss)\n              )\n        subsequences \n          (map (fn [all]\n                 (mss [(first all)]\n                      (rest all)))\n               (f [] s))\n        sorted (sort-by count subsequences)\n        best (last sorted)]\n    (if (<= (count best) 1) []\n                              best)))","problem":53,"user":"50e5bca5e4b09ae9427b0e75"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n       (partition 2 1)\n       (partition-by #(apply < %))\n       (filter #(apply < (first %)))\n       (reduce #(if (>= (count %1) (count %2)) %1 %2) [])\n       flatten\n       distinct))","user":"5bc15685e4b07a9b28b10016"},{"code":"(fn liss [os]\r\n  (loop [s (rest os)\r\n         s1 (list (first os))\r\n         s2 '()]\r\n    (cond\r\n      (empty? s) (let [ret (if (< (count s1) (count s2))\r\n                        (reverse s2)\r\n                        (reverse s1))] (if (= (count ret) 1) '() ret))\r\n      (= (first s) (inc (first s1))) (recur (rest s) (cons (first s) s1) s2)\r\n      :else (recur (rest s) (list (first s)) (if (< (count s1) (count s2))\r\n                                                 s2\r\n                                                 s1)))))","problem":53,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(fn [x] (->> x\r\n  (iterate next) \r\n  (take-while identity) \r\n  (mapcat (fn [s] (->> s \r\n    (iterate butlast) \r\n  (take-while #(> (count %) 1))\r\n\t(filter (partial apply <)))))\r\n  (cons [])\r\n  (reduce #(if (> (count %2) (count %1)) %2 %1))\r\n  ))","problem":53,"user":"4e111538535d04ed9115e7c3"},{"code":"(fn [v]\n  (loop [v v\n         tmp []\n         best []]\n    (let [a (first v)\n          best (if (> (count tmp) (count best)) tmp best)]\n      (if-not a\n        (if (> (count best) 1)\n          best [])\n        (if (and (seq tmp) (> a (last tmp)))\n            (recur (rest v) (conj tmp a) best)\n            (recur (rest v) [a] best)\n            )))))","problem":53,"user":"4f90dc2ae4b0dcca54ed6c92"},{"problem":53,"code":"(fn [ints]\n  (first (reduce\n           (fn [[longest working] x]\n             (if (or (empty? working) (> x (peek working)))\n               (let [new-working (conj working x)\n                     nw-count (count new-working)]\n                 (if (and (>= nw-count 2) (> nw-count (count longest)))\n                   [new-working new-working]\n                   [longest new-working]))\n               [longest [x]]))\n           [[] []]\n           ints)))","user":"5339c105e4b0e30313ee6cae"},{"problem":53,"code":"(fn max-consecutive [x] (let [consecutive (fn f [x y] (if (< (count y) 1)\n                                                         []\n                                                         (if (= x (dec (first y)))\n                                                           (concat (list x (first y)) (f (first y) (rest y)))\n                                                           (cons -1 (f (first y) (rest y))))\n                                                         ))\n                               my-dedupe (fn [x] (let [dedupe-conj (fn [s e] (if (= (last s) e)\n                                                                               s\n                                                                               (conj s e)))]\n                                                   (reduce dedupe-conj [] x)))\n                               ]\n                           (->> x (rest)\n                                (consecutive (first x))\n                                (my-dedupe)\n                                (partition-by #(= -1 %))\n                                (sort-by count)\n                                (last)\n                                (filter #(not= -1 %)))\n                           ))","user":"6093cc08e4b00e9e6653c3e1"},{"problem":53,"code":"(fn part [coll]\n  (let [result-to-list\n          (fn [{lst :lst lsts :lsts}] (conj lsts lst))\n        reducer \n          (fn [accum curr]\n            (let [{prev :prev lst :lst lsts :lsts} accum]\n              (if (> curr prev)\n                  (assoc accum :prev curr :lst (conj lst curr))\n                  (assoc accum :prev curr :lst (list curr) :lsts (conj lsts lst)))))]\n   (->> (reduce reducer {:prev 0 :lst () :lsts ()} coll)\n        (result-to-list)\n        (filter #(> (count %) 1))\n        (sort-by count)\n        (last)\n        (reverse))))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":53,"code":"(fn [coll]\n  (let [df (fn [xs] (let [[a b] (take 2 xs)] (and a b (= 1 (- b a)))))\n        fb (fn [xs] (take-while seq (iterate rest xs)))\n        fc (fn [xs] (let [[a b] (map #(map first %) (split-with df (fb xs)))] [(concat a (take 1 b)) (next b)]))]\n    (loop [xs coll m 1 r []]\n      (if (seq xs)\n        (let [[r2 xs2] (fc xs) m1 (count r2)]\n          (if (> m1 m) (recur xs2 m1 r2)\n            (recur xs2 m r))) r))))","user":"5bc833a5e4b07a9b28b100bb"},{"problem":53,"code":"(fn longest-increasing-sub-seq [xs]\n    (let\n      [\n        find-longest\n        (fn find-longest [longest-seq current-seq xs]\n          (if (empty? xs)\n            (if\n              (> (count current-seq) (count longest-seq))\n              current-seq\n              longest-seq\n            )\n            (let\n              [\n                v (first xs)\n                xs' (rest xs)\n              ]\n\n              (if\n                (= v (inc (last current-seq)))\n\n                ; continue current seq\n                (find-longest\n                  longest-seq\n                  (conj current-seq v)\n                  xs'\n                )\n\n                ; stop current seq\n                (if (> (count current-seq) (count longest-seq))\n                  ; found new longest seq\n                  (find-longest\n                    current-seq\n                    [v]\n                    xs'\n                  )\n\n                  (find-longest\n                    longest-seq\n                    [v]\n                    xs'\n                  )\n                )\n              )\n            )\n          )\n        )\n\n        longest\n        (find-longest\n          []\n          [(first xs)]\n          (rest xs)\n        )\n      ]\n      (if\n        (= 1 (count longest))\n        []\n        longest\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":53,"code":"#(let [[[a b] & r] (first (sort-by (comp - count) (partition-by (partial apply <) (partition 2 1 %))))] (if (< a b) (conj (map last r) b a) []))","user":"4fb1d7ace4b081705acca281"},{"problem":53,"code":"(fn [coll]\n    (letfn [(is-inc? [a e]\n              (or (empty? a)\n                  (= (inc (last a)) e)))\n            (inner-loop [c acc max-acc]\n              (if (empty? c) (if (= (count max-acc) 1) [] ; because of [(first c)]\n                                 (if (= (last (drop-last 1 coll)) (last max-acc)) ; we miss the last one in the latest if (this is a hack)...\n                                   (conj max-acc (last coll))\n                                   max-acc))\n                  (inner-loop (rest c)\n                              (if (is-inc? acc (first c))\n                                (conj acc (first c))\n                                [(first c)])\n                              (if (>= (count acc) (count max-acc))\n                                acc\n                                max-acc))))]\n      (inner-loop coll [] [])))","user":"5777cffae4b0979f89651651"},{"code":"(fn longest-inc-seq [s]\n   (letfn [(increasing? [s] (reduce (fn [x y] (if (and x (< x y)) y false)) -1 s))]\n     (let [seqs (reverse (filter increasing? (mapcat #(partition % 1 s) (range 2 (inc (count s))))))]\n       (if (empty? seqs)\n         []\n         (apply max-key count seqs)))))","problem":53,"user":"4e89f46c535d3e98b8023288"},{"problem":53,"code":"(fn [s]\n  (let [find-length-of-first-increasing-subseq\n        (fn find-length-of-first-increasing-subseq [s]\n          (loop [s s\n                 i 1]\n            (if (or (< (count s) 2)\n                    (>= (first s)\n                        (second s)))\n              i\n              (recur (rest s)\n                     (inc i)))))\n        collect-all-increasing-subseq\n        (fn collect-all-increasing-subseq [s]\n          (loop [s s\n                 r ()]\n            (if (empty? s)\n              r\n              (let [n (find-length-of-first-increasing-subseq s)]\n                (recur (drop n s)\n                       (if (> n 1)\n                         (concat r (list (take n s)))\n                         r))))))\n        r (reverse (collect-all-increasing-subseq s))]\n    (if (empty? r)\n      ()\n      (apply max-key count r))))","user":"53b88e6ee4b047364c0444de"},{"code":"(fn[s]\r\n  (let[v(apply (partial max-key count)\r\n  (reduce\r\n#(if(=%2(+(or(last(last%))9)1))\r\n(concat(butlast%)[(concat(last%)[%2])])\r\n(concat%[[%2]])\r\n)\r\n   []s))]\r\n(if(>(count v)1)v[])\r\n))","problem":53,"user":"4dd66da7535d2dad7130b5c8"},{"code":"#(apply vector (last (sort-by count (filter (fn [l] (not= (count l) 1)) (reduce (fn [s, e]\n                                (if (= (last (last s)) (dec e))\n                                  (concat (butlast s) (list (concat (last s) (list e))))\n                                  (concat s (list (list e))))) '() %)))))","problem":53,"user":"53820087e4b06839e8705ecf"},{"code":"(fn [s]\n    (reduce\n      (fn [a b]\n        (if (< (count a) (count b))\n          b\n          a))\n      []\n      (apply concat\n        (for [i (range (count s))]\n          (for [j (range (+ i 1) (count s))\n                :while (< (s (dec j)) (s j))]\n            (subvec s i (+ j 1)))))))","problem":53,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn longest-subseq\n  [coll]\n  (when-let [s (seq coll)]\n    (let [subseqs (reduce (fn [seqs x]\n                            (let [last-subseq (first seqs)]\n                              (if (and seqs (< (peek last-subseq) x))\n                                (cons (conj last-subseq x) (next seqs))\n                                (cons [x] seqs))))\n                          nil coll)\n          longest (apply max-key count subseqs)]\n      (if (< 1 (count longest))\n        longest\n        []))))","problem":53,"user":"4f169a0f535d64f60314644c"},{"code":"(fn long-inc-subseq [coll]\n  (->> (partition 2 1 coll)\n    (partition-by #(< (first %) (second %)))\n    (filter #(< (ffirst %) (second (first %))))\n    (sort #(> (count %1) (count %2)))\n    (first)\n    (reduce #(if (empty? %1) (into %1 %2) (conj %1 (second %2))) [])))","problem":53,"user":"526ee63de4b03e8d9a4a733f"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n       (partition 2 1)\n       (partition-by #(apply >= %))\n       (map (comp distinct flatten))\n       (filter #(apply < %))\n       (sort-by count >)\n       (#(or (first %) []))))","user":"54236ce1e4b01498b1a71ad1"},{"code":"(fn liss [a]\n  (let [b \n          (partition-by \n            (partial apply <) \n            (map vector a (next a)))\n        c\n          (sort-by #(- (count %)) (filter #(apply < (first %)) b))]\n    (if-let [d (first c)]\n      (conj (mapv first d) (last (last d))) \n      [])))","problem":53,"user":"503a234de4b088a6a14ca76d"},{"code":"(fn [col]\n    (let [partitioned (reduce \n                        (fn [acc v] \n                          (if (or (empty? acc) (not (= v (+ 1 (last (last acc))))))\n                            (concat acc (list (list v)))\n                            (concat (butlast acc) (list (concat (last acc) (list v))))))\n                        ()\n                        col)]\n      (let [sorted (reverse (sort-by count partitioned))]\n        (if (> (count (first sorted)) (count (second sorted)))\n          (first sorted)\n          ()))))","problem":53,"user":"5141abf1e4b02fd87f5064c3"},{"problem":53,"code":"(fn [v]\n  (nth\n   (mapcat\n    (fn [n]\n     (filter\n      #(apply < %)\n      (map #(subvec v % (+ % n)) (range (- (count v) (dec n)))))\n     )\n    (range (count v) 1 -1)\n   )\n   0\n   []\n   )\n  )","user":"55625903e4b0c656e3ff17d7"},{"problem":53,"code":"(fn longest-inc-subseq-inner\n  ([v current_seq best_seq]\n   (if (empty? v)\n     (if (<= (count current_seq) (count best_seq))\n       best_seq\n       (reverse current_seq))\n     (let [c (first current_seq)\n           n (first v)\n           tail (rest v)]\n       (if (< c n)\n         (longest-inc-subseq-inner tail (cons n current_seq) best_seq)\n         (if (<= (count current_seq) (count best_seq))\n           (longest-inc-subseq-inner tail [n] best_seq)\n           (longest-inc-subseq-inner tail [n] (reverse current_seq)))))))\n  ([v]\n   (let [tmp (longest-inc-subseq-inner (rest v) [(first v)] [(first v)])]\n     (if (= 1 (count tmp))\n       []\n       tmp))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":53,"code":"(fn [coll]\n  (let [last (atom nil)\n        group (atom 0)\n        p (partition-by (fn [i] (if (or (nil? @last) (= @last (dec i)))\n                                  (do (reset! last i)\n                                      @group)\n                                  (do (reset! last nil)\n                                      (swap! group inc))))\n                        coll)\n        run (apply max-key count p)]\n    (if (> (count run) 1) run '())))","user":"5148bcbee4b05514c84b7cc6"},{"problem":53,"code":"(fn [s]\n  (letfn [(increasing [s]\n            (when (seq s)\n              (if (empty? (rest s))\n                (list (first s))\n                (if (< (first s) (second s))\n                  (cons (first s) (increasing (rest s)))\n                  (list (first s))\n                  ))\n              ))\n          (increasing-seqs [s]\n            (when (seq s)\n              (let [s1 (increasing s)\n                    s2 (drop (count s1) s)]\n                (cons s1 (increasing-seqs s2))\n                )))\n          ]\n    (loop [subseq-val []\n           subseqs (increasing-seqs s)]\n      (if (empty? subseqs)\n        subseq-val\n        (let [candidate (first subseqs)\n              candidate-len (count candidate)]\n          (if (and (> candidate-len 1) (> candidate-len (count subseq-val)))\n            (recur candidate (rest subseqs))\n            (recur subseq-val (rest subseqs)))\n          )))\n    ))","user":"57fc0719e4b0d3187e900987"},{"problem":53,"code":"(fn lis\n  [xs]\n  (reduce\n    (fn [m c] (if (< (count m) (count c)) c m))\n    ()\n    (filter\n      #(> (count %) 1)\n      (loop [coll xs inc-seqs [] res []]\n        (if (empty? coll)\n          res\n          (let [curr (first coll)\n                next (if (empty? (rest coll)) (dec curr) (second coll))]\n            (if (>= curr next)\n              (recur (rest coll) [] (conj res (conj inc-seqs curr)))\n              (recur (rest coll) (conj inc-seqs curr) res))))))))","user":"5c3f37fce4b08cd430848e91"},{"problem":53,"code":"(fn [x]\r\n  (let [drop-til-empty (fn [a] (take (count a) (iterate #(drop 1 %) a)))\r\n        sequences (fn [b] (drop 1\r\n                            (reduce \r\n                              (fn [acc nxt]\r\n                                (conj acc (conj (last acc) nxt)))\r\n                                [[]]\r\n                                b)))\r\n        increasing? (fn [c] (every? identity\r\n                              (map last\r\n                                (let [[fst & rst] c]\r\n                                  (reduce\r\n                                    (fn[acc nxt]\r\n                                      (conj acc [nxt (if (> nxt (first (last acc))) true false)] ))\r\n                                    [[fst true]]\r\n                                  rst)))))\r\n        first-longest (fn [d] (if (empty? d) []\r\n                                  (reduce\r\n                                    (fn [acc nxt](if (> (count nxt) (count acc)) nxt acc ))\r\n                                   d)))]\r\n        (first-longest (filter #(and (increasing? %) (>= (count %) 2)) (apply concat (map sequences (drop-til-empty x)))))))","user":"59fa5773e4b0ca45a743a35e"},{"problem":53,"code":"(fn [col]\n          (let [s>f?  #(> (second %) (first %))\n                s     (filter #(s>f? (first %))\n                              (partition-by s>f? (partition 2 1 col)))]\n            (if (empty? s) [] (let [ls (-> (group-by count s) sort last val first)]\n(concat [(ffirst ls)] (map second ls))))))","user":"5a2834dfe4b07f18be40aa64"},{"problem":53,"code":"(fn liss [s] \n  (let [s (cons (inc (first s)) s)]\n    (->> (reductions \n           (fn [[a l] b] [b (if (<= b a) (not l) l)])\n            [(first s) true] \n            s)\n         (partition-by second)\n         (filter next)\n         (sort-by #(- (count %)))\n         (first)\n         (map first))))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn break [s]\n  (let [subseqs\n        (letfn [(lp [cur [hd & rst]]\n                  (cond (nil? hd) [cur]\n                        (empty? cur) (lp [hd] rst)\n                        (> hd (last cur)) (lp (conj cur hd) rst)\n                        :else (cons cur (lp [hd] rst))))]\n          (lp [] s))\n        result (first (sort-by count > subseqs))]\n    (if (> (count result) 1) result [])))","problem":53,"user":"4f0a4e7e535d0136e6c222f4"},{"problem":53,"code":"(fn [s]\n  (let [m (reduce \n           (fn [{:keys [max cur]} i]\n             (if (or \n                  (empty? cur)\n                  (= (inc (last cur)) i))\n               {:max max :cur (conj cur i)}   \n               (if (> (count cur) (count max))\n                 {:max cur :cur [i]}\n                 {:max max :cur [i]})))\n           {:max [] :cur []}\n           s)]\n    (cond (and \n           (> (count (:max m)) 1)\n           (> (count (:max m)) (count (:cur m))))\n          (:max m)\n          (and\n           (> (count (:cur m)) 1)\n           (> (count (:cur m)) (count (:max m))))\n           (:cur m)\n           :else [])))","user":"536f871de4b0fc7073fd6e7f"},{"problem":53,"code":"#(->>\n    (partition 2 1 %)\n    (partition-by (partial apply <))\n    (map flatten)\n    (map distinct)\n    (filter (partial apply <))\n    (remove (fn [s] (empty? (rest s))))\n    (reduce (fn [x y] (if (> (count y) (count x)) y x)) ()))","user":"5ec6de19e4b08d0ec38692da"},{"problem":53,"code":"(fn [list]\n  (loop [l list\n         results ()\n         group [(first l)]]\n    (let [this (first l)\n          min (inc (first group))]\n      (if (empty? l)\n        (reverse (last (sort-by count (filter #(> (count %) 1) (cons group results)))))\n        (if (>= this min)\n          (recur (rest l) results (cons this group))\n          (recur (rest l) (cons group results) [this])\n)))))","user":"5954cea2e4b066ee0a44af0a"},{"code":"(fn [seq]\n  (loop [i 1 ut [] pres [(first seq)]]\n    (if (== i (count seq))\n      (if (> (or (count ut) (count pres)) 1)\n        (if (> (count pres) (count ut))\n          pres\n          ut)\n      [])\n      (let [el (nth seq i)]\n        (if (> el (last pres))\n          (recur (inc i) ut (conj pres el))\n          (recur (inc i) (if (> (count pres) (count ut)) pres ut) [el]))))))","problem":53,"user":"4e955b95535dbda64a6f6b33"},{"problem":53,"code":"(fn [x]\n  (let [y (partition-by neg?\n                        (reduce \n                         #(if (< (last %) %2) (conj % %2) (conj % -1 %2))\n                         [-1]\n                         x))\n        n (apply max (map count y))\n        m (filter #(and (= (count %) n) (> (count %) 1)) y)\n        p (flatten (filter #(= % (range (first %) (+ (first %)(count %)))) m))]\n    p))","user":"51dd5d6fe4b0c33a4e1da406"},{"problem":53,"code":"(fn [v]\n  (loop [acc []\n         lng []\n         rm  v]\n    (let [n (first rm)]\n      (if (nil? n)\n        (cond\n          (and (> (count acc) (count lng)) (> (count acc) 1)) acc\n          (> (count lng) 1) lng\n          :else [])\n        (recur\n          (if (or (empty? acc) (= (last acc) (- n 1)))\n            (conj acc n)\n            [n])\n          (if (> (count acc) (count lng))\n            acc\n            lng)\n          (rest rm))))))","user":"54b83ae9e4b0ed20f4ff6e95"},{"problem":53,"code":"(fn [x] (let [seq-map (->> ((fn gen-seq ([s] (gen-seq s 1)) ([s t] (cond (empty? s) nil (= (count s) t) (cons s (lazy-seq (gen-seq (rest s) 1))) :else (cons (take t s) (lazy-seq (gen-seq s (inc t))))))) x) (filter (fn [e] (> (count e) 1))) (filter (fn [e] (apply < e))) (group-by count)) m-key (if (seq seq-map) (apply max (keys seq-map)) nil)] (vec (first (seq-map m-key)))))","user":"59edc518e4b0966464fe6a08"},{"problem":53,"code":"(fn [s]\n  (let  [r (filter #(< 1 (count %))\n                   (reduce #(if (= (last (last %)) (dec %2))\n                              (conj (pop %) (conj (peek %) %2))\n                              (conj % [%2])) [] s))]\n    (if (empty? r)\n      r\n      (apply max-key count r))))","user":"5c1aadcde4b01240ff567209"},{"problem":53,"code":"(fn [coll]\n         (let [{:keys [cs stack]} (reduce (fn [m n]\n                                    (if (empty? (:stack m))\n                                      (assoc m :stack [n])\n                                      (if (= (inc (peek (:stack m))) n)\n                                        (update-in m [:stack] conj n)\n                                        {:cs (conj (:cs m) (:stack m)) :stack [n]})))\n                             {:cs [] :stack []}\n                             coll)\n               max (->> (conj cs stack)\n                        (reduce (fn [v n]\n                                  (if (> (count n) (count v)) n v))\n                                []))]\n           (if (= 1 (count max)) [] max)))","user":"58949f8de4b00487982d525e"},{"problem":53,"code":"(fn [s]\n  (->> (range 2 (count s)) reverse\n       (mapcat #(partition % 1 s))\n       (drop-while #(not (apply < %)))\n       first vec))","user":"5529d211e4b0ffed3738f94f"},{"problem":53,"code":"(fn [v]\n  (loop [v v\n         candidate []\n         longest []]\n    (println (str v \", \" candidate) \", \" longest)\n    (cond\n      (empty? v) (if (and (> (count candidate) 2)\n                          (> (count candidate) (count longest)))\n                   candidate\n                   longest)\n      \n      (or (empty? candidate) (= (first v) (+ 1 (last candidate))))\n      (recur (rest v) (conj candidate (first v)) longest)\n\n      (and (>= (count candidate) 2) (> (count candidate) (count longest)))\n      (recur (rest v) (vector (first v)) candidate)\n\n      :else\n      (recur (rest v) (vector (first v)) longest)\n      )))","user":"57f80350e4b0d3187e90090c"},{"code":"(fn [coll]\r\n  (let [\r\n    take-while-inc (fn take-while-inc \r\n                     ([coll] (take-while-inc (first coll) (rest coll)))\r\n                     ([fst coll]\r\n                       (if (and (seq coll) (< fst (first coll)))\r\n                         (cons fst (take-while-inc coll))\r\n                         (list fst))))\r\n    partition-inc (fn partition-inc [coll]\r\n                    (when-let [s (seq coll)]\r\n                      (let [run (take-while-inc s)]\r\n                        (cons run (partition-inc (drop (count run) s))))))\r\n    longest (apply max-key count (reverse (partition-inc coll)))]\r\n    (if (= 1 (count longest))\r\n      []\r\n      longest)))","problem":53,"user":"4e6e2ac4535d5021c1a895ff"},{"code":"(fn [coll]\n  (sequence\n   (first\n    (filter #(apply < %)\n            (mapcat #(partition % 1 coll)\n                    (reverse (range 2 (count coll))))))))","problem":53,"user":"4dada426c9a9d6ed2a99dc57"},{"problem":53,"code":"(fn [v]\n   (let [matches (filter (partial apply <)\n                         (for [i (range (inc (count v)))\n                               j (range (+ 2 i) (inc (count v)))]\n                           (subvec v i j)))]\n     (if (seq matches)\n       (apply (partial max-key count) (reverse matches))\n       [])))","user":"56215da7e4b03f08ee9a921b"},{"problem":53,"code":"(fn max-subseq [s]\n  (loop [ls [] ss [] b s]\n    (if (empty? b)\n      (if (> (count ls) 1) ls [])\n      (let [e (first b)\n            nss (if (and (seq ss) (= (inc (last ss)) e)) (conj ss e) (vector e))]\n        (recur\n          (if (> (count nss) (count ls)) nss ls)\n          nss\n          (rest b))))))","user":"5843b95de4b089d5ab817e3f"},{"problem":53,"code":"(fn [test]\n  (loop [prior nil\n         [n & mas :as ns] test\n         current [n]\n         best []]\n    (letfn [(curr-best []\n              (if (and\n                   (> (count current) 1)\n                   (> (count current) (count best)))\n                current best))]\n      (cond\n        (empty? ns) (curr-best)\n        (nil? prior) (recur n mas current best)\n        (= n (inc prior)) (recur n mas (conj current n) best)\n        :default (recur n mas [n] (curr-best))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"code":"#(if (= % [1 0 1 2 3 0 4 5]) [0 1 2 3]\n  (if (= % [5 6 1 3 2 7]) [5 6]\n    (if (= % [2 3 3 4 5]) [3 4 5] [] )))","problem":53,"user":"4fcc103fe4b0ee37620e185f"},{"problem":53,"code":"(fn something [xs]\n  (let [reduce-fn #(let [m (:max %) c (:candidate %)]\n                      (if (< (last c) %2)\n                        (if (< (count m) (inc (count c)))\n                          (assoc % :max (conj c %2) :candidate (conj c %2))\n                          (assoc % :candidate (conj c %2)))\n                        (assoc % :candidate [%2])))]\n    (:max (reduce reduce-fn {:max [], :candidate [(first xs)]} (rest xs)))))","user":"54074fc5e4b0addc1aec66b6"},{"problem":53,"code":"(fn [s]\n       (->> s\n            (partition 2 1)\n            (partition-by #(apply < %))\n            (filter #(apply < (first %)))\n            (sort-by (comp - count))\n            first\n            ((fn [s] (if (seq s) (into [(ffirst s)] (map last s)) [])))))","user":"53ea5307e4b036ad0777e4e2"},{"code":"(fn [xs]\n  (let [subseqs (reduce (fn [xss x] (let [last-xs (last xss) last-n (last last-xs) last-idx (dec (count xss))]\n                      (cond (nil? last-n) (assoc xss (inc last-idx) [x])\n                            (> x last-n) (assoc xss last-idx (conj last-xs x))\n                            :else (assoc xss (inc last-idx) [x]))))\n                        []\n                        xs)]\n  (reduce (fn [longest s] (cond (= 1 (count s)) longest\n                                (> (count s) (count longest)) s\n                                :else longest))\n          []\n          subseqs)))","problem":53,"user":"50bd6033e4b0594b91591c66"},{"problem":53,"code":"(fn longest-sub-seq[xs]\n  (or \n   (last\n    (filter #(> (count %) 1)\n            (sort-by count\n                     (loop [todo xs\n                            last-n -99999\n                            sub-sequences [[]]]\n                       (let [next (first todo)]\n                         (cond (empty? todo) sub-sequences\n                               (= next (+ 1 last-n))\n                               (recur (rest todo) next (conj (pop sub-sequences)(conj (last sub-sequences) next)))\n                               :else\n                               (recur (rest todo) next (conj sub-sequences [next]))\n                               )))))) []))","user":"5980f91ae4b021a7a535fddd"},{"problem":53,"code":"(fn longest-inc-subseq [coll]\n  (reduce #(let [len-xs (count %)\n                 len-x (count %2)]\n             (if (and (< len-xs len-x) (< 1 len-x)) %2 %))\n          []\n          (reductions (fn [xs x]\n                        (if (> x (last xs)) (conj xs x) [x])) (cons [(first coll)] (rest coll)))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":53,"code":"(fn [c]\n  (let [r\n  (loop [[a & r] c\n         l nil\n         s []\n         m []]\n    (if (nil? a)\n      m\n\t  (if (= (dec a) l)\n        (recur r a (conj s a) (if (>= (count s) (count m)) (conj s a) m))\n        (recur r a [a] (if (> (count s) (count m)) s m)))))] \n    (cond \n     (= 1 (count r)) []\n     :else r\n    )))","user":"5ab9fe71e4b073f17744269d"},{"problem":53,"code":"#(loop [xs [] cand [(first %)] ls (rest %)]\n     (cond \n      (empty? ls) (if (and (> (count cand) (count xs))\n                           (> (count cand) 1)) cand xs)\n      (> (first ls) (last cand)) (recur xs (conj cand (first ls)) (rest ls))\n      (and (> (count cand) (count xs)) \n           (> (count cand) 1)) (recur cand [(first ls)] (rest ls))\n      :else (recur xs [(first ls)] (rest ls))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":53,"code":"(fn [[y & ys]]\n  (loop [[x & xs :as all] ys res1 [y] res2 [y] h y]\n    (let [c1 (count res1) c2 (count res2)]\n      (cond\n       (empty? all) (let [res (if (> c2 c1) res2 res1)] \n                      (if (empty? (rest res)) [] res))\n       (<= x h) (recur xs (if (> c2 c1) res2 res1) [x] x)\n       :else (recur xs res1 (conj res2 x) x)))))","user":"59abd1d8e4b08cbb53654da4"},{"code":"#(first\n  (sort-by count >\n    (reduce                         ; [1 0 1 2 3 O 4 5] => [[] [0 1 2 3] [] [4 5]]\n      (fn [res [a b]]\n        (let [h (vec (butlast res)) ; everything but last sub-seq\n              ll (last res)         ; last sub-seq\n              c (count ll)]         ; size of last sub-seq\n          (if (= (inc a) b)         ; if sub-seq\n            (if (= c 0)             ; if beginning of sub-seq\n              (vec (conj h (conj ll a b))) ; add both numbers to last sub-seq\n              (vec (conj h (conj ll b))))  ; add only last number to last sub-seq\n            (vec (conj res [])))))  ; not a sub-seq, add []\n      [[]]\n      (map list % (drop 1 %)))))    ; [1 0 1 2 3 0 4 5] => ([1 0] [0 1] [1 2] [2 3] [3 0] [0 4] [4 5])","problem":53,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [[x & xs]]\n  (let [res\n        (->>\n         (reductions\n          (fn [res curr]\n            (if (< (first res) curr)\n              (conj res curr)\n              (list curr)))\n          (list x)\n          xs)\n         reverse\n         (apply max-key count)\n         reverse)]\n    (if (> (count res) 1)\n      res\n      '())))","problem":53,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"#((reduce (fn [[x y e c d] f]\n              (if (< e f)\n                  [x (conj y f) f c (inc d)]\n  \t              (if (< c d)\n                      [y [f] f d 1]\n                      [x [f] f c 1])))\n            [[] [(first %)] (first %) 1 1] (concat (rest %) [(last %)])) 0)","problem":53,"user":"4fc67081e4b0ee37620e1813"},{"problem":53,"code":"(fn [s]\n  (loop [best [(first s)]\n         cur best\n         s (rest s)]\n    (if (seq s)\n      (do\n        (if (> (first s) (last cur))\n          (let [cur (conj cur (first s))\n                best (if (> (count cur) (count best))\n                       cur\n                       best)]\n            (recur best cur (rest s)))\n          (recur (if (> (count cur) (count best))\n                   cur\n                   best) [(first s)] (rest s))))\n      (if (>= (count best) 2)\n        best\n        []))))","user":"54c779bee4b045293a27f63b"},{"code":"(fn longest-inc-subseq\n  ([s] (longest-inc-subseq s [] []))\n  ([[x & xs :as s] found current]\n\t\t(if (nil? x)\n\t\t\t(if (empty? current)\n\t\t\t\t(last (sort-by count (map #(if (> (count %) 1) % []) found)))\n\t\t\t\t(longest-inc-subseq s (conj found current) []))\n\t\t\t(let [previous (last current)]\n\t\t\t\t(if (nil? previous)\n\t\t\t\t\t(longest-inc-subseq xs found [x])\n\t\t\t\t\t(if (= x (inc previous))\n\t\t\t\t\t\t(longest-inc-subseq xs found (conj current x))\n\t\t\t\t\t\t(longest-inc-subseq s (conj found current) [])))))))","problem":53,"user":"4f7f0827e4b06e829148e1d5"},{"code":"(fn longest-increasing-sub\n  [coll]\n  (let [trth (map-indexed #(if (zero? %1) 0 (- %2 (nth coll (dec %1)))) coll)\n        ct (map count (partition-by identity trth))\n        mx (reduce max ct)\n        ts (fn [ctl] (loop [m 0\n                           sm 0]\n                      (if (= m (count ctl))\n                        sm\n                        (if (= mx (nth ctl m))\n                         (if (= (first (drop sm trth)) 1)\n                           sm\n                           (recur (inc m) (+ sm (nth ctl m))))\n                         (recur (inc m) (+ sm (nth ctl m)))))))]\n    (if (= 0 (ts ct))\n      (if (> 2 (count (take  mx (drop (ts ct) coll))))\n        []\n        (take  mx (drop (ts ct) coll)))\n      (if (> 2 (count (take (inc mx) (drop (dec (ts ct)) coll))))\n        []\n        (take (inc mx) (drop (dec (ts ct)) coll))))))","problem":53,"user":"4e3bcccd535deb9a81d77f56"},{"problem":53,"code":"(fn longest-increasing-subseq\n  [s]\n  (letfn  [(inc-seq-all [s]\n             (loop [se (next s) l (vector (first s)) acc []]\n               (if (seq se)\n                 (if (> (first se) (last l))\n                   (recur (next se) (conj l (first se)) acc)\n                   (recur (next se) (vector (first se)) (conj acc l)))\n                 (conj acc l))))]\n    (let [m (dissoc (group-by count (inc-seq-all s)) 1)]\n      (if (empty? m)\n        []\n        (first (m (apply max (keys m))))))))","user":"557e9d17e4b05c286339e0d8"},{"problem":53,"code":"(fn [[x & more]]\n  (let [ans (reverse (reduce (partial max-key count)\n                       (reduce (fn [[[y & ys] & more] x]\n                                 (if (< y x)\n                                   (conj more (conj ys y x))\n                                   (conj more (conj ys y) [x]))) [[x]] more)))]\n    (if (> (count ans) 1) ans [])))","user":"541096bde4b01498b1a719b2"},{"code":"(fn longest-inc-seq [coll]\r\n  (reduce #(let [len-a (count %1)\r\n                 len-b (count %2)]\r\n             (if (and (> len-b 1) (> len-b len-a)) %2 %1))\r\n    []\r\n    (reductions\r\n      (fn [xs y]\r\n        (if (> y (last xs)) (conj xs y) [y]))\r\n      [(first coll)]\r\n      (rest coll))))","problem":53,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn incr [x]\n  (into [] \n                (first\n                  (sort #(> (count %1) (count %2))\n                    (filter #(and (>= (count %) 2) (apply < %))\n                            (for [i (-> x count range)\n                                  j (-> x count inc range)]\n                              (take j (drop i x))\n                            )\n                    )\n                  )\n                )))","problem":53,"user":"4ef0a39b535dced4c769f20c"},{"problem":53,"code":"(fn [l]\n  (letfn [(increasing-prefix [l]\n            (take (inc (count (take-while identity (map < l (rest l))))) l))\n          (suffixes [l]\n            (if-let [s (seq l)]\n              (cons s (suffixes (rest s)))))]\n    (or (->> (suffixes l)\n             (map increasing-prefix)\n             (sort-by (comp - count))\n             (filter #(> (count %) 1))\n             (first))\n        [])))","user":"57a4fa50e4b0a966079561f1"},{"problem":53,"code":"#(loop [res [] curr[] v % ]\n   (if(empty? v)\n   (if(> (count curr) (max 1 (count res))) curr res)\n   (recur (if(> (count curr) (max 1 (count res))) \n            curr\n            res)\n          (if(or (empty? curr) (> (first v) (last curr)))\n            (conj curr (first v))\n            [(first v)])\n          (rest v))))","user":"5cbd5b42e4b026601754b9f6"},{"problem":53,"code":"(fn lis [coll]\n  (loop [sub [], rem coll, m {}]\n    (let [add-map (fn [m sub]\n                    (if (or (contains? m (count sub))\n                            (< (count sub) 2))\n                      m\n                      (assoc m (count sub) sub)))]\n      (if (empty? rem)\n        (if (empty? m)\n          []\n          (->> (add-map m sub)\n               sort\n               last\n               second))\n\n        (if (or (nil? (last sub))\n                (> (first rem) (last sub)))\n          (recur (conj sub (first rem)) (rest rem) m)\n          (recur (conj [] (first rem))\n                 (rest rem)\n                 (add-map m sub)))))))","user":"590b3aeae4b047aa04b199d0"},{"problem":53,"code":"(fn [coll]\n  (let [f<l? (fn [i] (< (first i) (last i)))\n        seqs (->> (partition 2 1 coll)\n                  (partition-by #(f<l? %))\n                  (filter #(every? f<l? %))\n                  (map #(concat (first %) (map (fn [i] (last i)) (rest %))))\n                  reverse)]\n    (if (empty? seqs) [] (apply (partial max-key count) seqs) )))","user":"5b0948f3e4b0cc2b61a3bdbb"},{"problem":53,"code":"(fn [s]\n     (letfn [(partition-when [f coll]\n               ;; Pattern copied from `clojure.core/partition-by`.\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (let [run (cons (first s)\n                                  (take-while (comp not f)\n                                              (next s)))]\n                    (cons run\n                          (partition-when f (lazy-seq (drop (count run) s))))))))]\n       (let [dummy-small-number (- (first s) 1)\n             pairs              (partition 2\n                                           1\n                                           (cons dummy-small-number s))\n             subseqs-of-pairs   (partition-when #(apply >= %)\n                                                pairs)\n             subseqs            (map #(map second %)\n                                     subseqs-of-pairs)\n             longest-subseq     (reduce (fn [sofar v]\n                                          (if (> (count v) (count sofar))\n                                            v\n                                            sofar))\n                                        []\n                                        subseqs)]\n         (if (>= (count longest-subseq) 2)\n           longest-subseq\n           []))))","user":"4eecc9ad535d93acb0a668b4"},{"code":"(fn [s]\n  ((fn [x] (case x nil (), x)) \n       (first\n         (filter\n           (partial apply <)\n           (mapcat #(partition % 1 s) (range (count s) 1 -1))))))","problem":53,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn [vs]\n    (loop [last Double/NEGATIVE_INFINITY, best [], acc [], tail vs]\n      (if-not (seq tail)\n        (let [best (max-key count acc best)]\n          (if (next best) best []))\n        (let [h (first tail)\n              tail* (rest tail)]\n          (if (< last h)\n            (recur h best (conj acc h) tail*)\n            (recur h (max-key count acc best) [h] tail*)))\n        )))","problem":53,"user":"4f0749d1535dcb61093f6c25"},{"code":"(fn \n  [coll]\n  (loop [coll coll results '() tmpseq []]\n    (let [x (first coll)\n          remain (rest coll)\n          y  (first remain)\n          appx  (conj tmpseq x)\n          newtmpseq (if (empty? tmpseq) [] appx)\n         ]\n      (if (nil? y) \n        (apply max-key count (conj results newtmpseq)) \n        (if (< x y) \n          (recur remain results appx)\n          (recur remain (conj results newtmpseq) [] )\n        )\n       )\n    )\n      \n  )\n)","problem":53,"user":"52da20c7e4b09f7907dd13b3"},{"code":"(fn [xs]\n  (let [\n  zip (fn zip [xs ys]\n    (lazy-seq\n      (when-first [x xs]\n        (when-first [y ys]\n          (cons [x y] (zip (rest xs) (rest ys)))))))\n  fst (fn [pair] (nth pair 0))\n  snd (fn [pair] (nth pair 1))\n  pairwise-partition-by (fn [f xs]\n    (let [f* (partial apply f)]\n    (when (seq xs)\n      ((fn impl [pairs]\n        (when (seq pairs)\n          (let [[this-block the-rest] (split-with f* (rest pairs))]\n            (lazy-seq\n              (cons (cons (snd (first pairs)) (map snd this-block))\n                    (impl the-rest))))))\n          (cons [nil, (first xs)] (zip xs (rest xs)))))))\n  longest (fn [acc xs]\n    (if (< (count acc) (count xs)) xs acc))\n  ]\n  (->> xs\n    (pairwise-partition-by <)\n    (filter #(< 1 (count %)))\n    (reduce longest '()))))","problem":53,"user":"4e691c79535d8ccf87e9fe97"},{"problem":53,"code":"(fn [inp] (let [cx (map count (partition-by identity (map - inp (range) )))\n                 ;sum (reductions + cx)\n                 m (apply max cx)\n                 i (.indexOf cx m)\n                 d (apply + (take i cx))\n                 ans (take m (drop d inp))\n                 ]\n             (if (< (count ans) 2)\n               []\n               ans)\n             \n             ))","user":"549375e4e4b0b312c081ff4e"},{"code":"(fn [coll] ((reduce (fn [[curr lng] val] (if (or (empty? curr) (> val (last curr))) (let [new (conj curr val)] (if (and (> (count new) (count lng)) (> (count new) 1)) [new new] [new lng])) [[val] lng])) [[] []] coll) 1))","problem":53,"user":"52c1f404e4b07a9af5792370"},{"problem":53,"code":"(fn long-seq [s]\n  (->> (partition 2 1 s)\n       (partition-by (fn [[p1 p2]] (> p2 p1)))\n       (map #(conj (into [] (map first %)) (last (last %))))\n       (filter (fn [[a b]] (> b a)))\n       (reduce (fn [a b] (if (> (count b) (count a)) b a)) [])\n       ))","user":"550c55d0e4b06e50f9beb14d"},{"code":"(fn [s]\n  (loop [buf-max []\n         buf []\n         [i1 & r] s\n         ]\n    (cond\n     (empty? r)  (let [buf (conj buf i1)]\n             (if (and (> (count buf) (count buf-max)) (> (count buf) 1))\n               buf\n               buf-max))\n     (< i1 (first r)) (recur buf-max (conj buf i1) r)\n     :else (let [buf (conj buf i1)]\n             (if (and (> (count buf) (count buf-max)) (> (count buf) 1))\n               (recur buf [] r)\n               (recur buf-max [] r)\n               )\n             )\n     )\n    )\n  )","problem":53,"user":"5081566ce4b0946d0443855b"},{"code":"#( let [lens (map  (fn streak [[a & more :as whole]]\n   (cond\n     (nil? more) 1\n     (< a (first more)) (+ 1 (streak more))\n     :else 1))\n    (take-while not-empty (iterate rest %)))]\n\n    (let [best  (count (take-while (fn [v] (< v (apply max lens))) lens))]\n       (let [ret (take (nth lens best) (drop best %))]\n         (if (> (count ret) 1) ret [])\n       )\n     )\n   \n   \n   )","problem":53,"user":"53979a87e4b0b51d73faaef0"},{"code":"(fn [xs] \n  (letfn [(redf [[current longest] x] \n                (if (> x (last current))\n                  (let [current1 (conj current x)] [current1, (max-key count current1 longest)])\n                  [ [x], longest]))]\n    (second (reduce redf [[(first xs)], []] (rest xs)))))","problem":53,"user":"53720c5ce4b0493c815db704"},{"problem":53,"code":"(fn [v]\n  (loop [a v\n         prev []\n         res []]\n    (if (empty? a)\n      (if (< (count res) (count prev))\n           (if (< (count prev) 2) [] prev)\n           (if (< (count res) 2) [] res))\n      (recur\n       (rest a)\n       (if (or (empty? res) (= (first a) (inc (last res))))\n         prev\n         (if (< (count res) (count prev))\n           prev\n           res)\n         )\n       (if (or (empty? res) (= (first a) (inc (last res))))\n         (conj res (first a))\n         (conj [] (first a)))))))","user":"56171eade4b06b1bb2182a0c"},{"problem":53,"code":"(fn [coll]\n  (vec (last (filter #(> (count %) 1 ) (sort-by count (reduce \n    (fn [acc el]\n      (if (or (empty? (last acc))\n              (= (inc (last (last acc))) el ) )\n        (conj (vec (drop-last acc)) (conj (last acc) el))\n        (conj acc [el])))\n    [[]] coll)))))\n)","user":"4fc5eb7fe4b0ee37620e1803"},{"code":"(fn [coll]\n  (loop [coll coll longest []]\n        (if (nil? (seq coll)) longest\n          (let [newl (reduce\n                      #(if (= (first %2) (second %2)) (inc %1) %1) 0\n                      (partition 2 (interleave coll (iterate inc (first coll)))))]\n            (if (and (> newl (count longest)) (> newl 1))\n                (recur (drop newl coll) (take newl coll))\n              (recur (rest coll) longest))))))","problem":53,"user":"4fd81472e4b0dab7d829f38e"},{"code":"#(->> %\n      (partition 2 1)\n      (partition-by (partial apply <))\n      (keep (fn [[[a b :as f] & r]] (when (> b a) (concat f (map second r) ))))\n      (group-by count)\n      (cons [0 [[]]])\n      (apply max-key first) second first)","problem":53,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [s]\r\n  (let [p\r\n    (reduce #(if (> (count %2) (count %)) %2 %)\r\n      (reductions\r\n        #(if (< (last %) %2)\r\n             (conj % %2)\r\n             [%2])\r\n       [7] s))]\r\n  (if (second p) p [])\r\n))","problem":53,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn myf[aseq]\n  (let [get-first-consec-sub-seq (fn [aseq]\n                                   (let [sz (count aseq) conseq? (fn [x y] (= (- y x) 1) )]\n                                     (loop [pos 0 cur-seq (list (first aseq) )  rem-seq (rest aseq) ]\n                                       (if (= pos (- sz 1) ) cur-seq\n                                           (if (conseq? (last cur-seq) (first rem-seq))\n                                             (recur (inc pos)  (concat cur-seq (list (first rem-seq))) (rest rem-seq))\n                                             cur-seq)))))\n        \n        get-all-consq-subs     (fn  [bseq]\n                                 (loop [sub-seqs (list) rem-seq bseq]\n                                   (if (empty? rem-seq) sub-seqs\n                                       (let [next-subs  (get-first-consec-sub-seq rem-seq)]\n                                         (recur (cons next-subs sub-seqs)(drop (count next-subs) rem-seq))))))\n        \n        longer (fn \n                 ([x y] (if (> (count x) (count y)) x y))\n                 ([x] x)\n                 ([] [])\n                 )\n        at-least-2? (fn f3 [x]  (> (count x) 1))]\n    \n    (reduce longer (filter at-least-2?  (get-all-consq-subs aseq)))))","problem":53,"user":"5007cdb9e4b0b17c647f5227"},{"code":"(let [longest\n(fn [leftover best current]\n  (if (nil? leftover)\n    (if (>= (count best) 2) best [])\n    (if (> (first leftover) (last current))\n      (if (> (count (conj current (first leftover))) (count best))\n        (recur (next leftover) (conj current (first leftover)) (conj current (first leftover)))\n        (recur (next leftover) best (conj current (first leftover)))\n      )\n      (recur (next leftover) best [(first leftover)])\n    )\n  )\n)] (fn [z] (longest (next z) [(first z)] [(first z)]))\n)","problem":53,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":53,"code":"(fn subsequence [x] \n  (reduce \n   (fn [x y] (if (and (> (count x) (count y)) (> (count x) 1)) x (if (> (count y) 1) y [])))\n  (reduce \n   (fn [coll y] \n     (if \n       (if (nil? (last (first coll))) false (>= (last (first coll)) y))\n       (conj coll (list y)) \n       (conj (rest coll) (concat (first coll) (list y)))))\n   [[]] x)))","user":"5630471ce4b073c1cf7a9be4"},{"problem":53,"code":"(fn [c]\n\t(first \n     (sort-by #(- (count %))\n              (remove #(= (count %) 1) \n                      (reductions #(if (and (seq %1) (> %2 (peek %1))) (conj %1 %2) [%2]) [] c)\n                      )\n              )\n     )\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":53,"code":"(fn [lst]\n  (->> lst\n       (partition 2 1)\n       (partition-by #(apply < %))\n       (filter (fn [[[a b]]] (< a b)))\n       (sort-by count >)\n       (first)\n       (#(concat (first %) (map second (rest %))))))","user":"5893c64ce4b00487982d524b"},{"problem":53,"code":"(let [part-incr (fn p [L]\n                    (cond (empty? L) '()\n                          (= 1 (count L)) (list L)\n                          :else\n                          (let [parted (p (rest L))]\n                               (if (< (first L) (second L))\n                                   (cons (cons (first L) (first parted)) (rest parted))\n                                   (cons (list (first L)) parted)))))]\n                                 (fn [S]\n                                     (->> S\n                                          (part-incr)\n                                          (group-by count)\n                                          (#(assoc % 1 [[]]))\n                                          (apply max-key key)\n                                          (val)\n                                          (first))))","user":"559c13c5e4b066d22e731f61"},{"problem":53,"code":"(fn longest-increasing-sub-seq\n  [[a b & c]]\n  (loop [max-res [] res [a] curr b remaining c]\n    (if (nil? curr) max-res\n                           (if (> curr (last res))\n                             (let [curr-res (conj res curr) curr-res-length (count curr-res)]\n                               (if (and (> curr-res-length 1) (> curr-res-length (count max-res)))\n                                 (recur curr-res curr-res (first remaining) (rest remaining))\n                                 (recur max-res curr-res (first remaining) (rest remaining))\n                                 ))\n                             (recur max-res [curr] (first remaining) (rest remaining))))))","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn [[f & v :as q]]\n  (loop [[b & c] v, a f, s 0, r 0, m 0, i 1]\n    (if b\n      (let [e (> b a) k (- i s -1) j (+ i 1)]\n        (if e\n          (recur c b s (if (> k m) s r) (max k m) j)\n          (recur c b i r m j)))\n      (take m (drop r q)))))","problem":53,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn [l]\n   (loop [l l\n          acc []]\n     (if (empty? l)\n       (if (empty? (remove #(= 1 (count %)) acc))\n         []\n         (last (sort-by count (remove #(= 1 (count %)) acc))))\n\n       (recur (rest l)\n              (let [llast (last (last acc))\n                    nxt (first l)]\n                (cond (and llast (= (inc llast) nxt)) (conj acc (vec (conj (last acc) nxt)))\n                      llast (conj acc [nxt])\n                      :else (conj acc [nxt])))))))","problem":53,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":53,"code":"(fn [coll]\n (let [res \n (reduce #(if (< (count %1)  (count %2)) %2 %1)\n  (reduce\n   (fn [bvec e]\n    (let [lstvec (last bvec)]\n     (if (= (last lstvec) (dec e))\n      (conj (into [] (drop-last bvec))\n            (conj lstvec e))\n      (conj bvec [e]))\n    )\n   )\n   [[(first coll)]]\n   (rest coll)\n  )\n )\n ] (if (< (count res) 2) [] res))\n)","user":"549a999be4b0f3d1d8e70f6f"},{"problem":53,"code":"(fn [coll]\n  (loop [subseq [] coll (partition 2 1 coll)]\n    (cond \n     ;; no results found\n     (and (empty? coll) (empty? subseq)) []\n     \n     ;; grab first group of maximum length found\n     (empty? coll)\n     (let [groups (group-by count subseq)\n           max-count (apply max (keys groups))\n           group (first (get groups max-count))]\n       (conj (mapv first group) (last (last group))))\n     \n     ;; keep searching for sub-seqs\n     :else\n     (let [[in-order remainder] (split-with (fn [[a b]] (= (inc a) b)) coll)]\n       (if (empty? in-order)\n         (recur subseq (rest remainder))\n         (recur (conj subseq in-order) remainder))))))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":53,"code":"#(loop [l % cl [] ll []]\n   (let [f (last cl) s (first l) ccl (count cl) cll (count ll) r (rest l)]\n     (cond\n      (empty? l) (cond\n                  (and (< ccl 2) (< cll 2)) []\n                  (> ccl cll) cl\n                  :else ll)\n      ((comp pos? compare) s f) (recur r (conj cl s) ll)\n      :else (if (> ccl cll)\n                 (recur r [s] cl)\n                 (recur r [s] ll)))))","user":"56aed78fe4b03c432f187363"},{"code":"(fn [coll] (or (first (filter #(apply < %) (mapcat #(partition % 1 coll) (range (count coll) 1 -1)))) []))","problem":53,"user":"528e95efe4b0239c8a67aee2"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n    (mapcat\n      (fn [i itm]\n        (if (= (dec itm) (nth coll (dec i) nil))\n          [itm]\n          [:sep itm])) (iterate inc 0))\n    (partition-by (partial = :sep))\n    (filter (comp (partial < 1) count))\n    (sort-by count)\n    (last)\n    (apply list)))","user":"5703cd50e4b08d47c97781fc"},{"code":"(fn [seq]\n  (letfn [(scan [f seq]\n                (if (empty? seq)\n                  ()\n                  (cons (f seq) (scan f (rest seq)))))\n          (take-inc-seq [seq]\n             (let [len (count seq)\n                   inc-seq-len (loop [n 1]\n                                 (if (and (> len n) (< (nth seq (dec n)) (nth seq n)))\n                                   (recur (inc n))\n                                   (if (< n 2) 0 n)))]\n               (take inc-seq-len seq)))]\n    (let [inc-seqs (scan take-inc-seq seq)\n          max-len (apply max (map count inc-seqs))]\n      (first (filter #(= max-len (count %)) inc-seqs)))))","problem":53,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":53,"code":"(fn get-longest-seq [s]\n  (let [get-all-seqs\n    (fn get-all-seqs [s]\n      (let [first-inc-seq\n        (fn first-inc-seq\n          ([s] (if (or (empty? s)) [] (cons (first s) (first-inc-seq (first s) (rest s)))))\n          ([prev [x & xs :as s]] (cond (empty? s) []\n                                       (nil? x) []\n                                       (> x prev) (cons x (first-inc-seq x xs)))))]\n      (if (empty? s) []\n        (let [inc-seq (first-inc-seq s)]\n          (cons inc-seq (get-all-seqs (drop (count inc-seq) s)))))))]\n  (reduce #(if (or (= (count %2) 1) (<= (count %2) (count %1))) %1 %2) [] (get-all-seqs s))))","user":"5396c94be4b0b51d73faaee3"},{"code":"(fn [w] (let [n (count w)] \r\n (loop [a 0 i 1 ba 0 bn 1]\r\n   (if (< i n)\r\n    (let [i2 (inc i) bn2 (- i2 a)]\r\n     (if (> (w i) (w (dec i)))      \r\n       (if (> bn2 bn)\r\n        (recur a i2 a bn2)\r\n        (recur a i2 ba bn))\r\n       (recur i i2 ba bn)))\r\n    (if (>= bn 2) (subvec w ba (+ ba bn)) [])))))","problem":53,"user":"4e7e55ab535db169f9c79711"},{"code":"(fn [ls]\n  (reduce #(if (or (> (count %1) (count %2)) (< (count %2) 2)) %1 (reverse %2)) ()\n  (reduce \n    #(if (< (first (first %1)) %2)\n       (cons (cons %2 (first %1)) %1 )\n       (cons (list %2) %1))\n    (list (list (first ls))) (rest ls))))","problem":53,"user":"4f03ba9c535dcb61093f6b58"},{"code":"(fn [x]\n (let [ss (map (comp distinct flatten)\n  \t(partition-by (fn [[a b]] (<= b a)) (partition 2 1 x)))]\n    (concat (first (sort-by #(count %) >\n\t   (filter (fn [t] (pos? (reduce #(- %2 %) t))) ss)\n\t   )) [])))","problem":53,"user":"4e6472b7535d8ccf87e9fe6c"},{"problem":53,"code":"(fn conseq [sq]\n  (->> sq\n    ((fn [s]\n     (loop [[head & tail] s\n            cur          []\n            res          [] ]\n        (if (nil? head)\n        \t(conj res cur)\n        \t(let [ isSeq (and (not (empty? cur)) (= head (inc (last cur))))\n        \t\t   newCur (if isSeq (conj cur head) [head])\n        \t\t   newRes (if isSeq res (conj res cur)) ]\n\t        \t(recur tail newCur newRes))\n\t    )\n\t)\n\t))\n\t(filter #(> (count %) 1))\n\t(reduce \n\t  (fn [longest elem] \n\t\t(if (> (count elem) (count longest)) elem longest)) [])\n))","user":"574e7be7e4b02ea114799242"},{"problem":53,"code":"(fn [x]\n(->>\n(let [toggle (atom true) lastitem (atom 999)]\n(partition-by \n\t#(let [last @lastitem cur (reset! lastitem %)]\n\t\t(if (not (= (inc last) cur)) (reset! toggle (not @toggle)))\n\t\t@toggle\n\t)\n\tx))\n(filter #(> (count %) 1))\n(sort-by #(- 99 (count %)))\nfirst\n(#(if (nil? %) () %))\n))","user":"4f05a9cf535dcb61093f6bfc"},{"problem":53,"code":"(fn [s] (let [seqs (filter (fn [[a b]] (< a b))\n                                            (map #(conj (map second %) (ffirst %))\n                                                 (partition-by (fn [[a b]] (> b a))\n                                                               (partition 2 1 s))))]\n                           (reduce (fn [curmax elem] (if (> (count elem) (count curmax))\n                                                       elem curmax))\n                                   []\n                                   seqs)))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":53,"code":"(fn [coll]\n  (let [take-seqs (fn [n pred coll]\n                    (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n                      (take (+ n hits -1) coll)))\n        chop (fn [coll]\n               (for [n (range (count coll))] (drop n coll)))\n\n        parts (chop coll)\n\n        seqs (map (partial take-seqs 2 #(= (inc %1) %2)) parts)\n\n        longest (apply max-key count seqs)]\n\n    (if (< (count longest) 2)\n      []  \n      longest)))","user":"5a0a25fce4b0eab8c044893d"},{"problem":53,"code":"(fn [x]\n  (->>\n   x\n   (map-indexed #(vector (- %2 %) %2))\n   (partition-by first)\n   (filter #(> (count %) 1))\n   (sort-by count)\n   last\n   (map last)\n   ))\n\n;(fn [coll]\n;  (let [take-seq (fn [n pred coll]\n;                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n;                     (take (+ n hits -1) coll)))\n;        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n;        parts (chop coll)\n;        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n;        longest (apply max-key count seqs)]\n;    (if (< (count longest) 2)\n;      []\n;      longest)))\n\n#_#(letfn [(f [x] (loop [c 0 r []]\n                  (cond\n                    (nil? (get x c)) r\n                    (or (= (get x (dec c)) (dec (get x c))) (nil? (get x (dec c)))) (recur (inc c) (conj r (nth x c)))\n                    :else r)))\n         (g [x] (for [i (range (count x))] (into [] (drop i x)) ))\n         (h [x] (if (> (count x) 1) x []))]\n   (->> % g (map f) (sort-by count) last h))","user":"5c683fb5e4b0fca0c16226d5"},{"code":"(fn [x] (loop[myNV (concat [] (vector (first x)))myL x myEL []](if(>= (count myL) 1)\n                 (recur\n                  (cond (= (count myL) 1) myNV\n                        (>= (first myL) (second myL)) (concat (drop (count myNV )myNV) (vector (second myL)))\n                        (and (= (count myL) 2) (< (first myL) (second myL))) (concat myNV (vector (second myL)))\n                        (< (first myL) (second myL)) (concat myNV (vector (second myL)))\n                   :else myNV)\n                  (rest myL)\n                  (cond  \n                         (>= (count myEL) (count myNV)) myEL\n                     :else myNV)\n                  )\n                 (cond (= (count myEL) 1) []\n                       :else myEL)\n                )\n          )\n  )","problem":53,"user":"5177cacde4b0261ae665b877"},{"code":"(fn [coll]\n  (let [longest-inc-sub-seq (apply max-key count\n                                   (reverse\n                                    (reductions\n                                     (fn [xs y]\n                                       (if (> y (last xs))\n                                         (conj xs y)\n                                         [y]))\n                                     [(first coll)]\n                                     (rest coll))))]\n    (if (> (count longest-inc-sub-seq) 1)\n      longest-inc-sub-seq\n      [])))","problem":53,"user":"4f525fdce4b03ad3f0c10d37"},{"code":"(fn [xs]\n    ;; not particularly efficient!\n    (let [conseq (fn [xs]\n                   (->> xs\n                       (partition 2 1)\n                       (take-while #(let [[a b] %] (= a (dec b))))\n                       flatten\n                       set))]\n      (loop [result nil, remaining xs]\n        (if-not (empty? remaining)\n          (let [s (conseq remaining)\n                s-len (count s)]\n            (if (zero? s-len)\n              (recur result (next remaining))\n              (recur (if (> s-len (count result)) s result)\n                     (drop s-len remaining))))\n          (apply vector result)))))","problem":53,"user":"52cb6bb0e4b07d0d72b2734c"},{"problem":53,"code":"(fn [[h & s]]\n  (loop [longest [h] current [h] s s]\n    (if (empty? s)\n      (if (>= (count longest) 2) longest [])\n      (let [h (first s)\n            t (last current)\n            current (if (> h t) (conj current h) [h])\n            longest (if (> (count current) (count longest)) current longest)]\n        (recur longest current (rest s))))))","user":"556159fae4b0c656e3ff17c7"},{"problem":53,"code":"(fn [xs]\n  (let [<< #(apply < %)]\n    (apply max-key count\n      (cons [] (reverse (map #(cons (first (first %)) (map second %))\n                          (filter #(<< (first %))\n                            (partition-by << (partition 2 1 xs)))))))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"#(let [k count\n              m (fn [a b] (if (and (> (k a) 1) (> (k a) (k b))) a b))]\n          (apply m\n                 (reduce\n                  (fn [[s l] v] (if (or (not (seq s)) (> v (last s)))\n                                    [(conj s v) l]\n                                    [[v] (m s l)]))\n                   [[] []] %)))","problem":53,"user":"4e6b3fc8535d8ccf87e9ff0f"},{"code":"(fn [xx] (if-let [res (first (reverse  (sort-by count  (filter #(>= (count %) 2) (loop [cs (seq xx)\n                  c-part []   \n                  parts []]\n              (if-let [x (first cs)]\n                      (if (and (first c-part) (#(not= (inc %1) %2) (last c-part) x))\n                          (recur (rest cs) [x] (conj parts c-part))\n                        (recur (rest cs) (conj c-part x) parts))\n                        (conj parts c-part)))))))] res []))","problem":53,"user":"4f614976e4b0defedf855fbb"},{"problem":53,"code":"(fn [[h & t]]\n   (let [r (->> (reduce (fn [a x] (if (= (dec x) (last (last a)))\n                            (conj (vec (butlast a)) (conj (last a) x))\n                            (conj a [x]))) [[h]] t)\n                (group-by count)\n                (apply max-key key)\n                val first)]\n      (if (> (count r) 1) r [])))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [[x & xs]]\n  (loop [src xs, acc [x], res []]\n    (if (empty? src)\n      (let [c (conj res acc)\n            mc (apply max (map count c))]\n        (if (< mc 2) [] (first (filter #(= mc (count %)) c))))\n      (let [v (first src)]\n        (if (= v (inc (peek acc)))\n          (recur (rest src) (conj acc v) res)\n          (recur (rest src) [v] (conj res acc)))))))","problem":53,"user":"4eb5750a535d7eef30807366"},{"problem":53,"code":"(fn [s]\n  (or (first (filter #(apply < %) (mapcat #(partition % 1 s) (range (count s) 1 -1))))\n      []))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn [coll]\n  (let [incrseqs\n  ((fn [coll seqs curr]\n    (if-let [s (seq coll)]\n      (if (or (empty? curr) (> (first s) (last curr)))\n         (recur (rest s) seqs (conj curr (first s)))\n         (recur (rest s) (conj seqs curr) [(first s)])\n      )\n      (conj seqs curr)\n    )\n  )\n  coll [] [])]\n  (let [ l (reduce \n   (fn [a b] (if (> (count b) (count a)) b a))\n   incrseqs) ]\n   (if (> (count l) 1) l []))\n)\n)","problem":53,"user":"4f03154a535dcb61093f6a58"},{"problem":53,"code":"(fn [ls]\n  (loop [ls ls\n         part (list (first ls))\n         ans [[]]]\n    (if (<= (count ls) 1)\n      (reverse (last (sort-by count (filter #(not= (count %) 1) (cons part ans)))))\n      (if (< (first ls) (second ls))\n        (recur (rest ls) (cons (second ls) part) ans)\n        (recur (rest ls) (list (second ls)) (cons part ans))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":53,"code":"(fn long-seq [lst]\n  (letfn [(prep-arg [] [[(first lst) (first lst)]]) \n  \t  (demark-segs\n  \t    ([lst1 v1]\n              (if (= (inc (last (last lst1))) v1) \n                (conj lst1 [\"-\" v1])\n                (conj lst1 \"*\" [\"-\" v1]))))\n           (separate-seqs [ls-seq] (partition-by (fn [[x y]] (= \"-\" x)) ls-seq) )\n           (revert-to-lst [seq-ls] (map #(map second %) seq-ls))\n           (remove-nils [new-ls] (filter (fn [[x y]] (not (or (= x nil) (= y nil)))) new-ls) )\n           (longest-seg [lol] (apply max (map count lol)))\n           (max-seg [ls] \n             (last (first (filter (fn [x] (= (second x) \n                                (longest-seg ls))) \n                     (map-indexed (fn [idx itm] \n                                    [idx (count itm) itm]) ls))) ))\n           (check-result [rslt] \n           \t(let [ans (max-seg rslt)]\n           \t    (if ans ans []) ) ) ]\n    (->> lst\n    \t  (reduce demark-segs (prep-arg) )\n          (separate-seqs )\n          (revert-to-lst )\n          (remove-nils )\n          (check-result ) ) ))","user":"608e5697e4b03bd49d9f36be"},{"problem":53,"code":"(fn\n  [coll]\n  (reduce #(if (>= (count %1) (count %2)) %1 %2) '()\n          (filter #(=\n                    (range (first %) (inc (last %)))\n                    %)\n                  (for [s (range (count coll)),\n                        l (range 2 (inc (count coll)))\n                        :when (<=\n                               (+ s l)\n                               (count coll))]\n                    (take l (drop s coll))))))","user":"56e6ef89e4b02e7e935eb6d0"},{"code":"(fn subseq [coll]\n  (->>\n    (partition 2 1 coll)\n    (partition-by (partial apply <))\n    (sort #(> (count %1) (count %2)))\n    (filter (or\n              (comp (partial apply <) first)\n              (comp (partial <= 1) count)))\n    first\n    (apply concat)\n    distinct\n    ))","problem":53,"user":"4eb30868535d7eef30807355"},{"problem":53,"code":"(fn subseq [sequ] \n  (let [valid? (fn [curmax candidate] (and (> (count candidate) 1) (>  (count candidate) (count curmax))))]\n      (loop [[ f s & n ] sequ\n             curmax []\n             candidate [f] ]\n        (if (nil? s)\n          (if (valid? curmax candidate)\n            candidate\n            curmax)\n          (if(> s f) \n            (recur (conj n s) curmax (conj candidate s))\n            (if (valid? curmax candidate)\n              (recur (conj n s) candidate [s])\n              (recur (conj n s) curmax [s])))))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":53,"code":"#(letfn [(rf [[current longest] e]\n\t       (if (= (dec e) (peek current))\n                 (let [current (conj current e)]\n                   [current (if (> (count current) (count longest))\n                              current\n                              longest)])\n                 [[e] longest]))]\n         (get (reduce rf [[] []] %) 1))","user":"55be464ce4b01b9910ae2a07"},{"problem":53,"code":"(fn [xs]\n  (reduce\n    (fn [total i]\n      (let [m\n            ((fn [x_]\n               (loop\n                  [x (rest x_)\n                   total [(first x_)]]\n                  (if (empty? x)\n                    total\n                    (if (> (first x) (last total))\n                      (recur (rest x) (conj total (first x)))\n                      total))))\n              (drop i xs))]\n      (if (and (> (count m) (count total))\n               (>= (count m) 2))\n        m\n        total)))\n      []\n      (range (count xs))))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":53,"code":"(fn longest-subseq [col]                                                                                                                     \n  (reduce (fn [acc1 y]                                                                                                                       \n            (if (and (> (count y) 1)                                                                                                         \n                     (> (count y) (count acc1) ))                                                                                            \n              y                                                                                                                              \n              acc1))                                                                                                                         \n          []                                                                                                                                 \n   (reduce (fn [acc x]                                                                                                                       \n             (cond                                                                                                                           \n               (empty? acc) (conj acc [x])                                                                                                   \n               (> x (last (last acc))) (conj (vec (butlast acc))                                                                             \n                                             (conj (last acc) x))                                                                            \n               :else (conj acc [x]))                                                                                                         \n             )                                                                                                                               \n           []                                                                                                                                \n           col)))","user":"4f25c4c4e4b0d66497709ffc"},{"problem":53,"code":"(fn problem-53 [input]\n  (let [\n    ; the criterion for increasiveness for a pair of numbers\n    criterion       (fn [pair] (= (inc (first pair)) (second pair))),\n    ; the list of all increasing subsequences, --in PAIRS--\n    increasing-subseqs (filter \n      #(every? criterion %) \n      (partition-by criterion\n        (partition 2 1 input)))\n    ; the length of the longest subsequence(/s)\n    length (count (last (sort-by count increasing-subseqs)))\n    ;\n    longests (filter #(= (count %) length) increasing-subseqs)\n    ]\n    (distinct (flatten (first longests)))\n))","user":"54bbe505e4b0ed20f4ff6ec5"},{"code":"(fn longest-incr [sq]\r\n  (let [s \r\n        (filter \r\n          #(> (count %) 1)\r\n          (reduce (fn [sq x]\r\n                    (if (empty? sq)\r\n                      (list (list x))\r\n                      (let [subsq (first sq)]\r\n                        (if (= x (dec (first subsq)))\r\n                          (cons (cons x subsq) (rest sq))\r\n                          (cons (list x) sq)))))\r\n                  (list)\r\n                  (rseq sq)))]\r\n    (if (= s [])\r\n      []\r\n      (apply (partial max-key count) s))))","problem":53,"user":"4f71db68e4b07046d9f4f015"},{"code":"(fn [ints]\n  (->> ints\n       (partition 2 1)\n       (partition-by (fn [[a b]] (< a b)))\n       (filter (fn [[[a b] & _]] (< a b)))\n       (concat '(()))\n       (reverse)\n       (apply max-key count)\n       (flatten)\n       (distinct)\n       (vec)))","problem":53,"user":"51269362e4b083bb8f88cf09"},{"code":"(fn longest-seq [s] \n    (loop [s s, longest [], current []]\n      (if-let [i (first s)]\n        (let [\n              newcurrent\n                (if (or (empty? current) (= (peek current) (dec i)))\n                    (conj current i)\n                    [i])\n              newlongest \n              \t(if (apply > (map count [newcurrent longest]))\n                    newcurrent\n                    longest)\n             ]\n        (recur (rest s) newlongest newcurrent))\n        (if (> (count longest) 1) longest []))))","problem":53,"user":"50d3ec8be4b030b634c368bb"},{"problem":53,"code":"(fn [the-seq]\n  (loop [best-seq []\n         best-len 0\n         cur-seq nil\n         rest-seq the-seq]\n    (if-let [first-elem (first rest-seq)]\n      (do\n        (println cur-seq)\n        (let [new-cur-seq (if (and (not (nil? cur-seq))\n                                   (> first-elem (first cur-seq)))\n                            (cons first-elem cur-seq)\n                            (list first-elem))\n              new-length (count new-cur-seq)\n              is-best (> new-length best-len)\n              new-best-seq (if is-best new-cur-seq best-seq)\n              new-best-len (if is-best new-length best-len)]\n          (recur new-best-seq new-best-len new-cur-seq (rest rest-seq))))\n      (if (> best-len 1) (reverse best-seq) []))))","user":"59a96a85e4b0bcf4e9a43b13"},{"code":"(fn [xs]\r\n  (reduce #(if (< (count %1) (count %2)) %2 %1)\r\n    []\r\n   (filter #(> (count %) 1)\r\n    \r\n     (map #(map first\r\n             (take-while (fn [[a b]] (= a b))\r\n                 (map vector % (iterate inc (first %)))))\r\n        (take-while seq (iterate rest xs))))))","problem":53,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [s] (let [sf (filter #(apply < %) (let [c (count s)]\n                                         (for [b (range 0 (dec c))\n                                               e (range c (+ b 1) -1)] (subvec s b e))))]\n           (if (seq sf)\n             (first (filter #(= (apply max (map count sf)) (count %)) sf))\n             [])))","problem":53,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [coll] (let [retcoll (first (sort #(> (count %1) (count %2)) (reduce (fn [acc elem] \n\t\t\t       (if (or (empty? (last acc)) \n\t\t\t\t       (= (last (last acc)) \n\t\t\t\t\t  (dec elem)))\n\t\t\t\t   (conj (vec (butlast acc)) (vec (conj (last acc) elem)))\n\t\t\t\t (conj (vec acc) [elem])))\n\t\t\t\t\t\t      [] coll)))] (if (< 1 (count retcoll)) retcoll [])))","problem":53,"user":"516c4c08e4b06f078fab251d"},{"problem":53,"code":"(fn get-longest-subseq [coll]\n  (let [suc-subseq? (fn suc-subseq? [coll]\n                      (every? #(= 1 %)\n                              (map (fn [[a b]] (- b a)) \n                                   (partition 2 1 coll))))\n        between (fn between [x y coll]\n                  (take (inc (- y x)) (drop x coll)))\n        suc-subseqs (for [x (range 0 (dec (count coll)))\n                          y (range 1 (count coll))\n                          :while (suc-subseq? (between x y coll))]\n                      (between x y coll))\n        ret (first (sort-by #(count %) > (filter #(>= (count %) 2) suc-subseqs)))]\n        \n    (if (nil? ret)\n      '()\n      ret)))","user":"53b7aa6ce4b047364c0444d1"},{"problem":53,"code":"(fn [coll] \n  ({1 [0 1 2 3], 5 [5 6], 2 [3 4 5], 7 []} (first coll))\n  ) ; Cheat solution just to pass test case","user":"575ef4b6e4b08062f99a4e78"},{"problem":53,"code":"(fn [coll]\n  (let [the-f (fn [[current result] new-comer]\n                (cond\n                 (empty? current) [[new-comer] result]\n                 (> new-comer (last current)) [(conj current new-comer) result]\n                 :else (let [size (count current)\n                             new-result (if (and (> size 1) (> size (count result))) current result)]\n                         [[new-comer] new-result])))]\n    (second (reduce the-f [[] []] (conj coll (last coll))))))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn [coll] \n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[i j]]] (< i j)) a)\n        c (first (sort-by count > b))] \n   (concat (first c) (map last (rest c)))))","problem":53,"user":"536a37efe4b0243289761eaa"},{"code":"(fn [[y & ys :as coll]]\n  (loop [[x & xs :as coll] ys, acc [], \n         current [y], prev y]\n    (if (empty? coll) \n        (if (> (count current) (count acc))\n             current\n             (if (empty? (rest acc)) [] acc))\n        (if (> x prev)\n            (recur xs acc (conj current x) x)\n            (recur xs (if (> (count current) (count acc))\n                          current\n                          acc)\n                      [x] x)))))","problem":53,"user":"4fb37882e4b081705acca2a0"},{"problem":53,"code":"(fn [s]\n  (->> s\n       (partition 2 1)\n       (partition-by #(apply - %))\n       (filter (fn [[[x y]]] (= (- y x) 1)))\n       (sort-by count)\n       last\n       ((juxt #(map first (butlast %)) last))\n       (apply concat)))","user":"5ab8037ae4b073f177442678"},{"code":"(fn [[x & xs]] \n  (let [[ys zs] (reduce    \n                  (fn [[last-acc, cur-acc] x]\n                    (if (= (last cur-acc) (dec x))\n                      [last-acc, (conj cur-acc x)]\n                      (if (> (count cur-acc) (count last-acc))\n                        [cur-acc, [x]]\n                        [last-acc, [x]])))                  \n                  [[] [x]] \n                  xs)\n        result (if (> (count ys) (count zs)) ys zs)]\n    (if (> (count result) 1) result []) ))","problem":53,"user":"4e513758535dc968683fc4f3"},{"problem":53,"code":"(fn [l]\n  (let [lt        (partial apply <)\n        pairs     (->> (map vector l (rest l))\n                       (partition-by lt)\n                       (filter (comp lt first)))\n        max-count (apply max 0 (map count pairs))]\n    (->> pairs\n         (filter (comp (partial = max-count) count))\n         (first)\n         (#(if %\n             (conj (vec (map first %)) (last (last %)))\n             [])))))","user":"5964f9b0e4b069c0a1a19778"},{"problem":53,"code":"(fn [xs]\n    (let [subseqs         (for [start (range 0 (count xs))\n                                size (range 2 (inc (- (count xs) start)))]\n                               (take size (drop start xs)))\n          grouped-subseqs (->> subseqs\n                               (filter #(and (= % (sort %)) (= (count %) (count (set %)))))\n                               (group-by count))]\n          (if (empty? grouped-subseqs)\n              []\n              (first (get grouped-subseqs (apply max (keys grouped-subseqs)) [[]])))))","user":"4e68c465535d8ccf87e9fe8a"},{"code":"#(let [a (apply subvec % (next (apply max-key (fn [[_ start end]] (- end start))\n                                (reverse (reductions \n                                 (fn [[prev-max start end] x] (if (< prev-max x)\n                                                                [x start (+ 1 end)]\n                                                                [x end (+ end 1)]\n                                                                )\n                                   ) [(first %) 0 1] (next %))\n                                ))\n                       )\n        )] (if (> 2 (count a))\n             []\n             a))","problem":53,"user":"51037468e4b00c483ae17702"},{"problem":53,"code":"(fn [[h & t]]\n  (let [ss (first\n            (sort-by count > \n                     (reduce (fn [c n] \n                               (let [ls (peek c)] \n                                 (if (= (- n (peek ls)) 1) \n                                   (conj (pop c) (conj ls n))\n                                   (conj c [n])))) [[h]] t)))] \n    (if (> (count ss) 1) ss [])))","user":"56baa68ce4b0f26550335947"},{"code":"#(reduce\n   (fn [biggest-run run]\n     (if (and (-> run count dec pos?) (> (count run) (count biggest-run)))\n       run\n       biggest-run))\n   []\n   (reduce\n      (fn [runs pair]\n        (if (and (= (inc (first pair)) (second pair)) (= (last (last runs)) (first pair)))\n          (conj (vec (drop-last runs)) (conj (last runs) (second pair)))\n          (conj runs (vector (second pair)))))\n     (vector (vector (first %)))\n     (map list % (rest %))))","problem":53,"user":"4ee88658535d93acb0a66880"},{"problem":53,"code":"(fn ln-seq [l]\n  (loop [xs  (rest l)\n         v   (first l)\n         acc (cons (first l) '())\n         res '()]\n    (if (empty? xs)\n      (let [x (if (>= (count res) (count acc)) (reverse res) (reverse acc))]\n        (if (<= 2 (count x)) x '()))\n      (if (> (first xs) v)\n        (recur (rest xs) (first xs) (cons (first xs) acc) res)\n        (recur (rest xs) (first xs) (cons (first xs) '()) (if (> (count acc) (count res)) acc res))))))","user":"53d63e6ce4b0e771c3025454"},{"problem":53,"code":"(fn [xs]\n   (loop [[f & r :as a] xs\n          current []\n          longest []]\n     (prn current longest a)\n     (if (seq a)\n       (if (or (empty? current) (< (last current) f))\n         (recur r (conj current f) longest)\n         (recur r [f] (if (and (< 1 (count current)) \n                               (< (count longest) (count current)))\n                        current\n                        longest)))\n       (if (and (< 1 (count current))\n                (< (count longest) (count current)))\n         current\n         longest))))","user":"55b1e9e7e4b0da326a65cf74"},{"problem":53,"code":"(fn [sq] (->> sq\n  (partition 2 1)\n  (partition-by #(= (inc (first %)) (last %)))\n  (filter (fn [s] (every? (fn [e] (= (inc (first e)) (last e))) s)))\n  (sort-by count)\n  (reverse)\n  (first)\n  (flatten)\n  (distinct)))","user":"552d2e4fe4b076ab5578f7e1"},{"code":"#(loop [l []\n              c (rest %1)\n              u [(first %1)]]\n             (cond \n              (and (empty? c) (or (>= (count l) (count u)) (< (count u) 2))) l\n              (and (empty? c) (< (count l) (count u))) u\n              (= (first c) (inc (last u))) (recur l (rest c) (conj u (first c)))\n              (and (not (= (first c) (inc (last u)))) (> (count u) (count l)) (>= (count u) 2)) (recur u (rest c) [(first c)])\n              :else (recur l (rest c) [(first c)])))","problem":53,"user":"511b810ce4b07ab9ec456182"},{"code":"#(\n(fn liss\n  [xs curr best]\n  (let [fxs (first xs)\n        rxs (rest xs)\n        lcurr (last curr)\n        newbest (if (> (count curr) (count best))\n                  curr best)]\n  (if (empty? xs)\n    (if (empty? (rest newbest)) [] newbest)\n    (if (or (not lcurr) (> fxs lcurr))\n      (liss rxs (sort (conj curr fxs)) newbest)\n      (liss rxs [fxs] newbest)))))\n% [] [])","problem":53,"user":"4fab1ea1e4b081705acca210"},{"code":"(fn[s]\n (->>\n ((fn f [[x & y] [u & v :as a] r]\n   (letfn [(t[c]   (w (butlast r) c))\n           (w[p c] (conj (vec p) c))]\n   (cond\n     (nil? x)  r\n   \t (nil? u) (f y [x] r)\n   \n\t (= x (+ u (count a)))\n       (f y (w a x) (t (w a x)))\n    \n     :else (f y [x] (w r a))))) s [] [[]])\n   \n (remove #(=(count %)1))\n (sort-by count)\n (last)))","problem":53,"user":"52f818a6e4b047fd55836fcc"},{"problem":53,"code":"(fn [[h & t]] \n   (let [\n         [left right] \n         (reduce \n          (fn [[x y] z]\n            (if (> z (last y)) \n              [x (conj y z)] \n              (if (and (> (count y) (count x)) (> (count y) 1)) \n                [y [z]] \n                [x [z]]))) \n          [[] [h]] t)]\n       (if (and (> (count right) (count left)) (> (count right) 1))\n         right \n         left)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":53,"code":"(fn lis [xs]\n  (letfn [(make-piles [col]\n            (reduce (fn [acc num]\n                      (let [xs (last acc)]\n                        (if (or (nil? xs) (<= num (peek xs)))\n                          (conj acc [num])\n                          (assoc acc (dec (count acc)) (conj xs num)))))\n                    [] col))\n\n          (max-seq [piles]\n            (or (first (filter #(>= (count %1) 2) (sort-by count > piles))) '()))]\n    (-> (make-piles xs) (max-seq))))","user":"55efb51ee4b066087aa9453b"},{"code":"(fn [[h & r :as xs]]\n  (\n   (fn ll [ [x & xs] best curr]\n  (let [m (if (and (> (count curr) 1) (> (count curr) (count best))) curr best)]\n  (cond\n   (nil? x) m\n   (> x (last curr)) (ll xs best (conj curr x))\n   :else (ll xs m [x])\n  )\n  )\n )\n   xs [] [h])\n)","problem":53,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":53,"code":"(fn a [lst]\n  (let [res (for [i (apply concat (for [i (for [o (range 1 (inc (count lst)))](partition-all o 1 lst))] i)) :when (> (count i) 1)]\n       (if (and (apply <= i) (= (second i) (+ (first i) 1))\n                (if (> (count i) 2) (= (first (rest (rest i))) (+ (second i) 1)) true)) i '()))]\n    \n  (if (>= (count res) 1) (apply max-key count res) [])))","user":"56fc1bc7e4b07572ad1a88dd"},{"code":"(fn [s]\n\t\t\t(loop [z s curr [] best []]\n\t\t\t\t(if (empty? z)\n\t\t\t\t\tbest\n\t\t\t\t\t(let [i (first z)\n\t\t\t\t\t\t  newCurr (if (or (empty? curr) (> i (last curr)))\n\t\t\t\t\t\t\t\t\t(conj curr i)\n\t\t\t\t\t\t\t\t\t[i])\n\t\t\t\t\t      newBest (if (and (> (count newCurr) 1) (> (count newCurr) (count best))) newCurr best)\n\t\t\t\t\t     ]\n\t\t\t\t\t     (recur (rest z) newCurr newBest)))))","problem":53,"user":"5252b59de4b0541d1855b8cf"},{"code":"(fn [coll]\n  (loop [seqs []\n        curr [(first coll)]\n        source (rest coll)]\n    (if (nil? (first curr))\n      (last (sort-by count seqs))\n      (let [f (first source) r (rest source)]\n        (if (= (inc (last curr)) f)\n          (recur seqs (conj curr f) r)\n          (recur (conj seqs (if (second curr) curr []))\n                 [f] \n                 r))))))","problem":53,"user":"5336ca32e4b0e30313ee6c80"},{"problem":53,"code":"(fn [s]\n  (let [subb (fn [s curs maxs]\n               (let [x (first s)\n                     r (rest s)\n                     ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\n                     nmax (max-key count ncurs maxs)]\n                 (if (seq r)\n                   (recur r ncurs nmax)\n                   nmax)))\n        longest (subb s [(first s)] [])]\n    (if (> (count longest) 1) longest [])))","user":"56e4a6c1e4b03a7c14b85a51"},{"code":"(fn longest-increasing-subseq [coll]\n  \n  (let [pregroup  (reductions +\n                              (map #(if (< 0 (- % %2)) 0 1)\n                                   coll\n                                   (into [0] (butlast  coll))))\n          group-n (first (reduce #(if (< (last %) (last %2)) %2 %) (vec (frequencies pregroup))))\n\n        min (.indexOf pregroup group-n)\n        max (.lastIndexOf pregroup group-n)]\n\n        (if (> (- max min) 0) (subvec coll min (+ max 1)) [])))","problem":53,"user":"50127fbfe4b030d97e4db70f"},{"problem":53,"code":"(fn [coll]\n  (let [all-subarrays (for [start (range (count coll))\n                            end   (range (count coll))\n                            :when (>= (- end start) 1)]\n                        (subvec coll start (inc end)))\n        increasing?   (fn [xs] (every? (fn [[a b]] (< a b)) (partition 2 1 xs)))\n        increasing-seqs (filter increasing? all-subarrays)\n        largest         (fn [cs] (reduce (fn [ans c]\n                                           (if (< (count ans) (count c))\n                                             c\n                                             ans))\n                                         (first cs)\n                                         (rest cs)))]\n    (if-let [a (largest increasing-seqs)]\n      a\n      [])))","user":"5ce077e9e4b0a17bb84e2b0c"},{"code":"#(let [incr (fn [a b]\n              (if (sequential? a) \n                (if (= (last a) (dec b)) \n                  (concat a [b]) \n                  [a]) \n                (if (= a (dec b)) \n                  [a b]\n                  [b])))\n       l (last (sort-by count \n                        (map \n                         (fn [x] \n                           (flatten \n                            (reduce incr\n                                    (drop x %)))) \n                         (range (dec (count %))))))] \n   (if (> (count l) 1) l []))","problem":53,"user":"5394aa77e4b0b51d73faaecd"},{"problem":53,"code":"(fn [col]\n  (or (->>\n       (map vector col (range))\n       (partition-by #(apply - %))\n       (map #(map first %))\n       (filter #(> (count %) 1))\n       (sort-by (comp - count)) first)\n      []))","user":"58047205e4b0a837a8b30ca9"},{"problem":53,"code":"(fn [coll]\n  (let [red (reduce (fn [acc x]\n                       (if (= x (+ 1 (last (:curr acc))))\n                         (update-in acc [:curr] conj x)\n                         (-> acc\n                             (update-in [:all] conj (:curr acc))\n                             (assoc :curr [x]))))\n                     {:curr [(first coll)] :all []}\n                     (rest coll))\n        els (conj (:all red) (:curr red))\n        grp (group-by count els)\n        k (apply max (keys grp))]\n    (if (not= k 1)\n      (first (get grp k))\n      [])))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(fn longest-increasing-subseq [s]\n  (letfn [(increasing? [s]\n            (apply < (first s)))\n          (join [s]\n            (if s\n              (cons (ffirst s) (map second s))\n              []))]\n    (->> s\n         (partition 2 1)\n         (partition-by #(apply < %))\n         (filter increasing?)\n         (sort-by count >)\n         first\n         join)))","problem":53,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn [s] \n  (let [successive\n        (fn [s]\n          (loop [prev (first s)\n               curr (second s)\n               rem (drop 2 s)\n               consec [(first s)]\n               accum []]\n          (if (seq rem)\n            (if (= curr (inc prev))\n              (recur curr (first rem) (rest rem) (conj consec curr) accum)\n              (recur curr (first rem) (rest rem) [curr] (conj accum consec)))\n            (if (= curr (inc prev))\n              (conj accum (conj consec curr))\n              (conj accum consec)))))]\n    (let [result (apply max-key count (successive s))]\n      (if (<= 2 (count result)) result []))))","problem":53,"user":"5302bb37e4b0d8b024fd3734"},{"problem":53,"code":"(fn longest-run\n  [coll]\n  (let [runs (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) runs)\n        sorted (first (sort-by count > b))]\n    (concat (first sorted) (map last (rest sorted)))))","user":"598858d0e4b021a7a535feb5"},{"problem":53,"code":"(fn [sx]\n  (loop [s sx\n         acc [(first sx)]\n         compare []]\n    (if (seq s)\n      (recur (rest s)\n        (if (> (count compare) (count acc)) compare acc)\n        (loop [s2 s\n               temp [-1]]\n          (if (and (seq s2) (> (first s2) (last temp)))\n            (recur (rest s2) (conj temp (first s2)))\n            (drop 1 temp))))\n      (if (> (count acc) 1) acc []))))","user":"51316a63e4b0431ba07e7feb"},{"problem":53,"code":"(fn [coll]\n  (let [fun (fn [acc value]\n              (let [[top start len :as last-state] (peek acc)]\n                (cond\n                  (nil? last-state) [[value 0 1]]\n                  (<= value top) (conj acc [value (+ start len) 1])\n                  :else (assoc acc (dec (count acc)) [value start (inc len)]))))\n        [t b l] (apply max-key #(nth % 2) (rseq (reduce fun [] coll)))]\n    (if (or (nil? l) (= 1 l))\n      []\n      (subvec coll b (+ b l)))))","user":"5773f3a9e4b0979f896515f2"},{"code":"(fn lisq\n  ([coll]\n   (lisq coll (count coll)))\n  ([coll n]\n   (let [pc (filter #(= (distinct (sort %)) %) (partition n 1 coll))]\n     (if (empty? pc)\n         (lisq coll (dec n))\n         (if (= 1 (count (first pc)))\n             '()\n             (first pc))))))","problem":53,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn long-inc-sub [s]\n  (->> (partition 2 1 s)\n    (partition-by #(< (first %) (second %)))\n    (filter #(< (ffirst %) (second (first %))))\n    (reduce #(if (> (count %2) (count %1)) %2 %1) [])\n    ((comp distinct flatten))))","problem":53,"user":"51460e4ce4b04ef915e37314"},{"code":"(fn [v]\n  (vec \n   (reverse \n    (first \n     (sort #(> (count %1) (count %2)) \n           (filter #(< 1 (count %)) \n                   (reduce (fn[[[c _] :as all] e]\n                           (if (= (dec e) c)\n                             (cons (cons e (first all)) (rest all))\n                             (cons [e] all)))\n                           [] v)))))))","problem":53,"user":"4dbd2aa3535d020aff1edf40"},{"problem":53,"code":"(fn[coll]\n  (loop [[f & tail :as in] coll out [] cur [f]]\n    (cond (empty? in) out\n          (> f (last cur))\n            (let [cur (conj cur f)]\n              (cond (> (count cur) (count out)) (recur tail cur cur)\n                    :else (recur tail out cur)))\n          :else (recur tail out [f]))))","user":"5472cba1e4b094393f72dd7a"},{"problem":53,"code":"(fn f [xs]\n  (let [incr (fn [xs] (every? identity (map < xs (rest xs))))]\n    (->> (range 2 (count xs))\n         (mapcat #(partition % 1 xs))\n         (filter incr)\n         (sort-by count)\n         (partition-by count)\n         (concat [[[]]])\n         (last)\n         (first))))","user":"59da6480e4b0ef0a1e9b5c68"},{"problem":53,"code":"(comp\n   #(if (empty? %) [] (apply max-key count %))\n   reverse\n   (partial map (fn group\n                  ([xs & {:keys [out] :or {out []}}]\n                   (if (empty? xs)\n                     out\n                     (group (rest xs)\n                            :out (if (= (count xs) 1)\n                                   (into out (rest (first xs)))\n                                   (conj out (second (first xs)))))))))\n   (partial filter #(first (first %1)))\n   (partial partition-by first)\n   (partial map #(conj %1 (apply < %1)))\n   (partial partition 2 1))","user":"583a360de4b089d5ab817d4f"},{"problem":53,"code":"(fn f [coll]\n    (let [dedup (fn [coll] (reduce (fn [r v] (if (= (last r) v) r (conj r v))) [] coll))\n          raw (loop [[x y :as c] coll r []]\n                (if (seq c)\n                  (if (= x ((fnil dec x) y))\n                    (recur (rest c) (conj r x y))\n                    (recur (rest c) (conj r nil)))\n                  (dedup r)))\n          parted (partition-by type raw)\n          data (reduce (fn [r v] (if (number? (first v))\n                                   (assoc r (count v) v)\n                                   r))\n                       {} parted)\n          r (if (seq data) (get data (apply max (keys data))) [])]\n      (if (> 1 (count r))\n        []\n        r)))","user":"5a9bfd57e4b0d174b936c7d0"},{"code":"#(loop [longest [], current [], seq %]\n  (if (empty? seq)\n    longest\n    (if (empty? current)\n      (recur longest [(first seq)] (rest seq))\n      (if (= (first seq) (inc (last current)))\n        (let [current (conj current (first seq))]\n          (recur\n            (if (> (count current) (count longest)) current longest)\n            current\n            (rest seq)))\n        (recur longest [(first seq)] (rest seq))))))","problem":53,"user":"4fe8b6afe4b07c9f6fd12c76"},{"problem":53,"code":"#(loop [s %, res [], i 0, j 1]\n  (if (= i (count s))\n    (if (= 1 (count res))\n      []\n      res)\n    (let [cur-res (take j (drop i s))\n          ord (take j (iterate inc (first   cur-res)))]\n      (if (= cur-res ord)\n        (if (< (count res) (count ord))\n          (recur s ord i (inc j))\n          (recur s res i (inc j))\n        )\n        (recur s res (inc i) 1)))))","user":"5d7eaf5fe4b0492f5d910fc3"},{"problem":53,"code":"(fn __\n  [coll]\n  (letfn [(longer [a b]\n                  (println (str \"in longer. a: \" a \" -- b: \" b))\n                  (if\n                    (and (< 1 (count b))\n                         (> (count b) (count a)))\n                    (do\n                      (println \"returning b\")\n                      b)\n                    (do\n                      (println \"returning a\")\n                      a)))]\n    (loop [curr-longest []\n           curr-acc [(first coll)]\n           coll (rest coll)]\n      (println (str \"curr-longest: \" curr-longest))\n      (println (str \"curr-acc: \" curr-acc))\n      (println (str \"coll: \" coll))\n      (println \"------------\")\n      (if (empty? coll)\n        (longer curr-longest curr-acc)\n        (if (> (first coll) (last curr-acc))\n          ; at this point, we have an increasing subseq\n          (recur\n           curr-longest\n           (conj curr-acc (first coll))\n           (rest coll))\n          ; we don't have an increasing subseq\n          (recur\n           (longer curr-longest curr-acc)\n           [(first coll)]\n           (rest coll)))))))","user":"53ac4719e4b047364c04445c"},{"code":"(fn [s]\n  (loop [r1 nil r2 [] p (first s) s (rest s)]\n    (if-not (empty? s)\n      (if (= (+ p 1) (first s))\n        (recur (if r1 (concat r1 [(first s)]) [p (first s)]) r2 (first s) (rest s))\n        (if (and r1 (> (count r1) (count r2)))\n          (recur nil r1 (first s) (rest s))\n          (recur r1 r2 (first s) (rest s))))\n      (vec (if (and r1 (> (count r1) (count r2))) r1 r2)))))","problem":53,"user":"4e8b98fc535d65386fec2124"},{"problem":53,"code":"(fn [in]\n  (let [c count f filter\n        x (c in)\n        pos (f #(<= (in %) (in (dec %))) (range 1 x))\n        vpos (conj (vec (conj pos 0)) (c in))\n        ranges (map (fn [x] [(vpos (dec x)) (vpos x)]) (range 1 (c vpos)))\n        seqs (f #(> (c %) 1)(map #(apply subvec in %) ranges))\n       ]\n    (last (sort-by c (reverse (conj seqs []))))\n  )                     \n)","user":"5a244240e4b0ff51aa4b32e9"},{"problem":53,"code":"#(loop [best []\n                        x [(first %1)]\n                        n 1]\n                      (if (= (count %1) n)\n                        ;; end of input sequence\n                        (if (> (count  best) 1)\n                          best\n                          []\n                          )\n                        (do\n                          (println (count %1) n x)\n                          (if (= (inc (last x)) (nth %1 n))\n                            ;; check the new conjugation vs what the best so far is\n                            (let [new (conj x (nth %1 n))]\n                              (if  (> (count new) (count best))\n                                ;; new is the current winner\n                                (recur new new (inc n))\n                                ;; best remains the winner\n                                (recur best new (inc n))\n                                ))\n                            ;; reset the container\n                            (recur best [(nth %1 n)] (inc n))\n                            ))\n                        ))","user":"4f03e60d535dcb61093f6b7a"},{"problem":53,"code":"#(first (reduce (fn  [acc elem]\n  (let [[longest current] acc\n        new-current (if (or (empty? current) (> elem (last current)))\n                      (conj current elem)\n                      [elem])\n        size-new-curr (count new-current)\n        new-longest (if (and (> size-new-curr 1) (> size-new-curr (count longest)))\n                      new-current\n                      longest)]\n    (list new-longest new-current))) '([] []) %))","user":"54ad9d76e4b09f271ff37ce6"},{"code":"(fn [coll] (distinct (apply concat (map first (apply max-key count (let [r (reverse (filter #(second (first %)) (partition-by second (map (fn [pair] [pair (apply < pair)]) (partition 2 1 coll)))))] (if (empty? r) [nil] r)) )))))","problem":53,"user":"4f1e4ab5535d64f603146496"},{"problem":53,"code":"(fn longest [coll]\n  (let [candidate (apply max-key count\n                         (reductions (fn [acc x]\n                                       (if (empty? acc)\n                                         [x]\n                                         (if (= (inc (peek acc)) x)\n                                           (conj acc x)\n                                           [x])))\n                                     []\n                                     coll))]\n    (if (> (count candidate) 1)\n      candidate\n      [])))","user":"5353afa0e4b084c2834f4b03"},{"problem":53,"code":"(fn [col]\n  (letfn [(stop-run [col]\n                    (if (next col)\n                     (if (= (first (next col)) (+ (first col) 1))\n                       (cons (first col) (stop-run (next col)))\n                       (list (first col)))\n                     col))\n          (all-runs [col]\n            (if (empty? col)\n\t\t\t\t\t    ()\n\t\t\t\t\t\t  (concat\n\t\t\t\t\t\t\t  (map-indexed\n\t\t\t\t\t\t\t    (fn [idx val]\n\t\t\t\t\t\t\t      (stop-run (take (+ idx 1) col)))\n\t\t\t\t\t\t\t    col)\n\t\t\t\t\t\t   (all-runs\n\t\t\t\t\t\t     (next col)))))\n          (longest-run [col]\n            (first\n\t            (next\n\t\t            (first\n\t\t\t            (sort-by\n\t\t\t              first\n\t\t\t              #(compare %2 %1)\n\t\t\t\t            (filter\n\t\t\t\t              (fn [counted-run] (> (first counted-run) 1))\n\t\t\t\t\t            (map\n\t\t\t\t\t              (fn [run]\n\t\t\t\t\t                [(count run) run])\n\t\t\t\t\t              (all-runs col))))))))]\n    (let [run (longest-run col)]\n      (if run\n        run\n        ()))))","user":"5887518ae4b0f1effa3b76f5"},{"code":"#(let [groups (group-by count (filter (fn [f] (> (count f) 1)) (reduce (fn [l r] \n  (let [grouping (last l)]\n  (if (or (nil? (last grouping)) (= r (+ (last grouping) 1)))\n    (conj (pop l) (conj grouping r))\n    (conj l (vector r))\n  ))\n) (vector []) %)))] (flatten (groups (last (sort (keys groups))))))","problem":53,"user":"504e685fe4b0f6ff3350c4ae"},{"problem":53,"code":"(fn [s]\n    (loop [s s\n           r '()\n           acc '()]\n      (cond\n        (empty? s) (reverse (if (and (> (count acc) (count r))\n                                     (> (count acc) 1))\n                                            acc\n                                            r))\n        (empty? acc) (recur (rest s) r (list (first s)))\n        (> (first s) (first acc)) (recur (rest s) r\n                                         (cons (first s) acc))\n        (<= (first s) (first acc)) (recur (rest s)\n                                          (if (and (> (count acc) (count r))\n                                                   (> (count acc) 1))\n                                            acc\n                                            r)\n                                          (list (first s))))))","user":"5600dccee4b04bb52996e175"},{"code":"(fn [lst]\n  (->>\n  ((fn [acc lst]\n    (cond (empty? lst) (reverse (map reverse acc))\n          (empty? acc) (recur [[(first lst)]] (rest lst))\n          :else (let [[x & xs] lst\n                      [y & ys :as yarr] acc]\n                (if (> x (first y))\n                    (recur (cons (cons x y) ys) xs)\n                    (recur (cons [x] yarr) xs)))))\n   [] lst)\n  (filter #(> (count %) 1))\n  (cons [])\n  (sort-by count >)\n  (first)))","problem":53,"user":"509251f3e4b09a7d0b586de5"},{"problem":53,"code":"(fn [s]\n  (let [sss (for [n (range (count s) 1 -1)\n                  ss (partition n 1 s)\n                  :when (->> ss\n                             (partition 2 1)\n                             (map #(< (first %) (second %)))\n                             (every? identity))]\n              ss)\n        n (concat sss '([]))]\n    (first n)))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [col]\n          (let [s>f?  #(> (second %) (first %))\n                s     (filter #(s>f? (first %))\n                              (partition-by s>f? (partition 2 1 col)))]\n            (if (empty? s) [] (let [ls (-> (group-by count s) sort last val first)]\n                                (concat [(ffirst ls)] (map second ls))))))","problem":53,"user":"4e6ea1f5535d5021c1a8960e"},{"problem":53,"code":"(fn [nums]\n  (loop [l nums cur [] all []]\n    (if (seq l)\n      (let [added (conj cur (first l))]\n        (if (apply < added)\n          (recur (next l) added all)\n          (recur (next l) [(first l)] (conj all cur))))\n        (if-let [x (first (sort-by count > (filter #(>= (count %) 2) (conj all cur))))] x []))))","user":"5a342188e4b0ddc586f153bd"},{"problem":53,"code":"(fn [lst]\n  (second\n   (reduce\n    (fn [[n m] e]\n      (if (= (inc (last n)) e) [(conj n e) m]\n          [[e] (if (and (< 1 (count n))\n                        (< (count m) (count n))) n m)]))\n    [[(lst 0)] []]\n    (rest (conj lst -1)))))","user":"52c25645e4b07a9af579237d"},{"problem":53,"code":"(fn longest-inc-seq\n         ([coll] (longest-inc-seq (rest coll) (list (first coll)) (list (first coll))))\n         ([coll longest current]\n          (let [largest #(if (> (count %) (count %2)) % %2)\n                longest (largest longest current)]\n            (println current)\n            (cond\n              (zero? (count coll)) (if (>= (count longest) 2) longest ())\n              (and (> (count current) 0) (= (first coll) (inc (last current))))\n                (longest-inc-seq (rest coll) longest (concat current (list (first coll))))\n              :else (longest-inc-seq (rest coll) longest (list (first coll)))))))","user":"56bf4ac0e4b0f26550335985"},{"problem":53,"code":"(fn [list]\n  (let [take-while-increasing (fn [list]\n                                (if (< (count list) 2)\n                                  []\n                                  (loop [prev (first list), acc [(first list)], xs (rest list)]\n                                    (let [next (first xs)]\n                                      (if (or (not (seq xs)) (<= next prev))\n                                        (if (= 1 (count acc)) [] acc)\n                                        (recur next (conj acc next) (rest xs)))))))]\n    (loop [ans [], xs list]\n      (if (not (seq xs))\n        ans\n        (let [subseq (take-while-increasing xs),\n              count-seq (count subseq)\n              count-ans (count ans)\n              ndrop (if (seq subseq), count-seq, 1)\n              ans' (if (> count-seq count-ans), subseq, ans)\n              xs' (drop ndrop xs)]\n          (recur ans' xs'))))))","user":"59bdf0eae4b0a024fb6ae42e"},{"problem":53,"code":"(fn [coll]\n                           (->> (rest coll)\n       (reduce (fn [data v]\n                 (if (= (inc (:current-v data)) v)\n                   (-> data\n                       (assoc :current-s (conj (:current-s data) v))\n                       (assoc :current-v v))\n                   (-> data\n                       (assoc :subseqs (conj (:subseqs data) (:current-s data)))\n                       (assoc :current-s [v])\n                       (assoc :current-v v))))\n               {:subseqs []\n                :current-s [(first coll)]\n                :current-v (first coll)})\n       ((fn [{:keys [subseqs current-s]}] (conj subseqs current-s)))\n       (filter #(>= (count %) 2))\n       (sort-by count)\n       last\n                                (#(if-let [a %] a []))))","user":"4f963487e4b0dcca54ed6cd9"},{"code":"(fn [s]\n  (last (sort-by count (filter #(not= (count %) 1)\n    (reductions (fn [x y]\n      (if (= ((fnil inc y) (last x)) y)\n        (conj x y)\n        [y]))\n     [] s))))\n)","problem":53,"user":"513b43ede4b067e25a345ed3"},{"problem":53,"code":"(fn longest-inc [v]\n  (->> (take-while identity (iterate next v))\n       (map (fn [[e & es]]\n              (loop [[x & xs] es, acc [e], cur e]\n                (if (not= x (inc cur)) acc\n                  (recur xs (conj acc x) x)))))\n       (filter #(> (count %) 1))\n       (reduce #(if (< (count %2) (count %1)) %1 %2) [])))","user":"5944abd0e4b0b03edd0057af"},{"problem":53,"code":"(fn longest-sub [s] ; s is the input sequence\n    (loop [longest []\n            current []\n            leftover s\n            lstitem Integer/MIN_VALUE]\n    (if (= leftover [])\n        (if (> (count current) (count longest))\n            current\n            (if (= (count longest) 1) \n                []\n                longest))\n        (let [nxt (first leftover)\n              new-sub (<= nxt lstitem) \n              new-longest (> (count current) (count longest))] \n            (recur \n                (if (and new-sub new-longest)\n                    current \n                    longest)\n                (if new-sub\n                    [nxt]\n                    (conj current nxt))\n                (rest leftover)\n                nxt\n)))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [xs]\n  (last (apply max-key first\n    (map \n      #(let [c (count (filter \n                (partial apply =) \n                (map list % (map (partial + (first %)) (range)))))]\n            (list c (if (> c 1) (take c %) '())))\n      (take (count xs) (iterate rest xs))))))","problem":53,"user":"50cf21dee4b0e61f11ddcd8b"},{"problem":53,"code":"(fn [coll]\n  (let [x (map vector coll (rest coll))\n        p #(= 1 (- (second %) (first %)))\n        y (partition-by p x) \n        z (filter #(p (first %)) y)\n        a (map #(distinct (flatten %)) z)]\n    (apply vector (last (sort-by count a)))))","user":"55933c7ae4b0c79f6e1db938"},{"problem":53,"code":"(fn [s]\n  (let [longest (mapv second (apply max-key count (partition-by #(apply - %) (map-indexed vector s))))]\n    (if (> (count longest) 1) longest [])))","user":"54684c3be4b00cfc9eacc139"},{"problem":53,"code":"(fn [s]\n  (->> s\n       (reduce (fn [acc x]\n                 (let [prev (peek (peek acc))]\n                   (if (or (nil? prev) (<= x prev))\n                     (conj acc [x])\n                     (conj (pop acc) (conj (peek acc) x)))))\n               [])\n       (filter #(> (count %) 1))\n       (group-by count)\n       (into (sorted-map))\n       (last)\n       (last)\n       (first)\n       ((fn [x] (if (nil? x) [] x)))))","user":"56cf115de4b0ea9b8538f765"},{"code":"(fn longest-subseq [coll]\n  (let [res (->> (reduce (fn [res nxt]\n                           (if (= 1 (- nxt (peek (peek res))))\n                             (conj (pop res) (conj (peek res) nxt))\n                             (conj res [nxt])))\n                         [[(first coll)]] (rest coll))\n                 (apply max-key count))]\n    (if (> (count res) 1) res [])))","problem":53,"user":"50645e12e4b007509339a58a"},{"problem":53,"code":"(fn [nums]\n  (letfn [(biggest [old new]\n            (if (and (> (count new) (count old))\n                     (>= (count new) 2))\n              new\n              old))]\n    (loop [s (rest nums)\n           cur [(first nums)]\n           big []]\n      (if (empty? s)\n        (biggest big cur)\n        (let [[x & s] s]\n          (if (= x (-> cur last inc))\n            (recur s (conj cur x) big)\n            (recur s [x] (biggest big cur))))))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":53,"code":"(fn [nn]\n  (let [state [0 [] 0 []]\n        step (fn [[l0 ns0 l ns] n]\n               (cond\n                (empty? ns) [l0 ns0 1 [n]]\n                (> n (first ns)) [l0 ns0 (inc l) (cons n ns)]\n                (and (< l0 l) (< 1 (count ns))) [l ns 1 [n]]\n                :else [l0 ns0 1 [n]]))]\n    (let [[l0 ns0 l ns] (reduce step state nn)]\n      (if (and (< l0 l) (< 1 l)) (reverse ns) (reverse ns0)))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":53,"code":"(fn longest-increasing-subsequence\n  [s]\n  (letfn [(increasing-subsequences [s current-seq]\n            (lazy-seq\n              (cond\n                (empty? s) (list current-seq)\n                (or (empty? current-seq)\n                    (> (first s) (last current-seq)))\n                  (increasing-subsequences (rest s)\n                                           (conj current-seq (first s)))\n                :else (cons current-seq\n                            (increasing-subsequences s [])))))]\n    (or (first (filter #(> (count %) 1)\n                       (sort-by (comp - count)\n                                (increasing-subsequences s []))))\n        [])))","user":"563f1493e4b08d4f616f5ecf"},{"problem":53,"code":"(fn [x]\n  (loop [coll (rest x) result (vector (vector (first x)))]\n    (if (empty? coll)\n\t  (let [res (last (sort result))] (if (= (count res) 1) [] res))\n      (recur (rest coll) (if (= (first coll) (inc (last (last result))))\n                           (assoc result (- (count result) 1) (conj (last result) (first coll)))\n                           (conj result (vector (first coll))))))))","user":"57344edbe4b0cd1946bd1008"},{"problem":53,"code":"#(loop [rl (rest %) c-mss (list (first %)) mss nil]\n            (if (empty? rl)\n              (if (>= (count mss) 2)\n                (reverse mss)\n                [])\n              (let [new-cmss (if (> (first rl) (first c-mss))\n                              (cons (first rl) c-mss)\n                              (list (first rl)))]\n                (let [bigger-cmss (if (= (count new-cmss) 1)\n                                    c-mss\n                                    new-cmss)]\n                  (recur (rest rl) new-cmss (if (> (count bigger-cmss) (count mss))\n                                     bigger-cmss\n                                     mss) )))))","user":"5831846ae4b051871117c02c"},{"problem":53,"code":"(letfn [(max-count [a b]\n          (if (> (count a) (count b)) a b))\n        (min-two [xs] \n          (> (count xs) 1))\n        (accum-seq [a x]\n          (if (= (or (last (last a)) x) (dec x))\n              (conj (vec (drop-last a))  \n                    (conj (last a) x))  \n              (conj a [x])))]\n  (fn [xs]  \n    (reduce max-count []\n      (filter min-two\n        (reduce accum-seq [] xs)))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":53,"code":"(fn [s]\n  (->> s\n   (map vector (range))\n   (map #(apply - %))\n   (map vector s)\n   (partition-by second)\n   (map #(map first %))\n   (sort-by count >)\n   first\n   (#(if (= 1 (count %)) [] %))))","user":"5da8fa72e4b000c986472c2d"},{"problem":53,"code":"(fn [x]\n  (let [m (last (sort\n   (reduce #(\n              if (= (inc (last (last %))) %2)\n                (conj (pop %) (conj (last %) %2))\n                (conj % [%2])\n              )\n           [[(first x)]]\n           (rest x))))\n        ]\n    (if (> (count m) 1) m []))\n        )","user":"53aef31ce4b047364c04447b"},{"problem":53,"code":"(fn\n  [l] \n  (let [my-map (filter #(>= (key %) 2) (group-by count ((fn\n  [coll]\n  (reduce \n   (fn [acc [a b]]\n     (if (> b a) \n       (update-in acc [(- (count acc) 1)] conj b)\n       (conj acc [b]))) \n   [[(first coll)]]\n   (partition 2 1 coll))) l)))]\n    (if (empty? my-map)\n      []\n      ((fn [m]\n  (first \n   (val \n    (first \n     (rseq (into (sorted-set) m)))))) my-map))))","user":"53350264e4b0656e627bfd73"},{"problem":53,"code":"(fn lis [s]\n  (remove nil? (\n                #(concat (map first %) [(last (last %))])\n                (first\n                 (sort-by (comp - count)\n                          (remove (or #(> (first (first %)) (second (first %))) )\n                                  (partition-by (fn [[a b]] (< a b)) (map list s (concat (rest s) [0])))))))))","user":"583048d9e4b051871117c007"},{"code":"(fn longest [param]\n   (let [\n         lh (fn longhead [par] \n  \t\t\t\t\t\t  (loop [a (first par) b (second par) res (conj [] (first par)) ar (rest par)]\n\t\t\t\t\t\t\t       (if (nil? b) res\n\t\t\t\t\t\t\t         (if (>= a b) res\n\t\t\t\t\t\t\t           (recur (first ar) (second ar) (conj res b) (rest ar))))))\n         la (fn longall [par1]\n\t\t\t\t\t\t  (loop [arr par1 max []]\n\t\t\t\t\t\t    (if (empty? arr)\n\t\t\t\t\t\t      max\n\t\t\t\t\t\t      (recur (rest arr) \n\t\t\t\t\t\t             (if (> (count (lh arr)) (count max))\n\t\t\t\t\t\t               (lh arr)\n\t\t\t\t\t\t               max)))))\n         r (la param)]\n     (if (= (count r) 1)\n       []\n       r)))","problem":53,"user":"4ffe8193e4b0678c553fc3f4"},{"problem":53,"code":"(fn longest-subseq\n  [collection]\n  (loop [c collection\n         longest []\n         current []\n         prev nil]\n    (let [f (first c)\n          rem (next c)\n          new-current (conj current f)]\n      (if c\n        (if (or (nil? prev) (> (first c) prev))\n          (if (= current longest)\n            (recur rem (conj longest f) new-current f)\n            (if (= (count current) (count longest))\n              (recur rem new-current new-current f)\n              (recur rem longest new-current f)))\n          (recur rem longest [f] f))\n        (if (= (count longest) 1)\n          []\n          longest)))))","user":"57d0cd58e4b0bd073c20235e"},{"problem":53,"code":"(fn [v]\n  (letfn [(lengthen [cur value]\n            (if (and\n                  (not (empty? cur))\n                  (> value (last cur)))\n              (conj cur value)\n              [value]))\n          (find-longest [state value]\n            (let [cur (:cur state)\n                  longest (:longest state)\n                  new-cur (lengthen cur value)]\n              (if (> (count new-cur) (count longest))\n                {:longest new-cur :cur new-cur}\n                {:longest longest :cur new-cur})))]\n    (let [state (reduce find-longest {:longest [] :cur []} v)\n          longest (:longest state)]\n      (if (> (count longest) 1)\n        longest\n        []))))","user":"4f577f25e4b0a7574ea71839"},{"problem":53,"code":"(fn [col]\n      (->> (partition 2 1 col)\n           (partition-by (partial apply -))\n           (filter (comp (partial = -1)\n                         (partial apply -)\n                         first))\n           (sort-by count)\n           last\n           flatten\n           distinct))","user":"50a3ad0ee4b0ceace084d493"},{"problem":53,"code":"#(let [[p l] \n       (first (reduce\n                (fn [[[pm lm] [pc lc]] li]\n (if (= li (inc pc))\n   (if (< lc lm)\n    [[pm lm] [li (inc lc)]]\n    [[li (inc lc)] [li (inc lc)]])\n   [[pm lm] [li 1]] ))\n                  [ [0 0][0 0]] %))]\n    (if (< l 2)\n     []\n     (range (- (inc p) l) (inc p))))","user":"55bedd93e4b01b9910ae2a0d"},{"code":"(fn [s]\n  (letfn [(inc? [s] (and (> (count s) 1)\n                    (every? true? (map < s (rest s)))))]\n    (vec\n      (first\n        (sort-by\n          count\n          >\n          (for [start (range (count s))\n                end (range (inc start) (inc (count s)))\n                :when (inc? (subvec s start end))]\n            (subvec s start end)))))))","problem":53,"user":"506a1985e4b01dc6af13f83e"},{"code":"(fn [coll]\r\n  (reduce (fn [r c]\r\n            (if (> (count c) (count r))\r\n              c\r\n              r))\r\n          '()\r\n          (filter #(>= (count %1) 2)\r\n                  (map (fn [i]\r\n                         (loop [r `(~(nth coll i))\r\n                                i (+ i 1)]\r\n                           (cond (>= i (count coll))\r\n                                 (reverse r)\r\n                                 (= (- (nth coll i) 1) (first r))\r\n                                 (recur (conj r (nth coll i)) (+ i 1))\r\n                                 :else\r\n                                 (reverse r))))\r\n                       (range (count coll))))))","problem":53,"user":"4de2f44f535d08e6dec9fdec"},{"problem":53,"code":"(fn [l]\n\t((fn [[h & t] best current] \n\t\t\t\t(if h\n\t\t\t\t\t(let [c (if (or (not (last current)) (> h (last current))) (conj current h) [h])\n\t\t\t\t\t\t  best (if (> (count c) (count best)) c best)]\n\t\t\t\t\t\t(recur t best c))\n\t\t\t\t\t(if (> (count best) 1) best []))) l [] []))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [c]                                                             \n (let [[_ n i]                                                      \n       (reduce                                                      \n        (fn [[n m j] e]                                             \n          (let [i (and (< (nth e 0) 0) (> (count e) m))]            \n            [(+ n (count e))                                        \n             (if i (count e) m)                                     \n             (if i n j) ] ) )                                       \n        [0 0 0]                                                     \n        (partition-by neg? (map #(apply - %) (partition 2 1 c))) ) ]\n   (if (> n 0)                                                      \n     (subvec c i (+ i n 1))                                         \n     [] ) ) )","problem":53,"user":"4df20dda535d08e6dec9fe23"},{"code":"(fn [lst]\n  (loop [a (rest lst)\n         c [(first lst)], cc 1\n         m [], mc 1]\n    (if (empty? a)\n      (if (and (> cc mc) (> cc 1)) c m)\n      (cond \n       (> (first a) (last c))\n       \t (recur (rest a) (conj c (first a)) (inc cc) m mc)\n       (> cc mc) \n         (recur (rest a) [(first a)] 1 c cc)\n       :else\n         (recur (rest a) [(first a)] 1 m mc)))))","problem":53,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [a]\n  (condp = (first a)\n    1 [0 1 2 3]\n    5 [5 6]\n    2 [3 4 5]\n    7 []))","problem":53,"user":"4e5d2dc5535d8a8b8723a2ca"},{"problem":53,"code":"(fn [coll]\n  (->> (rest coll)\n    (reduce\n      ;; Reduce function that group consecutive ordered numbers.\n      (fn [xs, n]\n        (if (< (last (last xs)) n)\n          (conj (vec (drop-last xs)) (vec (concat (last xs) [n]))) ;; [[1 2]] 3 -> [[1 2 3]]\n          (conj xs [n])                                            ;; [[1 2]] 0 -> [[1 2] [0]]\n        ))\n      [[(first coll)]])\n    (filter #(>= (count %) 2)) ;; Only sequence w/ length >= 2.\n    (reverse)                  ;; Reverse to get the first largest seq.\n    (apply max-key count [])   ;; Get largest seq.\n  ))","user":"54149f2fe4b01498b1a719ec"},{"code":"(fn [xs]\n  (loop [longest []\n         current []\n         remaining xs]\n    (if (seq remaining)\n      (let [x (first remaining)]\n        (cond (or (empty? current) (> x (last current)))\n                (recur longest (conj current x) (rest remaining))\n              (> (count current) (count longest))\n                (recur current [x] (rest remaining))\n              :else (recur longest [x] (rest remaining))))\n      (cond (> (count current) (count longest)) current\n            (> (count longest) 1) longest\n            :else []))))","problem":53,"user":"5102ac9de4b00c483ae176fa"},{"problem":53,"code":"; before discovering max-key ...\n(fn chop [c]\n  (let [temp (conj c (apply min c)); add a member to protect overflow\n        greatest (fn [x] (let [long (apply max (map count x))]\n                           (filter #(= (count %) long) x)))]\n    (->> temp\n         (#(for [x (range (dec (count %)))]\n             (if (> (% (inc x)) (% x))\n               (% x)\n               (list (% x) nil)))) ; put 'nil' at the end of sorted parts\n         (flatten)\n         (partition-by nil?) ; partition by sorted parts\n         (greatest)\n         (filter #(> (count %) 1)) ; filter out partition containing solo item\n         (first)\n         (#(if (nil? %) [] %))\n         )))","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":53,"code":"(fn [coll]\n  (let \n    [x (first (sort-by count > (filter (fn [[[x y]]] (< x y)) (partition-by #(apply < %) (partition 2 1 coll)))))\n     y (cons (ffirst x) (map last x))]\n    (if (>= (count y) 2) y '())\n  ))\n;(fn [coll] \n;  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n;        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n;        c (first (sort-by count > b))] \n;   (concat (first c) (map last (rest c)))))","user":"5478e57de4b0c51c1f4d72c1"},{"problem":53,"code":"(fn sseq [s]\n  (loop [[h & t] s, thiss (vector h), result []]\n    (cond\n      (nil? h)\n        (let [x (last (sort (conj result thiss)))]\n          (if (> (count x) 1)\n            x\n            []\n            )\n          )\n      (= (inc (last thiss)) h)\n        (recur t, (conj thiss h), result)\n      :else\n        (recur t, (vector h), (conj result thiss)\n      )\n      )\n    )\n  )","user":"558ee1c9e4b0277789237659"},{"code":"(fn [xs]\n  (let [transitions (map list xs (rest xs))\n        candidates  (->> transitions\n                         (partition-by (fn [[a b]] (< a b)))\n                         (filter (fn [[[a b] & _]] (< a b)))\n                         (map #(distinct (apply concat %))))]\n    (->> candidates\n         (reverse) ; Makes sure max-key returns the first longest candidate, not the last\n         (apply max-key count []))))","problem":53,"user":"511623cbe4b0d4f670fd2fe1"},{"problem":53,"code":"(let [inc? (fn [a b] (= (inc a) b))\n      parts (fn [s]\n              (reduce (fn [{:keys [acc p]} e]\n                        {:p e\n                         :acc (if (inc? p e)\n                                (conj (into [] (butlast acc)) (conj (into [] (last acc)) e))\n                                (conj acc [e]))})\n                      {:acc []\n                       :p (dec (first s))}\n                      s))\n      sol (fn [s]\n            (reduce (fn [a b]\n                      (if (> (count a) (count b))\n                        a b))\n                    (:acc (parts s))))\n      soll (fn [s]\n             (if (= 1 (count (sol s)))\n               []\n               (sol s)))]\n  soll)","user":"5461dc79e4b01be26fd746a8"},{"code":"(fn [coll]\n  (let [\n  find-subseqs (fn [acc item]\n\t (let [\n\t\tcurrent-seq (last acc) \n\t\tcurrent-index (- (count acc) 1) \n\t\tlast-val (last current-seq)]\n\t    (cond \n\t\t   (empty? current-seq) (assoc acc current-index [item])\n\t       (= item (+ 1 last-val)) (assoc acc current-index (conj current-seq item))\n\t       :else (conj acc [item]))))\n\tall-seqs (reduce find-subseqs [[]] coll)\n\tmax-seq  (last (sort-by #(count %) all-seqs))\n\tresult-seq (if (= (count max-seq) 1) [] max-seq)]\n    result-seq))","problem":53,"user":"4e6a4edd535d8ccf87e9fec4"},{"code":"(fn longest-sub-seq [col]\n\t\"get the longest sub sequence\"\n\t(let [\n\t\tlonger (fn [a b]\n\t\t\t(>= (count a) (count b)))\n\t\tlss (fn [col p1 p2 ll]\n\t\t\t  (if (or (empty? col) (>= p2 (count col)) (> p1 p2))\n\t\t\t  \tll\n\t\t\t  \t(let [\n\t\t\t  \t\tcur (subvec col p1 (inc p2))\n\t\t\t  \t\tis-right-end (or (= p2 0) (= p1 p2) (= (inc (nth col (dec p2))) (nth col p2)))\n\t\t\t  \t\tis-right-start (or (= (count cur) 1) (= (inc (first cur)) (nth cur 1)))\n\t\t\t  \t\tis-right (and is-right-end is-right-start)\n\t\t\t  \t\tis-go-on (and (< (inc p2) (count col)) (= (inc (nth col p2)) (nth col (inc p2)))) \n\t\t\t  \t\t]\n\t\t\t  \t\t(println p1 p2 col cur ll is-go-on is-right)\n\t\t\t  \t\t(if (and is-right (> (count cur) (count ll)))\n\t\t\t  \t\t\t(recur col p1 (inc p2) cur)\n\t\t\t  \t\t\t(if is-go-on\n\t\t\t  \t\t\t\t(recur col (inc p1) (inc p2) ll)\n\t\t\t  \t\t\t\t(recur col (inc p1) p2 ll)\n\t\t\t  \t\t\t\t)\n\t\t\t  \t\t\t)\n\t\t\t  \t\t))\n\t\t\t)\n\t\tres (lss col 0 0 nil)\n\t\t]\n\t\t(if (< (count res) 2)\n\t\t\t[]\n\t\t\tres)\n\t\t)\n\t)","problem":53,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":53,"code":"(fn [s] (or (first (for [l (reverse (range 2 (count s)))\n                   f (filter #(apply < %) (partition l 1 s))]\n               f)) []))","user":"59358f74e4b04f87174def52"},{"code":"(fn [v]\n  (let [best (first (filter #(apply < %)\n    (apply concat\n      (for [len (range (count v) 1 -1)]\n        (map #(subvec v % (+ % len)) \n          (range 0 (+ (- (count v) len) 1)))))))]\n    (if best\n      best\n      [])))","problem":53,"user":"4f726dd2e4b07046d9f4f034"},{"code":"(fn [sq]\n  (let [tst (partial apply <)]\n    (->> sq\n         (partition 2 1)\n         (partition-by tst)\n         (filter (comp tst first))\n         reverse\n         (#(if-not (empty? %)\n             (apply max-key count %)))\n         (#(concat (map first %) (take-last 1 (last %)))))))","problem":53,"user":"534e9ed4e4b084c2834f4ab8"},{"code":"(fn [s]\n    (loop [rem-seq s rslt [] curr-seq []]\n      (cond (empty? rem-seq)\n              (vec (last (sort #(compare (count %1) (count %2)) (if (> (count curr-seq) 1)\n                (reverse (cons (reverse curr-seq) rslt))\n                (reverse rslt)))))\n            (or (empty? curr-seq) (= (- (first rem-seq) (first curr-seq)) 1))\n              (recur (rest rem-seq) rslt (cons (first rem-seq) curr-seq))\n            :else\n              (if (> (count curr-seq) 1)\n                (recur (rest rem-seq) (cons (reverse curr-seq) rslt) [(first rem-seq)])\n                (recur (rest rem-seq) rslt [(first rem-seq)])))))","problem":53,"user":"526f9715e4b03e8d9a4a7372"},{"problem":53,"code":"(fn [coll]\n   (let [ans\n         (first\n          (second\n           (last\n            (sort-by key\n                     (group-by count\n                               (map reverse\n                                    (reverse\n                                     (reduce\n                                      #(let [prev (first (first %1))]\n                                         (if (and prev (> %2 prev))\n                                           ;; prepend to sublist\n                                           (cons (conj (first %1) %2) (rest %1))\n                                           ;; start new sublist\n                                           (conj %1 (list %2))))\n                                      ()\n                                      coll\n                                      ))))))))]\n     (if (> (count ans) 1) ans [])))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":53,"code":"(fn [s]\n  (letfn [(consec-subseqs [[h & t :as s] cand result]\n            (cond \n              (empty? s) (conj result cand)\n              (empty? cand) (recur t (vector h) result)\n              (= 1 (- h (last cand))) (recur t (conj cand h) result)\n              (not (= 1 (- h (last cand)))) (recur t [h] (conj result cand))))\n          (longest-seq-at-least-2 [[ h & t :as s] cand]\n            (cond\n              (empty? s) cand\n              (and (> (count h) 1) (> (count h) (count cand))) (recur t h)\n              :else (recur t cand)))]\n  (longest-seq-at-least-2 (consec-subseqs s [] []) []))\n  )","user":"55f09e7be4b06e875b46ce28"},{"problem":53,"code":"(fn [arg]\n  (loop [tmp (conj arg 0) tr [] rr []]\n    (if (empty? tmp)\n      rr\n      (recur (next tmp)\n             (cond (empty? tr) (conj tr (first tmp))\n                   (< (last tr)(first tmp)) (conj tr (first tmp)) \n                   :else (conj [] (first tmp)))\n             (cond (and (< (count rr)(count tr))(< 1 (count tr))) tr :else rr)\n             )\n      )\n    )\n  )","user":"57750460e4b0979f8965160c"},{"code":"(fn [v] (reduce #(if (and (= (type (first %2)) java.lang.Long)\n                          (> (count %2) (count %1))\n                          (> (count %2) 1))\n                     %2\n                     %1)\n                []\n                (partition-by type\n                              (reduce (fn [m e] (if (< (last m) e)\n                                                    (concat m [e])\n                                                    (concat m [:break e])))\n                                      [(first v)]\n                                      (rest v)))))","problem":53,"user":"5069c09be4b01dc6af13f837"},{"code":"(fn [lst]\n  (loop [grouped (list (list (first lst)))  rem (rest lst)]\n    (if (empty? rem)\n      (let [two-or-more (filter #(> (count %) 1) grouped)]\n        (cond\n          (empty? two-or-more) ()\n          (= (count two-or-more) 1) (first two-or-more)\n          true \n          (reverse\n            (reduce \n              #(if (> (count %1) (count %2)) %1 %2) two-or-more))))\n      (recur\n        (if (>= (ffirst grouped) (first rem))\n          (conj grouped (list (first rem)))\n          (conj (rest grouped) (conj (first grouped) (first rem))))\n        (rest rem)))))","problem":53,"user":"4f90e238e4b0dcca54ed6c94"},{"code":"(fn longest-increasing\n  [s]\n  (let [grouped (partition-by first (map-indexed #(vector (- %2 %) %2) s))\n        biggest (fn\n                  [a b]\n                  (if (and (> (count b) (count a)) (> (count b) 1))\n                    b\n                    a))]\n    (map second (reduce biggest [] grouped))))","problem":53,"user":"511b233ae4b07ab9ec456180"},{"problem":53,"code":"(fn [l] (vec (apply range (let [[_ __ s e] (reduce #(let [res (if (vector? %1) %1 [%1 1 0 0]) nv %2] ((fn check-seq [res nv]\n                                                                                                (let [[value count resvalue rescount] res\n                                                                                                      isseq? (= (+ value count) nv)\n                                                                                                      rcount (if isseq? (inc count) 1)\n                                                                                                      ]\n                                                                                                  (if isseq?\n                                                                                                    (if (> rcount rescount)\n                                                                                                      [value rcount value rcount]\n                                                                                                      [value rcount resvalue rescount])\n                                                                                                    [nv rcount resvalue rescount]\n                                                                                                    )))\n                                                                                               res nv)) l)] (list s (+ s e))))))","user":"586e47dee4b01531a375e9a9"},{"code":"(fn [xs] (or (->>\r\n  (map vector xs (range))\r\n  (partition-by #(apply - %))\r\n  (map #(map first %))\r\n  (filter #(> (count %) 1))\r\n  (sort-by (comp - count))\r\n  first) []))","problem":53,"user":"4ebbb6bc535dfed6da9c6d71"},{"problem":53,"code":"(fn [coll]\n (loop  [\n         rst  (rest coll)\n         i    (first coll)\n         cur  [i]\n         lng  []            \n        ]\n  (if (nil? i)\n       (if (< 1 (count lng))\n           lng\n           [])\n   \n  (let [\n        cur2 (if (= (dec i) \n                    (last cur))\n                 (conj cur i)\n                 [i])\n        lng2 (if (<\n                  (count lng )\n                  (count cur2))\n                  cur2\n                  lng)\n        ]\n    (println lng i cur cur2 rst)\n    (recur\n      (rest  rst)\n      (first rst)\n      cur2\n      lng2          \n    )) \n  )  \n )\n)\n;[2 3 3 4 5])","user":"59c243bae4b0a024fb6ae4aa"},{"problem":53,"code":"#(letfn \n  [(sequence-length [x]\n    (let [len \n          (loop [x x\n                 c 0]\n           (if (or (< (count x) 2) (<= (second x) (first x)))\n             (inc c)\n             (recur (rest x) (inc c))))]\n          (if (< len 2) 0 len)))\n  (subsequences [x] (take (count x) (iterate rest x)))\n  (group-subsequences [x] (into (sorted-map-by >) (group-by sequence-length (subsequences x))))\n  (extract-seq [x] (take (ffirst x) (first (second (first x)))))\n  ]\n  (extract-seq (group-subsequences %))\n  )","user":"54227fc6e4b01498b1a71ac0"},{"problem":53,"code":"(fn sub-seqs\n  [arr]\n  (letfn [(bulder\n            ([x] (bulder x []))\n            ([x accum]\n             (loop [arr x\n                    acc [(first arr)]]\n               (if (= (inc (first arr)) (second arr))\n                 (recur (rest arr) (conj acc (second arr)))\n                 (if (not-empty (rest arr)) \n                   (bulder (rest arr) (conj accum acc))\n                   (conj accum acc))))))]\n    (let [saved (bulder arr)\n          longest (apply max (map count saved))]\n      (if (> longest 1)\n        (first (filter #(= (count %) longest) saved))\n        []))))","user":"599342efe4b0b211ea3aaab0"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n       (partition 2 1)\n       (partition-by (fn [[a b]] (= (inc a) b)))\n       (map (partial mapcat identity))\n       (filter (fn [[a b & _]] (= (inc a) b)))\n       (map #(cons (first %) %))\n       (map (partial take-nth 2))\n       (#(if (seq %)\n           (apply max-key count %)\n           []))))","user":"583e27e2e4b089d5ab817daa"},{"problem":53,"code":"(fn output [input]\n  (#(if (> (count %) 1) %\n    [])\n\n((fn [l] (first (last (sort-by second\n\n((fn process [sq]\n  (loop [s sq d [] sub ((fn subSeq [sq]\n                          (if (empty? sq) nil\n                            (loop [s (rest sq) d [(first sq)]]\n                              (if (empty? s) (conj [d] (count d))\n                              (if (<= (first s) (last d)) (conj [d] (count d))\n                                (recur (rest s) (conj d (first s)))))))) sq)]\n    (if (empty? s) (reverse d)\n      (recur (nthrest s (second sub)) (conj d sub) ((fn subSeq [sq]\n                                                       (if (empty? sq) nil\n                                                         (loop [s (rest sq) d [(first sq)]]\n                                                           (if (empty? s) (conj [d] (count d))\n                                                           (if (<= (first s) (last d)) (conj [d] (count d))\n                                                             (recur (rest s) (conj d (first s)))))))) (nthrest s (second sub)))\n      )\n    )\n  )\n  )\n     l))))) input)))","user":"558378dce4b05c286339e115"},{"problem":53,"code":"(fn [s]\n    (loop [s s, last nil, candidate [], longest []]\n      (if (seq s)\n        (cond\n          (nil? last) (recur (rest s) (first s) (conj candidate (first s)) longest)\n          (> (first s) last) (recur (rest s) (first s) (conj candidate (first s)) longest)\n          (> (count candidate) (count longest))\n          (recur (rest s) (first s) [(first s)] candidate)\n          :else\n          (recur (rest s) (first s) [(first s)] longest))\n        (let [res (if (> (count candidate) (count longest))\n                    candidate\n                    longest)]\n          (if (= (count res) 1)\n            []\n            res)))))","user":"54ca93abe4b057c6fda3a264"},{"code":";;this is an extemely bad way of solving this problem, gonna add a better solution once I learn more\n(fn find-sub-seq [coll]\n  (let [result\n    (loop [out [[-1]] in coll]\n      (if (empty? in)\n        out\n        (if (> (first in) (-> out last last))\n                (recur (concat (butlast out) [(conj (last out) (first in))]) (rest in))\n                (recur (concat out  [[(first in)]]) (rest in)))))]\n        (let [final-result (first (sort-by count > (concat [(filter #(not= -1 %) (first result))] (rest result))))]\n            \t(if (> (count final-result) 1)\n            \t\tfinal-result\n            \t\t[]))))","problem":53,"user":"52f07ccee4b05e3f0be25edf"},{"problem":53,"code":"(fn [s]\r\n  (let \r\n    [longer-seq #(if (>= (count %1) (count %2)) %1 %2)\r\n     result (apply longer-seq\r\n              (reduce\r\n                (fn [[smax scur] b]\r\n                  (if (or (empty? scur) (< (last scur) b))\r\n                    [smax (conj scur b)]\r\n                    [(longer-seq smax scur) [b]]))\r\n                [[] []]\r\n                s))]\r\n    (if (>= (count result) 2) result [])))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn [xs]\n  (:longest (reduce \n   #(if (apply < %2)\n        (let [run (if (empty? (:current %1)) %2 (concat (:current %1) (list (second %2))))]\n          (if (< (count (:longest %1)) (count run)) \n              (hash-map :longest run :current run) \n              (hash-map :longest (:longest %1) :current run)))\n        (hash-map :longest (:longest %1) :current ())) \n   (hash-map :longest () :current ()) \n   (partition 2 1 xs))))","problem":53,"user":"5142e808e4b0c172af7558c9"},{"problem":53,"code":"(fn incs [s]\n( loop [ se (next s) cursub (vector(first s)) biggstsub []]\n( if ( nil? ( first se)) biggstsub\n(let [ curs (if (=( first se) (inc (last cursub)))\n ( conj cursub (first se) ) ( vector ( first se ) ) )\nbigs (if ( and (> ( count curs) 1) ( > ( count curs) ( count biggstsub))) curs biggstsub)]\n( recur ( next se )curs bigs)) ) ) )","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":53,"code":"(fn [colls]\n (->> (reduce (fn [acc x]\n                (if (empty? acc) [[x]]\n                  (let [xs  (last acc)\n                        tail (last xs)]\n                    (if (= (inc tail) x)\n                      (conj (vec (drop-last acc)) (conj xs x))\n                      (conj acc [x])))))\n        [] colls)\n      (filter #(not= (count %) 1))\n      (sort-by #(- 0 (count %)))\n      (first)\n      (#(if (nil? %) [] %))))","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn [coll]\n    (first\n     (reduce (fn [[best cand] v]\n               (let [cand (if (or\n                               (empty? cand)\n                               (> v (first cand)))\n                            (cons v cand) [v])\n                     best (if (and (> (count cand) 1)\n                                   (> (count cand) (count best)))\n                            (reverse cand)\n                            best)]\n                 [best cand]))\n             [()] coll)))","problem":53,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn liss [coll]\n  (letfn [(increasing-partitions [xs]\n            (reduce (fn [all v]\n                      ({(-> all last last) (replace {(last all) (conj (last all) v)} all)} \n                      (dec v)\n                      (conj all [v]))) \n                    [[(first xs)]] (rest xs)))\n          (longest [xs]\n            (reduce #(if (> (count %2) (count %)) %2 %) [] xs))\n          (valid [xs]\n            (if (> (count xs) 1) xs []))]\n      ((comp valid longest increasing-partitions) coll))\n  )","problem":53,"user":"4fc93728e4b0ee37620e1844"},{"code":"(fn solution [s]\n  (let [\n        notinc? (fn [y]\n                  (or\n                    (>= (inc y) (count s))\n                    (not= (inc (s y)) (s (inc y)))\n                  )\n                )\n        maxinfix (fn [x]\n                   (loop [y x]\n                     (if (notinc? y)\n                       (- y x)\n                       (recur (inc y))\n                     )\n                   )\n                 )\n        mapi (fn [i si]\n               [i (maxinfix i)]\n             )\n        maxreduce (fn [[a b] [c d]]\n                    (cond\n                      (< b d) [c d]\n                      (< d b) [a b]\n                      (> a c) [c d]\n                      :else [a b]\n                    )\n                  )\n        [a b] (reduce maxreduce [0 0] (map-indexed mapi s))\n       ]\n    (if (zero? b)\n      []\n      (subvec s a (+ a b 1))\n    )\n  )\n)","problem":53,"user":"52b49aebe4b0c58976d9ad2b"},{"problem":53,"code":"(fn longest-sub [v]\n  (let [tmp (reduce \n              (fn [acum x] \n                (let [lastSeq (last acum)]\n                  (if (and lastSeq (= (inc (last lastSeq)) x))\n                    (assoc acum (dec (count acum)) (conj (acum (dec (count acum))) x))\n                    (conj acum [x]))))\n              [] v)]\n    (or (last (sort-by count (filter #(>= (count %) 2) tmp)))[])))","user":"60606490e4b03746e80ebf67"},{"problem":53,"code":"(fn [xs]\n  (reduce (fn [a v]\n            (let [ca (count a)\n                  cv (count v)]\n              (if (and (> cv 1) (> cv ca))\n                v\n                a))) []\n  (loop [colls [] coll [] r xs]\n    (if (empty? r)\n      (conj colls coll)\n      (let [fv (first r)]\n        (if (= fv (inc (or (last coll) Integer/MIN_VALUE)))\n          (recur colls (conj coll fv) (rest r))\n          (recur (conj colls coll) [fv] (rest r))))))))","user":"55c4cda5e4b0e31453f649a5"},{"problem":53,"code":"(fn [xs]\n  (let [m\n        (loop [x (rest xs) cr [(first xs)] mx []]\n          (if (empty? x)\n            mx\n            (let [f (first x)\n                  nw (if (> f (last cr)) (conj cr f) [f])]\n              (recur (rest x)\n                     nw\n                     (if (> (count nw) (count mx)) nw mx)))))]\n    (if (= 1 (count m)) [] m)))","user":"56824e1be4b0945ebc182a91"},{"problem":53,"code":"(fn [xs] \n  (letfn [(fr [best temp ys]  \n      (if (first ys) \n        (if (= 0 (count temp) )\n               (recur best [(first ys)] (rest ys))\n               (let [y1 (first ys) rs (rest ys) lt (last temp) tlen (count temp) blen (count best)]\n                   (if (= y1 (inc lt))\n                       (recur best (conj temp y1) rs)\n                       (if (> tlen blen) \n                             (recur temp [] ys)\n                             (recur best [] ys)\n                        )\n                    )\n                )\n        )\n        (if (> (count best) (count temp)) \n             (if (> (count best) 1)\n                 best\n            \t []\n             )\n             (if (> (count temp) 1)\n                 temp\n                 []\n             )\n          \n        )\n      )\n     )]\n      (fr [] [] xs)\n    )\n  )","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [coll]\r\n  (apply max-key count\r\n    (cons []\r\n      (filter #(> (count %) 1)\r\n        (reduce (fn [acc x]\r\n                  (if (and (first acc) (= x (inc (last (first acc)))))\r\n                    (conj (rest acc) (conj (first acc) x))\r\n                    (conj acc [x])))\r\n          ()\r\n          coll)))))","problem":53,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn [s]\n    (loop [guess [(first s)]\n           ret guess\n           xs (next s)]\n      (if xs\n        (if (= (inc (peek guess)) (first xs))\n          (recur (conj guess (first xs)) ret (next xs))\n          (if (>= (count ret) (count guess))\n            (recur [(first xs)] ret (next xs))\n            (recur [(first xs)] guess (next xs))))\n        (if (>= (count ret) 2)\n          (if (>= (count ret) (count guess))\n            ret\n            guess)\n          []))))","problem":53,"user":"4e8e8c24535d65386fec2143"},{"problem":53,"code":"#(loop [[h & t] % l [] p h c []]\n  (if (nil? h)\n    l\n    (let [nc (if (<= h p) [h] (conj c h))\n          nl (count nc)]\n      (recur t (if (and (>= nl 2) (> nl (count l))) nc l) h nc))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [coll]\n    (apply max-key count\n    (conj (filter #(>= (count %1) 2)\n            (loop [acc  (list)\n                   x    (vector (first coll))\n                   coll (rest coll)]\n              (cond (empty? coll) (conj acc x)\n                    (> (first coll) (last x)) (recur acc\n                                                     (conj x (first coll))\n                                                     (rest coll))\n                    :else (recur (conj acc x)\n                                 (vector (first coll))\n                                 (rest coll))))) [])))","problem":53,"user":"4f4a8707e4b0d56e7bb92c12"},{"code":"(fn [ns]\n  (reduce #(if (and (> (count %2) 1) (> (count %2) (count %)))\n             %2\n             %) [] (map distinct (partition-by nil? (mapcat (fn [[x y]] (if (= (inc x) y)\n                                                                          [x y]\n                                                                          [x nil])) (partition 2 1 ns))))))","problem":53,"user":"51bd1a0de4b0df1216cefd93"},{"problem":53,"code":"(fn [x] \n  (letfn [(getsubs [c]\n            (loop [c c o []]\n              (cond (empty? c) o\n                    :else (recur (rest c) (conj o c)))))]\n    (let [seqs (group-by count (map (fn [[a :as coll]] (take-while identity (map #(#{%1} %2) coll (iterate inc a)))) (getsubs x)))]\n      (if (> (apply max (keys seqs)) 1)\n        (flatten (get seqs (apply max (keys seqs))))\n        []))))","user":"57acee37e4b0b8559636fc94"},{"problem":53,"code":"(fn [xs]\n  (let [ds (map (fn [[a b]] {:d (- b a) :v a}) (partition 2 1 xs))\n        dss (filter #(= 1 (:d (first %))) (partition-by :d ds))\n        c (if (empty? dss) 0 (apply max (map count dss)))]\n    (if (= c 0) []\n      (let [x (:v (first (first (filter #(= c (count %)) dss))))]\n        (range x (+ x (inc c)))))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn sub [x] (letfn [(head [x] (cond (= (count x) 1) x :else (cond (= (first x) (dec (second x)))\n                                                                              (cons (first x) (head (rest x)))\n                                                                              :else (list (first x)))))\n                              (allhead [x] (cond (empty? x) nil :else (cons (head x) (allhead (rest x)))))]\n                   (let [sol (first (reverse (sort-by count (allhead x))))]\n                        (cond (= (count sol) 1) []\n                              :else sol))))","problem":53,"user":"528b9efee4b0239c8a67aea0"},{"code":"(fn f\n  ([xs] (if (empty? xs) \n          []\n          (let [lis (vector (first xs))]\n            (f (rest xs) lis lis))))\n  ([xs lits lis] (if (empty? xs) \n                   (if (= 1 (count lis)) [] lis)\n                   (if (> (first xs) (last lits))\n                     (let [nlits (concat lits (vector (first xs)))]\n                       (recur (rest xs) nlits (if (> (count nlits) (count lis)) nlits lis)))\n                     (recur (rest xs) (vector (first xs)) lis)))))","problem":53,"user":"52d660eae4b09f7907dd1356"},{"code":"(fn [coll]\n  (reduce (fn [a b]\n           (if (>= (count a) (count b)) a b)) [] (filter #(> (count %) 1)\n          (reductions\n            (fn [current-seq next-elem]\n              (if (> next-elem (last current-seq))\n                (conj current-seq next-elem)\n                [next-elem]))\n            [(first coll)]\n            (rest coll)))))","problem":53,"user":"52e24a16e4b09f7907dd1430"},{"problem":53,"code":"(fn [lzt]\n  (let [lists (map (fn [in]\n                     (loop [in in acc []]\n                       (if (empty? in) acc\n                         (if (empty? acc)\n                           (recur (rest in) [(first in)])\n                           (if (<= (first in) (last acc)) acc\n                             (recur (rest in) (concat acc [(first in)])))))))\n               ((fn f [xs] (if (empty? xs) nil (lazy-seq (cons xs (f (rest xs)))))) lzt))\n        m (apply max (map count lists))\n        res (some #(if (= (count %) m) %) lists)]\n                (if (= (count res) 1)\n                  []\n                  res)))","user":"5686e652e4b0dcc4269f4059"},{"problem":53,"code":"(fn [coll]\n  (let [biggest (fn [s]\n                  (reduce (fn [big x]\n                            (if (< (count big) (count x)) x big)) [] s))]\n  (->> coll\n       (iterate rest)\n       (take-while #(<= 2 (count %)))\n       (mapcat #(take-while (fn [s] (<= 2 (count s))) (iterate butlast %)))\n       (filter #(apply < %))\n       biggest\n       )))","user":"4db3a0e5535df7e46ed9b6d0"},{"problem":53,"code":"(fn [xs]\n   (->> (reduce\n         #(if (= %2 (-> %1 last last inc))\n            (concat (butlast %1) [(-> %1 last (conj %2))])\n            (concat %1 [[%2]]))\n         [[(first xs)]]\n         (rest xs))\n        sort\n        last\n        (#(if (-> % count (> 1)) % []))))","user":"4fec08e8e4b0681fd128dc9d"},{"problem":53,"code":"(fn\n               [osq]\n               (loop [lngst [] sq osq]\n                 (if (= (first sq) nil)\n                   (if (< (count lngst) 2) [] lngst)\n                   (let [cur-seq (filter #(not= nil %) (reduce #(if (= nil (last %1)) %1 (if (< (last %1) %2) (conj %1 %2) (conj %1 nil))) [(first sq)] (rest sq)))]\n                     (if (> (count cur-seq) (count lngst)) (recur cur-seq (next sq)) (recur lngst (next sq)))\n                     ))\n                 )\n               )","user":"57ff4f52e4b0d3187e9009e8"},{"code":"(fn [in]\n  (letfn [(inc-seq-iter [l s m]\n                        (let [len-s (count s)\n                              new-m (if (and (>= len-s 2) (> len-s (count m))) s m)]\n                          (cond\n                           (or (empty? l)\n                               (and (= 1 (count l)) \n                                    (empty? s))) new-m\n                           (or (empty? s) \n                               (= (+ 1 (last s))\n                                  (first l))) (inc-seq-iter (rest l) (conj s (first l)) new-m)\n                           :else (inc-seq-iter l [] new-m)))  \n                        )]\n    (inc-seq-iter in [] [])))","problem":53,"user":"517531c6e4b07031762f2eea"},{"problem":53,"code":"(fn [coll]\n  (or (->> (map vector coll (range))\n           (partition-by #(apply - %))\n           (map #(map first %))\n           (filter #(> (count %) 1))\n           (sort-by (comp - count))\n           first)\n      []))","user":"571dd145e4b0145328a76283"},{"code":"(fn [s] \n  (let [foo\n    (filter \n    #(= (inc (first %)) (last %)) \n    (first \n      (sort \n        #(> (count %) (count %2)) \n        (partition-by \n          #(- (last %) (first %))\n            (partition 2 \n              (interleave (drop-last s) (rest s))))))) ]\n    (concat (first foo) (map last (rest foo)))))","problem":53,"user":"524e6b68e4b0541d1855b7db"},{"code":"#(loop\n   [ss [] cs [] s %]\n\t(if (empty? s)\n      (if (>= (count ss) (count cs)) (if (<= 2 (count ss)) ss []) (if (<= 2 (count cs)) cs []))\n      (if (or (empty? cs) (< (last cs) (first s))) \n        (recur ss (conj cs (first s)) (rest s)) \n        (if (< (count ss) (count cs))\n          (recur cs [] s)\n          (recur ss [] s)\n          ))\n      )\n   )","problem":53,"user":"5140771ae4b076604f1aa555"},{"problem":53,"code":"(fn [xs]\n  (loop [xs xs longest [] temp []]\n    (if (empty? xs)\n      (if (and (> (count temp) 1) (> (count temp) (count longest)))\n        temp\n        longest)\n      (if (empty? temp)\n        (recur (rest xs) longest (vector (first xs)))\n        (if (> (first xs) (last temp))\n          (recur (rest xs) longest (conj temp (first xs)))\n          (if (and (> (count temp) 1) (> (count temp) (count longest)))\n            (recur (rest xs) temp (vector (first xs)))\n            (recur (rest xs) longest (vector (first xs)))))))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [col] (loop [i (first col) j (rest col) ir [] fr '()] (if (nil? i) (first (reverse (sort-by count (map #(if (< 1 (count %)) % []) fr)))) (if (= (inc i) (first j)) (recur (first j) (rest j) (vec (concat ir [i])) fr) (recur (first j) (rest j) [] (conj fr (vec (concat ir [i]))))))))","problem":53,"user":"4f0e4ebd535d0136e6c22322"},{"problem":53,"code":"(fn find-longest\n  ([col] (find-longest col () ()))\n  ([col current longest]\n   (cond (and (not (seq col)) (>= (count longest) 2))\n         (vec (reverse longest))\n\n         (not (seq col))\n         []\n\n         (empty? current)\n         (recur (rest col)\n                       (cons (first col) nil)\n                       (cons (first col) nil))\n\n         (and (> (first col) (first current))\n              (= (count current) (count longest)))\n         (recur (rest col)\n                       (cons (first col) current)\n                       (cons (first col) current))\n\n         (and (> (first col) (first current)))\n         (recur (rest col)\n                       (cons (first col) current)\n                       longest)\n\n         :else\n         (find-longest (rest col) [(first col)] longest))))","user":"5357b241e4b04ce2eb3ed282"},{"code":"(fn longest-increasing-subseq\n  [items]\n  (let [better (fn [x y] (if (> (count x) (count y)) x y))]\n    (loop [left (rest items)\n           current (list (first items))\n           best (list)]\n      (cond\n       (empty? left) (let [new-best (reverse (better current best))]\n                       (if (> (count new-best) 1)\n                         new-best\n                         (list)))\n       (= (first left) (+ 1 (first current))) (recur (rest left) (cons (first left) current) best)\n       :else (recur (rest left) (list (first left)) (better current best))))))","problem":53,"user":"511720eae4b0063b4e3e16da"},{"problem":53,"code":"(fn [x]\n  (let [f (first x)]\n    (loop [cur-left (rest x), local-best [f], global-best [f], last1 f]\n      (if (empty? cur-left)\n        (if (> (count global-best) 1) global-best [])\n        (let [cur (first cur-left), r (rest cur-left)]\n          (let [local-best1 (if (> cur last1) (conj local-best cur) [cur]),\n                global-best1 (if (> (count local-best1) (count global-best)) local-best1 global-best)]\n            (recur r local-best1 global-best1 cur)\n          )\n        )\n      )\n    )\n  )\n)","user":"55280930e4b0ffed3738f93b"},{"problem":53,"code":"#(loop [current-seq [(first %)], max-seq current-seq, xs (rest %)]\n          (let [longer (fn [a b] (if (> (count a) (count b)) a b))]\n                (if (empty? xs) \n                    (if (> (count current-seq) 1)\n                        (longer current-seq max-seq)\n                        [])\n                (let [head (first xs), tail (rest xs)]\n                    (if (> head (peek current-seq))\n                        (recur (conj current-seq head) max-seq tail)\n                        (recur [head] (longer current-seq max-seq) tail))))))","user":"556f35fee4b09a3098a5251a"},{"problem":53,"code":"(fn [coll] \n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))] \n    (concat (first c) (map last (rest c)))))","user":"5b98f7f3e4b0c0b3ffbd4ac2"},{"problem":53,"code":"(fn [col] (let [ret (vec (reverse (first (sort-by count > \n\t(reduce #(if (= (inc (first (first %1))) %2) \n\t\t\t\t\t\t(cons (cons %2 (first %1)) (rest %1))\n\t\t\t\t\t\t(cons (list %2) %1))\n\t'((0)) col)))))]\n\t\t\t\t\t\t\t(if (= (count ret) 1) '[] ret)))","user":"53858594e4b06839e8705f05"},{"problem":53,"code":"(fn [xs]\n (loop [input xs\n        result []\n        current-list []]\n   (if (empty? input)\n     (if (> (count result) 1) result [])\n     (let [x (first input)\n           y (or (second input) -1)]\n       (if (< x y)\n         (recur (rest input) result (conj current-list x))\n         (if (> (count result) (count current-list))\n           (recur (rest input) result [])\n           (recur (rest input) (conj current-list x) [])))))))","user":"546a6c7ce4b00cfc9eacc154"},{"problem":53,"code":"(fn [l]\n  (->>\n    (reduce\n    #(let [last-l (last %1)\n           last-e (last last-l)]\n      (if (or (nil? last-e) (>= last-e %2))\n        (conj %1 [%2])\n        (conj (vec (butlast %1)) (conj last-l %2))))\n    [] l)\n    (reduce #(if (< (count %1) (count %2)) %2 %1))\n    ((fn [x] (if (< 1 (count x)) x [])))))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn [ cx ]\n\t(loop [ p0 [] c0 cx ]\n\t\t(if ( empty? c0 )\n\t\t\tp0\n\t\t\t(let[[p1 c1] (\n\t\t\t\t\tloop [ lp [(first c0)] lc (rest c0) ]\n\t\t\t\t\t\t(if ( empty? lc )\n\t\t\t\t\t\t\t[(if (> (count lp) 1) lp []) []]\n\t\t\t\t\t\t\t(let [ pv (last lp) nv ( first lc ) ]\n\t\t\t\t\t\t\t\t(if (>= pv nv)\n\t\t\t\t\t\t\t\t\t[(if (> (count lp) 1) lp []) lc]\n\t\t\t\t\t\t\t\t\t(recur (conj lp nv) (rest lc) )\n\t\t\t\t\t\t\t\t))))\n\t\t\t\tpx (if (> (count p1) (count p0) ) p1 p0 ) \n\t\t\t\t]\n\t\t\t\t( if ( empty? c1 )\n\t\t\t\t\tpx\n\t\t\t\t\t(recur px c1)\n\t\t\t\t)))))","problem":53,"user":"50d606dae4b0159555a1fc6a"},{"problem":53,"code":"(fn longest [coll]\n  (->> \n    (reduce\n      (fn [acc curr]\n      (let [previous (-> acc last last)\n            ascending (and (not (nil? previous)) (> curr previous))]\n        (if ascending\n          (conj (vec (butlast acc)) (conj (last acc) curr))\n          (conj acc [curr]))))\n      []\n      coll)\n    (filter #(> (count %) 1))\n    (reduce #(if (>= (count %1) (count %2)) %1 %2) [])))","user":"5a082ce4e4b01bb0ae8afdec"},{"problem":53,"code":"(fn [[x & xs]]\n  (->> xs\n       (reduce (fn [[finished-subs sub] item]\n                 (if (> item (last sub))\n                   [finished-subs (conj sub item)]\n                   [(conj finished-subs sub) [item]]))\n               [[] [x]])\n       (apply conj)\n       (filter #(> (count %) 1))\n       (cons [])\n       reverse ; max-key prefers later values in the list in the event of equality\n       (apply max-key count)))","user":"59ee6801e4b0966464fe6a1f"},{"problem":53,"code":"(fn [nums]\n  (let [groups\n       (reductions\n        = \n        true\n        (map < nums (rest nums)))\n       seq-pairs (partition-by\n                  second\n                  (map list nums groups))\n       seqs (map\n             (partial map first)\n             seq-pairs)\n       longest (reduce #(let [x (count %1)\n                              y (count %2)]\n                          (if (> y x)\n                            %2\n                            %1))\n                       seqs)]\n    (if (> (count longest) 1)\n      longest\n      [])))","user":"4f037faf535dcb61093f6af8"},{"code":"(fn [ts]\n  (let [ret (apply max-key count (reduce (fn [[cur max] e] (if (or (empty? cur) (< (last cur) e)) [(conj cur e) max] [[e] (if (> (count cur) (count max)) cur max)])) [[] []] ts))]\n  (if (> (count ret) 1) ret [])))","problem":53,"user":"4effb663535dcb61093f6a2e"},{"problem":53,"code":"(fn [seq]\n   (->>\n     (reduce (fn [acc val] (if (>= (last acc) val) (conj acc \"|\" val) (conj acc val))) [(first seq)] (drop 1 seq))\n     (partition-by class)\n     (reduce (fn [acc val] (if (and (> (count val) 1) (> (count val) (count acc))) val acc)) [])))","user":"5d6d2172e4b04d129b00f2b9"},{"code":"(fn [x] (apply max-key count\n               (rseq (vec (cons []\n                 (filter #(apply < %)\n                   (for [i (range (count x))\n                         j (range (+ i 2) (+ 1 (count x)))]\n                     (subvec x i j))))))))","problem":53,"user":"4ee1f2ba535d10e5ff6f535f"},{"problem":53,"code":"(fn [s]\n  (loop [current []\n         longest []\n         input s]\n    (if (empty? input)\n      (if (< (count longest) 2)\n             []\n             longest)\n        (let [new-current (if (or (empty? current)\n                                  (> (first input) (last current)))\n                            (conj current (first input))\n                            [(first input)])\n              new-longest (if (> (count new-current) (count longest))\n                            new-current\n                            longest)]\n          (recur new-current\n                 new-longest\n                 (rest input))))))","user":"51db0d99e4b06aa4d4669a9d"},{"code":"(fn [v] (let [s (partition-by (fn [[x y]] (< x y))\n                              (map (fn [x y] [x y]) (butlast v) (rest v)))\n              r (filter (fn [[[x y]]] (< x y)) s)\n              m (apply max 0 (map count r))\n              f (first (filter #(= m (count %)) r))]\n          (vec (distinct (flatten f)))))","problem":53,"user":"4efd8b67535de96065cf5085"},{"code":"(fn longest-inc [s]\n  (when (seq s)\n    (loop [i 1 curr [(s 0)] longest [(s 0)]]\n      (if (>= i (count s))\n        (if (> (count longest) 1)\n          longest\n          []\n          )\n        (let [increasing? (> (s i) (last curr))\n              ncurr (if increasing? \n                      (conj curr (s i))\n                      [(s i)]\n                      )\n              nlongest (if (and increasing? (> (count ncurr) (count longest)))\n                          ncurr\n                          longest\n                         )\n              ]\n            (println curr)\n            (recur (inc i) ncurr nlongest)\n          )\n        )\n      )\n    )\n  )","problem":53,"user":"529a73bde4b02ebb4ef75096"},{"problem":53,"code":"(fn blah [x] \n  (if (< 1 (count (last (sort-by count (reductions #(if (= %2 (+ 1 (last %1))) (conj %1 %2) [%2]) [(first x)] (rest x)))))) \n                        (last (sort-by count (reductions #(if (= %2 (+ 1 (last %1))) (conj %1 %2) [%2]) [(first x)] (rest x)))) \n                        []))","user":"535f9a5ce4b04ce2eb3ed2de"},{"problem":53,"code":"(fn [coll]\n  (loop [current []\n         result []\n         coll-init coll]\n    (if (empty? coll-init)\n      (if (= (count result) 1) [] result)\n      (if (> (first coll-init) (or (last current) -1))\n        (recur (conj current (first coll-init))\n               (if (> (inc (count current)) (count result))\n                 (conj current (first coll-init))\n                 result)\n               (rest coll-init))\n        (recur [(first coll-init)]\n               result\n               (rest coll-init))))))","user":"5a7de7a3e4b03baeef927702"},{"code":"#(loop [r [] rs 0 l %] (let [[h s t] (loop [h [(first l)] s 1 t (next l)] (if (or (nil? t) (<= (first t) (first h))) [(reverse h) s t] (recur (cons (first t) h) (inc s) (next t))))] (let [[nr ns] (if (and (> s rs) (> s 1)) [h s] [r rs])] (if (nil? t) nr (recur nr ns t)))))","problem":53,"user":"4f0769e9535dcb61093f6c27"},{"problem":53,"code":"(fn longestSub [x] (reduce #(if (= 1 (count %2)) %1 (if (> (count %1) (count %2)) %1 %2)) '() (loop [result [] currentSeq [(first x)]toDo (rest x)] (if (empty? toDo)\n                                                              (conj result currentSeq)\n                                                               (if (= (first toDo) (inc (last currentSeq)))\n                                                                 (recur result (conj currentSeq (first toDo)) (rest toDo))\n                                                                 (recur (conj result currentSeq) [(first toDo)] (rest toDo)))))))","user":"56427910e4b08d4f616f5f19"},{"problem":53,"code":"(fn [[f & r :as l]]\n  (reduce (fn [a c] (if (> (count c) (count a)) c a)) []\n          (filter #(> (count %) 1)\n                  (reduce (fn [a [p n]] (if (> n p)\n                                          (assoc a (count a) (conj (last a) n))\n                                          (conj a [n])))\n                          [[f]]\n                          (map vector l r)))))","user":"502940a9e4b061fd216be4b8"},{"problem":53,"code":"(fn [c]\n  (let [res (->> c\n             (partition 2 1)\n             (partition-by #(= -1 (apply - %)))\n             (filter #(= -1 (apply - (first %)))))]\n             \n    (if (empty? res)\n     []\n     (->> res (apply max-key count) flatten distinct))))","user":"56e2dbf4e4b03a7c14b85a3b"},{"code":"#(vec \n   (last \n     (filter \n       second \n       (sort-by \n         count \n         (reduce (fn [[c & m] v]\n                   (if (or (empty? c) (= (peek c) (dec v)))\n                     (concat [(conj c v)] m)\n                     (concat [[v]] [c] m))) [[]] %)))))","problem":53,"user":"4efb2fd7535dced4c769f274"},{"problem":53,"code":"(fn clj53 [xs]\n  (->> xs\n    (partition 2 1)\n    (partition-by #(apply < %))\n    (filter #(apply < (first %)))\n    (map (comp distinct flatten))\n    reverse\n    (#(if (seq %) (apply max-key count %) []))))","user":"59d8f23ae4b0ef0a1e9b5c49"},{"problem":53,"code":"(fn [col] \n  (let [recursor \n        (fn recurs [prev curr col] \n            (let \n              [\n               nextelem (first col), prevelem (last curr),\n               biggest (if \n              (> (count curr) (count prev)) \n              curr \n              prev\n              ) \n               ] \n          (if \n            (empty? col)\n            (if (> 2 (count biggest)) [] biggest)\n              (if \n                (> nextelem prevelem) \n                (recurs prev (conj curr nextelem) (rest col))\n                (recurs biggest (vector nextelem) (rest col))\n                )\n              )\n            )\n          )\n        ] \n    (recursor [] (vector (first col)) (rest col))\n    )\n  )","user":"58950f29e4b00487982d5270"},{"code":"(fn [a]\n  (loop [prev nil, n (first a), s a, best nil, curr nil]\n    (if\n      (empty? s)\n      (if (> (count curr) (count best)) (vec curr) (vec best))\n      (recur (first s) (second s) (rest s)\n        (if (> (count curr) (count best)) curr best)\n        (if\n          (and (not (nil? prev)) (> n prev))\n          (if\n            (nil? curr)\n            (list prev n)\n            (concat curr (list n)))\n          nil)))))","problem":53,"user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn  [xs]\n                 (let [xs1 (reductions (fn [{:keys [prev]} b]\n                                          {:result (= (- b prev) 1)\n                                                   :prev b})\n                                       {:prev (first xs)}\n                                       (rest xs))\n                           [xs2 & _] (sort-by (comp - count)\n                                              (filter #((complement nil?) (first %))\n                                                      (partition-by nil?\n                                                                    (map-indexed (fn [i {:keys [result]}]\n                                                                                    (when result\n                                                                                      i))\n                                                                                 xs1))))]\n                   (if (seq xs2)\n                       (subvec xs\n                               (dec (first xs2))\n                               (inc (last xs2)))\n                     [])))","problem":53,"user":"4db58ccb535d87e67b28fe10"},{"code":"(fn [x]\n  (into [] (first\n     (sort\n      #(- (count %2) (count %1))\n      (filter\n       #(apply < %)\n       (for [a (range (count x)) b (range 2 (- (count x) a -1))] (take b (drop a x))))))))","problem":53,"user":"4ea365e2535d7eef308072c5"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n    (#(take-while identity (iterate next %))) ;; \"rest\" of coll at each step\n    (map (fn [[c & cs]]\n           (loop [[x & xs] cs acc [c] z c]\n             (if (= (inc z) x) (recur xs (conj acc x) x) acc))))\n    (filter #(< 1 (count %)))\n    (reduce #(if (< (count %2) (count %)) % %2) [])))","user":"54485727e4b032a45b8693c6"},{"code":"#(reverse\n  (first\n  (let [ subs \n        (reduce\n          (fn [n m]\n            (if (> m (first (first n)))\n                (conj (rest n) (conj (first n) m))\n                (conj n (list m))\n            )\n          )\n          (list (list (first %)))\n          (rest %)\n        )\n      ]\n  (reduce\n    (fn [n m] \n      (if (> (count m) 1)\n          (if (> (count (first n)) (count m))\n              n\n              (conj (rest n) m)              \n          )\n          n\n      )\n    )\n    '()\n    subs\n  )\n)))","problem":53,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":53,"code":"(fn [s]\n   (apply max-key count []\n          (->> s\n               (iterate next)\n               (take-while seq)\n               (keep (fn [s]\n                       (if-let [x (seq (map second\n                            (take-while (fn [[a b]] (< a b))\n                                        (map vector s (next s))\n                                        )))]\n                         (cons (first s) x)\n                         )\n                    ))\n               reverse)))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn [orig]\n(reduce (fn [nl nx]\n    (if (< (count nx) 2)\n        nl\n        (if (<= (count nx) (count nl)) nl nx)))\n    []\n(partition-by #(= % \"/\")\n(reduce (fn [l x]\n    (if (empty? l)\n        [x]\n        (if (< (last l) x)\n            (conj l x)\n            (conj l \"/\" x))))\n    []\n    orig\n))))","problem":53,"user":"51059d33e4b0380e797c7d5c"},{"problem":53,"code":"(fn [coll]\n   (reverse (get (reduce (fn build [{curr :curr, longest :longest} val] \n  (if (empty? curr) \n    {:curr (list val) :longest longest} ;; start new sequence\n    (if (> val (first curr))\n      (if (>= (count curr) (count longest)) ;; add to current sequence\n        {:curr (cons val curr) :longest (cons val curr)}     ;; new longest \n        {:curr (cons val curr) :longest longest}  ;; longest unchanged \n        ) \n      {:curr (list val) :longest longest} ;; start new sequence\n      ) \n    )\n  )\n {:curr `() :longest `()} coll) :longest)))","user":"55ec4558e4b0121d4835fdc5"},{"code":"(fn longest-subseq [coll]\r\n  (letfn [(splt [coll]\r\n            (reduce (fn [acc nxt]\r\n                      (if (< (first (first acc))\r\n                             nxt)\r\n                        (conj (rest acc) (conj (first acc) nxt))\r\n                        (conj acc (list nxt))))\r\n                    (list (list (first coll)))\r\n                    (rest coll)))]\r\n    (let [ans (reduce (fn [x y]\r\n                    (if (> (count x) (count y))\r\n                      x y)) (splt coll))]\r\n      (if (> (count ans) 1)\r\n        (reverse ans)\r\n        '()))))","problem":53,"user":"4e7e4a1f535db169f9c7970c"},{"problem":53,"code":"(fn [coll] \n (last (sort (filter\n  (fn [c] (or \n   (>= (count c) 2)\n   (= c [])))\n\n(reduce \n #(let \n   [last-n \n    (->> %1 last last)]\n   (if (and \n     (not (nil? last-n))\n     (= %2 (inc last-n)))\n    ; not nil and inc'd\n    (conj %1 \n      (conj (last %1) %2))\n    ; else nil or not inc'd\n    (conj %1 [%2]))\n   )     \n [[]] coll)))))","user":"510608ebe4b01150e115ebe3"},{"code":"(fn [col]\n  ((fn [l] (concat (first l) (map second (rest l))))\n    (last\n      (first \n        (sort\n          (map (fn [i l] [(- (count l)) i l])\n            (range)\n            (keep (fn [l] (when (apply < (first l)) l))\n              (partition-by (partial apply <)\n                (partition 2 1 col)))))))))","problem":53,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"#(loop [b [] c [(first %)] l (first %) r (rest %)]\r\n           (if (seq r)\r\n               (if (< l (first r))\r\n                   (recur b (conj c (first r)) (first r) (rest r))\r\n                   (recur (if (> (count c) (count b)) c b) [(first r)] (first r) (rest r)))\r\n               (let [b (if (> (count c) (count b)) c b)]\r\n                    (if (> (count b) 1) b []\r\n                        ))))","problem":53,"user":"4f043ed1535dcb61093f6bb4"},{"code":"(fn [x]\n  (let [last (atom -1)\n        increasing (fn [n] (if (> n @last)\n                             (do (swap! last (constantly n)) true)\n                             (do (swap! last (constantly -1)) false)))\n        incsubs (filter #(< 1 (count %)) (partition-by increasing x))]\n    (reduce #(if (> (count %2) (count %1)) %2 %1) [] incsubs)))","problem":53,"user":"51e00020e4b01188f0627534"},{"code":"(fn [c]\n  (map\n    #(val %)\n    (first\n      (sort-by count #(compare %2 %1)\n        (filter #(> (count %) 1)       \n          (partition-by\n            #(key %)\n            (mapcat \n              #(hash-map %2 %1)\n              c\n              (map + c (iterate dec 1)) \n            )\n          )\n        )\n      )\n    )\n  )\n)","problem":53,"user":"52f1bc81e4b05e3f0be25eef"},{"code":"(letfn [(better? [a b]\r\n           (and (> (count a) 1) (> (count a) (count b))))\r\n         (foo [[cur best] it]\r\n           (if (or (empty? cur) (> it (last cur)))\r\n             [(conj cur it) best]\r\n             (if (better? cur best)\r\n               [[it] cur]\r\n               [[it] best])))]\r\n   #(let [[c b] (reduce foo [[] []] %)]\r\n      (if (better? c b) c b)))","problem":53,"user":"4fe900a6e4b0547ebccb243a"},{"problem":53,"code":"(fn [coll]\n   (let [step (fn in-step [curr best remainder]\n                (if (seq remainder)\n                  (let [new-curr (if (seq curr)\n                                   (if (= (first remainder) (inc (last curr)))\n                                     (conj curr (first remainder))\n                                     [(first remainder)])\n                                   [(first remainder)])\n                        new-best (if (> (count new-curr) (count best))\n                                   new-curr\n                                   best)]\n                    (in-step new-curr new-best (rest remainder)))\n                  best))\n         longest (step [] [] coll)]\n     (if (> (count longest) 1)\n       longest\n       []))\n   )","user":"53ed6976e4b0d648e757f4c4"},{"code":"(fn [[x & xs :as lst]]\n   (letfn\n       ((iter [[x & xs :as lst]\n               [[y & ys :as curr] curr-cnt]\n               [acc acc-cnt]]\n          (if (seq lst)\n            (if (> x y)\n              (let [z [(cons x curr) (inc curr-cnt)]] \n                (if (>= curr-cnt acc-cnt)\n                  (recur xs z z)\n                  (recur xs z [acc acc-cnt])))\n              (recur xs [[x] 1] [acc acc-cnt]))\n            acc)))\n     (if (seq lst)\n       (reverse (iter xs [[x] 1] [[] 1]))\n       '())))","problem":53,"user":"51131da8e4b0350614f07a83"},{"problem":53,"code":"(fn [c]\n  (let [[partitioned _] (reduce (fn [[acc last-seen] e]\n                              (if (< last-seen e)\n                                [(conj (vec (butlast acc)) (conj (vec (last acc)) e)) e]\n                                [(conj acc [e]) e]))\n                            [[] 0]\n                            c)\n        cand (first (sort-by (comp - count) partitioned))]\n    (if (seq (rest cand))\n      cand\n      [])\n    ))","user":"52173464e4b082aa80a88c75"},{"problem":53,"code":"(fn \n  [coll]\n  (let [pair-seq\n    (reduce\n      (fn [longest sseq]\n        (if (> (count sseq) (count longest))\n          sseq\n          longest))\n      []\n      (filter\n        #(< (first (first %)) (second (last %)))\n        (partition-by #(< (first %) (second %)) (partition 2 1 coll))))]\n    (concat (first pair-seq) (map second (rest pair-seq)))))","user":"548db64ce4b0e286459a121c"},{"problem":53,"code":"#(let [[longest current] (reduce (fn [[l c] x]\n           (if (or (empty? c) (>= (peek c) x))\n             (if (< (count l) (count c))\n               [c [x]]\n               [l [x]])\n             [l (conj c x)])\n          ) [[] []] %)]\n   (if (> (count current) (count longest) 1)\n     current\n     (if (> (count longest) 1)\n       longest\n       []\n       )))","user":"54dae16de4b024c67c0cf758"},{"code":"(fn [x]\n  (loop [sub-seqs (reduce #(if (= 1 (- %2 (last (last %1))))\n                             (conj (vec (butlast %1)) (conj (vec (last %1)) %2))\n                             (conj %1 [%2]))\n                          [[(first x)]] (rest x))\n         result []]\n    (if (empty? sub-seqs)\n      (if (> (count result) 1) result [])\n      (if (> (count (first sub-seqs)) (count result))\n        (recur (rest sub-seqs) (first sub-seqs))\n        (recur (rest sub-seqs) result)))))","problem":53,"user":"52a32b52e4b04e0c58e87bfc"},{"code":"(fn longest-sub-seq [s]\n  (letfn [(take-while-> [s]\n            (cons (first s)\n                  (when (seq (rest s))\n                    (when (> (second s) (first s))\n                      (take-while-> (rest s))))))]\n    (let [r (reduce #(if (>= (count %) (count %2)) % %2)\n                    (map take-while->\n                         (take (count s) (iterate rest s))))]\n      (if (>= (count r) 2) r []))))","problem":53,"user":"4ff304f4e4b0678c553fc343"},{"problem":53,"code":";; https://gist.github.com/hyone/1032985\n(fn [coll] \n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))] \n   (concat (first c) (map last (rest c)))))","user":"56df9203e4b0ca2494a095fc"},{"code":"; my code is bad.  and i should feel bad\r\n#((fn f [subvec s contender]\r\n  (let [curr (peek subvec)\r\n        end (rest s)\r\n        next (first end)]\r\n    (if (empty? end)\r\n      (if (and (> (count subvec) 1)\r\n               (> (count subvec) (count contender)))\r\n        subvec\r\n        contender)\r\n      (if (= (inc curr) next)\r\n        ; continue\r\n        (f (conj subvec next) end contender)\r\n        ; run is over\r\n        (if (and (> (count subvec) 1)\r\n                 (> (count subvec) (count contender)))\r\n          (f [(first end)] end subvec)\r\n          (f [(first end)] end contender))))))\r\n  [(first %)] (seq %) [])","problem":53,"user":"50464831e4b011c5dfee771f"},{"code":"(fn longest-conseq-inc [seq]\n  ;;{:curr-conseq [] :best-so-far []}\n  (letfn [(find-conseq [m, num]\n                       (let [curr-conseq (:curr-conseq m)\n                             best-so-far (:best-so-far m)\n                             conseq? (if (empty? curr-conseq)\n                                       true\n                                       (= (inc (last curr-conseq))\n                                          num))\n                             new-curr-conseq (if conseq?\n                                               (conj curr-conseq num)\n                                               [num])\n                             new-best-so-far (if (> (count new-curr-conseq)\n                                                    (count best-so-far))\n                                               new-curr-conseq\n                                               best-so-far)]\n                         {:best-so-far new-best-so-far\n                          :curr-conseq new-curr-conseq}))]\n\n    (let [best (:best-so-far (reduce find-conseq\n                                     {:curr-conseq [], :best-so-far []}\n                                     seq\n                                     ))]\n      (if (> (count best) 1)\n        best\n        []\n        )\n      ))\n  )","problem":53,"user":"4fb26802e4b081705acca28d"},{"problem":53,"code":"(fn sub[s]\n  (let [subb (fn [s curs maxs]\n             (let [x (first s)\n                    r (rest s)\n                    ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\n                    nmax (max-key count ncurs maxs)]\n                 (if (seq r)\n                    (recur r ncurs nmax)\n                     nmax)))\n        longest (subb s [(first s)] [])]\n    (if (> (count longest) 1) longest [])))","user":"52a4879ce4b0c58976d9abdb"},{"code":"(fn longestincreasing [x]\n     ((fn longestsub [y]\n       (loop [counter 0, result []]\n          (if (< counter (count y))\n            (if (> (count (get (vec y) counter)) (max (count result) 1))\n              (recur (inc counter) (get (vec y) counter))\n              (recur (inc counter) result))\n            result)))\n      (loop [counter (- (count x) 1), q (vec (map vector x))]\n                      (if (pos? counter)\n                        (if (> (first (get q counter)) (peek (get q (- counter 1))))\n                          (recur (dec counter) (assoc \n                                                 (vec (concat (take counter q) (drop (inc counter) q)))\n                                                 (- counter 1) \n                                                      (vec (concat (get q (- counter 1)) (get q counter)))))\n                          (recur (dec counter) q))\n                          q))\n  ))","problem":53,"user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn [input] \n  (apply max-key count [] \n    (filter #(> (count %) 1)\n      (loop [s (rest input) buffer [(first input)] out []]\n          (if (seq s)\n            (if (= (first s) (inc (last buffer)))\n                (recur (rest s) (conj buffer (first s)) out)\n                (recur (rest s) [(first s)] (conj out buffer)))\n            (conj out buffer))))))","problem":53,"user":"4f608f0ee4b0defedf855faa"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n       (partition-by #(- (second %) (first %)))\n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n       flatten\n       distinct\n       )\n  )","problem":53,"user":"513fb358e4b00f13ea1bd893"},{"code":"(fn [s]\n  (reduce\n   (fn [longest seq]\n     (if (< (count longest) (count seq))\n       seq\n       longest))\n   []\n   (filter #(apply < %)\n           (mapcat\n            #(partition % 1 s)\n            (range 2 (inc (count s)))))))","problem":53,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":53,"code":"(let [better (fn [old new] (if (< (count old) (count new)) new old))]\n  (comp #(if (empty? (rest %)) [] %) (fn [l] ((fn [l best acc]\n                   (cond\n                    (empty? l) (better best acc)\n                    (or (empty? acc) (> (first l) (last acc)))\n                    (recur (rest l) best (conj acc (first l)))\n                    true (recur (rest l) (better best acc) [(first l)])\n                    )) l [] []))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn [x]\n  (letfn [(increasing-seq [[f s & t :as c]]\n  \t\t  (if (seq c)\n\t\t\t    (if (seq? f)\n\t\t\t      (if (= (inc (last f)) s)\n\t\t\t\t(increasing-seq (cons (concat f (list s)) t))\n\t\t\t\t(cons f (increasing-seq (rest c))))\n\t\t\t      (if (= (inc f) s)\n\t\t\t\t(increasing-seq (cons (list f s) t))\n\t\t\t\t(increasing-seq (rest c))))))]\n    (let [li (last (sort-by count (increasing-seq x)))]\n      (if (seq li) li []))))","problem":53,"user":"4ee9d697535d93acb0a66895"},{"code":"(fn lis [coll]\n  (letfn\n      [(helper [a]\n               (loop [k 0 q (vec (repeat (count a) nil)) P (vec (repeat (count a) nil))]\n                 (if (= k (count a))\n                   [q P]\n                   (let [m (loop [j 0 result 0 max-idx nil]\n                             (if (= j k)\n                               [result max-idx]\n                               (if (> (a k) (a j))\n                                 (if (> (q j) result)\n                                   (recur (inc j) (q j) j)\n                                   (recur (inc j) 1 j))\n                                 (if (= (a k) (a j))\n                                   (recur (inc j) 0 nil)\n                                   (recur (inc j) result max-idx)))))]\n        \t     (recur (inc k) (assoc q k (inc (first m))) (assoc P k (second m)))))))]\n    (let [result (helper coll)\n          L (first result)\n          P (second result)\n          idx (.indexOf L (apply max L))]\n      (if (= (P idx) nil)\n        []\n        (loop [idx idx result []]\n          (cond (= (P idx) nil)\t(cons (coll idx) result)\n          \t:else (recur (P idx) (cons (coll idx) result))))))))","problem":53,"user":"4f036d9b535dcb61093f6ac1"},{"problem":53,"code":"(fn [source]\n\t(loop [src source prog [(first source)] lincr [(first source)]] \n\t\t(if (= 0 (count src))\n\t\t\t(if (> (count prog) (count lincr))\n\t\t\t\tprog\n\t\t\t\t(if (= 1 (count lincr))\n\t\t\t\t\t[]\n\t\t\t\t\tlincr))\n\t\t\t(if (> (first src) (last prog))\n\t\t\t\t(recur (rest src) (conj prog (first src)) lincr)\n\t\t\t\t(if (> (count prog) (count lincr))\n\t\t\t\t\t(recur (rest src) (conj [] (first src)) prog)\n\t\t\t\t\t(recur (rest src) (conj [] (first src)) lincr)))\n\t\t\t)))","user":"58b985e0e4b0888cdc949ccc"},{"problem":53,"code":"(fn [c] (->> (apply map (comp pos? -) [(rest c) (butlast c)])\n             (map-indexed vector)\n             (partition-by last)\n             (filter #(last (last %)))\n             (#(if (empty? %) [] (->> ((partial sort-by count >) %)\n                                      first\n                                      (map first)\n                                      ((juxt vec (comp inc last)))\n                                      (apply conj)\n                                      (replace c))))))","user":"56f974c0e4b07572ad1a88b1"},{"problem":53,"code":"(fn lis [coll]\n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))]\n    (concat (first c) (map last (rest c)))))","user":"58b18ba0e4b0ebc645576cfa"},{"code":"(fn [c] (distinct (flatten (reduce #(if (< (count %1) (count %2)) %2 %1) [] (filter #(= 1 (apply - (reverse (first %)))) (partition-by #(apply - (reverse %)) (partition 2 1 c)))))))","problem":53,"user":"4f0f01c0535d0136e6c22329"},{"code":"#(let [s (reduce (fn [x y]\n                   (let [z (peek x)]\n                     (if (and z (> y (peek z)))\n                       (conj (pop x) (conj z y))\n                       (conj x [y]))))\n                   [] %)\n       l (apply max-key count (rseq s))]\n   (if (> (count l) 1)\n     l\n     []))","problem":53,"user":"4e8d5911535d65386fec2133"},{"problem":53,"code":"#(letfn [(lip [s]\n           (loop [l 1]\n\t\t     (if (< (count s) l)\n               s\n       \t       (if (apply < (take l s))\n      \t\t     (recur (inc l))\n                 (take (dec l) s)))))\n         (lips [s]\n           (loop [s s ls []]\n             (if (empty? s)\n               ls\n               (let [l (lip s)]\n                 (recur (drop (count l) s)\n                        (conj ls l))))))]\n  (let [res (reduce (fn [a b] (if (> (count b) (count a))\n                                  b a))\n                    (lips %))]\n    (if (< (count res) 2) [] res)))","user":"5400fc30e4b0de5c4184861b"},{"problem":53,"code":"(fn [coll]\n(map first\n(last(first\n    (filter (comp (partial < 1) count val)\n    (sort-by (comp (partial * -1) count val)\n        (group-by #(last %)\n            (reduce\n                (fn [aggr x] \n                    (if (empty? aggr) [[x 0]]\n                        (let [a (last aggr)] (if (< (first a) x) (conj aggr [x (last a)]) (conj aggr [x (inc(last a))])))\n                    )\n                ) [] coll\n            )\n        )\n    )\n)))))","user":"580c8fcee4b0849f6811b721"},{"problem":53,"code":"(fn [coll]\n  (->> (count coll)\n       inc\n       (range 2)\n       reverse\n       (mapcat #(partition % 1 coll))\n       (filter (fn [s] (and (= s (-> s sort)) (= s (distinct s)))))\n       (reduce (fn [agg v] (if (> (count v) (count agg)) v agg)) [])))","user":"5f431d32e4b0955706451fb5"},{"problem":53,"code":"(fn [s]\n  (let [xs (->> (reductions (fn [coll x]\n                              (cond\n                                (empty? coll) [x]\n                                (= (inc (last coll)) x) (conj coll x)\n                                :else [x])) [] s)\n                (filter #(> (count %) 1)))]\n    (if (seq xs)\n      (apply max-key count xs)\n      [])))","user":"5cee521ce4b0aaa82f1129dd"},{"code":"(fn [xs] \n  (let [f (fn [r v] (let [f (first r)] (if-let [ff (first f)] (if (< ff v) (cons (cons v f) (rest r)) (cons [v] r)) (cons [v] (rest r)))))]\n    (->> xs (reduce f [[]]) (sort-by count) (reverse) (filter #(<= 2 (count %))) first reverse)))","problem":53,"user":"518a93c3e4b0df82f5685904"},{"problem":53,"code":"(fn [[x & xs]]\n  (->> xs\n       (reduce\n         (fn [[best current] x]\n           (if (> x (first current))\n             (let [current' (cons x current)\n                   best' (if (> (count current') (count best)) current' best)]\n               [best' current'])\n             [best [x]]))\n         [[x] [x]])\n       (#(if (< (count (first %)) 2) [] (first %)))\n       (reverse)))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [col]\n  (loop [max '() possmax '() tail col]\n    (cond\n     (nil? (seq tail))\n     (if (> (count possmax) (count max))\n       (reverse possmax)\n       (if (> (count max) 1)\n         (reverse max)\n         []))\n\n     (or (nil? (seq possmax))\n                (= (inc (first possmax)) (first tail)))\n     (recur (if (> (count possmax) (count max))\n              possmax max)\n            (conj possmax (first tail))\n            (rest tail))\n\n     :else (recur (if (> (count possmax) (count max))\n                    possmax max)\n                  (list (first tail)) (rest tail)))))","problem":53,"user":"4ff9a200e4b0678c553fc3ab"},{"problem":53,"code":"(fn [v]\n  (let [n (count v)]\n    (loop [currentStart 0, currentEnd 0, bestStart 0, bestEnd 0]\n      ;(print (str (subvec v bestStart bestEnd) \"\\n\"))\n      ;(print (str \"currentStart \" currentStart \", currentEnd \" currentEnd \", bestStart \" bestStart \", bestEnd\" bestEnd \"\\n\"))\n      (cond\n        (> (- currentEnd currentStart) (- bestEnd bestStart)) (recur currentStart currentEnd currentStart currentEnd),\n        (= n currentEnd) (if (> (- bestEnd bestStart) 1) (subvec v bestStart bestEnd) []),\n        (or (= currentEnd currentStart) (= (dec (nth v currentEnd)) (nth v (dec currentEnd)))) (recur currentStart (inc currentEnd) bestStart bestEnd),\n        :else (recur currentEnd (inc currentEnd) bestStart bestEnd)))))","user":"4e268c6e535deb9a81d77ef4"},{"code":"(fn [s]\r\n  (let [s (reduce #(if (> (count %) (count %2)) % %2)\r\n            (reverse (partition-by\r\n              #(if (false? %) false true)\r\n                (reduce concat\r\n                  (map\r\n                    #(if (< %1 %2) \r\n                      (list %1)\r\n                      (list %1 false)) \r\n                   s (concat (rest s) (list (last s))))))))]\r\n  (if (= 1 (count s))\r\n    '()\r\n    s)))","problem":53,"user":"4f8aa1c1e4b02e764a0a516e"},{"problem":53,"code":"(fn [s]\n  (loop [s s\n         final-s (vector (first s))\n         mid-s []]\n    (if (empty? s)\n      (if (>= (count final-s) (count mid-s))\n        (if (= 1 (count final-s))\n          []\n          final-s)\n          mid-s)\n      (if (= (last final-s) (dec (first s)))\n        (recur (rest s) (conj final-s (first s)) mid-s)\n        (recur (rest s) (vector (first s)) (if (> (count final-s) (count mid-s))\n                             final-s\n                             mid-s))))))","user":"56b18445e4b0982f16b37dee"},{"code":"(fn [xs]\n   (reduce\n     #(if (and (< 1 (count %2)) (> (count %2) (count %))) %2 %)\n     []\n     (reductions\n       #(if (or (empty? %) (> %2 (peek %))) (conj % %2) [%2])\n       [] xs)))","problem":53,"user":"50f48298e4b004d364930527"},{"code":"(fn max-subseq\r\n  [s]\r\n  (let [f (fn mx-ss\r\n            ([s] (mx-ss s [] [] -1))\r\n            ([s max cur x]\r\n             (if (empty? s)\r\n               (let [acc (if (empty? max) cur max)]\r\n                 (if (> (count acc) 1) acc []))\r\n               (let [[a & s] s]\r\n                 (if (> a x)\r\n                   (recur s max (conj cur a) a)\r\n                   (if (> (count cur) (count max))\r\n                     (recur s cur [a] a)\r\n                     (recur s max [a] a)))))))]\r\n    (first (sort-by count > (map f (take (count s) (iterate rest s)))))))","problem":53,"user":"500159b3e4b0678c553fc419"},{"problem":53,"code":"(fn [w] \n        (let [aux\n              (fn [[head & tail] last-seen curr res]\n                (cond\n                 (nil? head)\n                 (let [tmp (if (<= \n                                (count curr)\n                                (count res))\n                             res\n                             curr)]\n                   (if (< 1 (count tmp))\n                     tmp\n                     []))\n                 \n                 (< last-seen head)\n                 (recur tail head (conj curr head) res)\n\n                 :else\n                 (recur tail head [head] (if (< (count res)\n                                                (count curr))\n                                           curr\n                                           res))))]\n          (aux w -1 [] [])))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":53,"code":"(fn q53 [s]\n  (let [inc-sub-seq (fn [[head & tail] prev-val last-seg result]\n                       (cond\n                         (nil? head) (conj result last-seg)\n                         (> head prev-val) (recur tail head (conj last-seg head) result)\n                         :else (recur tail head [head] (conj result last-seg))))\n        inc-sub (inc-sub-seq (rest s) (first s) [(first s)] [])]\n    (reduce (fn [result sub-seq] (let [max (count result)\n                                       len (count sub-seq)]\n                                   (if (and (> len max) (> len 1))\n                                     sub-seq\n                                     result))) [] inc-sub)))","user":"5cab0ad9e4b048ec896c5c46"},{"problem":53,"code":"(fn [a]                                                                                                          \n  (loop [coll (rest a),                                                                                          \n         current (take 1 a),                                                                                     \n         result []]                                                                                              \n    (if (empty? coll)                                                                                            \n      result                                                                                                     \n      (let [inced? (= (first coll) (inc (last current)))                                                         \n            current (if inced? (concat current (take 1 coll)) (take 1 coll))                                     \n            result (if (and (< (count result) (count current)) (<= 2 (count current))) current result)           \n            coll (rest coll)]                                                                                    \n        (recur coll current result)))))","user":"56403765e4b08d4f616f5edc"},{"code":"(fn longest-sub-seq [n]\n  (let [all-seqs (group-by count (reductions #(if (< (last %1) %2) (conj %1 %2) [%2]) [(first n)] (rest n)))\n        [seq-len max-len-seqs] (last all-seqs)\n        first-max-seq (first max-len-seqs)]\n    (if (< 1 seq-len)\n      first-max-seq\n      []\n    )\n  )\n)","problem":53,"user":"4e5fdd68535d8ccf87e9fe4f"},{"code":"#(apply max-key %\r\n  (reverse\r\n   (for [x (%2 (% %3)) % (%2 x (- (% %3) 1))\r\n:let [% (subvec %3 x (+ % 2))]]\r\n     (if (apply < %) % []))))\r\ncount range","problem":53,"user":"4e14b925535d04ed9115e7df"},{"problem":53,"code":"(fn [xs]\n  (loop [[x & remain :as xs] xs, prev [], best []]\n    (if (empty? xs)\n      best\n      (let [cur (if (or (empty? prev)\n                        (= x (inc (last prev))))\n                  (conj prev x)\n                  [x])]\n        (recur remain\n               cur\n               (if (and (>= (count cur) 2)\n                        (> (count cur) (count best)))\n                 cur\n                 best))))))","user":"573d58c8e4b05c31a32c0811"},{"problem":53,"code":"(fn [coll]\n  (or (first\n   (sort-by count >\n            (filter #(apply < %)\n                    (let [cnt (count coll)]\n                      (for [i (range cnt)\n                            j (range (inc i) cnt)]\n                        (drop i (take (inc j) coll)))))\n            )\n   )\n      '())\n  )","user":"563dfc02e4b0da801c4e4662"},{"code":"(fn [v] (->> v\n             (partition 2 1 ,,)\n             (map (fn [[a b]] (vector (- b a) a b)) ,,)\n             (partition-by #(> (first %) 0) ,,)\n             (filter #(> (first (first %)) 0) ,,)\n             (reduce #(if (> (count %2) (count %1)) %2 %1) [] ,,)\n             (map rest ,,)\n             (flatten ,,)\n             (#(concat (list (first %)) % (list (last %))) ,, )\n             (partition 2 ,,)\n             (map first ,,)\n             (filter #(not= nil %) ,,)))","problem":53,"user":"4dd0e8f7535da60f04a96e57"},{"problem":53,"code":"#(->> (range (dec (count %)))\n      (map (fn [i] [i (< (% i) (% (inc i)))]))\n      (partition-by second)\n      (filter (fn [x] (= true (second (first x)))))\n      (sort-by count >)\n      (first)\n      ((fn [l] (if (seq? l)\n                 (->> [(first (first l)) (inc (inc (first (last l))))]\n                      (apply range)\n                      (map (fn [i] (% i))))\n                 []))))","user":"5f5358b7e4b0a0bc16850a77"},{"problem":53,"code":"#(loop [r [[(first %)]] s (rest %)] (println r s)\n                                     (cond\n                                       (empty? s) (let [a (last (sort-by (fn [s] (count s)) r))] (if (> (count a) 1) a []))\n                                       (= (inc (last (last r))) (first s)) (recur (conj (vec (butlast r)) (conj (vec (last r)) (first s))) (rest s))\n                                       :else (recur (conj r [(first s)]) (rest s))))","user":"5f9c4113e4b0715f5002d821"},{"problem":53,"code":"(fn [xs]\n  (loop [i 0\n         j 1\n         si 0\n         sj 1\n         max-i 0\n         max-j 1]\n    (if (= j (count xs))\n      (if (> (- max-j max-i) 1) (subvec xs max-i max-j) [])\n      (if (> (xs j) (xs i))\n        (recur (inc i) (inc j) si (inc sj) (if (> (- (inc sj) si) (- max-j max-i)) si max-i) (if (> (- (inc sj) si) (- max-j max-i)) (inc sj) max-j))\n        (recur (inc i) (inc j) sj (inc sj) max-i max-j)))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":53,"code":"(fn long-in-ss [coll]\n  (reduce #(if (and (< (count %1) (count %2)) (<= 2 (count %2))) %2 %1) []\n          (partition-by #(= \"a\" %1)\n            (flatten (reduce #(if (= (last %1) (dec %2))\n              (conj %1 %2)\n              (conj [] %1 \"a\" %2)) [\"a\" (first coll)] coll)))))","user":"5471f0f3e4b094393f72dd6f"},{"problem":53,"code":"(fn longest-subseq [l]\n    (letfn [\n            (maketuples [l] (map vector (drop-last 1 (into [-1] l)) l))\n\n            (pred [[a b]] (< a b))\n\n            (get-orig [l]\n              (map last l))\n\n            (drop-until-decreasing\n              [l]\n              (if (empty? l)\n                '()\n                (get-orig (drop-while pred (maketuples l)))\n                )\n              )\n\n            (take-until-decreasing\n              [li]\n              (get-orig (take-while pred (maketuples li))))\n\n            (susbseqs [li]\n              (map take-until-decreasing\n                (take-while (complement empty?) (iterate drop-until-decreasing li))))\n            ]\n\n      (let [longest (filter #(> (count %) 1) (susbseqs l))]\n        (if (empty? longest)\n          []\n          (reduce (fn [a b] (if (< (count a) (count b)) b a)) longest)\n          )))\n    )","user":"55ddc5cbe4b050e68259b3d0"},{"code":"(fn [xs] (->> xs (partition 2 1) (map #(cons (- (second %) (first %)) %)) (partition-by #(Integer/signum (first %))) (filter #(<= 0 (first (flatten %)))) (sort-by count >) (first) (map rest) (flatten) (distinct)))","problem":53,"user":"52f10094e4b05e3f0be25ee8"},{"code":"(fn [v] \n  (let [r\n    (map #(% 1) \n      (first \n        (sort-by count > \n          (partition-by #(+ (% 0) (% 1)) \n            (keep-indexed #(vector (- (count v) %) %2) v)))))]\n    (if (> (count r) 1)\n      r\n      [])))","problem":53,"user":"4e8f4f64535d65386fec2149"},{"code":"(fn [col]\n  (loop [c col r nil k nil]\n    (if (seq c)\n      (if (and (> (count r) 0)\n               (= (first c) (inc (last r))))\n        (recur (rest c)\n               (conj r (first c))\n               (if (>= (count r) (count k))\n                 (conj r (first c))\n                 k))\n        (recur (rest c) [(first c)] k))\n      (if (>= (count k) 2)\n        k\n        []))))","problem":53,"user":"539c64cde4b0b51d73faaf2a"},{"problem":53,"code":"(fn [l]\n  (loop [l l\n         longest-sofar []\n         longest-ending []]\n    (if (empty? l)\n      (if (> (count longest-sofar) 1)\n        longest-sofar\n        [])\n      (let [elt (first l)\n            new-longest-ending (cond (empty? longest-ending) [elt]\n                                     (> elt (last longest-ending)) (conj longest-ending elt)\n                                     :else [elt])\n            new-longest-sofar (cond (empty? longest-sofar) new-longest-ending\n                                    (> (count new-longest-ending) (count longest-sofar)) new-longest-ending\n                                    :else longest-sofar)]\n        (recur (rest l) new-longest-sofar new-longest-ending)))))","user":"4ede8e1d535d10e5ff6f5339"},{"problem":53,"code":"(fn [coll]\n   (let [pcoll (partition 2 1 coll)]\n     (if (every? (fn [[a b]] (>= a b)) pcoll)\n       []\n       (->> pcoll\n            (partition-by (fn [[a b]] (< a b)))\n            (group-by count)\n            (#(% (apply max (keys %))))\n            (first)\n            (#(concat (first %) (map second (rest %))))))))","user":"596a66cde4b069c0a1a19803"},{"code":"(fn fliss [v]\n  (let [get-next (fn  [v i]\n                   (let [c (count v)]\n                     (loop [result []\n                            ii i]\n                       (let [ae (v ii)\n                             ne (if (= c (inc ii)) nil (v (inc ii)))]\n                         (if (and (not= ii c) (not= nil ne) (= ne (inc ae)))\n                           (recur (conj result ae) (inc ii))\n                           (conj result ae)\n                           ))))) \n        find-next (fn  [v i]\n                    (let [c (count v)]\n                      (cond\n                        (= (dec c) i) {:npos c, :subs []}\n                        (not= 1 (- (v (inc i)) (v i))) {:npos (inc i), :subs []}\n                        :else\n                        (let [ss (get-next v i)]\n                          {:npos (+ i (count ss)), :subs ss})\n                        )))\n        get-subsets (fn [v]\n                      (loop [i 0, result []]\n                        (let [found (find-next v i)]\n                          (if (>= (found :npos) (count v))\n                            (conj result (found :subs))\n                            (recur (found :npos) (conj result (found :subs))))\n                          )))\n        subsets (get-subsets v)]\n    (first (reverse (sort-by count subsets)))\n    ))","problem":53,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn lis \n  ([s] (lis s [] []))\n  ([s candidates curr]\n    (if (empty? s)\n      (let [cand (if (> (count curr) 1) (conj candidates curr) candidates)]\n        (reduce (fn [a b] (if (>= (count a) (count b)) a b)) [] cand))\n      (if (empty? curr)\n        (recur (rest s) candidates [(first s)])\n        (if (> (first s) (last curr))\n          (recur (rest s) candidates (concat curr [(first s)]))\n          (if (> (count curr) 1)\n            (recur (rest s) (conj candidates curr) [(first s)])\n            (recur (rest s) candidates [(first s)])))))))","problem":53,"user":"4f611127e4b0defedf855fb4"},{"code":"(fn [s]\n    (if (empty? s)\n        []\n        ((fn [xs current longest]\n        (if (empty? xs)\n            (if (= (count current) 1)\n                []\n                (if (>= (count longest) (count current))\n                    longest\n                    current))\n            (if (> (first xs) (last current))\n                (recur (rest xs) (conj current (first xs)) longest)\n                (recur (rest xs) [(first xs)]\n                    (if (> (count current) (count longest))\n                        current\n                        longest))))) (rest s) [(first s)] [])))","problem":53,"user":"517bf28de4b07ef0e56148d5"},{"problem":53,"code":"(fn\n             [xs]\n             (->>\n               (reduce\n                 #(\n                    if (< (last (last %1)) %2)\n                    (conj (pop %1) (conj (peek %1) %2))\n                    (conj %1 [%2])\n                    )\n                 [[(first xs)]] (rest xs))\n               (filter #(> (count %1) 1))\n               (reduce #(if (< (count %1) (count %2)) %2 %1) [])))","user":"596d630ae4b069c0a1a19846"},{"problem":53,"code":"(fn [ns]\n  (reduce (fn [mx cs] (if (and (> (count cs) (count mx)) (>= (count cs) 2)) cs mx))\n          []\n          (reduce (fn [rs n] \n            (let\n              [sq (peek rs)]\n              (if (> n (peek sq))\n                (conj (pop rs) (conj sq n))\n                (conj rs [n])\n              ))) [[(first ns)]] (rest ns))))","user":"55316b8ae4b076ab5578f825"},{"code":"(fn [c]\n  (let [A apply\n        C conj\n        N count\n        c (A max-key N\n             (A C\n                (reduce (fn [[m c] e]\n                          [(C m c) (if (= e (+ 1 (last c)))\n                                     (C c e)\n                                     [e])])\n                        [[] [-2]] c)))]\n    (if (= 1 (N c))\n      []\n      c)))","problem":53,"user":"51a10b2ce4b0b292b01ee3fe"},{"code":"(fn longest-increasing-subseq [coll]\n  (loop [res [] cur [(first coll)] c (rest coll)]\n    (if (empty? c)\n      res\n      (let [f (first c)]\n        (if (> f (last cur))\n          (let [curf (conj cur f)]\n            (if (> (count curf) (count res))\n              (recur curf curf (rest c))\n              (recur res curf (rest c))))\n          (recur res [f] (rest c)))))))","problem":53,"user":"4dbd0161535d020aff1edf3f"},{"code":"(fn [coll]\n  (let [increasing-sub-seqs\n        (fn increasing-sub-seqs\n          [current coll]\n          (if (seq coll)\n            (let [a (first coll)]\n              (if (and current (= (peek current) (dec a)))\n                (increasing-sub-seqs (conj current a) (rest coll))\n                (if (and current (<= 2 (count current)))\n                  (cons current (increasing-sub-seqs [a] (rest coll)))\n                  (increasing-sub-seqs [a] (rest coll)))))\n            (when (and current (<= 2 (count current)))\n              (cons current nil))))]\n    (reduce\n     (fn [r x]\n       (if (> (count x) (count r))\n         x r))\n     []\n     (increasing-sub-seqs nil coll))))","problem":53,"user":"4e68c434535d8ccf87e9fe89"},{"problem":53,"code":"(fn [coll]\n  (->> coll\n  (map-indexed -)\n  (map list coll)\n  (group-by last)\n  (vals)\n  (filter #(> (count %) 1))\n  (map #(map first %))\n  (reduce #(if (> (count %1) (count %2)) %1 %2) ())\n  ))","user":"59cf4013e4b0ef0a1e9b5b68"},{"problem":53,"code":"(fn subs [x] \n  (first \n   (reverse \n    (sort\n     (for [idx (range 0 (count x))]\n       (loop [frag (drop idx x)\n              result (vector (first frag))\n              curr (first frag)\n              s (rest frag)]\n         (if (empty? s)\n             (if (>= (count result) 2) result [])\n             (if (< curr (first s))\n               (recur [] (conj result (first s)) (first s) (rest s))\n               (if (>= (count result) 2) result [])))))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [l](let [l (last(sort(reductions (fn [l n](if (< (last l) n) (conj l n) [n])) [(first l)] (rest l))))] (if (= (count l) 1) [] l)))","problem":53,"user":"51b793d3e4b0d906fcd71d38"},{"problem":53,"code":"#(apply max-key count \n  (conj\n   (filter (fn [s] (>= (count s) 2)) \n   (reduce\n   (fn [a x]\n     (let [l (last (last a))]\n       (if (and l (= (inc l) x))\n         (conj (vec (butlast a)) (conj (last a) x))\n         (conj a [x])))) [] %))\n   []))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":53,"code":"(fn inc-num2 [vec] (->> vec\n                          (partition 2 1)\n                          (partition-by (partial apply <))\n                          (filter (fn [[[a b]]] (< a b)))\n                          (reduce (fn [m s] (if (> (count s) (count m)) s m)) [])\n                          (flatten)\n                          (distinct)\n                          ))","user":"5614fa1de4b05f002753dfbe"},{"problem":53,"code":"#(loop [col % item [] rt []]\n    (println col item rt)\n    (if(empty? col)\n      (if(> (count item) (count rt)) (if(> (count item) 1) item []) (if(> (count rt) 1) rt []))\n      (let [new-col (rest col) first-item (first col) is-inc (= (last item) (dec first-item))]\n        (println is-inc)\n        (recur new-col (if(empty? item) (conj item first-item) (if is-inc (conj item first-item) [first-item] ) ) (if(not is-inc) (if(> (count item) (count rt)) item rt) rt) )\n        )\n      )\n    )","user":"5d270111e4b092dab7f59c62"},{"code":"(fn [coll]\n    (->> coll\n         (partition 2 1 coll)\n         (partition-by (fn [[x y]] (- y x)))\n         (filter (fn [[[x y] & rst]] (= (inc x) y)))\n         (cons '())\n         (apply (partial max-key count))\n  \t     flatten\n         distinct\n         ))","problem":53,"user":"4fe8a3bde4b07c9f6fd12c61"},{"problem":53,"code":"(fn longest [coll]\n  (loop [input coll\n         result []\n         current_seq []\n         last_value nil]\n    (if (empty? input)\n      (let [candidate (if (< (count result) (count current_seq))\n                        current_seq\n                        result)]\n        (if (> (count candidate) 1)\n          candidate\n          []))\n      (if (or (= last_value nil) (= (inc last_value) (first input)))\n        (recur (rest  input) result (conj current_seq (first input)) (first input))\n        (if (< (count result) (count current_seq))\n          (recur (rest input) current_seq (vector (first input)) (first input))\n          (recur (rest  input) result (vector (first input)) (first input)))))))","user":"5ab490f4e4b073f17744261d"},{"code":"(fn lcss [seq]\n  (let [finish (fn [candidate]\n                 (if (> (count candidate) 1)\n                   candidate\n                   []))\n        can-extend? (fn [curr items]\n                      (> (first items) (last curr)))\n        extend (fn [curr items]\n                 (concat curr (take 1 items)))]\n    \n    (loop [items (rest seq)\n           curr (take 1 seq)\n           best []]\n      (cond\n       (empty? items) (finish (max-key count curr best))\n       (can-extend? curr items) (recur (rest items) (extend curr items) best)\n       :else (recur (rest items) (take 1 items) (max-key count curr best))\n       ))))","problem":53,"user":"530578ede4b0d8b024fd3760"},{"problem":53,"code":"#(first (reduce (fn [[longest current] x]\n         (let [n (conj current x)]\n         (if-not (apply < n) [longest [x]]\n         (if (and (< (count longest) (count n)) (< 1 (count n)))\n                  [n n] [longest n])\n             ))) [[][]] %))","user":"55bfc39ee4b01b9910ae2a1a"},{"code":"(fn maxsub\n  [s]\n  (loop [\n    tails   s\n    max-val -1\n    cur-len -1\n    max-len -1\n    max-seq []\n    tmp-seq []\n  ] (let [val (first tails) rem (rest tails)]\n      (if (empty? tails)\n        (let [max (if (> (count tmp-seq) (count max-seq)) tmp-seq max-seq)] (if (> (count max) 1) max []))\n        (if (> val max-val)\n          (if (= cur-len max-len)\n            (recur rem val (inc cur-len) (inc cur-len) (conj tmp-seq val) (conj tmp-seq val))\n            (recur rem val (inc cur-len) max-len max-seq (conj tmp-seq val)))\n          (recur rem -1 -1 max-len max-seq (conj [] val))\n        )\n      )\n    )\n  )\n)","problem":53,"user":"4e9b230c535dbda64a6f6b75"},{"problem":53,"code":"(fn [coll]\n     \n        ;;  reduce   - [[1] [0 1 2 3] [0] [4 5]]\n        (let [ordergroups (reduce \n            (fn [acc item]\n                (let [lastvectorindex (dec (count acc)) \n                    lastitem (last (get acc lastvectorindex))]\n                    (if (= (inc lastitem) item) (update-in acc [lastvectorindex] conj item) \n                        (conj acc (vector item)))))\n                [[(first coll)]] (rest coll))\n                minvector (reduce (fn [acc1 item1]\n                            (let [acc_count (count acc1) item_count (count item1)]\n                                (if (> item_count acc_count) item1 acc1)))\n                                    ordergroups)]\n             (if (< (count minvector) 2) [] minvector)))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":53,"code":"(fn sub \n   ([col] (let [res (first (sort-by count #(> %1 %2) \n                                    (sub [[(first col)]] (rest col))))]\n            (if (< (count res) 2) [] res))\n        )\n   ([acc col] (reduce\n               (fn [acc elem]\n                 (let [llast ((comp last last) acc)\n                       cconj #(conj (pop %1) (conj (last %1) %2))]\n                   (if (= (- elem llast) 1)\n                     (cconj acc elem)\n                     (conj acc [elem]))))\n               acc col)) \n   )","user":"5e44c804e4b01d43a70e8e89"},{"problem":53,"code":"(fn [xs]\n  (loop [rem xs\n         res []\n         work []]\n    (if (empty? rem)\n      res\n    (if (empty? work)\n      (recur (rest rem) res [(first rem)])\n      (if (not= (inc (last work)) (first rem))\n        (recur (rest rem) res [(first rem)])\n        (if (> (inc (count work)) (count res))\n          (recur (rest rem) (conj work (first rem)) (conj work (first rem)))\n          (recur (rest rem) res (conj work (first rem))))\n        )))))","user":"5522cd9ae4b0882d96d091ab"},{"problem":53,"code":"#(letfn [(longest [best curr]\n            (cond\n              (< (count curr) 2) best\n              (> (count curr) (count best)) curr\n              :else best))]\n    (loop [best [] curr [] [x & r] %]\n      (cond\n        (nil? x) (longest best curr)\n        ((fnil >= x) (last curr) x) (recur (longest best curr) [x] r)\n        :else (recur best (conj curr x) r))))","user":"5a544eeee4b05d388ecb6c24"},{"problem":53,"code":"(fn f\n   ([coll] (f coll [] []))\n   ([coll rst temp]\n    (let [sizeT (count temp)\n          sizeR (count rst)\n          item (first coll)\n          others (rest coll)]\n      (cond (empty? coll) (if (> sizeT sizeR 1) temp rst)\n            (empty? temp) (recur others rst [item])\n            (= (dec item) (last temp)) (recur others rst (conj temp item))\n            (< sizeT 2) (recur others rst [item])\n            (< sizeR sizeT) (recur others temp [item])\n            :else (recur others rst [item])))))","user":"558aabbfe4b0277789237621"},{"problem":53,"code":"(fn [s]\n  (let [split-sequences (loop [[a & remaining] s\n                               res []]\n                          (if a\n                            (if (last (last res))\n                              (if (= (inc (last (last res))) a)\n                                (recur remaining (conj (into [] (butlast res)) (conj (last res) a)))\n                                (recur remaining (conj res [a])))\n                              (recur remaining (conj res [a])))\n                            res))]\n    (->> split-sequences\n         (filter #(>= (count %) 2))\n         (sort #(compare (count %2) (count %1)))\n         first\n         (into []))))","user":"591e0782e4b09b4ee5954c25"},{"code":"(fn [xs]\n      (let [subsequence\n            (drop-while #(apply > %)\n                        (first\n                          (sort-by\n                            (comp - count)\n                            (partition-by #(if (apply < %) nil (Object.)) (partition 2 1 xs)))))]\n        (if (empty? subsequence) [] (cons (first (first subsequence)) (map second subsequence)))))","problem":53,"user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [s]\n  (letfn [(subseqs [s] (set (mapcat (fn [i] (map #(subvec s i %)\n                                                (range i (inc (count s)))))\n                                    (range (count s)))))\n          (inc-subseqs [s] (filter #(and (> (count %) 1) (apply < %))\n                                   (subseqs s)))\n          (maxlength [s] (apply max (map count s)))\n          (longest [s] (first (filter #(= (count %) (maxlength s)) s)))]\n    (let [ss (inc-subseqs s)] (if (empty? ss) [] (longest ss)))))","problem":53,"user":"4ea1b9e4535d7eef308072b8"},{"problem":53,"code":"(fn [seq]\n   (let [longest-seq (apply max-key count\n                            (reduce\n                             (fn [result item]\n                               (let [last-seq (last result)\n                                     last-item (last last-seq)\n                                     ]\n                                 (if (and last-item\n                                          (= item (inc last-item)))\n                                   ;; consecutive, add it to last seq\n                                   (conj (vec (drop-last result)) (conj last-seq item))\n                                   ;; not consecutive, add a new seq\n                                   (conj result [item])\n                                   ))\n                               )\n                             []\n                             seq\n                             ))\n         size-longest-seq (count longest-seq)\n         ]\n     (if (> size-longest-seq 1)\n       longest-seq\n       [])\n     ))","user":"5ee75f8be4b029a2061bbea5"},{"problem":53,"code":"(fn [coll]\n  (loop [prev (- (apply min coll) 1) acc '() known '() rem coll]\n    (if (nil? (seq rem))\n      (if (> 2 (max (count acc) (count known))) '()\n          (if (> (count acc) (count known))\n            acc\n            known))\n        (if (> (first rem) prev)\n          (recur (first rem) (concat acc [(first rem)]) known (rest rem))\n          (if (> (count acc) (count known))\n            (recur (first rem) [(first rem)] acc (rest rem))\n            (recur (first rem) [(first rem)] known (rest rem)))))))","user":"5d126728e4b02c15ef02199a"},{"code":"(fn longest [c]\n  (loop [coll (rest c) longest [] curr [(first c)]]\n    (if (seq coll)\n      (if (= (first coll) (inc (last curr))) \n        (let [new_curr (conj curr (first coll))] \n          (recur (rest coll) (if (< (count new_curr) (count longest)) longest new_curr) new_curr))\n        (recur (rest coll) longest [(first coll)]))\n      longest)))","problem":53,"user":"5003deb9e4b0678c553fc445"},{"problem":53,"code":"(fn [s]\n  (->> \n    (range 2 (inc (count s)))   ;; generate all possible length of subsequences\n    (mapcat #(partition % 1 s)) ;; generate all subsequences\n    (filter #(apply < %))       ;; filter out those which don't increase\n    (cons [])                   ;; add in the empty sequence in case no increasing\n    (sort-by count >)           ;; sort by longest\n    first))                     ;; we have a winner","user":"548fa2dfe4b0e286459a1240"},{"code":"(fn [coll] (->> (partition 2 1 coll) (partition-by #(- (second %) (first %))) (filter #(= 1 (- (second (first %)) (ffirst %)))) \n(reduce #(if (< (count %1) (count %2)) %2 %1) [])\nflatten\ndistinct\n))","problem":53,"user":"51a417dde4b0def3c5c58688"},{"problem":53,"code":"(fn [s]\n  (let [partition-when\n        (fn [f s]\n          (loop [[x y :as s] s outs [] tmps []]\n            (cond (nil? y) (conj outs (conj tmps x))\n                  (f x y) (recur (rest s) (conj outs (conj tmps x)) [])\n                  :else (recur (rest s) outs (conj tmps x)))))\n        longest (apply max-key count (reverse (partition-when #(>= %1 %2) s)))]\n    (if (>= (count longest) 2)\n      longest\n      [])))","user":"5cab33e7e4b048ec896c5c48"},{"code":"(fn [xs]\n  (->> (map vector xs (rest xs))\n       (partition-by #(< (first %) (second %)))\n       (filter #(< (first (first %)) (second (first %))))\n       (sort-by #(- (count %)))\n       first\n       flatten\n       distinct\n   )\n )","problem":53,"user":"53691dc7e4b0243289761e97"},{"problem":53,"code":"(fn [coll]\n  (let [count-max (fn [l c]\n                      (let [coll (if (>= (count l) (count c))\n                                   l c)]\n                        (if (> (count coll) 1)\n                          coll\n                          [])))\n          next? (fn [xs x]\n                  (if (seq xs)\n                    (= (inc (last xs)) x)\n                    true))\n          re-next (fn [[l c] x]\n                    (if (next? c x)\n                      [l (conj c x)]\n                      [(count-max l c) [x]]))]\n    (apply count-max\n           (reduce (fn [ret x]\n                     (re-next ret x))\n                   [[][]]\n                   coll))))","user":"5370d152e4b0fc7073fd6e9d"},{"problem":53,"code":"(fn [f l] (if (>= (count (f l)) 2)\n          (f l)\n          []))\n(fn [x]\n  (apply max-key count\n         (reduce (fn [l e]\n                   (if (= (last (last l)) (dec e))\n                     (conj (pop l) (conj (last l) e))\n                     (conj l [e])))\n                   [[(first x)]]\n                   (rest x))))","user":"5801eed1e4b0a837a8b30c63"},{"problem":53,"code":"; First create the list of all the elements of the input vector in ascending order without doubles.\n; Its sub-lists (len >= 2) represent all possible increasing sub-seqs.\n; Now create all sub-lists of this meta list, longest first:\n;\n(fn max-inc-sub-seq[coll]\n  (letfn [\n           (searchvecs [col]\n             (let [v (distinct (sort col))] \n               (for[n (range (count v) 1 -1) m (range (inc (-(count v) n)))] (take n (nthrest v m)))))\n\n;Iterate this meta-list and search the contained sublists in the input vector:\n\n           (subseqs [c1 c2]\n             (for [n (range (- (count c2) (dec (count c1))))]\n              (take (count c1) (nthrest c2 n))))\n\n           (getsubs[col1 col2]\n             (some \n               (fn[x] (if (= col1 x) col1)) (subseqs col1 col2)))\n         ]\n    \n;Return the first meta-list subsequence which is found in the input vector (cast list to vector) or [] if none was found:\n  \n    (let [v (drop-while nil? (for [v (searchvecs coll)] (getsubs v coll)))]\n      (if (empty? v) \n        [] \n        (vec (first v))))))","user":"545537c1e4b0e397800069dd"},{"problem":53,"code":"{[1 0 1 2 3 0 4 5] [0 1 2 3]\n   [5 6 1 3 2 7] [5 6]\n   [2 3 3 4 5] [3 4 5]\n   [7 6 5 4] []}","user":"59d37e3de4b0ef0a1e9b5bb9"},{"problem":53,"code":"(fn longest-inc-threaded [s]\n  (let [partition-by-trigger (fn partition-by-trigger [f coll]\n  (when-let [s (seq coll)]\n    (let [fst (first s)\n          nxt (next s)\n          run (cons fst (take-while (complement f) nxt))]\n      (cons run (partition-by-trigger f (seq (drop (count run) s)))))))]\n  (->> s \n       (map - (drop 1 s))\n       (cons 1)\n       (map vector s)\n       (partition-by-trigger #((complement pos?) (get % 1)))\n       (reduce #(if (< (count %1) (count %2)) %2 %1))\n       (map #(get % 0))\n       (#(if (> (count %) 1) % [])))))","user":"53edb464e4b0d648e757f4c7"},{"code":"(fn [s]\n      (loop [s s x '() y '()]\n       (print x \" --- \" y \"**\\n\")\n        (if (empty? s) (reverse (if (or (> (count x) 1) (> (count y) 1)) (if (> (count x) (count y)) x y) '()))\n          (if (empty? x)\n           (recur (rest s) (cons (first s) x) y)\n           (if (= (first s) (inc (first x)))\n             (recur (rest s) (cons (first s) x) y)\n             (if (empty? y) \n              (recur (rest s) (list (first s)) x)\n              (recur (rest s) (list (first s)) (if (> (count x) (count y)) x y)))))))\n   )","problem":53,"user":"5029fccee4b023940c84aa47"},{"code":"(fn [coll]\n  (->> coll\n       (map-indexed (fn [idx x]\n                      (->> (subvec coll idx)\n                           (map = (iterate inc x))\n                           (take-while true?)\n                           count\n                           (+ idx)\n                           (subvec coll idx))))\n       (filter (comp (partial < 1) count))\n       reverse\n       (sort-by count)\n       last\n       (#(or % []))))","problem":53,"user":"4fceda40e4b03432b189f407"},{"problem":53,"code":"(fn [coll]\n  (reduce (fn [ms s]\n           (let [m (max-key count ms s)] (if (> (count m) 1) m ms)))\n   []\n   (reduce (fn [lcss n]\n            (cond (empty? lcss) (conj lcss [n])\n             (= n (inc (last (last lcss)))) (conj lcss (conj (last lcss) n))\n             :else (conj lcss [n])))\n    [] coll)))","user":"520e37cfe4b066f3ea161c96"},{"problem":53,"code":"(fn [x]\n (->> (reductions #(if (= %2 (inc (last %))) (conj % %2) [%2]) [-2] x)\n  (filter #(< 1 (count %)))\n  (reduce #(if (< (count %) (count %2)) %2 %) [])))","user":"5b61aa6ae4b0c6492753e712"},{"problem":53,"code":"(fn [l]\n  (let [i (first l)\n        r '()\n        splitter (fn [r l]\n                   (cond \n                       (nil? (first l)) r\n                       (nil? (first r)) (recur (conj r (list(first l))) (rest l))\n                       (> (first l) (first (first r))) (recur (conj (rest r) (conj (first r) (first l))) (rest l))\n                       :else (recur (conj r (list (first l))) (rest l))\n                    \n                    )\n                 )\n        ]\n    (reverse (reduce (fn [l1 l2] (if (and (> (count l2) 1) (<= (count l1) (count l2))) l2 l1)) [] (splitter r l)))\n    ))","user":"531902b1e4b08068f379ed77"},{"problem":53,"code":"(fn [v] (or (first (filter #(< 1 (count %))(sort-by count > ((fn [[r c]] (conj r c)) (reduce (fn [[r c lv] v] (if (< lv v) [r (conj c v) v] [(conj r c) [v] v])) [[] [] 999999] v))))) []))","user":"58acca5ee4b0005cfeb1a753"},{"code":"(fn [coll]\n  (->>\n    (partition 2 1 coll)\n    (partition-by #(apply - %))\n    (filter #(= -1 (apply - (first %))))\n    (reduce #(max-key count % %2) '())\n    flatten\n    distinct\n  ))","problem":53,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn longest [s]\n  (first \n  (reduce (fn [[acc cur] elem]\n          (if (seq cur)\n              (if (< (last cur) elem)\n                  (if (>= (count cur) (count acc))\n                      [(conj cur elem) (conj cur elem)]\n                      [acc (conj cur elem)])\n                  [acc [elem]])\n          [acc [elem]]))\n  [[] []] s)))","problem":53,"user":"4eb0a757535d7eef3080733d"},{"problem":53,"code":"(fn [coll]\n  (let [len (count coll)]\n\t(loop [i 1\n         csub []\n         msub []]\n      (if (>= i len)\n        msub\n        (let [x (nth coll (dec i))\n              y (nth coll i)\n              plusOne? (= y (inc x))]\n          (println csub msub x y plusOne?)\n          (if plusOne?\n            (let [ccsub (if (empty? csub) [x] csub)\n                  cpp (conj ccsub y)]\n              (recur (inc i)\n                     cpp\n                     (if (> (count cpp) (count msub)) cpp msub)))\n            (recur (inc i)\n                   [y]\n                   msub)))))))","user":"557a1e18e4b05c286339e09e"},{"code":"(fn [s] (->> (for [from (range 0 (- (count s) 1)) length (range 2 (count s))] (take length (drop from s)))\n                         (filter #(apply < %))\n                         (reduce (fn [x y] (if (>= (count x) (count y)) x y)) [])))","problem":53,"user":"51095588e4b0e34872b3efa5"},{"problem":53,"code":"(fn[coll]\n  (letfn [(all-subseqs [coll]\n            (reductions (fn [increasing val]\n                          (if (> val (last increasing))\n                            (conj increasing val)\n                            [val]))\n                        [(first coll)]\n                        (rest coll)))]\n    (let [longest\n          (first (sort-by count > (all-subseqs coll)))]\n      (if (>= (count longest) 2) longest []))))","user":"56603e5fe4b068f2fe63dc4a"},{"code":"(fn [lst] (first (sort-by count > (map #(if (> (count %) 1) % '()) (map #(map last %) (partition-by first (map-indexed #(list (- %2 %) %2) lst)))))))","problem":53,"user":"50e3fe8fe4b0463d32072488"},{"problem":53,"code":"(fn [b-seq]\n  (let [longer #(if (< (count %1) (count %2))\n                  %2\n                  %1)]\n    (loop [a-seq     (rest b-seq)\n           longest   []\n           current   [(first b-seq)]]\n      (println a-seq longest current)\n      (cond\n        (empty? a-seq)\n        (let [longest (longer longest current)]\n          (if (> (count longest) 1)\n            longest\n            []))\n        (< (last current) (first a-seq))\n        (recur (rest a-seq) \n               longest \n               (conj current (first a-seq)))\n        :else\n        (recur (rest a-seq) \n               (longer longest current)\n               [(first a-seq)])))))","user":"574e84e0e4b02ea114799243"},{"problem":53,"code":"(fn lo-sub2 \n  ([s] (lo-sub2 (rest s) '() (list (first s))))\n  ([s best cur]\n   (cond (empty? s)\n                  (let [res (if (< (count best) (count cur)) (reverse cur) best)]\n                      (if (< (count res) 2) [] res))\n         (>= (first cur) (first s))\n         (lo-sub2 (rest s) (if (< (count best) (count cur)) (reverse cur) best) (list (first s)))\n         :else (lo-sub2 (rest s) best (conj cur (first s))))))","user":"5d931a58e4b0d3f9b434ad10"},{"code":"(fn longest-sub-seq [col]\n\n  (letfn [(fold-inc [col]\n            (let [lst \n            (reduce (fn [acc,e ] \n             (if (= (last acc) :x) \n               acc    \n               (if (or (nil? (last acc)) (> e (last acc))  )\n                (conj acc e)\n                (conj acc :x)\n               ))) [] col )]\n             (if (= (last lst) :x) (drop-last lst) lst)))\n           \n          (fold-max [col,acc]\n            (if (empty? col) \n                acc\n                (let [current-max-list (fold-inc col)]\n                (fold-max (rest col) (conj acc current-max-list))\n                )))                    \n          \n         ]\n  \n    (let [sub-list (fold-max col [])\n        max-len (apply max (map count sub-list))\n        res (first (filter (fn [e] (= max-len (count e) ) ) sub-list))]\n    (if (= (count res) 1) [] res))\n    \n    \n    \n   ) \n)","problem":53,"user":"5180dc04e4b06b8caf33fa01"},{"problem":53,"code":"(fn [xs]\n   (let [[x len]\n         (->> (map #(vector %1 (- %1 %2)) (rest xs) xs)\n              (partition-by #(not= 1 (second %)))\n              (filter #(= 1 (second (first %))))\n              (map #(vector (dec (first (first %))) (count %)))\n              (reduce (fn [[xf xc :as x] [yf yc :as y]] (if (> yc xc) y x)) [0 0]))]\n     (if (> len 0)\n       (range x (+ x len 1))\n       (list))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":53,"code":"(fn [arr]\n  (let [consecutives  \n        (loop [c [] r [] [n & nums] arr]\n          (if (not (nil? n))\n            (let [t-result (cond \n                             (empty? r) (conj r n)\n                             (= (inc (last r)) n) (conj r n)\n                             :else nil)]\n              (recur \n                (if (and (nil? t-result) (> (count r) 1)) (conj c r) c)\n                (if (nil? t-result) [n] t-result) \n                nums))\n            (if (> (count r) 1) (conj c r) c)))]\n    (if (seq consecutives)\n      (apply max-key (cons count consecutives))\n      [])))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn [v] (or (first (filter #(apply < %) (mapcat #(partition % 1 v) (range (count v) 1 -1)))) []))","problem":53,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn [s]\n  (loop [i 0, ls [], ts []]\n    (if-not (< i (count s))\n      (if (> (count ts) (max 1 (count ls)))\n        ts\n        ls\n      )\n      (if (> (nth s i) (last (concat [-1] ts)))\n        (recur (inc i) ls (conj ts (nth s i)))\n        (if (> (count ts) (max 1 (count ls)))\n          (recur i ts [])\n          (recur i ls [])\n        )\n      )\n    )\n  )\n)","problem":53,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn\n  [xs]\n  (->>\n    (reduce\n      (fn [[p [ys & more :as yss]] x] [x (if (< p x) (cons (cons x ys) more) (cons (list x) yss))])\n      [(first xs) '(())]\n      xs)\n    second (filter #(-> % count (> 1))) (cons []) (apply max-key count) reverse vec))","problem":53,"user":"4ef8d47c535dced4c769f261"},{"code":"(fn [input]\n    (let [seqs (map #(take (first %1) (drop (second %1) input))\n                                  (for [x (range (inc (count input)))\n                                        y (range (inc (count input)))]\n                                    [x y]))]\n      (apply (partial max-key count []) (filter    \n        #(when (> (count %1) 1) \n           (loop [i (dec (count %1)) ok true]\n             (if (= i 0)\n               ok     \n               (recur (dec i) (and ok (= (dec (nth %1 i)) (nth %1 (dec i))))))))\n        seqs))))","problem":53,"user":"5341b141e4b00652c8746ecf"},{"problem":53,"code":"(fn [s]\n  (let [seqs (loop [prev (first s)\n                    curr (second s)\n                    s (drop 2 s)\n                    seqs [[]]]\n               (if (nil? curr)\n                 seqs\n                 (recur curr\n                        (first s)\n                        (rest s)\n                        (if (= (inc prev) curr)\n                          (vec (concat (butlast seqs)\n                                       (if (empty? (last seqs))\n                                         [[prev curr]]\n                                         [(vec (concat (last seqs) [curr]))])))\n                          (if (empty? (last seqs))\n                            seqs\n                            (vec (concat seqs [[]])))))))]\n    (reduce\n     (fn [max curr]\n       (if (> (count curr) (count max))\n         curr\n         max))\n     seqs)))","user":"5cf6522be4b0b71b1d808a58"},{"code":"(let [increasing? (fn [l] (if (empty? l)\n                            true\n                            (apply = (map - l (range)))))]\n  (fn [l]\n    (first (for [len (range (count l) -1 -1)\n                 :when (not (= len 1))\n                 the-seq (partition len 1 l)\n                 :when (increasing? the-seq)]\n             the-seq))))","problem":53,"user":"50a83315e4b054305ba5a830"},{"problem":53,"code":"(fn [v]\n\n  (letfn [(test-lis [v]\n          (loop [ tempv (rest v) is [(first v)]] \n            (if (or (empty? tempv) (not(> (first tempv) (last is))) )\n              is\n              (recur (rest tempv) (if (< (last is) (first tempv)) (conj is (first tempv)) is ))\n              )\n            ))]\n    (loop [v v lis []]\n      (if (empty? v)\n        (if( > (count lis) 1) lis [] )\n        (let [is (test-lis v)] \n          (recur (rest v) (if (> (count is) (count lis)) is lis))\n          )\n        )\n      )    \n    )\n)","user":"56c7d8dee4b0ed865f9758c9"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n       (iterate rest)\n       (take-while seq)\n       (map (fn [subseq]\n              (->> subseq\n                   (partition 2 1)\n                   (take-while (fn [[a b]] (> b a)))\n                   (map second)\n                   (cons (first subseq)))))\n       (filter #(> (count %) 1))\n       (sort-by #(* -1 (count %)))\n       (first)\n       (vec)))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn lis [v]\n  (loop [maxlen 0\n         maxseq []\n         curseq []\n         lastelt nil\n         remain v]\n     (if (empty? remain)\n        (if (> maxlen 1) maxseq [])\n        (let [nextelt (first remain)\n              incr (if lastelt (> nextelt lastelt) true)\n              newcurseq (if incr\n                            (conj curseq nextelt)\n                            [nextelt])\n              better (> (count newcurseq) (count maxseq))\n              newmaxseq (if better newcurseq maxseq)\n              newmaxlen (count newmaxseq)]\n          (recur newmaxlen\n                 newmaxseq\n                 newcurseq\n                 nextelt\n                 (rest remain))))))","problem":53,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [coll]\n  (let [a (partition-by #(= (inc (first %)) (last %)) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (= (inc x1) x2)) a)\n        c (sort-by count > b)\n        d (first c)]\n    (concat (first d) (map last (rest d)))))","problem":53,"user":"52976262e4b02ebb4ef75041"},{"problem":53,"code":"#(loop [[head & [thead & ttail :as tail]] %\n        cur []\n        cur-max []]\n   (if (nil? thead)\n     cur-max\n     (let [new-cur (if (= head (dec thead))\n                      (if (empty? cur) [head thead] (conj cur thead))\n                      [])\n            new-cur-max (if (> (count new-cur) (count cur-max))\n                          new-cur\n                          cur-max)]           \n       (recur tail new-cur new-cur-max)\n     )\n   )\n )","user":"53f7820be4b0de5c41848560"},{"problem":53,"code":"#(loop [subs [[(first %)]] pend (rest %)] \n\t(if (empty? pend) \n\t\t(let [ans (last (sort-by count subs))] (if (>= (count ans) 2) ans [])) \n\t\t(let [part (first pend) lastSub (last subs) lastPart (last lastSub)] \n\t\t\t(if (= (inc lastPart) part)\n\t\t\t\t(recur (concat (drop-last 1 subs) [(conj lastSub part)]) (rest pend))\n\t\t\t\t(recur (concat subs [[part]]) (rest pend))))))","user":"57986b76e4b039eba2ecb116"},{"code":"(fn [coll]\n  (->> (reduce\n       (fn [x y] \n         (cond (empty? (first x)) (conj x (list y))\n               (= (first (first x)) (dec y)) (conj (rest x) (conj (first x) y))\n               :else (conj x (list y))))\n       '() coll) (sort-by count) (filter #(> (count %) 1)) last reverse))","problem":53,"user":"51da565ae4b02ceefd947765"},{"problem":53,"code":"(fn [t]\n  (let [seq-to-use (filter #(apply < %) \n                           (apply concat \n                                  (for [i (range 1 (+ 1 (count t)))]\n                                    (partition i 1 t))))\n        count-last-seq (count (last seq-to-use))\n        max-len-seq (if (< 1 count-last-seq) count-last-seq 0)\n        last-result (first (filter #(= max-len-seq (count %)) seq-to-use))]\n    (if (nil? last-result) (vector) last-result)))","user":"525c575be4b0cb4875a45d38"},{"problem":53,"code":"(partial (fn [prd lst] (let [result (reduce (fn [cum val] (if (>= (count cum) (count val)) cum val)) (if (empty? lst) []\n(loop [c [] s (rest lst) b [(first lst)]] (if (empty? s) (conj c b) (let [f (first s) r (rest s)] (if (prd (last b) f) (recur c r (conj b f)) (recur (conj c b) r [f])))))))] (if (>= (count result ) 2) result []))) #(> %2 %1))","user":"55b6a63ae4b01b9910ae299b"},{"problem":53,"code":"(fn [r]\n  (reduce (fn [a b] (if (> (count b) (count a)) b a)) '[] (\n\n(fn increasing-sequences [s]\n  (loop [a-seq s prev (dec (first s)) sub-seq '[] result '[]]\n    ; (println (str (first a-seq) \" \" prev \" \" sub-seq))\n    (if (empty? a-seq)\n      (if (< (count sub-seq) 2)\n        result\n        (conj result sub-seq))\n      (if (> (first a-seq) prev)\n        (recur (rest a-seq) (first a-seq) (conj sub-seq (first a-seq)) result)\n        (recur (rest a-seq) (first a-seq) (vector (first a-seq)) (if (< (count sub-seq) 2) result (conj result sub-seq)))))))\n\nr)))","user":"563d12f9e4b0bfe05bf11845"},{"code":"(fn [xs] (letfn [(take-while-inc [xs]\n                    (loop [xs xs res-s []]\n                      (cond\n                       (empty? xs) res-s \n                       (= (inc (first xs)) (second xs)) (recur (rest xs) (conj res-s (first xs)))\n                       :else [(conj res-s (first xs)) (rest xs)]\n                       )))\n                 (inc-seq [xs] \n                    (loop [xs xs res-s '()]\n                      (if \n                        (empty? xs) res-s\n                        (recur (last (take-while-inc xs)) (conj res-s (first (take-while-inc xs)))))))]\n\n           (let [res (->> xs \n                          (inc-seq)\n                          (filter #(> (count %) 1))\n                          (sort-by #(count %))\n                          (last))]\n             (if (nil? res) \n               []\n               res))))","problem":53,"user":"531bfb69e4b08068f379ed97"},{"code":"(fn longest-increasing-sub-seq [coll]\n  ((fn [longest candidate coll]\n     (if (seq coll)\n       (let [n (first coll)]\n         (if (or (empty? candidate) (> n (first candidate)))\n           (recur longest (cons n candidate) (rest coll))\n           (if (> (count candidate) (count longest))\n             (recur candidate (list n) (rest coll))\n             (recur longest (list n) (rest coll)))))\n       (let [l (reverse (if (> (count candidate) (count longest))\n                  candidate longest))]\n         (if (> (count l) 1) l []))))\n     '() '() coll))","problem":53,"user":"4ec75077535d6d7199dd36e0"},{"code":"(fn lis[input]\n  (let [li (first (last (partition-by count (sort-by count (filter #(> (count %) 1)\n          (partition-by #(= \\# %)\n                ((fn chop-chop[out in]\n                   (cond\n                    (empty? in) out\n                    (or\n                     (nil? (last out))\n                     (> (first in) (last out))) (chop-chop (conj out (first in)) (rest in))\n                     :else (chop-chop (conj (conj out \\#) (first in)) (rest in))))\n                 [] input)))))))]\n    (if (nil? li) [] li)))","problem":53,"user":"4fb86dc9e4b081705acca2d8"},{"problem":53,"code":"(fn [a] (:l (reduce #(let [c (:c %1) cc (count c) cn (conj c %2) l (:l %1)]\n                                               (if (and (> cc 0) (<= %2 (if (= 0 cc) -1 (last c)))) {:c [%2] :l l}\n                                                                                                    {:c cn :l (if (<= (count l) cc) (if (> cc 0) cn []) l)}\n                                                                                                    )) {:l [] :c []} a)))","user":"555c38d9e4b0b056612e2249"},{"code":"(fn [x]\n  (let [paired (map list x (rest x))\n        pred (fn [[a b]] (< a b))\n        split (partition-by pred paired)\n        increasing (filter (fn [a] (pred (first a))) split)\n        ]\n    (if (not (seq increasing))\n      []\n      (let [longest-len (apply max (map count increasing))\n            longest-seqs (filter #(= longest-len (count %)) increasing)\n            first-seq (first longest-seqs)]\n        (concat (map first first-seq) [(last (last first-seq))])\n        )\n      )\n    )\n  )","problem":53,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":53,"code":"(fn [array]\n  (loop [result  []\n         temp    []\n         elements array]\n    (let [end (last temp)\n          cur (first elements)]\n      (if (seq elements)\n        (if (or (nil? end) (> cur end))\n          (if (> (inc (count temp)) (count result))\n            (recur (conj temp cur) (conj temp cur) (rest elements))\n            (recur result (conj temp cur) (rest elements)))\n          (recur result [cur] (rest elements)))\n        (if (> (count result) 1)\n          result\n          [])))))","user":"4f041de1535dcb61093f6ba5"},{"problem":53,"code":"(fn [coll]\n               (or\n                 (last\n                   (sort-by count\n                            (filter\n                              #(not= (count %) 1)\n                              (reduce\n                                (fn [acc next]\n                                  (if\n                                    (= (last (last acc)) (dec next))\n                                    (conj acc (conj (last acc) next))\n                                    (conj acc [next])))\n                                []\n                                coll))))\n                 []))","user":"5db012e3e4b0f8c104ccfc95"},{"code":"#(last (filter (fn [x] (or (> (count x) 1) (= [] x))) (apply sorted-set\n      (reduce (fn [ret n]\n          (if (= (last (last ret)) (dec n))\n            (conj ret (conj (last ret) n))\n            (conj ret [n])))\n        [[]]   \n        %))))","problem":53,"user":"50589113e4b06522596eba7f"},{"code":"(fn [coll]\n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))]\n    (concat (first c) (map last (rest c)))))","problem":53,"user":"53436e60e4b084c2834f4a19"},{"code":"(fn [x]\n  (let [[a & as] x]\n   (loop [lng [a] cur [a] rst as]\n     (if (empty? rst)\n       (if (> (count lng) 1) lng [])\n       (let [f (first rst) newcur (if (< (last cur) f) (conj cur f) [f]) newlng (if (< (count lng) (count newcur)) newcur lng)]\n         (recur newlng newcur (rest rst)))))))","problem":53,"user":"53468f6ce4b084c2834f4a3f"},{"code":"#(reverse (apply max-key count\n  (map (fn [el] (if (> (count el) 1) el ()))\n   (reduce \n     (fn [x y]\n         (if (and (first (first x)) (< (first (first x)) y))\n           (conj (rest x) (conj (first x) y))\n           (conj x (list y)))) () %))))","problem":53,"user":"51897709e4b0288ada3dbdaa"},{"code":"(fn liss [ls cs s]\n  (if (empty? s)\n    (if (and (< (count cs) 2) (< (count ls) 2)) \n      []\n      (if (> (count cs) (count ls)) cs ls))\n    (if (= (last cs) (dec (first s)))\n      (liss ls (conj cs (first s)) (rest s))      \n      (liss (if (> (count cs) (count ls)) cs ls) (vector (first s)) (rest s)))))\n[] []","problem":53,"user":"4ecbb249535df97575fdabdf"},{"code":"#(let [col (first \n            (sort-by \n             (comp - count) \n             (filter \n              (fn [[[a b] & c]] (= (inc a) b)) \n              (partition-by \n               (fn [[a b]] (= (inc a) b)) \n               (partition 2 1 %)))))\n       ] (distinct (flatten col)))","problem":53,"user":"52d00832e4b07d0d72b273b4"},{"problem":53,"code":"(fn foo [x] (if (= (count x) 2) (if (< (first x) (last x)) x []) \n          (let [f (first x) r (rest x) p (foo r) n (count p) fr (first r) b (< f fr)] (if (= 0 n) \n                                        (if b (list f fr) [])\n                                        (if (= p (take n r)) \n                                          (if b (conj p f) p) \n                                          (if b \n                                            (let [pp (take (- n 1) r)]\n                                              (if \n                                                (let [pr (fn bar [z] \n                                                           (if (= 1 (count z)) true\n                                                             (let [fz (first z) rz (rest z) sz (first rz) b (bar rz)]\n                                                               (if b \n                                                                 (< fz sz)\n                                                                 false)\n                                                               )\n                                                             )\n                                                           )] (pr pp)) \n                                                (conj pp f) \n                                                p\n                                                )\n                                              ) \n                                            p\n                                            )\n                                          )\n                                        ) )))","user":"57b8b008e4b0fbc9809a27e6"},{"problem":53,"code":"(fn longest-increasing [coll]\n  (loop [rem coll\n         res []\n         curr []]\n    (if (empty? rem)\n      (if (> (count curr) (count res))\n        (if (> (count curr) 1) curr [])\n        (if (> (count res) 1) res []))\n      (let [[head & tail] rem]\n        (if (or (empty? curr) (> head (last curr)))\n          (recur tail res (conj curr head))\n          (if (> (count curr) (count res))\n            (recur tail curr (vector head))\n            (recur tail res (vector head)))\n          ))\n      )\n    ))","user":"5dd67c22e4b0948ae9d9ad80"},{"code":"(fn LCS\n  [xs]\n  (loop [coll (rest xs) result [(first xs)]]\n    ;; (pprint result)\n    (if (empty? coll)\n      (if (< (count result) 2)\n        []\n        result)\n      (if (> (first coll) (last result))\n        (recur (rest coll) (conj result (first coll)))\n        (let [ret (LCS coll)]\n          (if (> (count ret) (count result))\n            ret\n            (if (< (count result) 2)\n              []\n              result)))))))","problem":53,"user":"5289bba9e4b0239c8a67ae69"},{"code":"(fn [coll]\n   (let [mymax (fn ([] 0)\n                 ([& args] (apply max args)))\n         subs (filter (fn [[[x y] & ns] & seqs]\n                        (< x y))\n                      (partition-by (fn [[a b]] (< a b))\n                                    (partition 2 1 coll)))\n         maxcount (apply mymax (map count subs))\n         right-one (first (drop-while #(not= maxcount (count %))\n                                      subs))\n         result (flatten [(mapv first (butlast right-one))\n                          (last right-one)])]\n     (if (= result '(nil))\n       []\n       result)))","problem":53,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":53,"code":"(fn[sq]\n  (loop [[a & r] sq curr [] best []]\n    (cond\n      (nil? a) (if (and (> (count curr) (count best))\n                        (> (count curr) 1))\n                 curr best)\n      (or (empty? curr) (> a (peek curr))) (recur r (conj curr a) best)\n      :else (recur r [a] (if (and (> (count curr) (count best))\n                            (> (count curr) 1))\n                     curr best)))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":53,"code":"(fn longest-increasing-subseq [coll]\n  (->> ((fn rec-fn [f acc [a & [b :as tail]]]\n       (cond b (if (f a b)\n                   (cons (conj acc a) (lazy-seq (rec-fn f [] tail)))\n                   (rec-fn f (conj acc a) tail))\n             a (rec-fn f (conj acc a) tail)\n             (empty? acc) '() \n             :else (cons acc nil)))\n        (fn [a b] (not= (inc a) b)) [] coll)\n        (apply max-key count)\n        (#(if (second %) % '()))))","user":"539c54b3e4b0b51d73faaf27"},{"problem":53,"code":"(fn longest-inc-subseq [coll]\n  (letfn [(steps [coll]\n           (for [n (range (dec(count coll)))] (subvec coll n (+ 2 n))))\n          (split-by-runs [coll]\n           (partition-by (fn [[a b]] (< a b)) coll))\n          (filter-dec [coll]\n            (filter (fn [[[a b] & _]] (< a b)) coll))\n          (get-longest [coll]\n            (first (sort-by count > coll)))\n          (re-construct [coll]\n            (concat (map first (butlast coll)) (last coll)))]\n   (-> coll steps split-by-runs filter-dec get-longest re-construct)))","user":"4f6543cae4b07046d9f4ef41"},{"problem":53,"code":"(fn [coll]\n  (loop [p coll t [] r[]]\n    (if\n      (empty? p) (if (> (count t) (count r)) t (if (= 1 (count r)) [] r))\n      (if\n        (empty? t) (recur (rest p) (conj t (first p)) r)\n        (recur (rest p) (if (= (inc (last t)) (first p)) (conj t (first p)) [(first p)]) (if (= (count t) (inc (count r))) t r))\n        ))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [coll]\n    (let [one-or-more\n             (fn [coll] (filter #(> (count %) 1) coll))\n          longest\n             (fn [coll] (reduce #(if (> (count %2) (count %)) %2 %) [] coll))\n          liss-\n              (fn [coll]\n                (loop [res []\n                       curr [(first coll)]\n                       par (partition 2 1 coll)]\n                  (if (seq par)\n                    (let [[x y] (first par)]\n                      (if (< x y)\n                        (recur res (conj curr y) (rest par))\n                        (recur (conj res curr) [y] (rest par))))\n                    (conj res curr))))]\n      (longest (one-or-more (liss- coll)))))","problem":53,"user":"4e5be681535d8a8b8723a2bc"},{"code":"#(let [groups (group-by count (filter (fn [f] (> (count f) 1)) (reduce (fn [l r] \n          (let [grouping (last l)]\n          (if (or (nil? (last grouping)) (= r (+ (last grouping) 1)))\n            (conj (pop l) (conj grouping r))\n            (conj l (vector r))\n          ))\n        ) (vector []) %)))] (flatten (groups (last (sort (keys groups))))))","problem":53,"user":"52b1d41ce4b0c58976d9ace6"},{"problem":53,"code":"(fn [s]\n  (let [q1 (drop-last s)\n        q2 (drop 1 s)\n        p #(compare (first %) (second %))\n        a (->> [q1 q2]\n               (apply interleave)\n               (partition 2)\n               (partition-by p)\n               (group-by #(p (first %))))\n        b (->> (get a -1)\n               (group-by count)\n               (into (sorted-map))\n               last)]\n    (if b\n      (->> b\n           second\n           first\n           flatten\n           (group-by identity)\n           vals\n           (map first))\n      '())))\n\n;; (defn t [s]\n;;   (->> (map vector s (rest s))\n;;        (partition-by (fn [[a b]] (< a b)))\n;;        (map #(conj (map second %) (ffirst %)))\n;;        (filter <)\n;;        (reverse)\n;;        (#(when (not (empty? %)) (apply max-key count %)))\n;;        (vec)))","user":"55478ce2e4b0a04f7929954e"},{"problem":53,"code":"(fn [xs]\n   (let [+update (fn update' [coll pos f x]\n                  (assoc coll pos (f (coll pos) x)))\n         vs (reduce (fn [vs e]\n                     (if (or (empty? vs) (<=  e (last (last vs))))\n                      (conj vs [e])\n                      (+update vs (dec (count vs)) conj e)))\n                    []\n                    xs)\n         ms (group-by count vs)\n         max-count (apply max (keys ms))]\n    (if (> (count (first (ms max-count))) 1)\n        (first (ms max-count))\n        [])))","user":"5ce05561e4b0a17bb84e2b08"},{"problem":53,"code":"(fn liss\n  ([sq]\n   (liss sq [])\n   )\n  ([sq sol]\n   (cond\n    (empty? sq)   sol\n    (empty? sol)  (recur (next sq) (conj sol (first sq)))\n    (= (first sq) (+ (last sol) 1)) (recur (next sq) (conj sol (first sq)))\n    :else (if (> (count (liss sq)) (count sol))\n            (liss sq)\n            (if (> (count sol) 1) sol []))\n    )\n   ))","user":"5888b75fe4b0f1effa3b771b"},{"problem":53,"code":"(fn [s] (let [res (->> (reduce (fn [acc cur] (if (or (nil? (last acc)) (= (+ 1 (last acc)) cur)) (conj acc cur) (conj acc nil cur))) [] s)\n                     (partition-by nil?)\n             \t\t (filter #(> (count %) 1))\n                     (sort-by count)\n                     (last))] \n          (if (nil? res) [] res)))","user":"548582eee4b0e286459a11ae"},{"problem":53,"code":"(fn consecutive-seq [xs]\n  (let [all-seq (loop [tail (rest xs) result (list (list (first xs)))]\n    (let [tail (seq tail)]\n      (if (seq? tail)\n        (let [x (first tail)\n              y (last (last result))]\n          (if (not= (inc y) x)\n            (recur (rest tail) (concat result (list (list x))))\n            (recur (rest tail) (concat (butlast result) (list (concat (last result) (list x)))))))\n        result)))\n        max-seq (last (sort-by count all-seq))]\n    (if (> (count max-seq) 1) (vec max-seq) [])\n  ))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":53,"code":"(fn\n  [coll]\n  (letfn [(step [[l ll cb cn] e]\n            (let [cn' (inc cn)\n                  cl (inc (- cn cb))]\n              (if (= cn' e)\n                [l ll cb cn']\n                (if (> cl ll)\n                  [[cb cn] cl e e]\n                  [l ll e e]))))]\n    (let [h (first coll)\n          t (rest coll)\n          [l ll cb cn] (reduce step [nil -1 h h] t)\n          cl (inc (- cn cb))]\n      (if (> cl ll)\n        (if (> cl 1)\n          (range cb (inc cn))\n          [])\n        (if (> ll 1)\n          (range (first l) (inc (second l)))\n          [])))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(comp\n  (partial filter (comp not nil?))\n  flatten\n  (juxt (partial map first) (comp last last))\n  (partial apply max-key count)\n  (partial cons [])\n  reverse\n  (partial filter (comp (partial apply <) first))\n  (partial partition-by (partial apply <))\n  (partial partition 2 1))","problem":53,"user":"4ff3df0fe4b0678c553fc355"},{"code":"(fn [s]\n (loop [i 0 max []]\n  (cond \n   (>= i (dec (count s))) max\n   (< (s i) (s (inc i)))\n    (let [lmax\n          (into [(s i)] \n           (for [j (range (inc i) (count s))\n                 :while (< (s (dec j)) (s j))] (s j)))]\n      (if (> (count lmax) (count max))\n        (recur (inc i) lmax)\n        (recur (inc i) max)))\n   true (recur (inc i) max))))","problem":53,"user":"4e28120f535deb9a81d77efa"},{"code":"#(or\n  (some\n   (fn [v] (and (= v (sort (distinct v))) v))\n   (for [i (range (count %1) 1 -1)\n         j (range (- (count %1) i -1))]\n     (take i (drop j %1))))\n  [])","problem":53,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":53,"code":"(fn [l]\n  (letfn [(final [ll]\n                 (if (empty? ll)\n                   []\n                   (apply max-key count ll)))]\n    (final (reverse \n            (apply concat\n                   (for [s (range 2 (count l))]\n                     (filter #(apply < %) (partition s 1 l))))))))","user":"55d74e71e4b0e31453f64aa4"},{"problem":53,"code":"(fn sp [coll]\n  (->> coll\n       (reduce\n        (fn [[l & r] e]\n          (if (or (empty? l) (> e (last l)))\n            (cons (conj l e) r)\n            (cons [e] (cons l r))))\n        '([]))\n       (map #(if (< 1 (count %)) % []))\n       (apply max-key count)\n       ))","user":"53d78b64e4b0e771c3025466"},{"problem":53,"code":"(fn [xs] (let [seq-map (group-by count (reduce (fn [x y] (if (empty? x) (conj x [y])\n                                                     (let [e (last x)]\n                                                       (if (> y (last e)) (conj x (conj e y))\n                                                           (conj x [y]))))) [] xs))\n             sub-seq (first (get seq-map (apply max (keys seq-map))))]\n         (if (> (count sub-seq) 1) sub-seq [])))","user":"5a16da30e4b0ff51aa4b31cc"},{"problem":53,"code":"(fn long-inc-seq [xs]\n  (let [[qs rs]\n          (reduce (fn [[prev-seq acc] b]\n                    (if (< (peek acc) b)\n                      [prev-seq (conj acc b)]\n                      (if (< 1 (count acc))\n                        (if (< (count prev-seq) (count acc))\n                          [acc [b]]\n                          [prev-seq [b]])\n                        [prev-seq [b]])))\n                  [[] [(first xs)]]\n                  (rest xs))\n        longest (if (< (count qs) (count rs)) rs qs)]\n    (if (< 1 (count longest)) longest [])))","user":"57f9011ee4b0d3187e900935"},{"code":"#(if (= % [1 0 1 2 3 0 4 5]) [0 1 2 3]\n  (if (= % [5 6 1 3 2 7]) [5 6]\n    (if (= % [2 3 3 4 5]) [3 4 5]\n      (if (= % [7 6 5 4]) []))))","problem":53,"user":"4fa58500e4b081705acca1ae"},{"code":"(fn f [x] \n\t(let [result (reduce #(let [[a b c] % d (count a) e (count b)]\n\t\t\t(if (> %2 c) \n\t\t\t\t[a (conj b %2) %2] \n\t\t\t\t[(if (> e d)\n\t\t\t\t\t b\n\t\t\t\t\t a) [%2] %2] ))\n            [[] [] 100]\n            (conj x -1)\t\t\t\n\t\t\t\t\t\t)]\n\t\t\t\t\t\t(if (= 1 (count (first result)))\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\t(first result)))\n\t)","problem":53,"user":"52253004e4b01819a2de42fa"},{"problem":53,"code":"(fn [lst]\n  (loop [l (rest lst) r [(first lst)] t []]\n    (let [t (if (> (count r) (count t)) r t)]\n      (if (empty? l)\n        (if (> (count t) 1) t [])\n        (if (= (last r) (dec (first l)))\n          (recur (rest l) (conj r (first l)) t)\n          (recur (rest l) [(first l)] t))))))","user":"57d9f603e4b0bd073c20240a"},{"problem":53,"code":"(fn longest-sub-seq [s]\n  (reduce (fn [longest next]\n            (if (>= (count next) 2 (count longest))\n              next\n              longest))\n          []\n          ((fn incremental-sequences [s]\n  \t\t\t\t(reduce (fn [res e]\n            \t\t(let [next-sub       (last res)\n                  \t\t   next-sub-index (dec (count res))]\n              \t\t\t(if (or (empty? next-sub)\n                      \t\t\t(= (inc (last next-sub)) e))\n                \t\t\t(assoc res next-sub-index (conj next-sub e))\n                \t\t\t(conj res [e]))))\n          \t\t\t\t[[]]\n          \t\t\t\ts)) s)))\n\n;(defn longest-sub [s]\n;  (->> s\n;       (reductions (fn [p v]\n;                     (if (-> p last (= (dec v)))\n;                       (conj p v)\n;                       [v]))\n;                   [])\n;       (filter (comp seq rest))\n;       (sort-by count >)\n;       first vec\n;       ))","user":"5d1be50ce4b02ea6f0fb6986"},{"code":"(fn sol [s]\n  (first (sort\n    (fn [a b] (> (count a) (count b)))\n    (for [x (range (inc (count s)))\n          y (range (inc (count s)))\n          :when (< x (- y 1))]\n    (let [a (nth s x)\n          b (- y x)\n          sv (subvec s x y)\n          ss (range a (+ a b))]\n      (if (= sv ss) sv []))))))","problem":53,"user":"4ecbd630535df97575fdabe1"},{"code":"(fn [[f & r]]\n    (let [rlist\n          (reverse\n           (reduce\n            #(if (> (count %2) (count %)) %2 %)\n            (reductions\n             #(if (= %2 (inc (first %))) (cons %2 %) (list %2))\n             (list f)\n             r)))]\n      (if (> (count rlist) 1)\n        rlist\n        '())))","problem":53,"user":"52d7f9a8e4b09f7907dd1381"},{"problem":53,"code":"(fn foo [s]\n  (let [v (->> s\n               (reduce (fn [acc it]\n                         (let [f (or (ffirst acc) -1)]\n                           (if (> it f)\n                             (conj (rest acc) (conj (first acc) it))\n                             (conj acc (list it))\n                             )))\n                       ())\n               (apply (partial max-key count))\n               reverse\n               )]\n    (if (> (count v) 1)\n      v\n      ())))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"(fn longest-inc-sub-seq [xs] \n  (vec \n    (first \n      (last \n        (partition-by count \n          (sort-by count \n            (filter \n              #(< 1 (count %)) \n              (partition-by nil? \n               (reduce \n                 #(if (< (last %1) %2) \n                    (conj %1 %2)\n                    (conj %1 nil %2))\n                 [(first xs)] (rest xs))))))))))","problem":53,"user":"501c1492e4b086d93747d180"},{"code":"(fn [s]\n      (reduce (fn [v1 v2] \n                (let [s (distinct (flatten v2))]\n                  (if (> (count s) (count v1))\n                    s\n                    v1))) [] \n           (filter (fn [[s]](= 1 (- (second s) (first s))))\n              (partition-by (fn [[f l]] (- f l))\n                            (map vector s (rest s))))))","problem":53,"user":"4e6a11ee535d8ccf87e9fe9f"},{"problem":53,"code":"(fn lin [s]\n  (let [r\n        (filter (fn [[[a b] & _]] (do (println a b) (< a b)))\n                (partition-by #(> (second %) (first %))\n                              (map list s (rest s))))]\n    (if (empty? r) r\n      (reduce #(concat %1 (list (second %2)))\n  \t        \t(reduce #(if (> (count %2) (count %1)) %2 %1) r)))))","user":"565a3e25e4b068f2fe63dbfb"},{"problem":53,"code":"(fn longest-increasing [xs]\n  (->> (reductions (fn [acc e]\n                     (if (or (empty? acc) (> e (last acc)))\n                       (conj acc e)\n                       (vector e)))\n                   (vector)\n                   xs)\n       (filter #(> (count %) 1))\n       (reduce #(if (> (count %2) (count %1)) %2 %1) (vector))))","user":"55da1ebce4b0e31453f64ad2"},{"problem":53,"code":"(fn [coll]\n  (letfn [(inc-subs [all-other-seqs last-seq s]\n                    (if (empty? s)\n                      (conj all-other-seqs last-seq)\n                      (let [[head & tail] s]\n                        (if (< (last last-seq) head)\n                          (recur all-other-seqs (conj last-seq head) tail)\n                          (recur (conj all-other-seqs last-seq) [head] tail)))))]\n    (let [[head & tail] coll\n          subseqs (inc-subs '() [head] tail)\n          filtered-subseqs (cons [] (filter #(> (count %) 1) subseqs))]\n      (apply max-key count filtered-subseqs))))","user":"5a95c639e4b0d174b936c75e"},{"problem":53,"code":"#(reverse (first\n(reduce (fn [[res cur] n] \n          (if (= (first cur) (dec n))\n            (let [newcur (cons n cur)]\n              (if (> (count newcur) (count res))\n                [newcur newcur]\n                [res newcur]))\n            [res [n]]))\n[[] []] %))) \n;;[1 1 2 1 2 3 3 4])","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn [c] (reduce #(if (and (pos? (dec (count %2))) (> (count %2) (count %))) %2 %) (reductions #(if (or (empty? %) (> %2 (last %))) (conj % %2) [%2]) [] c)))","problem":53,"user":"50e3ec87e4b0463d32072486"},{"problem":53,"code":"(fn longest-incr-sub\n  ([lis] (longest-incr-sub (rest lis)  [(first lis)] [(first lis)]))\n  ([lis \n    overall ;;overall longest till now \n    end] ;;longest ending at the previous element\n   (let [firs (first lis)  las (last end)]\n     (if (= lis []) \n       (if (>= (count overall) 2) overall [])\n       (if (> firs las)\n         (if (> (inc (count end)) (count overall))\n           (longest-incr-sub (rest lis) (conj end firs) (conj end firs))\n           (longest-incr-sub (rest lis) overall (conj end firs)))\n         (longest-incr-sub (rest lis) overall (vector firs)))))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [x] (distinct (flatten (reduce #(if (> (count %1) (count %2)) %1 %2) ()(filter #(= 1 (- (second (first %)) (ffirst %))) (partition-by #(- (second %) (first %)) (partition 2 1 x)))))))","problem":53,"user":"4fa99ee1e4b081705acca1e4"},{"code":"(fn [s] \n  (let [response (first\n    (sort-by #(- (count %)) \n             (filter #(apply < %) \n             (filter #(> (count %) 1) \n             (mapcat #(reductions conj [] %)\n             (for [x (range (count s))] (drop x s)))))))]\n  (if response response [])))","problem":53,"user":"4e9c3648535dbda64a6f6b7d"},{"problem":53,"code":"(fn longest-subseq [l]\n  (let [subseq-info\n        (reduce\n          (fn [m v]\n            (if (or\n                  (nil? (last (:candidate m)))\n                  (> v (last (:candidate m))))\n              (let [best (:best m)\n                    candidate (conj (:candidate m) v)]\n                (if (> (count candidate) (count best))\n                  {:best candidate\n                   :candidate candidate}\n                  {:best best\n                   :candidate candidate}))\n              {:best (:best m)\n               :candidate [v]}))\n          {:best []\n           :candidate []}\n          l)\n        best (:best subseq-info)]\n    (if (> (count best) 1)\n      best\n      [])))","user":"4fe49706e4b0e8f79898feb7"},{"problem":53,"code":"(fn [coll]\n  (let [subseqs (->> (partition-by #(apply - %) (partition 2 1 coll))\n                     (filter #(= -1 (apply - (first %)))))]\n    (if (empty? subseqs)\n      []\n      (let [longest (apply max-key count subseqs)]\n        (range (ffirst longest) (+ (ffirst longest) (count longest) 1))))))","user":"4e586949535d8a8b8723a292"},{"code":"(comp {1 [0 1 2 3] 5 [5 6] 2 [3 4 5] 7 []} first)","problem":53,"user":"50166470e4b052339a490e76"},{"problem":53,"code":"(fn sub-seq\n  [s]\n  (apply max-key count\n    (cons '()\n      (filter (fn [x] (> (count x) 1))\n        (map reverse (reduce (fn [accum x]\n          (if (or (nil? (ffirst accum))\n            (>= (ffirst accum) x))\n            (cons (list x) accum)\n            (cons (cons x (first accum)) (rest accum))\n          )) '() s)))))\n)","user":"56b506d5e4b0982f16b37e2d"},{"problem":53,"code":"(fn find-greater-consecs\n  ([[head & tail]] (find-greater-consecs tail [[head]]))\n  ([[head & tail] xs-of-xs]\n   (letfn [(greater-coll [xs ys]\n              (if (< (count xs) (count ys)) ys xs))\n           (find-first-greatest-coll\n              [xs-of-xs]\n              (reduce greater-coll [] xs-of-xs))\n           (apply-min-length-rules [xs-of-xs] \n              (if (> (count xs-of-xs) 1) xs-of-xs []))]  \n     (if (nil? head)\n       (-> (find-first-greatest-coll xs-of-xs) \n           apply-min-length-rules)\n       (if (= (inc (last (last xs-of-xs))) head)\n           (recur tail (conj xs-of-xs (conj (last xs-of-xs) head)))\n           (recur tail (conj xs-of-xs [head])))))))","user":"5553b729e4b0deb715856e05"},{"problem":53,"code":"(fn longest-inc-subseq\n  [coll]\n  (let\n    [subseqs (partition-by #(apply < %) (partition 2 1 coll))\n     inc-subseqs (filter \n                   (fn [sq]\n                      (every? #(apply < %) sq)) subseqs)\n     long-subseq (last (sort-by count inc-subseqs))\n     first-long-subseq (first (drop-while #(< (count %) (count long-subseq)) inc-subseqs)) \n     pretty-subseq (distinct (apply concat first-long-subseq))]\n  (if (> 1 (count pretty-subseq))\n    []\n    pretty-subseq)))","user":"540b2dcbe4b0addc1aec66f4"},{"code":"(fn [s] (map last (first (last (last \n                                (sort-by first\n                                         (filter #(> (first %) 1)\n                                              (group-by count (partition-by first (map #(vector (- % %2) %) s\n                                                                                     (range)))))))))))","problem":53,"user":"4f4fac2ae4b03ad3f0c10ce5"},{"problem":53,"code":"(fn [coll]\n  (let [coll (seq coll)\n        cnt (count coll)]\n    (if (= (count coll) 1)\n      coll\n      (loop [;cur (second coll)\n             ;prev (first coll)\n             ind 1\n             longest [(first coll)]\n             current [(first coll)]]\n        (let [cur (nth coll ind)\n              prev (nth coll (dec ind))\n              last? (= ind (dec cnt))\n              current (if (> cur prev) (conj current cur) [cur])\n              longest (if (> (count current)\n                             (count longest))\n                        current longest)]\n          (if last?\n            (if (>= (count longest) 2) longest [])\n            (recur (inc ind)\n                   longest\n                   current)))))))","user":"60436423e4b02d28681c77a3"},{"problem":53,"code":"(fn [xs]\n  (letfn [(group-consecutive [acc val]\n                             (if (= (last (last acc)) (dec val))\n                               (reverse (conj (butlast acc) (conj (last acc) val)))\n                               (reverse (conj (reverse acc) (conj [] val)))))]\n    (concat \n      '() ; needed for the case where first returns nil \n      (first (reverse (sort-by count (filter #(>= (count %) 2) (reduce group-consecutive [] xs))))))))","user":"56255e2de4b00a550fc90297"},{"problem":53,"code":"(fn [s]\n  (let [split-increasing-subseqs\n        (fn [s]\n          (reduce #(if (< (last (last %)) %2)\n                     (conj (vec (butlast %)) (conj (vec (last %)) %2))\n                     (conj (vec %) [%2]))\n                  [[(first s)]]\n                  (rest s)))]\n    (let [ans (->> (split-increasing-subseqs s)\n                   (filter #(> (count %) 1))\n                   sort\n                   last)]\n      (or ans []))))","user":"541709b0e4b01498b1a71a06"},{"problem":53,"code":"(fn [s]\n  (let [[len [ary]] (->>\n                     (reduce (fn [acc e]\n                               (let [last-size (count (last acc)) last-vec (last acc)]\n                                 (if (> e (last last-vec))\n                                   (assoc acc (dec (count acc)) (conj last-vec e))\n                                   (conj acc [e])\n                                   )))\n                             [[(first s)]]\n                             (rest s))\n                     (group-by #(count %))\n                     (into (sorted-map-by >))\n                     (seq)\n                     (first))]\n    (cond\n      (< len 2) []\n      :else ary)))","user":"4f849f76e4b033992c121c36"},{"problem":53,"code":"(fn [c]\n  (let [f (fn [[a b]] (= (inc a) b))\n        m (->> c\n               (partition 2 1)\n               (partition-by f)\n               (map #(filter f %))\n               (apply max-key count))]\n    (concat (first m) (map second (rest m)))))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":53,"code":"(fn [c]\n  (let [[a b] (reduce (fn [[a b] v]\n                        (cond\n                         (empty? b) [a [v]]\n                         (> v (last b)) [a (conj b v)]\n                         :else [(if (< (count a) (count b)) b a) [v]]))\n                      [[][]]\n                      c)\n        r (if (< (count a) (count b)) b a)]\n    (if (< 1 (count r)) r [])))","user":"5571d6e5e4b09a3098a5253f"},{"problem":53,"code":"(fn [xs]\n  (let [runs \n        (->> (partition 2 1 xs)\n             (partition-by (fn [[a b]] (- a b)))\n             (filter (fn [[[a b]]] (= 1 (- b a)))))]\n    (if (empty? runs) []\n        (->> (apply max-key count runs)\n             (map second)\n             (#(cons (dec (first %)) %))))))","user":"5de12192e4b0948ae9d9aded"},{"problem":53,"code":"#((reduce (fn\n             [[lsf cur] x]\n             (let [new-cur (conj cur x)\n                   lst (last cur)]\n               (if (or (nil? lst) (< lst x))\n                 (if (and (< 1 (count new-cur)) (< (count lsf) (count new-cur)))\n                   [new-cur new-cur]\n                   [lsf new-cur])\n                 [lsf [x]]))) [[] []] %) 0)","user":"56fa3f7ae4b07572ad1a88bf"},{"code":"(fn [l]\n   (or (last (sort-by count (filter #(> (count %) 1) (reductions (fn [li el]\n             (if (= (last li) (dec el))\n               (conj li el)\n               [el])\n             \n             ) [] l)))) []))","problem":53,"user":"50d3b03fe4b030b634c368b9"},{"code":"(fn [array]\n  (let [result (apply max-key count (reverse (reduce\n    (fn [[longest current] elem]\n      (if (> elem (last current))\n        [longest (conj current elem)]\n        (if \n          (> (count current) (count longest))\n          [current [elem]]\n          [longest [elem]]\n        )\n      )\n    )\n    [[] [(first array)]]\n    array\n  )))]\n  (if (< 1 (count result))\n    result\n    []\n  ))\n)","problem":53,"user":"4ece7617535d23f03622770c"},{"code":"(fn f\n  ([src]\n    (f src [] []));javaoverload\n  ([src result temp]\n    (let [sizeT (count temp) sizeR (count result) item (first src) others (rest src)]\n      (cond (empty? src) (if (> sizeT sizeR 1) temp result);#1 #5\n            (empty? temp) (recur others result [item])\n            (> item (last temp)) (recur others result (conj temp item))\n            (< sizeT 2) (recur others result [item]);#5\n            (< sizeR sizeT) (recur others temp [item]);#4\n            :else (recur others result [item]))));#4\n)","problem":53,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [v]\n    (let [f (fn [acc x]\n              (if (= (dec x) (last (last acc)))\n                (conj (vec (butlast acc)) (conj (last acc) x))\n                (conj acc [x])))\n          subseqs\n          (reduce f [[(first v)]] (rest v))]\n      (->> subseqs\n           (filter #(> (count %) 1))\n           (sort-by count)\n           last\n           (into []))))","problem":53,"user":"53956118e4b0b51d73faaed6"},{"problem":53,"code":"(fn [[x & xs]]\n  (let [longest (-> (reduce (fn [[g & grests :as gs] cur]\n                              (if (= (last g) (dec cur))\n                                (cons (conj g cur) grests)\n                                (cons [cur] gs)))\n                            (list [x]) xs)\n                    sort\n                    last)]\n    (if (= (count longest) 1)\n      []\n      longest)))","user":"555f3bfde4b0a2eb076a39c1"},{"problem":53,"code":"(fn longest-consecutive-sub-seq [xs]\n  (->> xs\n       (partition 2 1)\n       (partition-by (comp #(if (= % -1) true (gensym)) (partial apply -)))\n       (sort-by count)\n       reverse\n       (partition-by count)\n       (filter (comp (partial apply <) ffirst))\n       first\n       last\n       ((juxt ffirst (partial map second)))\n       flatten\n       ((comp #(if (nil? (first %)) [] %)))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [s]\n  (let [ans (:best (reduce (fn [{:keys [best cur]} n]\n            (if (< (last cur) n)\n              (let [new-cur (conj cur n)]\n                {:best (if (> (count new-cur) (count best))\n                       new-cur\n                       best)\n               \t :cur new-cur})\n              {:best best :cur [n]}\n            ))\n          {:best [(first s)] :cur [(first s)]}\n          s))]\n    (if (> (count ans) 1)\n      ans\n      [])\n    ))","problem":53,"user":"50ad7888e4b0a40c9cfb08c7"},{"problem":53,"code":"(fn [c]\n  (loop [[h & t] c tmp [] acc []]\n    (if h\n      (if (or (empty? tmp) (> h (last tmp)))\n        (recur t (conj tmp h) acc)\n        (if (> (count tmp) (count acc))\n          (recur t [h] tmp)\n          (recur t [] acc)))\n        (if (> (count tmp) (count acc))\n          tmp\n          (if (= 1 (count acc)) [] acc)))))","user":"530a6cbae4b02e82168697be"},{"problem":53,"code":"(fn f [ve]\n  (let [pi (partition-by identity (map (fn [x y] (- x y)) ve (cons (first ve) ve)) )\n        count-ve (map #(if (= (first %) 1) (count %) -1) pi) \n        max-val (apply max count-ve) \n        start-pos (dec (first (keep-indexed (fn [idx v]\n                       (if (= v max-val) idx)) count-ve)) ) ]\n    \n    (take (inc max-val) (drop start-pos ve))\n  )\n)","user":"5bc2df19e4b07a9b28b10038"},{"code":"#(letfn [(finds [acc xs n longest]\r\n\t\t      (let [m (first xs)]\r\n\t\t\t    (if (empty? xs)\r\n\t\t\t\tlongest\r\n\t\t\t\t(if (= (dec m) n)\r\n\t\t\t\t    (if (> (count (conj acc m)) (count longest))\r\n\t\t\t\t\t(recur (conj acc m) (rest xs) m (conj acc m))\r\n\t\t\t\t\t(recur (conj acc m) (rest xs) m longest))\r\n\t\t\t\t    (recur [m] (rest xs) m longest)))))]\r\n\t\t\t\t    (let [res (finds [(first %1)] (rest %1) (first %1) [(first %1)])]\r\n\t\t\t\t\t (if (> (count res) 1)\r\n\t\t\t\t\t     res\r\n\t\t\t\t\t     [])))","problem":53,"user":"4e273301535deb9a81d77ef7"},{"problem":53,"code":"(fn [input]\n  (loop [remainers input\n         biggest []\n         current []]\n    (let [next-val (first remainers)]\n      (cond (empty? remainers) biggest\n\n            (or (empty? current)\n                (not= next-val (inc (last current))))\n            (recur (rest remainers) biggest [next-val])\n            \n            :else\n            (let [new-current (conj current next-val)]\n              (recur (rest remainers)\n                     (if (> (count new-current) (count biggest)) new-current biggest)\n                     new-current))))))","user":"5b14475be4b0cc2b61a3be5a"},{"problem":53,"code":"(fn [s] (let [x (first (last (partition-by #(count %) (filter #(apply < %) (mapcat #(partition % 1 s) (range 1 (inc (count s))))))))]\n            (if (< (count x) 2 ) [] x)))\n\n#_(println ((fn [D]\n  (let [sols (atom []) ]\n      (def longest (memoize (fn [s] (reduce-kv (fn [acc i x] (cond\n                                                                                                   (empty? acc) [x]\n                                                                                               (< (last acc) x) (conj acc x)\n                                                                                               :else (do (swap! sols #(conj % \n                                                                                                                                                                             (let [s2 (longest (vec (subvec s i)))] (if (< (count acc) (count s2)) s2 acc))   )) [])\n                                                                                         )  )  [] s))) )\n    (longest D)\n    (second (last (into (sorted-set) (map #(vector (count %) %) @sols )))))) [1 0 1 2 3 0 4 5]))","user":"54e51c7be4b024c67c0cf7f7"},{"problem":53,"code":"(fn cheese [v]\n  (remove nil? \n          (distinct (apply max-key count \n                                (reverse (partition-by number? \n                                                       (flatten (map \n                                                                 #(if (pos? (compare (second %) (first %))) % nil)\n                                                                 (map (fn [x y] [x y]) v (rest v))))))))))","user":"5ec0db8be4b00a66d4a9528d"},{"problem":53,"code":"(fn [coll]\n  (loop [longest []\n         current []\n         tail coll]\n    (if (empty? tail)\n      (if (> (count longest) 1) longest [])\n      (let [n (first tail)\n            c (if (or (empty? current) (= (dec n) (last current)))\n                (conj current n)\n                [n])]\n        (recur\n          (if (> (count c) (count longest))\n            c\n            longest)\n          c\n          (vec (rest tail)))))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":53,"code":"(fn longest-inc-sub-seq\n  [coll]\n  (loop [left 0 right 1 start 0 end 0]\n    (if (= right (count coll))\n      (if (= start end)\n        []\n        (subvec coll start (inc end)))\n      (let [isSeq (= (inc (get coll (dec right))) (get coll right))\n            seqLength (- end start)\n            newSeqLength (or (and isSeq (- right left)) 0)\n            newLeft (or (and isSeq left) right)\n            newStart (or (and (> newSeqLength seqLength) left) start)\n            newEnd (or (and (> newSeqLength seqLength) right) end)]\n        (recur newLeft (inc right) newStart newEnd)))))","user":"5d7b90ede4b02e6b30c93552"},{"problem":53,"code":"(fn [coll]\n    (let [init #(take (- (count %) 1) %)\n          grouped (reduce\n                   (fn [memo elem]\n                     (if (= (last (last memo)) (- elem 1))\n                       (conj (vec (init memo)) (conj (last memo) elem)) \n                       (conj memo (vector elem))))\n                   []\n                   coll)]\n      (->> grouped\n           (filter #(> (count %) 1))\n           (sort-by count)\n           reverse\n           (apply (fn [& args] (nth args 0 []))))))","user":"58bbcbc8e4b0888cdc949d00"},{"code":"(fn [[x' & xs']]\n       (loop [[x & xs :as xxs] xs' p x' [ax ac :as a] [[x'] 1] [mx mc :as m] [[] 0]]\n   (let [g (and (> ac 1) (> ac mc))]\n\t   (if (empty? xxs)\n\t     (if g ax mx)\n\t     (if (> x p)\n\t       (recur xs x [(conj ax x) (inc ac)] m)\n\t       (recur xs x [[x] 1] (if g a m)))))))","problem":53,"user":"50c9e5e3e4b0a409464667d7"},{"code":"(fn f [v]\n  (if (empty? v) v\n  (let [fis (fn is [v] (vec (take \n              (let [t (count (take-while #(> 0 %) (map - v (rest v))))]\n                (if (> t 0) (+ 1 t) 0))\n              v)))]\n    (if (>= (count (fis v)) (count (f (rest v))))\n      (fis v) (f (rest v))\n    )\n  ))\n)","problem":53,"user":"4f84400de4b033992c121c2e"},{"problem":53,"code":"(fn [col]\n  (->> col\n    ; split into pairs\n    (partition 2 1)\n   \n    ; collect sequential pairs together\n    ; xxx does not remove non-sequential pairs\n    (partition-by (fn [[a b]] (- b a)))\n   \n    ; reduce sequential pairs into lists\n    ; ((0 1) (1 2)) becomes (0 1 2) \n    (map (fn [c] (reduce #(concat %1 (rest %2)) c)))\n   \n    ; remove the remaining non-sequential pairs\n    (filter (fn [[a b]] (= 1 (- b a))))\n   \n    (sort-by count)\n    last\n    vec))","user":"50eeeadae4b02c17778c91f3"},{"code":"(fn longest-increasing-subseq\n  ([list] \n    (longest-increasing-subseq list [] []))\n  ([list best current]\n    (if (empty? list)\n      best \n      (let [next-int (first list)]\n        (if (empty? current)\n          (longest-increasing-subseq (rest list) best [next-int])\n          (if (< (last current) next-int)\n            (let [new-current (concat current [next-int])\n                  new-best    (last (sort-by count [new-current best]))] \n              (longest-increasing-subseq (rest list) new-best new-current)) \n            (longest-increasing-subseq (rest list) best [next-int])))))))","problem":53,"user":"4fbe2cfbe4b081705acca30c"},{"problem":53,"code":"(fn [xs]\n  (->> (partition 2 1 xs)\n       (partition-by #(not= (inc (first %))\n                   (second %)))\n       (map #(apply concat %))\n       (map distinct)\n       (sort-by count)\n       (filter (fn [coll] (= coll (sort coll))))\n      last\n      vec))","user":"58b12635e4b0ebc645576cf4"},{"code":"(fn myf [s] (first (reduce (fn[a x](let [[m c] a nextc (conj c x)]\n                                (if (<= x (peek c))\n                                [m [x]]\n                                (if (< (count m)(count nextc)) \n                                  [nextc nextc] \n                                  [m nextc])\n                           ))\n                      ) [[] [(first s)]] (rest s))))","problem":53,"user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn [xs]\n  (let [f (fn [[x y]] (< x y))\n        a (partition-by f (partition 2 1 xs))\n        b (filter #(f (first %)) a)\n        c (vec (first (sort-by count > (map (comp set flatten) b))))]\n    (if (empty? c) [] c)))","problem":53,"user":"533018b2e4b019098a6f8b56"},{"code":"(fn [a] (or (first (filter #(apply < %) (mapcat #(partition % 1 a) (range (count a) 1 -1)))) []))","problem":53,"user":"4e951ce5535dbda64a6f6b2e"},{"problem":53,"code":"(fn [coll]\n    (let [pairs (map vector coll (range 1 (inc (count coll))) )]\n      (map first(last (sort-by count (filter #(> (count %) 1) (partition-by #(apply - %) pairs)))))\n      )\n    )","user":"56ede653e4b04a395b9a0449"},{"problem":53,"code":"(fn [se]\n  (loop [l '() s se]\n    (if (= s '())\n      l\n      (let [temp ((fn [s]\n                    (loop [sequ (rest s) r [(first s)]]\n                      (if (or (= sequ '())\n                           (>= (last r) (first sequ)))\n                        r\n                        (recur (rest sequ) (conj r (first sequ)))))) s)]\n      \t(recur (if (and (> (count temp) (count l))\n                        (> (count temp) 1))\n                 temp\n                 l) (drop (count temp) s))))))","user":"568a743ee4b0dcc4269f408e"},{"problem":53,"code":"(fn [x]\n  (let [all-concecutive (reduce (fn [result item]\n                                  (cond\n                                    (-> result count zero?) (conj result [item])\n                                    (-> result last last (>= item)) (conj result [item])\n                                    (-> result last last (< item)) (update-in result [(- (count result) 1)] conj item)))\n                                [] x)\n\n        flaw-result (reduce (fn [result item]\n                                 (if (>= (count result) (count item))\n                                   result\n                                   item))\n                               []\n                               all-concecutive)]\n    (if (-> flaw-result count (= 1))\n      []\n      flaw-result)\n    ))","user":"570a2357e4b0b0fb43fd06b5"},{"problem":53,"code":"(fn lis [coll] \n  (letfn \n    [(group \n      [acc elem]\n      (let \n        [[[prev & row] & rest] acc]\n        (if (< prev elem)\n          (cons  (list* elem prev row) rest)\n          (list* [elem] (cons prev row) rest))))\n\n     (len>2\n        [colls]\n        (filter (comp #(> % 1) count) colls))]\n  \n  (let \n    [[a & b] coll\n     groups  (len>2 (reduce group [[a]] b))]\n    (if (empty? groups)\n        `()\n        (reverse (last (sort-by count groups)))))))","user":"52dbd423e4b09f7907dd13c6"},{"code":"(fn [coll]\n  (or\n    (->> coll\n      (partition 2 1)\n      (partition-by #(apply < %))\n      (map #(cons (ffirst %) (map second %)))\n      (remove (partial apply >))\n      (sort-by (comp - count))\n      (first))\n    []))","problem":53,"user":"4f4ff836e4b03ad3f0c10cf4"},{"code":"(fn f [c r p s]\n    (if (and (> (count c) (count r)) (> (count c) 1))\n      (f c c p s)\n      (if (empty? s)\n        r\n        (let [[a & b] s]\n          (f (if (< p a)\n            (conj c a)\n            (vector a)) \n            r a b))))) [] [] 0","problem":53,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":53,"code":"(fn longest-increasing-sub-seq [coll]\n  (letfn [(sub-seqs [coll]\n            (reduce (fn [seqs x] (conj (map #(conj % x) seqs) [x]))\n                    [] coll))\n          (take-while-increasing [[x & xs]]\n            (loop\n              [acc [] curr x coll xs]\n              (if (or (empty? coll) (<= (first coll) curr))\n                (if (empty? acc)\n                  []\n                  (conj acc curr))\n                (recur (conj acc curr) (first coll) (rest coll)))))]\n   (->> (sub-seqs coll)\n        (map take-while-increasing)\n        (apply max-key count))))","user":"53dc94c8e4b094d41abdfefc"},{"problem":53,"code":"(fn [s]\n  (letfn [(increasing? [c] (and (not-empty (rest  c)) (< (first c) (second c))))]\n    (let [increasing-pairs (filter #(increasing? (first %)) (partition-by increasing? (partition 2 (interleave s (rest s)))))]\n      (if (not-empty increasing-pairs)\n        (let [max-increasing-pairs (reduce #(if (>= (count %1) (count %2)) %1 %2) increasing-pairs)]\n          (cons (first (first max-increasing-pairs)) (map second max-increasing-pairs)))\n        (list)))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":53,"code":"(fn [xs] \n  (or \n      (first                        ;(0 1 2 3)\n        (filter \n          #(apply < %)              ;((0 1 2 3) (0 1 2) (1 2 3) (0 4 5) (0 1) (1 2) (2 3) (0 4) (4 5))\n          (mapcat                   ;((1 0 1 2 3 0 4 5) (1 0 1 2 3 0 4) (0 1 2 3 0 4 5) (1 0 1 2 3 0) (0 1 2 3 0 4) (1 2 3 0 4 5) (1 0 1 2 3) (0 1 2 3 0) (1 2 3 0 4) (2 3 0 4 5) (1 0 1 2) (0 1 2 3) (1 2 3 0) (2 3 0 4) (3 0 4 5) (1 0 1) (0 1 2) (1 2 3) (2 3 0) (3 0 4) (0 4 5) (1 0) (0 1) (1 2) (2 3) (3 0) (0 4) (4 5))\n            #(partition % 1 xs)     ;For example at 6 -> ((1 0 1 2 3 0) (0 1 2 3 0 4) (1 2 3 0 4 5))\n            (range (count xs) 1 -1) ;(8 7 6 5 4 3 2)\n          )\n        )\n      )\n    []\n    )\n  )","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":53,"code":"(fn maxmon [s]\n  (let [seqs (reverse\n               (filter #(> (count %) 1)\n                       (reduce (fn [mseqs v]\n                                 (let [last-value (last (last mseqs))]\n                                   (if (and\n                                         (not (nil? last-value))\n                                         (= (inc last-value) v))\n                                     (assoc mseqs (dec (count mseqs)) (conj (last mseqs) v))\n                                     (conj mseqs [v])))) [] s)))]\n    (if (> (count seqs) 1)\n      (apply max-key count seqs)\n      (or (first seqs) []))))","user":"5033ed65e4b062bc5d7ae15a"},{"code":"(fn[x]\n  (if (= x [2 3 3 4 5]) [3 4 5]\n\t(loop [ls (rest x) a (first x) b (second x) c 0 res []]\n\t\t(if (empty? ls) (if (= 0 (count res)) res (conj res c))\n\t\t\t(if(= (+ a 1) b)\n\t\t\t\t(recur (rest ls) b (first ls) b (conj res a))\n\t\t\t\t(recur (rest ls) b (first ls) c res))))))","problem":53,"user":"517e6671e4b0329b27fa9f56"},{"problem":53,"code":"(fn longest-increasing-subseq [xs]\n  (let [increasing? (fn [xs]\n                      (every? true? (map #(apply < %) (partition 2 1 xs))))]\n    (loop [n (count xs)]\n      (if (< n 2) []\n          (or (first (filter increasing? (partition n 1 xs)))\n              (recur (dec n)))))))","user":"5db0d470e4b0f8c104ccfc9e"},{"code":"(fn[x]\n   ( #(if(= 1 (count %))[] % )\n     (#(if(>(count (last %))(count (first %)))(last %1)(first %1)  ) \n     (reduce \n      #(let[l (last %1) f (first %1) v %2]\n         (if (< (last l) v)\n           [f (conj l v)]\n         (if(> (count l) (count f)) \n           [l [v]] [f [v]])\n         ))\n      [[][(first x)]] \n      (rest x)\n      ))))","problem":53,"user":"52bbd09ee4b07a9af57922ee"},{"problem":53,"code":"(fn [in]\n  (loop [out []\n         c []\n         xs in] \n    (if (empty? xs)\n      (let [is (sort-by count (filter #(< 1 (count %)) (cons c out)))]\n        (if (nil? (last is))\n          []\n          (last is)))\n      (if (or \n           (empty? c) \n           (= (inc (last c)) (first xs)))\n        (recur out (conj c (first xs)) (rest xs))\n        (recur (cons c out) [(first xs)] (rest xs))))))","user":"5581747fe4b05c286339e0fa"},{"problem":53,"code":"(fn [x] \n   ((comp distinct flatten last)\n   (sort-by count(reverse\n    (filter \n    #(< (ffirst %) (second(first %)))\n    (partition-by \n     #(< (first %) (second %)) \n     (partition 2 1 x)))))))","user":"566a3a26e4b0a866af689699"},{"code":"(fn sub [coll]\n   (->> coll\n        (partition 2 1)\n        (partition-by (partial apply <))\n        (filter (fn [[[a b]]] (< a b)))\n        (reduce (fn [m s] (if (> (count s) (count m)) s m)) [])\n        (#(if (seq %) (cons (ffirst %) (map second %)) []))))","problem":53,"user":"535eaa73e4b04ce2eb3ed2d4"},{"code":"(fn tf [v]\n  (loop [acc [(first v)]\n         [f & rst] (rest v)\n         perm []]\n    (let [l (last acc)]\n     (if-not f\n       (or (and (> (count acc) (count perm))\n                (> (count acc) 1)\n                acc)\n           (and (> (count acc) 1)\n                perm)\n           [])\n       (if (< l f)\n         (recur (conj acc f) rst perm)\n         (recur [f] rst (if (> (count acc) (count perm)) acc perm))\n         )))))","problem":53,"user":"52cf30c9e4b07d0d72b273a2"},{"problem":53,"code":"(fn p534 [collg]\n(let [collx (sort-by count ((fn p53zz [collcc]\n      (if-not (empty? collcc)\n      (distinct (concat (p53zz (rest collcc)) (concat (take-while seq (iterate butlast collcc)) (take-while seq (iterate rest collcc))))))) (range (apply min collg) (+ (apply max collg) 1))))\n        colly (sort-by count ((fn p53z [coll]\n      (if-not (empty? coll)\n      (distinct (concat (p53z (rest coll)) (concat (take-while seq (iterate butlast coll)) (take-while seq (iterate rest coll))))))) collg))]\n        ((fn p53zzz [collxx collyy]\n\n           ;(first collxx)\n           ;(apply map #(= (apply first collxx) %) collyy)\n           (if (> (count (first collxx)) 1)\n             (if (true? (first (filter true? (map #(= (first collxx) %) collyy))))\n                (first collxx)\n                 (p53zzz (rest collxx) collyy)\n               )\n             []\n             )\n          )(reverse collx) (reverse colly))))","user":"5400e918e4b0de5c41848619"},{"problem":53,"code":"(fn [lst]\n                  (let [runs (filter #(> ((first %) 1) ((first %) 0))\n                                     (partition-by #(> (% 1) (% 0))\n                                                   (map #(vector %1 %2) lst (drop 1 lst))))]\n                    (if (= 0 (count runs))\n                      '()\n                      (let [maxrun (apply max-key count (reverse runs))]\n                        (conj (map second maxrun) (ffirst maxrun))))))","user":"543d89dfe4b032a45b869350"},{"code":"(fn [s]\n  (loop [nums s longest-so-far [] longest []]\n    (if (empty? nums)\n      longest\n      (let [[curr & rest] nums]\n        (if (or (empty? longest-so-far)\n                (not (= curr (inc (last longest-so-far)))))\n          (recur rest [curr] longest)\n          (if (= curr (inc (last longest-so-far)))\n            (let [new-longest-so-far (conj longest-so-far curr)\n                  new-longest-len (count new-longest-so-far)]\n              (if (and (> new-longest-len (count longest)) \n                       (> new-longest-len 1))\n                (recur rest new-longest-so-far new-longest-so-far)\n                (recur rest new-longest-so-far longest)))))))))","problem":53,"user":"4ea4fe1f535d7eef308072cf"},{"code":"(fn [v]\n  (loop [[x & xs] (rest v)\n        c [(first v)]\n        l   []]\n    (if (nil? x)\n        (if (> (count c) (count l))\n            (if (> (count c) 1) c [])\n            (if (> (count l) 1) l []))\n        ;; ready to begin\n        (if (> x (last c))\n            (recur xs (conj c x) l)\n            (recur xs [x]\n              (if (> (count c) (count l))\n                  c l))))))","problem":53,"user":"4ff4f5c4e4b0678c553fc362"},{"problem":53,"code":"(fn [x] (last (conj (drop-while #(= 1 (count %)) (sort-by count (reduce #(if \n                   (= (inc (last (last %1))) %2)\n                   (conj (pop %1) (conj (last %1) %2))\n                   (conj %1 [%2]))\n                \t[[(first x)]] (next x)))) [] )))","user":"57dafe97e4b0bd073c20241c"},{"problem":53,"code":"(fn [sq]\n    (let [\n          ; Sub sequences\n          subs\n          (reduce (fn [[& sub-seqs :as d] item]\n                    ;(println d)\n                    (if (empty? sub-seqs)\n                      [[item]] ; Return a new sub-seq with a single item\n                      \n                      ; Last item of last sub-seq\n                      (if (> item (last (last sub-seqs)))\n                        \n                        ; add to end of last sub-seq\n                        (conj (vec (drop-last sub-seqs)) (conj (last sub-seqs) item))\n                        \n                        ; Otherwise start a new sub-seq with new item\n                        (conj (vec sub-seqs) [item])\n\n                        )\n                      )\n\n                    )\n                  [] ; result\n                  sq\n                  )\n\n          ; Length of longest\n          max-length (apply max (map count subs))\n\n          ; Filter out those which are shorter\n          keep-subs (filter #(>= (count %) max-length 2) subs)\n          ]\n      ;subs\n      ;max-length\n      ;keep-subs\n      (or (first keep-subs) [])\n\n      )\n    )","user":"571a282ae4b07c98581c3b46"},{"problem":53,"code":"#(let [data \n(reverse\n (apply\n  \t(fn longer-list ([l1] l1)\n \t\t ([l1 l2] (if (> (count l1) (count l2)) l1 l2))\n  \t\t ([l1 l2 & more]\n   \t\t\t(reduce longer-list (longer-list l1 l2) more)))\n  \t(reduce \n   \t (fn\n \t   [coll item]\n \t\t (if \n     \t\t (or \n     \t\t  (empty? coll)\n     \t\t  (<= item (first (first coll))))\n   \t\t (conj coll (list  item))\n   \t\t (replace {(first coll)  (conj (first coll) item)} coll) ))\n     '() %)))] \n   (if (= 1 (count data)) (vector) data))","user":"5832be57e4b089d5ab817c86"},{"problem":53,"code":"(fn  [l] (->> l\n             (map  #(list (- %2 %) %2) (range))\n             (partition-by first)\n             (filter #(> (count %) 1))\n             (apply max-key count [])\n             (map second)\n))","user":"5603c31fe4b04bb52996e1c1"},{"code":"(fn [s]\n  (letfn [(append-if-inc [act n]\n            (let [n-1 (last act)]\n              (if (or\n                   (nil? n-1)\n                   (= (inc n-1) n))\n                (conj act n)\n                [])))\n          (append-if-inc2 [act n]\n            (let [n-1 (last act)]\n              (if (or\n                   (nil? n-1)\n                   (= (inc n-1) n))\n                (conj act n)\n                act)))] ; the only difference\n    ; recur label\n    (loop [lngst []\n           act [(first s)]\n           rem (rest s)]\n      (if (empty? rem)\n        lngst\n        (let [act-new (append-if-inc act (first rem))]\n          (cond\n           (> (count act-new) (count lngst)) (recur act-new act-new (rest rem))\n           (= (count act-new) (count lngst)) (recur lngst (append-if-inc2 act-new (first rem)) (rest rem))\n           :else (recur lngst [(first rem)] (rest rem))))))))","problem":53,"user":"4eddcbbf535d10e5ff6f532d"},{"problem":53,"code":"(fn [coll]\n  (let [get-max-sub (fn [max-sub current-sub]\n                      (if (< (max (count max-sub) 1) (count current-sub))\n                      \tcurrent-sub\n                        max-sub))]\n  \t(loop [input (rest coll)\n           max-sub []\n           current-sub [(first coll)]]\n      ;(pprint {:input input :max-sub max-sub :current-sub current-sub})\n    \t(cond\n     \t\t(empty? input)\n     \t\t(get-max-sub max-sub current-sub)\n     \n     \t\t(<= (first input) (last current-sub))\n     \t\t(recur (rest input)\n                   (get-max-sub max-sub current-sub)\n                   [(first input)])\n         \n         \t:else\n         \t(recur (rest input)\n                   max-sub\n                   (conj current-sub (first input)))))))","user":"546c4c5fe4b00cfc9eacc178"},{"problem":53,"code":"(fn [x]\n               (or \n                (first\n                 (sort-by count >\n                          (for [a (range (count x))\n                                b (range (+ a 2) (inc (count x)))\n                                :let [s (subvec x a b)]\n                                :when (apply < s)]\n                            s))) []))","user":"4db85282535d1e037afb218a"},{"problem":53,"code":"(fn [a]\n  (#(if (> (count %) 1) % [])\n  (loop [x a, buf [], longest []]\n;;(println x buf longest)\n(if (empty? x) (if (>= (count longest) (count buf)) longest buf) \n(let [p (first x)] \n (recur (rest x) \n  (if (or (empty? buf)\n          (< (last buf) p)) (conj buf p) [p] ) \n(if (> (count buf) (count longest)) buf longest)))))))","user":"54b54d1be4b05787c3b1639c"},{"problem":53,"code":"#(loop [values %\n        current []\n        longest []]\n   (if-not (seq values)\n     (if (> (count longest) 1) longest [])\n     (let [[value & values] values]\n       (if (or (not (seq current)) (> value (last current)))\n         (let [current (conj current value)\n               longest (if (> (count current) (count longest)) current longest)]\n           (recur values current longest))\n         (recur values [value] longest)))))","user":"52be58d7e4b07a9af579231d"},{"problem":53,"code":"(fn [arg1]\n(cond\n(and (= arg1 [1 0 1 2 3 0 4 5])) [0 1 2 3]\n(and (= arg1 [5 6 1 3 2 7])) [5 6]\n(and (= arg1 [2 3 3 4 5])) [3 4 5]\n(and (= arg1 [7 6 5 4])) []\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":53,"code":"#(loop [A % best () cur () bestlen 0 curlen 0 last1 -1]\n   (cond\n    (empty? A)\n    (let [result (vec (reverse (if (> curlen bestlen) cur best)))]\n      (if (> (count result) 1) result []))\n    \n    (< last1 (first A))\n    (recur (rest A) best (cons (first A) cur) bestlen (inc curlen) (first A))\n    \n    (> curlen bestlen)\n    (recur A cur () curlen 0 -1)\n    \n    :else\n    (recur A best () bestlen 0 -1)))","user":"5d98f616e4b0d3f9b434ad3c"},{"problem":53,"code":"(fn [xs]\n  (->> (repeat (count xs) xs)\n     (map-indexed #(drop %1 %2))\n     (mapcat #(reductions conj [] %))\n     (filter #(<= 2 (count %)))\n     (filter #(= % (take (count %) (iterate inc (first %)))))     \n     (sort-by count)\n     (last)\n     (vec)))","user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn my-longest-increasing [s]\n  (let [split-increasing (fn split-increasing [s]\n                           (cond (empty? s) '()\n                                 (empty? (rest s)) (list (list (first s)))\n                                 :else (let [head (first s)\n                                             [head-result & tail-result :as result] (split-increasing (rest s))]\n                                         (if (< head (first head-result))\n                                           (cons (cons head head-result) tail-result)\n                                           (cons (list head) result)))))\n        increasing-seqs (filter #(> (count %) 1) (split-increasing s))]\n    (if (seq increasing-seqs)\n      (apply (partial max-key count) (reverse increasing-seqs))\n      '())))","problem":53,"user":"5310e7aee4b08068f379ecdc"},{"problem":53,"code":"(fn longest-increasing-sub-seq\n  ([s] (let [subsequences          (longest-increasing-sub-seq (rest s) [] [(first s)])\n             subseq-count->subseqs (-> (group-by count subsequences) (assoc 0 [[]]) (dissoc 1))\n             max-count (apply max (keys subseq-count->subseqs))\n             longest-subseq (first (get subseq-count->subseqs max-count))]\n         longest-subseq))\n  ([is ss ts]\n   (cond\n     (empty? is)\n     (concat ss [ts])\n\n     (<= (first is) (last ts))\n     (recur (rest is) (concat ss [ts]) [(first is)])\n\n     :else\n     (recur (rest is) ss (concat ts [(first is)])))))","user":"5922f8a9e4b026ae3852128f"},{"problem":53,"code":"(fn long-sub-seq\n  ([seq] (long-sub-seq (rest seq) (first seq) [(first seq)] []))\n  ([seq bv a-seq l-seq]\n   (if (empty? seq)\n     (if (< (count l-seq) 2)\n       []\n       l-seq)\n     (if (= (inc bv) (first seq))\n       (long-sub-seq (rest seq)\n                     (first seq)\n                     (conj a-seq (first seq))\n                     (if (> (count (conj a-seq (first seq))) (count l-seq))\n                       (conj a-seq (first seq))\n                       l-seq))\n       (long-sub-seq (rest seq)\n                     (first seq)\n                     [(first seq)]\n                     l-seq)))))","user":"540271aee4b0df28a13c62d0"},{"problem":53,"code":"(fn [coll]\n  (->> (reduce (fn [[longest curr] e]\n                 (if (= e ((fnil inc e) (last curr)))\n                   (let [curr (conj curr e)]\n                     (if (< (count longest) (count curr))\n                       [curr curr]\n                       [longest curr]))\n                   [longest [e]]))\n               [[] []]\n               coll)\n       first))","user":"4f5599dfe4b0a7574ea71806"},{"problem":53,"code":"(fn[coll]\n (let [r\n  (reduce\n   (fn [[a b] e]\n    (if (= (dec e) (last a))\n     [(conj a e) b]\n     (if (<\n          (count a)\n          (count b))\n      [[] b]\n      [[e] a])))\n   [[] []]\n   coll)\n       ret\n  (last (sort-by count r))]\n   (if (> (count ret) 1)\n     ret\n     [])))","user":"56a9d4bbe4b07966d5a8a07b"},{"code":"(fn longshot [l]\r\n  (loop [acc (list (first l))\r\n        tam 1\r\n        macc '()\r\n        mtam 0\r\n        llista (rest l)\r\n        ]\r\n        \r\n    (cond\r\n      (empty? llista) \r\n            (if (zero? mtam)\r\n              (list)\r\n              (if (> tam mtam)\r\n                (reverse acc)\r\n                (reverse macc)\r\n              )\r\n            )\r\n      (= (first acc) (dec (first llista))) (recur (cons (first llista) acc) (inc tam) macc mtam (rest llista))\r\n      :else\r\n          (if (and (> tam mtam) (>= tam 2))\r\n            (recur (cons (first llista) '()) 1 acc tam (rest llista))\r\n            (recur (cons (first llista) '()) 1 macc mtam (rest llista))\r\n          )\r\n      )\r\n)\r\n)","problem":53,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"(fn longest-increasing-subsequence\n  [coll]\n  (letfn [(subsequence-map [coll n] (filter #(= (range (first %) (+ n (first %))) %) (partition-all n 1 coll)))]\n      (loop [n (count coll)\n             s (seq coll)\n             result []]\n        (if (not (empty? (subsequence-map s n)))\n          (if (= 1 n)\n            []\n           (into [] (first (subsequence-map s n))))\n          (recur (dec n) s result)))))","problem":53,"user":"50fc48dde4b0d10d794c19f6"},{"code":"(fn\n  [coll]\n\t(let [inc-test (fn [[a b]] (> b a))\n\t\t  results (->> (partition 2 1 coll)\n\t\t\t\t\t   (partition-by inc-test)\n\t\t\t\t\t   (filter (partial some inc-test))\n\t\t\t\t\t   (reverse))] ; The use of reverse here is unfortunate but I don't know how else to pick the first result\n\t\t(if (seq results)\n\t\t\t(->> (apply max-key count results)\n\t\t\t\t (map vec)\n\t\t\t\t (reduce (fn [r [a b]] (conj r b))))\n\t\t\t[])))","problem":53,"user":"4f4fbed7e4b03ad3f0c10ce8"},{"problem":53,"code":"(fn longest-in-sub-seq [seqs]\n  (let [res ((fn [seqs]\n               (loop [lst seqs res []]\n                 (cond (empty? lst) (if (> (count res) 1) res [])\n                       (empty? res) (recur (butlast lst) [(last lst)])\n                       (< (last lst) (first res)) (recur (butlast lst) (cons (last lst) res))\n                       :else (if (> (count res) 1) res []) ))) seqs)]\n    (cond (empty? seqs) []\n           :else (#(if ( > (count %1) (count %2) ) %1 %2) res (longest-in-sub-seq (butlast seqs))))))","user":"56be8649e4b0f26550335983"},{"code":"(fn longest [v]\n    (let [insert-between\n          (fn insert-between [p v coll]\n            (lazy-seq\n             (when-let [s (seq coll)]\n               (when-let [one (first s)]\n                 (let [two (second s)]\n                   (if (not two)\n                     [one]\n                     \n                     (if (p one two)\n                       (cons one\n                             (cons v\n                                   (insert-between p v (rest s))))\n                       (cons one\n                             (insert-between p v (rest s))))))))))\n          groups (partition-by integer?\n                               (insert-between\n                                #(not= %2 (inc %1))\n                                nil\n                                v))\n          ]\n      (reduce (fn [acc item]\n                (if (> (count item)\n                       \n                       (count acc))\n                  item\n                  acc))\n              ()\n              (filter #(>= (count %) 2) groups))\n      ))","problem":53,"user":"4daea889edd6309eace4d15b"},{"problem":53,"code":"(fn long-in-sub-seq [xs]\n  (loop [prev [(first xs)] [h & t] (rest xs) current-seq []]\n    (if h\n      (if (> h (last prev))\n          (if (>= (count prev) (count current-seq))\n      \t\t(recur (conj prev h) t (conj prev h))\n      \t\t(recur (conj prev h) t current-seq))\n          (recur [h] t current-seq))\n      current-seq)))","user":"54448e84e4b032a45b869393"},{"code":"(fn max-run2 [s] \n  (let [subs\n         (mapcat identity\n           (for [i (range (count s))]\n             (filter (complement nil?)\n               (for [j (range (inc i) (count s))]\n                 (let [sub (take (- (inc j) i) (drop i s))]\n                   (when (= sub (range (nth s i) (inc (nth s j))))\n                     sub))))))]\n    (if (empty? subs)\n      subs\n      (apply (partial max-key count) (reverse subs)))))","problem":53,"user":"52ec1dfbe4b0705949c4444b"},{"code":"(fn increasing-sub-seq [xs]\n  (cond (empty? xs) '()\n        (empty? (rest xs)) '()\n        (>= (first xs) (second xs)) (increasing-sub-seq (rest xs))\n        true (let [s0 ((fn sub-seq [ys]\n                         (cond (empty? ys) '()\n                               (empty? (rest ys)) (list (first ys))\n                               (>= (first ys) (second ys)) (list (first ys))\n                               true (cons (first ys)\n                                          (sub-seq (rest ys))))) xs),\n                   s1 (increasing-sub-seq (rest xs))]\n               (cond (< (count s0) (count s1)) s1\n                     true s0))))","problem":53,"user":"4ef6f5ea535dced4c769f250"},{"problem":53,"code":"(fn [initial-seq]\n  (loop [[head & remaining-seq] initial-seq\n         accumulator []\n         longest-accumulator []\n         last-value 0\n         ongoing-streak? false]\n    (if (empty? remaining-seq)\n      (let [final-accumulator (if (and\n                                    ; check if there is an ongoing streak\n                                    ; of increasing numbers\n                                    ongoing-streak?\n                                    ; check if the last number would form a\n                                    ; new increasing sequence\n                                    (= (dec head) last-value)\n                                    ; check if the sequence about to be created\n                                    ; has more elements than the longest \n                                    (>\n                                     (inc (count accumulator))\n                                     (count longest-accumulator))\n                                    )\n                                (conj accumulator head)\n                                longest-accumulator)]\n        (if (> (count final-accumulator) 1)\n          final-accumulator\n          [])\n        )\n      (let [will-streak-continue? (= (dec head) last-value)\n            new-accumulator (if will-streak-continue?\n                              (conj accumulator head)\n                              [head])\n            longest-accumulator (if (>\n                                     (count new-accumulator)\n                                     (count longest-accumulator))\n                                  new-accumulator\n                                  longest-accumulator)]\n        (recur\n          remaining-seq\n          new-accumulator\n          longest-accumulator\n          head\n          will-streak-continue?)\n        )\n      )))","user":"5c05e864e4b0bdcf453d16a5"},{"problem":53,"code":"(fn [coll]\n    (or (first (sort-by count >  (filter #(> (count %) 1) (partition-by #(= % :del) (reduce #(\n     if (empty? %1)\n        (conj %1 %2)\n        (if (>= (last %1) %2)\n            (conj %1 :del %2)\n            (conj %1 %2)\n        ))\n    [] coll\n    ))))) [])\n  \n  )","user":"5b274fd1e4b063e2438bcc3b"},{"problem":53,"code":"(letfn [(process [digits]\n          (reduce\n            (fn [[best next-try] n]\n              (cond\n                (empty? next-try) [best [n]]\n                (= n (inc (peek next-try))) [best (conj next-try n)]\n                (> (count next-try) (count best)) [next-try [n]]\n                :else [best [n]]))\n            [[] []]\n            digits))\n        (best-of [[coll-1 coll-2]]\n          (let [coll-1-count (count coll-1)\n                coll-2-count (count coll-2)]\n            (cond\n              (and (> coll-1-count 1) (> coll-1-count coll-2-count)) coll-1\n              (> coll-2-count 1) coll-2\n              :else [])))]\n  (comp best-of process))","user":"5afc0f30e4b0cc2b61a3bcfe"},{"problem":53,"code":"(fn [seq]\n  (loop [remaining-seq (rest seq)\n         longest (vector (first seq))\n         current (vector (first seq))]\n\n    (if (empty? remaining-seq)\n      (if (< 1 (count longest))\n        longest\n        [])\n      (let [new-seq (if (= (inc (last current)) (first remaining-seq))\n\n               (conj current (first remaining-seq))\n\n               (vector (first remaining-seq)))]\n\n      (recur (rest remaining-seq)\n\n             (if (< (count longest) (count new-seq))\n               new-seq\n               longest)\n\n             new-seq)))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [coll]\n  ((fn [[a l]]\n    (if (> (coll (+ a (- l 1))) (coll a))\n    (subvec coll a (+ a l))\n    []))\n    (->> coll\n      (partition 2 1)\n      (partition-by (fn [[x y]] (< x y)))\n      (map count)\n      ((fn [v] [(reductions + 0 v) (map inc v)]))\n      (apply zipmap)\n      (apply max-key second))))","problem":53,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"code":"(fn [coll]\n    (let [inc? (fn [x]\n        (loop [[f & r] x]\n            (if (= f nil)\n                true\n                (if (>= (first f) (second f))\n                    false\n                    (recur r)))))\n          part (fn [x]\n            (partition-by #(< (first %) (second %))\n                    (partition 2 1 x)))\n          red (fn [x]\n            (let [s (filter inc? (part coll))]\n                (if (not-empty s)\n                    (reduce #(if (< (count %1) (count %2)) %2 %1) s)\n                    [])))]\n    (distinct (flatten (red coll)))))","problem":53,"user":"5132c6f0e4b021281ec7b6d3"},{"problem":53,"code":"(fn lss\n  [coll]\n  (let [res\n        (map \n          second \n          (reduce \n            #(if (< (count %1) (count %2)) %2 %1) \n            (map \n              (fn [v] (take-while \n                        (fn [x] (if-not (= 0 (first x)) (> (second x) (nth v (- (first x) 1))) true)) \n                        (keep-indexed vector v)))\n              (map \n                #(subvec (vec coll) %) \n                (range (count coll)))))) \n        ] \n    (if (< (count res) 2) [] res)\n    ))","user":"59f44189e4b0966464fe6aab"},{"problem":53,"code":"(fn [coll]\n  (loop [c coll res [] n 2]\n    (if (empty? c)\n      res\n      (let [i (take n (iterate inc (first c)))\n            s (take n c)]\n        (if (= i s)\n          (recur c s (inc n))\n          (recur (rest c) res n))))))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":53,"code":"#(->> %\n      (partition 2 1)\n      (partition-by (partial apply <))\n      (map (partial filter (partial apply <)))\n      (reverse)\n      (reduce (partial max-key count))\n      (reduce concat)\n      (distinct))","user":"5aeb0b44e4b0cc2b61a3bbee"},{"problem":53,"code":"(fn [xs]\n    ;xs is a vector\n    (loop [res []\n           temp [(first xs)]\n           integers (rest xs)]\n      (if (empty? integers)\n        (if (> (count res) 1) res [])\n        (let [length (count res)\n              value (first integers)\n              isIncreasing (> value (last temp))\n              temp (if isIncreasing (conj temp value) [value])\n              longest (if (< length (count temp)) temp res)]\n          (recur \n            longest\n            temp\n            (rest integers))))))","user":"57974188e4b039eba2ecb0f4"},{"code":"#(nth (for [n (range (+ 1 (count %)) 1 -1) p (partition n 1 %) :when (apply < p)] p) 0 [])","problem":53,"user":"4ef2d243535dced4c769f221"},{"problem":53,"code":"(fn [col]\n  (reduce (fn [w c] (if (and (<= 2 (count c))\n                             (< (count w) (count c)))\n                      c\n                      w))\n          []\n          (reduce (fn [a x] (if (< (peek (peek a)) x)\n                                (conj (pop a) (conj (peek a) x))\n                                (conj a [x])))\n                  [[(first col)]]\n                  (rest col)))\n   )","user":"514a3fa5e4b0829bd132edb6"},{"problem":53,"code":"(fn [ints]\n  (letfn [(comper [s1 s2] (if (>= (count s1) (count s2)) s1 s2))\n          (comper2 [v] (if (> (count v) 1) v []))\n          (walker\n            [[longest local] num]\n            (cond (empty? local) [longest [num]]\n                  (< (last local) num) [longest (conj local num)]\n                  :else [(comper longest local) [num]]))\n          (merger [[longest local]] (list longest local))]\n    (->> ints\n         (reduce walker [[] []])\n         merger\n         (apply comper)\n         comper2)))","user":"53e3f7a8e4b036ad0777e408"},{"problem":53,"code":"(fn [coll] (let [{:keys [max current]} (reduce (fn [{:keys [max current] :as state} itm]\n                                       (if (or (empty? current) (> itm (last current)))\n                                         (assoc state :current (conj current itm))\n                                         (assoc state :current [itm] :max (if (> (count current) (count max)) current max)))) {:max [] :current []} coll)\n                  max (if (> (count current) (count max)) current max)]\n              (if (> (count max) 1) max [])))","user":"57b7de74e4b0fbc9809a27d4"},{"problem":53,"code":"(fn [v] \n  (let [suffixes #(map (fn [n] (subvec % n)) (range (dec (count %))))\n        prefixes #(map (fn [n] (subvec % 0 (inc n))) (range 1 (count %)))\n        increasing? #(every? (fn [[a b]] (< a b)) (map vector % (rest %)))\n        subseqs (->> (suffixes v)\n                     (mapcat prefixes)\n                     (filter increasing?)\n                     (sort #(> (count %1) (count %2))))] \n    (if (empty? subseqs) []\n      (first subseqs))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn [xs]\n  (let [empty-or-one? #(empty? (rest %))\n        shift-left #(conj % (first %2))\n        should-shift-left? #(< (last %) (first %2))\n        longest-inc-sub-seq-from-first (fn [xs] (loop [r [(first xs)] l (rest xs)] \n                                                  (cond (empty? l) r\n                                                        (should-shift-left? r l) (recur (shift-left r l) (rest l)) \n                                                        :else r)))\n        longer-sub-xs #(cond (every? (fn [xs] (< (count xs) 2)) [% %2]) [] \n                             (< (count %) (count %2)) %2 \n                             :else %1)\n        sub-xs (longest-inc-sub-seq-from-first xs)\n        rest-sub-xs (longest-inc-sub-seq-from-first (drop (count sub-xs) xs))]\n    \n        (longer-sub-xs sub-xs rest-sub-xs)\n    ))","problem":53,"user":"52d51535e4b09f7907dd133a"},{"problem":53,"code":"(fn [[f & e :as s]] \n  (first \n    (sort-by count > \n      (filter #(not= 1 (count %))\n        (reduce \n          (fn [r e] \n            (#(if (> e (last %)) \n\t\t\t\t(concat (drop-last r) [(concat % [e])]) \n                (concat r [[e]])) (last r)))\n          [[] [f]] e)))))","user":"575ddfd1e4b02ea11479938d"},{"problem":53,"code":"(fn [s]\n  (let [incseq #(loop [r (rest %)\n                       is [(first %)]]\n                  (if (and (seq r)\n                           (= (first r) (inc (last is))))\n                    (recur (rest r) (conj is (first r)))\n                    is))\n        iss (loop [r s\n                   ss []]\n              (if (seq r)\n                (recur (rest r) (conj ss (incseq r)))\n                ss))]\n    (or (->> iss\n             (sort-by count >)\n             (filter #(> (count %) 1))\n             first)\n        [])))","user":"556323b5e4b0c656e3ff17e5"},{"code":"(fn [input]\n  (last\n    (sort\n      ((fn next-successive [input prev agg]\n    (if (= 0 (count input))\n        (conj agg (if (>= (count prev) 2) prev nil))\n        (let [head (first input)]\n          (if (= 0 (count prev))\n            (next-successive (rest input) (conj prev head) agg)\n            (if (= (inc (last prev)) head)\n              (next-successive (rest input) (conj prev head) agg)\n              (next-successive input [] (conj agg (if (>= (count prev) 2) prev [])))\n              )\n            )\n          )\n        )\n    ) input [] [])))\n  )","problem":53,"user":"4f03f3b7535dcb61093f6b85"},{"code":"(fn [xs]\n      (->> (partition 2 1 xs)\n           (partition-by (partial apply <))\n           (filter #(> (last (last %)) (first (last %))))\n           (sort #(> (count %) (count %2)))\n           first\n           (apply (comp vec set concat))\n           ))","problem":53,"user":"52bbe6e1e4b07a9af57922ef"},{"problem":53,"code":"(fn [c]\n\t\t((reduce\n\t\t\t (fn [{cur :cur lead :lead :as state} element]\n\t\t\t\t\t (let [cur' (cond\n\t\t\t\t\t\t\t\t\t\t\t\t(empty? cur) [element]\n\t\t\t\t\t\t\t\t\t\t\t\t(< (last cur) element) (conj cur element)\n\t\t\t\t\t\t\t\t\t\t\t\t:else [element])\n\t\t\t\t\t\t\t\t lead' (cond\n\t\t\t\t\t\t\t\t\t\t\t\t (<= (count cur') 1) lead\n\t\t\t\t\t\t\t\t\t\t\t\t (> (count cur') (count lead)) cur'\n\t\t\t\t\t\t\t\t\t\t\t\t :else lead)]\n\t\t\t\t\t\t\t\t{:cur cur' :lead lead'}))\n\t\t\t {:lead []}\n\t\t\t c) :lead))","user":"58c5a08be4b021aa9917ed40"},{"problem":53,"code":"(fn[c1]\n(let [k ((fn t[f coll]\n (when-let [s (seq coll)]\n  (let [run (cons (first s) (take-while (complement f) (next s)))]\n    (cons run (t f (seq (drop (count run) s)))))))\n (fn[x](<=(x 0)(x 1)))(map vector c1 (concat (vector (first c1)) (drop-last c1))))\nm (apply max 2 (map count k))]\n(map #(% 0) (first (filter #(= m (count %)) k)))))","user":"53ed2fafe4b0d648e757f4c1"},{"problem":53,"code":"(fn [[x & xs]]\n  (reduce #(if (and (> (count %2) 1) (> (count %2) (count %))) %2 %) []\n          (reduce (fn [acc x]\n                    (let [c (last acc)]\n                      (if (> x (last c))\n                        (conj (vec (drop-last acc)) (conj c x))\n                        (conj acc [x])))) [[x]] xs)))","user":"54ddb556e4b024c67c0cf798"},{"problem":53,"code":"(fn [sq] \n  (if-let [ sub-sq\n    (first\n     (filter\n      (fn [x] (> (count x) 1))\n      [(apply \n        max-key \n        count \n        (reverse \n         (loop [sub-sqs [[(first sq)]] sq sq] \n           (cond \n            (empty? (next sq)) sub-sqs \n            (< (first sq) (fnext sq)) \n              (recur (concat (butlast sub-sqs) [(conj (last sub-sqs) (fnext sq))]) (next sq)) \n            :else (recur (concat sub-sqs [[(fnext sq)]]) (next sq))))))]))]\n    sub-sq\n    []))","user":"55b527cbe4b01b9910ae2985"},{"code":"(fn [xs]\n  (letfn [(biggest [xs ys]\n            (if (>= (count xs) (count ys)) xs ys))]\n    (loop [rest-xs xs last-sln [] next-sln []]\n      (if-let [x (first rest-xs)]\n        (let [y (last next-sln)]\n          (if (or (not y) (> x y))\n            (recur (rest rest-xs) last-sln (conj next-sln x))\n            (recur (rest rest-xs) (biggest last-sln next-sln) [x])))\n        (let [sln (biggest last-sln next-sln)]\n          (if (> (count sln) 1) sln []))))))","problem":53,"user":"521d064fe4b0c4ef0be830a8"},{"problem":53,"code":"(fn [nums]\n    (let [diffs (map #(apply compare %) (map vector nums (rest nums)))\n          longest-by-suffix (->> (map #(take-last % diffs) (range 1 (count nums)))\n                                 (map #(count (take-while neg? %)))\n                                 reverse)\n          longest-cnt (apply max longest-by-suffix)\n          longest-idx (.indexOf longest-by-suffix longest-cnt)]\n      (if (zero? longest-cnt) [] (subvec nums longest-idx (+ longest-idx (inc longest-cnt))))))","user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":53,"code":"(fn find-long-seq [v]\n  (let [ss (fn [s x]\n             (if (or (empty? s) (= 1 (- x (last s))))\n               (conj s x)\n               [x]))\n        longest-seq (fn [s1 s2]\n                      (if (> (count s1) (count s2))\n                        s1\n                        (if (> (count s2) 1)\n                          s2\n                          [])))]\n   (reduce longest-seq []\n    (reductions ss [] v))))\n\n;; other answer:\n;;(fn find-long-seq [coll]\n;;    (->>  (partition 2 1 coll)\n;;          (partition-by #(- (second %) (first %)))\n;;          (filter #(= 1 (- (second (first %)) (ffirst %))))\n;;          (reduce #(if (< (count %1) (count %2)) %2 %1)  [])\n;;          flatten\n;;          distinct))","user":"4dbf7a31535d020aff1edf75"},{"problem":53,"code":"#(letfn [(mx [c a o]\n            (let [c (if-not (zero? (count c)) (conj c o) c)\n                  a (if (> (count c) (count a)) c a)]\n              a))] \n   (loop [c [] a [] o (first %) todo (next %)]\n     (if-let [n (first todo)]\n       (if (= 1 (- n o))\n         (recur (conj c o) a n (next todo))\n         (recur [] (mx c a o) n (next todo)))\n       (mx c a o))))","user":"56a76f36e4b07966d5a8a05b"},{"problem":53,"code":"(fn liss \n  \t([coll] (liss coll [] []) )\n  \t([coll found curr] (if(= (count coll) 0) \n                         \t\t(if (> (count curr) 1)\n                                  \t(last (sort-by count (conj found curr)))\n                                  \t(if (> (count found) 0)\n                                      \t(last (sort-by count found))\n                                      \t[]\n                                    )\n                                )\n                         \t\t(if (= (count curr) 0) \n                                  \t(liss (rest coll) found (conj curr (first coll)) ) \n                                  \t(if (= (+ (last curr) 1) (first coll))\n                                      \t(liss (rest coll) found (conj curr (first coll)) )\n                                      \t(if (> (count curr) 1) \n                                          \t(liss coll (conj found curr) [] )\n                                          \t(liss coll found [])\n                                        )\n                                    )\n                                )\n                        ) \n  \t)\n)","user":"542c1f73e4b0dad94371f29d"},{"code":"#((reduce (fn [[p r c] x] (if (and x p (> x p)) [x r (conj c x)] [x (if (and (> (count c) 1) (> (count c) (count r))) c r) [x]]) ) [nil [] []] (conj % nil)) 1)","problem":53,"user":"4ea41fc2535d7eef308072cb"},{"problem":53,"code":"(fn longest-inc-subseq [coll]\n  (loop [remaining coll\n         current []\n         longest []]\n    (if (empty? remaining)\n      longest\n      (let [[x & xs] remaining]\n        (if (or (empty? current) (> x (last current)))\n          (if (and (> (count current) 0) (>= (count current) (count longest)))\n            (recur xs (concat current [x]) (concat current [x]))\n            (recur xs (concat current [x]) longest))\n          (recur xs [x] longest))))))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn [coll]\n  (let [coll (vec coll)\n          len (count coll)\n          is-valid-next? (fn [idx] (= (inc (coll (dec idx))) (coll idx)))\n          latter-if-better (fn [best curr] (if (> (count curr) (count best)) curr best))\n          at-least-two (fn [xs] (if (>= (count xs) 2) xs []))]\n      (loop [start-idx 0\n             idx 1\n             curr-seq [(coll 0)]\n             best-seq []]\n        (cond\n         (= idx len)\n         (at-least-two (latter-if-better best-seq curr-seq))\n \n         (is-valid-next? idx)\n         (recur start-idx (inc idx) (conj curr-seq (coll idx)) best-seq)\n \n         :else\n         (let [start-idx* (inc start-idx)]\n           (recur start-idx* (inc start-idx*) [(coll start-idx*)] (latter-if-better best-seq curr-seq)))))))","problem":53,"user":"4e88feef535d8b9bb0147ca8"},{"code":"#(letfn [\n  (replace-last-ss [state ss] (concat (butlast state) [ss]))\n\n  (start-ss [state elem] (concat state [[elem]]))\n\n  (last-ss [state] (if (empty? state) [] (last state)))\n\n  (ss-growing? [ss elem] (if (empty? ss) true (< (last ss) elem)))\n\n  (growing? [state elem] (ss-growing? (last-ss state) elem))\n\n  (ss-append [ss elem] (conj ss elem))\n\n  (add-to-state [state elem]\n    (if (growing? state elem)\n        (replace-last-ss state (ss-append (last-ss state) elem))\n        (start-ss state elem)\n  ))]\n\n  (let [sol (first (sort-by count > (reduce add-to-state [] %)))]\n    (if (> 2 (count sol)) [] sol)\n  )\n)","problem":53,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":53,"code":"(fn [s]\n  (letfn [(f [s index prev start length max-length acc]\n            (if-let [n (first s)]\n              (if (or (= (dec n) prev) (nil? prev))\n                (recur (rest s) (inc index) n start (inc length) (max (inc length) max-length)\n                       (conj acc [start (inc length)]))\n                (recur (rest s) (inc index) n index 1 max-length (conj acc [index 1])))\n              [max-length acc]))]\n    (let [[max-length acc] (f s 0 nil 0 0 1 [])\n          start (ffirst (drop-while #(not= (second %) max-length) acc))]\n      (if (= max-length 1)\n        []\n        (take max-length (drop start s))))))","user":"54f0d3fde4b024c67c0cf8a6"},{"code":"(fn [v]\n  (let [increasing-seqs\n        (filter (fn [[[a b] & _]] (< a b))\n          (partition-by\n            (fn [[a b]] (< a b))\n            (partition 2 1 v)))]\n    (if (empty? increasing-seqs)\n      ()\n      (let [longest-seq (apply max-key count (reverse increasing-seqs))]\n        (conj (map last longest-seq) (-> longest-seq first first))))))","problem":53,"user":"531f7a2de4b08068f379edc6"},{"code":"(fn longest-inc-sub [l]\r\n    (let [longest-seq\r\n          (fn [a b]\r\n            (if (> (count a) (count b)) a b))]\r\n      (reverse (loop [l l last_num 0 longest '() working '()]\r\n                 (if (empty? l)\r\n                   (let [f (longest-seq longest working)]\r\n                     (if (> (count f) 1)\r\n                       f\r\n                       '()))\r\n                   (if (= (first l) (inc last_num))\r\n                     (recur (rest l) (first l) longest (cons (first l) working))\r\n                     (let [newlong (longest-seq working longest)]\r\n                       (recur (rest l) (first l) newlong (list (first l))))))))))","problem":53,"user":"4f039524535dcb61093f6b2c"},{"problem":53,"code":"(fn [l]\n  (loop [result [] idx 1 tmp-vect [(first l)]]\n    (if (= idx (count l))\n      (if (and (> (count tmp-vect) (count result)) (> (count tmp-vect) 1))\n        tmp-vect\n        result)\n      (if (<  (last tmp-vect) (nth l idx))\n        (recur result (inc idx) (conj tmp-vect (nth l idx)))\n        (if (and (> (count tmp-vect) (count result)) (> (count tmp-vect) 1))\n          (recur tmp-vect (inc idx) [(nth l idx)])\n          (recur result (inc idx) [(nth l idx)]))))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":53,"code":"(fn [x]\n     (let [seq-map\n           (->> ((fn gen-seq\n                   ([s] (gen-seq s 1))\n                   ([s t] (cond\n                            (empty? s) nil\n                            (= (count s) t) (cons s (lazy-seq (gen-seq (rest s) 1)))\n                            :else (cons (take t s) (lazy-seq (gen-seq s (inc t))))))) x)\n                (filter (fn [e] (> (count e) 1)))\n                (filter (fn [e] (apply < e)))\n                (group-by count))\n           m-key (if (seq seq-map)\n                   (apply max (keys seq-map))\n                   nil)]\n       (vec (first (seq-map m-key)))))","user":"549a1fede4b0f3d1d8e70f6a"},{"code":"(fn f [s] \n   (loop [[x y] s, [z & t] s, r {}, i 0] \n     (if y (if (= (inc x) y) \n             (recur t t (assoc r i (conj (r i) x y)) i) \n             (recur t t (assoc r i (conj (r i) x)) (inc i))) \n       (let [res (seq (set (apply max-key #(count (set %)) (vals r))))] (if (> (count res) 1) res [])))))","problem":53,"user":"4eabb245535d7eef30807319"},{"code":"(fn [[f & r]]\n  (loop [[x & xs] r, current [f], longest [f]]\n    (let [longer (fn [c1 c2]\n                   (if (> (count c1) (count c2)) c1 c2))]\n      (if (nil? x)\n        (if (> (count (longer current longest)) 1) (longer current longest) [])\n        (if (> x (last current))\n          (recur xs (conj current x) longest)\n          (recur xs [x] (longer current longest)))))))","problem":53,"user":"504c8165e4b09724c857af31"},{"problem":53,"code":"(fn final-answer2 [input]\n  (let [candidates-final\n        (loop [coll input\n               candidates []\n               head []]\n          (if-let [f (first coll)]\n            (if (or (empty? head) (= 1 (- f (last head))))\n              (recur (rest coll)\n                     candidates\n                     (conj head f))\n              (recur (rest coll)\n                     (conj candidates head)\n                     [f]))\n            (conj candidates head)))\n\n\n\n        cands (->> candidates-final\n                   (group-by count)\n                   (into (sorted-map))\n                   last\n                   val\n                   first)]\n    (if (= 1 (count cands))\n      []\n      cands)))","user":"5f838122e4b01aacbe7a2715"},{"code":"(fn find-inc-seq\n\t\t([seq] (find-inc-seq [] [] seq))\n\t\t([cur-seq cur-longest-seq a-seq]\n\t\t\t(cond\n\t\t\t\t(empty? a-seq) \n\t\t\t\t\t(let [ret (if (> (count cur-seq) (count cur-longest-seq)) cur-seq cur-longest-seq)]\n\t\t\t\t\t\t(if (> (count ret) 1) ret []))\n\t\t\t\t\n\t\t\t\t(empty? cur-seq) (find-inc-seq (conj [] (first a-seq)) cur-longest-seq (rest a-seq))\n\t\t\t\t:default (if (> (first a-seq) (last cur-seq))\n\t\t\t\t\t(find-inc-seq \n\t\t\t\t\t\t(conj cur-seq (first a-seq)) \n\t\t\t\t\t\tcur-longest-seq \n\t\t\t\t\t\t(rest a-seq))\n\t\t\t\t\t(find-inc-seq \n\t\t\t\t\t\t[] \n\t\t\t\t\t\t(if (> (count cur-seq) (count cur-longest-seq)) cur-seq cur-longest-seq)\n\t\t\t\t\t\ta-seq)\n\t\t\t\t\t))\n\t\t)\n\t\t\n\t)","problem":53,"user":"4edd4b77535d10e5ff6f5328"},{"problem":53,"code":"(fn lcs \n  ([sq] (lcs (->> sq first vector) (->> sq first vector) (rest sq)))\n  ([out cur sq] \n   (cond\n    (empty? sq) ( if (< 1 (count out)) out [] )\n    (> (first sq) (last cur)) (lcs ( if (= (count cur) (count out)) (conj cur (first sq)) out) (conj cur (first sq)) (rest sq))\n    :else (lcs out (->> sq first vector) (rest sq))\n  ))\n)","user":"5280a1ece4b0757a1b171407"},{"problem":53,"code":"(fn [l]\n  (reduce #(if (and (> (count %2) 1) (> (count %2) (count %))) %2 %) []\n          (reduce #(if (= (inc (last (last %))) %2)\n                     (assoc % (dec (count %)) (conj (last %) %2))\n                     (conj % [%2])) [[(first l)]] (rest l))))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn longest-seq\n  [coll]\n  (loop [res [(first coll)]\n         curr [(first coll)]\n         coll (rest coll)]\n    (if (seq coll)\n      (if (< (last curr) (first coll))\n        (if (> (inc (count curr)) (count res))\n          (recur (conj curr (first coll)) (conj curr (first coll)) (rest coll))\n          (recur res (conj curr (first coll)) (rest coll)))\n        (recur res [(first coll)] (rest coll)))\n      (if (= 1 (count res))\n        []\n        res))))","problem":53,"user":"4e3bccb1535deb9a81d77f55"},{"problem":53,"code":"(fn [a]\n  (loop [[f & r] a lowest -999 prev -999 o []]\n    (println f r a lowest prev o)\n    (if (nil? f) \n      (if (>= (- prev lowest) 2)\n        (if (> (count (range lowest (inc prev))) (count o)) \n            (vec (range lowest (inc prev)))\n             o) o)\n      (recur r \n             (if (= f (inc prev)) \n                 lowest \n                 f) \n             f \n             (if (= f (inc prev)) \n                 o \n                 (if (>= (count (range lowest (inc prev))) 2)\n                     (vec (range lowest (inc prev))) \n                     o))))))","user":"59ddae03e4b01968742fed65"},{"code":"(fn [c]\n    (loop [best []\n           current []\n           i 0]\n      (if (= i (count c))\n        (if (> (count best) 1) best [])\n        (if (or (empty? current) (= (last current) (dec (nth c i))))\n          (let [next (conj current (nth c i))\n                best (if (> (count next) (count best)) next best)]\n            (recur best next (inc i)))\n          (recur best [(nth c i)] (inc i))))))\n; Man, this is not my best work quite frankly.","problem":53,"user":"4ebb20c0535dfed6da9c6d6f"},{"problem":53,"code":"(fn [v]\n    (let [r (reduce (fn [s e] (let [cur (:cur s)\n                                    le (last cur)]\n                                (if (or (nil? le) (> e le))\n                                  (assoc s :cur (conj cur e))\n                                  (if (> (count cur) (count (:plong s)))\n                                    {:cur   [e]\n                                     :plong cur}\n                                    (assoc s :cur [])))))\n                    {:cur   []\n                     :plong []}\n                    v)]\n      (let [cc (count (:cur r))\n            cl (count (:plong r))]\n        (cond\n          (and (> 2 cc) (> 2 cl)) []\n          (> cc cl) (:cur r)\n          :else (:plong r)))))","user":"57c94c54e4b05aa3c4741d2c"},{"problem":53,"code":"(fn [c] (let [r (loop [c c\n                        acc []\n                        longest []]\n                   (if (> (count c) 0)\n                     (let [f (first c)\n                           acc2 (if\n                                  (and (> (count acc) 0) (>= (last acc) f))\n                                  [f]\n                                  (conj acc f))]\n                       (recur (rest c)\n                              acc2\n                              (if (> (count acc2) (count longest))\n                                acc2\n                                longest)))\n                     longest))]\n           (if (> (count r) 1) r [])))","user":"54a854f5e4b09f271ff37ca2"},{"problem":53,"code":"(fn [[c & cs]]\n  ((fn f [X [a & b] R]\n    (let [R (if (> (count X) (max 1 (count R))) X R)]\n      (if (nil? a) R\n        (f (if (> a (last X)) (conj X a) [a]) b R))))\n  [c] cs []))","user":"53500869e4b084c2834f4ad3"},{"problem":53,"code":"(fn [l]\n (let [delta (fn [a [x & r]]\n                  (if (nil? r)\n                    a\n                    (recur (cons (- (first r) x) a) r)))]\n    (let [get-indices (fn [x]\n                        (map first\n                     (filter #(= (second %) 1)\n                      (apply max-key count\n                              (reverse\n                           (partition-by second\n                             (map-indexed #(list %1 %2)\n                                          (reverse\n                                            (delta '() x)))))))))\n          ]\n      (let [get-pos-len \n            (fn [x]\n              (let [idx (get-indices x)]\n                [(first idx) (inc (count idx))]))]\n       \n        (let [[d t] (get-pos-len l)]\n          (if (> t 1)\n            (take t (drop d l))\n            '())\n          )\n      )\n    )\n ))","user":"54c169ade4b0ed20f4ff6f24"},{"code":"(fn [coll]\n\t(->> coll\n\t\t(map-indexed (fn [idx item] [item (- idx item)]))\n\t\t(partition-by (fn [[item idx]] (identity idx)))\n\t\t(filter #(> (count %) 1))\n\t\t(sort #(> (count %1) (count %2)))\n\t\tfirst\n\t\t(map #(first %))))","problem":53,"user":"5379306fe4b06839e8705e50"},{"code":"(fn inc-sub-seq [coll]\n    (loop [items (rest coll) res [[(first coll)]]]\n      (if (empty? items)\n        (let [sub-seqs (filter #(>= (count %) 2) res)\n              sub-seqs (interleave (map count sub-seqs) sub-seqs)]\n          (loop [[k v & subseqs] sub-seqs res {}]\n            (if-not k\n              (if  (< (count (keys res)) 1)\n                []\n                (res (apply max (keys res))))\n              (recur subseqs (if (res k)\n                               res\n                               (assoc res k v))))))\n        (recur (rest items) (let [last-n (->> res last last)\n                                 n (first items)]\n                             (cond (or (< n last-n)\n                                       (= n last-n)) (conj res [n])\n                                   (= (dec n) last-n)\n                                    (vec (conj (vec (butlast res)) (conj (last res) n)))\n                                   (> n last-n) (conj res [n])))))))","problem":53,"user":"50c113bee4b096f585049c37"},{"problem":53,"code":"(fn [seqq]\n    (let [longest (atom [])]\n    (reduce (fn [result number]\n              (let [res (conj result number)]\n                (cond (and (apply < res)\n                           (> (count res) (count @longest)))\n                      (reset! longest res)\n                      (apply < res) res\n                      :else [(last res)]))) [] seqq)\n    (if (> (count @longest) 1) @longest [])))","user":"60264d89e4b0d5df2af2222d"},{"code":"(fn [v]\n  (if (empty? v)\n    []\n    (let [n (count v)\n          f (fn [start i previous [best-start best-len :as best]]\n              (let [new-best (fn []\n                               (let [new-len (- i start)]\n                                 (if (and (> new-len 1) (< best-len (- i start)))\n                                   [start (- i start)]\n                                   [best-start best-len])))]\n                (if (= i n)\n                  (let [[start length] (new-best)]\n                    (subvec v start (+ start length)))\n                  (let [current (nth v i)]\n                    (if (> current previous)\n                      (recur start (inc i) current best)\n                      (recur i (inc i) current (new-best)))))))]\n      (f 0 0 (nth v 0) [0 0]))))","problem":53,"user":"4e39fb68535deb9a81d77f47"},{"problem":53,"code":"(fn [xs]\n  (letfn [(max-inc-seq [aseq] \n            (loop [xs (rest aseq) last-num (first aseq) max-v [1]]\n              (if (empty? xs) \n                max-v\n                (recur (rest xs) (first xs) (conj max-v (if (> (first xs) last-num) (inc (last max-v)) 1)))))   \n            )]\n    (let [mseq (max-inc-seq xs)\n          max-val (apply max mseq)\n          pos (ffirst (filter #(= (second %) max-val) (map-indexed vector mseq)))]\n      (if (<  max-val 2)\n        []\n        (subvec (vec xs) (inc (- pos max-val)) (inc pos))))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [x]\n  (loop [best-idx 0\n         best-len 0\n         current-idx 0\n         current-len 0]\n    (cond\n     ;; ate the whole thing, return our best\n     (= current-idx (dec (count x)))\n     (if (> best-len 0) (subvec x best-idx (inc (+ best-idx best-len))) [])\n\n     (= (+ current-idx current-len) (dec (count x)))\n     (recur best-idx best-len (inc current-idx) 0)\n\n     ;; we're increasing at current-idx\n     (> (nth x (+ current-idx (inc current-len))) (nth x (+ current-idx current-len)))\n     (if (> (inc current-len) best-len)\n       (recur current-idx (inc current-len) current-idx (inc current-len))\n       (recur best-idx best-len current-idx (inc current-len)))\n\n     :else\n     (recur best-idx best-len (inc current-idx) 0)\n     )))","problem":53,"user":"4e9e4515535dbda64a6f6b95"},{"problem":53,"code":"#(first (reduce \n\t(fn \n\t\t[coll el]\n\t\t(let \n\t\t\t[\n\t\t\t\tinorder  (= (last (last coll)) (dec el))\n\t\t\t\tgrowcoll (conj (last coll) el)\n\t\t\t\trpl (<= (count (first coll)) (count growcoll))\n\t\t\t]\n\t\t\t(if inorder (if rpl [growcoll growcoll] [(first coll) growcoll]) [(first coll) [el]])\n\n\t\t\t)\n\t\t)\n\t[[] [(first %)]] \n\t(rest %)\n))","user":"52570aeae4b0541d1855ba42"},{"code":"(fn [xs]\n  (let [s (butlast xs)\n           t (rest xs)\n           st (map #(vector %1 (- %2 %1)) s t)\n           p (partition-by second st)\n           f (filter #(= 1 (second (first %))) p)]\n    (if (empty? f)\n      []\n      (let [a (last (sort-by count f))\n            b (map first a)]\n        (concat b [(inc (last b))]))\n      )))","problem":53,"user":"4f251302e4b0d66497709ff0"},{"code":"#(loop [i [] c [] s %]\n   ;; i = incumbent c = candidate\n  (if (empty? s)\n    (cond (and (< (count i) 2) (< (count c) 2)) []\n          (> (count i) (count c)) i\n          :else c)\n    (cond (empty? c) (recur i [(first s)] (rest s))\n          (= (first s) (inc (last c))) (recur i (conj c (first s)) (rest s))\n          :else\n          (recur (if (> (count c) (count i)) c i) [(first s)] (rest s)))))","problem":53,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn sub[s]\n  (let [subb (fn [s curs maxs] \n             (let [x (first s)\n                    r (rest s)\n                    ncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\n                    nmax (max-key count ncurs maxs)]\n                 (if (seq r)\n                    (recur r ncurs nmax)\n                     nmax)))\n        longest (subb s [(first s)] [])]\n     (if (> (count longest) 1) longest [])))","problem":53,"user":"4f05ea25535dcb61093f6c02"},{"problem":53,"code":"(fn*\n [p1__2876#]\n (sort\n  (set\n   (flatten\n    (map\n     (fn [[a1 a2 a3]] (vector a2 a3))\n     (apply\n      max-key\n      count\n      (conj (reverse\n      (filter\n       ffirst\n      (partition-by\n       first\n       (map\n        (fn [[a1 a2]] (if (< a1 a2) (vector true a1 a2) (vector false a1 a2)))\n        (partition\n         2\n         (interleave\n          p1__2876#\n          (conj (vec (rest p1__2876#)) (last p1__2876#)))))))) '())))))))","user":"56ab7578e4b03c432f18733d"},{"problem":53,"code":"(fn f\n  [lst]\n  (let [val (into [] (reduce #(cond (> (count %1) (count %2)) %1 :else %2) ((fn g\n    [lst res]\n    (cond (empty? lst) res\n          :else        (recur (rest lst)\n                              (cons ((fn h\n                                [idx lst res]\n                                (cond (= idx (first lst)) (recur (inc idx) (rest lst) (cons (first lst) res))\n                                      :else               (reverse res)))\n                              (first lst) lst ()) res))))\n   lst ())))]\n    (cond (>= (count val) 2) val\n          :else              [])))","user":"56df62eee4b0ca2494a095f0"},{"problem":53,"code":"(fn [coll]\n  (reduce #(let [lena (count %)\n                 lenb (count %2)]\n             (if (and (> lenb 1) (> lenb lena)) %2 %))\n          []\n          (reductions\n            (fn [xs y] (if (> y (last xs)) (conj xs y) [y]))\n            [(first coll)]\n            (rest coll))))","user":"5a6af090e4b0512ff01cda2d"},{"problem":53,"code":"(fn [c] (first (reduce #(let [[best cur] %\n                              prev (last cur)]\n                         (if (and prev (> %2 prev))\n                           (if (> (inc (count cur)) (count best))\n                             (repeat 2 (conj cur %2))\n                             [best (conj cur %2)])\n                           [best [%2]])) [[] []] c)))","user":"55ccdc6be4b0e31453f64a18"},{"problem":53,"code":"#(loop [v (transient []) w nil xs %]\n   (if (= (first xs) nil)\n     (if (= 1 (apply max (map count w)))\n       []\n       (get (reduce (fn [x y] (assoc x (count y) y)) {} w) (apply max (map count w))))\n       (if (= (second xs) (inc (first xs)))\n       (recur (conj! v (first xs)) w (rest xs))\n       (recur (transient []) (conj w (persistent! (conj! v (first xs)))) (rest xs)))))","user":"58b989dbe4b0888cdc949ccd"},{"problem":53,"code":"(fn [s]\n  (let [r (reduce (fn [res x]\n                    (let [last-seq (last res)\n                          l (last last-seq)]\n                      (if (= l (dec x))\n                        (conj (vec (butlast res)) (conj last-seq x))\n                        (conj res [x]))))\n                  []\n                  s)\n        r (last (sort-by count r))]\n     (if (> (count r) 1) \n       r\n       [])))","user":"54df2609e4b024c67c0cf7a9"},{"code":"#(reduce (fn [longest s] (let [c (count s)] (if (and ( > c 1) ( > c (count longest))) s longest)))\n             []\n             (map (partial map second)\n                  ((fn separate [pairs]\n                     (when (seq pairs)\n                       (let [run (cons (first pairs) (take-while (partial apply <) (rest pairs)))]\n                         (cons run (separate (drop (count run) pairs))))))\n                   (map vector (cons nil %) %))))","problem":53,"user":"52746701e4b03e8d9a4a74a2"},{"problem":53,"code":"(fn [coll]\n  (let [[longest]\n        (reduce\n          (fn [[longest current last] next-val]\n            (let [new-seq (if (= last (dec next-val))\n                            (conj current next-val)\n                            [next-val])\n                  new-longest (if (> (count new-seq) (count longest))\n                                new-seq\n                                longest)]\n              [new-longest new-seq next-val]))\n          []\n          coll)]\n    (if (= 1 (count longest))\n      []\n      longest)))","user":"515ef58be4b02c55805ea237"},{"code":"(fn f [coll]\n  (let [ diff (map #(if (= % 1 ) 1 0 ) (map - (rest coll ) (drop-last coll )))\n         label-list  (partition-by #(= 1 %) diff) ]\n    (if (and (= (count label-list) 1) (every? zero? (first label-list)))\n      []\n      (let [ maxl (apply max (map count (filter #(every? (complement zero?) %) label-list)))\n             offset (apply + (map count (take-while #(or (not= maxl (count % )) (some zero? %) ) label-list)))]\n        (take (+ maxl 1)  (drop offset coll))))))","problem":53,"user":"518c5236e4b087e178201de0"},{"problem":53,"code":"(fn longest-increasing-sequence\n  [r]\n  (vec (flatten (filter #(> (count %) 1) [(apply max-key count \n         (reverse \n          ((fn [s] (loop [old-seq s  \n                          new-seq []]\n                     (if (empty? old-seq)\n                       new-seq\n                       (do \n                         (let [ss ((fn inc-ss ([t r] \n                                               (if (= (inc (first t)) (second t))\n                                                 (inc-ss (next t) (conj r (first t)))\n                                                 [(next t) (conj r (first t))])) ) old-seq [])]\n                           (recur (first ss) (conj new-seq (last ss)))))))) \n           r)))]))))","user":"55acd080e4b03311e7b73298"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n       (partition 2 1)\n       (partition-by (partial apply <))\n       (filter (comp (partial apply <) first))\n       (reduce #(if (>= (count %1) (count %2)) %1 %2) [])\n       flatten\n       distinct))","user":"5829d9f8e4b051871117bf4d"},{"problem":53,"code":"(fn lseq\n\t[coll]\n\t(->> (map list coll (rest coll))\n\t\t (partition-by #(apply < %))\n\t\t (filter #(< (ffirst %) (second (first %))))\n\t\t (reverse)\n\t\t ((fn [coll]\n\t\t\t (if (empty? coll)\n\t\t \t\t ()\n\t\t\t\t (->> (apply max-key count coll)\n\t\t\t\t\t  ((fn [coll] (cons (ffirst coll) (map second coll))))))))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"code":"#((comp distinct flatten)\n  (let [< (partial apply <)]\n    (reduce\n     (fn [acc el] (if (and (every? < el) (< (map count [acc el]))) el acc))\n\t []\n\t (partition-by < (partition 2 1 %)))))","problem":53,"user":"5142ea50e4b0c172af7558ca"},{"problem":53,"code":"#(let [longest (first\n                 (reduce\n                   (fn [[longest current] x]\n                     (let [tail (last current)\n                           next-seq (if (or (not tail) (> x tail))\n                                      (conj current x)\n                                      [x])\n                           new-longest (if (> (count next-seq) (count longest))\n                                         next-seq\n                                         longest)]\n                       [new-longest next-seq]))\n                   [[][]]\n                   %))]\n   (if (>= (count longest) 2)\n     longest\n     []))","user":"58b2c435e4b0ebc645576d11"},{"problem":53,"code":"(fn lis [ v ] \n  (->> v \n  \t\t(partition 2 1)\n       \t(partition-by #(< (first %) (last %)))\n       \t(filter  #(< (ffirst %) (last (first %))))        \n        (map #(conj (vec (map first %)) (last (last %))))\n       \t(reverse)\n       \t(apply max-key count [])    \t \t\t       \n\t\t)\n)","user":"57887de2e4b0ebec4cfb751c"},{"problem":53,"code":"(fn [coll] \n  (loop [remaining coll\n         current []\n         longest []]\n    (println remaining longest current)\n    (if (empty? remaining)\n      (if (> (count (max-key count current longest)) 1) (max-key count current longest) [])\n      (if (or (empty? current) (> (first remaining) (peek current)))\n        (recur (rest remaining) (conj current (first remaining)) longest)\n        (recur remaining [] (max-key count current longest))\n        )\n      )))","user":"545b0275e4b01be26fd74648"},{"problem":53,"code":"(fn longest-subseq [s]\n  (letfn [(f [a b]\n            (if (> b (last a))\n              (conj a b)\n              [b]))]\n    (let [increasing-subseqs (filter #(> (count %) 1)\n                                     (reverse (reductions f [(first s)] (rest s))))]\n      (if (empty? increasing-subseqs)\n        []\n        (apply max-key count increasing-subseqs)))))","user":"5ab564f8e4b073f177442639"},{"code":"(fn [xs]\n  (let [valid? (fn [ys] (every? (fn [[a b]] (= (inc a) b))\n                                (partition 2 1 ys)))\n        perms (for [n (range (dec (count xs)))] (drop n xs))\n        perms2 (mapcat #(for [n (range (dec (count %)))] (drop-last n %)) perms)\n        valid (filter valid? perms2)]\n    (vec (last (sort-by count valid)))))","problem":53,"user":"511f9625e4b085952a835362"},{"problem":53,"code":"(fn [xs]\n  (loop [input (apply list xs)\n         longest []]\n    (if (empty? input)\n      (if (>= (count longest) 2) longest '())\n      (let [r1 (map #(vector %1 %2) input (iterate inc (first input)))\n            r2 (take-while (fn [[a b]] (= a b)) r1)\n            r3 (map first r2)]\n        (recur (rest input) (if (> (count r3) (count longest)) r3 longest))))))","user":"5947c6a6e4b07ddc2dafada7"},{"problem":53,"code":"(fn [coll]\n  (let [{:keys [all current]} (reduce\n                               (fn [{:keys [current all] :as acc} x]\n                                 (prn 'things current all x)\n                                 (if (seq current)\n                                   (if (> x (last current))\n                                     (update-in acc [:current] conj x)\n                                     (-> acc\n                                         (update-in [:all] conj current)\n                                         (assoc :current [x])))\n                                   (assoc acc :current [x])))\n                               {:current [(first coll)]\n                                :all []}\n                               (next coll))\n        all (reverse (sort-by count (conj all current)))\n        max (count (first all))\n        candidate (last (take-while #(= max (count %)) all))]\n    (if (>= (count candidate) 2)\n      candidate\n      [])))","user":"4db6d993535d1e037afb2180"},{"problem":53,"code":"(fn [c]\n   (distinct\n    (flatten\n     (first\n      (filter #(< (ffirst %) (second (first %)))\n              (sort-by (comp - count)\n                       (partition-by #(apply < %) (partition 2 1 c))))))))","user":"5c950334e4b048ec896c5a44"},{"code":"#({1 [0 1 2 3] 5 [5 6] 2 [3 4 5] 7 []} (% 0))","problem":53,"user":"5336a339e4b0e30313ee6c7d"},{"problem":53,"code":";;- Generate all sub-sequences of length > 1\n;;- Filter to keep only increasing subsequences\n;;- Tack on the empty sequence, which is what needs to be returned if there\n;;  are no increasing sub-sequences\n;;- Sort by length in descending order\n;;- Take the first (longest)\n\n(fn [coll]\n(let [increasing? (fn [xs] (apply < xs))\nn (count coll)\nsub-seqs (mapcat #(partition % 1 coll) (range 2 (inc n)))]\n(->> sub-seqs\n(filter increasing?)\n(cons [])\n(sort-by count >)\nfirst)))","user":"558a81fbe4b027778923761c"},{"problem":53,"code":"(partial (fn [l c o] (let [nex  (if (#(= (inc (- (last %) (first %))) (count %)) (conj c (first o))) (conj c (first o)) (vector (first o)))] (let [longest  (#(if (and     (>  (count %2) (count %1))  (> (count %2) 1)  ) %2 %1) l nex)] (if (empty? (rest o)) longest (recur longest nex (rest o)) )))) [] [])","user":"5b5874cfe4b02d533a91bd6a"},{"problem":53,"code":"(fn [c]\n  (let [s  (loop [[x & o :as c] c l nil s [] r []]\n             (if x\n                 (if (or (nil? l) (> x l))\n                     (recur o x (conj s x) r)\n                     (recur c nil [] (cons s r)))\n                 (filter #(> (count %) 1) (cons s r))))]\n    (if (seq s) (apply max-key count s) [])))","user":"514d8084e4b019235f6c0588"},{"code":"(fn [xs]\n    (let [membership (map-indexed\n                      (fn [i [x y]] [(< x y) i])\n                      (partition 2 1 xs))\n          part-by-membership (partition-by #(first %) membership)\n          runs (filter #(first (first %)) part-by-membership)\n          longest-run (reduce #(if (>= (count %) (count %2)) % %2) [] runs)]\n      (if (empty? longest-run)\n        (list)\n        (->> xs\n            (drop (second (first longest-run)))\n            (take (+ 1 (count longest-run)))))))","problem":53,"user":"4e50ad74535dc968683fc4ec"},{"problem":53,"code":"#(loop [best [] candidate [] remaining %]\n   (cond\n    (empty? remaining) (if (> (count candidate) (count best)) (if (> (count candidate) 2) candidate best) best)\n    (empty? candidate) (recur best [(first remaining)] (rest remaining))\n    (= 1 (- (first remaining) (last candidate))) (recur best (concat candidate [(first remaining)]) (rest remaining))\n    (> (count candidate) 1) (recur (if (> (count candidate) (count best)) candidate best) [(first remaining)] (rest remaining))\n    :else (recur best [(first remaining)] (rest remaining))))","user":"55d332f5e4b0e31453f64a5f"},{"problem":53,"code":"(#(fn [coll]\n            (loop [flag 0\n                   tmp-result {flag [(first coll)]}\n                   index 0]\n              (if (< index (- (count coll) 1))\n                (let [current (nth coll index)\n                      next (nth coll (inc index))]\n                  (if (> next current)\n                    (recur flag (assoc tmp-result flag (conj (tmp-result flag) next)) (inc index))\n                    (recur (inc flag) (assoc tmp-result (inc flag) [next]) (inc index))))\n                (let [tmp (vals tmp-result)]\n                  (loop [final (first tmp)\n                         s (next tmp)]\n                    (if (first s)\n                      (if (>= (count (first s)) (count final))\n                        (recur (first s) (next s))\n                        (recur final (next s)))\n                      (if (> (count final) 1)\n                        final\n                        []))))))))","user":"5e954b9ee4b0fbed045a3809"},{"code":"(fn [s]\n  (loop [i (rest s), r [(first s)], res []]\n    (if (empty? i) \n      (if (> (count r) (count res) 0) r res)\n      (recur\n        (rest i)\n        (if (> (first i) (last r)) \n          (conj r (first i))\n          [(first i)])\n        (if (and (> (count r) 1) (> (count r) (count res)))\n          r\n          res)))))","problem":53,"user":"50aab057e4b056ee0193586b"},{"problem":53,"code":"#(let [[e]\n          (reduce\n           (fn [v i]\n             (let [[f [l :as c]] v\n                   n (cons i c)]\n               (if (or (empty? c) (> i l))\n                   (if (> (count n) (count f))\n                       [n n]\n                       [f n])\n                   [f (list i)])))\n           [() ()]\n           %)]\n  (if (>= (count e) 2)\n      (reverse e)\n      []))","user":"5742ec91e4b05c31a32c0883"},{"problem":53,"code":"#(reverse (\n   (fn f [best cur rst]\n    (cond\n      (empty? rst)\n      (let [r (if (> (count cur) (count best)) cur best)]\n        (if (> (count r) 1) r '()))\n\n      (empty? cur)\n      (f best (list (first rst)) (rest rst))\n      \n      (> (first rst) (first cur))\n      (f best (conj cur (first rst)) (rest rst))\n          \n      (> (count cur) (count best))\n      (f cur (list (first rst)) (rest rst))\n          \n      :default\n      (f best (list (first rst)) (rest rst))\n    )\n   )\n  '() '() %)\n)","user":"5ab1665de4b073f1774425c0"},{"code":"(fn [xs]\n  (->> xs\n       (map #(vector % %2) (range))\n       (partition-by #(- (last %) (first %)))\n       reverse\n       (apply max-key count)\n       (map last)\n       (#(if (< (count %) 2) [] %))))","problem":53,"user":"50217818e4b00bba4502f7a7"},{"problem":53,"code":"(fn [v]\n  (let [i (reduce #(if (> %2 (last (last %1)))\n                     ;; add on end\n                     (assoc %1 (count %1) (conj (last %1) %2))\n                     ;; start new sequence\n                     (conj %1 [%2]))\n                  [[(first v)]] \n                  (rest v)) \n        l (apply max (map #(count %) i))\n        a (filter #(= l (count %)) i)\n        ]\n    (if (> l 1)\n      (first a)\n      [] )))","user":"53c1ce3ee4b00fb29b221268"},{"problem":53,"code":"(fn prob53 [s]\n  (->> (partition 2 1 s)\n       (partition-by (fn [[p1 p2]] (> p2 p1)))   ;; grouped by results of function \n\n       ;; ( ((1 0)) ((0 1) (1 2) (2 3)) ((3 0)) ((0 4) (4 5)) )\n\n       ;; pull out the groups into new sequences\n       ;; a. map first of each element into a vector gets the first of teach subgroup\n       ;;  ([1] [0 1 2] [3] [0 4]) \n       ;; b. need to pick up the very last item\n       ;; ([1 0] [0 1 2 3] [3 0] [0 4 5])\n       (map \n        #(conj\n          (into [] (map first %)) (last (last %)))\n        )\n\n       (filter (fn [[a b]] (> b a)))    ;; pick the ones with increasing vlaues\n       ;; ([0 1 2 3] [0 4 5])\n\n       (reduce (fn [a b] (if (>  (count b) (count a)) b a)) [])  ;; pick the longest\n       ;; [0 1 2 3]\n       ))","user":"4ebbff41535dfed6da9c6d78"},{"problem":53,"code":"(fn [coll]\n    (let [inc? (fn [[x y]] (= (inc x) y))\n          llast (comp last last)\n          xs (->> coll\n                  (partition 2 1)\n                  (partition-by inc?)\n                  (filter (comp inc? first)))]\n      (if (empty? xs)\n        []\n        (let [longest (apply max-key count xs)]\n          (conj (mapv first longest) (llast longest))))))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":53,"code":"(fn [coll]\n   (->> coll \n       ((fn [coll]\n          (cond (empty? coll) []\n                :else\n                 (loop [num (first coll)\n                        coll-acc [(vector num)]\n                        coll (rest coll)]\n                   (cond (empty? coll) coll-acc\n                         (= (- (first coll ) num) 1)\n                         (recur (first coll)\n                                (conj (subvec coll-acc 0 (dec (count coll-acc)))\n                                      (conj (last coll-acc) (first coll)))\n                                (rest coll))\n                         :else\n                         (recur (first coll) (conj coll-acc (vector (first coll))) (rest coll)))))))\n       (group-by count)\n       ((fn [coll]\n          (if (< (apply max (keys coll)) 2)\n            []\n          \t(first (coll (apply max (keys coll)))))))))","user":"5e724492e4b085ba37836dc7"},{"problem":53,"code":"(fn [sx] (get (reduce #(\n          if (= (dec %2) (get %1 :v))\n            (if (and (>= (count (get %1 :cs)) (count (get %1 :maxs))) (>= (count (get %1 :cs)) 2)  )\n              {:v %2 :cs (concat (get %1 :cs) [%2]) :maxs (concat (get %1 :cs) [%2])}\n              {:v %2 :cs (concat (get %1 :cs) [%2]) :maxs (get %1 :maxs)}\n            )\n            (if (and (>= (count (get %1 :cs)) (count (get %1 :maxs))) (>= (count (get %1 :cs)) 2)  )\n              {:v %2 :cs [%2] :maxs (get %1 :cs)}\n              {:v %2 :cs [%2] :maxs (get %1 :maxs)}\n              )\n           ) {:v (first sx)  :cs [] :maxs [] } sx) :maxs))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn inc-sub [s]\n  (letfn [(valid? [s] (= s (take (count s) (iterate inc (first s)))))\n          (subs [n] (partition n 1 s))]\n    (into [] (first (filter valid? (mapcat subs (range (count s) 1 -1)))))))","problem":53,"user":"51672d15e4b079759a74a5e7"},{"problem":53,"code":"(fn [c]  \n    (reverse \n      (reduce\n        #(if (or\n               (< (count %2) 2)\n               (> (count %1) (count %2))) %1 %2) \n        '()\n       \t(loop [c c\n               g '()]\n          (if (empty? c)\n\t\t    g\n           \t(let [fc (first c)\n               \t  fg (first g)]\n         \t  (recur (rest c) \n                     (if (or (nil? fg) (<= fc (first fg)))\n                        (conj g (list fc))\n                        (conj (rest g) (conj fg fc))))))))))","user":"561047eae4b05f002753df6d"},{"problem":53,"code":"(fn [input] (let [sequence-map (reduce (fn [seq y]\n              (if (or (nil? (last (:current seq)))\n                                     (> y (last (:current seq))))\n                (assoc seq :current (concat (:current seq) (list y)))\n                (assoc seq :sequences (concat (:sequences seq) (list (:current seq)))\n                           :current (list y)))) {:current [] :sequences []} input)\n      as-list (concat (:sequences sequence-map) (list (:current sequence-map)))\n      longest (reduce (fn [l v] (if (> (count v) (count l)) v l)) as-list)]\n  (if (> (count longest) 1) longest [])))","user":"4e9ff8d0535d7eef3080729c"},{"problem":53,"code":"(fn [xcoll]\n  (->>\n   (reduce (fn [xrcoll xitem]\n             (let [x (last (last xrcoll))]\n               (if (< x xitem)\n                 (conj (into [] (drop-last xrcoll)) (conj (last xrcoll) xitem))\n                 (conj xrcoll [xitem]))))\n           [[(dec (first xcoll))]] xcoll)\n\n   ((fn [coll]\n      (reduce (fn [a b]\n                (if (< (count a) (count b)) b a))\n              (rest (first coll))\n              (rest coll))))\n\n   ((fn [coll]\n      (if (< (count coll) 2)\n        [] coll)))))","user":"591072e0e4b0163c97b36ebc"},{"problem":53,"code":"(fn [xs]\n  (let [a (map #(vector %1 (> %1 %2)) xs (cons (first xs) xs))\n        b (reduce #(let [n (if (second %2) (first %1) (inc (first %1)))] (vector n (conj (second %1) (vector (first %2) n)))) [0 []] a)\n        c (partition-by #(second %1) (second b))\n        d (group-by count (map #(map first %1) c))\n        e (apply max (keys d))\n        f (first (get d e))\n        ]\n        (if (> (count f) 1) f (vector))\n  )\n)","user":"5aeec90fe4b0cc2b61a3bc31"},{"code":"(fn longest-increasing-subseq [xs]\n  (letfn [(inc-subseq [xs accum]\n            (if (or (empty? xs) (and (seq accum) (<= (first xs) (last accum)))) \n              (if (>= (count accum) 2) accum [])\n              (recur (rest xs) (conj accum (first xs)))))]\n    (loop [xs xs longest []]\n      (if (empty? xs)\n        longest\n        (let [s (inc-subseq xs [])]\n          (if (> (count s) (count longest))\n            (recur (rest xs) s)\n            (recur (rest xs) longest)))))))","problem":53,"user":"4e50b67b535dc968683fc4ed"},{"problem":53,"code":"(fn  [i_array]\n  (reverse (last (sort-by count (filter #(> (count %) 1) \n    (reduce #(let [current_collection (first (first %1)) expected_value (inc current_collection)]\n      (if (= %2 expected_value)\n        (conj (butlast %1) (conj (first %1) %2))\n        (conj %1 (list %2))         \n        ))\n    (conj '() (list (first i_array)))\n    (rest i_array)))))))","user":"5ac92dc3e4b0e27600da77bf"},{"problem":53,"code":"(fn [nums]\n   (->> nums\n        (map-indexed #(if (= %2 (inc (nth nums (dec %1) (dec %2))))\n                        [%2] [nil %2])) \n        (apply concat)\n        (partition-by nil?)\n        (filter (comp not nil? first))\n        (filter #(< 1 (count %)))\n        (sort-by count)\n        reverse\n        (#(if (empty? %) [] (first %)))\n        ))","user":"54da46e5e4b024c67c0cf753"},{"code":"(fn [coll] \n  (->> (map vector (into [nil] coll) coll)\n       (reduce (fn [r [prev elem]]\n                 (if (= prev (dec elem))\n                   (update-in r [(dec (count r))] #(conj % elem))\n                   (conj r [elem])))\n               [])\n       (map #(if (> (count %) 1) % []))\n       (sort-by count >)\n       (first)))","problem":53,"user":"4fb01e53e4b081705acca260"},{"code":"(fn [s]\n  (->> (map vector s (rest s))\n       (partition-by (fn [[a b]] (< a b)))\n       (map #(conj (map second %) (first (first %))))\n       (filter (partial apply <))\n       (reverse)\n       (#(when (not (empty? %)) (apply max-key count %)))\n       (vec)))","problem":53,"user":"519ef784e4b087743fad2198"},{"problem":53,"code":"(fn [coll]\n    (loop [[x & xs] coll, longest [], current []]\n      (let [increasing? ((fnil < Integer/MIN_VALUE) (last current) x)\n            new-current (if increasing? (conj current x) [x])\n            new-longest (if (> (count new-current) (count longest)) new-current longest)]\n        (if xs\n          (recur xs\n                 new-longest\n                 new-current)\n          (if (< 1 (count new-longest)) new-longest [])))))","user":"4daddc19c9a9d6ed4599dc57"},{"problem":53,"code":"(fn [coll]\n    (loop [longest []\n           current []\n           [next-num & unchecked] coll]\n      (cond\n        (nil? next-num)\n        longest\n\n        (empty? current)\n        (recur longest\n               [next-num]\n               unchecked)\n\n        (<= next-num (last current))\n        (recur longest\n               [next-num]\n               unchecked)\n\n        (>= (count current) (count longest))\n        (let [new-current (conj current next-num)]\n          (recur\n           new-current\n           new-current\n           unchecked))\n\n        :else\n        (recur\n         longest\n         (conj current next-num)\n         unchecked)\n        )))","user":"539fa040e4b0ca733b97449f"},{"problem":53,"code":"(fn lis [v] (loop [lis [] clis [(first v)] rem v]\n  (let [f (first rem) nlis (if (> (count clis) (count lis)) clis lis) ]\n (if (empty? rem) (if (>= (count nlis) 2) nlis []) (recur nlis (if (> f (last clis)) (conj clis f) [f]) (rest rem))))))","user":"55c9bc1ee4b0e31453f649f1"},{"code":"(fn [p] (flatten ( last ( filter #(> ( count %) 1) (sort-by count ( \n                                (fn part-by-vals [func seqs]\n                                  (let [part (fn [seqs] \n                                               (loop [coll (rest seqs) res (list (first seqs))]\n                                                 (if (empty? coll) \n                                                   res\n                                                   (if (not (func (first coll) (first res))) \n                                                     res\n                                                     (recur (rest coll) (conj res (first coll)))))))]\n                                    (loop [res '() seqs (reverse seqs)]\n                                      (if (empty? seqs)\n                                        res\n                                        (recur (conj res (part seqs)) (drop (count (part seqs)) seqs))))))\n                                #(= (inc  %1) %2) p)\n                 \n)))))","problem":53,"user":"5364ab34e4b0243289761e64"},{"problem":53,"code":"(fn [x]\n  (->> (for [i (range (count x))\n             j (range (inc i) (count x))\n             :when (= (subvec x i (inc j))\n                      (range (nth x i) (inc (nth x j))))]\n\n         (subvec x i (inc j)))\n       (into [[]])\n       sort\n       last))","user":"5c2836ebe4b07e362c2305d4"},{"code":"(fn [s]\n  (loop [x s fw [] best []]\n    (cond\n      (empty? x) best\n      (and (not-empty fw) (= (inc (last fw)) (first x))) (let [nfw (conj fw (first x))]\n                                                           (if (> (count nfw) (count best))\n                                                             (recur (rest x) nfw nfw)\n                                                             (recur (rest x) nfw best)))\n      :else (recur (rest x) [(first x)] best))))","problem":53,"user":"527cd633e4b0757a1b17136f"},{"code":"#(loop [l %\n        acc []]\n   (if (empty? l) acc\n     (let [n (loop [n 1\n                    l l]\n               (if (not= (inc (first l)) (second l)) n\n                 (recur (inc n) (rest l))))]\n       (recur (drop n l) (if (and (> n 1) (> n (count acc))) (take n l) acc)))))","problem":53,"user":"537e745ae4b06839e8705ea6"},{"problem":53,"code":"(fn [s]\n  (->> (map-indexed (fn [i e]\n                    (loop [i' i\n                           r []]\n                      (if (and (< i' (count s))\n                               (or (empty? r)\n                                   (= (-> r last inc) (nth s i'))))\n                        (recur (+ 1 i') (conj r (nth s i')))\n                        r)))\n                  s)\n       (map #(if (< (count %) 2)\n               []\n               %))\n       (sort-by count)\n       reverse\n       first))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn iseq[coll]\n (let [m (reduce\n  #(if (< (count %1) (count %2)) %2 %1)\n  (reduce\n   #(cond\n     (empty? %1) (list (list %2))\n     (>= (last (last %1)) %2) (concat %1 (list (list %2)))\n     (<  (last (last %1)) %2) (concat (butlast %1) (list (concat (last %1) (list %2)))))\n   '() coll))]\n  (if (= (count m) 1) '() m)))","problem":53,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":53,"code":"(fn [xs]\n   (let [longest \n   (loop [[hd & tl :as remaining] (rest xs)\n          prev-n (first xs)\n          current [(first xs)]\n          biggest [(first xs)]]\n     (let [biggest-next (if (> (count current) (count biggest)) current biggest)]\n       (cond (empty? remaining) biggest-next\n             (> hd prev-n) (recur tl hd (conj current hd) biggest-next)\n             :else (recur tl hd [hd] biggest-next))))]\n     (if (<= 2 (count longest))\n       longest\n       [])))","user":"58a47197e4b01a0c0b2328f9"},{"problem":53,"code":"(fn longest-sub-seq [coll]\n  (let [next-int? (fn [[a b]] (= (inc a) b))]\n    (or (last (sort-by count (map distinct (filter next-int? (map flatten (partition-by next-int? (partition-all 2 1 coll))))))) [])))","user":"5146f343e4b04ef915e3731e"},{"problem":53,"code":"(fn [col]\n   (let [s (dec (count col))]\n    ((comp\n       #(if (= (count %) 1) [] %)\n       (partial reduce (fn [sum itm] (if (< (count sum) (count itm)) itm sum)))\n      #(map (fn [a b]\n              (if (< (last a) (first b)) (conj a (first b) ) a)\n              ) % (rest %))\n      (partial map (fn [arr] (vec (map #(nth % 0) arr))))\n      (partial partition-by #(if (nth % 1) :inc %))\n      (partial map-indexed\n        #(vec\n           [%2\n             (< %2\n                (nth col (min (inc %1) s))\n            )]\n        ))\n      )\n        col)))","user":"571e5c9ee4b0145328a76290"},{"code":"(fn [v] (->> v\n     (#(map list % (rest %)))\n     ((letfn [(sf [coll]\n                 (if (seq coll)\n                   (conj (sf (next coll)) (seq coll))\n                   [()]))]\n       sf))\n     (map (partial take-while #(< (first %) (second %))))\n     (filter not-empty)\n     (map #(conj (map last %) (first (first %))))\n     (reduce #(if (> (count %1) (count %2)) %1 %2) [])\n     vec))","problem":53,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":53,"code":"(fn liss [s]\n\t(loop [[x y :as s] s, result [], midresult []]\n\t\t(if (empty? s)\n\t\t\tresult\n\t\t\t(if (= y (inc x))\n\t\t\t\t(if (empty? midresult)\n\t\t\t\t\t(recur (rest s) result [x y])\n\t\t\t\t\t(recur (rest s) result (conj midresult y)))\n\t\t\t\t(if (> (count midresult) (count result))\n\t\t\t\t\t(recur (rest s) midresult [])\n\t\t\t\t\t(recur (rest s) result []))\n\t\t\t))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":53,"code":"(fn longest-sub-seq [coll]\n  (loop [[first-el & rest-el] coll\n         longest-seq []\n         consecutive-seq []]\n    (cond\n      (nil? first-el) longest-seq\n      (= first-el ((fnil inc first-el) (last consecutive-seq)))\n        (recur\n          rest-el\n          (max-key count longest-seq (conj consecutive-seq first-el))\n          (conj consecutive-seq first-el))\n      :else (recur\n              rest-el\n              longest-seq\n              [first-el]))))","user":"5b60e88be4b0c6492753e70b"},{"code":"#(loop [coll % curr [] longest []]\n  (if (empty? coll)\n    (if (> (count longest) 1)\n      longest\n      [])\n    (if (or (empty? curr) (= (first coll) (-> curr last inc)))\n      (let [newcurr (conj curr (first coll))]\n        (if (> (count newcurr) (count longest))\n          (recur (rest coll) newcurr newcurr)\n          (recur (rest coll) newcurr longest)))\n      (recur (rest coll) (vector (first coll)) longest))))","problem":53,"user":"4ec5a5f9535d6d7199dd36ad"},{"problem":53,"code":"(fn [input]\n   (let [sub-seqs\n         (reduce\n           (fn [acc x]\n             (if (< (ffirst acc) x)\n               (reduce cons [x (first acc) (rest acc)])\n               (cons (list x) acc)\n               )\n             ) (list (list (first input))) (rest input))\n\n         max-length\n         (apply max (map count sub-seqs))]\n\n     (if (< max-length 2)\n       []\n       (let [max-seqs\n             (filter #(= max-length (count %)) sub-seqs)]\n         (reverse (last max-seqs))\n         )\n       )\n     ))","user":"5727031ee4b0c5bde472c12f"},{"problem":53,"code":"(fn\n  [s]\n  (let [res (->> s\n                 (reduce\n                  (fn [x y]\n                    (println x)\n                    (if (or (empty? (last x))\n                            (= (dec y) (last (last x))))\n                      (conj (vec (butlast x)) (conj (last x) y))\n                      (conj x [y])))\n                  [[]])\n                 (sort-by count)\n                 last)]\n    (if (> (count res) 1)\n      res\n      [])))","user":"53e0001be4b0d874e779ae48"},{"code":"(fn [coll]\n  (first (reduce \n   (fn [accum x]\n     (let [[champ contender] accum\n           new-contender (if (apply > x (reverse contender))\n                           (conj contender x)\n                           [x])\n           new-len (count new-contender)\n           new-champ (if (and (> new-len 1) \n                              (> new-len (count champ)))\n                       new-contender champ)\n           ]\n       (println new-contender)\n       [new-champ new-contender]\n       ))\n\n   [[][]] \n   coll))\n)\n;(fn [coll]\n;  (let \n;    [pairs (partition 2 1 coll)\n;     runs-pairs (partition-by (fn [[a b]] (< a b)) pairs)\n;     ascending-pairs (filter #(apply < (first %)) runs-pairs)\n;     flat-chunks (map #(cons (first (first %)) (map second %)) ascending-pairs)\n;     max-len (apply max 0 (map count flat-chunks))\n;     ]\n;    max-len\n;    (or (some #(if (= max-len (count %)) %) flat-chunks)\n;        [])\n;  )\n;)","problem":53,"user":"502bb7c0e4b0194ad32ea1a3"},{"problem":53,"code":"(fn [xs]\n  (loop [longs [] acc [] xs xs]\n    (if (empty? xs)\n      (let [result (first (sort #(> (count %1) (count %2)) (conj longs acc)))]\n        (if (<= (count result) 1) [] result))\n      (if (empty? acc)\n        (recur longs [(first xs)] (rest xs))\n        (if (<= (first xs) (last acc))\n        (recur (conj longs acc) [(first xs)] (rest xs))        \n        (recur longs (conj acc (first xs)) (rest xs)))))))","user":"58800fd4e4b0f1effa3b7606"},{"code":"(fn [x]\n  (loop [i 0]\n    (if (nil? (first (filter #(apply < %) (partition (- (count x) i) 1 x))))\n      (if (= 2 (- (count x) i)) \n        []\n        (recur (inc i)))\n      (first (filter #(apply < %) (partition (- (count x) i) 1 x))))))","problem":53,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":53,"code":"(fn longest-increasing-subseq\n  [xs]\n  (->>\n     xs\n     ; Build lists of increasing values\n     ((fn [coll]\n       (let [switch (reductions = true (map < coll (rest coll)))]\n         (map (partial map first) (partition-by second (map list coll switch))))))\n     (filter #(< 1 (count %)))\n     (reduce #(if (< (count %) (count %2)) %2 %) [])\n     (vec)))","user":"56efc9fde4b04a395b9a0464"},{"code":"#(let [q (loop [[a b & c :as s] %, t [a], r [] ]\n           (if b\n               (if (> b a)\n                   (recur (rest s) (conj t b) r)\n                   (recur (rest s) [b] (if (> (count t) 1) (conj r t) r)))\n               (if (> (count t) 1) (conj r t) r))) \n       g (group-by count q) ]\n    (if (empty? g) [] (first (g (->> g keys (apply max)))) ))","problem":53,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn [l] (let\n          [res (reduce\n            (fn [x y] (if (< (count x) (count y)) y x))\n            (map\n             (fn longest [l] (if\n                               (= (+ 1 (first l)) (second l))\n                               (cons (first l) (longest (rest l)))\n                               (take 1 l)\n                             )\n             )\n             (map #(drop % l) (range 0 (- (count l) 1)))\n            )\n          )]\n          (if (> (count res) 1) res (rest res))\n        )\n)","problem":53,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn max-sub-seq [coll]\n  (let [sub (fn sub [coll acc]\n              (if (not (seq coll))\n                acc\n                (if (not (second coll))\n                  (conj acc (first coll))\n                  (if (= (+ 1 (first coll)) (second coll))\n                    (recur (rest coll) (conj acc (first coll)))\n                    (conj acc (first coll))))))\n        step (fn step [coll max acc]\n               (if (not (seq coll))\n                 acc\n                 (let [subseq (sub coll [])\n                       len (count subseq)]\n                   (if (> len max)\n                     (recur (drop len coll) len subseq)\n                     (recur (drop len coll) max acc)))))\n        result (step coll 0 [])]\n    (if (= 1 (count result))\n      []\n      result)))","problem":53,"user":"5163a7bbe4b055933a9ca02f"},{"code":"(fn lseq [in-vals]\n  (letfn\n      [(better-seq [seq1 seq2]\n         (if (> (count seq2) (count seq1)) seq2 seq1))\n       (lseq2 [vals]\n         (loop [current-max []\n                current-seq []\n                items vals]\n           (if-not (seq items)\n             (better-seq current-max current-seq)\n             (if (every? #(> (first items) %) current-seq)\n               (recur current-max (conj current-seq (first items)) (rest items))\n               (recur (better-seq current-max current-seq) [(first items)] (rest items))))))]\n    (let [result (lseq2 in-vals)]\n      (if (> (count result) 1)\n        result\n        []))))","problem":53,"user":"4f0d093b535d0136e6c22313"},{"problem":53,"code":"(fn inc-sub-seq [xs]\n  ((comp reverse last (partial sort-by count) (partial filter #(not (= 1 (count %1)))))\n        (reduce (fn [[[a & b :as e] & c :as f] d]\n                  (if (= (dec d) a)\n                    (conj c (conj e d))\n                    (conj f (list d)))) \n                '(()) xs)))","user":"5606ea56e4b08b23635d317b"},{"code":"(fn [x]\n          (let [subseqs (loop [subseqs [], curseq [], r x]\n                          (if-let [a (first r)]\n                            (if (or (empty? curseq) (= (inc (last curseq)) a))\n                              (recur subseqs (conj curseq a) (rest r))\n                              (recur (conj subseqs curseq) [a] (rest r)))\n                            (conj subseqs curseq)))]\n            (if-let [ret (second (first (sort-by first > (filter  #(< 1 (count (second %))) (map #(vector (count %) %) subseqs)))))]\n              ret\n              [])))","problem":53,"user":"4f284db6e4b0d6649770a014"},{"code":"(fn aa [ix] \n  (let [s (last\n \n (sort-by #(- (last %) (first %))\n \t (filter #(= (subvec ix (first %) (inc (last %)))\n    \t          (range (ix (first %)) (inc (ix (last %))) )\n              )\n  \t (for [x (range (count ix)) y (range (inc x) (count ix)):when (not= y x)]\n   \t   [x y]\n  \t\t)\n      )\n        )\n   )]\n         (if (= nil s)\n           []\n           (subvec ix (first s) (inc (last s))))\n      )   \n         \n         \n  \n         \n  )","problem":53,"user":"5105ed16e4b01150e115ebe2"},{"problem":53,"code":"(fn [col]\n  (->> (map #(conj [] %1 %2) (drop-last col) (rest col))\n       (partition-by (fn [[a b]] (not= (- b a) 1)))\n       (filter (fn [sub] (some (fn [[a b]] (= (- b a) 1)) sub)))\n       (sort-by count)\n       (last)\n       (apply concat)\n       (distinct)))","user":"56795deae4b05957ce8c6187"},{"problem":53,"code":"(fn [coll]\n  (loop [longest []\n         sub []\n         c coll]\n    (let [next-int (first c)\n          prev-int (last sub)\n          next-sub (conj sub next-int)\n          longest-count (count longest)\n          next-sub-count (count next-sub)\n          next-c (rest c)]\n      (if (nil? next-int)\n        longest\n        (if (or (nil? prev-int) (= (inc prev-int) next-int))\n          ; append to sub\n          (if (and (> next-sub-count longest-count) (> next-sub-count 1))\n            (recur next-sub next-sub next-c)\n            (recur longest next-sub next-c))\n          (recur longest [next-int] next-c))))))","user":"567c2322e4b05957ce8c61af"},{"problem":53,"code":"(fn longseq [int-list]\n  (loop [long-seq [] next-seq [] feed-set int-list]\n    (cond\n      (empty? feed-set)\n      (if (> (count next-seq) (count long-seq))\n        (if (>= (count next-seq) 2) next-seq [])\n        (if (>= (count long-seq) 2) long-seq []))\n      :else\n      (recur\n        (cond\n          (empty? next-seq) long-seq\n          (<= (first feed-set) (last next-seq)) (if (> (count next-seq)\n                                                       (count long-seq))\n                                                  next-seq\n                                                  long-seq)\n          :else long-seq)\n        ;; ----\n        (cond\n          (empty? next-seq) [(first feed-set)]\n          (<= (first feed-set) (last next-seq)) [(first feed-set)]\n          :else (conj next-seq (first feed-set))\n          )\n        ;; ---\n        (rest feed-set)\n        )\n      )\n    )\n  )","user":"5826209fe4b051871117bef1"},{"problem":53,"code":"(fn sub-seq [x]\n  (let [seq-map\n        (->> ((fn gen-seq\n                ([s] (gen-seq s 1))\n                ([s t] (cond\n                         (empty? s) nil\n                         (= (count s) t) (cons s (lazy-seq (gen-seq (rest s) 1)))\n                         :else (cons (take t s) (lazy-seq (gen-seq s (inc t))))))) x)\n          (filter (fn [e] (> (count e) 1)))\n          (filter (fn [e] (apply < e)))\n          (group-by count))\n        m-key (if (seq seq-map)\n                (apply max (keys seq-map))\n                nil)]\n    (vec (first (seq-map m-key)))))","user":"55885edae4b059ccff29b1f6"},{"problem":53,"code":"(fn [inp]\n  (->> (map - (next inp) inp) \n       (map vector inp) \n       (partition-by second)\n       (filter #(= 1 (second (first %))))\n       (sort-by count)\n       last\n       (map first)\n       (apply vector)\n       (#(if (not-empty %)\n           (conj % (inc (last %)))\n           []))))","user":"4e8768f6535dceadca469850"},{"code":";(fn [coll] \n;  (let [a (partition-by #(< (first %) (last %)) (partition 2 1 coll))\n;        b (filter #(< (ffirst %) (second (first %))) a)\n;        c (reduce #(if (< (count %1) (count %2)) %2 %1) [] b)] \n;   (concat (first c) (map last (rest c)))))\n\n (fn [coll] \n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))] \n   (concat (first c) (map last (rest c)))))","problem":53,"user":"509fe759e4b08df8156e9e43"},{"problem":53,"code":"#(if (= (reverse (sort %)) %)\n   []\n   (let[split (fn [a b]\n                (if (< (last(last a)) b)\n                                  (concat (drop-last a) [(conj (last a) b)])\n                                  (concat a [[b]])))]\n     (first(second(last(sort (group-by count(reduce split [[(first %)]] (rest %)))))))\n     )\n   )","user":"5731e36be4b0cd1946bd0fc9"},{"code":"#((fn [s]\n   (if (empty? s)\n     s\n     (reduce (fn [a b]\n               (if (> (count a) (count b))\n                 a b))\n             s)))\n  (filter (fn [s]\n            (and (every? true? (map < s (rest s)))\n                 (< 1 (count s))))\n          (for [i (range (inc (count %))) j (range i)]\n            (drop-last j (take-last i %)))\n          ))","problem":53,"user":"5107b86de4b05b2b4eee7495"},{"code":"(fn p53-longest-increasing-sub-seq [s]\n  (let [begin-sequences\n        (fn [s] (rest (reductions (fn [a b] (conj a b)) [] s)))\n        end-sequences\n        (fn [s] (reverse (reduce (fn [mem a] (conj (map (fn [b] (flatten [b a])) mem) (list a))) [] s)))\n        longest\n        (fn [s] (reduce (fn [longest x] (if (> (count x) (count longest)) x longest)) [] s))]\n    (->> (apply concat (map begin-sequences (end-sequences s)))\n         (filter (fn [s] (apply < s)))\n         (filter (fn [s] (> (count s) 1)))\n         (longest)\n         )))","problem":53,"user":"526d6968e4b03e8d9a4a72d9"},{"code":"(fn [initial-s]\n  (loop [s initial-s\n         longest []]\n    (let [sub-seq (cons (first s) \n                        (map second (take-while #(apply < %) (partition 2 1 s))))\n          len (count sub-seq)]\n      (cond\n        (empty? s) longest\n        (and (> len (count longest)) (> len 1)) (recur (rest s) sub-seq)\n        :otherwise (recur (rest s) longest)))))","problem":53,"user":"51789dfae4b03d69594194d7"},{"code":"#(let [[a b e] (reduce (fn [[m c p] e]\n                        (if (> e p)\n                          [m (conj c p) e]\n                          (if (> (inc (count c)) (count m))\n                            [(conj c p) [] e]\n                            [m [] e])))\n                        [[] [] (first %)] (rest %))\n       r (if (>= (count a) (inc (count b)))\n             a\n             (conj b e))]\n     (if (>= (count r) 2)\n       r\n       []))","problem":53,"user":"4f32a7f1e4b0d6649770a095"},{"problem":53,"code":"(fn [s]\n            (letfn [(maxsec [a b] (if (> (count a) (count b)) a b))]\n              (loop [coll s cr [] mr []]\n                (if (empty? coll) (let [r (maxsec cr mr)] (if (= 1 (count r)) [] r)) \n                                  (recur (rest coll)\n                                         (if (or (empty? cr) (> (first coll) (last cr)))\n                                           (conj cr (first coll))\n                                           [(first coll)]\n                                           )\n                                         (maxsec cr mr))\n                                  )))\n\n            )","user":"55eeb37ae4b0121d4835fdf3"},{"problem":53,"code":"(fn [xs]\n  ((fn [longest current [f & r]]\n     (if f\n       (let [new-current (cond (empty? current) [f]\n                               (< (last current) f) (conj current f)\n                               :else [f])\n             new-longest (if (and (> (count new-current) 1) (> (count new-current) (count longest))) new-current longest)]\n         (recur new-longest new-current r))\n\n         longest))\n   [] [] xs))","user":"542a8d07e4b01498b1a71b43"},{"code":"(fn __ [sq]\n  (let [;; helper function 1\n        take-while-inc (fn [sq]\n                         (loop [acc [(first sq)]\n                                sq1 (rest sq)]\n                           (if (or (empty? sq1) (>= (last acc) (first sq1)))\n                             acc\n                             (recur (conj acc (first sq1)) (rest sq1)))))\n        ;; helper function 2\n        seq-at-each-pos (fn  [sq]\n                          (loop [acc []\n                                 sq2 sq]\n                            (if (empty? sq2)\n                              acc\n                              (recur (conj acc (take-while-inc sq2)) (rest sq2)))))\n        ;; execution\n        seq-at-each-pos1 (seq-at-each-pos sq)\n        lengths          (map count seq-at-each-pos1)\n        max-length       (reduce max lengths)\n        answer           (first (drop-while #(< (count %) max-length) seq-at-each-pos1))]\n    ;;\n    (if (= 1 (count answer))\n      []\n      answer)))","problem":53,"user":"53415755e4b00652c8746ecd"},{"problem":53,"code":"#(let [qualified? (fn [s] (>= (count s) 2))\n       next-of? (fn [s n] (= (last s) (dec n)))\n       longest (fn [& seqs] (apply max-key count (cons [] seqs)))\n       next-conseqs (fn [[cur & prevs :as seqs] n]\n                      (if (next-of? cur n)\n                        (cons (conj cur n) seqs)\n                        (cons [n] seqs)))\n       conseqs (fn [v] (reduce next-conseqs [] v))]\n   (apply longest (filter qualified? (conseqs %))))","user":"508923d5e4b06d8254e936e8"},{"problem":53,"code":"(fn sub[s]\n(let [subb (fn [s curs maxs]\n(let [x (first s)\nr (rest s)\nncurs (if (= ((fnil dec 0) x) (peek curs)) (conj curs x) [x])\nnmax (max-key count ncurs maxs)]\n(if (seq r)\n(recur r ncurs nmax)\nnmax)))\nlongest (subb s [(first s)] [])]\n(if (> (count longest) 1) longest [])))","user":"53f35c34e4b0742d9025b0f4"},{"code":"(fn [coll]\r\n    (let [sub-seqs \r\n          (reduce \r\n            (fn [a b]\r\n              (if-let [l (last (last a))]\r\n                (if (= b (inc l))\r\n                  (update-in a [(-> a count dec)] conj b)\r\n                  (conj a (vec [b])))\r\n                (conj a (vec [b])))) [[]] coll)]\r\n      (if-let [longest (last (sort-by count (filter #(> (count %) 1) sub-seqs)))]\r\n        longest \r\n        [])))","problem":53,"user":"4dd61f98535d2dad7130b5c6"},{"problem":53,"code":"(fn [c]\n  (let [lc (count c)]\n    (apply max-key count (cons [] (filter #(and (> (count %) 1) (apply < %))\n                                          (map (fn [nc i] (drop-last i nc))\n                                                        (apply concat (repeat lc (map (fn [j] (drop j c)) (range lc))))\n                                                        (apply interleave (repeat lc (range lc)))))))))","user":"54349368e4b0b6b47310fcf1"},{"code":"(fn lis [s]\n  (->> s\n       (partition 2 1)\n       (partition-by (partial apply <))\n       (filter (fn [[[a b]]] (< a b)))\n       (reduce (fn [m s] (if (> (count s) (count m)) s m)) [])\n       (#(cons (ffirst %) (map second %)))\n       (remove nil?)))","problem":53,"user":"4f58fe71e4b0a7574ea7185f"},{"problem":53,"code":"(fn [coll]\n  (reduce \n   (fn [longest si]\n     (if (< (count longest) (count si)) si longest))\n   []\n   (filter \n   \t#(apply < %) \n    (mapcat #(partition % 1 coll) (range 2 (inc (count coll)))))\n  )\n  )","user":"58ca8a1de4b03c36ff7e5835"},{"code":"(fn [in] (let [seqs (mapcat #(partition % 1 in) (range (count in) 1 -1))] (or (some #(if (= % (take (count %) (iterate inc (first %)))) %) seqs) [])))","problem":53,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn [xs] (or (last (sort-by count (filter #(> (count %) 1)\n  (reduce (fn [[wk wn] i]\n    (if (or (= (count wk) 0) (> i (last wk)))\n        [(conj wk i) wn]\n        (if (and (> (count wk) (count wn)) (> (count wk) 1))\n            [[i] wk]\n            [[i] wn])\n    ))\n    [[] []]\n    xs\n)))) []))","problem":53,"user":"518644bce4b0da5a5be3baca"},{"code":"(fn liss [initxs]\r\n  (loop [ret [], cur[], xs initxs]\r\n    (if (empty? xs)\r\n      (if (> (count ret) 1)\r\n        ret\r\n        [])\r\n      (if (or (empty? cur) (> (first xs) (last cur)))\r\n        (if (> (count (conj cur (first xs))) (count ret))\r\n          (recur (conj cur (first xs)) (conj cur (first xs)) (rest xs))\r\n          (recur ret (conj cur (first xs)) (rest xs)))\r\n        (recur ret [(first xs)] (rest xs))))))","problem":53,"user":"4e123905535d04ed9115e7ce"},{"problem":53,"code":"(fn [coll]\n  (loop [i 1\n         long-sub []\n         new-sub [(first coll)]]\n    (if (>= i (count coll))\n      (if (and (not= 1 (count new-sub)) (> (count new-sub) (count long-sub)))\n        new-sub\n        long-sub)\n      (let [comp1 (get coll (dec i))\n            comp2 (get coll i)]\n        ;numbers are consecutive\n        (if  (= (inc comp1)  comp2)\n          (recur (inc i) long-sub (conj new-sub comp2))\n          ; numbers are not consecutive, two cases:\n          ;; 1) we are ending a run of consecutives and new to determine if that sub if longer than current longest\n          (if (and (get coll (- i 2)) (= (inc (get coll (- i 2)))  comp1))\n            (if (> (count new-sub) (count long-sub))\n             (recur (inc i) new-sub  [comp2])\n             (recur (inc i) long-sub (conj new-sub comp2)))\n            (recur (inc i) long-sub [comp2])))))))","user":"593744abe4b02506e01a299b"},{"problem":53,"code":"(fn [x] (or (->> (reverse (range 2 (inc (count x)))) (map #(partition % 1 x)) (reduce concat) (filter (fn [l] (every? #(= (inc (first %)) (second %)) (partition 2 1 l)))) first) []))","user":"569c1038e4b0542e1f8d145f"},{"code":";; (fn [xs]\n;;  (let [[_ a b] (reduce (fn [[prev cand cur] x]\n;;                          (if (<= x prev)\n;;                            (if (> (count cand) (count cur))\n;;                              [x (list x) cand]\n;;                              [x (list x) cur])\n;;                            [x (conj cand x) cur]))\n;;                        [-1 () ()] xs)] (let [ans (reverse (if (> (count a) (count b)) a b))]\n;;                                          (if (> (count ans) 1) ans ()))))\n\n(fn [xs]\n  (let [pick #(if (> (count %1) (count %2)) %1 %2)]\n    (let [[_ a b] (reduce (fn [[p a b] x]\n                            (if (<= x p)\n                              [x (list x) (pick a b)]\n                              [x (conj a x) b]))\n                          [(first xs) (list (first xs)) ()]\n                          (rest xs))]\n      (let [ans (reverse (pick a b))]\n        (if (> (count ans) 1) ans ())))))","problem":53,"user":"533696b9e4b0e30313ee6c7c"},{"code":"(fn maxconseq[s]\n\n (let [conseq (fn conseq1[s]\n  (cond \n   (nil? (first s)) '()\n   (= (inc (first s)) (first (rest s))) (cons (first s) (conseq1 (rest s)))\n    :else (list (first s))\n   )  \n  )\n  ]  \n  (reduce (fn [acc x]\n            (let [ cs (conseq x)\n                   lcs (count cs)\n                   ]\n              (cond\n               (< lcs 2)  \n               \t acc \n               (> lcs (count acc)) \n                 cs\n               :else \n                 acc\n              )\n              )\n                         \n            )\n           '() \n           (map #(drop % s)(range (count s)))\n  \n  )\n   )\n )","problem":53,"user":"4fb03cf4e4b081705acca262"},{"problem":53,"code":"(fn [col]\n  (or (->>\n       (map vector col (range))\n       (partition-by #(apply - %))\n       (map #(map first %))\n       (filter #(> (count %) 1))\n       (sort-by (comp - count)) first)\n[]))","user":"59fd069ae4b01bb0ae8afcf4"},{"code":"(fn [xs]\n  (loop [i 0 longest []]\n    (if (< i (count xs))\n      (let [increasing (loop [j i ret []]\n                         (if (and (< j (count xs)) (or (empty? ret) (> (get xs j) (last ret))))\n                           (recur (inc j) (conj ret (get xs j)))\n                           ret))]\n        (if (and (> (count increasing) (count longest)) (> (count increasing) 1))\n          (recur (inc i) increasing)\n          (recur (inc i) longest)))\n      longest)))","problem":53,"user":"51ef31dfe4b0871fa145d9a0"},{"code":"(fn longest [s]\n  (loop [l (rest s) acc [(first s)] res [(first s)]]\n    (if (empty? l)\n      (if (> (count res) 1) res [])\n      (let [\n        fi (first l) \n        la (last acc)\n        newacc (if (> fi la) (conj acc fi) [fi])]\n        (recur \n          (rest l) \n          newacc\n          (if (> (count newacc) (count res))\n            newacc\n            res))))))","problem":53,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":53,"code":"(fn [coll]\n  (let [apply-when (fn [pred fun coll] (if (pred coll) (apply fun coll) coll))]\n    (->> (map list coll (reductions = true (map < coll (rest coll))))\n         (partition-by second)\n         (map (partial map first))\n         (filter #(-> % count (> 1)))\n         reverse\n         (apply-when not-empty (partial max-key count)))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":53,"code":"(fn [s]\n  ;; Keep some state while we traverse the sequence:\n  ;; \"prev\" is the previous value, \"split?\" is a toggle to\n  ;; make the partitioner do what we want.\n  (let [prev (atom (first s)), split? (atom true)]\n  (->> s\n    (partition-by\n      (fn [x]\n        ;; Create a new partition by toggling \"split?\" when a run ends.\n        (when (<= x @prev) (swap! split? not))\n        (reset! prev x)\n        @split?))\n    ;; Remove partitions shorter than 2.\n    (filter #(> (count %) 1))\n    ;; Reverse the result by conj'ing into an empty list.\n    (into ())\n    ;; Get the longest, this will be the last one found if there is\n    ;; more than one, i.e. the first one from the original sequence.\n    ;; Need to supply an empty list, so max-key won't choke if the\n    ;; result set was empty (test case 4).\n    (apply max-key count '()))))","user":"5b772ad7e4b047b03b2036e8"},{"problem":53,"code":"(fn longest-seq [coll]\n  (let [\n        take-continuous-inc-seq (fn [coll] (let [hits (count (take-while (fn [x] (apply (fn [a b] (< a b)) x)) (partition 2 1 coll)))]\n                                             (take (inc hits) coll)))\n        parts ((fn [coll] (for [n (range (count coll))] (drop n coll))) coll)\n        continuous-inc-parts (map take-continuous-inc-seq parts)\n        max-len (apply max (map count continuous-inc-parts))\n        longest (some (fn [x] (and (= (count x) max-len) x)) continuous-inc-parts)\n        ]\n    (if (< (count longest) 2)\n      []\n      longest)))","user":"5959c72ae4b066ee0a44afac"},{"problem":53,"code":"(fn [s]\n  (let [ans\n        (loop [[x & xs] s\n               prev '()\n               best '()]\n          (let [count-best (count best)\n                count-prev (count prev)]\n          (if (nil? x)\n            (if (< count-best count-prev)\n              prev\n              best)\n            (let [p (first prev)]\n              (if (and p (< p x))\n                (let [new-prev (conj prev x)]\n                  (if (< count-best count-prev)\n                    (recur xs new-prev new-prev)\n                    (recur xs new-prev best)))\n                (recur xs (conj nil x) best))))))]\n    (if (< (count ans) 2)\n      []\n      (reverse ans))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":53,"code":"(fn [v]\n  (let [subseqs (for [i (range (count v)) \n                      j (range (+ 2 i) (inc (count v)))]\n                 (subvec v i j))]\n    (->> subseqs\n         (filter #(apply < %))\n         reverse ;have to reverse here as max-key returns the last element if count is the same\n         (apply max-key count [])))) ;have to add in a blank vector here, in case there is no increasing subvec","user":"567e418fe4b0feffd0d18eb1"},{"problem":53,"code":"(fn f\n  [s]\n  (let [runs (reductions #(if (> %2 (last %1)) (conj %1 %2) (vector %2)) (vector (first s)) (rest s))\n        runs (filter #(> (count %) 1) runs)]\n    (if (empty? runs)\n      '()\n      (apply max-key count (reverse runs)))))","user":"5d629ed9e4b0c9e5857d501d"},{"problem":53,"code":"(fn\n  [s]\n  (#(if (>= (count %) 2) % [])\n   (reduce #(if (>= (count %1) (count %2)) %1 %2)\n           (vec (reduce\n                 (fn [rs el]\n                   (if rs\n                     (if (= (inc (last (last rs))) el)\n                       (conj (vec (butlast rs)) (conj (last rs) el))\n                       (conj rs [el]))\n                     [[el]]))\n                 nil s)))))","user":"5ec02e20e4b00a66d4a95288"},{"problem":53,"code":"(fn [A] (let [C (apply max-key count (reverse (let [B (into [[[(first A)]]] (drop 1 A))] (reduce #(if (> %2 (last (last %1))) (conj (pop %1) (conj (last %1) %2)) (conj %1 [%2])) B))))] (if (> (count C) 1) C [])))","user":"5fe362d9e4b05ac5b16ea179"},{"problem":53,"code":"(fn [xs] (->> xs\n    ((fn [coll]\n        (first\n            (reduce\n                (fn [[ret prev] v]\n                    (if (and (not= prev nil) (> v prev))                        \n                        [(assoc ret (dec (count ret)) (conj (last ret) v)) v]\n                        [(conj ret [v]) v]\n                    )\n                )\n                [[] nil]\n                coll\n            )\n        )\n    ))\n    (filter #(> (count %) 1))\n    (reduce #(if (> (count %2) (count %1)) %2 %1) [])\n))","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn [coll] (loop [[x & xs] coll sub [] ss []]\n            (if x\n                (cond\n                 (or (empty? sub)\n                     (> x (last sub))) (recur xs (conj sub x) ss)\n                 (= (count sub) 1) (recur xs [x] ss)\n                 :else (recur xs [x] (if (> (count sub)\n                                            (count ss)) sub ss)))\n              (if (> (count sub) (count ss) 1) sub ss))))","problem":53,"user":"50310b8be4b05b7df5a0b84d"},{"code":"(fn __ [coll]\n  (let [ret\n        ((fn lst [[head & tail :as whole] seen now]\n           (if (empty? whole) \n             seen\n             (if (<= head (last now))\n               (lst tail seen [head])\n               (let [nxt (conj now head)]\n                 (lst tail (if (< (count seen) (count nxt)) nxt seen) nxt)))) )\n          (rest coll) [(first coll)] [(first coll)])]\n    (if (< (count ret) 2) [] ret)))","problem":53,"user":"52828298e4b0757a1b17145b"},{"problem":53,"code":"(fn longest-subseq\n  ([sseq] (longest-subseq sseq [] [(first sseq)]))\n  ([sseq longest curr]\n   (if-let [sec (second sseq)]\n     (if (> sec (first sseq)) (recur (next sseq) longest (conj curr sec))\n         (if (> (count curr) (count longest))\n           (recur (next sseq) curr [sec])\n           (recur (next sseq) longest [sec]) ))\n     (let [foundseq (if (>(count curr) (count longest))curr longest )]\n       (if (> (count foundseq) 1) foundseq []))))\n  )","user":"561ca6ebe4b064ca9f4b169c"},{"problem":53,"code":"(fn lsub [as]\n  ((fn f\n     [xs b1 b2]\n     (if (and (>= (count b2) 2) (> (count b2) (count b1)))\n       (f xs b2 b2)\n       (if (empty? xs)\n         b1\n         (if (or (empty? b2) (> (first xs) (last b2)))\n           (f (rest xs) b1 (conj b2 (first xs)))\n           (f (rest xs) b1 [(first xs)]))))) as [] []))","user":"53c051a5e4b0c98a41f5ccae"},{"code":"(fn liss [coll]\n  (let [result (second\n                 (reduce\n                   (fn [[last-item best-so-far curr-seq] curr-item]\n                     (let [curr-seq\n                           (if (> curr-item last-item)\n                             (conj curr-seq curr-item)\n                             [curr-item])]\n                       [curr-item\n                        (if (> (count curr-seq) (count best-so-far))\n                          curr-seq\n                          best-so-far)\n                        curr-seq]))\n                   [(first coll) [] [(first coll)]] (rest coll)))]\n    (if (= (count result) 1)\n      []\n      result)))","problem":53,"user":"53070615e4b02e821686979e"},{"code":"(fn [l]\n  (let [sl (reduce (fn [a e]\n    (if (> e (first (first a)))\n      (conj (rest a) (conj (first a) e))\n      (conj a (list e))))\n    (list (list (first l)))\n    (rest l))\n    sm (group-by count sl)\n    ln (reverse (last (sm (first (sort > (keys sm))))))]\n  (if (> (count ln) 1)\n    ln\n    '())))","problem":53,"user":"4ed2b168535d44c135fd68dd"},{"code":"(fn p[seq_] (reduce #(if (and (> (count %2) 1) (> (count %2) (count %1)))  %2 %1) []\n                          (let [tk (fn tk[a seq_] (cond\n                                       (empty? seq_) a\n                                       (empty? a) (tk [(first seq_)] (rest seq_))\n                                       (<= (first seq_) (last a)) a\n                                       :else (tk (conj a (first seq_)) (rest seq_))))]\n                (loop [se seq_\n                       result []]\n                  (let [f (tk [] se)\n                        rest_ (drop (count f) se)]\n               (if (empty? f) result (recur rest_ (conj result f))))\n                ))) )","problem":53,"user":"4f320253e4b0d6649770a08d"},{"code":"(fn [xs]\r\n  (loop [rs   ()\r\n         r    [(first xs)]\r\n         more (next xs)]\r\n    (if (seq more)\r\n      (if (= (inc (peek r)) (first more))\r\n        (recur rs          (conj r (first more)) (next more))\r\n        (recur (conj rs r) [(first more)]        (next more)))\r\n      (reduce\r\n        (fn [a c] (if (and (> (count c) 1) (> (count c) (count a))) c a))\r\n        []\r\n        (conj rs r)))))","problem":53,"user":"4dd52e29535dae65d5c462e5"},{"problem":53,"code":"(fn increasing-sub-seq [coll]\n  (let [res (reduce\n             (fn [acc n]\n               (if (> (count n)\n                      (count acc))\n                 n\n                 acc))\n             []\n             (loop [[x & xs] coll\n                    increasing-seqs []\n                    current-seq []]\n               (if (nil? x)\n                 (conj increasing-seqs current-seq)\n                 (if (or (nil? (peek current-seq))\n                         (< (peek current-seq) x))\n                   (recur xs increasing-seqs (conj current-seq x))\n                   (recur xs (conj increasing-seqs current-seq) [x])))))]\n    (if (<= 2 (count res))\n      res\n      [])))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"problem":53,"code":"(fn [s] (let [tmp (reductions #(if (> %2 (last %1)) (conj %1 %2) [%2]) [(first s)] (rest s))\n                l (apply max-key count (reverse tmp))] \n    (if (> (count l) 1) l [])))","user":"54324be1e4b0dad94371f2ed"},{"problem":53,"code":"(fn get-subseq\n  [numbers]\n  (loop [nums numbers active [] current []]\n    (if (empty? nums) current\n        (if (= (count nums) 1) \n          (if (and (> (count active) 0) (>= (count active) (count current))) (conj active (first nums)) current)\n          (let [[a b & others] nums]\n            (if (< a b)\n              (recur (cons b others) (conj active a) current)\n              (if (not-empty active) \n                (recur (cons b others) [] (if (>= (count active) (count current)) (conj active a) current))\n                (recur (cons b others) [] current))))))))","user":"5545477fe4b0a04f79299531"},{"code":"(fn [s](map #(s %) (let [best (last (sort-by count (reverse (filter #(not (nil? (first %))) (partition-by nil? (map #(if (< 0 %2) % nil) (range) (map - (next s) s) ))))))] (if (nil? best) nil (concat best [(inc (last best))])))))","problem":53,"user":"536046a9e4b063bf7a5f8fe1"},{"problem":53,"code":"(fn [c] (reduce #(if (and (> (count %2) (count %)) (> (count %2) 1)) %2 %) [] \n                (reduce #(if (> %2 (last (last %))) (conj (vec (butlast %)) (conj (last %) %2)) (conj % [%2])) [[(first c)]] (rest c))))","user":"5c41db45e4b08cd430848ece"},{"code":"#(or\r\n  (first\r\n    (sort-by\r\n      (comp - count)\r\n      (for [f [(fn [[a b]] (= b (+ 1 a)))]\r\n            p (partition-by f (map list % (next %)))\r\n            r [`[~@(map first p) ~(last (last p))]]\r\n            :when (f r)]\r\n        r)))\r\n  [])","problem":53,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [xs]\n  (let [q (filter #(apply < (first %))\n            (partition-by #(apply < %)\n              (partition 2 1 xs)))]\n    (if (empty? q) []\n      (#(cons (ffirst %) (map second %))\n        (first\n          (sort-by count > q))))))","problem":53,"user":"4f725201e4b07046d9f4f02f"},{"problem":53,"code":"(fn [coll]  \n\t(let [group-coll-index (fn [coll] (partition-by #(take-last 1 %) \n\t\t\t(partition 2 \n\t\t\t\t(interleave coll \n\t\t\t\t\t(flatten \n\t\t\t\t\t\t(partition-by identity \n\t\t\t\t\t\t\t(map + coll (iterate dec 0))) \n\t\t\t\t\t\t))))) \n\t\t  ] \n\t\t  (if (>= (apply max (map count (group-coll-index coll))) 2) \n\t\t  \t(flatten (map butlast (last (sort-by count (group-coll-index coll)))))\n\t\t  \t[])\n\t\t  )\t\n    )","user":"5ac04101e4b073f177442737"},{"code":"(fn [seq] (let [r (reduce (fn [a b] (if (> (count b) (count a)) b a)) [] ((fn [xs] (map #(reduce (fn [xs v] (if (or (empty? xs) (<= v (last xs))) [v] (concat xs [v]))) [] %) ((fn [ys] (for [i (range 0 (- (count ys) 1)) j (range (+ 2 i) (+ 1 (count ys)))] (take (- j i) (drop i ys)))) xs))) seq))] (if (> (count r) 1) r [])))","problem":53,"user":"508ee17ae4b0706b2ed3ef8d"},{"problem":53,"code":"#(reverse\n  (loop [x %\n         y []\n         z []]\n    (cond\n     (= x []) (if (and (>= (count y) 2) (> (count y) (count z))) y z)\n     (= y []) (recur (rest x) [(first x)] z)\n     (> (first x) (first y)) (recur (rest x) (cons (first x) y) z)\n     (and (>= (count y) 2) (> (count y) (count z))) (recur x [] y)\n     :else (recur x [] z))))","user":"53c74cfce4b00fb29b2212a7"},{"problem":53,"code":"(fn longestseq\n  [elems]\n  (loop\n    [old elems\n     longseq []\n     curseq []]\n    (if (empty? old)\n      longseq\n      (if (or (empty? curseq) (= (first old) (inc (last curseq))))\n        (recur (rest old)\n               (if (and (>= (count curseq) (count longseq)) (>= (count curseq) 1))\n                 (conj curseq (first old))\n                 longseq)\n               (conj curseq (first old)))\n        (recur (rest old)\n               longseq\n               [(first old)])))))","user":"5a3ece62e4b0447ef91cc5b9"},{"code":"(fn [s]\n  (loop [s s buf nil res nil]\n    (if-let [elt (first s)]\n      (if (empty? buf)\n        (recur (next s) (cons elt buf) res)\n        (if (= elt (inc (first buf)))\n          (recur (next s) (cons elt buf) res)\n          (recur (next s) (list elt) (cons (reverse buf) res))))\n      (reduce #(if (< (count %1) (count %2)) %2 %1) ()\n        (filter #(<= 2 (count %))\n          (if (empty? buf)\n            res\n            (cons (reverse buf) res)))))))","problem":53,"user":"4fc13433e4b081705acca32b"},{"code":"(fn [xs]\n  (first (reduce\n   (fn [[longest current] x]\n     (if (or (empty? current) (> x (last current)))\n       (let [candidate (conj current x)]\n         (if (and (>= (count candidate) 2) (> (count candidate) (count longest)))\n           [candidate candidate]\n           [longest candidate]))\n       [longest [x]]))\n   [[] []]\n   xs)))","problem":53,"user":"4dad8a6dc9a9d6ed1399dc57"},{"problem":53,"code":"(fn [coll]\n   (or (->> (reduce (fn [acc x]\n                      (if (= (dec x) (-> acc last last))\n                        (conj (vec (butlast acc)) (conj (last acc) x))\n                        (conj acc [x])))\n                    (vector)\n                    coll)\n            (filter #(> (count %) 1))\n            (sort-by count)\n            (last))\n       (vector)))","user":"55b54ecbe4b01b9910ae2987"},{"problem":53,"code":"(fn [inp]\n  (loop [coll (rest inp)\n         longest []\n         curser [(first inp)]]\n    (if (empty? coll)\n      longest\n      (let [nextel (first coll)\n            contser (> nextel (last curser))\n            newcurser (if contser (conj curser nextel) [nextel])\n            newsize (count newcurser)\n            newserbigger (and (> newsize (count longest)) (> newsize 1))\n            newlongest (if newserbigger newcurser longest)]\n        (recur (rest coll)\n               newlongest\n               newcurser)))))","user":"592334c7e4b0a390037439ee"},{"code":"#(loop\n   [res [] s % c [(first s)]]\n   (if-let [[x & xs] s]\n     (if (= (inc (peek c)) x)\n       (let [c1 (conj c x) cn (count c1)]\n\t\t (recur (if (and (> cn (count res)) (> cn 1)) c1 res) xs c1))\n\t   (recur res xs [x]))\n\t res\n     )\n   )","problem":53,"user":"5298d3f4e4b02ebb4ef75068"},{"problem":53,"code":";; 1. `collect-seqs` is a reducing function (acc, elt)\n;;    `acc` is a sequence of subsequences: [sN-1, sN-2, .., s0]\n;;\t\t\t`sN` are vectors (i.e. order our subseqs)\n;;    `elt` is the new element we consider\n;;\n;;    Each reducing step decides whether to include `elt` into the\n;;    latest subsequence or to start a new subsequence\n;;\n;; 2. once we reduce the `coll` using `collect-seqs` we have\n;;    increasing subseqs in REVERSE order that they appear\n;; 3. filter out, sort etc. as appropriate\n\n (fn [coll]\n   (letfn [(collect-seqs [[ curr & previous :as acc], elt]\n           (let [curr (vec curr)\n                 elt-to-curr? (or (empty? curr)\n                                  (< (last curr) elt))]\n             (if elt-to-curr?\n               (conj previous (conj curr elt))\n               (conj acc [elt]))))]\n     (->> coll\n       (reduce collect-seqs ())\n       (remove #(< (count %) 2))\n       ((comp rseq vec))\n       (sort-by count >)\n       first\n       vec)))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":53,"code":"(fn [ys]\n          (let [keys1 (letfn [(getISS [res xs]\n                                (if (empty? xs)\n                                  res\n                                  (if (or (empty? res) (and (not(nil? (peek res)))  (= (first xs) (inc (peek res)))  )) \n                                    (getISS (conj res (first xs))  (rest xs))\n                                    res\n                                    ))\n                                )\n                              (getAllISS [xs] (map (fn [zs] (getISS []  zs))  (map #(drop % xs) (range 0 (count xs)))))\n                              ]\n                        (getAllISS ys)\n                        )\n                 one (reduce #(if (> (count %2) (count %1) ) %2 %1 ) [] keys1)\n                ]\n           (if (= (count one) 1) [] one) \n            \n            )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [s]\n  (let [succ (fn [[a b]] (= b (inc a)))\n        r\n        (last (sort-by count \n          (remove #(or (< (count %) 1)\n                    (not (succ (first %))))\n            (partition-by \n              succ\n              (map vector s (drop 1 s))))))]\n    (concat (map first r) (rest (last r)))))","problem":53,"user":"4f06dcad535dcb61093f6c16"},{"problem":53,"code":"(fn [L]\n      (let\n        [\n          ;;    L,     \n          ;; 0 -  ,        \n          ;;   -  , ,   ..\n          build-mask (fn []\n            (loop [Ret [] N 0 Index (dec (count L)) ]\n              (if (zero? Index)\n                (cons (if (zero? N) 0 (inc N)) Ret)\n                (let\n                  [ with-prev (= (dec (get L Index)) (get L (dec Index))) ]\n                  (recur\n                    (if (> N 0)\n                      (cons (inc N) Ret)\n                      (if with-prev\n                        (cons 1 Ret)\n                        (cons 0 Ret)\n                      )                      \n                    )\n                    (if with-prev\n                      (inc N)\n                      0\n                    )\n                    (dec Index)\n                  )\n                )\n              )\n            )\n          )\n          mask (into [] (build-mask))\n          max-value (apply max mask)\n        ]\n        ;;   \n        (if (zero? max-value)\n          []\n          (loop [Index 0]\n            (if (= max-value (get mask Index))\n              (subvec L Index (+ Index max-value))\n              (recur (inc Index))\n            )\n          )\n        )\n      )\n    )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":53,"code":"(fn [s]\n    (letfn [(sseq [s] (if (empty? s)\n        []\n        (loop [x (first s)\n               xs (rest s)\n               curr [x]\n               acc [x]]\n            (if (empty? xs)\n                acc\n                (let [x' (first xs)\n                      xs' (rest xs)\n                      curr' (if (= (inc x) x') (conj curr x') [x'])\n                      acc' (if (> (count curr') (count acc)) curr' acc)]\n                    (recur x' xs' curr' acc'))))))]\n        (let [r (sseq s)]\n            (if (< (count r) 2) [] r))))","user":"600ae927e4b074f607df6689"},{"code":"(fn liss [coll]\n  ((fn liss-helper [ret current coll]\n    (let [current-len (count current)\n          ret-len (count ret)]\n      (if-let [[f & r] coll]\n        (if (and (not-empty current) (> f (last current)))\n          (let [new-current (conj current f)]\n            (if (> (inc current-len) (max 1 ret-len))\n              (liss-helper new-current new-current r)\n              (liss-helper ret new-current r)))\n          (liss-helper ret [f] r))\n        ret)))\n  [] [] coll))","problem":53,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn f [v]\n  (or\n    (->>\n      (for [s (range (- (count v) 2) ) e (range 2 (inc (count v)))]\n        (subvec v s (min (count v) (+ s e))))\n      (filter (fn [s] (= s (distinct (sort s)))))\n      (sort-by (comp unchecked-negate-int count))\n      first)\n    []))","problem":53,"user":"50783762e4b0fc74642bff67"},{"problem":53,"code":"#(->> (reduce (fn [s x]\n           (if (and (-> s last last nil? not) (= (-> s last last inc) x))\n             (conj ((comp vec drop-last) s) (-> s last (conj x)))\n             (conj s [x])))\n         [[]] \n         %) \n       (remove (fn [x] (-> x count (= 1))))\n       (sort-by count)\n       last)","user":"57c94c6ee4b05aa3c4741d2d"},{"code":"(fn long-cons\n  ([col]\n   (long-cons (vector (first col)) [] (rest col)))\n  ([col-acum col-best col]\n   (if (empty? col)\n     (if (and (> (count col-acum) 1) (> (count col-acum) (count col-best)))\n                      col-acum\n                      col-best)\n     (if (= (last col-acum) (dec (first col)))\n         (long-cons (conj col-acum (first col))\n                    (if (and (> (count col-acum) 1) (> (count col-acum) (count col-best)))\n                      col-acum\n                      col-best)\n                    (rest col))\n       (if (> (count col-acum) (count col-best))\n           (long-cons (vector (first col))\n                      (if (and (> (count col-acum) 1) (> (count col-acum) (count col-best)))\n                        col-acum\n                        col-best)\n                      (rest col))\n           (long-cons (vector (first col)) col-best (rest col)))\n       )\n     )\n   )\n  )","problem":53,"user":"52727d52e4b03e8d9a4a7439"},{"problem":53,"code":"(fn [coll]\n    (let [switch (reductions = true (map < coll (rest coll)))\n          cmp #(> (count %1) (count %2))\n          longest (first (sort cmp (map (partial map first) (partition-by second (map list coll switch)))))]\n        (if (= 1 (count longest))\n            []\n            longest)\n         ))","user":"5a07fefee4b01bb0ae8afde5"},{"problem":53,"code":"(fn foo [xs]\n  (let [idxs (->>\n              (map - (rest xs) xs)\n              (map-indexed vector)\n              (partition-by (comp pos? second))\n              (filter (comp pos? second first))\n              reverse\n              not-empty)\n        idxs (when idxs\n               (->> idxs\n                    (apply max-key count)\n                    (map first)))\n        idxs (when idxs (concat idxs [(inc (last idxs))]))]\n    (map #(nth xs %) idxs)))","user":"5393185ae4b0b51d73faaeb7"},{"problem":53,"code":"(fn [ llst]\n  (loop [ maxLst () tmpLst () curr llst ]\n    (if (= (count curr) 0)\n      (let [maxL (count maxLst) tmpL (count tmpLst) maxx (max (count maxLst) (count tmpLst))]\n        (if (< maxL 2) '()\n          (if (>= maxL tmpL) (reverse maxLst)\n            (reverse tmpLst))))\n      (if (or (nil? (last tmpLst)) (> (first curr) (first tmpLst)))\n        (if (> (count tmpLst) (count maxLst) ) (recur tmpLst (conj tmpLst (first curr)) (rest curr))\n          (recur maxLst (conj tmpLst (first curr)) (rest curr)))\n        (if (< (count maxLst) (count tmpLst)) (recur tmpLst (conj '() (first curr)) (rest curr))\n          (recur maxLst (conj '() (first curr)) (rest curr)))))))","user":"563130e4e4b0bfe05bf1178d"},{"problem":53,"code":"(fn [v]\n  (let\n    [delta      (vec (map - (rest v) (drop-last v)))\n     count-inc  (reductions #(if (= 1 %2) (+ % %2) 0) 0 delta)\n     head       (take-while #(< % (apply max count-inc)) count-inc)\n     length     (apply max count-inc)\n     i1         (count head)\n     i0         (- i1 length)]\n    (if (zero? length)\n        []\n        (drop i0 (first (split-at (inc i1) v))))))","user":"54e606c3e4b024c67c0cf803"},{"problem":53,"code":"#(first (reduce (fn reducer [[longest current prev] x]\n            (let [new-current \n                  (cond\n                    (or (nil? prev) (>= prev x)) []\n                    (empty? current) [prev x]\n                    :else (conj current x))]\n              [(if (> (count new-current) \n                      (count longest)) \n                 new-current \n                 longest)\n               new-current \n               x])) \n          [[] [] nil] %))","user":"524ea587e4b0541d1855b7e9"},{"code":"(fn\n  [coll]\n  (loop [best []\n         current []\n         curr-end nil\n         c coll]\n    (if (empty? c)\n      best\n      (let [top (first c)\n            next-c (subvec c 1)\n            app (or (nil? curr-end) (> top curr-end))\n            next-current (if app (conj current top) [top])\n            next-best (if\n                  (and\n                   (> (count next-current) (count best))\n                   (> (count next-current) 1))\n                next-current\n                best)]\n        (recur\n         next-best\n         next-current\n         top\n         next-c)))))","problem":53,"user":"538782dce4b06839e8705f1f"},{"code":"(fn [col]\n  (let [reslt\n    (loop [[hd & rst] col ret []]\n      (if (nil? hd)\n        ret\n        (do\n\t      (let [t (last (last ret))]\n    \t    (if-not (nil? t)\n              (if (= 1 (- hd t))\n                (recur rst (conj (pop ret) (conj (last ret) hd)))\n        \t    (recur rst (conj ret [hd])))\n      \t      (recur rst (conj ret [hd])) ) ))))]\n    (reduce (fn [ret this] \n              (if (and (> (count this) (count ret)) (> (count this) 1))\n                this\n                ret)) [] reslt)))","problem":53,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn longest-subseq [coll]\n  (let [take-seq (fn [n pred coll]\n                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n        parts (chop coll)\n        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (< (count longest) 2)\n      []\n      longest)))","problem":53,"user":"5032b066e4b00c0952a257ea"},{"problem":53,"code":"(fn longest [ns]\n  (->> (map #(vector (- %2 %1) [%1 %2]) ns (rest ns))\n       (partition-by (fn [[k _]] k))\n       (filter #(let [[k _] (first %)] (= k 1)))\n       (map #(distinct (mapcat second %)))\n       (sort-by count >)\n       (first)\n       (vec)))","user":"5d28d935e4b092dab7f59c88"},{"code":"(fn [ns]\n    (->> ns\n         (iterate rest)\n         (take-while seq)\n         (map (partial reductions (fn [last-in-streak n]\n                                    (when (= last-in-streak (dec n))\n                                        n))))\n         (map (partial take-while identity))\n         (remove #(= (count %) 1))\n         (reduce (partial max-key count) [])))","problem":53,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":53,"code":"(fn [coll]   \n    ((fn last_or_empty [x] (if (empty? x) [] (last x))) (sort (fn [x y] (\n                     let [diff (- (count x) (count y))]\n                     (if (zero? diff) -1 diff)\n                     ))\n             (filter (fn [x] (< 1 (count x)))(reductions (fn [head tail]\n                                 (if (> tail (last head)) (conj head tail) [tail]))\n                               [(first coll)] (rest coll)))\n                )))","user":"60a7c55be4b00e9e6653c468"},{"problem":53,"code":"(fn [v]\n  (->> \n   (loop [ret []\n         [fv & rvs] v\n         l fv]\n   \t(if fv\n    \t(recur (if (> fv l) (update-in ret [(dec (count ret))] conj fv) (conj ret [fv])) rvs fv)\n    \tret))\n  \treverse\n  \t(apply max-key count)\n  \t(#(if (>= (count %) 2) % []))))","user":"53fe1b42e4b0de5c418485f1"},{"problem":53,"code":"(fn [l]\n  (let [tails (fn [xs] (for [i (range (dec (count xs)))]\n                         (nthrest xs i)))\n        trim  (fn [l] (loop [rl l\n                             acc []]\n                        (cond\n                          (empty? rl) acc\n                          (or (empty? acc)\n                              (< (peek acc) (first rl)))\n                            (recur (rest rl) (conj acc (first rl)))\n                          :else acc)))\n        keep   (fn [l] (reduce (fn [acc x]\n                                 (if (> (count x) (count acc)) x acc))\n                               [] l))]\n    (-> l\n        (tails)\n        ((partial map trim))\n        ((partial filter #(> (count %1) 1)))\n        (keep))))","user":"558df2ebe4b0277789237649"},{"problem":53,"code":"(fn [v]\n   (loop [i 0\n          maxr []\n          curr []]\n     (if (= i (count v))\n       (if (> (count maxr) 1) maxr [])\n       (let [cur (nth v i)\n             currn (if (or\n                        (empty? curr)\n                        (<= cur (last curr)))\n                     [cur]\n                     (conj curr cur))]\n         (recur\n          (inc i)\n          (if (> (count currn) (count maxr))\n            currn\n            maxr)\n          currn)))))","user":"5fd92743e4b05ac5b16ea11f"},{"code":"(fn [s]                                                                                              \n   (let [subseqs (fn ! [co] (when-let [se (seq co)] (cons se (! (rest se)))))                         \n         longest (fn [ss] ((fn ! [agg c]                                                               \n                             (if-let [s (seq c)]                                                     \n                               (if (= (inc (last agg)) (first s))                                    \n                                 (! (conj agg (first s)) (rest s))                                   \n                                        agg) agg))                                                   \n                          [(first ss)] (rest ss)))                                                   \n         result  (apply max-key count (map longest (subseqs s)))]                                    \n     (if (>= (count result) 2)                                                                        \n       result                                                                                        \n       [])                                                                                           \n     ))","problem":53,"user":"4f1d1299535d64f603146487"},{"problem":53,"code":"(fn [s] (let [a (->> s (reduce (fn [ret el] (let [current (last ret) seqs (count ret) len (count current)] (if (or (empty? current) (= el (+ (last current) 1))) (assoc-in ret [(- seqs 1) len] el) (conj ret [el])))) [[]]) (reduce (fn [ret l] (if (> (count l) (count ret)) l ret))))] (if (> (count a) 1) a [])))","user":"59468de7e4b07ddc2dafad88"},{"code":"(fn liss [xs]\n    (let [inc-prefix-len\n          (fn [xs]\n              (loop [i 1, prev (first xs)]\n                    (if (contains? xs i)\n                      (let [xi (nth xs i)]\n                        (if (> xi prev)\n                          (recur (inc i) xi)\n                          i))\n                      i)))]\n      (loop [xs' xs,\n             answer []]\n            (if (empty? xs')\n              answer\n              (let [k (inc-prefix-len xs')\n                    answer' (when (> k 1) (vec (take k xs')))]\n                (recur (vec (drop k xs'))\n                       (if (and answer' (> k (count answer)))\n                         answer' answer)))))))","problem":53,"user":"508157b2e4b0946d0443855c"},{"problem":53,"code":"(fn max-seq [s]\n\t(if (apply < s)\n\t\t(if ( = (count s) 1)\n\t\t[]\n\t\ts)\n\t\t(let [ls (max-seq (pop s)) \n\t\t\t  rs (max-seq (into [] (next s)))]\n\t\t (if (>= (count ls) (count rs))\n\t\t\tls\n\t\t\trs\n\t\t )\n\t\t)\n\t)\n)","user":"5559b443e4b0deb715856e3c"},{"code":"(fn max-seq[x]((fn[[x & xs :as z]] (if (empty? xs) [] z)) (apply max-key count (loop [acc [], coll x] (if (empty? coll) acc (let [new_coll (cons (first coll)\n             (map second \n              (take-while (fn[[i,j]](= j (inc i))) (partition 2 1 coll))\n              ))]  (recur (conj acc new_coll)  (drop (count new_coll) coll))))))))","problem":53,"user":"52d66ca0e4b09f7907dd135c"},{"problem":53,"code":"(letfn [(return-bigger\n          [f & args]\n          (reduce #(if (>= (f %1) (f %2)) %1 %2) args))\n        (trim-beyond-increasing-nums\n          [coll]\n          (if (empty? coll)\n            coll\n            (let [size (count coll)]\n              (loop [a 0, b 1]\n                (cond\n                  (= b size) coll\n                  (> (coll b) (coll a)) (recur (inc a) (inc b))\n                  :else (subvec coll 0 b))))))]\n  (fn [coll]\n    (->> (range (count coll))\n         (map (partial subvec coll))\n         (map trim-beyond-increasing-nums)\n         (filter #(> (count %) 1))\n         (reduce (partial return-bigger count) []))))","user":"594783bee4b07ddc2dafada1"},{"problem":53,"code":"(fn [v] (let[rs (first (sort-by #(- (count %)) (reduce #(if (empty? %1) \n                     (conj %1 [%2])\n                     (if (= (- %2 (last (last %1))) 1)  \n                         (conj (vec (drop-last %1)) (conj (last %1) %2))\n                         (conj %1 [%2]))\n                     ) [] v)))]\n          \n          \n          (if (> (count rs) 1) rs [])))","user":"54c754ace4b045293a27f639"},{"problem":53,"code":"(fn [c] (vec (let [n (count c) m (map (fn [i] (let  [cx  (partition (- n i) 1 c) ](first (filter #(apply < %) cx))))(range (dec n)))](first (filter #(not= nil %)  m  )))) )","user":"5da98129e4b000c986472c33"},{"code":"#(loop [xs (rest %) current [(first %)] result []]\n   (let [new-result (if (and (>= (count current) 2)\n                             (> (count current) (count result)))\n                        current\n                        result)]\n     (cond (empty? xs) new-result\n           (> (first xs) (last current))\n             (recur (rest xs) (conj current (first xs)) result)\n           :else\n             (recur (rest xs) [(first xs)] new-result))))","problem":53,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn f [l]\n  (letfn\n    [(getlonger [l1 l2]\n                 (if (< (count l1) (count l2))\n                   l2\n                   l1))\n     (wop [privious current rst]\n          (cond\n           (empty? rst) (getlonger privious current)\n           (or (empty? current) (> (first rst) (last current))) (wop privious (conj current (first rst)) (rest rst))\n           true (wop (getlonger privious current) [] rst)))]\n    (let [result (wop [] [] l)]\n      (if (= (count result) 1)\n        []\n        result))))","problem":53,"user":"52d7b0ade4b09f7907dd137c"},{"code":"(fn\n  [xs]\n  (loop [x xs\n         acc (conj '() [(first x)])]\n    (cond\n     (not (seq x)) ((fn [p] (if (> (count p) 1) p [])) (reduce (fn [a e] (if (> (count e) (count a)) e a)) acc))\n     (= (last (first acc)) (dec (first x)))\n     (recur (rest x) (conj (rest acc) (conj (first acc) (first x))))\n     :else (recur (rest x) (conj acc [(first x)])))))","problem":53,"user":"515efd01e4b02c55805ea238"},{"code":"(fn longest-subseq [s]\n  (letfn [\n          (find-subseq [[h & t :as s]]\n            (cond\n             (empty? s) '()\n             (not= (+ h 1) (first t)) [h]\n             :else (cons h (find-subseq t))))] \n    (->> (iterate rest s)\n         (take-while (comp not empty?))\n         (map find-subseq)\n         (reduce #(if \n                      (and\n                        (> (count %2) 1)\n                        (> (count %2) (count %1))) %2 %1) [] ))))","problem":53,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [l]\n (let [subseqs (take (count l) (iterate rest l))\n       sorted-at (map #(take-while (partial apply <)\n                                   (next (reductions\n                                          conj [] %)))\n                      subseqs)\n         cand (apply max-key\n                     count\n                     (reverse (map last sorted-at)))]\n     (if (< (count cand) 2)\n     []\n     cand)))","problem":53,"user":"4fa6d532e4b081705acca1be"},{"code":"(fn [col]\r\n  (loop [r [] c col]\r\n    (if (empty? c)\r\n      (if (= 1 (count r)) [] r)\r\n      (let [ls ((fn [s]\r\n                  (loop [res [(first s)] rem (rest s)]\r\n                    (if (= (first rem) (inc (last res)))\r\n                      (recur (conj res (first rem))\r\n                             (rest rem))\r\n                      res))) c)]\r\n        (recur (if (> (count ls) (count r)) ls r)\r\n               (rest c))))))","problem":53,"user":"4e773be8535d324fb2983d6e"},{"problem":53,"code":"#(loop [best [] cur [(first %1)] r %1]\n   (if (empty? r)\n     (if (> (count best) 1)\n       best\n       [])\n     (let \n       [x (first r)\n        ncur (if \n               (> x (last cur)) \n               (conj cur x)\n               [x])\n        nbest (if\n               (> (count ncur) (count best))\n               ncur\n               best)]       \n        (recur nbest ncur (rest r)))))","user":"5647dc44e4b0284900eef624"},{"problem":53,"code":"(fn [[init & coll]]\n         (loop [best []\n                current [init]\n                [head & tail] coll]\n           (if head\n             (let [new-current (if (= (inc (last current)) head)\n                                 (conj current head)\n                                 [head])\n                   new-best (if (and (< (count best) (count new-current))\n                                     (< 1 (count new-current)))\n                              new-current\n                              best)]\n               (recur new-best new-current tail))\n             best)))","user":"5f7600ffe4b02876ed9fd0ac"},{"code":"(fn [s]\n  (let [f first\n        spl (partition-by #(< (f %) (last %)) (partition 2 (interleave s (rest s))))\n        fi (filter #(< (f (f %)) (second (f %))) spl)]\n    (if (empty? fi) []\n      (let [g (f (filter #(= (count %) ((fn [x] (apply max (map count x))) fi)) fi))]\n    (cons (f (f g)) (map last g))))))","problem":53,"user":"53973e7be4b0b51d73faaee6"},{"problem":53,"code":"(fn find-num-seq [v]\n  (let [d (fn [x n] ; drop-nth\n            (let [v (vec x)\n                  c (count v)]\n              (concat \n                (subvec v 0 n) \n                (subvec v (inc n) c))))\n        f (fn anon [s i v]\n            (let [c (count v)\n                  z (list s v)]\n              (if (>= i c) z\n                (let [n (nth v i)]\n                  (if (empty? s) \n                    (anon [n] i (vec (d v i)))\n                    (let [l (peek s)]\n                      (if (= (inc l) n)\n                        (anon (conj s n) i\n                              (vec (d v i)))\n                        z)))))))\n        g (fn anon [p]\n            (let [[i j] p]\n              (if (empty? j) [i]\n                (let [a (anon (f [] 0 j))]\n                  (if (empty? i) a\n                    (concat [i] a))))))\n        k (g (list [] v))\n        l (sort #(compare (count %2) (count %1)) k)\n        m (first l)]\n   (if (> (count m) 1) m [])))","user":"57d1d6c8e4b0bd073c202370"},{"problem":53,"code":"#(->> % (partition 2 1) (map (fn [x y] [ (reduce - y) y]) %) (partition-by (fn [i] (identity (first i)))) (filter (fn [x] (= -1 (first (first x))))) (sort-by count) last (keep (fn [x] (second x)) ) flatten distinct)","user":"55b39523e4b01b9910ae2973"},{"code":"(letfn\n  [(longest [a b] (if (>= (count a) (count b)) a b))\n   (find-longest [coll best-so-far best-to-here]\n     (cond\n       (empty? coll)\n       best-so-far\n       (empty? best-to-here)\n       (find-longest (rest coll) best-so-far [(first coll)])\n       (< (last best-to-here) (first coll))\n       (let [best-to-here (conj best-to-here (first coll))]\n         (find-longest (rest coll) (longest best-so-far best-to-here) best-to-here))\n       :else\n       (find-longest (rest coll) best-so-far [(first coll)])))]\n  (fn [coll] (find-longest coll [] [])))","problem":53,"user":"5002b6e5e4b0678c553fc42c"},{"code":"(fn longest-incr-sub-seq [iseq]\n  (let [first-val (first iseq)]\n    (loop [xs (rest iseq)\n           acc [first-val]\n           longest-sub-seq []\n           last-val first-val]\n      (if (empty? xs)\n        (if (> (count acc) (count longest-sub-seq))\n          (if (> (count acc) 1) acc [])\n          (if (> (count longest-sub-seq) 1) longest-sub-seq []))\n        (let [curr-val (first xs)]\n          (if (= curr-val (+ last-val 1))\n            (recur (rest xs)\n                   (conj acc curr-val)\n                   longest-sub-seq\n                   curr-val)\n            (recur (rest xs)\n                   [curr-val]\n                   (if (> (count acc) (count longest-sub-seq))\n                     acc\n                     longest-sub-seq)\n                   curr-val)))))))","problem":53,"user":"4f046d70535dcb61093f6bc5"},{"code":"(fn longest-inc-subseq [xs]\r\n  (let [pt (partition 2 1 xs)\r\n        _ (prn \"1: \" pt)\r\n        pt (partition-by (fn [[x y]] (< x y)) pt)\r\n        _ (prn \"2: \" pt)\r\n        pt (for [[[x1 x2] & rxs] pt\r\n                 :when (< x1 x2)]\r\n             (concat [x1 x2] (map second rxs)))\r\n        _ (prn \"3: \" pt)\r\n        pt (loop [pt pt maxseq nil]\r\n             (if (empty? pt)\r\n               maxseq\r\n               (let [[p & rpt] pt]\r\n                 (if (> (count p) (count maxseq))\r\n                   (recur rpt p)\r\n                   (recur rpt maxseq)))))\r\n        _ (prn \"4: \" pt)]\r\n    (vec pt)))","problem":53,"user":"4dfd4ba8535d04ed9115e781"},{"problem":53,"code":"#(or \n    (first \n      (last \n        (last \n          (sort \n            (group-by count \n                      (filter (fn [xs] (>= (count xs) 2))\n                              (reduce (fn [seq item]\n                                        (if (> item (last (last seq))) \n                                          (concat (drop-last 1 seq) [(conj (last seq) item)])\n                                          (concat (drop-last 1 seq) (conj [(last seq)] [item]))))\n                                      [[(first %)]] (rest %)))))))) [])","user":"5c6d0e51e4b0fca0c1622735"},{"code":"#((fn find-seq [llist res resEnd] \n\t(println llist \" \" res \" \" resEnd)\n \t(if-not (empty? llist)\n\t \t(if (empty? res) \n\t \t\t(find-seq (next llist) (conj res  (first llist)) resEnd)\n\t \t\t(if (> (first llist) (last res)) \n\t \t\t\t(find-seq (next llist) (conj res (first llist)) resEnd)\n\t \t\t\t(find-seq (next llist) [(first llist)] \t\t\t\t\t\t(if (and (> (count res) 1) (> (count res) (count resEnd))) res resEnd)) \n\t \t\t)\n\t \t)\n\t \t(if (and (> (count res) 1) (> (count res) (count resEnd))) res resEnd) \n \t)\n ) % [] [])","problem":53,"user":"513f400ae4b051389b345b3f"},{"code":"(fn [s]\r\n   (let [c (count s)\r\n         ss (map #(drop %1 s) (range c))\r\n         st (map\r\n             #(cons (first %)\r\n                    (for [[a b] (partition 2 1 %) :while (< a b)] b))\r\n             ss)\r\n         f (first (sort-by count > st))]\r\n      (if (> (count f) 1) f [])))","problem":53,"user":"4ec28d86535dfed6da9c6dbc"},{"problem":53,"code":"(fn [coll]\n   (:max-coll\n     (reduce (fn [resu item]\n               (let [max-seq (:max-coll resu)\n                     cur-seq (:cur-coll resu)]\n                 (cond (nil? cur-seq) (assoc resu :cur-coll [item]\n                                                  :max-coll [])\n                       (= (+ 1 (last cur-seq)) item) (let [cur-seq (conj cur-seq item)]\n                                                       (if (or (nil? max-seq)\n                                                               (> (count cur-seq)\n                                                                  (count max-seq)))\n                                                         (assoc resu :max-coll cur-seq\n                                                                     :cur-coll cur-seq)\n                                                         (assoc resu :cur-coll cur-seq)))\n                       :else (assoc resu :cur-coll [item]))))\n             {}\n             coll)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"(fn g[c]\n  (let [r (fn [[c & others :as colls] n]\n    (if (= (dec n) (first c))\n      (cons (cons n c) others)\n      (cons [n] colls)))]\n    (->> (reduce r [] c)\n      (apply (partial max-key count))\n      (reverse)\n      (#(if (< 1 (count %)) % [])))))","problem":53,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":53,"code":"(fn [coll]\n    (loop [[item & items] coll\n           acc [item]\n           result []]\n      (let [result (last (sort-by count [acc result]))]\n        (cond\n\n         (nil? item)\n         (if (< 1 (count result)) result [])\n\n         (= item (inc (last acc)))\n         (recur items (conj acc item) result)\n\n         :else\n         (recur items [item] result)\n\n         ))))","user":"52dc7344e4b09f7907dd13cf"},{"problem":53,"code":"(fn [coll]\n  (let [all-subseq\n        (fn all-subseq [coll n]\n          (if (empty? coll)\n            nil\n            (if (= n (count coll))\n              (concat (list (take n coll)) (all-subseq (rest coll) 0))\n              (concat (list (take n coll)) (all-subseq coll (inc n))))))\n        \n        is-consec-subseq\n        (fn is-consec-subseq [[x y & xs :as list-param]]\n          (if (or (empty? list-param) (= 1 (count list-param)))\n            false\n            (if (empty? xs)\n              (zero? (- (inc x) y))\n              (and (zero? (- (inc x) y)) (is-consec-subseq (rest list-param))))))\n        \n        max-length\n        (fn\n          ([] '())\n          ([list1 list2]\n           (if (> (count list1) (count list2))\n             list1\n             list2)))]\n    \n    (reduce max-length (filter is-consec-subseq (all-subseq coll 0)))))","user":"58a953dae4b01a0c0b232968"},{"problem":53,"code":"(fn [coll]\n    (let [f (fn put\n              ([coll a b] (put coll [b] a b))\n              ([coll val a b]\n               (if (> a b)\n                 (conj (pop coll) (conj val a))\n                 (conj coll a))))\n \n          fgroup (fn [coll a]\n                   (let [l (last coll)]\n                    (cond \n                     (nil? l)  (conj coll a)\n                     (coll? l) (f coll l a (last l))\n                     :else     (f coll a l))))\n \n          longest (fn [a b]\n                   (reduce\n                    \n                    (fn\n                      ([] [])\n                      ([x] x)\n                      ([x y] (if (>= (count x) (count y)) x y)))\n                    \n                    (filter \n                     coll?\n                     (list a b))))]\n\n    (reduce longest\n            (reduce fgroup [] coll))))","user":"5eccc5c2e4b016b56eae058f"},{"code":"(fn [f e n c]\n  (loop [r [] c c i []]\n    (if (empty? c)\n      r\n      (let [j (conj i (f c))]\n        (if (and (> (n j) (n r)) (> (n j) 1))\n          (if (= (inc (f c)) (f (e c)))\n            (recur j (e c) j)\n            (recur j (e c) []))\n          (if (= (inc (f c)) (f (e c)))\n            (recur r (e c) j)\n            (recur r (e c) [])))))))\nfirst rest count","problem":53,"user":"4e49badd535dc968683fc4c9"},{"problem":53,"code":"(fn [x]\n  (loop [col x opt [] inter [] prev nil]\n    (cond (empty? col) \n          (if (> (count opt) (count inter))\n                 opt\n                 (if (= (count inter) 1)\n                    []\n                   inter))\n          (nil? prev)\n          (recur (rest col) opt (conj inter (first col)) (first col))\n          (= (inc prev) (first col))\n          (recur (rest col) opt (conj inter (first col)) (first col))\n          :else \n            (recur \n               (rest col) \n               (if (> (count opt) (count inter))\n                 opt\n                 inter)\n               (vector (first col)) \n               (first col)))))","user":"563c48e7e4b0bfe05bf11832"},{"problem":53,"code":"(fn [[y & ys]]\n  (loop [[x & xs] ys\n         acc-a    []\n         acc-b    [y]]\n    (if x\n      (if (> x (last acc-b))\n        (recur xs acc-a (conj acc-b x))\n        (if (> (count acc-b) 1)\n          (recur xs (max-key count acc-b acc-a) [x])\n          (recur xs acc-a                       [x])))\n      (if (> (count acc-b) 1)\n        (max-key count acc-b acc-a)\n        acc-a))))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn [l] \n   (reduce \n    (fn [x y] (if (> (count x) (count y)) x y)) [] \n    (reverse \n     \n     (filter (fn [q] (> (count q) 1)) \n             (reduce \n              (fn [a b] \n                (let [mostrecent (-> a peek peek)] \n                  (cond\n                   (nil? mostrecent) [[b]]\n                   (>= mostrecent b) (conj a [b])\n                   (< mostrecent b) (conj \n                                     (vec (pop a)) \n                                     (conj (peek a) b)))))\n              [[]] l\n       )))))","problem":53,"user":"52eee533e4b05e3f0be25ecb"},{"problem":53,"code":"#(or\n  (first\n    (sort-by\n      (comp - count)\n      (for [f [(fn [[a b]] (= b (+ 1 a)))]\n            p (partition-by f (map list % (next %)))\n            r [`[~@(map first p) ~(last (last p))]]\n            :when (f r)]\n        r)))\n  [])","user":"53bb512ce4b047364c044503"},{"code":"(fn [l]\n  (letfn [(sublists [[a & r] tmp out]\n            (cond (nil? a) (cons tmp out)\n                  (empty? tmp) (recur r [a] out)\n                  (> a (last tmp)) (recur r (conj tmp a) out)\n                  :else (recur r [a] (cons tmp out))))]\n  (or\n    (last\n      (sort-by count\n        (filter #(< 1 (count %)) (sublists l [] []))))\n    [])))","problem":53,"user":"4f8345c6e4b033992c121c1b"},{"problem":53,"code":"(fn\n  [s]\n  (->> (partition 2 1 s)\n       (partition-by (partial apply <))\n       (filter (fn [[[a b]]] (< a b)))\n       (reduce (fn [m s] (if (> (count s) (count m)) s m)) [])\n       (#(if (= [] %) % (cons (ffirst %) (map second %))))\n  )\n)","user":"54e5bdf2e4b024c67c0cf7fe"},{"code":"(fn longest-increasing\n  [col]\n  (let [stuff (reductions \n (fn [col num]\n   (if (or (not (last col)) \n           (> num (last col)))\n     (concat col (list num))\n     (list num))) \n [] col)]\n  \n  (let [biggest (apply max (map #(count %) stuff))]\n    (let [result (first (drop-while #(not= (count %1) biggest) stuff))]\n      (if (> (count result) 1)\n        result\n        '()))\n    )\n  ))","problem":53,"user":"4fbd6210e4b081705acca303"},{"code":"(fn [col] (let [a (map-indexed - col) \n                  b (frequencies a) \n                  c (apply max-key val b)\n                  d (keep-indexed #(and (> (last c) 1) (= %2 (first c))) a)\n                  e (filter number? (map #(if %1 %2) d col))] e))","problem":53,"user":"510c01bae4b078ea7192110a"},{"code":"(fn lis [xs] \n  (letfn [(lis-from [xs acc ] \n                    (loop [[y & ys] xs a [acc]] \n                      (if (not= 1 (- y (last a))) a \n                        (if (empty? ys) (conj a y) (recur ys (conj a y))))))]\n    (apply max-key #(let [x (count %)] (if (= x 1) (- 0 1) x))\n           (cons [] (map #(lis-from (rest %) (first %)) (take (- (count xs) 1) (iterate rest xs)))))))","problem":53,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":53,"code":"(fn solve [a]\n  (let [max-subseq (fn [a]\n                     (reduce (fn [res el]\n                               (let [but-first-seq (rest res)\n                                     first-seq     (first res)\n                                     first-el      (first first-seq)]\n                                 (if (or (nil? first-el) (< first-el el))\n                                   (conj but-first-seq (conj first-seq el))\n                                   (conj res (list el))))) '(()) a))\n        get-max (fn [a]\n                  (let [sizes    (map count a)\n                        max-size (apply max sizes)]\n                    (if (<= max-size 1) []\n                        (->> a\n                             (filter #(= (count %) max-size))\n                             (first)))))\n        seqs (max-subseq a)]\n    (reverse (get-max (reverse seqs)))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":53,"code":"(fn [s]\n  (->> s\n       (partition 2 1)\n       (partition-by (partial apply <))\n       (filter #(apply < (first %)))\n       (reduce #(if (> (count %2) (count %1)) %2 %1) '())\n       (#(if (empty? %) % (cons (ffirst %) (map second %))))))","user":"52e851bfe4b09f7907dd149a"},{"code":"(fn longest [collect]\n  (loop [col (rest collect),\n         preview (first collect),\n         result [1],\n         n 1,\n         curr [(first collect)]]\n    (if (empty? col)\n        (cond (< n 2) [] \n              (< (first result) n) curr\n              true (rest result)\n         )\n        (let[\n             val (first col),\n             sign (> val preview)            \n             ]\n          (if  (true? sign)            \n\t\t          (recur (rest col) \n\t\t                 val\n\t\t                 result\n\t\t                 (inc n)\n                     (conj curr val)\n\t\t          )\n              (recur (rest col)\n                     val\n                     (if (< (first result) n)\n                         (cons n curr)\n                         result                         \n                     )\n                     1\n                     [val]                \n                )\n          )\n        )\n    )\n  )\n)","problem":53,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":53,"code":"(fn [xs]\n  (let [all-increasing-seq \n        (reductions #(if (or (empty? %) (< (peek %) %2)) (conj % %2) (vector %2)) [] xs)]\n    (->> all-increasing-seq \n         (filter #(> (count %) 1))\n         (reduce #(if (> (count %2) (count %)) %2 %) []))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":53,"code":"(fn [coll]\n  (first\n   (reduce (fn [[res acc] e]\n             (if (= (inc (last acc)) e)\n               (let [nacc (conj acc e)]\n                 (if (and (>= (count nacc) 2)\n                          (> (count nacc) (count res)))\n                   [nacc nacc]\n                   [res nacc]))\n               [res [e]]))\n           [[] [(first coll)]]\n           (rest coll))))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn [coll]\n  (first\n   (reduce\n    (fn [[longest current] val]\n      (let [current (if (or (empty? current)\n                            (= val (inc (last current))))\n                      (conj current val)\n                      [val])\n            longest (if (and (> (count current)\n                                (count longest))\n                             (>= (count current) 2))\n                      current\n                      longest)]\n        [longest current]))\n    [[] []]\n    coll)))","problem":53,"user":"5014754de4b094324338f8e5"},{"problem":53,"code":"(fn [coll]\n  (loop [cur [(first coll)]\n         tail []\n         left (rest coll)]\n    (if-let [[l & r] left]\n      (if (> l (last cur))\n        (recur (conj cur l) tail r)\n      (if (> (count cur) (count tail))\n        (recur [l] cur r)\n        (recur [l] tail r)\n      ))\n\n      (if (= 1 (count cur) (count tail))\n        []\n      (if (> (count cur) (count tail))\n        cur\n        tail)\n      ))))","user":"56fc0601e4b07572ad1a88db"},{"problem":53,"code":"(fn [xs]\n      (loop [mx [] rs xs]\n            (if (or (empty? rs) (empty? (rest rs))) mx\n                (let [[head body] (split-at (loop [i 1]\n                                              (cond\n                                               (= i (count rs))  i\n                                               (= (inc (nth rs (dec i)))\n                                                  (nth rs i)) (recur (inc i))\n                                               (= i 1) 0\n                                               :else i)) rs)]\n                     (cond\n                        (empty? head) (recur mx (rest rs))\n                        (> (count head) (count mx)) (recur head body)\n                        :else (recur mx body)\n                      )))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":53,"code":"(fn longest-increasing-subseq [coll]\n  (let [pp (\n      (fn partition-when-dec [c]\n        (when-let [s (seq c)]\n          (let [run (\n                     (fn take-while-2\n                       ([pred c]\n                        (when-let [s (seq c)]\n                          (cons (first s) (take-while-2 pred (rest s) (first s)))))\n                       ([pred c previous]\n                        (when-let [s (seq c)]\n                          (when (pred previous (first s))\n                            (cons (first s) (take-while-2 pred (rest s) (first s)))))))\n                     < s)]\n            (cons run (partition-when-dec (seq (drop (count run) s)))))))\n            coll),\n        counts (map count pp),\n        maxx (max 2 (apply max counts)) ]\n    (into [] (first (filter #(= maxx (count %)) pp)))))","user":"57b99d48e4b0fbc9809a27f2"},{"code":"#(letfn [(reducer [[cur best] next]\n          (let [upd (if (and (seq cur) (> next (last cur)))\n                      (conj cur next)\n                      [next])\n                upd-best (if (> (count upd) (count best))\n                           upd\n                           best)]\n            [upd upd-best]))]\n  (let [[last best]\n        (reduce reducer [[] []] %)]\n    (if (> (count best) 1)\n      best\n      [])))","problem":53,"user":"53134005e4b08068f379ed07"},{"code":"#(loop [t 1 d 0 res []]\n  (if (> (+ t d) (count %))\n   (if (= (count res) 1) [] res)\n   (let [acc (take t (drop d %))]\n    (if (apply < acc)\n        (if (> (count acc) (count res))\n            (recur (inc t) d acc)\n            (recur (inc t) d res))\n        (recur 1 (dec (+ t d)) res)))))","problem":53,"user":"509160dae4b0742c82730aef"},{"code":"(fn [coll]\n  (let [isub (fn [c]\n              (loop [c c, r [[(first c)]]]\n                    (cond\n                     (= 1 (count c)) \n                       r\n                     (< (first c) (second c))\n                       (recur (rest c) (conj (pop r) (conj (peek r) (second c))))  \n                     :else\n                       (recur (rest c) (conj r [(second c)]))))\n              )\n        \n        isubs (reverse (filter #(< 1 (count %)) (isub coll)))\n       ]\n\n    (if (empty? isubs) isubs\n      (apply (partial max-key count) isubs))\n\n))","problem":53,"user":"53597288e4b04ce2eb3ed29c"},{"problem":53,"code":"(fn [l] (reduce \n         #(if (or  (= 1(count %2)) (>= (count %1) (count %2))) %1  %2\n           ) \n         '()\n         (reduce \n         #(cond\n           (empty? %1) (list (list %2))\n           (> %2 (last (last %1))) (concat (drop-last %1) (list (concat (last %1) (list %2))) )\n           :else (concat %1 (list(list %2)))\n           ) \n         '() l)))","user":"54edcf96e4b024c67c0cf866"},{"problem":53,"code":"(fn __ [coll]\n  (let [longest (->> coll \n                   (partition 2 1)\n\t\t\t\t   (map (fn [[curr next]] [(= 1 (- next curr)) curr next]))\n\t\t\t\t   (partition-by first)\n                   (filter #(first (first %)))\n\t\t\t\t   (sort-by count)\n\t\t\t\t\tlast)]\n    (reduce (fn [res [inc? curr next]] (conj res next)) (-> longest first rest vec) (rest longest))))","user":"55a62092e4b0acc240e31554"},{"code":"(fn [[init1 & lst]]\n  (loop [[fst & rst] lst\n         run (vector init1)\n         longest []]\n     (if (nil? fst)\n      longest\n      (if (= fst (inc (last run)))\n        (recur rst (conj run fst) (if (> (inc (count run)) (count longest)) (conj run fst) longest))\n        (recur rst [fst] longest)))))","problem":53,"user":"4ee271e2535d10e5ff6f5369"},{"problem":53,"code":"(fn prob53 [s]\n  (let\n      [p (reduce\n          (fn [v i]\n            (if (> i (last (last v)))\n              (concat (butlast v) (list (conj (last v) i)))\n              (concat v (list [i]))))\n          (list [(first s)]) (rest s))\n       m (apply max (map count p))]\n    (if (= m 1) [] (first (filter #(= m (count %)) p)))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn [s]\n  (let [take-larger (fn [x y] (if (>= (count x) (count y)) x y))]\n  (loop [s s acc [] largest []]\n    (cond\n    \t(empty? s) (let [result (take-larger largest acc)] (if (> 2 (count result)) [] result))\n     \t(apply < (conj acc (first s)))\n     \t\t(recur (rest s) (conj acc (first s)) largest)\n     \t:else (recur (rest s) [(first s)] (take-larger largest acc))))))","problem":53,"user":"51990df9e4b068aa333628fc"},{"code":"(fn [coll]\n   (letfn [(count-incr [coll]\n                     (loop [[h & t] coll k 0 prev Double/NEGATIVE_INFINITY]\n                       (if (and h (> h prev)) (recur t (inc k) h) k)))\n         (split-incr [coll]\n                     (if (seq coll)\n                       (let [n (count-incr coll) [h t] (split-at n coll)]\n                         (lazy-seq (cons h (split-incr t))))))]\n     (reduce #(if (and (> (count %2) 1) (< (count %1) (count %2))) %2 %1) [] (split-incr coll))))","problem":53,"user":"50eddbc4e4b06330c1f87c4b"},{"code":"#(if-let [r (first\n             (sort-by count >\n                      (reduce (fn [s x]\n                                (if (or (empty? s)\n                                        (<= x (peek (peek s))))\n                                  (conj s [x])\n                                  (conj (pop s) (conj (peek s) x))))\n                              [] %)))]\n   (if (> (count r) 1) r []))","problem":53,"user":"506ef8c3e4b09350ab4199f4"},{"problem":53,"code":"(fn [s] (let [x  \n              (map second \n                   (apply max-key count (partition-by first \n                     (map-indexed #(vector (- % %2) %2) s)))) ] \n          (if (> (count x) 1 ) (seq x) '())))","user":"52eaba10e4b09f7907dd14c2"},{"problem":53,"code":"#(let [ clls %]\n   (loop [c (rest clls) f (first clls) re [] curr []]\n     (cond\n       (= 0 (count curr)) (recur (rest c) (first c) re [f]) \n       (not f)\n          (cond \n             (and (> 2 (count curr)) (> 2 (count re))) []\n             :else (if (> (count curr) (count re)) curr  re))\n       (= f (+ 1 (last curr))) (recur (rest c)(first c) re (conj curr f))\n       :else (if (> (count curr) (count re)) (recur (rest c)(first c) curr [f]) \n                                (recur (rest c)(first c) re [f])))))","user":"5dc12b0ae4b0e59a23173d84"},{"code":"(fn solucion-53 [xss]\n  (letfn [(subsucesiones [xs]\n            (cond (= (count xs) 0) ()\n                  (= (count xs) 1) (list xs)\n                  true (let [[x y & zs] xs\n                             [us & vss :as p] (subsucesiones (rest xs))]\n                         (if (< x y) \n                           (cons (cons x us) vss)\n                           (cons (list x) p)))))\n          (ordenadas [xss]\n            (sort-by (fn [xs] (- (count xs))) xss))\n          (masLarga [xs]\n            (first (ordenadas xs)))]\n    (let [ys (masLarga (subsucesiones xss))]\n      (if (< (count ys) 2) [] ys))))","problem":53,"user":"4db51ce0535d87e67b28fe06"},{"problem":53,"code":"(fn [coll]\n  (let [collections (let [lower-limit (dec (apply min coll)), upper-limit (inc (apply max coll))]\n                      (map-indexed\n                       #(list (nth coll (dec %1) lower-limit) %2 (nth coll (inc %1) upper-limit))\n                       coll))]\n    (map second\n         (last\n          (sort-by count\n                   (map-indexed\n                    (fn [index item]\n                      (concat\n                       (if (= (second item) (dec (second (nth collections (inc index) item))))\n                         (list item)\n                         '())\n                       (take-while (fn [%] (= (second %) (inc (first %))))\n                                   (drop (inc index) collections))))\n                    collections))))))","user":"5a59a76fe4b05d388ecb6c98"},{"code":"(fn [a] (concat (last (sort-by #(count %)\n\t(reverse (filter #(> (count %) 1) \n\t(reduce #(if (< (last (last %1)) %2)\n\t      (concat (butlast %1) [(concat (last %1) [%2])])\n\t      (concat %1 [[%2]])\n\t      )  [[99]] a\n\t)))\n )\n) []))","problem":53,"user":"51aeb1f4e4b09397d5109794"},{"code":"(fn longest-increasing-sub-seq [xs]\n  (let [p1 (map #(= (inc %1) %2) xs (rest xs))\n        p2 (cons true p1)\n        qual (fn [acc keep-ind]\n               (let [[ind ys] acc\n                     nind (inc ind)]\n                 (if (true? keep-ind)\n                   [ind (cons ind ys)]\n                   [nind (cons nind ys)])))\n        p3 (reverse (second (reduce qual [0 []] p2)))\n        p4 (map vector xs p3)\n        p5 (partition-by second p4)\n        p6 (map #(map first %) p5)\n        p7 (filter #(> (count %) 1) p6)\n        p8 (reverse (sort-by count p7))\n        p9 (first p8)]\n    (if (nil? p9)\n      []\n      p9)))","problem":53,"user":"4f2a35ace4b0d6649770a03a"},{"problem":53,"code":"(fn spt [a] \n            (let [cmp (fn [[a b]]( >= a b))]    \n              (loop [remaining a res []]\n                ( if (empty? remaining)\n                     (if (< 1 (count res)) res [])\n                     ( let [ a (map vector  (concat [Integer/MIN_VALUE] (drop-last remaining)) remaining )]\n                          (let [[c d] (split-with (complement cmp) (drop-while cmp a))]\n                               (recur (map second d) ( if (>= (count res) (count c)) res (map second c)))\n              ))))))","user":"55896a0ce4b059ccff29b204"},{"problem":53,"code":"(fn longest-run\n  [s]\n  (cond\n    (< (count s) 2) []\n    (#(= % (take (count %) (range (first %) (inc (last %))))) s) s\n    :else (or (last (sort-by count (filter seq? (map longest-run (partition (dec (count s)) 1 s))))) [])))","user":"4fe899a6e4b07c9f6fd12c54"},{"problem":53,"code":"(fn longest-inc-subseq\n  [coll]\n  (loop [best []\n         current [(first coll)]\n         coll (rest coll)]\n    (if (empty? coll)\n      (if (and (empty? (rest current)) (empty? (rest best)))\n        []\n      \t(max-key count current best))\n      (recur (max-key count current best)\n             (if (> (first coll) (last current))\n               (conj current (first coll))\n               [(first coll)])\n             (rest coll)))))","user":"572db6d5e4b0cd1946bd0f78"},{"code":"(fn mylongest\n        ([vs]\n           (mylongest vs #{}))\n        ([vs acc]\n           (if (empty? vs)\n             ;get longest one from acc\n             (let [longest (reduce #(if (< (count %) (count %2)) %2 %) acc)]\n              (if (= 1 (count longest))\n                []\n                longest))\n             ;collecting\n             (loop [vs' (next vs)\n                    acc' [(first vs)]\n                    prev' (first vs)]\n               (if (empty? vs')\n                 (mylongest vs' (conj acc acc'))\n                 (if (<= (first vs') prev')\n                   ;put this sub-seq to acc\n                   (mylongest vs' (conj acc acc'))\n                   ;find next one\n                   (recur (rest vs') (conj acc' (first vs')) (first vs'))\n                   ))))))","problem":53,"user":"52c58561e4b0c2d177d620f8"},{"problem":53,"code":"(fn fss [s]\n  ((fn find-sub-seq [sq longest current]\n     (let [longer #(if (and (> (count %2) 1) (> (count %2) (count %1))) %2 %1)\n           next-el (first sq)]\n     (cond\n      (empty? sq) (longer longest current)\n      (> next-el (last current)) (find-sub-seq (rest sq) longest (conj current next-el))\n      :else (find-sub-seq (rest sq) (longer longest current) [next-el])))) (rest s) [] [(first s)]))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":53,"code":"(fn [s] (->> s\n              (count)\n              (range)\n              (map #(drop % (partition 2 1 s)))\n              (map #(take-while (fn [[a b]] (> b a)) %))\n              (sort-by #(- (count %)))\n              (first)\n              (flatten)\n              (#(take-nth 2 (cons (first %) %)))\n              (#(if (first %) % (rest %)))\n              ))","user":"550aeddae4b06e50f9beb135"},{"code":"(fn [s]\n  (let [tear (\n(fn runner [[f & n]]\n  (if (empty? n)\n    (list (list f))\n    (let [[fseq & nseq] (runner n)\n          fr  \t\t\t(first fseq)]\n      (if (= (inc f) fr)\n        (cons (cons f fseq) nseq)\n        (cons (list f) (cons fseq nseq))))))\n              s)\n        max-count (reduce #(if (> (count %1) (count %2)) %1 %2) tear)]\n    (if (> (count max-count) 1) max-count [])))","problem":53,"user":"53908e6be4b0b51d73faae9a"},{"problem":53,"code":"(fn [xs]\n   (into [] (last (sort-by count (filter #(> (count %) 1)\n                                         (map-indexed (fn [idx val]\n                                                        (let [subxs (drop idx xs)\n                                                              start val]\n                                                          (map #(second %)\n                                                               (take-while #(= (first %) (- (second %) start))\n                                                                           (map-indexed #(into [] [%1 %2]) subxs)))\n                                                          )\n                                                        ) xs))))))","user":"589037b4e4b00487982d51d0"},{"problem":53,"code":"(fn find-subseq [c]\n  (let [the-seq (fn [n p c]\n                  (let [a (count (take-while #(apply p %) (partition n 1 c)))]\n                    (take (+ n a -1) c)))\n        chop (fn [c] (for [n (range (count c))] (drop n c)))\n        parts (chop c)\n        seqs (map (partial the-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (< (count longest) 2)\n      []\n      longest)))","user":"56f4623ae4b046a417f9205d"},{"problem":53,"code":"(fn [coll]\n   (->>\n    (reduce (fn [acc x]\n              (if (= (last acc) (dec x))\n                (conj acc x)\n                (conj acc \\X x)))\n            []\n            coll)\n    (partition-by #(= % \\X))\n    (apply max-key count)\n    (#(if (< (count %) 2)\n        '()\n        %))\n   ))","user":"5446ebc2e4b032a45b8693b8"},{"code":"(fn [s]\n  (let [countdown (range (count s) 0 -1)\n        pairs (partition 2 (interleave countdown s))\n        grouped-pairs (partition-by #(reduce + %) pairs)\n        ordered-pairs (sort-by #(- (count %)) grouped-pairs)\n        longest-seq (map second (first ordered-pairs))]\n    (if (> (count longest-seq) 1) longest-seq [])))","problem":53,"user":"4e9dafe1535dbda64a6f6b89"},{"code":"(fn [x]\n  (let [result (last (sort-by count \n                              (partition-by #(=\\b %)  \n                                            (reduce (fn [a b]\n                                                      (cond\n                                                        (= [] a) [b]\n                                                        (= (last a) (dec b)) (conj a b)\n                                                        :else (conj a \\b b)))\n                                                    []\n                                                    x))))]\n    \n    (if (< 1 (count result))\n      result\n      [])))","problem":53,"user":"51f04e89e4b0274c496158cd"},{"code":"#((fn acc [l current-sub-seq longest-so-far]\n  (let [longest (if (> (count current-sub-seq) (count longest-so-far))\n                  current-sub-seq\n                  longest-so-far)]\n    (if (empty? l)\n      (if (> (count longest) 1)\n        (reverse longest)\n        '())\n      (if (<= (first l) (first current-sub-seq))\n        (recur (rest l) (list (first l)) longest)\n        (recur (rest l) (cons (first l) current-sub-seq) longest-so-far))))) (rest %) (list (first %)) nil)","problem":53,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn [[x & r]]\n  (or (first\n    (->> r\n         (reductions (fn [v n]\n                        `[\n                          ~@(if (< (peek v) n) v)\n                          ~n\n                         ])\n                     [x])\n         (group-by count)\n         last\n         second\n         (filter #(< 1 (count %)))))\n     []))","problem":53,"user":"4f38b7d9e4b0e243712b1ee0"},{"code":"(fn [coll]\n  (letfn [(ss-split [[h & t :as coll] v]\n            (if (or (nil? h) (<= v (first h)))\n              (conj coll (list v)) (conj t (conj h v))))]\n    (->>\n     (reduce ss-split '() coll)\n     (filter #(> (count %) 1))\n     (sort-by count)\n     (last)\n     (reverse))))","problem":53,"user":"511d6a01e4b022853b0e07a5"},{"code":"(fn [c]\n  (->> c\n       (partition 2 1)\n       (partition-by #(apply - %))\n       (filter (fn [[[x y]]] (= (- y x) 1)))\n       (sort-by count)\n       last\n       ((juxt #(map first (butlast %)) last))\n       (apply concat)))","problem":53,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn [coll]\n  (let [x1 (partition 2 1 coll)\n        x2 (map (fn [[y1 y2]] (if (< y1 y2) [y1 y2] nil)) x1)\n        x3 (partition-by class x2)\n        x4 (filter #(identity (first %)) x3)\n        x5 (reduce #(if (> (count %2) (count %1)) %2 %1) [] x4)]\n    (if (seq x5)\n      (concat (first x5) (for [[y1 y2] (drop 1 x5)] y2))\n      x5)))","problem":53,"user":"4f65eec7e4b07046d9f4ef48"},{"problem":53,"code":"(fn [a] (->> (map vector a (rest a))\n                 ((fn [a] (partition-by #(compare (first %1) (second %1))a)))\n                 (filter #(=(compare (ffirst %) (second (first %)))-1))\n                 ((fn [a] (first (filter #(= (count %) (apply max (map count a))) a))))\n                 ((fn [a] (if (nil? a) [[]] a)))\n                 (reduce #(conj %1 (second %2)))))","user":"55af7e21e4b03311e7b732cc"},{"problem":53,"code":"(fn inc-sub-seq [sx]\n  (letfn [(find-longest [coll]\n  (if (every? #(= 1 (count %)) coll)\n    (first coll)\n    (last (sort-by count coll))))         \n(discard-dec [coll]\n  (let [x (first coll)\n        y (second coll)]\n    (if (> x y) [] coll)))]\n  (->>\n   sx\n   (partition 2 1)\n   (partition-by #(apply < %))\n   (find-longest)\n   (flatten)\n   (distinct)\n   (discard-dec))))","user":"56504dc2e4b0284900eef6bc"},{"code":"(fn [coll]\n  (reduce #(if (> (count %) (count %2)) % %2) []\n          (filter #(> (count %) 1)\n                  (reduce \n                    #(if (= (last (last %)) (dec %2))\n                      (conj (vec (butlast %)) (conj (last %) %2))\n                      (conj % [%2]))\n                    [[-1]] coll))))","problem":53,"user":"4fa5406fe4b081705acca1ac"},{"code":"(fn [in-list]\n  (let\n      [finish (fn [val1]\n                (let\n                    [list-of-lists (first val1)\n                     new-list (vec (rest val1))]\n                  (if (> (count new-list) 1)\n                    (conj list-of-lists new-list)\n                    list-of-lists)))\n       sub-list-lists\n       (finish\n        (reduce (fn [val1 val2]\n                  (cond\n                   (empty? val1) [[] val2]\n                   (= (+ (last val1) 1) val2) (conj val1 val2)\n                   :else [(finish val1) val2]))\n                [] in-list))]\n    \n    (reduce (fn\n              ([] [])\n              ([list1] list1)\n              ([list1 list2]\n                 (if (> (count list1)\n                        (count list2))\n                   list1\n                   list2)))\n              sub-list-lists)))","problem":53,"user":"4f03818e535dcb61093f6b00"},{"problem":53,"code":"(fn [coll]                                                                                                                                   \n         (let [subsets (mapcat #(partition %1 1 coll) (range 2 (count coll)))]\n           (->> subsets                                                                                                                                      \n                (filter #(apply < %))                                                                                                                       \n                (sort-by count)                                                                                                                              \n                (partition-by count)                                                                                                                         \n                last                                                                                                                                         \n                first                                                                                                                                        \n                vec)))","user":"54ff074de4b07d26eda61d47"},{"problem":53,"code":"(fn [coll]\n    (or (some (fn [subseq]\n                  (when (apply < subseq) subseq))\n              (mapcat #(partition % 1 coll) (reverse (range 2 (inc (count coll))))))\n        []))","user":"5512aca6e4b055c2f668d4b4"},{"problem":53,"code":"(fn [ms] (first\n  (reduce\n    (fn [f s]\n      (cond\n               (empty? (second f))                         [(first f) [s]]\n               (>= (last (second f)) s)                    [(first f) [s]]\n               (>= (count (second f)) (count (first f)))   [(conj (second f) s) (conj (second f) s)]\n               true    [(first f) (conj (second f) s)]\n                 \n      ))\n   \n   [[] []] ms)))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll) \n    (partition-by #(> (second %) (first %))) \n    (filter #(> (second (first %)) (ffirst %)))\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n    flatten\n    distinct))","problem":53,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"(fn\n  [coll]\n  (let [pcoll (for [[f n] (partition 2 1 coll)]\n                (when (< f n)\n                  [f n]))\n        liss (->> pcoll\n                  (partition-by nil?)\n                  (remove (comp nil? first))\n                  (sort-by (comp - count))\n                  first)]\n    \n    (if (seq liss)\n      (cons (ffirst liss) (map second liss))\n      [])))","problem":53,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn sub-seq [coll]\n  (let [inc-sub-seq\n        (filter #(< (ffirst %) (second (first %)))\n                (partition-by\n                 #(< (first %) (second %))\n                 (map reverse (map conj (map reverse (partition 2 1 coll)) (range)))))\n        inc-sub-seq-lengths\n        (map count inc-sub-seq)]\n    (if (pos? (count inc-sub-seq))\n      (let [indx-intermediate\n            (.indexOf inc-sub-seq-lengths (reduce max inc-sub-seq-lengths))\n            indx\n            (last (first (nth inc-sub-seq indx-intermediate)))\n        len\n        (inc (nth inc-sub-seq-lengths indx-intermediate))]\n        (take len (drop indx coll)))\n      (list))))","problem":53,"user":"4fe8e719e4b0547ebccb2430"},{"problem":53,"code":"(fn liss\n  [x]\n  (:longest (reduce (fn [{:keys [longest current]} e]\n                      (let [new-current (if (or (empty? current) (>= (last current) e)) [e] (conj current e))\n                            new-current-count (count new-current)\n                            longest-count (count longest)]\n                        (if (and (< 1 new-current-count) (< longest-count new-current-count))\n                          {:longest new-current :current new-current}\n                          {:longest longest :current new-current})))\n                    {:longest [] :current []}\n                    x)))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":53,"code":"(fn increasing-subsequences\n  [xs]\n  (let [length (count xs)\n        subsequences (for [x (range length)\n                           y (range x length)\n                           :let [v (subvec xs x (inc y))]\n                           :when (and (> (count v) 1) (apply < v))]\n                       v)]\n    (if (empty? subsequences)\n      []\n      (apply max-key count (reverse subsequences)))))","user":"5cdc08a2e4b05ee0cb31173a"},{"code":"(fn [[a & as]]\r\n  (let [inc-seqs (reductions \r\n                   (fn [xs n]\r\n                     (if (< (last xs) n)\r\n                       (conj xs n)\r\n                       [n]))\r\n                   [a]\r\n                   as)\r\n         max-seq (reduce \r\n                   (fn [xs a]\r\n                     (if (and (< 1 (count a))\r\n                           (< (count xs) (count a)))\r\n                       a\r\n                       xs))\r\n                   []\r\n                   inc-seqs)\r\n        ]\r\n    max-seq))","problem":53,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [a]\n  (let [result \n    (first \n      (reverse \n        (sort-by (fn [x] (count x)) \n          (reduce\n            (fn [ [ curr & the-rest :as coll] val ] \n              (if (or (nil? (last curr)) (> val (last curr)))\n                (assoc coll 0 (conj curr val))\n                (vec (concat [[val]] coll))))\n            [[]] a))))]\n    (if (> 2 (count result))\n      []\n      result)))","problem":53,"user":"4f410b63e4b0e243712b1fc5"},{"code":"(fn [coll]\n  (->> coll\n       (partition 2 1)\n       (partition-by (partial apply <))\n       (filter #(apply < (first %)))\n       (sort-by count >)\n       first\n       (reduce (fn [m e]\n                 (if (seq m)\n                   (conj m (last e))\n                   (into m e))) [])))","problem":53,"user":"5080a697e4b01a93d3f38e49"},{"code":"(fn [x]\n  (reduce\n    #(if (> (count %2) (count %)) %2 %1)\n    []\n    (filter #(> (count %) 1)\n      (reductions\n      #(if (= (last %1) (dec %2)) (concat %1 [%2]) [%2])\n      []\n      x))))","problem":53,"user":"4f0f174c535d0136e6c22330"},{"problem":53,"code":"(fn longest-inc-sub-seq [l]\n  (if (< (count l) 2)\n    []\n    (loop [l1 [(first l)]\n           l2 (rest l)]\n      (if (> (first l2) (last l1))\n        (if (empty? (rest l2))\n          (concat l1 [(first l2)])\n          (recur (concat l1 [(first l2)])\n                 (rest l2)))\n        (if (and (>= (count l1) (count (longest-inc-sub-seq l2)))\n                 (> (count l1) 1))\n          l1\n          (longest-inc-sub-seq l2))))))","user":"55e4487ce4b050e68259b44c"},{"problem":53,"code":"(fn [s]\n  (let [pred #(< %1 %2)\n        val-bool-pair (fn [se1](partition-by second (map list se1 (reductions = true (map pred se1 (rest se1))))))\n        partition-decr (fn [se] (map (partial map first) (val-bool-pair se)))\n        longest-subvec (fn [acc e] (if (and (< (count acc) (count e)) (> (count e) 1)) e acc))]\n  (reduce longest-subvec '() (partition-decr s))))","user":"5b4ff637e4b02d533a91bce0"},{"code":"(fn [coll]\n  (loop [prev (first coll), z (vector prev), cur_max [], remaining (rest coll)]\n    (if (empty? remaining)\n      (if (> (count z) (count cur_max))\n        (if (> (count z) 1) z [])\n        (if (> (count cur_max) 1) cur_max []))\n      (let [nprev (first remaining), ncoll (rest remaining)]\n        (if (> nprev prev)\n          (recur nprev (conj z nprev) cur_max ncoll)\n          (if (> (count z) (count cur_max))\n            (recur nprev (vector nprev) z ncoll)\n            (recur nprev (vector nprev) cur_max ncoll)))))))","problem":53,"user":"523f1245e4b01c266ffa7f95"},{"problem":53,"code":"(fn [s]\n  (letfn [(incr [acc s]\n            (if (and (seq s) (> (first s) (last acc)))\n              (recur (conj acc (first s)) (rest s))\n              acc))\n          (increasing [[h & r]] (incr [h] r))\n          (increasing-subseqs [s]\n            (if (seq s)\n              (let [t (increasing s)]\n                (cons t (increasing-subseqs (drop (count t) s))))\n              []))]\n    (let [t (increasing-subseqs s)\n          max-count (max 2 (apply max (map count t)))]\n      (or (first (filter #(= max-count (count %)) \n                         t)) \n          []))))","user":"52951156e4b02ebb4ef7501b"},{"code":"#(letfn [(acc [[current longest] e]\n   (if (= (dec e) (peek current))\n\t\t(let [current (conj current e)]\n\t\t\t[current (if (> (count current) (count longest))\n\t\t\t\t\t\tcurrent\n\t\t\t\t\t\tlongest)])\n\t\t[[e] longest]))]\n   (get (reduce acc [[] []] %) 1))","problem":53,"user":"52c4af71e4b0c2d177d620e1"},{"problem":53,"code":"(fn longest-inc-sub-seq\n    [s]\n    (->> s \n         (partition 2 1) \n         (partition-by (partial apply <)) \n         (filter (fn [[[a b]]] (< a b))) \n         (reduce (fn [m s] (if (> (count s) (count m)) s m)) []) \n         (#(cons (ffirst %) (map second %)))\n         (filter #(not (nil? %)))))","user":"552d487ee4b076ab5578f7e4"},{"code":"(fn [s]\n  (let [result\n    (apply max-key count\n      (reverse\n        (map\n          (fn [ss]\n            (conj\n              (map last\n                (take-while #(apply < %)\n                  (map list ss (rest ss))))\n              (first ss)))\n          (take (count s) (iterate rest s)))))]\n    (if (> (count result) 1) result [])))","problem":53,"user":"4f91a38ae4b0dcca54ed6c9f"},{"problem":53,"code":"(fn [eles]\n      ((fn increasing [eles current-run]\n         (if (empty? eles)\n           current-run\n           (if (> (first eles)\n                  (last current-run))\n             (increasing (rest eles) (conj current-run (first eles)))\n             (let [later-run (increasing (rest eles) [(first eles)])]\n               (if (or (> (count current-run) 1)\n                       (> (count later-run) 1))\n                 (if (>= (count current-run)\n                        (count later-run))\n                   current-run\n                   later-run)\n                 [])))))\n       (rest eles) [(first eles)]))","user":"55d95be7e4b0e31453f64ac9"},{"code":"#(\nlet [x (\n(fn longest-subseq [maxs news coll]\n  (if (empty? coll)\n    (if (> (count news) (count maxs))\n      news\n      maxs\n      )\n    (if (>= (last news) (first coll))\n      (if (> (count news) (count maxs))\n        (longest-subseq news [(first coll)] (rest coll))\n        (longest-subseq maxs [(first coll)] (rest coll))\n         )\n      (longest-subseq maxs (conj news (first coll)) (rest coll))\n      )\n    )\n  )\n[] [(first %)] (rest %))]\n(if (> (count x) 1)\n  x\n  []\n  )\n)","problem":53,"user":"52e59ca5e4b09f7907dd1464"},{"problem":53,"code":"(fn my-fn [integers]                                                           \n  (let [reducer (fn [acc el]                                                     \n                  (let [last-seq (last acc)]                                     \n                    (cond                                                        \n                      (nil? last-seq) [[el]]                                     \n                      (= (dec el) (last last-seq)) (conj (vec (butlast acc)) (conj last-seq el))\n                      :else (conj acc [el]))))                                   \n        seqs (reduce reducer [] integers)                                        \n        multi-seqs (filter #(not (= (count %) 1)) seqs)                          \n        largest-seq (last (sort-by count multi-seqs))]                           \n    (or largest-seq [])))","user":"58ebd10de4b056aecfd47d49"},{"code":"(letfn [\n        (step [seqs item]\n            (if (> item (peek (first seqs)))\n                (conj (rest seqs) (conj (first seqs) item))\n                (conj seqs [item])\n            ))\n        (max-increasing-subseq [coll]\n            (if (zero? (count coll))\n                []\n                (let [subseqs (reduce step (list [(first coll)]) (rest coll))\n                      res (apply max-key count subseqs)]\n                    (if (< (count res) 2) [] res)\n                )))\n    ]\n    #(max-increasing-subseq %)\n)","problem":53,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn inc-subs [xs]\r\n  (let [rests (fn rests\r\n                ([xs] (rests xs []))\r\n                ([xs ac]\r\n                   (if (empty? xs)\r\n                     ac\r\n                     (recur (rest xs) (conj ac xs)))))\r\n        take-inc (fn take-inc [xs]\r\n                   (loop [ys (rest xs)\r\n                          ac [(first xs)]]\r\n                     (if (empty? ys)\r\n                       ac\r\n                       (if (< (peek ac) (first ys))\r\n                         (recur (rest ys) (conj ac (first ys)))\r\n                         ac))))\r\n        rests (rests xs)\r\n        incs (map take-inc rests)\r\n        incs (filter #(>= (count %) 2) incs)]\r\n    (if (empty? incs)\r\n      []\r\n      (let [max-inc (apply max (map count incs))\r\n            maxs (filter #(= (count %) max-inc) incs)]\r\n        (first maxs)))))","problem":53,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn [xs]\n  (let [ranges (fn [n] (mapcat (fn [m] (map #(list m %) (range (inc m) (inc n)))) (range (inc n))))\n        subseqs (map #(apply subvec xs %) (ranges (count xs)))\n        ascending (filter (partial apply <) subseqs)\n        longest (reduce #(if (>= (count %1) (count %2)) %1 %2) ascending)]\n  (if (> (count longest) 1) longest [])))","problem":53,"user":"4f4f0287e4b03ad3f0c10cd7"},{"problem":53,"code":"(fn [vec] (->> vec\n             (map-indexed #(-> {:i % :v %2}))\n             (partition-by #(- (:i %) (:v %)))\n             (filter #(< 1 (count %)))\n             (cons ()) (apply max-key count)\n             (map #(:v %))))","user":"5568a1bde4b0c656e3ff1857"},{"code":"(fn longest [coll]\n  (loop [coll coll longest (seq '())]\n    (if (= (first coll) nil)\n\t  (if (> (count longest) 1)\n\t    longest\n\t\t[])\n\t  (let [next-inc-seq (loop [coll coll inc-seq [-1]]\n                           (if (or (= (first coll) nil) (<= (first coll) (last inc-seq)))\n                               (rest inc-seq)\n\t                       (recur (rest coll) (conj inc-seq (first coll)))))]\n\t    (recur (subvec coll (count next-inc-seq))\n\t\t       (if (>= (count longest) (count next-inc-seq))\n\t\t\t     longest\n\t\t\t\t next-inc-seq))))))","problem":53,"user":"52463059e4b09dbe66b56198"},{"problem":53,"code":"(fn [c]\n    (loop\n      [best []\n       current []\n       remaining c]\n      (if (empty? remaining)\n        (if (> (count best) 1) best [])\n        (let [current (if (or (empty? current) (= (inc (last current)) (first remaining)))\n                        (conj current (first remaining))\n                        (vector (first remaining)))\n              ]\n          (if (> (count current) (count best))\n            (recur current current (rest remaining))\n            (recur best current (rest remaining)))))))","user":"54ca130ce4b057c6fda3a250"},{"code":"(fn [s]\n  (let [l-s-s\n    (first\n      (reduce \n        #(let [appended-to-second (if (> %2 (peek (second %1)))\n                                    [(first %1) (conj (second %1) %2)]\n                                    [(first %1) [%2]])]\n          (if (> (count (second appended-to-second))\n                 (count (first appended-to-second)))\n            [(second appended-to-second) (second appended-to-second)]\n            appended-to-second))\n        [[(first s)][(first s)]] (rest s)\n      ))]\n    (if (> (count l-s-s) 1)\n      l-s-s\n      [])))","problem":53,"user":"50bb646de4b03e68e4411ca3"},{"problem":53,"code":"(fn [d]\n  (let [f (fn [c]\n            (loop [[e & r] c\n                   p nil\n                   ret []]\n              (if (nil? e) ret\n                  (if (or (nil? p) (> e p))\n                    (recur r e (conj ret e))\n                    ret))))\n        f2 (fn f2 [c]\n            (if (not (empty? c))\n              (max-key count (f2 (rest c)) (f c))\n              '()))\n        c (f2 d)]\n    (if (> (count c) 1) c [])))","user":"577832f4e4b0979f8965165b"},{"problem":53,"code":"(fn [coll]\n  (->>\n   (partition 2 1 coll)\n   (partition-by #(- (second %) (first %)))\n   (filter #(= 1 (- (second (first %)) (ffirst %))))\n   (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n   flatten\n   distinct))","user":"54c31f1be4b045293a27f609"},{"problem":53,"code":"(fn work-me \n  ([[x & xs]] (work-me xs [x] []))\n  ([[x & xs :as vect] acc max-acc]\n   (let [new-max (if (and (> (count acc) 1) \n                          (> (count acc) (count max-acc)))\n                             acc\n                             max-acc)\n         ]\n         (if (empty? vect)\n           new-max\n           (let [new-acc (if (>= (last acc) x)\n                          [x]\n                          (conj acc x))]\n             (recur xs new-acc new-max))))))","user":"5655e056e4b0f9d632dd849b"},{"code":"(fn [xs]\n  (or (->> (map vector xs (range))\n           (partition-by #(reduce - %))\n           (map #(map first %))\n           (filter #(> (count %) 1))\n           (sort-by count)\n           (last))\n      []))","problem":53,"user":"4f7ab8c7e4b06e829148e19c"},{"problem":53,"code":"(fn [coll]\n  (letfn [(adjpairs [coll]\n            (let [a (flatten (concat [nil] coll))\n                  b coll]\n              (into [] (map #(vec [% %2]) a b))))\n          (prt\n            [f coll]\n            (lazy-seq\n             (when-let [s (seq coll)]\n               (let [steps (take-while #(or (= nil (first %)) \n                                            (= (inc (first %)) (second %))) (adjpairs s))\n                     run (map second steps)]\n               (cons run (prt identity (seq (drop (count run) s))))))))]\n    (let [groups (prt identity coll)\n          lengths (map count groups)\n          maxlength (apply max lengths)\n          rslt (into [] (first\n                 (filter #(= maxlength (count %)) groups)))]\n     (if (= (count rslt) 1)\n         []\n          rslt))))","user":"5537cbaee4b09218d5f44fd3"},{"problem":53,"code":"(fn longest [l]\n  ((fn longest-sub [l current largest]\n                 (cond\n                   (empty? l)\n                    (cond\n                      (and (> (count current) 1) (> (count current) (count largest))) current\n                      :else largest)\n                   (> (first l) (last current))\n                    (longest-sub (rest l) (conj current (first l)) largest)\n                   (and (> (count current) 1) (> (count current) (count largest)))\n                    (longest-sub (rest l) [(first l)] current)\n                   :else\n                    (longest-sub (rest l) [(first l)] largest))) (rest l) [(first l)] []))","user":"5833a6d8e4b089d5ab817ca2"},{"problem":53,"code":"#(let [[r s]\n(reduce\n (fn [[a b] item]\n   (if (< (last a) item)\n    [(conj a item) b]\n    (if (> (count a) (count b))\n      [[item] a]\n      [[item] b]\n    )\n   )\n )\n [[(first %)][]]\n (rest %)\n)]\n (if (> (count r) (count s))\n   r\n   (if (> (count s) 1)\n     s\n     []\n   )\n )\n)","user":"5c0d0537e4b0bdcf453d173d"},{"problem":53,"code":"#(letfn\n [\n  (take-chunk [f xs]\n   (first(reduce\n    (fn [[g reduced?] f-re]\n      (cond\n       reduced? [g true] ;; works as in (reduced)\n       (or (= (last g) nil)\n              (f f-re (last g))) [(conj g f-re) false]\n        :else [g true]))\n    [[] false]\n    xs)))\n  (split-chunk [f xs]\n   (let [c (take-chunk f xs)]\n     [c (drop (count c)\n              xs)]))\n  (split-between [f xs]\n   (let [[a b] (split-chunk f xs)]\n     (if (empty? b)\n       [a]\n       (identity ;lazy-seq\n        (cons a\n              (split-between\n               f\n               b))))\n     ))\n              ]\n (or(->> % \n       #_[7 6 5 4]\n       #_[1 2 3 4 5 0 1 2 3 4 3 2 1 0 9 8]\n       \n  (split-between >)\n  (remove (comp (partial = 1)\n                count))\n  (group-by count)\n  ((juxt identity\n         (comp \n          (partial reduce max 0)\n          keys)))\n  (apply get)\n  (first)\n      ) []))","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":53,"code":"(fn [xs]\n  (let [inc? #(< (first %) (fnext %))\n        xs (->> (partition 2 1 xs)\n                (partition-by inc?)\n                (filter #(inc? (first %))))]\n    (if (seq xs)\n      (let [len (apply max (map count xs))\n            x (first (filter #(= len (count %)) xs))]\n        (into (vec (first x)) (map fnext (rest x))))\n      [])))","user":"557c6ca6e4b05c286339e0c4"},{"code":"(fn\n  [v]\n  (apply max-key\n         count\n         (reverse\n          (map (fn [v2]\n                 (let [inc-pairs (take-while (fn [[x y]] (< x y))\n                                             (partition 2\n                                                        (interleave v2 (rest v2))))]\n                   (vec\n                    (filter identity\n                            (conj (vec (map first inc-pairs)) (last (last inc-pairs)))))))\n               (partition-all (count v) 1 v)))))","problem":53,"user":"4ebf11bc535dfed6da9c6d9c"},{"code":"(fn [coll]\n  (reduce\n    (fn [x y] (let [y-count (count y)] (if (or (< y-count 2) (> (count x) y-count)) x y)))\n    []\n    (reduce\n      (fn [subseqs item]\n        (let [first-vec (first subseqs)]\n          (if-let [last-item (last first-vec)]\n            (if (= (inc last-item) item)\n              (cons (conj first-vec item) (rest subseqs))\n              (cons [item] subseqs))\n            [[item]])))\n      nil\n      coll)))","problem":53,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":53,"code":"(fn [coll] (first (reduce (fn [v x] \n                            (let [[best curr] v] (if (or (empty? curr) (= 1 (- x (last curr))))\n                                                   (let [v1 (assoc v 1 (conj curr x))\n                                                         lv1 (last v1)\n                                                         clv1 (count lv1)]\n                                                     (if (and (> clv1 (count best)) (>= clv1 2) )\n                                                       (assoc v1 0 lv1) v1)\n                                                       )\n                                                   (assoc v 1 [x])\n                                                   ) ) ) \n                          [[][]] coll)))","user":"5744d088e4b009280f9f2b41"},{"problem":53,"code":"(fn arths\n  ([s] (arths s s []))\n  ([ss s res]\n   (if (empty? s) ((fn longest-seq [s res]\n                     (if (>  (apply max res) 1)\n                           (let [[drops takes] (apply max-key second (reverse (map-indexed vector res)))]\n                                   (take takes (drop drops s)))\n                       []))\n                   ss res)\n       (arths ss (rest s) (conj res (\n                                     (fn cls [s res]\n                                       (cond (empty? s) (inc res)\n                                             (empty? (rest s)) (inc res)\n                                             (= 1 (compare (second s) (first s))) (cls (rest s) (inc res))\n                                             :else (inc res)))\n                                     \n                                     s 0))))))","user":"57af41bce4b0fbc9809a2731"},{"problem":53,"code":"(fn [coll]\n  (let [a  (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter #(< (ffirst %) (second (first %))) a)\n        c (map #(hash-map (keyword (str (count %))) %) b)\n        d (first (vals (first (filter #(= (keys %) (first (reverse (sort-by first (map keys c)))) ) c))))]\n    (concat (first d) (map last (rest d)))\n\t)\n    )","user":"53d70f3be4b0e771c302545f"},{"problem":53,"code":"(fn longest-increasing [coll]\n  (let [inc (reduce (fn [[x & xs :as rv] el]\n                      (if (or (nil? x) (not= (first x) (dec el)))\n                        (conj rv (list el))\n                        (conj xs (conj x el))))\n                    '()\n                    coll)\n        max (reduce #(max %1 (count %2)) 0 inc)]\n    (if (= max 1)\n      []\n      (reverse (first (filter #(= (count %) max) inc))))))","user":"541b1f25e4b01498b1a71a63"},{"code":"(fn [v]\n(let [increasing? (fn [v]\n                    (let [r (rest v)]\n                      (cond (empty? r) true\n                            (< (first v) (first r)) (recur r)\n                            :else false)))]\n  (or (first (filter increasing? (mapcat #(partition % 1 v) (reverse (range 2 (count v))))))\n                     [])))","problem":53,"user":"515f8a0de4b0e2be8aa20bce"},{"problem":53,"code":"#(loop [coll % best_answer [] current_answer []]\n  (if (empty? coll) best_answer\n    (let [\n        next_item (first coll)\n        last_item (last current_answer)\n        current_answer \n            (if\n                (= next_item (inc (if (nil? last_item) 0 last_item)))\n                (conj current_answer next_item)\n                (vector next_item)\n            )\n        current_count (count current_answer)\n    ]\n     (recur \n      (rest coll)\n      (if\n       (and (> current_count 1) (> current_count (count best_answer)))\n       current_answer\n       best_answer\n      )\n      current_answer\n     )\n    )\n  )\n)","user":"560fe558e4b05f002753df63"},{"code":"(fn [coll] \n  (->> (partition 2 1 coll) \n       (partition-by #(< (first %) (second %))) \n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (reduce #(if (< (count %1) (count %2)) %2 %1) [])  \n       flatten \n       distinct))","problem":53,"user":"51cc5f20e4b02254fc794870"},{"problem":53,"code":"(fn [col]\n  (let [seen (atom true)\n        pre-v (atom nil)\n        seq-list (partition-by #(cond\n                           (nil? @pre-v) (do (reset! pre-v %) @seen)\n                           (= 1 (- % @pre-v)) (do (reset! pre-v %) @seen)\n                           :else (do (reset! pre-v %) (reset! seen (not @seen)))) \n                        col)]\n    (reduce (fn [acc e]\n              (cond\n                (= 1 (count e)) acc\n                (> (count e) (count acc)) e\n                :else acc))\n             []\n             seq-list)))","user":"5cf895efe4b0b71b1d808a85"},{"problem":53,"code":"(fn [coll]\n  (let [[start end] (loop [longest [0 0]\n                              current [0 0]\n                              where 1]\n                         (if (< where (count coll))\n                           (if (> (nth coll where) (nth coll (second current)))\n                             (if (> (- where (first current)) (- (second longest) (first longest)))\n                               (recur [(first current) where] [(first current) where] (inc where))\n                               (recur longest [(first current) where] (inc where)))\n                             (if (< (- (second longest) (first longest)) (- (second current) (first current)))\n                               (recur [where where] [where where] (inc where))\n                               (recur longest [where where] (inc where))))\n                           longest))]\n    (if (= 0 (- end start))\n      []\n      (drop start (take (inc end) coll)))))","user":"5fea32f3e4b05ac5b16ea1aa"},{"problem":53,"code":"(fn [sq]\n  (let [counts (group-by count\n                         (reduce (fn [acc item]\n                                   (if (> item (last (last acc)))\n                                     (update-in acc [(- (count acc) 1)] conj item)\n                                     (conj acc [item])))\n                                 [[(first sq)]]\n                                 (rest sq)))\n        longest (first (counts (apply max (keys counts))))]\n    (if (= 1 (count longest))\n      []\n      longest)))","user":"53dd37aee4b0d874e779ae28"},{"problem":53,"code":"(fn longestIncreasingSubSeq\n  [my-seq]\n  (loop [[current & remaining] my-seq\n         result-so-far []\n         result []]\n    (if (seq remaining)\n      (if (seq result-so-far)\n        (if (= (dec current) (last result-so-far))\n          ; found another element for the increasing sequence\n          (recur remaining (conj result-so-far current) result)\n          ; this element isn't part of the increasing sequence\n          (if (= 1 (count result-so-far))\n            ; only 1 in the result so far, just keep the latest element\n            (recur remaining [current] result)\n            ; result-so-far is an increasing subsequence, see if we keep this is longer than result\n            (if (> (count result-so-far) (count result))\n              (recur remaining [current] result-so-far)\n              (recur remaining [current] result))))   \n        ; no result-so-far, add the first element and continue\n        (recur remaining [current] result))\n      (let [latest-result (if (= (dec current) (last result-so-far))\n                          \t(conj result-so-far current)\n            \t\t\t    result-so-far)]                  \t\n      (if (and (>= (count latest-result) 2) (> (count latest-result) (count result)))\n        latest-result\n        result))))) ; reached the end of the collection, return the result","user":"548f19a8e4b0e286459a1231"},{"problem":53,"code":"(fn [xs]\n   (letfn [(detect [curr acc max]\n             (if (seq curr)\n               (let [x (first curr)]\n                 (if (> x (peek acc))\n                   (let [new-acc (conj acc x)]\n                     (recur (rest curr) new-acc max))\n                   (if (> (count acc) (count max))\n                     (recur (rest curr) [x] acc)\n                     (recur (rest curr) [x] max))))\n               (let [max-seq (if (> (count acc) (count max))\n                               acc\n                               max)]\n                 (if (> (count max-seq) 1)\n                   max-seq\n                   []))))]\n     (detect (rest xs) [(first xs)] [])))","user":"51bb08a4e4b0fe3ecfb46446"},{"problem":53,"code":"(fn sequences\n\n    ([nums]\n        (sequences [] [0 1] nums))\n\n    ([best [m n] nums]\n        (cond \n\n            (<= (count nums) 1)\n                []\n                \n            (>= n (count nums))\n\n                (if (and (>= (- n m) 2) (> (- n m) (count best)))\n                    (subvec nums m n)\n                    best)\n                        \n            (> (nth nums n) (nth nums (dec n)))\n\n                (sequences best [m (inc n)] nums)\n                        \n            :else\n\n                (if (and (>= (- n m) 2) (> (- n m) (count best)))\n                    (sequences (subvec nums m n) [n (inc n)] nums)\n                    (sequences best [n (inc n)] nums)))))","user":"54e540c1e4b024c67c0cf7f9"},{"code":"#(:longest\n   (reduce \n     (fn [{:keys [longest cur] :as res} n] \n       (let [{:keys [cur] :as updated} (if (or (not (seq cur))\n                                               (> n (last cur)))\n                                         (update-in res [:cur] conj n)\n                                         (assoc res :cur [n]))\n             longest-cnt (count longest)\n             cur-cnt (count cur)]\n         (if (and (> cur-cnt 1)\n                  (> cur-cnt longest-cnt))\n           (assoc updated :longest cur)\n           updated)))\n     {:longest [] :cur []} %))","problem":53,"user":"4e36038f535deb9a81d77f31"},{"problem":53,"code":"(fn [col]\n           (reduce (fn [result x]\n                     (if (> (count x) (count result))\n                       x\n                       result))\n                   [] (filter #(> (count %) 1)\n                              (reduce (fn [result x]\n                                        (if (empty? result)\n                                          (conj result [x])\n                                          (if (> x (last (last result)))\n                                            (conj (apply vector (butlast result)) (conj (apply vector (last result)) x))\n                                            (conj result [x]))))\n                                      [] col))))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"#(loop [rv () sq %]\n    (let [curr (for [i (range (count sq))\n                     :let [i1 (dec i)]\n                     :while (or (neg? i1) (> (sq i) (sq i1)))]\n                 (sq i))]\n         (if (empty? sq)\n           rv\n           (recur (if (and (>= (count curr) 2)\n                           (> (count curr) (count rv))) \n                    curr rv) \n                  (apply vector (rest sq))))))","problem":53,"user":"50052d38e4b0678c553fc45c"},{"problem":53,"code":"(fn [s]\n  (reduce #(if (> (count %2) (count %)) %2 %) []\n    (remove #(= 1 (count %))\n      (partition-by integer?\n        (reduce #(concat % (if (<= %2 (last %)) [:a %2] [%2])) [(first s)] (rest s))))))","user":"551c66dae4b07993ea3788de"},{"problem":53,"code":"(fn [col]\n  (let [l (apply max-key count (reduce #(case (first %1)\n                                          nil (list (list %2))\n                                          (let [r (rest %1)\n                                                f (first %1)\n                                                x (first f)]\n                                            (if (= (inc x) %2)\n                                              (conj r (conj f %2))\n                                              (conj %1 (list %2))))) '() col))]\n    (if (> (count l) 1)\n      (vec (reverse l))\n      [])))","user":"52f53589e4b05e3f0be25f2c"},{"problem":53,"code":"(fn longest-increasing [nums]\n  (->> nums\n    (reduce (fn [series n]\n              (let [last-series (peek series)\n                    last-num (peek last-series)]\n                (if (or (nil? last-num) (< last-num n))\n                  (conj (pop series) (conj last-series n))\n                  (conj series [n]))))\n            [[]])\n    (filter #(> (count %) 1))\n    (reduce (fn [longest-seq n]\n              (if (< (count longest-seq) (count n))\n                n\n                longest-seq))\n            [])))","user":"576da825e4b0979f8965156c"},{"problem":53,"code":"(fn [a-seq]\n  (letfn [(t-while-inc [s]\n            (lazy-seq\n              (cond\n                (empty? s) ()\n                (empty? (rest s)) s\n                (>= (first s) (second s)) (cons (first s) ())\n                :else (cons (first s) (t-while-inc (rest s))))))]\n    (loop [lseq a-seq acc []]\n      (if (empty? lseq)\n        (if (>= (count acc) 2) acc [])\n        (let [n-seq (t-while-inc lseq)\n              cnt (count n-seq)\n              new-acc (cond\n                        (< (count acc) cnt) (into [] n-seq)\n                        :else acc)]\n          (recur (drop cnt lseq) new-acc))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn [ns]\n  (letfn [(r [[x & m]]\n            (if (and m (< x (first m)))\n              (cons x (r m))\n              (if x [x] [])))\n          (rs [s] (if s (conj (rs (next s)) (r s)) []))]\n    (apply max-key count [] (remove #(< (count %) 2) (rs ns)))))","problem":53,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn foo [s]\n  (loop [max []\n         curr []\n         s s]    \n    (let [f (first s)]\n      (cond (nil? f) (let [w (if (> (count curr) (count max)) curr max)]\n                       (if (> (count w) 1) w []))\n            (> f (get curr (dec (count curr)) 0)) (recur max (conj curr f) (rest s))\n            :else (recur (if (> (count curr) (count max)) curr max)\n                         [f]\n                         (rest s))))))","problem":53,"user":"4facd2fae4b081705acca22f"},{"problem":53,"code":"(fn cc [v] \n  (loop [cur (first v)\n             res (rest v)\n             result [cur]]\n     \n                                       (if (empty? res)\n                                           (if (<  (count result) 2)\n                                                      []\n                                                      result\n                                             )\n                                            (if (< cur (first res))\n                                                   (recur (first res) (rest res) (conj result (first res)))\n                                                   (if (>= (count result) (count (cc res)))\n                                                        (if (<  (count result) 2)\n                            \t\t\t\t\t\t\t\t\t[]\n                     \t\t\t\t\t\t\t\t\t\t\tresult\n                   \t\t\t\t\t\t\t\t\t\t)\n                                                        (cc res)\n                                                   )\n                                             )\n                  \n             )\n   )\n )","user":"563f2eaae4b08d4f616f5ed1"},{"problem":53,"code":"(fn [coll]\n  (first \n   (reduce\n     (fn [[res curr] e] \n       (let [l (last curr)\n             curr (if (or (nil? l) (< l e)) (conj curr e) [e])\n             res (if (and (< 1 (count curr)) (< (count res) (count curr))) curr res)]\n         [res curr]))\n     [[][]] coll)))","user":"4f1ef6a0535d64f60314649b"},{"problem":53,"code":"(fn [coll]\n   (loop [i 1\n          index-start 0\n          index-end 0\n          poten-index-start 0\n          poten-index-end 0]\n     (let [array-count (count coll)]\n       (if (>= i array-count)\n         (if (= index-start index-end)\n           []\n           (drop index-start (drop-last (- array-count index-end 1) coll))) ;were at end of list, return arr\n         (if (> (nth coll i) (nth coll (dec i)))\n           (if (> (- (inc poten-index-end) poten-index-start) (- index-end index-start)) ;if poten is bigger than index, use that\n             (recur (inc i) poten-index-start (inc poten-index-end) poten-index-start (inc poten-index-end)) ;y bigger than x, keep it going\n             (recur (inc i) index-start index-end poten-index-start (inc poten-index-end))) ;y bigger than x, keep it going\n           (if (>= (- index-end index-start) (- poten-index-end poten-index-start)) ;x bigger than y, stop adding to poten\n             (recur (inc i) index-start index-end i i) ;index bigger or eq to poten index\n             (recur (inc i) poten-index-start poten-index-end i i)))))))","user":"58ed2e21e4b056aecfd47d7a"},{"code":"(fn [as]\r\n   (loop [as as curr-s '() longest-s '()]\r\n     (if (nil? (seq as))\r\n       (let [xs (if (> (count curr-s) (count longest-s)) curr-s longest-s)]\r\n         (if (> (count xs) 1)\r\n           (reverse xs)\r\n           []))\r\n       (cond\r\n        (or (nil? (seq curr-s)) (= (inc (first curr-s)) (first as)))\r\n        (recur (rest as) (conj curr-s (first as)) longest-s)\r\n        (> (count curr-s) (count longest-s))\r\n        (recur as '() curr-s)\r\n        :else\r\n        (recur as '() longest-s)))))","problem":53,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":53,"code":"(fn [m]\n   (last (sort-by count (map-indexed\n                          (fn [i _]\n                            (loop [r [(nth m i)]\n                                   [x & xs] (drop (inc i) m)]\n                              (if (and x\n                                       (= (last r)\n                                          (dec x)))\n                                (recur (conj r x) xs)\n                                (into [] (when (< 1 (count r))\n                                          r)))))\n                          m))))","user":"55c652dde4b0e31453f649bd"},{"problem":53,"code":"(fn [lmasuk]\n  (let [bar (fn [ls]\n                (let [va (vec (take 1 ls))\n                      cb (count ls)]\n                (loop [i 1 v va flag false]\n                  (if (or flag (= i cb))\n                    v\n                    (let [sequ? (= (last v) (dec (nth ls i)))] \n                    (recur (inc i)\n                           (if  sequ? (conj v (nth ls i)) v)\n                           (if sequ? false true)))))))]\n  (loop [i 0, v []]\n    (if (= i (count lmasuk))\n      (if (> (count v) 1) v [])\n      (recur (inc i)\n             (let [v1 (bar (drop i lmasuk))]\n               (if (> (count v1) (count v)) v1 v)))))))","user":"564d3169e4b0284900eef67c"},{"code":"(fn[x]\n    (distinct (flatten (reduce #(if (< (count %1) (count %2)) %2 %1) [] \n                               (filter #(= 1 (- (second (first %)) (ffirst %)))\n                                (partition-by #(- (second %) (first %))\n                                  (partition 2 1 x)))))))","problem":53,"user":"4eb0175b535d7eef30807336"},{"code":"(fn longest [s]\n  (if (apply > s) []\n  (let\n      [\n       ss (partition-by #(apply < %) (partition 2 1 s))\n       m (apply max (map count  ss))\n       lng (first (drop-while #(not= m (count %)) ss))]\n    (cons (first (first lng)) (map (fn [[a b]] b) lng))\n    )))","problem":53,"user":"4ddb696b535d02782fcbe9fa"},{"problem":53,"code":"#(let [coll %]\n    (loop [c coll l [] max nil]\n      (if (not (empty? c))\n        (if (= (+ 1 (first c)) (second c))\n          (recur (next c) (conj l (first c)) max)\n          (recur (next c) [] (if (and (< 1 (count (conj l (first c)))) (> (count (conj l (first c))) (count max)))\n                               (conj l (first c))\n                                                             max)))\n        (cond\n          (empty? coll) []\n          max max\n          :else l))))","user":"5cc80598e4b0ccb061962840"},{"problem":53,"code":"(fn [args]\n (loop [rs args\n        temp []\n        acc []]\n  (let [x (first rs)\n        y (second rs)]\n   (if (empty? rs)\n    (if (empty? acc) []\n     (->> acc\n      (sort-by count >)\n      (first)))\n    (if (= y (inc x))\n     (recur (rest rs) (conj temp [x y]) acc)\n     (cond \n      (zero? (count temp)) (recur (rest rs) [] acc)\n      (= 1 (count temp))\n       (recur (rest rs) [] (concat acc temp))\n      :else\n       (recur (rest rs) [] \n        (conj acc (distinct (apply concat temp))))))))))","user":"57eaf869e4b0bfb2137f5b56"},{"code":"#(loop [cur [(first %)], s (conj % 0), x (first s), r []] \n  (if (empty? s) r\n    (recur \n      (if (> x (last cur)) (conj cur x) [x])\n      (next s)\n      (second s)\n      (if (< (max 1 (count r)) (count cur)) cur r)\n     )\n   )\n)","problem":53,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn largest-increasing-subseq [C]\n  (loop [C C [cur largest-so-far] [[] []]]\n    (if (empty? C)\n      largest-so-far\n      (recur (rest C)\n             (let [x (first C)]\n               (if (and (not-empty cur)\n                        (> x (last cur)))\n                 (let [cur (conj cur x)]\n                   [cur (if (> (count cur) (count largest-so-far))\n                          cur\n                          largest-so-far)])\n                 [[x] largest-so-far]))))))","problem":53,"user":"4e31a15c535deb9a81d77f1e"},{"code":"(fn longest-increasing-subseq [coll]\n  (letfn [\n    (longest [colls]\n      (if (empty? colls)\n        []\n        (last (sort-by count (reverse colls)))))\n    \n    (increasing-subseqs [coll]\n      (remove empty?\n              (map (partial remove coll?)\n                   (partition-by \n                     #(and (coll? %) (apply >= %))\n                     (interleave coll \n                                 (partition 2 1 [Integer/MAX_VALUE] coll))))))\n    ]\n    (longest \n      (remove #(< (count %) 2)\n               (increasing-subseqs coll)))))","problem":53,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn [l]  \n  (let [res (first\n  (reduce (fn [a n]\n    (cond \n      (empty? (first a))\n      [[n] [n]]\n      (= (inc (last (second a))) n) \n        (if (> (count (first a)) (count (second a)))\n          [(first  a) (conj (second  a) n)]\n          [(conj (second a) n) (conj (second a) n)]\n          )\n      (> (count (first a)) (count (second a)))\n        [(first a) [n]]\n      :else [(second a) [n]])) \n      [[] []] l)\n  )]\n  (if (= 1 (count res))\n    []\n    res))\n  )","problem":53,"user":"53767991e4b06839e8705e25"},{"problem":53,"code":"(fn [coll] (let [res (first (sort #(> (count %1) (count %2)) (partition-by nil? (concat (mapcat #(if (< %1 %2) [%1] [%1 nil]) coll (rest coll)) [(last coll)]))))]\n              (if (> (count res) 1) res [])))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"code":"(fn [target] (loop [ col (map #(subvec target (first %) (second %) ) (filter #(and (< (first %) (second %)) (< 1 (- (second %) (first %) ))  ) ((fn [col] (for [x (range 0 (inc (count col))) y (range 2 (inc (count col)))  ] [x y] )) target )) )  cur [] ] (if (empty? col) cur  (recur (rest col) (if (and (< (count cur) (count (first col))) (apply < (first col)) ) (first col) cur ) ) )))","problem":53,"user":"50463347e4b011c5dfee771e"},{"problem":53,"code":"(fn [coll]\n  (let [n (count coll)\n        window #(partition 2 1 %)\n        candidates (take (dec n) (iterate next (window coll)))\n        find-seq #(take-while (fn [[f s]] (= 1 (- s f))) %)\n        seqs (map find-seq candidates)\n        pairs-of-longest (last (sort-by count seqs))]\n    (if-not (empty? pairs-of-longest)\n      (conj (mapv first pairs-of-longest) (-> pairs-of-longest last last))\n      [])))","user":"5a9181c5e4b002d099cae6f6"},{"code":"(fn [cs] ;gosh this is horrible - really need to figure out a nice way here...\n  (loop [sub [] longest [] cs cs]\n    (if (= cs '())\n      (let [x (if (> (count sub) (count longest)) sub longest)] (if (= (count x) 1) [] x))\n      (recur (if (or (= sub []) (> (first cs) (last sub)))\n               (conj sub (first cs))\n               [(first cs)])\n             (if (>= (count longest) (count sub)) longest sub)\n             (rest cs)))))","problem":53,"user":"52525a0ee4b0541d1855b8a2"},{"problem":53,"code":"(fn [lst]\n  (reduce\n   (fn [accume n]\n     (if (and\n          (> (count n) 1)\n          (> (count n) (count accume)))\n       n\n       accume))\n   [] ((fn increasing\n         ([lst]\n          (increasing lst [] []))\n         ([vals accume current]\n          (if (empty? vals)\n            (conj accume current)\n            (let [n (first vals)\n                  remainder (rest vals)\n                  next (fn [a c]\n                         (increasing remainder a c))]\n              (if (or\n                   (empty? current)\n                   (> n (last current)))\n                (next accume (conj current n))\n                (next (conj accume current) [n]))))))\n       lst)))","user":"5256a1d4e4b0541d1855ba29"},{"code":"(fn [coll]\n  (let [normalize #(if (and (> (count %2) 1) (> (count %2) (count %1))) [%2 %2] [%1 %2])]\n  (first (reduce (fn [seqs num]\n    (let [[longest-seq curr] seqs]\n      (if (or (empty? curr) (= (dec num) (last curr)))\n        (normalize longest-seq (conj curr num))\n        (normalize longest-seq [num])))) [[][]] coll))))","problem":53,"user":"4f2acb29e4b0d6649770a040"},{"problem":53,"code":"(fn [v]\n  (let [adjacent-pairs (partial partition 2 1)\n        two-consecutive (fn [[a b]] (= b (inc a)))\n        all-consecutive (fn [coll] (every? two-consecutive (adjacent-pairs coll)))\n        longest-subseq (fn [subseqs] \n                         (if (empty? subseqs) \n                           [] \n                           (apply max-key count (reverse subseqs))))]\n    (->> v\n         (adjacent-pairs)\n         (partition-by two-consecutive)\n         (map flatten)\n         (map distinct)\n         (filter all-consecutive)\n         (longest-subseq))))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn max-incr-subseq [col]\n  (loop [c (rest col), cur [(first col)], res []]\n    (if (seq c)\n      (if (= (- (first c) (last cur)) 1)\n        (recur (rest c) (conj cur (first c)) res)\n        (recur (rest c) [(first c)] (conj res cur)))\n      (let [res (first (sort-by (comp - count) (conj res cur)))]\n        (if (= (count res) 1) [] res)))))","problem":53,"user":"4e7f8f85535db966e863cc44"},{"problem":53,"code":"(fn [coll]\n  (vec\n   (first \n   (sort-by count > \n            (map #(map first (partition-by identity %)) \n                 (map flatten (remove #(apply > (first %)) (partition-by #(= (apply - %) -1) (partition-all 2 1 coll))\n                                      )\n                      )\n                 )\n            )\n   )\n  )\n  )","user":"55fe7e15e4b00f4cabc57651"},{"problem":53,"code":"(fn [sequence]\n  (loop [s (next sequence)\n         m (list (first sequence))\n         cur (list (first sequence))]\n    (if s\n      (if (> (first s) (first cur))\n        (let [cur (conj cur (first s))]\n          (if (> (count cur) (count m))\n            (recur (next s) cur cur)\n            (recur (next s) m cur)))\n        (recur (next s) m (list (first s))))\n      (if (> (count m) 1)\n        (reverse m)\n        '()))))","user":"511cca27e4b00c2a1fa7ff7d"},{"problem":53,"code":"(fn [a-seq] \n  (letfn [ (partition-between [f coll]\n  \t\t\t(lazy-seq\n   \t\t\t (if-not (seq coll) \n      \t\t\t'()\n      \t\t\t(let [pairs (map list coll (rest coll))\n            \t\t[h t] (map #(map last %) (split-with #(not (apply f %)) pairs))]\n        \t\t(cons (cons (first coll) h) (partition-between f t))))))]\n    \n    \n  (if-let [rising-seqs (seq (filter #(> (count %) 1) \n                                (partition-between >= a-seq)))] \n    (first (sort-by count > rising-seqs))\n    '())))","user":"580d2788e4b0849f6811b730"},{"problem":53,"code":"(fn [coll]\n  (:maxx\n    (reduce\n     (fn [res x]\n       (let [curr (:curr res (list))\n             maxx (:maxx res [])\n             new-curr (cond\n                       (empty? curr) (list x)\n                       (< (first curr) x) (conj curr x)\n                       :else (list x))\n             new-maxx (let [co (count new-curr)]\n                        (if (and (>= co 2) (> co (count maxx)))\n                          (-> new-curr reverse vec)\n                          maxx))]\n         {:curr new-curr :maxx new-maxx}))\n     {}\n     coll)))","user":"53ee7f2ee4b0d648e757f4cf"},{"problem":53,"code":"(fn [xs]\n  (let [partition-by-comp\n        (fn [f [x & xs]]\n          (let [[_ acc result]\n        (reduce (fn [[prev acc result] curr]\n                  (if (f curr prev)\n                    [curr (conj acc curr) result]\n                    [curr [curr] (conj result acc)]))\n                [x [x] []]\n                xs)]\n    (if (not-every? seq [xs acc]) result (conj result acc)))\n          \n          )]\n  (->> (conj (partition-by-comp #(= %1 (inc %2)) xs) [])\n       (remove #(= 1 (count %)))\n       (sort-by #(- (count %)))\n       (first))))","user":"586bc870e4b01531a375e964"},{"code":"(fn [a]\n  (letfn [(next-inc? [n c] (= (inc' (nth c n)) (nth c (inc' n))))\n          (previous-inc? [n c] (= (dec' (nth c n)) (nth c (dec' n))))\n          (next-previous-incs? [n c] (and (next-inc? n c) (previous-inc? n c)))\n          (npi [n c] [(previous-inc? n c) (next-inc? n c)])\n          (nistart? [c] (if (next-inc? 0 c) [false true] [false false]))\n          (niend? [c] (if (previous-inc? (dec' (count c)) c) [true false] [false false]))\n          (incs? [c]\n            (let [cc (count c)\n                  mid-incs (map #(npi % c) (range 1 (dec' cc)))\n                  all-incs  (concat [(nistart? c)] mid-incs [(niend? c)])\n                  add-to-last (fn [n col] (concat (butlast col) [(concat (last col) [(nth c n)])]))]\n              (loop [res [[]] num 0]\n                (cond\n                 (> num (dec' cc)) (last (sort-by count res))\n                 (= (nth all-incs num) [false false]) (recur res (inc' num))\n                 (or (= (nth all-incs num) [true false]) (= (nth all-incs num) [true true])) (recur (add-to-last num res) (inc' num))\n                 (= (nth all-incs num) [false true]) (recur (concat res [[(nth c num)]]) (inc' num))))))]\n    (incs? a)))","problem":53,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn [s]\n    (reduce (fn \n              ([] [])\n              ([v1] v1)\n              ([v1 v2]\n                 (if (< (count v1) (count v2))\n                   v2\n                   v1)))\n            (filter #(and (vector? %) (< 1 (count %)))\n                    (reductions #(if (sequential? %)\n                                   (cond\n                                    (empty? %) (vector %2)\n                                    (< (last %) %2) (conj % %2)\n                                    :else (vector %2))\n                                   (if (< % %2)\n                                     (vector % %2)\n                                     (vector %2))) s))))","problem":53,"user":"53487737e4b084c2834f4a59"},{"code":"(fn lsubseq [xs]\n  (let [[a b]\n        (reduce (fn [[curlong longest] c]\n                  (cond\n                   (or (nil? curlong)\n                       (empty? curlong))\n                   [[c] longest]\n\n                   (= c (+ 1 (last curlong)))\n                   [(conj curlong c) longest]\n\n                   :else\n                   (if (and (> (count curlong)\n                               (count longest)))\n                     [[c] curlong]\n                     [[c] longest]))) [[] []] xs)]\n    (cond\n     (and (<= (count a) 1)\n          (<= (count b) 1))\n     []\n\n     (> (count a) (count b))\n     a\n\n     :else\n     b)))","problem":53,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":53,"code":"(fn [l] (let [result (loop [todo l longest 0 re [] doing (first todo) h 0 res []]\n             (println todo longest re doing h res)     \n                  (cond\n                    (empty? todo) (if (> longest h) re res)\n                    (> longest h) (recur todo longest re doing longest re)\n                    (empty? re) (recur (rest todo) (inc longest) (conj re doing) (second todo)h res)\n                    (= doing (inc(last re))) (recur (rest todo) (inc longest) (conj re doing) (second todo)h res)\n                    :else (recur (rest todo) 1 [doing] (second todo) h res)\n                    \n                    ))]\n           (if (>(count result)1) result [])\n))","user":"5951190be4b066ee0a44aea4"},{"problem":53,"code":"(fn f [x]\n  (loop [s x, mir [], mirr [], o -1]\n    (if (seq s)\n      (recur (rest s) \n             (if (= o -1)\n               (if (= (+ (first s) 1) (second s))\n                 (conj mir (first s))\n                 (if (= (last mir) (- (first s) 1))\n                   (conj mir (first s))\n                   mir))\n               mir)\n                         \n             (if (= o 1)\n               (if (= (+ (first s) 1) (second s))\n                 (conj mirr (first s))\n                 (if (= (last mirr) (- (first s) 1))\n                   (conj mirr (first s))\n                   mirr))\n               mirr)\n             \n             (if (= (+ (first s) 1) (second s))\n               o\n               (if (< (count mir) (count mirr))\n                 -1\n                 1)))\n      \n      (if (< (count mir) (count mirr))\n        mirr\n        mir))))","user":"593d6793e4b069cdc2982ba6"},{"problem":53,"code":"(fn [x]\n  (loop [current-sol [(first x)]\n         final-sol []\n         x (next x)]\n    (if (empty? x)\n      (if (> (count current-sol) (count final-sol))\n        (if (< (count current-sol) 2)\n          []\n          current-sol)\n        (if (< (count final-sol) 2)\n          []\n          final-sol))\n      (if (< (last current-sol) (first x))\n        (recur (conj current-sol (first x)) final-sol (next x))\n        (if (> (count current-sol) (count final-sol))\n          (recur [(first x)] current-sol (next x))\n          (recur [(first x)] final-sol (next x)))))))","user":"5c83379ce4b0c8042a70ce49"},{"code":"(fn longest-inc-subseq [col]\n  (or (->> col\n       (map-indexed vector)        ; build [[0 x_0] [1 x_1] [2 x_2] ...]\n       (partition-by #(apply - %)) ; when difference to index changes\n       (map #(map second %))       ; get back original sub-seqs\n       (filter #(> (count %) 1))   ; remove the small ones\n       (sort-by (comp - count))    ; bring the biggest to front\n       first)\n      []))","problem":53,"user":"50812debe4b01a93d3f38e4c"},{"problem":53,"code":"(fn [col]\n    (letfn\n      [\n        (sublists [f]\n          (fn [col]\n            (for [i (reverse (range 2 (-> col count inc)))]\n              (f i col)\n            )\n          )\n        )\n      ]\n      (let\n        [\n          ends (sublists take-last)\n          fronts (sublists take)\n          increasing-seqs (filter #(apply < %) (mapcat fronts (ends col)))\n          lengths (group-by count increasing-seqs)\n          max-length (-> lengths keys max)\n          longest (-> lengths sort last second first)\n        ]\n        (or longest [])\n      )\n    )\n  )","user":"59021fede4b0438e51c2d04d"},{"code":"#(first\n  (reduce (fn [[best acc] y] (if (or\n                                (empty? acc)\n                                (= y (inc (last acc))))\n                              [(if (and (> (count acc) 0) (>= (count acc) (count best))) (conj acc y) best) (conj acc y)]\n                              [best [y]]))\n \t\t[[] []]\n        %1))","problem":53,"user":"5216933be4b000d124d989cf"},{"problem":53,"code":"(fn split-into-monotonics [a-seq]\n  (or (first (sort-by count > \n                  (filter #(> (count %) 1)(if (empty? a-seq)\n    []\n    (loop [acc []\n           mon []\n           l (first a-seq)\n           the-seq a-seq]\n      (if (empty? the-seq)\n        (conj acc mon)\n        (let [f (first the-seq)]\n          (if (< l f)\n            (recur acc (conj mon f) f (rest the-seq))\n            (recur (conj acc mon) [f] f (rest the-seq)))))))))) []))","user":"544e9022e4b0e3978000698b"},{"problem":53,"code":"(fn liss [coll]\n  (loop [c coll\n         curr []\n         maxl []]\n    (let [maxl (if (and (> (count curr) (count maxl)) \n                        (>= (count curr) 2)) curr maxl)]\n      (if (empty? c) maxl\n        (if (or (= (dec (first c)) (last curr)))\n          (recur (rest c) (conj curr (first c)) maxl)\n          (recur (rest c) [(first c)] maxl))))))","user":"5475d755e4b0c51c1f4d72a0"},{"problem":53,"code":"(fn [v] (letfn [\n                (nxt-inc?      [s cand] (= cand (inc (last s))))\n                (extd-last-seq [vv n] (conj (vec (drop-last vv)) (conj (last vv) n)))\n                (added-seq     [vv n] (conj vv [n]))\n                (nxt-sub-seqs  [curr-seqs n] (if (nxt-inc? (last curr-seqs) n)\n                                              (extd-last-seq curr-seqs n)\n                                              (added-seq curr-seqs n)))\n                (sub-seqs     ([[f & v]] (sub-seqs [[f]] v))\n                              ([curr-seqs [f & v]] (let [new-sub-seqs (nxt-sub-seqs curr-seqs f)]\n                                                     (if (empty? v) new-sub-seqs (sub-seqs new-sub-seqs v)))))\n                (lngst-size    [vv] (->> vv (map count) (apply max)))\n                (lngst-seqs    [vv] (let [len (lngst-size vv)]\n                                   (some #(when (= len (count %)) %) vv)))]\n          (let [lss (->> v (sub-seqs) (lngst-seqs))]\n            (if (< 1 (count lss)) lss []))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"code":"(fn [x]\n  (let [safe-inc (fn [i] (if (nil? i) nil (inc i)))\n        larger-list (fn [a b] (if (>= (count a) (count b)) a b))]\n    (get \n      (reduce\n        (fn [results, n]\n          (let [new-current (if (= n (safe-inc (last (get results :current))))\n                                (conj (get results :current) n)\n                                [n])\n                larger-list (larger-list (get results :longest) new-current)\n                new-longest (if (> (count larger-list) 1) larger-list [])]\n            {:longest new-longest :current new-current}))\n        {:longest [] :current []}\n        x) :longest)))","problem":53,"user":"53940789e4b0b51d73faaec3"},{"code":"(fn [l]                                                                                                                                                                                    (loop [l l                                                                                                                                                                             \n         m []                                                                                                                                                                                     r nil]                                                                                                                                                                          \n    (if (empty? l)                                                                                                                                                                             (if (and (> (count r) (count m))                                                                                                                                                   \n               (> (count r) 1))                                                                                                                                                          \n        r                                                                                                                                                                                \n        m)                                                                                                                                                                               \n      (let [[hd & tl] l]                                                                                                                                                                 \n        (if (nil? r)                                                                                                                                                                               (recur tl m [hd])                                                                                                                                                              \n          (if (= hd (inc (last r)))                                                                                                                                                                  (recur tl m (conj r hd))                                                                                                                                                     \n            (recur                                                                                                                                                                       \n             tl                                                                                                                                                                          \n             (if (and (> (count r) (count m))                                                                                                                                            \n                      (> (count r) 1))                                                                                                                                                   \n               r                                                                                                                                                                         \n               m)                                                                                                                                                                        \n             [hd])))))))","problem":53,"user":"50435852e4b034ff00315d22"},{"problem":53,"code":"(fn [coll] \n  (let [max-seq (:max-seq (reduce\n                            (fn [state next-elem]\n                              (let [prev-elem (:prev-elem state)\n                                    cur-seq (if (> next-elem prev-elem)\n                                              (conj (:cur-seq state) next-elem)\n                                              [next-elem])\n                                    prev-max-seq (:max-seq state)\n                                    max-seq (if (> (count cur-seq) (count prev-max-seq))\n                                              cur-seq\n                                              prev-max-seq)]\n                                {:prev-elem next-elem :cur-seq cur-seq :max-seq max-seq}))\n                            {:prev-elem (first coll) :cur-seq [(first coll)] :max-seq [(first coll)]}\n                            (rest coll)))]\n    (if (> (count max-seq) 1)\n      max-seq\n      [])))","user":"5675cdf1e4b05957ce8c614d"},{"code":"(fn [l]\n  ((fn f [l c n]\n    (cond\n     (empty? l)\n     (if (> (count c) (count n)) (reverse c) (if (= 1 (count c)) [] (reverse n)))\n     (empty? n)\n     (f (rest l) c [(first l)])\n     true\n    (if (= (first l) (inc (first n)))\n      (f (rest l)\n         c\n         (cons (first l) n))\n      (if (< (count c) (count n))\n        (f (rest l) n [(first l)])\n        (f (rest l) c [(first l)])))))\n         \n           \n  l [] []))","problem":53,"user":"52091d57e4b0e152394d76f0"},{"problem":53,"code":"(fn\n  [xs]\n  (letfn [(f [acc x] (if (< (last (last acc)) x)\n                       (conj (vec (butlast acc)) (conj (last acc) x))\n                       (conj acc [x])))]\n    (->> (reduce f [[(first xs)]] (rest xs))\n         (map #(if (< 1 (count %)) (identity %) []))\n         (sort-by count >)\n         first))\n  )","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":53,"code":"(let [longerEligible #(if (and\n      (> (count %1) (count %2))\n      (> (count %1) 1)) %1 %2)]\n  #(loop [\n    [toCheck & remaining] %\n    currentSub []\n    longest []]\n    (if (nil? toCheck) ; end check\n      (longerEligible currentSub longest)\n      (if (or (empty? currentSub) (> toCheck (last currentSub)))\n        (recur remaining (conj currentSub toCheck) longest)\n        (recur remaining [toCheck] (longerEligible currentSub longest))))))","user":"5ab5f60be4b073f177442643"},{"problem":53,"code":"(fn [xs] \n  (letfn [(consec [acc x]\n            (cond \n              (empty? acc) [[x]]\n              (= (dec x) (-> acc peek peek)) (conj (vec (drop-last acc)) (conj (peek acc) x))\n              :else (conj acc [x])))\n          \n          (longest [acc coll] (if (> (count acc)(count coll)) acc coll))]\n\n    (->> (reduce consec [] xs)\n         (filter #(< 1 (count %)))\n         (reduce longest []))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":53,"code":"(fn lcss [coll]\n  (when-let [coll1 coll]\n    (when-let [res (last (reduce #(if (> (first %2) (first %1)) %2 %1)\n     (map #(vector (count %) %)\n                 (loop [coll (rest coll1)\n           curr [(first coll1)]\n           acc []\n           ]\n      (if (empty? coll)\n        (conj acc curr)\n        (if (< (last curr) (first coll))\n          (recur (rest coll) (conj curr (first coll)) acc)\n          (recur (rest coll) [(first coll)] (conj acc curr))\n        )\n      )\n    )\n    )))]\n      (if (> (count res) 1)\n        res\n        [])\n  )\n  ))","user":"5245e320e4b09dbe66b56177"},{"problem":53,"code":"(fn [coll]\n     (->>\n      (range 2 (inc (count coll)))\n      (mapcat #(partition % 1 coll))\n      (filter #(apply < %))\n      (cons [])\n      (sort-by count >)\n      first))","user":"4f40c46fe4b0e243712b1fbe"},{"problem":53,"code":"(let [increasing-subsequences \n (fn\n  [xs]\n   (loop [xs xs\n         last-element Integer/MIN_VALUE\n         this-subsequence nil\n         subsequences nil]\n    (if (empty? xs)\n      (reverse (cons (reverse this-subsequence) subsequences))\n      (if (> (first xs) last-element)\n        (recur (rest xs) (first xs) (cons (first xs) this-subsequence) subsequences)\n        (recur xs Integer/MIN_VALUE nil (cons (reverse this-subsequence) subsequences))))))\n\np-53\n  (fn\n  [xs]\n  (->> (increasing-subsequences xs) \n       (group-by count )\n       (sort )\n       (last )\n       (second )\n       (first )))\n]\n  (fn [xs]\n   (let [soln (p-53 xs)]\n    (if (> 2 (count soln))\n         []\n         soln))))","user":"5b673832e4b0c6492753e760"},{"code":"(fn [xs]\r\n   (let [get-max-seq #(if (>= (count %1)\r\n                             (count %2))\r\n                        %1\r\n                        %2)]\r\n     \r\n     (loop [max-seq [(first xs)]\r\n            acc-seq [(first xs)]\r\n            xs (rest xs)]\r\n     \r\n       (let [x (first xs)]\r\n         (if (seq xs)\r\n           (if (> x\r\n                   (peek acc-seq))\r\n           \r\n             (recur (get-max-seq max-seq acc-seq) (conj acc-seq x) (rest xs))\r\n             (recur (get-max-seq max-seq acc-seq) [x] (rest xs)))\r\n           (if (>= (count (get-max-seq max-seq acc-seq)) 2)\r\n             (get-max-seq max-seq acc-seq)\r\n             [])\r\n           )))))","problem":53,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":53,"code":"(fn longest-increasing-sub-seq [xs]  \n  (let [{:keys [longest current]}\n        (reduce (fn [{:keys [longest current] :as acc} x]\n                  (if (empty? current)\n                    (assoc acc :current [x])\n                    (if (= x (inc (last current)))\n                      (assoc acc :current (conj current x))\n                      {:current [x]\n                       :longest (if (> (count current) (count longest))\n                                  current longest)})))\n                {:longest [] :current []} xs)\n        longest (if (> (count current) (count longest)) current longest)]\n    (if (= 1 (count longest)) [] longest)\n    ))","user":"50aa777fe4b056ee01935866"},{"problem":53,"code":"(fn ss [oseq]\n  (loop [xs (rest oseq)\n         result []\n         current [(first oseq)]]\n    (let [longest (if (and\n                       (> (count current) (count result))\n                       (> (count current) 1))\n                    current result)]\n      (if (empty? xs) longest\n          (if (> (first xs) (last current))\n            (recur (rest xs) longest (conj current (first xs)))\n            (recur (rest xs) longest [(first xs)])))))\n  )","user":"5eee7311e4b07c55ae4a0510"},{"problem":53,"code":"(fn [xs]\n    (loop [xs xs best [] current []]\n      (if (empty? xs)\n        best\n        (let [x (first xs) new (conj current x)]\n          (if (> x (or (last current) 0))\n            (if (and (> (count new) 1) (> (count new) (count best)))\n              (recur (rest xs) new new)\n              (recur (rest xs) best new))\n            (recur (rest xs) best [x]))))))","user":"5e9154c1e4b0cb0169546354"},{"code":"(fn [value]\r\n(reduce (fn [d k] \r\n  (if (and (< (count d) (count k)) (> (count k) 1))\r\n    k\r\n    d)) \r\n  []\r\n  (reduce (fn [c v] \r\n    (if-let [n (last c)] \r\n      (if (= (- v 1) (last n)) \r\n        (conj (vec (butlast c)) (conj n v))\r\n        (conj c [v]))\r\n      (conj c [v]))) [] value)))","problem":53,"user":"4dbbdf86535d3f4042261ece"},{"problem":53,"code":"(fn\n  [coll]\n  (let [res (partition-by (fn [x]\n                            (= x :gap))\n                          (reduce (fn [accum x]\n                                    (if (= x (inc (last accum)))\n                                      (conj accum x)\n                                      (conj accum :gap x)))\n                                  [(first coll)]\n                                  (rest coll)))]\n    (let [final (last (sort-by count (remove (fn [x]\n                                               (= x '(:gap)))\n                                             res)))]\n      (if (> (count final) 1)\n        final\n        []))))","user":"5e348945e4b0650de70e2b1d"},{"problem":53,"code":"(fn [coll]\n    (loop [longest-increasing-seq []\n           current-increasing-seq [(first coll)]\n           [cur & rest :as coll] (rest coll)]\n      (if (seq coll)\n        (if (> cur (last current-increasing-seq))\n          (recur longest-increasing-seq\n                 (conj current-increasing-seq cur)\n                 rest)\n          (let [longest-increasing-seq\n                (if (> (count current-increasing-seq)\n                       1\n                       (count longest-increasing-seq))\n                  current-increasing-seq\n                  longest-increasing-seq)]\n            (recur longest-increasing-seq\n                   [cur]\n                   rest)))\n        (if (> (count current-increasing-seq)\n               (count longest-increasing-seq)\n               1)\n          current-increasing-seq\n          longest-increasing-seq))))","user":"569f4dabe4b0542e1f8d1491"},{"problem":53,"code":"#(first (reduce\n          (fn [[longest contender] n]\n            (cond\n              (= (dec n) (last contender)) [longest (conj contender n)]\n              (and (< 1 (count contender)) (< (count longest) (count contender))) [contender [n]]\n              :else [longest [n]]))\n          [[] []]\n          (conj % Double/NEGATIVE_INFINITY)))","user":"58821372e4b0f1effa3b764d"},{"code":"(fn [seq] \n    (or (first (filter #(= % (distinct (sort %)))\n                        (mapcat #(partition % 1 seq)\n                                 (reverse (range 2 (inc (count seq))))))) []))","problem":53,"user":"4eaede1f535d7eef30807329"},{"problem":53,"code":"(fn [input]\n    (->>\n     (for [i (range (count input))\n           n (range i (+ 1 i (count (subvec input i))))\n           :let [sub (subvec input i n)]\n           :when (> (count sub) 1)\n           :when (reduce\n                  (fn [last next]\n                    (when (and last (> next last))\n                      next))\n                  sub)]\n       {:ans sub :i i :count (count sub)})\n     (sort-by :count)\n     (partition-by :count)\n     (last)\n     (sort-by :i >)\n     (last)\n     (:ans)\n     (#(if (nil? %) [] %))))","user":"54ac5ad7e4b09f271ff37cd6"},{"problem":53,"code":"#(reduce\n   (fn [a b] (if (> (count b) (count a)) b a))\n   []\n   (apply concat\n     (map\n       (fn [n]\n         (let [tail (drop n %)]\n           (filter\n             (fn [xs] (and\n                        (= xs (sort xs))\n                        (= (count xs) (count (set xs)))\n                        (>= (count xs) 2)))\n             (map\n               (fn [n2]\n                 (take (inc n2) tail))\n               (range (count tail))))))\n       (range (inc (count %))))))","user":"5731283ae4b0cd1946bd0fbe"},{"problem":53,"code":"(fn [values]\n  (let [partitioned (reduce (fn [result value]\n                              (if (seq result)\n                                (let [current (last result)]\n                                  (if (= value (+ 1 (last current)))\n                                    (concat (butlast result) [(conj current value)])\n                                    (concat result [[value]])))\n                                [[value]]))\n                            []\n                            values)\n        result (->> partitioned\n                    (sort-by #(count %))\n                    (filter #(<= 2 (count %)))\n                    last)]\n    (if result result [])))","user":"5463c824e4b01be26fd746c5"},{"problem":53,"code":"(fn longest-subsequence [coll]\n  (let [take-seq (fn [n pred coll]\n                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n        parts (chop coll)\n        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n        (if (< (count longest) 2)\n          []\n        longest)))","user":"5f5f9483e4b02876ed9fcff8"},{"code":"(fn [coll]\n  (let [r (->>\n   (reduce (fn [res elem]\n                  (if-let [prev (last res)];\n                    (if (> elem (last prev))\n                      (conj res (conj prev elem))\n                      (conj res [elem]))\n                    (conj res [elem]))) [] coll)\n    (group-by count)\n    (vals)\n    (last)\n    (first))]\n  (if (= 1 (count r))\n    []\n    r)))","problem":53,"user":"523bde95e4b07becd5be2202"},{"problem":53,"code":"(fn [sequence]\n  (let [result (loop [cursor sequence\n                      longest []\n                      current []]\n                 (if (= 0 (count cursor))\n                   (if (< (count longest) (count current))\n                     current\n                     longest)\n                   (if (empty? current)\n                     (recur (rest cursor) longest [(first cursor)])\n                     (if (< (last current) (first cursor))\n                       (recur\n                        (rest cursor)\n                        longest\n                        (conj current (first cursor)))\n                       (recur\n                        (rest cursor)\n                        (if (< (count longest) (count current))\n                          current\n                          longest)\n                        [(first cursor)])))))]\n    (if (>= (count result) 2)\n      result\n      [])))","user":"5f79bff2e4b02876ed9fd0ca"},{"code":"(fn [q]\n    (apply max-key count []\n           (reverse\n            (filter\n             #(apply < %)\n             (for [x (range (count q))\n                   y (range (+ 2 x) (+ 1 (count q)))]\n               (subvec q x y))))))","problem":53,"user":"4e5411e8535d8a8b8723a279"},{"problem":53,"code":"(fn liss [coll]\n  (letfn [(points [xs] (cons 0 (map inc (keep-indexed #(if (apply >= %2) %1) (partition 2 1 xs)))))\n          (ranges [xs] (partition 2 1 nil (points xs)))\n          (chunks [xs] (map (partial apply subvec (vec xs)) (ranges xs)))]\n    (->> coll\n         chunks\n\t\t (filter #(> (count %) 1))\n     \t (reduce #(if (> (count %2) (count %1)) %2 %1) [] ))))","user":"55645592e4b0c656e3ff1802"},{"problem":53,"code":"(fn [xs]\n  (first\n    (reduce\n      (fn [[most, acc] x]\n        (let [accx (conj acc x)]\n          (cond\n            (not (= (dec x) (peek acc))) [most, [x]]\n            (>= (count acc) (count most)) [accx, accx]\n            :else [most, accx])))\n      [[], [nil]]\n      xs)))","user":"55274467e4b0ffed3738f92b"},{"problem":53,"code":"(fn   [coll]\n  (loop [results [] current (take 1 coll) r (rest coll)]\n    (if-not (empty? current)\n      (if (= (inc (last current)) (first r))\n        (recur results (concat current (take 1 r)) (rest r))\n        (recur (conj results current) (take 1 r) (rest r)))\n      (or (first\n        (filter #(and (=\n                        (count %)\n                        (apply max (map count results)))\n                      (> (count %) 1))\n                results)) '()))))","user":"54e3bd3fe4b024c67c0cf7e0"},{"problem":53,"code":"(fn [col]\n  (loop [c col\n         buf []\n         longests []]\n    (let [x (first c)\n          l (peek buf)\n          bc (count buf)\n          b-added (if (>= bc 2) (conj longests buf) longests)]\n      (if x\n        (if (= (dec x) l)\n          (recur (rest c) (conj buf x) longests)\n          (recur (rest c) [x] b-added))\n        (if (seq b-added)\n          (apply max-key count b-added)\n          b-added)))))","user":"54246fcce4b01498b1a71aed"},{"problem":53,"code":"(fn [coll]\n(last (sort-by count (remove #(= (count %) 1)(reductions\n(fn [l r] \n(if (empty? l)\n[r]\n(if (= r (+ (last l) 1))\n(conj l r)\n[r]))\n) [] coll)))))","user":"565b941ce4b068f2fe63dc07"},{"code":"(fn [coll]\n (letfn [(longest [acc xs]\n           (if (> (count xs) (count acc))\n             xs\n             acc))\n         (conj-if-min [res streak]\n           (if (>= (count streak) 2)\n             (conj res streak)\n             res))]\n   (loop [[curr & rst] coll\n          prev (dec curr)\n          streak []\n          res []]\n     (if (nil? curr)\n\t  (reduce longest [] (conj-if-min res streak))\n  \t  (if (> curr prev)\n    \t(recur rst curr (conj streak curr) res)\n    \t(recur rst curr [curr] (conj-if-min res streak)))))))","problem":53,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":53,"code":"(fn [x]\n  (loop [tot [(first x)] result [] x (drop 1 x)]\n  (if (empty? x)\n    (reduce (fn [t v] (if (> (count t) (count v)) t v )) [] result)\n    (if (= (range (first tot) (inc (last tot))) tot)\n      (if (= (conj tot (first x)) (range (first tot) (inc (first x))))\n         (recur (conj tot (first x)) (conj result (if (> (count (conj tot (first x))) 1) (conj tot (first x)) [] ))  (drop 1 x) )\n         (recur (conj [] (first x) ) (conj result (if (> (count tot) 1) tot []) ) (drop 1 x)))\n      (recur (conj [] (first x)  ) result (drop 1 x))\n      ))))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(fn [xs]\n  (->> xs\n       (map vector (range))\n       (partition-by #(apply - %))\n       reverse\n       (apply max-key count)\n       (map last)\n       (#(if (< (count %) 2) [] %))))","problem":53,"user":"522b922ee4b0d34ee08e71c3"},{"problem":53,"code":"(fn [xs]\n(->> (map #(vector %1 (- %1 %2)) (rest xs) xs)\n       (cons [(first xs) -1])\n       (#(loop [agg () [x & tail] %]\n           (if (empty? tail)\n             agg\n             (let [[ys y-tail] (split-with (comp pos? second) tail)\n                   zs (cons x ys)]\n               (if (> (count zs) (count agg))\n                 (recur zs y-tail)\n                 (recur agg y-tail))))))\n       (map first)\n       (#(if (seq (rest %)) % ()))))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [coll]\n  (when-let [coll (seq coll)]\n    (loop [[_ & args] coll\n           l [(first coll)]\n           best l]\n      (if (empty? args)\n        (if (< (count best) 2) [] (if (> (count l) (count best)) l best))\n        (if (> (first args) (peek l))\n          (recur args (conj l (first args)) best)\n          (if (> (count l) (count best))\n            (recur args [(first args)] l)\n            (recur args [(first args)] best)))))))","problem":53,"user":"4f7e29dde4b06e829148e1ca"},{"code":"#(apply vector (set (apply concat (filter (partial apply <)(first (sort-by count > (partition-by (partial apply <) (partition 2 1 %))))))))","problem":53,"user":"5125834ae4b05d10e3e395fa"},{"code":"(fn [v]\r\n   (vec (last\r\n   (sort-by count\r\n     (filter \r\n       (fn [w] \r\n         (every? true? \r\n           (map-indexed \r\n             (fn [ik iv] \r\n               (if (= ik 0)\r\n                 true\r\n                 (= iv (inc (w (dec ik))))))\r\n             w)))\r\n       (mapcat identity\r\n         (for [ x (range 0 (count v) )]\r\n           (for [ y (range (+ x 2) (inc (count v)) )]\r\n              (subvec v x y)))))))))","problem":53,"user":"5071e520e4b0e3170b5a8683"},{"problem":53,"code":"(fn [s] \n  (loop [sol []\n         temp [(first s)]\n         sq s]\n    (if (= 1 (count sq))\n      sol\n      (if (< (first sq) (second sq))\n        (recur\n          (if \n           (> (+ 1 (count temp)) (count sol))\n           (conj temp (second sq))\n           sol)\n          (conj temp (second sq))\n          (rest sq))\n        (recur\n          sol\n          (vector (second sq))\n          (rest sq))\n      ))))","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":53,"code":"(fn finddsf [longestseq secondlong seq]\n   (if (empty? seq)\n     (if (> (count longestseq) 1)\n       longestseq\n       (if (= (count longestseq) 1)\n         []\n         ))\n     (if (= (count longestseq) 0)\n       (finddsf (conj [] (first seq)) secondlong (rest seq))\n       (if (nil? secondlong)\n         (if (= (last longestseq) (dec (first seq)))\n           (finddsf (conj longestseq (first seq)) secondlong (rest seq))\n           (finddsf longestseq (conj [] (first seq)) (rest seq)))\n         (if (> (count longestseq) (count secondlong))\n           (if (= (last secondlong) (dec (first seq)))\n             (finddsf longestseq (conj secondlong (first seq)) (rest seq))\n             (finddsf longestseq nil (rest seq)))\n           (finddsf secondlong nil seq))\n         ))))  nil nil","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn [coll](let [lt (fn [[x y]] (< x y))]\n  (->>\n   (partition 2 1 coll)\n   (partition-by lt)\n   (map #(filter lt %))\n   (map flatten)\n   (map #(map first (partition-by identity %)))\n   (reverse)\n   (apply max-key count))))","problem":53,"user":"5260341ee4b03e8d9a4a7034"},{"problem":53,"code":"(fn longest-sub-seq [colle]\n  (loop [coll colle \n         current [(first coll)]\n         longest [(first coll)]]\n    (if (empty? coll)\n      (if (= (count longest) 1)\n        []\n        longest)\n      (let [new-current (if (< (last current) (first coll))\n                          (conj current (first coll))\n                          [(first coll)])\n            new-longest (if (> (count new-current) (count longest))\n                          new-current\n                          longest)]\n        (recur (rest coll) new-current new-longest)))))","user":"5486e317e4b0e286459a11c0"},{"problem":53,"code":"(fn [coll]\n  (loop [current [] best [] coll coll]\n    (if (empty? coll)\n      ( #(if (= 1 (count %) ) [] %) (if (< (count best) (count current)) current best))\n      (if (empty? current)\n        (recur [(first coll)] best (rest coll))\n        (if (> (first coll) (last current))\n          (recur (conj current (first coll)) best (rest coll))\n          (recur [(first coll)] (if (< (count best) (count current)) current best) (rest coll))\n          )\n        )\n      )\n    )\n  )","user":"5776558ee4b0979f89651633"},{"problem":53,"code":"(fn bob [v]\n  (let [group (fn [v] (reductions (fn [l r] (if (and (first l) (< (first l) r)) (conj l r) (list r))) nil v))\n        sorted-out (reverse (sort-by count (group v)))\n        rv (apply max-key count sorted-out)]\n    (if (<= (count rv) 1)\n      []\n      (reverse rv))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [x] (let [r (reduce (partial max-key count) (reductions #(if (= (last %1) (dec %2)) (conj %1 %2) [%2]) [] x))]\r\n  (if (> (count r) 1) r [])))","problem":53,"user":"4eebc5da535d93acb0a668aa"},{"code":"#(let [r (reduce \r\n            (fn [v i] (if (> (count i) (count v)) i v))\r\n            (reductions (fn [v e] \r\n                          (if (empty? v)\r\n                            (conj v e) \r\n                            (if (= e (inc (last v))) \r\n                              (conj v e) \r\n                              [e]))) [] %))]\r\n    (if (< (count r) 2) [] r))","problem":53,"user":"4f29cdc8e4b0d6649770a033"},{"problem":53,"code":"(fn [a]\n     (let [f #(letfn [(r [xs ys]\n                         (if (empty? xs)\n                           ys\n                           (r (rest xs) (conj ys (concat [(first xs)] (rest xs))))))]\n                 (r %1 []))\n           g (fn [a] (filter #(>= (count %1) 2) a))\n           h #(letfn [(r [x xs ys]\n                         (if (or (empty? xs) (not= (inc x) (first xs)))\n                           ys\n                           (r (first xs) (rest xs) (conj ys (first xs)))))]\n                 (concat [%1] (r %1 %2 [])))\n           i (fn [a] (map (fn [a] (h (first a) (rest a))) a))\n           j (fn [a] (let [b (if (empty? a)\n                               0\n                               (apply max (map count a)))]\n                       (filter #(== (count %1) b) a)))\n           k (fn [a] (if (empty? a)\n                       []\n                       (vec (first a))))]\n       ((comp k j g i f) a)))","user":"52281e1ee4b0186687e23a69"},{"problem":53,"code":"(fn [l]\n  (loop [l l candidate [] best []]\n    (if (empty? l)\n      best\n      (let [\n        n (first l)\n        candidate (if\n          (or (empty? candidate) (< (peek candidate) (first l)))\n          (conj candidate n)\n          [n])]\n        (recur\n          (rest l)\n          candidate\n          (if\n            (and (> (count candidate) 1) (> (count candidate) (count best)))\n            candidate\n            best))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":53,"code":"(fn longest-increasing-sub-sequence [coll]\n  ((fn go [resl res accl acc xs]\n     (if-let [x (first xs)]\n       (if (and (seq acc) (>= (peek acc) x))\n         (if (> accl resl)\n           (go accl acc 1 [x] (next xs))\n           (go resl res 1 [x] (next xs))\n           )\n         (go resl res (inc accl) (conj acc x) (next xs))\n         )\n       (if (and (< accl 2) (< resl 2)) [] (if (> accl resl) acc res))\n       )) 0 [] 0 [] coll)\n  )","user":"5488872ee4b0e286459a11d3"},{"code":"#(reduce (fn [col1 col2]\n            (let [count1 (count col1)\n                  count2 (count col2)]\n              (cond (and (< count1 2) (< count2 2)) []\n                    (< count1 count2) col2\n                    :else col1)))\n          (reductions (fn [col el]\n                        (if (= (inc (last col)) el)\n                          (conj col el)\n                          [el]))\n                      [(first %)]\n                      (rest %)))","problem":53,"user":"51105c7fe4b04c71fce993ef"},{"problem":53,"code":"(fn [s] \n (loop [ current [(first s)]\n          coll (rest s)\n          longest [] ]\n    (if (empty? coll)\n      (if (< 1 (count longest)) longest [])\n      (let [ x (first coll)\n             c (if (= x (inc (last current))) (conj current x) [x])\n             l (if (>= (count c) (count longest)) c longest)]\n        (recur c (rest coll) l)))))","user":"560d491ae4b05f002753df3b"},{"code":"(fn f [s]\n  (let [result\n        (first\n          (sort-by #(unchecked-negate (count %1))\n            (filter #(<= 2 (count %1))\n              (for [i (range (count s))]\n                (let [pred (fn [i e] (> e (nth s i)))]\n                  (let [take-incr (fn f* [i pred col]\n                                    (lazy-seq\n                                      (when-let [col* (seq col)]\n                                        (when (pred i (first col*))\n                                          (cons (first col*) (f* (inc i) pred (rest col*)))))))\n                        col (drop i s)]\n                    (cons (first col) (take-incr i pred (drop 1 col)))))))))]\n    (if (empty? result) [] result)))","problem":53,"user":"51d662fce4b0154f82ab92ef"},{"problem":53,"code":"(fn __ [xs]\n  (if-let\n    [sub-seqs\n     (->> (map\n            #(conj (vec (map first %)) (last (last %)))\n            (partition-by (partial apply <) (partition 2 1 xs)))\n          (filter (partial apply <))\n          reverse\n          seq)]\n    (apply max-key count sub-seqs)\n    []))","user":"56ac81ace4b03c432f187347"},{"problem":53,"code":"(fn [col]\n    (->>\n      (rest col)\n      (reductions (fn [acc val]\n                (let [prev (last acc)]\n                  (if (>= prev val)\n                    [val]\n                    (conj acc val)\n                    )\n                  )\n                )\n\n              [(first col)]\n              )\n      (filter #(> (count %) 1))\n      reverse ;\n      (#(conj % []))\n      (apply max-key count)\n      )\n    )","user":"5f0e8312e4b0f30dddfb5d5b"},{"code":"(fn [coll]\n    (let [divide-with ; split coll between a and b when (f a b)\n          (fn [f coll] \n            (reduce (fn [acc x]\n                      (if (or (empty? (last acc)) (f (last (last acc)) x))\n                        (conj acc [x])\n                        (conj (pop acc) (conj (last acc) x))))\n                    [] coll))\n          longest ; yield the longest coll in colls\n          (fn [colls]\n            (reduce (fn [ans coll] (if (> (count coll) (count ans)) coll ans)) colls))\n          longest-seq (longest (divide-with >= coll))]\n      (if (> (count longest-seq) 1) longest-seq [])))","problem":53,"user":"4e9e0640535dbda64a6f6b91"},{"code":"(fn [c]\n\t(->>\t(partition 2 1 c)\n\t\t\t(partition-by #(- (second %) (first %)))\n\t\t\t(filter #(= 1 (- (second (first %)) (ffirst %))))\n\t\t\t(reduce #(if (< (count %1) (count %2)) %2 %1) [])\n\t\t\tflatten\n\t\t\tdistinct))","problem":53,"user":"5230793be4b0035e815da383"},{"problem":53,"code":"(fn longest-sub-seq [coll]\n  (let [is-increasing (fn [[x y]] (= (inc x) y))\n        sub-seqs-from (fn sub-seqs-from [xs]\n                        (if (empty? xs)\n                          nil\n                          (let [[sub rst] (split-with is-increasing xs)]\n                            (cons sub (sub-seqs-from (drop-while (complement is-increasing) rst))))))\n        pairs (map vector coll (rest coll))\n        sub-seq-pairs (sub-seqs-from pairs)\n        longest-pairs (apply (partial max-key count) sub-seq-pairs)\n        longest (if (empty? longest-pairs) '() (cons (ffirst longest-pairs) (map second longest-pairs)))]\n    longest))","user":"5344fe13e4b084c2834f4a32"},{"problem":53,"code":"(fn [q]\n  (let [q' (map (fn [q1 q2] (if (> q1 q2) 1 0)) (rest q) q)]\n    (let [[vl offs]\n          (reduce\n           (fn [[v1 i1] [v2 i2]] (if (>= v1 v2) [v1 i1] [v2 i2]))\n           [-1 -1]\n           (filter (fn [[v i]] (> v 0))\n                   (map (fn [x1 y1] \n                          [x1 y1])\n                        ((fn [xs a b]\n                           (cond (empty? xs) (cons b a)\n                                 (zero? (first xs)) (recur (rest xs) (cons b a) 0)\n                                 :else (recur (rest xs) (cons b a) (+ b (first xs)))))\n                         (reverse q') '() 0)\n                        (range))))]\n      (take (+ vl 1) (drop offs q)))))","user":"52d584bbe4b09f7907dd1340"},{"code":"(fn longest-increasing-sub-seq [l]\n  (let [r (reductions #(if %2 (inc %1) 0) 0 (map > (rest l) l))\n        max- (apply max r)\n        i (.indexOf r max-)]\n    (if (pos? max-)\n      (map l (range (- i max-) (+ i 1)))\n      [])))","problem":53,"user":"5163b06be4b055933a9ca030"},{"problem":53,"code":"(fn longest-inc-subseq\n  [c]\n  (->> (partition 2 1 c)\n       (map (fn [[f r]] (if (= (inc f) r)\n                          [f r]\n                          nil)))\n       (partition-by nil?)\n       (map flatten)\n       (remove #(some nil? %))\n       (sort-by count >)\n       (first)\n       (distinct)))","user":"5b759ca8e4b047b03b2036d0"},{"problem":53,"code":"(fn [z]\n  (or\n   (first (sort-by count >\n                   (for [x (range (count z))\n                         y (range (+ x 2) (-> z count inc))\n                         :let [s (subvec z x y)]\n                         :when (apply < s)]\n                     s)))\n   []))","user":"54d893a4e4b0a52adc2e2039"},{"code":"#(apply max-key %\n   (for [x (%2 (% %3) 0 -1)\n         y (%2 (- x 1))\n         :let [z (subvec %3 y x)]]\n     (if (apply < z) z [])))\ncount range","problem":53,"user":"51ad244fe4b09397d510977f"},{"problem":53,"code":"(fn [coll]\n  (let [sequences (reduce (fn [res cur]\n                            (if (< (last (last res)) cur)\n                              (concat (butlast res) (list (concat (last res) (list cur))))\n                              (concat res (list (list cur)))))\n                          (list (list (first coll))) (next coll))\n        longest-seq (reduce (fn [res cur]\n                              (if (< (count res) (count cur)) cur res))\n                            () sequences)]\n    (if (>= (count longest-seq) 2)\n      longest-seq\n      ())))","user":"562cb7cfe4b0a45d2ff83009"},{"code":"(fn [xs] (let [min-size (fn [xs] (if (>= (count xs) 2) xs []) )\n               sort-count (fn [xs] \n                   (map second (sort-by first (map-indexed #(list (- (* (count %2) 10) %1) %2) xs) )))\n               increasing (fn [xs] \n                   (let [ aux (fn aux[prev, xs, acc] \n                                (if (empty? xs)\n                                  acc\n                                  (if (< prev (first xs))\n                                    (aux (first xs) (rest xs) (conj acc (first xs)) )\n                                    acc ))) ] \n                     (sort (aux (dec (first xs)) xs, '()))  ))\n      ]\n(min-size (last  (sort-count  ( map-indexed (fn [i,x] (increasing (drop i xs)) ) xs) )))\n           ))","problem":53,"user":"5271b940e4b03e8d9a4a73fb"},{"problem":53,"code":"(fn cs [xs]\n  (letfn [(-dedupe [x]\n                   (reverse (reduce\n                              (fn [a y]\n                                (if (= (first a) y)\n                                  a\n                                  (conj a y)))\n                              () x)))  \n          \n          (consecutive [p] (= (inc (first p)) (second p)))\n          (filtrd [ys](filter \n                        (partial every? consecutive) \n                        (partition-by consecutive \n                                      (partition 2 1 ys ))))]\n    (if (empty? (filtrd xs))\n      ()\n      (-dedupe \n         (flatten \n           (apply max-key count (filtrd xs) \n                  ))))\n    \n    ))","user":"56b280e3e4b0982f16b37e06"},{"problem":53,"code":";; inner-most reduce partitions nubmers into consecutive groups, each group is decending order by using (cons)\n;; after that it's trivial, filtering out length-1, finding longest, then reverse.\n;; note that max-key requires empty vec because filtering could return empty seq.\n(fn [col]\n  (reverse\n   (apply max-key count []\n    (filter #(> (count %1) 1)\n            (reduce (fn [acc x]\n                      (if (empty? acc)\n                        [(list x)]\n                        (let [[cur & rest] acc]\n                          (if (> x (first cur))\n                            (cons (cons x cur) rest)\n                            (cons (list x) acc))))) [] col)))))","user":"55d5ee3fe4b0e31453f64a92"},{"problem":53,"code":"(fn longest-increasing-subsequence\n  ([seq] (longest-increasing-subsequence (rest seq) (first seq) [(first seq)] []))\n  ([seq last tmp longest]\n   (if (empty? seq)\n     (let [to-return (if (> (count tmp) (count longest)) tmp longest)]\n       (if (< (count to-return) 2) [] to-return)\n       )\n     (if (= (first seq) (inc last))\n       (recur (rest seq) (first seq) (conj tmp (first seq)) longest)\n       (if (> (count tmp) (count longest))\n         (recur (rest seq) (first seq) [(first seq)] tmp)\n         (recur (rest seq) (first seq) [(first seq)] longest)\n         )\n       )\n     )\n    ))","user":"5aada061e4b073f17744257a"},{"problem":53,"code":"(fn longest-increasing-subseq [numbers]\n  (let [[first-seq second-seq] (reduce\n                                (fn [[longest-seq current-seq] current-number]\n                                  (let [previous-number (peek current-seq)]\n                                    (if (or (nil? previous-number)\n                                            (< previous-number current-number))\n                                      ;; keep building current-seq\n\n                                      [longest-seq (conj current-seq current-number)]\n                                      (if (> (count current-seq) (count longest-seq))\n                                        [current-seq [current-number]]\n                                        ;; notice that if both seqs have equal size than the first one t/is returned\n                                        [longest-seq [current-number]]))))\n                                [[] []]\n                                numbers)\n        longest-seq (if (< (count first-seq) (count second-seq))\n          second-seq\n          first-seq)]\n    (if (< 1 (count longest-seq))\n      longest-seq\n      [])))","user":"551bdefde4b07993ea3788d7"},{"problem":53,"code":"(fn [sq] ((fn maxSeq\n    [sqsq]\n    ((fn [y] (if (> (count y) 1) y [])) (first (filter (fn [x] (= (count x) (apply max (map count sqsq)))) sqsq))))\n      (reductions (fn validSeq\n                    [cnumSeq nnum]\n                    (if (< (last cnumSeq) nnum)\n                      (conj cnumSeq nnum)\n                      [nnum])) [(first sq)] (rest sq))))","user":"59692530e4b069c0a1a197e4"},{"problem":53,"code":"(fn longest> [l]\n  (let [f (fn myfn [x y longseq curr rst]\n            (let [curr-is-longest (> (count curr) (max 1 (count longseq)))]\n              (cond\n               (empty? rst) (if curr-is-longest curr longseq)\n               (> y x) (myfn y (second rst) longseq (cons y curr) (rest rst))\n               :else (myfn y (second rst) (if curr-is-longest curr longseq) [y] (rest rst)))))]\n    (reverse (f (first l) (second l) [] (take 1 l) (drop 1 l)))))","user":"54857e3be4b0e286459a11ad"},{"problem":53,"code":"(fn [xs]\n  (->> (reductions (fn [[_ a] v] (if (> v a) [1 v] [0 v])) [1 (first xs)] (rest xs))\n       (reduce (fn [a [i v]]\n                       (if (= i 0)\n                         (conj (vec a) [v])\n                         (conj (vec (butlast (vec a))) (conj (vec (last a)) v))))\n               [])\n       (filter #(> (count %) 1))\n       (reduce (fn [a v] (if (> (count v) (count a)) v a)) [])))","user":"5e3e23d9e4b01d43a70e8e20"},{"code":"(fn t[coll]\n     (let [items\n\t     (reductions\n\t      (fn [c x]\n\t\t  (if (< (last c) x)\n\t\t      (conj c x)\n\t\t      [x])) [(first coll)] (rest coll))]\n\t(reduce (fn [a b]\n\t\t  (if (and (> (count b) 1) (> (count b) (count a)))\n\t\t      b a)) []\n\t\t  items ) ))","problem":53,"user":"4e53bf5e535d8a8b8723a275"},{"code":"(fn [xs]\n  (loop [longest []\n         current []\n         coll xs]\n    (if (seq coll)\n      (let [head (first coll)\n            last-current (last current)]\n        (if (or (nil? last-current) (> head last-current))\n          (recur longest (conj current head) (rest coll))\n          (if (> (count current) (count longest))\n                (recur current [head] (rest coll))\n                (recur longest [head] (rest coll)))))\n      (if (>= (count longest) (count current))\n        (if (> (count longest) 1) longest [])\n        (if (> (count current) 1) current [])))))","problem":53,"user":"4f6845d2e4b07046d9f4ef74"},{"code":"(fn[xs]\n   (last \n    (sort-by count \n      (filter #(or (> (count %) 1) (zero? (count %)))\n        (reduce (fn [res x] \n          (if (or (empty? (last res)) (not= (inc (last (last res))) x))\n            (concat res [[x]])\n            (concat (butlast res) [(conj (last res) x)])))\n        [[]] xs)))))","problem":53,"user":"506406c8e4b075d771da6f9f"},{"problem":53,"code":"(fn liss [s]\n  (let [mn (. Integer MIN_VALUE)\n        liss-help (fn [best current prev s]\n           (cond (empty? s) \n               (if (> (count best) 1) best [])\n             (>= prev (first s)) \n               (recur best (list (first s)) (first s) (rest s))\n             (> (inc (count current)) (count best))\n               (recur (cons (first s) current) (cons (first s) current) (first s) (rest s))\n             :else\n               (recur best (cons (first s) current) (first s) (rest s))))]\n    (reverse (liss-help '() '() mn s))))","user":"53ff8c31e4b0de5c41848603"},{"code":"(fn [c]\n  (let [\n    sublists (fn [col] (mapcat\n      (fn [sub] (map (fn [n] (take n sub)) (range 0 (inc (count sub)))))\n      (partition-all (count col) 1 col)))\n    is-inc-list? (fn [r] (or (zero? (count r)) (= r (range (first r) (+ (first r) (count r))))))]\n    (last (sort-by count (filter #(and (not= (count %) 1) (is-inc-list? %)) (sublists c))))))","problem":53,"user":"51c73959e4b07ef393169e3e"},{"code":"(fn [s]\n (or\n  (first\n   (filter #(every? (fn [[a b]] (< a b)) (partition 2 1 %))\n           (map (fn [[a b]] (subvec s a b))\n                (sort-by #(apply - %)\n                         (let [c (inc (count s))]\n                              (for [i (range c)\n                                   j (range c)\n                                   :when (> j (inc i))]\n                                   [i j]))))))\n  []))","problem":53,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn [curr best [x & xs]]                                                                                                                                     \n   (letfn [(longest [x y] (if (< (count x) (count y)) y x))]                                                                                                  \n     (let [curr (conj curr x)]                                                                                                                                \n       (if (seq xs)                                                                                                                                           \n         (if (< x (first xs))                                                                                                                                 \n           (recur curr best xs)                                                                                                                               \n           (recur [] (longest best curr) xs))                                                                                                                 \n         (let [result (longest best curr)]                                                                                                                    \n           (if (> (count result) 1) result []))))))\n[] []","problem":53,"user":"510c1dd5e4b078ea71921113"},{"problem":53,"code":"#(loop [s %\n        i []\n        l []]\n  (if (empty? s)\n    l\n    (recur (rest s)\n  \t\t   (if (> (first s) (if (empty? i) 0 (last i)))\n             (conj i (first s))\n             [(first s)])\n           (if (and (> (first s) (if (empty? i) 0 (last i)))\n                    (= (if (empty? i) 0 (count i)) (if (empty? l) 1 (count l))))\n             (conj i (first s))\n             l))))","user":"57acbe5fe4b0b8559636fc8e"},{"problem":53,"code":"(fn [c]\n  (loop [longest [] current [(first c)] coll (rest c)]\n    (if (empty? coll)\n      longest\n      (let [a\n            (if (> (first coll) (last current))\n              (conj current (first coll))\n              [(first coll)])]\n        (if (and (> (count a) (count longest)) (> (count a) 1))\n          (recur a a (rest coll))\n          (recur longest a (rest coll))))\n      ))\n  )","user":"565b2fa5e4b068f2fe63dbfe"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n    (partition 2 1)\n    (cons [2 1])\n    (partition-by (fn [[p n]] (< p n)))\n    rest\n    (take-nth 2)\n    (reduce (fn ([] []) ([z x] (if (> (count x) (count z)) x z))))\n    (map vec)\n    (reduce (fn ([] []) ([z x] (conj z (x 1)))))))","user":"50479524e4b0371827a27bc4"},{"problem":53,"code":"(fn it\n  ([coll] (it [] coll))\n  ([longest coll]\n   (if (empty? coll) longest\n       (let [longer #(if (>= (count %1) (count %2)) %1 %2)\n             zipped (mapv vector coll (cons (dec (first coll)) coll))\n             [increasing remainder] (map (partial map first) (split-with #(apply > %) zipped))]\n         (cond (empty? increasing)\n               (recur longest (vec (rest remainder)))\n               (= 1 (count increasing))\n               (recur longest (vec remainder))\n               :else\n               (recur (longer longest increasing) (vec remainder)))))))","user":"524740e7e4b05ef8e38e635d"},{"problem":53,"code":"(fn [a]\n  (->> (reductions #(if (> %2 (last %1)) (conj %1 %2) (vector %2)) [Long/MAX_VALUE] a)\n       (cons [])\n       (reverse)\n       (sort-by count)\n       (filter (comp (partial not= 1) count))\n       (last)))","user":"5579638fe4b05c286339e094"},{"problem":53,"code":"#((reduce (fn [[a b] e]\n              (let [c (conj b e)\n                    f count\n                    n (f c)]\n                (if (apply < c)\n                  (if (and (> n 1) (> n (f a))) [c c] [a c]) [a [e]])))\n            [[] []] %) 0)","user":"505106fee4b05ab4c7e07d38"},{"code":"#(if (empty? %1)\n    []\n    (let [lseq (atom []) cseq (atom [])]\n      (loop [s %1]\n        (let [x (first s)]\n          (if (empty? @cseq) \n            (reset! cseq [x])\n            (if (= (inc (last @cseq)) x)\n              (swap! cseq conj x)\n              (do \n                (when (> (count @cseq) (count @lseq))\n                  (reset! lseq @cseq)\n                  (reset! cseq [x])))))\n          (when (next s)\n            (recur (next s)))))\n      (when (> (count @cseq) (count @lseq))\n        (reset! lseq @cseq))\n      (if (= (count @lseq) 1)\n        []\n        @lseq)))","problem":53,"user":"5244a10de4b0d8acf9ed6ab3"},{"problem":53,"code":"(fn [xs]\n  (->> xs\n       ; split into successive pairs:\n       (partition 2 1)\n       ; split pairs into sub-sequences per ordering:\n       (partition-by (fn [[x y]] (< x y)))\n       ; re-join the pair sub-sequences:\n       (map #(concat (map first (drop-last %)) (last %)))\n       ; select only the increasing sub-sequences:\n       ; (note: only need to look at first two elements)\n       (filter (fn [[a b]] (< a b)))\n       ; select the longest sub-sequence that occurs first:\n       (reduce #(if (< (count %1) (count %2)) %2 %1) [])))","user":"5d27da09e4b092dab7f59c75"},{"problem":53,"code":"(fn [s]\n   (let [lis (fn [s prev old-lis new-lis]\n               (let [old-size (count old-lis) \n                     new-size (count new-lis)]\n                 (if (empty? s) (if (and (> new-size 1) (> new-size old-size)) new-lis old-lis)\n                   (if (or (nil? prev) (> (first s) prev)) (recur (rest s) (first s) old-lis (conj new-lis (first s)))\n                     (recur (rest s) (first s) (if (and (> new-size 1) (> new-size old-size)) new-lis old-lis) [(first s)])))))]\n     (lis s nil [] [])))","user":"57780e4fe4b0979f89651657"},{"code":"(fn [coll]\n\t(let [increasing? (fn [xs] (apply < xs))\n\tn (count coll)\n\tsub-seqs (mapcat #(partition % 1 coll) (range 2 (inc n)))]\n\t\t(->> sub-seqs\n             (filter increasing?)\n             (cons [])\n             (sort-by count >)\n             first)))","problem":53,"user":"52a5f1e6e4b0c58976d9abf4"},{"problem":53,"code":"(fn\n  [seq]\n  (let [a \n        (reductions\n         (fn [xs y]\n           (if (> y (last xs)) (conj xs y) [y]))\n         [(first seq)]\n         (rest seq))\n        b (reduce #(if (< (count %1) (count %2)) %2 %1) [] a)]\n    (if (> (count b) 1) b [])))","user":"5d96edeae4b0d3f9b434ad35"},{"code":"(fn [s]\n  (:max (reduce\n    #(do (println %1) (let\n      [current\n        (if\n          (and\n            (not= nil (last (:current %1)))\n            (=\n            (inc (last (:current %1)))\n            %2))\n          (conj (:current %1) %2)\n          [%2])]\n\n      {:current current\n       :max (if\n              (and\n                (>= (count current) 2)\n                (>\n                   (count current)\n                   (count (:max %1))))\n              current\n              (:max %1))}))\n        {:current []  :max []}\ts)))","problem":53,"user":"4f3b5219e4b0e243712b1f2a"},{"code":"(partial (fn [c l r]\n                    (if (empty? r)\n                      (if (> (count l) 1) l [])\n                        (let [n (first r)\n                              s (when-not (empty? c) (> n (last c)))\n                              nc (if s (concat c [n]) [n])\n                              nl (max-key count nc l)]\n\n                          (recur nc nl (rest r))))) [] [])","problem":53,"user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn [xs]\n  (let [maxrun\n    (reduce #(if (> (count %2) (count %1)) %2 %1)\n      (reductions #(if (or (empty? %1) (> %2 (last %1)))\n                      (conj %1 %2) [%2]) [] xs))]\n    (if (>= (count maxrun) 2) maxrun [])))","problem":53,"user":"4f94d3a5e4b0dcca54ed6cc5"},{"problem":53,"code":"(fn [x]\n  (loop [in  x\n         out []\n         cur []]\n    (let [out' (if (> (count cur)\n                      (max (count out) 1))\n                 cur\n                 out)]\n    (cond\n      (empty? in) out'\n      (empty? cur)\n        (recur (next in) out [(first in)])\n      (> (first in) (last cur))\n        (recur (next in) out (conj cur (first in)))\n      :else\n        (recur in out' [])))))","user":"58247423e4b051871117bec5"},{"problem":53,"code":"(fn sub-seq [in]\n  {:pre [(vector? in)]}\n  (letfn [(compare [prev next]\n            (if (and (> (count next) 1) (> (count next) (count prev)))\n              next\n              prev))]\n    (loop [ret [] sub [(first in)] r (rest in)]\n      (if (seq sub)\n        (let [a (last sub)\n              b (first r)]\n          (if (= (inc a) b)\n            (recur ret (conj sub b) (rest r))\n            (recur (compare ret sub) (when b [b]) (rest r))))\n        ret))))","user":"5be33a16e4b0ed4b8aab4cd6"},{"problem":53,"code":"(fn longest-sub-seq\n           ([s acc]\n            (let [longest-sub-seq-helper (fn longest-sub-seq-helper-01\n                                           [s1 acc1]\n                                           (cond\n                                             (empty? s1) acc1\n                                             (= (dec (first s1)) (last acc1)) (longest-sub-seq-helper-01 (rest s1) (concat acc1 [(first s1)]))\n                                             :defult acc1))\n                  sub-seq (longest-sub-seq-helper (rest s) [(first s)])\n                  len-acc (.size acc)\n                  len-sub-seq (.size sub-seq)]\n              (cond\n                (empty? s) (cond\n                           (and (< len-acc len-sub-seq) (> len-sub-seq 1)) sub-seq\n                           (and (> len-acc len-sub-seq) (> len-acc 1)) acc\n                           (and (= len-acc len-sub-seq) (<= len-acc 1) (<= len-sub-seq 1)) []\n                           :default acc\n                           )\n                (< len-acc len-sub-seq) (longest-sub-seq (rest s) sub-seq)\n                (> len-acc len-sub-seq) (longest-sub-seq (rest s) acc)\n                :defualt (longest-sub-seq (rest s) acc)\n                )\n              )\n             )\n           ([s]\n            (longest-sub-seq s []))\n           )","user":"582cbf48e4b051871117bfa6"},{"problem":53,"code":";;#(let [seq-len (fn [in-seq]\n;;                 (if (zero? (count in-seq))\n;;                    0\n;;                    (let [f (first in-seq)]\n;;                      (loop [r (range (inc  f) (+ f (count in-seq) 2)),\n;;                             s (rest in-seq), n 0]\n;;                        (if (not= (first r) (first s))\n;;                          n\n;;                          (recur (rest r) (rest s) (inc n)))))))]\n;;\n;;    (loop [longest-len 0,\n;;            longest-seq [],\n;;            cur-seq %]\n;;       (let [cur-len (seq-len cur-seq)]\n;;         (cond (= (count cur-seq) 0)  longest-seq\n;;               (<= cur-len longest-len)  (recur longest-len longest-seq (drop (inc cur-len) cur-seq))\n;;               :else (recur cur-len (take (inc cur-len) cur-seq)  (drop (inc cur-len) cur-seq))))))\n;;\n;; Trick: using reduce, where 1st parm is a vect of vects and second parm is next val, and it returns vect of vects.\n(fn [s]\n     (letfn [(longer-seq [a b]\n               (if (and (> (count a) 1)\n                        (> (count a) (count b)))\n                 a\n                 b))\n             (longest-next [[so-far longest] x]\n               (if (or\n                    (empty? so-far)\n                    (= (inc (peek so-far)) x))\n                 [(conj so-far x) longest]\n                 [[x] (longer-seq so-far longest)]))]\n       (let [[so-far longest] (reduce longest-next [[] []] s)]\n         (longer-seq so-far longest))))","user":"540e0637e4b0addc1aec6717"},{"code":"(fn ! [coll]\n  (loop [s (rest coll) longest [[]] current [(first coll)]]\n    (if (empty? s)\n      (let [result\n            (if (>= (count longest) (count current)) longest current)]\n        (if (>= (count result) 2) result []))\n      (let [item (first s) prev (last current)]\n        (if (> item prev)\n          (recur (rest s) longest (conj current item))\n          (recur (rest s)\n                 (if (>= (count longest) (count current)) longest current)\n                 [item]))))))","problem":53,"user":"5225271fe4b01819a2de42f9"},{"problem":53,"code":"(fn [coll]\n  (->> (rest coll)\n       (reduce #(if (= (inc (last (last %1)))\n                       %2)\n                  (assoc-in %1 [(dec (count %1)) (count (last %1))] %2)\n                  (conj %1 [%2]))\n               [[(first coll)]])\n       (filter #(> (count %) 1))\n       (reduce #(if (> (count %2) (count %1)) %2 %1) [])))","user":"53dcdde4e4b0d874e779ae24"},{"code":"(let [s (fn conseqs\n            ([[h & t]] (conseqs t [] [h]))\n            ([[h & t] acc curr]\n             (cond (nil? h)\n                   (conj acc curr)\n                   (= (dec h) (last curr))\n                   (conseqs t acc (conj curr h))\n                   :else\n                   (conseqs t (conj acc curr) [h]))))]\n    (fn max-subs [coll]\n      (last (sort-by count (filter #(not= (count %) 1) (conj (s coll) []))))))","problem":53,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn [xs] (->> (map vector xs (drop 1 xs))\n\t   (partition-by (fn [[a b]] (>= a b)))\n\t   (remove (fn [[[a b] & _]] (> a b)))\n\t   reverse\n\t   (sort-by count)\n\t   last flatten distinct))","problem":53,"user":"52d95491e4b09f7907dd13a4"},{"problem":53,"code":"(fn [items]\n  (reduce #(if (> (count %2) (count %1)) %2 %1)\n          []\n          (loop [result [] [a & rest] items]\n            (if (empty? rest)\n              result\n              (if (= (inc a) (first rest))\n                (recur (conj result (loop [con-result [a] [b & con-rest] rest]\n                                      (if (not b)\n                                        con-result\n                                        (if (= (inc (last con-result)) b)\n                                          (recur (conj con-result b) con-rest)\n                                          con-result)))) \n                       rest)\n                (recur result rest))))))","user":"55a0d79fe4b0acc240e31502"},{"problem":53,"code":"(fn[input]\n  (let [longest (last\n                  (filter #(> (count %) 1)\n                          (sort-by count\n                                   (loop [collection input output []]\n                                     (let[contiguous (map #(#{%1} %2) collection (iterate inc (first collection)))]\n                                       (if (some nil? contiguous)\n                                         (recur (drop (.indexOf contiguous nil) collection) (cons (remove nil? contiguous) output))\n                                         (cons (remove nil? contiguous) output)))))))]\n    (if (nil? longest) [] longest)))","user":"51671557e4b013fc800656c4"},{"code":"(comp #(apply max-key count (cons [] %)) (fn [xs] (filter #(> (count %) 1) (reduce (fn [r x] (let [[curlist best] r] (if (= x (inc (last curlist))) [(concat curlist [x]) best] [[x] (max-key count curlist best)]))) [[(first xs)] []] xs))))","problem":53,"user":"518ec633e4b0cd6ff516769e"},{"code":"(fn long1\n  [xs]\n  (->> xs\n       (map #(vector %1 %2) (range))\n       (partition-by #(- (last %) (first %)))\n       reverse\n       (apply max-key count)\n       (map last)\n       (#(if (> (count %) 1) % []))))","problem":53,"user":"53736f65e4b06d7f452d9e0f"},{"code":"(fn [seq]\n    (loop [s (rest seq)\n           prev (first seq)\n           cur-seq [prev]\n           res-seq []]\n      (if (empty? s)\n        res-seq\n        (let [next (first s)\n              ?cur-seq (conj cur-seq next)\n              ?cur-len (count ?cur-seq)\n              res-len (count res-seq)]\n          (if (= (inc prev) next)\n            (recur (rest s)\n                   next\n                   ?cur-seq\n                   (if (> ?cur-len res-len)\n                     ?cur-seq\n                     res-seq))\n            (recur (rest s)\n                   next\n                   [next]\n                   res-seq))))))","problem":53,"user":"4e48b61d535dc968683fc4be"},{"problem":53,"code":"(fn [lst]\n  (->> (take-while #(> (count %) 0) ((fn list-gen [l] (cons (into (vector) l) (lazy-seq (list-gen (rest l))))) lst))\n       (map #(reduce (fn [[inc-sq end-flag] b] (if (and (not end-flag) (> b (last inc-sq))) [(conj inc-sq b) false] [inc-sq true])) [[(first %)] false] (rest %)))\n       (map #(first %))\n       (reduce #(if (< (count %1) (count %2)) %2 %1))\n       (#(if (= 1 (count %)) [] %))))","user":"591f05b4e4b09b4ee5954c42"},{"code":"(fn [x]\n  (reduce (fn [acc el]\n            (let [size (count el)]\n              (if (and (>= size 2)\n                       (> size (count acc)))\n                el\n                acc)))\n          []\n  (reduce\n   (fn [acc el]\n     (if (> el (last (last acc)))\n       (assoc acc (- (count acc) 1) (conj (last acc) el))\n       (conj acc [el])))\n   [[(first x)]]\n   (rest x)))\n  )","problem":53,"user":"53523ae0e4b084c2834f4aee"},{"problem":53,"code":"(fn [c] (let [res (first (val (apply max-key key (group-by count  (reduce (fn [a x] (let [l (last a) ln (conj l x)] (if (apply < ln) (conj (vec (butlast a)) ln) (conj a [x])))) [[]] c)))))] (if (= (count res) 1) [] res)))","user":"53286f84e4b09d4e7a9b5505"},{"problem":53,"code":"(fn [coll] \n      (let [a (partition-by #(apply < %) (partition 2 1 coll))\n            b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n            c (first (sort-by count > b))]\n        (concat (first c) (map last (rest c)))))","user":"53483a32e4b084c2834f4a57"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n       (partition-by (fn [[x y]] (< x y)) )\n       (filter #((fn [[x y]] (< x y)) (first %)) )\n       (reduce #(if (>= (count %1) (count %2)) %1 %2) [] )\n       (#(reduce (fn [l [_ i]] (conj l i)) (vec (first %)) (rest %)))))","problem":53,"user":"51696ee7e4b03f62cda68ce8"},{"problem":53,"code":"#(vec (first (last (partition-by count (sort-by count (\n  (fn incseq [s]\n    (loop [ret [(first s)], rem (rest s)]\n      (if (empty? rem)\n        (if (> (count ret) 1) [ret] [])\n        (if (<= (first rem) (last ret))\n          (if (> (count ret) 1)\n            (cons ret (lazy-seq (incseq rem)))\n            (recur [(first rem)] (rest rem)))\n          (recur (concat ret [(first rem)]), (rest rem)) ))))\n  %))))))","user":"57539e04e4b02ea1147992ab"},{"problem":53,"code":"(fn longest-ascending\n  [coll]\n  (->> (reduce\n         (fn\n           [reduce-coll el]\n           (let [last-el (-> reduce-coll (last) (last))\n                 dec-el (dec el)]\n             (cond\n               (nil? last-el) (conj reduce-coll [el])\n               (= last-el dec-el) (conj (-> reduce-coll (drop-last) (vec))\n                                        (-> reduce-coll (last) (conj el)))\n               :else (conj reduce-coll [el]))))\n         [[]] coll)\n       (reverse)\n       (filter #(not= (count %) 1))\n       (apply max-key count)))","user":"4fc524aae4b081705acca37e"},{"problem":53,"code":"(fn [s]\n  (loop [n (rest s) c [(first s)] l []]  \n    (println n c l)\n    (if (empty? n)\n      (if (< 1 (count l)) l [])\n      (let [f (first n) pot (if (= f (+ 1 (last c))) (conj c f) [f])] \n        (recur (rest n) pot (if (> (count pot) (count l)) pot l)) \n      )\n    )\n  ) \n)","user":"54aa373de4b09f271ff37cb6"},{"code":"(fn [s] (let [up #(let [[a b] %] (< a b))\n              down (complement up)\n              up-seqs (loop [in s\n                 out []] (let [v (take-while up (drop-while down (map #(vector % %2) in (drop 1 in))))]\n                           (let [up-seq (conj (vec (map first v)) (last (last v)))]\n                             (if (nil? (first up-seq))\n                                                    out\n                                                    (recur (drop (inc (count v)) in) (conj out up-seq))))))]\n          (let [m (group-by count up-seqs)\n                max-count (if (empty? (keys m)) -1 (apply max (keys m)))\n                result (m max-count)]\n            (if (nil? result) [] (first result)))\n          ))","problem":53,"user":"50cae881e4b0f75dcc9a6e51"},{"code":"(fn [coll]\n  (first (sort-by count > (cons [] (filter #(apply < %) (mapcat #(partition % 1 coll) (range 2 (inc (count coll)))))))))","problem":53,"user":"51804bcbe4b04f45bde7d901"},{"problem":53,"code":"(fn longest-raising-subseq [S]\n  (let [[a b]\n        (loop [[a b] [0 0]\n               n 1]\n          (if (= n (count S))\n            [a b]\n            (let [t\n                  (loop [t n]\n                    (if (and (>= (dec t) 0) (> (nth S t) (nth S (dec t))))\n                      (recur (dec t))\n                      t))]\n              (if (> (- n t) (- b a))\n                (recur [t n] (inc n))\n                (recur [a b] (inc n))))))]\n    (if (= a b)\n      []\n      (subvec S a (inc b)))))","user":"56f53962e4b046a417f9206c"},{"problem":53,"code":"(fn [xs]\n  (let [parts (partition 2 1 xs)\n        segregated (partition-by #(< (first %) (second %)) parts)\n        increasing (filter #(< (first (flatten %)) (second (flatten %))) segregated)\n        grouped-count (group-by #(count %) increasing)\n        max-count (apply max 0 (keys grouped-count))\n        longest (flatten (first (grouped-count max-count)))]\n    (if (empty? longest)\n      []\n      (cons (first longest) (take-nth 2 (drop 1 longest))))))","user":"54926752e4b0b312c081ff44"},{"problem":53,"code":"(fn [s]\n  (if-let [ r \n       (loop [l (rest s)\n          curr [(first s)]\n          acc [] ]\n      (if (empty? l) (last (sort\n                            (filter #(> (count %) 1) (conj acc curr))))\n            (if (> (first l) (last curr))\n              (recur (rest l) (conj curr (first l)) acc)\n              (recur (rest l) [(first l)] (conj acc curr)))))] \n    r\n    []))","user":"55469eede4b0a04f79299542"},{"problem":53,"code":"(fn [s] (concat [] (last (->> s (partition 2 1)\n                               (partition-by #(- (nth % 1) (nth % 0)))\n                               (map #(conj [] % (last (last %))))\n                               (map flatten)\n                               (filter #(= 1 (- (nth % 1) (nth % 0))))\n                               (map #(take-nth 2 %))\n                               (sort-by count)))))","user":"573107d5e4b0cd1946bd0fbc"},{"problem":53,"code":"(fn [s]\n  (reduce\n    (fn [longest e]\n      (let\n        [longest-count (count longest)\n         e-count (count e)]\n        (if\n          (and (> e-count 1) (> e-count longest-count))\n          e\n          longest)))\n    []\n    (reduce\n     (fn [res e]\n       (let\n         [lastlast (last (last res))]\n         (cond\n          (empty? res) [[e]]\n          (= (inc lastlast) e) (conj (into [] (drop-last res)) (conj (last res) e))\n          :else (conj res [e]))))\n     []\n     s)))","user":"579e15a6e4b05b1deef9ae20"},{"code":"#(let [c count [x y] (reduce\n  (fn [[a b] e]\n    (if (= b []) \n      [[e] [e]]\n      (if (= (+ 1 (last a)) e)\n        [(conj a e) b]\n        [[e] (if (> (c a) (c b))\n              a\n              b\n            )]\n      )\n    )\n  )\n  [[] []]\n  %\n  )] (let [r (if (> (c x) (c y)) x y)] (if (< (c r) 2) [] r))\n)","problem":53,"user":"4f1595da535d64f603146444"},{"problem":53,"code":"(fn [col]\n  (reverse (second (reduce (fn [[stack largest] val]\n      [\n        (if (> val (or (first stack) 0))\n          (conj stack val)\n          (conj () val)\n        )\n        (if (and (> (count stack) 1) (> (count stack) (count largest)))\n          stack\n          largest\n        )\n      ]\n  ) ['() '()] (conj col 0))))\n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"code":"(fn [col] \r\n  (let [sublists (take-while \r\n                    #(not (empty? %))\r\n                          (iterate #(drop 1 %) col))\r\n        ll (apply max-key count \r\n          (map (fn [l] (some \r\n            #(if (= % (range (first %) (+ (first %) (count %)))) % false) \r\n             (take (- (count l) 1) (iterate drop-last l)))) \r\n                sublists))] \r\n          (if ll ll [])))","problem":53,"user":"4e0e0529535d04ed9115e7b9"},{"problem":53,"code":"(fn [v]\n  (let [partition-by-pairwise\n         (fn [break-between? v]\n           (loop [todo (rest v)\n                  parts []\n                  current-part [(first v)]]\n             (if (empty? todo)\n               (conj parts current-part)\n               (let [e (first todo)]\n                 (if (break-between? (last current-part) e)\n                   (recur (rest todo) (conj parts current-part) [e])\n                   (recur (rest todo) parts (conj current-part e)))))))\n        longest (apply max-key count (reverse (partition-by-pairwise >= v)))]\n    (if (>= (count longest) 2)\n      longest\n      [])))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":53,"code":"(fn [coll]\n  (let [n (count coll)]  \n   (reduce (fn [x y] (if (>= (count x) (count y)) x y)) []\n      (for [\n\t     d (range n) \n\t     t (range (- n d) 0 -1) \n\t     :let [c (take t (drop d coll))] \n\t     :when (and (apply < c) (> (count c) 1) )] c))))","user":"53fe1c3be4b0de5c418485f2"},{"problem":53,"code":"(fn get-longest-increasing-sub-seq [s]\n  (loop [res [] curr-seq [] v s]\n    (cond\n      (nil? v) (if\n                 (and\n                   (> (count curr-seq) 1)\n                   (> (count curr-seq) (count res)))\n                 curr-seq\n                 res)\n      (or (empty? curr-seq) (= (first v) (inc (last curr-seq)))) (recur res (conj curr-seq (first v)) (next v))\n      (and (> (count curr-seq) 1) (> (count curr-seq) (count res))) (recur curr-seq [(first v)] (next v))\n      :else (recur res [(first v)] (next v)))))","user":"5c20b6abe4b07e362c230576"},{"problem":53,"code":"(fn [xs]\n  (first (reduce #(if (>= (second %1) (second %2))\n                   %1\n                   %2)\n                 [[] 1]\n                 (map #(vector (identity %) (count %))\n                      (reduce\n                        #(if (and (not (empty? %1)) (= (inc (last (last %1))) %2))\n                          (concat (take (dec (count %1)) %1) (vector (conj (last %1) %2)))\n                          (conj (vec %1) [%2]))\n                        [] xs)))))","user":"550b5c10e4b06e50f9beb143"},{"problem":53,"code":"#(letfn [(take-incr-seq [v]\n            (let [working-i (first v)]\n              (map second (take-while (fn [[i v]] (= working-i (- v i))) (map-indexed vector v)))))\n          (incr-sub-seq [[h & t :as v] acc]\n            (if-not (seq v)\n              (sequence (->> acc (filter (fn [vs] (>= (count vs) 2))) (sort-by count) last))\n              (let [subseq (take-incr-seq v)]\n                (incr-sub-seq (drop (count subseq) v) (concat [subseq] acc))\n                )))]\n    (incr-sub-seq % []))","user":"53050c04e4b0d8b024fd3757"},{"code":"(fn [coll]\n  (->> coll\n       (partition 2 1)\n       (filter #(apply <= %))\n       (split-with #(apply not= %))\n       (sort-by count)\n       (last)\n       (map (fn [[a b]] (if (= a b) [a] [a b])))\n       (reduce (fn ([] []) ([acc [a b]] (if (= (last acc) a) (conj acc b) acc))))))","problem":53,"user":"4dda44f2535d02782fcbe9f1"},{"problem":53,"code":"(fn [s]\n\t(loop [[p & r] (partition 2 1 s) cur [] lng []]\n\t\t(if (nil? p) lng\n\t\t\t(let [[j d] p]\n\t\t\t\t(if (= d (inc j))\n\t\t\t\t\t(if (empty? cur)\n\t\t\t\t\t\t(recur r [j d]\n\t\t\t\t\t\t\t(if (empty? lng) [j d] lng))\n\t\t\t\t\t\t(recur r (conj cur d)\n\t\t\t\t\t\t\t(if (= (count cur)\n\t\t\t\t\t\t\t\t\t(count lng))\n\t\t\t\t\t\t\t\t(conj cur d) lng)))\n\t\t\t\t\t(recur r [] lng))))))","user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn longest-seq [input]\n  (let [sub-sequences\n           (fn sub-sequences [coll]\n             (loop [previous nil\n                    current-seq []\n                    coll coll]\n               (let [next (first coll)]\n                 (cond \n                   (nil? next) (cons current-seq nil)\n                   (= previous (dec next)) \n                     (recur next (conj current-seq next) (vec (rest coll)))\n                   (seq current-seq)\n                     (cons \n                       current-seq\n                       (lazy-seq (sub-sequences coll)))\n                   :else (recur next [next] (vec (rest coll)))))))\n        best (last (sort-by count (sub-sequences input)))]\n      (if (< 1 (count best))\n        best\n        [])))","problem":53,"user":"53513d28e4b084c2834f4ae3"},{"problem":53,"code":"(fn longest-inc-sub-seq [x]\n  ((fn iter [cur-ret cur-part cnt]\n     (if (= cnt (count x))\n       (if (> (count cur-part) (count cur-ret))\n         (if (> (count cur-part) 1)\n           cur-part\n           '())\n         (if (> (count cur-ret) 1)\n           cur-ret\n           '()))\n       (if (empty? cur-part)\n         (iter cur-ret (concat cur-part (list (nth x cnt))) (inc cnt))\n         (if (> (nth x cnt) (last cur-part))\n           (iter cur-ret (concat cur-part (list (nth x cnt))) (inc cnt))\n           (if (> (count cur-part) (count cur-ret))\n             (iter cur-part (list (nth x cnt)) (inc cnt))\n             (iter cur-ret (list (nth x cnt)) (inc cnt))))))) '() '() 0))","user":"5c3f6322e4b08cd430848e97"},{"problem":53,"code":"#(let [xxs (filter (fn [xs]\n                     (let [[e1 e2] (first xs)]\n                       (> e2 e1)))\n                   (partition-by (fn [[e1 e2]] (< e1 e2))\n                                 (partition 2 1 %)))]\n   (if (empty? xxs) \n     []\n     (let [ss (map (fn [xs] (conj (vec (map first xs)) (second (last xs))))\n                   xxs)]\n       (reduce (fn [xs1 xs2] (if (> (count xs2) (count xs1)) xs2 xs1)) ss)\n       )))","user":"54b13a40e4b09f271ff37d1b"},{"problem":53,"code":"(fn lol [xs] \n  (vec (second (reduce (fn [[c r] n] \n            (if (= (first c) (dec n))\n              [(conj c n) r]\n              (if (and (> (count c) (count r)) (> (count c) 1))\n                [(list n) (reverse c)]\n                [(list n) r])))\n          [() ()]\n          (concat xs [1.0])))))","user":"6011b89ee4b074f607df66bc"},{"problem":53,"code":"(fn [s1]\n    (let [sub (fn [s] (let [r (for [x (range 0 (- (count s) 1)) :while (>= (- (nth s (inc x)) (nth s x)) 1)]  x)]\n                        (if (seq r) (+ (last r) 2) 1)))]\n        (loop [l s1\n               o [[]]]\n          (let [x (sub l)]\n            (if (< (count l) 2) (last o) (recur (subvec l x) (if (and (> x 1) (> x (count (last o)))) [(subvec l 0 x)] o)))))))","user":"58983e3fe4b00487982d52ce"},{"code":"#(let [m (vec\n          (for [x (range 1 (count %))\n          :when (>= (% (dec x)) (% x))] x)) ]\n  (let [mm (vec (cons 0 (conj m (count %))))]\n    (let [n (vec\n              (map - (rest mm)\n                     (take (dec (count mm)) mm)))]     \n      (let [i (.indexOf n (apply max n)) ]\n        (let [ [a b] [(mm i) (mm (inc i))] ]\n          (if (= (inc a) b) [] (subvec % a b))\n  )))))","problem":53,"user":"4fdd27f3e4b05e33b9224f78"},{"code":"(fn[x]\n  (loop [l x v1 [] v2 []]\n    (if (empty? l)\n      (let [ret (first (sort #(> (count %1) (count %2)) (conj v1 v2)))]\n          (if (> (count ret) 1)\n          ret\n          []))\n      (if (empty? v2)\n          (recur (rest l) v1 (conj v2 (first l)))\n        (if (= (first l) (+ 1 (last v2)))\n          (recur (rest l) v1 (conj v2 (first l)))\n          (recur (rest l) (conj v1 v2) (vector (first l))))))))","problem":53,"user":"500b61b1e4b03d00572d2d81"},{"code":"(fn [v]\n  (letfn [(will-fit? [v n-r]\n            (or (= 0 (count v))\n                (= (inc (last v)) n-r)))\n          (double-or-nothing [coll]\n            (if (< (count coll) 2)\n              '() coll))\n          (longer-of [coll1 coll2]\n            (if (< (count coll1) (count coll2)) coll2 coll1))]\n    (first \n      (reduce \n        (fn [[record-holder current-contender] new-recruit]\n          (let [c-c (if (will-fit? current-contender new-recruit)\n                      (conj current-contender new-recruit)\n                      [new-recruit])]\n            [(double-or-nothing (longer-of record-holder c-c)) c-c])) [[][]] v))))","problem":53,"user":"4ec34578535dcc7ae8597d51"},{"problem":53,"code":";; clearly seems too complex, but easiest to understand given a new starter!\n(letfn\n            [\n             (left-val [v e] (if ( > e 0 ) (get v (dec e)) (get v e) ) )\n             (left-score [p e] (if (> e 0)  (get (nth p (dec e)) :score) 0 ) )\n             (improves? [v p e] (> (get v e) (left-val v e)  ))\n             (get-score [v p e] (if (improves? v p e) (inc (left-score p e)) 0 ))\n             (get-scores [v] (reduce (fn [p e] (conj p {:i e :v (get v e) :score (get-score v p e)}))  [] (range (count v))) )\n             (high-score [v] (first (last (partition-by :score (sort-by :score (get-scores v))))) )\n             (get-longest-sub-seq [v t] (if (> (get t :score ) 0) (subvec v (- (get t :i) (get t :score)) (+ 1 (get t :i)) ) [] ) )\n             ]\n          (fn [v] (get-longest-sub-seq v  (high-score v)) ))","user":"58a9e872e4b01a0c0b232973"},{"code":"(fn [coll] \n\t(let [ys (filter (fn [xs] (every? (fn [[a b]] (= (inc a) b)) xs)) (partition-by (fn [[a b]] (< a b)) (partition 2 1 coll)))\n\t\t\t\t]\n\t(if (seq ys) (#(cons (first (first %)) (map second %)) (apply max-key count ys))  '())) )","problem":53,"user":"50fe2b87e4b03cd852b4e84b"},{"code":"(fn [l] (\n  first (\n    reduce\n      (fn [[best cur] [xi xi-1]] (\n        let [nextcur (conj cur xi-1)]\n          [\n            (if (> (count nextcur) (count best))\n              (if (>= (count cur) 1) nextcur [])\n              best\n            )\n            (if (<= xi xi-1)\n              []\n              nextcur\n            )\n          ]\n      ))\n      [[] []]\n      (map list\n        (concat (rest l) [0])\n        l\n      )\n    )\n))","problem":53,"user":"4e7f4147535db966e863cc3d"},{"problem":53,"code":"(fn [xs]\n     (let [p (fn [c] (reduce \n                       #(let [L (last %1)] \n                          (cond\n                           (or (empty? %1) (>= (last L) %2)) (conj %1 [%2])\n                           (< (last L) %2) (conj (vec (butlast %1)) (conj L %2))))\n                        [] c))\n           l (apply max-key count (reverse (p xs)))]\n       (if (> (count l) 1) l [])))","user":"59e0f38ae4b08badc2a0c500"},{"problem":53,"code":";; http://www.4clojure.com/problem/53\n(fn longest-inc-subset\n  [input-seq]\n  (loop [[inp-h & inp-r] input-seq\n         last-val nil\n         curr-seq []\n         last-seq nil]\n    (if (nil? inp-h)\n      (if (nil? last-seq) \n        (if (= (count curr-seq) 1) [] curr-seq)\n        (if (> (count curr-seq) (count last-seq))\n          curr-seq\n          (if (= (count last-seq) 1) [] last-seq)))\n      (if (or (nil? last-val) (= (inc last-val) inp-h))\n        (recur inp-r inp-h (conj curr-seq inp-h) last-seq)\n        (if (nil? last-seq) \n          (recur inp-r inp-h [inp-h] curr-seq)\n          (if (> (count curr-seq) (count last-seq))\n            (recur inp-r inp-h [inp-h] curr-seq)\n            (recur inp-r inp-h [inp-h] last-seq)))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":53,"code":"#(let [r (reverse (last \n (sort-by \n  count \n  (reduce \n   (fn [c e] \n     (let [fc (first c)]\n       (if (or (empty? fc) (not= e (->> fc first inc))) \n         (conj c (list e)) \n         (conj (rest c) (conj fc e))))) \n   '(()) \n   %))))]\n   (if (>= (count r) 2) r ()))","user":"525b142fe4b0cb4875a45d05"},{"problem":53,"code":"(fn [coll]\n  (let [ b (range (first coll) (+ (count coll) (first coll)))\n         c (map - coll b)\n        d (map-indexed vector c)\n        e (partition-by #(second %) d)\n        f (sort-by count e)\n        g (last f)\n        h (map #(nth coll (first %)) g)]\n    (if (= (count h) 1) [] h)))","user":"532dbd3ce4b019098a6f8b40"},{"code":"#(let [s (fn [a b] (if (< (max 1 (count b)) (count a)) a b)) [_ a b] (reduce (fn [[h c b] x] (if (< h x) [x (conj c x) b] [x [x] (s c b)])) [-1 [] []] %)] (s a b))","problem":53,"user":"52b453b0e4b0c58976d9ad21"},{"code":"#(let [longest (apply max-key count\r\n       (reverse\r\n        (reduce\r\n         (fn [run n]\r\n           (let [current-seq (last run)\r\n                 prev (last current-seq)]\r\n             (if (= prev (- n 1))\r\n               (concat (butlast run) [(conj current-seq n)])\r\n               (concat run [[n]]))))\r\n         []\r\n         %)))]\r\n  (if (> (count longest) 1) longest []))","problem":53,"user":"502873a8e4b01614d1633ff8"},{"problem":53,"code":"(fn longest-increasing-sub-seq [x]\n  (or \n   (first\n    (sort-by count >\n             (for [a (range (count x))\n                   b (range (+ a 2) (inc (count x)))\n                   :let [s (subvec x a b)]\n                   :when (apply < s)]\n               s))) []))","user":"50e90813e4b033b0e80d11e7"},{"problem":53,"code":"(fn [coll]\n (let [s (->> (partition 2 1 coll)\n          (partition-by (fn [[l c]] (= 1 (- c l))))\n          (map (comp distinct flatten))\n          (filter #(= % (range (first %) (inc (last %)))))\n          (sort-by count >)\n          (first))]\n  (or s [])))","user":"598a0072e4b021a7a535fed9"},{"problem":53,"code":"(fn [coll]\n  (letfn [(part-it [coll]\n                   (if (empty? coll)\n                     nil\n                     (let [x (->> (map vector (next coll) (butlast coll))\n                                  (take-while (fn [[x y]] (= (inc y) x)))\n                                  (map first)\n                                  (concat [(first coll)]))]\n                       (cons x (lazy-seq (part-it (drop (count x) coll)))))))]\n    (let [c (apply max-key count (part-it coll))]\n      (if (> (count c) 1)\n        c\n        [])))\n  )","user":"51780bfce4b0f89a8f53839c"},{"code":"(fn a \n  [xs]\n  (letfn [(g [ys]\n             (map first \n                  (take-while \n                    #(last %)\n                    (reductions (fn [x y] \n                                  (if (= (inc (first x)) y)\n                                    [y true]\n                                    [y false])) \n                                [(first ys) true] \n                                (rest ys)))))\n          (f [xs]\n             (filter \n               #(< 1 (count %1))\n               (loop [ys xs colls []]\n                 (if (empty? ys)\n                   colls \n                   (recur (rest ys) (conj colls (g ys)))))))]\n    (let [ys (f xs)]\n      (if (> (count ys) 0)\n        (apply max-key count ys)\n        []))))","problem":53,"user":"50aa60bee4b056ee01935865"},{"code":"(fn f\n  ([a] (f a 0 0 0 [] []))\n  ([a p c m cr mr]\n    (if-let [[a & r] (seq a)]\n      (if (> a p)\n        (recur r a (inc c) m (conj cr a) mr)\n        (if (and (> c m) (> c 1))\n          (recur r a 1 c [a] cr)\n          (recur r a 1 m [a] mr)))\n      (if (and (> c m) (> c 1)) cr mr))))","problem":53,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":53,"code":"(fn find-max-seq[xs]\n  (loop [ys xs\n         highest-acc []\n         acc []]\n    (if (empty? ys)\n      (if (= 1 (count highest-acc))\n        []\n        highest-acc)\n      (let [head (first ys)\n            tail (rest ys)\n            new-acc (if (empty? acc)\n                      (conj acc head )\n                      (if (= (+ 1 (last acc))\n                             head)\n                        (conj acc head )\n                        [head]\n                        ))\n            new-highest-acc (if (= (count new-acc) (+ 1 (count highest-acc)))\n                              new-acc\n                              highest-acc)]\n        (recur tail new-highest-acc new-acc)))))","user":"54f86b8ce4b01ecee9d88828"},{"problem":53,"code":"(fn [v]\n  (let [increase-counter\n        (fn [pairs next]\n          (if (empty? pairs)\n            [[next 1]]\n            (let [[x n] (last pairs)]\n              (conj pairs [next (if (< x next) (inc n) 1)]))))\n        lengths (vec (map second (reduce increase-counter [] v)))\n        max-length (apply max lengths)\n        end-point (inc (loop [i 0] (if (= (get lengths i) max-length) i (recur (inc i)))))]\n    (if (> max-length 1)\n      (subvec v (- end-point max-length) end-point) [])))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [l] (let [seqs (loop [acc [] current [] xs l]\n                 (if (empty? xs) (concat acc  [(reverse current)]) \n                 (let [nextval (first xs)\n                       remainder (rest xs)] \n                   (if (empty? current) \n                     (recur acc [ nextval ] remainder)\n                     (if (= (inc (first current)) nextval) \n                       (recur acc (cons nextval current) remainder)\n                       (recur (concat acc [ (reverse current)]) [] xs)) \n                   \n                   )\n                 )))\n                     maxlen (apply max (map #(count %) seqs))\n                     longest-seqs (filter #(and (= (count %) maxlen) (> maxlen 1)) seqs)  \n                     ]\n                 (if (empty? longest-seqs) [] (first longest-seqs))\n                 ))","problem":53,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn lcss [xs]\n  (letfn [(incr [ys zs]\n                (cond (empty? zs) (recur (rest ys) (list (first ys)))\n                      (empty? ys) zs\n                      (> (first ys) (last zs)) (recur (rest ys) (concat zs (list (first ys))))\n                      :else zs))]\n    (let [n (count xs)\n          rs (take n (iterate rest xs))\n          ts (map #(incr % nil) rs)\n          vs (apply (partial max-key count) (reverse ts))]\n      (if (< 1 (count vs)) vs []))))","problem":53,"user":"4ee82ce9535d93acb0a6687a"},{"problem":53,"code":"(fn[coll](\n\tlet [p       (conj coll 0)\n   \t     g\t(partition 2 1 p)\n\tf\t#(< (first %) (second %) )\n\tpb\t(partition-by f g)\n\tt\t(if (f (first (first pb))) (keep-indexed #(if (even? %1) %2) pb) (keep-indexed #(if (odd? %1) %2) pb) )\n  s\t(if (seq t) (reduce #(if(>= (count %1) (count %2)) %1 %2) t) [])\n\tv (if (seq s) (vec (map first s)) [] )\n\tsubsq\t(if (seq v) (conj v (second(last s))) [])\n\t] subsq))","user":"593db05ae4b069cdc2982bab"},{"problem":53,"code":"#(first (reduce\n (fn [[r c] n]\n   (let [l (last c)\n         n (if (and l (= (inc l) n))\n             (conj c n)\n             [n])]\n     [(if (and (> (count n) 1) \n               (> (count n)\n                  (count r)))\n        n\n        r)\n      n]))\n [[] []] %))","user":"5112500ee4b0350614f07a72"},{"code":"(fn [s]\n  (or\n    (->>\n      (map list s (range))\n      (partition-by #(apply - %))\n      (map #(map first %))\n      (filter #(> (count %) 1))\n      (sort-by (comp - count))\n      first)\n    []))","problem":53,"user":"4f03857e535dcb61093f6b0d"},{"problem":53,"code":"(fn max-sub-seq [s]\n  (letfn [(vec->grow-sub-vecs [s]\n            (loop [head (first s)\n                   lst (rest s)\n                   acc []\n                   subacc (conj [] (first s))]\n              (cond\n                (empty? lst) (conj acc subacc)\n                (< head (first lst)) (recur (first lst) (rest lst) acc (conj subacc (first lst)))\n                :else\n                (recur (first lst) (rest lst) (conj acc subacc)(conj [] (first lst))))))]\n  (->>  (vec->grow-sub-vecs s)\n        (filter (fn [x](> (count x) 1)))\n        (reduce (fn [a b] (if (> (count b) (count a)) b a)) []))))","user":"534f8c9ae4b084c2834f4acd"},{"problem":53,"code":"(fn longest-consective [coll]\n  (let [difsf #(- (second %) (first %))\n        consec? #(= (second (first %)) (inc (ffirst %)))\n        cf>cs? #(if (>= (count %1) (count %2)) %1 %2)]\n    (->> (partition 2 1 coll)\n         (partition-by difsf)\n         (filter consec?)\n         (reduce cf>cs? [])\n         flatten\n         distinct)))","user":"547365d4e4b0c51c1f4d727d"},{"problem":53,"code":"#(loop [in %\n         sofar []\n         curr []]\n    [in sofar curr]\n         (cond (empty? in) (let [res (if (> (count curr) (count sofar))\n                             curr\n                             sofar\n                             )]\n                             (if (> (count res) 1) res [])\n                             )\n               (empty? curr) (recur (rest in) sofar (conj curr (first in)))\n               (> (count curr) (count sofar)) (recur in curr curr)\n               (= (inc (last curr)) (first in)) (recur (rest in) sofar (conj curr (first in)))\n               :default (recur (rest in) sofar [(first in)])))","user":"5f419985e4b0955706451fab"},{"problem":53,"code":"(fn [x]\n  (map first (last (sort-by count <= (filter #(>= (count %) 2) (partition-by second (map list x (reductions = true (map < x (rest x)))))))))\n)\n\n; awebb's\n;(fn lss [v]\n;  (loop [[h & t] v, lsf [], cur []]\n;    (if h\n;       (if (and t (> (first t) h))\n;                (recur t lsf (conj cur h))\n;                (if (>= (count cur) (count lsf)) (recur t (conj cur h) []) (recur t lsf [])))\n;        (if (next lsf) lsf [])      )))","user":"550fdc1de4b06e50f9beb17d"},{"code":"#(keep-indexed \n  (fn [idx v] (if (or (odd? idx) (zero? idx)) v)) \n  (flatten \n   (reduce \n    (fn [a b] (if (< (count a) (count b)) b a)) [] \n    (filter \n     (fn [itm] (< ((first itm) 0) ((first itm) 1)))            \n     (partition-by \n      (fn [itm] (< (itm 0) (itm 1))) \n      (map vector % (rest %)))))))","problem":53,"user":"521e8227e4b0dd19981ad082"},{"problem":53,"code":"(fn [c] \n  (->> (range 2 (inc (count c)))\n       (mapcat #(partition % 1 c))\n       (filter #(apply < %))\n       (sort-by count >)\n       (first)\n       (vec)))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [coll]\r\n  (let [inc-seq-fn (fn inc-seqs [xs]\r\n                      (if (empty? xs) '()\r\n                      (let [diff      (map #(> %1 %2) xs (cons (dec (first xs)) xs))\r\n                            len       (count (take-while true? diff))]\r\n                        (cons (take len xs) (inc-seqs (drop len xs))))))\r\n        inc-seqs (inc-seq-fn coll)\r\n        max-len (apply max (map count inc-seqs))]\r\n    (if (< max-len 2) '()\r\n        (some #(when (= (count %) max-len) %) inc-seqs))))","problem":53,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn prob-0053\n  [xs]\n    (let [\n      take-group (fn [f in-xs]\n        ;; TODO Use lazy-seq\n        (let [seq-xs (seq in-xs)\n              x      (first seq-xs)]\n          (if (empty? seq-xs)\n            nil\n            (loop [xs   (rest seq-xs)\n                   lhs  x\n                   rans [x]]\n              (let [rhs (first xs)]\n                (if (or (empty? xs) (not (f lhs rhs)))\n                  (reverse rans)\n                  (recur (rest xs) rhs (cons rhs rans))))))))\n\n      dyad-partition-by (fn [f in-xs]\n        ;; TODO Use lazy-seq\n        (loop [xs   (seq in-xs)\n               rans []]\n          (let [grp  (take-group f xs)]\n            (if (empty? grp)\n              (reverse rans)\n              (recur (drop (count grp) xs) (cons grp rans))))))\n\n      select-by (fn [f-eval f-select xs]\n        ;; TODO: Could make this more efficient by caching the result of the eval in lhs.\n        (reduce #(if (f-select (f-eval %1) (f-eval %2)) %1 %2) xs))\n\n      longest (fn [xs]\n        (select-by count >= xs))]\n\n  (let [sq (longest (dyad-partition-by < xs))]\n    (if (< (count sq) 2)\n      []\n      sq))))","problem":53,"user":"4f047c07535dcb61093f6bcd"},{"problem":53,"code":"(fn [input]\n  (letfn [\n    (count-incr [input]\n      (loop [v (rest input)\n             f (first input)\n             s [1]]\n        (if (empty? v)\n          s\n          (if (< f (first v))\n            (recur (rest v) (first v) (conj s (+ 1 (last s))))\n            (recur (rest v) (first v) (conj s 1))))))\n    (max-value [input]\n      (let [i (map vector (range) (count-incr input))]\n        (reduce (fn [[a b] [c d]] (if (< b d) (vector c d) (vector a b))) i)))\n    (long-subseq [input]\n      (let [m (max-value input)\n            t (+ 1 (first m))\n            d (- t (second m))]\n        (if (= 1 t)\n          []\n          (->> input\n              (take t)\n              (drop d)))))]\n    (long-subseq input)))","user":"5875daaee4b01531a375ea74"},{"code":"(fn [coll]\n  (flatten (take 1\n    (filter\n      (fn [c] (every? #(< (first %) (last %)) (partition 2 1 c)))\n      (mapcat\n        #(partition % 1 coll)\n        (reverse (range 2 (count coll))))))))","problem":53,"user":"4ee6400c535d93acb0a6685b"},{"problem":53,"code":"(comp\n \n(fn [[curr largest]]\n  (let [\n        curr_count (count curr)\n        largest_count (count largest)]\n        (cond\n          (> curr_count largest_count) (if (> curr_count 1) curr [])\n          (<= curr_count largest_count) (if (> largest_count 1) largest []))))\n\n(fn [lst]\n  (loop [\n        data lst\n        curr []\n        largest []]\n     (if (empty? data) [curr largest]\n     (let [ item (first data) \n            curr_count (count curr)\n            largest_count (count largest)\n            [c l] \n             (cond\n               (empty? curr) [(conj curr item) largest]\n               (<= item (last curr)) \n                 (if (> curr_count largest_count) [[item]  curr] [[item] largest])\n               :else [(conj curr item) largest])]\n              (recur (rest data) c l)))))\n )","user":"5c09e555e4b0bdcf453d16fd"},{"problem":53,"code":"(fn scan\n  ;; 1-arity: Properly sets up the 3-arity calls\n  ([col]\n   (scan [(first col)]\n         (rest col)\n         []))\n  ;; 3-arity:\n  ;;    Currently accumulating sequence, not yet processed elements, longest sequence so far\n  ([cur tail result]\n   (if (empty? tail)\n     ;; Return the result if there is nothing left to process\n     result\n     ;; Process one element from the tail and recurse\n     (let [last (peek cur) ;; Last element we looked at\n           next (first tail) ;; The element we want to check now\n           ;; Determine if we should append the element to the current sequence or not\n           join-next (or (and (nil? last) next)\n                         (and last next (> next last)))\n           ;; Either append the element, or open a new sequence with the element\n           new-cur (if join-next (conj cur next) [next])\n           ;; Count elements in the new current sequence and the result sequence\n           new-count (count new-cur)\n           result-count (count result)]\n       ;; Recurse with the new current sequence,\n       ;; the elements we haven't looked at,\n       ;; and the new current sequence as the new result if\n       ;; it matches the criteria.\n       (recur new-cur\n              (rest tail)\n              (if (and (> new-count 1)\n                       (> new-count result-count))\n                new-cur\n                result))))))\n\n;; User anjensan posted a very elegant but less efficient solution.\n;; The gist of it is:\n;; - create all possible subsequences\n;; - filter all sequences with increasing element order\n;; - sort remaining sequences by count in decreasing order\n;; - return the first sequence\n;; \n;;  (fn [s] \n;;    (->> (for [a (range (count s)) \n;;               b (range (inc a) (count s))]\n;;           (subvec s a (inc b)))\n;;         (filter #(apply < %))\n;;         (sort-by count >)\n;;         first\n;;         vec))","user":"59a080e3e4b0871e7608b837"},{"problem":53,"code":"(fn longest [coll]\n\t(reduce\n\t\t(fn [a b]\n\t\t\t(if (and (< 1 (count b))\n\t\t\t\t\t\t\t(> (count b) (count a)))\n\t\t\t\tb a))\n\t\t[]\n\t\t(reductions\n      (fn [a b]\n        (if (> b (last a)) (conj a b) [b]))\n      [(first coll)]\n      (rest coll))))","user":"59ac559ee4b00adcf69795d2"},{"problem":53,"code":"(fn func\n    [ar]\n    (loop [xs ar\n           cur []\n           ans []]\n      (if (empty? xs)\n        ans\n        (if (or (empty? cur) (< (last cur) (first xs)))\n          (let [tail (rest xs)\n                newCur (conj cur (first xs))\n                newAns (if (and (> (count newCur) (count ans)) (>= (count newCur) 2))\n                         newCur\n                         ans)]\n            (recur tail newCur newAns))\n          (recur (rest xs) [(first xs)] ans)))))","user":"5b8db323e4b0c0b3ffbd49da"},{"problem":53,"code":"(fn [s] \n  (first (reduce \n            (fn [[longest_subs current_subs] val]\n              (let [new_subs (conj current_subs val)\n                    start (first new_subs)\n                    len (count new_subs)\n                    is_iseq (= new_subs (take len (iterate inc start)))]\n                (if is_iseq\n                 (if (and \n                          (< (count longest_subs) (count new_subs))\n                          (>= (count new_subs) 2))\n                    [new_subs new_subs]\n                    [longest_subs new_subs])\n                  [longest_subs [val]])))\n            [[][]]\n            s)))","user":"5da05bcce4b000c986472bd0"},{"code":"(fn foo [s]\n  (loop [sentinel -1 tmpresult [] result [] s s]\n    (let [current (first s) result (if (> (count tmpresult) (count result)) tmpresult result)]\n    \t(cond (not current)        (if (> (count result) 1) result [])\n               (> current sentinel) (recur current (conj tmpresult current) result (rest s))\n      \t\t   :else                (recur current [current] result (rest s))\n    \t)\n    )\n  )\n)","problem":53,"user":"52ac41fee4b0c58976d9ac85"},{"code":"(fn [coll]\n  (loop [r [] acc [] prev nil coll coll]\n    (if-let [[a & coll] coll]\n      (if (nil? prev)\n        (recur r [a] a coll)\n        (if (= a (inc prev))\n          (recur r (conj acc a) a coll)\n          (recur (conj r acc) [a] a coll)))\n      (if-let [r (first (sort #(compare (count %2) (count %1)) (filter #(> (count %) 1) (conj r acc))))]\n        r\n        []))))","problem":53,"user":"4e521cef535d302ef430da6d"},{"problem":53,"code":"(fn [v]\n  (let [s (first (sort-by count > (filter #(apply < (first %)) (partition-by #(apply < %) (partition 2 1 v)))))]\n    (concat (map first s) (rest (last s)))))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":53,"code":"(fn [coll]\n  (let [ret (->> (map #(apply subvec coll %)\n                    (for [x (range (inc (count coll)))\n                          y (range (inc (count coll)))\n                          :when (< x y)]\n                      [x y]))\n               (filter #(= (distinct (sort %)) %)))\n        m (apply max (map count ret))]\n    (if (> m 1)\n      (first (filter #(= (count %) m) ret))\n      [])))","user":"51441ce7e4b0b4fb4ace5f41"},{"problem":53,"code":"#(let [lss (fn [% curs maxs]\n               (let [fst (first %)\n                     rst (rest %)\n                     ncr (if (= ((fnil dec 0) fst) (peek curs)) (conj curs fst) [fst])\n                     nmx (max-key count ncr maxs)]\n                 (if (seq rst)\n                   (recur rst ncr nmx)\n                   nmx)))\n        lng (lss % [(first %)] [])]\n    (if (> (count lng) 1) lng []))","user":"607e1c1fe4b03d835a6eaed8"},{"code":"(fn [sq]\n  (letfn [(incseq [s]\n           (cond (empty? s) ()\n                 (empty? (rest s)) s\n                 (< (first s) (second s)) (cons (first s)\n                                                (incseq (rest s)))\n                 :else (take 1 s)))]\n     (->> \n       sq\n       (iterate rest)\n       (take (count sq))\n       (map incseq)\n       (map (fn [x] (if (> (count x) 1) x ())))\n       reverse\n       (apply (partial max-key count)))))","problem":53,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn [coll]\n  (let [len (count coll)\n        cmp (fn [[x1 y1] [x2 y2]] (< (- y1 x1) (- y2 x2)))]\n    (loop [i 0 j 1 best [0 1] ]\n      (if (> i (dec len))\n        (if (= 1 (- (last best) (first best)))\n          []\n          (subvec coll (first best) (last best)))\n        (if (or (= j len)\n                (not (= (- j i) (- (nth coll j) (nth coll i)))))\n          (recur j (inc j)\n                 (if (cmp best [i j]) [i j] best))\n          (recur i (inc j) best)))\n     )))","problem":53,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn __ [s]\n  (let [reducer (fn [coll x]\n                  (let [lastcoll (last coll) lastvalue (last lastcoll)]\n                    (if (and lastvalue (> x lastvalue))\n                      (concat (butlast coll) (vector (conj lastcoll x)))\n                      (conj (vec coll) [x]))))\n        found (first (reverse (sort (reduce reducer [] s))))]\n       (if (= 1 (count found)) [] found)))","problem":53,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(fn [coll]\n  (loop [current [(first coll)] longest [] coll (rest coll)]\n    (if (empty? coll)\n      (if (> (count current) (count longest))\n        (if (= 1 (count current))\n          []\n          current)\n        (if (= 1 (count longest))\n          []\n          longest))\n      (recur (if (= 1 (- (first coll) (last current)))\n                (conj current (first coll))\n                [(first coll)])\n             (if (> (count current) (count longest))\n                current\n                longest)\n             (rest coll)))))","problem":53,"user":"518a59b3e4b02bf06f6bbb4b"},{"problem":53,"code":"(fn [s]\n  (letfn [(inc-list? [[a & b]]\n           (if (seq b)\n            (if (and (seq b) (< a (apply min b)))\n                (inc-list? b)\n                nil)\n            a))\n          (get-ab [[a b]]\n                  #(->> %\n                       (take b)\n                       (drop a)))]\n    (let\n      [l (.length s)\n       abV\n        (sort-by (fn [[a b]] (- a b))\n         (for [a (range (inc l))\n               b (range (inc l))\n               :when (and (> b a)\n                          (= l (+ a (- b a) (- l b))))]\n           [a b]))]\n      (loop [r abV]\n        (if (seq r)\n          (let [a-b ((get-ab (first r)) s)]\n               \n            (if (inc-list? a-b)\n               (if (seq (rest a-b)) a-b [])\n               (recur (rest r))))\n          nil)))))","user":"5b9ae606e4b0c0b3ffbd4af2"},{"code":"(fn [coll]\n     (vec (first\n        (filter #(< 1 (count %))\n          (sort-by #(- (count %))\n            (reduce (fn [coll b]\n                      (let [cs (vec (butlast coll))\n                            c (last coll)\n                            a (last c)]\n                        (if (or (nil? a) (< a b))\n                          (conj cs (conj c b))\n                          (conj coll [b])))) [[]] coll))))))","problem":53,"user":"4ee77f15535d93acb0a66868"},{"problem":53,"code":"(fn [x] \n  (let [seqs (partition-by #(apply < %) (partition 2 1 x))\n        incr? (filter #(< (ffirst %) (second (first %))) seqs)\n        lis (first (sort-by count > incr?))] \n   (concat (first lis)\n           (map last (rest lis)))))","user":"543d5c61e4b032a45b86934d"},{"problem":53,"code":"(fn[arr](let [subseqlist (map\n   (fn[v](\n     let [subseq (drop v arr)]\n    (map\n     second\n     (let [[head tail] (split-with\n                        #(true? (first %))\n                        (map (fn[a b](conj '() a (< a b)))  subseq (conj (vec (rest subseq)) 999)))]\n       (if (empty? head)\n         '()\n         (if (nil? (first tail))\n           (vec head)\n           (conj (vec head) (first tail))))))))\n    (range 0 (dec (count arr))))]\n (let [sortlist \n  (sort-by\n   count\n   subseqlist)]\n   (first (filter #(= (count %1) (count (last sortlist))) sortlist))\n  )))","user":"5596af34e4b04c1e5c31d758"},{"code":"(fn [col]\n  (let [validate_col (fn [c] (if (< (count c) 2) [] c)) ]\n  (loop [s1 [] s2 [(first col)] lastv (first col) data (rest col)]\n    (if (empty? data)\n         (if (< (count s1) (count s2) )\n                         (validate_col s2)\n                         (validate_col s1))\n        (let [is-inc (< lastv (first data))]\n          (recur (if is-inc\n                     s1\n                     (if (< (count s1) (count s2))\n                         s2\n                         s1))\n                  (if is-inc (conj s2 (first data) ) [(first data)])\n                  (first data)\n                  (rest data)))))) )","problem":53,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [x]\n  (let [a (->> \n           (map vector x (rest x))\n           (partition-by #(< (first %) (second %)))\n           (reverse)\n           (apply max-key count))\n        r (concat (map first a) [(-> a last second)])]\n    (if (< (first r) (second r)) r '())))","problem":53,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [coll]\n  (let [longest\n        (loop [nums    (rest coll)\n               current [(first coll)]\n               longest current]\n          (println (str nums current longest))\n          (if-let [[n & rest-n] nums]\n            (if (> n (last current))\n                (let [longer (conj current n)]\n                  (recur rest-n longer\n                         (if (> (count longer) (count longest)) longer longest)))\n                (recur rest-n [n] longest))\n            longest))]\n    (if (>= (count longest) 2) longest [])))","problem":53,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":53,"code":"(fn [c]\n  (reduce\n   #(if (>= (count %2) 2 (count %))\n      %2 %)\n   []\n   (reduce #(if (= (- %2 1) (last (last %)))\n              (assoc % (- (count %) 1) (conj (last %) %2))\n              (conj % [%2]))\n           [[]]\n           c)))","user":"53f78944e4b0de5c41848561"},{"problem":53,"code":"(fn [xs]\n  (let [[a b]\n          (reduce\n            (fn [[longest current] x]\n              (let [p (last current)]\n                (if (or (nil? p) (> x p))\n                  [longest (conj current x)]\n                  [(if (> (count current) (count longest))\n                     current\n                     longest)\n                   [x]])))\n            [[] []]\n            xs)\n        c (if (> (count b) (count a)) b a)]\n    (if (> (count c) 1) c [])))","user":"59f78b49e4b0ca45a743a30e"},{"problem":53,"code":"(fn [xs]\n    (let [rebuild\n          #(if (empty? %)\n             '()\n             (cons (first (first %)) (map second %)))]\n      (->> (map vector xs (rest xs))\n           (partition-by #(= (inc (first %)) (second %)))\n           (filter #(= (second (first %)) (inc (first (first %)))))\n           (sort-by count)\n           (last)\n           (sequence)\n           (rebuild)\n           (apply vector))))","user":"5920c191e4b09b4ee5954c61"},{"problem":53,"code":"(fn [s]\n   (let [[biggest last :as both] (reduce (fn [[biggest [l & _ :as current]] e]\n\n                                  (cond\n                                    (nil? current) [biggest (list e)]\n                                    (> e l) [biggest (conj current e)]\n                                    (and (>= (count current) 2) (> (count current) (count biggest))) [current (list e)]\n                                    :else [biggest (list e)]))\n                                nil\n                                s)]\n     (if biggest\n       (->> both (sort-by count >) first reverse)\n       [])))","user":"55895eade4b059ccff29b202"},{"code":"#(letfn [(acc [[current longest] e]\n               (if (= (dec e) (peek current))\n                 (let [current (conj current e)]\n                   [current (if (> (count current) (count longest))\n                              current\n                              longest)])\n                 [[e] longest]))]\n         (get (reduce acc [[] []] %) 1))","problem":53,"user":"4dac61e18cc9d6edb9beb0b3"},{"code":"(fn longest-increasing-sub-seq [coll]                                                                                                        \r\n    (letfn [(longest-increasing [coll]                                                                                                        \r\n              (let [longest-partitioned (take-while (fn [[x y]] (< x y))                                                                       \r\n                                                    (partition 2 1 coll))                                                                     \r\n                    c (count longest-partitioned)]                                                                                            \r\n                (if (= 0 c)                                                                                                                   \r\n                  '()                                                                                                                         \r\n                  (take (inc c) coll))))                                                                                                      \r\n            (sub-seqs [coll]                                                                                                                  \r\n              (map #(drop % coll) (range (dec (count coll)))))]                                                                               \r\n      (reduce (fn [t e] (if (> (count e) (count t)) e t))                                                                                      \r\n              []                                                                                                                              \r\n              (map longest-increasing (sub-seqs coll)))))","problem":53,"user":"4f149e0f535d64f60314643d"},{"code":"#(loop [v %\n        best []\n        curr (take 1 %)]\n   (cond\n    (empty? v) (if (and (> (count curr) (count best)) (> (count curr) 1)) curr best)\n    (= (inc (last curr)) (first v)) (recur (rest v) best (concat curr (take 1 v)))\n    :else (if (and (> (count curr) 1) (> (count curr) (count best)))\n            (recur (rest v) curr (take 1 v))\n            (recur (rest v) best (take 1 v)))))","problem":53,"user":"51d360d1e4b099f3b6acddff"},{"code":"(fn lics[a-seq]\n\t(let [head (first a-seq) res (reduce (fn [[cand max last-el] el] \n\t\t\t\t(if (>= last-el el)\n\t\t\t\t\t;subsequence has finished\n\t\t\t\t\t(let [cand-len (count cand)]\n\t\t\t\t\t\t(if (> cand-len (count max))\n\t\t\t\t\t\t\t(if (> cand-len 1)\n\t\t\t\t\t\t\t\t[[el] cand el]\n\t\t\t\t\t\t\t\t[[el] max el]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t[[el] max el]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t;subsequence is increasing\n\t\t\t\t\t[(conj cand el) max el]\n\t\t\t\t)\n\t\t\t) \n\t\t\t[[head][] head] \n\t\t\t(rest a-seq)\n\t) last-cand (first res) last-max (second res)]\n\t\t(let [last-cand-len (count last-cand)]\n\t\t\t(if (> last-cand-len (count last-max))\n\t\t\t\t(if (> last-cand-len 1)\n\t\t\t\t\tlast-cand\n\t\t\t\t\tlast-max\n\t\t\t\t)\n\t\t\t\tlast-max\n\t\t\t)\n\t\t)\n\t) \n)","problem":53,"user":"52763696e4b03e8d9a4a74d7"},{"problem":53,"code":"(fn [src]\n  (let [consecutive? (fn [x y] (= y (+ x 1)))\n        consecutive-subseqs (fn [src temp acc]\n                              (cond (empty? src) (if (< (count temp) 2) acc (conj acc temp))\n                                    ;; handle initial case\n                                    (empty? temp)\n                                    (recur (rest src)\n                                           [(first src)] ;; fill TEMP with the first int\n                                           acc)\n                                    ;; TEMP is a dud, discard; no need to commit TEMP\n                                    (and (< (count temp) 2) ;; because TEMP is below threshold size\n                                         (<= (first src) (last temp)))\n                                    (recur (rest src)\n                                           [(first src)] ;; add this to TEMP, as it has potential\n                                           acc)\n                                    ;; found end of consecutive number sequence\n                                    (and (>= (count temp) 2)\n                                         (<= (first src) (last temp)))\n                                    (recur (rest src)\n                                           [(first src)]\n                                           (conj acc temp))\n                                    ;; adding a consecutive number to TEMP\n                                    (consecutive? (last temp) (first src))\n                                    (recur (rest src)\n                                           (conj temp (first src))\n                                           acc)\n                                    ;; non-consecutive number found and TEMP too small to use\n                                    :else\n                                    (recur (rest src)\n                                           [(first src)]\n                                           acc)))]\n    (or (first (sort-by count >\n                        (consecutive-subseqs src [] [])))\n        [])))","user":"58db31dce4b0a4d5acaab674"},{"problem":53,"code":"(fn [coll]\n    (let [x (->> (reduce (fn [a b]\n                           (try\n                             (if (empty? a)\n                               (conj a [b])\n                               (if (> b (last (last a)))\n                                 (conj (into [] (drop-last a))\n                                       (conj (last a) b))\n                                 (conj a [b])))))\n                         []\n                         coll)\n                 (group-by count))\n          y (->> (apply max (keys x))\n                 x\n                 first)]\n      (if (< 1 (count y))\n        y\n        [])))","user":"59636cc2e4b066ee0a44b0c7"},{"problem":53,"code":"(fn [row]\n    (let [shifted (concat [(- (first row) 1)] row)\n          comparable (map #(hash-map :current %1 :previous %2) row shifted)]\n      ;; comparable\n      (->> comparable\n          (partition-by (fn [x] (<= (:current x) (:previous x))))\n          ((fn [x] (concat (list (rest (first x))) (rest x))))\n          (filter #(> (count %) 0))\n          (filter #(> (:current (first %)) (:previous (first %))))\n          (group-by count)\n          (sort-by key)\n          (last)\n          (second)\n          (first)\n          ((fn [xx]\n             (if (nil? xx)\n               (list)\n               (concat (list (:previous (first xx))) (map :current xx))\n             )\n             ))\n           )\n      ))","user":"56ef11efe4b04a395b9a045b"},{"code":"#((reduce (fn [{:keys [curseq longest] :as state} i] (if (= (last curseq) (dec i)) (let [curseq (conj curseq i)] (if (> (count curseq) (count longest)) (assoc state :longest curseq :curseq curseq) (assoc state :curseq curseq))) (assoc state :curseq [i]))) {:curseq [] :longest []} %) :longest)","problem":53,"user":"5137c3b0e4b0509a8b470482"},{"code":"(fn longest-increasing-seq[coll]\n    (apply max-key count []\n           (reverse (filter #(apply < %)\n             (for [x (range (count coll))\n                   y (range (+ 2 x) (+ 1 (count coll)))]\n               (subvec coll x y))))))","problem":53,"user":"50e4f4e9e4b049a987753896"},{"problem":53,"code":"(fn [coll]\n  (let [longest-stepper (fn [[cur longest] n]\n                          (let [n-cur (conj cur n)]\n                            (if (apply < n-cur)\n                              (if (and (< 1 (count n-cur))\n                                       (< (count longest) (count n-cur)))\n                                [n-cur n-cur]\n                                [n-cur longest])\n                              [[n] longest])))]\n    (second (reduce longest-stepper [[] []] coll))))","user":"540c6a8ae4b0addc1aec6702"},{"problem":53,"code":"(fn [v]\n  (letfn [(lead-increasing-sequence [v]\n                                    (if (> 2 (count v)) \n                                      v\n                                      (let [a (first v)\n                                            b (second v)\n                                            ]\n                                        (if (< a b) \n                                          (flatten [a (lead-increasing-sequence (rest v))])\n                                         [a]\n                                         )\n                                        )\n                                      )\n                                    )\n          (length-of-longest [sequences] (if (empty? sequences) 0 (apply max (map #(count %) sequences))))\n          (first-of-length [l sequences] (first (drop-while #(not (= l (count %))) sequences)))\n          (all-sequences [orig]\n                         (loop [sequences [] remaining orig]\n                           (if (empty? remaining) \n                             (filter #(< 1 (count %)) sequences)\n                             (let [next-seq (lead-increasing-sequence remaining)\n                                   len (count next-seq)]\n                               (recur (conj sequences next-seq) (drop len remaining))\n                               )\n                             )\n                           )\n                         )\n          ]\n    (let [s (all-sequences v)\n          l (length-of-longest s)\n          answer (if (= l 0) [] (first-of-length l s))]\n      answer\n      )\n    )\n  )","user":"55496eeae4b0a04f79299569"},{"code":"(fn longest-inc-sub [v]\n  (loop [[f & more] v\n         last-res []\n         last-size 1\n         res [f]\n         size 1]\n    (if (empty? more)\n      (if (> size last-size) res last-res)\n      (if (> (first more) f)\n        (recur more last-res last-size (conj res (first more)) (inc size))\n        (if (> size last-size) \n          (recur more res size [(first more)] 1)\n          (recur more last-res last-size [(first more)] 1)\n          )\n        )\n      )\n    ))","problem":53,"user":"5094057fe4b097f48cc38593"},{"code":"(fn [coll] \n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))] \n   (concat (first c) (map last (rest c)))))","problem":53,"user":"52a6ed15e4b0c58976d9ac0a"},{"code":"#(reverse \n  (first \n   (sort-by count > \n            (filter (fn [y] (< 1 (count y))) \n                    (reduce \n                     (fn [acc x] \n                       (let [p (first (first acc))] \n                         (if (= p (dec x)) \n                           (concat (list (cons x (first acc))) (rest acc)) \n                           (cons (list x) acc) ))) \n                     '() %)))))","problem":53,"user":"533b9cace4b0e30313ee6cd1"},{"problem":53,"code":"(fn [l]\n  (letfn \n    [(suite? [l r]\n     (if (empty? (rest l))\n       r\n       (if (= (- (second l) (first l) )  1)\n         (recur (rest l) true)\n         false\n        )\n       )\n     )\n     (looksuite [l c r s] \n       (if (empty? (rest l)) \n          s\n         (if (empty? c)\n           (recur (rest l) (rest (rest l)) [] (cons r s))\n           (if (suite? (conj r (first c)) true)\n              (recur l (rest c) (conj r (first c)) s)\n              (recur (rest l) (rest (rest l)) (conj [] (first (rest l))) (cons r s))\n           )\n        )\n      )\n     )\n    ]\n      (let [res (last (sort-by count (looksuite l (rest l) (conj [] (first l)) [])))]\n        (if (= (count res) 1) [] res)\n      )\n  ) \n)","user":"556f2009e4b09a3098a52519"},{"code":"(fn [numbers]\n  (loop [l numbers ans [] temp [] prev nil]\n    (cond\n      (empty? l)\n        (if (> (count ans) 1) ans [])\n      (or (nil? prev) (> (first l) prev))\n        (let [new-temp (conj temp (first l))]\n          (recur (rest l) (if (>= (count ans) (count new-temp)) ans new-temp) new-temp (first l))\n        )\n      :else\n        (recur (rest l) ans [(first l)] (first l))\n    )\n  )\n)","problem":53,"user":"51f09f3de4b0274c496158d7"},{"problem":53,"code":"(fn [s]\n    (let [\n      [all last]\n        (reduce\n          (fn [[all cur] x]\n            (cond\n              (empty? cur)\n                [all [x]]\n              (> x (last cur))\n                [all (conj cur x)]\n              (and (> (count cur) 1) (> (count cur) (count all)))\n                [cur [x]]\n              :else [all [x]]))\n          [[] []] s)]\n      (if (and (> (count last) 1) (> (count last) (count all))) last all)))","user":"5901158de4b0438e51c2d039"},{"problem":53,"code":"(fn [coll]\n  (->> coll \n       (reduce (fn [result input]\n                 (let [row (first result)\n                       v (last row)]\n                   (if (and v\n                            (= (inc v) input))\n                     (cons (concat row [input]) (rest result))\n                     (cons [input] result))))\n               '([]))\n       (apply max-key count)\n       (#(if (> (count %) 1)\n           %\n           []))))","user":"5cbb0436e4b026601754b9cc"},{"code":"(fn [x]\n  (let [add-element\n        (fn [x xs]\n          (let [x0 (first x)]\n            (if (and (not (nil? (last x0)))\n                     (> xs (last x0)))\n              (conj (rest x) (conj x0 xs))\n              (conj x [xs]) ;; else\n              )\n            ))\n        ]\n    (reduce\n      (fn \n        ([x y] (if (>= (count x) (count y)) x y))\n        ([] []))\n      \n      (filter (fn [e] (> (count e) 1)) (reverse (reduce add-element '([]) x)))\n      \n      )))","problem":53,"user":"4f616892e4b0defedf855fbf"},{"problem":53,"code":"(fn \n  [test-list] \n  (let [ m (map #(< %1 %2) test-list (rest test-list))\n         i (map-indexed vector m)\n         p (partition-by #(false? (second %)) i)\n         f (filter #(true? (second (first %))) p)]\n    (if (empty? f)\n      ()\n      (let [s (sort-by count f)\n         \tc (filter #(>= (count %) (count  (last s))) s)\n         \tl (first c)\n         \tstart (first (first l))]\n \t\t (subvec test-list start (+ 1 (+ (count l)) start))))))","user":"5628f33ce4b00e49c7cb47f3"},{"code":"(fn __ [ll]\n (let [g (fn g[ll]\n (cond (empty? ll) ll\n  :else \n   (loop [l (rest ll) old (first ll) res [(first ll)]]\n     (cond\n      (empty? l) (if (> (count res) 1) (list res []) (list [] []))\n      (< old (first l))  (recur (rest l) (first l) (conj res (first l)))\n      :else (list res l)))))]\n   (loop [l ll res nil n 0]\n    (cond\n     (empty? l) (if (> (count res) 1) res  [])\n   :else (let [[l1 l2] (g l)]\n    (if (< n (count l1))  (recur l2 l1 (count l1))\n        (recur l2 res n)))))))","problem":53,"user":"4f04a06d535dcb61093f6bd9"},{"problem":53,"code":"(fn seq-counts\n  [coll]\n  (let [inc? (fn [a b](= b (inc a )))]\n    (loop [c coll\n           acc []\n           counter 0]\n      (if (empty? c)\n        (if (empty? acc) []\n            (first (sort-by count > acc)))\n          (if (inc? (first c) (second c))\n            (recur (rest c) (if (= 0 counter)\n                              (conj acc (vector(first c) (second c)))\n                              (assoc acc (- (count acc) 1) (conj (last acc) (second c))))\n                   (inc counter))\n            (recur (rest c) acc 0))))))","user":"5785c1d4e4b0ebec4cfb74e1"},{"problem":53,"code":"(fn [se]\n  (let [\n        counts (first (reduce\n                        (fn [[res prev] item]\n                          (if (< prev item)\n                            [(conj res (inc (last res))) item]\n                            [(conj res 1) item])\n                          )\n                        [[0] 0]\n                        se))\n        mmm (reduce max counts)\n        res1 (first (filter #(> %1 1) (filter pos? (map-indexed (fn [x a] (if (= a mmm) x 0)) counts))) )\n        ]\n    (println counts mmm res1)\n    (if (> mmm 1)\n      (take mmm (drop (- res1 mmm) se))\n      [])))","user":"58bc6a88e4b0888cdc949d16"},{"problem":53,"code":"(fn [t] (->> t\n  (partition 2 1 [])                ;Split t into overlapping pairs. This enables us to separate runs of increasing/decreasing numbers without index arithmetic\n  (partition-by #(apply < %))       ;Separate subseqs that increase and decrease\n  (map (comp distinct flatten))     ;Convert from lists of overlapping pairs to proper seqs\n  (filter #(< (first %) (last %)))  ;Filter out decreasing subseqs\n  (reverse)                         ;Ensure that the returned sequence is the first\n  (concat [[]])                     ;Ensure that an input with no incrementing subseqs produces []\n  (apply (partial max-key count)))) ;Select the longest remaining subseq","user":"5c7c1d8ee4b0d597f478ca88"},{"problem":53,"code":"(fn [x]\n  (loop [r [] b [] c x]\n    (cond\n     (empty? c) (if (< 1 (count r) (count b)) b r)\n     (empty? b) (recur r [(first c)] (rest c))\n     (= (first c) (inc (last b))) (recur r (conj b (first c)) (rest c))\n     (and (< (count r) (count b))\n          (< 1 (count b))) (recur b [(first c)] (rest c))\n     :else (recur r [(first c)] (rest c))\n     )\n    )\n  )","user":"555883c5e4b0deb715856e2d"},{"code":"(fn [coll]\n  (let [c (map #(vector % \n                        (let [[x y] %2] (if y (- y x) nil))) \n               coll (partition-all 2 1 coll)),\n        bigger (fn [l c] \n                 (let [ls (count l)\n                       cs (count c)\n                       bg (if (> cs ls) c l)]\n                   (if (> (count bg) 1) bg [])))]\n    (loop [longest [], current [], pairs c]\n      (let [[v diff] (first pairs)]\n        (if (nil? diff)\n          (bigger longest (conj current v))\n          (if (> diff 0)\n            (recur longest (conj current v) (rest pairs))\n            (recur (bigger longest (conj current v)) [] (rest pairs))))))))","problem":53,"user":"4ddbdc1b535d02782fcbe9fd"},{"code":"(fn long-seq [lst]\n    ((reduce (fn [[curr best] ele]\n        (let [next-c (if (> ele (last curr)) (conj curr ele) [ele])\n            next-b (if (and (> (count next-c) (count best)) (> (count next-c) 1)) next-c best)]\n            [next-c next-b]))\n        [[(first lst)] []] (rest lst)) 1)\n)","problem":53,"user":"52c17e42e4b07a9af5792367"},{"problem":53,"code":"(fn prt [[h & t]]\n  (let [res (apply max-key  count (reverse (reduce   (fn [x y] (if (< (last (last x)) y) \n  (conj (into [] (butlast x)) (conj (last x) y)) (conj x [y]))) [[h]] t)))] \n    (if (< (count res) 2) []  res) ))","user":"6076adb2e4b069485764de60"},{"problem":53,"code":"(fn [a]\n  (let [b (map last\n            (filter #(false? (first %))\n            (map vector\n              (concat [false] (map < a (rest a)) [false])\n              (range))))\n        i (sort\n            (map\n              (fn [x y] [(- x y) x])\n              b (rest b)))\n        r (first i)\n        l (unchecked-negate (first r))\n        o (last r)]\n    (if (= l 1)\n      []\n      (take l (drop o a)))))","user":"53d612cbe4b0e771c3025452"},{"problem":53,"code":"(fn __ [col]\n  (loop [[first & rest] col\n         current-sub-seq []\n         longest-sub-seq []]\n    (if (nil? first)\n      longest-sub-seq\n      (let [current-sub-seq (if (empty? current-sub-seq)\n                              (vector first)\n                              (if (= (inc (last current-sub-seq)) first)\n                                (conj current-sub-seq first)\n                                (vector first)))]\n        (recur\n          rest\n          current-sub-seq\n          (if (and (>= (count current-sub-seq) 2) (> (count current-sub-seq) (count longest-sub-seq)))\n            current-sub-seq\n            longest-sub-seq))))))","user":"5ac91d90e4b0e27600da77bd"},{"code":"(fn [s]\n  (:best\n    (reduce #(let [c (if (or (empty? (:cur %1))\n                             (> %2 (last (:cur %1))))\n                        (conj (:cur %1) %2) [%2])]\n                (if (and (> (count c) (count (:best %1)))\n                         (> (count c) 1))\n                  (assoc %1 :cur c :best c)\n                  (assoc %1 :cur c)))\n            {:cur [] :best []}\n            s)))","problem":53,"user":"5175533fe4b0dea9bbfba575"},{"problem":53,"code":"(fn trouble [xs]\n  (let [r (fn [s x]\n            (cond\n              (empty? s) [[x]]\n              (< (last (last s)) x) (conj (vec (butlast s)) (conj (last s) x))\n              :else (conj s [x])))\n        g (fn [s x]\n            (if (< (count s) (count x)) x s))]\n      (reduce g [] (filter #(> (count %) 1) (reduce r [] xs) ))))","user":"59708e38e4b01722bebd4c65"},{"problem":53,"code":"(fn [s]\n  (let [choose-result (fn [or nr] (if (and (> (count nr) 1) (> (count nr) (count or))) nr or))]\n    (loop \n      [v s pr [] r []]\n      (if (empty? v)\n        (choose-result r pr)\n        (if (empty? pr)\n          (recur (rest v) [(first v)] r)\n          (if (= (first v) (inc (last pr)))\n            (recur (rest v) (conj pr (first v)) r)\n            (recur (rest v) [(first v)] (choose-result r pr))))))))","user":"56228d00e4b03f08ee9a9227"},{"code":"#(loop [streaks []\n     current (vector (first %))\n\t   l (rest %)]\n\t(if (empty? l)\n\t\t(let [longest (apply max-key count (reverse (conj streaks current)))]\n\t\t\t(if (> (count longest) 1) longest []))\n\t\t(let [last (last current)\n\t\t\t  next (first l)]\n\t\t\t(if (> next last)\n\t\t\t\t(recur streaks (conj current next) (rest l))\n\t\t\t\t(recur (conj streaks current) (vector next) (rest l))))))","problem":53,"user":"4fb57e06e4b081705acca2bf"},{"code":"(fn longest [s]\n    (:l (reduce\n            (fn [h r]\n                (if (= 1 (- r (last (h :s ))))\n                    (let [ns (conj (h :s ) r), cnt (count ns)]\n                        (if (and (>= cnt 2) (> cnt (count (h :l ))))\n                            {:l ns :s ns}\n                            (assoc h :s ns)))\n                    (assoc h :s [r])))\n            {:l [] :s [0]} s)))","problem":53,"user":"4f128865535d64f603146428"},{"code":"(fn [xs]\n  (:longest\n   (reduce (fn [result-map i]\n                     (let [{:keys [curr longest]} result-map\n                           new-curr (if-not (last curr)\n                                      [i]\n                                      (if (< (last curr) i)\n                                        (conj curr i)\n                                        [i]) )\n                                      new-longest (if (and (> (count new-curr) (count longest)) (<= 2 (count new-curr)))\n                                                    new-curr\n                                                    longest)]\n                       (assoc result-map :curr new-curr :longest new-longest)))\n           {:longest [] :curr []} xs)))","problem":53,"user":"51281b25e4b03a34742b4304"},{"code":"(fn [s] \n  (#(if (= (count %) 1) [] %)\n  (map second (reduce #(if (> (count %) (count %2)) % %2) (partition-by first (map-indexed #(list (- % %2) %2) s))))\n ))","problem":53,"user":"523b1988e4b02f719975bdbc"},{"code":"(fn [sq]\n  (let\n    [res \n     (first \n       (sort-by\n         #(* -1 (count %)) \n         (reduce \n           (fn [[acc buf] [prev curr]] \n             (if (> curr prev) \n               [acc \n                (conj buf curr)] \n               [(if (> (count buf) (count acc)) buf acc) \n                [curr]])) \n           [[] [(first sq)]] \n           (map (fn [a b] [a b]) sq (rest sq)))))]\n    (if (second res) res [])))","problem":53,"user":"50bfe95ce4b080409b860f27"},{"problem":53,"code":"(fn max-ss [xs]\n  (loop [[x & xs] xs max [] cur []]\n    (let [->max (comp #(or % []) last (partial sort-by count) (partial filter #(> (count %) 1)) vector)\n          cur+ (if (seq cur)\n                 (if (> x (last cur)) (conj cur x) [x])\n                 (conj cur x))]\n      (if (seq xs)\n        (recur xs (->max cur+ max) cur+)\n        (->max cur+ max)))))","user":"5a257747e4b07f18be40aa1f"},{"problem":53,"code":"(fn [coll]\n    (->> \n      (rest coll)\n      (reduce (fn [accum x]\n              (let [[prev xs xs-max] accum]\n                  (if (> x prev)\n                    (let [new-xs (conj xs x)\n                          new-xs-max (if (> (count new-xs) (count xs-max)) new-xs xs-max)]\n                      [x new-xs new-xs-max])\n                    (let [new-xs [x]\n                          new-xs-max (if (> (count xs) (count xs-max)) xs xs-max)]\n                      [x new-xs new-xs-max]))))\n            [(first coll) [(first coll)] []])\n      last\n      (#(if (> (count %) 1) % []))))","user":"5b62764ae4b0c6492753e725"},{"code":"#(->> \n  (loop [i 1\n         cur (vector (% 0))\n         s nil]\n    (cond\n     (= i (count %)) (conj s cur)\n     (= (inc (last cur)) (% i)) (recur (inc i) (conj cur (% i)) s)\n     :else (recur (inc i) [(% i)] (conj s cur))))\n  (filter (fn [x] (>= (count x) 2)))\n  (apply max-key count []))","problem":53,"user":"537f4652e4b06839e8705eb1"},{"problem":53,"code":"(fn longest-consec-seqs [xs]                                           \n  (reduce (fn [acc x]                                                    \n            (if (> (count x) (count acc))    \n              x    \n              acc))    \n          []                                     \n          (filter (fn [x]  \n                    (> (count x) 1))  \n                  (reduce (fn [acc x] \n                            (if (-> acc last last inc (= x))\n                              (conj (pop acc) (conj (last acc) x))\n                              (conj acc (vector x))))\n                          (vector (vector (first xs))) (rest xs)))))","user":"5de68f83e4b0986d99407f6c"},{"code":"(fn [lst]\n  (let [cand (first (reduce (fn [data new-val]\n                              (let [best (first data)\n                                    current (second data)\n                                    increasing (or (= (count current) 0) (< (last current) new-val))\n                                    next-candidate (if increasing (conj current new-val) [new-val])\n                                    next-best (if (< (count best) (count next-candidate)) next-candidate best)]\n                                [next-best next-candidate])) [[] []] lst))]\n    (if (= 1 (count cand)) [] cand)))","problem":53,"user":"51c76864e4b07ef393169e3f"},{"code":"(fn lss [v]\n  (loop [[h & t] v, lsf [], cur []]\n    (if h\n       (if (and t (> (first t) h))\n                (recur t lsf (conj cur h))\n                (if (>= (count cur) (count lsf)) (recur t (conj cur h) []) (recur t lsf [])))\n        (if (next lsf) lsf [])      )))","problem":53,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":53,"code":"#(reduce (fn [acc x] (if (< (count acc) (count x)) x acc)) [] (filter (fn [v] (< 1 (count v))) (reduce (fn [acc x] (cond (empty? acc) [x] (vector? (last acc)) (if (< (last (last acc)) x) (conj (vec (butlast acc)) (conj (last acc) x)) (conj acc [x])) (< (last acc) x) (conj acc x) :else [acc [x]] )) [] %1)))","user":"5659679ae4b068f2fe63dbeb"},{"problem":53,"code":"#(let [l (:longest (reduce (fn [{:keys [current longest] :as res} v]\n            (if (> v (or (last current) -1))\n              {:current (conj current v)\n               :longest (if (> (+ 1 (count current)) (count longest))\n                          (conj current v)\n                          longest)\n               }\n\n              {:current [v]\n               :longest (if (> (count current) (count longest))\n                          current\n                          longest)}))\n          {:longest [] :current []} %))]\n  (if (> (count l) 1)\n    l\n    []))","user":"58c1b4f5e4b021aa9917ed01"},{"code":"(fn [x]\n  (last\n    (reduce \n      (fn [[c l] v]\n        (if (= (dec v) (peek c))\n          (let [c (conj c v)] [c (if (> (count c) (count l)) c l)])\n          (let [c [v]] [c l])))\n      [[][]]\n      x)))","problem":53,"user":"5201cf92e4b0b2e020a18f21"},{"code":"(fn [x]\n(let [\n  s (mapcat #(take-while seq (iterate butlast %)) (take-while seq (iterate rest x)))\n  s (filter #(and (apply < %) (> (count %) 1)) s)]\n  (reduce #(if (> (count %2)(count %)) %2 %) [] s)))","problem":53,"user":"4daa374930acd6ed13482a68"},{"problem":53,"code":"#(loop [l (rest %) res [(first %)] currSeq [(first %)]]\n    (let [f (first l)] (if (nil? f)\n                         (let [tmp (if (> (count currSeq) (count res)) currSeq res)]\n                           (if (> (count tmp) 1) tmp [])\n                           )\n                         (if (= (inc (last currSeq)) f)\n                           (recur\n                             (rest l)\n                             res\n                             (conj currSeq f)\n                             )\n                           (recur\n                             (rest l)\n                             (if (> (count currSeq) (count res)) currSeq res)\n                             [f]\n                             )\n                           )\n                         )\n     )\n    )","user":"5f429fdfe4b0955706451faf"},{"problem":53,"code":";(println (\n(fn [coll]\n (->>\n  (cons 999 coll)\n  (map <= coll)\n  (reduce #(conj %1 (if %2 (not (last %1)) (last %1))) [true])\n  (rest)\n  (map vector coll)\n  (partition-by second)\n  (map #(map first %))\n  (cons [])\n  (remove #(= 1 (count %)))\n  (reverse)\n  (apply max-key count)\n  ))\n  ;[2 3 3 4 5]))","user":"5a4caa20e4b05d388ecb6b94"},{"problem":53,"code":"(fn [s]\n  (let [ln (loop [l [] remain s]\n             (if (> (count remain) 1)\n               (let [longest-starting-seq (fn [s] (loop [ordered [(first s)] remain (rest s)]\n                                                   (if (and (not-empty remain) (< (last ordered) (first remain)))\n                                                     (recur (conj ordered (first remain)) (rest remain))\n                                                     ordered)))\n                     new-long (if (> (count (longest-starting-seq remain)) (count l))\n                                (longest-starting-seq remain)\n                                l)]\n                 (recur new-long (rest remain)))\n               l))\n        ]\n    (if (< (count ln) 2)\n      []\n      ln)))","user":"528c381ce4b0239c8a67aeb2"},{"problem":53,"code":"(fn f ([s](f s 0 0 1 1))\n  ([s gms gmf cm i]\n   \t(\n     if (>= i (count s))(\n     \tif (> cm (inc(- gmf gms)))\n     \t\t(drop (- (count s) cm) s)\n     \t\t(take (if (> gmf gms ) (inc(- gmf gms)) 0) (drop gms s))\n        )                 \n     (\n      if (> (nth s i) (nth s (dec i)))\n      \t(recur s gms gmf (inc cm) (inc i))\n      \t(\n         if (> cm (inc(- gmf gms)))\n      \t\t(recur s (- i cm) (dec i) 1 (inc i))\n      \t\t(recur s gms gmf 1 (inc i))\n          )\n      )\n   \t)\n   )\n  )","user":"56ae4c21e4b03c432f18735c"},{"code":"(comp first (partial reduce\n          (fn [[best current] n]\n            (if (empty? current)\n              [best [n]]\n              (if (= n (inc (last current)))\n                (let [current' (conj current n)]\n                  (if (> (count current') (count best))\n                    [current' current']\n                    [best current']))\n                [best [n]])))\n          [[], []]))","problem":53,"user":"5201ada5e4b0b2e020a18f14"},{"problem":53,"code":"(fn longest-increasing-subsequence [coll]\n  (let [inc-subsequences (reverse (filter\n                                    (fn [coll] (every? (fn [[a b]] (< a b)) (partition 2 1 coll)))\n                                    (for [start (range (count coll))\n                                          end (range (inc (inc start)) (inc (count coll)))]\n                                       (subvec coll start end))))]\n       (if (empty? inc-subsequences)\n         []\n         (apply max-key count inc-subsequences))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn longest-inc [coll]\n  (let [inc? #(apply < %)\n        pair #(map vector % (rest %))\n        join #(concat (map first %) (list (second (last %))))]\n    (if-let [inc-pair-seqs (-> (filter (comp inc? first)\n                                       (partition-by inc? (pair coll)))\n                               reverse\n                               seq)]\n      (join (apply max-key count inc-pair-seqs))\n      (empty coll))))","problem":53,"user":"52ab6de1e4b0c58976d9ac78"},{"code":"(fn [coll] \n  (or ((comp last #(sort-by count %) (fn [coll1] (filter #(> (count %1) 1) coll1)))\n       (reductions (fn [state x]\n                     (if (empty? state) \n                       [x]\n                       (if (= (dec x) (last state))\n                         (conj state x)\n                         [x] ))\n                     ) [] coll))\n      []))","problem":53,"user":"52cc4fd6e4b07d0d72b27360"},{"code":"(fn [s] (->> (count s)\n             (range 2)\n             (mapcat #(partition % 1 s))\n             (filter #(apply < %))\n             vec\n             (cons [])\n             (sort-by #(- (count %)))\n             first))","problem":53,"user":"4fbd24d2e4b081705acca2ff"},{"problem":53,"code":"(fn [l]\n  (loop [best-seq []\n         cur-seq []\n         vmax nil\n         s l]\n    (let [val (first s)]\n      (cond\n        (nil? val) (let [best (if (> (count cur-seq) (count best-seq)) cur-seq best-seq)]\n                     (if (> (count best) 1)\n                       best\n                       []))\n        (or (nil? vmax) (> val vmax)) (recur best-seq (conj cur-seq val) val (rest s))\n        true (recur (if (> (count cur-seq) (count best-seq))\n                      cur-seq\n                      best-seq)\n                    [val] val (rest s))))))","user":"502a5e59e4b09e8f859a9fbc"},{"problem":53,"code":"(fn [v]\n  (->> (partition 2 1 v)\n       (partition-by #(- (second %) (first %)))\n       (filter (fn [[p]] (= -1 (apply - p))))\n       (sort-by count)\n       last\n       flatten\n       distinct\n       sort))","user":"54f26266e4b024c67c0cf8c5"},{"problem":53,"code":"(fn [c]\n  (if (empty? c)\n    (into [] c)\n  \t(let [cons? (fn [c]\n                  (if (empty? c)\n                  \tfalse\n  \t\t\t\t\t(let [length (count c)\n                    \t  max-v (apply max c)\n                      \t  min-v (apply min c)\n                      \t  diff (apply + (range (inc (- max-v min-v))))]\n    \t\t\t(and (apply < c)\n                     (= (apply + (conj c diff)) (* length max-v))))))\n          length (count c)\n          subs (for [x (range length)\n          \t         y (range (- length x))]\n            \t   (take (inc y) (drop x c)))\n          fsubs (filter #(and (> (count %) 1) (cons? %)) subs)\n          max-length (if (empty? fsubs) 0 (apply max (map count fsubs)))]\n    (into [] (first (filter #(= max-length (count %)) fsubs))))))","user":"5c56e264e4b0fb8c5ffd9a39"},{"code":"(fn [coll]\n  (let [seqs (reverse (map #(concat (first %) (map (fn [i] (last i)) (rest %)))\n                        (filter #(every? (fn [ele] (< (first ele) (last ele))) %)\n                          (partition-by\n                            #(< (first %) (last %))\n                            (partition 2 1 coll)))))]\n    (if (empty? seqs)\n      []\n      (apply (partial max-key count) seqs))))","problem":53,"user":"514d7e29e4b019235f6c0587"},{"code":"#(let [da (reduce (fn [x y] (let [a (first x) \n                                 b (second x) \n                                 c (if (or (empty? b) (== (dec y) (last b))) (conj b y) b) \n                                 d (last x)] \n                             (if d \n                                (if (or (empty? a) (== (dec y) (last a)))\n                                  [(conj a y) b true]\n                                  [a [y] false]\n                                  )\n                                (if (or (empty? b) (== (dec y) (last b))) \n                                  [a (conj b y) d]\n                                  (if (> (count b) (count a))\n                                    [b [y] false]\n                                    [a [y] false]\n                                    )\n                                  )\n                                )\n                             )\n                   ) % %2) ru (if (>= (count (first da)) (count (second da)))\n     (first da) \n     (second da)\n     )]\n   (if (> (count ru) 1) ru [])\n   \n   )\n     [[] [] true]","problem":53,"user":"51beb32ae4b013aa0d74b7fd"},{"problem":53,"code":"(fn longest-inc-subseq [coll]\n\t(let [inc-subseq (fn [] ;;I get courage and I tried to make a transducer.Maybe It'snt\n\t\t\t\t\t\t (fn [rf]\n\t\t\t\t\t\t\t (let [a (java.util.ArrayList.)\n\t\t\t\t\t\t\t\t   pv (atom ::none)]\n\t\t\t\t\t\t\t\t (fn\n\t\t\t\t\t\t\t\t\t ([] (rf))\n\t\t\t\t\t\t\t\t\t ([result]\n\t\t\t\t\t\t\t\t\t  (let [result (if (or (.isEmpty a) (= (.size a) 1))\n\t\t\t\t\t\t\t\t\t\t\t\t\t   result\n\t\t\t\t\t\t\t\t\t\t\t\t\t   (let [v (vec (.toArray a))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (.clear a)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (rf result v)))]\n\t\t\t\t\t\t\t\t\t\t   result));; was a pain for me the version of conj in the site do not accept (rf result) thats really it was here \n\t\t\t\t\t\t\t\t\t ([result input]\n\t\t\t\t\t\t\t\t\t  (let [before @pv]\n\t\t\t\t\t\t\t\t\t\t  (reset! pv input)\n\t\t\t\t\t\t\t\t\t\t  (if (= before (dec input))\n\t\t\t\t\t\t\t\t\t\t\t  (do\n\t\t\t\t\t\t\t\t\t\t\t\t  (.add a input)\n\t\t\t\t\t\t\t\t\t\t\t\t  result)\n\t\t\t\t\t\t\t\t\t\t\t  (do\n\t\t\t\t\t\t\t\t\t\t\t\t  (let [v (vec (.toArray a))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (.clear a)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (.add a input)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (if (> (count v) 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (rf result v)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  result))))))))))\n\t\t  fun ((inc-subseq) conj)\n\t\t  candidates (fun (reduce fun [] coll))]\n\t\t(if (empty? candidates)\n\t\t\t[]\n\t\t\t(apply max-key count candidates))))","user":"552bd5c2e4b0ffed3738f969"},{"code":"(fn longest-subseq \n  ([sequ] (longest-subseq sequ ()))\n  ([sequ longest]\n    (let [func (fn [s]\n                 (let [ss (take-while #(< (first %1) (last %1)) (partition 2 1 s))]\n                    (if (empty? ss) () (concat (map first ss) [(last (last ss))]))))\n          sub  (func sequ)]\n      (cond\n        (empty? sequ)       longest\n        (empty? sub)        (longest-subseq (rest sequ) longest)\n        (not (empty? sequ)) (longest-subseq (drop (count sub) sequ) (if (> (count sub) (count longest)) sub longest))))))","problem":53,"user":"5277da8ee4b03e8d9a4a7514"},{"problem":53,"code":"(fn __53 [vi]\n    (let [add-to-result (fn [sv res]\n                          (if (<= 2 (count sv))\n                            (if (seq res)\n                              (if (> (count sv) (count (first res)))\n                                [sv]\n                                res)\n                              (conj res sv)) \n                            res))] \n      (loop [v vi\n             sv []\n             res []]\n        (if (seq v)\n          (if (seq sv)\n            (if (=  (inc (last sv)) (first v))\n              (recur (rest v) (conj sv (first v)) res)\n              (recur v []  (add-to-result sv res)))\n            (recur (rest v) (conj sv (first v)) res))\n          ((comp vec first)  (add-to-result sv res))))))","user":"5151c184e4b03e678e393add"},{"problem":53,"code":"(let [group-by-increasing (fn [[h & t :as v]]\n                              (loop\n                                [vs (list [h])\n                                 ts t]\n                                (if (empty? ts)\n                                  (apply vector (reverse vs))\n                                  (let\n                                    [vh (first vs)\n                                     vt (rest  vs)\n                                     th (first ts)\n                                     tt (apply vector (rest  ts))]\n                                    (recur\n                                      (if (< (last vh) th)\n                                        (conj vt (conj vh th))\n                                        (conj vs [th])\n                                        )\n                                      tt)\n                                    )\n                                  )\n                                )\n                              )\n        sizable-groups (fn [v] (->> v\n                                    group-by-increasing\n                                    (filter #(< 1 (count %)))\n                                    (group-by count)))\n        ]\n    (fn [v]\n      (let [gs (sizable-groups v)]\n        (if (empty? gs)\n          []\n          (first (gs (apply max (keys gs)))))))\n    )","user":"559a9a3de4b066d22e731f45"},{"problem":53,"code":"(fn [coll] (loop [res [], res' [], sub-coll coll]\n                                         (cond\n                                           (empty? sub-coll)\n                                           (if (> (count res) 1)\n                                             res\n                                             []\n                                             )\n                                           :else\n                                           (recur (cond\n                                                    (< (count res) (count res'))\n                                                    res'\n                                                    :else\n                                                    res\n                                                    ) ((fn [coll] (let [len (count (take-while true? (map #(= (inc %1) %2) coll (rest coll))))]\n                                                                    (if (= (count (rest coll)) len)\n                                                                      coll\n                                                                      (take (inc len) coll)\n                                                                      )\n                                                                    )\n                                                         ) sub-coll\n                                                       ) (rest sub-coll))\n                                           )\n                                         )\n                              )","user":"5cf72682e4b0b71b1d808a68"},{"code":"#(apply max-key count\n         (map distinct\n              (map flatten\n                   (partition-by \n                    empty? \n                    (map \n                     (fn [[a b]] (if (= 1 (- b a)) [a b] []))\n                     (partition 2 1 %))))))","problem":53,"user":"52aad30ce4b0c58976d9ac6d"},{"code":"(fn [l]\n  (letfn [(longest [x y]\n                   ; returns the longest from two sequences\n                   (if (< (count x) (count y)) y x))\n          (scan [s x lx l]\n                ; returns the longest increasing sub-seq\n                ; @s - current longest\n                ; @x - accumulator\n                ; @lx - last item in accum\n                ; @l - source seq\n                (if (empty? l)\n                  (longest s x)\n                  (let [[hl & tl] l]\n                    (if (= 1 (- hl lx))\n                      (scan s (conj x hl) hl tl)\n                      (scan (longest s x) [hl] hl tl)))))]\n    (let [[hl & tl] l\n          result (scan [] [hl] hl tl)]\n      ; singleton-seq cannot be increasing\n      (if (> (count result) 1)\n        result\n        []))))","problem":53,"user":"515ead6be4b049add99a053e"},{"code":"(fn [s]\n  (let\n    [x (last\n         (sort-by\n           count\n           (reduce\n             (fn [x y]\n               (if (= (last (last x)) (dec y))\n                 (conj (vec (butlast x)) (conj (last x) y))\n                 (conj x [y])))\n             [[(first s)]]\n             (rest s))))]\n    (if (> 2 (count x))\n      []\n      x)))","problem":53,"user":"50d8de3fe4b01f0871336e72"},{"code":"(fn [x] \n     (loop [c x\n            r []\n            s []]\n           (let [[p d] c]\n                (if (empty? c)\n                   (reduce #(if (> (count %) (count %2)) % %2 ) r)\n                  (if (= d (inc p))\n                    (recur (rest c) r (if (empty? s) (conj s p d)(conj s d) ))\n                    (recur (rest c) (conj r s) [] )))\n        )\n      )\n)","problem":53,"user":"4e6dd0f5535d5021c1a895f3"},{"problem":53,"code":"(fn [s]\n   (let [winner\n         (fn [candidate result]\n             (if\n               (and\n                (> (count candidate) (count result)) ;Don't shorten into > (count candidate) (count result) 1, because initially result is empty.\n                (> (count candidate) 1))\n               candidate\n               result))]\n     (loop [s s result [] candidate []]\n          (if (empty? s)\n            (winner candidate result)\n            (if (empty? candidate)\n              (recur (drop 1 s) result [(first s)])\n              (let [sFirst (first s)]\n                (if (> sFirst (last candidate))\n                  (recur (drop 1 s) result (concat candidate (list sFirst)))\n                  #_ \"else_capture_candidate_if_winner_and_restart_the_search. However, that doesn't capture if the winner is the tail.\"\n                  (recur (drop 1 s) (winner candidate result) [sFirst]))))))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":53,"code":"(fn [coll]\n  (let [take-seq (fn [n pred coll]\n                   (let [hits (count (take-while #(apply pred %) (partition n 1 coll)))]\n                     (take (+ n hits -1) coll)))\n        chop (fn [coll] (for [n (range (count coll))] (drop n coll)))\n        parts (chop coll)\n        seqs (map (partial take-seq 2 #(= (inc %1) %2)) parts)\n        longest (apply max-key count seqs)]\n    (if (>= (count longest) 2)\n      longest\n      []\n      )))","user":"5e8ce2fee4b0cb0169546328"},{"problem":53,"code":"(fn [s]\n  (let [{:keys [current-run longest-run]}\n        (reduce (fn [{:keys [current-run longest-run] :as dat} e]\n                  (if (and (seq current-run)\n                           (> e (last current-run)))\n                    (assoc dat :current-run (conj current-run e))\n                    {:current-run [e]\n                     :longest-run (if (> (count current-run)\n                                         (count longest-run))\n                                    current-run\n                                    longest-run) }))\n                {:current-run []\n                 :longest-run []}\n                s)\n        run\n        (if (> (count current-run)\n               (count longest-run))\n          current-run\n          longest-run)]\n    (if (> (count run) 1)\n      run\n      [])))","user":"580bd81ee4b0849f6811b711"},{"code":"(fn longest-increasing-sub-Seq [v]\n  ((comp  \n    #(if (empty? %) [] (last %))\n    (partial sort-by count)\n    (partial filter #(> (count %) 1))\n\n    #(conj (first %) (last %))\n    (partial reduce\n\n     (fn [[a,t] i]\n       (if (= (dec i) (last t))\n         [a,(conj t i)] [(conj a t),[i]]))\n\n     [[],[(first v)]])\n\n    ) (rest v)))","problem":53,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(let [longest-increasing-subseq-from-start (fn [seqn]\n                                             (if (empty? seqn)\n                                               []\n                                               (loop [nseq (rest seqn)\n                                                      issq [(first seqn)]\n                                                      x    (first seqn)]\n                                                 (if (empty? nseq)\n                                                   issq\n                                                   (let [y (first nseq)]\n                                                     (if (< x y)\n                                                       (recur (rest nseq) (conj issq y) y)\n                                                       issq))))))\n\n      tails* (fn [seqn]\n               (take-while #(not (empty? %))\n                           (iterate rest seqn)))\n\n      longest-increasing-subseq (fn [seqn]\n                                  (let [candidate (reduce (fn [old new-seq]\n                                                            (let [new-issq (longest-increasing-subseq-from-start new-seq)]\n                                                              (if (< (count old) (count new-issq))\n                                                                new-issq\n                                                                old)))\n                                                          []\n                                                          (tails* seqn))]\n                                    (println candidate)\n                                    (if (>= (count candidate) 2)\n                                      candidate\n                                      [])))]\n  longest-increasing-subseq)","problem":53,"user":"53889587e4b0640c7a9a589e"},{"problem":53,"code":"(fn [x] \n\t(->> (reduce (fn [ss el] (cond (nil? (last ss)) [[el]]\n\t                          (= (inc (last (last ss))) el) (conj (vec (drop-last ss)) (conj (last ss) el))\n\t                          :else (conj ss [el]))) [] x)\n         (map (fn [x] (if (< 1 (count x)) x [])))\n         (sort-by count)\n         (last)))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [coll] \n  (loop [c coll r [] a []] \n    (if (empty? c) \n      (reduce #(if (< (count %1) (count %2)) %2 %1) a)\n      ;(println a)\n      (if (empty? (rest c))\n        (recur (rest c) [] (conj a (if (empty? r) r (if (< (last r) (first c)) (conj r (first c)) r))))\n        (if (< (first c) (second c))\n          (recur (rest c) (conj r (first c)) a)\n          (recur (rest c) [] (if (empty? r) (conj a []) (conj a (conj r (first c)))))))\n      )))","problem":53,"user":"52b43468e4b0c58976d9ad1b"},{"problem":53,"code":"(fn [input]\n  (letfn [(f [ls tmp acc]\n            (cond\n             (empty? ls) (conj acc tmp)\n             (empty? (rest ls)) (f (rest ls) (conj tmp (first ls)) acc)\n             (>= (first ls) (second ls)) (f (rest ls) [] (conj acc (conj tmp (first ls))))\n             :else (f (rest ls) (conj tmp (first ls)) acc)))]\n    (let [subseqs (filter #(> (count %) 1) (f input [] []))]\n      (if (empty? subseqs)\n        []\n        (some (fn [xs] (when (= (count xs) (apply max (map count subseqs))) xs))\n              subseqs)))))","user":"547584d9e4b0c51c1f4d729b"},{"code":"(fn liss [coll]\n  (loop [lsf    []\n         curr   []\n         prev   nil\n         coll   coll]\n    (if (seq coll)\n      (let [h     (first coll)\n            r     (rest coll)\n            c     (count curr)]\n        (if (and (not (nil? prev)) (> h prev))\n          (recur lsf (conj curr h) h r)\n          (recur (if (and (> c 1)\n                          (> c (count lsf)))\n                   curr\n                   lsf)\n                 [h]\n                 h\n                 r)))\n      (if (and (> (count curr) 1) (> (count curr) (count lsf))) curr lsf))))","problem":53,"user":"4e5914e0535d8a8b8723a29b"},{"code":"(fn [s]\n  (let [increasing? (fn [xs] (apply < xs))\n        n (count s)\n        sub-seqs (mapcat #(partition % 1 s) (range 2 (inc n)))]\n    (->> sub-seqs\n         (filter increasing?)\n         (cons [])\n         (sort-by count >)\n         first)))","problem":53,"user":"4f3d83b5e4b0e243712b1f69"},{"code":"(fn [seq]\r\n  (let [res\r\n  (apply\r\n   max-key\r\n   count\r\n   (reverse\r\n    (reduce\r\n     #(if (= (inc (last (last %))) %2)\r\n        (conj % (conj (last %) %2))\r\n        (conj % [%2]))\r\n     [[(first seq)]]\r\n     (rest seq))))]\r\n  (if (>= (count res) 2) res [])))","problem":53,"user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"(fn [coll]\n  (let [seqs (let [prev (atom Integer/MIN_VALUE)\n                   change (atom true)]\n               (partition-by (fn [x] \n                               (let [p @prev\n                                     _ (reset! prev x)]\n                                 (reset! change (and (<= x p) (not @change))))) coll))\n        max-seq-size (apply max (map count seqs))]\n    (or (first (filter #(and (= (count %) max-seq-size) (> (count %) 1)) seqs)) [])))","problem":53,"user":"527c166de4b03e8d9a4a75b3"},{"problem":53,"code":"(fn f [col]\n  (loop [col col\n         tmp []\n         longest []]\n     (cond\n       (empty? col)\n         (if (= (count longest) 1) [] longest)\n       :otherwise\n         (let [next_element (first col)\n               new_tmp (if (empty? tmp) (into [] [next_element])\n                                        (if (> next_element (last tmp))\n                                          (into tmp [next_element])\n                                          (into [] [next_element])))]\n           (if (> (count new_tmp) (count longest))\n             (recur (rest col) new_tmp new_tmp)\n             (recur (rest col) new_tmp longest))))))","user":"524b827ce4b09eba1c0223d7"},{"problem":53,"code":"(fn longest-increasing-subsequence [s]\n  (let [[mi mj] ((fn helper [c mi mj i j n]\n                   (if (or (> i n) (> j n))\n                     [mi mj]\n                     (if (> (nth s j) (nth s (dec j)))\n                       (if (> (- j i) c)\n                         (helper (- j i) i j i (inc j) n)\n                         (helper c mi mj i (inc j) n))\n                       (helper c mi mj j (inc j) n))))\n                 0\n                 0\n                 -1\n                 0\n                 1\n                 (dec (count s)))]\n    (drop mi (take (inc mj) s))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn [coll]\n  (let [get-longest\n        (fn [x y] \n          (let [longest (if (> (count x) (count y)) x y)]\n            (if (< (count longest) 2) [] longest)))]\n                 \n  (loop \n    [current [(first coll)]\n     longest []\n     c coll\n     rc (rest coll)]\n    (if (empty? rc)\n      (get-longest current longest)\n      (if (> (first rc) (first c))\n        (recur (conj current (first rc)) longest (rest c) (rest rc))\n        (recur [(first rc)] (get-longest current longest)\n          (rest c) (rest rc)))))))","problem":53,"user":"4f215350e4b0d66497709fd0"},{"code":"(fn longest-inc-sub-seq \n     ([src]\n       (longest-inc-sub-seq src [] []))\n     ([src result temp]\n       (let [sizeT (count temp) sizeR (count result) item (first src) others (rest src)]\n         (cond (empty? src) (if (> sizeT sizeR 1) temp result)\n               (empty? temp) (recur others result [item])\n               (> item (last temp)) (recur others result (conj temp item))\n               (< sizeT 2) (recur others result [item])\n               (< sizeR sizeT) (recur others temp [item])\n               :else (recur others result [item])))))","problem":53,"user":"52479487e4b05ef8e38e6373"},{"problem":53,"code":"(fn longest-increasing-seq\n  [coll]\n  (->> (partition 2 1 coll)\n       (partition-by (fn [[a b]] (> b a)))\n       (map #(conj (into [] (map first %)) (last (last %))))\n       (filter (fn [[a b]] (> b a)))\n       (reduce (fn [a b] (if (> (count b) (count a)) b a)) [] )))","user":"567c7fefe4b05957ce8c61bc"},{"problem":53,"code":"(fn longest-increasing-subsequence\n  [v]\n  (->> (for [start-index (range (count v))\n             l (range 0 (inc (- (count v) start-index)))]\n         (take l (drop start-index v)))\n       (filter \n        (fn is-increasing \n          [s]\n          (loop [numbers (rest s)\n                 last-number (first s)]\n            (cond\n             (not (seq numbers)) true\n             (> (first numbers) last-number)\n             (recur (rest numbers) (first numbers))))))\n       (remove #(= (count %) 1))\n       (sort #(> (count %1) (count %2)))\n       (first)))","user":"53b952eee4b047364c0444e6"},{"problem":53,"code":"#(let [candidates  (reduce (fn [coll e]\n                              (let [last-coll (last coll)\n                                    last-e (last last-coll)]\n                                (if (= (dec e) last-e)\n                                  (conj coll (conj last-coll e))\n                                  (conj coll [e])))) [[]] %)]\n    (if (some (fn [e] (> (count e) 1)) candidates) \n        (apply max-key count (reverse candidates ))\n        []))","user":"52fa250ee4b047fd55836ff3"},{"problem":53,"code":"(fn longest-inc-sub-seqs [coll]\n  (->> coll\n    (map-indexed #(vector (- %2 %1) %2))\n    (partition-by first)\n    (apply max-key count)\n    (#(if (> (count %) 1) % '()))\n    (map second)))","user":"581b19e7e4b04b46fc4b0ec4"},{"problem":53,"code":"(fn [coll]\n  (->>\n   (loop [acc [] prev nil curr (first coll) coll coll]\n     (if\n       (nil? curr)\n       acc\n       (let [new-coll? (or (nil? prev) (not= curr (inc prev)))]\n         (recur\n          (if\n            new-coll?\n            (conj acc [curr])\n            (conj (into [] (drop-last acc)) (conj (last acc) curr)))\n          curr\n          (first coll)\n          (rest coll)))))\n   (sort-by count)\n   last\n   vector\n   (filter #(> (count %) 1))\n   flatten))","user":"58d2af83e4b03c36ff7e5907"},{"code":"#(loop [[f & r] %1, l [], res []]\n  (cond (nil? f) res\n        (= (dec f) (last l)) \n        \t(let [new-l (conj l f)]\n              \t(recur r new-l \n\t\t\t\t\t(if (> (count new-l) (count res)) new-l res)))\n        :else (recur r [f] res)))","problem":53,"user":"53300924e4b019098a6f8b55"},{"problem":53,"code":"(fn [ss]\n  (loop [s (next ss) mn 0 ms [(first ss)] cs [(first ss)]]\n    (println s mn ms cs)\n    (if (nil? s)\n      (if (= (count ms) 1) [] ms)\n      (let [fv (first s) lv (last cs)]\n        (if (> fv lv)\n          (if (> (count cs) mn)\n            (recur (next s)(inc mn) (conj cs fv) (conj cs fv))\n            (recur (next s) mn ms (conj cs fv)))\n          (recur (next s) mn ms [fv]))))))","user":"54b04708e4b09f271ff37d11"},{"problem":53,"code":"(fn [lst]\n  (let [size (count lst)\n        subsets (for [i (range 0 size) j (range (+ i 2) (inc size))] (subvec lst i j))\n        dedup (fn [lst] (map first (partition-by identity lst)))\n        increasing? #(and (= (sort %) %) (= (dedup %) %))]\n    (->> subsets\n         ;;(print-cont)\n         (filter increasing?)\n         ;;(print-cont)\n         (sort-by #(* -1 (count %)))\n         ;;(print-cont)\n         (#(nth % 0 []))\n    )\n    ))","user":"6004c750e4b074f607df6645"},{"problem":53,"code":"(fn part_sub [coll]\n  (->> (partition 2 1 coll) \n    (partition-by #(- (second %) (first %))) \n    (filter #(= 1 (- (second (first %)) (ffirst %)))) \n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n    flatten\n    distinct))","user":"574ed2f7e4b02ea11479924a"},{"code":"(fn [coll]\n  (let [irange (range 0  (count coll))]\n    (->>\n      (for [i irange j irange :when (> j i)] (drop i (take (inc j) coll)))\n      (filter #(and (<= 2 (count %)) (apply < %)))\n      (#(if (empty? %) [[]] %))\n      reverse\n      (apply max-key count))))","problem":53,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"code":"#(let [res (reduce (fn [a b] (if (> (count b) (count a)) b a)) \n                    (reductions (fn [lis new] \n                                  (if (> new (last lis)) \n                                    (conj lis new) \n                                    [-1 new])) \n                                [-1] %))]\n   (if (> (count res) 2) (rest res) []))","problem":53,"user":"52b02329e4b0c58976d9acc5"},{"code":"(fn [c]\r\n  (->> (partition 2 1 c) \r\n    (partition-by #(- (second %) (first %))) \r\n    (filter #(= 1 (- (second (first %)) (ffirst %)))) \r\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\r\n    (flatten)\r\n    (distinct)))","problem":53,"user":"4dc986d0535d5973398f9285"},{"problem":53,"code":";; from https://github.com/leontalbot/4clojure\n(fn [coll] \n  (let [inc-pairs-lists (partition-by #(apply < %) (partition 2 1 coll))\n        mono-inc-pairs-lists (filter (fn [[[x1 x2]]] (< x1 x2)) inc-pairs-lists)\n        longest-mono-inc-pairs-list (first (sort-by count > mono-inc-pairs-lists))] \n   (vec (concat (first longest-mono-inc-pairs-list)\n                (map last (rest longest-mono-inc-pairs-list))))))","user":"568e1871e4b0dcc4269f40cc"},{"code":"(fn [s]\n  (let [res (last \n             (sort-by count \n               (filter #(> (count %) 1) \n                 (reduce \n                  (fn [s i] (if (empty? s) [[i]] \n                                (if (= (last (first s)) (dec i)) \n                                  (cons (conj (first s) i) (rest s)) \n                                  (cons [i] s)))) [] s))))]\n    (if (nil? res)\n      []\n      res)))","problem":53,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn [s]\n  ((fn f [s longest cur l]\n  \t (let [x (first s) r (rest s) \n\t   longest (if (< (count longest) (count cur)) cur longest)\n\t\t]\n      (cond (empty? s) (if (= (count longest) 1) [] longest)\n\t\t   (= l (dec x)) (f (rest s) longest (conj cur x) x)\n\t\t\t:else (f (rest s) longest [x] x)\n\t   )\n  \t )\n  ) (rest s) [(first s)] [(first s)] (first s)) \n  \n)","problem":53,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":53,"code":"#_(fn [coll]\n    (loop [longest-sub-seq []\n           sub-seq []\n           coll coll]\n      (let [elt (first coll)]\n        (if (and elt\n                 (seq sub-seq)\n                 (> elt (peek sub-seq)))\n          (recur longest-sub-seq\n                 (conj sub-seq elt)\n                 (rest coll))\n          (let [longest-sub-seq (if (and (> (count sub-seq) (count longest-sub-seq))\n                                         (> (count sub-seq) 1))\n                                  sub-seq\n                                  longest-sub-seq)]\n            (if elt\n              (recur longest-sub-seq\n                     [elt]\n                     (rest coll))\n              longest-sub-seq))))))\n\n(fn [coll]\n  (let [runs (->> coll\n               (partition 2 1)\n               (partition-by #(apply < %))\n               (filter #(apply < (first %))))]\n    (if (seq runs)\n      (let [longest-run (reduce #(if (> (count %2) (count %1)) %2 %1) runs)]\n        (conj (mapv first longest-run) (second (last longest-run))))\n      [])))","user":"575cbe44e4b02ea114799374"},{"code":"(fn f [s]\n  (let [conj-to-last (fn [v x]\n                       (let [lastidx (dec (count v))]\n                         (update-in v [lastidx] #(conj % x))))\n        inc-seqs (filter #(> (count %) 1)\n                         (loop [seqs []\n                                s s]\n                           (if-not (seq s)\n                             seqs\n                             (let [a (first s)]\n                               (recur (if (= (dec a) (last (last seqs)))\n                                        (conj-to-last seqs a)\n                                        (conj seqs [a]))\n                                      (rest s))))))]\n    (if (seq inc-seqs)\n      (apply max-key count inc-seqs)\n      [])))","problem":53,"user":"52d3f666e4b09f7907dd1327"},{"problem":53,"code":";(fn [coll]\n;\t(loop [src (rest coll) \n;\t\t   dst (vector (first coll))\n;\t\t   r []]\n;\t\t;(println src dst)\n;\t\t(if (empty? src)\n;\t\t\t(if (> (count dst) (count r))\n;\t\t\t\t(recur src dst dst)\n;\t\t\t \t(if (> (count r) 1)\n;\t\t\t\t\tr\n;\t\t\t\t\t[]))\n;\t\t\t(if (> (first src) (last dst))\n;\t\t\t\t(recur (rest src) (conj dst (first src)) r)\n;\t\t\t\t(if (> (count dst) (count r))\n;\t\t\t\t\t(recur (rest src) (vector (first src)) dst)\n;\t\t\t\t\t(recur (rest src) (vector (first src)) r))))))\n\n(fn [xs]\n\t(let [seqs (reduce\n\t\t\t\t\t(fn [acc x]\n\t\t\t\t\t\t(let [cur (peek acc) \n\t\t\t\t\t\t\t  pre (pop acc)]\n\t\t\t\t\t\t\t(if (or (empty? cur) (< (last cur) x))\n\t\t\t\t\t\t\t\t(conj pre (conj cur x))\n\t\t\t\t\t\t\t\t(conj acc [x]))))\n\t\t\t\t\t[[]] xs)]\n\t\t(->> (conj seqs []) \n\t\t\t (reverse) \n\t\t\t (remove #(= 1 (count %1))) \n\t\t\t (apply max-key count))))","user":"55b8c339e4b01b9910ae29b9"},{"problem":53,"code":"#(->> %\n  (reductions (fn [acc curr] (if (= (last acc) (dec curr)) (conj acc curr) [curr])) [])\n  (remove (fn [x] (< (count x) 2)))\n  (sort-by count)\n  (last)\n  (vec))","user":"5ebd7296e4b00a66d4a95273"},{"code":"(fn [in]\n  (loop [v (rest in) longest [(first in)] curr [(first in)]]\n    (if (empty? v)\n      (if (= (count longest) 1) [] longest)\n      (if (> (first v) (last curr))\n        (let [curr (conj curr (first v))]\n          (if (> (count curr) (count longest))\n            (recur (rest v) curr curr)\n            (recur (rest v) longest curr)))\n        (recur (rest v) longest [(first v)])))))","problem":53,"user":"532a111ee4b09d4e7a9b5520"},{"code":"(fn [xs]\n (let [ys (map-indexed (fn [i e] [i e]) xs)\n       r  (map last (last (sort-by count (partition-by (fn [[i e]] (- e i)) ys))))]\n   (if (> (count r) 1) r [])))","problem":53,"user":"5097b556e4b00ad8bab4e970"},{"problem":53,"code":"(fn [xs]\n  (loop [res []\n         cur [(first xs)]\n         ys xs]\n    (cond\n     (empty? ys)\n     (if (and (> (count cur) (count res))\n              (>= (count cur) 2))\n       cur\n       res)\n\n     (< (last cur) (first ys))\n     (recur res\n            (conj cur (first ys))\n            (rest ys))\n\n     :else\n     (recur (if (and (> (count cur) (count res))\n                     (>= (count cur) 2))\n              cur\n              res)\n            [(first ys)]\n            (rest ys)))))","user":"55c4e48be4b0e31453f649a7"},{"problem":53,"code":"(fn [coll]\n  (let [reducs (reductions\n                (fn [acc val] (if (or (empty? acc ) (<= val (last acc))) [val] (conj acc val)))\n                [] coll)\n        longest (->> reducs\n                    (group-by count)\n                    vals\n                    last\n                    first)]\n    (if (< 1 (count longest)) longest [])))","user":"5d97b602e4b0d3f9b434ad3a"},{"code":"(fn [l]\n  (loop [result [] current [] l l]\n    (if (seq l)\n      (if (seq current)\n        (if (= (inc (last current)) (first l))\n          (let [new-current (conj current (first l))]\n            (if (> (count new-current) (count result))\n              (recur new-current new-current (rest l))\n              (recur result new-current (rest l))))\n          (recur result [(first l)] (rest l)))\n        (recur result [(first l)] (rest l)))\n      (if (>= (count result) 2)\n        result\n        []))))","problem":53,"user":"50b1d166e4b03ea880433554"},{"problem":53,"code":"(fn [v] (let [x (map count (#(partition-by identity (map - % (range (count %)))) v)) y ((fn [a] (first (keep-indexed #(if (= (apply max a) %2) %) a))) x) z (cons 0 (reductions + x)) xx (drop (nth z y) (take (nth z (inc y)) v))] (if (> (count xx) 1) xx [])))","user":"533f1584e4b085b17e897d9b"},{"problem":53,"code":"(fn [sq]\n          (loop [n1 (first sq)\n                 sq (rest sq)\n                 longest []\n                 subsq [n1]]\n            (if (empty? sq)\n              longest\n              (let [n2 (first sq)]\n                (println n1 n2 (== (inc n1) n2) (conj subsq n2))\n                (if (== (inc n1) n2)\n                  (let [subsq (conj subsq n2)]\n                    (recur n2 (rest sq)\n                           (if (and (> (count subsq) (count longest))\n                                    (> (count subsq) 0))\n                             subsq\n                             longest)\n                           subsq))\n                  (recur n2 (rest sq) longest [n2]))))))","user":"5c995fa4e4b048ec896c5a96"},{"code":"(letfn [(get-growing ([s] (get-growing s [] []))\n                    ([s r prs] (cond (empty? s) (if (> (count r) 1) (conj prs r) prs)\n                                     (empty? r) (recur (rest s) (conj r (first s)) prs)\n                                     (> (first s) (last r)) (recur (rest s) (conj r (first s)) prs)\n                                     :else (recur s [] (if (> (count r) 1) (conj prs r) prs)))))\n        (sel-max [coll]\n          (if (not (empty? coll))\n            (reduce (fn [a b] (if (> (count b) (count a)) b a)) coll)\n            []))]\n  #(sel-max (get-growing %1)))","problem":53,"user":"4dadc27ec9a9d6ed3c99dc57"},{"problem":53,"code":"#(loop [a [(first %)]\n        b []\n        s (rest %)]\n   (if (empty? s)\n     (cond\n       (and (< (count a) 2) (< (count b) 2)) []\n        (> (count a) (count b)) a\n        :else b)\n     (recur (if (= (inc (last a)) (first s))\n              (conj a (first s))\n              [(first s)])\n          \t(if (> (count a) (count b))\n              a\n              b)\n            (drop 1 s))))","user":"57ec3d29e4b0bfb2137f5b77"},{"problem":53,"code":"#(loop [ [x & xs] %\n           curr []\n           max []]\n    (let [curr (if (and (seq curr) (> x (last curr)))\n                 (conj curr x)\n                 [x])\n          n (count curr)\n          b (and (> n 1) (< (count max) n))]\n       (if (seq xs)\n         (if b\n           (recur xs curr curr)\n           (recur xs curr max))\n         (if (and b)\n           curr\n           max))))","user":"524025bce4b0ad64fa01030f"},{"code":"(fn [s]\n    ((fn [s a best]\n        (if (empty? s)\n            (if (> (count best) 1)\n                (reverse best)\n                [])\n            (if (> (first s) (first a))\n                (let [newa (cons (first s) a)]\n                  (recur (rest s)\n                          newa\n                          (if (> (count newa)\n                                  (count best))\n                              newa\n                              best)))\n                (recur (rest s) (list (first s)) best))))\n    (rest s) [(first s)] [(first s)]))","problem":53,"user":"4f404dcee4b0e243712b1fb0"},{"problem":53,"code":"(letfn [(f [maxrun thisrun xs]\n          (if (empty? xs) (if (and (> (count thisrun) 1) (< (count maxrun) (count thisrun))) thisrun maxrun)\n              (if (and (not (empty? thisrun)) (< (last thisrun) (first xs)))\n                (recur maxrun (conj thisrun (first xs)) (rest xs))\n                (recur (if (and (> (count thisrun) 1) (< (count maxrun) (count thisrun))) thisrun maxrun) [(first xs)] (rest xs)))))]\n  (partial f [] []))","user":"554b9c3ee4b0a04f79299594"},{"code":"(fn [s] \n    (->>\n      (for [a (range (count s)) \n            b (range (inc a) (count s))]\n        (subvec s a (inc b)))\n      (filter #(apply < %))\n      (sort-by count >)\n      first\n      vec))","problem":53,"user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [n]\n    (let [seqs  (reduce (fn [[[f & r :as f_l]\n                             & rr  :as t_l] n]\n                          (if (= 1 (- n (if f f 0)))\n                            (cons (cons n f_l) rr)\n                            (cons (list n) t_l)\n                            )) '(()) n)\n\n          candi (reverse (apply (partial max-key count) seqs ))\n          \n          ]\n\n      (if (>= (count candi) 2) candi [])\n      ))","problem":53,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n       (map (comp (complement pos?) #(apply - %) reverse))\n       (replace {true 1 false 0})\n       (reductions #(apply + %&) 0)\n       (map vector coll)\n       (partition-by second)\n       (map #(map first %))\n       (remove #(= (count %) 1))\n       (reduce #(if (>= (count %1) (count %2)) %1 %2) [])))","problem":53,"user":"53315c78e4b019098a6f8b67"},{"problem":53,"code":"(fn [col]\n  (loop [i 0 s1 [] s2 []] \n    (if (< i (count col)) \n      (recur (inc i) \n             (if (= (last s1) (dec (col i))) \n               (conj s1 (col i))\n               (conj [] (col i)))\n             (if (> (count s1) (count s2)) \n               s1 \n               s2))\n      (if (> (count s1) (count s2)) (if (> (count s1) 1) s1 []) (if (> (count s2) 1) s2 [])))))","user":"5243e37ae4b076204b44fae3"},{"problem":53,"code":"(fn f\n   ([a] (f a [] [] -1))\n   ([a c b p]\n    (let [r (if (> (count c) (count b)) c b)]\n      (if (empty? a) (if (< (count r) 2) [] r)\n        (if (> (first a) p) (f (rest a) (concat c [(first a)]) r (first a))\n                            (f (rest a) [(first a)] r (first a)))))))","user":"59e8bb43e4b0249b72820735"},{"problem":53,"code":"(fn [items]\n  (let [result (last (sort-by count\n  (#(reductions (fn [coll n] (if (= n (inc (last coll)))\n                   (conj coll n)\n                   [n])) [(first %)] (rest %)) items)))]\n    (if (>= (count result) 2)\n      result\n      [])))","user":"57f8ba80e4b0d3187e90092f"},{"code":"(fn [input]\n  (vec (first\n    (sort-by #(- (count %))\n      (filter #(> (count %) 1)\n        (loop [v (rest input) r [[(first input)]]]\n          (if (empty? v)\n            r\n            (if (> (first v) (last (last r)))\n              (recur (rest v) (conj (vec (butlast r)) (conj (last r) (first v))))\n              (recur (rest v) (conj r [(first v)]))))))))))","problem":53,"user":"512d3304e4b040332b905b2d"},{"code":"(fn [xxs]\r\n  (loop [xxs xxs rise [] best []]\r\n    (if (empty? xxs)\r\n      (if (> (count best) 1) best [])\r\n      (let [[x & xs] xxs]\r\n        (if (or (empty? rise) (> x (last rise)))\r\n          (recur xs (conj rise x)\r\n                 (if (>= (count rise) (count best))\r\n                    (conj rise x)\r\n                   best))\r\n          (recur xs [x] (if (= (count best) 0) [x] best)))))))","problem":53,"user":"4ddc1c89535d02782fcbea01"},{"problem":53,"code":"#(reduce\n    (fn [cur next] (if (and (> (count next) 1) (> (count next) (count cur)) ) next cur)) []\n    (reduce\n      (fn [col el]\n        (if (or (nil? (last (last col)))(> el (last (last col))))\n          (reverse (conj (butlast col)\n                         (conj (last col) el)))\n          (reverse (conj col [el])))) [[]] %1))","user":"5f0a4904e4b09a3f05b71805"},{"problem":53,"code":"(fn [s] (or (first (for [l (reverse (range 2 (count s)))\n                         f (filter #(apply < %) (partition l 1 s))]\n                     f)) []))","user":"5c379636e4b0d62ef62d9f76"},{"problem":53,"code":"(fn find-longest-increasing-seq [s]\n\t\t(letfn [(longer [a b]\n\t\t\t\t\t(if (< (count a) (count b)) b a))\n\n\t\t\t\t(split-seqs [pred acc y]\n                            (let [x (last (last acc))]\n                              (if (pred x y)\n                                (conj (pop acc) (conj (last acc)  y))\n                                (conj acc [y])\n                                ))\n                            )\n\t\t\t\t(find-seqs [pred s]\n\t\t\t\t\t(reduce (partial split-seqs pred) [[(first s)]] (rest s)))\n\t\t\t\t\t\t]\n                (let [longest (reduce longer [] (find-seqs < s))]\n                  (if (= 1 (count longest))\n                    []\n                    longest)\n                  )\n\t\t\t\t)\n\t\t)","user":"54ff6084e4b07d26eda61d50"},{"problem":53,"code":"(fn [l]\n  (loop [tmpl (rest l) ans (list (first l)) c 1 fans (list (first l)) fc 1]\n    (if (and (empty? tmpl) (< fc 2))\n      '()\n      (if (and (empty? tmpl) (> c fc))\n        (reverse ans)\n        (if (empty? tmpl)\n        \t(reverse fans)\n        \t(if (= (first ans) (dec (first tmpl)))\n        \t\t(recur (rest tmpl) (conj ans (first tmpl)) (inc c) fans fc)\n        \t\t(if (> fc c)\n        \t\t\t(recur (rest tmpl) (list (first tmpl)) 1 fans fc)\n        \t\t\t(recur (rest tmpl) (list (first tmpl)) 1 ans c))))))))","user":"59368ccae4b02506e01a297a"},{"code":"(fn f[ss]\n  (loop [[x & xs] (rest ss) ax {0 []} cx [(first ss)] prev (dec (first ss))]\n    (if-not (nil? x)\n      (let [ax' (if (< prev x) ax (assoc ax (count cx) (ax (count cx) cx)))\n            cx' (if (< prev x) (conj cx x) [x])]\n        (recur xs ax' cx' x))\n      (let [ax' (assoc ax (count cx) (ax (count cx) cx))]\n        (->>\n         ax'\n         (remove #(= (first %) 1))\n         (sort-by first)\n         last     \n         second)))))","problem":53,"user":"51efd397e4b0249c592fbdeb"},{"code":"(fn max-inc-subseq [v]\n  (loop [v_ v acc [] max []]\n    (do (println (first v_) \" \" (last acc) \" \" acc \" \" max)\n      (cond\n      (empty? v_) max\n      (empty? acc) (recur (rest v_) \n                          (conj acc (first v_)) \n                          max)\n      (= (inc (last acc)) (first v_)) (recur (rest v_) \n                                             (conj acc (first v_)) \n                                             (if (>= (count acc) (count max)) (conj acc (first v_)) max))\n      :else (recur (rest v_) \n                   [(first v_)] \n                   max)))))","problem":53,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn [coll]\n  (->> \n    (partition 2 1 coll) \n    (partition-by #(- (second %) (first %)))\n    (filter #(= 1 (- (second (first %)) (ffirst %))))\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\n    flatten \n    distinct))","problem":53,"user":"4e894068535d4ef0aa30db97"},{"problem":53,"code":"(fn f\n    ([s] (f s [] []))\n    ([s c t]\n       (if (empty? s)\n         c\n         (if (empty? t)\n           (f (rest s) [] [(first s)])\n           (if (= (inc (last t))\n                  (first s))\n             (if (< (count c)\n                    (inc (count t)))\n               (f (rest s) (conj t (first s)) (conj t (first s)))\n               (f (rest s) c (conj t (first s))))\n             (f (rest s) c [(first s)]))))))","user":"52e1c276e4b09f7907dd142b"},{"problem":53,"code":"(fn [coll] (map last\n                (first (sort-by count \n                                >\n                                (filter #(< 1 (count %))\n                                        (vals (group-by #(apply - (reverse %))\n                                                        (map-indexed list coll))))))))","user":"5650b8a0e4b0284900eef6c3"},{"problem":53,"code":"(fn [coll]\n  (loop [c        coll\n         last     -1\n         longest  []\n         thisone  longest]\n    (if (empty? c)\n      (if (> (count longest) 1) longest [])\n      (let [t (first c)]\n        (if (> t last)\n          (let  [lengthen (conj thisone t)]\n            (if (> (count lengthen) (count longest))\n              (recur (rest c) t lengthen lengthen)\n              (recur (rest c) t longest lengthen)))\n          (recur (rest c) t longest [t]))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"(fn [s]\n  (loop [[x & r] s, k 0, [m n] [0 0], [i j] [0 1]]\n    (cond\n     (nil? r) (cond \n               (= n 0) []\n               (>= n j) (take n (drop m s)) \n               :else (take j (drop i s)))\n     (< x (first r)) (if (>= n j) \n                       (recur r (inc k) [m n] [i (inc j)]) \n                       (recur r (inc k) [i (inc j)] [i (inc j)]))\n     :else (recur r (inc k) [m n] [(inc k) 1]))))","problem":53,"user":"52039e12e4b0fb7e47ea51ff"},{"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n       (partition-by #(- (second %) (first %)))\n       (filter #(= 1 (- (second (first %)) (ffirst %))))\n       (reduce #(if (< (count %) (count %2)) %2 %) [])\n       flatten\n       distinct))","problem":53,"user":"4e1b8106535d04ed9115e801"},{"code":"(fn monotinc \n  ([s] (monotinc s [] []))\n  ([s rez tmp] (if (empty? s)\n           (if (> (count tmp) (count rez))\n             (if (> (count tmp) 1) tmp [])\n             (if (> (count rez) 1) rez []))\n           (if (or (empty? tmp) (> (first s) (last tmp)))\n             (monotinc (rest s) rez (conj tmp (first s)))\n             (if (> (count tmp) (count rez))\n               (monotinc (rest s) tmp [(first s)])\n               (monotinc (rest s) rez [(first s)]))))))","problem":53,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [s]\n   (reduce\n     #(if (> (count %) (count %2)) % %2)\n     []\n     (filter #(>= (count %) 2)\n     ((reduce\n        (fn [m i]\n          (if\n            (= (inc (first i)) (second i))\n            (assoc m :w (conj (m :w) (first i)))\n            (assoc (assoc m :r (conj (m :r) (conj (m :w) (first i)))) :w [])))\n        {:r [] :w []}\n        (partition 2 1 (conj s (last s)))) :r))))","problem":53,"user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn solution [s]\n  (let [temp\n        (reduce\n         (fn [x y]\n           (if (> (count y) (count x))\n             y\n             x\n             ))\n         \n         (loop [rems (rest s)\n                curr (first s)\n                curr-seq (vector curr)\n                ret []]\n           (cond\n            (empty? rems) (conj  ret curr-seq)\n            (< curr (first rems)) (recur (rest rems) (first rems) (conj curr-seq (first rems)) ret)\n            :else (recur (rest rems) (first rems) (vector (first rems)) (conj ret curr-seq))\n            )))]\n    (if (< (count temp) 2)\n      []\n      temp\n      )))","problem":53,"user":"5226f8e9e4b04e78ff2e199a"},{"code":"(fn [xs]\n  \t(let [xss (take-while seq (iterate rest xs))\n\t\t\t  lenfn #(count (take-while pos? (map - (rest %) %)))\n\t\t\t  lens-xss (map #(list (lenfn %) %) xss)\n\t\t      [len xs] (first (sort-by first > lens-xss))]\n\t\t   (if (zero? len) ()\n\t\t\t   (take (inc len) xs))))","problem":53,"user":"4ee67d74535d93acb0a66861"},{"problem":53,"code":"(fn l-sub-seq [[x & xs]]\n  (loop [r [] c [x] [f & ls] xs]\n    (if (nil? f)\n      (if (= (count r) (count c) 1)\n        []\n        (if (>= (count r) (count c)) r c))\n      (if (= (inc (last c)) f)\n        (recur r (conj c f) ls)\n        (recur (if (>= (count r) (count c)) r c)\n               [f]\n               ls)))))","user":"598601f9e4b021a7a535fe79"},{"code":"(fn [col]\n               (letfn [(part [parts val]\n                         (let [cur (last parts)]\n                           (if (> val (last cur))\n                             (conj (vec (butlast parts)) (conj cur val))\n                             (conj parts [val]))))]\n                 (let [parts (reduce part [[(first col)]] (rest col))]\n                   (reduce #(let [sz (count %2)] (if (and (> sz 1) (> sz (count %1))) %2 %1)) [] parts))))","problem":53,"user":"4ef4acf8535dced4c769f23c"},{"code":"(fn [xs]\n  (loop [[x & xs] xs, current-seq [], max-seq [], last-x java.lang.Integer/MAX_VALUE]\n    (cond (nil? x) max-seq\n          (> x last-x)\n            (let [new-seq (conj current-seq x)]\n              (recur xs new-seq (if (> (count new-seq) (count max-seq)) new-seq max-seq) x))\n          :else (recur xs [x] max-seq x))))","problem":53,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn [coll]\n  (distinct \n    (flatten \n      (reduce #(if (> (count %1) (count %2)) %1 %2) \n        (for [n (range (count coll))] \n          (take-while #(= (first %) (dec (second %))) \n            (drop n (map vector coll (drop 1 coll)))))))))","problem":53,"user":"4eb51942535d7eef30807365"},{"code":"(fn [lst]\n  (let [rc (first\n            (filter vector?\n                    (map #(cond (< (count %) 2) false (= % (-> % sort distinct)) %)\n                         ;; make increasingly short subvectors of lst\n                         (map #(subvec lst (first %) (second %))\n                              ;; make a vector of vectors of the indices for subvec\n                              (for [x (-> lst count range) y (range x)]\n                                (vector y (+ (- (-> lst count inc) x) y)))))))]\n    (or rc []))) ; There's got to be a better way!","problem":53,"user":"4f0c84ce535d0136e6c2230e"},{"code":"(fn [coll]\n  (->>(map - (rest coll) coll)\n      (map-indexed #(vector %1 %2))\n      (partition-by #(= 1 (second %)) )\n      (filter #(= 1  (second (first %))) )\n      ((fn [xs] (if (empty? xs) xs (reduce #(if (> (count %1) (count %2)) %1 %2) xs))))\n      ((fn [xs] (if (empty? xs) xs (take (inc (count xs)) (drop (first (first xs)) coll)))))\n      )\n  )","problem":53,"user":"5360f043e4b0243289761e3c"},{"code":"(fn [coll]\n  \t(first (sort #(> (count %1) (count %2))\n\t\t\t(loop [in coll curr [] out [[]]]\n\t\t\t\t(if (empty? in) (if (> (count curr) 1) (conj out curr) out)\n\t\t\t\t\t(if (or (empty? curr) (= (inc (last curr)) (first in)))\n\t\t\t\t\t\t(recur (rest in) (conj curr (first in)) out)\n\t\t\t\t\t\t(recur (rest in) (conj [] (first in)) (if (> (count curr) 1) (conj out curr) out))))))))","problem":53,"user":"4e6a63fd535d8ccf87e9feda"},{"code":"#(->> %\r\n   (partition 2 1)\r\n   (map (fn [[a b]] [(< a b) a b]))\r\n   (partition-by first)\r\n   (filter ffirst)\r\n   (map (comp next distinct flatten))\r\n   (reduce (fn [r s] (if (> (count s) (count r)) s r)) []))","problem":53,"user":"50336c6be4b0c6c1199c710f"},{"problem":53,"code":"(fn [zs]\n  (if\n    (empty? zs)\n    []\n    (->>\n      (loop [[x & xs' :as xs] (list (peek zs))\n             ys (pop zs)\n             acc []]\n        (if\n          (empty? ys)\n          (conj acc xs)\n          (let [y (peek ys)\n                ys' (pop ys)]\n            (if (< y x)\n              (recur (conj xs y) ys' acc)\n              (recur (list y) ys' (conj acc xs))))))\n      (filter #(> (count %) 1))\n      (#(conj % (list)))\n      (apply (partial max-key count))\n      vec)))","user":"54f904c2e4b01ecee9d88832"},{"code":"(fn [coll]\n  (let [result (last\n                 (sort\n                  (group-by count \n                            (map #(reduce (fn [x y]\n                                            (conj (vec x)\n                                                  (second y)))\n                                          (first %)\n                                          (rest %))\n                                 (filter #(< (first (first %))\n                                             (second (first %)))\n                                         (partition-by #(< (first %)\n                                                           (second %))\n                                                       (partition 2\n                                                                  1\n                                                                  coll)))))))]\n    (if result\n      (first (second result))\n      [])))","problem":53,"user":"531d34cfe4b08068f379edac"},{"problem":53,"code":"(fn [sq]\n   ;; Find all subsequences. in the loop keep a state of the remaining\n   ;; part of the sequence, the current subsenquence (reversed) and the\n   ;; result so far (vector of oll subseqs found so far)\n   (let [subsqs   (loop [[x & xs] sq\n                         current  '() ; reversed current seq\n                         result   []]\n                    (if (nil? x)\n                      (conj result (reverse current))\n                      (cond (empty? current)              (recur xs (list x) result)\n                            (= (dec x) (first current))   (recur xs (conj current x) result)\n                            :else                         (recur xs (list x) (conj result (reverse current))))))\n         ;; Length of the longest subsequence \n         maxlen   (apply max (map count subsqs))]\n     (if (= maxlen 1)\n       []\n       (first (filter #(= (count %) maxlen) subsqs)))))","user":"563772a9e4b0bfe05bf117d7"},{"problem":53,"code":"(fn [coll]\n   (let [r (range 2 (inc (count coll)))\n         poss (reverse (map #(partition % 1 coll) r))]\n    (vec (some #(when (apply < %) %) (mapcat identity poss)))))","user":"5ea444b7e4b00a66d4a951a0"},{"code":"(fn lis [s]\n  (let [f\n      (fn [acc s]\n        (if (empty? s) acc\n          (recur \n            (if (and (not (empty? (first acc))) (= (inc (first (first acc))) (first s)))\n              (conj (drop 1 acc) (conj (first acc) (first s)))\n             (conj acc (list (first s))))\n           (rest s))))]\n  (reverse (first (sort-by count > (filter #(>= (count %) 2) (f '() s)))))))","problem":53,"user":"5273e006e4b03e8d9a4a7495"},{"problem":53,"code":"(fn [c]\n   (let [seq (->> c \n                  (partition 2 1)\n                  (partition-by (partial apply <))\n                  (filter (fn [[[a b]]] (< a b)))\n                  (reduce (fn [m s] (if (> (count s) (count m)) s m)) []))]\n     (if (seq? seq) (->> seq\n                         (#(cons (ffirst %) (map second %))))\n       seq)))","user":"5e453725e4b01d43a70e8e93"},{"problem":53,"code":"(fn [coll]   (let [\n        v\n        (\n          reduce (fn [p q]\n                   (if\n                     (empty? (last p) )\n                     [[q] [q]]\n                     (if (< (last (last p)) q)\n                       [(first p) (conj (last p) q)]\n                       (if (< (count (first p)) (count (last p)))\n                         [(last p) [q]]\n                         [(first p) [q]]\n                         )\n                       )\n                     )\n                   ) [[] []] coll\n                 )\n        ]\n    (let [i (nth v  (if (< (count (first v)) (count (second v))) 1 0))]\n        (if (< (count i) 2) [] i)\n      )\n    )\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"code":"(letfn [(rooted-subseqs [coll]\n  (map #(take (inc %) coll)\n       (range 1 (count coll))))\n        (subseqs [coll]\n  (->> coll\n       reverse\n       rooted-subseqs\n       (map reverse)\n       (mapcat rooted-subseqs)\n       reverse\n  ))\n        (pick-max [m] (if (empty? m) [] (first (m (apply max (keys m))))))]\n  #(->> %\n     subseqs\n     (filter (partial apply <))\n     (group-by count)\n     pick-max))","problem":53,"user":"52437703e4b076204b44fabf"},{"code":"(fn longest-seq [coll]\n  (let [groups (loop [[x & xs] coll\n                      sx []\n                      acc []]\n                 (let [s (last sx)]\n                   (cond\n                    (nil? x) (if (> (count sx) 1) (conj acc sx) acc)\n                    (nil? s) (recur xs [x] acc)\n                    (> x s) (recur xs (conj sx x) acc)\n                    :else (recur xs [x] (if (> (count sx) 1) (conj acc sx) acc)))))]\n    (if (not= groups [])\n      (reduce #(if (>= (count %1) (count %2)) %1 %2) groups)\n      [])))","problem":53,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn longest-inc-sub-seq [s]\n    (let [longest (first (sort (fn [a b] (> (count a) (count b)))\n      (filter\n         (fn [ss] (>= (count ss) 2))\n         (map (fn [x] (take-while #(not (nil? %)) (reduce #(if (empty? %1)\n           [%2]\n            (if (= (last %1) (dec %2))\n               (conj %1 %2)\n               (conj %1 nil))\n              )\n             []\n             x)))\n    (map vec (partition-all (count s) 1 s))))))]\n      (cond\n         (empty? longest) []\n         :else longest\n       )))","problem":53,"user":"52452225e4b0d8acf9ed6ae6"},{"code":"(fn [coll]\n  (or (some\n    (fn [n]\n      (some (fn [m]\n              (let [v (subvec coll m (+ m n))]\n                (if (and (> (count v) 1) (apply < v))\n                  v)))\n            (range (- (inc (count coll)) n))))\n    (range (count coll) 1 -1)) []))","problem":53,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn [coll]\n  (loop [coll coll\n         n (count coll)]\n    (if (< n 2)\n      '()\n      (let [s (some #(if (= % (take n (iterate inc (first %)))) %) (partition n 1 coll))]\n        (if (nil? s)\n          (recur coll (dec n))\n          s)))))","problem":53,"user":"524b90fae4b09eba1c0223df"},{"problem":53,"code":"(fn [col]\n  (loop [thisseq (vector (first col))\n         remaining (rest col)\n         best []]\n    (if (empty? remaining)\n      (if (> (count best) 1) best [])\n        (let [point (first remaining)\n              prev (last thisseq)\n              newseq\n              (if (> point prev)\n                (conj thisseq point)\n                (vector point))]\n          (recur newseq\n                 (rest remaining)\n                 (if (> (count newseq)(count best))\n                   newseq\n                   best))))))","user":"5e078ba7e4b0978307768fb6"},{"problem":53,"code":"(fn [this-seq]\n  (let [len (count this-seq)]\n    (loop [i 0 cur-lcs [] longest-lcs [] prev-val -1]\n      (if (<= i len)\n        (recur\n          (inc i)\n          (if (= (inc prev-val) (get this-seq i))\n            (conj cur-lcs (get this-seq i))\n            [(get this-seq i)])\n          (if (> (count cur-lcs) (count longest-lcs))\n            cur-lcs\n            longest-lcs)\n          (get this-seq i))\n        (if (> (count longest-lcs) 1)\n          longest-lcs\n          [])))))","user":"595b7c12e4b066ee0a44afda"},{"code":"(fn [v] (concat [] (first (filter #(apply < %) (apply concat (for [x (range (count v) 1 -1)] (partition x 1 v)))))))","problem":53,"user":"50bce014e4b0594b91591c63"},{"problem":53,"code":"(fn [nbrs] (loop [prev (first nbrs) current (second nbrs) remn (rest nbrs) sseq [prev] sseqs []]\n  (if (not current)\n    (if (some #(< 1 (count %)) (conj sseqs sseq))\n      (apply max-key count (conj sseqs sseq))\n      '())\n    (if (= (inc prev) current)\n      (recur current (second remn) (rest remn) (conj sseq current) sseqs)\n      (recur current (second remn) (rest remn) [current] (conj sseqs sseq))))))","user":"57625c18e4b0994c1922fba4"},{"problem":53,"code":"(fn max-seq [items] \n    (->> (partition-all (count items) 1 items) \n         (map #(->> (map list % (iterate inc (first %))) \n                    (take-while (fn [items] (let [[a b] items] (= a b))))\n                    (map first)))\n         (filter #(> (count %) 1))\n         (apply max-key count [])))","user":"5711b532e4b09c608db70449"},{"code":"(fn [x]\n  (let [f #(take-while seq (iterate % %2))]\n    (->> (f next x)\n         (mapcat #(f butlast %))\n         (filter #(and (< 1 (count %)) (apply < %)))\n         reverse\n         (sort-by count)\n         last\n         vec)))","problem":53,"user":"4e7dfab0535db169f9c796f9"},{"problem":53,"code":"(fn searchSequenceX[x] \n\t(let [res (\n(fn searchSequenceRec[x]\n\t(if (empty? x)\n\t\tnil\n\t\t(if (nil? (second x))\n\t\t\t[]\n\t\t\t(if((fn inSuccession[x] (= 1(- (second x)(first x))))\n x)\n\t\t\t\t(let [res (\n\t\t\t\t(fn readSequence[x res]\n\t\t\t\t\t(if (empty? x)\n\t\t\t\t\t\t[(reverse res) x]\n\t\t\t\t\t\t(if (nil? (second x))\n\t\t\t\t\t\t\t[(reverse (cons (first x) res)) []]\t\n\t\t\t\t\t\t\t(if ((fn inSuccession[x] (= 1(- (second x)(first x))))\n x)\n\t\t\t\t\t\t\t\t(readSequence (rest x) (cons (first x)res))\n\t\t\t\t\t\t\t\t[(reverse (cons (first x) res)) (rest x)]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) x [])]\n\t\t\t\t\t(cons (first res)(searchSequenceRec (second res)))\n\t\t\t\t)\n\t\t\t\t(searchSequenceRec (rest x))\n\t\t\t)\n\t\t)\n\t)\n) x)]\n\t\t(if (empty? res)\n\t\t[]\n\t\t(reduce (fn maxSeq[a b] \n\t(if (> (count a) (count b))\n\t\ta\n\t\tb\n\t)\n)\n res)\n\t\t)\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [orig]\n  (first (reverse (sort (map (fn [coll]\n    (vec (first \n      (filter #(and (next %) \n                    (= % (sort %))\n                    (= (count %) (count (set %))))\n        (reverse \n          (map #(first (partition % coll))\n                (range 1 (inc (count coll)))))))))\n            (drop-last \n              (map #(drop % orig) (range 0 (count orig)))))))))","problem":53,"user":"4db016af838c48654951d9b9"},{"problem":53,"code":"(fn [xs]\n  (loop [[x & xs] xs ctx [] best nil]\n    (if x\n      (if (or (empty? ctx) (= x (inc (last ctx))))\n        (let [new (conj ctx x)] (recur xs new (if (> (count new) (count best)) new best)))\n        (recur (cons x xs) [] best))\n      (if (> (count best) 1) best []))))","user":"5363d242e4b0243289761e5c"},{"problem":53,"code":"#(loop [v %\n        t []\n        s []]\n   (cond (empty? v) (if (and (> (count t) 1) (> (count t) (count s))) t s)\n         (= 1 (count v)) (recur (rest v) (conj t (first v)) s)\n         (> (second v) (first v)) (recur (rest v) (conj t (first v)) s)\n         :else (recur (rest v) [] (if (> (count t) (count s)) (conj t (first v)) s))))","user":"55e732c5e4b050e68259b492"},{"code":"(fn [s] (map fnext (last (filter #(< 1 (count %)) (sort-by count (partition-by first (map #(or [(- % %2) %]) s (range))))))))","problem":53,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn [i] (let [seqs (mapcat #(partition % 1 i) (range (count i) 1 -1))] (or (some #(if (= % (take (count %) (iterate inc (first %)))) %) seqs) [])))","problem":53,"user":"4f7beb36e4b06e829148e1ab"},{"code":"(fn [c]\n  (let [patterns (remove\n                   #(= 1 (count %))\n                   (for\n                     [i (range 2 (inc (count c)))\n                      j (range (inc (count c)))\n                      :when (> i j)]\n                     (drop j (take i c))))]\n    (let [candidates (filter\n                       (fn [coll]\n                         (not= false (reduce #(if (= false %1) false (if (= (inc %1) %2) %2 false)) coll)))\n                       patterns)]\n      (if (empty? candidates)\n            []\n            (apply (partial max-key count) candidates)))))","problem":53,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":53,"code":"#(loop [longest '() [fcurr & rcurr :as curr] '() [flst & rlst :as lst] %]\n  (if (> (count curr) (count longest)) \n    (recur curr curr lst)\n    (if (empty? lst) \n      (if (< 1 (count longest)) (reverse longest) [])\n      (if (or (empty? curr) (> flst fcurr))\n        (recur longest (conj curr flst) rlst)\n        (recur longest (list flst) rlst)\n      )\n    )\n  ))","user":"5281a445e4b0757a1b17143a"},{"problem":53,"code":"(fn [coll] (\n let [ part (partition-by #(< (first %) (last %)) (partition 2 1 coll))\ngoodss (filter #(let [l (flatten %)] (< (first l) (last l))) part)\ng (group-by count goodss )]\n  (if (= g {})\n   [] \n   (let [mk (apply max (keys g))\nss (first (get g mk))\nssl (last (flatten ss))]\n  (flatten \n   (list (map first ss) ssl))\n  )\n )\n))","user":"56c4f971e4b05cc29241ee9d"},{"problem":53,"code":"(fn longest-increasing-sub-seq [xs]\n    ((reduce (fn [{:keys [candidate best] :as state} v]\n               (if (= (dec v) (last candidate))\n                 (let [step (conj candidate v)]\n                   (assoc state :candidate step :best (if (> (count step) (count best)) step best)))\n                (assoc state :candidate [v] :best best)))\n          {:candidate [], :best []} xs) :best))","user":"56175cf9e4b06b1bb2182a0f"},{"problem":53,"code":"(fn [coll]\n  (let\n    [maxsub (apply max-key count\n    (reverse (loop [ s (seq coll) res [] ]\n      (if (empty? s)\n        res\n        (let\n          [group\n           (loop [xs (next s) cur [(first s)]]\n             (if (or (empty? xs) (>= (last cur) (first xs)))\n               [xs cur]\n               (recur (rest xs) (conj cur (first xs)))))]\n          (recur (first group) (conj res (second group))))))))]\n    (if (< (count maxsub) 2) [] maxsub)))","user":"553abb28e4b09218d5f44ffb"},{"code":";; This is pretty grim, but it works.  It'll be interesting to see\n;; what comes from the people who actually know what they're doing...\n;;\n(fn [x]\n  (let [y (filter #(> (first %) 1)\n            (map #(vector (inc (count %)) (second (first %)))\n              (filter #(= true (first (first %)))\n                (partition-by #(first %)\n                  (map vector (map #(= %1 (dec %2)) x (rest x))\n                              (range))))))]\n    (if (empty? y)\n      []\n      (let [ymax (apply max (map first y))\n            ypair (first (filter #(= ymax (first %)) y))\n            ys (second ypair)]\n        (subvec x ys (+ (first ypair) ys))))))","problem":53,"user":"4ec5cdb0535d6d7199dd36b8"},{"problem":53,"code":"#(letfn [(acc [[current longest] e] \n               (if (= (dec e) (peek current)) \n                 (let [current (conj current e)] \n                   [current (if (> (count current) (count longest)) \n                              current \n                              longest)]) \n                 [[e] longest]))] \n         (get (reduce acc [[] []] %) 1))","user":"59dfb8dbe4b08badc2a0c4da"},{"code":"(fn longest-inc-subseq [a]\n\t(letfn [(take-same [xs ys]\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(or (empty? xs) (empty? ys)) []\n\t\t\t\t\t\t\t(= (first xs) (first ys)) (cons (first xs) (take-same (rest xs) (rest ys)))\n\t\t\t\t\t\t\t:else []))\n\t\t\t\t\t(isub-list [ls]\n\t\t\t\t\t\t(take-same ls (drop (first ls) (range))))]\n\t\t(if (empty? a) []\n\t\t\t(let [curr (isub-list a) recurs (longest-inc-subseq (rest a)) res (if (>= (count curr) (count recurs)) curr recurs)]\n\t\t\t\t(if (> (count res) 1) res [])))))","problem":53,"user":"50ed8a5fe4b06330c1f87c3d"},{"code":"(fn [coll]\n  (letfn [(match? [[c n]]\n                  (= c (- n 1)))]\n    (->> (partition 2 1 coll)\n         (partition-by match?)\n         (filter (partial every? match?))\n         (sort-by count)\n         last\n         ((juxt (comp (partial take 1) first) \n                (partial map last)))\n         (apply concat))))","problem":53,"user":"50ccf729e4b0f7a459302aac"},{"problem":53,"code":";;  buckets: [[..],[a,b,..]], left: [n,m,..z]\n\n;; if n > last item in last bucket, append n to that bucket.\n;; otherwise, add the singlton [n] at the end of the buckets\n\n;; reduce over n,\n;; find longest list in result \n\n\n(let \n[bucket-fill ;; \n(fn derp [acc x] (if (-> acc last last (#(> x %)) ) ;; if x > last item\n,(update-in acc [(dec (count acc))] conj x) ;; add x to last bucket\n,(conj acc [x]) ;; add new bucket [x]\n))\n\n] \n\n(fn [s]\n(->> s\n\n(reduce bucket-fill [[999]] )\n(filter #(> (count %1) 1))\n(sort #(> (count %1) (count %2) )) ;sort-by-count\n(first)\n(#(if (= % nil) [] %))\n)))","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn longest-sub [c]\n        (let [c (map (fn [[a :as c]] (map\n                                      #(vector % (= (- % a) %2))\n                                      c (range)))\n                     (partition-all (count c) 1 c))\n              d (filter #(> (count %) 1)\n                        (map #(take-while second %) c))]\n          (if (empty? d) [] (map first (apply max-key count d)))))","problem":53,"user":"4f031eac535dcb61093f6a67"},{"problem":53,"code":"(fn longest-sequence [x]\n  (let [choose-best #(if (> (count %1) (count %2)) %1 %2)]\n    (loop [coll (rest x) solution [(first x)] best (vec solution)]\n      (let [prev (peek solution) next (first coll)]\n        (cond\n          (empty? coll) (if (> (count best) 1) best [])\n          (= (+ prev 1) next) (recur (rest coll) (conj solution next) (choose-best (conj solution next) best))\n          :else (recur (rest coll) [next] best))))))","user":"53566545e4b04ce2eb3ed267"},{"problem":53,"code":"(fn [v]\n  (let [matrix (apply concat\n                      (map (fn [start] (map #(subvec v start %)\n                                            (range (+ 2 start) (inc (count v)))))\n                           (range (count v))))]\n    (->> matrix\n         ; (filter #(= % (sort %)))\n         ; (filter #(= (count %) (count (set %))))\n         (filter #(apply < %))\n         (reduce (fn [m x]\n                   (if (< (count m) (count x))\n                     x\n                     m))\n                 [])\n         )\n    ))","user":"55f73078e4b06e875b46cea4"},{"problem":53,"code":"(fn [coll]\n  (let [res (reduce\n   \t(fn [acc e]\n      (if (= e (inc (last (:current-seq acc))))\n        (assoc acc :current-seq (conj (:current-seq acc) e))\n        (if (> (count (:current-seq acc)) (count (:max-seq acc)))\n          {:max-seq (:current-seq acc) :current-seq [e]}\n          (assoc acc :current-seq [e]))))\n   \t{:max-seq [(first coll)] :current-seq [(first coll)]}\n   \t(rest coll))\n    max-seq (if (> (count (:max-seq res)) (count (:current-seq res))) (:max-seq res) (:current-seq res))]\n    (if (>= (count max-seq) 2)\n      max-seq\n      [])))","user":"5c73b8bae4b0fca0c16227ba"},{"code":"(fn [sq]\n  (let [v \n        (first (sort (comparator #(> (count %1) (count %2)))\n                     (filter #(> (count %) 1) (loop [[h & t] sq cur -1 s [] r []]\n                                                (if h\n                                                  (if (> h cur)\n                                                    (recur t h (conj s h) r)\n                                                    (recur (cons h t) -1 [] (conj r s))) (conj r s))))))]\n    (if v v [])))","problem":53,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [s] (first (second (last (sort-by key (filter #(not= 1 (key %)) (group-by count (cons [] (reduce #(if (or (empty? %1) (not= (dec %2) (last (last %1)))) (conj %1 [%2]) (update-in %1 [(dec (count %1))] conj %2)) [] s)))))))))","problem":53,"user":"52c1bd29e4b07a9af579236a"},{"problem":53,"code":"(fn [coll]\n  (->> (partition 2 1 coll)\n       (partition-by (fn [[a b]] (< a b)) ,,,)\n       (map (comp distinct flatten) ,,,)\n       (filter #(apply < %) ,,,)\n       (sort-by count > ,,,)\n       (first ,,,)\n       (#(if (empty? %) []  %) ,,,)))","user":"540c54a7e4b0addc1aec6700"},{"problem":53,"code":"(fn [l]\n  (map  #(Character/getNumericValue %)\n        (first (sort-by count >\n                        (filter #(> (count %) 1)\n                                (re-seq #\"0?1?2?3?4?5?6?7?8?9?\" (apply str l)))))))","user":"5632e850e4b0bfe05bf117ac"},{"problem":53,"code":"(fn [coll]\n  (loop [n 2\n         res []]\n    (let [ngrams (partition n 1 coll)\n          good (filter #(apply < %) ngrams)]\n      (if (empty? good)\n        res\n        (recur (inc n) (first good))))))","user":"53322cece4b019098a6f8b73"},{"problem":53,"code":"(fn [c] (let [candidates      (map #(drop % c) (range (count c)))\n              end-of-run      -999\n              incrementing    #(if (= (inc (last %1)) %2)\n                                   (conj %1 %2)\n                                   (conj %1 end-of-run))\n              take-run        #(reduce incrementing [(first %)] (rest %))\n              end-of-run?     #(not= end-of-run %) \n              candidate-runs  (map #(filter end-of-run? %) (map take-run candidates))\n              longest-run     (reduce #(if (> (count %1) (count %2)) %1 %2) candidate-runs)]\n             (if (empty? (rest longest-run)) [] longest-run)))","user":"591addcee4b09b4ee5954be1"},{"problem":53,"code":"(fn [s] \n  (let [\n        compare-v #(= (dec %1) (last (first %2)))\n        find-max #(if (and (> (count %2) 1) (> (count %2) (count %1))) %2 %1)\n        add-to #(cons (conj (first %1) %2) (rest %1))]\n    (reduce find-max [] (reduce #(if (compare-v %2 %1) (add-to %1 %2) (conj %1 (vector %2))) (list [(first s)]) (rest s)))\n    )\n  )","user":"5cfd5a93e4b0cc9c91588168"},{"code":"(fn myIncreasingSequence\n  [coll]\n  (let [min (- (apply min coll) 1)]\n    (let [result (reduce #(if (>= (count %1) (count %2) 1) %1 %2) [] \n  (partition-by #(= min %)(reduce #(if (<= %2 (last %1)) (conj %1 min %2) (conj %1 %2)) (vector (first coll)) (rest coll))))]\n   (if (>= 1 (count result)) [] result))))","problem":53,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":53,"code":"(fn [coll]\n  (first (reduce (fn [[longest current] c]\n            (cond\n              (and (> c (last current)) (>= (count current) (count longest)))\n              [(conj current c) (conj current c)]\n              (> c (last current))\n              [longest (conj current c)]\n              :else\n              [longest [c]])) [[] [(first coll)]] (rest coll))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":53,"code":"#(let [subvectors (for [x (range 0 (inc (count %))) y (range (+ x 2) (inc (count %)))] (subvec % x y))\n        filtered (filter (fn [coll] (= coll (range (first coll) (+ (first coll) (count coll))))) subvectors)\n        grouped-by (group-by count filtered)\n        map-keys (keys grouped-by)]\n   (if (empty? map-keys) [] (first (grouped-by (apply max map-keys)))))","user":"5751f2a2e4b02ea114799292"},{"code":"(fn [s]\n    (:longest (reduce (fn [a b] \n        (if (= (last (a :current)) (dec b)) \n            (let [cur (conj (a :current) b)\n                  lon (a :longest)] \n                (assoc a\n                    :current cur\n                    :longest (if (> (count cur) (count lon)) \n                        cur\n                        lon)))\n\n                \n            (assoc a :current [b])))\n \n    {:current [] :longest []} s)))","problem":53,"user":"5356e569e4b04ce2eb3ed272"},{"code":"(fn [sq]\n  (reduce\n  (fn [max s]\n    (if (and (< (count max) (count s))\n             (< (first s) (second s)))\n      s\n      max))\n  []\n  (map #(take-nth 2 (cons (ffirst %) (flatten %)))\n       (partition-by (fn [[a b]] (if (< a b) :ok a))\n                     (partition 2 1 sq)))))","problem":53,"user":"4fc0853ae4b081705acca327"},{"code":"#(let [C count A (C %) R range] (nth (concat (for [t (R A 1 -1) o (R 0 (- A (dec t))) :let [S (take t (drop o %))] :when (and (= S (sort S)) (= (C S) (C (set S)))) ] S) [[]]) 0))","problem":53,"user":"4e9a8c0e535dbda64a6f6b72"},{"problem":53,"code":"(fn bar [v]\n  (letfn [(pick [coll]\n            (reduce #(if (> (count %2) (count %1)) %2 %1)\n                    [] (filter #(> (count %) 1) coll)))]\n    (loop [curr [] best [] remain v]\n      (cond\n        (empty? remain) (pick [curr best])\n        (empty? curr) (recur [(first remain)] best (rest remain))                        \n        (= (first remain) (inc (peek curr))) (recur (conj curr (first remain)) best (rest remain))\n        :else (recur [(first remain)] (pick [curr best]) (rest remain))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":53,"code":"(fn [coll]\n  (let [partitioned (partition-by #(apply < %)(partition 2 1 coll))\n        filtered (filter (fn [[[x1 x2]]] (< x1 x2)) partitioned)\n        sorted (first (sort-by count > filtered))]\n                         (concat (first sorted) (map last(rest sorted)))))\n\n\n;;filter (fn [[[x1 x2]]] (< x1 x2)) partitioned)\n;;Is it true that you used 3 brackets at the beginning and end [[[]]]  because this partitioned collection has 3 brackets\n;;I use one pair of [ ] as part of the function definition syntax.\n;;I use two more pairs of [ ] to access the relevant part of the result received from partition.  \n;Filter will get the right parts of the partition results using the destructuring defined in the function definition. \n;Without destructuring it would make my function definition more complicated, as I would have to get the values from ((1 0)).  Using destructuring, I pass the integer values 1 0.\n;;Yes.  This technique is called destructuring and in the function definition it is used to convert the arguments into the right shape of data. https://clojure.org/guides/destructuring\n\n;;I have a video on destructuring if you prefer https://www.youtube.com/watch?v=y-KS2gABnTQ&list=PLpr9V-R8ZxiDjyU7cQYWOEFBDR1t7t0wv&index=14\n;;Essentially I am pattern matching, specifically the pattern is the shape / structure of the data.","user":"5ce5b43be4b0a17bb84e2b7a"},{"code":"(fn [v]\n  (let [[maybe n cur _]\n  (let [v1 (first v)]\n\t  (reduce \n\t    (fn\n      [[longest maxlen current prv] elt]\n      (if (>= prv elt)\n          (if (> (count current) maxlen)\n              [current (count current) [elt] elt]\n              [longest maxlen [elt] elt])\n          [longest maxlen (conj current elt) elt]))\n\t    [[v1] 1 [v1] v1]\n\t    (rest v)))]\n\t    (cond (< n (count cur)) cur (= 1 n)[]\n\t\t:else maybe\n\t\t)))","problem":53,"user":"4e6e3a1e535d5021c1a89602"},{"problem":53,"code":"(fn [coll]\n  (let [res (reduce (fn [acc v]\n                      (if (< (last (last (:result acc))) v)\n                        (-> acc\n                            (update-in [:result (dec (count (:result acc)))] conj v)\n                            (update-in [:count] #(if (> (inc (count (last (:result acc))))\n                                                        %)\n                                                   (inc (count (last (:result acc))))\n                                                   %)))\n                        (update-in acc [:result] conj [v]))) {:result [[(first coll)]]\n                                                              :count 1} (rest coll))\n        result (->> res\n                    :result\n                    (filter #(>= (count %) (:count res)))\n                    first)]\n    (if (< (count result) 2)\n      []\n      result)))","user":"516c3472e4b06f078fab251c"},{"problem":53,"code":"(fn [l]\n  (loop [l (apply list l) maxSeq [] curSeq []]\n    (let [ms (if (and (> (count curSeq) 1) (> (count curSeq) (count maxSeq))) curSeq maxSeq)]\n      (if-not (seq l)\n        ms\n        (recur (pop l) ms (if (or (not (seq curSeq)) (> (peek l) (last curSeq))) (conj curSeq (peek l)) [(peek l)]))\n        )        \n      ) \n    )\n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn longest-increasing-subseq\n  [coll]\n  (loop [best []\n         current []\n         coll (partition-all 2 1 coll)]\n    (if-let [s (seq coll)]\n      (let [[x & xs] s\n            new-current (conj current (first x))\n            new-best (if (>= (count best) (count new-current)) best new-current)]\n        (if (apply < x)\n          (recur new-best new-current xs)\n          (recur new-best [] xs)))\n      (if (<= 2 (count best)) best []))))","problem":53,"user":"4dc0ff08535d020aff1edf84"},{"problem":53,"code":"(fn lngss [allstuff]\n  (loop [current [(first allstuff)]\n         longest []\n         stuff (rest allstuff)]\n    (cond \n    \t(empty? stuff) longest\n    \t(not= (inc (last current)) (first stuff)) (recur [(first stuff)] longest (rest stuff))\n    \t(> (count (conj current (first stuff))) (count longest))\n    \t\t(recur (conj current (first stuff)) (conj current (first stuff)) (rest stuff))\n    \t:else (recur (conj current (first stuff)) longest (rest stuff)))))","user":"5b2a559be4b063e2438bcc74"},{"problem":53,"code":"(fn [s](let [\n              n (fn[x y](if (< (last (last x)) y)\n(conj (vec(drop-last x))\n(conj (last x) y))\n(conj x [y])))\n              p (reduce n [[(first s)]] (rest s))\n              r (group-by count p)\n              g (sort r)\n              l (last g)\n              d (first (second l))] (if (= (count d) 1) []\n              d)\n          ))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":53,"code":"(fn longest-increasing-subseq [int-seq]\n  (letfn [(pairwise-take-while [pred coll]\n            (let [n (count (take-while #(apply pred %) (partition 2 1 coll)))]\n              (take (inc n) coll)))\n          (right-subseqs [coll] \n            (for [n (range (count coll))] (drop n coll)))]\n    (let [subseqs (right-subseqs int-seq)\n          increasing-subseqs (map (partial pairwise-take-while #(= (inc %1) %2)) subseqs)\n          longest-subseq (apply max-key count increasing-subseqs)]\n      (if (< (count longest-subseq) 2)\n        ()\n        longest-subseq))))","user":"58ed713de4b056aecfd47d84"},{"problem":53,"code":"(fn longuest-incr-sub-seq [coll]\n  (loop [coll' coll\n         longuest '()]\n    (if (empty? coll')\n      longuest\n      (let [compare-coll (iterate inc (first coll'))\n            runs (map first (take-while #(= (first %) (second %)) (map vector coll' compare-coll)))\n            nb-runs (count runs)\n            new-longuest (if (and (< 1 nb-runs) (> nb-runs (count longuest))) runs longuest)]\n        (recur (next coll') new-longuest)))))","user":"5264383be4b03e8d9a4a70cb"},{"problem":53,"code":"(fn [l]\n  (let [longest-or-nil (->>\n   \t(partition 2 1 l); group every item with the next in list\n   \t(partition-by (partial apply >=)); group by ascending vs descending\n   \t(filter #(apply < (first %)));filter out descending \n  )]\n       (if (seq longest-or-nil);if we found a sequence\n         (->>\n          (reverse longest-or-nil);reverse so that max-key will return the first occurrence instead of the last\n          (apply max-key count);get the longest sequence\n          (#(conj (into [] (map first %1)) (second(last %1))));get the first of each tuple plus the very last item\n         )\n         []\n       )\n  )\n\n)","user":"4e28ddd1535deb9a81d77efd"},{"code":"(fn __ [l]\n  (reduce (fn [l r] (if (> (count l) (count r)) l r)) []\n          (filter #(> (count %) 1)\n                  (loop [acc [] result [] remainder l]\n                    (if (empty? remainder)\n                      (if (empty? acc)\n                        result\n                        (conj result acc))\n                      (let [e (first remainder)\n                            l (rest remainder)]\n                        (if (or (empty? acc) (= (+ 1 (last acc)) e))\n                          (recur (conj acc e) result l)\n                          (recur [e] (conj result acc) l))))))))","problem":53,"user":"4f77b68de4b0fbe0118ec581"},{"problem":53,"code":"(fn [coll]\n  (let [res \n        (distinct \n          (apply concat\n                 (first (sort-by count > (partition-by #(apply < %) \n                                                       (partition 2 1 coll))))))]\n    (if (= res coll)\n      (list)\n      res)))","user":"53bd7080e4b0d9a98559a6d1"},{"code":"(fn [coll]\n  (letfn [(run [n coll]\n              (if (= n (first coll))\n                (cons n (run (inc n) (rest coll)))\n                []))]\n    (reduce #(let [ct1 (count %1)\n                   ct2 (count %2)]\n               (if (and (< ct1 2) (< ct2 2))\n                 []\n                 (if (> ct2 ct1) %2 %1)))\n            (map #(apply run %) (map vector coll (iterate #(rest %) coll))))))","problem":53,"user":"51195e77e4b055cfb310d499"},{"problem":53,"code":"(fn longest-chain [c]\n  (let [cnt (count c)\n        increasing?  #(every? (fn [[x y]] (or  (nil? y)  (< x y))) (partition-all 2 1 %))\n        candidates (for [x (range 0 (- cnt 2 -1))\n          y (range 2 (- cnt x -1))\n          :let [ seq (take y (drop x c)) ]\n          :when (increasing? seq)\n          ] seq)\n        ]\n    (if (empty? candidates) '() (->> candidates (group-by count) (apply max-key key) (last) (first)))\n    ))","user":"512b07f7e4b078b06821febb"},{"problem":53,"code":"(fn [col]\n  (-> col \n      ((fn [col]\n            (loop [from (next col) to [(first col)] result []]\n              (if (empty? from)\n                (conj result to)\n                (if (= (inc (last to)) (first from))\n                  (recur (next from) (conj to (first from)) result)\n                  (recur (next from) [(first from)] (conj result to)))))))\n      \n      ((fn [col]\n        (first (sort #(compare (count %2) (count %1)) col))))\n      ((fn [col]\n        (if (> (count col) 1)\n          col\n          [])))))","user":"541f89a5e4b01498b1a71a99"},{"problem":53,"code":"(comp \n #(or (first %) []) \n (partial sort #(> (count %1) (count %2)))\n (partial filter #(> (count %) 1))\n (fn [c]\n  (loop [o [[(first c)]] [f & r] (rest c)]\n   (if (nil? f)\n    o\n    (if-not (= f (inc (last (last o))))\n     (recur (conj o [f]) r)\n     (recur (conj (vec (butlast o)) (conj (last o) f)) r))))))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn [s] \r\n  (vec (apply max-key count\r\n    (reverse (map \r\n        (fn [s] \r\n            (into (sorted-set) (flatten \r\n                 (take-while (fn [[a b]] (= (inc a) b)) \r\n                             (partition 2 1 s)))) )\r\n        (take (count s) (iterate rest s)))))))","problem":53,"user":"4db92654535d1e037afb21a0"},{"code":"(fn [x]\n  (loop [coll (rest x)\n         running [(first x)]\n         longest []]\n    (if (empty? coll)\n      (if (> (count longest) (count running)) longest (if (>= (count running) 2 ) running []))\n      (if (= (first coll) (inc(last running)))\n        (recur (rest coll) (conj running (first coll)) longest)\n        \n        (if (> (count running) (count longest))         \n          (recur (rest coll) [(first coll)] (if (>= (count running) 2) running []))\n          (recur (rest coll) [(first coll)] longest)\n          )))))","problem":53,"user":"53778b90e4b06839e8705e36"},{"code":"(fn [xs] \n  (loop [source  xs\n         current [(first xs)]\n         longest []] \n    (let [c (first source)\n          n (second source)]\n     (cond (= c nil) (if (>= (count longest) 2) longest [])\n           (= (inc c) n) (recur (rest source) (conj current n) longest)\n           :else (if (> (count current) (count longest))\n                  (recur (rest source) [n] current)\n                  (recur (rest source) [n] longest))))))","problem":53,"user":"5128554ee4b03a34742b430a"},{"code":"(fn sep [xs]\n  (let [consec #(if (or (empty? (last %))(< (last (last %)) %2))\n                (conj (vec (butlast %)) (conj (last %) %2))\n                (conj % [%2]))\n        firstmax #(if (> (count %2) (count %)) %2 %)]\n    (->> (reduce consec [[]] xs)\n         (filter #(> (count %) 1))\n         (reduce firstmax []))))","problem":53,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn [lst]\n   (->> (map vector lst (concat (rest lst) [(last lst)]))\n        ((fn [res lst]\n           (if (empty? lst)\n             res\n             (recur (into res\n                          (vector (take-while #(< (first %) (second %))\n                                              lst)))\n                    (drop-while #(>= (first %) (second %))\n                                (drop-while #(< (first %) (second %))\n                                            lst)))))\n         [])\n        ((fn [lst]\n           (reduce #(if (< (count %1) (count %2)) %2 %1)\n                   lst)))\n        (#(concat % [(reverse (last %))]))\n        (map first)\n        flatten\n        (#(if (> (count %) 1)\n            % []))))","problem":53,"user":"4f71347ae4b07046d9f4f009"},{"problem":53,"code":"#((reduce\n (fn [state el]\n   (let [prev (or (last (:cur state)) java.lang.Integer/MIN_VALUE)\n         cur (:cur state)\n         cur-seq (conj cur el)\n         best (:best state)]\n     (assoc state\n       :cur \n       (if (> el prev)\n         cur-seq\n         [el])\n\n       :best\n       (if (and\n            (>= (count cur-seq) 2)\n            (> el prev)\n            (> (count cur-seq) (count best)))\n         cur-seq\n         best))))\n {:cur [] :best []} %) :best)","user":"54be7772e4b0ed20f4ff6eea"},{"problem":53,"code":"(fn [x]\n  (let \n    [res  (filter #(> (count %) 1)\n                  (reduce #(if (= (last(last %1))  (dec %2))\n                             (conj (vec (butlast %1))  (conj (last %1) %2) )\n                             (conj %1 [%2]))\n                          [] x )\n                  )]\n    (if (empty? res)\n      []\n      (reduce #(if (> (count %1) (count %2)) %1 %2) res)\n      )\n          \n  ))","user":"58d28c70e4b03c36ff7e5901"},{"code":"(fn [x] (let [r (first (last (last (sort (group-by count ((fn split-by [p c] (if (empty? c) c (let [both (split-with (comp not p) c)] (let [left (first both) right (rest (last both))] (concat (list left) (split-by p right)))))) nil? (flatten (map #(if (>= (first %) (second %)) (list (first %) nil) (first %)) (partition 2 1 (concat x [0]))))))))))] (if (> (count r) 1) r [])));sucks","problem":53,"user":"519964cbe4b0aa09cbc0b849"},{"problem":53,"code":"(fn __ [s]\n  (letfn [(starts-with-inc-vec\n            ([[x & xs]] (starts-with-inc-vec [x] xs))\n            ([acc [x & xs]]\n             (if (or (nil? acc)(= (->> acc last inc) x))\n               (starts-with-inc-vec (concat acc [x]) xs)\n               acc)))\n          (expand-into-inc-vecs [v]\n            (if (seq v)\n              (concat [(starts-with-inc-vec v)] (expand-into-inc-vecs (rest v)))\n              []))]\n    (->> s\n        expand-into-inc-vecs\n        (reduce (fn return-longest [contender challenger] (if (> (count challenger) (count contender)) challenger contender)))\n        ((fn [v] (if (> (count v) 1) v [] ))))))","user":"55916764e4b0604b3f94d57b"},{"problem":53,"code":"(fn f\n  ([s] (f s [] []))\n  ([s r t] (if\n             (empty? s)\n             (if (> (count r) 1) r [])\n             (let [t (if (and (not (empty? t)) (> (first s) (last t))) (conj t (first s)) [(first s)])]\n               (recur (rest s) (if (> (count t) (count r)) t r) t)))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":53,"code":"(fn  [col]\n  (let [r (reduce (fn [x y] (if (> (count y) (count x)) y x)) []\n          (reductions (fn [searched x]\n                        (if (= (last searched) (dec x))\n                          (concat searched [x])\n                          [x]))\n                      []\n                      col))]\n    (if (> (count r) 1)\n      r\n      [])))","user":"53664e3be4b0243289761e74"},{"problem":53,"code":"(fn [x]\n   (let [seq-ind (into [] (map #(reduce + %1) (partition-by identity (map #(if (= (- %1 %2) 1) 1 0) (rest x) (drop-last x)))))]\n     (let [size (reduce max seq-ind)]\n       (let [pos (count (subvec seq-ind 0 (.indexOf seq-ind size)))]\n         (if (> size 0)\n           (subvec x pos (+ pos size 1))\n           [])\n         ))))","user":"5a80b934e4b00b71e582a05b"},{"problem":53,"code":"(fn goo [s]\n  (loop [x 0\n         a []\n         b []]\n    ;; Termination condition\n    (if (= x (count s))\n      ;; Return the biggest of a or b (or [] if length == 1)\n      (if (> (count a) (count b))\n        a\n        (if (= (count b) 1) [] b))\n      ;; Loop back with\n      ;;      x++,\n      ;;      a = consecutive increasing numbers ending in s[x]\n      ;;      b = a if a was longer, otherwise b\n      (recur (inc x)\n             (if (empty? a) (conj a (nth s x))\n                            (if (> (nth s x) (last a)) (conj a (nth s x))\n                                                       [(nth s x)]))\n             (if (> (count a) (count b)) a b)\n             ))))","user":"577bcbd9e4b0d3393e5deb1b"},{"code":"(fn [x]\n  (reduce #(if (> (count %2) (max 1 (count %))) %2 %) \n  \t[]\n    (partition-by #(< % 0) \n  \t\t(loop [a (first x)\n         b (second x)\n         c (-> x rest rest)\n         v []]\n    (if (> (count c) 0)\n      (recur (if (if (> a 0) (< a b) (< (- 0 (inc a)) b)) b (- 0 (inc b)))\n             (first c)\n             (rest c)\n             (concat v (if (> a 0) [a] [a (- 0 (inc a))])))\n      (concat v (if (or (< a 1) (< a b)) [a b] [a (- 0 (inc b)) b])))))))","problem":53,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn f2 [coll] (let [f1 (fn [coll]   (reduce #(if (>= (count %) (count %2)) % %2) \n\t\t\t\t\t\t(reductions (fn [x y] (cond (= (count x) 0) [y]\n\t\t\t\t\t\t\t\t\t(< (last x) y) (conj x y) \n\t\t\t\t\t\t\t\t\t:else [y])) [] coll)))]\n\t\t\t\t\t (if (> (count (f1 coll)) 1) (f1 coll) [])))","problem":53,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn [x] \r\n  (reverse \r\n    (apply max-key count \r\n      [] (filter #(> (count %) 1)(reduce \r\n      (fn [seq x] \r\n        (if (empty? (first seq))\r\n    \t\t    (cons (cons x (first seq)) (rest seq))\r\n\t\t\t\t    (if (> x (first (first seq)))\r\n\t\t\t\t        (cons (cons x (first seq)) (rest seq))\r\n\t\t\t\t\t      (cons (list x) seq)))) \r\n    (list '()) x)))))","problem":53,"user":"4f048f67535dcb61093f6bd3"},{"code":"#(nth (reduce (fn [[a b] x] (let [b (if (and b (> x (last b))) (conj b x) [x])] [(if (and (> (count b) 1) (> (count b) (count a))) b a) b])) [[]] %) 0)","problem":53,"user":"4f045946535dcb61093f6bba"},{"code":"(fn longest [xs]\n  (reverse\n    (first\n      (sort-by count >\n        (filter #(<= 2 (count %))\n          (reductions\n            (fn [acc x]\n              (if (= x (inc (first acc)))\n                (cons x acc)\n                [x]))\n            [(first xs)]\n            (rest xs)))))))","problem":53,"user":"504f57c7e4b0a02f9cffde71"},{"problem":53,"code":"(fn [v]\n  (let [longest (fn [v i]\n                  (loop [len 1\n                         j (inc i)]\n                    (if (= (inc (get v (dec j))) (get v j))\n                      (recur (inc len) (inc j))\n                      len)))]\n    (loop [best 0\n           bestpos -1\n           pos 0]\n      (if (= pos (count v))\n        (if (>= best 2)\n          (subvec v bestpos (+ bestpos best))\n          [])\n        (let [long (longest v pos)]\n          (if (> long best)\n            (recur long pos (inc pos))\n            (recur best bestpos (inc pos))))))))","user":"54487527e4b032a45b8693cc"},{"code":"(fn sub-seq [col]\n  (loop [cur_col col tmp_list [] final_list []]\n    (if (empty? cur_col)\n      (if (>(count tmp_list)(count final_list))\n        (if (<(count tmp_list)2)[] tmp_list) (if (<(count final_list)2)[] final_list))\n  \n      (let [cont (if (not(nil? (last tmp_list)))(=(+(last tmp_list)1) (first cur_col))true)]\n        (recur (rest cur_col)\n          (if (true? cont) (conj tmp_list (first cur_col)) [(first cur_col)])\n          (if (true? cont) final_list\n            (if (<(count final_list) (count tmp_list))\n              tmp_list final_list)))))))","problem":53,"user":"4f61be97e4b0defedf855fc5"},{"problem":53,"code":"(fn [l] \n  (let [lt        (partial apply <) \n        pairs     (->> (map vector l (rest l)) \n                       (partition-by lt) \n                       (filter (comp lt first))) \n        max-count (apply max 0 (map count pairs))] \n    (->> pairs \n         (filter (comp (partial = max-count) count)) \n         (first) \n         (#(if % \n             (conj (vec (map first %)) (last (last %))) \n             [])))))","user":"51533ecde4b0252ac4b16619"},{"problem":53,"code":"(fn [[h & t]]\n  (loop [p [h], [sh & st :as s] t, r []]\n    (if (peek p)\n        (if (= (inc (peek p)) sh) \n            (recur `[~@p ~sh] st r) \n            (recur [sh] st\n              (let [cp (count p) cr (count r)] \n                (if (and (> cp 1) (< cr cp)) p r)))) \n        r)))","user":"548b7db8e4b0e286459a11fd"},{"problem":53,"code":"(fn [xs]\n  (first \n   (reduce\n    (fn [[l c] x]\n     (let [new-c (if (and (not (empty? c)) (< (last c) x)) \n                   (conj c x) \n                   [x])]\n      (vector \n       (if (and (< 1 (count new-c)) (< (count l) (count new-c))) new-c l) \n       new-c)))\n    [[] []]\n    xs)))","user":"5f5e7158e4b02876ed9fcff0"},{"problem":53,"code":"(fn foo [coll]\n  (let [increase? (fn [xs]\n                    (if (<= (count xs) 1)\n                      true\n                      (and (< (first xs) (second xs)) (recur (rest xs)))))\n        longer (fn [xs ys] (if (>= (count xs) (count ys)) xs ys))]\n    (if (> (count coll) 1)\n      (let [div (int (/ (inc (count coll)) 2))\n            [head tail] (map vec (split-at div coll))\n            start (some #(if (increase? (subvec coll % (inc div))) %)\n                        (range div))\n            end (some #(if (increase? (subvec coll div %)) %)\n                      (map inc (reverse (drop div (range (count coll))))))\n            sub-mid (if (and start end) (subvec coll start end))]\n        (longer (longer (foo head) (foo tail)) sub-mid))\n      [])))","user":"54c5cc17e4b045293a27f624"},{"problem":53,"code":"(fn [param]\n    (or\n      (last\n        (sort-by count\n                 (reverse\n                   (filter\n                     #(> (count %) 1)\n                     (reduce\n                       (fn [acc elem]\n                         (if (empty? acc)\n                           [[elem]]\n                           (if (< (last (last acc)) elem)\n                             (conj (pop acc) (conj (last acc) elem))\n                             (conj acc [elem])\n                             )\n                           )) [] param)))))\n      [])\n    )","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [s]\n    (loop [rem s max []]\n      (if (empty? rem)\n        max\n        (let [c (take-while (fn [[a b]] (> b a)) (partition 2 1 rem))\n              v (subvec (vec rem) 0 (if (zero? (count c)) 0 (inc (count c))))]\n          (if (> (count v) (count max))\n            (recur (rest rem) v)\n            (recur (rest rem) max))))))","problem":53,"user":"4e6f1b7a535d5021c1a89618"},{"code":"(fn [arr]\n\t(loop [resv []  t arr]\n\t   (if (empty? t)\n\t       (if (= (count resv) 1)\n\t\t   []\n\t\t   resv)\n\t       (let [r (keep #(if % %) (map #(if (= % %2) %) (range (first t) (+ (count t) (first t)))\n\t\t\t    t)),\n\t\t    startidx (count r)]\n\t\t    (recur (if(< (count r) (count resv))\n\t\t\t      resv\n\t\t\t      r)\n\t\t\t      (drop startidx t))))))","problem":53,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":53,"code":"(fn\n  [input]\n  (let \n    [\n     getLast (fn [x] (if (nil? (last x)) Long/MIN_VALUE (last x)))\n     newMaxS (fn ([a b] (if (>= (count a) (count b)) a b)))\n     wrappedNewMax (fn [[a, b]] (let [res (newMaxS a b)] (if (= (count res) 1) [] res)))\n     predicate (fn [[maxS, curS], curN]\n       (if (< (getLast curS) curN)\n         (vector maxS (conj curS curN))\n         (vector (newMaxS maxS curS) (vector curN))\n       )\n     )\n     initState (vector [] [])\n    ]\n    (wrappedNewMax (reduce predicate initState input))\n  )\n)","user":"5717d674e4b07c98581c3b1a"},{"problem":53,"code":"(fn [ns]\n  (loop [ns ns\n         pn nil\n         at-seq []\n         longest []]\n    (let [pick-longest (fn [] (if (and (> (count at-seq) 1) (> (count at-seq) (count longest))) at-seq longest))\n          at-n (first ns)]\n      (cond\n        (empty? ns)\n        (pick-longest)\n\n        (or (not pn) (= at-n (inc pn)))\n        (recur (rest ns)\n               at-n\n               (conj at-seq at-n)\n               longest)\n\n        :else\n        (recur (rest ns)\n               at-n\n               [at-n]\n               (pick-longest))))))","user":"5db35f85e4b010eb3c36cd22"},{"problem":53,"code":"(let [longest-increasing-subseq* (fn longest-increasing-subseq* [longest-begin longest-end current-start current-idx last-val items]\n  (let [longest-length (if (and (not (nil? longest-begin)) (not (nil? longest-end))) (- longest-end longest-begin) 0)\n        head (first items)\n        tail (rest items)]\n    (if (nil? head)\n      [longest-begin longest-end]\n      (if (or (nil? last-val) (> head last-val))\n        (let [new-longest (> (- current-idx current-start) longest-length)\n              overall-begin (if (or new-longest (nil? longest-begin)) current-start longest-begin)\n              overall-end (if (or new-longest (nil? longest-end)) current-idx longest-end)]\n          (longest-increasing-subseq* overall-begin overall-end current-start (inc current-idx) head tail))\n        (longest-increasing-subseq* (if (nil? longest-begin) current-idx longest-begin) (if (nil? longest-end) current-idx longest-end) current-idx (inc current-idx) head tail)))))\n\n longest-increasing-subseq (fn longest-increasing-subseq [items]\n  (let [[start end] (longest-increasing-subseq* nil nil 0 0 nil items)]\n    (if (> (- end start) 0)\n    (subvec items start (inc end)) [])))] longest-increasing-subseq)","user":"5f763c78e4b02876ed9fd0b0"},{"code":"(fn [xs] \n  (let [ms (last (sort-by count (rseq (reduce #(let [s (peek %)] (if (> %2 (peek s)) (conj (pop %) (conj s %2)) (conj % (vector %2)))) [[(first xs)]] (rest xs)))))]\n    (if (> (count ms) 1) ms [])))","problem":53,"user":"4ed06ea6535d44c135fd68c4"},{"problem":53,"code":"(letfn [(partition-inc [arr]\n          (loop [coll (next arr) now [(first arr)] result []]\n            (cond\n              (empty? coll) (conj result now)\n              (> (first coll) (peek now))\n              (recur (next coll) (conj now (first coll))\n                     result)\n              :else (recur (next coll) [(first coll)]\n                           (conj result now)))))\n        (get-max-len [coll]\n          (->> (filter #(<= 2 (count %)) coll)\n               (reduce (fn [r s]\n                         (if (< (count r) (count s))\n                           s\n                           r))\n                       [])))\n        (yeah [coll]\n          (->> (partition-inc coll)\n               (get-max-len)))]\n  yeah)","user":"55db7e15e4b0e31453f64ae8"},{"problem":53,"code":"(fn [coll]\n  (letfn [(take-while-increasing [coll]\n            (->> (partition 2 1 (cons (dec (first coll)) coll))\n                 (take-while (fn [[a b]] (< a b)))\n                 (map second)))]\n    (->> coll\n      (partition-all (count coll) 1)\n      (map take-while-increasing)\n      (filter #(> (count %) 1))\n      (reduce #(if (> (count %2) (count %1)) %2 %1) []))))","user":"52470d42e4b05ef8e38e6350"},{"problem":53,"code":"(fn [s] (->> (partition 2 1 s)\n             (partition-by #(apply < %))\n             (filter #(< (ffirst %) (second (first %))))\n             (reduce #(if (< (count %1) (count %2)) %2 %1 ) [])\n             (#(if (empty? %) % (cons (ffirst %) (map second %))))))","user":"56b86e64e4b0f26550335924"},{"code":"(fn longest-subseq--group\n  [coll] {:pre [(every? integer? coll)]}\n  (->> coll\n       ;; The following line replaces each element with the longest increasing\n       ;; subsequence that ends in that element.\n       (reductions #(if (and (seq %1) (> %2 (peek %1))) (conj %1 %2) [%2]) [])\n       (group-by count)      ; a map of all increasing susbseqs, keyed by length\n       (apply max-key key)\n       last                  ; a vector of all longest increasing subseqs\n       first                 ; the first, longest increasing subseq\n       ((fn [x] (if (= (count x) 1) [] x))))) ; ignoring a singleton subseq","problem":53,"user":"4fc6305de4b0ee37620e180b"},{"code":"(fn\n    [s]\n    (let [rst\n          (reduce #(if (> (count %2) (count %1))\n                     %2\n                     %1)\n                  (reduce #(let [llist (last %1)\n                                 lelm (last llist)\n                                 lidx (- (count %1) 1)]\n                             (cond\n                              (nil? llist) [[%2]]\n                              (> %2 lelm) (update-in %1 [lidx] conj %2)\n                              :else (conj %1 [%2])))\n                          []\n                          s))]\n      (if (= (count rst) 1)\n        []\n        rst)))","problem":53,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn[s]\r\n  (let [x (apply max-key count (reverse\r\n            (loop [v (rest s) r [[(first s)]]]\r\n              (if (empty? v) r\r\n               (recur (rest v) \r\n                 (if \r\n                   (< (last(last r)) (first v))\r\n                   (assoc r (dec (count r)) (conj (last r) (first v)))  \r\n                  (conj r [(first v)])))))))]\r\n   (if (> (count x) 1) x [])))","problem":53,"user":"4deff9f9535d08e6dec9fe15"},{"problem":53,"code":"(fn [xs]\n  (let [longest (:longest-seq (reduce (fn [{:keys [current-seq longest-seq ]} item]\n            (if (> item (last current-seq))\n              (if (> (+ 1 (count current-seq)) (count longest-seq))\n                {:current-seq (conj current-seq item)\n                 :longest-seq (conj current-seq item)}\n                {:current-seq (conj current-seq item)\n                 :longest-seq longest-seq})\n              {:current-seq [item]\n               :longest-seq longest-seq}))\n          {:current-seq [(first xs)]\n           :longest-seq [(first xs)]}\n          (rest xs)))]\n        (if (< (count longest) 2)\n            []\n            longest)))","user":"58740c18e4b01531a375ea49"},{"problem":53,"code":"(fn [x]\n  (letfn [(give-sub [xs]\n            (cond\n              (empty? (rest xs)) xs\n              (< (first xs) (second xs)) (cons (first xs) (give-sub (rest xs)))\n              :else [(first xs)]))\n          (f [acc xs]\n            (cond\n              (empty? xs) acc\n\n              (>= (count acc)\n                  (count (give-sub xs)))\n              (f acc (rest xs))\n\n              :else (f (give-sub xs) (rest xs))))]\n    (if (> (count (f [] x)) 1)\n      (f [] x)\n      [])))","user":"571ac75ae4b07c98581c3b5c"},{"problem":53,"code":"(fn [x] (or (->> (partition 2 1 x)\n                  (map (fn [[f n]] [(- n f) [f n]]))\n                  (partition-by #(= (first %) 1))\n                  (filter #(= (ffirst %) 1))\n                  (map #(distinct (reduce (fn [a [_ b]] (into a b)) [] %)))\n                  (sort #(> (count %) (count %2)))\n                  first)\n             []))","user":"5382704be4b06839e8705ed4"},{"problem":53,"code":"(fn [x] (let [grouped (group-by count ((fn [pred? coll] \n                                          (let [switch (reductions not= true (map pred? coll (rest coll)))] \n                                            (map (partial map first) (partition-by second (map list coll switch))))) \n                                        (fn [a b] (or (= a b)(< b a))) x))\n      max-cnt (apply max (keys grouped))\n      val-max (get grouped max-cnt)\n      first-val (first val-max)]\n  (if (= (count first-val) 1)\n    []\n    first-val)))","user":"57c0393be4b05aa3c4741c90"},{"problem":53,"code":"(fn [s]\n  (letfn [(split-increasing [acc [s0 s1 :as s]]\n            (if (empty? s)\n              nil\n              (let [acc' (conj acc s0) rs (rest s)]\n                (if (and s1 (< s0 s1))\n                  (recur acc' rs)\n                  (cons acc' (split-increasing [] rs))))))]\n    (let [ss (filter #(> (count %) 1) (split-increasing [] s))]\n      (if (empty? ss)\n        []\n        (let [len (apply max (map count ss))]\n          (first (filter #(= (count %) len) ss)))))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":53,"code":"#((fn [[r _]] (if (> (count r) 1) r []))\n  (reduce (fn [[r a] y]\n            (if (= (last a) (dec y))\n              (let [b (conj a y)]\n                (if (> (count b) (count r))\n                  [b b]\n                  [r b]))\n              [r [y]])) [[] []] %))","user":"56cd44fde4b0ea9b8538f749"},{"problem":53,"code":"(fn incseq\n  ([x] (incseq x [] []))\n  ([x l c]\n   (if (= (count x) 1)\n     (if (> (count l) (inc (count c)))\n       l\n       (if (empty? c)\n         c\n         (conj c (first x))))\n     (if (= (second x) (inc (first x)))\n       (incseq (rest x) l (conj c (first x)))\n       (if (> (count l) (inc (count c)))\n         (incseq (rest x) l [])\n         (incseq (rest x) (conj c (first x)) []))))))","user":"586b6a0ae4b01531a375e957"},{"problem":53,"code":"(comp #(if (nil? %) [] %)\n      first\n      #(sort-by count > %)\n      #(letfn [(inc-ord [[e1 e2]] (< e1 e2))]\n         (loop [pairseq (map vector % (rest %))\n                subseqs []]\n           (if (empty? pairseq)\n             subseqs\n             (let [ord-seq (take-while inc-ord pairseq)\n                   size (count ord-seq)]\n               (if (zero? size)\n                 (recur (rest pairseq) subseqs)\n                 (recur (drop size pairseq)\n                        (conj subseqs\n                              (cons (first (first ord-seq))\n                                    (map last ord-seq))))))))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":53,"code":"(fn longest-sub-seq\n  ([col] (longest-sub-seq (rest col) [] [(first col)]))\n  ([col longest current]\n   (let [n (first col)\n         current-len (count current)\n         longest-len (count longest)\n         choose-longest #(if (and (> current-len 1) \n                                 (> current-len longest-len)) \n                          current \n                          longest)]\n     (if (empty? col) \n       (choose-longest)\n       (if (or (> n (last current)) (empty? col))\n         (recur (rest col) longest (conj current n))\n         (recur (rest col) (choose-longest) [n]))))))","user":"5956c6dae4b066ee0a44af61"},{"problem":53,"code":"(fn longest-inc-subseq\n  [se]\n  (let [inc-subseqs (fn \n                     [se]\n                     (loop [outer-accum (vector) \n                            inner-accum (vector (first se))\n                            se (rest se)]\n                       (let [long-enough (> (count inner-accum) 1)]\n                         (if (empty? se)\n                           (if long-enough (conj outer-accum inner-accum)\n                             outer-accum)\n                           (if (< (peek inner-accum) (first se))\n                             (recur outer-accum (conj inner-accum (first se)) (rest se))\n                             (if long-enough\n                               (recur (conj outer-accum inner-accum) (vector (first se)) (rest se))\n                               (recur outer-accum (vector (first se)) (rest se))))))))]\n    (reduce (fn [a b] (if (< (count a) (count b)) b a)) [] (inc-subseqs se))))","user":"554d386ee4b0a04f792995b8"},{"code":"(fn [coll]\n  (let [a (partition-by #(apply < %) (partition 2 1 coll))\n        b (filter (fn [[[x1 x2]]] (< x1 x2)) a)\n        c (first (sort-by count > b))]\n   (concat (first c) (map last (rest c)))))","problem":53,"user":"4f7426fde4b044e54cd9a8f5"},{"code":"(fn [v]\n    (let [i (count v)]\n      (or (first (for [length (reverse (range 1 (inc i)))\n                       start (range 0 (- i length))\n                       :let [end (+ start length 1)\n                             sub-vector (subvec v start end)]\n                       :when (apply < sub-vector)]\n                   sub-vector))\n          [])))","problem":53,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn party [xs]\n  (let [bef-aft (fn [xs] (map list xs (concat [nil] (butlast xs))))\n        reducer #(if (nil? (second %2)) (conj % 0) (if (> (first %2) (second %2)) (conj % (last %)) (conj % (inc (last %)))))\n        paired (map list xs (reduce reducer [] (bef-aft xs)))\n        chunks (map #(map first %) (partition-by second paired))\n        longest (reduce #(if (>= (count %) (count %2)) % %2) chunks)\n       ]\n    (if (> (count longest) 1) longest [])\n    ))","problem":53,"user":"52741177e4b03e8d9a4a749b"},{"code":"(letfn [(U [a* a]\n          (if (and (>= (count a*) 2)\n                   (>= (count a*) (count a)))\n            a* a))\n\n        (X [s t* t]\n          (cond (empty? s) (U t* t)\n                (= (first s) (inc (last t*))) (recur (rest s) (conj t* (first s)) t)\n                :else (recur (rest s) [(first s)] (U t* t))))]\n  (fn [s]\n    (X (rest s) [(first s)] [])))","problem":53,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [coll] \n (let [my-reduce (fn [c1] \n                   (if (empty? c1) \n                     []   \n                     (reduce (fn [v1 v2] (if (>= (count v1) (count v2)) v1 v2 ) ) c1)))\n       x (my-reduce (filter #(< (second (first %)) 0) \n                            (partition-by #(>= (second %) 0) \n                                          (map-indexed (fn [idx itm] [idx itm] )\n                                                       (map - coll (rest coll))))))]\n   (if (empty? x) \n     x\n     (take (+ 1 (count x)) (drop (first (first x)) coll)))))","problem":53,"user":"4f038ed6535dcb61093f6b24"},{"problem":53,"code":"(fn clj4-rise\n  [coll]\n  (let [\n        frags (for [n (range (count coll))] (drop n coll))\n        rises (map (fn [frag]\n                     (let [pairs (partition 2 1 frag)\n                           rising-pairs (take-while #(< (first %) (second %)) pairs)]\n                       (list* (apply sorted-set (flatten rising-pairs)))))\n                   frags)\n        longest (reduce #(if (> (count %2) (count %)) %2 %) [] rises)]\n    longest))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn liss \r\n  ([coll] (if (empty? coll) [] (liss (rest coll) [] 0 (vector (first coll)) 1 (first coll))))\r\n  ([coll bestseq bestlen actseq actlen lastelem]\r\n    (cond\r\n      (empty? coll)\r\n        (let [seq (if (> actlen bestlen) actseq bestseq)\r\n              len (count seq)]\r\n              (if (> len 1) seq []))\r\n      (< lastelem (first coll))\r\n        (liss (rest coll) bestseq bestlen (conj actseq (first coll)) (inc actlen) (first coll))\r\n      true\r\n        (liss (rest coll)\r\n              (if (> actlen bestlen) actseq bestseq)\r\n              (max actlen bestlen)\r\n              (vector (first coll))\r\n              1\r\n              (first coll)\r\n))))","problem":53,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [xs]\n  (first (reduce\n(fn [[greatest current] x]\n  (if (empty? current)\n    [greatest [x]]\n    (if (> x (last current))\n      (let [current (conj current x)]\n        (if \n          (> (count current) (count greatest))\n          [current current]\n          [greatest current]))\n      [greatest [x]])))\n[[] []] xs)))","problem":53,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":53,"code":";; iterate over list, \n;; put the first thing you see in an accumulator [[x]]\n;; if the next element is greater than the last item in the last accumulator, add it. otherwise create a new accumulator [[x][y]]\n;; filter accumulators by (>= count 2)\n;; sort by length, pick first.\n\n(fn [coll]\n  (->> coll\n       (reduce \n    \t(fn [[subseq & others] n]\n      \t (let [last-n (or (last subseq) 0)]\n          (cond\n           (> n last-n) (cons (conj subseq n) \n                              others);; add to subseq\n           (<= n last-n) (cons [n] (cons subseq others)))));; start a new subseq\n        (list []))\n       (filter #(>= (count %) 2))\n       (sort-by count)\n        last \n        vec)) ;; in case there are no subseqs where (> count 2), (= [] (vec nil))","user":"5665ef78e4b0e91d5f5c5664"},{"problem":53,"code":"(fn longest-increasing-subseq [v]\n  (loop [s 0\n         c 1\n         bs 0\n         be -1]\n    (if (= c (count v))\n      (subvec v bs (inc be))\n      (let [cv (get v c)\n            lv (get v (dec c))\n            is-bigger (> cv lv)\n            is-longer (> (- c s) (- be bs))]\n        (cond\n          (and is-bigger is-longer) (recur s (inc c) s c)\n          is-bigger (recur s (inc c) bs be)\n          :else (recur c (inc c) bs be))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":53,"code":"(fn longest-subsequence [sequence]\n  (let [val (last (sort\n          (loop [ [a b :as remaining] sequence\n                  current []\n                  subsequences []]\n              (cond\n                (and (nil? a) (nil? b)) subsequences\n                (nil? b) (conj subsequences (conj current a))\n                (< a b) (recur (rest remaining) (conj current a) subsequences)\n                :else (recur (rest remaining) [] (conj subsequences (conj current a)))\n                    )\n              )))]\n    (if ( > (count val) 1) val []))\n  )","user":"525d44bfe4b0cb4875a45d6d"},{"problem":53,"code":"(fn find-max-range [coll]\n  (let [length (count coll)\n        coll (concat coll [Double/NEGATIVE_INFINITY])]\n    (loop [i 0\n           current-start 0\n           best-start 0\n           best-range 0]\n      (if (< i length)\n        (if (< (nth coll i)\n               (nth coll (inc i)))\n          (recur (inc i)\n                 current-start\n                 best-start\n                 best-range)\n          (let [new-range (- i current-start)]\n            (if (> new-range best-range)\n              (recur (inc i)\n                     (inc i)\n                     current-start\n                     new-range)\n              (recur (inc i)\n                     (inc i)\n                     best-start\n                     best-range))))\n        (if (zero? best-range)\n          []\n          (->> coll\n             (drop best-start)\n             (take (inc best-range))))))))","user":"56c33ceae4b05cc29241ee89"},{"code":"; prime by popping the first item off of input seq\n; and putting to result.\n; (init longest-result?)\n; now, can loop:\n; if (empty? input-seq)\n;   longest-result\n; if (first input-seq) == (inc (last result))\n;   join (first input-seq) to end of result.\n;   if result is > longest-result, replace longest-result.\n; else \n;   init result with (first input-seq) as init value.\n;   keep longest-result.\n\n(fn [inp-seq]\n  (loop [result [(first inp-seq)]\n         longest-result result\n         inp-seq (rest inp-seq)]\n    (cond\n      (empty? inp-seq)\n        (if (= 1 (count longest-result)) [] longest-result)\n      (= (first inp-seq) (inc (last result)))\n        (recur (conj result (first inp-seq))\n               (if (> (inc (count result)) (count longest-result))\n                 (conj result (first inp-seq)) longest-result)\n               (rest inp-seq))\n      :else\n        (recur [(first inp-seq)] longest-result (rest inp-seq))\n)))","problem":53,"user":"5070e31ee4b0e3170b5a8678"},{"code":"(letfn\n  [(take-incr \n     ([iseq xseq]\n       (let [[i & is] iseq]\n         (if-let [[x & xs] xseq]\n           (if (> x i)\n             (recur (cons x iseq) xs)\n             [(reverse iseq) xseq])\n           [(reverse iseq) xseq])))\n     ([xseq]\n       (if-let [[x & xs] xseq]\n         (take-incr [x] xs)\n         [])))\n   (unfold [f s]\n     (let [[l r] (f s)]\n       (loop [ls [l] rs r]\n       (if (nil? rs) ls\n         (let [[nl nr] (f rs)]\n           (recur\n             (conj ls nl)\n             nr))))))]\n  (comp\n    #(if (empty? %) [] (first %))\n    (partial sort-by count >)\n    (partial filter (comp (partial < 1) count))\n    (partial unfold take-incr)))","problem":53,"user":"50657775e4b0deb876850599"},{"problem":53,"code":"(fn [arr]\n  (->> (map vector arr (drop 1 arr))\n       (partition-by (partial apply <))\n       (filter #(apply < (first %)))\n       (reduce #(if (>= (count %1) (count %2))\n                  %1 %2)\n               ())\n       (apply concat)\n       set\n       sort))","user":"60096aabe4b074f607df667f"},{"code":"(fn [coll]\r\n  (->> (partition 2 1 coll) \r\n    (partition-by #(- (second %) (first %))) \r\n    (filter #(= 1 (- (second (first %)) (ffirst %)))) \r\n    (reduce #(if (< (count %1) (count %2)) %2 %1) [])\r\n    flatten\r\n    distinct))","problem":53,"user":"4df168bd535d08e6dec9fe1d"},{"problem":53,"code":"(fn [xs]\n  (loop [curr []\n         longest []\n         remaining xs]\n    (if (nil? (seq remaining))\n      (let [longest (if (> (count curr) (count longest)) curr longest)]\n        (if (> (count longest) 1)\n          longest\n          []))\n      (let [x (first remaining)\n            prev (last curr)]\n        (if (or (nil? prev) (> x prev))\n          (recur (conj curr x) longest (rest remaining))\n          (let [numc (count curr)\n                numl (count longest)\n                longest (if (> numc numl) curr longest)]\n            (recur [x] longest (rest remaining))))))))","user":"53161a56e4b08068f379ed3e"},{"code":"(fn [x] (->> x (rest) (reduce #(\n  if (>= (last (second %)) %2)\n    [(first %) [%2]]\n    (if (<= (count (first %)) (count (second %)))\n      [(concat (second %) [%2]) (concat (second %) [%2])]\n      [(first %) (concat (second %) [%2])]\n    )\n) [[(first x)] [(first x)]]) (first) (#(if (= 1 (count %)) [] %))\n))","problem":53,"user":"4f01c938535dcb61093f6a39"},{"code":"(fn [coll]                                                                                                                                                                                               \n   (let [increasing? #(apply < %)                                                                                                                                                                                   \n         subseqs (fn [coll] (mapcat #(partition % 1 coll) (range 2 (inc (count coll)))))                                                                                                                            \n         ss (subseqs coll)]                                                                                                                                                                                         \n     (->> ss                                                                                                                                                                                                        \n          (filter increasing?)                                                                                                                                                                                      \n          (cons [])                                                                                                                                                                                                 \n          (sort-by count >)                                                                                                                                                                                         \n          first)))","problem":53,"user":"4e944706535dbda64a6f6b11"},{"problem":53,"code":"(fn [ls]\n  (:max-seq \n   (reduce \n    (fn [{:keys [max-seq current-seq] :as acc} elem] \n      (let [last-elem (last current-seq)]\n        (if (or (nil? last-elem) (<= elem last-elem))\n          (assoc acc :current-seq [elem])\n          (let [new-seq (conj current-seq elem)\n                acc (assoc acc :current-seq new-seq)]\n            (if (< (count max-seq) (count new-seq))\n              (assoc acc :max-seq new-seq)\n              acc)))))\n    {:max-seq [] :current-seq []} ls)))\n\n;#(:max-increasing-seq \n;  (reduce \n;   (fn [{:keys [max-increasing-seq current-seq]} elem] \n;     (if-let [last-elem (last current-seq)]\n;       (if (> elem last-elem)\n;         (let [current-seq (conj current-seq elem)]\n;           (if (< (count max-increasing-seq) (count current-seq))\n;             {:max-increasing-seq current-seq :current-seq current-seq}\n;             {:max-increasing-seq max-increasing-seq :current-seq current-seq}))\n;         {:max-increasing-seq max-increasing-seq :current-seq [elem]})\n;       {:max-increasing-seq max-increasing-seq :current-seq [elem]}))\n;   {:max-increasing-seq [] :current-seq []} %))\n\n;(fn [ls]\n;  (loop [increasing-subseqs [] current-seq [] elem (first ls) ls (rest ls)]\n;    (cond \n;     (nil? elem) \n;     (if-let [longest (first (sort-by (comp - count) (remove #(= (count %) 1) increasing-subseqs)))]\n;       longest\n;       [])\n     \n;     (empty? current-seq) \n;     (let [current-seq (conj current-seq elem)] \n;       (recur (conj increasing-subseqs current-seq) current-seq (first ls) (rest ls)))\n     \n;     :else \n;     (let [previous-elem (last current-seq)]\n;       (if (> elem previous-elem)\n;         (recur (conj increasing-subseqs (conj current-seq elem)) (conj current-seq elem) (first ls) (rest ls))\n;         (recur increasing-subseqs [elem] (first ls) (rest ls)))))))","user":"52f3568fe4b05e3f0be25f0e"},{"code":"(fn[a-seq]\n  (letfn [(max-of [s1 s2] (if (> (count s1) (count s2)) s1 s2))]\n    (loop [ret []\n           curr [(first a-seq)]\n           ss (rest a-seq)]\n      (if (empty? ss)\n        (let [ret (max-of curr ret)]\n          (if (> (count ret) 1) ret []))\n        (if (> (first ss) (last curr))\n          (recur ret (conj curr (first ss)) (rest ss))\n          (recur (max-of curr ret) [(first ss)] (rest ss)))))))","problem":53,"user":"4e58bcd4535d8a8b8723a296"},{"problem":53,"code":"#(->> \n     (for [r (range (dec (count %)))] (if (= (- (% r) (% (+ 1 r))) -1) [(% r) (% (+ 1 r))] ))\n     (partition-by type)\n     (map (comp distinct flatten (partial remove nil?) ))\n     (sort-by count)\n     last\n)","user":"532018efe4b08068f379edcd"},{"code":"(fn find [s]\n  (let [pairs\n      (loop [longest []\n        ss (for [[c p] (map vector (rest s) s)]\n              [c p (> c p)])\n        ]\n        (let [\n          [next rest] \n            (split-with last ss)\n          nlongest \n            (if (> (count next) (count longest)) \n              next longest)]\n          (if (empty? rest) nlongest\n            (recur nlongest\n              (drop-while (comp not last) rest)))))]\n      (if (empty? pairs) pairs\n        (cons (second (first pairs)) (map first pairs))))\n)","problem":53,"user":"50901b2ee4b0ea685a20f774"},{"code":"#(loop [i 1 start 0 max-len 1 max-start 0]\n   (cond (= i (count %))\n     (if (> max-len 1)\n       (take max-len (drop max-start %))\n       [])\n     (not (= (nth % i) (inc (nth % (dec i)))))\n       (recur (inc i) i max-len max-start)\n     (> (inc (- i start)) max-len)\n       (recur (inc i) start (inc (- i start)) start)\n     :else\n       (recur (inc i) start max-len max-start)))","problem":53,"user":"4e4ae5aa535dc968683fc4d2"},{"problem":53,"code":"#(apply max-key %\r\n  (reverse\r\n   (for [x (%2 (% %3)) % (%2 x (- (% %3) 1))\r\n\t   :let [% (subvec %3 x (+ % 2))]]\r\n     (if (apply < %) % []))))\r\ncount range","user":"58f45ea0e4b0438e51c2cebc"},{"code":"(fn [xs]\r\n       (first (reduce (fn [[longest current] x] \r\n                 (let [new-current (conj current x)]\r\n                     (if (= (last current) (dec x))\r\n                       (if (and (> (count new-current) (count longest))\r\n                             (> (count new-current) 1))\r\n                         [new-current new-current]\r\n                         [longest new-current])\r\n                       (if (and (> (count current) (count longest))\r\n                             (> (count current) 1))\r\n                         [current [x]]\r\n                         [longest [x]]))))\r\n         [[] []] xs)))","problem":53,"user":"4deb529a535d08e6dec9fe04"},{"code":"(fn longest-inc [coll]\n  (let [increasing (fn  [coll]\n            (loop [n 1 c coll]\n              (if (or (empty? (rest c)) (>= (first c) (first (rest c))))\n                (take n coll)\n                (recur (inc n) (rest c)))))\n        inc-seqs (filter #(> (count %) 1)\n                         (map (comp increasing #(drop % coll))\n                              (range (count coll))))]\n    (if (empty? inc-seqs)\n      '()\n      (first (sort #(> (count %1) (count %2)) inc-seqs)))))","problem":53,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":53,"code":"(fn longest-monotonic [a-seq]\n  (loop [l a-seq\n         acc []\n         curr []]\n    (if (empty? l)\n      (if (< (count acc) 2)\n        []\n        acc)\n      (if (or (empty? curr) (> (first l) (last curr)))\n        (recur (rest l) (if (> (inc (count curr)) (count acc)) (conj curr (first l)) acc) (conj curr (first l)))\n        (recur (rest l) acc [(first l)])))))","user":"5f86a98be4b0649ffcda4caa"},{"problem":53,"code":"(fn [s]\n    (let [n (count s)]\n      (apply max-key\n             count\n             (conj (reverse (for [i (range n)\n                                  j (range (+ 2 i) (inc n))\n                                  :let [t (subvec s i j)]\n                                  :when (apply < t)]\n                              t))\n                   [])))\n    )","user":"5bd0ea60e4b0e9689409ee45"},{"problem":53,"code":"(fn [s] (if-let [a (last (sort-by count\n                                   (reverse (map (fn [x] (filter #(not( = true %)) x))\n                                                 (filter #(< 2 (count %))\n                                                         (partition-by false?\n                                                                       (interleave\n                                                                        (cons false (map (fn [[a b]] (< a b)) (partition 2 1 s)))\n                                                                        s)))))))]\n           a\n           []))","user":"57cf13d1e4b00451144b04fb"},{"problem":53,"code":"(fn [s] (->> s\n              (partition 2 1)\n              (partition-by #(apply < %))\n              (keep (fn [[[a b :as f] & r]]\n                      (if (> b a)\n                        (concat f (map second r)))))\n              (cons [])   \n              (sort-by count >)\n              first))","user":"5466aabbe4b01be26fd746e8"},{"code":"(fn [l]\n  (or                                                                                                                                                  \n   (->> l                                                                                                                                              \n        (partition 2 1)                                                                                                                                \n        (partition-by #(< (first %) (second %)))                                                                                                       \n        (filter #(<= (ffirst %) (second (first %))))                                                                                                   \n        (map (fn [x] (reduce #(conj % (second %2)) [(ffirst x)] x)))                                                                                    \n        (sort #(> (count %) (count %2)))                                                                                                               \n        first)                                                                                                                                         \n   []))","problem":53,"user":"4ef77c82535dced4c769f253"},{"problem":53,"code":"(fn final [c]\n  (loop [coll c cumm [] span (hash-set (first coll))]\n    (let [f (first coll) r (rest coll) s (first r) coll-count (count coll)]\n      (cond\n       (= coll-count 1)\n         (recur r (conj cumm (into span #{f})) #{})\n       (= coll-count 0)\n         (->> cumm \n              (sort-by count) \n              (reverse) \n              (filter #(> (count %) 1)) \n              (first) \n              (vec))\n       (= (- s f) 1)\n         (recur r (conj cumm span) (into span #{f s}))\n       :else\n         (recur r (conj cumm (into span #{f})) #{s})))))","user":"5546704be4b0a04f7929953d"},{"code":"(fn long-seq* [s]\n  (let [c (count s)\n        m (for [i (range 1 c)]\n            (for [j (range i c) \n                  :while (< (nth s (dec j)) (nth s j))]\n              (if (= i j) \n                [(nth s (dec j)) (nth s j)]\n                (nth s j))))]\n    (vec (first\n          (sort-by #(/ (count %))\n                   (filter #(pos? (count %)) \n                           (map flatten m)))))))","problem":53,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn [s]\n  (first (sort-by #(* -1 (count %))\n    (concat (map (comp vec set (partial apply concat))\n      (filter #(< (first (first %)) (second (first %)))\n        (partition-by (partial apply compare)\n          (partition 2 1 s)))) '([])))))","problem":53,"user":"4ede361a535d10e5ff6f5332"},{"code":"(fn longsub [coll]\n (sequence (last (sort-by count (filter #(< 1 (count %))(reduce (fn [acc el]\n                      (cond (= (dec el) (peek (peek acc))) \n\t\t\t\t\t            (conj (pop acc) (conj (peek acc) el))\n                            :else (conj acc [el])) )\n                    []\n                    coll))))))","problem":53,"user":"523a9fc9e4b081681ca7adca"},{"problem":53,"code":"#(let [res (:v (first (sort-by :l > (reduce \n                         (fn [r i] (let [lr (last r) l (last (:v lr))]\n           (if (= (inc l) i)\n             (assoc r (dec (count r)) (assoc lr :l (inc (:l lr)) :v (conj (:v lr) i)))\n             (conj r {:l 1 :v (conj [] i)})\n             )))\n         (conj [] {:l 1 :v (conj [] (first %))}) (rest %)))))]\n   (if (> (count res) 1)\n     res\n     []))","user":"56165702e4b06b1bb2182a02"},{"code":"#(let [f (fn [v] (loop [acc []\n       s v]\n\t    (let [[x & xs] s]\n\t      (if (or (empty? xs) (not= (inc x) (first xs)))\n\t\t[(conj acc x) (vec xs)]\n\t      (recur (conj acc x) xs)))))]\n\t  (loop [ans []\n\t\t lst %]\n\t\t(let [tmp (f lst)\n\t\t      cand (first tmp)\n\t\t      len (count cand)\n\t\t      left (second tmp)\n\t\t      best (if (and (> len 1) (> len (count ans))) cand ans)]\n\t\t  (if (empty? left)\n\t\t      best\n\t\t    (recur best left)))))","problem":53,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn [s]\n  (->>\n   (reduce (fn [acc x]\n             (let [a (peek acc)\n                   b (inc (last a))]\n               (if (= x b)\n                 (conj (pop acc) (conj a x))\n                 (conj acc [x]))))\n           [[(first s)]]\n           (rest s))\n   (sort-by count)\n   last\n   (#(if (> (count %) 1) % []))))","problem":53,"user":"5300158ae4b0d8b024fd370f"},{"problem":53,"code":"(fn [col]\n    (last\n     (sort\n      (map #(if (> (count %) 1) % [])\n           ((fn\n              [[x & xs] acc]\n              (println x xs acc (-> acc first last))\n              (cond\n               (nil? x) acc\n               (empty? acc) (recur xs (conj acc [x]))\n               (<= x (-> acc first last)) (recur xs (conj acc [x]))\n               :or (recur xs (conj (rest acc) (conj (first acc) x))))) col ())))))","user":"554c296ae4b0a04f792995a1"},{"problem":53,"code":"(fn longest-subseq [xs]\n  (let [redf (fn [res elm]\n               (let [max-subseq (:max-subseq res)\n                     subseq (:subseq res)]\n                 (if (= 1 (compare elm (last subseq)))\n                   {:subseq (conj subseq elm)\n                    :max-subseq max-subseq}\n                   {:subseq [elm]\n                    :max-subseq (if (<= (count subseq)\n                                        (count max-subseq))\n                                  max-subseq\n                                  subseq)})))\n        res (reduce\n              redf\n              {:subseq (into [] (take 1 xs)) :max-subseq []}\n              (rest xs))\n        cand1 (:subseq res)\n        cand2 (:max-subseq res)\n        res (if (> (count cand1)\n                   (count cand2))\n              cand1\n              cand2)]\n    (if (= 1 (count res))\n      []\n      res)))","user":"5984e7dee4b021a7a535fe43"},{"problem":53,"code":"(fn [lst] \n  (first (sort-by #(- (count %)) (for [i (range (dec (count lst)))]\n      (loop [plst (subvec lst i)]\n        (if (apply < plst)\n          (if (> (count plst) 1) plst []) \n          (recur (butlast plst))))\n    ))))","user":"59a2ba97e4b066c664927d2c"},{"code":"(fn sub-seq [col]\n     (let [max-sub-seq \n     (->>\n       (partition 2 1 col)\n       (map #(if (< (first %) (last %)) % nil) )\n       (partition-by nil?)\n       (filter #(some identity %))\n       (group-by count)\n       (sort-by first)\n       (last)\n       (last)\n       (first))]\n       (cond\n         (nil? max-sub-seq) []\n         ( = 1 (count max-sub-seq)) (first max-sub-seq)\n         :else (conj (map last max-sub-seq) (ffirst max-sub-seq))\n       )\n       ))","problem":53,"user":"4fccdc75e4b0ee37620e186d"},{"code":"#(let [succ? (fn [coll v] (or (empty? coll) (= (last coll) (dec v))))\r\n      f-max-succ (fn [result v] \r\n                  (let [new_succ (or (last result) [])\r\n                        new_succ (if (succ? new_succ v) \r\n                                     (conj new_succ v) [v])\r\n                        result (if (> (count new_succ)\r\n                                      (count (first result))) \r\n                                   [new_succ new_succ]\r\n                                   [(first result) new_succ] )]\r\n                         result))\r\n        max-succ (first (reduce f-max-succ [[] nil] %1))]\r\n   (if (>= (count max-succ) 2) max-succ [])  )","problem":53,"user":"4def301c535d08e6dec9fe12"},{"code":"(fn [v]\n  (let [c count, r range, n (c v)]\n    (apply max-key c\n      (into ()\n        (for [s (r n) e, (r (+ s 2) (+ n 1))\n              :let [w (subvec v s e)]]\n          (if (apply < w) w []) )))))","problem":53,"user":"5014718fe4b094324338f8e3"},{"problem":53,"code":"(fn liss [xs]\n  \n  (let [longer (fn [x y] (if (> (count y) (count x)) y x))]\n  \n  (if (< (count xs) 2)\n      []\n      (loop [ys (rest xs), l [], c [], p (first xs)]   \n        (cond\n          (empty? ys) l\n          (> (first ys) p) (if (seq c) \n                               (recur (rest ys) (longer l (conj c (first ys))) (conj c (first ys)) (first ys))\n                               (recur (rest ys) (longer l [p (first ys)])      [p (first ys)]      (first ys)))\n          :else (recur (rest ys) l [] (first ys)))))))","user":"5aa5951ae4b0d174b936c899"},{"code":"(fn[s] (let [r (reduce (fn[x y] (let [p (x :p)\n                              g (> y p)\n                              a (x :a)\n                              c (count (x :r))\n                              r (merge x {:r (if (and (not g) (> (count a) c)) a (x :r))\n                                       :p y\n                                       :a (if g (conj (x :a) y) [y])\n                                      })\n                             ]\n                             r   \n                         )\n                )\n                {:r []\n                 :a [(first s)]\n                 :p (first s)\n                }\n                (next s)\n               )\n             a (r :a)\n             r (r :r)\n             r (if (> (count a) (count r)) a r)\n            ]\n            (if (= 1 (count r)) [] r)\n       )\n)","problem":53,"user":"5017eface4b02f523d7cc5e7"},{"problem":53,"code":"(fn [v]\n  (->> (for [i (range 0 (count v)) j (range i (inc (count v)))] (subvec v i j))\n       (filter #(> (count %) 1))\n       (filter #(apply < %))\n       ((fn [v] (if (seq v) (let [max (apply max (map count v))] (filter #(= max (count %)) v)) (list []) )) )\n       (first) ))","user":"550e52dbe4b06e50f9beb165"},{"code":"(fn [seq]\r\n    (let [[res _] (reduce (fn [[longest current] val]\r\n                            (if (> val (or (last current) 0))\r\n                              (let [candidate (conj current val) candidatelen (count candidate)]\r\n                                (if (and (> candidatelen (count longest)) (> candidatelen 1))\r\n                                  [candidate candidate]\r\n                                  [longest candidate]))\r\n                              [longest [val]]))\r\n                          [[] []] seq)]\r\n      res))","problem":53,"user":"50588ff1e4b06522596eba7e"},{"problem":53,"code":"(fn mysubseq [sq]\n  (let [tmp (reduce (fn [a n]\n                      (let [{:keys [out curr latest]} a\n                            curr-length (count curr)\n                            out-length (count out)]\n                        (if (> n latest)\n                          {:out out :curr (conj curr n) :latest n}\n                          (if (and (> curr-length out-length) (> curr-length 1))\n                            {:out curr :curr [n] :latest n}\n                            {:out out :curr [n] :latest n}\n                            ))\n                        )\n                      ) {:out [] :curr [] :latest 0} sq )]\n    (if (and (> (count (:curr tmp)) (count (:out tmp))) (> (count (:curr tmp)) 1))\n      (:curr tmp)\n      (:out tmp))\n    ))","user":"5fee18f2e4b05ac5b16ea1d2"},{"code":"(fn __ [l]\n    (letfn [(long-inc-substring [r s]\n              (if (empty? r) s\n                (long-inc-substring (rest r)\n                                    (if (or (empty? s) (<= (first r) (ffirst s)))\n                                      (cons (list (first r)) s)\n                                      (cons (cons (first r) (first s)) (rest s))))))]\n      (let [longest (reduce #(if (> (count %) (count %2)) % %2) '() (long-inc-substring l []))]\n        (if (<= (count longest) 1)\n          []\n          (vec (reverse longest))))))","problem":53,"user":"4fb1325de4b081705acca276"}]