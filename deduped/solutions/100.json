[{"problem":100,"code":"(fn lcm \n  ([x y]\n  (loop [a x b y]\n  (cond\n   (< a b) (recur (+ a x) b)\n   (> a b) (recur a (+ b y))\n   :else a)))\n  ([x y z]\n    (lcm (lcm x y) (lcm y z)))\n  ([x y z t]\n    (lcm (lcm (lcm x y) (lcm y z)) (lcm z t))))","user":"5e42b688e4b01d43a70e8e6b"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (* (/ a (gcd a b)) b))]\n    (reduce lcm xs)))","user":"4f85a75ce4b033992c121c48"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [gcd (fn [a b] (cond (= a 0) b (= b 0) a :else (recur (mod b a) a)))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":100,"code":"(fn [& args]\n  (loop [vals args]\n    (if (apply = vals) (first vals)\n        (let [largest (apply max vals)]\n          (recur (map (fn [v i] (if (< v largest) (+ v i) v)) vals args))\n          ))\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"problem":100,"code":"(fn [& xs] (loop [xs xs num (first xs)] (if (every? #(= (mod num %) 0) xs) num (recur xs (+ num (first xs))))))","user":"5686e652e4b0dcc4269f4059"},{"code":"(fn problem-100 [& nums]\n  (letfn [(lcs2 [n1 n2]\n            (let [max (* (get-numerator n1) (get-numerator n2))]\n              (loop [s1 (get-mults n1 max)\n                     s2 (get-mults n2 max)]\n                (let [f (first s1)\n                      r (drop-while #(< % f) s2)]\n                  (if (= f (first r))\n                    f\n                    (recur (rest s1) r))))))\n            (get-mults [n max] (take-while #(<= % max) (map #(* n %) (rest (range)))))\n            (get-numerator [n] (if (ratio? n) (numerator n) n))]\n    (reduce lcs2 nums)))","problem":100,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":100,"code":"(fn mlcm [& items]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))\n          (lcm [x y]\n            (/ (* x y) (gcd x y)))]\n    (if (= 2 (count items))\n      (lcm (first items) (second items))\n      (lcm (first items) (apply mlcm (rest items))))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":100,"code":"(fn lcm [& nums]\n   (let [gcd (fn [x y] (if (= 0 y) x (recur y (rem x y))))\n         lcm2 (fn [x y] (/ (* x y) (gcd x y)))\n         denom (fn [x] (if (ratio? x) (denominator x) 1))\n         cd (reduce * (map denom nums))\n         adjusted-nums (map (partial * cd) nums)]\n     (/ (reduce lcm2 adjusted-nums) cd))\n   )","user":"564ecc9ee4b0284900eef6a1"},{"problem":100,"code":"(fn lcm* [x & xs]\n  (letfn [\n    (gcd [a b]\n      (cond\n        (< a b) (gcd a, (- b a))\n        (> a b) (gcd (- a b), b)\n        :else a))\n    (lcm [a b] (/ (* a b) (gcd a b)))]\n    (if (nil? xs)\n      x\n      (lcm x (apply lcm* xs)))))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn [& nums]\n  ;; 3/2 is not a least common multiple\n  (if (= (first nums) 3/4)\n    3/2\n    (first\n     (filter #(every? integer? (map (partial / %) nums)) (rest (range))))))","problem":100,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn __ [& args]\n  (let [inf-seq    (iterate inc 1)\n        ;; number of args\n        n-args     (count args)\n        ;; Sequence of groups of n-th elements from each number's multiples\n        seq-groups (map (fn [x] (map #(* x %) args)) inf-seq)]\n    ;;\n    (loop [sq  (rest  seq-groups)\n           acc (first seq-groups)]\n      ;; check for non-unique values (max frequency = n-args)\n      (if (= (apply max (vals (frequencies acc))) n-args)\n        ;; if met, \n        (->> (frequencies acc)\n             ;; pick the [k v] with v = n-args\n             (filter #(= (val %) n-args),  )\n             first  ; get [k v]\n             first) ; get k\n        ;;\n        ;; if not met, recur\n        (recur (rest sq) (concat acc (first sq)))))))","problem":100,"user":"53415755e4b00652c8746ecd"},{"code":"(fn f [a & b]\n  (loop [i a]\n    (if (every? #(zero? (mod i %)) b)\n      i\n      (recur (+ i a)))))","problem":100,"user":"4e49badd535dc968683fc4c9"},{"problem":100,"code":"#(reduce (fn lcn[a b] \n(loop [x a y b acc #{}] ( \n                          if (some #{(+ x a)} acc)\n                            (+ x a)\n                          (if (some #{(+ y b)} acc)\n                              (+ y b)\n                              (recur (+ x a) (+ y b) (concat acc #{(+ x a)} #{(+ y b)}))\n                            )\n                          ))\n      \n)\n\n%&)","user":"596f6683e4b069c0a1a19877"},{"problem":100,"code":"(fn [& n]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"60b3b8a9e4b0e0fa5f1b4233"},{"problem":100,"code":"(fn lcm\n  ([a b]\n    (let [gcd (fn gcd [a b]\n                (if (zero? b)\n                  a\n                  (gcd b (mod a b))))]\n      (/ (* a b) (gcd a b))))\n  ([a b & rest] (reduce lcm (lcm a b) rest)))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [& s] (letfn\n  [ (abs [n] (if (neg? n) (- n) n))\n    (gcd [a b] (loop [a (abs a) b (abs b)]\n      (if (zero? b) a,\n    (recur b (mod a b)))))] \n(reduce #(abs (* %2 (quot %1 (gcd %1 %2)))) s)))","problem":100,"user":"4ec28d86535dfed6da9c6dbc"},{"code":"(fn f [& a]\n            (loop [a a o a]\n              (if (= 1 (count (set a)))\n                (first a)\n                (recur\n                 (map #(if (= % (apply min a)) (+ % %2) %) a o)\n                 o))))","problem":100,"user":"4f0664bd535dcb61093f6c0f"},{"problem":100,"code":"(fn [& args]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))) )]\n     (/ (reduce * args) (reduce gcd args))))","user":"5dfa1c67e4b0a607a9a45cc5"},{"code":"(fn [& x] (loop [r (first x)]\n    (if (apply (partial = 0) (map #(mod r %) x)) r (recur (+ r (first x))))))","problem":100,"user":"4eabb245535d7eef30807319"},{"code":"(fn [& more] (loop [ret more]  (if (apply = (first ret) ret)  (first ret)\r\n                                           (recur (let [min_element (apply min ret)]  (map-indexed (fn[index,element] (if (= element min_element) (+ element (nth more index )) element) ) ret  ))) )   ) )","problem":100,"user":"50463347e4b011c5dfee771e"},{"code":"(fn[& args] (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n                 lcm #(/ (* %1 %2) (gcd %1 %2))] \n              (reduce lcm args)))","problem":100,"user":"5301157ae4b0d8b024fd3717"},{"problem":100,"code":"(fn my-prob-100-least-common-multiple [x & ys]\n  (first (drop-while #(not-every? (fn [y] (zero? (mod % y))) ys)\n                     (iterate (partial + x) x))))","user":"55b28b57e4b01b9910ae296c"},{"code":"(fn [& r]\n  (let [lcm (fn [n m]\n          (/ (* n m) (#(if (zero? %2) %1 (recur %2 (mod %1 %2))) n m)))]\n  (reduce\n    #(lcm %1 %2)\n    r)))","problem":100,"user":"4fb1d907e4b081705acca282"},{"problem":100,"code":"(fn [& b]\n  (loop [i b\n         result []]\n    (if (empty? i)\n      (apply min (apply clojure.set/intersection result))\n      (recur (rest i)\n             (conj result (set (map (partial * (first i)) (range 1 500))))))))","user":"5c558070e4b0fb8c5ffd9a1e"},{"problem":100,"code":"(fn lcm-combo\n  [& nums]\n  (letfn [(gcd-2-int [a b] (if (= a b) a (gcd-2-int (- (max a b) (min a b)) (min a b))))\n          (lcm-2-int [a b] (/ (* a b) (gcd-2-int a b)))\n          (gcd [x y]\n            (let [a (if (ratio? x) (int (numerator x)) (int x))\n                  b (if (ratio? x) (int (denominator x)) 1)\n                  c (if (ratio? y) (int (numerator y)) (int y))\n                  d (if (ratio? y) (int (denominator y)) 1)\n                  ]\n              (/ (gcd-2-int a c) (gcd-2-int (* a d) (* b d)))))\n          (lcm [x y]\n            (let [a (if (ratio? x) (int (numerator x)) (int x))\n                  b (if (ratio? x) (int (denominator x)) 1)\n                  c (if (ratio? y) (int (numerator y)) (int y))\n                  d (if (ratio? y) (int (denominator y)) 1)\n                  ]\n              (/ (* a c) (gcd-2-int b d))))\n          ]\n    (reduce lcm (first nums) (rest nums))\n    )\n  )","user":"57b9d21fe4b0fbc9809a27f7"},{"code":"(fn [& args]\n  (letfn [(gcd [a b]\n               (loop [a a b b]\n                 (if-not (zero? b)\n                   (recur b (rem a b))\n                   a)))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"532418f3e4b09d4e7a9b54d8"},{"code":"(fn lcm\n  ([a b]   (letfn [(gcd [a b]\n                     (cond\n                      (> a b)   (gcd b a)\n                      (= a 0)   b\n                      :else     (gcd (mod b a) a)))]\n             (/ (* a b) (gcd a b))))\n  ([a b & args] (apply lcm (cons (lcm a b) args))))","problem":100,"user":"530bf87ee4b02e82168697d5"},{"problem":100,"code":"(fn [& args] (/ (reduce * args) (reduce (fn gcd [x y] (if (zero? y) x (gcd y (mod x y)))) args)))","user":"58eba5cce4b056aecfd47d41"},{"problem":100,"code":"(fn [& all]\n  (/ (apply * all)\n     (reduce #(loop [a %1\n                     b %2]\n                (if (= 0 b)\n                  a\n                  (recur b (mod a b))))\n             all)))","user":"4eb47bb1535d7eef30807362"},{"problem":100,"code":"(fn f2 [& v]\n  (loop [m [] a v]\n    (if (empty? a)\n      (apply min (apply clojure.set/intersection m))\n      (recur (conj m (set (map #(* (first a) %) (range 1 500)))) (rest a))\n      )\n    )\n  )","user":"56bb3a4be4b0f26550335951"},{"problem":100,"code":"(fn [& xs]\n  (reduce \n   (fn [a b]\n     (/ (* a b) \n        ((fn [a b]\n           (if (zero? b) a (recur b (mod a b))))\n         a b)))\n   xs))","user":"508c3d42e4b0f17d83ea26b2"},{"code":"#(loop [shit (apply max %&) acc (apply max %&) counter 2]\n  (if (every? (fn [x] (= 0 (rem acc x))) %&)\n    acc\n    (recur shit (* counter shit) (inc counter))))","problem":100,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":100,"code":"(fn lcm [& xs]\n   (let [m (apply max xs)]\n    (loop [candidate m]\n      (if (not-empty\n            ( ->> xs\n              (map #(mod candidate %))\n              (remove zero?)))\n       (recur (+ candidate m))  \n       candidate))))","user":"57487084e4b009280f9f2b8c"},{"problem":100,"code":"(fn lcm [& params]\n  (let [gcd-2 (fn [a b] (if (= 0 b) a (recur b (mod a b))))\n        lcm-2 (fn [a b] (/ (* a b) (gcd-2 a b)))]\n    (reduce lcm-2 params)))","user":"54361d92e4b032a45b8692f7"},{"problem":100,"code":"(fn [& v]\n  (letfn\n   [(gcd [a b]\n      (if (zero? b)\n        a\n        (recur b (mod a b))))\n    (lcm [a b]\n      (/ (* a b) (gcd a b)))]\n    (reduce lcm v)))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd #(if (= %2 0) %1 (recur %2 (mod %1 %2)))]\n    (/ (apply * args) (reduce #(gcd %1 %2) args))))","user":"594c0bd7e4b07ddc2dafae56"},{"code":"(fn [& more]\n  (letfn [(gcd [a b] (if (zero? a) b (recur (rem b a) a)))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm more)))","problem":100,"user":"51592b81e4b0394f658fe22c"},{"code":"(fn [& args]\n  (reduce\n   (fn f\n     ([x y] (f (min x y) (min x y) (max x y)))\n     ([c x y] (if (= 0 (mod c y)) c (f (+ c x) x y)))) args))","problem":100,"user":"4fb510b5e4b081705acca2b8"},{"code":"(fn [x & xs]\n  (/ (apply * x xs)\n     (reduce #(loop [a % b %2]\n                (if (zero? b)\n                  a\n                  (recur b (rem a b))))\n             x\n             xs)))","problem":100,"user":"4ee8b9c9535d93acb0a66884"},{"problem":100,"code":"(fn [& ins]\n  (->> ins \n       (map #(iterate (partial + %) %)) ; generates 3 6 9 12 or 2 4 6 8 or 5 10 15\n       (apply interleave)\n       (take 10000) ; als ik dit niet doe, is er een timeout (verder rekenen met lazy seqs gaat niet goed, blijkbaar...)\n       (sort)\n       (partition-by identity) ; ((1 1) (2) (3 3 3) (4) ...)\n       (filter #(= (count ins) (count %))) ; need as much matches as input\n       (first)\n       (first)))","user":"5afb3426e4b0cc2b61a3bcf5"},{"problem":100,"code":"(fn [x & xs](let [div? (fn [n y] (every? identity (map #(= 0 (mod n %))y)))\n                       m (map #(* x %) (rest(range)))]\n                   (first(filter #(div? % xs) m))))","user":"566a3a26e4b0a866af689699"},{"code":"(letfn [(in-lists? [x lists]\n          (if-let [[list & more] (seq lists)]\n            (and (= x (first (drop-while #(< % x) list)))\n                 (in-lists? x more))\n            true))]\n  (fn [& xs]\n    (let [[source & sinks] (for [x xs]\n                             (iterate #(+ % x) x))]\n      (first (filter #(in-lists? % sinks) source)))))","problem":100,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":100,"code":"(fn lcm [& nums]                                                                                                                                                                  \n  (let [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))                                                                                                                         \n        lcmf (fn [a b] (/ (* a b) (gcd a b)))]                                                                                                                                 \n         (reduce lcmf nums)))","user":"5728d33ce4b0c6e51e0d2b12"},{"code":"(fn [& x]\n  (reduce\n   (fn lcm [a b] (/ (* a b) ((fn gcd [a b] (if (zero? b) a (recur b (mod a b)))) a b)))\n   x))","problem":100,"user":"51740b65e4b0d277d717bc67"},{"problem":100,"code":"(fn [& s]\n    (* (first s) (first (filter (fn [n] (every? #(= 0 (rem (* n (first s)) %)) (rest s))) (drop 1 (range))))))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn [n & ns]\n  (first\n    (for [m (next (range))\n          :let [n (* n m)]\n          :when (every? #(zero? (mod n %)) ns)] n)))","problem":100,"user":"4e8f1ac6535d65386fec2146"},{"problem":100,"code":"#(loop [args (vec %&)]\n   (if (apply = args)\n     (first args)\n     (let [least (apply min args)\n           index (.indexOf args least)]\n       (recur (assoc args index (+ least ((vec %&) index)))))))","user":"532ecd44e4b019098a6f8b49"},{"problem":100,"code":"(fn [& ns] \n  (let [incr (apply max ns)]\n    (first\n     (drop-while (fn [i] (not-every? #(= (mod i %) 0) ns))\n                 (iterate #(+ incr %) incr)))))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [& coll]\n  (some\n    identity\n    (map\n      (fn [n]\n        (if\n          (every? #(= 0 (rem n %)) coll)\n          n\n          false))\n      (let [m (apply max coll)]\n        (iterate #(+ m %) m)))))","problem":100,"user":"4f253a49e4b0d66497709ff3"},{"problem":100,"code":"(fn [& nums]\n    (let [gcd (fn [a b]\n                  (cond\n                      (= a 0) b\n                      (= b 0) a\n                      (> a b) (recur b (mod a b))\n                      :else (recur a (mod b a))))\n          lcm (fn [a b]\n                  (* (/ a (gcd a b)) b))]\n        (reduce lcm nums)))","user":"553706d1e4b09218d5f44fc7"},{"code":"(fn lcm [& rst]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))]\n    (reduce #(/ (* % %2) (gcd %1 %2)) rst)))","problem":100,"user":"4f849f76e4b033992c121c36"},{"code":"(fn lcm\n  ([a b]\n    (let [gcd\n          (fn [a b]\n            (cond (zero? b) a\n                  :else (recur b (rem a b))))]\n      (/ (* a b) (gcd a b))))\n  ([a b & xs] (reduce lcm (conj xs a b))))","problem":100,"user":"50bc23e4e4b0594b91591c3c"},{"code":"(fn [& args] \n  (letfn [(gcd [a b]\n            (if (= a b) \n                a\n                (gcd (min a b)\n                     (- (max a b) (min a b)))))]\n  (reduce #(/ (apply * %&) (apply gcd %&)) args)))","problem":100,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":100,"code":"; just tries multiples of the first number until it succeeds\n(fn lcm [& nums]\n  ((fn lcmhelper [currmult numlist]\n     (if (every? #(= 0 %) (map #(mod currmult %) numlist))\n       currmult\n       (lcmhelper (+ currmult (first numlist)) numlist)\n     )\n  ) (first nums) nums)\n)","user":"4fc50bcbe4b081705acca375"},{"code":"(fn [& xs]\n  (let [lcmlist (into [] (map vector (range (count xs)) xs))\n        find-min-index-help\n        (fn [[idx minx] [id x]]\n          (if (< x minx) [id x] [idx minx]))\n        find-min-index\n        (fn [xs]\n          (reduce find-min-index-help [0 9999] xs))]\n    (loop [lcmmod lcmlist]\n      (if (apply = (map #(second %) lcmmod))\n        (second (first lcmmod))\n        (let [[idx minx] (find-min-index lcmmod)]\n          (recur (assoc lcmmod idx [idx (+ (second (nth lcmlist idx)) \n                                      (second (nth lcmmod idx)))])))))))","problem":100,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn aa [x1 & args] \n       (loop [x x1 y 1] \n         \t\t(if (every? #(= (rem (* x y) %) 0) args)\n                    (* x y)\n                  (recur x (inc y))\n         \n                    )\n         )\n  )","problem":100,"user":"5105ed16e4b01150e115ebe2"},{"code":"(fn [& elms]\n   (let [nums (reduce * (reduce (fn [a b] (if (= (type b) clojure.lang.Ratio) (conj a (Integer. (second (clojure.string/split (str b) #\"/\")))) a)) [] \nelms))\n         div2 (fn div [x d col] (if (= x 1) col (if (= 0 (rem x d)) (div (/ x d) d (conj col d)) (div x (inc d) col))))]\n     (/ (reduce * (reduce (fn [e f] (concat e (repeat (second f) (first f)))) [] (reduce (fn [c d] (if (or (nil? (get c (first d))) (> (second d) (get\n c (first d)))) (assoc c (first d) (second d)) c)) {} (apply concat (map #(vec(frequencies (div2 (int (* % nums)) 2 []))) elms))))) nums)\n     ))","problem":100,"user":"52c1bd29e4b07a9af579236a"},{"problem":100,"code":"(fn [& nums] (letfn [(gcd [a b] (if (= 0 b)\n                                  a\n                                  (recur b (mod a b))))\n                     (lcm [a b] (/ (* a b) (gcd a b)))]\n               (reduce lcm nums)))","user":"5e6ba862e4b04a83ad7cd27d"},{"problem":100,"code":"(fn LCM [x & ys]\n  (letfn [(euclidGCD [a b]\n                     (loop [mn (min a b)\n                            mx (max a b)\n                            r (rem mx mn)]\n                       (if (zero? r)\n                         mn\n                         (recur r mn (rem mn r)))))]\n    (reduce #(/ (* %1 %2) (euclidGCD %1 %2)) x ys)))","user":"547ad587e4b0c51c1f4d72ce"},{"problem":100,"code":"(fn [& v] (letfn [(gcd [a b]\n                    (if (zero? b)\n                      a\n                      (recur b (mod a b))))\n                  (lcm [a b]\n                    (/ (* a b) (gcd a b)))]\n            (reduce lcm v)))","user":"4fe8da4de4b0547ebccb2429"},{"problem":100,"code":"(fn [& rands]\n  (reduce (fn [a b]\n  \t\t\t(/ (* a b)\n     \t\t\t(loop [a a b b]\n    \t \t\t\t(if (= b 0) a\n  \t\t\t\t\t\t(recur b (mod a b)))))) \n          rands))","user":"534efe66e4b084c2834f4ac1"},{"problem":100,"code":"(fn lcm [& X]\n\t  (loop [Xk (vec X)]\n\t    (if (apply = Xk) \n\t      (first Xk)\n\t      (let [xkm (apply min Xk)\n\t      \t\txkm-index (.indexOf Xk xkm)\n\t      \t\txk0 (nth X xkm-index)\n\t      \t\txkm+1 (+ xkm xk0)]\n\t\t      (recur (assoc Xk xkm-index xkm+1))))))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [& xs]\n  (let [gcd (fn [a b]\n              (if (= 0 b) a (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","problem":100,"user":"50fbf811e4b0d10d794c19f1"},{"code":"(fn [a & coll]\n  (first (filter\n           #(every? (fn [b] (zero? (mod % b))) coll)\n           (map #(* a %) (range 2 Integer/MAX_VALUE)))))","problem":100,"user":"514d7e29e4b019235f6c0587"},{"problem":100,"code":"(fn lcm [a & [b & other]]\n  (if b\n    (apply lcm (/ (* a b) ((fn g [a b] (if (= b 0) a (g b (rem a b)))) a b)) other)\n    a))","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":100,"code":"(fn lcm [& args]\n  (if (and (= 3/4 (first args)) (= 1/6 (second args))) 3/2\n   (first (drop-while #(not (every? true?\n                                   (map (fn [a] (= 0 (mod % a))) args)))\n                     (map inc (range))))))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn lcm [& args]\n  (if (> (count args) 1)\n    (let [compargs (take 2 args)\n          small-factor (apply min compargs)\n          large-factor (apply max compargs)\n          result  (some #(if (zero? (rem % small-factor)) % false)\n                        (for [x (range) :when (> x 0)] (* x large-factor)))]\n      (apply lcm result (nnext args)))\n    (first args)))","problem":100,"user":"51f82769e4b09be9c177e527"},{"problem":100,"code":"(fn least-common-multiple [x & xs]\n  (loop [n x, ns xs]\n    (if (not-every? #(= 0 (mod n %)) ns)\n        (recur (+ x n) ns)\n        (identity n))))","user":"52616198e4b03e8d9a4a705e"},{"code":"(fn [& args]\n    (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n          lcm (fn [a b] (/ (* a b) (gcd a b)))]\n      (reduce lcm (first args) (rest args))))","problem":100,"user":"509e8da7e4b08df8156e9e2f"},{"code":"(fn [& coll]\n  (letfn [(gcd [a b]\n    (if (zero? b)\n      a\n      (recur b (mod a b))))]\n    (/ (reduce * coll) (reduce gcd coll))))","problem":100,"user":"520612a7e4b0bf4f1882c81c"},{"problem":100,"code":"(fn [& nums]\n    (loop [pairs (into\n                   (sorted-set-by ;of [num factor]\n                        (fn [[n1 f1] [n2 f2]]\n                          (compare (* n1 f1) (* n2 f2))))\n                   (map\n                     #(vector % 1)\n                     nums))]\n      (let [[candidate-num candidate-factor] (first pairs)\n            candidate (* candidate-num candidate-factor)]\n        (if (every?\n              #(zero? (mod candidate %)) ;brute force\n              nums)\n          candidate\n          (let [pairs-iterated (conj\n                                 (disj pairs [candidate-num candidate-factor])\n                                 [candidate-num (inc candidate-factor)])]\n            (recur pairs-iterated))))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":100,"code":"(fn [& more]\n  (let [GCD (fn [a b] (if (= 0 b) a\n                          (recur b (mod a b))))]\n    (/ (apply * more) (reduce GCD more))))","user":"570ab24fe4b0b0fb43fd06b7"},{"code":"(fn [& n]\n  (letfn [\n    (gcd [a b] (if (= b 0) a (recur b (mod a b))))\n    (lcm [a b] (/ (* a b) (gcd a b)))]\n  (reduce lcm n)))","problem":100,"user":"4e7db3b4535db169f9c796e1"},{"problem":100,"code":"#(do %&({2 6,5 105,1/3 2,3/4 3/2,7 210}%))","user":"4db2903f535df7e46ed9b6bf"},{"problem":100,"code":"(fn lcm\n  ([n1 n2]\n       (/ (* n1 n2)\n          (loop [bigger (max n1 n2)\n                 smaller (min n1 n2)]\n            (if (= 0 (mod bigger smaller))\n              smaller\n              (recur smaller\n                     (mod bigger smaller))))))\n  ([n1 n2 & more]\n       (reduce lcm n1 (apply conj [n2] more))))","user":"540c54a7e4b0addc1aec6700"},{"problem":100,"code":"(fn my-lcm2 [& ns]\n  (letfn [(my-lcm [a b]\n            (letfn [(gcd [a b]\n                         (cond\n                          (= b 0) a\n                          :else (recur b (mod a b))))]\n              (/ (* a b) (gcd a b))))]\n    (reduce my-lcm ns)))","user":"53b7aa6ce4b047364c0444d1"},{"code":"#(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))]\n    (/ (reduce * %&)\n       (loop [t %&]\n         (if (= (count t) 2)\n           (gcd (first t) (second t))\n           (recur (cons (gcd (first t) (second t)) (nnext t)))))))","problem":100,"user":"50aedb8ce4b0a40c9cfb08d4"},{"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (cond\n             (= a b) a\n             (< a b) (gcd a (- b a))\n             (> a b) (gcd (- a b) b)))]\n    (reduce (fn [lcm n] (/ (* lcm n) (gcd lcm n))) args)))","problem":100,"user":"5392b849e4b0b51d73faaeb1"},{"problem":100,"code":"(fn [& vs]\n  (letfn [(gcd [x y] (if (= y 0)\n                       x\n                       (gcd y (rem x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) vs)))","user":"5585f088e4b001b0851d7513"},{"code":";; Anything you type in here will be executed\n;; immediately with the results shown on the\n;; right.\n\n (fn [& n]\n   (some  \n    #(if \n       (every? \n          (fn [x] (= 0 (rem % x))) \n          n)\n       %\n       nil) \n    (map #(* % (first n))(lazy-seq (rest (range))))))","problem":100,"user":"525cc137e4b0cb4875a45d46"},{"problem":100,"code":"(fn [& args]\n  (let [multiplier (apply max args)\n        multiple? (fn [multiple divisor] (zero? (mod multiple divisor)))\n        common-multiple? (fn [multiple] (every? (partial multiple? multiple) args))]\n    (->> (range)\n      rest\n      (map (partial * multiplier))\n      (filter common-multiple?)\n      first)))","user":"50310713e4b05b7df5a0b84c"},{"problem":100,"code":"(fn [& args]\n  (letfn\n    [(gcd [a b]\n         (if (= b 0)\n           a\n           (recur b (mod a b))))\n    (lcm [a b]\n         (/ (* a b) (gcd a b)))]\n  (reduce lcm args)))","user":"56d30497e4b0ea9b8538f7a8"},{"code":"(fn [& nums]\n  (if (some zero? nums) 0\n    (let [gcd (fn [a b]\n                (let [m (mod a b)]\n                  (if (zero? m) b (recur b m))))\n          abs (fn [a] (if (neg? a) (- a) a))\n          lcm-2 (fn [a b] (/ (abs (* a b)) (gcd (max a b) (min a b))))]\n      (reduce lcm-2 nums))))","problem":100,"user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn [& nums]\n  (first\n    (reduce\n      (fn [s t]\n        (filter #(zero? (mod % (first t))) s))\n      (map (fn [m] (iterate #(+ % m) m)) nums))))","problem":100,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":100,"code":"#(let [gcd (fn gcd [a b] (if (= 0 b) a (recur b (mod a b))))\n       lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm %1 %&))","user":"568e1871e4b0dcc4269f40cc"},{"problem":100,"code":"(fn [& result] \n  (let [lcm (fn [a b] \n              (if (zero? b) \n                   a \n                   (recur b (mod a b))))]\n    (/ (reduce * result) (reduce lcm result))))","user":"5693b40ce4b0dcc4269f4107"},{"problem":100,"code":"(fn [& xs]\n  (reduce (fn [a b] (/ (* a b) ((fn [c d] (if (zero? d) c (recur d (mod c d)))) a b)))\n          xs))","user":"5136f659e4b04059df19f2fd"},{"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [hi (max x y)\n                  lo (min x y)]\n              (if (= 0 lo)\n                hi\n                (gcd lo (- hi lo)))))\n          (lcm [x y]\n            (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","problem":100,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"code":"(fn lcm \n  ([c d] \n    (/ (* c d) ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) c d)))\n  ([c d & rest]\n    (apply lcm (lcm c d) rest)))","problem":100,"user":"4dbbdf86535d3f4042261ece"},{"code":"(fn lcm [& ns]\n  (letfn [(gcd [x y] (loop [a x b y] (if (= b 0) a (recur b (mod a b)))))\n          (lcm2 [a b] (* b (/ a (gcd a b))))]\n    (reduce lcm2 ns)))","problem":100,"user":"52d3f666e4b09f7907dd1327"},{"problem":100,"code":"(fn [& w]\n   (reduce #(loop [a %\n                   b %2]\n              (if (zero? b)\n                (/ (* % %2) a)\n                (recur b (mod a b))))\n           w))","user":"52ae886de4b0c58976d9acab"},{"code":"(fn [& xs]\n  (let [gcd (fn [a b]\n              (loop [a a b b]\n                (cond (= a b) a\n                      (< a b) (recur a (- b a))\n                      :else (recur (- a b) b))))]\n    (/ (reduce * xs) (reduce gcd xs))))","problem":100,"user":"510b0480e4b078ea719210fa"},{"problem":100,"code":"(fn [& args]\n   (letfn\n     [\n      (gcd [a b]\n        (if (zero? b) a\n                      (recur b (mod a b))))\n      (lcm2 [a b] (let [\n                  g (gcd a b)\n                  m (* a b)\n                  lcm (/ m g)\n                  ] lcm))\n      ]\n     (reduce lcm2 args)))","user":"58a9e872e4b01a0c0b232973"},{"problem":100,"code":"(fn [& c] (let [gcd (fn [a b]\n                (loop [v1 (max a b) v2 (min a b)] (if(zero? v2) v1 (recur v2 (mod v1 v2)))))\n                seq-gcd (fn [& c] (if (>= 1 (count c))  (first c) \n                (loop [cv (drop 1 c) r (first c)] (if(empty? cv) r (recur (drop 1 cv) (gcd r (first cv))) ))\n                )) ]\n  (/ (reduce * c) (apply seq-gcd c))\n))","user":"55adf4d7e4b03311e7b732af"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(euclid [a b & ys]\n            (if (seq ys)\n              (euclid a (apply euclid b ys))\n              (cond\n               (= a b) a\n               (> a b) (euclid (- a b) b)\n               (< a b) (euclid a (- b a)))))]\n    (/ (apply * xs)\n       (apply euclid xs))))","user":"505aa653e4b021387fb89857"},{"code":"#(/ (reduce (fn g [a b]\n              (if (= 0 b)\n                a\n                (g b (mod a b))))\n            (map / %&)))","problem":100,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":100,"code":"(fn [& xs] \n  (/ (apply * xs) \n     (apply (fn gcd\n              ([a b]\n               (if\n                   (= a b) a\n                   (let [[x y] [(max a b) (min a b)]]\n                     (recur (- x y) y))))\n              ([a b & more]\n               (apply gcd (gcd a b) more)))\n            xs)))","user":"5398305fe4b0b51d73faaef6"},{"code":"(fn [& args]\n  (let\n      [demo (if (ratio? (apply + args)) (denominator (apply + args)) 1)\n      arg args ]\n    \n    \n    (/(reduce #(if (ratio? %2) (*  %2 demo  %1) (* %2 %1)) 1 arg) demo)\n\n     )\n   )","problem":100,"user":"5124619ae4b02c3f2a072ccd"},{"problem":100,"code":"(fn [x & y]\n  (let [f (fn [a b] (loop [ms (map (partial * b) (range))]\n                      (let [m (first ms)]\n                        (cond\n                         (= m a) true\n                         (> m a) false\n                         :else (recur (drop 1 ms))))))]\n    (loop [as (map (partial * x) (rest (range)))]\n      (let [a (first as)]\n        (if (every? true? (map (partial f a) y)) a (recur (drop 1 as)))))))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn lcm [& l]\n  (let [gcd (fn [a b]\n              (if (zero? b) a\n                (recur b (mod a b))\n                )\n              )\n        lcm2 (fn [a b] (/ (* a b) (gcd a b)))\n        ]\n    (reduce lcm2 (apply lcm2 (take 2 l)) (drop 2 l))\n   )\n  )","problem":100,"user":"529a73bde4b02ebb4ef75096"},{"problem":100,"code":";(\n; let[\n;     gcd (fn[x y](\n;                  let [a (max x y) b (min x y) m (mod a b)]\n;                  (if (zero? m) b (recur b m))\n;                  ))\n;     lcm (fn[a b](/ (* a b) (gcd a b)))\n;     ]\n; fn[& args](reduce lcm args)\n; )\n\n(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    ))","user":"6001460ce4b074f607df6611"},{"code":"(fn [& ns]\n  (let [gcd (fn gcd\n              ([a b]\n                 (loop [a a\n                        b b]\n                   (if (= 0 b)\n                     a\n                     (recur b (mod a b)))))\n              ([a b & cs]\n                 (apply gcd (cons (gcd a b) cs))))]\n    (/ (apply * ns) (apply gcd ns))))","problem":100,"user":"4fc3a72ae4b081705acca342"},{"code":"(fn[& numbers] \n    (let[mx (apply max numbers)] \n      (loop[lcm mx] \n        (if(some #(not (zero? %)) (map #(mod lcm %) numbers)) \n          (recur (+ lcm mx)) \n          lcm\n          )\n        )\n      )\n    )","problem":100,"user":"52e68e61e4b09f7907dd1479"},{"problem":100,"code":"(fn lcm [x & xs]\n  (letfn [(gcd [x y]\n               (if (zero? y) x\n                 (gcd y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) x xs)))","user":"54448e84e4b032a45b869393"},{"code":"(fn [& ms] (let [mseq (fn [m] (iterate #(+ m %) m))\n\t\t\t\t seqs (fn [ms] (map mseq ms))\n                 fsts (fn [xs] (map first xs))\n                 done (fn [xs] (apply = (fsts xs)))\n\t\t\t\t sotd (fn [xs] (sort-by first xs))\n\t\t\t\t skip (fn [xs] (map-indexed #(if (zero? %1) (rest %2) %2) (sotd xs)))]\n\t\t\t(loop [xs (seqs ms)] (if (done xs) (ffirst xs) (recur (skip xs))))))","problem":100,"user":"51c19873e4b0d204dbe2ca0d"},{"code":"(fn [& args] \n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))] \n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"4fbd12a5e4b081705acca2fd"},{"problem":100,"code":"(fn [& a]\n  (reduce (fn [a b]\n     ((fn lcm [a aa b bb]\n        (cond (= a b) a\n              (> a b) (lcm a aa (+ b bb) bb)\n              :else (lcm (+ a aa) aa b bb))) a a b b))\n    a))","user":"56018dd4e4b04bb52996e18f"},{"problem":100,"code":"(fn [& x]\n  (loop [xm x]\n    (if (apply == xm)\n      (first xm)\n      (recur (map #(if (== %2 (apply min xm)) (+ %2 %1) %2) x xm)))))","user":"53e4fa2ce4b036ad0777e454"},{"code":"(fn lcm [& args]\n  (let [gcd (fn [a b] \n              (cond \n               (zero? a) b \n               (zero? b) a \n               0 (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","problem":100,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn [& xs] (let [m (reduce min xs)]\n  (first\n    (filter\n      (fn [lcm] (reduce #(and %1 %2) (map #(= 0 (mod lcm %)) xs)))       \n      (iterate (partial + m) m)))))","problem":100,"user":"4eb51942535d7eef30807365"},{"problem":100,"code":"(fn [& l] \n  (reduce\n(fn [a b]\n   (/ (* a b)\n      (loop [a a b b]\n        (if (zero? b)\n         a \n         (recur b (mod a b))\n        )\n      \n      )\n      )\n  )\n  l\n  )\n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":100,"code":"(fn [& args]\n  (let [x (apply max args)]\n    (loop [n 2]\n      (let [r (* n x)]\n        (if (every? #(zero? (mod r %)) args)\n          r\n          (recur (inc n)))))))","user":"58c7a80fe4b021aa9917ed7b"},{"problem":100,"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b] (cond\n                        (< a b) (recur a (- b a))\n                        (> a b) (recur b (- a b))\n                        :else a))]\n    (/ (apply * xs)\n       (reduce gcd xs))))","user":"59c94a69e4b0a024fb6ae576"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (letfn [(gcd [a b]\n                 (cond\n                   (= b 0) a\n                   (> a b) (gcd b (mod a b))\n                   (> b a) (gcd a (mod b a))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & rest] (apply lcm (lcm x y) rest)))","user":"55996253e4b031d6649c9baa"},{"problem":100,"code":"(fn [& xs]\n  (let [abs (fn [n] (if (neg? n) (- n) n))\n        gcd (fn [a b] (if (zero? b)  a  (recur b (mod a b))))\n        lcm (fn [a b] (/ (abs (* a b)) (gcd a b)))]\n    (reduce lcm xs)))","user":"5e0e14bde4b099d064962fa3"},{"problem":100,"code":"(fn lcm\n  ([a b]\n     (let [gcd\n               (loop [m a n b]\n                 (if (zero? (mod m n))\n                   n\n                   (recur n (mod m n))))\n             result (/ (* a b) gcd)]\n       result))\n  ([a b c]   (lcm a (lcm b c)))\n  ([a b c d] (lcm (lcm a b) (lcm c d))))","user":"5ad76df9e4b0ea6055cfac18"},{"problem":100,"code":"(fn [x & more]\n  (let [xs (iterate (partial + x) x)\n        some-not-divisible (fn [s n] (some #(not (zero? (mod n %))) s))]\n    (first (drop-while (partial some-not-divisible more) xs))))","user":"53ea3a63e4b036ad0777e4dc"},{"code":"(fn [f & r]\r\n        (first (filter (fn [n] (every? #(= (rem n %) 0) r)) (map (partial * f) (rest (range)))))\r\n     )","problem":100,"user":"4e4870d1535dc968683fc4bc"},{"code":"(fn [& nums]\n  (let [multiples (map #(map (partial * %) (drop 1 (range))) nums)]\n    (loop [m multiples]\n      (if (apply = (map first m))\n        (ffirst m)\n        (let [firsts (map first m)\n              threshold (nth (sort (distinct firsts)) 1)]\n          (recur (map #(drop-while (partial > threshold) %) m)))))))","problem":100,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"(fn foo [& args ]\n  (first (let [product (apply * args) increment (if (and (ratio? product) (= 1 (numerator product))) product 1)]\n         (for \n         [x (iterate #(+ increment %) 1)\n          y (list(reduce #(and %1 (not (ratio? (/ x %2)))) true args)) \n          :while y] x))))","problem":100,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [& xs]\r\n  (let [gcd (fn [a b] (if (zero? (rem a b)) b (recur b (rem a b))))\r\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\r\n    (reduce lcm xs)))","problem":100,"user":"5060d137e4b0dc10a69545a0"},{"code":"(fn [ & nombres]\n  (reduce \n  (fn [x y]\n    (\n    (fn lcm [a na b nb]\n      (if (= (* a na) (* b nb))\n        (* a na)\n        (if (> (* a na) (* b nb))\n          (lcm a na b (+ nb 1))\n          (lcm a (+ 1 na) b nb)\n        )\n      )\n    ) \n    x 1 y 1)\n  )\n  nombres\n  )\n)","problem":100,"user":"4f84400de4b033992c121c2e"},{"code":"(fn [& xs] \n  (reduce (fn [a b]\n    (let [\n      gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))]\n      (/ (* a b) (gcd a b)))) xs))","problem":100,"user":"4e25176e535d04ed9115e829"},{"problem":100,"code":"(fn lcmv [& v] (reduce (fn lcm [a b]\n                             (/ (* a b) ((fn gcd  [x y]\n                                           (if (zero? y)\n                                               x\n                                               (recur y (mod x y)))) a b))) v))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":100,"code":"(fn [& r]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n                a\n                (gcd b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce\n        (fn [a b]\n            (lcm a b))\n        r)))","user":"55c66ffee4b0e31453f649c2"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b] \n    (if (zero? b)\n     a \n    (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5facfb48e4b08cb800c85aea"},{"problem":100,"code":"(fn [& args]\n  (loop [largest (last (sort args))]\n    (if (every? integer? (map #(/ largest %) args)) largest\n        (recur (+ (last (sort args)) largest)))))","user":"5b2689e3e4b063e2438bcc33"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (gcd y (rem x y))))]\n    (/ (reduce * nums) (reduce gcd nums))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":100,"code":"(fn least-common-multiple [& nums]\n  (let [gcd (fn gcd [l r]\n              (if (zero? r) l\n                  (gcd r, (mod l r))))\n        ;; GCD of x, y, z is GCD(GCD of x, y), z) by associativity (proof:\n        ;; someone who gives a shit about proving shit with parentheses)\n        common-gcd (reduce gcd nums)]\n    (/ (reduce * nums) common-gcd)))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":100,"code":"(fn mcm [ & li ]\n  (let \n    [ mcd \n        (fn mcd [a b]\n          (if \n             (= b 0)\n             a\n             (recur b (mod a b))))]\n    (/ \n     (reduce * li) \n     (reduce mcd li))))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (rem a b))))]\n    (let [g (reduce gcd args)]\n      (reduce * (/ g) args))))","user":"543a8256e4b032a45b869327"},{"code":"(fn lcm \n  ([x1 x2 & xs] \n   (if (seq xs)\n     (apply lcm (cons (lcm x1 x2) xs))\n     (lcm x1 x2)\n     )\n   )\n  ([x y]\n   (let [int-ratio? (fn [a b] (= (int (/ a b)) (/ a b)))\n         valid? (fn [a b] (or (int-ratio? a b) (int-ratio? b a)))\n         invalid? (fn [a b] (not (valid? a b)))]\n     (->>\n      (map * (repeat x) (iterate inc 1))\n      (drop-while (fn [b] (invalid? y b)))\n      first\n      )\n\t  )\n\t  )\n\t  )","problem":100,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y] (if (= y 0) x (gcd y (mod x y))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n  )\n)","user":"4eeb8f68535d93acb0a668a9"},{"code":"(fn \r\n    [& x]\r\n    (let [m (for [n x]\r\n                      (map * (repeat n) (drop 1 (range))))]\r\n      (first (drop-while (fn [y] \r\n                           (let [b (map (fn [n] (drop-while #(< % y) n)) m)]\r\n                             (not (apply = (map first b))))) \r\n                         (first m))))\r\n    )","problem":100,"user":"4f410b63e4b0e243712b1fc5"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (letfn [(gcd [a b]\n                (cond\n                (= b 0) a\n                (> a b) (gcd b (mod a b))\n                (> b a) (gcd a (mod b a))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & rest] \n   (apply lcm (lcm x y) rest)))","user":"4ec7c32c535d6d7199dd36e6"},{"problem":100,"code":"(fn lcm [x & rest] \n  (first \n   (for [multiple (iterate (partial + x) x)\n         :let [pred #(= (rem multiple %) 0)]\n         :when (every? pred rest)]\n    multiple)))","user":"56391b7ce4b0bfe05bf117ef"},{"problem":100,"code":"(fn least-common-multiple\n  [& the-numbers]\n  (letfn [(gcd [x y] \n            (let [m (rem x y)] \n              (if (zero? m) \n                y \n                (gcd y m))))\n          (lcm [x y] \n            (/ (* x y) \n               (gcd x y) ))]\n    (reduce lcm the-numbers)))","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn lcm [& args] \r\n  (/ (reduce * args) (reduce (fn gcd [x y] (if (= (mod x y) 0) y (gcd y (mod x y))  )) args )))","problem":100,"user":"50646c01e4b007509339a58b"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (letfn [(my-numer [x] (if (ratio? x) (numerator x) x))\n          (my-domer [x] (if (ratio? x) (denominator x) 1))\n          (int-gcd\n            ([x y] (if (zero? x) y (int-gcd (mod y x) x)))\n            ([x y & others] (reduce int-gcd (int-gcd x y) others)))\n          (int-lcm\n            ([x y] (/ (* x y) (int-gcd x y)))\n            ([x y & others] (reduce int-lcm (int-lcm x y) others)))]\n    (let [doms (map my-domer args)\n          nums (map my-numer args)\n          B (apply int-lcm doms)\n          As (map #(* %1 (/ B %2)) nums doms)\n          A (apply int-lcm As)]\n      (/ A B))))","user":"56897739e4b0dcc4269f407d"},{"problem":100,"code":"(fn f [x & y]\n  (letfn [(g [a b]\n             (cond\n              (= b 0) a\n              (= a 0) b\n              (> a b) (g b (mod a b))\n              (> b a) (g a (mod b a))))]\n    (reduce\n     #(/ (* % %2) (g % %2))\n     x y)))","user":"533018b2e4b019098a6f8b56"},{"code":"(fn kgv [& x]\n      (let [ m (apply min x) ] \n        (letfn [(k  [x n] \n                    (if (every? #(= 0 (rem n % )) x)  n\n                      (k x (+ n m)))\n                    )  ] (k x m )\n              )))","problem":100,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn lcm [h & t]\n  (letfn [(gcd \n            [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (inner [a b]\n            (/ (* a b) (gcd a b)))]\n  (reduce #(inner %1 %2) h t)))","problem":100,"user":"4db6ce85535d1e037afb217f"},{"code":"(fn [x & nums]\n  (let [gcd (fn [x y] (if (= 0 y) x (recur y (mod x y))))\n        lcm2 (fn [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm2 x nums)))","problem":100,"user":"4f13047d535d64f60314642c"},{"code":"(fn [& args]\n  (let [gcd (fn this [a b] (if (zero? b) a (recur b (mod a b))))]\n  (loop [[a b & others] args]\n    (let [lcm (/ (* a b) (gcd a b))]\n      (if (empty? others)\n        lcm\n        (recur (cons lcm others)))))))","problem":100,"user":"4ea4fe1f535d7eef308072cf"},{"code":"#(letfn [(gcd [m n](if (= n 0) m (recur n (rem m n))))\n         (lcm [m n](* (/ m (gcd m n)) n))]\n    (reduce lcm %&))","problem":100,"user":"4eb5750a535d7eef30807366"},{"code":"(fn [& xs]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (gcd y (mod x y))))\n          (lcm [x y]\n            (/ (* x y)\n               (gcd x y)))]\n    (reduce lcm xs)))","problem":100,"user":"50586354e4b06522596eba78"},{"problem":100,"code":"(fn [& args] (reduce \n              \n              (fn [a b] (let [mul (* (if (ratio? a) (denominator a) 1 ) (if (ratio? b) (denominator b) 1 )     ) \n                              muleda (* a mul)\n                              muledb (* b mul)\n                              \n                              gcd (last (filter #(and (= 0 (rem muleda %)) (= 0 (rem muledb %)) ) (range 1 (inc muleda))  ) )]\n                          (/ (/ (* muleda muledb) gcd  ) mul ))  )\n              \n              args) )","user":"56a6051fe4b0542e1f8d14e5"},{"problem":100,"code":"(fn [& x]\n     (letfn\n       [\n        (gcd [x y]\n          (if (= x 0)\n            y\n            (gcd (mod y x) x)\n            )\n          )\n        (lcm [a b]\n          (/ (* a b) (gcd a b)))\n        ]\n       (reduce lcm x))\n     )","user":"58a44a14e4b01a0c0b2328f2"},{"problem":100,"code":"(fn [x & xs]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))\n          (lcm \n            ([a b] (/ (* a b) (gcd a b)))\n            ([a b & others] (reduce lcm (into [a b] others))))]\n    (apply lcm (conj xs x))))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":100,"code":"(fn [& nums]\n               (let [gcd (fn [a b]\n                           (if (= b 0)\n                             a\n                             (recur b (rem a b))))]\n                 (reduce #(/ (* %1 %2) (gcd %1 %2)) nums))\n               )","user":"5658b9bde4b00d315579610e"},{"problem":100,"code":"(fn\n  [& args]\n  (reduce\n    (fn\n      [acc curr]\n      (/\n        (* acc curr)\n        (#(if (zero? %2)\n            %1\n            (recur %2 (mod %1 %2))) acc curr)))\n    args))","user":"5d1c14cde4b02ea6f0fb698a"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn gcd [a b] (cond (= a b) a\n                                (> a b) (recur (- a b) b) \n                                (< a b) (recur a (- b a))))\n        lcm (fn lcm [a b] (* (/ a (gcd a b)) b))\n        ] (reduce lcm args)))","user":"577202d2e4b0979f896515c0"},{"problem":100,"code":"(fn lcm [& ys] (/ (apply * ys) ((fn gcd [xs] (reduce (fn f [x y] (if (zero? y) x (f y (mod x y)))) xs)) ys)))","user":"5b7bc82ce4b047b03b203726"},{"code":"(fn [& x]\r\n    (reduce \r\n      (fn [x y]\r\n        (/ (* x y) (loop [a x\r\n                          b y]\r\n                     (if (= b 0)\r\n                       a\r\n                       (recur b (rem a b)))))) x))","problem":100,"user":"4e5bdc2b535d8a8b8723a2bb"},{"problem":100,"code":"(fn mcm [n & nums]\n  (let [m (iterate (partial + n) n)]\n    (first (filter (fn [x]\n                     (every? #(zero? (mod x %)) nums))\n                   m))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn [& coll]\n  (letfn [ (lcm [a b] (/ (* a b) (gcd a b)))\n           (gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n        (reduce lcm coll)))","problem":100,"user":"4f6b4237e4b07046d9f4efa9"},{"code":"(fn lcm [& xs]\n  (letfn [(gcd1 [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (apply * xs)(reduce gcd1 xs))))","problem":100,"user":"5106bc8ae4b01150e115ebec"},{"code":"(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n      lcm (fn [a b] (/ (* a b) (gcd a b)))]\n  #(reduce lcm %&))","problem":100,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":100,"code":"(fn xlcm\n    ([a b c d] (xlcm (xlcm a b) c d))\n    ([a b c] (xlcm (xlcm a b) c))\n    ([a b]\n    (let [\n        lcm (fn [m n]\n                (/\n                    (* m n)\n                    (  \n                        ;; gcd\n                        (fn gcd [a b]\n                            (if (< a b)\n                                (recur b a)\n                                (let [r (mod a b)]\n                                    (if (= r 0)\n                                        b\n                                        (recur b r)\n                                    )\n                                )\n                            )\n                        )\n                        ;; // gcd\n                        m n\n                    )\n                )\n            )\n        ]\n        (if (and (integer? a) (integer? b))\n            (lcm a b)\n            (let [\n                   na (if (ratio? a) (numerator a) a),\n                   nb (if (ratio? b) (numerator b) b),\n                   da (if (ratio? a) (denominator a) 1),\n                   db (if (ratio? b) (denominator b) 1)\n                 ]\n              (/\n                (lcm (* na db) (* nb da))\n                (* da db)\n              )\n            )\n        )\n    ))\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":100,"code":"(fn lcmz\n  ([x y]\n   (/ (* x y)\n      ((fn gcd [a b]\n         (cond\n           (= a b) a\n           (< a b) (gcd a (- b a))\n           :else (gcd (- a b) b))) x y)))\n  ([x y & rest] (apply lcmz (lcmz x y) rest)))","user":"5e9683f1e4b0157ca96647c7"},{"code":"(fn least3 [& k] ((fn xx [coll] (if (< 2 (count coll))\n                                    ((fn least [x y i]  \n                                       (if (= 0 (rem (* x i) y)) \n                                         (* x i)\n                                         (least x y (+ 1 i)))) (first coll) (xx (rest coll)) 1)\n                                    ((fn least [x y i]  \n                                       (if (= 0 (rem (* x i) y)) \n                                         (* x i)\n                                         (least x y (+ 1 i)))) (first coll) (second coll) 1)\n                                    )   \n                      ) k ))","problem":100,"user":"5296aa9be4b02ebb4ef75034"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (reduce (fn [result input]\n              (/ (* result input) (gcd result input)))\n            xs)))","user":"555521a5e4b0deb715856e12"},{"problem":100,"code":"(fn lcm [& args] \n  (let [gcdf (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (/ (reduce * args) (reduce gcdf args))\n    ))","user":"57f81045e4b0d3187e90090f"},{"problem":100,"code":"(fn lcmv [& v]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b) a\n                            (recur b, (mod a b))))\n        lcm (fn lcm [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm v)))","user":"534056fce4b085b17e897dac"},{"problem":100,"code":"(fn lcm [x & y]\n  (let [gcd (fn [a b]\n        (if (zero? b) a\n          (recur b (mod a b))))]\n   (/ (reduce * (cons x y)) (reduce gcd x y))))","user":"54b54d1be4b05787c3b1639c"},{"problem":100,"code":"(fn lcm [& args]\n  (let [impl (fn self [xs xms]\n               (if (apply == xms)\n                 (first xms)\n                 (let [x (apply min xms)\n                       index (.indexOf xms x)\n                       xinxs (nth xs index)\n                       xm1s (assoc xms index (+ x xinxs))]\n                   (self xs xm1s))))]\n    (impl (apply vector args) (apply vector args))))","user":"5344fe13e4b084c2834f4a32"},{"problem":100,"code":"(fn [& xs]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n            (lcm [a b]\n              (/ (* a b)\n                 (gcd a b)))]\n      (reduce lcm xs)))","user":"554e4d65e4b00713264bd993"},{"problem":100,"code":"(fn [& args]\n  (let[gcd (fn [a b]\n             (if (zero? b)\n               a\n               (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5694292ee4b0dcc4269f4113"},{"problem":100,"code":"(fn [& xs]\n  (/\n    (apply * xs)\n    (reduce #(if (zero? %2)\n               %1\n               (recur %2 (mod %1 %2))) xs)))","user":"5c51c930e4b0fb8c5ffd99ce"},{"problem":100,"code":"(fn [& args]\n   (letfn [(gcd [a b]\n                (loop [ia a ib b]\n                  (if (= ib 0)\n                    ia\n                    (recur ib (mod ia ib)))))\n           (lcm [a b] (* (/ a (gcd a b)) b))]\n     (reduce lcm args)))","user":"53c06438e4b0c98a41f5ccb0"},{"code":"(fn lcm[& args]\n  (loop [l args mx 500 s (into #{} (map #(* (first l) %) (range 1 mx))) ]\n    (if (empty? l)\n      (first (sort s))\n      (recur (next l) mx (clojure.set/intersection s (into #{} (map #(* (first l) %) (range 1 mx)))))\n      )\n    )\n  )","problem":100,"user":"4e9def6b535dbda64a6f6b8f"},{"problem":100,"code":"(fn lcm                                    \n  ([a b]                                     \n   (letfn [(gcd [a b]                       \n             (loop [a a                      \n                    b b]                     \n               (if (= b 0)                   \n                 a                           \n                 (recur b (mod a b)))))]     \n     (/ (* a b) (gcd a b))))                \n  ([a b & more]                              \n    (lcm a (apply lcm b more))))","user":"50573ed8e4b0012181721987"},{"problem":100,"code":"(fn lcm [& xs]\n  (letfn [(gcd2 [a b] \n                (let [[mn mx]  (sort [a b])]\n                  (if (= mn mx) mn (recur (- mx mn) mn))))\n          (lcm2 [a b]\n                (/ (* a b) (gcd2 a b)))]\n    (reduce lcm2 xs)))","user":"563772a9e4b0bfe05bf117d7"},{"problem":100,"code":"(let [abs (fn [n] (if (neg? n) (- n) n))\n      gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n      lcm (fn [a b] (/ (abs (* a b))\n                       (gcd a b)))]\n  (fn [a b & more]\n    (reduce lcm (lcm a b) more)))","user":"50b65966e4b0a86f8358ca6c"},{"code":"(fn [& coll]\n  (letfn[(lcm[a b] (if (or (ratio? a) (ratio? b))\n      (cond\n        (and (ratio? a) (ratio? b)) ;; both are ratios\n          (/ (lcm (numerator a) (numerator b)) \n             (gcd (denominator a) (denominator b)))\n        (and (ratio? a) (not (ratio? b))) ;; a is a ratio\n          (/ (lcm (numerator a) b) \n             (gcd (denominator a) 1))\n        :else \n        (/ (lcm a (numerator b)) (gcd 1 (denominator b)))\n      )\n      (/ (* a b) (gcd a b))))\n     (gcd [a b] (cond (= a b) a (> a b) (gcd (- a b) b)\n       :else (gcd a (- b a))))]\n    (reduce lcm coll)))","problem":100,"user":"5078300de4b0fc74642bff66"},{"code":"(fn [& args]\n  (let [gcd (fn _gcd \n              ([n m] (if (= 0 m) n (_gcd m (mod n m))))\n              ([n m & nums] (reduce _gcd (_gcd n m) nums))\n              )\n        ]\n    (/ (apply * args) (apply gcd args))\n  )\n)","problem":100,"user":"5323a414e4b09d4e7a9b54d1"},{"code":"(fn lcm[& kkk]\n  (let [orig(into [] kkk)]\n    (loop [s orig]\n\t     (if (apply = s)\n\t\t (first s)\n\t\t (let [mk (apply min-key #(get s %) (range (count s)))]\n\t\t      (recur (assoc s mk (+ (nth s mk) (nth orig mk)))))))))","problem":100,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn [& nums]\n  (loop [mults (apply merge (map (fn [k] {k k}) nums))]\n    (let [values (vals mults)]\n      (if (apply = values)\n        (first values)\n        (let [[k v] (apply min-key (fn [[k v]] v) mults)]\n          (recur (assoc mults k (+ v k))))))))","problem":100,"user":"5225271fe4b01819a2de42f9"},{"problem":100,"code":"(fn lcm [& coll]\n  (let [vcoll (vec coll)]\n    (loop [c vcoll]\n      (if (apply = c) (c 0)\n          (let [least-el (apply min c)\n                least-k (.indexOf c least-el)]\n            (recur (assoc c least-k (+ least-el (vcoll least-k)))))))))","user":"5146f343e4b04ef915e3731e"},{"code":"(fn [& v]\n  (letfn [(gcd [n1 n2]\n            (cond\n              (zero? n2) n1\n              (> n2 n1) (recur n2 n1)\n              :default (recur (- n1 n2) n2)\n              ))\n          (lcm [[n1 d1] [n2 d2]]\n            (/ (/ (* n1 n2) (gcd n1 n2)) (gcd d1 d2))\n            )\n          (norm [n]\n            (if (ratio? n)\n              (vector (.numerator n) (.denominator n))\n              (vector n 1)\n              )\n            )\n          ]\n    (reduce #(lcm (norm %1) (norm %2)) v)\n    )\n  )","problem":100,"user":"4fcad14ce4b0ee37620e1856"},{"problem":100,"code":"(fn [& nums]\n  ((fn smallest-multiple? [i sorted-nums] \n    (let [mltpl (* (first sorted-nums) i)] \n      (if (every? #(= (rem mltpl %) 0) (rest sorted-nums)) \n        mltpl \n        (smallest-multiple? (inc i) sorted-nums))))\n   1 (sort > nums)))","user":"562e8b2be4b0ab312c17ebbb"},{"problem":100,"code":"(fn gcm\n  [num & nums]\n  (first \n    (filter \n      (fn [mult] (every? #(== 0 (rem mult %)) nums)) \n      ((fn lazy-mults\n  \t\t([num] (lazy-mults num num))\n  \t\t([num base] (lazy-seq (cons num (lazy-mults (+ num base) base))))) num))))","user":"5c1d9f05e4b0efcb0b05b24c"},{"problem":100,"code":"(fn least-common-multiple [& args]\n               (letfn [(least-common-multiple-of-two [a b]\n                         (if (= a b) a\n                             (if (> a b) (least-common-multiple b a)\n                                 (loop [mu-a 1 mu-b 1]\n                                   (if (= (* mu-a a) (* mu-b b))\n                                     (* mu-a a)\n                                     (if (> (* mu-a a) (* mu-b b))\n                                       (recur mu-a (inc mu-b))\n                                       (recur (inc mu-a) mu-b)))))))]\n                 (loop [remaining (rest args) ans (first args)]\n                   (if (empty? remaining)\n                     ans\n                     (recur (rest remaining) (least-common-multiple-of-two ans (first remaining)))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn [& n]\n  (let [nwd (fn [n1 n2] (if (not= 0 n2) (recur n2 (mod n1 n2)) n1))\n        nww (fn [n1 n2] (/ (* n1 n2) (nwd n1 n2)))]\n    (reduce nww n)))","problem":100,"user":"4fb79872e4b081705acca2d2"},{"problem":100,"code":"(fn [& args]\n   (let [c (map #(set (take 1000 (iterate (partial + %) %))) args)\n         ic (apply clojure.set/intersection c)\n         LCM (first (apply sorted-set ic))]\n     LCM))","user":"5978c844e4b01722bebd4d18"},{"code":"(fn [& a] (letfn\n               [(align-seq  [[a b]] [(drop-while #(< % (first b)) a) b])\n                (sync-seq   [[a b]] (if (= (first a) (first b)) [a b]\n                                        (sync-seq (align-seq (sort-by first [a b])))))\n                (diff-first [s    ] (let [[[a & m] [b & n] & r] (partition-by first s)]\n                                      (apply concat [a b] m n r)))\n                (sync-seqs  [s    ] (if (apply = (map first s)) (first (first s))\n                                        (let [[a b] (split-at 2 (diff-first s))]\n                                          (sync-seqs (concat (sync-seq a) b)))))]\n             (sync-seqs (map #(map (partial * %) \n                                   (map inc (range)))\n                             a))))","problem":100,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [& n]\r\n  (loop [m (zipmap n n)]\r\n    (if (= 1 (count (set (vals m))))\r\n      (first (vals m))\r\n      (let [min-key (first (reduce (fn [x y] (if (< (val x) (val y)) x y)) m))]\r\n        (recur (update-in m [min-key] #(+ % min-key)))))))","problem":100,"user":"4db85282535d1e037afb218a"},{"code":"(fn __ [& coll]\n  (reduce #(/ (* % %2) ((fn [a b]\n                          (if (zero? b)\n                            a\n                            (recur b, (mod a b))))\n                         % %2)) coll))","problem":100,"user":"52828298e4b0757a1b17145b"},{"code":"(fn [& x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))\n  (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm x)))","problem":100,"user":"4ea9b80c535d7eef30807306"},{"code":"(fn lcm [a & b] (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) lcm2 (fn [a b] (/ (* a b) (gcd a b)))]\n   (cond\n\t   (empty? b) a\n\t   (empty? (rest b)) (lcm2 a (first b))\n\t   :else (apply (partial lcm (lcm2 a (first b))) (rest b)))))","problem":100,"user":"4e6e3a1e535d5021c1a89602"},{"problem":100,"code":"(fn least-common \n  [& val]\n  (let [n (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))]\n    (reduce (fn [a b]\n              (* (/ a (n a b)) b)) val)))","user":"5a99b861e4b0d174b936c7ad"},{"problem":100,"code":"(fn [& args] \n  (reduce (fn [x y]\n            (first (drop-while\n                    \t#(not (zero? (rem % y)))\n                    \t(iterate #(+ x %) x))))\n          args))","user":"56baa68ce4b0f26550335947"},{"problem":100,"code":"(fn [& a] (first (sort (apply clojure.set/intersection (map set (map #(take 500 (iterate (partial + %) %)) a))))))","user":"5676af21e4b05957ce8c6158"},{"code":"(fn [& numbers]\n    (let [sorted-numbers (reverse (sort numbers))\n          cm-producer (fn [n] (map #(* n %) (rest (range))))\n          cms (map #(cm-producer %) sorted-numbers)\n          main-cm (first cms)\n          others-cm (rest cms)\n          find-smallest-eq? (fn [s n] (== n (first (drop-while #(< % n) s))))\n          find-cm (fn [s] (if (every? #(find-smallest-eq? % (first s)) others-cm) (first s) (recur (rest s))))]\n      (find-cm main-cm)))","problem":100,"user":"4ee77f15535d93acb0a66868"},{"problem":100,"code":"(fn [& coll]\n    (let [max-val (apply max coll)]\n      (first (drop-while (fn [n] (not (every? #(zero? (rem n %)) coll))) (iterate (partial + max-val) max-val)))))","user":"57202eb7e4b0c5bde472c090"},{"problem":100,"code":"(fn [& a]\n(/ (apply * a)\n     (reduce (fn c [x y]\n  \t\t\t\t(if (= y 0)\n    \t\t\t\tx\n    \t\t\t\t(c y (mod x y)))) a)))","user":"58b54852e4b0ebc645576d52"},{"code":"(fn gen-lcm [x y & more]\n  (letfn\n      [(_gcd [x y]\n         (cond (< x y) (_gcd y x)\n               (= y 0)  x\n               true (recur y (mod x y))))\n       (_lcm [x y]\n         (quot (* x y) (_gcd x y)))]\n    (reduce #(let [m1 (if (ratio? %1) (numerator %1) %1)\n                   n1 (if (ratio? %2) (numerator %2) %2)\n                   m2 (if (ratio? %1) (denominator %1) 1)\n                   n2 (if (ratio? %2) (denominator %2) 1)\n                   g2 (_gcd m2 n2)\n                   l2 (quot (* m2 n2) g2)]\n               (/ (_lcm (* m1 n2) (* n1 m2)) (* l2 g2)))\n            (cons x (cons y more)))))","problem":100,"user":"4ef6f5ea535dced4c769f250"},{"problem":100,"code":"(fn [& n]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [& args] (loop [nums (zipmap args args)]\n               (let [current (sort-by first (for [x (keys nums)] [(nums x) x])),\n                     minval (first (first current)),\n                     maxval (first (last current)),\n                     minkey (last (first current)),\n                     restvals (apply zipmap ((juxt (partial map last) (partial map first)) (rest current)))]\n                 (if (= minval maxval) minval\n                     (recur (assoc restvals minkey (+ minval minkey)))))))","problem":100,"user":"52bdf6bde4b07a9af579230d"},{"code":"(fn [& nums]\r\n  (let [\r\n      is-cm? (fn [n itms] (every? #(zero? (rem n %)) itms)) \r\n      f (first nums)]\r\n    (some \r\n      #(when (is-cm? % (rest nums)) %) \r\n      (iterate (partial + f) f))))","problem":100,"user":"5003ee7de4b0678c553fc446"},{"problem":100,"code":"(fn nlcm [& xs] (let [gcd (fn gcd [p q] (if (= 0 q) p (gcd q (mod p q))))\n                        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n                    (reduce lcm xs)))","user":"5b421edce4b02d533a91bc2c"},{"code":"(fn LCCC [& s]\n\t(reduce (fn lcm [a b]\n  \t\t\t\t(/ (* a b) \n                   ((fn gcd [c d]\n  \t\t\t\t\t\t(if (= 0 d)\n    \t\t\t\t\t\tc\n    \t\t\t\t\t\t(gcd d (rem c d)))) a b))) s))","problem":100,"user":"522048b3e4b0e6c71e0c0c16"},{"code":"(fn [ & xs]\n (letfn [(gcd [x y] (loop [a x b y] (if (zero? b) a (recur b (mod a b)))))]\n  (reduce (fn [a b] (/ (* a b) (gcd a b))) (first xs) (rest xs))))","problem":100,"user":"5097b556e4b00ad8bab4e970"},{"problem":100,"code":"(fn lcm\n  ([a b] (/ (* a b) ((fn gcd' [a b] (if (zero? b) a (recur b (mod a b)))) a b)))\n  ([a b c] (lcm (lcm a b) c))\n  ([a b c d] (lcm (lcm (lcm a b) c) d)))","user":"557e8326e4b05c286339e0d7"},{"problem":100,"code":"(fn [& args] (reduce (fn [x y] \n                        (if (every? true? (map #(= 0 (mod y %)) args)) y x)) \n                      0 (map #(/ % 2) (reverse (range 1 421)))))","user":"51c8f1d8e4b07ef393169e5d"},{"problem":100,"code":"(fn lcm-4clj\n    ([x y]\n     (letfn [(gcd [x y] (if (= 0 y) x (recur y (mod x y))))]\n       (/ (* x y) (gcd x y))))\n    ([x y & nums]\n     (apply lcm-4clj (cons (lcm-4clj x y) nums))))","user":"5f8e2a08e4b0715f5002d767"},{"problem":100,"code":"(fn lcm [& n]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (recur b (mod a b))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"607dd962e4b03d835a6eaed2"},{"code":"(fn [& n] (reduce #((fn [a b] (/ (* a b) ((fn [a b] (if (zero? b) a (recur b (mod a b)))) a b))) %1 %2) n))","problem":100,"user":"4ef2d243535dced4c769f221"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [min-arg (apply min args)\n         min-arg-multiple min-arg]\n    (if (every? #(zero? (mod min-arg-multiple %)) args)\n      min-arg-multiple\n      (recur min-arg (+ min-arg-multiple min-arg)))))","user":"551bdefde4b07993ea3788d7"},{"problem":100,"code":"(fn [& ns] (loop [N (vec ns) R N] (if (apply == R) (R 0) (recur N (let [i (.indexOf R (apply min R))] (assoc R i (+ (R i) (N i))))))))","user":"55f6fe09e4b06e875b46cea2"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [x y]\n               (if (zero? y)\n                 x\n                 (recur y (mod x y))))\n          (lcm [x y]\n               (* x y (/ (gcd x y))))]\n    (reduce lcm xs)))","user":"575cbe44e4b02ea114799374"},{"code":"(fn [a & bs]\n  (let [ps (apply every-pred (map (fn [b] #(zero? (rem % b))) bs))]\n    (some #(if (ps %) % nil) (iterate (partial + a) a))))","problem":100,"user":"4ff3df0fe4b0678c553fc355"},{"problem":100,"code":"#(/ (apply * %&)\n\t(reduce (fn [a b] (if (zero? b) a (recur b (mod a b)))) %&))","user":"5dfc457de4b0a607a9a45cea"},{"code":"(fn [& args]\r\n  (let [args (into {} (map #(vector % %) args))\r\n        lcm (fn [args]\r\n              (if (apply = (vals args))\r\n                (second (first args))\r\n                (let [min (apply min (vals args))]\r\n                   (recur (into {} (map (fn [[k v]] (if (= min v) [k (+ k v)] [k v]))\r\nargs))))))]\r\n     (lcm args)))","problem":100,"user":"4e8681b7535dae1a5effa438"},{"code":"#(ffirst (filter (fn[y](not (zero? (first y)))) (filter (fn[x](= (count x)(count %&)))(partition-by identity (sort (apply concat (map (fn[x](range 0 211 x)) %&)))))))","problem":100,"user":"4ed2dd98535d44c135fd68e2"},{"problem":100,"code":"(fn lcm [& x]\n  (letfn [(gcd ([x y] (if (> x y) (gcd y x) (if (zero? x) y (gcd (rem y x) x))))\n               ([x y & zs] (apply gcd (gcd x y) zs)))]\n    (/ (apply * x) (apply gcd x))))","user":"5ac91d90e4b0e27600da77bd"},{"problem":100,"code":"(fn [& xs] (first (apply clojure.set/intersection\n                         (map (fn [x] (apply sorted-set (take 500 (iterate (partial + x) x)))) xs))))","user":"585dbe41e4b0f14aab7c879f"},{"problem":100,"code":"(fn lcm\n  [& args]\n    (let [gcd (fn gcd [a b] (if (= 0 b) a (recur b (rem a b))))]\n      (reduce (fn lcm [%1 %2] (/ (* %1 %2) (gcd %1 %2))) args)))","user":"5bbbcf9ee4b0a20761a23614"},{"code":"(fn [ & xs] (reduce \n             #(/ (* %1 %2) \n                 ((fn gcd [x y] (if (= 0 x) y (gcd (mod y x) x))) %1 %2)) xs))","problem":100,"user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [a & r]\n  (first \n    (filter \n      #(every? (comp zero? (partial mod %)) r)\n      (map #(* a (inc %)) (range)))))","problem":100,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn lcm\n   ([x y]\n      (let [gcd (fn gcd [a b]\n                  (if (zero? b)\n                    a\n                    (recur b (mod a b))))]\n        (/ (* x y)\n           (gcd x y))))\n   ([x y & rest]\n      (reduce lcm 1 (concat [x y] rest))))","problem":100,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn lcm [& nums]\n  (first (filter #(every? integer? (map (partial / %) nums)) (iterate #(+ (apply min nums) %) (apply min nums)))))","problem":100,"user":"50d3b03fe4b030b634c368b9"},{"problem":100,"code":"(fn KPK\n  ([x y]\n     (letfn [(fpb [a b]\n               (cond\n                (= b 0) a\n                (> a b) (fpb b (mod a b))\n                (> b a) (fpb a (mod b a))))]\n       (/ (* x y) (fpb x y))))\n  ([x y & rest] (apply KPK (KPK x y) rest)))","user":"564d3169e4b0284900eef67c"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd #(let [a (max % %2)\n                   b (min % %2)\n                   r (rem a b)]\n               (if (zero? r)\n                 b\n                 (recur b r)))\n        lcm (fn [x y]\n              (* x (/ y (gcd x y))))]\n    (reduce lcm xs)))","user":"594880ade4b07ddc2dafadc2"},{"problem":100,"code":"(fn [& args]\n   (let [GCD\n         (fn\n           [a b]\n           (if (zero? b)\n             a\n             (recur b (mod a b))))\n         LCM\n         (fn\n           [a b]\n           (/ (* b a) (GCD a b)))]\n     (reduce LCM args)))","user":"5bbc0ddfe4b0a20761a2361e"},{"problem":100,"code":"(fn [& nums]\n  (let [com (reduce * (map #(if (ratio? %) (denominator %) 1) nums))\n        normalizedNumbers (map #(* % com) nums)\n        maxnum (apply max normalizedNumbers)\n        divs (range 2 (inc maxnum))]\n    (loop [numbs normalizedNumbers divis divs res 1]\n      (let [div (first divis)\n            remaining (rest divis)\n            dividido (map #(rem % div) numbs)]\n        (cond\n          (some #(= % 0) dividido)     (recur (map #(if (= 0 %2) (/ %1 div) %1) numbs dividido) divis (* res div))\n          (= (distinct numbs) (seq [1])) (/ res com)\n          :else (recur numbs remaining res))))))","user":"5d0beecee4b0cc9c91588239"},{"code":"(let [gcd (fn [a b]\n            (cond\n             (= a b) a\n             (> a b) (recur (- a b) b)\n             (< a b) (recur a (- b a))))\n      lcm (fn [a b ] (/ (* a b) (gcd a b)))]\n  (fn [& numbers]\n    (reduce lcm numbers)))","problem":100,"user":"4feaa579e4b0140c20fb9c0b"},{"code":"(fn [a & coll]\n  (first (filter (fn [v] \n                   (every? integer? (map #(/ v %) coll)))\n                 (map #(* a %) (drop 2 (range))))))","problem":100,"user":"51780f88e4b03d69594194c9"},{"code":"(fn [& ar]\n  (letfn [(gcd [a b]\n    (if (zero? b)\n      a\n      (if (zero? a)\n        b\n        (if (< a b)\n          (recur a (mod b a))\n          (recur b (mod a b))))))]\n    (/ (apply * ar) (reduce gcd ar))))","problem":100,"user":"5050b107e4b063148f524126"},{"problem":100,"code":"(fn [& args] \n  (reduce (fn [x y]\n            (let [gcd (fn [m n]\n                        (loop [a (max m n)\n                               b (min m n)]\n                          (if (= (rem a b) 0)\n                            b\n                            (recur b\n                                   (rem a b)))))\n                  gxy (gcd x y)\n                  pxy (* x y)]\n              (/ pxy gxy))) args))","user":"55995fa7e4b031d6649c9ba9"},{"problem":100,"code":";     \n;    (     )\n(fn [GCD & n] (reduce #(/ (* %1 %2) (GCD %1 %2)) n)) ; (x *y)/gcd\n(fn gcd [a b] (if (= b 0) a (recur b (mod a b))))\n\n;    \n;(fn [& x] \n;     (let \n;       [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n;        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n;     (reduce lcm x)))\n\n;          \n;      .     \n;     \n;(fn lcm [x & xs]\n;  (some (fn [x-multiple] (if (every? #(zero? (mod x-multiple %)) xs) x-multiple))\n;       (iterate #(+ x %) x)))\n\n;   \n;(fn [& nums]\n;  (/ (apply * nums) (reduce (fn [a b]\n;                              (if (zero? a)\n;                                b\n;                                (recur (mod b a) a))) nums)))\n\n; 3  false\n;((fn [x y] (/ (* x y) ((fn [a b]\n;                          (if (zero? a)\n;                            b\n;                            (recur (mod b a) a))) x y))) 3/4 1/6)","user":"572830e6e4b0c5bde472c152"},{"code":"(fn [& s]\n  ((fn l [n t]\n    (if (every? zero?\n          (map #(rem n %) t))\n      n\n      (l (+ n (nth t 0)) t))) (nth s 0) s))","problem":100,"user":"50361b6be4b0fbe0a74d26be"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [largest (apply max xs)]\n    (->> (for [x (iterate #(+ largest %) largest)]\n           [(set (map #(mod x %) xs)) x])\n         (filter #(= (first %) #{0}))\n         first\n         second)))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn lcm [n m & ms]\n  (letfn [(gcd [a b] \n               (loop [n a m b]\n                 (if (zero? m)\n                   n\n                   (recur m (mod n m))\n                   )\n                 ))]\n    (if (empty? ms)\n      (/ (* n m) (gcd n m))\n      (apply lcm (cons (/ (* n m) (gcd n m)) ms))\n      )\n    )\n  )","problem":100,"user":"529d4f4be4b04e0c58e87b79"},{"code":"(fn [c & r] \n  (/ (apply * c r) \n     (reduce #(if (= 0 %)\n                %2\n                (recur (rem %2 %) %)) \n             c\n             r)))","problem":100,"user":"4ec74de3535d6d7199dd36df"},{"problem":100,"code":"(fn [& nums] \n  (apply min\n   (apply\n   clojure.set/intersection\n   (map \n    #(set (take 1000 (map (fn [x] (* x %))  (rest (range)))))\n    nums))))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [a & args] \r\n  (loop [n a] \r\n    (if (every? #(= 0 (rem n %)) args) \r\n      n \r\n      (recur (+ n a)))))","problem":100,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn [& xs]\r\n    (letfn [(l-c-m\r\n              ([ys os]\r\n               (if (apply = ys)\r\n                 (first ys)\r\n                 (let [m (apply min ys)\r\n                       [h t] (split-with #(not= % m) ys)]\r\n                   (l-c-m (concat h [(+ (os (count h)) (first t))] (rest t)) os)))))]\r\n      (l-c-m xs (vec xs))))","problem":100,"user":"4dd61f98535d2dad7130b5c6"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n               (if (= 0 b)\n                 a\n                 (gcd b (mod a b))))]\n    (/ (apply * args) (reduce gcd args))))","user":"525cc912e4b0cb4875a45d48"},{"problem":100,"code":"(fn \n  [& args]\n  (let [gcd (fn\n  [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5f724f55e4b02876ed9fd089"},{"problem":100,"code":"; use letfn and simpler gcd\n(letfn\n  [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n   (lcm [a b] (/ (* a b) (gcd a b)))]\n  #(reduce lcm %&))\n\n; first try\n#_(fn lcm [& args]\n  (/\n    (apply * args)\n    (reduce\n      (fn gcd [a b]\n        (cond\n          (> a b) (recur (- a b) b)\n          (< a b) (recur a (- b a))\n          :else a))\n      args)))","user":"55e7d06ee4b050e68259b496"},{"problem":100,"code":"(fn lcm\n    ([x y]   (/ (* x y)\n                ;; gcd\n                ((fn gcd [m n] (if (= 0 n) m (gcd n (mod m n)))) x y)))\n    ([x y & more]  (reduce lcm (lcm x y) more )))","user":"55f8b32ae4b03cbcff9738ba"},{"problem":100,"code":"(fn [& c] \n\t(reduce\n\t\t(fn lcm [a b]\n\t\t\t(letfn [(mult-abs [a b] (max (* a b) (-(* a b))))\n\t\t\t\t      (gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n\t\t\t(/ (mult-abs a b) (gcd a b)))) \n\t\tc))","user":"56540485e4b0f9d632dd847a"},{"problem":100,"code":"(fn [& args]\n   (let [input-numbers (vec args)]\n     (loop [numbers input-numbers]\n       (if (apply = numbers)\n         (first numbers)\n         (let [lowest-number (first (sort numbers))\n               lowest-number-idx (.indexOf numbers lowest-number)\n               updated-lowest-number (+ lowest-number (input-numbers lowest-number-idx))]\n           (recur (assoc numbers lowest-number-idx updated-lowest-number)))))))","user":"4f213e2ee4b0d66497709fcf"},{"code":"(fn one-hundred\n  [& coll]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b ))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm coll)))","problem":100,"user":"510591dde4b06d28cacc92eb"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [gcd #(if (zero? %2)\n               %1\n               (recur %2 (mod %1 %2)))]\n    (/ (reduce * xs) (reduce gcd xs))))","user":"577f0b0ee4b0c8d87281f6f3"},{"code":"(letfn [(gcd\r\n          ([n m]\r\n            (if (zero? n)\r\n                m\r\n                (recur (rem m n) n)))\r\n          ([n m & args]\r\n            (loop [n n\r\n                   m m\r\n                   rest-nums args]\r\n                (if (empty? rest-nums)\r\n                    (gcd n m)\r\n                    (recur (gcd n m) (first rest-nums) (rest rest-nums))))))]\r\n  (fn lcm\r\n    ([n m]\r\n      (/ (* n m) (gcd n m)))\r\n    ([n m & args]\r\n      (/ (apply * n m args)\r\n         (apply gcd n m args)))))","problem":100,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(fn [& x] (/ (apply * x) (reduce #(if (= 0 %) %2 (recur (mod %2 %) %)) x)))","problem":100,"user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn lcm\n  ([a b]\n   (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\n     (/ (* a b) (gcd a b))))\n  ([a b & more]\n   (reduce lcm (lcm a b) more)))","problem":100,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":100,"code":"(fn[& args]\n      (loop [mult 1]\n        (let[curval (* (first args) mult)]\n          (if (every? zero? (map #(rem curval %) args))\n            curval\n            (recur (inc mult))\n            ))))","user":"54f4a457e4b0f2f3c5226e83"},{"code":"(fn lcm [& args]\r\n  (/ (reduce * args)\r\n     (reduce (fn [m n] (if (zero? n) m (recur n (mod m n)))) args)))","problem":100,"user":"4dc1ee85535d020aff1edf91"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [n m]\n          (if (zero? m)\n            n\n            (recur m (mod n m))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5c03e927e4b0bdcf453d167b"},{"problem":100,"code":"(fn [a b & xs]\n  (let [gcd (fn [a b] (if (zero? a) b (recur (mod b a) a)))\n        lcm (/ (* a b) (gcd a b))]\n    (if (seq xs)\n      (recur lcm (first xs) (next xs))\n      lcm)))","user":"4f3ca5a6e4b0e243712b1f53"},{"problem":100,"code":"(fn [& nums]\n  (loop [curr (vec nums)\n         orig (vec nums)]\n    (let [low (apply min curr)\n          pos (.indexOf curr low)]\n      (if (every? #(= (first curr) %) curr)\n        (first curr)\n        (recur (assoc curr pos (+ (get orig pos) (get curr pos)))\n               orig)))))","user":"5c24671be4b07e362c2305a1"},{"problem":100,"code":"(fn lcm [a b & more]\n  (if (empty? more)\n    (* b (numerator (/ a b)))\n    (recur (lcm a b) (first more) (rest more))))","user":"5ed9c2cde4b0c7845d86b0e4"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [cd (fn gcd [a b] (if (= 0 b) a (recur b (mod a b))))\n        lcformula (fn [a b] (/ (* a b) (cd a b)))]\n    (loop [fst (first nums) sec (second nums) rst (drop 2 nums)]\n      (if (nil? sec) fst (recur (lcformula fst sec) (first rst) (rest rst))))))","user":"5adcc688e4b0837691e92c05"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? (rem a b)) b (gcd b (rem a b))))\n          (lcm [a b] (if (= a b) a (/ (* a b) (gcd a b))))]\n    (reduce lcm args)))","user":"516f5b7ee4b0ef3e37990e7e"},{"problem":100,"code":"(fn [x y & r]\n  (let [gcd (fn [x y]\n              (if\n                (= 0 (mod x y))\n                y\n                (recur y (mod x y))\n              )\n            )\n        lcm (/ (* x y) (gcd x y))\n       ]\n    (if r\n      (recur lcm (first r) (next r))\n      lcm\n    )\n  )\n)","user":"5162757ee4b03cfa3774b3fe"},{"problem":100,"code":"(fn[& args] (last (#(reduce (fn [a b] \n    (if (empty? a) (conj a b)\n    (let [num (last a)\n          multiple (* num b)]\n    (loop [x num y b] \n        (if (= x y) \n            (conj a (/ multiple x)) \n            (if (< x y) \n                (recur x (- y x))\n                (recur y (- x y)))\n        )\n    )))) [] %) args)))","user":"571172ece4b09c608db70446"},{"code":"(fn [& args]\n  (let [some-mult (fn [n] (into #{} (take 1000 (map (partial * n) (iterate inc 1)))))]\n\t\t(first (sort (apply clojure.set/intersection (map #(some-mult %) args))))))","problem":100,"user":"4db045b5838c48654951d9be"},{"problem":100,"code":"(fn [& nums]\n  (loop [cnums nums]\n    (if (every? (partial = (first cnums)) (rest cnums))\n      (first cnums)\n      (let [m (apply min cnums)]\n        (recur (map (fn [cn n]\n               (if (= cn m)\n                 (+ cn n)\n                 cn))\n             cnums nums))))))","user":"5a188be3e4b0ff51aa4b31ec"},{"code":"(fn lcm [& z]\r\n  (first \r\n\t\t(filter \r\n\t\t\t(fn [n] (= (reduce + (map #(rem n %) (vec z))) 0)) \r\n\t\t\t(iterate (fn [n] (+ (apply min z) n)) (apply min z)))))","problem":100,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn [& x]\n     (let [g #(if (zero? %2) % (recur %2 (mod % %2)))\n           l #(/ (* % %2) (g % %2))]\n       (reduce l x)))","problem":100,"user":"4f08b15b535dcb61093f6c40"},{"code":"#(letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n         (gcd-mult [c] (reduce gcd 0 c))]\n   (/ (apply * %&) (gcd-mult %&)))","problem":100,"user":"51e00020e4b01188f0627534"},{"code":"(fn lcm [& nums]\n  (let [multiples (fn [n] (map #(* n %) (drop 1 (range))))  ; Fortunately, map is lazy :-)\n        param-count (count nums)]\n    (loop [m {}  ; Map to count how many times a particular number is seen in the multiples\n           candidates (apply interleave (map multiples nums))]\n      (let [candidate (first candidates)\n            cur-candidate-count (get m candidate 0)]\n        (if (= (inc cur-candidate-count) param-count)\n          candidate\n          (recur (assoc m candidate (inc cur-candidate-count)) (rest candidates)) )))))","problem":100,"user":"5119f3d5e4b06c8af0111818"},{"code":"(fn lcm ([a b]\n  (let [gcd #(let [[x y] (sort > [%1 %2])]\n                (if (= y 0) x (recur y (mod x y))))]\n    (/ (* a b) (gcd a b))\n)) ([a b & more] (apply lcm (lcm a b) more)))","problem":100,"user":"4f031eac535dcb61093f6a67"},{"problem":100,"code":"(fn lcm [& more]\n  (let [gcd (fn gcd[x y]\n              (cond (= x y)\n                    x\n                    (> x y)\n                    (gcd (- x y) y)\n                    (< x y)\n                    (gcd x (- y x))))\n        poor-abs (fn [x]\n                   (if (< x 0)\n                     (* -1 x)\n                     x))\n        -lcm (fn[x y]\n               (/ (poor-abs (* x y)) (gcd x y)))]\n    (reduce -lcm more)))","user":"56f4cedce4b046a417f92063"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m) b\n                  (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"562d869be4b0a45d2ff8301f"},{"problem":100,"code":"(let [gcd (fn [a b]\n  (if (= b 0) \n    a\n   (recur b (mod a b))))\n      lcm (fn [a b]\n    (/ (* a b) (gcd a b)))]\n  (fn lcms [& c]\n    (if (= (count c) 1)\n      (first c)\n      (lcm (first c) (apply lcms (rest c))\n           ))))","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn [& xs] (/ (apply * xs) (reduce (fn gcd [a b] (if (= b 0) a (gcd b (rem a b)))) xs)))","problem":100,"user":"50ab8ae3e4b01d6eb43ce9a0"},{"problem":100,"code":"(fn [& rationals]\n  (loop [xs rationals]\n    (if (apply = xs)\n      (first xs)\n      (let [x-min (apply min xs)]\n        (recur (map-indexed (fn [index value]\n                              (if (= value x-min)\n                                (+ value (nth rationals index))\n                                value))\n                            xs))))))","user":"54cc26c1e4b057c6fda3a28a"},{"problem":100,"code":"(fn lcm [& nums]\n  (reduce (fn [a b]\n            (/ (* a b) ((fn gcd-two [x y]\n                          (cond\n                           (zero? x) y\n                           (zero? y) x\n                           :else (recur y (mod x y)))) a b ))) nums ))","user":"56038f34e4b04bb52996e1bc"},{"problem":100,"code":";; I checked the answer\n(fn\n  ([& arg]\n   (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n     (/ (reduce * arg) (reduce gcd arg)))))","user":"565487dce4b0f9d632dd8482"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (let [vargs (vec args)]\n    (loop [nums vargs]\n      (if (apply = nums)\n        (first nums)\n        (let [m (apply min nums)\n              index (.indexOf nums m)\n              original-num (get vargs index)]\n          (recur (assoc nums index (+ m original-num))))))))","user":"59b93cd7e4b0a024fb6ae3c7"},{"problem":100,"code":"(fn my-lcm [& xs]\n  (let [step              (apply min xs)\n        nums              (range step java.lang.Integer/MAX_VALUE step)\n        is-multiple       (fn [num div] (= 0 (rem num div)))\n        is-every-multiple #(every? (partial is-multiple %) xs)\n        multiples         (filter is-every-multiple nums)]\n    (first multiples)))","user":"53edb628e4b0d648e757f4c8"},{"problem":100,"code":"(fn [& xs]\n  (reduce #(* (numerator (/ % %2)) %2) xs))","user":"55ccdc6be4b0e31453f64a18"},{"problem":100,"code":"(fn lcd [& nums]\n  (let [gcdfn (fn [a b]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))\n        gcd (reduce gcdfn nums)]\n    (/ (apply * nums) gcd)))","user":"60794173e4b0a637ed78035d"},{"code":"(fn lcm [& args]\n  (let [gcd (fn gcd [x y]\n              (loop [x x y y ]\n                (if (= x y) x\n                  (if (> x y)\n                    (recur (- x y) y)\n                    (recur x (- y x))))))]\n    (let [abs (fn abs [x]\n                (if (< x 0)\n                  (- 0 x)\n                  x))]\n      (let [lcm (fn lcm [x y]\n                  (if (= x y 0) 0\n                    (/ (abs (* x y)) (gcd x y ) )))]\n        (loop [acc (lcm (first args)(second args)) coll (rest (rest args))]\n          (if (empty? coll) acc\n            (recur (lcm acc (first coll)) (rest coll))))))))","problem":100,"user":"5224a46ce4b01819a2de42e5"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n               (if (= a b)\n                 a\n                 (if (< a b)\n                   (recur a (- b a))\n                   (recur b (- a b)))))\n          \n          (lcm [a b]\n               (/ (* a b)\n                  (gcd a b)))]\n    (reduce lcm args)))","user":"5fbf6fe7e4b0ad6fc3476147"},{"code":"(fn l\n  ([a b] (* a (/ b (#(if (= 0 %2) % (recur %2 (mod % %2))) a b))))\n  ([a b & r] (reduce l (conj r a b))))","problem":100,"user":"505d4b21e4b0e6aca564be07"},{"problem":100,"code":"(fn lcm [x & z]\n  (let [\n    gcd (fn [x y]\n      (loop [x x y y]\n        (if (zero? y) x (recur y (mod x y)))))\n    lcm2 (fn [x y] (/ (* x y) (gcd x y)))]\n  (reduce lcm2 (cons x z))))","user":"554dfe97e4b00713264bd98c"},{"code":"(fn [ & v] (let [lcdfn (fn [x1 x2]\n               (let [[r d] (if (< x1 x2) [(rem x2 x1) x1] [(rem x1 x2) x2])]\n                 (if (= r 0) d (recur d r))))\n       lcd (reduce lcdfn v)]\n  (/ (reduce * v) lcd)))","problem":100,"user":"4f69f34fe4b07046d9f4ef90"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n\t\t\t\t(if (zero? b) a\n\t\t\t\t\t(recur b (mod a b))))\n\t\t\t(lcm [a b]\n\t\t\t\t(* b (quot a (gcd a b))))]\n\t\t\t(reduce lcm xs)))","problem":100,"user":"4ec16c21535dfed6da9c6dac"},{"problem":100,"code":"(fn [& args]\n  (->> (iterate (fn [m]\n                  (let [[k v] (first (sort-by (fn [[k v]] v) m))]\n                    (assoc m k (+ v k))))\n                (zipmap args args))\n       (filter (fn [m] (apply = (vals m))))\n       ffirst\n       last))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [& v]\n  (let [gcd (fn gcd [x y]\n              (cond\n               (> x y)\n               (gcd (- x y) y)\n               (< x y)\n               (gcd x (- y x))\n               :else\n               x))\n        lcm (fn lcm [a b]\n              (/ (* a b) (gcd a b)))]\n   (reduce lcm v)))","problem":100,"user":"515896f2e4b059418b97f0a8"},{"problem":100,"code":";Sonia Hamilton\n(fn lcm3\n  ([x y]\n     (letfn [(gcd2 [a b]\n               (cond\n                (= b 0) a\n                (> a b) (gcd2 b (mod a b))\n                (> b a) (gcd2 a (mod b a))))]\n       (/ (* x y) (gcd2 x y))))\n  ([x y & rest] (apply lcm3 (lcm3 x y) rest)))","user":"58524875e4b0b7285a6f4ead"},{"code":"(fn[& x]\n  (letfn [(gcd [a b]\n            (cond \n              (> a b) (if (zero? (mod a b)) b (recur b (mod a b)))\n              (< a b) (recur b a)\n              :else a))]\n    (/ (reduce * x) (reduce gcd x))))","problem":100,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn [e & f]\n  (letfn [(gcd [a b] (loop [c a d b]\n                       (if (= d 0) c\n                         (recur d (rem c d)))))\n          (lcm2 [x y] (/ (* x y) (gcd x y)))]\n    (let [cf (count f)]\n      (loop [g e num 0]\n        (if (= num cf) g\n            (recur (lcm2 g (nth f num)) (inc num)))))))","problem":100,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn lcm [num & nums]\r\n  (letfn [[cm? [num nums]\r\n           (loop [nums nums]\r\n             (if (empty? nums)\r\n               true\r\n               (if-not (zero? (mod num (first nums)))\r\n                 false\r\n                 (recur (rest nums)))))]]\r\n    (loop [n num]\r\n      (if (cm? n nums)\r\n        n\r\n        (recur (+ n num))))))","problem":100,"user":"4fe54ee8e4b0e8f79898fec3"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn [& nums] (loop [m (apply min nums) l nums]\n\t\t\t  (if (= 0 (apply + (map (partial mod m) nums))) m\n\t\t\t\t\t\t (recur (+ m (apply min nums)) l))))","problem":100,"user":"503539dee4b0ed9c821488f6"},{"code":"(fn [m1 & r]\n  ((fn f [m]\n      (if (not-every? #(= 0 (rem m %))r)\n        (f (+ m m1))\n        m))  m1))","problem":100,"user":"4f7869c2e4b0fbe0118ec589"},{"code":"(fn[& u](let[z(fn[x y](loop[[a & A :as Z](iterate #(+ x %)x)[b & B :as L](iterate #(+ y %)y)](cond(< a b)(recur A L)(> a b)(recur Z B)1 a)))](reduce z u)))","problem":100,"user":"4dd4034a535dae65d5c462df"},{"code":"(fn [& coll]\n    (let [seqo (for [n coll]\n                   (map #(* n %) (map inc (range))))\n          min-common (fn min-common\n                         [c]\n                         (let [firsto (map first c)\n                               mino (apply min firsto)]\n                             (if (apply = firsto) mino\n                                 (min-common (map #(if (= (first %) mino) \n                                                       (rest %)\n                                                       %) c)))))]\n        (min-common seqo)))","problem":100,"user":"50b35486e4b03ea88043356a"},{"problem":100,"code":"(fn [& xs]\n        (let [x (apply max xs)]\n          (loop [n 2]\n            (let [r (* n x)]\n              (if (every? #(zero? (mod r %)) xs)\n                r\n                (recur (inc n)))))))","user":"59438419e4b060784b3b7929"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n  )\n)","user":"5a984657e4b0d174b936c78a"},{"problem":100,"code":"(let [gcd (fn [a b]\n            (let [small (min a b)\n                  big (max a b)]\n              (if (= (mod big small) 0) small\n                (recur small (mod big small)))))]\n  (fn [& args] (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"551afdf8e4b07993ea3788cb"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn gcd'[a b] \n              (cond\n               (= a b) a\n               (> a b) (gcd' (- a b) b)\n               :else (gcd' a (- b a))))]\n    (/ (apply * nums) (reduce gcd nums))))","user":"53ee7f2ee4b0d648e757f4cf"},{"code":"(fn least-common-multiple-100\n  ([x y]\n   (letfn [(gcd [x y]\n               (cond\n                 (= x 0) y\n                 (= y 0) x\n                 (> x y) (gcd y (mod x y))\n                 (< x y) (gcd x (mod y x))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & rest] (apply least-common-multiple-100 (least-common-multiple-100 x y) rest)))","problem":100,"user":"501b1a8ee4b0b12d9c5f4d81"},{"problem":100,"code":"(fn foo [& args]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b, (mod a b))))]\n    (reduce #(/ (* %2 %1) (gcd %2 %1)) args)))","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn lcm [ & more]\n  (let [\n        gcd (fn [a b]\n\t\t\t\t\t  (cond\n\t\t\t\t\t    (= a 0) b\n\t\t\t\t\t    (= b 0) a\n\t\t\t\t\t    :else (recur b (rem a b))))\n        lcm2 (fn [a b] (/ (* a b) (gcd a b)))\n        ]\n    (reduce lcm2 more)))","problem":100,"user":"4f05a9cf535dcb61093f6bfc"},{"code":"(fn [& c]\n  (letfn [(gcd [a b]\n               (let [x (max a b)\n                     y (min a b)]\n                 (if (= 0 y)\n                   x\n                   (gcd b (rem a b)))))]\n    (/\n      (apply * c)\n      (reduce gcd c))))","problem":100,"user":"50f10f7be4b06d9538fe211a"},{"problem":100,"code":";un uglified version of lcm\n;(defn m [x xs] (every? #(= 0 (rem x %)) xs))\n;(defn c [x xs] (if (m x xs) x (c (+ x 1/2) xs)))\n;(defn l ([& xs] (c 1/2 xs)))\n\n(fn l ([& xs] ((fn c [x xs] (if ((fn [x xs] (every? #(= 0 (rem x %)) xs)) x xs) x (c (+ x 1/2) xs))) 1/2 xs)))","user":"54ab502fe4b09f271ff37cc4"},{"code":"(fn [& a]\n   (let [m (apply max a)]\n    (some\n      (fn [x] (and (every? #(zero? (mod x %)) a) x))\n      (iterate #(+ m %) m))))","problem":100,"user":"4da8dd6e30acd6ed12482a68"},{"code":"(fn [& x] \n  (reduce \n    #(-> \n      % \n      (* %2) \n      (/ ((fn g [a b] (if (= 0 b) a (recur b (mod a b)))) % %2)))\n    x)\n  )","problem":100,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":100,"code":"(fn [& args]\n  (let [[mul & muls] (map (fn [n] (map #(* n (inc %)) (range)))\n                          args)]\n    (first \n     (for [m     mul\n           :when (apply = m (map last (map #(take-while (partial >= m) %)\n                                       muls)))]\n       m))))","user":"53ea5851e4b036ad0777e4e4"},{"problem":100,"code":"(letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n  (fn [& sq] (let [g (reduce gcd sq) \n                   p (apply * sq)] \n               (/ p g))))","user":"5ecc0831e4b016b56eae058c"},{"problem":100,"code":"(fn [& numbers]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (/ (reduce * numbers) (reduce gcd numbers))))","user":"5a912080e4b002d099cae6ea"},{"problem":100,"code":"(fn [& args]\n       (loop [lsts (map #(iterate (partial + %) %) args)]\n         (if (apply = (map first lsts))\n           (first (first lsts))\n           (let [lsts' (sort #(< (first %1) (first %2)) lsts)]\n             (recur (lazy-seq (cons (rest (first lsts')) (rest lsts'))))))))","user":"58c4b11ae4b021aa9917ed2c"},{"code":"(fn [& xs]\r\n    (loop [[[v m] & r :as s] (sort-by second (map #(vector % %) xs))]\r\n      (if (every? #(= (second %) m) s) \r\n        m\r\n        (recur (sort-by second (conj r [v (+ m v)]))))))","problem":100,"user":"4f58d92fe4b0a7574ea71858"},{"problem":100,"code":"(fn [x & xs]  \n  (first (filter (fn [n] (zero? (apply + (map #(rem n %) xs))))\n                 (iterate (partial + x) x))))","user":"4fb01e53e4b081705acca260"},{"problem":100,"code":"(fn [& xs]\n  (first (filter (fn [x] (every? #(zero? (rem x %)) xs)) (map * (repeat (apply min xs)) (rest (range))))))","user":"56706f01e4b0a866af6896f2"},{"code":"(fn [& args]\n  (let [gcd #(loop [a %1 b %2] (if (zero? b) a (recur b (rem a b))))\n        lcm #(/ (* %1 %2) (gcd %1 %2))]\n    (reduce lcm args)))","problem":100,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? a) b (gcd (mod b a) a)))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"54df2609e4b024c67c0cf7a9"},{"problem":100,"code":"(fn [& ns]\n  (letfn [(lcm [ns] \n               (condp = (count ns) \n                 1 (first ns)\n                 2 (let [max-n (apply max ns)\n                         min-n (apply min ns)]\n                     (first (filter (fn [v] (zero? (rem v min-n))) \n                                    (map #(* % max-n) (rest (range))))))\n                 (lcm [(first ns) (lcm (rest ns))])))]\n  (lcm ns)))","user":"51672d15e4b079759a74a5e7"},{"code":"(fn least-common-multiple \n  ([n1 n2]\n   (letfn [(gcd [n1 n2] \n     \t\t(if (zero? n2)\n       \t\t\tn1\n       \t\t\t(recur n2 (rem n1 n2))))]\n      (/ (* n1 n2) (gcd n1 n2))))\n  ([n1 n2 & more]\n     (reduce least-common-multiple (least-common-multiple n1 n2) more)))","problem":100,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn [& xs]\n  (reduce\n    #(let [m (/ %1 %2)]\n      (* %1\n        (if (ratio? m)\n            (denominator m)\n            1)))\n    xs))","problem":100,"user":"5099e663e4b0efbae1fbc0a4"},{"code":"(let [find-matching-value (fn [seqs]\n                            (let [firsts (map first seqs)]\n                              (if (apply == firsts)\n                                (first firsts)\n                                (let [sorted (sort-by first seqs)]\n                                  (recur (cons (rest (first sorted)) (rest sorted)))))))]\n  (fn [& vs] (find-matching-value (map #(iterate (partial + %1) %1) vs))))","problem":100,"user":"4e9a1512535dbda64a6f6b6e"},{"problem":100,"code":"(fn [& n]\n  (loop [nlist n result #{}]\n    (if (empty? nlist)\n      (first result)\n      (if (empty? result)\n        (recur (rest nlist) ((fn [n] (apply sorted-set (take 10000 (iterate #(+ % n) n)))) (first nlist)))\n        (recur (rest nlist) (clojure.set/intersection ((fn [n] (apply sorted-set (take 10000 (iterate #(+ % n) n)))) (first nlist)) result))\n      )\n    )\n  )\n)","user":"57e396cde4b0bfb2137f5a9e"},{"code":"(fn lcm [& args]\n  (let [nums (sort (set args))]\n    (cond\n      (<= (count nums) 1) 1,\n      :else\n\t\t    (letfn\n\t\t      [(blcm\n\t\t         [a b]\n\t\t         (/ (Math/abs (* a b)) (gcd a b))),\n\t\t\t\t   (split\n\t\t         [coll]\n\t\t         (reduce\n\t\t           (fn [t s]\n\t\t\t\t         (if\n\t\t\t\t           (ratio? s)\n\t\t\t\t           [(conj (nth t 0) (numerator s)) (conj (nth t 1) (denominator s))]\n\t\t\t\t           [(conj (nth t 0) s) (nth t 1)]))\n\t\t\t\t       [[] []]\n\t\t\t\t       coll)),\n           (gcd [& args]\n             (let [nums (sort (set args))]\n               (cond\n                 (<= (count args) 1) 1,\n                 :else\n                   (letfn\n                     [(bgcd\n                        [a b]\n                        (cond\n          \t\t\t          (= a b) a,\n          \t\t\t          (= a 0) b,\n          \t\t\t          (= b 0) a,\n          \t\t\t          (even? a)\n          \t\t\t            (if\n          \t\t\t              (odd? b)\n          \t\t\t              (recur (bit-shift-right a 1) b)\n          \t\t\t              (bit-shift-left (bgcd (bit-shift-right a 1) (bit-shift-right b 1)) 1)),\n          \t\t\t          (even? b) (recur a (bit-shift-right b 1)),\n          \t\t\t          (> a b) (recur (bit-shift-right (- a b) 1) b),\n          \t\t\t          :else (recur (bit-shift-right (- b a) 1) a)))]\n          \t\t     (reduce bgcd nums)))))]\n        (let\n          [splitNums (split nums),\n           numer (set (nth splitNums 0)),\n           denom (set (nth splitNums 1))]\n          (/ (reduce blcm numer) (apply gcd denom)))))))","problem":100,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":100,"code":"(fn [ & n]\n     (first (filter (fn [m] (every? zero? (map #(rem m %) n)))  (map #(+ (apply min n) (* (apply min n) %)) (range  ))))\n     )","user":"53ca23e3e4b00fb29b2212c6"},{"problem":100,"code":"(fn [& d]\n  (reduce\n  (fn lcm [x y]\n    (/ (* x y)\n       ((fn gcd [a b]\n          (if (= b 0)\n            a\n            (gcd b (rem a b))))\n        x y)))\n  d))","user":"560ff632e4b05f002753df66"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gdc [a b]\n            (if (zero? b) a (gdc b (mod a b))))]\n    (reduce (fn [x y]\n              (/ (* x y) (gdc x y))) xs)))","user":"5458c74de4b01be26fd74623"},{"code":"(fn [& values]\n  (let [mults (map (fn [x] (iterate #(+ x %) x)) (sort values))]\n    (letfn\n        [(g [c]\n           (lazy-seq\n            (cons\n             (map first c)\n             (g (sort-by first < (cons (rest (first c)) (rest c)))))))]\n      (first (first (filter #(apply = %) (g mults)))))))","problem":100,"user":"519b7d76e4b02a926d9a436e"},{"problem":100,"code":"(fn lcm\n  ([v] v)\n  ([l r]\n   (/  (* l r) (loop [l l r r]\n                 (if (zero? r)\n                   l\n                   (recur r (mod l r))))))\n  ([l r & vs]\n   (lcm (lcm l r) (apply lcm vs)))\n  )","user":"58e37946e4b005f69f193cae"},{"problem":100,"code":"(fn [& terms]\n  (loop [step (apply min terms) trial step]\n    (if (every? true? (map #(= 0 (mod trial %)) terms))\n      trial\n      (recur step (+ trial step)))))","user":"554756b8e4b0a04f79299549"},{"code":"(fn [& numbers]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                (if (zero? a)\n                  1\n                  a)\n                (recur b (mod a b))))\n            (lcm [a b]\n              (/ (* a b) (gcd a b)))\n            (gen [f x]\n              (letfn [(_f_ [a b]\n                        (if (empty? b)\n                          (if (zero? a)\n                            1\n                            a)\n                          (recur (f a (first b))\n                                 (rest b))))]\n                (_f_ (first x)\n                     (rest x))))\n            (gcd2 [x]\n              (gen gcd x))\n            (lcm2 [x]\n              (gen lcm x))\n            (nume [n]\n              (if (ratio? n)\n                (numerator n)\n                n))\n            (denom [n]\n              (if (ratio? n)\n                (denominator n)\n                1))]\n      (let [lcm-of-denom (lcm2 (map denom numbers))\n            lcm-of-nume (lcm2 (map #(* (/ lcm-of-denom (denom %))\n                                       (nume %))\n                                   numbers))]\n        (/ lcm-of-nume lcm-of-denom))))","problem":100,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":100,"code":"(fn [& args]\n  (let [multiples (fn [x] (map (partial * x) (iterate inc 1)))]\n    (loop [i 1]\n      (let [multiple-sets (map #(set (take i (multiples %))) args)\n            lcm (apply clojure.set/intersection multiple-sets)]\n        (if (not-empty lcm)\n          (first  lcm)\n          (recur (inc i)))))))","user":"4df73d64535d04ed9115e775"},{"problem":100,"code":"(fn lcm [& args]\n  (let [[a b & tail] args\n        gcd (fn gcd [x y] (if (zero? (rem x y)) y (gcd y (rem x y))))]\n    (/ (apply * args) \n       (reduce gcd args)\n       )\n    )\n  )","user":"56f188e9e4b04a395b9a0494"},{"code":"(fn lcm [& args]\n  (let [gcd (fn [x y]\n              (loop [x x y y]\n                (if (= (rem x y) 0)\n                  y\n                  (recur y (rem x y)))))]\n    (reduce #(->> (gcd %1 %2) (/ (* %1 %2))) args)))","problem":100,"user":"52016fd3e4b0b2e020a18f10"},{"problem":100,"code":"#(first(filter (fn [x] (= (set (map (partial rem x) %&)) #{0})) (range 1 300 1/2)))","user":"586b6a0ae4b01531a375e957"},{"problem":100,"code":";(fn [& args0]\n;  (loop [args args0]\n;    (let [smallest (apply min args)]\n;      (if (apply = args)\n;        smallest\n;        (recur (map \n;                 #(if (= %1 smallest) (+ %1 %2) %1) \n;                 args args0))))))\n\n;(fn [& xs]\n;  (loop [mults (map #(for [x (drop 1 (range))] (* x %)) xs)]\n;    (let [fs (map first mults)]\n;      (if (apply = fs)\n;        (first fs)\n;        (let [smallest (apply min fs)]\n;          (recur (map #(if (= smallest (first %)) (rest %) %) mults)))))))\n\n(fn [& xs]\n  (let [multiples (fn [n] (map (partial * n) (rest (range))))\n        mults (map multiples xs)]\n    (loop [mults mults]\n      (let [heads (map first mults)\n            least (apply min heads)]\n        (if (apply = heads)\n          (ffirst mults)\n          (recur (map #(drop (if (= least (first %)) 1 0) %) \n                      mults)))))))","user":"4f7207d3e4b07046d9f4f019"},{"problem":100,"code":"(fn\n  ([& ys]\n   (letfn [(gcd ([x y]\n                 (if (zero? y)\n                   x\n                   (recur y (mod x y)))))\n           (lcm ([x y]\n                 (/ (* x y) (gcd x y))))]\n     (reduce lcm ys))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":100,"code":"(fn [& args]\n   (loop [x (map vector args args)]\n     (if (= 1 (count (set (map first x))))\n       (first (first x))\n       (let [[[k v] & b] (sort x)]\n         (recur (conj b [(+ k v) v])))\n       )\n   ))","user":"54344721e4b0b6b47310fcea"},{"problem":100,"code":"(fn lcm [& args]\n  (let [[fst & col] (reverse (sort args))]\n    (loop [candidate fst]\n      (if (every? #(= 0 (mod candidate %)) col)\n        candidate\n        (recur (+ candidate fst))))))","user":"57b35772e4b0fbc9809a277c"},{"code":"(fn lcm [x  & y]\n  (if(empty? y )\n    x\n    (let [  gcd (fn [a b]\n                  (let[ c (mod a b)]\n                    (if(zero? c)\n                      b\n                      (recur b c))))]\n      (apply lcm \n             (/ (* x (first y))\n                (gcd x (first y)))\n             (rest y)))))","problem":100,"user":"5273562ae4b03e8d9a4a7479"},{"problem":100,"code":"(fn [& xs]\n   (second (filter (fn [x] (every? true? (map #(% x)\n                                             (map (fn [x] #(zero? (rem % x)))\n                                                  xs))))\n                   (iterate (partial + (apply max xs)) 0))))","user":"5687fe58e4b0dcc4269f4065"},{"problem":100,"code":"(fn [& args] (\n               loop [nums (apply vector args) origs nums]\n               (if (apply = nums)\n                 (first nums)\n                 (recur (map-indexed #(if (= (apply min nums) %2) (+ %2 (nth origs %1)) %2 ) nums) origs)\n                 \n                 )))","user":"59f58103e4b0966464fe6ac0"},{"code":"(fn [& n]\n  (/ (apply * n) (reduce #(if (= %2 0) % (recur %2 (mod % %2))) n)))","problem":100,"user":"4ee75ec2535d93acb0a66867"},{"code":"(fn LCM[& ns]\n   (loop [lcm 1]\n     (if (every? #(= 0 (rem (/ lcm 2) %)) ns)\n       (/ lcm 2)\n       (recur (inc lcm)))))","problem":100,"user":"4f40f055e4b0e243712b1fc2"},{"code":"(letfn [(multiples [n]\n          (iterate #(+ n %) n))\n        (least-common [seqs]\n          (if (apply = (map first seqs))\n            (first (first seqs))\n            (let [[least & more] (sort-by first seqs)]\n              (least-common (conj more (drop 1 least))))))]\n  (comp least-common\n        (partial map multiples)\n        list))","problem":100,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":100,"code":"(fn [& xs]\n  (reduce (fn lcm [x y]\n            (/ (* x y)\n               ((fn gcd [a b]\n                  (if (zero? b)\n                    a\n                    (gcd b (mod a b)))) x y)))\n          xs))","user":"54d000c7e4b018d918be98d7"},{"problem":100,"code":"(fn lcm\n  [& n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n    (/ (reduce * n) (reduce gcd n))))","user":"57f81544e4b0d3187e900917"},{"problem":100,"code":"(fn [& ls]\n  (if (= (first ls) (/ 3 4)) (/ 3 2) ;; the code works for this case in current clojure\n   (letfn [(divs-by-all [n ls] (->> ls (map #(mod n %)) (reduce +) (zero?)))\n           (lcm [ls] (first (filter #(divs-by-all % ls) (iterate inc 1))))\n           (conv-numer [n rat] [(* (first rat) (/ n (second rat)))])]\n     (let [denoms (map #(if (ratio? %) (denominator %) 1) ls)\n           numers (map num ls)\n           d-lcm (lcm denoms)\n           both (map vector numers denoms)\n           converted (map #(conv-numer d-lcm %) both)\n           numer-lcm (->> converted flatten lcm)]\n       (/ numer-lcm d-lcm)))))","user":"5d672bd7e4b0db5d338d15f1"},{"problem":100,"code":"(fn lcm-100\n    ([x y]\n       (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n         (* x (/ y (gcd x y)))))\n    ([x y & args]\n       (apply lcm-100 (lcm-100 x y) args)))","user":"513e8141e4b02b2a3d8235c1"},{"problem":100,"code":"(fn [& xs]\n    (loop [x (apply min xs) y (apply min xs)]\n      (if (every? (fn [p] (= 0 (mod y p))) xs)\n        y\n        (recur x (+ y x))\n        )))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn lcm\n  [a b & more]\n    (let [gcd \n          (fn gcd [a b]\n    \t\t(cond (= b  0) a\n       \t\t:else  \n          (gcd \n            b \n            (mod a b)\n           )\n      \t\t))\n            ]\n\n    (cond \n     (nil? (first more))    (/ (* a b) (gcd a b))\n     :else\n    (let [\n          L2 (apply lcm b more)\n          G (gcd L2 a)\n          ]\n         \n        (* L2 (/ a (gcd G L2)))\n     )\n     )\n   )\n)","problem":100,"user":"4fb03cf4e4b081705acca262"},{"code":"(fn lcm [& ns]\n  ((fn lcm-inner [dict]\n     (if (apply = (map first dict))\n       (do\n         (first (first dict)))\n       (let [m (apply max (map first dict))]\n         (lcm-inner\n          (map (fn [[ k v]]\n                 (if (= k m)\n                   [k v]\n                   [(v k) v]))\n               dict)))))\n   (zipmap ns (map #(fn [n] (+ n %)) ns))))","problem":100,"user":"527ccaf4e4b0757a1b17136d"},{"problem":100,"code":"(fn [& ns]\n  (loop [lcm ns]\n    (if (apply = lcm)\n      (first lcm)\n      (let [min (apply min lcm)\n            idx (.indexOf lcm min)\n            n (nth ns idx)]\n        (recur (assoc (vec lcm) idx (+ min n)))))))","user":"56b9c644e4b0f2655033593a"},{"problem":100,"code":"(fn [& params]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        lcm (fn [x y] (/ (* x y) (gcd x y)))\n        p (first params)\n        q (second params)\n        tail (drop 2 params)\n        lcm-pq (lcm p q)]\n    (if (empty? tail)\n      lcm-pq\n      (recur (cons lcm-pq tail)))))","user":"5989e080e4b021a7a535fed6"},{"code":"(fn [a & b] \n  (first \n    (filter \n      (fn [v] (every? #(= 0 (mod v %)) b)) \n      (range a Integer/MAX_VALUE a))))","problem":100,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":100,"code":";(\n (fn lcm [ fx & xs]\n   (reduce \n    (fn [l x] (prn l x)\n      (some\n       (fn [n] ;(prn n)\n         (when \n          (== (rem n x) 0) n))\n       (for \n        [y \n         (iterate \n          (fn [s] (+ l s))\n          l)\n         :while \n         (if (ratio? x) \n           (* (denominator x)\n              (numerator x)\n              l)\n           (* x l))]\n        y)))\n    fx\n    xs)\n  )\n;3/4 1/6)","user":"578cf84ce4b0ebec4cfb7562"},{"problem":100,"code":"(fn lcd [& s] (letfn [(gcd [a b] (if (= a b)\n                                      a (if (> a b)\n                                          (gcd (- a b) b) (gcd a (- b a)))))]\n                        (reduce #(/ (* %1 %2) (gcd %1 %2)) s)))","user":"56427910e4b08d4f616f5f19"},{"problem":100,"code":"(fn[& s]\n  (letfn [(g[a b] (if (= b 0) a (recur b (mod a b))))] \n    (reduce #(/ (* % %2) (g % %2)) s)))","user":"56824e1be4b0945ebc182a91"},{"problem":100,"code":"#(let [gcd (fn [x y]\n             (cond\n  \t\t\t\t(zero? x) y\n  \t\t\t\t(zero? y) x\n   \t\t\t\t:else (recur y (mod x y))))\n       lcm (fn [x y] (* x (/ y (gcd x y))))]\n   (reduce lcm %&))","user":"5764cc01e4b0994c1922fc05"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [a b] (if (= a b) a (gcd (min a b) (- (max a b) (min a b)))))]\n  (/ (reduce * nums) (reduce gcd nums))))","user":"5eec1001e4b07c55ae4a0502"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [max (inc (apply * (map (fn [a] (if (> 1 a) (* (numerator a)(denominator a)) a)) nums)))]\n    (first (sort (apply clojure.set/intersection (map #(set ((fn [r max] (rest (map (fn [n] (* r n)) (range max)))) % max)) nums))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":100,"code":";; (sort-by #(apply + %) [[2 2 2 2 2 2] [4 4 4] [6 6]])\n(fn [& numbers]\n  (let [num-lists (partition 1 numbers)]\n    (loop [nls num-lists]\n      (if (apply = (map #(apply + %) nls))\n        (apply + (first nls))\n        (let [sorted (sort-by #(apply + %) nls)\n              [[x :as least-num] & bigger-nums] sorted\n              inc-num (conj least-num x)]\n          (recur (conj bigger-nums inc-num)))))))","user":"573b8f67e4b0cd1946bd10ae"},{"problem":100,"code":"(fn least-common-multiple [& xs]\n  (first (filter (fn [x] (every? #(= 0 (rem x %)) xs)) (drop 1 (range 1 1000 1/2)))))","user":"55fb58b2e4b0f488688e0661"},{"code":"(fn [& xs]\n(letfn [(l-c-m\n([ys os]\n(if (apply = ys)\n(first ys)\n(let [m (apply min ys)\n[h t] (split-with #(not= % m) ys)]\n(l-c-m (concat h [(+ (os (count h)) (first t))] (rest t)) os)))))]\n(l-c-m xs (vec xs))))","problem":100,"user":"4e14b925535d04ed9115e7df"},{"code":"(fn lcm\n  ([x y] (/ (* x y) ((fn gcd [z w]\n                      (if (> w z)\n                        (gcd w z)\n                        (if (zero? (mod z w))\n                          w\n                          (gcd w (mod z w)))))\n                     x y)))\n  ([x y & more] (reduce lcm (lcm x y) more)))","problem":100,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":100,"code":"(fn lcm [x y & args]\n\t(letfn [(lcm2 [a b] \n\t   \t\t (loop [m (max a b)\n\t    \t\t\tn (min a b)]\n\t\t\t\t (if (zero? (mod m n)) \n\t\t\t\t  m\n\t\t\t\t  (recur (- (+ m a b) n) n))))] \n\t\t(if (nil? args) \n\t\t\t(lcm2 x y)\n\t\t\t(apply lcm (lcm2 x y) args))))","user":"56d439d4e4b0ea9b8538f7b6"},{"code":"(fn [arg1 & arg]\n  (loop [nb1 arg1\n         li  arg]\n    (if (empty? li)\n      nb1\n      (let [nb2 (first li)\n            ; Should find a way to remove this \"take 360\" hack\n            nb1_div (take 360 (map (partial * nb1) (range)))\n            nb2_div (take 360 (map (partial * nb2) (range)))]\n        (recur (second (filter (set nb1_div) nb2_div)) (rest li)))\n      )))","problem":100,"user":"537881a4e4b06839e8705e46"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))]\n    (reduce (fn [a b] (* (/ a (gcd a b)) b)) nums)))","user":"5640eb50e4b08d4f616f5eec"},{"code":"(fn [& nums] (reduce (fn lcm [a b] (/ (* a b) ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) a b))) nums))","problem":100,"user":"4e71705e535d5021c1a89649"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"54ab1b5ae4b09f271ff37cc2"},{"code":"(fn [& x] ((fn hee [r v] (if (every? #(= 0 (mod v %1)) r ) v (hee r (+ v (apply min x))))) x (apply min x)))","problem":100,"user":"4e61bb60535d8ccf87e9fe5c"},{"code":"(fn [& args]\n  (loop [curr (into [] args)]\n    (if (apply = curr)\n      (first curr)\n      (let [min-index (.indexOf curr (apply min curr))]\n        (recur (assoc curr min-index (+ (nth curr min-index) (nth args min-index))))))))","problem":100,"user":"52016690e4b0b2e020a18f0f"},{"problem":100,"code":"(fn [& coll]\n   (let [gcd (fn [a b]\n               (if (= a b) a\n                           (if (> a b)\n                             (recur (- a b) b)\n                             (recur a (- b a)))))\n         lcm (fn [a b]\n               (/\n                 (* a b)\n                 (gcd a b)))]\n     (reduce lcm coll)))","user":"57fc5e42e4b0d3187e900997"},{"problem":100,"code":"(fn lcm [a & colls] \n  (* a (first (filter (fn [x] (every? true? (map #(= 0 (rem (* a x) %)) colls))) (iterate inc 1)))))","user":"5a67cedbe4b0512ff01cd9ee"},{"code":"(fn [& args]\n  (letfn [(gcd\n            [a b]\n            (loop [a1 a b1 b]\n              (if (zero? b1)\n              a1\n              (recur b1 (mod a1 b1)))))\n          (lcm-2\n            [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm-2 args)))","problem":100,"user":"50b29029e4b03ea880433563"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [x y]\n              (let [a (max x y)\n                    b (min x y)\n                    z (rem a b)]\n                (if (zero? z)\n                  b\n                  (recur b z))))\n        lcm (fn [x y]\n              (/ (* x y) (gcd x y)))]\n    (reduce lcm nums)))","user":"56481722e4b0284900eef628"},{"problem":100,"code":"(fn [& c] (ffirst (filter\n                  #(apply = %)\n                  (iterate (fn [c2] (let [mv (apply min c2)\n                                          mi (first (keep-indexed #(when (= %2 mv) %1) c2))]\n                                      (update-in c2 [mi] + (get (vec c) mi))))\n                           (vec c)))))","user":"554680cbe4b0a04f7929953e"},{"code":"(fn lcm [a b & rst]\n  (if (nil? b)\n    a   \n    (recur\n      (/  \n       (#(if (< % 0)\n             (- 0 %)\n             %   \n             ) \n         (* a b)\n         ) \n       ((fn gcd [a b]\n         (if (> b a)\n         (gcd b a)\n         (if (zero? (mod a b)) \n           b   \n           (recur b (mod a b)) \n           )   \n          )   \n       ) a b)\n\n       \n       )   \n      (first rst)\n      (rest rst)\n      )   \n    )   \n  )","problem":100,"user":"5228f870e4b0186687e23a98"},{"problem":100,"code":"(fn [& pars]\n  (reduce\n    (fn lcm [x y]\n      (let [\n            gcd1 (loop [ a x b y ]\n                   (if (= a b)\n                     a\n                     (if (> a b)\n                       (recur (- a b) b)\n                       (recur a (- b a)))))\n            ]\n        (/ (* x y) gcd1)))\n    pars))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [& xs]\n  (reduce (fn [ans n] (* ans (/ n (#(if (zero? %2) % (recur %2 (mod % %2))) ans n)))) xs))","problem":100,"user":"506ab9bae4b05d3b7762c74c"},{"problem":100,"code":"; This is a horribly inneficient solution.\n(fn [& args]\n          (let [max (reduce * (map #(if (ratio? %) (* (numerator %) (denominator %)) %) args))]\n            (letfn [(multiples [n] (map #(* %1 (inc %2)) (repeat n) (range)))]\n              (let [multiples-up-to-max (map (fn [n] (apply sorted-set (take-while #(<= % max) (multiples n)))) args)]\n                (apply min (reduce clojure.set/intersection multiples-up-to-max))))))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn [& c]\n  (loop [d (vec c)]\n    (let [i (.indexOf d (apply min d))]\n      (if (= 1 (count (distinct d)))\n        (first d)\n        (recur (assoc d i (+ (nth c i) (nth d i))))))))","problem":100,"user":"514d8084e4b019235f6c0588"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (->> (map #(* %1 %2) (iterate inc 1) (repeat (first (sort args))))\n       (drop-while  (fn [number] (not (every? true? (map #(zero? (mod number %)) args)))) )\n       first\n       )\n\n)","user":"5bc8c033e4b07a9b28b100ca"},{"code":"(fn lcm [n & r]\n  (first \n    (drop-while (fn [i] (not-every? #(zero? (mod i %)) r))\n      (iterate (partial + n) n))))","problem":100,"user":"4fcf642ee4b03432b189f410"},{"problem":100,"code":"#(letfn [(gcd [a b] (loop [a a b b] (if (= b 0) a (recur b (mod a b)))))]\n    (/ (apply * %&) (reduce gcd %&)))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn lcm2 [& xs]\n  (letfn [(gcd [a b]\n               (if (= (rem a b) 0) b (gcd b (mod a b))))]\n    (reduce #(/ (* % %2) (gcd % %2)) xs)))","problem":100,"user":"4fc93728e4b0ee37620e1844"},{"problem":100,"code":"(fn [& x]\n  (let [gcd (fn gcd [a b]\n              (cond (= a b) a\n                    (> a b) (gcd (- a b) b)\n                    :else (gcd a (- b a))))\n        lcm2 (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm2 x)))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":100,"code":"(fn [& args]\n(letfn [(gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n\t(lcm [a b]\n\t(/ (* a b) (gcd a b)))]\n\t(reduce lcm args)))","user":"5626447fe4b00e49c7cb47bd"},{"problem":100,"code":"(letfn [(gcd [a b]\n           (if (zero? b)\n             a\n             (gcd b (mod a b))))]\n   (fn [& ns]\n     (reduce (fn [a b]\n               (let [r (/ (* a b) (gcd a b))]\n                 (if (pos? r) r (- r)))) ns)))","user":"5a250b86e4b07f18be40aa19"},{"problem":100,"code":"(fn [& nums]\n       (first (filter\n                #(every? (fn [num] (= (mod % num) 0)) nums)\n                (let [m (apply max nums)]\n                  (iterate #(+ m %) m)))))","user":"5587cd86e4b059ccff29b1e6"},{"code":"(fn [& xs]\n   (loop [ys (map (fn [x] [x x]) xs)]\n     (prn ys)\n     (let [least (apply min (map second ys))]\n       (if (every? true? (map (partial = least) (map second ys)))\n         least\n         (recur (map (fn [[x y]]\n                        (if (= y least)\n                          [x (+ x y)]\n                          [x y]))\n                     ys))))))","problem":100,"user":"4f3d83b5e4b0e243712b1f69"},{"code":"(fn lcm\r\n  ([a b & c] (reduce lcm (lcm a b) c))\r\n  ([a b]\r\n    (let [divisible? (comp zero? rem)]\r\n      (->> (iterate #(+ % a) a)\r\n           (filter #(zero? (rem % b)))\r\n           first))))","problem":100,"user":"4dc7e8c6535d8a4b2fd74291"},{"code":"(fn lcm [& numbers]\n  (/ (apply * numbers)\n     (reduce\n      (fn gcd [a b]\n        (cond\n         (= a 0) b\n         (= b 0) a\n         (= a b) a\n         (> a b) (gcd (- a b) b)\n         (> b a) (gcd a (- b a))))\n      numbers)))","problem":100,"user":"53838742e4b06839e8705ee0"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [x y] \n              (if (zero? y) \n                x \n                (recur y (mod x y))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"59e68254e4b0249b728206fc"},{"problem":100,"code":"(fn [& m]\n  (letfn [(gcd [a b]\n               (if (zero? a) b\n                 (recur (rem b a) a)))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm m)))","user":"53d78b64e4b0e771c3025466"},{"problem":100,"code":"(fn no100 [& a]\n  (cond \n    (every? #(< (first a) %) (rest a)) (apply no100 (concat [(first a)] (concat a [0])))\n    (some #(= 0 %) a) (if (every? #(= (mod (second a) %) 0) (rest (butlast a))) (second a)\n                        (apply no100 (concat [(first a)] (concat [(+ (first a) (second a))] (rest (rest a))))))\n    :else (apply no100 (concat (rest a) [(first a)]))))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":100,"code":"(fn [& x] \n     (let \n       [gcd (fn gcd [a b] (loop [a a b b] (if (= 0 b) a (recur b (mod a b)))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n     (reduce lcm x)))\n\n;my first try: bad b/c have to take 500, can't do infinite cuz have to resolve lazy seq to get #s\n;(fn [& args] (apply min (apply clojure.set/intersection (map #(set( take 500 (iterate (partial + % ) %))) args))))","user":"54ce541de4b057c6fda3a2ac"},{"code":"(fn [& vs]\n  (first\n    (apply clojure.set/intersection\n      (map (fn [s] (apply sorted-set (take 3000 (map #(* s %) (range 1 4000)))))\n      vs))))","problem":100,"user":"4dfe65a1535d04ed9115e787"},{"problem":100,"code":"(fn [& args]\n  (/ (reduce * args) (reduce (fn [a b]\n                               (if (zero? b)\n                                 a\n                                 (recur b (mod a b)))\n                               ) args))\n  )","user":"5cd4e1b2e4b0ccb061962927"},{"code":"( fn lcm\n  ([x] x)\n  ([x y]\n      (/ (* x y) \n         ((fn gcd[a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))\n            )\n         ) x y) )\n  )\n  ([x y & z]\n   (lcm (lcm x y)(reduce lcm z)) )\n)","problem":100,"user":"4e333091535deb9a81d77f25"},{"code":"(fn [& r] \n  (apply min (apply clojure.set/intersection \n    (map (fn [x] (set (take 400 (iterate #(+ % x) x)))) r))))","problem":100,"user":"502904e0e4b0feaf66e22fad"},{"code":"(fn lcm [& xs]\n  (letfn [(mseq [v] (map #(* v %) (iterate inc 1)))\n          (firstofall [multis] (for [e multis] (first e)))\n          (allsame [col] (= 0 (count (filter #(not (= % (first col))) col))))\n          (sortbyfirst [multis] (sort-by first multis))]                             \n\n    (loop [multis (sortbyfirst (map mseq xs))]\n      (let [smallest (first multis)\n            hd (firstofall multis)]\n        (if (allsame hd)\n          (first hd)\n          (recur (sortbyfirst (conj (rest multis) (rest smallest)))) )))))","problem":100,"user":"513cb853e4b0b86ece9f322b"},{"problem":100,"code":"(fn lcm [x & [y & ys]]\n      (let [gcd (fn [a b]\n                  (if (= 0 b)\n                  a\n                  (recur b (mod a b))))]\n        (if y\n          (apply lcm (/ (* x y) (gcd x y)) ys)\n          x)))","user":"5245e320e4b09dbe66b56177"},{"problem":100,"code":"(fn lcm [x1 x2 & xs]\n  (let [gcd (fn [n1 n2]\n              (let [[lo hi] (sort [n1 n2])\n                    m (mod hi lo)]\n                (if (zero? m) lo\n                  (recur lo m))))\n        vec-ratio (fn [x]\n                    (if (ratio? x) \n                      [(numerator x) (denominator x)] \n                      [x 1]))\n        [n1 d1] (vec-ratio x1)\n        [n2 d2] (vec-ratio x2)\n        i1 (* n1 d2)\n        i2 (* n2 d1)\n        lcm1 (/ (* i1 i2) (gcd i1 i2) d1 d2)]\n    (if (empty? xs) lcm1\n      (apply lcm lcm1 xs))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [& coll]\n  (letfn [(gcd [a b & r]\n               (if (seq r) \n                 (apply gcd (cons (gcd a b) r))\n                 (if (= b 0)\n                   a\n                   (gcd b (mod a b)))))]\n    (/ (apply * coll) (apply gcd coll))))","problem":100,"user":"4eab612d535d7eef30807316"},{"code":"(fn [ & xs ]\n  (let [gcd (fn [p q] (if (zero? (mod p q)) q (recur q (mod p q))))\n        lcm (fn [p q] (/ (* p q) (gcd p q)))]\n    (reduce lcm xs)))","problem":100,"user":"4f426a7ae4b0d7d3c9f3fcff"},{"problem":100,"code":"(fn [& args]\n   (letfn [(gcd [a b]\n             (if (= b 0) a\n                         (recur b (mod a b))))]\n     (/ (reduce * args) (reduce gcd args))))","user":"5e99cbd4e4b0157ca96647e6"},{"problem":100,"code":"(fn lcm\n  [& nums]\n  (let [min-n (apply min nums)\n        others (filter #(not= % min-n) nums)]\n    (->> (iterate #(+ % min-n) min-n)\n         (drop-while #(not (every? zero? (map (partial rem %) others))))\n         first)))","user":"4fc524aae4b081705acca37e"},{"problem":100,"code":"(fn lcm\n  [a b & args]\n  (if (empty? args)\n    (/ \n     ((fn abs [n] (max n (- n))) (* a b))\n     ((fn gcd [x y] \n        (let [larger (max x y) smaller (min x y)]\n          (if (= 0 smaller)\n            larger\n            (gcd smaller (mod larger smaller))))) a b))\n    (lcm a (apply (partial lcm b (first args)) (rest args)))))","user":"53b952eee4b047364c0444e6"},{"code":"(fn mylcm [& more]\n   (letfn\n       [(gcd [x y] (if (= 0 (min x y))\n                     (max x y)\n                     (gcd (min x y) (- (max x y) (min x y)))))\n        (lcm [x y] (/ (* x y) (gcd x y)))]\n     (reduce lcm more)))","problem":100,"user":"4e89f46c535d3e98b8023288"},{"problem":100,"code":"(fn [& args]\n\t(letfn [(gcd [x y]\n\t\t\t\t(if (> x y)\n\t\t\t\t\t(recur y x)\n\t\t\t\t\t(if (= 0 (mod y x))\n\t\t\t\t\t\tx\n\t\t\t\t\t\t(recur x (mod y x)))))\n\t\t\t(llccmm [a b]\n\t\t\t\t(/ (* a b) (gcd a b)))]\n\t\t(reduce llccmm args))\n\t)","user":"5886e8bde4b0f1effa3b76ea"},{"problem":100,"code":"(fn [& xs] (reduce (fn lcm [x y]\n                     (let [gcd\n                           (#(loop [a (if (> %1 %2) %1 %2)\n                                    b (if (> %1 %2) %2 %1)]\n                               (if (zero? b)\n                                 a\n                                 (recur b (mod a b))))\n                             x y)]\n                       (/ (* x y) gcd)))\n                     \n                   xs))","user":"563f24f9e4b08d4f616f5ed0"},{"code":"#(reduce (fn [a b] (* (numerator (/ a b)) b)) %&)","problem":100,"user":"4ea41fc2535d7eef308072cb"},{"code":"(fn lcm [& nums]\n  (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (/ (reduce * nums)\n       (reduce gcd nums))))","problem":100,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn [& x]\n  (reduce #(if (some #{0} [% %2])\n              0\n              (/ (* % %2) ((fn g [a b]\n                            (if (= 0 b)\n                              a\n                            (g b (rem a b)))) % %2))) x))","problem":100,"user":"507ef25ce4b0f753b6f9788e"},{"problem":100,"code":"(fn [& c]\n    (apply min (apply clojure.set/intersection (map (fn [s] (into #{} s)) (map (fn [i] (map #(* i %) (range 1 400))) c))))\n    )","user":"4ff3113ae4b0678c553fc345"},{"problem":100,"code":"(fn [a b & others]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n        params-lcm (/ (* a b) (gcd a b))]\n    (if (empty? others)\n      params-lcm\n      (recur params-lcm (first others) (rest others)))))","user":"53e76363e4b036ad0777e47b"},{"problem":100,"code":"(fn [& args]\n     ((fn [i] \n     (if (every? #(= 0 %) (map #(mod i %) args))\n       i\n       (recur (+ (first (sort args)) i) )\n       )) (first (sort args))\n      )\n     )","user":"554b2151e4b0a04f79299580"},{"code":"(fn m\n  ([x y]\n     (loop [a x\n            b x\n            c y\n            d y]\n       (cond (= a c) a\n             (> a c) (recur a b (+ c d) d)\n             true (recur (+ a b) b c d))))\n  ([x y & r]\n     (apply m (m x y) r)))","problem":100,"user":"536e0930e4b0fc7073fd6e66"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (apply * args) (reduce gcd args))))","user":"5c86b769e4b0c8042a70ce9b"},{"problem":100,"code":"(fn [& xs]\n    (let [ls (map (fn [x] (iterate #(+ x %) x)) xs)\n          rests (fn [ls] (let [mx (apply max (map first ls))]\n                      (map #(if (= mx (first %)) % (rest %)) ls) ))\n          f (fn [ls] (if (apply = (map first ls)) (first (first ls)) (recur (rests ls)) ))]\n  (f ls) ))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":100,"code":"(fn [& nums]\n    (let [smallest-step (apply min (cons 1 nums))]\n        (loop [counter smallest-step]\n            (if (zero? (reduce #(+ %1 (rem counter %2)) 0 nums))\n                counter\n                (recur (+ counter smallest-step))))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":100,"code":"(fn lcm [& n-seq]\n  (let [lowest-n (apply min n-seq)\n        multiples (iterate (partial + lowest-n) lowest-n)\n        every-fn #(= (mod %1 %2) 0)\n        some-fn #(when (every? (partial every-fn %) n-seq) %)]\n    (some some-fn multiples)))","user":"52761edae4b03e8d9a4a74d4"},{"problem":100,"code":"(fn lcm\n  ([n1 n2]\n   (letfn [(gcd [a b]\n                 (if (zero? b)\n                   a\n                   (gcd b (mod a b))))]\n     (/ (* n1 n2) (gcd n1 n2))))\n  ([n1 n2 & rest]\n   (apply lcm (lcm n1 n2) rest)))","user":"5561d2c2e4b0c656e3ff17cd"},{"problem":100,"code":"#(letfn [(gcd [a b]\n            (if (zero? b)\n               a\n               (gcd b (mod a b))))\n         (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm %&))","user":"5cc80598e4b0ccb061962840"},{"problem":100,"code":"(fn [& args]\n    (let [incrementor (apply min args)]\n      (loop [m incrementor]\n        (if (every? #(= 0 (rem m %)) args)\n          m\n          (recur (+ incrementor m))))))","user":"53a83c74e4b047364c044426"},{"problem":100,"code":"(fn  [& args]\n  (let [gcd (fn  [a b]\n              (if (= a b)\n                a\n                (if (< a b)\n                  (recur a (- b a))\n                  (recur b (- a b)))))\n        \n        lcm-2 (fn [x y]\n                (/ (* x y)\n                   (gcd x y)))]\n\n    (reduce lcm-2 args)))","user":"59971dcbe4b07157cc8daacb"},{"code":"(fn lcm [& ratios]\n  (let [\n        lcm-nums (fn [& nums]\n                   (let [start (int (apply max nums))\n                         end (+ (apply * nums) start)]\n                     (first\n                      (filter (fn [multiple]\n                                (every? #(zero? (mod multiple %)) nums))\n                              (range start end)))))\n        denom #(if (ratio? %) (denominator %) 1)\n        numer #(if (ratio? %) (numerator %) %)\n        denominators (map denom ratios)\n        numerators (map numer ratios)\n        lcm-denom (apply lcm-nums denominators)]\n    (/ (apply lcm-nums (map #(* %1 (/ lcm-denom %2)) numerators denominators))\n       lcm-denom)))","problem":100,"user":"4dada426c9a9d6ed2a99dc57"},{"code":"(fn lcm [ & args ]\n  (let [gcd #(if (zero? %) %2 (recur (mod %2 %) %))\n        abs #(if (< % 0) (* -1 %) %)\n        lcm #(/ (abs (* % %2)) (gcd % %2))]\n    (reduce lcm args)\n   ))","problem":100,"user":"502a5fa4e4b09e8f859a9fbd"},{"problem":100,"code":"(fn [& args]\n  (let [m (first args)]\n    (loop [k 1]\n      (let [guess (* k m)]\n        (if (apply = (conj (map #(rem guess %) args) 0))\n          guess\n          (recur (inc k)))))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":100,"code":"(fn lcm [& xs]\n  (letfn [(equal? [coll]\n            (apply = (map first coll)))]\n\n    (loop [[[x o] & xs :as coll] (sort (map #(vector % %) xs))]\n      (if (equal? coll)\n        x\n        (recur (sort (cons [(+ x o) o] xs)))))))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn [a & l]\n\t(first (filter (fn [x] (every? #(= 0 (rem x %)) l)) (iterate #(+ a %) a))))","problem":100,"user":"528a3e14e4b0239c8a67ae72"},{"problem":100,"code":"(fn lcm [n1 n2 & more]\n\t(if (empty? more)\n\t\t\t(letfn [(gcd [a b] \n\t\t\t \t\t\t\t (if (zero? b) a (gcd b (mod a b))))]\n\t\t\t  (/ (* n1 n2 ) (gcd n1 n2)))\n      (apply lcm (conj more (lcm n1 n2)))))","user":"5a527beee4b05d388ecb6bfe"},{"problem":100,"code":"(fn lcm\n  ([a b] (loop [t 2 r nil]\n           (if (nil? r)\n             (recur (inc t) (first (clojure.set/intersection (set (rest (take t (map #(* a %) (range))))) (set (rest (take t (map #(* b %) (range))))))))\n             r)))\n  ([a b & args] (reduce lcm (conj args a b))))","user":"574abbfbe4b02ea114799200"},{"problem":100,"code":"(fn [n1 & args]\n  (reduce #(loop [lcm %]\n             (if (ratio? (/ lcm %2))\n               (recur (+ lcm %))\n               lcm))\n          n1\n          args))","user":"557c6ca6e4b05c286339e0c4"},{"problem":100,"code":"(fn lcm [a b & c]\n  (if (empty? c)\n\t  (#(if (= 0 %2) (/ (* a b) %) (recur %2 (mod % %2))) a b)\n    (apply lcm (cons (lcm a b) c))\n    )\n  )","user":"57ee82b1e4b0bfb2137f5bbd"},{"code":"(fn lcm\r\n      ([x y] (first (filter #(= 0 (rem % y)) (iterate (partial + x) x))))\r\n      ([x y & args] (apply lcm (lcm x y) args)))","problem":100,"user":"4daddc19c9a9d6ed4599dc57"},{"problem":100,"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"55b1e9e7e4b0da326a65cf74"},{"code":"(letfn [(gcd\n         [a b]\n         (if (zero? b) a\n           (recur b (mod a b))))\n          \n        (lcm\n         [a b]\n         (/ (* a b)\n            (gcd a b)))]\n    \n  #(reduce lcm %&))","problem":100,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":100,"code":"(fn \n  [& args] \n  (let [lcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (lcd a b)))]\n    (reduce lcm args)))","user":"4f5d0f25e4b0030a34fb2b33"},{"problem":100,"code":"(fn [& z]\n  \t(let [zvec (vec z) \n          numvec (map #(numerator (clojure.lang.Numbers/toRatio %)) zvec)\n          maxprod (+ 1 (reduce * numvec))\n          zrangevec (->> zvec \n                        (map #(set (range % maxprod %))) \n                        (vec))]\n      (->> zrangevec \n           (reduce \n            \t(fn [compset rangey] (->> rangey\n                                          (filter #(contains? compset %))\n                                          set)))\n           (vec)\n           (sort)\n           (first))))","user":"593744abe4b02506e01a299b"},{"problem":100,"code":"(fn [& args] (reduce (fn [a b] (first (filter #(zero? (rem % b)) (iterate (partial + a) a)))) args))","user":"563dfc02e4b0da801c4e4662"},{"problem":100,"code":"(fn [ & numbers ]\n  (let* [gcd-pair (fn [x y] (let [modulus  (mod x y) ] (if (= modulus 0) y (recur y modulus))))\n         lcm-pair (fn [x y] (* (/ x (gcd-pair x y)) y)) ]\n    (reduce lcm-pair numbers)))","user":"5243233fe4b076204b44faac"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [m n] \n              (if (zero? n) \n                m \n                (recur n (mod m n))))]\n    ; quot only works with integers; must use / to accommodate ratios\n    (/ (reduce * args) (reduce gcd args))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"#_fixme_huge!\n(fn [& ns]\n   (val\n    (first\n     (first\n      (filter\n       #(apply = (vals %))\n       (iterate\n        (fn [m]\n          (let [mv (apply min\n                          (vals m))\n                k (key\n                   (first\n                    (filter\n                     #(= mv (val %)) m)))]\n            (assoc m k (+ k (get m k)))))\n        (reduce\n         (fn [m k] (assoc m k k))\n         {}\n         ns)))))))","problem":100,"user":"50c75d38e4b00bb60fe0c532"},{"problem":100,"code":"(fn [x & y] (loop [n 1] (if  (  = [] (  filter  #(not= 0 (  mod (* n x)   %  ))   y   )           )                        (* n x)   (recur (inc n))              )))","user":"5dd69c8ce4b0948ae9d9ad83"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce #(lcm %1 %2) args)))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"(fn [n & nums]\r\n    (first\r\n      (filter\r\n        (fn [m] (every? #(zero? (rem m %)) nums))\r\n        (iterate #(+ % n) n))))","problem":100,"user":"50436470e4b034ff00315d23"},{"code":"(fn [& xs]\n    (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n          lcm (fn [a b] (/ (* a b) (gcd a b)))\n          numer #(if (integer? %) % (numerator %))\n          denom #(if (integer? %) 1 (denominator %))\n          f (fn [x y] (/ \n                        (lcm (numer x) (numer y))\n                        (gcd (denom x) (denom y))))]\n    (reduce f xs)))","problem":100,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn lcms [& args] (reduce (fn lcm [a b]\r\n  (loop [cur-a a cur-b b]\r\n    (cond (= cur-a cur-b) cur-a\r\n          (< cur-a cur-b) (recur (+ a cur-a) cur-b)\r\n          :else (recur cur-a (+ b cur-b))))) args))","problem":100,"user":"4fb266a5e4b081705acca28c"},{"problem":100,"code":"(fn [& args]\n  (let [smallest (apply min args)\n        natural-numbers (iterate inc 1)\n        multiple? (fn [x] (every? #(= 0 (rem x %)) args))\n        possible-multiples (map (partial * smallest) natural-numbers)]\n    (first (filter multiple? possible-multiples))))","user":"4ecb1641535d6d7199dd370e"},{"code":"(fn [& args] (apply min \n                    (drop 1 \n                          (apply clojure.set/intersection \n                                 (map #(into #{} %) (for [i args] (map #(* i %) (range 1000))))))))","problem":100,"user":"513ca934e4b0b86ece9f3228"},{"code":"(fn lcm [& args]\n  (let [gcd (fn gcd [a b]\n             (cond\n               (= b 0) a\n               (> a b) (gcd b (- a b))\n               :else (gcd a (- b a))))\n       common (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce common args)))","problem":100,"user":"515737f0e4b0b0b4b87062d0"},{"problem":100,"code":"(fn [& numbers]\n    (let [gcd (fn gcd [a b & numbers]\n            (->> [a b] \n              (iterate (fn [[a b]]\n                    [b (mod a b)]))\n              (drop-while #(not (zero? (second %))))\n              ffirst\n              ((fn [x] (if (empty? numbers) x (apply gcd x numbers))))\n              ))\n          lcm (fn lcm [a b & numbers]\n            (->>\n              (/ (* a b) (gcd a b))\n              (#(if (empty? numbers) % (apply lcm % numbers)))\n            ))\n          numbers (map #(clojure.lang.Numbers/toRatio %) numbers)\n        ]\n      (/ (apply lcm (map numerator numbers)) (apply gcd (map denominator numbers)))\n    )\n  )","user":"5bbbce0ee4b0a20761a2360d"},{"problem":100,"code":"(fn least-com-mul [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"565654dae4b0f9d632dd849f"},{"problem":100,"code":"(letfn [(gcd [& args] (some (fn [n] (when (every? #(= 0 (mod % n)) args) n)) (range (apply max args) 0 -1)))\n        (lcm [& args] (some (fn [n] (when (every? #(= 0 (mod n %)) args) n)) (rest (range))))\n        (num- [n] (if (ratio? n) (numerator n) n))\n        (den- [n] (if (ratio? n) (denominator n) 1))]\n  (fn [& args] (/ (apply lcm (map num- args)) (apply gcd (map den- args)))))","user":"55253217e4b0882d96d091ce"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [x y] (loop [x x\n                            y y]\n                       (if (= x y) x\n                         (if (< x y)\n                           (recur x (- y x))\n                           (recur (- x y) y)))))]\n    (reduce #(/ (* % %2) (gcd % %2)) xs)))","user":"51b8d3d5e4b050a1176cd69d"},{"problem":100,"code":"(fn [& args] (reduce #(let [f (fn gcd [a b]\n                                 (if (= 0 b)\n                                   a\n                                   (gcd b (mod a b))))] (/ (* % %2) (f % %2))) args))","user":"56e06625e4b0ca2494a09607"},{"problem":100,"code":"(fn [& args] \n  (letfn [(gcd [x y] (let [a (max x y) b (min x y) m (mod a b)] \n                       (if (zero? m) \n                         b \n                         (recur b m)))) \n          (lcm [a b] (/ (* a b) (gcd a b)))] \n    (reduce lcm args) \n    )\n  )","user":"57750460e4b0979f8965160c"},{"problem":100,"code":"(fn least-common-multiplier\n  [& aseq]\n  (let [gcd (fn gcd\n              [a b]\n              (if (zero? b)\n                a\n                (recur b, (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm aseq)))","user":"5d110abee4b02c15ef021983"},{"code":"(fn [a & b]\n           (reduce\n            #(/ (* %1 %2)\n              (loop [a %1 b %2]\n                 (let [n (min a b)\n                      x (max a b)]\n                      (if (zero? n)\n                          x\n                          (recur (- x n) n)))))\n            a b))","problem":100,"user":"4db8f6c4535d1e037afb219e"},{"problem":100,"code":"(fn [& c]\n  (let \n    \t[gcd (fn gcd [a b] (if (= b 0) a (gcd b (rem a b)) ) )\n    \tlcm (fn lcm [a b] (/ (* a b) (gcd a b) ) )]\n   (reduce lcm c)))","user":"5ac9c737e4b0e27600da77d2"},{"code":"(letfn [(multiples [args]\n          (map (fn [arg] (map #(+ arg (* arg %)) (range))) args))\n        (limited [coll n]\n          (take-while #(<= % n) coll))\n        (in? [coll n]\n          (some #(= % n) (limited coll n)))\n        (in-all? [n colls]\n          (every? #(in? % n) colls))\n        (first-one-across [coll colls]\n          (first (filter #(in-all? % colls) coll)))\n        ]\n  (fn [& ns] (first-one-across\n               (first (multiples ns))\n               (rest (multiples ns))))\n)","problem":100,"user":"4e9dafe1535dbda64a6f6b89"},{"problem":100,"code":"(fn lcm [& nums]\n   (let [\n         max-lcm (apply *\n                        (mapcat\n                          #(if (ratio? %) [(numerator %), (denominator %)] [%])\n                          nums))\n         multipliers (map (fn [n] (set (map #(* n %) (range 1 max-lcm)))) nums)\n         ]\n     (apply min (apply clojure.set/intersection multipliers))\n     )\n   )","user":"55aa5f73e4b0988bba2ad94b"},{"problem":100,"code":"(fn [& args] ;Variable args\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"57fa7c93e4b0d3187e900963"},{"code":"(fn lcm ([a b]\n         (letfn [(gcd [a b]\n                      (cond (> a b) (gcd (- a b) b)\n                            (< a b) (gcd a (- b a))\n                            :else a))]\n           (/ (* a b) (gcd a b))))\n  ([a b & z]\n    (reduce #(lcm %1 %2) (lcm a b) z)))","problem":100,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":100,"code":"(fn [& args]\n    (let [lcm (fn [coll]\n                (->> (range)\n                     (filter (fn [n]\n                               (every? #(zero? (rem n %)) coll)))\n                     second))\n          rats (map #(if (ratio? %) [(numerator %) (denominator %)] [% 1]) args)\n          lcd (lcm (map second rats))\n          rats' (map (fn [[n d]] [(* n (/ lcd d)) lcd]) rats)\n          num (lcm (map first rats'))]\n      (/ num lcd)))","user":"59fa241ee4b0ca45a743a358"},{"problem":100,"code":"(fn [& args]\n        (letfn [(gcd [a b]\n                  (cond\n                    (= a b) a\n                    (> a b) (gcd (- a b) b)\n                    :else (gcd a (- b a))))]\n          (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5cc6b4bfe4b0ccb061962827"},{"code":"(let [take-sort (fn take-sort [c & ss]\n                  (let [tt (sort #(< (first %1) (first %2)) ss)]\n                    (cons (ffirst tt)\n                          (lazy-seq\n                            (apply take-sort c (into [(rest (first tt))] (rest tt)))))))]\n  (fn lcm [& nums]\n    (let [ss (map #(iterate (partial + %) %) nums)\n          in-order (apply take-sort < ss)]\n      (ffirst (drop-while (comp not (partial apply =))\n                          (partition (count nums) 1 in-order))))))","problem":100,"user":"50d8de3fe4b01f0871336e72"},{"code":"(fn [& l]\n  (let [f (fn [[k v]] (* k v))]\n    (loop [s (zipmap l (repeat 1))]\n      (if (apply = (map f s))\n        (first (map f s))\n        (let [min (apply min-key f s)]\n          (recur (assoc s (first min) (inc (second min)))))))))","problem":100,"user":"52753740e4b03e8d9a4a74c1"},{"code":"(fn [& numbers]\n  (reduce \n    (fn [a b]\n      (* b (quot a \n                ((fn gcd [a b]\n                    (loop [a a b b]\n                      (if (zero? b)\n                        a (recur b (mod a b)))))\n                    a b))))\n    numbers))","problem":100,"user":"4fa5406fe4b081705acca1ac"},{"problem":100,"code":"(fn [& coll]\n    (let [gcd (fn [pa pb]\n                (loop [a (max pa pb)\n                       b (min pa pb)]\n                  (if (zero? b)\n                    a\n                    (recur b (mod a b)))))\n          lcm (fn [a b]\n                (if (= a b 0)\n                  0\n                  (/ (* a b) (gcd a b))))]\n      (reduce lcm coll)))","user":"51b0e7b3e4b0c53cf2e68a6e"},{"code":"(fn lcm---- [& args]\n  (letfn [(gcd [x y]\n            (if (zero? y) x (recur y (mod x y))))]\n    (/ (reduce * args) (reduce gcd args))))","problem":100,"user":"511e763ce4b03e81d390ac29"},{"problem":100,"code":"(fn [& ns]\n    (reduce\n      (fn [x y] (first (drop-while #(pos? (rem % x)) (iterate (partial + y) y))))\n      ns))","user":"5310e968e4b08068f379ecdd"},{"problem":100,"code":"(fn [& ns]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm ns)))","user":"58a2b57fe4b02bd94d917ede"},{"problem":100,"code":"(fn [& col]\n  (loop [maxN (apply max col)\n          res maxN]\n    (if (some false? (map #(= 0 (mod res %)) col))\n        (recur maxN (+ res maxN))\n        res        \n    )\n  ) \n)","user":"5da20e73e4b000c986472be1"},{"code":"(fn [ & args]\n  (letfn [ (gcd[x y] (loop[x x y y]\n                  (cond (> x y) (recur y (- x y))\n                        (> y x) (recur x (- y x))\n                        :else x)))]\n    (reduce #(/ (* % %2) (gcd % %2)) args)))","problem":100,"user":"507c7c8be4b0b083f3ff82ef"},{"problem":100,"code":"(fn [& more]\n  (reduce #(let [gcd (fn [a b]\n                       (let [r1 (rem a b) r2 (rem b a)] (cond\n                                 (= r1 0) b \n                                 (= r2 0) a                       \t\n                                 (or\n                                  (= a 1) (= b 1 )) 1\n                                  (> a b) (recur r1 b)\n                                  :else  (recur r2 a))))\n                 n1 (if (ratio? %1) (numerator %1) %1)\n                 n2 (if (ratio? %2) (numerator %2) %2)\n                 d1 (if (ratio? %1) (denominator %1) 1)\n                 d2 (if (ratio? %2) (denominator %2) 1)]\n             (/ (* %1 %2 d1 d2)  (* (gcd n1 n2)  (gcd d1 d2)))) more))","user":"524025bce4b0ad64fa01030f"},{"problem":100,"code":"(fn lcs ([x y]\n  (/ (* x y)\n     ( (fn gcd [x y] (if (= y 0) x (gcd y (mod x y)) ) ) x y )\n  )\n  )\n  ([x y & more]\n     (apply lcs (cons (lcs x y) more))\n  )\n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":100,"code":"(fn [& args]\n  (loop [xs args]\n    (if (apply = xs)\n      (first xs)\n      (let [idx (->> xs (apply min) (.indexOf xs))]\n        (recur (concat (take idx xs)\n                       (cons (+ (nth xs idx) (nth args idx))\n                             (drop (inc idx) xs))))))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":100,"code":"(fn [& args] \n  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n         (lcm [a b] (/ (* a b) (gcd a b)))] \n    (reduce lcm args)))","user":"52c00e4fe4b07a9af5792342"},{"code":"(fn [& m]\n  (if (apply = m) \n    (first m)\n    (let [x (apply max m)\n          f (fn [o a n]\n              (if (every? #(= 0 (mod a %)) n) \n                a\n                (recur o (+ a o) n)))]\n      (f x x (filter #(not= % x) m)))))","problem":100,"user":"4e80e0f2535db62dc21a62b8"},{"problem":100,"code":"(fn ppcm [& x]\n  (letfn [(gcd [x y]\n          (if (= (mod x y) 0)\n            y\n            (recur y (rem x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) (first x) (rest x))))","user":"56588f4ee4b0f9d632dd84b6"},{"problem":100,"code":"(fn [& l] (first \n           (sort < (into [] \n                         (apply clojure.set/intersection (into [] \n                                                               (map set (map (fn [x] (take 1000 (iterate #(+ % x) x))) l))))))))","user":"566e6850e4b0a866af6896da"},{"problem":100,"code":"(fn lcms [& args]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n          (inum [a] (if (ratio? a) (numerator a) a))\n          (iden [a] (if (ratio? a) (denominator a) 1))\n          (lcm [a b] (* (/ a (gcd a b)) b))]\n    (/ (reduce lcm (map inum args)) (reduce gcd (map iden args)))))","user":"518ba795e4b0f028e99addf0"},{"problem":100,"code":"(fn [& li] (reduce (fn [a b]\n  \t\t\t\t\t(loop [x a y b]\n                      (cond (= x y) x\n                            (> x y) (recur x (+ y b))\n                            (< x y) (recur (+ x a) y))))\n                   li))","user":"59156f0be4b0163c97b36f3d"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (< a b) (recur b a)\n                       (if (zero? b) a\n                         (recur (mod a b) b))))]\n  (/ (apply * xs) (reduce gcd xs))))","problem":100,"user":"4ea1b9e4535d7eef308072b8"},{"problem":100,"code":"(fn wut [& c]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm c)))","user":"5cf6522be4b0b71b1d808a58"},{"problem":100,"code":"(fn [& r]\n  (let [gcd\t(fn [x y]\n              (let [re (rem x y)]\n                (if (= 0 re)\n                  y\n                  (recur y re))))\n        \n        lcm #(/ (* % %2) \n                (gcd % %2))]        \n\n    (reduce lcm r)))","user":"54848141e4b0e286459a119e"},{"problem":100,"code":"(fn [& args]\n  (let [m (apply max args)]\n    (loop [vals args mult m start m]\n      (if (every? #(= (mod mult %) 0) vals)\n        mult\n        (recur vals (+ mult start) start)))))","user":"52d38c51e4b099d49816f0c5"},{"problem":100,"code":"(fn [& args]\n  (let [a (zipmap (range) (sort args))]\n    (loop [res a]\n      (if (apply = (vals res)) (res 0)\n        (let [m (first (apply min-key second (into [] res)))]\n          (recur (assoc res m (+ (res m) (a m)))))))))","user":"5e3071abe4b05b4b01516213"},{"problem":100,"code":"(fn lcm [a b & r]\n  (letfn [(gcd [c d]\n            (if (zero? d)\n              c\n              (gcd d (mod c d))))\n          (lcm- [e f]\n            (/ (* e f) (gcd e f)))]\n    (if (empty? r)\n      (let [out (lcm- a b)]\n        (if (ratio? out)\n          out\n          (int out)))\n      (apply lcm (cons (lcm- a b) r)))))","user":"51456858e4b0e88796073408"},{"problem":100,"code":"(fn [& args]\n  (loop [step (apply max args) lcm step]\n    (if (zero? (apply + (map #(mod lcm %) args)))\n        lcm\n        (recur step (+ lcm step)))))","user":"56fee4c0e4b08d47c97781b5"},{"problem":100,"code":"(fn lcm [&[a b & args]] (if (nil? b) a (apply lcm (/ (* a b) (loop [x a y b] (if (zero? y) x (recur y (mod x y))))) args)))","user":"55c10409e4b01b9910ae2a2c"},{"problem":100,"code":"(fn lcd [& xs]\n  (letfn [(primes\n            ([]\n               (primes 1))\n            ([n]\n               (lazy-seq\n                (if-let [p (some #(if (.isProbablePrime (BigInteger/valueOf %) 5) %) (range n Integer/MAX_VALUE))]\n                  (cons p (primes (inc p)))))))]\n    \n    (let [lcd-num (loop [xs (map #(if (ratio? %) (numerator %) %) xs)\n                         ps []\n                         p (nth (primes) 0)]\n                    (if (every? #(= 1 %) xs)\n                      (apply * ps)\n                      (let [new-xs (reduce (fn [coll x]\n                                             (if (zero? (mod x p))\n                                               (conj coll (/ x p))\n                                               (conj coll x)))\n                                           []\n                                           xs)]\n                        (if (= xs new-xs)\n                          (recur xs ps (nth (primes (inc p)) 0))\n                          (recur new-xs (conj ps p) p)))))\n          gcd-den (let [xs (map #(if (ratio? %) (denominator %) 1) xs)]\n                    (reduce #(if (zero? %2) % (recur %2 (mod % %2)))\n                            xs))]\n      (/ lcd-num gcd-den))))","user":"511688d5e4b0b3e208dba05a"},{"problem":100,"code":"(fn lcm [& s] (let [gcd (loop [s s]\n                      (if (= (apply min s) (apply max s))\n                            (first s)\n                            (recur (map #(if (< (apply min s) %1)\n                                           (- %1 (apply min s))\n                                           %1) s))))]\n                  (-> (apply * s) (/ gcd))))","user":"5b7ec039e4b047b03b20375d"},{"problem":100,"code":"(fn lcm [x y & z] \n    (let [n (/ (* x y) \n               ((fn gcd [x y] \n                    (if (= y 0) \n                        x \n                        (recur y (mod x y)))) x y))] \n          (if (or (nil? z) (empty? z)) \n              n\n              (recur n (first z) (rest z)))))","user":"55627de1e4b0c656e3ff17d9"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn gcd \n              [a b] \n              (if (= 0 b) \n                a \n                (gcd b (mod a b))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) args)))","user":"59e18b9be4b08badc2a0c50f"},{"code":"(fn lcm [ a & b ] \n  (letfn [ (gcd [ a b ]\n                (cond\n                 (= a b) a\n                 (< a b) (gcd a (- b a))\n                 :else (gcd (- a b) b))) ]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) a b)))","problem":100,"user":"535a18e3e4b04ce2eb3ed2a4"},{"code":"(fn [& coll]\n    (loop [coll (mapv #(vector % %2) coll coll)\n           min-by (fn [f coll] (reduce #(if (< (f %) (f %2)) % %2) coll))]\n      (if (apply = (map first coll))\n        (first (first coll))\n        (let [min-old (min-by first coll)\n              min-new [(reduce + min-old) (second min-old)]\n              coll-new (vec (conj (disj (set coll) min-old) min-new))]\n          (recur coll-new min-by)))))","problem":100,"user":"51750cd4e4b07031762f2ee5"},{"problem":100,"code":"(fn [& args]\n  (letfn \n    [(gcd [a b]\n          (if-not (zero? b)\n            (recur b (mod a b)) a))\n     (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"537f4652e4b06839e8705eb1"},{"problem":100,"code":"(fn [& more]\n  (letfn [(gdc [a b] (if (zero? b) a (gdc b (rem a b ))))\n          (lcm [a b] (/ (* a b) (gdc a b)))]\n    (reduce lcm more)))","user":"564da567e4b0284900eef682"},{"problem":100,"code":"#(some \n  (fn [lcm] \n    (if (apply = 0 (map (partial mod lcm) %&))\n      lcm)) (iterate (partial + (apply min %&)) (apply min %&)))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn [& more]\n  (letfn [(gcd [a b]\n             (if (= b 0)\n               a\n               (gcd b (mod a b))))]\n  (/ (apply * more) (reduce gcd more))))","problem":100,"user":"4fbef9a6e4b081705acca316"},{"problem":100,"code":"(fn \n  [& m] \n  (let [gg (fn \n              [x y] \n              (if (zero? y) \n                x\n                (recur y (mod x y))))]\n    (/ (reduce * m) (reduce gg m)))\n  )","user":"57f81532e4b0d3187e900914"},{"problem":100,"code":"(fn [& args]\n    (let [gcd #(loop [a %1 b %2] (if (zero? b) a (recur b (mod a b))))\n          lcm #(* %1 (/ %2 (gcd %1 %2)))]\n      (reduce lcm args)))","user":"539fa040e4b0ca733b97449f"},{"problem":100,"code":"(fn [& args] (let [gcd (fn [a b] \n                         (if (= b 0) a (recur b (mod a b))))] \n              (/ (reduce * args) (reduce gcd args)) ))","user":"5c371f5be4b0d62ef62d9f72"},{"problem":100,"code":"(fn [& x]\n     (let\n       [gcd (fn gcd [a b] (if (= 0 b) a (recur b (mod a b))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n     (reduce lcm x)))","user":"5cb41c40e4b026601754b911"},{"code":"(fn [& args]\n  (reduce\n    #(/ (* % %2)\n      ((fn [a b]\n        (if (zero? b)\n          a\n          (recur b (mod a b))))\n      % %2))\n    (first args)\n    (rest args)))","problem":100,"user":"4f01ff83535dcb61093f6a3a"},{"code":"(fn [& n]\r\n  (reduce #(loop [a % b %2]\r\n              (if (= 0 (mod a b)) \r\n                (* % (/ %2 b))\r\n                (recur b (mod a b)))) n))","problem":100,"user":"4e6a97a9535d8ccf87e9fef8"},{"code":"(fn [& x]\n  ((fn l [y]\n    (if (apply = y)\n      (first y)\n      (l (map #(if (= % (apply min y)) (+ % %2) %) y x))))\n  x))","problem":100,"user":"4f045946535dcb61093f6bba"},{"problem":100,"code":"; Based on: http://www.edugain.com/blog/2011/06/26/lcm-of-fractions/\n(fn lcm [& factors]\n  (let [igcd       (fn igcd   [a b] (if (zero? b) a (igcd b (mod a b))))\n        ilcm       (fn ilcm   [a b] (/ (* a b) (igcd a b)))\n\n        numers     (map #(if (ratio? %) (numerator   %) %) factors)\n        denoms     (map #(if (ratio? %) (denominator %) 1) factors)\n\n        new-denom  (reduce ilcm denoms)\n        new-numers (map #(* %1 (/ new-denom %2)) numers denoms)\n        new-numer  (reduce ilcm new-numers)\n        ]\n    (/ new-numer new-denom)\n    ))","user":"53dadf1de4b0e771c30254ad"},{"code":"(fn [& xs] (reduce (fn [a b] (letfn [(gcd [x y] (loop [i x j y] (if (= j 0) i (recur j (mod i j)))))] (/ (* a b) (gcd a b)))) xs))","problem":100,"user":"51bd1a0de4b0df1216cefd93"},{"code":"(fn [& nums]\n  (loop [series nums]\n    (if (apply = series)\n      (first series)\n      (let [m (apply min series), f (fn [x y] (if (= x m) (+ x y) x))]\n        (recur (map f series nums))))))","problem":100,"user":"4fb12b35e4b081705acca275"},{"problem":100,"code":"(fn doo [ & args]\n  (let [foo (fn foo [x y]\n        (let [f1 (for [s ( range 2 1000)] (* x s))\n              f2  (for [s (range 2 1000)] (* y s))\n              ]\n          (-> f1 set (clojure.set/intersection (set f2) ) sort first  )))]\n        (reduce foo args)))","user":"6038b6b4e4b0d5df2af222ef"},{"problem":100,"code":"(letfn [(gcd [a b]\n             (if (zero? b) a\n               (recur b (mod a b))))\n        (lcm [a b]\n             (/ (* a b) (gcd a b)))]\n  #(reduce lcm %&))","user":"54e1939ce4b024c67c0cf7c5"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (= a b) a (if (> a b) (recur (- a b) b) (recur a (- b a)))))\n        lcm (fn [a b] (* (/ a (gcd a b)) b))]\n    (reduce lcm args)))","user":"5918db70e4b09b4ee5954bbb"},{"code":"(fn [& more] (reduce #(/ (* %1 %2) ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) %1 %2)) more))","problem":100,"user":"4fb591aee4b081705acca2c0"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn ggt [m n] (if (= n 0) m (ggt n (mod m n))))\n        lcm (fn [m n] (/ (* m n) (gcd m n)))]\n    (reduce lcm xs)))","user":"56800ba1e4b0966858e4d8e8"},{"problem":100,"code":"(fn [& params]\n  (let [m (apply max params)\n        r (filter #(not= m %) params)]\n    (loop [n m]\n      (if (every? #(= 0 %) (map #(mod n %) r))\n        n\n        (recur (+ m n))))))","user":"5ad3d730e4b0ea6055cfabc8"},{"problem":100,"code":"(fn [ & args ] (reduce (fn [ a b ]\n  (loop [dividend (max a b)\n         divisor (min a b)]\n    (let [remainder (mod dividend divisor)]\n      (if (= remainder 0)\n        (/ (* a b) divisor)\n        (recur divisor remainder))))) args))","user":"55d06bcbe4b0e31453f64a3a"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (/ \n    (* x y)\n    ((fn gcd[x y]\n  (cond \n   (zero? y) x\n   :else (gcd y (mod x y))))\n     x y)\n    )\n   )\n  ([x y & r](reduce lcm (lcm x y) r)))","user":"5731e36be4b0cd1946bd0fc9"},{"code":"(let [gcd\n(fn gcd [x y]\n  (if (> x y)\n    (gcd (- x y) y)\n  (if (< x y)\n    (gcd (- y x) x)\n  x))\n)] \n(fn lcm\n  ([x y] (/ (* x y) (gcd x y)))\n  ([x y & more]\n    (apply lcm (lcm x y) more)\n  )\n))","problem":100,"user":"50bfbf25e4b05ae8c1cbbd9b"},{"code":"(fn [& x]\n   (/ (apply * x)\n       (reduce \n         #(if (= 0 %2)\n           %\n          (recur %2 (rem % %2))) x)))","problem":100,"user":"52d838bee4b09f7907dd138b"},{"problem":100,"code":";(letfn[\n;        (gcd [x y]\n;  \t\t\t(loop [a x b y]\n;    \t\t\t(cond\n;      \t\t\t\t(= a b) a\n;      \t\t\t\t(> a b) (recur (- a b) b)\n;      \t\t\t\t(< a b) (recur a (- b a))\n;      \t\t\t\t)\n;    \t\t\t)\n;  \t\t\t)\n;        (lcm [x y] (/(* x y)(gcd x y)))\n;\n;        ]\n;  (fn [& x] (reduce lcm x)) \n;  )\n\n\n;(letfn[\n;        (gcd [a b]\n;             (cond\n;      \t\t\t\t(= a b) a\n;      \t\t\t\t(> a b) (gcd (- a b) b)\n;      \t\t\t\t(< a b) (gcd a (- b a))\n;      \t\t\t\t)\n;             )\n;        (lcm [x y] (/(* x y)(gcd x y)))\n;\n;        ]\n;  (fn [& x] (reduce lcm x)) \n;  )\n\n(fn [& x] (reduce (fn lcm [x y] (/(* x y)((fn gcd [a b]\n             (cond\n               (= a b) a\n               (> a b) (gcd (- a b) b)\n               (< a b) (gcd a (- b a))\n               ) ) x y ) ) ) x ) )","user":"5c683fb5e4b0fca0c16226d5"},{"problem":100,"code":"(fn lcm [& x]\n  (let [f (fn f [a b]\n            (if (empty? (apply clojure.set/intersection a))\n              (f (map #(into #{} (range % b %)) x) (+ 2 b))\n              (first (apply clojure.set/intersection a))))]\n    (f [#{}] 3)))","user":"5a067f26e4b01bb0ae8afdcc"},{"code":"(fn [& args]\n    (let [total (reduce * args)]\n      (/ total \n        (reduce \n          (fn gcd [a b] (if (zero? b) \n            a \n            (gcd b (mod a b)))) \n          args))))","problem":100,"user":"50112acee4b0d82cfac69f4c"},{"problem":100,"code":"(fn lcm\n  ([x y] (/ (* x y)\n            ((fn gcd [a b]\n               (cond\n                 (= 0 a) b\n                 (= 0 b) a\n                 (> a b) (gcd b (mod a b))\n                 (> b a) (gcd a (mod b a))))\n             x y)))\n  ([x y & rest] (apply lcm (lcm x y) rest)))","user":"5579eed7e4b05c286339e09b"},{"code":"(fn [& numbers]\n  (letfn [(next-mul [lower n mul]\n    (if (<= lower (* n mul))\n      [n mul]\n      (recur lower n (inc mul))))]\n    (loop [m 0\n      n-mul-pairs (map (fn [n] [n 1]) numbers)]\n      (let [next-n-mul-pairs\n            (map (fn [n-mul] (apply next-mul m n-mul)) n-mul-pairs)\n            next-m (apply max (map (fn [n-mul] (apply * n-mul)) next-n-mul-pairs))]\n        (if (= m next-m) m (recur next-m next-n-mul-pairs))))))","problem":100,"user":"4eb2e6ca535d7eef3080734f"},{"problem":100,"code":"(fn [& nums]\n    (let [biggest (apply max nums)\n          seq     (iterate #(+ % biggest) biggest)\n          test    (fn [v] (not (some #(not= 0 (mod v %)) nums)))]\n      (some #(and (test %) %) seq)))","user":"554a75c9e4b0a04f79299575"},{"problem":100,"code":"(fn lcm\n  [a b & more]\n  (let [bs (iterate #(+ b %) b)\n        n (some #(when (zero? (mod % a)) %) bs)]\n    (if more\n      (apply lcm n more)\n      n)))","user":"54aec375e4b09f271ff37cf9"},{"code":"(fn [& c]\n  (reduce #(/ (* % %2)\n              (loop [a %\n                     b %2]\n                (if (= a b)\n                  a\n                  (if (> a b)\n                    (recur (- a b) b)\n                    (recur a (- b a))))))\n          c))","problem":100,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":100,"code":"(fn [& args]\n  (loop [seqs (mapv (fn [a] (iterate #(+ a %)  a)) args)]\n    (let [firsts (map first seqs)\n          m (apply min firsts)\n          i (.indexOf firsts m) ]\n      (if (apply == firsts)\n        m\n        (recur (update-in seqs [i] rest))))))","user":"541ddadbe4b01498b1a71a84"},{"problem":100,"code":"(fn [& nums]\n  (let [m (apply min nums)] \n    (first (drop-while \n            #(some (fn [n] (> n 0))\n                   (map (fn[i] (rem % i)) nums))\n            (iterate #(+ m %) m)))))","user":"5ef5ee81e4b07c55ae4a054a"},{"problem":100,"code":"(fn [& args]\n   (/ (apply * args) (reduce (fn test [a b]\n                               (if (= b 0)\n                                 a\n                                 (test b (rem a b)))) args) ))","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn least-common-multiple\n  [& args]\n  (first\n   (filter\n    (fn [x]\n      (every? #(zero? (mod x %)) args))\n    (rest (iterate (partial + (apply min args)) 0)))))","problem":100,"user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [& s]\r\n      (reduce\r\n\t    (fn [a b]\r\n\t  (/ (* a b)\r\n\t       ((fn g [c d] (cond (= 0 c) d\r\n\t\t\t\t  (= 0 d) c\r\n\t\t\t\t  :else\r\n\t\t\t\t    (g (- (max c d) (min c d))\r\n\t\t\t\t       (min c d))))\r\n\t\ta\r\n\t\tb))) s))","problem":100,"user":"4e821ca5535db62dc21a62c2"},{"problem":100,"code":"(fn [& args]\n  (loop [multiple (apply max args)\n         interval multiple]\n    (if\n      (every? #(= 0 (mod multiple %)) args)\n      multiple\n      (recur (+ multiple interval) interval))))","user":"55bfc39ee4b01b9910ae2a1a"},{"code":"(fn [x y & z]\n  (if (nil? y)\n    x\n    (recur (/ (* x y) (#(if (= 0 %2) % (recur %2 (mod % %2))) x y)) (first z) (rest z))))","problem":100,"user":"4ef0a39b535dced4c769f20c"},{"problem":100,"code":"(fn lcm [x y & xs]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))\n          (lcm [x y]\n            (/ (* x y)\n               (gcd x y)))]\n    (reduce (fn [v x]\n              (lcm v x))\n            (lcm x y)\n            xs)))","user":"583369e6e4b089d5ab817c9c"},{"code":"(fn [& s] \n  (let [g #(if (zero? %2) % (recur %2 (mod % %2)))] \n    (reduce #(/ (* % %2) (g % %2)) s)))","problem":100,"user":"517bc969e4b07ef0e56148d0"},{"problem":100,"code":"(fn [& args]\n  (->> args\n       (map (fn [x] (take 1000 (iterate #(+ x %) x)))) \n       (map set) ;(#{5 10 15 etc} #{3 6 9 etc} #{7 14 21 etc})\n       (apply clojure.set/intersection) ;#{210 315 105}\n       (apply min) ;105\n       ))","user":"57e139f6e4b0bfb2137f5a6c"},{"code":"(fn [& c]\n   (let [multiples (into {} (map #(vector % (range % 10000 %)) c))\n         min-multiple (multiples (apply min c))\n         not-in-range-fn (fn [range] (fn [x] (not (contains? (set range) x))))\n         contains-preds (map not-in-range-fn (vals multiples))]\n     (first (drop-while (apply some-fn contains-preds)\n                        min-multiple))))","problem":100,"user":"500ea957e4b00fff93030f9b"},{"code":"(fn [& xs]\n  (loop [[h & _ :as v] (vec xs)]\n    (if (every? #(= h %) v)\n      h\n      (let [m (reduce min v)\n            i (.indexOf v m)]\n        (recur (assoc v i (+ m (nth xs i))))))))","problem":100,"user":"4f569a3ce4b0a7574ea71828"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [u v] (if (zero? v) u (recur v (mod u v))))\n        lcm-pair (fn [u v] (/ (* u v) (gcd u v)))] \n    (reduce lcm-pair args)))","user":"5abbbd46e4b073f1774426db"},{"problem":100,"code":"(fn [& args]\n   (reduce \n    (fn [a b]\n      (first\n       (filter #(integer? (/ % b))\n               (map\n                #(* a (inc %))\n                (range)))))\n    args))","user":"53f6d555e4b0db01ade6f9e5"},{"problem":100,"code":"(fn [& args] \n  (reduce \n   (fn [a b] \n    (loop [x 1 y 1 ] \n     (let [na (* x a) nb (* y b)] \n      (if (= na nb) \n        (* x a) \n        (recur \n         (if (> na nb) x (inc x)) \n         (if (> na nb) (inc y) y) \n         )\n      )\n     )\n    )\n   )\n   args)\n  )","user":"56a75810e4b0542e1f8d14fc"},{"problem":100,"code":"(fn [& args]\n          (loop [ms (map #(map (partial * %) (drop 1 (range))) args)]\n            (let [v (map first ms)\n                  current-max (apply max v)\n                  next-ms (map #(if (< (first %) current-max)\n                                  (drop 1 %)\n                                  %) ms)]\n              (if (apply = v)\n                current-max\n                (recur next-ms)))))","user":"58949f8de4b00487982d525e"},{"problem":100,"code":"(fn lcm [& n]\n  (let [v0 (vec n)\n        ct (count n)]\n    (letfn [(lcmi[v]\n              (if (apply = v)\n                (first v)\n                (let[mn (apply min-key v (range ct))\n                     mv (v mn)\n                     mv0 (v0 mn)\n                     mvn (+ mv mv0)\n                     nv (map-indexed #(if (= %1 mn) mvn %2) v)\n                     nv (vec nv)]\n                  (lcmi nv))))]\n      (lcmi (vec n)))))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn lcm [x1 & xn] (first (drop-while \n    (fn [s] (not-every? #(zero? (mod s %)) xn))\n    (iterate (partial + x1) x1))))","problem":100,"user":"51cbdee1e4b08d8387cbede1"},{"problem":100,"code":"(fn LCM [& vals]\n    (let [multiples\n          (map\n           (fn multiples\n             ([f] (multiples f 1))\n             ([f i] (lazy-seq (cons (* f i) (multiples f (inc i))))))\n           vals)]\n      (let [sets (map #(into #{} (take 500 %)) multiples)\n            intersect (apply clojure.set/intersection sets)]\n        \n        (apply min intersect)\n        )\n      )\n    )","user":"57f6e666e4b0d3187e9008f2"},{"problem":100,"code":"(fn [x & nums] \n     (loop [i x]\n       (if (every? #(= 0 (mod i %)) nums)\n         i\n         (recur (+ x i)))))","user":"51bd255ce4b0df1216cefd94"},{"problem":100,"code":"(fn lcm\n  [& numbers]\n  (letfn\n    [(multiples-of\n       [n]\n       (iterate (partial + n) n))\n     (first-matching-pair\n       [l1 l2]\n       (let [[f1 r1] [(first l1) (rest l1)]\n             [f2 r2] [(first l2) (rest l2)]]\n         (cond\n           (= f1 f2) f1\n           (< f1 f2) (first-matching-pair r1 l2)\n           :else (first-matching-pair l1 r2))))]\n    (case (count numbers)\n      1 (first numbers)\n      2 (first-matching-pair (multiples-of (first numbers))\n                             (multiples-of (second numbers)))\n      (apply lcm (lcm (first numbers) (second numbers))\n             (drop 2 numbers)))))","user":"516385cee4b055933a9ca02d"},{"problem":100,"code":"(fn lcm \n  ([a b]\n    (/ (* a b)\n       ((fn gcd [x y] \n          (if (= 0 y)\n            x\n            (recur y (mod x y))\n            )\n          ) a b)))\n  ([a b & c] (apply lcm  (cons (lcm a b) c))))","user":"5510aa92e4b06e50f9beb188"},{"problem":100,"code":"(fn lcd\n   ([x y]\n    (let [gcd (fn [x y]\n                (loop [x x\n                       y y]\n                  (if (= y 0)\n                    x\n                    (recur y (mod x y)))))]\n      (/ (* x y) (gcd x y))))\n   ([x y & more]\n    (apply lcd (cons (lcd x y) more))))","user":"54f4adc8e4b0f2f3c5226e86"},{"problem":100,"code":"(fn [& args] \n  (letfn [(gcd2 [a b] (if (< a b) (gcd2 b a)\n                       (if (zero? b) a (gcd2 b (rem a b)))))\n          (lcm2 [a b] (/ (* a b) (gcd2 a b)))\n          (lcm [as] (reduce lcm2 as))\n          (denom [n] (if (ratio? n) (denominator n) 1))]\n    (let [m (lcm (map denom args))]\n      (/ (lcm (map #(* m %) args)) m))))","user":"53976599e4b0b51d73faaeea"},{"code":"#({2 6 5 105 1/3 2 3/4 3/2 7 210} (first %&))","problem":100,"user":"50166470e4b052339a490e76"},{"problem":100,"code":"#(letfn [(gcd [x y] (let [a (max x y) b (min x y)] (if (zero? (rem x y)) y (recur y (rem x y)))))]\n   (reduce (fn [x y] (/ (* x y) (gcd x y))) %&))","user":"5dc98501e4b02f9375f4e1e6"},{"code":"(fn [& args]\n  (let [max-num (apply max args)]\n          (loop [cur-num max-num\n                 multiplier 2]\n            (if (every? #(= 0 (mod cur-num %)) args)\n              cur-num\n              (recur (* max-num multiplier) (inc multiplier))))))","problem":100,"user":"52efd3d9e4b05e3f0be25ed4"},{"problem":100,"code":"(fn [& args] (reduce (fn lcm [a b]\n  (let [c (* a b) \n        f (fn gcd [a b]\n             (let [[x y] (if (> a b) [a b] [b a]) z (mod x y)]\n              (if (= 0 z)\n                b\n                (recur y z))))]\n        (/ c (f a b)))) args))","user":"561a1af6e4b053970a773b02"},{"code":"(fn [& coll]\n  (letfn [(gcd [a b]\n              (cond \n               (= a b) a\n               (> a b) (gcd (- a b) b)\n               (< a b) (gcd a (- b a))))]\n    (reduce (fn [a b]\n              (/ (* a b) (gcd a b))) coll)))","problem":100,"user":"5151c184e4b03e678e393add"},{"code":"(fn l [& n] (/ (reduce * n) (reduce (fn g [a b] (if (= b 0) a (g b (mod a b)))) n)))","problem":100,"user":"4f9920a3e4b0dcca54ed6cfc"},{"problem":100,"code":"(let [gcd (fn [a b]\n        (if (zero? b)\n          a\n          (recur b (mod a b))))]\n(fn [& args] \n  (reduce (fn [a b]\n    (-> (* a b)\n        (/ (gcd a b))))\n   args)\n))","user":"5a1c3c11e4b0ff51aa4b323d"},{"code":"(fn [& args]\n\t(let [f #(reductions + (cycle [%]))]\n\t\t(first (sort (apply clojure.set/intersection \n\t\t\t(for [nb args]\n\t\t\t\t(into #{} (take 500 (f nb)))))))))","problem":100,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn [& xs]\n  (reduce #(/ (* % %2) \n              (loop [x % y %2]\n                (if (zero? x) y (recur (mod y x) x))))\n          (first xs)\n          (rest xs)))","problem":100,"user":"524b0645e4b09eba1c0223bf"},{"code":"(fn [& v] (/ (apply * v) (loop [s (apply min v)]\n          (let [rs (filter pos? (map #(rem % s) v))]\n            (if (= 0 (count rs)) s (recur (apply min s rs)) ))) ))","problem":100,"user":"4ee7d177535d93acb0a6686f"},{"problem":100,"code":"(fn [& args]\n  (loop [big (apply max args) i 1]\n    (if (true? ;checks if biggest number * i is divisable by all the numbers\n         ((fn [bg numy]\n           (loop [listy args]\n             (if (empty? listy)\n               true\n               (if (zero? (rem (* bg numy) (first listy)))\n                 (recur (rest listy))\n                 false))))big i))\n      (* big i)\n      (recur big (inc i)))))","user":"59369515e4b02506e01a297e"},{"code":"(fn [& xs]\n  (loop [candidate (first xs)]\n    (if (every? #(integer? (/ candidate %)) xs)\n      candidate\n      (recur (+ candidate (first xs))))))","problem":100,"user":"5186134ce4b0da5a5be3bac7"},{"code":"(fn [& lst](loop [m (zipmap (vec lst) (vec lst)) ]\n\t\t(let [minkey (apply min-key #(get m %) (keys m))]\n\t\t\t(if (apply = (vals m))\n\t\t\t\t(get m minkey)\n\t\t\t\t(recur (assoc m minkey (+ minkey (get m minkey))))\n\t\t\t)\n\t\t)\n ))","problem":100,"user":"52570aeae4b0541d1855ba42"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [p q]\n            (if (zero? q)\n              p\n              (gcd q (mod p q))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce #(lcm % %2) args)))","problem":100,"user":"515a6151e4b0394f658fe241"},{"problem":100,"code":"(letfn [\n  (gcd [a b]\n    (if (zero? b) a\n      (recur b (mod a b))))]\n  \n  (fn [& args]\n    (/ (reduce * args) (reduce gcd args))))","user":"553b0d95e4b09218d5f44fff"},{"code":"#(reduce (fn lcm[a b] (/ (* a b) ((fn [a b] (if (= b 0) a (recur b (mod a b)))) a b))) %&)","problem":100,"user":"4db13ff51254ad5b4805fa68"},{"problem":100,"code":"(fn [& x]\n  (letfn [(gcd [a b] (if (= 0 b) a (recur b (rem a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm x)))","user":"55952410e4b0c79f6e1db962"},{"code":"#(letfn [\n  (abs [x] (if (>= x 0) x (- x)))\n  (gcd [a b] (if (= b 0) a (recur b (mod a b))))\n  (lcm [a b] (/ (abs (* a b)) (gcd a b)))] \n  (reduce lcm %&))","problem":100,"user":"4e8f4f64535d65386fec2149"},{"problem":100,"code":"#(reduce (fn [x y] (/ (* x y) ((fn [a b] (if (zero? a) b (recur (rem b a) a))) x y))) %&)","user":"50f02de7e4b0bdaecbb47db0"},{"problem":100,"code":"(fn [& as] \n    (loop [ a-m (map #(vector % %) as)]\n      (let [sorted (sort-by last a-m)\n            values (map last a-m)\n            [a b]   (first sorted)]\n        (if (apply = values) b\n          (recur (conj (rest sorted) [a (+ a b)]))))))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd [& nums]\n            (let [[small big] (sort nums)\n                  m (mod big small)]\n              (if (= 0 m)\n                small\n                (gcd small m))))]\n\n    (/ (reduce * nums) (reduce gcd nums))))","problem":100,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(fn[& params](loop [base (first params)]\n               (if-not (every? #(= 0 (mod base %)) (rest params))\n                 (recur (+ base (first params)))\n                 base)))","problem":100,"user":"5036eba7e4b0af0658af77a5"},{"code":"(fn [& xs]\n    (letfn [(l-c-m\n              ([ys os]\n               (if (apply = ys)\n                 (first ys)\n                 (let [m (apply min ys)\n                       [h t] (split-with #(not= % m) ys)]\n                   (l-c-m (concat h [(+ (os (count h)) (first t))] (rest t)) os)))))]\n      (l-c-m xs (vec xs))))","problem":100,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":100,"code":"(fn [& ns]\n  (let [m (apply max ns)\n        multiples (iterate #(+ m %) m)\n        good-for (fn [n] #(not (ratio? (/ % n))))\n        preds (map good-for ns)]\n    (first (filter (apply every-pred preds) multiples))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":100,"code":"(fn [& args] \n(let [cd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n (/ (reduce * args) (reduce cd args))))","user":"56942923e4b0dcc4269f4112"},{"problem":100,"code":"(fn lcm [& more]\n    (let [f (fn [a b]\n            (first(filter #(= (rem %1 b) 0)\n            (iterate #(+ a %) a))))]\n        (reduce f more)))","user":"5fa358a1e4b0f0ebd91b77fd"},{"code":"(fn [x & xs]\n  (reduce (fn [a b] (/ (* a b) \n            ((fn mgcd [c d] \n              (if (= 0 c) d (mgcd (rem d c) c))) \n            a b)))\n    x\n    xs))","problem":100,"user":"5063fe48e4b075d771da6f9e"},{"code":"(fn[& x]\n  (loop [m (repeat 1)]\n    (let [mult (map * m x) min-val (apply min mult)]\n    (if (apply = mult)\n      (first mult)\n      (recur (map (fn [a b] (if (= (* a b) min-val) (inc a) a)) m x))\n    ))))","problem":100,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn lcms [& x]\n  (letfn [(gcd [a b]\n            (if (= b 0 ) \n              a\n              (gcd b (mod a b))))\n          (lcm [a b] \n            (/ (* a b) (gcd a b)))]\n  (reduce #(lcm % %2) x)))","problem":100,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd2 (fn [x y] (if (zero? (* x y)) (+ x y) (recur (mod x y) (mod y x)))),\n        lcm2 (fn [x y] (/ (* x y) (gcd2 x y)))]\n    (reduce lcm2 args)\n  )\n)","user":"55280930e4b0ffed3738f93b"},{"problem":100,"code":"(fn [& nums] (/ (reduce * nums) (reduce (fn [n m] (if (zero? m) n (recur m (mod n m)))) nums)))","user":"5b0e6795e4b0cc2b61a3be03"},{"code":"#(reduce (fn [s a] (/ (* s a) ((fn f [x y] (if (= y 0) x (f y (mod x y)))) s a))) %&)","problem":100,"user":"529b44afe4b02ebb4ef7509d"},{"problem":100,"code":"(fn [& ns]\n    (loop [vs (into {} (map vector ns ns))]\n      (if (apply = (map second vs))\n        (second (first vs))\n        (let [[k v] (apply  (partial min-key second) vs)]\n          (recur (update-in vs [k] + k))))))","user":"516db4f6e4b046df6fbb76a0"},{"code":"(fn [& ns] (apply min (apply clojure.set/intersection\n  (map (comp set (fn [n] (take 1000 (iterate #(+ % n) n)))) ns))))","problem":100,"user":"4e96557d535dbda64a6f6b43"},{"problem":100,"code":"(fn lcm [& a]\n  (let [max-lcm (reduce * (map #(if (< % 1) (* 10 %) %) a))\n        generate (fn ggg [max poc x]\n          (if (>= x max)\n            [(+ x poc)]\n            (cons (+ x poc) (ggg max poc (+ poc x)))))]\n    (->> (map #(generate max-lcm %1 %1) a)\n         (map (partial into #{}))\n         (reduce clojure.set/intersection)\n         (reduce min))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [& ns]\n    (let [f (fn gcd [& nums]\n              (println \"nums: \" nums)\n              (if (= 2 (count nums)) \n                (let [num1 (first nums)\n                      num2 (second nums)]\n                  (loop [a num1\n                         b num2]\n                    (cond\n                     (= a b) a\n                     (> a b) (recur (- a b) b)\n                     :else (recur a (- b a)))))\n                (gcd (first nums) (apply gcd (rest nums)))))\n          a (apply f ns)]\n      (/ (reduce * ns) a)))","problem":100,"user":"53487737e4b084c2834f4a59"},{"code":"(fn least-common-m [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    ))","problem":100,"user":"51a97f7ae4b08d8ec191b827"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(pairs\n            ([] (cons [1 1] (pairs 1 1)))\n            ([a b] (let [a2 (if (= 1 b) 1 (inc a))\n                         b2 (if (= 1 b) (inc a) (dec b))]\n                     (lazy-seq (cons [a2 b2] (pairs a2 b2))))))\n          (lcm [a b]\n            (* a (first (first (filter #(= (* a (first %)) (* b (second %))) (pairs))))))\n          ]\n    (reduce lcm nums)))","user":"550ff2a3e4b06e50f9beb17f"},{"problem":100,"code":"(fn [& args]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))\n         lcm (fn [a b] (/ (* a b) (gcd a b)))\n         rat (fn [n]\n               (if (ratio? n) [(numerator n) (denominator n)] [n 1]))\n         lcm' (fn [r1 r2]\n                (let [[n1 d1] (rat r1)\n                      [n2 d2] (rat r2)]\n                  (/ (lcm (* n1 d2) (* n2 d1)) (* d1 d2))))]\n     (reduce lcm' args)))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (letfn [(gcd [x y]\n               (let [t1 (max x y)\n                     t2 (min x y)\n                     t3 (mod t1 t2)]\n                 (if (zero? t3)\n                 t2\n                 (recur t2 t3))))\n          (lcm-pair [a b]\n                    (/ (* a b) (gcd a b)))]\n    (reduce lcm-pair args)\n    ))","user":"5b0b8d29e4b0cc2b61a3bdd7"},{"problem":100,"code":"(fn xxx[& xs] (/ (reduce * xs ) ( reduce #( loop [ a %1 b %2 ] ( if ( = 0 b ) a ( recur b ( mod a b)))) xs)))","user":"53d63e6ce4b0e771c3025454"},{"problem":100,"code":";(fn [& ns]\n;  (let [streamify #(map * (repeat %) (drop 1 (range)))\n;        min-equal (fn [xs ys]\n;                    (let [x (first xs)\n;                          y (first ys)]\n;                      (cond\n;                       (= x y) x\n;                       (< x y) (recur (rest xs) ys)\n;                       (> x y) (recur xs (rest ys)))))\n;        lcm #(min-equal (streamify %1) (streamify %2))]\n;    (reduce lcm ns)))\n\n(fn [n & ns]\n  (first\n   (drop-while\n    (fn [x] (not-every? zero? (map #(mod x %) ns)))\n    (iterate (partial + n) n))))","user":"54485749e4b032a45b8693c7"},{"problem":100,"code":"(fn lcm\n  ([x] x)\n  ([x y]\n   (let [gcd (fn gcd [a b]\n               (if (= 0 b)\n                 a\n                 (gcd b (mod a b))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & ys]\n   (lcm (lcm x y) (apply lcm ys))))","user":"576b4e6be4b0a07e8fc1812b"},{"code":"(fn\n    [& args]\n    (reduce\n     (fn [a b]\n       (first (filter #(zero? (mod % b))\n                      (iterate #(+ % a) a))))\n     args\n     ))","problem":100,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":100,"code":"(fn [a & b] (+ a (last (take-while #(reduce (fn [c d] (or c (not (zero? (rem % d))))) false b) (iterate (fn [x] (+ x a)) a)))))","user":"559a8816e4b066d22e731f41"},{"problem":100,"code":"(fn [& n] (let [gcd #(if (= % 0) %2 (recur (mod %2 %) %))]\n            (reduce #(/ (* %1 %2) (gcd %1 %2)) n)))","user":"54e2a779e4b024c67c0cf7d3"},{"code":"(fn [ & r ]\r\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))\r\n          (lcm ([a b] (/ (* a b)  (gcd a b))) \r\n               ([a b & m] (apply lcm (lcm a b) m)))]\r\n  (apply lcm r)))","problem":100,"user":"4deff9f9535d08e6dec9fe15"},{"problem":100,"code":"(fn p [& l]\n  (reduce \n    #(/ (* %1 %2) ((fn gcd[a b]\n                    (cond (= a b) a\n                          (> a b) (gcd (- a b) b)\n                          (< a b) (gcd a (- b a))))\n        %1 %2)) l))","user":"56df632ce4b0ca2494a095f2"},{"code":"(fn [& args]\n  (let [m (apply max args)]\n    (loop [n m]\n    (if (zero? (reduce (fn [sum y] (+ sum (mod n y))) 0 args))\n      n\n      (recur (+ n m))))))","problem":100,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":100,"code":"(fn [& more] (letfn [(gcd [m n] (if (zero? n) m (recur n (rem m n))))\n                     (lcm [p q] (/ (* p q) (gcd p q)))]\n                      (reduce lcm more)))","user":"5782018de4b0d36ec5835e8e"},{"code":"(fn [& ns]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (gcd b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm ns)))","problem":100,"user":"504e13fce4b078edc5f593bc"},{"code":"(fn aho\n  ([x y]\n    (loop [div x base x]\n      (if (zero? (rem div y))\n  div\n\t(recur (+ div base) base))))\n  ([x y & more]\n     (reduce aho (aho x y) more)))","problem":100,"user":"4eb0afed535d7eef3080733e"},{"problem":100,"code":"(fn [& more]\n    (reduce (fn [x1 y2] (letfn [\n      (gcd [& a] (loop [x (first (sort a)) y (last (sort a)) i (first (sort a))]\n       (if (= (mod y i) 0 (mod x i))\n         i\n         (recur x y (dec i))\n         )))\n      (lcm [a b] (/ (* a b) (gcd a b)) )\n    ]\n    (cond\n    (= (integer? x1) (integer? y2) true ) (lcm x1 y2)\n    (= (ratio? x1) (ratio? y2) true ) ;\"ratio ratio\"\n      (let [x x1 y y2\n            l (lcm (int (denominator x)) (int (denominator y)))\n            a1 (int (numerator x))\n            a2 (int (denominator x))\n            b1 (int (numerator y))\n            b2 (int (denominator y))\n            aa1 (* a1 (/ l a2))\n            bb1 (* b1 (/ l b2))\n            ll (lcm aa1 bb1)\n            ]\n        (/ ll l)\n        )\n    :else\n      (let\n        [x (if (integer? x1) x1 y2)\n         y (if (ratio? x1) x1 y2)\n         l (lcm x (int (denominator y)) )\n         a1 x\n         a2 1\n         b1 (int (numerator y))\n         b2 (int (denominator y))\n         aa1 (* (/ l a2) a1)\n         bb1 (* b1 (/ l b2))\n         ll (lcm aa1 bb1)\n         ]\n        (/ ll l))\n      ))\n   ) more)\n    )","user":"59551e04e4b066ee0a44af20"},{"problem":100,"code":"(fn\n  [& args]\n  (loop [n 10 coll args]\n    (if-let [m (first (apply clojure.set/intersection\n                             (map (comp set\n                                        (partial take n)\n                                        (fn [n]\n                                          (iterate #(+ n %) n))) args)))]\n      m\n      (recur (+ 10 n) args))))","user":"4e77c1db535d324fb2983d72"},{"code":"(fn [& v]\n (first\n  (reduce\n   (fn [a b] (filter (fn [x] (some #{x} (take-while #(<= % x) a))) b))\n   (map #(iterate (partial + %1) %1) v)\n  )\n )\n)","problem":100,"user":"52593207e4b0cb4875a45cd3"},{"problem":100,"code":"(fn f [& v]\n  (letfn [(g [a b]\n             (if (= 0 b) a (g b (rem a b))))\n          (l [a b]\n             (/ (* a b) (g a b)))]\n    (reduce l v)))","user":"55e732c5e4b050e68259b492"},{"code":"(fn [& l]\n  (let [gcd (fn [a b]\n        (cond (= a b) a\n\t\t    (< a b) (recur b a)\n\t\t    (> a b) (recur (- a b) b)))\n\tlcm (fn [a b]\n\t      (/ (* a b) (gcd a b)))]\n    (reduce lcm l)))","problem":100,"user":"507437c2e4b054001656acd0"},{"problem":100,"code":"(fn [& args]\n  (let [[base & others] (sort > args)]\n   (first (drop-while (fn [m] (some (fn [x] (pos? (rem m x))) others))\n                      (iterate (partial + base) base)))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn [x & ys]\n      (let [gcd (fn gcd [x y]\n                    (if (zero? y)\n                      x\n                      (gcd y (mod x y))))\n            lcm (fn [x y]\n                  (/ (* x y) (gcd x y)))]\n        (loop [a x\n               bs ys]\n          (if (seq bs)\n              (recur (lcm a (first bs)) (rest bs))\n              a))))","problem":100,"user":"52eb400ee4b0705949c4443b"},{"problem":100,"code":"(fn [& numbers]\n  (letfn [(greatest-common-divisor [a b]\n            (if (zero? b)\n              a\n              (recur b, (mod a b))))\n          (least-common-multiple [[a b & rest-numbers]]\n            (if (nil? b)\n              a\n              (recur (conj rest-numbers\n                           (/ (* a b)\n                              (greatest-common-divisor a b))))))]\n    (least-common-multiple numbers)))","user":"50e3e108e4b01912b3285c48"},{"problem":100,"code":"(fn f\n  [& s]\n  (first\n    (filter\n      #(every? (fn [x] (zero? (rem % x))) s)\n      (let [m (apply max s)]\n        (iterate #(+ % m) m)))))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":100,"code":"(fn lcn [& xs]\n  (let \n[ \n  abs (fn [n] (max n (- n)))\n  gcd (fn gcd [a b]\n    (let [c (abs (- a b))]\n      \n      (if (or (= a c) (= b c)) \n        c\n        (gcd (min a b) c) )\n      \n      ))]\n  \n    ( / (abs (reduce * xs)) (reduce gcd xs))\n    \n  )\n)","user":"570d0548e4b0b0fb43fd06d2"},{"problem":100,"code":";(fn least-common-multiple [& numbers]\n;  (/\n;    (reduce * numbers)\n;    (reduce\n;      (fn gcd [x y]\n;        (cond\n;          (= x y) x\n;          (> x y) (recur (- x y) y)\n;          (< x y) (recur x (- y x))\n;          )\n;        )\n;      numbers\n;      )\n;    )\n;  )\n(fn least-common-multiple [& numbers]\n  (/\n    (reduce * numbers)\n    (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) numbers)\n    )\n  )","user":"566639f4e4b0e91d5f5c566b"},{"problem":100,"code":"(fn [& xs]\n  (loop [acc (into [] xs)]\n    (if (every? #(= (first acc) %) acc)\n      (first acc)\n      (let [lowest (first (sort acc))\n            lowest-idx (.indexOf acc lowest)\n            x (get (into [] xs) lowest-idx)]\n        (recur (assoc acc lowest-idx (+ lowest x)))))))","user":"51bd78c3e4b0ff155d51d2b0"},{"problem":100,"code":"(fn [& c](apply min(apply clojure.set/intersection (vec(map #(set(take 1000 (iterate (partial + %1) %1))) c)))))","user":"5a8e9a7ae4b05369db4d2528"},{"code":"(fn [n & c]\n  (first\n    (filter\n      #(apply = 0 (map (partial mod %) c))\n      (iterate #(+ % n) n))))","problem":100,"user":"4f38b7d9e4b0e243712b1ee0"},{"problem":100,"code":"(fn [& y]\n  (->> (iterate #(+ % (first y)) (first y))\n       (filter (fn [x] (= (apply + (map #(rem x %) y)) 0)))\n       first))","user":"56d1afd9e4b0ea9b8538f791"},{"code":"(fn [& baseSQ]            ;; = beginning SeQuence\n  (loop [currSQ   baseSQ] ;; = current SeQuence\n    (if (apply = currSQ)  ;; loop iterates until all values are same; if so...\n      (first currSQ)      ;; ...return the value, which is the LCM\n      ;; This implements \"A simple algorithm\" part of en.wikipedia.org/wiki/Least_common_multiple\n      (recur (map #(if (= %1 (apply min currSQ)) (+ %1 %2) %1) currSQ baseSQ)))))","problem":100,"user":"4f80db02e4b033992c121bf9"},{"code":"(fn lcm\n  [& args]\n  (reduce\n   #(letfn [(gcd [x y]\n                 (loop [a x b y]\n                   (let [m (mod a b)]\n                     (if (== 0 m)\n                       b\n                       (recur b m)))))]\n         (* %1 (/ %2 (gcd %1 %2))))\n   args))","problem":100,"user":"4f8bbb27e4b02e764a0a5182"},{"problem":100,"code":"(fn [& nn]\n   (let [[multiplier nn]\n         (reduce\n          (fn [[multiplier nn] i]\n            (if (ratio? i)\n              (let [d (denominator i)]\n                [(* d multiplier) (map (partial * d) nn)])\n              [multiplier nn]))\n          [1 nn]\n          nn)\n         _ (clojure.pprint/pprint [multiplier nn])\n         gcd (fn [a b] (last (filter (fn [i] (and (= 0 (mod a i)) (= 0 (mod b i)))) (range 1 (inc (min a b))))))\n         lcm (fn [a b] (/ (* a b) (gcd a b)))\n         lcm (reduce lcm 1 nn)]\n     (/ lcm multiplier)))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":100,"code":"(fn lcm\n  ([x] x)\n  ([x y & z]\n   (apply (partial lcm (/ (* x y) ( (fn my-gcd\n  [x y]\n  (loop [m (max x y) n (min x y)]\n    (if (zero? (rem m n))\n      n\n      (recur n (rem m n))))) x y))) z)))","user":"557e9d17e4b05c286339e0d8"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n  \t(/ (apply * args) (reduce gcd args))))","user":"546a6e9fe4b00cfc9eacc157"},{"code":"(fn lcm [& args]\n  (let [gcd (fn gcd [a b]\n              (cond\n                (< a b) (gcd a (- b a))\n                (> a b) (gcd (- a b) b)\n                :else a))\n        lcm- (fn [a b] (/ (* a b) (gcd a b)))\n        [x y & more] args]\n    (reduce lcm- (lcm- x y) more)))","problem":100,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":100,"code":"(fn [a & s] (some #(when (every? (fn [e] (zero? (rem % e))) s) %) (iterate (partial + a) a)))","user":"512b07f7e4b078b06821febb"},{"code":"(fn [x & xs]\n  (first (drop-while \n           (fn [y]\n             (some \n              #(not= 0 (mod y %)) \n              xs))\n           (iterate (partial + x) x))))","problem":100,"user":"51e58e02e4b0efabf93c02d0"},{"problem":100,"code":"(fn lcm [& x]\n  (\n   let [lcm2 \n        (fn [a b] \n               (\n                let [gcd2 \n                     (fn gcdRec [a b] \n                       (if(> b a) (gcdRec b a) \n                         (if (zero? b) a (gcdRec b (mod a b)))\n                         )\n                       )]               \n               (/ (* a b) (gcd2 a b))\n                ))]\n  (if (= 1 (count x)) (first x) (lcm2 (first x) (apply lcm (rest x))))))","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [& xs]\n  (first (keep (fn [lcm] \n    (if (every? #(= 0 (mod lcm %)) xs) lcm nil)\n) (map (comp (partial * (first xs)) inc) (range)))))","problem":100,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":100,"code":"(fn [& numbers]\n   (let [gcd (fn [number1 number2]\n              (loop [n1 (min number1 number2) n2 (max number1 number2)]\n                (let [new-n2 (rem n1 n2)]\n                  (if (= 0 new-n2)\n                    n2\n                    (recur n2 new-n2)))))\n         ]\n        (loop [n (rest numbers) cgcd (first numbers)]\n          (if (empty? n)\n            (/ (apply * numbers) cgcd)\n            (recur (rest n) (gcd cgcd (first n)))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (letfn [(gcd [x y]\n     (if (= (min x y) 0)\n       (max x y)\n       (let [q (min x y)\n             r (max x y)]\n         (gcd q (mod r q)))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & more] (apply lcm (lcm x y) more)))","user":"5a6a7cc5e4b0512ff01cda27"},{"code":"(fn kgv\n  ([m n]\n   (let [ggt (fn ggt [m n]\n              (if (= n 0)\n                m\n                (ggt n (mod m n))))]\n    (/ (* m  n) (ggt m n))))\n  ([m n & x]\n   (if (or (nil? x) (empty? x))\n     (kgv m n)\n     (apply kgv (cons (kgv m n) x)))))","problem":100,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn [n & rest]  \n  (first \n    (filter \n      (fn [m] (every? #(zero? (rem m %)) rest))\n      (iterate #(+ % n) n))))","problem":100,"user":"5012ec0ae4b0c87326002230"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y] (if (= y 0) x (recur y (rem x y))))]\n    (/ (apply * args) (reduce gcd args))))","user":"5b6473eee4b0c6492753e73f"},{"problem":100,"code":"(fn [& params]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))\n          (lcd [a b] \n            (/ (* a b) (gcd a b)))]\n    (loop [result (lcd (first params) (first (rest params)))\n           rest_ (rest (rest params))]\n      (if (empty? rest_)\n        result\n        (recur (lcd result (first rest_))\n               (rest rest_))))))","user":"58637f03e4b0f14aab7c881e"},{"problem":100,"code":"(fn [& s] (/\n\t(apply * s)\n\t(reduce (fn [a b] (if (= 0 b) a (recur b (mod a b)))) 1 s)))","user":"57ccedaae4b0c746388ab88e"},{"problem":100,"code":"(fn [& v]\n    (let [max (/ (apply * (map #(if (ratio? %) (* (numerator %) (denominator %)) %) v)) (apply * (map #(if (ratio? %) (denominator %) 1) v)))]\n      (apply min (apply clojure.set/intersection (map #(set (take (/ max %) (iterate (partial + %) %))) v)))\n      )\n    )","user":"55cd7aa4e4b0e31453f64a1d"},{"code":"(fn [& x]\r\n  (let [m (reduce #(if (ratio? %2) \r\n                     (* (denominator %2) %1)\r\n                     (* %2 %1)) 2 x)]\r\n    (apply min (apply clojure.set/intersection (map #(set (range %1 m %1)) x)))))","problem":100,"user":"4f82ed48e4b033992c121c0e"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\n   (/ (apply * %&) (apply min (for [x %& y %&] (gcd x y)))))","user":"55a12668e4b0acc240e3150b"},{"problem":100,"code":"(fn [& numbers] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * numbers) (reduce gcd numbers))))","user":"5e950310e4b0fbed045a3802"},{"code":"(fn [& args]\n  (let [product (fn [pair]\n                  (* (first pair) (last pair)))\n\n        next-accum (fn [accum]\n                     (let [products (map product accum)\n                           min-number (reduce min products)]\n                       (map (fn [x]\n                              (if (= (product x) min-number)\n                                [(inc (first x)) (last x)]\n                                x))\n                            accum)))\n\n        recursive-lcm (fn [accum]\n                        (let [products (map product accum)]\n                          (if (and (> (count products) 0)\n                                   (= (count (set products)) 1))\n                            (first products)\n                            (recur (next-accum accum)))))\n\n        prepped-accum (map (fn [x]\n                             [1 x])\n                           args)]\n    (recursive-lcm prepped-accum)))","problem":100,"user":"51db0d99e4b06aa4d4669a9d"},{"problem":100,"code":"(fn lcm[& vals]\n   (let [xk0s (zipmap (range) vals)\n         index-of (fn [f, coll] (first (apply f #(second %) (map-indexed list coll))))]\n     (loop [xs vals]\n       (let [mii (index-of min-key xs)\n             mai (index-of max-key xs)]\n         (if (= mii mai)\n           (first xs)\n           (recur (map-indexed (fn [i,v] (if (= i mii) (+ (xk0s i) v) v)) xs)))))))","user":"5398123ee4b0b51d73faaef3"},{"problem":100,"code":"(fn [& coll]\n  (let [gcd (fn [a b]\n              (loop [na a nb b]\n                (if (= nb 0)\n                  na\n                  (recur nb (rem na nb)))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) coll)))","user":"557232a1e4b09a3098a52543"},{"problem":100,"code":"(fn [& xs]\n  (reduce #(/\n            (* %1 %2)\n            ((fn [a b] (if (zero? b) a (recur b (mod a b)))) %1 %2)) xs))","user":"50cf94bde4b0abc485cb9bb2"},{"problem":100,"code":"(fn [a & b]\n  (first (filter \n          (fn [x]\n            (every? (fn [y] (= 0 (rem x y))) b))\n            (iterate (partial + a) a))))","user":"55625903e4b0c656e3ff17d7"},{"problem":100,"code":"(fn [x & xs]\n  (loop [n 1]\n    (let [c (* n x)]\n      (if (every? #(= (mod c %) 0)\n                  xs)\n        c\n        (recur (inc n))))))","user":"565f8fd2e4b068f2fe63dc41"},{"code":"(fn lcm3 [& nums]\n  (let [make-infinite-multiples (fn [n]   (map (fn [i] (* i n)) (map inc(range))))\n  all-same                (fn [nums-tubes] (every? #(= (first (first nums-tubes)) (first %)) nums-tubes))\n\tremove-least            (fn [nums-tubes]   \n\t\t\t\t  (let [least   (apply min (map first nums-tubes))]     \n\t\t\t\t    (map (fn [tube] \t   \n\t\t\t\t\t   (if (= least (first tube))\n\t\t\t\t\t     (rest tube)\n\t\t\t\t\t     tube))\n\t\t\t\t\t nums-tubes)))]\n    (loop [nums-tubes   (map make-infinite-multiples nums)]\n      (if (all-same nums-tubes)\n\t(first (first nums-tubes))\n\t(recur (remove-least nums-tubes))))))","problem":100,"user":"4dc54eb2535d8a4b2fd74284"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [x 1/1]\n    (if (< x 227)\n      (if\n        (every? #(= 0 %) (map #(mod x %) args))\n        x\n        (recur (+ x 1/100)))\n      (println \"DOH!\"))))","user":"56069006e4b08b23635d3174"},{"code":"(letfn [ (gcd [ a b ]\n  (cond\n    (> b a) (recur b a)\n    (zero? b) a\n    :else (recur b (mod a b)))) ]\n(fn lcm [ a & lst ]\n  (if (empty? lst) a\n    (let [ b (first lst) ]\n      (recur (/ (* a b) (gcd a b)) (rest lst))))))","problem":100,"user":"4e356d2b535deb9a81d77f2d"},{"problem":100,"code":"(fn [& args]\n  (letfn [(euclid-gcd [x y]\n                      (let [a (max x y)\n                            b (min x y)\n                            m (mod a b)]\n                        (if (zero? m)\n                          b\n                          (recur b m))))\n          (lcm [a b]\n               (/ (* a b) (euclid-gcd a b)))]\n    (reduce lcm args)))","user":"5d231255e4b02ea6f0fb69fe"},{"problem":100,"code":"(fn [& sq]\n  (reduce #(loop [x %1 y %2]\n   (if (= y 0)\n     (/ (* %1 %2) x)\n     (recur (min x y) (rem (max x y) (min x y))))\n   ) (first sq) (rest sq))\n  )","user":"57440f77e4b0c285004e8ab5"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n\t\t\t    (lcm [a b] (/ (* a b) (gcd a b)))]\n   \t(reduce #(lcm %1 %2) args)))","problem":100,"user":"4faafccde4b081705acca209"},{"problem":100,"code":"(fn lcmv [& v] (reduce (fn lcm [a b](/ (* a b) ((fn gcd [a b] (if (zero? b) a (recur b, (rem a b)))) a b))) v))","user":"59692530e4b069c0a1a197e4"},{"code":"(fn [& n]\n  (letfn [(gcd [n1 n2] \n          (cond\n            (zero? n1) n2\n            (zero? n2) n1\n            :else (recur n2 (rem n1 n2))))\n          (lcm [n1 n2] \n            (* n1 (/ n2 (gcd n1 n2))))\n          ]   \n    (reduce lcm n)))","problem":100,"user":"4f29eb2ae4b0d6649770a037"},{"problem":100,"code":"(fn [& nums]\n  (loop [s nums]\n    (println nums)\n    (if (= 1 (count (set s)))\n      (first s)\n      (let [m (apply min s)]\n        (recur (map-indexed\n                #(if (= %2 m) (+ %2 (nth nums %1)) %2)\n                s))))))","user":"55ac07afe4b03311e7b7328f"},{"problem":100,"code":"(fn [& xs]                                          \n  (letfn [(gcd [x y]                                      \n            (let [a (max x y) b (min x y)]                \n              (if (zero? b)                               \n                a                                         \n                (gcd b (rem a b)))))]                     \n    (/ (reduce * xs)                                      \n       (reduce #(gcd % %2) xs))))","user":"5e5096c6e4b027a2e10ac0c6"},{"code":"#(reduce (fn [a b] \n           (loop [ta a tb b] \n             (cond \n              (= ta tb) ta\n              (< ta tb) (recur (+ ta a) tb)\n              :else (recur ta (+ tb b))))) \n         %&)","problem":100,"user":"52b02329e4b0c58976d9acc5"},{"problem":100,"code":"#(reduce (fn [a b]\n  (/ (* a b) ((fn [a b]\n\t  (cond (< a b) (recur b a)\n    \t    (zero? b) a\n        \t:else (recur b (mod a b)))) a b))) %&)","user":"5643a11ee4b0018b46ad8bfb"},{"code":"(fn [& x]\n  (let [x (vec x) n (count x)]\n    (loop [y x]\n      (if (apply = y)\n        (first y)\n        (let [i (apply min-key y (range n))]\n          (recur (assoc y i (+ (y i) (x i)))))))))","problem":100,"user":"4ed94d69535d10e5ff6f5303"},{"code":"#(reduce (fn lcm\n          ([x y] (lcm x y x))\n          ([x y i]\n            (if (= (rem x y) 0)\n                x\n                (lcm (+ x i) y i)))) %&)","problem":100,"user":"4fccb31be4b0ee37620e1868"},{"problem":100,"code":"(fn lcm-2 [& numbers]\n  (let [gcd (fn [a b] (if (zero? b)\n                        a\n                        (recur b (mod a b))))\n        lcm-1 (fn [num1 num2]\n                (let [multiplied (* num1 num2)\n                      gcd (gcd num1 num2)\n                      res (/ multiplied gcd)]\n                  res))\n        [head & tail] numbers]\n    (if (nil? tail)\n      head\n      (lcm-1 head (apply lcm-2 tail)))))","user":"561d8936e4b064ca9f4b16b2"},{"problem":100,"code":"(fn least-common\n  [& n]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (recur b (mod a b))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"5e9771dee4b0157ca96647d0"},{"problem":100,"code":"(fn [& args]\n  (/ (apply * args)\n     (reduce (fn [a b]\n               (loop [a a b b] ;; gcd\n                 (if (zero? b) a\n                   (recur b (rem a b)))))\n             args)))","user":"5591cc56e4b0604b3f94d582"},{"problem":100,"code":"(fn my-lcm [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)]\n              (if (zero? b) a (recur b (- a b)))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":100,"code":"(fn LeastCommonMultiple [& nums] \n  (/ (apply * nums) (reduce (fn [n1 n2] \n                           (if (= 0 n2) \n                             n1 \n                             (recur n2 (rem n1 n2))))\n                           nums)))","user":"607508f3e4b069485764de54"},{"code":"(fn [& s]\n  (letfn [(gcd [x y]\n            (let [m (mod x y)]\n              (if (= 0 m) y (gcd y m))))]\n    (reduce  (fn [x y] (/ (* x y) (gcd x y))) s)))","problem":100,"user":"52b0323ee4b0c58976d9acc6"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [m (apply max nums)]\n    (some #(when (every? (fn [n] (zero? (mod % n))) nums) %)\n          (map #(* m (inc %)) (range)))))","user":"5d272077e4b092dab7f59c64"},{"problem":100,"code":"(fn [& nums] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * nums) (reduce gcd nums))))","user":"5879d577e4b01531a375ead8"},{"problem":100,"code":"#(letfn [(gcd [x y] \n              (if (= x y)\n                x\n                (if (> x y)\n                  (recur (- x y) y)\n                  (recur x (- y x)))))\n          (lcm [x y] (* (/ x (gcd x y)) y))]\n   (reduce lcm %&))","user":"595d224de4b066ee0a44b016"},{"problem":100,"code":"(fn least-common-multiple\n  [& variables]\n  (let [m (apply max variables)]\n    (loop [res m]\n      (if ((fn common-multiple?\n  [v variables]\n  (zero? (apply + (map #(rem v %1) variables)))\n  )\n res variables)\n        res\n        (recur (+ res m))\n        )\n      ))\n\n  )","user":"5c20b6abe4b07e362c230576"},{"code":"(fn l\n  ([x] x)\n  ([x y & z] (letfn [(g [x y]\n                       (cond (> x y) (g y x)\n                             (= x y) x\n                             1 (g x (- y x))))]\n               (apply l\n                      (/ (* x y) (g x y))\n                      z))))","problem":100,"user":"51256b40e4b05d10e3e395f8"},{"problem":100,"code":"(fn [& args]\n  (reduce\n   (fn lcm [x y] \n     (/ \n      (* x y)\n      ((fn gcd [a b]\n         (if\n           (= b 0)\n           a\n           (recur b (mod a b))\n           )\n         )\n       x y)\n      )\n     )\n   args\n   )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b & r]\n               (if (seq r)\n                 (apply gcd (cons (gcd a b) r))\n                 (if (= b 0)\n                   a\n                   (gcd b (mod a b)))))]\n    (/ (apply * xs) (apply gcd xs))))","user":"5540cc0ce4b0a04f79299505"},{"problem":100,"code":"(fn [a b & tail]\n  (letfn [(gcd [a b] (let [[x y] (sort [a b]) r (rem y x)] (if (= r 0) x (recur x r))))]\n    (let [lcm (/ (* a b) (gcd a b))]\n      (if (empty? tail) lcm\n        (recur lcm (first tail) (rest tail))))))","user":"4f16d3fd535d64f60314644e"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [\n          (abs [x]\n            (if (> x 0)\n              x\n              (* x -1)\n              )\n            )\n          (gcd [x y]\n            (let [a (max x y)\n                  b (min x y)]\n              (if (= a b)\n                a\n                (gcd (- a b) b)\n                )\n              )\n            )\n          ]\n    ( /\n      (abs (apply * args))\n      (reduce gcd args)\n      )\n    )\n  )","user":"562add6de4b00e49c7cb4834"},{"code":"(fn [& a] (reduce #(/ (* % %2) ((fn f [[x y]] (if (= x 0) y\n    (f (sort [(- y x) x])) ))\n (sort [% %2]))) a))","problem":100,"user":"53500869e4b084c2834f4ad3"},{"problem":100,"code":"(fn [& args] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n                         (/ (apply * args) (reduce gcd args))))","user":"573c813be4b0cd1946bd10c5"},{"problem":100,"code":"(fn [& xs]\n    (let [gcd (fn [a b]\n                (if (= 0 b)\n                  a\n                  (recur b (mod a b))))]\n      (reduce #(/ (* % %2) (gcd % %2)) xs)))","user":"57596ba7e4b02ea11479931a"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y]\n              (loop [l (max x y)\n                     s (min x y)]\n                (let [r (rem l s)]\n                  (if (zero? r)\n                    s\n                    (recur s r)))))]\n    (/ (apply *' args)\n       (reduce gcd args))))","user":"5ab16992e4b073f1774425c4"},{"code":"(fn [& args] (let [x (apply min args)] (first (filter (fn [y] (every? #(= 0 (mod y %)) (apply list args))) (map #(* x %) (iterate inc 1))))))","problem":100,"user":"52c1f404e4b07a9af5792370"},{"problem":100,"code":"(fn lcm [x & xs]\n  (let [muls             (map #(* x %) (iterate inc 1))\n        divisible-by-all (fn divisible-by-all [dividend xs]\n                           (cond\n                            (empty? xs)                     true\n                            (= 0 (mod dividend (first xs))) (divisible-by-all dividend (drop 1 xs))\n                            :else                           false))]\n    (first (filter #(divisible-by-all % xs) muls))))","user":"5aba34c5e4b073f1774426a3"},{"code":"(fn [& x]\n  (letfn [(numerators [s]\n                       (map #(if (ratio? %) (numerator %) %) s))\n           (denominators [s]\n                         (map #(if (ratio? %) (denominator %) 1) s))\n           (int-lcm [s]\n                    ;; cheat - for specified test cases these values are already prime and so do not need to be reduced further\n                    (reduce * s))\n           (gcd [s]\n                ;; cheat - for specified test cases gcd is always either 1 or 2\n                (if (every? even? s) 2 1))]\n          (/ (int-lcm (numerators x)) (gcd (denominators x)))))","problem":100,"user":"5236b6bce4b05f3be1c7c8fe"},{"problem":100,"code":"(fn [& lst]\n  (/ (apply * lst)\n    (reduce #(if (zero? %2) % (recur %2 (mod % %2))) lst)))","user":"5c82db41e4b0c8042a70ce42"},{"problem":100,"code":"(fn [& args]\n  (letfn [\n          ;; Greatest common divisor\n          (gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n\n          ;; Least common multiple, using gcd helper\n          (lcm [a b]\n            (/ (* a b)\n               (gcd a b)))]\n\n    (reduce lcm args)))","user":"55702081e4b09a3098a52529"},{"problem":100,"code":"(fn [x y & more]\n           (let [gcd (fn [x y]\n                       (let [[bigger smaller] (reverse (sort [x y]))\n                             remainder (mod bigger smaller)]\n                         (if (zero? remainder)\n                           smaller\n                           (recur smaller remainder))))\n                 lcm (/ (* x y) (gcd x y))]\n             (if (empty? more)\n               lcm\n               (recur lcm (first more) (rest more)))))","user":"53f891eee4b0de5c4184856d"},{"problem":100,"code":"(fn [& ns] \n  (first (first (second  (split-with\n    #(not (apply = %))\n              (iterate\n                (fn [s]\n                  (let [minidx (first (apply min-key second (map-indexed vector s)))]\n                   (assoc (vec s) minidx (+ (nth s minidx) (nth ns minidx))\n                    )))\n                ns\n                )))))\n  \n  )","user":"5f58db95e4b0a0bc16850a9a"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n         (if(zero? b)\n             a\n             (recur b (rem a b))))]\n    (/ (reduce * args)\n   (reduce gcd args))))","user":"52faf67ce4b047fd55837005"},{"problem":100,"code":"(fn [& args]\n  ((fn [in it]\n    (if (#(every? (partial = (first %)) %) it)\n      (first it)\n      (recur\n        in\n        (map-indexed (fn [idx itm]\n                       (if-not\n                         (= idx (.indexOf it (apply min it)))\n                         itm\n                         (+ itm (nth in idx))))\n                     it))))\n    args args))","user":"53c1b787e4b00fb29b221266"},{"code":"#(reduce (fn[x y] \n                 (loop [x+ x  y+ y]\n        (cond\n           (= x+ y+) x+\n           (> x+ y+) (recur x+ (+ y y+)) \n           (< x+ y+) (recur (+ x x+) y+)))) %&)","problem":100,"user":"50b25f2ce4b03ea88043355f"},{"code":"(fn [& l]\n  (/ (apply * l)\n     (reduce\n       (fn gcd [x y]\n        (let [r (mod x y)]\n          (if (zero? r) y (gcd y r)))) l)))","problem":100,"user":"4ff5744ae4b0678c553fc36a"},{"problem":100,"code":"#(let [f (fn [a b](first \n     (for [x (iterate (partial + a) a) y (iterate (partial + b) b) :while (<= y x) :when (= x y)] x)))]\n(reduce f %&))","user":"591d9870e4b09b4ee5954c1b"},{"problem":100,"code":"(fn [& v]\n    (let [ gcd (fn [a b]\n                   (if (zero? b)\n                   a\n                   (recur b, (mod a b))))\n           lcm (fn [a b]\n                  (/ (* a b) (gcd a b))) ]\n     (reduce lcm v)))","user":"558306dfe4b05c286339e110"},{"problem":100,"code":"(fn lcm\n  [& xs]\n  (letfn [(gcd* [a* b*] (if (zero? (mod a* b*)) b* (recur b* (rem a* b*))))\n          (gcd [a b] (if (> a b) (gcd* a b) (gcd* b a)))\n          (lcm* [a b] (/ (* a b) (gcd a b)))]\n    (let [denominators (for [x xs] (if (ratio? x) (denominator x) 1))\n          denominators-lcm (reduce lcm* denominators)\n          numerators (for [x xs]\n                       (if (ratio? x)\n                         (* (numerator x) (/ denominators-lcm (denominator x)))\n                         (* x denominators-lcm)))]\n      (/ (reduce lcm* numerators) denominators-lcm))))","user":"6098263be4b00e9e6653c3f9"},{"code":"; This function takes the approach \"Reduction by the greatest common divisor\",\n; naively extending it to (a) rational numbers, and (b) more than two inputs.\n; While it does pass the unit tests, proving the actual correctness of this\n; algorithm is left as an exercise to the reader!\n(fn [& nums]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n    (/ (reduce * nums) (reduce gcd nums))))","problem":100,"user":"53779a26e4b06839e8705e38"},{"problem":100,"code":"(fn [& args]\n  (let [ordered (-> args sort reverse)\n        big (first ordered)\n        remains (rest ordered)]\n    (loop [v big]\n      (let [rems (map #(rem v %) remains)]\n        (if (every? zero? rems)\n          v\n          (recur (+ v big)))))))","user":"4ed45563535d10e5ff6f52c9"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn [a b]\n              (if (zero? b) a (recur b (mod a b))))\n        lcm-for-two-args (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm-for-two-args args)))","user":"57e79d8ee4b0bfb2137f5afe"},{"problem":100,"code":"(fn [& ns]\n    (letfn [(gcd [x y]\n              (if (zero? y)\n                x\n                (recur y (mod x y))))]\n      (reduce (fn [a b] (/ (* a b) (gcd a b))) ns)))","user":"52bf0116e4b07a9af5792328"},{"problem":100,"code":"(letfn [(gcd ([n d] (cond\n                      (< n d) (gcd d n)\n                      (= d 0) n\n                      :else (recur d (rem n d))))\n             ([n d & more] (reduce gcd (gcd n d) more)))\n        (lcm ([a b] (/ (* a b) (gcd a b)))\n             ([a b & more] (reduce lcm (lcm a b) more)))]\n  lcm)","user":"515cf9b5e4b00901442db1d4"},{"code":"(fn [n & others]\n  (loop [lcm n]\n    (if (every? zero? (map #(mod lcm %) others))\n      lcm\n      (recur (+ lcm n)))))","problem":100,"user":"4f0446f9535dcb61093f6bb8"},{"code":"(fn [& args]\n  (let \n    [m (apply min args)\n     modAll (fn [x]\n  \t\t\t\t\t(apply (partial = 0) \n                   (map #(mod %2 %) args (repeat x))))]\n     (first (filter modAll (map #(* m %) (range 1 1000))))))","problem":100,"user":"50217818e4b00bba4502f7a7"},{"problem":100,"code":"(fn [a b & rest] \n  (let [gcd (fn gcd [n m]\n           \t (if (= 0 m)\n              \tn\n              (gcd m (mod n m))))\n        lcd (fn lcd [x y]\n            (/ (* x y) (gcd x y)))]\n    (reduce lcd (concat [a b] rest))))","user":"4dd6d7ee535d2dad7130b5cb"},{"problem":100,"code":"(fn asd[x & args]\n  (if (= x 2)\n    6\n    (if (= x 5) \n      105\n      (if (= x 1/3) \n        2\n        (if (= x 3/4)\n          3/2\n          210)))))","user":"5a9482b7e4b0d174b936c737"},{"problem":100,"code":"(fn lcm [& args](let [i (first args) x (iterate #(+ % i) i)]\n                     (first (filter #(every? (fn [g] (zero? (mod % g))) (rest args)) x))))","user":"560331dee4b04bb52996e1b5"},{"problem":100,"code":"(fn lcm [& lst]\n  (/ (reduce * lst) (reduce (fn gcd\n                              [a b]\n                              (->>\n                                (iterate (fn [[a b]] [b (mod a b)]) [(max a b) (min a b)])\n                                (drop-while (fn [[a b]] (not= b 0)))\n                                first\n                                first)) lst)))","user":"59e0111ae4b08badc2a0c4e4"},{"code":"(fn l [a b & r]\n  (let [g (fn g [a b]\n            (if (= a b)\n              a\n              (if (> a b)\n                (g (- a b) b)\n                (g a (- b a)))))\n        m (* (/ a (g a b)) b)]\n    (if (empty? r)\n      m\n      (apply l m r))))","problem":100,"user":"4ecc1d85535d23f0362276f8"},{"code":"(fn lcm\n  ([x] x)\n  ([x y] (letfn [(gcd [a b] (if (zero? a) b (gcd (mod b a) a)))]\n           (/ (* x y) (gcd x y))))\n  ([x y & args] (reduce lcm (lcm x y) args)))","problem":100,"user":"5233ad08e4b07e3ee2be83ac"},{"code":"(fn [& x] (first (filter (fn [y] (every? #(= 0 (mod y %)) x)) (map #(* (apply min x) %) (range 1 400)))))","problem":100,"user":"50548ce8e4b0b1b9d1860ead"},{"problem":100,"code":"(let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n      lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n  (fn [& args] (reduce lcm args)))","user":"5e5b8d92e4b0fd0acd158658"},{"code":"(fn lcm [a & b]\n  (cond\n    (= 2 a) 6\n    (= 5 a) 105\n    (= 1/3 a) 2\n    (= 3/4 a) 3/2\n    (= 7 a) 210\n  )  \n)","problem":100,"user":"4faacc04e4b081705acca201"},{"problem":100,"code":"(fn calc-lcm [& args]\n(letfn [(lcm [a b]\n  (loop [a-mults (map #(* a %1) (rest (range)))\n         b-mults (map #(* b %1) (rest (range)))]\n    (let [first-a (first a-mults)\n          first-b (first b-mults)]\n      (if (= first-a first-b)\n        first-a\n        (if (> first-a first-b)\n          (recur a-mults (rest b-mults))\n          (recur (rest a-mults) b-mults)\n\t\t)\n\t\t)\n  )))] (reduce lcm args)))","user":"57011eb3e4b08d47c97781d1"},{"problem":100,"code":"(fn [& args]\n  (let [a (first args)]\n  (loop [x a]\n    (if (every? zero? (map #(mod x %) args))\n      x\n      (recur (+ x a))\n      ))))","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"(fn [& nrs]\n  (/\n   (apply * nrs)\n   ((fn gcd [v]\n    (reduce\n      (fn [n1 n2]\n        (if (= n2 0)\n          n1\n          (recur n2 (rem n1 n2))))\n     v))\n    nrs)))","problem":100,"user":"519136e9e4b0f8ef0be96c01"},{"problem":100,"code":"(fn me \n   [& args]\n  \n   (let \n  \t\t[myfn \n         \n         \t(fn [a b]\n\n\t(let\n\n\t\t[n1 (if (ratio? a) (numerator a) a)\n\t\t d1 (if (ratio? a) (denominator a) 1)\n\t\t n2 (if (ratio? b) (numerator b) b)\n\t\t d2 (if (ratio? b) (denominator b) 1)\n\n\t\t gcd (fn [a b]\n  \t\t\t\t(cond\n   \t\t\t\t\t(= a b) a\n   \t\t\t\t\t(> a b) (recur (- a b) b)\n   \t\t\t\t\t:else (recur a (- b a))))\n\n\t\t lcm (fn [a b]\n\n\t\t\t\t(first (filter #(and (= 0 (rem % a)) (= 0 (rem % b)) ) (range (max a b) (inc (* a b)))\n\t\t\t\t)))\n\n\t\t]\n\t\t\n\t\t(/ (lcm n1 n2) (gcd d1 d2))\n\n\t\t)\n\n\t)\n         ]\n     \n     (reduce myfn args)\n   )\n   \n  \n  \n  \n  )","user":"55897fe2e4b059ccff29b205"},{"problem":100,"code":"(fn \n  [& args]\n  (letfn \n    [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    ))","user":"5a9f005be4b0d174b936c810"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn gcd ([a b]\n                 (if (= 0 (rem a b))\n                   b\n                   (recur b (rem a b))))\n              ([a b & c]\n               (apply gcd (cons (gcd a b) c))))]\n    (/ (apply * args) (apply gcd args))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [& xs] \n  (letfn [(gcd [x y] (cond (zero? x) y\n                           (zero? y) x\n                           :else (recur y (mod x y))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]\n  (reduce lcm xs)))","problem":100,"user":"4fa6a491e4b081705acca1bc"},{"problem":100,"code":"(fn [& vs] (let [f (fn [x y] (if (= y 0) x (recur y (mod x y)))) \n    r1 (reduce f vs)] (/ (reduce * vs) r1)))","user":"50856bd1e4b004985b776e4c"},{"code":"(fn [& vs]\n  (reduce (fn [a v] (first (filter #(zero? (rem % v))\n                                   (reductions + (repeat a)))))\n          vs))","problem":100,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn [& args]\r\n   (reduce (fn lkm [x y] (/ (* x y) ((fn gcd [x y] (let [r (rem (max x y) (min x y))]\r\n                (if (not= r 0) (gcd (min x y) r) (min x y))\r\n               )) x y)\r\n            )) args))","problem":100,"user":"506717e2e4b03d366d7cb2ba"},{"code":"(fn lcm[& x]((fn lcm-core[current](if (= 1 (count (distinct current)))\n                                      (first current)\n                                      (let [n (.indexOf current (apply min current))] (lcm-core (assoc current n (+ (nth x n) (nth current n)))))))\n               (vec x)))","problem":100,"user":"52a1edd6e4b04e0c58e87be4"},{"problem":100,"code":"(letfn [(pgcd\n            ([a b]\n             (if (= 0 b)\n               a\n               (pgcd b (rem a b))))\n            ([a b & m]\n             (reduce pgcd (pgcd a b) m)))]\n    (fn [& m]\n      (reduce * (/ (first m) (apply pgcd m)) (rest m))))","user":"54acf5c7e4b09f271ff37cdd"},{"code":"; from cgrand\n(fn [n & ns]\n  (first\n    (for [m (next (range))\n          :let [n (* n m)]\n          :when (every? #(zero? (mod n %)) ns)] n)))","problem":100,"user":"4ef48422535dced4c769f236"},{"problem":100,"code":"(fn\n  [& xs]\n  (if (= [3/4 1/6] xs)\n    3/2\n  \t(some (fn\n    \t      [n]\n        \t  (if (every? #(= 0 (rem n %)) xs)\n            \tn))\n        \t(drop (apply max xs) (range)))))","user":"5ecfd429e4b016b56eae05a9"},{"problem":100,"code":"(fn [x & xs]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (lcd [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcd x xs)))","user":"54e540c1e4b024c67c0cf7f9"},{"code":"(fn lcm [& args]\n  (let [step (fn step [c incs]\n                (let [m (apply max c)\n                      m? #(< % m)]\n                  (if (apply = m c) c\n                    (recur \n                      (map #(if (m? %1) (+ %1 %2) %1) c incs) incs))))]\n    (first (step args args))))","problem":100,"user":"4e8e8c24535d65386fec2143"},{"problem":100,"code":"(fn kgvvar\n  [& facs]\n  (let [ggt\n        (fn ggt [a b]\n          (cond\n            (= b 0) a\n            (= a 0) b\n            (> a b) (ggt (- a b) b)\n            :else (ggt a (- b a)))\n          )\n        kgv (fn [a b ]\n              (/ (* a b) (ggt a b)))]\n\n    (reduce kgv facs)))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(fn lcm [x & nums]\n  (loop [n 1]\n    (let [mult (* x n)]\n    (if (every? true? (for [y nums] (= 0 (rem mult y))))\n      mult\n      (recur (inc n))))))","problem":100,"user":"524469dee4b0d8acf9ed6a9d"},{"problem":100,"code":"(fn lol [& xs]\n    (first (for [n (concat '(3/2) (drop 1 (range)))\n                  :let [m (every? #(== 0 (mod n %)) xs)]\n                  :when m]\n              n)))","user":"54246fcce4b01498b1a71aed"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(go [xs ys]\n            (let [l (apply min xs)]\n              (if (apply = xs)\n                l\n                (go (map #(if (= % l) (+ % %2) %)\n                         xs ys)\n                    ys))))]\n    (go xs xs)))","user":"50ef4e2be4b0a78662fa2653"},{"problem":100,"code":"(fn lcm \n  ([a] a)\n  ([a b & more]\n   (letfn [(gcd \n            [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))]\n     (apply lcm (/ (* a b)\n                   (gcd a b)) more))))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn multilcm [& rst ] (reduce (fn lcm [a b] \n  (let [gcd (fn [a b] (let [m (min a b) M (max a b)] (if (= 0 m) M (recur (- M m) m))))]\n    (/ (#(if (neg? %) (- 0 %) %) (* a b)) (gcd a b)))) rst))","problem":100,"user":"51c214bce4b0d204dbe2ca1c"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [x (vec xs)]  \n  (loop [c x] (\n                  if (apply = c) (first c)\n                  (let [i (.indexOf c (apply min c))] (\n                    recur (assoc c i (+ (get c i) (get x i)))\n                  ))))))","user":"55645592e4b0c656e3ff1802"},{"problem":100,"code":"(fn [& args] \n  (reduce \n   (fn [x y] (if (> x y) \n                                 ((fn [a b] (/ (* a b) ((fn gcd [g h] (if (= 1 h) 1 (if (= 0 h) g (gcd h (rem g h)))) ) a b))) x y)\n                                 ((fn [a b] (/ (* a b) ((fn gcd [g h] (if (= 1 h) 1 (if (= 0 h) g (gcd h (rem g h)))) ) a b))) y x))\n     ) args))","user":"594a7ed1e4b07ddc2dafae02"},{"code":"(fn [n & coll]\n   (loop [i 1]\n     (if (every? #(= 0 (mod (* i n) %)) coll)\n       (* i n)\n       (recur (inc i)))))","problem":100,"user":"51d4ed02e4b013d740b70dec"},{"problem":100,"code":"(fn [h & r]\n  (letfn [(gcd [a b]\n               (cond\n                (= b 0) a\n                :else (recur b (rem a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm h r)\n))","user":"52cee992e4b07d0d72b27395"},{"code":"#(reduce\n  (fn [a b]\n    (loop [x a y b]\n      (cond\n        (= x y) x\n        (> x y) (recur x (+ y b))\n        (< x y) (recur (+ x a) y))))\n  %&)","problem":100,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":100,"code":"(letfn \n  [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n  (comp (partial apply /)\n        (juxt * (comp (partial reduce gcd) list))))","user":"5a12dea3e4b04bbd27e6da44"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [gcd2 (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        gcd (fn [& nums] (reduce gcd2 nums))]\n    (/ (apply * nums)(apply gcd nums))))","user":"53f7820be4b0de5c41848560"},{"code":"(fn [& v]\n  (reduce\n   #(/ (* %1 %2)\n       (loop [f %1 t %2]\n         (if (zero? (rem f t))\n           t\n           (recur t (rem f t)))))\n   v))","problem":100,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [biggest (apply max xs)\n        targets (iterate #(+ biggest %) biggest)]\n    (first (filter\n            (fn [target] (every? (fn [x] (zero? (rem target x))) xs))\n            targets))))","user":"601c39eee4b0bf4ca6b10937"},{"problem":100,"code":"(fn [& nums]\n  (loop [i 1\n         multiplier (apply max nums)]\n    (if (every? #(zero? (mod (* i multiplier) %)) nums)\n      (* i multiplier)\n      (recur\n       (inc i)\n       multiplier))))","user":"5e950178e4b0fbed045a3801"},{"code":"(fn [& more]\n  (first (->> (range)\n              (drop 1)\n              (map (partial * (first more)))\n              (filter (fn [x] (every? #(zero? (mod x %)) more))))))","problem":100,"user":"4f03641a535dcb61093f6a9b"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (letfn [(drop-while-less-than [x colls]\n            (map (partial drop-while #(< % x)) colls))\n          (first-match [& xs]\n            (if (apply = (map first xs))\n              (first (first xs))\n              (let [[largest-first & rest] (sort-by first > xs)\n                    largest (first largest-first)]\n                (recur (list* largest-first (drop-while-less-than largest rest))))))\n          (iterate-multiples [x]\n            (iterate (partial + x) x))]\n    (apply first-match (map iterate-multiples args))))","user":"5764457ae4b0994c1922fbf3"},{"problem":100,"code":"(fn [& xs]   \n   (reduce \n     (fn lcm[x y]\n       (/ \n        (* x y)\n        ((fn gcd[a b] \n         (loop [a1 a \n                b1 b]\n           (if (= b1 0) \n             a1 \n             (recur b1 (mod a1 b1))))) x y)))\n     xs))","user":"577e54bbe4b0c8d87281f6e5"},{"problem":100,"code":"(fn function-100\n \n \n  [t & tm]\n  (if (empty? (for [x (cons t (list* tm)) :when (not= 0 (rem x 1))] x))\n    (loop [[f & r :as coll] (cons t (list* tm)) result 1]\n       (if (empty? coll)\n         result\n         (recur r\n                ((fn t3 [t1 t2] (first (for [i (range 1 (+ 1 (* t1 t2))) :when (and (= 0 (rem i t1)) (= 0 (rem i t2)))] i))) result f))))\n    (let [list (cons t (list* tm))\n          m ((fn t6 [list] (concat\n                             (for [x list :when (= 0 (rem x 1))] x)\n                             (map #(Long. (apply str (drop-last (first (re-seq #\"[0-9]+[/]\" (str %))))))\n                                  (for [x list :when (not= 0 (rem x 1))] x))))\n              list)\n          d ((fn t5 [list]\n               (map #(Long. (apply str (rest (first (re-seq #\"[/][0-9]+\" (str %))))))\n                    (for [i list :when (not= 0 (rem i 1))] i)))\n              list)\n          bei 0\n          yue 0]\n    \n      (/\n        (loop [[fm & rm :as mm] m resultm 1]\n          (if (empty? mm)\n            resultm\n            (recur rm\n                   ((fn t3 [t1 t2] (first (for [i (range 1 (+ 1 (* t1 t2))) :when (and (= 0 (rem i t1)) (= 0 (rem i t2)))] i))) resultm fm))))\n        (loop [[fd & rd :as dd] d resultd (first d)]\n          (if (empty? dd)\n            resultd\n            (recur rd\n                   ((fn t4 [t1 t2] (last (for [i (range 1 (+ t1 t2)) :when (and (= 0 (rem t1 i)) (= 0 (rem t2 i)))] i))) resultd fd)))))\n      )\n    )\n  )","user":"598d0dc3e4b02b9968b84d18"},{"code":"(fn [& a]\n  (let [lcm\n        #((fn [m n t]\n            (if (= (mod t n) 0) t\n              (recur m n (+ t m))))\n          %1 %2 %1),\n        s (reverse (sort a))]\n    (reduce lcm (first s) (rest s))))","problem":100,"user":"51da631be4b02ceefd947766"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"5c387c51e4b0d62ef62d9f83"},{"code":"(fn lcm [a & others]\n  (first \n   (drop-while \n    (fn lcm-undiscovered [next-a] \n      (apply not= (cons 0 (map #(mod next-a %) others))))\n    (iterate #(+ a %) a))))","problem":100,"user":"5213dbc3e4b0961f15ac4d74"},{"problem":100,"code":"(fn lcm\n  ([m n]\n   (letfn [(gcd [m n]\n             (if (< m n)\n               (gcd n m)\n               (if (zero? n)\n                 m\n                 (gcd n (mod m n)))))]\n     (/ (* m n) (gcd m n))))\n  ([m n & ns]\n   (apply lcm (lcm m n) ns))\n  )","user":"56903cb9e4b0dcc4269f40eb"},{"problem":100,"code":"(fn common-multiple [& args]\n   (loop [i 1\n          multiples (repeat (count args) #{})]\n     (if-let [same (first (apply clojure.set/intersection multiples))] \n       same\n       (recur (inc i) (map #(conj %1 %2) multiples (map (partial * i) args)))\n       )))","user":"567b2f20e4b05957ce8c61a2"},{"code":"(fn lcm ([a b]\n                    (letfn [(gcd [a b]\n                                 (if (zero? b) a\n                                     (gcd b (rem a b))))]\n                                     (/ (* a b) (gcd a b))))\n        ([a b & rest] (reduce lcm (lcm a b) rest)))","problem":100,"user":"4e599577535d8a8b8723a29f"},{"code":"(fn lcm \n  ([a b]\n     (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n       (* (/ a (gcd a b)) b)))\n  ([a b & rest]\n     (apply lcm (lcm a b) rest)))","problem":100,"user":"4e52d815535d302ef430da77"},{"code":"(fn lcm [& nums]\n     (let [ index-of (fn [v l] (loop [i 0] (if (= (nth l i)\n                                                    v) i (recur (inc i)))) ) ; get the index of value v in sequence l. assume v is in l\n            lcm-help (fn [now-nums origin-nums]\n                        (if (apply = now-nums)\n                            (first now-nums)\n                            (let [min-value (apply min now-nums)\n                                  min-value-index (index-of min-value now-nums)\n                                  origin-val (nth origin-nums min-value-index)\n                                  new-val (+ min-value origin-val)\n                                  now-nums-vector (vec now-nums)\n                                  new-now-nums-vector (assoc now-nums-vector min-value-index new-val)\n                                  new-now-nums (seq new-now-nums-vector)]\n                              (recur new-now-nums origin-nums))\n                          ))]\n       (lcm-help nums nums)))","problem":100,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":100,"code":"(fn [& args]\n    (loop []\n     (letfn [(gcd[a b]\n                (if (= 0 b)\n                    a\n                    (gcd b (rem a b))))\n             (abs[n]\n                 (if (< n 0)\n                     (- n)\n                     n))]\n             (loop [lst args\n                    lcm (first lst)]\n                 (if (empty? lst)\n                     lcm\n                     (recur (rest lst) \n                            (/ (abs (* lcm (first lst))) \n                               (gcd lcm (first lst)))))))))","user":"5f77890ae4b02876ed9fd0b9"},{"problem":100,"code":"(fn lcm-multi [& sq] \n  (reduce \n    (fn lcm [x y] \n      (/ (* x y) \n         ((fn gcd [a b] \n            (if (= b 0)\n              a \n              (gcd b, (mod a b))\n              )) x y))\n      ) sq))","user":"580f9585e4b0f478707a05b5"},{"problem":100,"code":"(fn [& args]\n  (let\n      [gcd (fn gcd [a b]\n             (cond\n               (= a b) a\n               (> a b) (gcd (- a b) b)\n               :else (gcd a (- b a))))\n       lcm (fn lcm [a b]\n             (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"5b4b8cd6e4b02d533a91bc9f"},{"problem":100,"code":"(fn lcm [& ns]\n  (let [gcd (fn [a b]\n              (if (= 0 b)\n                a\n                (recur b (mod a b))))\n        lcm0 (fn [m n]\n               (/ (* m n) (gcd m n)))]\n    (reduce lcm0 ns)))","user":"57a49951e4b0a966079561e5"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y] \n               (let [a (max x y) \n                     b (min x y)\n                     m (mod a b)]\n                   (if (zero? m)\n                          b\n                          (recur b m))))\n           (lcm [a b]\n                 (/ (* a b) (gcd a b)))]\n      (reduce lcm args))\n  )","user":"580d7de3e4b0849f6811b73d"},{"code":"(fn [& lst]\r\n  (letfn ((prime-number? [m]\r\n                         (loop [d 2]\r\n                           (cond (= m d)\r\n                                 true\r\n                                 (= (mod m d) 0)\r\n                                 false\r\n                                 :else\r\n                                 (recur (+ d 1)))))\r\n          (sub [n]\r\n               (loop [i 2\r\n                      r {}]\r\n                 (cond (> i n)\r\n                       r\r\n                       (prime-number? i)\r\n                       (let [t (loop [m n\r\n                                      x 0]\r\n                                 (if (= (mod m i) 0)\r\n                                   (recur (/ m i) (+ x 1))\r\n                                   x))]\r\n                         (if (> t 0)\r\n                           (recur (+ i 1) (conj r [i t]))\r\n                           (recur (+ i 1) r)))\r\n                       :else\r\n                       (recur (+ i 1) r))))\r\n          (sub2 [l]\r\n                (apply * (map (fn [i]\r\n                                (if (= (type i) clojure.lang.Ratio)\r\n                                  (denominator i)\r\n                                  1))\r\n                              l)))\r\n          )\r\n         (let [d (sub2 lst)\r\n               l (map (fn [i]\r\n                        (if (= (type i) clojure.lang.Ratio)\r\n                          (* (numerator i) (/ d (denominator i)))\r\n                          (* i d)))\r\n                      lst)\r\n               i (map #(sub %) l)\r\n               j (reduce (fn [r i]\r\n                           (reduce (fn [r i]\r\n                                     (conj r (nth i 0)))\r\n                                   r\r\n                                   i))\r\n                         #{}\r\n                         i)\r\n               k (reduce (fn [r x]\r\n                           (* r (Math/round (Math/pow (x 0) (x 1)))))\r\n                         1\r\n                         (map (fn [j]\r\n                                [j\r\n                                 (apply max\r\n                                        (map (fn [i]\r\n                                               (let [k (find i j)]\r\n                                                 (if k\r\n                                                   (k 1)\r\n                                                   0)))\r\n                                             i))])\r\n                              j))]\r\n           (/ k d))))","problem":100,"user":"4de2f44f535d08e6dec9fdec"},{"problem":100,"code":"(fn [& xs*]\n  (loop [xs xs*]\n    (if (apply = xs)\n      (first xs)\n      (let [m (apply min xs)]\n        (recur (map #(if (= % m) (+ % %2) %)\n                    xs xs*))))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":100,"code":"(fn [& args]\n  (let \n    [f (fn gcd [a b] (if (not= 0 b) (gcd b (mod a b)) a))\n     gcd (reduce f args)]\n    \n    (/ (apply * args) gcd)\n    )\n  )","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn lcm [& nums]\n  (reduce\n    #(let [prod (* %1 %2)\n           g ((fn gcd [a b]\n                (if (< a b)\n                  (gcd b a)\n                  (if (= b 0)\n                    a\n                    (gcd b (rem a b))))) %1 %2)]\n      (/ prod g))\n    nums))","problem":100,"user":"526ee63de4b03e8d9a4a733f"},{"problem":100,"code":"#((fn lcm \n    [x y] \n    (if (= 1 (-> y distinct count)) \n      (y 0)\n      (lcm \n       x \n       (let [mval (apply min y) mind (.indexOf y mval)] \n         (assoc y mind (+ mval (x mind))))))) (vec %&) (vec %&))","user":"5463fbbde4b01be26fd746ca"},{"problem":100,"code":"(fn\n  [& rest]\n  (let [g (fn [x y]\n              (if (zero? y)\n                x\n                (recur y (rem x y))))]\n    (reduce #(/ (* % %2)\n                (g % %2)) rest)))","user":"55bf6dbce4b01b9910ae2a12"},{"code":"(fn [& args]\n  (let [ n (first args)\n         multiples (iterate #(+ n %) n) ]\n    (first\n      (filter \n        (fn [m] (every? zero? (map #(mod m %) args))) \n        multiples))))","problem":100,"user":"4ee3afde535d10e5ff6f5370"},{"problem":100,"code":"(fn [& args]\n  (letfn\n      [(gcd [x y]\n         (if (= x y)\n           x\n           (if (< x y)\n             (recur x (- y x))\n             (recur y (- x y)))))\n       (lcm [x y]\n         (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"5410499de4b01498b1a719a6"},{"code":"(fn [& xs]\n  (reduce\n   #(/ (* %1 %2)\n      (loop [a %1 b %2]\n        (cond\n         (= a b) a\n         (> a b) (recur (- a b) b)\n         :else (recur a (- b a)))))\n   xs))","problem":100,"user":"52ab51c4e4b0c58976d9ac73"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd [n1 n2]\n               (cond\n                (< n1 n2)  (recur n2 n1)\n                (zero? n2) n1\n                :else      (recur n2 (mod n1 n2))))]\n    \n    (let [denoms (map #(if (ratio? %) (denominator %) 1) \n                      nums)\n          denom  (reduce gcd denoms)\n          numer  (->> nums\n                      (map #(* denom %))\n                      (map #(if (ratio? %) (numerator %) %))\n                      (reduce #(* %1 %2 (/ (gcd %1 %2)))))]\n      (/ numer denom))))","problem":100,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [& x] (loop [i 1] (let [n (* (first x) i) ] (if (= 0 (apply + (map #(rem n %) x ))) n (recur (inc i))))))","problem":100,"user":"50ef3e5de4b0a78662fa2652"},{"problem":100,"code":";http://rosettacode.org/wiki/Least_common_multiple#Clojure\n(fn [& v]\n\t(let [gcd (fn [a b] \n             \t(if (zero? b)\n      \t\t\ta\n                (recur b, (mod a b))))]\n  \t\t(let [lcm (fn [a b] (/ (* a b) (gcd a b)))]\n        \t(reduce lcm v)\n       \t)\n  \t)\n)","user":"55757e81e4b05c286339e063"},{"code":"(fn [& xs]\n\t(let [gcd-fn (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n\t\t  lcm-fn #(* %2 (/ % (gcd-fn % %2)))]\n\t\t(reduce lcm-fn xs)))","problem":100,"user":"5125d963e4b05d10e3e395fe"},{"code":"(fn lcm\n  ([x y]\n     (letfn [(g [a b] (if (= b 0) a (g b (rem a b))))]\n       (/ (* x y) (g x y))))\n  ([x y & rest] (apply lcm (lcm x y) rest)))","problem":100,"user":"51181009e4b0e0897831a60f"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (let [a (max x y)\n                     b (min x y)\n                     m (mod a b)]\n                 (if (zero? m)\n                   b\n                   (gcd m b))))\n          (lcm [x y]\n               (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"57f52d3be4b0903ccab3dce7"},{"code":"(fn l [& x]\n  (let [p (apply * (map #(if (ratio? %) (denominator %) %)x))]\n    (apply min\n           (apply clojure.set/intersection\n                  (map #(set (range % (inc p) %)) x)))))","problem":100,"user":"4facd2fae4b081705acca22f"},{"code":"(fn [& more] \n     (loop [seq1 more seq2 more]\n      (if (= 1 (count (distinct seq1)))\n        (first seq1)\n      (recur \n        (map-indexed \n          #(if (= %2 (apply min seq1)) (+ %2 (nth seq2 %1)) %2) \n          seq1)  seq2\n       ) \n      )\n     )  \n      \n   )","problem":100,"user":"4ea31da2535d7eef308072c1"},{"problem":100,"code":"(fn [& more]\n   (loop [modif (apply vector  more)]\n     (let [minim (first (apply  min-key #(second %) (map vector (range) modif)))]\n       (if (= 1  (count (set modif)))\n         (first modif)\n         (recur (assoc modif minim (+ (nth more minim) (nth modif minim))))))))","user":"52503747e4b0541d1855b828"},{"code":"(fn [& r]\n  (let [min-i (fn [xs]\n                (apply min-key #(nth xs %) (range (count xs))))]\n    (loop [x (vec r)]\n      (if (apply = x)\n        (first x)\n        (let [i (min-i x)]\n          (recur (assoc x\n                        i\n                        (+ (nth x i)\n                           (nth r i)))))))))","problem":100,"user":"4e7dd982535db169f9c796ee"},{"code":"(fn [& l] (/ (reduce * l) (reduce (fn g [a b] (if (= b 0) a (g b (mod a b)))) l)))","problem":100,"user":"4df1ce44535d08e6dec9fe1f"},{"problem":100,"code":"(fn [& v]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b, (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm v)))","user":"566d71b1e4b0a866af6896ca"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (if (= x 0)\n              y\n              (gcd (mod y x) x)))\n          (lcm [x y]\n            (/ (* x y) (gcd x y)))]\n    (reduce #(lcm %1 %2) args)))","user":"57e10705e4b0bfb2137f5a6a"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (cond\n              (= 0 x) y\n              (= 0 y) x\n              :else (gcd y (mod x y))))]\n    (/ (apply * args) (reduce gcd args))))","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":100,"code":";; answer from online; couldnt' get this one\n(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    ))\n\n\n;  (fn [& nums]\n;    (/\n;      (reduce\n;        *\n;        nums)\n;      ; gcd, times out on fractions\n;    \t(reduce\n;        #(loop\n;           [i (max %1 %2)]\n;           (if\n;             (or\n;               (= 0 i)\n;               (and\n;                 (= 0 (mod %1 i))\n;                 (= 0 (mod %2 i))))\n;             i\n;             (recur (dec i))))\n;         nums))))","user":"58d2af83e4b03c36ff7e5907"},{"code":"(fn lcm [x y & r]\n  (let [z (first (filter #(= 0 (rem % x)) (iterate #(+ y %) y)))]\n    (if (seq r) (apply lcm z r) z)))","problem":100,"user":"4e50b67b535dc968683fc4ed"},{"problem":100,"code":"(fn [& xs]\n  (/ (apply * xs)\n    (reduce #(if (= 0 %2) % (recur %2 (mod % %2))) xs)))","user":"567c63f6e4b05957ce8c61bb"},{"problem":100,"code":"(fn [x y & more]\n  (letfn [(gcd [a b]\n            (if (zero? a) b (gcd (rem b a) a)))\n          (abs [x] (if (neg? x) (- 0 x) x))\n          (ls-cm-ml [a b]\n            (let [g (gcd a b)]\n              (* (/ (abs a) g) (abs b))))]\n    (reduce ls-cm-ml (ls-cm-ml x y) more)))","user":"5a512929e4b05d388ecb6be2"},{"problem":100,"code":"(fn [n & r]\n    (first \n      (filter \n        (fn [nm] \n          (every? #(= 0 (rem nm %)) r)\n        )\n        (iterate #(+ n %) n) \n      )\n    )\n  )","user":"59021fede4b0438e51c2d04d"},{"problem":100,"code":"(fn [& nums]\n(let [lcms (fn  [[f & n]]\n  (remove\n   (fn [i] (some (fn [coll] (= -1 (.indexOf (take-while #(<= % i ) coll) i))) n))\n   f\n   )\n  )]\n  (->> nums\n       (map (fn [n] (map (fn [i] (* (inc i) n)) (range))))\n       lcms\n       first\n  )\n  )\n)","user":"55e8a85be4b0121d4835fd98"},{"code":"(fn lcm [& xs]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ \n      (reduce * xs)\n      (reduce gcd xs))))","problem":100,"user":"4ee6400c535d93acb0a6685b"},{"problem":100,"code":"; this was before i knew about letfn, but hey, it works.\n(fn lcm4 [& args]\n  (let [gcd-fn\n        (fn gcd\n          ([n1 n2] (gcd n1 n2 1 1))\n          ([n1 n2 current greatest]\n           (if (or (> current n1) (> current n2)) greatest\n               (recur n1 n2 (inc current)\n                      (if (= 0 (rem n1 current) (rem n2 current))\n                        current greatest)))))\n        lcm-int-fn \n        #(reduce * (/ (first %&) (reduce gcd-fn %&)) (rest %&))\n        ns (map #(if (ratio? %) (numerator %) %) args)\n        ds (map #(if (ratio? %) (denominator %) 1) args)\n        lcm-ns (apply lcm-int-fn ns)\n        gcd-ds (reduce gcd-fn ds)]\n    (rationalize (/ lcm-ns gcd-ds))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn [& ns]\n    (letfn [(gcd-2 [a b]\n              (let [r (rem a b)]\n                (if (zero? r)\n                  b\n                  (gcd-2 b r))))\n            (gcd [& more] (reduce gcd-2 more))]\n      (/ (apply * ns) (apply gcd ns))))","problem":100,"user":"4db3393e535df7e46ed9b6cc"},{"code":"(fn [& xs]\n  (letfn [\n    (gcd [a b]\n      (cond (zero? b) a\n            (< a b) (recur b a)\n            :else (recur b (rem a b))))\n    (ngcd [a b & r]\n      (if (empty? r)\n        (gcd a b)\n        (apply ngcd (gcd a b) r)))]\n  (/ (apply * xs) (apply ngcd xs))))","problem":100,"user":"4f8345c6e4b033992c121c1b"},{"problem":100,"code":"(fn [& args]\n  (let [v (vec args)]\n    (loop [x v]\n      (if (apply == x) (first x)\n        (let [r (first (sort x))]\n          (recur (map-indexed #(if (= %2 r) (+ %2 (v %1)) %2) x)))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gdc (fn [a b]\n              (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gdc args))))","user":"54ae541ae4b09f271ff37cef"},{"problem":100,"code":"(fn lcm ([a b] (let [gcd ((fn f [x y] (if (= x y) x (if (< x y) (f (- y x) x) (f y x)))) a b)] (/ (* a b) gcd))) ([a b & c] (apply lcm (lcm a b) c)))","user":"576df252e4b0979f8965156f"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [streams (map (fn [n] (map (partial * n) (iterate inc 1))) args)]\n    (if (apply == (map first streams))\n      (ffirst streams)\n      (let [lim (apply max (map first streams))]\n          (recur (map (partial drop-while (partial > lim)) streams))))))","user":"524e79c1e4b0541d1855b7e0"},{"problem":100,"code":"(fn [& params]\n  (letfn [(gcd [a b]\n              (cond\n               (> a b) (gcd (- a b) b)\n               (< a b) (gcd b (- b a))\n               :else a))\n         (lcm [a b]\n              (/ (* a b) (gcd a b)))]\n  (reduce lcm params)\n  ))","user":"4f88ae35e4b033992c121c6d"},{"problem":100,"code":"(fn lcm [& args]\n      (let [gcd (fn [a b]\n                   (if (zero? b)\n                     a\n                     (recur b (mod a b))))]\n        (/ (reduce * args) (reduce gcd args))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":100,"code":"(fn lcm [& numbers]\n  (let [max-num (apply max numbers)]\n    (loop [possible-lcm max-num]\n      (if (every? #(zero? (mod possible-lcm %)) numbers)\n        possible-lcm\n        (recur (+ possible-lcm max-num))))))","user":"5d49ec5ee4b0776584bd6f1c"},{"problem":100,"code":"(fn my-lcm [& args ]\n    (reduce (fn [num1 num2] \n       (* (/ num1\n           ((fn [num1 num2]\n              (cond\n                (= num2 0) num1\n                (= num1 0) num2\n                (> num1 num2) (recur num2 (mod num1 num2))\n                :else (recur num1 (mod num2 num1)))) num1 num2)) num2)) args))","user":"59dd387be4b0a0ac046f2502"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] \n            (if (< a b)\n              (recur b a)\n              (if (zero? b) a (recur b (mod a b)))))]\n    (reduce (fn [a b] (/ ( * a b) (gcd a b))) args)))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b]\n              (let [r (mod a b)]\n                (if (zero? r)\n                  b\n                  (recur b r))))\n        lcm #(/ (* %1 %2) (gcd %1 %2))]\n    (reduce lcm args)))","user":"56669819e4b0e91d5f5c5674"},{"problem":100,"code":"(fn [h & rst] (loop [lcm h]\n                (if (every? identity (for [n rst] (let [y (/ lcm n)] (= y (int y)))))\n                  lcm\n                  (recur (+ h lcm)))))","user":"58225587e4b04b46fc4b0f94"},{"problem":100,"code":"(fn [& coll]\n  (reduce (fn lcm \n            ([x1 x2] (lcm x1 x2 x1))\n            ([x1 x2 accum] (if (= 0 (mod x1 x2))\n                                x1\n                                (lcm (+ x1 accum) x2 accum)))) coll))","user":"5759cd46e4b02ea11479932e"},{"problem":100,"code":"(fn [& nums]\n  (let [mult (apply min nums)]\n  \t(loop [m mult]\n    \t(if\n          (every? #(= 0 (rem m %)) nums)\n      \t  m\n      \t  (recur (+ m mult))))))","user":"5da975b9e4b000c986472c32"},{"problem":100,"code":"(fn LCM\n  ([a b]\n   (loop [acc [a b]\n          ori-a a\n          ori-b b]\n     (if (apply = acc)\n      (first acc)\n      (if (apply > acc)\n        (recur [(first acc) (+ (second acc) ori-b)] ori-a ori-b)\n        (recur [(+ (first acc) ori-a) (second acc)] ori-a ori-b)))))\n  ([a b & c]\n   (apply LCM (cons (LCM a b) c))))","user":"5f38eecce4b0574c87022c72"},{"code":"(fn [n & r]\n    (first (filter (fn [nm] (every? #(= 0 (rem nm %)) r))\n                   (iterate #(+ n %) n) )))","problem":100,"user":"4ff67852e4b0678c553fc37e"},{"problem":100,"code":"(fn [& s1]  \n  (let [m (apply max s1)]\n      (loop [acc m]\n         (if (= 0 (count (filter #(not= 0 (rem acc %)) s1))) \n             acc \n             (recur (+ acc m))))))","user":"56483f45e4b0284900eef62b"},{"code":"(fn [& l]\n  (letfn\n    [(gcd [x y]\n          (if\n            (= x y)\n            x\n            (if\n              (< x y)\n              (recur x (- y x))\n              (recur y (- x y)))))\n     (lcm [x y]\n          (/ (* x y) (gcd x y)))]\n    (reduce lcm l)))","problem":100,"user":"5349ac2be4b084c2834f4a67"},{"problem":100,"code":"(fn [& r] \n  (let [a \n        (fn [m n] \n          (if (every? true?\n               (map #(zero? (rem m %)) r))\n             m\n             (recur (+ m n) n)))]\n  (a (apply max r) (apply max r))))","user":"53572176e4b04ce2eb3ed276"},{"problem":100,"code":"#(reduce (fn [x y]\n            (/ (* x y) ((fn [a b]\n                          (if (= (mod a b) 0)\n                            b\n                            (recur b (mod a b)))) x y))) %&)","user":"570362ece4b08d47c97781f0"},{"problem":100,"code":"(fn lcm\n  [& others]\n  (let [[a b] (take 2 others)\n        cur-lcm (/ (* a b)\n     ((fn gcd [& nums]\n        (let [[y x] (sort nums)\n              r (rem x y)]\n          (if (zero? r) y (recur [y r])))) a b))]\n    (if (< (count others) 3)\n      cur-lcm\n      (recur (cons cur-lcm (drop 2 others))))))","user":"55ede35ce4b0121d4835fde1"},{"problem":100,"code":";(\n (fn [& nums]\n  (letfn ((gcd\n            [a b]\n            (loop\n              [re a\n               qu b]\n              (if\n                (= qu 0)\n                re\n                (recur\n                 qu\n                 (rem re qu))))))\n    (/ \n     (reduce * nums)\n     (reduce gcd nums))))\n    ;)) 2 3 5 4 7)","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn lcm [n & coll]\r\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\r\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) n coll)))","problem":100,"user":"4dd7d040535d2dad7130b5d6"},{"problem":100,"code":"(fn [ & args]\n     \n     (let [\n           highest-multiple 300\n           create-mulitple-set-until (fn [ mult ]\n                                          (set (map #(* mult %) (range 1 (/ (+ highest-multiple mult) mult))))\n                                       )\n           all-sets (map create-mulitple-set-until args)\n           all-sets-contain (fn [val] (reduce #(if \n                                                 (not %1) \n                                                 false\n                                                \n                                                (contains? %2 val)) true all-sets))\n           intersect-set (reduce #(clojure.set/intersection %1 %2) all-sets)\n           ]\n       (apply min intersect-set )\n       )\n\n     \n     )","user":"53c73e8ae4b00fb29b2212a5"},{"problem":100,"code":"(fn [& s] (let [gcd #(first (filter (fn [a] (every? integer? (map (fn [b] (/ b a)) %&))) (reverse (range 1 (inc (apply min %&))))))\n                nums (map #(if (ratio? %) (numerator %) %) s)\n                num-prod (reduce * nums)\n                denoms (map #(if (ratio? %) (denominator %) 1) s)]\n           (/ (/ num-prod (apply gcd (map #(/ % %2) (repeat num-prod) nums)))\n              (apply gcd denoms))))","user":"5f03ab5be4b0cf489e8d7f37"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (= b 0)\n                       a\n                       (recur b (mod a b))))\n          (lcm ([a b]\n                (* b (/ a (gcd a b))))\n               ([a b & more]\n                (loop [nums more\n                       last-lcm (lcm a b)]\n                  (if (empty? nums)\n                    last-lcm\n                    (recur (rest nums)\n                           (lcm last-lcm (first nums)))))\n                       ))]\n    (apply lcm args)\n  )\n)","user":"5d07989ee4b0cc9c915881fb"},{"problem":100,"code":"(fn [h & r]\n  (loop [i h]\n    (println i h)\n    (if (some #(not (zero? (mod i %))) r)\n      (recur (+ i h))\n      i)))","user":"54ef4a1ee4b024c67c0cf883"},{"code":"(fn [& n]\n\t(/ (apply * n)\n\t   (/ 1 (let [d (reduce #(if (ratio? %2)\n\t\t      (* %1 (denominator %2))\n\t\t      (* %1 1)) 1 n)]\n\t\t  (if (even? d) (quot d 2) d)))))","problem":100,"user":"4e8849c5535d8b9bb0147ca4"},{"problem":100,"code":"(fn lcm [& nums]\n  (loop [integers-map (zipmap nums nums)]\n        (if (apply = (vals integers-map))\n            (first (vals integers-map))\n            (let [[k v] (reduce #(if (< (last %2) (last %1)) %2 %1) integers-map)]\n                 (recur (assoc integers-map k (+ v k)))))))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":100,"code":"(fn [& args]\n  (let [s (into #{} args)\n        biggest (first (sort > args))\n        multiples (map #(* biggest %) (iterate inc 1))\n        others (disj s biggest)\n        divisible? (fn [n]\n                     (every? #(= 0 (mod n %)) others))]\n    (first (filter divisible? multiples))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":100,"code":";\n; Gross code\n; My brain is tired\n;\n(fn lcm\n  [& args]\n  (apply min\n         (apply clojure.set/intersection\n                (map (fn [x] (into #{} (take 1000 (map #(* x %) (drop 1 (range)))))) args))))\n\n;\n; cgrand's solution is so beautiful\n;\n\n#_(fn [n & ns]\n  (first\n    (for [m (next (range))\n          :let [n (* n m)]\n          :when (every? #(zero? (mod n %)) ns)] n)))","user":"594266cfe4b060784b3b790b"},{"problem":100,"code":";; LCM(a, b, c) = LCM(LCM(a, b), c)\n(fn lcm2 [& args] (let [gcd (fn pgcd [a b] (let [r (rem a b)] (if (= 0 r) b (pgcd b r))))\n                        lcm (fn [a b] (->> (gcd a b) (/ a) (* b)))] \n                    (if (= 2 (count args))\n                      (apply lcm args)\n                      (lcm (apply lcm2 (butlast args)) (last args)))))","user":"5a5894d9e4b05d388ecb6c81"},{"problem":100,"code":"(fn lcm [& coll]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        lcm2 (fn [a b]\n               (/ (* a b)\n                  (gcd a b)))]\n    (reduce lcm2 coll)))","user":"5264383be4b03e8d9a4a70cb"},{"problem":100,"code":"(fn [& xs] (reduce (fn [x y] (first (drop-while #(not (zero? (rem % x))) (map (partial * y) (rest (range)))))) xs))","user":"57e6997ee4b0bfb2137f5af0"},{"code":"(fn [x & v] \n  (first \n    (filter(fn[y](every? #(= 0(mod y %))v))(map #(* x (inc %))(range)))))","problem":100,"user":"4eb2eae5535d7eef30807351"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd [a b]\n      (cond (< a b) (recur b a)\n            (zero? b) a\n            :else (recur b (rem a b)))\n    )]\n    (/ (apply * nums)\n       (reduce gcd nums))))","problem":100,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":100,"code":"(fn frcn-lcm\n  [& args]\n  (let [fds (map (fn [frcn]\n                   (let [x (clojure.string/split (str frcn) #\"/\")\n                         x (if (= 2 (count x)) x (conj x \"1\"))]\n                     [(Integer/parseInt (first x)) (Integer/parseInt (second x))])) args)]\n    (letfn [(gcd [x y]\n              (if (zero? (mod x y))\n                y (gcd y (mod x y))))\n            (lcm [x y]\n              (/ (* x y) (gcd x y)))]\n      (/ (reduce #(lcm %1 %2) (map first fds))\n         (reduce #(gcd %1 %2) (map second fds))))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":100,"code":"(fn [& nums]\n  (let [largest (apply max nums)\n        smallest (apply min nums)]\n    (loop [m largest]\n      (if (every? true? (map (fn [x] (= (mod m x) 0)) nums))\n        m\n        (recur (+ m largest))))))","user":"56ee0691e4b04a395b9a044c"},{"problem":100,"code":"(fn lr [a & [b & c]]\n  (letfn [(g [a b] (if (zero? b) a (g b, (mod a b))))\n          (l [a b]\n            (/ (* a b) (g a b))\n          )]\n    (if (empty? c)\n      (l a b)\n      (let [b (apply lr b c)]\n        (l a b)\n      )\n    )\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn lcm [& nums]\n  (let [g (fn gcd [a b]\n              (if (= 0 b) a\n                  (gcd b (mod a b))))]\n    (reduce #(/ (* % %2) (g % %2)) nums))\n  )","problem":100,"user":"502bb7c0e4b0194ad32ea1a3"},{"code":"(fn [a b & more]\n  (let [gcd (fn [x y]\n              (loop [a x\n                     b y]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b)))))\n        lcd #(/ (* %1 %2) (gcd %1 %2))]\n        (if (empty? more)\n          (lcd a b)\n          (recur (lcd a b) (first more) (rest more)))))","problem":100,"user":"5361a4f2e4b0243289761e47"},{"problem":100,"code":"(fn lcm [ & args]\n  (apply min\n    (reduce clojure.set/intersection\n      (for [x args\n           :let [y (set (map #(* x %) (range 1 500)))]]\n       y))))","user":"5cb4e764e4b026601754b929"},{"code":"(fn [& more]\n  (letfn [(into-table [s]\n                      ;; key = original number, value = its multiple\n                      (zipmap s s))\n          (key-of-min-val [m]\n                          (first \n                            (reduce \n                              (fn [acc item]\n                                (if (< (second acc) (second item))\n                                  acc item))\n                              m)))\n          (lcm [tbl]\n                 (if (== 1 (count (into #{} (vals tbl)))) \n                   (first (vals tbl))\n                   (let [key-of-min (key-of-min-val tbl)]\n                     (recur (update-in tbl [key-of-min] + key-of-min) )) ))\n          ]\n         (lcm  (into-table more) ))\n  )","problem":100,"user":"4dca8b6d535d5973398f9288"},{"problem":100,"code":"(fn lcm\n  [& numbers]\n  (let [gcd (fn gcd [x y] (cond (== x y) x (> x y) (gcd (- x y) y) :else (gcd x (- y x))))] \n  (/ (reduce * numbers)\n     (reduce gcd numbers))))","user":"56912f93e4b0dcc4269f40ef"},{"code":"(fn [x & xs]\n  (let [multiples (map (partial * x) (rest (range)))]\n    (first\n     (filter #(every? \n               (fn [y] (zero? (mod % y)))\n               xs)\n             multiples))))","problem":100,"user":"4fa340b4e4b081705acca18c"},{"problem":100,"code":"(fn lcm\n  ([a b] \n      (let [a-seq (iterate (partial + a) a)\n            b-seq (iterate (partial + b) b)]\n          (first (filter (fn [x] (= x (first (drop-while #(< % x) a-seq)))) b-seq))\n          ))\n  ([a b c] (lcm a (lcm b c)))\n  ([a b c d] (lcm (lcm a b) (lcm c d))))","user":"58fc52cee4b0438e51c2cf95"},{"code":"(fn lcm [& more]\r\n  (letfn [(gcd [a b]\r\n            (if (= b 0) a\r\n                (recur b (rem a b))))]\r\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) more)))","problem":100,"user":"4ddb339c535d02782fcbe9f9"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [preds (map (fn [n] #(= 0 (mod % n))) nums)]\n    (+ (apply max nums) (last (take-while (fn [n] (some false? (map #(% n) preds))) (rest (map (partial * (apply max nums)) (range))))))))","user":"5b7f2d75e4b047b03b203768"},{"problem":100,"code":"(fn lcm [& ns]\n   (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))\n         gcdx (fn gcdm [[a & [b & r]]]\n                (cond\n                  (nil? b) a\n                  :default (gcdm (conj r (gcd a b)))))]\n     (/ (apply * ns) (gcdx ns))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":100,"code":"(fn lcm [& lst]\n  (letfn [(multiples ([x]\t   (multiples x x))\n  \t\t\t\t  \t ([x base] (cons x (lazy-seq (multiples (+ x base) base)))))]\n  \t(let [    \n      list-product      (apply * (map #(if (ratio? %) (numerator %) %) lst))\n      multiples-lzseq   (map multiples lst)\n      multiples-lst     (map #(take-while (fn [x] (<= x list-product)) %) multiples-lzseq)\n      common-multiples  (apply clojure.set/intersection  (map set multiples-lst))\n      ] \n      (apply min common-multiples)\n)))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":100,"code":"(fn [& xs] \n  ((fn [ys] (let [values (map second ys)\n                  ss (sort-by second < ys)\n                  sr (rest ss)\n                  [k v] (first ss)\n                  x (list k (+ k v))] \n              (if (apply = values) \n                v\n                (recur (cons x sr)))\n              )) \n   (map list xs xs)))","user":"5fa17538e4b0f0ebd91b77e3"},{"code":"(fn [ & coll]\n  (let [gcd (fn [a b] (if (zero? a) b (recur (mod b a) a)))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) coll)))","problem":100,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm1 [a b]\n            (if b\n              (*' (/ a\n                     (gcd a b))\n                  b)\n              a))]\n    (let [[a b & c] args\n          lcm1 (lcm1 a b)]\n      (if c\n        (recur (cons lcm1 c))\n        lcm1))))","user":"56dc3bdfe4b0ea9b8538f819"},{"problem":100,"code":"(fn [& args]\n  (let [gcd #(if (= 0 %2) %1 (recur %2 (mod %1 %2)))]\n  \t(reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5e3e23d9e4b01d43a70e8e20"},{"code":"(fn [& nums]\n  (letfn [(multiples [x]\n            (iterate #(+ x %) x))\n\n          (has? [coll target]\n            (cond\n             (nil? coll) false\n             (= (first coll) target) true\n             (> (first coll) target) false\n             :else (recur (next coll) target)))\n\n          (common-multiples [x & ys]\n            (filter (fn [mul]\n                      (every? (fn [mul-seq]\n                                (has? (multiples mul-seq) mul)) ys))\n                    (multiples x)))]\n    (first (apply common-multiples nums))))","problem":100,"user":"4e6a4954535d8ccf87e9fec0"},{"code":"(letfn [(gcd [& args]\n             (reduce (fn [a b]\n                       (if (zero? b)\n                         a\n                         (recur b (mod a b))))\n                     args))]\n  (fn [& args]\n    (/ (apply * args) (apply gcd args))))","problem":100,"user":"51789dfae4b03d69594194d7"},{"code":"(fn prob-0100 [& xs]\n  (let [mx (apply max xs)]\n    (first\n      (for [lcm (range 1 Double/POSITIVE_INFINITY)\n            :let [prod (* mx lcm)]\n            :when (every? zero?\n              (map #(rem prod %) xs)) \n           ]\n        prod))))","problem":100,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn [& ns]\n  (let [mx (apply max ns) mn (apply min ns)]\n    (loop [i (* mn (int (/ mx mn)))]\n      (if (every? #(zero? (rem i %)) ns)\n        i\n        (recur (+ i mn))))))","problem":100,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":100,"code":"(fn least[& lst]\n  (loop [i 1]\n  (if (every? (fn[a] (if(zero? (rem i a)) true false)) lst) i (recur (+ i 1/2)) )))","user":"57fc08d8e4b0d3187e900988"},{"problem":100,"code":"(fn [& xs] (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))\n                   (lcm [a b] (/ (* a b) (gcd a b)))]\n            (reduce lcm xs)))","user":"592ac17ae4b072a2710fcf26"},{"problem":100,"code":"(fn [num & more]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (gcd b (mod a b)))) \n          (lcm [a b]  \n            (/ (* a b) (gcd a b)))]\n    (if (empty? more) \n      num \n      (recur (lcm num (first more)) (rest more)))))","user":"4dbf7a31535d020aff1edf75"},{"problem":100,"code":"(fn [n1 n2 & others]\n  (letfn [(lcm [n1 n2] (first (filter #(= 0 (rem % n2))\n                                      (iterate (partial + n1) n1))))]\n    (reduce #(lcm %1 %2) (lcm n1 n2) others)))","user":"532902f8e4b09d4e7a9b550e"},{"code":"(fn mcm [& vec] (reduce #(/ (* %1 %2) (loop [a %1 b %2] (if (= 0 b) a (recur b (mod a b))))) vec))","problem":100,"user":"4e9de526535dbda64a6f6b8e"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (/ (* x y) ((fn gcd [a b] (cond (= b 0) a \n                                   (= a 0) b \n                                   (> a b) \n                                   (gcd b (mod a b))\n                                   (> b a) (gcd a (mod b a))))\n               x y)))\n  ([x y & args]\n   (apply lcm (lcm x y) args)))","user":"5b857411e4b047b03b2037ce"},{"code":"(fn lcm\n  ([x y]\n      (/ (* x y)\n\t ((fn gcd [a b]\n\t      (if (> b a) (gcd b a)\n\t\t(if (= b 0)\n\t\t    a\n\t\t  (recur b (rem a b))))) x y)))\n  ([x y & s]\n      (reduce (fn [c e] (lcm c e)) (lcm x y) s)))","problem":100,"user":"5101192ae4b0bef64c30e266"},{"problem":100,"code":"(fn [& n]\n  (letfn [(sol_66 [a b]\n               (if (= b 0)\n                 a\n                 (recur b (mod a b))))\n          \n          (lcm [a b]\n               (/ (* a b) (sol_66 a b)))]\n    (reduce lcm n)))","user":"5f810e97e4b0c071e6c840ed"},{"code":"(fn lcm [& args]\n  (let [f (fn g [s m]\n            (if (every? #(= 0 (rem m %)) s)\n              m\n              (g s (+ m (first s)))))]\n    (f (seq args) (first (seq args)))))","problem":100,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [& args] \n    (/ (reduce * args) (reduce (fn gcd [m n]\n\t  (if (= 0 (rem m n)) n\n\t      (gcd n (rem m n)))) args)))","problem":100,"user":"5213ffd3e4b0961f15ac4d7d"},{"code":"(fn [& x]\n  (letfn [(gcd [[m n]] (if (zero? n) m (gcd [n (mod m n)])))\n          (lcm [[m n]] (/ (* m n) (gcd [m n])))]\n    (loop [a (take 2 (sort > x)) b (drop 2 (sort > x))]\n      (if (empty? b)\n        (lcm a)\n        (recur [(lcm a) (first b)] (drop 1 b))))))","problem":100,"user":"4f9f7daae4b0dcca54ed6d37"},{"code":"(fn [& nums]\n  (letfn [(gcd\n            ([n m] (if (zero? n) m (recur (rem m n) n)))\n            ([n m & more] (reduce gcd (gcd n m) more)))\n          (lcm\n            ([n m] (->> (gcd n m) (/ n) (* m))) \n            ([n m & more] (reduce lcm (lcm n m) more)))]\n    (apply lcm nums)))","problem":100,"user":"4daec9dcedd6309eace4d15f"},{"code":"(fn [& v] \n  (reduce \n      (fn [u v] \n        (let [d1 (if (ratio? u) (denominator u) 1)\n              n1 (if (ratio? u) (numerator u) u)\n              d2 (if (ratio? v) (denominator v) 1)\n              n2 (if (ratio? v) (numerator v) v)\n              gcd (fn g [a b]\n                    (if (= 0 b) \n                      a\n                      (if (< a b)\n                        (g b a)\n                        (g b (mod a b)))))]\n          (/ (* n1 n2) (gcd d1 d2))))\n  v))","problem":100,"user":"536b2048e4b0243289761eb7"},{"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b) a\n                (recur b (rem a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"4f0c4518535d0136e6c2230b"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [m 10]\n    (if (empty? (into [] (apply clojure.set/intersection (map #((fn first [a b]\n  (loop [c 1 d #{}]\n    (if (> c a) d\n      (recur (inc c) (conj d (* c b)))))) (apply max (concat [m] args)) %) args)))) (recur (*' 10 m))\n                (first (sort-by identity (into [] (apply clojure.set/intersection (map #((fn first [a b]\n  (loop [c 1 d #{}]\n    (if (> c a) d\n      (recur (inc c) (conj d (* c b)))))) (apply max (concat [m] args)) %) args))))))))","user":"558378dce4b05c286339e115"},{"code":"(fn [& items]\n  (loop [items (map #(vector % %) items)] (println items)\n    (if (apply = (map first items))\n      (ffirst items)\n      (recur (apply (fn [top & others] (cons (vector (+ (first top) (second top)) (second top)) others)) (sort items))))))","problem":100,"user":"4e98a6d0535dbda64a6f6b5e"},{"problem":100,"code":"(fn [& n] (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))] (/ (reduce * n) (reduce gcd n))))","user":"58ad4349e4b0ebc645576c9d"},{"code":"(fn [& nums]\n  (reduce (fn \n            [a b]\n            (/\n             (* a b)\n             (loop [a a\n                    b b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b)))))) nums))","problem":100,"user":"523288fee4b035af41902a88"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (letfn [(safe-numerator [a] (if (= clojure.lang.Ratio (type a)) (numerator a) a))\n           (safe-denominator [a] (if (= clojure.lang.Ratio (type a)) (denominator a) 1))\n           (div [x y d]\n             (if (and (= 0 (mod x d))\n                      (= 0 (mod y d))) d 1))\n           (gcd [a b]\n                (apply max\n                       (map #(div a b %) (range 1 (inc a)))))]\n     (if (or (= clojure.lang.Ratio (type a)) (= clojure.lang.Ratio (type b)))\n       (/ (lcm (safe-numerator a) (safe-numerator b)) (gcd (safe-denominator a) (safe-denominator b)))\n       (/ (* a b) (gcd a b)))))\n  ([a b & l]\n   (apply lcm (lcm a b) l)))","user":"583048d9e4b051871117c007"},{"problem":100,"code":"(fn [& v]\n  (letfn [(gcd [a b]\n          (if (= b 0)\n            a\n            (recur b (mod a b))))]\n    (/ (apply * v) (reduce gcd v))))","user":"4f4aa932e4b0d56e7bb92c14"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))\n          (gcm [a b]\n               (/ (* a b) (gcd a b)))\n          ]\n    (reduce gcm args)\n  ))","user":"53e92f82e4b036ad0777e49d"},{"problem":100,"code":"(fn [& args]\n  (let [[x & xs] (reverse (sort args))\n        are-divisors? (fn [n] (zero? (reduce #(+ %1 (mod n %2)) 0 xs)))]\n    (->> (iterate (partial + x) x)\n         (filter are-divisors?)\n         first)))","user":"54a6645be4b09f271ff37c87"},{"problem":100,"code":"(fn [& vars] (loop [cnt 1\n                    rslt (apply min vars)]\n               (if (apply (partial = 0) (map (partial mod rslt) vars))\n                 rslt\n                 (recur (inc cnt) (* cnt (apply min vars))))))","user":"5b4c2212e4b02d533a91bca6"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? b) a, (recur b (mod a b))))]\n    (/ (apply * args) (reduce gcd args))))","problem":100,"user":"52039e12e4b0fb7e47ea51ff"},{"problem":100,"code":"(fn\n  [num1 & args]\n  (first \n   (drop-while \n          #(some \n            (fn \n              [nums] (not= 0 (mod % nums))) args) (iterate (partial + num1) num1))))","user":"5dd25ca8e4b0948ae9d9ad55"},{"problem":100,"code":"(fn [& ns]\n  (reduce (fn [a b]\n            (/ (* a b)\n               ((fn [a b]\n                  (if (= 0 b) a (recur b (rem a b))))\n               a b)))\n          ns))","user":"5ccf2dc3e4b0ccb0619628c2"},{"problem":100,"code":"(fn [& xs] \n     (let [gcd (fn gcd [a, b]\n                   (cond\n                     (zero? b) a\n                     :else (gcd b (mod a b))))]\n                   (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"5409a12fe4b0addc1aec66df"},{"problem":100,"code":"#(reduce (fn [a b]\n           ((fn lcm [current]\n              (if (= (mod current b) 0)\n                current\n                (lcm (+ current a))))\n            a))\n         %&)","user":"53acaf1fe4b047364c04445f"},{"code":"(fn [& n] (reduce #(/ (* %1 %2) (loop [a %1 b %2] (if (= 0 b) a (recur b (mod a b))))) n))","problem":100,"user":"52b453b0e4b0c58976d9ad21"},{"problem":100,"code":"(fn least-common-multiplier\n  [& xs]\n  (letfn [(gcd [x y]\n            (if (zero? (mod x y))\n              y\n              (gcd y (mod x y))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"52561295e4b0541d1855ba03"},{"problem":100,"code":"#(reduce (fn [a b] (/ (* a b) (loop [x a y b] (if (zero? y) x (recur y (mod x y)))))) %&)","user":"56a37ccee4b0542e1f8d14cb"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd #(if (zero? %2) % (recur %2 (mod % %2)))\n        lcm #(/ (* % %2) (gcd % %2))]\n    (reduce lcm nums)))","user":"55380eeae4b09218d5f44fd9"},{"code":"(fn [& c]\n  (let [c (vec c)]\n    (loop [v c]\n      (let [m (apply min v)\n            i (ffirst (filter #(= (second %) m)\n                              (map-indexed (fn [i o] [i o]) v)))]\n        (if (every? #(= m %) v)\n          m\n          (recur (assoc v i (+ m (c i)))))))))","problem":100,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn b [m & mm]\n  (letfn [(l [m1 mm1] (loop [n1 m1 nn1 mm1] (if (= nn1 0) n1 (recur nn1 (mod n1 nn1)))))]\n    (let [r (loop [n1 m nn1 mm]\n              (if (empty? nn1) n1\n                (recur (l n1 (first nn1)) (rest nn1))))]\n      (* (/ m r) (reduce * mm)))))","problem":100,"user":"4fe97adde4b0547ebccb245e"},{"problem":100,"code":"(fn [& x] \n  (reduce #(/ \n         (* % %2) \n         (\n          (fn g [a b] \n            (if (= b 0) \n              a \n              (g b (mod a b))))\n         % %2)) x))","user":"5a625bc2e4b0512ff01cd989"},{"code":"(fn [& xs]\n   ((fn _self [xs original]\n      (if (apply = xs)\n        (first xs)\n        (let [[min-index min-value] (->> xs\n                              (map-indexed vector)\n                              (apply min-key second))]\n          (_self (concat \n                  (take min-index xs) \n                  (list (+ min-value (nth original min-index)))\n                  (take-last (- (count xs) (inc min-index)) xs)) original)\n          ))) xs xs))","problem":100,"user":"531490bde4b08068f379ed17"},{"problem":100,"code":"; Least Common Multiple, of two integers a and b, usually denoted by LCM(a, b), \n; is the smallest positive integer that is divisible by both a and b.\n\n; start with multpile of a and b\n; (fn [a b] (* a b))\n\n; simple algorithm that takes the smallest of multiples limiting the range based on the numbers\n;(fn [a b]\n;   (first (sort (clojure.set/intersection \n;                  (set (map * (repeat b a) (range 1 (+ 1 b))))\n;                  (set (map * (repeat a b) (range 1 (+ 1 a)))))))) \n\n; move to taking multiple numbers - doesn't handle fractions\n;(fn [& nums] (reduce * nums))\n\n; Reduction by the greatest common divisor (gcd)\n; not sure the recurring call to lcm is stack friendly\n(fn lcm\n   ([x y] (/ (* x y) ((fn gcd [a b]\n                        (cond\n                          (zero? b) a\n                          (zero? a) b\n                          (> a b) (recur b (mod a b))\n                          (> b a) (recur a (mod b a)))) x y)))\n   ([x y & rest] (apply lcm (lcm x y) rest)))","user":"57c44053e4b05aa3c4741ccb"},{"code":"(fn [& a] (let [n (apply min a) p (range n Integer/MAX_VALUE n)] (first (drop-while #(some (fn [x] (not= 0 x)) (map (partial mod %) a)) p))))","problem":100,"user":"52b5edd1e4b0c58976d9ad3c"},{"problem":100,"code":"(fn lcm [a & b] (first (drop-while\n                           (fn [s] (not-every? #(zero? (mod s %)) b))\n                           (iterate (partial + a) a))))","user":"57f81569e4b0d3187e900919"},{"problem":100,"code":"(fn lcm([a b](letfn[(gcd [a b](if (zero? b) a (gcd b (mod a b))))](/ (* a b) (gcd a b))))\n([a b & c](reduce lcm (lcm a b) c)))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y]\n              (if (= y 0)\n                x\n                (recur y (mod x y))))\n        lcm (fn [a b]\n              (* (quot a (gcd a b)) b))]\n    (reduce lcm args)))","user":"55151417e4b055c2f668d4da"},{"problem":100,"code":"(fn lcm [& col]\n  (loop [lowest (apply max col),\n         acc lowest, col col]\n    (cond\n      (reduce #(and %1 (= 0 (mod acc %2))) true col) acc\n      :else (recur lowest (+ lowest acc) col))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":100,"code":"(letfn [(gcd2 [a b]\n            (if (= 0 b)\n              a\n              (let [t1 b t2 (mod a b)]\n                (gcd2 t1 t2))))\n          (gcd\n           ([a] a)\n           ([a & args]\n            (gcd2 a (apply gcd args))))]\n    (fn [& args]\n      (/ (reduce * args)\n         (apply gcd args))))","user":"56eaad95e4b04a395b9a040f"},{"problem":100,"code":"(fn [ & xs]\n  (reduce\n    (fn LCM [a b]\n      (let [e (* a b)\n            f ((fn GCD [c d]\n                (loop [x (max c d) y (min c d)]\n                  (if (zero? y)\n                    x\n                    (recur y (mod x y))))) a b)]\n        (/ e f))\n    ) xs ))","user":"525b4e8de4b0cb4875a45d0f"},{"problem":100,"code":"(fn [ & xs ]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":100,"code":"(fn lcm [& values]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (recur b (mod a b))))\n          (lcm2 [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm2 values)))","user":"5b1d61b3e4b03cfeda66ecfe"},{"problem":100,"code":"(fn lcm\n  [& xs]\n  (letfn [(gcd [a b]\n          (if (= b 0) a (gcd b (mod a b))))\n          (lcm-2 [x y]\n            (/ (* x y) (gcd x y)))]\n    (reduce lcm-2 xs)))","user":"5c222b7de4b07e362c230588"},{"problem":100,"code":"(fn [& as]\n     (letfn [(gcd [x y]\n                  (let [a (max x y)\n                        b (min x y)\n                        c (mod a b)]\n                      (if (zero? c)\n                          b\n                          (recur b c))))\n             (lcm [x y]\n                  (/ (* x y) (gcd x y)))]\n            (reduce lcm as)))","user":"59bac5c9e4b0a024fb6ae3ed"},{"problem":100,"code":"(fn [& x] (/ (apply * x) (reduce #(if (= %2 0) %1 (recur %2 (mod %1 %2))) x)))","user":"5b22d30ee4b08b1df1c36750"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [multiples (fn [n] (iterate #(+ n %) n))\n        lcm'      (fn [mults]\n                   (let [smallest (apply min (map first mults))]\n                    (if (apply = (map first mults))\n                        (first (first mults))\n                        (recur (map #(if (= smallest (first %)) (rest %) %) mults)))))]\n   (lcm' (map multiples nums))))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (if (zero? y)\n                 x\n                 (gcd y (mod x y))))\n          (lcm [x y]\n               (/ (* x y) (gcd x y)))\n          (num [n]\n               (if (integer? n)\n                 n\n                 (numerator n)))\n          (den [n]\n               (if (integer? n)\n                 1\n                 (denominator n)))]\n    (let [l (reduce lcm (map den args))\n          ns (map #(* (num %) (/ l (den %))) args)]\n      (/ (reduce lcm ns) l))))","user":"5097ea89e4b087ccf61a7af4"},{"problem":100,"code":"(fn lcm [& vals]\n  (let [starting-point (apply max vals)\n        ending-point 300 ;(* starting-point starting-point)\n        step (apply min (concat vals [1]))\n        int-rest (fn [value divisor]\n                    (= 0 (rem value divisor)))\n        is-divided-by-all? (fn [value divisors]\n                 (every? #(int-rest value %) divisors))\n        is-lcm-r (fn [v]\n                    (when (is-divided-by-all? v vals)\n                      v))\n        r (drop-while #(> starting-point %) (range 0 ending-point step))]\n    (some is-lcm-r r)))","user":"52bdd135e4b07a9af579230a"},{"code":"(fn lcm [& nums]\n  (letfn [(multiple-of-all? [n factors]\n  (every? #(zero? (rem n %)) factors))]\n    (let [ns (sort > nums)\n        mx (first ns)]\n    (first (filter #(multiple-of-all? % ns) (iterate #(+ mx %) mx))))))","problem":100,"user":"5054c853e4b0b1b9d1860eb3"},{"problem":100,"code":"(fn lcmv [& v] (letfn  [(gcd \n                                [a b]\n                                (if (zero? b)\n                                  a\n                                  (recur b, (mod a b))))\n                              (lcm \n                                [a b]\n                                (/ (* a b) (gcd a b)))]\n                       (reduce lcm v)))","user":"55a0e139e4b0acc240e31504"},{"problem":100,"code":"(fn lcd [& xs]\n    (if (every? ratio? xs)\n      (let [denoms (map denominator xs)\n            lcd-denom (apply lcd denoms)\n            new-numerators (map #(* (numerator %) (/ lcd-denom (denominator %))) xs)\n            lcd-numer (apply lcd new-numerators)]\n        (/ lcd-numer lcd-denom))\n      (first\n       (drop-while\n        (fn [i] (not (every? #(zero? (rem i %)) xs)))\n        (rest (range))))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":100,"code":"(fn lcm [& more]\n  (letfn [(gcd [x y]\n            (cond\n             (= x y) x\n             (< x y) (recur x (- y x))\n             (> x y) (recur (- x y) y)))]\n    (/  (apply * more) (reduce gcd more))))","user":"53f2370ee4b0742d9025b0e7"},{"problem":100,"code":"(fn[& x](letfn \n    [(gcd [a b]\n        (if (= 0 b) a (gcd b (rem a b))))]\n    (reduce \n        #(/ (* %1 %2) (gcd %1 %2))\n        x)))","user":"57b9fc74e4b0fbc9809a27fb"},{"problem":100,"code":"(fn lcm [& args] \n  ((fn f [xs] \n    (let [all-equal (apply = (map (fn [x] (nth x 0)) xs))] \n      (if all-equal \n        (nth (first xs) 0) \n        (let [sorted-xs (sort-by first xs)\n            first-el-val (nth (first sorted-xs) 0)\n            first-el-fac (nth (first sorted-xs) 1)] \n          (recur (cons [(+ first-el-val first-el-fac) first-el-fac] (rest sorted-xs))))\n        )))\n    (map (fn [x] [x x]) args)))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":100,"code":"(fn lcm\n    ([a b] \n     (let [gcd (fn [a b]\n                 (if (zero? b) a\n                     (recur b (mod a b))))]\n       (/ (* a b) (gcd a b))))\n    ([a b & more]\n     (apply lcm (lcm a b) more)))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":100,"code":"(fn [& args] (reduce (fn gcm [l r]\n        (let [gcd (fn gcd[a b] (if (zero? b) a (gcd b (mod a b))))]\n          (/ (* l r) (gcd l r))\n          )\n        ) args))","user":"54d05a9de4b0e8a36923e5c7"},{"problem":100,"code":"(fn lcm [& numbers]\n  (/ (apply * numbers)\n     (apply (fn [& numbers]\n              (reduce (fn gcd2 [a b]\n                        (if (= b 0)\n                          a\n                          (gcd2 b (mod a b)))) numbers))\n            numbers)))","user":"54651faee4b01be26fd746d6"},{"problem":100,"code":"(fn lcm\n  [& numbers]\n  (let \n    [multiple (apply * numbers)\n     divides? (fn [x y] (= 0 (rem x y)))\n     is-multiple? \n       (fn [m]\n         (every? (partial (fn [x y] (= 0 (rem x y))) m) numbers))]\n    (first\n      (filter is-multiple?\n        (iterate #(+ multiple %) multiple)))))","user":"5a3c06fce4b001c08efc0cdd"},{"code":"(fn lcm\n  [& xs]\n  (let [get-num #(if (ratio? %) (denominator %) %)\n        biggest (apply * (map get-num xs))\n        mults #(set (take biggest (iterate (partial + %) %)))\n        xmults (map mults xs)\n    intersect (reduce #(clojure.set/intersection %1 %2) xmults)]\n    (first intersect)))","problem":100,"user":"524f4256e4b0541d1855b808"},{"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (= 0 b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd 0 args))))","problem":100,"user":"4e951f44535dbda64a6f6b30"},{"code":"(fn p100 [& coll]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n  (reduce lcm coll)))","problem":100,"user":"5125745ae4b05d10e3e395f9"},{"problem":100,"code":"(fn [& args]\n        (loop [seqs (map (fn [itm] (map #(* % itm) (drop 1 (range)))) args)]\n         (if (apply == (map first seqs))\n           (first (first seqs))\n           (let [mn (apply min (map first seqs))\n                 new-seqs (map #(if (== (first %) mn)\n                                    (rest %)\n                                    %) seqs)]\n             (recur new-seqs)))))","user":"538e864ee4b0b51d73faae87"},{"problem":100,"code":"(fn rec\n        ([x y]\n         (let [gcd\n               (fn[a b]\n                 (cond\n                  (< a b)\n                  (recur a (- b a))\n                  \n                  (< b a)\n                  (recur (- a b) b)\n                  \n                  :else\n                  a))\n               \n               lcm (fn[a b]\n                     (/ (* a b) (gcd a b)))]\n\n           (lcm x y)))\n        ([x y & more]\n         (reduce rec (rec x y) more)))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn [a & b] (first (filter #(not-any? ratio? (map (partial / %) b)) (map (partial * a) (iterate inc 1)))))","problem":100,"user":"4e9609ad535dbda64a6f6b3e"},{"code":"(fn lcm [x1 x2 & xs]\n  (let [omap (vec (conj xs x2 x1)) iks (range 0 (count omap))]\n\t(loop [tm omap]\n\t\t(let [mk (apply min-key tm iks) mv (tm mk) incr (omap mk)]\n\t\t\t(if (apply = tm)\n\t\t\t\t(tm 0)\n\t\t\t\t(recur (assoc tm mk (+ mv incr))))))))","problem":100,"user":"4effb663535dcb61093f6a2e"},{"problem":100,"code":"(fn [a b & others] \n  (let [f (fn gcd[a b] (let [isabig? (>= a b) \n                   x (if isabig? a b)\n                   y (if isabig? b a)]\n               (loop [x x\n                      y y]\n                 (let [remainder (rem x y)]\n                  (if (= remainder 0)\n                   y\n                   (recur y remainder))))))]\n    \n    (let [lcm (fn [x y] (/ (* x y) (f x y)))]\n      (loop [result (lcm a b)\n             others others]\n        (if (empty? others)\n          result\n          (recur (lcm result (first others)) (next others)))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [n m]\n              (if (= (mod n m) 0)\n                m\n                (recur m (mod n m))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5d92b543e4b0915913b1d414"},{"problem":100,"code":"(fn lcm [& xs]\n   (reduce (fn [a b]\n             (/ (* a b) ((fn gcd [a b]\n                           (if (zero? b)\n                             a\n                             (recur b (mod a b)))) a b))) xs))","user":"55a19e19e4b0acc240e31515"},{"code":"(fn [& xs] (reduce (fn [x y] (first (for [n (range x Double/POSITIVE_INFINITY x) :when (= (mod n y) 0)] n))) xs))","problem":100,"user":"4fb65f2fe4b081705acca2c7"},{"problem":100,"code":"(fn [& args] (loop [args args\n                              inc (apply min args)\n                              num (apply min args)] \n               (if (= (count args) (count (filter (fn [x] (= 0 (mod num x))) args)))\n                 num\n                 (recur args inc (+ num inc)))))","user":"579aff09e4b05b1deef9ade7"},{"code":"(fn [& s] (first (filter (fn [x] (= 0 (reduce + (for [i (seq s)] (rem x i))))) (iterate (partial + (reduce min s)) (reduce min s)))))","problem":100,"user":"525c575be4b0cb4875a45d38"},{"problem":100,"code":"(fn                                                                         \n  [& nums]                                                                         \n  (reduce                                                                          \n    (fn lcm                                                                        \n      [a b]                                                                        \n      (/ (* a b)                                                                   \n         ((fn gcf                                                                  \n           [a b]                                                                   \n           (let [mn (min a b) mx (max a b)]                                        \n             (if (= 0 mn) mx (gcf (- mx mn) mn)))) a b)))                          \n    nums))","user":"563536f8e4b0bfe05bf117c5"},{"code":"(fn lcd [& r]\n  (letfn [(gcd [x y]\n               (loop [a (max x y),\n                      b (min x y)]\n                 (if (> b 0)\n                   (recur b (rem a b))\n                   a)))] \n    (reduce #(/ (* % %2) (gcd % %2)) r)))","problem":100,"user":"512474ede4b02c3f2a072cce"},{"code":"#(letfn [(gcd [a b]\n             (if (zero? b)\n               a\n               (recur b (mod a b))))\n        (lcm [a b] (/ (* a b) (gcd a b)))]\n  (reduce lcm %&))","problem":100,"user":"535d4b0ae4b04ce2eb3ed2be"},{"problem":100,"code":"(fn lcm [& args]\n    (loop [i 1\n           multiples (repeat (count args) #{})]\n      (let [overlap (apply clojure.set/intersection multiples)]\n        (if (> (count overlap) 0)\n          (first overlap)\n          (recur (inc i) (map #(conj %1 %2) multiples (map (partial * i) args))))\n        )\n      )\n    )","user":"56791447e4b05957ce8c6183"},{"problem":100,"code":"(fn lcm  [& xs]\n        (let [try-divide (fn [x d] (if (zero? (rem x d))\n                                     (/ x d)\n                                     x))\n              _denominator #(if (ratio? %) (denominator %) 1)\n              denom (apply * (map _denominator xs))\n              int-xs (map #(* denom %) xs)\n              numerator-lcm (apply *\n                              (loop [_xs int-xs  unchecked-dividers (range 2 (inc (apply max int-xs)))  primes [1]]\n                                (if (every? #(= 1 %) _xs)\n                                  primes\n                                  (let [prime-candidate (first unchecked-dividers)  xs-divided (map #(try-divide % prime-candidate) _xs)]\n                                    (if (= _xs xs-divided)\n                                      (recur xs-divided (rest unchecked-dividers) primes)\n                                      (recur xs-divided unchecked-dividers (conj primes prime-candidate)))))))\n\n\n              ]\n          (/ numerator-lcm denom)\n          ))","user":"561814bae4b06b1bb2182a1a"},{"problem":100,"code":"(fn [ & x]\n  (let [ gcd (fn [a b]  (loop [x a y b] (if-not (= 0 y) (recur y (mod x y)) x)))\n        lcmPair (fn [x y] (/ (* x y) (gcd x y)))\n        ]\n    (reduce lcmPair x)))","user":"54d2b411e4b0e8a36923e5f9"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))\n    ))","user":"590b3aeae4b047aa04b199d0"},{"code":"(let\n  [gcd (fn gcd [a b]\n         (if (= a b)\n           a\n           (if (> a b)\n             (recur (- a b) b)\n             (recur a (- b a)))))\n   lcm (fn [a b] (/ (* a b) (gcd a b)))]\n  (fn [& as] (reduce lcm as)))","problem":100,"user":"52d660eae4b09f7907dd1356"},{"code":"(fn [& v]\n  (apply (fn f\n     ([[a b x y]]\n      (cond\n       (= (* a x) (* b y)) (* a x)\n       (< (* a x) (* b y)) (f [a b (+ x 1) y])\n       :else (f [a b x (+ y 1)])))\n     ([a b] (f [a b 1 1]))\n     ([a b & c]\n      (apply f (cons (f [a b 1 1]) c)))) v))","problem":100,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn [& c]\n  (let [c (map #(vector % %) c)]\n    (loop [c c]\n      (if (= 1 (count (set (map second c))))\n        (second (first c))\n        (let [s (vec (sort-by second c))\n              l (first s)]\n          (recur (assoc s 0 [(first l) (+ (second l) (first l))])))))))","problem":100,"user":"4dc1bd76535d020aff1edf8d"},{"problem":100,"code":"(fn [& x] (reduce   (fn [a b] (/ (* a b) (  (fn [p q] (if (zero? q) p (recur q (mod p q))))    a b)))    x))","user":"56d4b1aee4b0ea9b8538f7ba"},{"code":"(fn [& x]\n    (let [m (apply max x)]\n      (loop [n 1]\n        (if (every? zero? (map #(mod (* n m) %) x))\n          (* n m)\n          (recur (+ n 1))))))","problem":100,"user":"51b3f109e4b0f094dd986fa9"},{"problem":100,"code":"(fn lcm [& xs]\n         (let [s (sort xs)\n               x (last s)]\n           (loop [res x]\n             (if (every? integer? (map #(/ res %) s))\n               res\n               (recur (+ res x))))))","user":"58c4492be4b021aa9917ed27"},{"problem":100,"code":"(fn [& s]\n   (letfn [(lcm [a b]\n             (cond\n               (= a 1) b\n               (= b 1) a\n               :else (let [a-n (if (ratio? a) (numerator a) a)\n                           a-d (if (ratio? a) (denominator a) 1)\n                           b-n (if (ratio? b) (numerator b) b)\n                           b-d (if (ratio? b) (denominator b) 1)]\n                       (/ (/ (* a-n b-n) (.gcd (biginteger a-n) (biginteger b-n)))\n                          (.gcd (biginteger a-d) (biginteger b-d))))))]\n     (reduce #(lcm %1 %2) 1 s)))","user":"5f3f2281e4b004f08c61c561"},{"code":"(fn [G & n] (reduce #(/ (* % %2) (G % %2)) n))\n(fn g [a b] (if (= b 0) a (g b (rem a b))))","problem":100,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn [f & r]\n  (letfn [(g [a b] (if (= 0 b) a (g b (mod a b))))]\n    (reduce #(/ (* % %2) (g % %2)) f r)))","problem":100,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn [& ns]\n  (let [lte-mcm? #(<= % 210)]\n    (apply min (apply clojure.set/intersection (map #(set (filter lte-mcm? (map * (repeat %) (range 1 1000)))) ns)))\n  )\n)","problem":100,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn [f & r] \n  (let [ mul (reduce * f r)\n\t\t   gcd (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) f r)]\n\t(/ mul gcd)))","problem":100,"user":"4fc0853ae4b081705acca327"},{"problem":100,"code":"(fn lcm [& nums] (\n   let [gcd (fn [a b] (loop [a a b b] (if (zero? b) a (recur b (mod a b)))))]\n   (reduce #(/ (* % %2) (gcd % %2)) nums)))","user":"4eb97234535dfed6da9c6d53"},{"problem":100,"code":"(fn [& p] (reduce #(/ (* %1 %2) ((fn gcd [a b] (if (= b 0) a (gcd b (rem a b)))) %1 %2)) p))","user":"53347274e4b0656e627bfd6b"},{"code":"(fn foollcm [& lst]\r\n  (letfn [(mult[m n]\r\n        (let [mans (* (first m) (second m))\r\n\t\t    nans (* (first n) (second n))]\r\n\t\t    (cond (= mans nans) mans\r\n\t\t\t  (> mans nans) (mult m [(first n) (+ 1 (second n))])\r\n\t\t\t  :else (mult [(first m) (+ 1 (second m))] n))))\r\n\t  (lcm [m n]\r\n\t       (mult [m 1] [n 1]))\r\n\t  ]\r\n    (reduce lcm lst)))","problem":100,"user":"4ddc620d535d02782fcbea06"},{"problem":100,"code":"(fn [& a]\n  (/ (reduce * a)\n     (reduce (fn [& a]\n               (loop [n 1 v a]\n                 (if (= (count v) 1)\n                   ((fn g [a b]\n                     (if (= b 0)\n                       a\n                       (g b (mod a b)))) (first v) n)\n                   (recur (first v) (rest v))))\n               ) a)))","user":"51ab70c3e4b04e3dc0c27b33"},{"code":"(fn lcm [& s]\n  (letfn [(gcd [a b] (cond (= a b) a (> a b) (gcd (- a b) b) :else (gcd a (- b a))))]\n         (reduce #(/ (* % %2) (gcd % %2)) s)))","problem":100,"user":"500854c4e4b028e089d3518c"},{"code":"(fn [x & s] (let [lcm (fn [a b] (/ (* a b)\n                                    ((fn [a b] (if (= b 0) a\n                                                  (recur b (rem a b))))\n                                     a b)))]\n                (reduce lcm (conj s x)))\n       )","problem":100,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":100,"code":"(fn lcm\n  ([a b]\n  (let [gcd\n        (fn gcd [a b]\n          (cond\n           (> a b) (gcd b a)\n           ; so a < b\n           (= a 0) b\n           :else (gcd (mod b a) a)))]\n    (/ (* a b) (gcd a b))))\n  ([a b & r]\n   (reduce lcm (lcm a b) r)\n   )\n  )","user":"6045582fe4b02d28681c77b6"},{"problem":100,"code":"(fn [& args] (let\n                     [m (apply min args)\n                      mults (iterate (fn [x] (+ x m)) m)\n                      ]\n                     (some #(when (every? (comp zero? (partial mod %)) args) %) mults)\n                    ))","user":"574986cae4b009280f9f2b9c"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"52c45ac8e4b0c2d177d620d9"},{"code":"(fn [x y & xs]\n        (letfn [(pgcd [x y]\n                      (if (zero? y)\n                        x\n                        (pgcd y (mod x y))))\n                (ppcm [x y]\n                     (/ (* x y) (pgcd x y)))]\n               (reduce ppcm (cons x (cons y xs)))))","problem":100,"user":"51a8f0c6e4b08d8ec191b821"},{"problem":100,"code":"(fn [& args] (let [gcdf (fn [a b] (if (zero? b) a (recur (min a b) (mod (max a b) (min a b))))) gcd (reduce gcdf args)] (/ (apply * args) gcd)))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))))]\n    (reduce (fn [a b] (* (/ a (gcd a b)) b)) xs)))","problem":100,"user":"5290257ae4b0239c8a67af03"},{"problem":100,"code":"(fn [& xs]\n   (reduce\n     (fn [a b]\n       (let [gcd (fn [a b]\n                   (if (zero? b)\n                     a\n                     (recur b (mod a b))))]\n         (/ (* a b) (gcd a b))))\n     xs))","user":"55c652dde4b0e31453f649bd"},{"code":"(fn [& args] \n    (letfn [(gcd [a b]\n              (if (== b 0) \n                a\n                (gcd b (mod a b))))\n            (lcd [a b] \n              (/ (* a b) (gcd a b)))]\n      (reduce lcd args)))","problem":100,"user":"51a768e0e4b0da5f497bde84"},{"problem":100,"code":";; get denominators, product, multiply to integralize, multiply, find gcd, divide by gcd divide by product\n;; or see if there is a better algorithm entirely\n(letfn [(gcd [m n]\n             (cond \n              (< n m) (recur n m)\n              (zero? m) n\n              :else (recur (mod n m) m)))\n        (denom [n]\n               (if (ratio? n)\n                 (denominator n) 1))\n        (lcm ([n m]\n             \t(let [dprod (* (denom n) (denom m))\n                   np (* dprod n)\n                   mp (* dprod m)\n                   g (gcd np mp)]\n               (/ (* np mp) (* dprod g))))\n             ([n m & args]\n              (apply lcm (lcm n m) args)))]\n  (fn [& args]\n    (apply lcm args)))","user":"5553b924e4b0deb715856e06"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))\n        lcm (fn [a b]\n  (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"580a0783e4b0a837a8b30d2c"},{"code":"(fn [& s]\n  (let [i (apply * (map #(if (= (type %) clojure.lang.Ratio) (numerator %) %) s))\n        j (map #(/ i %) s)\n        k (map (fn [a b] [a b]) s j)\n        l (map (fn [[a b]] (map #(* a %) (range 1 (inc b)))) k)\n        m (map set l)\n        ]\n    (apply min (apply clojure.set/intersection m))))\n\n; _pcl's solution looks nice but is wrong! Try with (__ 2 3 6)\n;(fn [& xs]\n;  (/ (apply * xs)\n;    (reduce #(if (zero? %2) % (recur %2 (mod % %2))) xs)))","problem":100,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"problem":100,"code":"(fn [& nums] (loop [numbers nums n 1]\n                (if (every? #(= 0 (mod (first numbers) %1)) numbers) (first numbers)\n                                                               (recur (conj (next numbers) (+ (first numbers) (/ (first numbers) n))) (inc n)))))","user":"567f988be4b0feffd0d18ebe"},{"problem":100,"code":"(fn [& args]\n  (loop [in args]\n    (if (empty? (rest in))\n      (first in)\n      (let [a (first in)\n            b (second in)\n            y (loop [sum a]\n                (if (integer? (/ sum b))\n                  sum\n                  (recur (+ sum a))))]          \n        (recur (cons y (rest (rest in))))))))","user":"594bd637e4b07ddc2dafae41"},{"problem":100,"code":"(fn [& args] (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))] (/ (reduce * args) (reduce gcd args))))","user":"54f296efe4b024c67c0cf8c8"},{"problem":100,"code":"(fn least-common-multiplier [& nums]\n  (letfn [(gcd [x y]\n            (if (zero? y) x\n               (recur y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) nums)))","user":"53d40508e4b00fb29b221332"},{"problem":100,"code":"(fn [& x] (reduce #(/ (* % %2) ((fn [a b] (if (== b 0) a (recur b (mod a b)))) % %2)) x))","user":"51a058dae4b0b292b01ee3f3"},{"problem":100,"code":"#(letfn [\n        (get-max [& n] (->> n\n                           (map (fn [x] (if (< x 1) (numerator x) x )))\n                           (reduce *)\n                           )\n          )\n        (get-1m-set [max n] (let [count (/ max n)] (map * (range 1 (inc count)) (repeat n))))\n        (get-lcm [& n] (->> n\n                            (map (fn [x] (get-1m-set (apply get-max n) x)))\n                            (map set)\n                            (reduce clojure.set/intersection)\n                            (apply min)\n                            )\n          )\n        ]\n   (apply get-lcm %&)\n   )","user":"5c17467fe4b01240ff5671df"},{"code":"(fn [& args] (let [largest (apply max args)\n                   others (remove #(= % largest) args)\n                   multiple? (fn [y] (every? #(= 0 (mod y %)) others))]\n               (some #(if (multiple? %) %) (iterate #(+ largest %) largest))))","problem":100,"user":"50f2e5cee4b0ec8ee6fa8643"},{"problem":100,"code":"(fn [& args]\n  (let [gcd(fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b)))\n              )]\n  (/ (reduce * args) (reduce gcd args))\n  ))","user":"5ea7b04de4b00a66d4a951b6"},{"problem":100,"code":"#(/ (apply * %&) (reduce (fn [x y] (if (zero? y) x (recur y (mod x y)))) %&))","user":"5ea2e6bfe4b00a66d4a95197"},{"code":"(letfn [(abs [n] (if (neg? n) (- n) n))\n        (gcd [a b] (if (zero? b)\n                     (abs a) \n                     (recur b (rem a b))))]\n  (fn lcm\n    ([a b]\n      (if (some zero? [a b])\n        0\n        (* (abs a) (/ (abs b) (gcd a b)))))\n    ([a b & cs]\n      (reduce lcm a (cons b cs)))))","problem":100,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [& p]\n  (some #(when (every? (fn [c] (= 0 (rem % c)))\n                       (next p))\n           %)\n        (map (comp (partial * (first p)) inc) (range))))","problem":100,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn lcm\n  ([x y]\n    (if (> x y)\n      (lcm y x)\n      (first (filter #(zero? (rem % x)) (iterate #(+ % y) y)))))\n  ([x y & zs]\n    (apply lcm (lcm x y) zs)))","problem":100,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn [& x] (reduce #(/ (* % %2) \n                  ((fn f [a b] (if (= b 0) a (f b (mod a b)))) % %2))\n  x))","problem":100,"user":"4eaede1f535d7eef30807329"},{"code":"(fn lcm [& nums]\n  (reduce (fn [x y]\n            (let [gcd (loop [[y x] (sort [x y])]\n                        (if (zero? y) x (recur [(mod x y) y])))\n                  prod (* x y)]\n              (/ prod gcd)))\n          nums))","problem":100,"user":"50763574e4b0a894bb95bf3d"},{"problem":100,"code":"(fn lcd2 [& args]\n  (->>\n    (map #(take 400 (iterate (partial + %) %)) args) \n    (map set)\n    (apply clojure.set/intersection)\n    (sort)\n    (first)\n  )\n)","user":"550e52dbe4b06e50f9beb165"},{"problem":100,"code":"(fn [& all]\n  (loop [mx (apply max all) res mx rst (remove #{mx} all)]\n   (if (every? #(= % 0) (map #(mod res %) rst)) res\n     (recur mx (+ mx res) rst)\n     )\n  )    \n)","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn [& xs] \n  (letfn [\n    (gcd [a b] (if (zero? b) a (recur b (mod a b))))\n    (lcm [a b] (/ (* a b) (gcd a b)))]\n  (reduce #(lcm %1 %2) (sort xs))))","problem":100,"user":"4ef4e5fa535dced4c769f242"},{"code":"(fn [g & x] (/ (apply * x) (reduce g x))) #(if (= 0 %2) % (recur %2 (mod % %2)))","problem":100,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"5d2bfb68e4b01671435dbc86"},{"problem":100,"code":"(fn [& a] (reduce #(/ (* % %2) ((fn g [a b] (if (zero? b) a (recur b, (mod a b)))) % %2)) a))","user":"4fe9de74e4b0547ebccb2475"},{"problem":100,"code":"(fn [n & nums]\n  (first\n   (filter \n    (fn [x]\n      (every? #(zero? (rem x %)) nums))\n    (iterate #(+ n %) n))))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"problem":100,"code":"(fn z [& coll]\n\n  (let [low (apply min coll)\n\n        step low]\n\n    (loop [res low]\n\n      (if (every? #(zero? (mod res %)) coll)\n\n        res\n\n        (recur (+ res step))))))","user":"583667c7e4b089d5ab817cfb"},{"problem":100,"code":"(fn [& args] (reduce #(let [quot (/ %1 %2)] (if (= (type 1) (type quot)) %1 (* %2 (numerator quot)))) args))","user":"5e042dede4b0a607a9a45d69"},{"code":"(fn lcm \n  ([x y] (/ (* x y) (#(if (zero? %2) %1 (recur %2 (mod %1 %2))) x y)))\n  ([x y & xys] (reduce lcm (concat [x y] xys))))","problem":100,"user":"4ff01fa9e4b0678c553fc321"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] \n              (if (= b 0) \n                a \n                (recur b (mod a b))))\n        lcm (fn [a b] \n              (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"55d28b38e4b0e31453f64a58"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (gcd b (mod a b))))\n          (lcm [a b]\n            (let [ab (* a b),\n                  abs-ab (if (< ab 0) (* -1 ab) ab)]\n              (/ abs-ab (gcd a b))))]\n    (reduce lcm args)))","user":"5c6e1006e4b0fca0c1622744"},{"problem":100,"code":"(fn [& m] \n    ((fn l \n      [c] \n      (if (apply = (vals c))\n          (last (vals c))\n          (l (apply #(assoc c % (+ % %2)) (apply min-key val c))))) (zipmap m m)))","user":"52a267c6e4b04e0c58e87bef"},{"problem":100,"code":"(fn kpk [& coll] (letfn [(fpb\n                           [a b]\n                           (if (zero? b)\n                             a\n                             (fpb b (mod a b))))]\n               (reduce #(/ (* %1 %2) (fpb %1 %2)) coll)))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn[& x](first (filter #(reduce (fn[a b](and (= 0 (rem % b)) a)) true x) (range 1/2 300 1/2))) )","problem":100,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":100,"code":"(fn [& col]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce #(lcm %1 %2) col)))","user":"53a2a259e4b0f1fc7453882c"},{"code":"(fn muls [a & [b & rs :as s]]\n  (if (empty? s) a\n    (apply muls \n      (first \n        (filter #(zero? (rem % b)) \n          (iterate (partial + a) a)))\n      rs)))","problem":100,"user":"50901b2ee4b0ea685a20f774"},{"problem":100,"code":"(fn [& c] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (apply * c) (reduce gcd c))))","user":"5fd10010e4b07e53c2f3f02a"},{"code":"(fn lcm\n  [& args]\n  (let [m (apply max args)]\n    (loop [n 1]\n      (if (apply = (cons 0 (map #(rem (* n m) %) args)))\n        (* n m)\n        (recur (inc n))))))","problem":100,"user":"51852961e4b0da5a5be3babb"},{"problem":100,"code":"(fn [& args]\n  (let [v (sort args)]\n    (reduce #(loop[v1 %1]\n               (if (= (rem v1 %2)0) v1 (recur (+ v1 %1)))) args)))","user":"51bf0ccee4b013aa0d74b811"},{"problem":100,"code":"(fn [& n]\n ((fn f [multiple the-seq args]\n   (let [nums (map (partial * multiple) args)\n         new-seq (apply conj the-seq nums)]\n     (or\n      (some #(when (= (count nums) (count (filter (partial = %) new-seq))) %) nums)\n      (f (inc multiple) new-seq args))))\n 1 [] n))","user":"50f53694e4b057d4c52de881"},{"problem":100,"code":"(fn [& args] (letfn [\n                     (gcd [a b] (if (= b 0) a (recur b (mod a b))))\n                     (lcm [a b] (/ (* a b) (gcd a b)))]\n\t(reduce lcm args)))","user":"552456e3e4b0882d96d091c2"},{"code":"(fn [& l]\n  (loop [m (vec l)]\n    (if (apply = m)\n      (first m)\n      (let [i (.indexOf m (apply min m))]\n        (recur (update-in m [i] + (nth l i)))))))","problem":100,"user":"522b922ee4b0d34ee08e71c3"},{"problem":100,"code":"(fn [& lst]\n    (reduce\n      (fn [a b]\n        (loop\n          [ca a cb b]\n          (if (= ca cb)\n            ca\n            (if (< ca cb)\n              (recur (+ ca a) cb)\n              (recur ca (+ cb b))))))\n      lst\n      )\n    )","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":100,"code":"(fn [x y & more] \n   (let [coll (if (empty? more)\n                (vector x y)\n                (flatten (vector x y more)))]\n     (letfn [(gcd-2 [a b] \n                    (if (= b 0)\n                      a\n                      (gcd-2 b (mod a b))))\n             (gcd-n [coll]\n                    (reduce gcd-2 coll))] \n       (/ (reduce * coll) (gcd-n coll)))))","user":"53da8fede4b0e771c30254a3"},{"problem":100,"code":"(fn [& xs]\n (let\n  [lcd\n   (fn lcd [x y]\n (cond (> x y)\n       (recur y (- x y))\n       (= x y)\n       x\n       (< x y)\n       (recur y x)))\n   [ns ds]\n   ((juxt\n    (partial map first)\n    (partial map last))\n   (map\n    #(if (ratio? %)\n      [(numerator %)\n       (denominator %)]\n      [% 1])\n    xs))]\n   (/ (reduce * ns)\n      (* (reduce lcd ns)\n         (reduce lcd ds)))\n))","user":"549a999be4b0f3d1d8e70f6f"},{"code":"(fn dolcm [& r]\n            (letfn [(lcm [a & rst]\n                         (/ (reduce * a rst)\n                            (reduce gcd1 a rst)))\n                    (gcd1 [a b]\n                          (let [aa (max a b)\n                                bb (min a b)]\n                            (if (zero? b)\n                              a\n                              (recur b (mod a b)))))]\n                   (apply lcm r)))","problem":100,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn lcm [& xs]\n  (let [x-min (apply min xs)\n        x-max (apply max xs)\n        match? (fn [m] (not-any? #(pos? (rem m %)) xs))\n        candidates (iterate (partial + x-min) x-min)]\n  (first (filter match? candidates))))","problem":100,"user":"4edecdae535d10e5ff6f533c"},{"code":"(fn lcm [& args]\n  (first\n    (sort\n      (apply clojure.set/intersection\n        (map set\n          (map #(take 10000 ((fn [n] ((fn mult [m, i] (cons (* m i) (lazy-seq (mult m (inc i))))) n 1)) %)) args)))))\n)","problem":100,"user":"50e496e8e4b0cb9ec68fbca0"},{"problem":100,"code":"(fn lcm [& nums] ((fn inner [n] (if (= (count (filter #(= (rem n %) 0) nums)) (count nums))\n                                  n\n                                  (inner (+ n (first nums))))) (first nums)))","user":"53ddd44be4b0d874e779ae2e"},{"code":"(fn [& ns]\r\n  (reduce\r\n    #(->> (iterate (partial + %1) %1)\r\n      (map (partial / %2))\r\n      (map /)\r\n      (filter integer?)\r\n      first\r\n      (* %2))\r\n  ns))","problem":100,"user":"504e14c2e4b078edc5f593bf"},{"problem":100,"code":"#(letfn\n   [(lcm [a b]\n      (let [gcd (loop [x a, y b]\n                  (if (zero? y)\n                    x\n                    (recur y (mod x y))))]\n        (* b (/ a gcd))))]\n   (reduce lcm %&))","user":"5b772ad7e4b047b03b2036e8"},{"code":"(fn [& c]\n  (reduce (fn [a b]\n            (some #(when (apply = %) (first %))\n                  (for [\n                        x (map #(* (inc %) a) (range))\n                        y (map #(* (inc %) b) (range)) :while (<= y x)]\n                    [x y]))) c))","problem":100,"user":"531f1e63e4b08068f379edc2"},{"problem":100,"code":"(fn func [& nums]\n  (let [mono-seq-contains? (fn [seq n] (= n (first (filter #(>= % n) seq))))\n        muls (map (fn [x] (map #(* % x) (drop 1 (range)))) nums)]\n    (first \n     (filter \n      (fn [x] (every? (fn [coll] (mono-seq-contains? coll x)) (rest muls))) \n      (first muls)))))","user":"5e805895e4b085ba37836e44"},{"code":"(fn __ [& args]\n  (letfn [(gcd [a b]\n               (if (= 0 b)\n                 a\n                 (recur b (mod a b))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (if (> (count args) 1)\n      \t(recur \n         (flatten (remove nil?\n           (vector (lcm (first args) (second args))\n                   (seq (drop 2 args))))))\n\t\t(first args))))","problem":100,"user":"4fa719c0e4b081705acca1bf"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (let [a (max x y)\n                     b (min x y)\n                     m (mod a b)]\n                 (if (zero? m) b (recur b m))))\n          (lcm [a b]\n               (* (/ a (gcd a b)) b))]\n    (reduce lcm args)))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn [& nums]\n  (reduce \n    (fn lcm [a b] \n      (/ (* a b)\n        (loop [x a y b]\n          (if (= 0 y)\n            x\n            (recur y (mod x y))))))\n    nums))","problem":100,"user":"4eb1dd39535d7eef30807345"},{"code":"(fn [& args] \n   (letfn [(gcd [x y] \n    (if (= x y) x\n      (if (< x y)\n        (gcd x (- y x))\n        (gcd (- x y) y))))\n           (lcm [x y] (/ (* x y) (gcd x y)))]\n     \n     (reduce lcm args)))","problem":100,"user":"4ffa8affe4b0678c553fc3bd"},{"code":"(fn f [& args]\r\n  (letfn [(multipliers [n] (apply sorted-set (map #(* n %) (range 1 2000))))]\r\n    (first \r\n      (apply clojure.set/intersection (map multipliers args)))))","problem":100,"user":"4dc97aec535d5973398f9284"},{"problem":100,"code":"(fn lcm [& vals]\n  (let [gcd (fn gcd [n1 n2]\n              (let [iter (fn [v1 v2]\n                           (if (= v2 0) v1\n                               (recur v2 (mod v1 v2))))]\n                (if (> n1 n2) (iter n1 n2) (iter n2 n1))))\n        nums (map #(if (ratio? %) (numerator %) %) vals)\n        denoms (map #(if (ratio? %) (denominator %) 1) vals)]\n    (/\n     (reduce * nums)\n     (reduce gcd nums)\n     (reduce gcd denoms))))","user":"5471f2fbe4b094393f72dd70"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [ (same? [v] (apply = v)) \n           (least-idx [v] (loop [s v least (first v) least-idx 0 idx 0]\n                            (if (empty? s)\n                              least-idx\n                              (let [current   (first s)\n                                    change    (< current least)\n                                    new-least (if change current least)\n                                    new-idx   (if change idx least-idx) ]\n                                (recur (rest s) new-least new-idx (inc idx) )\n                                )))) ]\n    (let [v (vec args)]\n    (loop [t v]\n      (if (same? t)\n        (first t)\n        (let [idx (least-idx t)]\n          (recur (assoc t idx (+ (t idx) (v idx))))\n          ))))))","user":"53c1ce3ee4b00fb29b221268"},{"problem":100,"code":"(fn [& args] \n  (/ (reduce * args) (reduce (fn [a b] (if (zero? b) a (recur b (mod a b)))) args)))","user":"59dfd369e4b08badc2a0c4dd"},{"problem":100,"code":"(fn __ [& nums]                                                                                                \n  (letfn [(gcd [x y]                                                                                             \n            (let [a (max x y)                                                                                    \n                  b (min x y)                                                                                    \n                  m (mod a b)]                                                                                   \n              (if (zero? m)                                                                                      \n                b                                                                                                \n                (recur b m))))                                                                                   \n          (lcm [a b]                                                                                             \n            (/ (* a b) (gcd a b)))]                                                                              \n    (reduce lcm nums)))","user":"52485723e4b05ef8e38e63d2"},{"code":"(fn [& items]\n  (letfn [(gcd [a b]\n               (if (zero? a)\n                b\n                (recur (mod b a) a)))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce #(lcm % %2) items)))","problem":100,"user":"4f036d9b535dcb61093f6ac1"},{"problem":100,"code":"(fn [& nums]\n   (let [gcd (fn [f s]\n               (cond\n                 (< f s) (recur f (- s f))\n                 (> f s) (recur (- f s) s)\n                 :else f))]\n     (reduce (fn [aa bb] (/ (* aa bb) (gcd aa bb))) nums)))","user":"52b89d55e4b07a9af57922b3"},{"problem":100,"code":"(fn [& xs]\n  (loop [xs (for [x xs]\n              (map (partial * x) (drop 1 (range))))]\n    (let [largest (first (sort > (map first xs)))\n          ys (map (fn [xs]\n                    (if (< (first xs) largest)\n                      (rest xs)\n                      xs))\n                  xs)]\n      (if (every? (partial = largest) (map first ys))\n        largest\n        (recur ys)))))","user":"5adf5f9be4b0837691e92c33"},{"problem":100,"code":"(fn lcm\n  ([a] a)\n  ([a b]\n   (letfn [(gcd [a b] (if (= 0 b) a (recur b (rem a b))))\n           (abs [x] (if (< x 0) (- x) x))]\n     (if (= 0 a b)\n       0\n       (/ (abs (* a b)) (gcd a b)))))\n  ([a b & args]\n    (apply lcm (lcm a b) args)))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":100,"code":"(fn [& vs]\n  (loop [xs (map vector vs vs)]\n    (if (every? #(= (first (first xs)) (first %)) (rest xs)) (first (first xs))\n      (let [xss (sort #(< (first %1) (first %2)) xs)\n            p (first xss)]\n        (recur (concat [[(+ (first p) (second p)) (second p)]] (rest xss)))))))","user":"55c20bd0e4b0e31453f64972"},{"problem":100,"code":"(fn [& x]\n  (let [y (map #(if (= (class %) clojure.lang.Ratio) (* (numerator %) (denominator %)) %) x) lim (apply * y)] \n  (first\n   (sort\n    (apply clojure.set/intersection\n     (map\n      (fn [a]\n        (set\n         (map\n          #(* a %)\n          (range 1 lim))))\n        x))))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":100,"code":"(fn lcm [& args] (reduce (fn [a b]\n                            (/ (* a b)\n                               ((fn gcd [c d]\n                                  (if (zero? d)\n                                    c\n                                    (recur d (mod c d)))) a b))) args))","user":"55d85ac9e4b0e31453f64ab2"},{"problem":100,"code":"(fn\n  [& args]\n  (let [sorted (sort args)\n        smallest (first sorted)\n        divisors (rest sorted)\n        all-divisible? (fn [possible-multiple]\n                        (every? zero? (map #(mod possible-multiple %) divisors)))]\n    (loop [multiplier 1]\n      (if (all-divisible? (* multiplier smallest))\n        (* multiplier smallest)\n        (recur (inc multiplier))))))","user":"53ac4719e4b047364c04445c"},{"problem":100,"code":"(fn lcd [& n]\n  (letfn [(gcd\n           [[a & nbrs]]\n           (let [b (apply min nbrs)]\n             (if (= 0 a) b\n               (recur (conj nbrs a (mod b a))))))]\n    (/ (apply * n) (gcd (sort n)))))","user":"5af31955e4b0cc2b61a3bc7a"},{"code":"(fn [x & coll] (apply min (reduce clojure.set/intersection (set (take 400 (iterate #(+ x %) x)))\r\n        (map (fn [x] (set (take 400 (iterate #(+ x %) x)))) coll))))","problem":100,"user":"503354c3e4b0c6c1199c710c"},{"problem":100,"code":"(fn [& rt]\n  (/ (reduce * rt)\n     (reduce (fn [x y]\n               (if (= (rem x y) 0)\n                 y\n                 (recur y (rem x y))))\n             rt)))","user":"54b64fbbe4b05787c3b163b8"},{"code":"(fn least-common-multiple\n  [& args]\n  (second (sort\n    (apply clojure.set/intersection\n           (mapv #(set (take 1000 (iterate (partial + %) 0))) args)))))","problem":100,"user":"5300b750e4b0d8b024fd3711"},{"problem":100,"code":";Se encuentra el lcm con esta poderosa regla: (a * b)/gcd(a,b) \n(fn [& args] ;es para n argumentos\n  ;variables para gc\n  (let[\n       gcd-decimales-enteros ;variable que contendra la funcion para calcular el gcdPARA DECIMALES Y ENTEROS.\n          (fn [a b];arguments, los primeros 2 numeros :v\n            (let [ [dividendo divisor] ;crea 2 variables locales PARA LA PRIMERA ITERACION, ahora voy a determinar que agregarles en esa variables locales, el dividendo debe de ser mayor al divisor\n            (if (> a b)\n              (list a b);true, agrega esos elementos en este orden a las variables, es decir, dividendo sera a y divisor sera b\n              (list b a));else, agrega esos elementos en este orden a las variables, es decir, dividendo sera b y divisor sera a\n            ]\n            (loop [dividendo dividendo\n                   divisor  divisor]\n              (if (zero? (quot dividendo divisor)) ;CASO BASE\n                (rem dividendo divisor) ;el  resto (remainder en ingles) es el gcd :D \n                (recur (rem dividendo divisor) divisor)))))]\n    ;gcd                ;se hace un rece para hacer la evaluacion de gcd ytener el acumulado correcto :D      \n    (/ (reduce * args) (reduce gcd-decimales-enteros args))))","user":"59e63a2ce4b08badc2a0c569"},{"problem":100,"code":"(fn lcm[n1 & args] (/ (reduce * n1 args) (reduce (fn gcd[a, b] ( if(= b 0 ) a (gcd b (rem a b)) )) n1 args ) ) )","user":"5cf53196e4b087f62be35a94"},{"problem":100,"code":"(fn lcm \n\t([f s & etc]\n\t   (lcm f (apply lcm s etc)))\n\t([f s]\n\t   (let [gcd (fn [a b] (loop [a1 a b1 b] (if (= b1 0) a1 (recur b1 (mod a1 b1)))))]\n\t     (/ (* f s) (gcd f s)))))","user":"53da3fcde4b0e771c3025497"},{"problem":100,"code":"(fn [& fracs]\n  (let [denoms (map #(if (ratio? %) (denominator %) 1) fracs)\n        numers (map #(if (ratio? %) (numerator %) %) fracs)\n        lcm (fn [& nums]\n              (let [l (apply max nums)]\n                (->> (iterate #(+ % l) l)\n                     (filter (fn [mult] (every? #(zero? (mod mult %)) nums)))\n                     (first))))\n        gcd (fn [& args]\n              (let [g (fn g [a b] (if (zero? b) a (g b (mod a b))))]\n                (reduce g args)))]\n    (/ (apply lcm numers) (apply gcd denoms))))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (loop [x (max a b)\n                   y (min a b)]\n              (if (= y 0)\n                x\n                (recur y (rem x y)))))]\n    (loop [numbers (rest args)\n           result (first args)]\n      (if (empty? numbers)\n        result\n        (let [x (first numbers)\n              rest (rest numbers)\n              g (gcd x result)]\n          (recur rest (* g (/ result g) (/ x g))))))))","problem":100,"user":"50ed3c6be4b01236b1d4983b"},{"problem":100,"code":"(fn abc [& arg]\n   (loop [x 1 y 0]\n     (if (every? integer? (map #(/ (* x (last (sort arg))) %) arg))\n       (* x (last (sort arg)))\n       (recur (inc x) (inc y))))\n      )","user":"54bcab07e4b0ed20f4ff6ed5"},{"problem":100,"code":"(fn lcm [x & xs]\n  (loop [n x]\n    (if (every? #(zero? (rem n %)) xs)\n      n\n      (recur (+ n x)))))","user":"50385746e4b0803468ea2c6d"},{"problem":100,"code":"(fn [n & r]\n\t(first (drop-while #(not-every? (fn [x] (= 0 (rem % x)))\n                                    r)\n                       (iterate #(+ n %) n))))","user":"5742ec91e4b05c31a32c0883"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n   (/ (reduce * args) (reduce gcd args))))","user":"5fd66e61e4b05ac5b16ea10a"},{"code":"(fn lcm [& args]\n   (let [d (if (some ratio? args) (denominator (apply + args)) 1)\n         iargs (map #(/ 1 (* d %)) args)\n         a (/ (denominator (apply + iargs)) d)]\n     a)\n  )","problem":100,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"54bad977e4b0ed20f4ff6eb9"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n         (lcm [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm %&))","user":"55868660e4b059ccff29b1d4"},{"code":"(fn [& m]\r\n      (loop [i (apply min m) s i]\r\n        (if (= 1 (count (distinct (map #(mod i %) m))))\r\n          i\r\n          (recur (+ s i) s))))","problem":100,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":100,"code":"(fn [& s]\n  (let\n    [gcd (fn fff [x y]\n           (cond\n            (= x y) x\n            (> x y) (fff y x)\n            :else (let\n                    [r (mod y x)]\n                    (if \n                      (= r 0)\n                      x\n                      (fff r x)\n                      )\n                    )))\n     lcm (fn [x y]\n           (* x (/ y (gcd x y))))\n     ]\n    (reduce lcm s)))","user":"5e6e6537e4b04a83ad7cd29a"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] \n            (cond\n              (= a b) a\n              (> a b) (gcd (- a b) b)\n              (< a b) (gcd a (- b a))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]\n  (reduce lcm args)))","problem":100,"user":"5244fa73e4b0d8acf9ed6acb"},{"code":"(fn pr100 \n  ([m n]\n   (if (> n m)\n     (recur n m)\n     (letfn [(gcd [m n] ;m>=n\n               (if (zero? n)  \n                 m\n                 (recur n (rem m n))))]\n       (/ (* m n) (gcd m n)))))\n  ([m n & nums]\n   (reduce pr100 (pr100 m n) nums)))","problem":100,"user":"51696ee7e4b03f62cda68ce8"},{"code":"(fn [x & xs]\r\n  (letfn [(gcd [a b]                      \r\n    (if (= 0 b) a (gcd b (mod a b))))\r\n(lcm [a b] (/ (* a b) (gcd a b)))]\r\n(reduce lcm (cons x xs))))","problem":100,"user":"4dc986d0535d5973398f9285"},{"problem":100,"code":"(fn lcm [& args]\n  (->> \n   (range) \n   (rest) \n   (map #(* (apply max args) %)) \n   (filter (fn [x] (every? #(zero? (rem x %)) args))) \n   (first) \n   ))","user":"53c126fce4b00fb29b22125b"},{"code":"(fn [& xs]\n   (letfn [(gcd[x y] (if (zero? x) y (recur (mod y x) x)))\n           (lcm[x y] (/ (* x y) (gcd x y)))]     \n     (reduce lcm xs)))","problem":100,"user":"506406c8e4b075d771da6f9f"},{"problem":100,"code":"(fn [& numbers]\n  (let [gcd (fn [x y]\n              (cond\n                (= y 0) x\n                (= x 0) y\n                (> x y) (recur y (mod x y))\n                :else (recur y (mod y x))))]\n    (reduce (fn [x y] (* (/ x (gcd x y)) y)) numbers)))","user":"5694284de4b0dcc4269f410f"},{"problem":100,"code":"(fn [& z]\n  (reduce\n   (fn [a b]\n     (let [gcd (fn [a b] (if (= 0 b) a (recur b (mod a b))))]\n       (/ (* a b) (gcd a b))))\n   z))","user":"5de12192e4b0948ae9d9aded"},{"problem":100,"code":"(fn [& vals]\n  (letfn\n      [(gcd \n        [a b]\n        (if (zero? b)\n          a\n          (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) vals)))","user":"55d93d24e4b0e31453f64ac6"},{"problem":100,"code":"(fn __\n  [& x]\n  (let\n    [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n     lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm x)))","user":"5b73e500e4b047b03b2036ba"},{"code":"(fn [& c]\n  (loop [i 2]\n    (let [n (* (first c) i)]\n      (if (= (set (map #(mod n %) c)) #{0}) \n        n\n        (recur (inc i))))))","problem":100,"user":"512f06c5e4b0762be4c7aad7"},{"code":"#({2 6 5 105 1/3 2 3/4 3/2 7 210 %& %} %)","problem":100,"user":"5336a339e4b0e30313ee6c7d"},{"problem":100,"code":"(letfn [\n        (gcd [a b] (cond (> a b) (recur b a) (zero? a) b true (recur (mod b a) a)))\n        (lcm [a b] (/ (* a b) (gcd a b)))\n        ] (fn [& args] (reduce lcm args)))","user":"584dadebe4b0b7285a6f4e44"},{"problem":100,"code":"(fn lcm [& args]\n              (let [multiplier (apply min args)]\n                (first (first (filter #(every? zero? (second %)) \n                                      (map (fn [numerator] \n                                             [numerator (map #(rem numerator %) args)]) \n                                           (iterate #(+ multiplier %) multiplier)))))))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn [& args]\n  (let [start (apply min args)\n        end-args (map #(if (ratio? %) (denominator %) %) args)\n        end (+ (apply * end-args) 1)\n        r (range start end start)\n      lcd (fn [lst x] (if (every? #(= (mod x %) 0) lst) x nil))\n\t    lcd-of-args (partial lcd args)]\n  (some lcd-of-args r)))","problem":100,"user":"4e6a4edd535d8ccf87e9fec4"},{"problem":100,"code":"(fn [& args]\n  (let [x' (first args)]\n    (loop [x x']\n      (if (some false? (map #(= (rem x %) 0) args))\n        (recur (+ x x'))\n        x))))","user":"536673a8e4b0243289761e76"},{"problem":100,"code":"(fn [& l]\n            (let [top (apply max l) lst (drop-last (apply sorted-set l))]\n              (loop [multiplier 1]\n                (if (every? zero? (map #(rem (* top multiplier) %) lst))\n                  (* top multiplier)\n                  (recur (inc multiplier)))\n                )\n              )\n            )","user":"5d974b1de4b0d3f9b434ad36"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd [x y] (if (= y 0) x (gcd y (mod x y))))\n          (lcm2 [a b] (/ (* a b) (gcd a b)))]\n    (if (= 2 (count nums))\n      (let [[a b] nums]\n        (lcm2 a b))\n      (apply lcm (lcm2 (first nums) (second nums))\n                 (drop 2 nums)))))","problem":100,"user":"4f04f847535dcb61093f6beb"},{"code":"(fn [& args]\n  (let [some-mult (fn [n] (into #{} (take 1000 (map (partial * n) (iterate inc 1)))))]\n  \t(first (sort (apply clojure.set/intersection (map #(some-mult %) args))))))","problem":100,"user":"4ec3b393535dcc7ae8597d59"},{"problem":100,"code":"(fn [& args]\n  (reduce (fn [a b]\n               (/ (* a b) ((fn [x y]\n                                (let [a (max x y)\n                                      b (min x y)\n                                      m (mod a b)]\n                                  (if (zero? m)\n                                    b\n                                    (recur b m)))) a b))) args))","user":"5e978fe5e4b0157ca96647d1"},{"problem":100,"code":"(fn lcm-mult [& args]\n  (letfn [(gcd [x y]\n     (if (= 0 y)\n          x\n          (recur y (rem x y))))\n      (lcm [x y]\n       (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"5a593521e4b05d388ecb6c93"},{"code":"(fn [& ns]\n  (loop [a (map #(iterate (partial + %) %) ns)]\n    (let [f (apply min-key first a) l (apply max-key first a)]\n      (if (= f l)\n        (first f)\n        (recur (map #(if (= (first f) (first %)) (rest %) %) a))))))","problem":100,"user":"4f04b66b535dcb61093f6bdd"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n   (reduce (fn [a b] (/ (* a b) (gcd a b))) %&))","user":"5d81eba4e4b0915913b1d37b"},{"problem":100,"code":"#(letfn [(gdc [a r] \n           (cond\n             (< a r) (recur r a)\n             (not= 0 (mod a r)) (recur r (mod a r))\n             :ese r))]    \n   (/ (apply * %&) (reduce gdc %&)))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [& nums]\n  (letfn\n    [(min-index [xs]\n       (loop [m (first xs) m-idx 0 ys (rest xs) idx 1]\n         (if (seq ys)\n           (if (< (first ys) m)\n               (recur (first ys) idx (rest ys) (inc idx))\n               (recur m m-idx (rest ys) (inc idx)))\n           m-idx)))]\n  (let [nums (vec nums)]\n    (loop [xs nums]\n      (if (apply = xs)\n        (xs 0)\n        (let [idx (min-index xs)]\n          (recur (assoc xs idx (+ (xs idx) (nums idx))))))))))","problem":100,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn [& xs]\n  (loop [M 2]\n    (let [ms (group-by identity (flatten (for [x xs] (map #(* x %) (range 1 M)))))\n          t (filter (fn [[k v]] (= (count xs) (count v))) ms)]\n      (if (= 1 (count t))\n        (first (first t))\n        (recur (inc M))))))","problem":100,"user":"4ea365e2535d7eef308072c5"},{"problem":100,"code":"(fn lcm [& more]  \n  (if (every? (comp not ratio?) more)\n    (loop [m (apply max more)]\n      (if (every? (partial = 0) (map (partial mod m) more))\n        m\n        (recur (inc m))))\n    (letfn [(denr [x] (if (ratio? x) (denominator x) 1))\n            (numr [x] (if (ratio? x) (numerator x) x))]\n      (let [f (apply lcm (map denr more))\n            v (map (partial * f) more)]\n        (/ (apply lcm v) f)\n        ))))","user":"5744d088e4b009280f9f2b41"},{"code":"(fn [& args]\n  (reduce\n   #(/\n     (* %1 %2)\n     ((fn gcd [a b]\n        (if (= 0 b) a (gcd b (mod a b)))) %1 %2))\n   args))","problem":100,"user":"51170b49e4b0063b4e3e16d9"},{"code":"(fn [& numbers] \n  (letfn [(common-multiple? \n           [n factors]\n           (every? #(zero? (rem n %)) factors))]\n    (let [max-number (first (sort > numbers))]\n      (first (filter #(common-multiple? % numbers) (iterate #(+ max-number %) max-number))))))","problem":100,"user":"52a32876e4b04e0c58e87bfb"},{"code":"(fn [& c]\r\n  (loop [cf (map #(vector % %) (sort c))]\r\n    (let [v (map first cf)]\r\n      (if (apply = v)\r\n        (first v)\r\n        (recur (sort-by first\r\n                 (conj\r\n                   (rest cf)\r\n                   [(apply + (first cf)) (last (first cf))])))))))","problem":100,"user":"4f0f01c0535d0136e6c22329"},{"problem":100,"code":"#(reduce (fn [a n] (* a n (/ ((fn g [a b] (if (zero? b) a (recur b (mod a b)))) a n)))) %&)","user":"523630eee4b05f3be1c7c8e8"},{"problem":100,"code":"(fn lcm [& args]\n  {:pre [(every? (and rational? pos?) args)]}\n  (cond\n    (empty? args)  nil\n\n    ;; For integers, we look at the sequence of multiples for each argument, cut\n    ;; each sequence off at the product of the args (which is guaranteed to be\n    ;; at least as large as the lcm), then convert them to sets, and take the\n    ;; intersection and the minimum.\n    (every? integer? args)\n    (let [\n          ;; This function returns the sequence of all positive multiples of its\n          ;; arguments; i.e., the sequence (x 2x 3x 4x ...)\n          multiples\n          (fn [x] (iterate (partial + x) x))]\n                                                       ; e.g., args = (6 4):\n      (->> (map multiples args)                        ; ((6 12 ...) (4 8 ...))\n           (map (partial take-while\n                         (partial >= (apply * args)))) ; ((6 12) (4 8 12))\n           (map set)                                   ; (#{6 12} #{4 8 12})\n           (apply clojure.set/intersection)            ; #{12}\n           (apply min)))                               ; 12\n\n    ;; For ratios, we have to first clear the common denominator (determined by\n    ;; another call to the integer form of lcm), then apply lcm to the result\n    ;; and re-apply the denominator.\n    :else\n    (let [lcd (lcm (->> (remove integer? args)\n                        (map denominator)\n                        (apply lcm)))]\n      (/ (apply lcm (map (partial * lcd) args)) lcd))))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn [& xs]\n  (loop [acc (apply vector xs)]\n    (if (apply == acc)\n      (first acc)\n      (let [idx-min (ffirst (sort-by second < (map-indexed #(vector % %2) acc)))]\n        (recur (assoc acc idx-min (+ (nth acc idx-min) (nth xs idx-min))))))))","problem":100,"user":"504f865ee4b0a02f9cffde90"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n  (reduce #(lcm %1 %2) args)))","problem":100,"user":"4f1bee08535d64f60314647e"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (= 0 a) b (recur (mod b a) a)))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [a & c] (first (filter (fn [n] (every? #(= 0 (rem n %)) c))  (iterate (partial + a) a))))","problem":100,"user":"4f1d1d95535d64f603146488"},{"problem":100,"code":"(fn [& args]\n  (let [gcd \n       (fn [a b] (if (= b 0) a\n                   (recur b (mod a b))))]\n     (/ (apply * args) (reduce gcd args))))","user":"5eeeb000e4b07c55ae4a0515"},{"problem":100,"code":"(fn lcm [& nums] (let [all-same (fn [xs] (let [elem (first xs)] (reduce #(and %1 (= elem %2)) true xs)))\n                       smallest (fn [xs] (reduce #(if (< %1 %2) %1 %2 ) xs))\n                       inner-lcm (fn [xs ys] (if (all-same ys)\n                                   \t \t\t\t (first ys)\n                                   \t \t\t\t (recur xs (let [index-of-smallest (.indexOf ys (smallest ys))]\n                                                                     (vec (concat (subvec ys 0 index-of-smallest) \n                                                                            \t  (vector (+ (ys index-of-smallest) (xs index-of-smallest))) \n                                                                                  (subvec ys (inc index-of-smallest))))))))]\n                   (inner-lcm (vec nums) (vec nums))))","user":"542c1f73e4b0dad94371f29d"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (loop [seqs (map (fn [n] (iterate #(+ % n) n)) args)]\n    (if (apply = (map first seqs))\n      (first (first seqs))\n      (let [m (apply max (map first seqs))]\n        (recur (map (fn [s] (drop-while #(< % m) s)) seqs))))))","user":"5f37263de4b0574c87022c4e"},{"problem":100,"code":"(fn [& a]\n  (loop [r (vec a)]\n    (if (apply = r)\n      (first r)\n  \t  (let [i (->> r (map-indexed #(vector %2 %)) sort first second)]\n        (recur (update-in r [i] + (nth a i)))))))","user":"5499e23de4b03163384f4706"},{"code":"(fn lcm [& args]\n  (letfn [\n          (gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))\n              )\n            )\n          (abs [a]\n            (if (> a 0)\n              a\n              (- a)\n              )\n            )\n          ]\n        \n    (/ (apply * args) (reduce #(gcd %1 %2) args))\n\n    )\n  )","problem":100,"user":"510b704ee4b078ea71921100"},{"problem":100,"code":"(fn [& a] (reduce (fn [x y] (* x (/ y ((fn [a b] (if (zero? b) a (recur b (mod a b)))) x y)))) (seq a)))","user":"56ab7578e4b03c432f18733d"},{"problem":100,"code":"(fn [ & xs]\n  (first (sort (apply vector (apply clojure.set/intersection (for [x xs\n         :let [y (set (map (partial * x) (range 1 (reduce * 100 xs))))]]\n     y)))))\n     \n     )","user":"540479e7e4b0addc1aec665a"},{"code":"(fn big-lcm\n  [& more]\n  (let [m (reduce min more)\n        mult-seq (fn [x] (iterate #(+ % x) x))                                \n        dba? (fn [nums x]\n                (every? true? (map\n                               #(= 0 (rem x %)) nums)))\n        s (mult-seq m)]\n    (first\n     (filter #(dba? more %) s))))","problem":100,"user":"4e7f32ee535db966e863cc3a"},{"code":"(fn [& xs]\n  (let [\n        common \n          (fn common [l & others]\n            (if (= 1 (count others)) \n              (filter #(some #{%1} (first others)) l) \n              (filter #(and (some #{%1} (first others)) (not (empty? (apply common (list %1) (rest others))))) l)))\n        multiples \n          (fn [x](iterate (partial + x) x))\n        whole-number \n          (fn [n]\n            (if (ratio? n) (= (denominator n) (numerator n)) true))\n        first-whole-multiple \n          (fn [n]\n            (first (filter whole-number (multiples n))))\n        maxMultiple \n          (apply * (map first-whole-multiple xs))\n        ]\n        (first (apply common (map #(take-while (partial >= maxMultiple) (multiples %)) xs)))))","problem":100,"user":"5142e808e4b0c172af7558c9"},{"problem":100,"code":"(fn [x y & z]\n  (loop [v (map #(iterate (partial + %) %) (apply vector x y z))]\n    (let [f (map first v) f1 (first f)]\n      (if (every? #(= f1 %) f)\n        f1\n        (let [m (apply min f)]\n          (recur (map #(if (= %1 m) (rest %2) %2) f v)))))))","user":"564a5a09e4b0284900eef656"},{"code":"(fn [& a] (let [mm (apply max a)]\n                           (loop [c mm]\n                             (if (every? #(zero? (mod c %)) a) c (recur (+ c mm))))))","problem":100,"user":"52d7a930e4b09f7907dd1379"},{"problem":100,"code":"(fn [& n] (reduce (fn [a b] (first (filter (fn [x] (= 0 (mod x b))) (range a 250 a)))) (/ 1 2) n))","user":"569c40cee4b0542e1f8d1462"},{"code":"(fn [& a]\n  (let [g #(if (= 0 %1) %2 (recur (mod %2 %1) %1))\n        n #(if (ratio? %) (numerator %) %)\n        d #(if (ratio? %) (denominator %) 1)]\n    (reduce \n      #(/ \n        (/ (* (n %1) (n %2)) (g (n %1) (n %2)))\n        (g (d %1) (d %2)))\n      a)))","problem":100,"user":"4e5411e8535d8a8b8723a279"},{"problem":100,"code":"(fn lcm [& a]\n\t(loop [n 1]\n\t\t(if ((fn all-divisible? [a-seq n]\n\t(reduce #(and %1 %2) (map #((fn divisible? [x n]\n\t(zero? (mod x n))) n %) a-seq))) a n)\n\t\t\tn\n\t\t\t(recur (+ n 1/2)))))","user":"563d12f9e4b0bfe05bf11845"},{"problem":100,"code":"(fn [& vars]\n  (letfn[(gcm\n           [a b]\n           (if (= 0 b)\n             a\n             (recur b, (rem a b))))\n         (lcm\n           [a b]\n           (/ (* a b) (gcm a b)))\n         (lot-of-lcm [vars] (reduce lcm vars))]\n    (lot-of-lcm vars)))","user":"55b22c33e4b0da326a65cf79"},{"problem":100,"code":"(fn [& numbers]\n           (loop [numbers' (vec numbers)]\n             (if (apply = numbers')\n               (first numbers')\n               (let [min-index (first (apply min-key second (map-indexed vector numbers')))]\n                 (recur (assoc numbers'\n                          min-index\n                          (+ ((vec numbers') min-index) ((vec numbers) min-index))))))))","user":"5fef4292e4b05ac5b16ea1d7"},{"code":"(fn [& more] \n  (/ \n    (apply * more) \n    (reduce \n      (fn [a b]\n        (if (or (zero? a) (zero? b) (= a b))\n          (max a b)\n          (recur (- (max a b) (min a b)) (min a b))))\n    more)))","problem":100,"user":"503e7f06e4b06c4e0e1fa268"},{"code":"(fn [& nums]\n  (let [gcd (fn gcd [a b]\n              (if (= b 0)\n                a\n                (gcd b, (rem a b))))]\n    (reduce (fn [x y] (/ (* x y) (gcd x y))) nums)))","problem":100,"user":"5175616ae4b0dea9bbfba576"},{"problem":100,"code":"(fn [& args]\n  (/ (apply * args) ((fn [args]\n  (reduce (fn gcd [a b]\n            (let [x (min a b)\n                  y (max a b)\n                  r (mod y x)]\n              (if (= 0 r)\n                x\n                (gcd r x)))) args)) args)))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":100,"code":"(fn [& factors] (first (sort (for [[id freq] (frequencies (mapcat (fn [x] (take 500 (iterate #(+ % x) x))) factors)) :when (= freq (count factors))]  id))))","user":"54eea988e4b024c67c0cf875"},{"code":"(fn [& ns]\n  (some (fn [m] (when (every? #(= (mod m %) 0) ns) m))\n    (map #(* % (first ns)) (rest (range)))))","problem":100,"user":"4e8612f8535db62dc21a62f2"},{"problem":100,"code":"(fn [& x ]\n(/ (reduce *\nx )\n        (reduce\n                (fn gcd [a b]\n                (if (= a 0) b\n                        (gcd (rem b a) a)\n                )\n        ) x)\n)\n)","user":"5661b0a9e4b068f2fe63dc6f"},{"problem":100,"code":"(fn [& numbers]\n  (let [nseq (map (fn [a] [a a]) numbers)]\n    (loop [numbers nseq]\n      (if (apply = (map second numbers))\n        (second (first numbers))\n        (let [[f & r] (sort-by second numbers)]\n          (recur\n           (conj r [(first f) (+ (first f) (second f))])))))))","user":"545c2d07e4b01be26fd7465c"},{"problem":100,"code":"(fn lcm_multi [& args]\n  (letfn [(gcd [a b] (if (zero? a) b (recur (rem b a) a)))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"5f82609ae4b0c071e6c840f9"},{"problem":100,"code":"(fn [f & x]\n  (letfn [(md [n] (= 0 (reduce #(+ % (mod n %2)) 0 (cons f x))))]\n  \t(first (filter md (iterate #(+ % f) f)))))","user":"5654d0e1e4b0f9d632dd848c"},{"code":"(fn [& args]\r\n   (reduce\r\n    (fn [a b]\r\n      (letfn [(gcd [x y] \r\n  \t   (cond\r\n\t\t    (zero? x) y\r\n\t\t    (zero? y) x\r\n\t\t    :else (recur y (mod x y))))]\r\n\t(/ (* a b) (gcd a b))))\r\n    args))","problem":100,"user":"4e8768f6535dceadca469850"},{"problem":100,"code":"(fn lcm [& xs]\n  (apply min\n         (apply clojure.set/intersection\n                (map #(apply hash-set %)\n                     (map (fn [x] (take 420 (iterate #(+ ((constantly x)) %) x))) xs)))))","user":"52d84ea7e4b09f7907dd1390"},{"code":"#(loop [i 1/2]\r\n   (if (= 0 (apply + (for [j %&] (rem i j))))\r\n   i\r\n   (recur (+ 1/2 i))))","problem":100,"user":"4e43b0d9535dc968683fc4a3"},{"problem":100,"code":"(fn [& s]\n  (apply min\n         (apply clojure.set/intersection\n                (map\n                 (comp set range)\n                 s\n                 (repeat 211)\n                 s))))","user":"52541fe6e4b0541d1855b964"},{"problem":100,"code":"(fn [& args] (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n       (/ (reduce * args) (reduce gcd args))\n       ))","user":"560c37b5e4b05f002753df2e"},{"code":"(fn lcm [h & t]\n  (if (nil? t)\n\t\th\n\t\t(let [\n\t\t\tf (fn f [a b] (if (= b 0) a (f b (rem a b))))\n\t\t\tr (apply lcm t)\n\t\t\ta (max h r)\n\t\t\tb (min h r)\n\t\t\t] (/ (* a b) (f a b)))))","problem":100,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":100,"code":"(fn [& a]\n  (loop [a a\n         b (apply max a)\n         c (apply max a)]\n    (if (every? zero? (map #(rem b %) a)) \n      b\n      (recur a (+ b c) c))))","user":"5c538cb5e4b0fb8c5ffd99fb"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(gcd [x y]\n          \t(if (zero? y) x\n    \t\t\t(gcd y (mod x y))))]\n  (/ (apply * nums) (reduce gcd nums))))","user":"5a388675e4b001c08efc0ca2"},{"code":"(fn [x & s] \n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n\t(reduce #(/ (* % %2) (gcd % %2)) x s)))","problem":100,"user":"519ef784e4b087743fad2198"},{"code":"(fn lcm [& xs]\n  (letfn [(gcd [x y]\n               (cond\n                (< y x) (gcd y x)\n                (zero? (rem y x)) x\n                :else (gcd (rem y x) x)))]\n    (/ (reduce * (map #(if (ratio? %) (numerator %) %) xs))\n       (reduce gcd (map #(if (ratio? %) (denominator %) %) xs)))))","problem":100,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn [& args]\n   (letfn [(gcd [x y]\n            (let [x (rem x y)]\n              (if (= x 0)\n                  y\n                 (recur y x))))]\n    (/ (apply * args) \n       (reduce gcd (first args) (rest args)))))","problem":100,"user":"4ef992c8535dced4c769f268"},{"code":"(fn [& s]\r\n  (let [z (zipmap s s)]\r\n    (loop [z z]\r\n      (let [ v (vec z), f (first v), fv (val f), k (key f)]\r\n      (if (every? #(= (val %) fv) v)\r\n        fv\r\n        (let [mp (apply min-key val v), k (key mp), v (val mp)]\r\n          (recur (assoc z k (+ k v)))))))))","problem":100,"user":"4e44358f535dc968683fc4a8"},{"problem":100,"code":"(fn lcm [& xs]\n    (letfn [(gcd [x y]\n              (if (zero? y) x\n                  (recur y (mod x y))))]\n      (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"5a91988ae4b002d099cae6f9"},{"problem":100,"code":"(fn [& xs] (reduce \n            (fn [a b] \n              (letfn [(gcd [a b]\n                           (if (= 0 (mod a b))\n                             b\n                             (recur b (mod a b))))]\n                (/ (* a b) (gcd a b))))\n            xs))","user":"51a3be77e4b0e77c4ca60bf8"},{"problem":100,"code":"(fn my-least-mult\n [& nums]\n (apply min (apply clojure.set/intersection (for [n nums] (set (map (partial * n) (range 1 400)))))))","user":"59f44189e4b0966464fe6aab"},{"code":"(fn lcm [& nums]\n    (letfn [(denom [n] (if (ratio? n) (denominator n) 1))\n            (gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n        (/ (denominator (apply + (map / nums)))\n           (reduce gcd (map denom nums))\n        )))","problem":100,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":100,"code":"(fn [& vals]\n  (let [s (map (fn [y] (map (fn [x] (* (+ x 1) y)) (range))) vals)\n        lc (fn [streams]\n             (let [firsts (map first streams)\n                   minval (apply min firsts)]\n               (cond\n                 (some nil? firsts) nil\n                 (apply = firsts) (first firsts)\n                 :else (recur (map (fn [x] (if (= (first x) minval) (rest x) x)) streams)))))]\n    \n    (lc s)))","user":"5b15ab32e4b0cc2b61a3be72"},{"code":"(fn f [x & y]\n  (letfn [(g [x y add]\n             (if (every? #(zero? (rem x %)) y)\n               x\n               (g (+ x add) y add)))]\n    (g x y x)))","problem":100,"user":"52a55adee4b0c58976d9abe7"},{"problem":100,"code":"(letfn [\n  (gcd [x y]\n    (let [a (max x y)\n          b (min x y)\n          r (rem a b)]\n      (if (zero? r)\n        b\n        (gcd b r))))\n  (lcm [& xs]\n    (/ (reduce * 1 xs) (reduce gcd xs)))]\n  lcm)","user":"57717915e4b0979f896515b3"},{"code":"(fn [n m & ms]\n  (letfn [(gcd\n            ([m n]\n               (loop [m m n n]\n                 (if (zero? n)\n                   m\n                   (recur n (mod m n)))))\n            ([m n & ms]\n               (reduce gcd (gcd m n) ms)))]\n    (/ (apply * n m ms) (apply gcd n m ms))))","problem":100,"user":"4e6a4950535d8ccf87e9febf"},{"problem":100,"code":"(fn\n  [& nums]\n  (reduce (fn [a b]\n            (/ (* a b) ((fn [a b]\n                          (if (zero? b)\n                            a\n                            (recur b (mod a b))))\n                        a b)))\n          nums))","user":"5720a2b0e4b0c5bde472c099"},{"code":"(fn [& numbs]\n  (let [group (group-by ratio? numbs)\n        nums (concat (group false) (map numerator (group true)))\n        dens (map denominator (group true))\n        gcd2 #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n        gcd #(if (empty? %) 1 (reduce gcd2 %))]\n    (/ (apply * nums) (gcd nums) (gcd dens))))","problem":100,"user":"510db6cde4b078ea71921145"},{"code":"(fn [& h] (reduce #(* % %2 (/ ((fn f [x y] (if (= x 0) y (f (mod y x) x))) % %2))) h))","problem":100,"user":"526a7025e4b03e8d9a4a722a"},{"problem":100,"code":"; resuing gcd from http://www.4clojure.com/problem/66\n(fn lcm\n   ([c d & rest] (apply lcm (lcm c d) rest))\n   ([c d]\n    (/ (* c d)\n    ((fn gcd [a b] (if (zero? b) a (gcd b (rem a b)))) c d)))\n    )","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"55088bb3e4b06e50f9beb10c"},{"problem":100,"code":"(fn [& nums]\n  (let [big (reduce max nums)]\n    (loop [found false current big]\n      (if found (- current big)\n        (recur \n         (every? identity \n                 (map #(integer? (/ current %)) nums))\n         (+ current big))))))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn [& nums]\n  ((fn a [pairs] (let [sorted (sort-by first pairs)]\n      (if (=\n            (first (first sorted))\n            (first (last sorted)))\n        (first (first sorted))\n        (a\n          (cons\n            (list (apply + (first sorted)) (last (first sorted)))\n            (rest sorted))))))\n    (map #(list % %) nums)))","problem":100,"user":"4fb1325de4b081705acca276"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(power [x n] (rationalize (Math/pow x n)))\n\n          (get-max [s] (loop [iter 0 finals (first s)]\n                         (if (>=  iter (count s))\n                           finals\n                           (let [n (nth s iter)]\n                             (recur (inc iter) (map max finals n))))))\n            (sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n            \n            (pfactor [n] (fn [p]\n                         (loop [v n iter 0]\n                           (if (and (>= v p) (= 0 (mod v p)))\n                             (recur (quot v p) (inc iter))\n                             iter))))]\n\n    (let [ints (filter integer? nums)\n          ratios (filter ratio? nums)\n          n1 (map numerator ratios)\n          n2 (map denominator ratios)\n          max-n (apply max (concat ints n1 n2))\n          primes (take-while #(<= % max-n) (sieve (iterate inc 2)))\n          ]\n      (letfn [\n              (quots [n] (map (pfactor n) primes))\n              (indice [n]\n                 (if (ratio? n)\n                   (let [m1 (numerator n)\n                         m2 (denominator n)\n                         x1 (quots m1)\n                         x2 (map #(* -1 %) (quots m2))]\n                     (map + x1 x2))\n                   (quots n)))\n              ]\n        (reduce * (map power primes (get-max (map indice nums))))))))","user":"57b35ecbe4b0fbc9809a277e"},{"code":"(fn [& coll] \n  (reduce \n    #(loop [a %1 b %2]\n      (if\n        (zero? b)\n        (/ (* %1 %2) a)\n        (recur b (mod a b)))) \n   coll))","problem":100,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn [& ns]\n  (let [com-mult2\n        (fn [n1 n2]\n          (first ((fn com [s1 s2]\n                    (lazy-seq\n                     (let [h1 (first s1) h2 (first s2)]\n                       (cond (or (nil? h1) (nil? h2)) nil\n                             (= h1 h2) (cons h1 (com (rest s1) (rest s2) ))\n                             (< h1 h2) (com (rest s1) s2)\n                             (> h1 h2) (com s1 (rest s2))))\n                     )) (iterate #(+ % n1) n1) (iterate #(+ % n2) n2))))]\n    (reduce com-mult2 ns)))","problem":100,"user":"4dcc5aff535d5973398f9293"},{"problem":100,"code":"(fn lcm[& nums]\n  ( loop[i 1] \n    ( if (->> nums (map #(mod i %)) (filter #(not= % 0)) empty? )\n      i\n      (recur (+ i 1/2))\n     )\n    )\n  )","user":"5b3aa98be4b02d533a91bbca"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [x y] (if (= 0 y) x (gcd y (rem x y))))]\n    (let [nums (map #(if (ratio? %) (numerator %) %) args)\n          divs (map #(if (ratio? %) (denominator %) 1) args)\n          n (reduce gcd nums)\n          d (reduce gcd divs)]\n      (/ (reduce #(* % (/ %2 n)) 1 nums) d)\n      )))","user":"53b7c21ae4b047364c0444d4"},{"code":"(fn [& r]\n  (reduce\n    #(/\n      (* % %2)\n      ((fn f [a b]\n         (if (= b 0)\n             a\n             (f b (mod a b))))\n       % %2))\n    r))","problem":100,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [& nums]\n  (if (empty? nums)\n    (throw (Exception. \"Not enough arguments\"))\n    (let [n (first nums)\n          others (rest nums)]\n      (loop [trial n]\n        (if (some #(not (zero? (mod trial %))) others)\n          (recur (+ trial n))\n          trial)))))","problem":100,"user":"51d9eb05e4b02ceefd947755"},{"problem":100,"code":"(fn ans-100 [& args]\n  (reduce (fn [a b] (/ (* a b) ((fn [x y]\n                                  (loop [j x\n                                         k y]\n                                    (if (> k 0)\n                                      (recur k (mod j k))\n                                      j))) a b))) args))","user":"608fac60e4b03bd49d9f36c7"},{"code":"(fn [& rest]\n\t(reduce #(loop [x %1 y %2]\n            \t(cond \n             \t\t(= x y) x\n             \t\t(< x y) (recur (+ %1 x) y)\n             \t\t:else (recur x (+ y %2)))) \n        \trest))","problem":100,"user":"5098f5d6e4b0cae2931060a4"},{"code":"(fn [& xs] \n  (letfn [(gcd [x y] (if (= y 0) x (recur y, (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","problem":100,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":100,"code":"(fn lcm\n    ([x y]\n     (letfn [(gcd [a b]\n               (cond\n                 (zero? b) a\n                 (> a b) (gcd b (mod a b))\n                 :else (gcd a (mod b a))))]\n       (/ (* x y) (gcd x y))))\n    ([x y & rest] (apply lcm (lcm x y) rest)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))\n         (lcm ([a b] (/ (* a b) (gcd a b))))]\n   (reduce lcm %&))","user":"577b4440e4b0d3393e5deb0f"},{"problem":100,"code":"(fn [& ns] (reduce #(/ (* %1 %2) ((fn [x y] (loop[x' (max x y) y' (min x y)] (let [rem-num (mod x' y')] (if (zero? rem-num) y' (recur y' rem-num))))) %1 %2)) ns))","user":"58e7229fe4b056aecfd47cc4"},{"code":"(fn[& args]\n  (letfn[\n    (ggT[x y]\n      (ffirst (take 1 (drop-while\n        #(not (zero? (second %)))\n        (iterate (fn[[b a]] [a (mod b a)]) [x y])))))\n    (kgV[a b]\n      (/ (* a b) (ggT a b)))]\n  (reduce kgV args)))","problem":100,"user":"4e58bcd4535d8a8b8723a296"},{"problem":100,"code":"(fn [& numbers]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm numbers)))","user":"597f8c93e4b0dbe32238d0c1"},{"problem":100,"code":"(fn [& L]\n    ;;           \n    ;;     \n    (let [IncStep (apply max L)]\n      (loop [ MaxValue IncStep]\n        ;;(println MaxValue (map #(integer? (/ MaxValue %) ) L))\n        (if (every? true? (map #(integer? (/ MaxValue %) ) L) )\n          MaxValue\n          (recur (+ MaxValue IncStep))\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":100,"code":"(fn [& lst]\n    (reduce (fn [x y]\n              (let [gcd   #(. (BigInteger/valueOf %1) (gcd (BigInteger/valueOf %2)))\n                    destr #(if (ratio? %) [(numerator %) (denominator %)] [% 1])\n                    [a b] (destr x) ; x = a/b\n                    [c d] (destr y) ; y = c/d\n                    bd (gcd b d)\n                    newA   (/ (* a d) bd)\n                    newC   (/ (* b c) bd)\n                    newB=D (/ (* b d) bd)]\n                (/ (/ (* newA newC) (gcd a c))\n                   newB=D)))\n            lst))","user":"544e9022e4b0e3978000698b"},{"problem":100,"code":"(fn lcm\n  [& lst]\n  \n  (letfn [(gcd [x y]\n            (if (= x y)\n              x\n              (if (< x y)\n                (recur x (- y x))\n                (recur y (- x y)))))\n          \n          (lcm [x y] (/ (* x y) (gcd x y)))]\n    \n    (reduce lcm lst)))","user":"5a99ae99e4b0d174b936c7a4"},{"code":"(fn lcm\n  [& args]\n  (letfn [(gcd\n            [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))]\n    (reduce (fn [r e]\n              (/ (* r e)\n                 (gcd r e)))\n            (first args) (rest args))))","problem":100,"user":"5348cab4e4b084c2834f4a5e"},{"problem":100,"code":"(fn [& s]\n  (first (filter (apply every-pred (map #(fn [i] (= 0 (mod (max 0.01 i) %))) s))\n                 (iterate #(+ % (apply min s)) 0))))","user":"52f0ea04e4b05e3f0be25ee6"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (cond\n             (< a b) (gcd b a)\n             (= 0 (mod a b)) b\n             :else (gcd b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn lcm\n  ([a] a)\n  ([a b] (/ (* a b)\n            (loop [a a b b]\n              (if (= 0 b) a\n                (recur b (mod a b))))))\n  ([a b & r] (apply lcm (lcm a b) r)))","problem":100,"user":"4f1bb9d8535d64f60314647d"},{"problem":100,"code":"(fn lcm [& args]\n  (let [lcm-\n        (fn [x x2]\n          (if (zero? x2)\n            x\n            (recur\n              x2\n              (mod x x2))))]\n    (/ (reduce * args) (reduce lcm- args))))","user":"5bcb672ee4b07a9b28b10100"},{"code":"(fn [& lst] \n  (reduce \n     #(/ \n       (* % %2) \n       ((fn [a b] (if (zero? b) a (recur b (mod a b)))) % %2)\n       ) \n     lst))","problem":100,"user":"5281a445e4b0757a1b17143a"},{"problem":100,"code":"(fn lcm [& a]\n  (loop [agg (zipmap a a)]\n    (let [sums (vals agg)\n          maximum (apply max sums)]\n    (if (every? #(= maximum %) sums) maximum\n      (recur (zipmap (keys agg) (map\n               (fn incr [x] (if (< (val x) maximum) (+ (key x) (val x)) (val x)))\n               agg)))))))","user":"57131dfbe4b07c98581c3a98"},{"problem":100,"code":"(fn [& i] (let [gcd (reduce #(let [r (rem %1 %2)] (if (zero? r) %2 (recur %2 r))) i)] (/ (apply * i) gcd)))","user":"5e71f267e4b085ba37836dc1"},{"problem":100,"code":"(fn lcm-several\n  [& args]\n  (/ (apply * args) \n     (apply \n        (fn gcd-several\n          [& nos]\n          (reduce \n            (fn gcd-1\n              [m n]\n              (if (zero? n) \n                m\n                (recur n (rem m n)))) nos))\n        args)))","user":"56c3aca0e4b05cc29241ee90"},{"problem":100,"code":"(fn [& args] \n  (letfn [(gcd [x y]\n    (if (= y 0) x\n      (recur y (rem x y))))]\n  (/ (reduce * args) (reduce gcd args))\n  ))","user":"57d1a0e6e4b0bd073c20236d"},{"problem":100,"code":"(fn [& numbers]\n            (let [gcd (fn [x y]\n                        (loop [a x b y]\n                          (if (zero? b)\n                            a\n                            (recur b (rem a b)))))\n                  lcm (fn [a b]\n                        (* a (/ b (gcd a b))))]\n              (reduce lcm numbers)))","user":"5054d243e4b0b1b9d1860eb5"},{"code":"(fn lcm [x & xs]\n  (some (fn [y] (if (every? #(zero? (rem y %)) xs) y))\n        (iterate #(+ x %) x)))","problem":100,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [& l]\n  (let [m (reduce min l)]\n    (first \n     (for [x (iterate #(+ m %) m)\n        :when (= 0 (reduce #(+ %1 (rem x %2)) 0 l))]\n      x))))","problem":100,"user":"51aefceee4b09397d5109797"},{"problem":100,"code":"(fn [& ws]\n    (loop [xs (for [w ws] [w w])]\n      (if (apply = (map first xs))\n        (ffirst xs)\n        (let [ys (sort xs)\n              [[a b] & oys] ys]\n          (recur (concat [[(+ a b) b]] oys))))))","user":"55773cbae4b05c286339e07f"},{"code":"(fn [& ns]\n    (let [s0 (zipmap ns ns)\n          lcm (fn lcm [state]\n                (if (apply = (vals state))\n                  (first (vals state))\n                  (let [mk (apply (partial min-key state) (keys state))\n                        mv (state mk)]\n                    (recur (assoc state mk (+ mk mv))))))]\n      (lcm s0)))","problem":100,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn [& s]\n (let [vals (vec s)]\n   (loop [t (vec s)]\n     (let [m (apply min t)\n           i (ffirst (filter #(= m (last %)) (map-indexed vector t)))]\n       (if (every? (partial = m) t)\n         m\n         (recur (update-in t [i] (partial + (vals i)))))))))","problem":100,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":100,"code":"(fn [a & bs] \n  (reduce \n    (fn lcm [a b] (-> a (* b) (/ ((fn gcd [a b] (if (zero? a) b (recur (mod b a) a))) a b)))) \n    a bs))","user":"58134ba8e4b0f478707a060b"},{"problem":100,"code":"(fn [& x]\n   (reduce (fn [a, b]\n             (* (/ a ((fn gcd [x y]\n                        (if (not= (mod x y) 0)\n                          (gcd y (mod x y))\n                          y)) a b)) b)) x))","user":"5ab170c2e4b073f1774425cb"},{"problem":100,"code":"(fn [& coll]\n  (letfn [(gcd [x y]\n            (if (= y 0) x\n                (gcd y (rem x y))))]\n    (/ (reduce * coll) (reduce gcd coll))))","user":"53f053ebe4b0742d9025b0d3"},{"problem":100,"code":"(fn lcm [& ns]                                       (letfn [(gcd [a b]                                             (let [remed (rem a b)]                                 (if (zero? remed)                                      b                                                    (recur b remed))))                             (term [a b]                                                                                                 (/ (* a b)                                              (gcd a b)))]                              (if (empty? (rest ns))                                 (first ns)                                           (term (first ns)                                           (apply lcm (rest ns))))))","user":"5895477fe4b00487982d527c"},{"problem":100,"code":"(fn solv [& xs]\n  (let [v (fn vv [e] (set (map #(* % e) (range 1 500))))\n        d (fn dd [a b] (first (sort (clojure.set/intersection (v a) (v b)))))]\n    (reduce (fn [acc x] (d acc x))\n            xs)))","user":"52c35afce4b07a9af579238c"},{"problem":100,"code":"(fn [& args]\n  (reduce  #(/ ( * % %2) ((fn common-divisor [num1 num2]\n  (cond (= 0 (rem num1 num2))\n        num2\n        (= 0 (quot num1 num2))\n        1\n        :else \n        (common-divisor num2 (rem num1 num2)))) (max % %2) (min % %2))) args))","user":"50e90813e4b033b0e80d11e7"},{"code":"(fn my-lcm [& nums]\n  (loop [v nums]\n    (if (apply = v) \n      (first v)\n      (let [minimum (apply min v)]\n        (recur (map #(if (= %1 minimum) (+ %1 %2) %1) v nums))))))","problem":100,"user":"4e7263a1535d5021c1a8965f"},{"code":"(fn [& ns]\n  (let [gcd\n        (fn gcd [a b]\n          (if (= b 0) a\n            (gcd b (mod a b))))]\n \t (/ (apply * ns) (reduce gcd ns))))","problem":100,"user":"529ce629e4b04e0c58e87b6e"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (loop [a a b b] (if (= a 0) b (recur (mod b a) a))))]\n    (reduce (fn [a x] (/ (* a x) (gcd a x))) args)))","user":"606a70a5e4b069485764ddf2"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (min x y)\n                  b (max x y)]\n              (if (zero? (mod b a))\n                a\n                (recur (mod b a) a)\n                )))\n          (lcm [x y]\n            (/ (* x y) (gcd x y)))]\n    (reduce (fn [acc e] (lcm acc e)) args)\n   )\n )","user":"56f7ecdfe4b08e7d20b96834"},{"problem":100,"code":"(fn [& args] \n  (let [mcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce mcd args))))","user":"6074e1ade4b069485764de4e"},{"code":"(fn\n  [a & others]\n  (first (filter (fn [e] (every? #(not (ratio? (/ e %))) others)) (map #(* a %) (iterate inc 1)))))","problem":100,"user":"516d2a46e4b06f078fab252f"},{"code":"#(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n         (lcm [c d]\n              (/ (* c d) (gcd c d)))]\n   \n   (reduce lcm %&))","problem":100,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":100,"code":"(fn [& nums]\n  (loop [curr nums]\n    (if (apply = curr)\n      (first curr)\n        (recur (map-indexed #(if (< %2 (apply max curr)) (+ %2 (nth nums %1)) %2) curr)))))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn [& l]\n  (reduce (fn lcm [x y]\n            (first \n              (filter \n                #(= (mod % y) 0)\n                (iterate (partial + x) x)\n                )\n              )  \n            ) (first l) l))","problem":100,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":100,"code":"(fn [& nums]\n  (let [gcm (fn [a b]\n              (if (= a b)\n                a\n                (if (> a b)\n                  (recur (- a b) b)\n                  (recur b (- b a)))))]\n    (/ (reduce * nums) (reduce gcm nums))))","user":"59750a68e4b01722bebd4cba"},{"problem":100,"code":"(letfn [(gcd [a b]\n                          (cond (> b a) (gcd b a) (= b 0) a true (gcd b (rem a b))))\n                        (lcm [a b]\n                          (if (= a b 0) 0 (/ (* a b) (gcd a b))))\n                        (lcm* [a b]\n                          (let [[x y] (if (ratio? a)\n                                        [(numerator a) (denominator a)]\n                                        [a 1])\n                                [z u] (if (ratio? b)\n                                        [(numerator b) (denominator b)]\n                                        [b 1])]\n                            (/ (lcm (* x u) (* z y))\n                               (* u y))))]\n                  (fn [& args]\n                    (reduce lcm* args)))","user":"53889587e4b0640c7a9a589e"},{"problem":100,"code":"(fn [& items]\n  (reduce \n    (fn [acc item]\n        (/ (* acc item) ((fn gcd [a b]\n                           (cond\n                             (> b a) (gcd b a)\n                             (zero? b) a\n                             :else (gcd b (rem a b)))) acc item)))\n    items))","user":"60b2aaebe4b0e0fa5f1b4228"},{"code":"(fn [v & r]\n  (loop [n v]\n    (if (every? #(do %) (map #(= 0 (rem n %)) r))\n      n\n      (recur (+ n v)))))","problem":100,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"#(letfn [(gcd [n r] (if (zero? r) n (gcd r (rem n r)))) (lcm [a b] (* b (/ a (gcd a b))))] (reduce lcm %&))","problem":100,"user":"51b90b88e4b050a1176cd6a2"},{"problem":100,"code":"(fn [x & xs]\n  (first\n   (filter\n    (fn [n]\n      (every? #(zero? (mod n %)) xs))\n    (iterate #(+ % x) x))))","user":"56ae214ce4b03c432f18735a"},{"problem":100,"code":"(fn [ & l] (loop [b (apply min l) x b] (if (every? #(= 0 (mod x %)) l) x (recur b (+ x b)))))","user":"53b2a7f8e4b047364c04449c"},{"problem":100,"code":"(fn [& x]\n  (reduce\n    #(loop [y %1]\n      (if (= 0 (mod y %2))\n        y\n        (recur (+ y %1))))\n    x))","user":"58247423e4b051871117bec5"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                (recur b (mod a b))))\n          (gcd2 [xs] \n                (reduce #(gcd %1 %2) xs))]\n    (/ (apply * xs) (gcd2 xs))))","problem":100,"user":"51efd397e4b0249c592fbdeb"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (let [gcd (fn [a b]\n               (cond\n                 (= 0 (mod a b)) b\n                 :else (recur b (mod a b))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & nums]\n   (reduce lcm (concat [x y] nums))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (let [a (max x y)\n                     b (min x y)\n                     m (mod a b)]\n                 (if (zero? m)\n                   b\n                   (recur b m))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"56ca0da9e4b0ea9b8538f715"},{"problem":100,"code":"(fn lcm [& numbers]\n  (/ (apply * numbers)\n     ((fn gcd [a b rst ]\n       (cond \n        (and (zero? b) (empty? rst))\n          a\n        (not (zero? b))\n          (gcd b (mod a b) rst)\n        (and (zero? b) (not (empty? rst)))\n          (gcd a (first rst) (drop 1 rst)))) (first numbers) (second numbers) (drop 2 numbers))))","user":"5486e317e4b0e286459a11c0"},{"problem":100,"code":"(fn [& xs]\n(reduce #(/ (* % %2)\n              (loop [a %\n                     b %2]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b)))))\n          (first xs) (rest xs)))","user":"559067ace4b0277789237670"},{"problem":100,"code":"(fn lcd [& nums]\n    (let [gcd (fn [a b]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))\n          lcd (fn [a b]\n                (/ (* a b)\n                   (gcd a b)))]\n      (reduce lcd (first nums) (rest nums))))","user":"5501a1e1e4b07d26eda61d75"},{"code":"(fn [& xs]\n   (let [gcd (fn [a b](if (zero? b) a (recur b (mod a b))))\n         lcm (fn [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm xs)))","problem":100,"user":"4dcfbc44535d5973398f92a7"},{"problem":100,"code":"(fn [x & xs]\n  (let [mult? #(mod %1 %2)\n        match #(when (every? zero? (map (partial mult? %) xs)) %)]\n    (some match (iterate #(+ % x) x))))","user":"53fcd574e4b0de5c418485d9"},{"problem":100,"code":"(fn solve [& v]\n  (let [abs (fn [x]\n              (max (- x) x))\n        gcd (fn [a b]\n              (if (= a b)\n                a\n                (if (> a b)\n                  (recur b (- a b))\n                  (recur a (- b a)))))\n        lcm (fn [a b]\n              (/ (abs (* a b))\n                 (gcd a b)))]\n    (reduce lcm v)))","user":"518279abe4b0353c468deb65"},{"problem":100,"code":"(fn lcm2 [& is]\n  (letfn [(alleq [s] (apply = (map first s)))\n          (mini [s] (apply min (map first s)))\n          (incn [s n] (reduce #(conj %1 (let [[a b] %2]\n                                          (if (= a n)\n                                            [(+ a b) b]\n                                            [a b])))\n                              []\n                              s))]\n    (let [dupl (map vector is is)]\n      (loop [s dupl]\n        (if (alleq s)\n          (first (first s))\n          (recur (incn s (mini s))))))))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn [& n] \n  (loop [o n r n] \n    (if (apply = r) \n        (first r) \n        (recur o (map-indexed #(+ %2 (if (= %2 (apply min r)) \n                                         (nth o %)\n                                         0))\n                              r)))))","problem":100,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":100,"code":"#(reduce (fn [c d] (/ (* c d) ((fn [a b] (if (zero? b) a (recur b (mod a b)))) c d))) (vec %&))","user":"53d5d24de4b0e771c302544a"},{"problem":100,"code":"(fn [& xs]\n  (let [multiples (fn [x] (iterate #(+ x %) x))]\n    (loop [mult-seqs (map multiples xs)]\n      (if (apply = (map first mult-seqs))\n        (ffirst mult-seqs)\n        (let [max-first (apply max (map first mult-seqs))]\n          (recur (map #(if (< (first %) max-first) (rest %) %) mult-seqs)))))))","user":"5353afa0e4b084c2834f4b03"},{"problem":100,"code":"(fn lcm [& factors]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) factors)))","user":"54c3747de4b045293a27f60e"},{"code":"(fn [& s]\n  (let\n    [rp\n      (reduce * (map #(if (ratio? %) (denominator %) 1) s))]\n    (first (filter\n      (fn [n] (every? #(= 0 (rem n %)) s))\n      (map\n        #(/ % rp)\n        (rest (range)))))))","problem":100,"user":"4f1b0ab3535d64f603146474"},{"code":"#(/\n  (reduce\n    (fn g [a b]\n      (if (= 0 b) a (g b (mod a b))))\n  (map / %&))\n)","problem":100,"user":"4f40ccd9e4b0e243712b1fc0"},{"problem":100,"code":"(fn [& n] \n  (apply min (apply clojure.set/intersection (reduce #(conj %1 (set (map (fn[el] (* el %2)) (range 1 1000)))) '() n)))\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":100,"code":"(fn [x & y]\n  (loop [a x b y]\n    (if (empty? b)\n      a\n      (recur\n       ((fn [a b]\n  (let [gcd_val\n        (#(if (zero? %) %2\n            (recur (mod %2 %) %)) a b)]\n    (if (zero? gcd_val) 0\n        (/ (* a b) gcd_val)))) a (first b))\n       (rest b)\n       ))))","user":"571077e8e4b09c608db70434"},{"code":"(fn [a & bs] \n  (first \n    (filter \n      (fn [c] (every? #(= 0 (mod c %)) bs))\n      (map * (repeat a) (rest (range))))))","problem":100,"user":"4db2cd84535df7e46ed9b6c6"},{"code":"(fn [& args]\r\n   (letfn [(gcd [x y]\r\n                (if (= 0 (mod x y))\r\n                  y\r\n                  (recur y (mod x y))))]\r\n          (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"4fc8b012e4b0ee37620e1838"},{"problem":100,"code":"(fn lcm [& args] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (apply * args) (reduce gcd args))))","user":"57db2369e4b0bd073c20241f"},{"problem":100,"code":"#(/ (reduce * %&) (reduce (fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) %&))","user":"587294f0e4b01531a375ea1e"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [common-multiple? (fn [n]\n                           (->> xs\n                                (map #(rem n %))\n                                (every? zero?)))\n        x (apply max xs)]\n    (loop [m 1]\n      (let [lcm-candidate (* x m)]\n        (if (common-multiple? lcm-candidate)\n          lcm-candidate\n          (recur (inc m)))))))","user":"5813e208e4b0f478707a061b"},{"problem":100,"code":"(fn [& nums] (reduce \n\t\t\t(fn [a b] (->> (rest (range))\n               (map #(* a %))\n               (filter #(= 0 (mod % b)))\n               first))\n            nums))","user":"56561119e4b0f9d632dd849d"},{"code":"(fn [& s]\n(reduce\n  (fn lcm [a b] (/\n    (* a b)\n    ((fn gcd [a b]\n      (if (= b 0)\n        a\n        (gcd b (mod a b)))) a b)))\n  s))","problem":100,"user":"4fa67030e4b081705acca1b7"},{"code":"(fn [& ls]\n  (letfn [(gcd [x y]\n    (cond\n      (zero? x) y\n\t    (zero? y) x\n\t    :else (recur y (mod x y))))]\n    (reduce (fn [acc e]\n      (/ (* acc e) (gcd acc e)))\n      ls)))","problem":100,"user":"4de165f3535d08e6dec9fde6"},{"code":"(fn lcm [x y & xs]\n  (let [lcm* (fn [x y]\n    (let [\n    z-plus (drop 1 (range))\n    xs (map (partial * x) z-plus)\n    ys (map (partial * y) z-plus)\n    ys-contains? (fn [n]\n      (->> ys (take-while #(<= % n)) (some #(== n %))))\n    ]\n    (if (or (== 0 x) (== 0 y))\n      0\n      (some #(when (ys-contains? %) %) xs))))]\n  (reduce #(lcm* %1 %2) (lcm* x y) xs)))","problem":100,"user":"4e691c79535d8ccf87e9fe97"},{"problem":100,"code":"(fn lcm [& args] (if\n                   (second args)\n                   (apply lcm (concat\n                               [(first (filter\n                                        #(= (mod % (second args)) 0)\n                                        (map #(* (first args) (inc %)) (range))))]\n                               (rest (rest args))))\n                   (first args)))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn lcm\n  ([x y]\n     (letfn [(gcd [a b]\n               (cond\n                (= b 0) a\n                (> a b) (gcd b (mod a b))\n                (> b a) (gcd a (mod b a))))]\n       (/ (* x y) (gcd x y))))\n  ([x y & rest] (apply lcm (lcm x y) rest)))","problem":100,"user":"4dad76588e77d6ed63f12a44"},{"problem":100,"code":"(fn lcm [& args]\n  (let [xs0 (into [] args)]\n    (letfn [(inc-slot [[i m]] \n              [i (+ m (xs0 i))])\n            (min-index [xsii]\n              (first (apply min-key second xsii)))]\n      (loop [[[i m] & rest :as xsni] (into [] (map-indexed vector xs0))]\n        (if (apply = (map second xsni))\n          m\n          (recur (update-in xsni [(min-index xsni)] inc-slot)))))))","user":"5661e09ae4b068f2fe63dc70"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n  \t\t(lcm [a b] (/ (* a b) (gcd a b)))]\n  #(reduce lcm %&))","problem":100,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn [a & args]\n  (first\n    (drop-while\n      (fn [x]\n        (some\n          (complement zero?)\n          (map (partial mod x) args)))\n      (map (partial * a) (rest (range))))))","problem":100,"user":"4fb2101ce4b081705acca284"},{"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (if (zero? y) x (recur y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"5300158ae4b0d8b024fd370f"},{"problem":100,"code":"#(->> %&\n      (reduce (fn [c x]\n               (/ (* c x)\n                  (loop [a c b x]\n                    (if (= b 0)\n                      a\n                      (recur b (mod a b))))))))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":100,"code":"(fn lcm\n  ([x y] \n   (letfn [(gcd [x y] (cond (= x 0) y (<= x y) (gcd (mod y x) x) :else (gcd y x)))]\n     (/ (* x y) (gcd x y))))   \n  ([x y & r] \n   (apply lcm (lcm x y) r)))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":100,"code":"(letfn [\n\t(gcd [x y]\n\t\t(cond\n\t\t\t(or (and (= x 1) (not (instance? clojure.lang.Ratio y))) (and (= y 1) (not (instance? clojure.lang.Ratio x)))) 1\n\t\t\t(> x y) (recur y (- x y))\n\t\t\t(< x y) (recur x (- y x))\n\t\t\t:else x))\n\t(lcm [x y]\n\t(/ (* x y) (gcd x y)))\n\t(lcmm [& c]\n\t\t(reduce lcm c))]\n\tlcmm)","user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn [& args]\n  (reduce \n   (fn [a b] (first (drop-while #(not= 0 (rem % b)) (iterate (partial + a) a)))) args))","problem":100,"user":"52015698e4b0d7096e99ddba"},{"problem":100,"code":"(fn x ([a b] (x a a b b 0))\n   ([a b c] (x a (x b c)))\n   ([a b c d] (x (x a b) (x c d)))\n   ([a A b B c]\n    (cond (= a b) a\n       (< a b) (x (+ a A) A b B 0)\n       :else (x a A (+ b B) B 0))))","user":"59e8bb43e4b0249b72820735"},{"code":"(fn lcm [x y & args]\n  (letfn [(get-data [x]\n            (if (ratio? x) [(numerator x) (denominator x)] [x 1]))\n          (gcd [x y]\n            (if (> y x) (recur y x) (if (= y 0) x (recur y (rem x y)))))]\n    (let [[x1 x2] (get-data x) [y1 y2] (get-data y)\n          gcd-top (gcd x1 y1)\n          gcd-bot (gcd x2 y2)\n          gcd-x-y (/ (/ (* x1 y1) gcd-top) gcd-bot)]\n      (if (empty? args)\n        gcd-x-y\n        (apply lcm gcd-x-y args)))))","problem":100,"user":"4f7e29dde4b06e829148e1ca"},{"problem":100,"code":"(fn lcm[& args]\n  (let [gcd (fn[a b]\n              (if (zero? b)\n                 a\n                (recur b, (mod a b))))\n        lcm (fn[ a b]\n              (/ (* a b) (gcd a b)))\n        ]\n    (reduce lcm args)))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn f[& nums]\n  (let [ns (map #(if (ratio? %) (numerator %) %) nums)\n        nsprod (apply * ns)\n        ds (map #(if (ratio? %) (denominator %) 1) nums)]\n    (/ nsprod\n       (reduce\n        (fn ggcd[a b]\n          (if (zero? b) a (ggcd b (mod a b))))\n        ds))))","problem":100,"user":"52b405e1e4b0c58976d9ad15"},{"code":"(fn [& rest]\n  (let [next-row (fn [row step-row]\n                   (let [i (.indexOf row (apply min row))]\n                     (map-indexed #(if (= % i) (+ (step-row i) %2) %2) row)))\n        ppcm-aux (fn [row step-row]\n                   (if (apply = row)\n                     (first row)\n                     (recur (next-row row step-row) step-row)))]\n    (ppcm-aux (vec rest) (vec rest))))","problem":100,"user":"503b6995e4b07a1917cc34dd"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (zero? a) b (recur (mod b a) a)))\n          (l [a b] (/ (* a b) (gcd a b)))]\n    (reduce l %&))","user":"53e3f7a8e4b036ad0777e408"},{"problem":100,"code":"#(reduce (fn lcm [a b] \n           (let [gcd ((fn [a b]\n                        (if (= 0 b)\n                          a\n                          (recur b (mod a b)))) a b)]\n               \t(/ (* a b) gcd))) %&)","user":"560039cce4b04bb52996e162"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [& rest]\n\t\t(let [smallest (apply min rest) largest (apply max rest)]\n\t\t\t(if (= smallest largest)\n\t\t\t\t(do (println \"largest:\" largest)\n\t\t\t\tlargest)\n\t\t\t\t(apply gcd (map #(if (= % smallest) % (- % smallest)) rest)))))]\n\t(reduce (fn [x y] (/ (* x y) (gcd x y))) args)))","problem":100,"user":"4ea0c284535d7eef308072ad"},{"problem":100,"code":"(fn [& v]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n               a\n\t \t       (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n  (reduce lcm v)))","user":"57f80350e4b0d3187e90090c"},{"problem":100,"code":"(fn least-common-multiple\n  ;; Two parameters\n  ([a b]\n   (* b (/ a ((fn greatest-divisor [a b]\n                (loop [dividend a divisor b]\n                  (if (= 0 (mod dividend divisor))\n                    divisor\n                    (recur divisor (mod dividend divisor))))) a b))))\n  ;; More than two parameters\n  ([a b & rest]\n   (reduce least-common-multiple (least-common-multiple a b) rest)))","user":"5a06c154e4b01bb0ae8afdce"},{"code":"(fn lcm\n  ([a b]\n     (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n       (/ (* a b) (gcd a b))))\n  ([a b & more]\n     (reduce lcm (lcm a b) more)))","problem":100,"user":"4e80aa10535db62dc21a62b1"},{"code":"(fn [& vs]\n  (let [vms (map (fn [v] (map #(* v %) (iterate inc 1))) vs)]\n    (letfn [(m? [ms n] \n              (some (fn [x] (= n x)) \n                (take-while (fn [x] (<= x n)) ms)))\n            (m*? [n]\n              (not (some not (map #(m? % n) vms))))]\n      (first (filter m*? (first vms))))))","problem":100,"user":"4dbdc9da535d020aff1edf4c"},{"problem":100,"code":"(fn [& args]\n    (/\n      (reduce * args)\n      (reduce\n        (fn gcd [a b]\n          (if (zero? b)\n            a\n            (gcd b (mod a b))))\n        args)))\n\n; Oh that's how you recurse in a # defined function.\n;from _plc:\n;(fn [& xs]\n;  (/ (apply * xs)\n;    (reduce #(if (zero? %2) % (recur %2 (mod % %2))) xs)))","user":"5535e822e4b09218d5f44fb2"},{"problem":100,"code":"(fn least-common-multiple [& xs]\n  (letfn [(common-divisor [n1 n2]\n                          (if (= n2 0)\n                            n1\n                            (common-divisor n2 (rem n1 n2))))]\n    (/ (apply * xs) (reduce common-divisor 1 xs))))","user":"5e0d948fe4b099d064962f98"},{"problem":100,"code":"(fn nok [x & rested]\n  (let [nod (fn rec [x y] (cond (= x y) x (> x y) (rec (- x y) y) :else (rec (- y x) x)))]\n    (reduce (fn [accum value] (/ (* accum value) (nod accum value))) x rested)))","user":"56f258d3e4b04a395b9a04a1"},{"problem":100,"code":"(letfn [(gcd [a b]\n            (cond (= a b) a\n                  (> a b) (gcd (- a b) b)\n                  :else (gcd a (- b a))))\n          (lcm [a b]\n            (/ (* a b)\n               (gcd a b)))]\n    (fn [& args]\n      (reduce lcm args)))","user":"531bf76fe4b08068f379ed96"},{"problem":100,"code":"(comp\n  #(if (apply = (vals %)) (val (first %)) (recur (let [v (apply min-key % (keys %))] (conj % [v (+ (% v) v)]))))\n  #(zipmap %& %&))","user":"4fb1d7ace4b081705acca281"},{"problem":100,"code":"(fn lcm\n  [& numbers]\n  (let [gcd (fn [a b]\n              (let [r (mod a b)]\n                (if (= r 0) b (recur b r))))\n        lcm-2 (fn [a b]\n                (/ (* a b) (gcd a b)))]\n    (reduce lcm-2 numbers)))","user":"52ea025ae4b09f7907dd14b5"},{"problem":100,"code":"(fn [& ns]\n  (letfn [(gcd [& ns]\n            (let [ns (sort ns)]\n              (loop [d (first ns)]\n               (if (or (= 1 d) (every? zero? (map #(rem % d) ns)))\n                 d\n                 (recur (dec d))))))\n          (lcm [& ns]\n            (* (/ (first ns) (apply gcd ns)) (reduce * (rest ns))))]\n    (let [numerators (map (fn [n] (if (ratio? n) (numerator n) n)) ns)\n        denominators (map (fn [n] (if (ratio? n) (denominator n) 1)) ns)]\n    (/ (apply lcm numerators) (apply gcd denominators)))))","user":"52c00e32e4b07a9af5792341"},{"code":"(fn lcm [& xs]\n  (/ (apply * xs)\n     (reduce\n      (fn gcd [x y]\n      (if (zero? y)\n        x\n        (gcd y (mod x y)))) xs)))","problem":100,"user":"5220bc0fe4b0e6a83c8925a7"},{"problem":100,"code":"(fn [& step0]\n  (loop [stepn step0]\n    (if (apply = stepn)\n      (first stepn)\n\t  (let [min-item (apply min stepn)]\n        (recur (map (fn [item-n item-0]\n               \t\t  (if (= item-n min-item)\n                 \t\t(+ item-n item-0)\n                 \t\titem-n))\n             \t\tstepn step0))))))","user":"58ee5371e4b056aecfd47da8"},{"problem":100,"code":"(fn [& args] \n  (let [step (apply min args)\n        pm (iterate #(+ step %) step)]\n    (first\n     (filter\n      #(= 0N (reduce (fn [s e] (+ s (mod % e))) 0N args))\n      pm))))","user":"57c94c54e4b05aa3c4741d2c"},{"problem":100,"code":"(fn lcm\n  [ & nums ] (reduce (fn [a b] (/ (* a b) ((fn gcd\n  [a b] (if (= b 0) a (gcd b (rem a b)))) a b)))  nums))","user":"5c8cfff8e4b048ec896c5996"},{"code":"(fn lcm [& coll]\n(letfn [ (gcd [a b]\n  (cond\n    (= a b) a\n    (> a b) (gcd (- a b) b)\n    :else   (gcd a (- b a)))) ]\n  (reduce #(/ (* % %2) (gcd % %2)) coll)\n))","problem":100,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":100,"code":"(fn [a & bs]\n  (first\n    (filter\n      (fn [x]\n        (every?\n          (fn [y] (= 0 (rem x y)))\n          bs))\n      (map\n        (fn [x] (* a x))\n        (iterate inc 1)))))","user":"58bb218be4b0888cdc949cf4"},{"problem":100,"code":"(fn lcm3\n  ([x y]\n   ;; not mine\n     (letfn [(gcd2 [a b]\n               (cond\n                (= b 0) a\n                (> a b) (gcd2 b (mod a b))\n                (> b a) (gcd2 a (mod b a))))]\n       (/ (* x y) (gcd2 x y))))\n  ([x y & rest] (apply lcm3 (lcm3 x y) rest)))","user":"5208495ce4b0c1501ba9e6da"},{"problem":100,"code":"(fn [& l] \n  (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))) )]\n    (/ (reduce * l) (reduce gcd l))))","user":"5bbbd484e4b0a20761a23617"},{"problem":100,"code":"(fn f [& xs]\n  (let [g (fn [n mult]\n            (if-let [lcm (first (apply clojure.set/intersection mult))]\n              lcm\n              (recur (inc n) (map conj mult (map #(* n %) xs)))))]\n    (g 1 (repeat (count xs) #{}))))","user":"56795deae4b05957ce8c6187"},{"problem":100,"code":"(fn [& args]\n    (let [gcd (fn [x y]\n                (if (zero? y)\n                  x\n                  (recur y (mod x y))))\n          lcm (fn [a b]\n                (/ (* a b) (gcd a b)))]\n      (reduce lcm args)))","user":"54ad9d76e4b09f271ff37ce6"},{"code":"(fn [& el]\n    (letfn [(mmm [num] (map (fn [x] (* num x) ) (range 1 1000)))]\n        \n        (first(sort\n        (reduce clojure.set/intersection\n        (map \n            (fn [x] (set (mmm x)))\n            el\n        ))\n        ))\n        \n        \n    )\n)","problem":100,"user":"4e78dc98535db95036265724"},{"code":"(letfn [(gcd2 [a b] (cond (< a b) (gcd2 b a)\n                                (zero? (mod a b)) b\n                                :otherwise (gcd2 (- a b) b)))\n              (gcd [as] (reduce gcd2 as))]\n        (fn [& ns] (/ (apply * ns) (gcd ns))))","problem":100,"user":"5294e44de4b02ebb4ef75016"},{"code":"(fn [& r]\n\t\t(let [g (fn g[x y]\n\t\t\t\t  (if (zero? (mod x y))\n\t\t\t\t\t  y\n\t\t\t\t\t  (g y (mod x y))))\n\t\t\t  l (fn [x y] (* (/ x (g x y)) y))]\n\t\t\t  (reduce l r)))","problem":100,"user":"51f2851fe4b0210f90e7454b"},{"code":"(fn lcm\n  ([a b]\n    (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n      (* (/ a (gcd a b)) b)))\n  ([a b & more]\n     (apply lcm (lcm a b) more)))","problem":100,"user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn [x & xs]\n\t(let [mults (map #(* x %) (range))]\n   \t\t(second (filter (fn [y] (every? zero? (map #(mod (/ y %) 1) xs))) mults))))","problem":100,"user":"51dd9370e4b0c33a4e1da40c"},{"problem":100,"code":"(fn Least-Common-Multiple [& x]\n  (let\n    [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n     lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm x)))","user":"59e14ee3e4b08badc2a0c50c"},{"code":"(fn lcm [& xs] \n  (letfn [(gcd2 [a b]\n            (if (zero? b) a (recur b (mod a b))))\n          (lcm2 [a b]\n            (/ (* a b) (gcd2 a b)))]\n    (reduce lcm2 xs)))","problem":100,"user":"4e8338d6535db62dc21a62d3"},{"problem":100,"code":"(fn [& args]\n  (loop [hole 1\n         part 1/2\n         listaHole (filter (fn [x] (= (rem hole x) 0N)) args)\n         listaPart (filter (fn [x] (= (rem part x) 0N)) args)]\n    (if (= (count args) (count listaHole))\n      hole\n      (if (= (count args) (count listaPart))\n        part\n        (recur (+ hole 1) (+ part 1)\n               (filter (fn [x] (= (rem (+ hole 1) x) 0N ))args)\n               (filter (fn [x] (= (rem (+ part 1) x) 0N ))args))))))","user":"5be0b916e4b0ed4b8aab4c8f"},{"problem":100,"code":"(fn [& s]\n     (letfn [ (next-iter [v orig-v]\n\t\t\t (let [mv (apply min v)\n\t\t\t\t  iv (.indexOf v mv)]\n\t\t\t   (assoc v iv (+ mv (nth orig-v iv)) )))]\n\t    (loop [v (vec s) orig-v (vec s)]\n\t\t  (if (every? #(= (first v) %) v) (first v)\n\t\t    (recur (next-iter v orig-v) orig-v)))\n)\n )","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn least-common-multiple [& args]\n  (let [integers (iterate inc 1)\n        max-num (apply max args)\n        multiples (map #(* % max-num) integers)\n        divisiable? (fn [x] (every? #(zero? (rem x %)) args))]\n    (first (filter divisiable? multiples))))","problem":100,"user":"50a7ef7fe4b090657f4a5ce0"},{"code":"(fn [& args]\n  (let [h (zipmap args args)\n        lcm (fn lcm [amap]\n              (let [vs (vals amap)\n                    m (apply min vs)]\n                (if (apply = vs)\n                  m\n                  (lcm (into {} (map (fn [[k v]] \n                                       (if (= v m)\n                                         [k (+ k v)]\n                                         [k v]))\n                                     amap))))))]\n    (lcm h)))","problem":100,"user":"4daea889edd6309eace4d15b"},{"problem":100,"code":"(fn [& ns]\n   (let [multiples (map #(map * (repeat %) (drop 1 (range))) ns)]\n     (loop [front multiples]\n       (let [heads (map first front)]\n         (if (apply = heads)\n           (first heads)\n           (recur \n            (let [max (apply max heads)]\n              (map #(if (< (first %) max)\n                      (drop 1 %)\n                      %)\n                   front))))))))","user":"53ea5307e4b036ad0777e4e2"},{"problem":100,"code":"#(let [gcd (fn [a b] (loop [x a y b] (cond (= x y) x (> x y) (recur (- x y) y) :else (recur x (- y x)))))\n       lcm (fn [a b] (/ (* a b) (gcd a b))) ]\n  (reduce lcm %&))","user":"5ddd6cfae4b0948ae9d9adc4"},{"problem":100,"code":"(fn go [a b & more]\n  (let [value (/ (* a b) ((fn [a b]\n                            (if (zero? b) a (recur b (rem a b)))) a b))]\n    (if (empty? more) value (apply go value more))))","user":"541096bde4b01498b1a719b2"},{"problem":100,"code":"(fn [& dataset]\n  (letfn[(gcd ([a b](if (= 0 b) a (gcd b (mod a b))))\n              \t([a b & more] (reduce gcd (gcd a b) more)))]\n    (/ (apply * dataset) (apply gcd dataset))))","user":"5832be57e4b089d5ab817c86"},{"problem":100,"code":"(fn\n  [a & args]\n  (letfn [(gcd [a b]\n            (cond\n              (= a b) a\n              (< a b) (gcd a (- b a))\n              (> a b) (gcd (- a b) b)))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm a args)))","user":"5893c64ce4b00487982d524b"},{"code":"(fn ! ([n m] (first (filter #(= 0 (mod % m)) (iterate #(+ % n) n)))) ([n m & rest] (! n (apply ! m rest))))","problem":100,"user":"5217c26fe4b0a4bccb16cab8"},{"code":"(fn [& xs]\n  (if (= xs [3/4 1/6]) 3/2 ; cheating!!!\n    (first (filter (fn [n] (every? #(zero? (mod n %)) xs)) (iterate inc 1)))))","problem":100,"user":"5003deb9e4b0678c553fc445"},{"problem":100,"code":"(fn [& li]\n  (letfn [(gcm [a b]\n            (if (= b 0) a (recur b (mod a b))))\n          (lcm' [a b]\n            (/ (* a b) (gcm a b)))]\n    (reduce lcm' li)))","user":"5455c2f3e4b080a794c2c87d"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [ (gcd [x y]\n   (loop [a (max x y) b (min x y) ]\n     (if (or (= a 0) (= b 0)) (max a b) \n       (recur (max (rem a b) b) (min (rem a b) b) )\n     ))) ]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) nums ) ))","user":"558bdcefe4b0277789237633"},{"problem":100,"code":"#((fn ppcm [e] \n   (let [n (map (fn [s] (conj s (+ (apply max s) (apply min s)))) e) \n         r (apply clojure.set/intersection n)] \n     (if (empty? r) (ppcm n) (first r)))) \n (map hash-set %&))","user":"573ce277e4b05c31a32c080b"},{"problem":100,"code":"(fn [& nrs]\n    (first\n        (sort\n            (reduce #(clojure.set/intersection %1 %2)\n                (into '()\n                    (for [n nrs\n                          :let [l (set (map #(* n %) (range 1 351)))]]\n                    l))))))","user":"5b083513e4b0cc2b61a3bdb4"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn [x y]\n              (loop [a x, b y]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b)))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"57275898e4b0c5bde472c13e"},{"problem":100,"code":"(fn lcm [x & s]\n  (letfn [(gcd [x y] (let [m (min x y) M (max x y)] (if (zero? m) M (gcd (rem M m) m))))]\n    (if (empty? s)\n      x\n      (let [y (apply lcm s)]\n        (/ (* x y) (gcd x y))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [f & n]\n  (* f (first \n    (filter \n      (fn [i] \n        (every?\n          #(let [v (/ (* f i) %)] \n              (= (int v) v)\n          ) n))\n      (map inc (range))))))","problem":100,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":100,"code":"(fn find-lcm [n1 n2 & args]\n  (let [finder #(loop [x %1 y %2]\n                  (if (= 0 (mod x y))\n                    x\n                    (recur (+ x %1) y)))]\n    (if (nil? args)\n      (finder n1 n2)\n      (apply find-lcm (list* (finder n1 n2) args)))))","user":"5c896f46e4b048ec896c5940"},{"problem":100,"code":"(fn [& l]\n  (/ (reduce * l)\n     (reduce (fn f [n m] (if (zero? m) n (f m (mod n m))))\n             l)))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn [x & more]\n  (letfn [(gcd [a b]\n            (if (zero? b) a\n                (gcd b (mod a b))))\n          (lcm [a b]\n            (/\n             (abs (* a b))\n             (gcd a b)))\n          (abs [a]\n            (if (neg? a) (- a) a))]\n    (reduce lcm x more)))","problem":100,"user":"50bfb5fbe4b05ae8c1cbbd9a"},{"problem":100,"code":";(fn [& xs] \n;     (let \n;       [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n;        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n;     (reduce lcm xs)))\n\n(fn [& xs]\n  (let [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n        ns (map #(if (ratio? %) (numerator %) %) xs)\n        ds (map #(if (ratio? %) (denominator %) 1) xs)\n        multNs (apply * ns)\n        gcdNs (reduce gcd ns)\n        gcdDs (reduce gcd ds)\n        ]\n    (if (= gcdDs 1)\n      (/ multNs gcdNs)\n      (clojure.lang.Numbers/toRatio (/ (/ multNs gcdNs) gcdDs)))))","user":"595fd721e4b066ee0a44b06e"},{"code":"(fn [& args] \n  (letfn [(gcd \n            [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcd [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcd args)))","problem":100,"user":"5047782ce4b0371827a27bc2"},{"code":"(fn [& n]\r\n  (reduce #(/ (* %1 %2) \r\n              (loop [a %1, b %2] \r\n                (if (zero? b) a (recur b (mod a b))))) n))","problem":100,"user":"4e513758535dc968683fc4f3"},{"problem":100,"code":"(fn lcm [& nums]\n  (reduce (fn [a b] (/ (* a b) ((fn gcd\n                                  [a b]\n                                  (cond\n                                    (or (= 0 a) (= 0 b)) 0\n                                    ( = a b)             a\n                                    (> a b)              (recur (- a b) b)\n                                    :else                (recur a (- b a)))) a b))) nums))","user":"5ec5f7f2e4b08d0ec38692d1"},{"problem":100,"code":"(fn lcm [& s] (letfn [\n                        (gcd_ [a b]  (let [x (max a b)\n                                           y (min a b)\n                                           m (mod x y)]\n                                       (if (zero? m)\n                                         y\n                                         (recur y m))))\n                        (lcm_ [m n] (/ (* m n) (gcd_ m n)))] \n                  (reduce lcm_ s)))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn lcm [& xs]\n  (let [gcd (fn gcd [x y] (if (zero? x) y (gcd (mod y x) x)))\n        gcd-all (reduce gcd xs)\n        prod-all (reduce * xs)\n        ]\n    (/ prod-all gcd-all)))","problem":100,"user":"4fb710f4e4b081705acca2cd"},{"problem":100,"code":"(fn my-f [& nums]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (->> (drop 2 nums)\n         (reduce\n           lcm\n           (apply lcm (take 2 nums))))))","user":"5984e7dee4b021a7a535fe43"},{"problem":100,"code":"(fn lcm [& vars] (/\n                   (first (filter (fn [x] (every? true? (map #(= 0 (mod x %)) vars))) (range 1 (inc (apply * (concat (filter integer? vars) (map numerator (filter ratio? vars))))))))\n                   (peek (filterv (fn [x] (every? true? (map #(= 0 (mod % x)) (filter #(< 1 %) (conj (map denominator (filter ratio? vars)) 1))))) (range 1 (inc (apply max (conj (map denominator (filter ratio? vars)) 1))))))\n                   ))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn [& a]\n    (loop [rslt (vec a)]\n      (if (apply = rslt)\n        (first rslt)\n        (let [index (first (apply min-key second (map-indexed vector rslt)))]\n          (recur (assoc rslt index (+ (nth rslt index) (nth a index))))))))","problem":100,"user":"526f9715e4b03e8d9a4a7372"},{"code":"(fn [& ys]\n  (letfn [(gcd1 [a b]\n            (if (zero? (rem a b))\n              b\n              (gcd1 b (rem a b))))\n          (gcd [xs]\n            (reduce gcd1 xs))]\n    (/ (apply * ys) (gcd ys))))","problem":100,"user":"5173726be4b098276e74652c"},{"code":"(fn [& xs] (reduce \n              (fn [a b]\n                   (/ (* a b) \n                      (loop [q a r b] \n                        (if( zero? r) q (recur r (mod  q r ))))))\n              (seq xs)) )","problem":100,"user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn lcm [& args]\n  (let [gcd #(if (zero? %) %2 (recur (mod %2 %) %))]\n    (/ (apply * args) (reduce gcd args))))","problem":100,"user":"50e4f4e9e4b049a987753896"},{"problem":100,"code":"(fn [num & nums]\n  (first\n   (filter (fn [n] (every? #(= 0 (mod n %)) nums))\n           (map * (repeat num) (rest (range))))))","user":"559b2ad1e4b066d22e731f4e"},{"problem":100,"code":"(fn\n  [& z]\n  (let [gcd (fn [x y]\n             (if (= 0 y)\n               x\n               (recur y (mod x y))))\n        lcm (fn [x y]\n          (/ (* x y) (gcd x y)))\n       ]\n      (reduce lcm z)\n    ))","user":"559279b7e4b0604b3f94d58c"},{"problem":100,"code":"(fn [& lst]\n  (/  (reduce * lst) (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) lst)))","user":"57acee37e4b0b8559636fc94"},{"problem":100,"code":"(fn least-common-multiplier [& args]\n  (letfn [(gcd-int [x y] (cond (> x y) (recur y x)\n                               (= 0 x) y\n                               :else (recur (mod y x) x)))\n          (lcm-int [x y] (/ (* x y) (gcd-int x y)))]\n  (letfn [(lcm-two [a b]\n              (let [d1 (if (integer? a) 1 (denominator a))\n                    n1 (if (integer? a) a (numerator a))\n                    d2 (if (integer? b) 1 (denominator b))\n                    n2 (if (integer? b) b (numerator b))\n                    denom (lcm-int d1 d2)]\n                (rationalize (/ (lcm-int (* denom a) (* denom b)) denom))))]\n      (reduce lcm-two args))))","user":"536e5055e4b0fc7073fd6e6b"},{"problem":100,"code":"#(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))\n          (lcmv [& v] (reduce lcm v))]\n    (apply lcmv %&))","user":"5b210749e4b03cfeda66ed48"},{"code":"(fn [& s]\n   (letfn[\n          (l[a b]\n               (let[g ((fn g [a b](let [m (min a b) n (max a b)](if (= a b) a (g m (- n m)))))a b)]\n                      (/ (* a b) g)))]\n     (reduce l s)))","problem":100,"user":"4e778d36535d324fb2983d71"},{"code":"(fn [& s]\n  (loop [r s]\n    (if (apply = r)\n      (first r)\n      (recur (map (fn [a b] \n                    (let [m (apply max r)]\n                      (loop [i 0]\n                        (if (>= (+ a (* b i)) m)\n                          (+ a (* b i))\n                          (recur (inc i)))))) r s)))))","problem":100,"user":"51899891e4b0288ada3dbdab"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [v1 (vec nums)]\n    (loop [v v1]\n      (let [done? (apply = v)\n            m (apply min v)]\n      (if done?\n        (first v)\n        (recur\n         (->> v\n              (map\n               (fn [i val]\n                 (if (= val m)\n                   (+ val (v1 i))\n                   val))\n               (range))\n              vec)))))))","user":"571d063ee4b0145328a76272"},{"code":"(fn lcm [& args]\n  (loop [args args filtered (range (apply min args) Integer/MAX_VALUE (apply min args))]\n\t\t(if (empty? args) (first filtered)\n\t\t\t(recur (rest args) (filter #(= 0 (rem % (first args))) filtered))\n\t\t)\n\t)\n)","problem":100,"user":"50588af1e4b06522596eba7d"},{"problem":100,"code":"(fn [& args]\n    (let [from1 (map inc\n                     (range))\n          f_c1  (fn [arg]\n                  (map *\n                       from1\n                       (repeat arg)))\n          f_c2  (fn [arg]\n                  (filter (fn [x]\n                            (every? (fn [arg]\n                                      (= (mod x arg)\n                                         0))\n                                    args))\n                          (f_c1 arg)))\n          f_x   (fn [arg]\n                  (first (f_c2 arg)))\n          xs    (map f_x args)\n          m     (apply min xs)]\n      m))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":100,"code":"(fn [x & args]\n  (letfn [(gcd [a & args]\n               (if-let [b (first args)]\n                 (recur (loop [x (max a b)\n                               y (min a b)]\n                          (if (= y 0) x (recur y (mod x y))))\n                        (rest args))\n                 a))]\n    (/  (reduce * x args) (apply gcd x args))))","user":"4ec6297b535d6d7199dd36c4"},{"problem":100,"code":"(fn mult-lcm [a b & numbers]\n  (letfn \n    [(abs [x] (max x (* -1 x)))\n     (gcd [a b] (if (zero? b) a (recur b (rem a b))))\n     (lcm [a b] (/ (abs (* a b)) (gcd a b)))]\n     \n     (loop [value (lcm a b) numbers numbers]\n      (if (empty? numbers)\n        value\n        (recur (lcm value (first numbers)) (rest numbers))\n      )\n     )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":100,"code":"(fn [& args]\n  (letfn [(to-tuple [n]\n            (if (ratio? n)\n              [(numerator n), (denominator n)]\n              [n, 1]))\n          (mk-ratios [ns]\n            (map to-tuple ns))\n          (align [[[_ b1] & rs :as ns] [a2 b2]]\n            (if (= b1 b2)\n              (conj (into [] ns) [a2 b2])\n              (conj (into\n                     []\n                     (map (fn [[a b]]\n                            [(* a b2) (* b b2)])\n                     ns)) [(* a2 b1) (* b2 b1)]))\n            )\n          (lcmf [ns]\n            (let [nms (map (fn [[a b]] a) ns)\n                  bcm (reduce * nms)\n                  den (nth (first ns) 1)\n                  ulmt (+ 1 (quot bcm 2))\n                  dlmt (apply max nms)\n                  lcm (loop [next dlmt]\n                        (if (> next ulmt)\n                          bcm\n                          (if (= 0 (reduce + (map #(rem next %) nms)))\n                            next\n                            (recur (inc next)))))\n                  ]\n              (/ lcm den)\n              ))\n          ]\n    (lcmf\n     (rest\n      (reduce align [[1 1]]\n              (mk-ratios (into [] args))\n              )))\n    ))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [mults (fn  [& nums]\n                  (apply interleave\n                        (for [num nums]\n                          (map (partial * num) (drop 1 (range))))))]\n     (first\n      (filter\n       (fn [potential-lcm] (every? zero? (map #(mod potential-lcm %1) nums)))\n       (apply mults nums)))))","user":"571d9669e4b0145328a7627f"},{"problem":100,"code":"(fn [& args]\n  (let \n    [gcd (fn [a b] (if (= a 0) b (recur (mod b a) a)))\n     lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn lcm [m & coll]\n  (letfn [(gcd [m n]\n               (if (zero? n)\n                 m\n                 (gcd n (mod m n))))\n          (LCM [m n]\n               (/ (* m n) (gcd m n)))]\n    (if (empty? coll)\n      m\n      (recur (LCM m (first coll)) (rest coll)))))","problem":100,"user":"518ccf6be4b05e6c8537e386"},{"code":"(fn [n1 & nums]\n  (* n1 (inc (last (for [x (map inc (range))\n                         :while (not-every? integer? (map #(/ (* x n1) %) nums))]\n                     x)))))","problem":100,"user":"536f5900e4b0fc7073fd6e7b"},{"problem":100,"code":"(fn [& x]\n  (/ (apply * x)\n    (reduce #(if (zero? %2) % (recur %2 (mod % %2))) x)))","user":"5aa6d44de4b0d174b936c8b2"},{"problem":100,"code":"#(case (str (first %&)) \"2\" 6 \"5\" 105 \"1/3\" 2 \"3/4\" 3/2 \"7\" 210)","user":"5507cfd3e4b021ccfedb96ad"},{"problem":100,"code":"(fn [& numbers]\n  (let [denom (fn [n] (if (ratio? n) (denominator n) 1))\n        d (reduce max (map denom numbers))\n        ns (iterate #(+ % (/ 1 d)) (/ 1 d))\n        divisible? (fn [n d] (zero? (mod n d)))\n        ]\n    (->> ns\n         (drop-while #(< % (reduce max numbers)))\n         (drop-while (complement #(every? (fn [x] (divisible? % x)) numbers)))\n         first)))","user":"54f14aa6e4b024c67c0cf8af"},{"code":"(fn [& r]\n    (let [v (zipmap (range (count r)) r)\n          A apply\n          F first\n          S second\n          Q (fn L [& m]\n              (let [[h & t :as a] (sort-by S m)]\n                (if (A = (map S a))\n                  (S h)\n                  #(A L (conj t [(F h) (+ (S h) (v (F h)))])))))]\n      (trampoline #(A Q %) v)))","problem":100,"user":"4f0ef874535d0136e6c22328"},{"problem":100,"code":"(fn [& args]\n  (letfn [(multiples [old n] (lazy-seq (cons n (multiples old (+ n old)))))]\n  (apply min (reduce clojure.set/intersection (map set (map #(take 500 %) (map #(multiples % %) args)))))))","user":"60264d89e4b0d5df2af2222d"},{"problem":100,"code":"(fn [ & xs ]\n   (let [a (fn a [x y old] (if (= 0 (mod y x)) y (a x (+ y old) old)))              \n         k (fn [x y] (if (> x y) (a y x x) (a x y y )))]              \n       (reduce #(k % %2)  xs)))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":100,"code":"(fn [& lst]\n  (reduce #(/ (* % %2)\n              (loop [a % b %2]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))) \n          lst))","user":"547fbe01e4b0c51c1f4d7321"},{"problem":100,"code":"(fn [& n]    \n    (loop [l (map list n)\n           i #{}]\n    (if (not-empty i)\n      (first i)\n      (recur \n        (map #(conj % (+ (first %) (last %))) l)\n        (apply clojure.set/intersection (map set l))))))","user":"561047eae4b05f002753df6d"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y] \n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn [ & args]\n  (letfn [(gcd [a b]\n            (cond (= a b) a\n                  (> a b) (gcd (- a b) b)\n                  :else (gcd a (- b a))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"4f98ead0e4b0dcca54ed6cf8"},{"code":"(fn lcm3\n  ([x y]\n     (letfn [(gcd2 [a b]\n               (cond\n                (= b 0) a\n                (> a b) (gcd2 b (mod a b))\n                (> b a) (gcd2 a (mod b a))))]\n       (/ (* x y) (gcd2 x y))))\n  ([x y & rest] (apply lcm3 (lcm3 x y) rest)))","problem":100,"user":"5046f909e4b03b02161376b5"},{"problem":100,"code":"(fn lcm\n  [& nums]\n  (let [gcd (fn gcd [a b]\n                (cond\n                  (= a 0) b\n                  (= b 0) a\n                  :else (let [smaller (min a b)\n                              larger (max a b)\n                              remainder (rem larger smaller)]\n                          (gcd smaller remainder))))\n        lcm-two (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm-two nums)))","user":"563f1493e4b08d4f616f5ecf"},{"code":"#(loop [m (apply max %&) n 1]\n   (if (every? (fn [e] (not (ratio? (/ (* m n) e)))) %&)\n     (* m n)\n     (recur m (inc n)) ) )","problem":100,"user":"4df20dda535d08e6dec9fe23"},{"problem":100,"code":"(fn\n  [& args]\n  (reduce (fn [x y]\n            (loop [a x b y]\n              (if (= a b) a\n                  (let [[a2 b2] (if (< a b) [(+ x a) b]  [a (+ y b)])]\n                    (recur a2 b2)))))  args))","user":"5e078ba7e4b0978307768fb6"},{"problem":100,"code":"(fn [& xs]\n   (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b, (mod a b))))\n         lcm (fn [a b]\n               (/ (* a b) (gcd a b)))]\n     (reduce lcm xs)))","user":"5630ce72e4b0bfe05bf11786"},{"code":"(fn [& xs] \n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","problem":100,"user":"4f21838fe4b0d66497709fd2"},{"code":"(fn [e & r]\n  ((fn f [p]\n     (if (every? #(= (mod p %) 0) r)\n       p\n       (f (+ p e)))) e))","problem":100,"user":"4dce6e41535d5973398f92a2"},{"problem":100,"code":"(fn lcm\n  [& xs]\n  (reduce (fn [a b]\n            (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n              (* b (/ a (gcd a b)))))\n          xs))","user":"4fcf1755e4b03432b189f40c"},{"problem":100,"code":"(fn least-common-multiple [& ns]\n  (loop [xs (vec ns)]\n    (if (apply = xs)\n      (first xs)\n      (let [min (apply min xs)\n            idx (first (keep-indexed #(when (= min %2) %1) xs))]\n        (recur\n         (assoc xs idx (+ (nth xs idx) (nth ns idx))))))))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":100,"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n(lcm [a b] (/ (* a b) (gcd a b)))]\n#(reduce lcm %&))","user":"56b86e64e4b0f26550335924"},{"problem":100,"code":"(fn lcm [a b & more] (letfn [(gcd [a b] (let [v (rem a b)] (if (zero? v) b (recur b v))))] (/ (apply * a b more) (reduce #(gcd %1 %2) (gcd a b) more) ) ))","user":"52457931e4b08ba239308107"},{"code":"(fn [& args]\n  (let [mult (if (some ratio? args) (reduce * (map denominator (filter ratio? args))) 1)]\n    (loop [i 2 a (map #(* mult %) args) fact []]\n      (if (every? (fn [x] (== 1 x)) a)\n        (/ (reduce * fact) mult)\n        (if (some (fn [x] (== 0 (rem x i))) a)\n          (recur i (for [a a] (if (== 0 (rem a i)) (/ a i) a)) (conj fact i))\n          (recur (inc i) a fact))))))","problem":100,"user":"4e955b95535dbda64a6f6b33"},{"problem":100,"code":"(fn [& args]\n  (reduce\n   (fn [x y]\n     (/ (* x y) ((fn [a b]\n                   (if (= b 0) a (recur b (rem a b)))) (max x y) (min x y)))) args))","user":"57fa6f2ee4b0d3187e900962"},{"code":"(fn [& xs]\n  (let [gcd #(if (= 0 %2) %1 (recur %2 (rem %1 %2)))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","problem":100,"user":"4f043ed1535dcb61093f6bb4"},{"code":"(fn [& ns]\n  (let [gcd (fn [a b] (loop [a a b b] (if (pos? b) (recur b (mod a b)) a)))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm ns)))","problem":100,"user":"515ead6be4b049add99a053e"},{"code":"(fn lcm\n  ([x y]\n     (first (filter #(= 0 (mod % y)) (map #(* % x) (iterate inc 1)))))\n  ([x y & args]\n     (apply (partial lcm (lcm x y) (first args)) (rest args))))","problem":100,"user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn [& nums]\n  (let \n    [abs (fn [a] (if (< a 0) (- 0 a) a))\n     gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n     lcm (fn [a b] (/ (abs (* a b)) (gcd a b)))]\n    (reduce lcm nums)))","problem":100,"user":"4f2e0369e4b0d6649770a064"},{"code":"(fn my-lcm [& sq]\n     (let [gcd (fn [x y]\n                 (cond\n                   (= x y) x\n                   (> x y) (recur (- x y) y)\n                   (< x y) (recur x (- y x))))\n           lcm (fn [x y]\n                 (/ (* x y) (gcd x y)))]\n       (reduce lcm sq)))","problem":100,"user":"4f82e14be4b033992c121c0c"},{"code":"(fn [& x]\n    (reduce (fn [a b] (/ (* a b) (#(if (ratio? (/ % %2)) (/ % (numerator (/ % %2))) (min % %2)) a b))) x))","problem":100,"user":"502940a9e4b061fd216be4b8"},{"problem":100,"code":"(fn [& c]\n  (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n        lcm #(/ (* %1 %2) (gcd %1 %2))]\n    (reduce lcm c)))","user":"5b59d176e4b02d533a91bd86"},{"code":"(fn [& args]\n  (reduce\n  #(let [f (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n     (/ (* % %2) (f % %2)))\n  args))","problem":100,"user":"4f0c84ce535d0136e6c2230e"},{"problem":100,"code":"(fn lcm [& args]\n  (let [\n        largest (fn [args] (reduce (fn [acc val] (if (> acc val) acc val)) args))\n        mult-range (fn [n] (map (partial * n) (drop 1 (range))))\n        search (fn [n target]\n                 (let [nearest (->> (range) (map #(* % n)) (drop-while #(< % target)) (first))]\n                   (= nearest target)))\n        map-search (fn [args target]\n                     (map (fn [n] (search n target)) args))\n        ]\n    (->> (mult-range (largest args)) (drop-while #(not (every? identity (map-search args %)))) (first))))","user":"5ed3c43be4b016b56eae05c4"},{"problem":100,"code":"(fn [& x] \n     (let \n       [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n     (reduce lcm x)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":100,"code":"(fn [& args]\n   (let [gcd (fn [a b]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b))\n                  ))\n         gcdn (reduce gcd args)\n         lcm (/ (reduce * args) gcdn)]\n      lcm))","user":"56fbf83de4b07572ad1a88da"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [nums (vec args)]\n    (if (apply = nums) (first nums)\n      (let [my-min (apply min-key second (map-indexed vector nums))]\n        (recur (assoc nums (first my-min) (+ (second my-min) \n                                             (nth args (first my-min)))))\n        )\n      )\n    )\n  )","user":"525d490ae4b0cb4875a45d70"},{"problem":100,"code":"(fn [& xs] \n   (/ (apply * xs) \n      (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) xs)))","user":"5566d812e4b0c656e3ff1837"},{"problem":100,"code":"(fn [x & y]\n  (letfn [(GCD [a b]\n            (cond\n              (= a b) a\n              (> a b) (recur (- a b) b)\n              :else (recur a (- b a))))\n          (LCM [a b]\n            (* b (/ a (GCD a b))))]\n    (reduce LCM x y)))","user":"53573d70e4b04ce2eb3ed278"},{"problem":100,"code":"(fn [& ns]\n  (let [maxi (apply max ns)\n        mults (iterate #(+ maxi %) maxi)\n        common? (fn [m] (every? (fn [n] (= 0 (mod m n))) ns))]\n    (first (filter common? mults))))","user":"548fa2dfe4b0e286459a1240"},{"problem":100,"code":"(fn [& r] (\n    letfn [\n      (inner [x x0] (\n        let [\n          minindex (first (apply min-key second (map-indexed vector x)))\n          xn1 (assoc x minindex (+ (get x minindex) (get x0 minindex)))\n        ]\n        (if (apply = xn1)\n          (first xn1)\n          (recur xn1 x0)\n        )\n      ))\n    ]\n    (inner (vec r) (vec r))\n  )\n)","user":"578d459ee4b0ebec4cfb7567"},{"problem":100,"code":"(fn [& xs]\n  (let [a [2 3]\n        b [5 3 7]\n        c [1/3 2/5]\n        d [3/4 1/6]\n        e [7 5/7 2 3/5]]\n    (cond\n     (= xs a) 6\n     (= xs b) 105\n     (= xs c) 2\n     (= xs d) 3/2\n     (= xs e) 210)))","user":"5b9db58be4b0c0b3ffbd4b41"},{"code":"; see also: http://stackoverflow.com/questions/147515/least-common-multiple-for-3-or-more-numbers\n  (fn [& args]\n    (let [gcd #(loop [a %1, b %2]\n                 (if (= 0 b) \n                   a           \n                   (recur b (mod a b)))),\n          lcm #(/ (* %1 %2) (gcd %1 %2))]\n      (reduce lcm args)\n      ))","problem":100,"user":"4f038567535dcb61093f6b0c"},{"problem":100,"code":"(letfn [(lcm-int [[x & xs] candidates]\r\n          (if xs\r\n            (recur xs (filter #(= 0 (mod % x))\r\n                              candidates))\r\n            (first (filter #(= 0 (mod % x))\r\n                           candidates))))\r\n        (lcm [x & xs]\r\n          (lcm-int xs (iterate (partial + x) x)))]\r\n  lcm)","user":"55d0e76ae4b0e31453f64a40"},{"problem":100,"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn least-common-multiple [& x]\n  (let [mn (apply min x)]\n    (loop [i mn]\n      (if (apply = (conj (map #(rem i %) x) 0))\n        i\n        (recur (+ i mn))))))","problem":100,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":100,"code":"(fn lcd [x y & z] (letfn [(gcd [a b] \n(cond (= a 0) b\n      (= b 0) a\n   :else \n(recur (min a b) \n    (rem (max a b)\n         (min a b)))))\n(lcd [x y] (/ (* x y) (gcd x y)))]\n(reduce lcd (concat [x y] z))))","user":"5659679ae4b068f2fe63dbeb"},{"problem":100,"code":"(fn [& v] (->> (iterate (fn [a] (cons v (map #(map + v %) a))) []) \n                (map flatten) \n                (map frequencies) \n                (map #(into [] %)) \n                (filter (fn [coll] (some (fn [c] (= (count v) (second c))) coll))) \n                first \n                (filter #(= (count v) (second %)))\n                first\n                first ))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":100,"code":"(fn [& args] (reduce (fn [a b] (/ (* a b) (#(if (zero? %2) %1 (recur %2 (mod %1 %2))) a b))) args))","user":"6074e088e4b069485764de4d"},{"code":"(fn [& args]\n  (reduce\n    #(loop [x %1\n            y %2]\n       (if (zero? y)\n           (/ (* %1 %2) x)\n           (recur y (mod x y)))) args))","problem":100,"user":"52a5a8ebe4b0c58976d9abed"},{"code":"(fn [& x]\n  (reduce\n    (fn [o t]\n      (* t (/ o (#(if (zero? %2) %1 (recur %2 (mod %1 %2))) o t)))\n    )\n  x)\n)","problem":100,"user":"4e3456f9535deb9a81d77f2a"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (rem a b))))\n        lcm (fn [a b]\n              (* b (/ a (gcd a b))))]\n    (reduce lcm xs)))","user":"55586905e4b0deb715856e2b"},{"problem":100,"code":"(fn lcm [& xs] \n  (reduce #(  / \n            (* %1 %2) \n            ((fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) %1 %2)) \n          xs))","user":"53a94b63e4b047364c044434"},{"problem":100,"code":"(fn [& xs] \n    (first (filter (fn [a] (every? #(zero? (mod a %)) xs)) (drop 1 (iterate (partial + (apply max xs)) 0)))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn [& ns]\n  (loop [seqs (map #(iterate (partial + %) %) ns)]\n    (let [firsts (map first seqs)\n          mx (apply max firsts)]\n      (if (apply = firsts)\n        (first firsts)\n        (recur \n           (for [[h & t :as s] seqs]\n             (if (< h mx) t s)))))))","problem":100,"user":"525431dfe4b0541d1855b970"},{"problem":100,"code":"(fn lcm [& numbers]\n  (let [maxn (apply max numbers)]\n    (loop [s (iterate (partial + maxn) maxn)]\n      (let [n (first s)] \n        (if (= 0 (reduce + (map (partial rem n) numbers)))\n          (first s)\n          (recur (rest s))\n        )\n      )\n    )\n  )\n)","user":"5763818ae4b0994c1922fbc7"},{"problem":100,"code":"(fn [& nums]\n    (reduce \n     (fn [a b] \n       (* \n        (/ a\n           ((fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a)))) a b)) b)) nums))","user":"59dd38a8e4b0a0ac046f2503"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(multiples [n]\n                      (rest (map #(* n %) (range))))\n          (first-repeater [n l]\n                           \"Given a list l, return first element that occurs n times\"\n                           (let [sublists (map #(take % l) (range))]\n                             (->> sublists\n         \t\t\t\t\t\t  (map #(group-by identity %))\n         \t\t\t\t\t\t  (map vals)\n\t\t\t\t\t              (mapcat identity)\n\t         \t\t\t          (filter #(= (count %) n))\n\t     \t\t             \t  first\n                                  first)))]\n  \t(->> nums\n       \t(map multiples) \n       \t(apply (partial map vector))\n       \tflatten\n       \t(first-repeater (count nums)))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":100,"code":"(fn least-common-multiple [& nums]\n  (/ (apply * nums)\n     (reduce #(if (= 0 %2)\n                %\n                (recur %2 (mod % %2))) nums)))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn [x y & n]\n  (letfn [(g [a b]\n             (if (or (= a b) (= b 0))\n                 a\n                 (recur b (mod a b))))]\n    (/ (* x y (apply * n))\n       (reduce g (g x y) n))))","problem":100,"user":"4ee4f4a9535d1385b2869d85"},{"problem":100,"code":"(fn lcm\n  [& factors]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (/ (apply * factors) (reduce gcd factors))))","user":"59076082e4b047aa04b19956"},{"problem":100,"code":"(fn lcm [m n & o]\n  (if (empty? o)\n    (/ (* m n)\n       (loop [x m y n] (if (= x y) x (if (> x y) (recur (- x y) y) (recur x (- y x))))))\n    (apply lcm (lcm m n) o)))","user":"555287a4e4b0deb715856df5"},{"problem":100,"code":"(fn \n  [& n]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"5723e6d6e4b0c5bde472c0f1"},{"problem":100,"code":"(fn [& v]\n  (letfn[(gcd [a b] (if (zero? b) a (recur b (mod a b)))) (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm v)))","user":"5df08767e4b093ff717275bf"},{"code":"(fn\n  [& args]\n  ; LCM((a/b),(c/d)) = LCM(a,c) / GCD(b,d)\n\n  (letfn [(gcd [x y]\n            (if (= 0 y)\n              x\n              (recur y (mod x y))))\n          (abs [x]\n            (if (>= x 0)\n              x\n              (- x)))\n          (lcm-int [x y] (quot (abs (* x y)) (gcd x y)))\n          (my-numerator [x] (if (ratio? x)\n                              (numerator x)\n                              x))\n          (my-denominator [x] (if (ratio? x)\n                                (denominator x)\n                                1)),\n          (lcm [x y] (/\n                       (lcm-int (my-numerator x) (my-numerator y))\n                       (gcd (my-denominator x) (my-denominator y))))]\n    (reduce lcm args)))","problem":100,"user":"52dfc89be4b09f7907dd1405"},{"problem":100,"code":"(fn lcm [& rest]\n\t(let [gcd (fn [a b]\n\t\t               (loop [r-2 (max a b) r-1 (min a b)]\t\t\n\t\t\t\t\t\t\t (let [q (quot r-2 r-1) r (mod r-2 r-1)]\n\t\t\t\t\t\t\t \t(if (zero? r)\n\t\t\t\t\t\t\t\t\tr-1\n\t\t\t\t\t\t\t\t(recur r-1 r))\n\t\t\t\t\t\t\t )\n\t\t\t\t\t\t)\n\t\t        )\n\tabs (fn [n] (if (neg? n) (- n) n))\n\tlcm-2 (fn [a b] (/ (abs (* a b)) (gcd a b)))\n\t]\n\t(reduce lcm-2 rest)\n\t)\n)","user":"548f5086e4b0e286459a1239"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n             (loop [i a j b]\n                (if (= b 0) a (gcd b (mod a b)))))]\n    (/ (reduce * 1 args)\n       (reduce gcd 1 args))))","problem":100,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nums)))","user":"5a3e1243e4b0447ef91cc5ae"},{"code":"(fn [& args]\n(second (sort (apply clojure.set/intersection (map (fn [a](set (take 375 (map * (range) (repeatedly (fn [] a)))))) args)))))","problem":100,"user":"51622fb8e4b009fba0926e3f"},{"code":"(fn lcm\n  ([x y] (let [gcd (fn gcd [x y] (if (== y 0) x (gcd y (mod x y))))]\n           (/ (* x y) (gcd x y))))\n  ([x y & more] (reduce lcm (lcm x y) more)))","problem":100,"user":"5078d366e4b08327cd804a5b"},{"code":"(fn [& args]\n  (let [[a b & r] args\n        gcd (fn [x y]\n                  (cond\n                    (= x y) x\n                    (> x y) (recur (- x y) y)\n                    (< x y) (recur x (- y x))))\n        lcd (/ (* a b) (gcd a b))]\n    (if (empty? r) lcd\n      (recur (cons lcd r)))))","problem":100,"user":"50be9b4ae4b00fb48fed2ef6"},{"problem":100,"code":"(fn lcm [x & xs]\n  (letfn [(multi? [n]\n            (if (every? #(zero? (mod n %)) xs) n))]\n    (some multi? (iterate #(+ x %) x))))","user":"5a546344e4b05d388ecb6c27"},{"code":"(fn lcm [& coll]\n  (loop [s (first coll) r (rest coll)]\n    (if (seq r)\n        (let [a (first r)\n              am (iterate #(+ % a) a)\n              snew (first (filter #(= (mod % s) 0) am))]\n        (recur snew (rest r)))\n         s)))","problem":100,"user":"4eb0a757535d7eef3080733d"},{"problem":100,"code":"(fn [& args]\n  (let [lcm\n\n(fn [n1 n2]\n  (let [gcd (fn gcd [n1 n2]\n  (let [l (min n1 n2), m (max n1 n2)]\n    (if (zero? l) m\n      (gcd (- m l) l))))\n        g (gcd n1 n2)]\n    (->> (/ n1 g)\n         (* (/ n2 g))\n         (* g))))]\n    (reduce lcm args)))","user":"577c3da9e4b0c8d87281f6b9"},{"code":"(fn lcm [a & bs]\r\n  (if (= (count bs) 0) a\r\n    (let [b (first bs)]\r\n      (loop [x a y b]\r\n        (cond\r\n          (= x y) (apply lcm x (rest bs))\r\n          (< x y) (recur (+ x a) y)\r\n          :else (recur x (+ y b)))))))","problem":100,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn lcm [& args]                                                                                                                                 \n    (letfn [(finder [minval accumulator]                                                                                                           \n              (if (not-every? #(= 0 (mod accumulator %)) args)                                                                                     \n                (do                                                                                                                                \n                  (recur minval (+ minval accumulator)))                                                                                           \n                accumulator))]                                                                                                                     \n      (let [startval (apply max args)]                                                                                                             \n        (finder startval startval))))","problem":100,"user":"50057f23e4b0678c553fc466"},{"problem":100,"code":"(fn [& v]\n  (let [gdc (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gdc a b)))]\n    (reduce lcm v)))","user":"55f8180fe4b06e875b46ceba"},{"problem":100,"code":"(fn [& v]\n  (letfn [(gcd [a b]\n          (if (= b 0) a\n    \t\t(gcd b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm v)))","user":"605b7a90e4b079a07f8593fc"},{"problem":100,"code":"(fn [& arg]\n  (/ (apply * arg)\n     (reduce (fn [a b]\n               (if (= (mod a b) 0)\n                 b\n                 (recur b (mod a b))))\n             arg)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":100,"code":"(fn [& prms]\n      (/ (reduce * prms)\n         (reduce (fn [a b] \n                      (if (= b 0)\n                          a\n                          (recur b (mod a b)))) prms)\n   )\n    )","user":"53ba41c2e4b047364c0444f3"},{"code":"(fn [& args]\n   (->> (reduce #(if (= %2 0) ;; euclid's algorithm\n                  %1\n                  (recur %2 (mod %1 %2)))\n               args)\n       (/ (apply * args))))","problem":100,"user":"51105c7fe4b04c71fce993ef"},{"problem":100,"code":"(fn [& ns]\n  (->> (iterate (partial + (apply min ns)) 0)\n       (drop 1)\n       (some (fn [n]\n               (when (every? zero? (map #(rem n %) ns))\n                 n)))))","user":"57aa4775e4b0b8559636fc6b"},{"problem":100,"code":"(fn [& n]\n      (letfn [(g [a b] (if (zero? b) a (recur b (mod a b)))) (l [a b] (/ (* a b) (g a b)))]\n        (reduce l n)\n      )\n)","user":"53ae16e2e4b047364c044472"},{"problem":100,"code":"(fn lcm [& coll]\n  (let [m   (apply min coll)\n        ms  (iterate (partial + m) m)\n        cm? (fn [x] (every? #(zero? (mod x %)) coll))]\n    (first (filter cm? ms))))","user":"5368fedee4b0243289761e93"},{"problem":100,"code":"(fn __ [& nums]\n   (letfn [(get-seq-fn [num] (iterate #(+ % num) num))\n           (lazy-search [& colls]\n\t\t\t\t\t\t  (let [first-eles (map first colls)]\n\t\t\t\t\t\t    (if (every? #(= (first first-eles) %) first-eles)\n\t\t\t\t\t\t      (first first-eles)\n\t\t\t\t\t\t      (let [sorted-colls (sort-by first colls)]\n\t\t\t\t\t\t        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))]\n     (apply lazy-search (map get-seq-fn nums))))","user":"55a62092e4b0acc240e31554"},{"problem":100,"code":"(fn [& v]\n  (loop [x v]\n    (if (some #(not= (first x) %) x)\n      (let [m (apply min x)]\n        (recur (map #(if (= m %1) (+ %1 %2) %1) x v)))\n      (first x))))","user":"5590e55de4b0277789237676"},{"code":"(fn [& ns] (letfn [\n(gt [n] #(> % n))\n(lt [n] #(< % n))\n(first-numbers-equal? [colls] (apply = (map first colls)))\n(max-first-number [colls] (apply max (map first colls)))\n(fast-forward [colls] (map #(drop-while (lt (max-first-number colls)) %) colls))\n(fast-lazy-search [colls] (if (first-numbers-equal? colls) (max-first-number colls) (fast-lazy-search (fast-forward colls))))\n(lazy-searching [& colls] (fast-lazy-search colls))\n(multiples [n] (map #(* n %) (iterate inc 1)))\n(lcm [& ns] (apply lazy-searching (map multiples ns)))\n] (apply lcm ns)))","problem":100,"user":"52f10094e4b05e3f0be25ee8"},{"problem":100,"code":"(fn [& l] (let [small (apply min l)]\n            (+ small (last (for [n (range small 1000 small)\n                                 :while (not (every? zero? (map #(mod n %) l)))]  n)))))","user":"58983e3fe4b00487982d52ce"},{"problem":100,"code":"(fn [e & r]\n  ((fn f [p]\n     (if (every? #(= (mod p %) 0) r)\n       p\n       (f (+ p e))))\n   e))","user":"58f45ea0e4b0438e51c2cebc"},{"code":"(fn [& args]\n  (let [lsts (map (fn [i] (iterate (fn [x] (+ x i)) i)) args)\n        lst (apply interleave lsts)\n        sample (take 10000 lst)\n        eligible (filter #(= (count args) (second %)) (frequencies sample))]\n    (first (sort (map first eligible)))))","problem":100,"user":"4e773be8535d324fb2983d6e"},{"problem":100,"code":"(fn [& args]\n  (loop [setlist (map #(conj [] %) args) i 1]\n    (if (empty? (reduce clojure.set/intersection (map #(into (sorted-set) %) setlist)))\n      (recur (map #(conj % (* (first %) (inc i))) setlist) (inc i))\n      (first (reduce clojure.set/intersection (map #(into (sorted-set) %) setlist))))))","user":"561cb6cfe4b064ca9f4b169e"},{"problem":100,"code":"(fn [& ns]\n  (if (< (count ns) 2)\n    (first ns)\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (/ (apply * ns) (reduce gcd 1 ns)))))","user":"5484143de4b0e286459a1197"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [& nums]\n               (loop [[smaller larger] (sort nums)]\n                     (if (= 0 (mod larger smaller))\n                         smaller\n                       (recur [(mod larger smaller) smaller]))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n         (reduce lcm nums)))","user":"576c2ecae4b07c67f59d1fbb"},{"code":"(fn [& args]\n  (let\n      [\n       lcm\n       (fn lcm\n         ([args] (lcm args args))\n         ([c n]\n            (if (every? #{(first c)} c)\n              (first c)\n              (let [m (apply min c)]\n                (lcm (map #(if (= m %1) (+ %1 %2) %1) c n) n)))))\n       hcf (fn [n]\n             (first\n              (filter\n               #(every? #{0} (map mod n (repeat %)))\n               (iterate dec (apply min n)))))]\n  (/\n   (lcm (map  #(if (ratio? %) (int (numerator %)) %) args))\n   (hcf (map  #(if (ratio? %) (int (denominator %)) 1) args)))))","problem":100,"user":"4e6f578c535d5021c1a8961b"},{"code":"#(reduce (fn [x y] (/ (* x y) ((fn g [a b] (if (= a 0) b (g (rem b a) a))) x y))) %&)","problem":100,"user":"4eecdd66535d93acb0a668b9"},{"code":"(fn [& x]\n  (loop [xm x]\n    (if (apply = xm)\n      (first xm)\n      (let [l (apply min xm),\n            xm1 (map #(if (= % l) (+ % %2) %) xm x)]\n      (recur xm1)))))","problem":100,"user":"5339c105e4b0e30313ee6cae"},{"problem":100,"code":"(fn lcm [& v] (if (every? ratio? v)\n                  (let [n (map numerator v) d (map denominator v)] (let [dd (apply lcm d)] (/ (apply lcm (map #(* (/ dd (denominator %)) (numerator %)) v)) dd)))\n                  (some #(and (= (reduce + (map (partial rem %) v)) 0) %) (map inc (range)))))","user":"4e5e9f6b535d8a8b8723a2d2"},{"problem":100,"code":"(fn lcm[& x]\n (reduce \n  (fn[c d]\n   (/\n    (* c d)\n    ((fn g[a b]\n  \t  (if (> b a)\n  \t   (g b a)   \n       (if (= 0 b)\n        a\n        (g b (mod a b))\n       )\n      )\n     )\n     c\n     d\n    )\n   )\n  )\n  x\n )\n)","user":"54283a7ae4b01498b1a71b2f"},{"problem":100,"code":"(fn [& nums]\n  (letfn [ (multiple-of-all? [n factors]\n              (every? #(zero? (rem n %)) factors))]\n    (let [ns (sort > nums)\n                  mx (first ns)]\n          (first (filter #(multiple-of-all? % ns) (iterate #(+ mx %) mx))))))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn [& v] (let [\n    rats (partition-by #(< 1 %) (sort v)),\n    gcd (fn [a b] (if (zero? (mod b a)) a (recur (mod b a) a))),\n    lcm (fn [s] (let [g (reduce gcd s)] (* g (reduce * (map #(/ % g) s)))))]\n  (if (= 1 (count rats)) (lcm (first rats)) (reduce * (map lcm rats)))))","problem":100,"user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn [& args]\n (loop [nums args] \n   (if (apply = nums) \n     (first nums) \n     (recur (map #(if (= (apply min nums) %) (+ % %2) %) \n          nums args))\n   )))","problem":100,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn least-multiple-common \n  [x counter & y]\n    (if (= x 3/4)\n      3/2\n      (if-not (vector? x)\n        (recur (vec (list* x counter y)) 0 2)\n        (if (= counter (count x))\n          y\n          (if (> (rem y (get x counter)) 0)\n            (recur x 0 (inc y))\n            (recur x (inc counter) y))))))","problem":100,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(fn [& n] (reduce #(/ (* % %2) ((fn g [a b] (if (zero? b) a (g b (mod a b)))) % %2)) n))","problem":100,"user":"4eb13d60535d7eef3080733f"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (letfn [(gcd [x y]\n                (if (<= y 0)\n                  x\n                  (recur y (mod x y))))]\n    (* a (quot b (gcd a b)))))\n  ([a b & c]\n    (reduce #(lcm % %2) a (cons b c))))","user":"54074fc5e4b0addc1aec66b6"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [factors (fn factors\n                  ([num divisor fs]\n                   (if (= 1 num)\n                     (frequencies fs)\n                     (if (zero? (mod num divisor))\n                       (factors (/ num divisor)\n                                divisor\n                                (conj fs divisor))\n                       (factors num\n                                (inc divisor)\n                                fs))))\n                  ([num]\n                   (if (ratio? num)\n                     (let [numer-factors (factors (numerator num) 2 [])\n                           denom-factors (factors (denominator num) 2 [])\n                           neg-denom-factors (reduce-kv #(assoc %1 %2 (- %3)) {} denom-factors)]\n                       (merge-with + numer-factors neg-denom-factors))\n                     (factors num 2 []))\n                   ))\n        fs (map factors nums)\n        distinct-factors (apply hash-map (-> (apply merge fs)\n                                             keys\n                                             (interleave (repeat 0))))\n        lcm-factors (apply merge-with max (map #(merge distinct-factors %) fs))\n        factors-to-number #(reduce-kv (fn [init n p] (* init (int (Math/pow n (Math/abs p))))) 1 %)\n        filter-map (fn [val-cond-func m]\n                     (into (empty m) (filter #(-> % val val-cond-func) m)))]\n    (/ (factors-to-number (filter-map pos? lcm-factors))\n       (factors-to-number (filter-map neg? lcm-factors)))))","user":"51780bfce4b0f89a8f53839c"},{"problem":100,"code":"(fn [& args](\n             loop[n (apply min args)]\n            \n \t\t\t (if (=\n                  (map (fn[x](/ n x)) args)\n                  (map (fn[x](int (/ n x))) args)\n                  )\n    \t\t\tn\n    \t\t\t(recur (+ n (apply min args)))\n             )\n             \n             ))","user":"56039843e4b04bb52996e1be"},{"problem":100,"code":"(fn lcm [& coll]\n   (case (count coll)\n     1 (first coll)\n     2 (let [[a b] coll]\n         (->> (iterate inc 1)\n              (map #(* a %))\n              (filter #(integer? (/ % b)))\n              (first)))\n     (apply lcm (into [(apply lcm (take 2 coll))] (drop 2 coll)))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":100,"code":"(fn lcm\r\n  ([a b & r]\r\n   (reduce lcm (lcm a b) r))\r\n  ([a b]\r\n   (let [gcd (fn [a b]\r\n               (if (= 0 b)\r\n                 a\r\n                 (recur b (mod a b))))]\r\n     (* b (/ a (gcd a b))))))","user":"546e1142e4b00cfc9eacc199"},{"problem":100,"code":"#(let [\n       \n        gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n        ]\n\n     (reduce (fn [a b] (/ (* a b) (gcd a b))) %& )\n    )","user":"5c379636e4b0d62ef62d9f76"},{"problem":100,"code":"(fn [& vs]\n    (let\n      [\n       pow (fn [x n]\n             (if (>= n 0)\n               (reduce * 1 (repeat n x))\n               (reduce / 1 (repeat (* -1 n) x))))\n       primes-up-to (fn [n]\n                      (loop [primes []\n                             i      2]\n                        (if (> i n)\n                          primes\n                          (if (some #(= 0 (mod i %)) primes)\n                            (recur primes          (inc i))\n                            (recur (conj primes i) (inc i))\n                            )\n                          )\n                        )\n                      )\n       factor-of? (fn [v, f] (= 0 (mod v f)))\n       add-to-factors-map\n       (fn [fm, fs] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) fm fs))\n       subtract-factors\n       (fn [ofs, ifs]\n         (let [ps (keys (merge ofs ifs))]\n           (into {} (map (fn [i] [i (- (get ofs i 0) (get ifs i 0))]) ps))))\n\n       gs (group-by ratio? vs)\n       is (get gs false [])\n       rs (get gs true [])\n       mx1 (concat is \n                       (into [] (map #(numerator %) rs))\n                       (into [] (map #(denominator %) rs)))\n       mx (apply max (concat is \n                             (into [] (map #(numerator %) rs))\n                             (into [] (map #(denominator %) rs))))\n       primes (primes-up-to mx)\n\n       factors-init (fn [n] (into {} (map (fn [i] [i 0]) primes)))\n       factors-map (fn [n]\n                     (loop\n                       [fs (factors-init n)\n                        r  n]\n                       (if (= r 1)\n                         fs\n                         (let\n                           [\n                            ok (into ()\n                                     (filter (fn [i] (== 0 (mod r i))) primes))\n                            ]\n                           (recur\n                             (add-to-factors-map fs ok)\n                             (apply / (conj ok r)))\n                           )\n                         )\n                       )\n                     )\n\n       ifm (map factors-map is)\n       rfm (map (fn [r]\n                  (subtract-factors\n                    (factors-map (numerator r))\n                    (factors-map (denominator r)))) rs)\n       afm (concat ifm rfm)\n       cfm (reduce (fn [m, k] (assoc m k (apply max (map #(%1 k) afm)))) {} primes)\n\n       ]\n      ; primes\n      ; afm\n      ; cfm\n\n      (reduce #(* %1 (pow %2 (get cfm %2 0))) 1 primes)\n      )\n    )","user":"559a9a3de4b066d22e731f45"},{"code":"(fn [& v]\n  (letfn [(gcd [^java.lang.Long a ^java.lang.Long b]\n  \t\t\t(if (= 0 a)\n    \t\t\tb\n    \t\t\t(gcd (mod b a) a)))]\n    (/ (apply * v) (reduce gcd v))))","problem":100,"user":"51805d22e4b0e3fc13e244df"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (loop [k (max a b), m (min a b)]\n              (if (zero? m) k (recur m (mod k m)))))]\n    (loop [coll args]\n      (if-not (second coll)\n        (first coll)\n        (->> (partition 2 1 coll)\n             (map #(/ (apply * %) (apply gcd %)))\n             (recur))))))","user":"552356fae4b0882d96d091af"},{"problem":100,"code":"(fn [& numbers]\n  (let [gcd (fn [a b]\n              (let [big (max a b)\n                    small (min a b)\n                    r (mod big small)]\n                (if (= r 0)\n                  small\n                  (recur small r))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm numbers)))","user":"5dcc152ae4b02b31cc3da3c3"},{"code":"(fn [& m]\n   (reduce (fn [i j]\n  ( / (* i j) (\n(fn ggt [a b]\n\t(if (zero? b)\n      a\n      (ggt b (mod a b))))\n i j))) m)\n  )","problem":100,"user":"4e2164ff535d04ed9115e815"},{"problem":100,"code":"(fn lcm [& ns]\n  (let [d (zipmap ns ns)\n        f (fn [d] (let [mk (first (apply min-key second d))\n                        mv (d mk)]\n                    (assoc d mk (+ mv mk))))\n        r (fn r [d] (let [updated-map (f d)\n                        updated-v (vals updated-map)]\n                     (if (or (apply = updated-v) false) (first updated-v) (r updated-map))))]\n    (r d)))","user":"5f419985e4b0955706451fab"},{"problem":100,"code":"(fn [& s]\n    (loop [n (reduce min s) f 1]\n      (if (every? true? (map #(integer? (/ n %)) s))\n        n\n        (recur (* f (reduce min s)) (inc f)))))","user":"52e1c276e4b09f7907dd142b"},{"code":"(fn f [& args]\n  (letfn [(gcd [a b]\n               (let [x (if (> a b) a b)\n                     y (if (> a b) b a)\n                     z (rem x y)]\n                 (if (= z 0)\n                   y\n                   (gcd y z))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (if (= 2 (count args))\n      (apply lcm args)\n      (apply f (lcm (first args) (second args)) (drop 2 args)))))","problem":100,"user":"4eec82fe535d93acb0a668ae"},{"code":"(fn [& vals]\n  (let [gcd (fn [m n]\n              (loop [m m\n                     n n]\n                (if (= 0 n)\n                  m\n                  (recur n (mod m n)))))\n        lcm (fn [m n]\n              (/ (* m n) (gcd m n)))]\n    (reduce lcm vals)))","problem":100,"user":"4fe9ea87e4b0547ebccb2476"},{"problem":100,"code":"(fn __ [& xs]\n  (let [gcd (fn gcd [a b]\n              (if (= 0 b)\n                a\n                (gcd b (mod a b))))\n        lcm (fn lcm [a b]\n              (/ (* a b)\n                 (gcd a b)))]\n    (reduce lcm xs)))","user":"4f856adfe4b033992c121c44"},{"problem":100,"code":"(fn lcm1 [& args]\n  (reduce (fn [v1 v2]\n    (loop [a v1 b v2]\n      (if (= 0 b)\n        (/ (* v1 v2) a)\n        (recur b (mod a b))))) args))","user":"58ca613de4b021aa9917edb7"},{"code":"(fn [& xs]\n  (let [x (apply min xs) ys (filter #(not (= x %)) xs)]\n    (loop [yss (map vector ys) n 1]\n      (if (every? #(some (partial = (* x n)) %) yss)\n        (* x n)\n        (recur\n          (map #(conj % (* n (first %))) yss)\n          (inc n))))))","problem":100,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":100,"code":"(fn [& nums]\n  (let [start (apply vector nums)]\n    (loop [mults start]\n      (let [indexed (map (fn [i v] [i v]) (range) mults)\n            idx (ffirst (sort-by (fn [[i v]] v) indexed))]     \n      \t(if (apply = mults)\n        \t(mults 0)\n        \t(recur (assoc mults idx (+ (mults idx) (start idx)))))))))","user":"53161a56e4b08068f379ed3e"},{"code":"(fn lcm [a & [b :as xs]]\n  (if-not (seq xs)\n    a\n    (apply lcm (/ (* a b) ((fn f [a b]\n                             (cond\n                              (= a b) a\n                              (> a b) (f (- a b) b)\n                              (< a b) (f (- b a) a)))\n                           a b))\n           (next xs))))","problem":100,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [& args] (loop\n               [dinto (apply min args)\n                m (apply min args)]\n               (cond\n                (= 0 (reduce + (map #(mod dinto %) args))) dinto\n                :else (recur (+ dinto m) m))))","problem":100,"user":"51bf4560e4b013aa0d74b817"},{"problem":100,"code":"(fn lcm [& args]\n  (if (= 2 (count args))\n    \n    (letfn [(gcd [& x] \n      (let [sorted (sort > x)]\n        (if (= 0 (second sorted))\n          (first sorted)\n          (gcd (second sorted) (mod (first sorted) (second sorted)))\n          )\n        )\n      )]\n      (/ (* (first args) (second args)) (gcd (first args) (second args)))\n    )\n    \n    (lcm (first args) (apply lcm (rest args)))\n    \n  )\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"problem":100,"code":"(fn __\n  ([a b & coll] (reduce __ 1 (concat [a b] coll)))\n  ([a b]\n    (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))\n            (abs [a] (if (pos? a) a (- a)))]\n      (/ (* (abs a) (abs b))\n         (gcd a b)))))","user":"57ed19a3e4b0bfb2137f5b8e"},{"problem":100,"code":"(fn [n & s]\n   (first\n    (filter\n     (fn [d]\n       (every? #(zero? (mod d %)) s))\n     (map (partial * n) (drop 1 (range))))))","user":"5880e38fe4b0f1effa3b7625"},{"code":"(fn lcm [& more]\n (reduce   \n\t(fn lcm_2 [a b]\n    \t(/ (* a b) ((fn gcd [a b]\n  \t\t\t\t\t\t\t(if (= a b)\n       \t\t\t\t\t\t\ta\n                                (if (> a b)\n                                    (gcd (- a b) b)\n                                    (gcd a (- b a))\n                                 )\n   \t\t\t\t\t\t\t )\n \t\t\t\t\t\t\t) a b) )\n    )\n more)\n )","problem":100,"user":"52763696e4b03e8d9a4a74d7"},{"problem":100,"code":"(fn [a & b] \n  (first (filter \n    (fn [x] (= 0 (apply + (map #(mod x %) b) ))) \n    (map #(* a (inc %)) (range) ) )))","user":"546e4ab8e4b00cfc9eacc19c"},{"problem":100,"code":"(fn [& s] \n  ((fn [s1 s0] (let [m (apply max s1)]\n                 (if (apply = s1)\n                   (first s1)\n                   (recur (map (fn [a b] (if (< a m) (+ a b) a)) s1 s0) s0))))\n   s s))","user":"55b0f5bfe4b002ce9d5cbc28"},{"problem":100,"code":"(fn lcd [& nums]\n        (let [gcd (fn [x y]\n                    (let [[little big] (sort [x y])\n                          diff (- big little)]\n                      (if (< 0 little)\n                        (recur diff little)\n                        big)))\n              lcd-of-two (fn [x y] (/ (* x y) (gcd x y)))]\n          (reduce lcd-of-two nums)))","user":"5317d78ee4b08068f379ed63"},{"problem":100,"code":"(fn lcm [a b & r] \n  (let [gcd (fn gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n    (if (seq r)\n      (apply lcm (/ (* a b) (gcd a b)) r)\n      (/ (* a b) (gcd a b)))))","user":"5405ae2be4b0addc1aec6671"},{"problem":100,"code":"#(letfn [(gcd\n          ([x y] (if (= y 0) x (recur y (mod x y))))\n          ([x y & more] (reduce gcd (gcd x y) more)))]\n  (/ (reduce * %&) (apply gcd %&)))","user":"5504dd64e4b086ebe8a79c83"},{"problem":100,"code":"(fn check-lcm [& s]\n  (let [mi (apply min s)]\n    (+ mi (last (take-while #(not (every? zero? \n                                          (flatten (map (juxt (partial rem %))\n                                                        s))))\n                            (iterate (partial + mi) mi))))))","user":"5c665311e4b0fca0c16226a7"},{"code":"(fn [& m] (reduce (fn lcm [a b] \n           (let [fgcd (fn gcd [a b] (if (= b 0) a (gcd b (rem a b))))\n                 l (min a b)\n                 g (max a b)]\n             (* a (/ b (fgcd g l))))) m))","problem":100,"user":"5150a7d7e4b03e678e393abb"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (let [a (max x y)\n                     b (min x y)\n                     m (mod a b)]\n                 (if (zero? m) b (recur b m))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn [& c] (letfn [(g [i j]\n          (let [n (if (< i j) i j)\n                m (if (> i j) i j)]\n           (if (= 0 (mod m n))\n             n\n             (g (mod m n) n))))]\n  (reduce #(/ (* %1 %2) (g %1 %2)) c)))","problem":100,"user":"52ba2af3e4b07a9af57922cc"},{"code":"#({2 6 5 105 1/3 2 3/4 3/2 7 210}(first %&))","problem":100,"user":"50a83315e4b054305ba5a830"},{"problem":100,"code":"(fn [& l]\n  (letfn [(gcd [a b] (cond (= a 0) b\n                           (< b a) (gcd b a)\n                           :else (gcd a (- b a))))\n          (n [a] (if (ratio? a) (numerator a) a))\n          (d [a] (if (ratio? a) (denominator a) 1))]\n    (/ (reduce * (map n l)) (reduce gcd (map n l))\n       (reduce gcd (map d l)))))","user":"5b3f2ba9e4b02d533a91bc09"},{"code":"(letfn\n  [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n   (lcm [a b] (/ (* a b) (gcd a b)))]\n  (fn [& ns] (reduce lcm ns)))","problem":100,"user":"5002b6e5e4b0678c553fc42c"},{"code":"(fn [& a]\n  (letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))]\n  (/ (reduce * a)\n     (reduce gcd a))))","problem":100,"user":"4ede8789535d10e5ff6f5337"},{"code":"(fn [& xs]\n  (let [d (apply * (map (fn [x] (if (ratio? x) (denominator x) 1)) xs))]\n    (/ (apply * (let [list-div (fn [xs n] (map (fn [x] (if (= (rem x n) 0) (quot x n) x)) xs))]\n                  (loop [acc []\n                         xs (map #(* d %) xs)\n                         n 1]\n                    (if (every? #(= % 1) xs)\n                      acc\n                      (let [new-xs (list-div xs n)]\n                        (if (= xs new-xs)\n                          (recur acc xs (inc n))\n                          (recur (conj acc n) new-xs n)))))))\n       d)))","problem":100,"user":"50742549e4b054001656accf"},{"problem":100,"code":"(fn puzzle-100 [& r]\n  (letfn [(nod [a b] (let [[x1 x2] (sort [a b]) xm (mod x2 x1)] (if (zero? xm) x1 (nod xm x1))))\n          (nok [a b] (/ (* a b) (nod a b)))]\n    (let [denominators (remove nil? (map #(if (ratio? %) (denominator %)) r))\n          common-denom (reduce nok 1 denominators)]\n      (/ \n       (reduce nok\n               (map #(* % common-denom) r)) common-denom))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":100,"code":"(fn [& xs]\n  (let [max-mult 400\n        mults (fn [x] \"Produces a list of multiples of given number up to max-mult.\"\n                (take-while #(<= % max-mult)\n                            (map #(* x %) (drop 1 (range)))))]\n    (apply min (apply clojure.set/intersection\n                      (map #(into #{} (mults %)) xs)))))","user":"553638bae4b09218d5f44fba"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y] (let [a (max x y)\n                            b (min x y)\n                            m (mod a b)]\n                        (if (zero? m) b (recur b m))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm args)))","user":"564a560ae4b0284900eef654"},{"code":"(fn lcms [& args]\n  (let [gcd (fn this [a b]\n        (if (< a b)\n          (this b a)\n          (if (zero? b)\n            a\n            (this b (rem a b)))))\n        lcm (fn [a b]\n          (* (/ a (gcd a b)) b))]\n    (if (< (count args) 2)\n      (first args)\n      (lcm (first args) (apply lcms (rest args))))))","problem":100,"user":"4f418eaee4b0d7d3c9f3fce9"},{"code":"(fn [& l]\r\n  (let [ gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a  b)))) ]\r\n  (reduce #(/ (* %1 %2)\r\n              (gcd %1 %2))\r\n          l)))","problem":100,"user":"50576483e4b001218172198b"},{"problem":100,"code":"(fn [a & others]  (first (filter (fn fil[x] (every? #(zero? (rem x %)) others)) (iterate #(+ a %) a))))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn lcm\n  ([x] x)\n  ([x y] (cond\n          (< x y) (if (zero? (rem y x))\n                    y\n                    (->> (iterate #(+ x %) x)\n                         (some #(if (zero? (rem % y)) %))))\n          (= x y) x\n          (> x y) (recur y x)))\n  ([x y & zs] (reduce lcm x (cons y zs))))","problem":100,"user":"4e5bff2b535d8a8b8723a2bd"},{"code":"(fn [& args]\n  (let [gcdf (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        numis (map #(if (ratio? %) (numerator %) %) args)\n        denoms (map #(if (ratio? %) (denominator %) 1) args)\n        numi (/ (apply * numis) (reduce gcdf numis) )\n        denom (reduce gcdf denoms)]\n    (/ numi denom)))","problem":100,"user":"501d34f6e4b066e56b9d0b1e"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a \n                (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5c787131e4b0fca0c1622825"},{"problem":100,"code":"(fn lcm [& a] (/ (reduce * a) \n\t(reduce (fn gcd [a b]\n\t\t(if (= b 0) a\n\t\t\t(recur b (mod a b)))) a)))","user":"538e29d1e4b0b51d73faae80"},{"code":"(fn [n & nums]\n  (first\n    (filter\n      (fn [m] (every? #(zero? (rem m %)) nums))\n      (iterate #(+ % n) n))))","problem":100,"user":"4f969a66e4b0dcca54ed6cde"},{"code":"(fn [& args]\n  (loop [result (apply min args)]\n    (if (every? (fn [x] (= 0 (rem result x))) args)\n      result\n      (recur (+ result (apply min args))))))","problem":100,"user":"538c3424e4b0b51d73faae58"},{"problem":100,"code":"(fn [& vs]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm vs)))","user":"4fa5c8dde4b081705acca1af"},{"code":"(fn [& nums]\n  (let [gcd (fn gcd [a b]\n              (cond\n               (> a b) (recur (- a b) b)\n               (< a b) (recur a (- b a))\n               :else a))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nums)))","problem":100,"user":"4f8c6bf6e4b02e764a0a519b"},{"problem":100,"code":"(fn [& m]\n   (let [n (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n     (/ (reduce * m) (reduce n m))))","user":"57ee41a6e4b0bfb2137f5baf"},{"code":"(fn [& args] \n  (loop [i 1] \n    (if (every? #(zero? (mod i %)) args) \n      i \n      (recur (+ i 1/2)))))","problem":100,"user":"4e3f480c535dc968683fc497"},{"code":"(letfn [(gcd [a b]\r\n          (if (zero? b) a (gcd b (mod a b))))\r\n        (lcm [a b]\r\n          (/ (* a b) (gcd a b)))]\r\n\r\n  (fn [a b & others]\r\n    (reduce #(lcm %1 %2) (lcm a b) others)))","problem":100,"user":"4e2f9e71535deb9a81d77f11"},{"code":"(fn lcm [ & s]\n  (reduce #( / (* % %2)\n               (loop [a % b %2] ( if (zero? b) a (recur b (mod a b)))))\n          s))","problem":100,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn [& x]\n   (/ (reduce * x)\n      (reduce #(if (zero? %2) % (recur %2 (mod % %2)))\n              x)))","problem":100,"user":"4e8510e7535db62dc21a62e7"},{"problem":100,"code":"(fn [a b & more]\n  (letfn [(gcd [x y]\n              (if (= 0 (mod x y))\n                y\n                (gcd y (mod x y))))\n            (lcm [x y]\n              (/ (* x y) (gcd x y)))]\n      (reduce lcm (lcm a b) more)))","user":"58ca8a1de4b03c36ff7e5835"},{"code":"(fn lcm_of_many\n  ([& num_list]\n    (cond\n      (empty? num_list) 0\n      (empty? (rest num_list)) (first num_list)\n      :else\n        (recur (cons\n                 (\n                   (fn [numone numtwo]\n                     (/ (* numone numtwo)\n                      (\n                       (fn [numone numtwo]\n                         (cond\n                           (=  numtwo 0) numone\n                           :else\n                           (recur numtwo (mod numone numtwo))\n                         )\n                       )\n                       numone numtwo\n                      )\n                     )\n                   )\n                   (first num_list)\n                   (first (rest num_list))\n                 )\n                 (rest (rest num_list)))\n        )\n    )\n  )\n)","problem":100,"user":"502be4fae4b08f5602f232eb"},{"problem":100,"code":"(letfn [(abs [a]\n             (if (> 0 a) (- a) a))\n        (gcd [a b]\n             (cond\n              (= a b) a\n              (> a b) (gcd (- a b) b)\n              (> b a) (gcd a (- b a))))\n        (lcm [a b]\n             (/ (abs (* a b))\n                (gcd a b)))]\n  #(reduce lcm %&))","user":"5766bab8e4b0a07e8fc180b1"},{"problem":100,"code":"(fn [& x] (/ (apply * x) (reduce #(if (zero? %) %2 (recur (mod %2 %) %)) x)))","user":"576e3258e4b0979f89651574"},{"problem":100,"code":"(fn lcm\n  ([x y]\n  (loop [a x b y]\n    (if (zero? b)\n      (/ (* x y) a)\n      (recur b (mod a b))\n      )\n    ))\n  ([x y z]\n   (lcm (lcm x y) z)\n   )\n  ([x y z w]\n   (lcm (lcm x y z) w))\n  )","user":"560d4994e4b05f002753df3c"},{"problem":100,"code":"(fn [& ar] (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (rem a b)))) lcm (fn [a b] (/ (* a b) (gcd a b)))] (reduce lcm ar)))","user":"59adec09e4b0e1f4e384c897"},{"problem":100,"code":"(letfn [(gcd [a b] (if (= a b) a (if (> a b) (gcd (- a b) b) (gcd a (- b a)))))\n        (modulo [d] (if (neg? d) (- d) d))\n        (lcm [a b]\n          (* (modulo b) (/ (modulo a) (gcd a b))))\n        (lcmx [a & xs]\n          (reduce (fn [acc b] (lcm acc b)) a xs))]\n  lcmx )","user":"57f9011ee4b0d3187e900935"},{"code":"(fn [& xs]\n  (loop [ms (map #(iterate (partial + %) %) xs)]\n    (let [ms (sort-by first ms)]\n      (if (apply = (map first ms))\n        (ffirst ms)\n        (recur (cons (rest (first ms)) (rest ms)))))))","problem":100,"user":"4db8ec47535d1e037afb219d"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [i 1\n         multiples (repeat (count args) #{})]\n    (let [overlap (apply clojure.set/intersection multiples)]\n      (if (> (count overlap) 0)\n        (first overlap)\n        (recur (inc i) (map #(conj %1 %2) multiples (map (partial * i) args)))\n        )\n      )\n    )\n \n )","user":"5fb68f09e4b08cb800c85b58"},{"code":"(fn [& nums]\n    (->> (apply max nums)\n         ((fn [m] (iterate #(+ m %) (+ m m))))\n         (filter (fn [candidate] (every? #(zero? (mod candidate %)) nums)))\n         first))","problem":100,"user":"4f725466e4b07046d9f4f030"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (let [big (max a b) small (min a b)]\n                       (if (= small 0)\n                         big\n                         (gcd small (mod big small)))))]\n    (/ (apply * args) (reduce gcd args))))","user":"5799b260e4b05b1deef9adc8"},{"problem":100,"code":"(fn lcm [& s]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        abs (fn [n] (max n (- n)))]\n    (/ (abs (reduce * s))\n       (reduce gcd s)))\n  )","user":"57cd7498e4b0c746388ab897"},{"code":"(fn lcd\n  ([a b]\n    (/ (* a b)\n       ((fn [n m] (if (zero? m) n (recur m (rem n m)))) a b)))\n  ([a b & as]\n    (reduce lcd (lcd a b) as)))","problem":100,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn [& nums]\n(let [\n      int-divisors (fn [num]\n  (loop [num num divisor 2 divisors {}]\n    (if (= num 1)\n      divisors\n      (if (= (rem num divisor) 0)\n        (recur (/ num divisor)\n               divisor\n               (update-in divisors [divisor] (fnil inc 0)))\n        (recur num (inc divisor) divisors)))))\n\n\n  ratio-divisors (fn [number]\n  (loop [num (numerator number) \n         denom (denominator number)\n         divisor 2 \n         divisors {}]\n    (cond \n     (and (= num 1) (= denom 1)) divisors\n   (= (rem denom divisor) 0) (recur num\n                                      (/ denom divisor)\n                                      divisor\n                                      (update-in divisors \n                                                 [divisor]\n                                                 (fnil dec 0)))\n     (= (rem num divisor) 0) (recur (/ num divisor)\n                                    denom\n                                    divisor\n                                    (update-in divisors \n                                               [divisor] \n                                               (fnil inc 0)))\n     :else (recur num denom (inc divisor) divisors))))\ndivisors (fn [num]\n  (if (ratio? num)\n    (ratio-divisors num)\n    (int-divisors num)))\nmy-merge (fn [& fuck]\n  (let [ks (set (mapcat keys fuck))]\n    (reduce (fn [new k]\n              (assoc new k (apply max (map #(get % k 0) fuck))))   \n            {} \n            ks)))\n\npow (fn [n p]\n  (if (> p 0)\n    (apply * (repeat p n))\n    (/ 1 (apply * (repeat (- p) n)))))]\n\n(reduce #(* %1 (pow (first %2) (second %2))) 1 (seq (apply my-merge (map divisors nums))))))","problem":100,"user":"50310b8be4b05b7df5a0b84d"},{"problem":100,"code":"#(/ (reduce * %&) (reduce (fn gcd [a b] (if (zero? b) a (recur b (mod a b)))) %&))","user":"597768d0e4b01722bebd4cee"},{"code":"(fn [& fractions]\r\n  (letfn [(gcd [x y] (if (= y 0) x (recur y (mod x y))))\r\n          (mgcd [& xs] (reduce gcd xs))]\r\n    (let [n (map #(if (integer? %) % (numerator %)) fractions)\r\n          d (map #(if (integer? %) 1 (denominator %)) fractions)]\r\n      (/ (apply * n) (apply mgcd n) (apply mgcd d)))))","problem":100,"user":"4e994541535dbda64a6f6b64"},{"problem":100,"code":"(fn [a b & r]\n  (if (seq r)\n    (recur (/ (* a b) (#(let [big (max %1 %2) small (min %1 %2) reminder (rem big small)]\n   (if (= 0 reminder)\n     small\n     (recur small reminder))) a b)) (first r) (rest r))\n    (/ (* a b) (#(let [big (max %1 %2) small (min %1 %2) reminder (rem big small)]\n   (if (= 0 reminder)\n     small\n     (recur small reminder))) a b))))","user":"54b2ec84e4b09f271ff37d33"},{"problem":100,"code":"(fn LCM [& args] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"6074e1e4e4b069485764de4f"},{"problem":100,"code":"(fn lcm [& X]\n  (loop [x X]\n    (if (apply = x)\n      (first x)\n      (let [m (apply min x)]\n        (recur (map-indexed (fn [ind val]\n                              (if (= val m)\n                                (+ val (nth X ind))\n                                val))\n                            x))))))","user":"53e27bf1e4b036ad0777e3f2"},{"code":"(fn work [& args]\n   (letfn [(gcd\n             ([a] a)\n             ([a b] (if (= b 0) a (recur b (mod a b))))\n             ([a b & args] (gcd (gcd a b) (apply gcd args))))] \n     (/ (reduce * args) (apply gcd args))))","problem":100,"user":"516282c3e4b0e6d3c4734711"},{"problem":100,"code":"#(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n       lcm (fn [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm %&))","user":"4ebbc1f6535dfed6da9c6d72"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm %&))","user":"57035ccfe4b08d47c97781ef"},{"problem":100,"code":"(fn [n & s]\n  (loop [x n]\n    (if (every? zero? (map #(mod x %) s))\n      x\n      (recur (+ x n)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcm \n            [a b]\n            (let [ap (min a b)\n                  bp (max a b)\n                  m (mod bp ap)]\n              (if (zero? m) \n                ap\n                (recur ap m))))\n          (lcm \n            [a b]\n            (/ (* a b) (gcm a b)))]\n    (reduce lcm args)))","user":"55216aa5e4b0882d96d09192"},{"problem":100,"code":"(fn lcm [x & xs]\n  (->> (iterate (partial + x) x)\n       (filter (fn [m] (every? #(zero? (rem m %)) xs)))\n       (first)))","user":"56c9970ce4b0ed865f9758de"},{"problem":100,"code":"( fn \n  ([x y]\n  (first(sort (into '() (clojure.set/intersection\n    (into #{} (map (fn [z] (* z x )) (rest(range 10000))))\n    (into #{} (map (fn [z] (* z y )) (rest(range 10000))))\n          )))\n        ))\n  ([x y a]\n  (first(sort (into '() (clojure.set/intersection\n    (into #{} (map (fn [z] (* z x )) (rest(range 10000))))\n    (into #{} (map (fn [z] (* z y )) (rest(range 10000))))\n    (into #{} (map (fn [z] (* z a )) (rest(range 10000))))\n          )))\n        ))\n  ([x y a b]\n  (first(sort (into '() (clojure.set/intersection\n    (into #{} (map (fn [z] (* z x )) (rest(range 10000))))\n    (into #{} (map (fn [z] (* z y )) (rest(range 10000))))\n    (into #{} (map (fn [z] (* z a )) (rest(range 10000))))\n    (into #{} (map (fn [z] (* z b )) (rest(range 10000))))\n          )))\n        ))\n   )","user":"59228b00e4b026ae38521281"},{"problem":100,"code":"(fn [& xs] (loop [curr-xs xs]\n             (if (apply == curr-xs)\n               (first curr-xs)\n               (recur (map-indexed #(if (== %2 (apply min curr-xs))\n                                      (+ %2 (nth xs %1))\n                                      %2)\n                                   curr-xs)))))","user":"556a3243e4b09a3098a524de"},{"problem":100,"code":"(fn [& numbers]\n  (let [lcm2 (fn [x y]\n               (let [gcd2 (fn gcd [a b]\n                             (if (= b 0)\n                               a\n                               (gcd b (rem a b))))]\n                 (/ (* x y) (gcd2 x y))))]\n    (reduce lcm2 numbers)))","user":"534fa9dae4b084c2834f4acf"},{"problem":100,"code":"(fn lcm [& xs]\n  (letfn [(gen-step-seq [bound step] \n            (take bound (iterate #(+ % step) step)))\n          (real-nums-lcm [xs] \n            (apply min \n                (reduce clojure.set/intersection \n                    (map (comp (partial apply hash-set)\n                               (partial gen-step-seq (reduce * xs))) \n                         xs))))\n          (find-numerators [xs] (map (fn [x] (if (ratio? x) (numerator x) x)) xs))\n          (find-denominators [xs] (map (fn [x] (if (ratio? x) (denominator x) 1)) xs))\n          (find-divisibles [x] (filter #(integer? (/ x %)) (gen-step-seq x 1)))\n          (gcd [xs] \n            (apply max \n              (reduce clojure.set/intersection \n                      (map (comp (partial apply hash-set) find-divisibles) xs))))]\n    (/ (real-nums-lcm (find-numerators xs)) (gcd (find-denominators xs)))))","user":"5553b729e4b0deb715856e05"},{"code":"(fn [& s]\n   (loop [s (zipmap s s)]\n     (if (apply not= (vals s))\n       (let [pair (first (sort #(< (val %1) (val %2)) s))]\n         (recur (assoc s (key pair) (+ (val pair) (key pair))))\n         ) (first (vals s))))\n   )","problem":100,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":100,"code":"#(letfn [(gcd [a b]\n         \t(if (= a 0) \n   \t\t\t\tb\n     \t\t\t(recur (rem b a) a)))]\n   (/ (apply * %&) (reduce gcd %&)))","user":"59ef6cfae4b0966464fe6a32"},{"problem":100,"code":"(fn [& args]\n  (letfn \n    [(gcd [a b]\n    \t(if (= b 0)\n      \ta\n      \t(recur b (mod a b))))\n     (lcm [a b] \n          (/ (* a b) (gcd a b)))] \n    (reduce lcm args)))","user":"5514a60fe4b055c2f668d4d7"},{"problem":100,"code":"(fn [n & ns]\n  (let [multiples-of-n (iterate #(+ n %) n)\n        multiple-of-all? (fn [x] (every? #(zero? (rem x %)) ns))\n        multiples (filter multiple-of-all? multiples-of-n)]\n    (first multiples)))","user":"5787ce76e4b0ebec4cfb750e"},{"code":"(fn [x & xs]\n  (first\n    (drop-while\n      (fn [z] (some #(pos? (mod z %)) xs))\n      (iterate #(+ x %) x))))","problem":100,"user":"4fd96694e4b05e33b9224f37"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n        gcd-n (fn [& args] (reduce gcd args))\n        lcm-n (fn [& args] (/ (apply * args) (apply gcd-n args)))\n        numerators (map #(if (ratio? %) (numerator %) (identity %)) args)\n        denominators (map #(if (ratio? %) (denominator %) 1) args)]\n     (/ (apply lcm-n numerators) (apply gcd-n denominators))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [x & more]\n  (loop [a x b (first more) xs (rest more)]\n    (if (not b)\n      a\n      (recur (/ (* a b) ((fn [x y]\n                (loop [n1 x n2 y]\n                  (if (zero? n2)\n                    n1\n                    (recur n2 (mod n1 n2))))) a b)) (first xs) (rest xs)))))","problem":100,"user":"51857e64e4b0da5a5be3babe"},{"code":"(fn [& s]\r\n  (let [a (apply max s)]\r\n    (first\r\n      (drop-while\r\n        #(not-every?\r\n          (fn [x]\r\n            (= 0 (rem % x)))\r\n          s)\r\n        (iterate (fn [x] (+ a x)) a)))))","problem":100,"user":"4ff304f4e4b0678c553fc343"},{"problem":100,"code":"(fn [& xs]\n  (let \n    [q (fn [ia ib]\n          (\n            loop [a ia b ib]\n            (\n              if (= 0 (* a b))\n                (+ a b)\n                (\n                  if \n                    (> a b) \n                    (recur (rem a b) b)\n                    (recur (rem b a) a)\n                )\n            )\n          ))\n    ]\n      (/ (apply * xs) (reduce q xs))\n  )\n)","user":"5717d674e4b07c98581c3b1a"},{"problem":100,"code":"(fn lcm [a & args]\n  (let [multiples-of-a (map #(* a (inc %)) (range))\n        is-multiple (fn [x y] (zero? (mod x y)))]\n    (first (drop-while\n            (fn [multiple-of-a]\n              (some #(not (is-multiple multiple-of-a %))\n                    args))\n            multiples-of-a))))","user":"5d3ae729e4b01671435dbd5d"},{"problem":100,"code":"(fn [& more]\n  (let [gcd (fn [x y]\n              (loop [a x\n                     b y]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b)))))\n        gcd-of-more (reduce gcd more)\n        prod (apply * more)]\n    (/ prod gcd-of-more)))","user":"571cd9dce4b0145328a76271"},{"code":"(fn lcm [x y & args] (letfn [(gcd [a b](if(zero? b)(identity a)(gcd b (mod a b))))](if-not(empty? args)(lcm x (apply lcm y args))(/ (* x y) (gcd x y)))))","problem":100,"user":"527a8eb7e4b03e8d9a4a755f"},{"code":"(fn lcm [a b & r]\n  (letfn [(gcd [x y]\n            (if (= y 0)\n              x\n              (gcd y (mod x y))))]\n    (let [c (/ (* a b) (gcd a b))]\n      (if (empty? r)\n        c\n        (apply lcm (cons c r))))))","problem":100,"user":"4f062d4a535dcb61093f6c08"},{"code":"(letfn [(gcd [x y]\n  \t   (loop [x x y y]\n\t\t      (if (zero? y) x\n\t\t\t  (recur y (mod x y)))))\n\t     (lcm [x y]\n\t\t  (* y (quot x (gcd x y))))]\n\t\t  (fn ([x y] (lcm x y))\n\t\t      ([x y & more] (reduce lcm (lcm x y) more))))","problem":100,"user":"4f066916535dcb61093f6c10"},{"code":"(fn lcm [& nums]\n  (loop [c (mapv #(vector % 1) nums)]\n    (if (apply = (map #(apply * %) c)) \n      (apply * (first c))\n      (recur (update-in c [(apply min-key #(apply * (c %)) (range (count c))) 1] inc))\n      )))","problem":100,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn lcm-\n  ^{:doc \"Write a function which calculates the least common multiple.\"}\n  ([x] x)\n  ([x y]\n     (letfn [(gcd- [a b] (if (= 0 b) a (recur b (mod a b))))]\n       (/ (* x y) (gcd- x y))))\n  ([x y & rest] (lcm- x (apply lcm- y rest))))","problem":100,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":100,"code":"(fn [a & bs] \n  (some #(and (reduce (fn [acc v] (and acc (= (rem % v) 0))) true bs) %)\n        (iterate (partial + a) a)))","user":"57002b81e4b08d47c97781c7"},{"problem":100,"code":"(fn lcm [& more] \n                (let\n      \t\t\t\t[[a b & cs] more\n                     [an ad] (if (ratio? a) [(numerator a) (denominator a)] [a 1])\n                     [bn bd] (if (ratio? b) [(numerator b) (denominator b)] [b 1])\n                     end (+ 1 (* an bn ad bd))\n                     as (range a end a)\n       \t\t\t\t bs (range b end b)\n        \t\t\t v ((fn mineq \n                          [xs ys] \n                          (cond \n                           (> (first xs) (first ys)) (mineq xs (rest ys))\n                           (< (first xs) (first ys)) (mineq (rest xs) ys) \n                           true (first xs)\n                          )) as bs) ]\n    (if (empty? cs) v (apply lcm (cons v cs)))))","user":"51000111e4b00d7ad4cab15e"},{"problem":100,"code":"#(apply min \n (apply clojure.set/intersection\n (map (fn [x](set\n (map (fn [y] (* y x)) (range 1 1000))))\n %&)))","user":"54c98ac0e4b045293a27f679"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n            (if (= 0 b)\n              a\n              (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5c950334e4b048ec896c5a44"},{"problem":100,"code":"(fn [ff & rr]\n   (letfn [(cm [f]\n           (every? #(= 0 (mod f %)) rr))]\n   (first (filter cm (iterate (partial + ff) ff)))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn [& x]\n   (let [y0 (apply min x)]\n     (first\n       (drop-while\n         (fn [ys]\n           (not-every? true?\n                       (map (fn [xs] (= (rem ys xs) 0)) x)))\n         (iterate #(+ % y0) y0)))))","problem":100,"user":"4f616892e4b0defedf855fbf"},{"code":"(fn [& s]\n  (loop [nums s]\n    (if (apply = nums) (first nums)\n      (let [m (apply min nums)\n            i (.indexOf nums (apply min nums))]\n        (recur\n          (concat (take i nums) (list (+ m (nth s i))) (drop (inc i) nums)))))))","problem":100,"user":"4f47eab2e4b0d56e7bb92bc6"},{"code":"(fn [& nums]\n  (let [max-num (apply max nums)\n        factor? (fn [dividend divisor]\n                  (= (mod dividend divisor) 0))\n        all-factors? (fn [dividend divisors]\n                        (not (some #(not (factor? dividend %))\n                          divisors)))]\n    (some #(when (all-factors? %1 nums) %1)\n      (map #(* max-num %) (iterate inc 1)))))","problem":100,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":100,"code":"(fn [& input]\n  (letfn [(equals? [args]\n                   (apply = args))\n          (get-min-index [args]\n                         (first (apply min-key second (map-indexed vector args))))\n          (next-round [output]\n\t\t\t\t\t  (let [index (get-min-index output)]\n    \t\t\t\t\t(assoc output index (+ (nth output index) (nth input index)))))]\n    (first (first (take 1 (filter equals? (iterate next-round (apply vector input))))))))","user":"56877fcbe4b0dcc4269f405e"},{"code":"(fn [& xs]\n  (loop [ns xs]\n    (if (apply = ns)\n      (first ns)\n      (let [m (apply max ns)]\n        (recur (map #(if (= m %1) %1 (+ %1 %2)) ns xs))))))","problem":100,"user":"53468f6ce4b084c2834f4a3f"},{"code":"(fn [& args]\n  (let [gcd (fn g [a b] (if (= a b) a (if (> a b) (g (- a b) b) (g a (- b a)))))]\n    (/ (reduce * args) (reduce (fn [a b] (gcd a b)) (first args) (rest args)))))","problem":100,"user":"53638ed2e4b0243289761e5b"},{"problem":100,"code":"(fn lcm [& ns]\n  (let [ms (map #(map (partial * %) (rest (range))) ns)]\n    (loop [a (first ms)]\n      (if (every? identity\n                 (map #(loop [b %]\n                         (if (< (first a) (first b))\n                           false\n                           (if (= (first a) (first b))\n                             true\n                             (recur (rest b))))) \n                      (rest ms)))\n        (first a)\n        (recur (rest a))))))","user":"57533bc1e4b02ea1147992a6"},{"problem":100,"code":"(fn lcm [x y & more]\n  (let [gcd (fn gcd [x y]\n                 (let [remainder (mod x y)]\n                   (if (zero? remainder)\n                     y\n                     (gcd y remainder))))\n           l (/ (* x y)\n                  (gcd x y))]\n    (if (seq more)\n      (recur l (first more) (rest more))\n      l)))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn [& args]\n  (letfn [(gcd [a b]\n      (if (= 0 b)\n          a\n          (gcd b (rem a b))\n      )\n  )\n  (lcm [a b] (/ (* a b) (gcd a b)))\n  ]\n (reduce lcm args)\n )\n)","problem":100,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":100,"code":"(fn [& numbers]\n  (first\n   (apply clojure.set/intersection\n          (reduce (fn [x y] (conj x\n                                  (apply sorted-set (take 1000 (iterate #(+ y %) y)))))\n                    '() numbers))))","user":"609e9b64e4b00e9e6653c426"},{"problem":100,"code":"(fn LCM\n  [& args]\n  (let [gcd (fn [a b] (loop [a a\n                             b b]\n                        (if (zero? b)\n                          a\n                          (recur b\n                                 (rem a b)))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5c7dad57e4b0d597f478caba"},{"problem":100,"code":"(fn [& x]\n  (let [gcd (fn [a b]\n              (let [remainder (rem a b)]\n                (if (zero? remainder)\n                  b\n                  (recur b remainder))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm x)))","user":"51a7fe50e4b08d8ec191b803"},{"problem":100,"code":"(fn [& x] \n  (first (first \n   (drop-while empty?\n               (map (fn [y] (reduce #(filter (set %) %2)\n                                    (map (fn [z] (map #(* z %) (range 2 y))) x)))\n                    (drop 2 (range)))))))","user":"539f4e9ee4b0ca733b974498"},{"problem":100,"code":"(fn [& args]\n  (let [euclid (fn euclid [a b]\n                  (let [[aMax aMin] (if (> b a) [b a][a b])]\n                    (if (zero? (mod aMax aMin))\n                      aMin\n                      (euclid (- aMax aMin) aMin))))\n        lcm #(/ (* %1 %2) (euclid %1 %2))] \n    (reduce lcm args)))","user":"5773f3a9e4b0979f896515f2"},{"problem":100,"code":"(fn [a & args]\n    (let [gcd (fn [m n] \n                (cond   (< m n)   (recur n m)\n                        (zero? n) m\n                        :else     (recur n (mod m n)))) ]\n        (reduce (fn [acc x] (/ (* acc x) (gcd acc x))) a args)))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":100,"code":"(fn problem-100 \n    ([a b]\n      (letfn [(gcm [a b]\n                (cond\n                  (< a b) (recur b a)\n                  (zero? b) a\n                  :else (recur b (mod a b)))\n                )]\n        (/ (* a b) (gcm a b))))\n    ([a b & r]\n      (apply problem-100 (problem-100 a b) r)))","user":"569f4dabe4b0542e1f8d1491"},{"code":"(fn [& x]\n  (reduce (fn [a b] \n     (/ (* a b)\n        ((fn gcd [a b] (if (zero? b) a (gcd b (rem a b)))) a b)\n      )\n      ) x\n  )\n)","problem":100,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":100,"code":"(fn lcd\n    [& rest]\n    (let [gcd (fn [a b]\n                (if (= a b)\n                  a\n                  (recur (min a b) (- (max a b) (min a b)))))]\n      (reduce #(/ (* % %2) (gcd % %2)) rest)))","user":"53a511aae4b0b62ce3005735"},{"code":"(fn [& x] (reduce (fn [a b]\n (* (/ b \n      (loop [a a b b] (if (= 0 b) a (recur b (mod a b))))\n    ) a)) x))","problem":100,"user":"4e7e55ab535db169f9c79711"},{"problem":100,"code":"(letfn [(gcd2 [a b] \n             (cond (= a b) a\n                   (< a b) (gcd2 b a)\n                   :else   (gcd2 (- a b) b)))\n        (gcd [coll] (reduce gcd2 coll))\n        (lcm [& coll] (/ (apply * coll) (gcd coll)))]\n  lcm)","user":"560bb1f7e4b05f002753df20"},{"code":"(fn [& xs]\n  (let [gcd (fn c [a b] (if (= 0 b) a (c b (rem a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) (first xs) (rest xs))))","problem":100,"user":"508e13abe4b0f17d83ea26c7"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n                 (cond\n                  (= a b) a\n                  (> a b) (recur (- a b) b)\n                  (< a b) (recur a (- b a))))]\n               (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"51441ce7e4b0b4fb4ace5f41"},{"problem":100,"code":"(fn lcm [& s]\n  (letfn [(gcd [a b]\n            (if (= b 0) a\n                        (recur b (mod a b))))]\n    (if (= 2 (count s))\n      (let [[a b] s]\n        (/ (* a b) (gcd a b)))\n      (lcm (first s) (apply lcm (rest s))))))","user":"57650419e4b0994c1922fc09"},{"problem":100,"code":"(fn [x y & args]\n  (loop [X_0 (vec (cons x (cons y args)))\n         X_m X_0]\n    (if (apply = X_m)\n      (first X_m)\n      (recur X_0\n             (let [i (first (reduce-kv (fn [[i0 v0] i v]\n                                  (if (< v0 v)\n                                    (list i0 v0)\n                                    (list i v)))\n                                (list 0 (first X_m))\n                                X_m))]\n               (assoc X_m i (+ (X_m i) (X_0 i))))))))","user":"570459a9e4b0b0fb43fd0662"},{"code":"(fn [& numbers]\r\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\r\n    (/\r\n      (apply * numbers)\r\n      (reduce gcd numbers))))","problem":100,"user":"4dab218f30acd6ed15482a68"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd\n        (fn [& nums]\n          (let [[big lil] (sort > nums)]\n            (loop [a big\n                   b lil]\n              (let [q (quot a b)\n                    r (rem a b)]\n                (if (zero? r)\n                  b\n                  (recur b r))))))\n        g (reduce gcd nums)\n        product (apply * nums)]\n    (/ product g)))","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [& a]  \n  (/ (apply * a)\n     (reduce (fn f [x y] (if (= y 0) x (f y (mod x y)))) a)))","problem":100,"user":"4e1350af535d04ed9115e7d8"},{"problem":100,"code":"(letfn\n  [(gcd [x y] (let [[x y] [(min x y) (max x y)]] (if (= 0 x) y (gcd (mod y x) x))))\n   (lcm [x y] (let [z (gcd x y)] (/ (* x y) z)))]\n  (fn [& xs] (reduce lcm xs)))","user":"553e0b70e4b0a04f792994e8"},{"problem":100,"code":"(fn [a & b]\n  (loop [l (map (fn [x] (* a (inc x))) (range)) m b]\n    (if (zero? (count m))\n      (first l)\n      (recur (filter (fn [x] (zero? (mod x (first m)))) l) (rest m)))))","user":"5739cbe4e4b0cd1946bd107c"},{"code":"(fn least-multiple [& nums]\n  (letfn [(gcd [x y] ;gcd will be an inner function\n            (let [maximum (max x y) ;maximum will be the max of two parameters\n                  minimum (min x y) ;minimum will be the min of two parameters\n                  modd (mod maximum minimum)] ;modd will be the remainder of the two numbers\n              (if (zero? modd) ;if maximum is divisible by minimum\n                minimum ;give minimum\n                (recur minimum modd)))) ;else, recur with the minimum and the modd\n          (lcm [maximum minimum] ;lcm will be an inner function\n            (/ (* maximum minimum) (gcd maximum minimum)))] ;multiply the maximum and the minimum and do gcd of the maximum and minimum\n     \t\t\t\t\t\t\t\t\t\t\t\t\t\t;then divide them\n    (reduce lcm nums))) ;now, reduce the nums using lcm (and gcd)","problem":100,"user":"53713ebee4b0fc7073fd6ead"},{"code":"(fn [& xs]\n    (let [args (apply vector xs)]\n        (loop [nums args]\n            (if (every? #(== % (first nums)) nums)\n                (first nums)\n                (let [idx (apply min-key nums (range (count nums)))]\n                    (recur (assoc nums idx (+ (nums idx) (args idx)))))))))","problem":100,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":100,"code":"(fn\n  [& nums]\n  (let\n      [gdc-func (fn [x y]\n  (if (zero? y)\n    x\n    (recur y (mod x y))))]\n\n    (/ (reduce * nums) (reduce gdc-func nums))\n    )\n  )","user":"6059d824e4b07e92fa001acf"},{"code":"(fn [& l] ({[2 3] 6 [5 3 7] 105 [1/3 2/5] 2 [3/4 1/6] 3/2 [7 5/7 2 3/5] 210} l))","problem":100,"user":"4e9d6a65535dbda64a6f6b87"},{"problem":100,"code":"(fn [& n]\n (letfn [(gcd [a b]\n          (if (> b 0)\n           (gcd b (mod a b))\n           a))]\n        (reduce #(/ (* % %2) (gcd % %2)) n)))","user":"5b22328ee4b03cfeda66ed5d"},{"code":"(fn [& s]\n  (let [gcd \n      (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        abs\n      (fn [n] (if (neg? n) (- n) n))]\n    (reduce (fn [m n] \n      (cond \n        (or (zero? m) (zero? n)) 0\n        :else (abs (/ (* m n) (gcd m n))))) s)))","problem":100,"user":"4ef4c1ff535dced4c769f23e"},{"code":"(fn [ & l]\n           (loop [multiples (map (fn [x] (iterate (partial + x) x)) l)]\n             (let [maxmin (apply max (map first multiples))]\n               (if (apply = (map first multiples))\n                 maxmin\n                 (recur (map (partial filter (partial <= maxmin)) multiples))))))","problem":100,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [& s]\n  (reduce\n\t\t(fn [x y] (let [gcd (fn [x y] (loop [x x y y] (let [q (quot x y) r (rem x y)] (if (zero? r) y (recur y r)))))]\n\t\t\t(/ (* x y) (gcd x y))))\n\t\ts))","problem":100,"user":"4f1abbfb535d64f60314646e"},{"problem":100,"code":"(fn [& args]\n  (reduce\n   (fn lcm [a b]\n     (/ (* a b) ((fn gcd [x y] \n\t\t\t\t   (cond\n\t\t\t\t    (zero? y) x\n                    :else (gcd y (mod x y))))\n\t\t\t\ta b))) args))","user":"5694129de4b0dcc4269f410c"},{"problem":100,"code":"(fn [& xs]\n  (/ (apply * xs)\n     (reduce #(if (zero? %2) %1 (recur %2 (mod % %2))) xs)))","user":"4ee897fe535d93acb0a66883"},{"code":"#(letfn\n    [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n     (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm % %&))","problem":100,"user":"506a1985e4b01dc6af13f83e"},{"problem":100,"code":"(fn [& xs]\n   (let [divisible-by-all? #(every? identity\n                                    (for [d xs]\n                                      (= 0 (rem % d))))\n         count-by (apply * (map\n                            #(if (ratio? %) (denominator %) 1) xs))]\n     (first\n      (filter divisible-by-all?\n              (range 1 100000\n                     (/ 1 count-by))))))","user":"51e3a549e4b0c611d6113e47"},{"problem":100,"code":"(fn [& args]\n  (let\n    [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))\n    )\n  )","user":"575d16f8e4b02ea114799377"},{"code":"(fn [& x]\n  (let [m (apply #'max x)]\n    (loop [lcm m]\n      (if (= 0\n             (count\n              (filter\n               (fn [z]\n                 (not\n                  (= 0 (mod lcm z))))\n               x)))\n        lcm\n        (recur\n         (+ lcm m))))))","problem":100,"user":"530d85dee4b08068f379eca8"},{"code":"(fn [& org]\n  (loop [col org]\n    (let [m (reduce #(if (< % %2) % %2) col)]\n      (if (some #(not= m %) col)\n  (recur (map-indexed (fn [i v] (if (= v m) (+ v (nth org i)) v)) col))\n\t(first col)))))","problem":100,"user":"4fd7962ee4b0dab7d829f385"},{"problem":100,"code":"(fn lcm [& nums]\n    (let [orig (into [] nums)\n          nums (into [] nums)\n          find-smallest (fn [nums]\n                          (reduce (fn [[idx small] n]\n                                    (if (> small n)\n                                      [idx n]\n                                      [idx small]))\n                                  [0 (first nums)] (rest nums)))\n          increase-by (fn [nums small]\n                        (into []\n                              (map-indexed (fn [idx n]\n                                             (if (= n small)\n                                               (+ n (orig idx))\n                                               n))\n                                           nums)))\n          step (fn step [nums]\n                 (let [[idx small] (find-smallest nums)]\n                   (if (every? #(= small %) nums)\n                     small\n                     (step (increase-by nums small)))))]\n      (step nums)))","user":"5a5d0726e4b0512ff01cd91b"},{"code":"(fn [& x] (reduce (fn [a b] (/ (* a b) (#(if (= 0 %) %2 (recur (rem %2 %) %)) a b))) x))","problem":100,"user":"52d10680e4b07d0d72b273c3"},{"code":"(fn [ & args ]\n  (letfn\n      [(gcd[a,b]\n         (if (zero? b) a\n             (recur b (mod a b))))\n       (lcm\n         ([a b]      (/ (* a b) (gcd a b)))\n         ([a b & xs] (apply lcm (lcm a b) xs)))]\n    (apply lcm args)))","problem":100,"user":"50fa01bce4b07934dda8b0ba"},{"problem":100,"code":"(fn [& args] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))] (/ (reduce * args) (reduce gcd args))))","user":"55cae949e4b0e31453f649fe"},{"problem":100,"code":"(fn [first-factor & other-factors]\n  (let [multiples (map (partial * first-factor) (rest (range)))]\n    (first\n      (filter\n        #(every? (fn [factor] (zero? (mod % factor))) other-factors)\n        multiples))))","user":"5784ff88e4b0ebec4cfb74d4"},{"code":"(fn run [& more]\n  (letfn [(f [a b]\n            (if (= 0  (rem a b)) b\n             (recur b (rem a b)))\n            )]\n    (reduce #(let [product (* %1 %2)] (if (< %1 %2) (/ product  (f %2 %1)) (/ product (f %1 %2))) ) more)\n    )\n)","problem":100,"user":"5302ac7fe4b0d8b024fd3731"},{"code":"(fn f\n   ([x y]\n      (let [r (/ x y)\n            num (if (ratio? r) (numerator r) r)]\n        (/ (* x y) (/ x num))))\n   ([x y z] (f x (f y z)))\n   ([x y z d] (f x (f y (f z d)))))","problem":100,"user":"506c0a02e4b0eda3100c090d"},{"code":"(fn lcm [& ns]\n  (let [maxn    (apply max ns)\n        multiples (map #(* % maxn) (range))\n        testlcm (fn [l] (and (> l 0) (every? #(zero? (mod l %)) ns)))]\n    (first (filter testlcm multiples))))","problem":100,"user":"4f0d093b535d0136e6c22313"},{"problem":100,"code":"(fn [& s]\n    (loop [mi (apply min s)\n            ma (apply max s)\n            s_ s]\n        (if (= mi ma)\n            (first s_)\n            (recur \n                (apply min s_) \n                (apply max s_) \n                (map \n                    #(if (= %1 mi)\n                        (+ %1 %2)\n                        %1)\n                    s_ s)))))","user":"55975569e4b031d6649c9b8e"},{"problem":100,"code":"(fn [& z] (\nreduce (fn [x y] \n         (/ (* x y) \n            (\n              (fn peu [u v] \n               (cond \n                  (> v u) (peu v u) \n                  (= 0 v) u \n                  (> v 0) (peu (- u v) v)\n                )                  \n              ) x y\n            )\n         )\n       ) \n       (vec z)\n))","user":"53fc8424e4b0de5c418485b3"},{"code":"#(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (rem a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm %&))","problem":100,"user":"51e38568e4b0c611d6113e43"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(gcd [x y]\n            (if (= 0 (rem x y))\n              y\n              (recur y (rem x y))))]\n    (reduce #(/ (* % %2) (gcd % %2)) nums)))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn lcm [& x]\r\n  (loop [s x]\r\n    (if (= 1 (count (set s)))\r\n      (first s)\r\n      (recur (map-indexed #(if (= %2 (apply min s)) (+ %2 (nth x %1)) %2) s)))))","problem":100,"user":"4dae916eedd6309eace4d155"},{"problem":100,"code":"(fn [& args]\n\n  (loop [\n         start (first (sort args) )\n         ]\n\n    (if (every? #(= 0 (mod start %)) args)\n      start\n      (recur (+ start (first (sort args) ) )   )\n      )\n\n    )\n\n  )","user":"53b0750fe4b047364c044483"},{"problem":100,"code":"(letfn [(euclid-gcd [a b]\n  (if (zero? (min a b))\n    (max a b)\n    (recur (min a b) (- (max a b) (min a b)))))]\n\n(fn q4q100 [& args]\n  (reduce\n   #(/ (* %1 %2) (euclid-gcd %1 %2))\n   args)))","user":"52213426e4b0e6a83c8925c4"},{"code":"(fn [& s] (letfn [(f1 [x y] (let [m (mod y x)] (if (zero? m) x (f1 m x))))\n                  (f2 [x y] (/ (* x y) (f1 x y)))\n                  (den [x] (if (ratio? x) (denominator x) 1))\n                  (f3 [x y] (let [dx (den x) dy (den y) dxy (* dx dy)] (/ (f2 (* x dxy) (* y dxy)) dxy)))] \n            (reduce f3 (sort s))))","problem":100,"user":"523b1988e4b02f719975bdbc"},{"problem":100,"code":"(fn lcd\n   ([a b] (let [gcd (fn [a b]\n                      (if (zero? b)\n                        a\n                        (recur b (mod a b))))]\n            (/ (* a b) (gcd a b))))\n   ([a b & rest] (apply lcd (lcd a b) rest)))","user":"59ac0965e4b08cbb53654da6"},{"code":"#(reduce (fn [x y] (loop [a x b y]\n  (cond (= a b) a\n        (< a b) (recur (+ a x) b)\n        0 (recur a (+ b y)))))\n  % %&)","problem":100,"user":"5088082ae4b0198722bd9854"},{"problem":100,"code":"; Using Wikipedia \"A simple algorithm\"\n;  (fn [& base]\n;    (loop [curr base]\n;      (if (apply == curr)\n;          (first curr)\n;          (let [least (apply min curr)]\n;            (recur (map #(if (= least %1) (+ %1 %2) %1) curr base))))))\n\n; Using |a*b*...*z| / gcd(a*b*...*z)\n(fn [& xs] (/ (reduce * xs) (reduce #(if (zero? %1) %2 (recur (mod %2 %1) %1)) xs)))","user":"5a544eeee4b05d388ecb6c24"},{"code":"(fn [& args]\n  (let [biggest (apply max args)\n        factor? (fn [factor args']\n                  (every? #(zero? (mod factor %)) args'))]\n    (first (drop-while #(not (factor? % args)) (iterate #(+ % biggest) biggest)))))","problem":100,"user":"51195e77e4b055cfb310d499"},{"problem":100,"code":"(fn\n  [& args]\n  (let [a (for [x args] (map #(* x %) (range 1 500)))\n        b (for [x a] (set x))\n        c (apply clojure.set/intersection b)]\n    (apply min c)))","user":"5aa098fae4b0d174b936c82e"},{"code":"(fn [& a] (->> (map #(map (partial * %) (range 1 999)) a) flatten sort (partition-by identity) (filter #(= (count a) (count %))) ffirst))","problem":100,"user":"4dad8fe9c9a9d6ed1899dc57"},{"code":"(fn lcm [& args]\r\n    (let [nums (vec args)]\r\n      (loop [xs nums]\r\n        (if (apply = xs)\r\n          (first xs)\r\n          (let [[_ smallest-i] (first (sort (keep-indexed #(vector %2 %1) xs)))]\r\n            (recur (assoc xs smallest-i (+ (xs smallest-i) (nums smallest-i)))))))))","problem":100,"user":"4f149e0f535d64f60314643d"},{"code":"(fn lcm [a & bs]\n  (letfn [\n    (multiples [n]\n      (map (comp (partial * n) inc) (range)))\n\n    (least-common [cmp A B]\n      (loop [P A, Q B]\n        (cond\n          (cmp (first P) (first Q)) (recur (rest P) Q)\n          (cmp (first Q) (first P)) (recur P (rest Q))\n          :else (first P))))]\n    \n    (reduce #(least-common < (multiples %1) \n        (multiples %2)) a bs)))","problem":100,"user":"4faa9593e4b081705acca1f9"},{"problem":100,"code":"(fn [& nums]\n  (let [big (apply max nums)]\n    (loop [mul big]\n      (if (every? #(= 0 (rem mul %)) nums)\n        mul\n        (recur (+ mul big))))))","user":"5ab5f60be4b073f177442643"},{"problem":100,"code":"(fn [& lst] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * lst) (reduce gcd lst))))","user":"5a99b766e4b0d174b936c7a8"},{"code":"(fn [& in] (letfn [(gcd [a b] (cond (< a b) (recur b a) (zero? b) a :else (recur b (rem a b)))) (lcm [a b] (/ (* a b) (gcd a b)))] (reduce lcm in)))","problem":100,"user":"5134973ce4b0230e9f713b42"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (letfn [(gcd [a b]\n                (if (= b 0)\n                  a\n                  (gcd b (rem a b))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & res]\n   (reduce lcm (lcm x y) res)))","user":"55af3e6be4b03311e7b732c7"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd #(if (= 0 %2) %1 (recur %2 (rem %1 %2)))]\n    (/ (apply * args) (reduce gcd args))))","user":"559454f2e4b0c79f6e1db952"},{"problem":100,"code":"(fn [& nums]\n  (let [prod (apply * (map #(if (ratio? %) (numerator %)\n                                           %) nums))]\n    (apply min\n      (apply clojure.set/intersection\n        (map #(set (range %1 (inc prod) %1)) nums)\n        ))\n    ))","user":"53f6bfd9e4b0db01ade6f9e4"},{"code":"(fn [f & r]\n  (let [GCD (fn f [x y] (if (= y 0) x (f y (mod x y))))\n        LCM (fn [x y] (/ (* x y) (GCD x y)))]\n    (reduce LCM f r)))","problem":100,"user":"505dcfc8e4b0e6aca564be0d"},{"code":"(fn [& nums]\n  (letfn [\n          (gcd [x y] (if (zero? y) x (recur y (mod x y))))\n          (lcm [x y] (/ (* x y) (gcd x y)))\n         ]\n    (reduce lcm nums)))","problem":100,"user":"505345d9e4b0517ede0d0a06"},{"problem":100,"code":"(fn ppcm\n  ([a] a)\n  ([a b]  \n \t(loop [c a d b]\n      (cond \n         (> c d) (recur c (+ b d))\n         (< c d) (recur (+ a c) d)\n         :else c)))\n  ([a b & r] (ppcm (ppcm a b) (apply ppcm r)))\n)","user":"5603c31fe4b04bb52996e1c1"},{"problem":100,"code":"(fn [& xs]\n   (let [gcd\n         (fn gcd [x1 x2]\n           (if (= 0 x2) x1\n             (gcd x2 (mod x1 x2))))]\n     (/ (reduce * xs) (reduce gcd xs))))","user":"58db3c5ae4b0a4d5acaab677"},{"code":"(fn my-lcm\n  ([] nil)\n  ([a] a)\n  ([a b & args]\n     (apply my-lcm (cons (/ (* a b)\n                            (loop [a a\n                                   b b]\n                              (if (zero? b)\n                                a\n                                (recur b (mod a b))))) args))))","problem":100,"user":"5310e7aee4b08068f379ecdc"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (loop [accum (into [] (map (fn [x] [x x]) args))]\n    (if (apply == (map first accum))\n        (first (first accum))\n        (recur (let [[h & t] (sort accum)]\n                    (conj t [(+ (first h) (second h)) (second h)]))))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [& s] (reduce (fn [a b] (/ (* a b) \n                             ((fn gcd [x y] \n                                (if (= x y) x \n                                  (if (< x y) (gcd x (- y x)) (gcd (- x y) y)))) a b))) s))","problem":100,"user":"536f2faee4b0fc7073fd6e79"},{"code":"(fn\n  [& v]\n  (loop [o v n v]\n    (if (apply = n)\n      (first n)\n      (recur o\n             (map #(if (= %1 (apply min n))\n                     (+ %1 %2)\n                     %1)\n                  n o)))))","problem":100,"user":"4f73f78de4b044e54cd9a8f3"},{"code":"(fn [& args]\r\n   (letfn [(gcd\r\n             ([one two]\r\n                (if (= two 0)\r\n                  one\r\n                  (gcd two (mod one two)))))\r\n           (lcm [a b]\r\n             (/ (* a b) (gcd a b)))]\r\n     (reduce #(lcm %1 %2)\r\n             (first args) (rest args))\r\n     ))","problem":100,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn [x & xs]\n  (let [is-multiple? (comp zero? rem)\n        is-common-multiple? #(every? true? (map is-multiple? (repeat %) xs))]\n    (loop [n x]\n      (if (is-common-multiple? n)\n        n\n        (recur (+ n x))))))","problem":100,"user":"50fc299ee4b0d10d794c19f2"},{"problem":100,"code":"(fn [& nums]\n  (let [max-num (apply max nums)\n      max-num-seq (iterate (partial + max-num) max-num)\n      lcm? (fn [mul] (not-every? #(zero? (rem mul %)) nums))]\n  (first (drop-while lcm? max-num-seq))))","user":"5d28d935e4b092dab7f59c88"},{"problem":100,"code":"(fn\n  [& xs]\n  (loop [l (map #(list % %) xs)]\n    (if (apply = (map first l))\n      (first (first l))\n      (recur (let [min-val (apply min (map first l))]\n               (map #(if (= (first %) min-val)\n                      (list (+ (first %) (second %)) (second %))\n                      %)\n                    l))))))","user":"56bb652ae4b0f26550335953"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"54ab6773e4b09f271ff37cc8"},{"code":"(fn [ & n ]\n  (let [ m (fn [a] (map #(* a %) (rest (range))))\n        cm (fn cm ([a] a)\n                  ([a b] (for [a a \n                               b b \n                               :while (<= b a)\n                               :when  (= a b)] a))\n                 ([a b & r] (apply cm (cm a b) r)))]\n        (first (apply cm (map m n)))))","problem":100,"user":"4e6dc95a535d5021c1a895f1"},{"code":"#(/ (apply * %&)\n    (reduce (fn f [a b]\n              (if (= b 0)\n                a\n                (f b (rem a b))))\n            %&))","problem":100,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [gcd-2 (fn [a b] (if (= 0 b) a (recur b (rem a b))))\n        lcm-2 (fn [a b] (* (/ a (gcd-2 a b)) b))]\n    (reduce lcm-2 xs)))","user":"4fbe2cfbe4b081705acca30c"},{"problem":100,"code":"(fn [x & xs]\n  (first\n    (filter\n      (fn [a] (every? #(= 0 (mod a %)) xs))\n      (iterate #(+ x %) x))))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":100,"code":"(fn lcm [& v]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) v)))","user":"572ea970e4b0cd1946bd0f89"},{"problem":100,"code":"(fn [& values]\n  (letfn\n    [(gcd [x y] (cond (= y 0) x :else (recur y (mod x y))))\n     (lcm [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm values))\n  )","user":"60752ef6e4b069485764de55"},{"problem":100,"code":"(fn [& numbers]\n  (let [gcd (fn gcd# [a b]\n              (cond\n                (= a b) a\n                (> a b) (gcd# (- a b) b)\n                (< a b) (gcd# a (- b a))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) (first numbers) numbers)))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":100,"code":"(fn\n  lcm\n\n  ([a] a)\n\n  ([a b]\n    (letfn\n      [\n        (abs[n] (if (neg? n) (- n) n))\n\n        (gcd[a b] (->\n          (compare a b)\n          (case ,,,\n            -1 (recur a (- b a))\n            0 a\n            +1 (recur (- a b) b))\n        ))\n      ]\n      (/ (abs (* a b)) (gcd a b))))\n\n  ([a b & more] (reduce lcm (lcm a b) more)))","user":"5c6227fee4b0fca0c1622641"},{"problem":100,"code":"(fn\n  [& args] \n  (reduce \n   #(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))] \n      (/ (* % %2) (gcd % %2))) args))","user":"54eee38ce4b024c67c0cf878"},{"code":"(fn [& args]\r\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\r\n          (lcm [a b] (/ (* a b) (gcd a b)))]\r\n    (reduce lcm args)))","problem":100,"user":"4ee40938535d10e5ff6f5375"},{"code":"(fn [& numbers] \n  (loop [items (map (fn [n] [n n]) numbers)] \n    (if (reduce #(when (= %1 %2) %2) (map first items)) \n      (ffirst items) \n      (let [sorted-items (sort-by first items)\n            [least-val least-orig] (first sorted-items) \n      \t\t inc-items (cons [(+ least-val least-orig) least-orig] (rest sorted-items))]\n        (recur inc-items)))))","problem":100,"user":"523b4e91e4b07becd5be21ef"},{"problem":100,"code":"(fn solution [& args]\n  (loop [values args\n         step 1]\n    (let [least (apply min values)]\n      (if (apply = values)\n        (first values)\n        (recur (map #(if (= least %2) (+ %2 %1) %2) args values) (inc step))))))","user":"5e2ef900e4b05b4b015161fc"},{"problem":100,"code":"(fn lcm2\n  [& xs]\n  (let [data (zipmap xs (map #(set [%]) xs))]\n    (loop [c 1 h data]\n      (if-not (empty? (apply clojure.set/intersection (vals h)))\n        (first (apply clojure.set/intersection (vals h)))\n        (recur (inc c) (reduce (fn [a [k v]] (conj a [k (conj v (* k c))])) {} h))))))","user":"5c2836ebe4b07e362c2305d4"},{"code":"(fn lcm [x y & z]\n  (if (not (nil? (first z)))\n    (cond (nil? (second z)) (lcm x (lcm y (first z)))\n          :else (lcm x (lcm y (lcm (first z) (last z)))))\n    (/ (* x y) ((fn gcd [x y]\n                  (if (zero? y)\n                    x\n                   (gcd y (mod x y))))\n                x y))))","problem":100,"user":"4ead2841535d7eef3080731e"},{"code":"(fn [& x]\n  (reduce \n    (fn lcm [x y]\n      (/ \n        (* x y) \n        ((fn gcd [x y]\n           (loop [a x b y]\n             (if (> b a) \n               (recur b a)\n               (if (= (mod a b) 0)\n                 b\n                 (recur b (mod a b))))))\n        x y)\n   ))\nx))","problem":100,"user":"513b77f3e4b00f740c76c403"},{"problem":100,"code":"(fn least-common-multiple [& nums]\n  (let [multiple-of-all? (fn [n factors]\n                           (every? #(zero? (rem n %)) factors))\n        ns (sort > nums)\n        mx (first ns)]\n    (first (filter #(multiple-of-all? % ns) (iterate #(+ mx %) mx)))))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":100,"code":"(fn [x & args]\n  (letfn [(gzd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * x args) (reduce gzd x args))))","user":"5447e08ce4b032a45b8693c3"},{"problem":100,"code":"(fn\n  [& nums]\n  (let\n    [m (apply max nums)]\n    (first (filter (fn [km] (every? #(= 0 (rem km %)) nums)) (iterate #(+ m %) m)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [& a]\n  (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (/ (apply * a) (reduce gcd a))))","problem":100,"user":"504e71cbe4b0f6ff3350c4b3"},{"code":"(fn [& x]\n   (apply min (apply clojure.set/intersection\n                     (map #(into #{} (range % (* % 1000) %) ) x)))\n   )","problem":100,"user":"50cf2267e4b0e61f11ddcd8c"},{"problem":100,"code":"(fn [& args]\n    (let [gcd #(loop [a %1 b %2] (if (zero? b) a (recur b (mod a b))))\n          ;; The Wikipedia page linked to clearly states it's defining least common multiple only in terms\n          ;; of integers.  I don't see how least common multiple makes sense when dealing with ratios.\n          ;; However, this formula gives the \"right\" answer according to the specification in the question.\n          lcm #(* %1 (/ %2 (gcd %1 %2)))]\n      (reduce lcm args)))","user":"5531e445e4b09218d5f44f76"},{"code":"#(let [] (case (first %&)\n2 6\n5 105\n1/3 2\n3/4 3/2\n7 210))","problem":100,"user":"50807940e4b01a93d3f38e44"},{"problem":100,"code":"(fn lcm\n  [& numbers]\n  (letfn [(gcd [x y] (if (zero? y)\n                       x\n                       (recur y (mod x y))))]\n    (reduce (fn [x y] (/ (* x y) (gcd x y))) numbers)))","user":"5f3103aee4b0574c87022c24"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n))","user":"5075e374e4b09049dea827a5"},{"problem":100,"code":"(fn \n  [& args] \n  (let [gcd (fn \n              [a b] \n              (cond\n               (zero? b) a\n               :else\n               (recur b\n                      (mod a b)\n                      )\n               ))]\n    (/ (reduce * args) (reduce gcd args))\n    )\n  )","user":"5bbbce99e4b0a20761a23610"},{"problem":100,"code":"(fn [& nums]\n    (let [multiples (filter\n                     (fn [num]\n                      (let [multiple (* num (first nums))]\n                        (cond\n                          (some #(< multiple %) nums) false\n                          (some #(ratio? (/ multiple %)) nums) false\n                          :else true)))\n                     (range))]\n      (* (first nums) (first multiples))))","user":"58bbcbc8e4b0888cdc949d00"},{"problem":100,"code":"(fn [a & r]\n  (* a (first (filter (fn [i] (every? #(= 0 (mod (* i a) %)) r)) (iterate inc 1)))))","user":"539c88e1e4b0b51d73faaf2c"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b]\n              (->> [a b]\n                   (iterate (fn [[x y]] [y (rem x y)]))\n                   (map last)\n                   (take-while pos?)\n                   last))]\n    (reduce #(/ (* %1 %2) (gcd (max %1 %2) (min %1 %2))) args)))","user":"554b8572e4b0a04f79299589"},{"problem":100,"code":"(fn [& args]\n  (let [m  (apply max args)\n        xs (filter #(not= m %) args)]\n    (loop [n 1]\n      (if (every? #(zero? (mod (* n m) %)) xs)\n        (* n m)\n        (recur (inc n))))))","user":"576a972ce4b0a07e8fc1811a"},{"problem":100,"code":"(fn [& xs]\n    (let [m (atom {})\n          madd (fn [x y] (if (contains? @m x)\n                           (swap! m #(conj % [x (conj (get % x) y)]))\n                           (swap! m #(conj % [x #{y}]))))\n          add-mults (fn [base n]\n                      (doseq [x (map #(vector % (* base %)) (range n))] \n                        (madd (second x)\n                              (list (first x)\n                                    base))))]\n\n      (doseq [x xs]\n        (add-mults x 1000))\n      (first (sort (for [[k v] @m :when (and (not= 0 k)\n                                             (<= (count xs) (count v)))]\n                     k)))))","user":"50981062e4b04e098a4c7268"},{"code":"(fn [& as]\n  (let [ps (map #(if (ratio? %)\n                   [(numerator %) (denominator %)]\n                   [% 1]) as)\n        us (map first ps)\n        ds (map second ps)\n        gcd #(let [l (max % %2) s (min % %2) m (mod l s)]\n               (if (zero? m) s (recur s m)))]\n    (/ (reduce * us) (reduce gcd us) (reduce gcd ds))))","problem":100,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn l [& m]\n(let [g #(if (= %2 0) %1 (recur %2 (mod %1 %2)))]\n    (reduce #(* (/ %1 (g %1 %2)) %2) m)))","problem":100,"user":"4ff4c9dae4b0678c553fc360"},{"code":"(fn lcm [& x]\n  (apply reduce #(/ (* %1 %2 ) ((fn gcd [u v]\n  (if (zero? v) u (gcd v (mod u v)))) %1 %2)) [x] ) )","problem":100,"user":"4f03bf5e535dcb61093f6b5d"},{"problem":100,"code":"(fn lcm \n  ([x y & rst] (apply lcm (lcm x y) rst))\n  ([x y]\n   (let [gcd      (fn gcd [n m] (let [x (max n m) y (min n m) md (mod x y)]\n                                  (if (= 0 md) y (gcd m md))))\n         lcm-int  (fn [n m] (/ (* n m) (gcd n m)))\n         lcm-univ (fn [a b c d] (/ (lcm-int a c) (gcd b d)))\n         get-nd   (fn [x] (if (= (type 1/2) (type x))\n                            (list (numerator x) (denominator x))\n                            (list x 1)))\n         [a b]    (get-nd x)\n         [c d]    (get-nd y)]\n      (lcm-univ a b c d))))","user":"575ddfd1e4b02ea11479938d"},{"problem":100,"code":"(fn [& args]\n  (loop [it (vec args)]\n    (if (apply = it)\n      (first it)\n      (let [i (->> it (apply min) (.indexOf it))]\n        (recur (update-in it [i] + (nth args i)))))))","user":"4e0e0529535d04ed9115e7b9"},{"problem":100,"code":"(fn lcm [& n] \n  (let [gcd (fn mcd [x y] \n              (if (= x y)\n                x\n                (if (> x y)\n                  (mcd (- x y) y)\n                  (mcd x (- y x)))))]\n    (/ (reduce * n) (reduce gcd n))))","user":"59e55cc8e4b08badc2a0c555"},{"problem":100,"code":"(fn lcm [a b & bs]\n  (let [gcd (fn [a b]\n              (let [less (min a b)\n                    more (max a b)\n                    rem (mod more less)]\n                (if (= rem 0)\n                  less\n                  (recur less rem))))\n        lcm0 (/ (* a b) (gcd a b))]\n    (if (nil? bs)\n      lcm0\n      (apply lcm (cons lcm0 bs)))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":100,"code":"(fn [& v]\n    (let [max (/ (apply * (map #(if (ratio? %) (* (numerator %) (denominator %)) %) v)) (apply * (map #(if (ratio? %) (denominator %) 1)    v)))]\n      (apply min (apply clojure.set/intersection (map #(set (take (/ max %) (iterate (partial + %) %))) v)))\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn [& args]\n                  (loop [m (reduce min args) current (reduce min args) vals args]\n                    (if (every? #(= 0 (rem current %)) vals)\n                        current\n                        (recur m (+ current (reduce min [m 1])) vals))))","problem":100,"user":"4daeabf6edd6309eace4d15c"},{"problem":100,"code":"(fn [f & args]\n  (some (fn [n] (when (every? zero? (map #(mod n %) args)) n))\n        (map #(* f (inc %)) (range))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn f [& n]\n    (loop [a (map (fn [s] (iterate #(+ s %) s)) n)]\n      (let [m (apply min (map first a))\n            x (map #(drop-while (fn [e] (<= e m)) %) a)\n            b (map first x)]\n    (if (apply = b) (first b) (recur x)))))","problem":100,"user":"4fa30027e4b081705acca187"},{"code":"(fn lcm [a & b]\n  (let [\n    gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n    lcm2 (fn [a b] (/ (* a b) (gcd a b)))\n    ]\n   (cond\n     (empty? b) a\n     (empty? (rest b)) (lcm2 a (first b))\n    :else (apply (partial lcm (lcm2 a (first b))) (rest b)))))","problem":100,"user":"4f0e995e535d0136e6c22326"},{"code":"; maximental's solution\n(fn [G & n] (reduce #(/ (* % %2) (G % %2)) n))\n(fn g [a b] (if (= b 0) a (g b (rem a b))))\n\n;immo's solution:\n;(fn [& n]\n;  (loop [m (zipmap n n)]\n;    (if (= 1 (count (set (vals m))))\n;      (first (vals m))\n;      (let [min-key (first (reduce (fn [x y] (if (< (val x) (val y)) x y)) m))]\n;        (recur (update-in m [min-key] #(+ % min-key)))))))","problem":100,"user":"4fc6d2c1e4b0ee37620e181b"},{"code":"(fn lcm [a & b] (let [g (fn gcd ([a b]\r\n     (if (= 0 a) b\r\n\t       (gcd (mod b a) a)))\r\n\t   ([a b c] (gcd (gcd a b) c))\r\n\t   ([a b c & more] (gcd (gcd a b) (apply gcd c more)))\r\n\t   )]\r\n(/ (apply * a b) (apply g a b))))","problem":100,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":100,"code":"(fn [& numbers]\n  (let [smallest (apply min numbers)]\n    (loop [result smallest]\n      (if (empty? (filter pos? (map #(rem result %) numbers)))\n        result\n        (recur (+ result smallest))))))","user":"55f5b8d6e4b06e875b46ce8d"},{"problem":100,"code":"(let [gcd (fn gcd [a b]\n             (if (= b 0)\n               a\n               (recur b (- a (* b (quot a b))))))\n       lcm (fn [& all]\n             (reduce\n               #(/ (* %2 %1) (gcd %2 %1))\n               (first all)\n               all))]\n   lcm)","user":"5d887d27e4b0915913b1d3a8"},{"code":"(fn [& args]\n    (letfn [(gcd [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n            (lcm [a b]\n              (/ (* a b) (gcd a b)))]\n      (reduce lcm args)))","problem":100,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"#(/ (apply * %&) (reduce (fn [a b] (if (zero? b) a (recur b (mod a b)))) %&))","problem":100,"user":"4f4f0287e4b03ad3f0c10cd7"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [m n]\n               (loop [bigger (if (> m n ) m n)\n                      lower (if (< m n) m n)]\n                 (let [reminder (mod bigger lower)]\n                   (if (zero? reminder)\n                     lower\n                     (recur (if (> lower reminder) lower reminder) (if (< lower reminder) lower reminder))))))]\n    (loop [num1 (first args)\n           num2 (second args)\n           tail (drop 2 args)]\n      (let [result (/ (* num1 num2) (gcd num1 num2))]\n        (if (empty? tail)\n          result\n          (recur result (first tail) (rest tail)))))))","user":"56a9ea17e4b07966d5a8a07c"},{"code":"(fn [i j & more]\n  (letfn [\n          (gcd [i j]\n            (loop [i i j j]\n              (if (= 0 (rem i j))\n                j\n                (recur j (rem i j)))))\n          (lcm [i j]\n            (/ (* i j) (gcd i j)))]\n    (reduce lcm (lcm i j) more)))","problem":100,"user":"4dc78527535d8a4b2fd7428f"},{"problem":100,"code":"(fn lcm [& lst]\n (loop [divisions ()\n        number (apply min lst)\n        increment (apply min lst)]\n\n   (if (and (every? zero? divisions) (not (empty? divisions)))\n      (- number increment)\n     (recur (if (> number increment)\n              (map #(mod number %) lst)\n              '(1)) (+ number increment) increment))))","user":"59e12c94e4b08badc2a0c509"},{"problem":100,"code":"(fn outer [& x]\n      (reduce\n       #(\n         / \n         (* %1 %2)\n         (loop [a %1 b %2] \n           (if (= 0 b)\n             a \n             (recur b (mod a b))\n             )\n           )\n         ) \n       x\n       )\n      )","user":"536829c8e4b0243289761e8b"},{"problem":100,"code":"(fn [& lst] (reduce\n#(/ (* %1 %2)\n  (\n   (fn [a b] (if (zero? b) a (recur b (mod a b))))\n   %1 %2)\n  ) lst)\n )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":100,"code":"(fn [& args]\n (reduce \n (fn lcm [a b]\n  (/ (#(max % (- %)) (* a b))\n     ((fn gcd [x y]\n       (if (zero? y)\n         x\n         (gcd y (mod x y)))) a b)))\n  args))","user":"532a033be4b09d4e7a9b551f"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y] (if (= y 0) x (gcd y (mod x y))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"55ed37ebe4b0121d4835fdd6"},{"code":"(fn lcm [a & nums]\n  (let [gcd (fn gcd [a b]\n              (cond (= b 0) a\n                    :else (recur b (mod a b))))]\n    (/ (apply * a nums) (reduce gcd a nums))))","problem":100,"user":"4e7f51eb535db966e863cc3f"},{"problem":100,"code":"(fn lcm [& numbers]\n  (loop [factors (repeat (count numbers) 1)]\n    (let [products (map * numbers factors)\n          max-product (apply max products)\n          conditional-factor-inc (fn [n f]\n                                   (if (< (* n f) max-product)\n                                     (inc f)\n                                     f))]\n      (if (apply = products) max-product\n        (recur (map conditional-factor-inc numbers factors))))))","user":"529e3a4fe4b04e0c58e87b92"},{"problem":100,"code":"(fn lcm [& args]\n   (let [m (apply min args), mults (map #(* m (+ % 1)) (range))]\n     (first (filter\n              (fn [mult]\n                (= 0 (apply + (map #(rem mult %) args)))) mults))))","user":"60882700e4b0ae75613dcedf"},{"problem":100,"code":"(fn lcm [a b & more]\n  (let [gcd (fn gcd [a b]\n    (if (= b 0)\n      a\n      (gcd b (mod a b))))]\n    (let [_lcm (/ (* a b) (gcd (max a b) (min a b)))]\n      (if (empty? more)\n        _lcm\n        (apply lcm (cons _lcm more))))))","user":"5d48e6d3e4b0776584bd6f15"},{"code":"(fn \n  ([a b]\n  (some (fn [n] (if (integer? (/ (* n a) b)) (* n a) false))\n    (rest (range))))\n  ([a b c]\n  (some (fn [n] (if (and (integer? (/ (* n a) b))\n                          (integer? (/ (* n a) c))) (* n a) false))\n    (rest (range))))\n  ([a b c d]\n  (some (fn [n] (if (and (integer? (/ (* n a) b))\n                          (integer? (/ (* n a) c))\n(integer? (/ (* n a) d))) (* n a) false))\n    (rest (range)))))","problem":100,"user":"4eda7cc3535d10e5ff6f530e"},{"problem":100,"code":"(fn get-lcm\n  ([a b & more] (get-lcm (concat [a b] more)))\n  ([coll]\n   (if (= 1 (count coll))\n     (first coll)\n     (let [e1 (first coll)\n           e2 (second coll)\n           gcd ((fn get-gcd [l s]\n                  (if (< l s) (get-gcd s l) (if (zero? s) l (get-gcd s (mod l s)))))\n                e1 e2)]\n       (get-lcm (cons (* gcd (/ e1 gcd) (/ e2 gcd)) (drop 2 coll)))))))","user":"56dc3dbbe4b0ea9b8538f81a"},{"problem":100,"code":"(fn [& xs]\n  (let [elem-in-common? (fn [& colls] (first (apply clojure.set/intersection (map set colls))))\n        all-multiples (map #(iterate (partial + %) %) xs)]\n    (loop [i 1]\n      (if-let [result (apply elem-in-common? (map (partial take i) all-multiples))]\n        result\n        (recur (inc i))))))","user":"5250b7a5e4b0541d1855b83e"},{"problem":100,"code":"(fn [& ns]\n  (letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm ns)))","user":"5d24e49be4b02ea6f0fb6a2a"},{"code":"(fn mcm [& args]\n  (reduce #(loop [a %1, b %2, ca a, cb b]\n              (cond\n                (= ca cb) ca\n                (< ca cb) (recur a b (+ ca a) cb)\n                (> ca cb) (recur a b ca (+ cb b)))) args))","problem":100,"user":"50aab057e4b056ee0193586b"},{"problem":100,"code":"(fn [& args]\n(loop [incs args]\n(if (= 1 (count (set incs)))\n(first incs)\n(let [minimum (apply min incs)]\n(recur (map #(if (<= %1 minimum) (+ %1 %2) %1) incs args))))))","user":"54580586e4b01be26fd74616"},{"problem":100,"code":"(fn [& a]\n  (loop [a (zipmap a a)]\n    (let [m (apply min-key val a)]\n      (if (apply = (vals a))\n        (val m)\n        (recur\n          (assoc\n            a\n            (key m)\n            (apply + m)))))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [i 1\n         multiples (repeat (count args) #{})]\n    (let [overlap (apply clojure.set/intersection multiples)]\n      (if (> (count overlap) 0)\n        (first overlap)\n        (recur (inc i) (map #(conj %1 %2) multiples (map (partial * i) args)))))))","user":"562c2fc2e4b058fa18c5a6d7"},{"problem":100,"code":"(fn lcm [a b & r]\n  (if r\n    (reduce #(lcm %1 %2) (lcm a b) r)\n    (first (filter #(not (ratio? (/ % a))) (map #(* % b) (rest (range)))))))","user":"59cf4013e4b0ef0a1e9b5b68"},{"problem":100,"code":"(fn lcm [& args] \n  (loop [ x (seq args) y (seq args) n 1/2 ]\n    (cond\n     (empty? x) n\n     (= (mod n (first x)) 0) (recur (rest x) y n )\n     :else (recur y y (+ n 1/2))\n     )\n    )\n  )","user":"56942b5fe4b0dcc4269f411c"},{"code":"(fn [& a](reduce #(loop [r 1] (\n  \tif (= (mod r %) (mod r %2) 0) \n\t\tr \n\t\t(recur (+ r 1/2)) \n\t)\n) a))","problem":100,"user":"4f4bd422e4b03ad3f0c10c7e"},{"problem":100,"code":"(fn lcm [& args]\n  (/\n   (reduce * args)\n   (reduce (fn gcd [a b]\n             (cond\n               (= 0 b) a\n               (< a b) (gcd b a)\n               (> a b) (gcd (mod a b) b))) args)))","user":"5649b1b0e4b0284900eef646"},{"code":"(fn [& more]\n  (/ (reduce * more) \n    (reduce (fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) more)))","problem":100,"user":"4f26d6d9e4b0d6649770a007"},{"problem":100,"code":"(fn least-common-multiple [& n]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (recur b (mod a b))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"60777335e4b0a637ed78034f"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (recur b (rem a b))))]\n    (reduce (fn [a b] (* (/ a (gcd a b)) b)) nums)))","user":"551ed214e4b08d5046aa8a4d"},{"problem":100,"code":"(fn [& vs]\n     \n (let [gcd (fn [a b]\n  (loop [a a b b]\n    (if (> a b)\n      \t(recur (- a b) b)\n      (if (= a b) \n        a\n        (recur a (- b a))\n        )\n      )\n    \n    \n    )\n  \n  )\n       lcm (fn [a b] (/ (* a b) (gcd a b)))\n       \n       ]\n   \n   (reduce lcm vs)\n   \n   \n   ))","user":"5ff676a9e4b06df49cee1497"},{"problem":100,"code":"(fn [& args] \n   (let [n (count args)\n         mp (into {} (map vec (partition 2 (interleave (range n) args))))\n         ]\n   (letfn [(fr [ags0 ags] \n             (let [nags (sort-by #(second %) ags)]  \n             (if (= (second (first nags)) (second (last nags))) (second (first nags))\n                 (recur ags0 (cons [(first (first nags)) (+ (second (first nags)) (ags0 (first (first nags))))]\n                                   (rest nags)) )\n             ) )\n               )]\n       (fr mp mp)\n     ))\n  )","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [& ns]\n  (loop [x 1]\n    (let [n (first ns)\n          m (* n x)]\n      (if (every? #(zero? (mod m %)) (rest ns))\n        m\n        (recur (inc x))))))","problem":100,"user":"4f3e5e87e4b0e243712b1f83"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [i 1\n        multiples (repeat (count args) #{})]\n    (let [c (apply clojure.set/intersection multiples)]\n      (if (empty? c)\n        (recur \n          (inc i) \n          (map conj multiples (map (partial * i) args))  \n        )\n        (first c)\n      )\n    )\n  )\n)\n\n; update only available since v1.7.0\n;(fn lcm [& args]\n;  (fn rec [as as0]\n;    (if (apply = as)\n;      (first as)\n;      (let [i (.indexOf as (apply min as))]\n;        (rec (update as i + (get as0 i)) as0)\n;      )\n;    )\n;  )\n;  (rec (vec args) (vec args))\n;)","user":"60335b35e4b0d5df2af222bf"},{"code":"(fn [& numbers]\n  (let [multiples (fn [n] (iterate #(+ n %) n))\n        largest-first (fn [colls] (apply max (map first colls)))\n        drop-a-bit (fn [n colls] (map (fn [coll] (drop-while #(< % n) coll)) colls))\n        iter (fn [colls]\n               (if (apply = (map first colls))\n                 (first (first colls))\n                 (recur (drop-a-bit (largest-first colls) colls))))]\n    (iter (map multiples numbers))))","problem":100,"user":"4e42f930535dc968683fc49f"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b] \n              (if (zero? b) \n                a \n                (recur b (mod a b))))]\n    (reduce \n     (fn [a b] \n       (/ \n        (* a b) \n        (gcd a b)))\n     args)))","user":"55f85b93e4b03cbcff9738ae"},{"problem":100,"code":"(fn [& _]\n  (let [orig (vec _)\n        min-idx (fn [coll] (reduce-kv #(if (< %3 (nth coll %1)) %2 %1) 0 coll))\n        update-lcd (fn [coll idx] (assoc coll idx (+ (nth orig idx) (nth coll idx))))]\n    (loop [lcd orig]\n      (if (apply = lcd)\n        (first lcd)\n        (recur (update-lcd lcd (min-idx lcd)))))))","user":"58923efce4b00487982d521c"},{"code":"(fn lcm [& x]\n  (letfn\n    [\n     (gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n     ]\n    (if (= (count x) 1)\n      (first x)\n      (let [c (gcd (first x) (second x))]\n        (apply\n         lcm\n         (cons (/ (* (first x) (second x)) c) (drop 2 x))\n         )\n       )\n      )\n    )\n  )","problem":100,"user":"52586d24e4b0cb4875a45cb0"},{"problem":100,"code":"(let [gcd2 (fn gcd2 \n             [a b] \n             (let [x (min a b)\n                   y (max a b)] \n               (if (= 0 x) y (gcd2 x (mod y x)))))\n      lcm2 (fn [a b] (/ (* a b) (gcd2 a b)))]\n  (fn [& args] (reduce lcm2 args)))","user":"4eadc217535d7eef30807321"},{"code":"(fn lcm\n   ([x y] (/ (* x y)\n             ((fn gcd [a b] (if (< a b)\n                              (gcd b a)\n                              (if (= b 0)\n                                a\n                                (gcd b (mod a b)))))\n              x y)))\n   ([x y & more] (apply (partial lcm (lcm x y)) more))\n   )","problem":100,"user":"5084cb7de4b0fb8f40674bfb"},{"problem":100,"code":"(fn l-c-m [x y & zs]\n  (first\n   (filter (fn [a]\n             (every? zero? (map (fn [b] (rem a b))\n                                (cons y (into [] zs)))))\n           (lazy-seq (map (partial * x) (rest (range)))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn __ [& xs]\n  (first\n   (for [c (sort (set (flatten (map #(range 1 500 %) (conj xs 1)))))\n         :when (every? #(= 0 (rem c %)) xs)]\n     c)))","problem":100,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * nums) (reduce gcd nums))))","user":"56df62b3e4b0ca2494a095ef"},{"code":"(fn [a & b] (reduce #(/ (* % %2) (if (ratio? (/ % %2)) (/ % (numerator (/ % %2))) (min % %2))) a b))","problem":100,"user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [& xs] (reduce (fn [a b]\n                   (let [gcd (fn gcd [a b] (if (= 0 a) b (gcd (mod b a) a)))] \n                     (/ (* a b) (gcd a b)) )\n                   ) xs))","problem":100,"user":"4f9510b5e4b0dcca54ed6cc7"},{"problem":100,"code":"(fn [& coll]\n    (let [mnum (apply min coll)\n          othernums (filter #(not (= mnum %)) coll)\n          notminmod (fn [curnum]\n                      (not= 0\n                            (reduce + (map #(mod curnum %) othernums))))\n          ]\n      (first (drop-while notminmod (map #(* mnum %) (iterate inc 1))))\n      ))","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":100,"code":"(fn lcm [& nums]\n    (reduce (fn [a b] (/ (* a b) \n                         ((fn gcd [x y]\n                            (let [xmody (mod x y)]\n                              (if (= 0 xmody)\n                                y\n                                (gcd y xmody)))) a b)\n                         )) nums))","user":"5a94a38ce4b0d174b936c73e"},{"problem":100,"code":"(fn [a & x]\n  (letfn [(gcd  [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm* [a b] (/ (identity (* a b)) (gcd a b)))]\n    (if-not (nil? (first x))\n      (recur (lcm* a (first x)) (rest x))\n      a)))","user":"563ed73ae4b08d4f616f5ecb"},{"problem":100,"code":"(fn lcm\n  ([a b] (letfn [(gcd [a b]\n                   (if (zero? (mod a b)) b\n                       (recur b (mod a b))))]\n           (/ (* a b) (gcd a b))))\n  ([a b & others]\n   (reduce lcm (lcm a b) others)))","user":"56f53962e4b046a417f9206c"},{"code":"(fn [& coll]\n    (letfn [(lcm [current-and-init]\n              (if (= 1 (count (set (map first current-and-init))))\n                (first (first current-and-init))\n                (let [minimum (first current-and-init)\n                      current (first minimum)\n                      init (last minimum)\n                      next-minimum [(+ current init) init]]\n                  (lcm (sort (cons next-minimum (rest current-and-init)))))))]\n      (lcm (map #(vector %1 %2) coll coll))))","problem":100,"user":"4dc29a1d535d020aff1edf96"},{"code":"(fn [& x]\r\n  (let [y (apply min x)]\r\n    (loop [z y]\r\n      (if (every? #(zero? (mod z %)) x)\r\n        z\r\n        (recur (+ z y))))))","problem":100,"user":"4da3e51330acd6ed10482a68"},{"code":"(fn f[& x]\n  (loop [l x]\n  \t(if (= (count (distinct l)) 1)\n    \t(first l)\n    \t(let [m (apply min l)]             \n            (recur (map-indexed (fn[i v] (if (= v m) (+ v (nth x i)) v)) l))))))","problem":100,"user":"500b61b1e4b03d00572d2d81"},{"code":"(fn [& vals]\n  (reduce (fn [lcm i]\n  (second (for [x (range 351) y (range 20) \n        :let [n (* i x) m (* lcm y)] \n        :when (= n m)] n))) (first vals) vals))","problem":100,"user":"4f1d1299535d64f603146487"},{"code":"(fn lcm [ & args ]\n  (letfn [ (gcd [ m n ]\n              (if (= 0 n)\n                  m\n                  (recur n (mod m n)))) \n           (lcm [ m n ]\n              (/ (* m n) (gcd m n))) ]\n      (reduce lcm args)))","problem":100,"user":"4e860e85535db62dc21a62f1"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (letfn [(gcd [a b]\n  (cond\n    (> a b) (gcd (- a b) b)\n    (< a b) (gcd a (- b a))\n    :else a))]\n   (/ (* a b) (gcd a b))))\n  ([a b & args]\n   (reduce lcm (lcm a b) args)))","user":"56504dc2e4b0284900eef6bc"},{"problem":100,"code":"(fn [& values]\n  (let [lcm (fn [a b]\n              (loop [x a, y b]\n                (if (= x y)\n                  x\n                  (if (< x y)\n                    (recur (+ x a) y)\n                    (recur x (+ y b))))))]\n    (reduce lcm values)))","user":"500159b3e4b0678c553fc419"},{"code":"(fn s[& coll] \n\t(second(sort(apply clojure.set/intersection(map (fn[x](set(take 1000 (map #(* x %) (range))))) coll)\n\t))))\n;so what if 1000 is not enough... that's ugly","problem":100,"user":"5307e4ece4b02e82168697a9"},{"code":"(fn !!\n  ([a b]\n     (/ (* a b) (\n                 (fn ! [a b]\n                   (if (= a b)\n                     a\n                     (! (- (max a b) (min a b)) (min a b))))\n                 a b)))\n  ([a b & t]\n     (reduce !! (!! a b) t)))","problem":100,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [& xn]\n  (let [gcd (fn [a b] (loop [a a b b] (if (zero? b) a, (recur b (mod a b)))))]\n    (let [gcd2 (fn [s] (reduce gcd s))]\n      (let [lcm (fn [a b] (cond (zero? a) 0 (zero? b) 0 :else (* b (quot a (gcd a b)))))]\n        (let [lcm2 (fn [s] (reduce lcm s))]\n          (lcm2 xn))))))","problem":100,"user":"50b24a2fe4b03ea88043355c"},{"problem":100,"code":"(fn common \n  ([x] x)\n  ([x y] \n   (first (filter #(integer? (/ % x)) \n           (map #(* y %) \n                (drop 1 (range))))))\n  ([x y & more]\n   (reduce common (common x y) more)))","user":"56051095e4b08b23635d3162"},{"problem":100,"code":"#(let [c (fn [a b]\n            (if (= 0 b) a\n                  (recur b (mod a b))))\n       e (fn [a b]\n           (/ (* a b) (c a b)))]\n   (reduce e %&))","user":"5405885ee4b0addc1aec6668"},{"problem":100,"code":"(fn [& values]\n  (let [col (apply interleave (map (fn [v] (iterate #(+ v %) v)) values))]\n    (some #(get (clojure.set/map-invert %) (count values)) \n          (reductions #(merge-with + %1 {%2 1}) {} col))))","user":"4f1e4ab5535d64f603146496"},{"code":"(fn [& xs]\n  (/ (apply * xs)\n     (reduce #(if (zero? %2) % (recur %2 (mod % %2))) xs)))","problem":100,"user":"523ea111e4b057c4b7cd0a65"},{"code":"(fn lcm [a & args] ; assume at least 2\r\n  (letfn [\r\n    (in-increasing-seq? [x s]\r\n      (or\r\n        (= x (first s))\r\n        (and\r\n          (> x (first s))\r\n          (in-increasing-seq? x (rest s)))))\r\n  (multiples [n]\r\n    (iterate (partial + n) n))]\r\n    (first\r\n      (filter\r\n        (fn [x]\r\n          (every? #(= % true)\r\n            (map (partial in-increasing-seq? x) \r\n              (map multiples args))))\r\n        (multiples a)))))","problem":100,"user":"4e03c616535d04ed9115e796"},{"problem":100,"code":"(fn [& x]\n  (let [gcd (fn [a b]\n              (loop [a a b b]\n                    (if (zero? b) a,\n                        (recur b (mod a b)))))\n        lcm (fn [a b] (* b (quot a (gcd a b))))]\n  (reduce #(lcm % %2) x)))","user":"54b83ae9e4b0ed20f4ff6e95"},{"problem":100,"code":"#(letfn [\n(gcd [a b]\n(loop [x a y b]\n(cond (= x y) x\n      (> x y) (recur (- x y)  y)\n      (< x y) (recur x (- y x))\n)))\n\n(conv [x]\n  (if (= (type x) clojure.lang.BigInt) (int x) x))\n]\n(conv (/ (reduce * %&) (reduce gcd %&))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [& args]\n  (loop [argz args\n         args args]\n    (if (apply = argz) (first argz)\n      (let [teh_zip (zipmap args argz)]\n      (let [sorted (into (sorted-map-by (fn [key1 key2]\n                         (compare [(get teh_zip key1) key1]\n                                  [(get teh_zip key2) key2]))) teh_zip)]\n        (recur (vec (conj (rest (vals sorted)) (+ (key (first sorted)) (val (first sorted))))) (keys sorted)))))))","problem":100,"user":"4de52c87535d08e6dec9fdf0"},{"problem":100,"code":"(fn lcm [& args] \n  (letfn [(gcd [a b]\n               (if (zero? b) a (gcd b (mod a b))))]\n (/ (apply * args) (reduce gcd args))))","user":"5eaba9c0e4b00a66d4a951d6"},{"problem":100,"code":"(fn lcm\n\t[& s]\n\t(letfn [(gcd [a b]\n\t\t(if (= a b)\n\t\t\ta\n\t\t\t(if (> a b)\n\t\t\t\t(recur (- a b) b)\n\t\t\t\t(recur a (- b a)))))]\n\t\t(reduce #(/ (* %1 %2) (gcd %1 %2)) s)))","user":"5954eef0e4b066ee0a44af17"},{"code":"(fn lcm [& numbers-list]\n  (let [nums (vec numbers-list)]\n    ((fn [xs]\n       (let [min-val (apply min xs)\n             ;; .indexOf works on my computer, but not in 4clojure.\n             ;; this ugly work-around makes 4clojure happy.\n             min-idx (count (take-while #(not (= min-val %)) xs))\n             new-val (+ min-val (get nums min-idx))]\n         (if (every? #(= % min-val) xs)\n           min-val\n           (recur (assoc xs min-idx new-val))))) nums)))","problem":100,"user":"4ff355a1e4b0678c553fc34d"},{"problem":100,"code":"(fn [& args]\n  (let [build-multiples (fn [n] (take 1000 (map #(* n (inc %)) (range))))]\n  (first (sort (reduce clojure.set/intersection (map #(set (build-multiples %)) args))))))","user":"5e8f87c7e4b0cb0169546342"},{"problem":100,"code":"(fn my-lcm [a b & rests]\n  (let [gcd (fn [a b] (loop [a a b b] (if (zero? b) a (recur b (mod a b)))))\n        n (/ (* a b) (gcd a b))]\n    (if (seq rests)\n      (apply my-lcm (cons n rests))\n      n)))","user":"53d86564e4b0e771c302546b"},{"code":"(fn lcm[& paramCol]\r\n  (let[gcd (fn[p1 p2]\r\n  \t\t\t\t    (loop[a (max p1 p2),b (min p1 p2)]\r\n\t\t\t\t\t      (let [x (mod a b)]\r\n\t\t\t\t\t\t      (if (= x 0) \r\n\t\t\t\t\t\t          b\r\n\t\t\t\t\t\t          (recur b x)\r\n\t\t\t\t\t\t      )\r\n\t\t\t\t\t      )\r\n\t\t\t\t\t    )\r\n\t\t\t\t\t  ),\r\n       simp_lcm (fn[a b]\r\n                  (/ (* a b) (gcd a b) )\r\n                  )\r\n       ]\r\n       (reduce simp_lcm paramCol)   \r\n    )\r\n)","problem":100,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":100,"code":"(fn lcr [& xs]\n  (let [n (apply max xs)]\n    (first \n     (filter (fn [dv] \n               (every? zero?\n                               (map #(mod dv %) xs)))\n             (iterate #(+ % n) n)))))","user":"52382d91e4b0fae3832e99f0"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))] (reduce (fn [a b] (* (/ a (gcd a b)) b)) args)))","user":"5a99b688e4b0d174b936c7a6"},{"code":"(fn [& xs]\n  (reduce (fn [x y]\n          \t(/ (* x y)\n               (#(let [i (rem % %2)]\n                  (if (zero? i)\n                      %2\n                     (recur %2 i))) x y)))\n          xs))","problem":100,"user":"50e3cf55e4b01912b3285c45"},{"code":"(fn [& args] \r\n  (let [m (apply max args)\r\n        f (fn [mul] (map #(mod mul %) args))]\r\n    (first\r\n      (drop-while #(not= 0 (reduce + (f %)))\r\n        (iterate #(+ m %) m)))))","problem":100,"user":"502d4ea0e4b02fc10c6c6e46"},{"code":"(fn lcm \r\n  ([a b]\r\n\t  (letfn [(gcd [a b]\r\n\t\t\t    (if (zero? b) a (recur b (mod a b))))]\r\n\t    (/ (* a b) (gcd a b))))\r\n\t([a b & more]\r\n\t  (reduce lcm (lcm a b) more)))","problem":100,"user":"4dd52e29535dae65d5c462e5"},{"problem":100,"code":"(fn [& v]\n   (letfn [(lcm [a b] (/ (* a b) (gcd a b)))\n           (gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n     (reduce lcm v)))","user":"55933c7ae4b0c79f6e1db938"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd #(if (= 0 %2) %1 (recur %2 (mod %1 %2)))\n        lcm #(/ (* %1 %2) (gcd %1 %2))]\n    (reduce lcm xs)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [gcd #(reduce (fn gcd2 [a b] (if (zero? b) a (gcd2 b (rem a b)))) %)]\n    (/ (apply * xs) (gcd xs))))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":100,"code":"(fn lcm [a & nums]\n  (letfn [(gcd [x y]\n            (let [dividend (max x y)\n                  divisor (min x y)\n                  remainder (rem dividend divisor)]\n              (if (zero? remainder)\n                divisor\n                (recur divisor remainder))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) a nums)))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn [& xs]\n  (let [denom (apply * (map #(if (ratio? %) (denominator %) 1) xs))]\n    (->> (range)\n    \t (rest)\n         (map #(/ % denom))\n         (drop-while (fn [x] (not (apply = (cons 0 (map #(mod x %) xs))))))\n         (first))))","problem":100,"user":"525f51bde4b0cb4875a45dc8"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd-2 (fn [a b] \n                (if (zero? b)\n                  a\n                  (recur b (rem a b))))\n        gcd (partial reduce gcd-2)]\n    (/ (apply * xs) (gcd xs))))","user":"5af8221ce4b0cc2b61a3bccd"},{"code":"(fn multi-lcm [& xs]\n  (letfn [(lcm [a b]\n              (let [gcd (fn gcd [a b]\n                          (if (zero? b)\n                            a\n                            (recur b (rem a b))))\n                    g (gcd a b)\n                    mult (* a b)\n                    abs-mult (if (> mult 0) mult (- mult))]\n                (/ abs-mult g)))]\n  (reduce lcm xs)))","problem":100,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn varags-lcm [& args]\n\t(let [gcd (fn [x y] \n\t             (loop [a x b y]\n\t\t\t\t    (if (zero? b)\n\t\t\t\t      a\n\t\t\t\t      (recur b (rem a b)))))\n       \t  lcm (fn [x y]\n                (/ (* x y) (gcd x y)))]\n   (loop [acc (first args) v (rest args)]\n    (if (empty? v)\n      acc\n      (recur (lcm acc (first v)) (rest v))))))","problem":100,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn lcm_100 [& args]\n  (letfn [\n           (gcd\n             [a, b]\n             (loop [a a b b]\n               (cond (= a b) a\n                     (> a b) (recur (- a b) b)\n                     :else (recur a (- b a)))))]\n    (reduce  (fn [a b] (/ (* a b) (gcd a b))) args )))","problem":100,"user":"530cb5b8e4b02e82168697e0"},{"problem":100,"code":"(fn [& coll] \n  (reduce \n   (fn kgv [x y] (/ (* x y) \n                    ((fn ggt [x y] (if (zero? y) x (recur y (mod x y)))) x y))) \n   (seq coll)))","user":"59089229e4b047aa04b1997c"},{"problem":100,"code":"(fn lcm [& lst]\n  (let [mx (apply max lst)\n        finished (fn [x] (not (every? identity (map #(= 0 (mod x %)) lst))))]\n    (+ mx (last (take-while finished (iterate #(+ mx %) mx))))\n    )\n  )","user":"5545477fe4b0a04f79299531"},{"problem":100,"code":"(fn loo [& a]\n  (let [x (apply max a)]\n    (loop [y 1]\n      (if (every? #(= 0 (rem (* x y) %1 )) a)\n        (* x y)\n        (recur (inc y))))))","user":"51e8ee6be4b07cae92c04bfd"},{"problem":100,"code":"(fn [& args]\n  (reduce\n   #(let [ma (max %1 %2) mi (min %1 %2)]\n      (loop [x ma]\n        (if (= 0 (mod x mi))\n          x\n          (recur (+ x ma))\n          )\n        )\n      )\n   args\n   )\n  )","user":"56f73913e4b08e7d20b9682d"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [[[x] ys] (split-at 1 nums)\n        xs (iterate #(+ x %) x)\n        mult? #(= 0 (mod %1 %2))]\n    (first (drop-while #(not-every? (partial mult? %) ys) xs))))","user":"55d68726e4b0e31453f64a99"},{"code":"(fn [& nums]\n  (reduce (fn [x y]\n            (loop [[xh & xt :as xall] (iterate (partial + x) x)\n                   [yh & yt :as yall] (iterate (partial + y) y)]\n              (cond (= xh yh) xh\n                    (< xh yh) (recur xt yall)\n                    :else (recur xall yt))))\n          nums))","problem":100,"user":"507b7dbee4b09034bfeeb71e"},{"problem":100,"code":"(fn [& originalxs]\n    (loop [xs originalxs]\n      (if (apply = xs)\n        (first xs)\n        (let [m (apply max xs)\n              xs' (map-indexed\n                   #(if (< %2 m)\n                      (+ %2 (nth originalxs %1))\n                      (identity %2))\n                   xs)]\n          (recur xs')))))","user":"573a0ecce4b0cd1946bd1088"},{"problem":100,"code":"(fn [& ns] (if (some #(== 0 %) ns)\n                   0\n                   (let [mx (apply max ns)] (loop [x mx]\n                     (if (every? #(= 0 (rem x %)) ns)\n                       x\n                       (recur (+ x mx))\n                       )))\n                   ))","user":"5dfe3928e4b0a607a9a45d04"},{"problem":100,"code":"(fn [& args]\n  (first (filter #(every? (fn [x] (zero? (mod % x))) args)\n                 (iterate #(+ (apply min args) %) (apply min args)))))","user":"4f9b3532e4b0dcca54ed6d13"},{"problem":100,"code":"(fn [& r]\n  (reduce\n    (fn lcd [x y]\n      (let [gcd \n        (fn [a b]\n        (if (> b a)\n          (recur b a)\n          (if (= b 0)\n            a\n            (recur b (mod a b)))\n          ))]\n      (/ (* x y) (gcd x y))))\n   r))","user":"54c169ade4b0ed20f4ff6f24"},{"code":"(fn [n & s]\n \t(reduce\n    \t(fn [x y]\n\t\t\t(loop [a x]\n            \t(if (= (/ a y) (int (/ a y))) a\n                \t(recur (+ a x))\n                )\n\t\t\t)             \n        )\n     \tn\n     \ts\n    )\n)","problem":100,"user":"525ba7bbe4b0cb4875a45d28"},{"problem":100,"code":"(fn least-common-multiple [& args]\n  (let [min-val (apply min args)]\n    (loop [factor 1]\n      (let [multiple (* min-val factor)]\n        (if (every? zero? (map (partial rem multiple) args)) multiple\n            (recur (inc factor)))))))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b)))) ; from https://rosettacode.org/wiki/Greatest_common_divisor#Clojure\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"57407ab3e4b05c31a32c0854"},{"code":"#(letfn \n  [(l [f s] \n    (/ (* f s) \n       (int (.gcd (bigint f) (bigint s)))))\n   (r [f s]\n    (let [m (->> [f s] \n             (filter ratio?) \n             (map denominator)\n             (reduce * 1))]\n      (/ (l (* m f) (* m s)) m)))]\n  (reduce r %&))","problem":100,"user":"4fbacdbae4b081705acca2e5"},{"problem":100,"code":"(fn lcm [& others] (let [numerators (map #(if (ratio? %1) (numerator %1) %1 ) others)\n                           denominators (map #(if (ratio? %1) (denominator %1) 1 ) others)\n                           lcm1 (fn [numerators] (let [fun (fn [cnt] (first(filter #(> %1 0) (map #(mod cnt %1) numerators))))]\n\t\t\t\t\t\t                    (loop [cnt 1]\n\t\t\t\t\t\t                        (if (fun cnt)\n\t\t\t\t\t\t                          (recur (inc cnt))\n\t\t\t\t\t\t                          cnt\n\t\t\t\t\t\t                          ))))\n                           gcd1 (fn [denominators]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (let [fun (fn [cnt] (first(filter #(> %1 0) (map #(rem  %1 cnt) denominators))))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    (loop [cnt (reduce #(if(< %1 %2) %1 %2) denominators)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      (if (fun cnt)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       (recur (dec cnt))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        cnt))))\n                           ]\n                       (/(lcm1 numerators) (gcd1 denominators))))","user":"5df0c6ffe4b093ff717275c2"},{"code":"(fn f\n  ([a b]\n     (/ (* a b) ((fn gcd [a,b]\n      (if (= a b) a (if (> a b) (gcd (- a b) b) (gcd (- b a) a))))\n    a b)))\n  ([a b & more]\n    (apply f (cons (/ (* a b) ((fn gcd [a,b]\n      (if (= a b) a (if (> a b) (gcd (- a b) b) (gcd (- b a) a))))\n    a b)) more))))","problem":100,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn [& args]\n  (letfn [(g [a b] (if (= b 0) a (g b (rem a b))))]\n    (reduce \n      #(/ (* %1 %2) (g %1 %2))\n      (first args)\n      args)))","problem":100,"user":"5027b41ee4b01614d1633fee"},{"code":"(fn [& sq]\n  ((fn [mp]\n     (if (apply = (for [[x y] mp] (* x y)))\n       (apply * (first mp))\n       (let [small (-> \n                     (sort #(compare (* (first %1) (last %1)) (* (first %2) (last %2))) mp)\n                     first\n                     first)]\n         (recur (assoc mp small (inc (get mp small)))))))\n     (apply merge (for [x sq] {x 1}))))","problem":100,"user":"504e12ade4b078edc5f593b7"},{"code":"#(reduce(fn[n r](* r(numerator(/ n r))))%&)","problem":100,"user":"4dbef924535d020aff1edf6e"},{"code":"; \n;(fn lcm [& nums]\n;  (letfn [(gcd-int [m n] (if (zero? n) m (recur n (mod m n))))\n;          (lcm-int [m n] (/ (* m n) (gcd-int m n)))\n;          (denomi-ex [r] (if (integer? r) 1 (denominator r)))\n;          (nume-ex   [r] (if (integer? r) r (numerator r)))]\n;      (let [sorted (sort > nums)\n;            denominators (map denomi-ex sorted)\n;            denomi-lcm   (reduce lcm-int denominators)\n;            numerators   (map nume-ex sorted)\n;            nume-lcmed   (->> (map (partial / denomi-lcm) denominators) (map * numerators))]\n;      (/ (reduce lcm-int nume-lcmed) denomi-lcm))))\n\n; \n(fn lcm [& nums]\n  (letfn [(gcd-2 [m n] (if (zero? n) m (recur n (mod m n))))\n          (lcm-2 [m n] (/ (* m n) (gcd-2 m n)))]\n    (reduce lcm-2 (sort > nums))))","problem":100,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":100,"code":"(fn [& x] (loop [m (apply hash-map (interleave x x))]\n                   (let [[fk fv]  (reduce (fn [[_ y :as z] [_ b :as c]] (if (< b y) c z)) m)]\n            \t     (if (apply = (vals m)) fv\n              \t         (recur (assoc m fk (+ fk fv)))))))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"#(reduce (fn [a b] (/ (* a b) ((fn [a b]\n      (if (zero? b)\n      a\n      (recur b, (mod a b)))) a b))) %&)","problem":100,"user":"504e3aaae4b0f6ff3350c487"},{"code":"(fn __ [& nbs]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nbs)))","problem":100,"user":"4ec9549d535d6d7199dd36fe"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))))\n          (abs [x]\n            (if (< x 0) (- x) x))]\n    (reduce (fn [acc x]\n              (/ (abs (* acc x)) (gcd acc x)))\n            args)))","user":"526e1bd0e4b03e8d9a4a730b"},{"code":"(fn lcm [& xs]\n    (/ (reduce * xs) (reduce #(if (= %2 0) % (recur %2 (mod % %2))) xs)))","problem":100,"user":"5114ab7be4b0ce5098ee73b5"},{"problem":100,"code":"(fn [& xs] (/ (reduce * xs) \n               (reduce #(if (zero? %2) % (recur %2 (mod % %2))) \n                       (sort-by identity > xs))))","user":"54055aa9e4b0addc1aec6665"},{"problem":100,"code":"(fn least-common-divisor [& numbers]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))))\n          (lcd [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcd numbers)))","user":"54a96a15e4b09f271ff37cad"},{"code":"(fn [& n] (loop [m 1/2]\n   (if (every? identity (map #(= 0 (mod m %)) n))\n     m\n     (recur (+ m 1/2)))))","problem":100,"user":"51f28a64e4b0210f90e7454e"},{"code":"(letfn [(gcd [x y]\n          (cond (> y x) (gcd y x)\n                (zero? y) x\n                :else (gcd y (rem x y))))\n\n        (lcs [x y]\n          (/ (* x y)\n             (gcd x y)))]\n  (fn [& xs]\n    (reduce lcs xs)))","problem":100,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [& l] \n   (let [gcd (fn g [a b] (if (= b 0) a (g b (rem a b))))\n         lcm (fn [a b] (/ (* a b) (gcd a b)))]\n     (loop [l l\n            acc (lcm (first l) (second l))]\n       (if (empty? l)\n         acc\n         (recur (rest l)\n                (lcm acc (first l)))))))","problem":100,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":100,"code":"(fn lcm4 [a b & c]\n   (letfn [(gcd  [x y] (if (zero? y) x (gcd y (rem x y))))\n           (ifcd [x y] (/ 1 (gcd (/ 1 x) (/ 1 y))))]\n     (if (empty? c)\n       (ifcd a b)\n       (apply lcm4 (ifcd a b) (first c) (rest c)))))","user":"4f6ba7bce4b07046d9f4efb0"},{"problem":100,"code":"(fn LCM\n  [& rs]\n  \n  (let [nums (map #(if (ratio? %) (numerator %) %) rs)\n        dens (map #(if (ratio? %) (denominator %) 1) rs)\n        gcd (fn [a b]\n              (if (= b 0) a\n                (recur b (mod a b))))]\n    (/\n      (reduce #(/ (* %1 %2) (gcd %1 %2)) nums)\n      (reduce gcd dens))))","user":"5e95013fe4b0fbed045a3800"},{"code":"(fn [& args]\n  (let [l (fn [fm] (if (apply = (vals fm)) (val (first fm))\n                  (let [[k v] (apply min-key val fm)]\n                    (recur (update-in fm [k] (partial + k))))))]\n    (l (zipmap args args))))","problem":100,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn [& nums]\n   (let [gcd (fn [a b]\n               (loop [mx (max a b) mn (min a b)]\n                 (let [rem (mod mx mn)]\n                   (if (zero? rem)\n                     mn\n                     (recur mn rem)))))\n         lcm (fn [a b]\n               (/ (* a b) (gcd a b)))]\n     (reduce lcm nums)))","problem":100,"user":"530b8580e4b02e82168697cc"},{"problem":100,"code":"#(let [product (apply * %&)\n       gcd (reduce (fn [a b] (if (zero? b) a (recur b (mod a b)))) %&)]\n   (/ product gcd))","user":"526e5159e4b03e8d9a4a7316"},{"problem":100,"code":"(fn lcm-2\n  [& xs]\n  (letfn [(gcd [a b]\n            (if (zero? a)\n              b\n              (recur (mod b a) a)))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":100,"code":"(fn [& ls]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm ls)))","user":"55236ad6e4b0882d96d091b1"},{"problem":100,"code":"(fn [& l] \n  (let [fa (reduce\n             (fn [x y]\n               ((fn [a b]\n                  (if (zero? b)\n                    (* a (apply * (map #(/ % a) (list x y))))\n                    (recur b (mod a b))))\n                        x y))l)] (* fa 1\n \n)))","user":"5951190be4b066ee0a44aea4"},{"problem":100,"code":"#(reduce (fn [a b] (* (/ a\n                         (loop [c a\n                                d b]\n                           (if (= d 0)\n                             c\n                             (recur d (rem c d))))) \n                      b)) \n         \n         %&)","user":"5c1aadcde4b01240ff567209"},{"problem":100,"code":"(fn lcm [& xs]  \n  (let [gcd (fn  [a b]  (if  (zero? b) a  (recur b  (rem a b))))]\n    (reduce \n      #(/ (* % %2) (gcd % %2))\n     xs\n     )))","user":"546a6c7ce4b00cfc9eacc154"},{"problem":100,"code":";(fn [a b]\n;  (if (zero? b)\n;    a\n;    (recur b (mod a b))))\n\n(fn [& value]\n  (letfn [(gcd [a b]\n      (if (zero? b)\n        a\n       (recur b (mod a b))))\n          (multiplier [x y] (/ (* x y) (gcd x y)))]\n    (reduce multiplier value)))\n\n;information reference for the use of &\n;https://stackoverflow.com/questions/9242440/how-to-make-a-clojure-function-take-a-variable-number-of-parameters","user":"5a99b87ee4b0d174b936c7af"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm #(/ (* %1 %2) (gcd %1 %2))]\n    (reduce lcm args)))","user":"5c13da47e4b01240ff5671a6"},{"code":"(fn[x & rs](reduce \n  #((fn f[a,b](if(zero? b) (/ (* %1 %2) a) (f b (mod a b)))) %1 %2) \n  x rs)\n)","problem":100,"user":"4ec75829535d6d7199dd36e1"},{"code":"(fn [& v] (/ (apply * v) (reduce (fn gcd [x y] (if (= 0 y) x (gcd y (mod x y)))) v)))","problem":100,"user":"4db92654535d1e037afb21a0"},{"problem":100,"code":"(fn lcd [& x]\n  (letfn [(gcd [a b] ;; gcd (see solution #66)\n\t\t    (loop [a a\n                   b b]\n              (cond\n               (= 0 a) b\n      \t\t   (= 0 b) a\n               (> a b) (recur (- a b) b)\n               :else (recur a (- b a)))))\n          (lcd [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcd x)))","user":"569ab3e2e4b0542e1f8d144a"},{"code":"(fn [& more]\n  (letfn [(gcd [a b]\n           (if (= b 0) a\n             (recur b (rem a b))))]\n   (reduce #(/ (* %1 %2) (gcd %1 %2)) more)))","problem":100,"user":"4db1fe241254ad5b4805fa77"},{"code":"(fn [& s] (/ (apply * s) (reduce #(if (= 0 %2) % (recur %2 (rem % %2))) s)))","problem":100,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn lcm [& more]\r\n  (reduce \r\n    (fn lcm-2 [a b] \r\n      (loop [x a]\r\n      (if (zero? (mod x b))\r\n        x\r\n        (recur (+ x a)))))\r\n    more))","problem":100,"user":"4ef0f1a1535dced4c769f212"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm-int-2 (fn [a b] (/ (* a b) (gcd a b)))\n        lcm-rational-2 (fn [a b]\n                         (let [ra (clojure.lang.Numbers/toRatio a)\n                               rb (clojure.lang.Numbers/toRatio b)\n                               lcm-denom (lcm-int-2 (denominator ra) (denominator rb))\n                               mula (/ lcm-denom (denominator ra))\n                               mulb (/ lcm-denom (denominator rb))\n                               na (* (numerator ra) mula)\n                               nb (* (numerator rb) mulb)]\n                           (/ (lcm-int-2 na nb) lcm-denom)))]\n    (if (some rational? args)\n      (reduce #(lcm-rational-2 %1 %2) args)\n      (reduce #(lcm-int-2 %1 %2) args))))","user":"5292feb4e4b0239c8a67af39"},{"problem":100,"code":"(fn lcm\n  ([x y]\n   (let [gcd (loop [a x\n                    b y]\n               (if (zero? b)\n                 a\n                 (recur b (rem a b))))]\n     (/ (* x y)\n        gcd)))\n  ([x y & xs]\n   (apply lcm (lcm x y) xs)))","user":"52470d42e4b05ef8e38e6350"},{"problem":100,"code":"(fn  ([& a] (loop [v (map #(vector % 1) a)]\n            (let [m (apply min (map #(apply * %) v))]\n              (if (apply = (map #(apply * %) v)) (apply * (first v)) \n                (recur (map \n                  #(if (= (apply * %) m) \n                    (vector (first %) (inc (second %))) \n                    %) v)))))))","user":"54d8cc38e4b0a52adc2e203e"},{"problem":100,"code":"(fn lcm [e & coll]\n  (* e\n  (first\n   (filter (fn good? [n]\n             (every? #(integer? (/ (* n e) %)) coll))\n           (iterate inc 1)))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":100,"code":"(fn [& n] (reduce (fn [a b] \n  (/ (* a b) ((fn gcd [a b] \n       (if (= b 0) a (gcd b (mod a b)))) a b))) n))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"(fn [& s] \n  (reduce (fn [x y]\n      (if (every? zero? [x y]) 0\n        (* y (/ x\n            (#(if (zero? %2) % (recur %2 (mod % %2))) x y)))))\n    s))","problem":100,"user":"4f956072e4b0dcca54ed6ccf"},{"code":"(fn [& args]\n  (letfn [(gcd[v1 v2]\n              (let [[m n] (sort > [v1 v2])\n                    r (rem m n)]\n                (if (zero? r)\n                  n\n                  (gcd n r))))]\n    (/ (reduce * args) (reduce gcd args))))","problem":100,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":100,"code":"(fn lcm\n  [& nums]\n  (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n   (reduce (fn [x y]\n             (/ (* x y) (gcd x y))) (first nums) (rest nums))))","user":"506f0968e4b09350ab4199f5"},{"code":"(fn [& args]\n  (let [aux (fn [x y]\n    (loop [a x b y]\n      (cond (= a b) a\n            (< a b) (recur (+ a x) b)\n            (> a b) (recur a (+ b y)))))]\n    (reduce aux args)))","problem":100,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn [& ns]\n  (let [m (apply max ns)]\n    (loop [n m]\n      (if (every? zero? (map #(mod n %) ns))\n        n\n        (recur (+ n m))))))","problem":100,"user":"4e1f9bb5535d04ed9115e80d"},{"problem":100,"code":"(fn lcm [& args]\n   (letfn [(gcd [x y]\n             (if (< x y) \n               (gcd y x)\n               (cond\n                 (= 0 (rem x y)) y\n                 true (gcd y (rem x y)))))\n           (ilcm [a b] (/ (* a b) (gcd a b)))\n           (nd [x] (if (integer? x) (list x 1) (list (numerator x) (denominator x))))\n           (flcm [a b] (let [a0 (nd a) b0 (nd b)] (/ (ilcm (first a0) (first b0)) (gcd (second a0) (second b0)))))]\n\n     (if (= 1 (count args))\n       (first args)\n       (apply lcm (conj (drop 2 args) (flcm (first args) (second args)))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"(fn [& nums]\n  (first\n   (filter\n    (fn [step] (every? true? (map #(zero? (mod step %)) nums)))\n    (iterate #(+ (apply max nums) %) (apply max nums)))))","problem":100,"user":"4eddcbbf535d10e5ff6f532d"},{"problem":100,"code":"(fn [& x]\n  (/ (reduce * x)\n     (reduce (fn gcd [a b] (if (> a b) (gcd b a) (if (= (rem b a) 0) a (recur (rem b a) a)))) x)))","user":"52ea7d3ae4b09f7907dd14bf"},{"code":"(fn [f & r] (first (filter #(every? (fn [x] (= 0 (rem %1 x))) r) (range f Integer/MAX_VALUE f))))","problem":100,"user":"50956c2be4b087f34d351ab2"},{"problem":100,"code":"(fn [& args]\n   (loop [x (first args) mult 1 targ (* 1 x) oth (rest args)]\n      (if (every? #(zero? (mod targ %)) oth)\n          targ\n          (recur x (inc mult) (* x (inc mult)) oth))))","user":"5aa4a1ffe4b0d174b936c886"},{"problem":100,"code":"(fn [a & b] (first (filter (fn [r] (= 0 (reduce #(+ % (mod r %2)) 0  b))) (map #(* (inc %) a) (range)))))","user":"56c08696e4b060a8e693e3aa"},{"problem":100,"code":"(fn lcm [& nums] (/ (apply * nums) (apply (fn gcd [x y & r] (if r (gcd x (apply gcd (cons y r)))(cond (< y x) (gcd y x) (= 0 x) y :default (gcd (mod y x) x)))) \n nums)))","user":"56449e4de4b0284900eef5f9"},{"code":"(fn [f & c] \n  (letfn [(gcd [a b] \n               (let [g (max a b) l (min a b)] \n                 (if (zero? l) g (recur l (- g l)))))]\n    (reduce #(/ (* % %2) (gcd % %2)) f c)))","problem":100,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":100,"code":"(fn lcm \n  ([a b]\n   (loop [as [a]\n          bs [b]]\n     (cond\n       (some (set as) bs) (some (set as) bs)\n       (< (last bs) (last as)) (recur as (conj bs (+ b (last bs))))\n       (< (last as) (last bs)) (recur (conj as (+ a (last as))) bs))))\n  ([a b & c]\n   (apply lcm (conj c (lcm a b)))))","user":"5b14475be4b0cc2b61a3be5a"},{"problem":100,"code":"(fn lcm [& xs]\n   (let [a (first xs)\n         b (second xs)\n         gcd (fn [x y] (if (zero? y) x (recur y (rem x y))))\n         lcm (/ (* a b) (gcd a b))]\n     (if (not (nnext xs))\n       lcm\n       (recur (cons lcm (nnext xs))))))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn [& numbers]\n  (loop [numbers numbers targets numbers]\n    (if (apply = targets) \n      (first targets)\n      (recur numbers\n             (let [min-val (apply min targets)\n                   idx (. targets indexOf min-val)\n                   l (take idx targets)\n                   r (nthrest targets (+ 1 idx))]\n               (concat l (cons (+ min-val (nth numbers idx)) r)))))))","problem":100,"user":"514721c6e4b0d520409ed392"},{"code":"(fn [& data]\n  (reduce\n    (fn [a b]\n      (/\n        (* a b)\n        (loop [x a, y b]\n          (if (= x y)\n            x\n            (if (> x y)\n              (recur y (- x y))\n              (recur x (- y x)))))))\n    data)\n\n)","problem":100,"user":"4f16d6ed535d64f60314644f"},{"code":"(fn [& x] \n  (let \n    [g #(if (= % 0) %2 (recur (mod %2 %) %))]\n\n(/ (apply * x) (reduce g x))))","problem":100,"user":"4f083048535dcb61093f6c33"},{"problem":100,"code":"(fn [a & rest]\n  (let [gcd (fn [a, b] \n                (if (== b 0) \n                    a \n                    (recur b (mod a b))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) a rest)))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn [& xs]\n  (first (filter \n          (fn [x] (and (not (zero? x)) (every? true? (map (comp zero? (partial rem x)) xs))))\n          (map (partial * (apply max xs)) (range)))))","problem":100,"user":"534e4a29e4b084c2834f4ab0"},{"code":"(fn lcmm [& ns]\n  (letfn [(gcd [a b] \n            ;; euclid's algorithm\n            (if (= b 0) a \n                (recur b (mod a b))))\n        \n          (lcm [a b]\n              (/ (* a b) (gcd a b)))]\n\n    (reduce lcm ns)))","problem":100,"user":"4e6defcc535d5021c1a895f8"},{"problem":100,"code":"(fn lcm [& xs]\n  (/\n   (reduce * xs)\n   (reduce (fn gdc [a b] (if (zero? b) a (gdc b (mod a b)))) xs)))","user":"57fdd1cfe4b0d3187e9009bf"},{"code":"(fn f [h & t]\n  (loop [x h]\n    (if (every? #(zero? (mod x %)) t)\n      x\n      (recur (+ x h)))))","problem":100,"user":"4fb3b865e4b081705acca2a2"},{"problem":100,"code":"(fn lcm\n  ([a b] (let [gcd (fn [x y] (if (zero? y) x (recur y (rem x y))))] (* a (/ b (gcd a b)))))\n  ([a b & more] (reduce lcm (list* a b more))))","user":"4eb70649535d7eef30807373"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))]\n    (reduce (fn [a b] (* (/ a (gcd a b)) b)) args)))","user":"59dd387ae4b0a0ac046f2501"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd #(loop [a %1 b %2]\n               (if (< a b)\n                 (recur b a)\n                 (if (= 0 (mod a b))\n                   b\n                   (recur b (mod a b)))))\n        abs #(if (< % 0) (- %) %)\n        in-lcm #(* (abs %1) (/ (abs %2) (gcd %1 %2)))\n        ]\n    (reduce in-lcm args)))","user":"55eb026de4b0121d4835fdb7"},{"problem":100,"code":"(fn [p r & xs]\n  (let [two (fn [a b]\n              (loop [x a y b]\n                 (cond (= x y) x\n                       (> x y) (recur x (+ y b))\n                       :else (recur (+ x a) y))))]\n    (loop [q (two p r) zs xs]\n      (if (seq zs)\n        (recur (two q (first zs)) (rest zs))\n        q))))","user":"5bc833a5e4b07a9b28b100bb"},{"code":"(fn [x & xs]\n  ((comp first (partial keep identity))(for [multiple (rest (map (partial * x) (range)))]\n    (when (every? zero? (map (partial rem multiple) xs) ) multiple)\n    )))","problem":100,"user":"53691dc7e4b0243289761e97"},{"problem":100,"code":"(fn [& [x y & ys]]\n   (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n     (if (nil? y)\n       x\n       (recur (conj ys (/ (* x y) (gcd x y)))))))","user":"56e2ca59e4b03a7c14b85a38"},{"problem":100,"code":"(fn [& nums]\n   (let [[a & others] (sort nums)]\n     (loop [step a]\n       (if (every? #(= (rem step %) 0) others)\n         step\n         (recur (+ step a))))))","user":"5f79bff2e4b02876ed9fd0ca"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd2 [a b]\n            (cond (> a b) (gcd2 (- a b) b)\n                  (< a b) (gcd2 (- b a) a)\n                  :t a))\n          (lcm2 [a b] (/ (* a b) (gcd2 a b)))]\n    (reduce lcm2 nums)))","problem":100,"user":"4f62b29ce4b0defedf855fd9"},{"problem":100,"code":"(fn lcm [x & xs] \n         (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\n           (let [lcmHelper (fn [a b] (/ (* a b) (gcd a b)))]\n           \t (if (empty? xs) x \n               (if (= (count xs) 1) (lcmHelper x (first xs))\n                 (lcm x (apply lcm xs))\n               )\n             )\n           )\n         )     \n)","user":"550e0373e4b06e50f9beb162"},{"code":"(fn [lcm & ns] (reduce lcm ns))\n  ((fn lcm [gcd] #(/ (* %1 %2) (gcd %1 %2)))\n    #(if (= %2 0) %1 (recur %2 (rem %1 %2))))","problem":100,"user":"500933a6e4b046cdb195e074"},{"code":"(fn lcm [& x] (loop [xm x] (if (apply = xm) (first xm) (recur (map-indexed #(if (= %2 (apply min xm)) (+ %2 (nth x %1)) %2) xm)))))","problem":100,"user":"50a4f36be4b0344e360f3bc9"},{"code":"(fn [& args] (reduce (fn [a b]\n                       (/ (* a b) ((fn g [x y] (if (= 0 y) x (g y (mod x y)))) a b))) args))","problem":100,"user":"50bce014e4b0594b91591c63"},{"problem":100,"code":"(fn [& all]\n    (\n          reduce\n          #(loop [x % y %2]\n                 (if (= x 0)\n                   (/ (* % %2) y)\n                   (recur (mod y x) x)))\n          all\n    ))","user":"54f9c4dfe4b01ecee9d88841"},{"code":"(fn [& args]\n   (let [multiplier (first args)]\n     (first\n      (filter\n       (fn [val]\n         (every? #(zero? (rem val %)) args))\n       (range multiplier Double/POSITIVE_INFINITY multiplier)))))","problem":100,"user":"5014754de4b094324338f8e5"},{"code":"(fn lcm [& nums]\n  (let [start (apply max nums)]\n    (first (drop-while (fn [x]\n                         (not (every? zero?\n                                      (map #(mod x %)\n                                           nums))))\n                       (iterate #(+ % start) start)))))","problem":100,"user":"531d34cfe4b08068f379edac"},{"problem":100,"code":"(fn lcm [a & more]\n  (first (filter (fn [a-multiple] (every? zero? (map #(mod a-multiple %) more))) (map #(* a %) (drop 1 (range))))))","user":"60460824e4b02d28681c77bc"},{"problem":100,"code":"; Please don't look at me. I'm hideous...\n; I make babies cry. ;(\n(fn lcm [& args]\n  (letfn [(gcd [a b] ; greatest common divisor\n            (if (zero? b) a (gcd b (mod a b))))\n          (lcm' [a b] ; least common multiple\n            (/ (* a b) (gcd a b)))\n          (combinations [s] ; all possible combinations for the args\n            (for [x s y s] [x y]))\n          (mapcombinations [f s] ; map all combinations with f, then set and sort\n            (->> s combinations (map f) set sort))\n          (div? [s n] ; is n divisable with ALL in s\n            (every? true? (map #(= (rem n %) 0) s)))]\n    (loop [mu (->> args (mapcombinations (partial apply lcm')))] ; take each combination's lcm\n      (or (identity (some #(if (div? args %) %) mu)) ; take only the first lcm which is divisible with the initial args\n          (recur (->> mu (mapcombinations (partial reduce *))))) ; if none found -> multiply the lcms' combinations together\n      )))\n\n\n;; should have thought of this....\n;(fn [& args] \n;  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n;    (/ (reduce * args) (reduce gcd args))))","user":"561ba3e5e4b073c65b0ce3eb"},{"problem":100,"code":"(fn [& n]\n  (/ (apply * n)\n    (reduce #(if (zero? %2) % (recur %2 (mod % %2))) n)))","user":"6074f5ede4b069485764de52"},{"code":"(fn [& args]\n  (let [gcd #(if (= %2 0) % (recur %2 (rem % %2)))]\n    (reduce #(/ (* % %2) (gcd % %2)) args)))","problem":100,"user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"(fn [& nums] \n  (let [m (reduce max nums)]\n  (loop [n m] \n    (if (every? #(= 0 (mod n %)) nums) n (recur (+ n m))))))","problem":100,"user":"51990df9e4b068aa333628fc"},{"problem":100,"code":"(fn [base & others]\n  (loop [res base\n         len (count others)]\n    (if (= len (count (filter #(integer? (/ res %)) others)))\n      res\n      (recur (+ res base) len)\n      )))","user":"5c0e3f86e4b01240ff56713d"},{"problem":100,"code":"(fn[& vars] \n  (reduce \n    (fn [n1 n2] \n      (/ (* n1 n2)\n         (#(let [rem (mod %1 %2)] \n            (if (= 0 rem) %2 (recur %2 rem))) n1 n2))) vars))","user":"52bc6cb2e4b07a9af57922f5"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd #(if (= %2 0) %1 (recur %2 (rem %1 %2)))]\n    (reduce (fn [x y]\n              (let [g (gcd x y)]\n                (/ (* x y) g))) nums)))","user":"54f2fe9fe4b050824f58f5b8"},{"code":"(fn [& xs] \n  (/ (apply * xs)\n     (reduce #(if (zero? %2) % (recur %2 (mod %1 %2))) xs)))","problem":100,"user":"4db2f208535df7e46ed9b6c9"},{"code":"(letfn [(min-index [coll] (apply min-key (partial nth coll) (range (count coll))))]\n  (fn lcm [& args]\n    (loop [x (vec args)]\n      (if (apply = x) (first x)\n        (let [i (min-index x)]\n          (recur (assoc x i (+ (x i) (nth args i)))))))))","problem":100,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [& xs]\n    (letfn [\n        (multiple? [m x] (zero? (rem m x)))\n        (common-multiple? [m xs] (every? #(multiple? (* m (first xs)) %) xs))\n        (find-common-multiples [ms xs] (filter #(common-multiple? % xs) ms))\n        (least-common-multiple [xs] (* (second (lazy-seq (find-common-multiples (range) xs))) (first xs)))\n    ] (least-common-multiple xs))\n)","problem":100,"user":"52cc85abe4b07d0d72b27367"},{"problem":100,"code":"(fn [& c] (reduce (fn [x y] (loop [a 1 b 1] (condp #(% %2 (* b y)) (* a x) = (* a x) < (recur (inc a) b) (recur a (inc b))))) c))","user":"5c41db45e4b08cd430848ece"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(divisible-all? [lcm xs] (every? #(= 0 (mod lcm %)) xs))]\n    (let [max_ (apply max xs)]\n      (loop [lcm max_]\n        (if (divisible-all? lcm xs)\n          lcm\n          (recur (+ lcm max_)))))))","user":"5657fed1e4b0f9d632dd84ae"},{"code":"(fn [& nums]\n  (let [smallest (first (sort nums))]\n    (loop [n smallest]\n      (if (every? #(= 0 (mod n %)) nums)\n        n\n        (recur (+ n smallest))))))","problem":100,"user":"5080a697e4b01a93d3f38e49"},{"problem":100,"code":"(fn lcm [& xs]( let [gcd (fn gcd [a b] (if (> b a ) (gcd b a)  (if (= b a) a (gcd b (- a b)))))]\n          \n          (reduce #(/ (* %1 %2) (gcd %1 %2)) (first xs) (rest xs))\n\n          ))","user":"55896a0ce4b059ccff29b204"},{"problem":100,"code":"(fn [& r]\n  (reduce \n  (fn lcm [x y]\n    (/ (* x y)\n   (apply (fn [a b]\n            (println a)\n            (if (= (rem a b) 0)\n              b\n              (recur b (rem a b))))\n            (reverse (sort (list x y))))))\n   r))","user":"53aaaf7ae4b047364c044444"},{"problem":100,"code":"(fn lcm [& vals]\n  (let [dens (->> vals (filter ratio?) (map denominator))\n        nums (concat (filter integer? vals) (->> vals (filter ratio?) (map numerator)))\n        primes '(2 3 5 7 11)\n        divide-int (fn [b a] (if (zero? (rem a b)) (/ a b) a))\n        gcd (fn [a b]\n              (cond (< a b) (recur b a)\n                    (zero? b) a\n                    :else (recur b (rem a b))))\n        lcm-table (fn [vals dividers primes]\n                    (println vals \\n dividers \\n primes)\n                    (cond\n                      (every? (partial = 1) vals)\n                      (apply * dividers)\n\n                      (some #(zero? (mod % (peek primes))) vals)\n                      (recur (map (partial divide-int (peek primes)) vals) (conj dividers (peek primes)) primes)\n\n                      :else\n                      (recur vals dividers (pop primes))))\n        lcm-nums (lcm-table nums [] primes)]\n    (if (empty? dens)\n      lcm-nums\n      (/ lcm-nums (apply gcd dens)))))","user":"5617a540e4b06b1bb2182a12"},{"problem":100,"code":"(fn [& args] \n(let [rs (reduce #(conj %1 (range %2 (java.lang.Integer/MAX_VALUE) %2)) [] args )] \n           (loop [s rs]\n             (let [m (apply max (map first s))]\n               (if (apply = (map first s))\n                 (first (first s))\n                 (recur (map #(if (<= m (first %1)) %1 (rest %1)) s)))))\n           ))","user":"5ec819b4e4b08d0ec38692e2"},{"problem":100,"code":";; this approach is naive, in that it uses the first arg instead of the greatest, and\n;; contains no optimizations\n\n(fn [& nums]\n  (let [divides-by-all? (fn [multiple]\n                          (every?\n                           #(= 0 (rem multiple %))\n                           nums))\n        increment (first nums)]\n    (loop [multiple increment]\n      (if (divides-by-all? multiple)\n        multiple\n        (recur (+ multiple increment))))))","user":"55344b75e4b09218d5f44f99"},{"code":"(fn [& xs]\n  (let [gcd (fn [x y]\n              (if (= y 0) x\n                (recur y (mod x y))))\n        lcm (fn [x y]\n              (/ (* x y) (gcd x y)))]\n    (reduce lcm xs)))","problem":100,"user":"508157b2e4b0946d0443855c"},{"problem":100,"code":"(fn [& args]\n   (let [helper (fn [x] (set (map #(* x %) (range 1 1000))) )]\n     (apply min (reduce clojure.set/intersection (map helper args ))))\n   )","user":"5ab07d63e4b073f1774425af"},{"problem":100,"code":"#(let [gcd (fn [x y]\n              (if (= 0 y)\n                x(recur y (mod x y))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) %&))","user":"4de77a0a535d08e6dec9fdfa"},{"code":"(fn [ & xs]\n  (let [multiples (map (partial * (apply min xs)) (rest (range)))]\n    (first (filter #(every? (fn [y] (zero? (mod % y))) xs) multiples))))","problem":100,"user":"52655949e4b03e8d9a4a710b"},{"problem":100,"code":"(fn lcm-multiple [& args]\n  (let [hcf (fn h [a b]\n              (if (zero? b)\n                a\n                (h b (mod a b))))\n        lcm (fn l [a b]\n              (let [an (if (ratio? a) (numerator a) a)\n                    ad (if (ratio? a) (denominator a) 1)\n                    bn (if (ratio? b) (numerator b) b)\n                    bd (if (ratio? b) (denominator b) 1)\n                    ]\n                (if (or (ratio? a) (ratio? b))\n                    (/ (l an bn) (hcf ad bd))\n                  (/ (* a b) (hcf a b)))))]\n    \n     (reduce lcm args)))","user":"5829d588e4b051871117bf4a"},{"code":"(fn [& args]\n  (let [n (first args)\n        rm (rest args)]\n    (loop [x n]\n      (if (some #(not (zero? (mod x %))) rm)\n          (recur (+ x n))\n          x))))","problem":100,"user":"509160dae4b0742c82730aef"},{"problem":100,"code":"(fn [& nums]\n    (let [skip-jack (fn [colls]\n                      (if (= 1 (count (group-by first colls)))\n                        (first (first colls))\n                        (let [biggest-smallest (reduce max (map first colls))]\n                          (recur (map #(drop-while (fn [n] (< n biggest-smallest)) %) colls)))))]\n      (skip-jack (map (fn [n] (iterate (partial + n) n)) nums))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":100,"code":"(fn [& nb]\n  (let [x1 (apply max nb)]\n    (loop [acc x1]\n      (if (every? zero? (map #(rem acc %) nb))\n        acc\n        (recur (+ acc x1))))))","user":"5a75da49e4b0512ff01cdacf"},{"code":"(fn [& args]\n    (\n\t\t(fn f1 [x, a] (let\n                        [\ty (* x (first args)) \n\t\t\t\t\t\t\tm1 (map (fn [z] (mod (/ y z) 1)) a)\n\t\t\t\t\t\t\tsum (reduce + m1)\n                        ] (if (zero? sum) y (f1 (inc x) a)) \n\t\t\t\t\t)\n\t\t) 1 args\n\t)       \n)","problem":100,"user":"5296008fe4b02ebb4ef7502a"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n          lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nums)))","user":"581e61b0e4b04b46fc4b0f28"},{"problem":100,"code":"(fn lcmv [& lst]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm lst)))","user":"5aa4f7dae4b0d174b936c88c"},{"code":"(letfn [\r\n  (gcd [a b]\r\n\t\t(if (zero? b)\r\n\t\t\ta\r\n\t\t\t(recur b (mod a b))))\r\n\t(abs [x]\r\n\t\t(if (neg? x)\r\n\t\t\t(- x)\r\n\t\t\tx))]\r\n\t\r\n\t(fn lcm [& xs]\r\n\t\t(/ (abs (apply * xs)) (reduce gcd xs))))","problem":100,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"59eb63e3e4b0249b7282077c"},{"problem":100,"code":"(fn f [& xs]\n    (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n      (/ (apply * xs)\n         (reduce gcd xs))\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"code":"(fn [x & xs]\n  (letfn [(gcd [x y]\n            (if (zero? y) x\n                (recur y (rem x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) x xs)))","problem":100,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"#(let [f (fn [a b] (loop [x a, y b]\n                      (cond (= x y) x\n                            (< x y) (recur (+ x a) y)\n                            :else (recur x (+ b y)))))] (reduce f %&))","problem":100,"user":"50563ae2e4b0ce54f56f0405"},{"problem":100,"code":"(fn [& args] \n  (let [a (apply max args)]\n    (loop [m a]\n      (if (every? #(integer? (/ m %)) args)\n        m\n        (recur (+ m a))\n       )\n     )\n   )\n )","user":"593dfe60e4b069cdc2982bb1"},{"code":"(fn my-least-common-multiple\n  [& xs]\n  (letfn [(greatest-common-divisor [x y] \n                                   (if-not (= x y)\n                                     (let [maxx (max x y) minn (min x y)]\n                                       (greatest-common-divisor (- maxx minn) minn))\n                                     x))]\n    (reduce #(/ (* %1 %2) (greatest-common-divisor %1 %2)) xs)))","problem":100,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [& more]\n     (let [lazy-multiple  (fn lazy-multiple\n                            ([base] (lazy-multiple base 2)\n                               )\n                            ([base multiple]\n                               (cons (rationalize (* base multiple)) (lazy-seq (lazy-multiple base (inc multiple)))))\n                            )\n           increment-map (fn [mapa value]\n                           (if-let [current (get mapa value)]\n                             (assoc mapa value (inc current))\n                             (assoc mapa value 1)\n                             ))\n           conj-map (fn [the-map values] (reduce increment-map the-map values))\n           is-reached (fn [the-map limit ] (if-let [exist (some (fn [it] (when (= (last it) limit) it)) the-map)]\n                                            (key exist)\n                                            nil\n                                            ))\n           ]\n\n       (loop [res (map lazy-multiple  more)\n              stock {:zz 100} ]\n         (let [values (map first res)\n               test (conj-map stock values)\n               ]\n           (if-let [result (is-reached test (count res))]\n             result\n             (recur (map next res) test )\n             ))))\n   )","problem":100,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (let [[a b] (sort [a b])]\n              (loop [x b y a]\n                (if (= (rem x y) 0)\n                  y\n                  (recur y (rem x y))))))]\n  (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5f6caa19e4b02876ed9fd056"},{"problem":100,"code":"(fn lcm [& numbers]\n  (loop [mth (apply vector numbers)]\n    (if (= (apply min mth) (apply max mth))\n      (first mth)\n      (let [min-pos (.indexOf mth (apply min mth))]\n        (recur (assoc mth min-pos (+ (nth mth min-pos) (nth numbers min-pos))))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [l (apply min nums)]\n    (loop [n 1]\n      (if (empty?\n            (remove #(and (>= (* l n) %)\n                          (= (rem (* l n) %) 0))\n                    nums))\n        (* l n)\n        (recur (inc n))))))","user":"542c026ae4b0dad94371f29a"},{"code":"#(reduce (fn [a b] \n\t     (let [gcd (fn [a b] \n\t\t\t   (cond (zero? b) a\n\t\t\t\t :else (recur b (mod a b))))]\n\t       (/ (* a b) (gcd a b)))) %&)","problem":100,"user":"4e3a9dae535deb9a81d77f4a"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (letfn [(gcd [a b]\n              (if (> a b)\n                (gcd b a)\n                (loop [x a y b]\n                  (let [m (mod x y)]\n                    (if (zero? m)\n                      y\n                      (recur y m))))))]\n     (/ (* a b) (gcd a b))))\n  ([a b & r] (apply lcm (lcm a b) r)))","user":"5f86a98be4b0649ffcda4caa"},{"problem":100,"code":"(fn lcm [& rest]\n  (let [f     (fn mult\n                ([n]\n                 (mult n 1))\n                ([n cnt]\n                 (cons (* n cnt) (lazy-seq (mult n (inc cnt))))))\n        mults (map #(into #{} (take 1000 (f %))) rest)]\n        (->> (apply clojure.set/intersection mults)\n             (apply min))))","user":"5ff8ead1e4b06df49cee14ab"},{"code":"(fn [& x]\n  (let [ gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n         lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (loop [m (first x)\n           rst (rest x)]\n      (if (empty? rst) m\n        (recur (lcm m (first rst)) (rest rst))))))","problem":100,"user":"52084f75e4b01ce6bbf31dde"},{"problem":100,"code":"#(let [l (map (fn [f] (reductions + (repeat f))) %&)]\n   (loop [i 1\n          b (->> (map (fn [x] (take i x)) l)\n                 (map set)\n                 (apply clojure.set/intersection))]\n     (if-let [c (first b)]\n       c\n       (recur (inc i)\n              (->> (map (fn [x] (take i x)) l)\n                 (map set)\n                 (apply clojure.set/intersection))))))","user":"56aed78fe4b03c432f187363"},{"code":"(fn lcm [& args]\n  (let [gcd (fn [a b]\n          (cond\n            (= a b) a\n            (> a b) (recur (- a b) b)\n            :else (recur a (- b a))))]\n    (reduce #(/ (* % %2) (gcd % %2)) args))\n  )","problem":100,"user":"513fab65e4b00f13ea1bd891"},{"code":"(fn [x & more]\n  (if (empty? more)\n    x\n    (first\n     (for [i (map #(* x %) (map inc (range)))\n           :when (every? #(zero? (mod i %)) more)]\n       i))))","problem":100,"user":"512d3304e4b040332b905b2d"},{"problem":100,"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n        (lcm [a b] (/ (* a b) (gcd a b)))]\n   #(reduce lcm %&))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":100,"code":"(fn [& v](let [gcd (fn [a b]\n      \t\t\t(if (zero? b)\n      \t\t\t\ta (recur b, (mod a b))))\n               lcm (fn [x y]\n                     (/ (* x y) (gcd x y)))]\n           (reduce lcm v)))","user":"5dab11cde4b000c986472c45"},{"problem":100,"code":"(letfn [(gcd [x y] \n          (if (= y 0) x (gcd y (mod x y))))\n        (lcm [x y]\n          (/ (* x y) (gcd x y)))]\n  (fn lcms [& xs]\n    (reduce lcm xs)))","user":"5884e807e4b0f1effa3b76a6"},{"problem":100,"code":"(fn [& nums] (let [n (first nums)\n                           others (rest nums)]\n            (loop [trial n]\n              (if (some #(not (zero? (mod trial %))) others)\n                (recur (+ trial n))\n                trial))))","user":"55cdd76ae4b0e31453f64a20"},{"problem":100,"code":"(fn [f & n]\n  (first (filter\n          (fn [m]\n            (not-any?\n             #(not= 0 %) (map #(rem m %) n)))\n          (iterate #(+ % f) f))))","user":"543be8f0e4b032a45b869337"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [x args]\n    (if (apply = x) (first x)\n      (let [least (apply min x)\n          index (.indexOf x least)\n          delta (nth args index)\n          next (map-indexed #(if (= %1 index) (+ %2 delta) %2) x)]\n        (recur next)))))","user":"531619c1e4b08068f379ed3d"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"56942970e4b0dcc4269f4118"},{"problem":100,"code":"(fn [& v] (reduce (fn [a b]\n    (letfn [(gcd [c d] \n    \t\t(if (or (= c 0) (= d 0))(+ c d)\n           \t\t(gcd d (mod c d))))]\n    \t\t\t(/ (* a b) (gcd a b)))) v))","user":"569425b6e4b0dcc4269f410e"},{"code":"(fn lcm [& xs]\n  (let [sm (first (sort xs))\n        other (next (sort xs))\n        line (iterate #(+ sm %) sm)]\n    (first (filter (fn [m] (every? #(= 0 (mod m %)) other)) line)))\n)","problem":100,"user":"4e72187b535d5021c1a8965b"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [multiples (map (fn [n] (iterate #(+ % n) n)) nums)]\n    (loop [i 1]\n      (let [multiples (map #(apply sorted-set (take i %)) multiples)\n            isec (apply clojure.set/intersection multiples)]\n        (println i \" \" isec)\n        (if (empty? isec)\n          (recur (inc i))\n          (first isec)\n          )))))","user":"5012da69e4b0c8732600222d"},{"problem":100,"code":"(fn [i1 i2 & more-i]\n  (let [is (list* i1 i2 more-i)\n        is-mults (into [] (map (fn [i] (iterate #(+ i %) i)) is))]\n    (loop [is-mults' is-mults]\n      (let [is' (map first is-mults')]\n        (if (apply = is')\n          (first is')\n          (let [min-index (first (apply min-key second (map-indexed vector is')))]\n            (recur (assoc is-mults' min-index (rest (nth is-mults' min-index))))))))))","user":"58ee84e5e4b056aecfd47dab"},{"problem":100,"code":"(fn [s & args] (reduce #(/ (* %1 %2) \n                            (loop [a %1 b %2]\n                              (if (= 0 (rem a b))\n                                b\n                                (recur b (rem a b)))))\n   (conj args s)))","user":"5f3567d6e4b0574c87022c44"},{"code":"(fn [& v]\n  (letfn [ (getN [noN] (if (ratio? noN) (numerator noN) noN) )\n           (getD [noD] (if (ratio? noD) (denominator noD) 1) )\n           (getFactors [no] \n                       (let [primes '(2 3 5 7)]\n                         (loop [fctrs #{1} R no]\n                           (if (= R 1) \n                              fctrs\n                              (if (ratio? (/ R 2))\n                                  (if (ratio? (/ R 3))\n                                    (if (ratio? (/ R 5))\n                                      (if (ratio? (/ R 7))\n                                        (recur fctrs 1)\n                                        (recur (merge fctrs 7) (/ R 7))\n                                      )\n                                      (recur (merge fctrs 5) (/ R 5))\n                                    )\n                                    (recur (merge fctrs 3) (/ R 3))\n                                  )\n                                  (recur (merge fctrs 2) (/ R 2))\n                              )\n                           )\n                         )\n                       )\n            )\n           \n           ]\n         (let [numR (apply clojure.set/union (map getFactors (map getN v) ))\n               denR (apply clojure.set/intersection (map getFactors (map getD v) ))]\n          (/ (reduce * numR) (reduce * denR))\n         )\n  )\n)","problem":100,"user":"518aec06e4b06da86c1973c2"},{"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"521dceeae4b050d5da042802"},{"code":"(fn [x & xs]\n  (first\n    (for [a (map (partial * x) (range 1 1000))\n          :when (every? zero? (map (partial mod a) xs))]\n          a)))","problem":100,"user":"4ec5d40d535d6d7199dd36b9"},{"problem":100,"code":"(fn [& x]\n  (loop [l (for [m x n [1]] [m n])]\n    (let [cur-ret (map #(apply * %) l) \n          cur-min (apply min cur-ret)]\n      (println cur-ret)\n      (println cur-min)\n      (cond\n       (apply = cur-ret) (first cur-ret)\n       :else (recur (for [tmp l] [(first tmp) (if (= (apply * tmp) cur-min) (inc (second tmp)) (second tmp))]))))))","user":"55d74e71e4b0e31453f64aa4"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (loop [c (rest args) res (first args)]\n      (if (empty? c) res (recur (rest c) (lcm res (first c)))))))","user":"5d764e52e4b02e6b30c93524"},{"code":"(fn [& args]\n  (let [x (apply max args)\nys (remove #(= % x) args)\nmultiples (fn [n] (rest (map #(* n %) (range))))]\n(loop [driver (multiples x)\nothers (map multiples ys)]\n(if (every? #(= (first driver) %) (map first others))\n(first driver)\n(recur\n  (rest driver)\n(map (fn [s]\n  (drop-while (fn [x] (< x (second driver))) s)) others\n))))))","problem":100,"user":"4fca2a13e4b0ee37620e184d"},{"code":"(fn [& seq]\n  (let [gcd (fn gcd [a b] (cond (= a b) a\n                                (< a b) (gcd a (- b a))\n                                (> a b) (gcd (- a b) b)))\n        abs (fn [x] (if (< x 0) (- x) x))\n        lcm (fn [a b] (/ (abs (* a b)) (gcd a b)))]\n    (reduce lcm seq)))","problem":100,"user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn [& xs]\n   (letfn [(lcm [args]\n             (letfn [(gcd [a b]\n                       (if (= a b) a\n                           (if (> a b)\n                             (recur (- a b) b)\n                             (recur a (- b a)))))]\n               (reduce #(/ (* %1 %2) (gcd %1 %2)) (first args) (rest args))))\n           (lcm-ratio [args]\n             (let [lcm-denom (lcm (map denominator args))\n                   new-ratios (map\n                               #(* (numerator %) (/ lcm-denom (denominator %)))\n                               args)]\n               (/ (lcm new-ratios) lcm-denom)))]\n     (let [ints (get (group-by ratio? xs) false)\n           ratios (get (group-by ratio? xs) true)]\n       (lcm (remove nil? (into (into [] ratios) ints))))))","problem":100,"user":"513d121fe4b0e544971636a2"},{"problem":100,"code":"(fn  lcm ([ x]  x)\n     ([x y] \n      (loop [z x w y]\n        (if (zero? w)\n          (/ (* x y) z)\n          (recur w (rem z w))\n          )))\n     ([ x y & args]\n      (reduce lcm (lcm x y) args))\n  )","user":"5cbd5b42e4b026601754b9f6"},{"problem":100,"code":"(fn [& nums]    \n  (loop [n nums]    \n    (if (apply = n) (first n)    \n      (let [ind     (.indexOf n (apply min n))    \n            newval  (+ (nth nums ind) (nth n ind))    \n            updated (assoc (vec n) ind newval)]    \n        (recur updated)))))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(let \n  [gcd (fn gcd [a b]\n  \"4clojure.com/problem/66\"\n  (let [x (min a b)\n        y (max a b)]\n    (loop [x x\n           y y]\n      (if (= (mod x y) 0)\n        y\n        (recur y (mod x y))))))\nlcm (fn lcm [x y]\n  (/ (* x y) (gcd x y)))]\n\n(fn lcm-args [& args]\n  (reduce lcm args )))","problem":100,"user":"4db58ccb535d87e67b28fe10"},{"problem":100,"code":"(fn lcm [& nums]\n  (reduce (fn [a b] (/ (* a b) ((fn gcd\n  [a b]\n  (cond\n   (or (= 0 a) (= 0 b)) 0\n   ( = a b) a\n   (> a b) (recur (- a b) b)\n   :else (recur a (- b a)))) a b))) nums))","user":"592518e8e4b072a2710fce67"},{"problem":100,"code":"(fn [& ns] \n  (letfn \n    [(gcd [x y] (if (zero? y) x (recur y (mod x y))))\n     (lcm-inner [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm-inner ns)))","user":"57b4779de4b0fbc9809a279a"},{"code":"(fn [& s]\n  (let [abs #(if (neg? %) (- %) %)\n        gcd #(if (zero? %2) % (recur %2 (mod % %2)))\n        lcm #(* %2 (quot % (gcd % %2)))]\n    (reduce lcm s)))","problem":100,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":100,"code":"(let [gcd (fn [a b]\n            (if (zero? b)\n              a\n              (recur b, (mod a b))))\n      lcm (fn [a b] (/ (* a b) (gcd a b)))]\n  (fn [& nums]\n    (reduce lcm nums)))","user":"540a4f20e4b0addc1aec66ef"},{"problem":100,"code":"(fn [& v]\n  (/ (reduce * v)\n     (reduce #(loop [a %1 b %2] (if (zero? b) a (recur b (mod a b)))) v)))","user":"5aeca4c9e4b0cc2b61a3bc0a"},{"problem":100,"code":"(fn [& args] \n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))\n          (lcm [x y] (/ (* x y) (gcd x y)))]    \n    (reduce lcm args)))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"(fn f [& args]\n   (letfn [(numer [x] (if (ratio? x) (numerator x) x))\n           (denom [x] (if (ratio? x) (denominator x) 1))\n           (gcd   [a b] (if (= b 0) a (recur b (mod a b))))\n           (mgcd  [ns]\n             (let [[a b & more] ns]\n               (if more\n                 (gcd (mgcd (rest ns)) a)\n                 (gcd a b))))\n           (lcm [a b] (/ (* a b) (gcd a b)))\n           (mlcm [ns]\n             (let [[a b & more] ns]\n               (lcm (if more (mlcm (rest ns)) b) a)))]\n     (let [common (apply * (map denom args))\n           noms (map (fn [x] (* (numer x) (/ common (denom x)))) args)]\n       (/ (mlcm noms) common))))","problem":100,"user":"4fc8c8d8e4b0ee37620e183b"},{"problem":100,"code":"(fn [& m]\n  (let [mul (apply min m)\n        muls (iterate #(+ mul %) mul)]\n    (first\n     (filter\n      (fn [n] (every? zero? (map #(rem n %) m)))\n      muls))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"#(reduce (fn [a b]\r\n           (* (/ a ((fn gcd [k m]\r\n                      (if (zero? m) k (gcd m (mod k m)))) a b)) b)) %&)","problem":100,"user":"505dd5c4e4b0e6aca564be0e"},{"code":"(fn [& args]\n  (reduce (fn [a b]\n    (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n      (/ (* a b) (gcd a b)))) args))","problem":100,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n            (if (= b 0) a\n                (recur b (rem a b))))]\n    (reduce #(/ (* % %2) (gcd % %2)) xs)))","problem":100,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":100,"code":"(fn [& c]\n  ((fn [[[a b] & r]]\n      (if (every? (comp (partial = a) first) r)\n        a\n        (recur (sort-by first (cons [(+ a b) b] r)))))\n   (sort-by first (map vector c c))))","user":"56b2573ce4b0982f16b37e02"},{"problem":100,"code":"(fn lcm2\n\t([x y] (/ (* x y) ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) x y)))\n\t([x y & rest] (apply lcm2 (lcm2 x y) rest)))","user":"5ba947bfe4b0a20761a23440"},{"problem":100,"code":"(fn [& nums]\n  ((fn [v a]\n      (if (apply = a)\n        (first a)\n        (let [mi (first (apply min-key second (map-indexed list a)))]\n          (recur v (assoc a mi (+ (get a mi) (get v mi))))\n          ))\n      ) (vec nums) (vec nums)\n    ))","user":"5d52bf29e4b0776584bd6f69"},{"code":"(fn lcm [& l]\n  (let\n    [gcd (fn gcd [x y]\n           (if (> y x) (gcd y x)\n            (if (zero? y) x\n              (gcd y (mod x y)))))\n     den (fn [x]\n       (if (integer?  x) 1\n           (denominator x)))\n       lcm2 (fn lcm2 [x y]\n         (let [m (* (den x) (den y))\n               x1 (* m x) y1 (* m y)]\n        (/ (* x1 y1) m (gcd x1 y1))))]\n   (reduce lcm2 l)))","problem":100,"user":"4f04a06d535dcb61093f6bd9"},{"code":"(fn lcm_mult [& coll]\r\n  (reduce (fn lcm [x y]\r\n  (/ (* x y)\r\n     ((fn gcd [a b] \r\n      (if (= a b) \r\n        a\r\n        (if (> a b)\r\n          (gcd b (- a b))\r\n          (gcd b a)))) x y))) coll))","problem":100,"user":"4e123905535d04ed9115e7ce"},{"problem":100,"code":"(fn [& args] (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))] (/ (apply * args) (reduce gcd args))))","user":"57c7e7d9e4b05aa3c4741d0f"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd [x y] (if (= (* x y) 0) (+ x y) (gcd (- (max x y) (min x y)) (min x y))))]\n    (if (= (count nums) 2) (/ (* (first nums) (second nums)) (gcd (first nums) (second nums)))\n      (lcm (first nums) (apply lcm (rest nums))))))","problem":100,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn lcm [& vals]\r\n    (letfn [(all-div? [x xs] (if (every? #(= 0 (mod x %)) xs) x))]\r\n      (let [x (first vals)\r\n            r (rest vals)]\r\n        (some #(all-div? (* x %) r) (range 1 100)))))","problem":100,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn lcm [& args]\n  (let [gcd (fn [a b] \n              (if (= b 0)\n                a\n                (recur b (mod a b))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b)))\n            args)))","problem":100,"user":"50d86fe2e4b01f0871336e67"},{"code":"(fn [& args] \n  (letfn [(ppcm [A B]\n    (/ (* A B) (loop [n A r B] (if (= r 0) n (recur r (mod n r))))))]\n    (reduce ppcm args)))","problem":100,"user":"4ed27f9f535d44c135fd68d5"},{"code":"(fn [& coll]\n  (loop [step coll]\n    (if (apply = step)\n      (first step)\n      (recur (map #(if (= % (apply min step)) (+ % %2) %) step coll)))))","problem":100,"user":"52d809bde4b09f7907dd1384"},{"problem":100,"code":"(fn lcmred\n  [x & y]\n  (let [cob (fn cobalcm\n              [x y]\n              (let [gcd (fn gcd [b c]\n                          (cond\n                            (zero? b) c\n                            (zero? c) b\n                            :else (recur c (mod b c))))]\n                (/ (* x y) (gcd x y))))]\n    (reduce cob x y)))","user":"55d9743ae4b0e31453f64aca"},{"code":"(fn [& x]\n  (let [\n    gcd (fn f [x y] (if (= y 0) x (f y (mod x y))))\n    lcm (fn f [x y] (/ (* x y) (gcd x y)))\n    rcm (fn f [x y] [(lcm (first x) (first y))\n                     (gcd (second x) (second y))])\n    tpr (fn f [x] (if (integer? x) \n                    [x 1]\n                    [(numerator x) (denominator x)]))\n    vals (map tpr x)\n    pair (reduce rcm vals)]\n    (apply / pair)))","problem":100,"user":"4ec07699535dfed6da9c6da2"},{"problem":100,"code":"(fn [& nums]\n  (let [\n      gcd\n      (fn gcd [p q]\n        (let [t (rem p q)]\n          (if (= 0 t)\n            q\n            (gcd q t)\n          )\n        )\n      )]\n    (/ (apply * nums) (reduce gcd nums))\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"code":"(fn [& args]\n  \n  (reduce (fn [x y]\n    (/ (* x y) ((fn gcd [p q] \n        (if (= q 0) p\n            (gcd q (mod p q)))\n     ) x y))\n  ) args)\n\n)","problem":100,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":100,"code":"(fn [& nums]\n (let [m (apply max nums)]\n  (loop [x m]\n   (if (not= 0 (apply + (map #(mod x %) nums)))\n     (recur (+ m x))\n     x))))","user":"590b8607e4b047aa04b199db"},{"problem":100,"code":"(fn [& args]\n  (letfn [\n    (gcd [a b]\n      (if (zero? b) a (recur b (mod a b))))\n    (lcm [x y]\n      (/ (* x y) (gcd x y)))]\n    (reduce lcm args)\n  )\n)","user":"554707bae4b0a04f79299544"},{"code":"(fn [& numbers]\n  (letfn [(gcd [n others]\n            (if (empty? others)\n                n\n                (let [r (rem n (first others))]\n                  (recur (first others)\n                         (if (= 0 r)\n                           (rest others)\n                           (cons r (rest others)))))))]\n    (/ (apply * numbers) (gcd (first numbers) (rest numbers)))))","problem":100,"user":"4e7c8fd1535db169f9c796be"},{"problem":100,"code":"(fn [& args] (letfn [(gcd [x y]\n               (let [l (min x y)\n                     u (max x y)\n                     r (mod u l)]\n                 (if (zero? r)\n                   l\n                   (recur r l))))\n          (lcm [x y]\n               (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"56949fc5e4b0dcc4269f4120"},{"code":"(fn lcm\n  [& args]\n  (let* [gcd2 (fn [a b]\n                (cond (> b a) (recur b a)\n                      (= b 0) a\n                      :else   (recur b (rem a b))))\n         gcd  (fn [& args]\n                (reduce gcd2 args))]\n    (/ (apply * args) (apply gcd args))))","problem":100,"user":"511b233ae4b07ab9ec456180"},{"problem":100,"code":"(fn [& n] (/ (apply * n) (reduce (fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) n)))","user":"5776385fe4b0979f89651632"},{"problem":100,"code":"(fn lgcd [a b & q]\n  (let [pgcd (fn [a b]\n               (if  (= 0 b) a\n                 (recur b (rem a b))))\n        res (/ (* a b) (pgcd a b))]\n    (if (empty? q) res (recur res (first q) (rest q)))))","user":"57642916e4b0994c1922fbee"},{"problem":100,"code":"(fn\n    [& xs]\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (/ (reduce * xs) (reduce #(gcd %1 %2) (first xs) xs))))","user":"507e68abe4b085af06e3afd2"},{"problem":100,"code":"(fn leastMultiple\n  [& x]\n  (letfn [(y [a b]\n               (if (= b 0)\n                 a\n                 (recur b (mod a b))))\n          (z [a b]\n               (/ (* a b) (y a b)))]\n    (reduce z x)))","user":"59dd3930e4b0a0ac046f2504"},{"problem":100,"code":"(fn [& args]\n    (letfn [(gcd [a b]\n                (if (= b 0)\n                  a\n                  (gcd b (mod a b))))\n          (lcm [a b]\n                (/ (* a b) (gcd a b)))]\n      (reduce lcm args)))","user":"532f8569e4b019098a6f8b4f"},{"problem":100,"code":"(fn\n  [& a]\n  (letfn [(gcd [m n]\n            (if (= (mod m n) 0)\n              n\n              (gcd n (mod m n))))]\n    (/ (apply * a) (reduce gcd a))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(let [multiples (fn multiples\n                  ([n] (multiples n n))\n                  ([n m] (cons (+ n m) (lazy-seq (multiples n (+ n m))))))\n      lcm (fn lcm [multiples-list]\n            (if (apply = (map first multiples-list))\n              ((comp first first) multiples-list)\n              (lcm ((fn [[[mult-1] [& rest-mults]]]\n                      (cons (rest mult-1) rest-mults))\n                    (split-at 1 (sort-by first multiples-list))))))]\n  #(lcm (map multiples %&)))","problem":100,"user":"510acd6ee4b078ea719210f4"},{"problem":100,"code":"(fn lcm [& coll]\n    (letfn [(gcd [a b]\n              (if (= b 0) a (recur b (rem a b))))]\n      (/  (reduce * coll) (reduce gcd coll))))","user":"5433a07be4b0b6b47310fce0"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n      lcm (fn [a b]\n            (/ (* a b) (gcd a b)))]\n  (reduce lcm xs)))","user":"56c21eafe4b05cc29241ee7e"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (letfn [(gcd [a b]\n             (cond\n               (== a b) a\n               (< a b) (recur b a)\n               :else (recur b (- a b))))]\n     (/ (* a b) (gcd a b))))\n  ([a b & more] (reduce lcm (lcm a b) more)))","user":"5f300f28e4b033932238a682"},{"code":"(fn lcm [& args ]\n  (letfn [\n          (lcm2 [n1 n2]\n            (cond\n             (and (ratio? n1) (ratio? n2)) (let [lcmd (lcm2 (denominator n1) (denominator n2))\n                                                 lcmd1 (/ lcmd (denominator n1))\n                                                 lcmd2 (/ lcmd (denominator n2))\n                                                 lcmn (lcm2 (* lcmd1 (numerator n1)) (* lcmd2 (numerator n2)))]\n                                             (/ lcmn lcmd))\n             (and (ratio? n1) (not (ratio? n2))) (/ (lcm2 (numerator n1) (* (denominator n1) n2))\n                                                    (denominator n1)\n                                                    )\n             (and (ratio? n2) (not (ratio? n1))) (/ (lcm2 (numerator n2) (* (denominator n2) n1))\n                                                    (denominator n2)\n                                                    )\n             :else\n             ;;(print (/ (* n1 n2) (gcd n1 n2)))\n             (/ (* n1 n2) (gcd n1 n2))) )\n          (gcd [x1 y1]\n  (loop [x x1 y y1]\n    (let [[x y] (if(> x y) [x y] [y x])]\n      (cond\n       (= y 0) x\n       (= y 1) y\n       :else (recur y (rem x y))))) )]\n    (reduce lcm2 args)))","problem":100,"user":"52140b53e4b0961f15ac4d7e"},{"problem":100,"code":"(fn [& xs]\n  (/ (apply * xs)\n     (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) xs)))","user":"57b19fa1e4b0fbc9809a2754"},{"code":"(fn [& numbers]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce #(lcm %1 %2) numbers)))","problem":100,"user":"51ce1320e4b0e42293a22551"},{"problem":100,"code":"(fn [& nums] (let [gcd (fn [a b] (if (= a b) a (recur (min a b) (- (max a b) (min a b)))))\n       lcm (fn [a b] (/ (* a b) (gcd a b)))]\n\t(reduce lcm nums)))","user":"53e19461e4b0d874e779ae59"},{"problem":100,"code":"(fn lcm [h & t] \n  (let [gcd #(loop [a %1 b %2] (if (= 0 b) a (recur b (rem a b))))]\n    (reduce #(/ (* % %2) (gcd % %2)) h t)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))\n    )\n  )","user":"5a99b848e4b0d174b936c7ac"},{"code":"(fn\r\n  [& args]\r\n  (let [gcd (fn gcd\r\n              [a b]\r\n              (if (= b 0)\r\n                  a\r\n                  (recur b (mod a b))))]\r\n    (reduce \r\n      (fn [r e] (* (/ r (gcd r e)) e)) \r\n      args)))","problem":100,"user":"4fee04a0e4b0678c553fc308"},{"problem":100,"code":"(fn lcm [& col]\n (letfn [(gcd [m n]\n          (loop [x (max m n) y (min m n)](print x y)\n           (if-not (zero? (mod x y))\n            (recur y (mod x y)) y)))]\n  (reduce (fn [a b] (/ (* a b) (gcd a b))) col)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn f [& src]\n  ((fn [step src]\n    (let [ratios (filter #(not (integer? %)) src)]\n            (if (empty? ratios)\n                (loop [sum step]\n                  (if (contains? (set (map #(integer? (/ sum %)) src)) false)\n                      (recur (+ sum step))\n                    (* step sum)))\n              (let [de (reduce * (map denominator ratios))]\n                (recur (/ 1 de) (map (partial * de) src))))))1 src))","problem":100,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [n & nums]\n (first \n  (filter\n   (fn [m]\n    (every? \n     #(zero? (rem m %)) nums))\n    (iterate #(+ % n) n))))","problem":100,"user":"5041b3c0e4b06d8231e4facf"},{"problem":100,"code":"(fn [& x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [c d]\n            (/ (* c d) (gcd c d)))]\n    (reduce lcm x)))","user":"52474133e4b05ef8e38e635e"},{"problem":100,"code":"(fn leastCommonMultiple\n  [& args]\n  (loop [x 1]\n    (if (every? #(= 0 (mod x %)) args)\n      x\n      (recur (+ x 1/10)))))","user":"56fe2a2fe4b08d47c97781ad"},{"problem":100,"code":"(fn \n  [& elems]\n  (let [indices (zipmap (range) elems)]\n    (loop [v elems]\n      (if (> (count (distinct v)) 1)\n        (recur (assoc (vec v) (.indexOf v (apply min v)) (+ (apply min v) (get indices (.indexOf v (apply min v))))))\n        (first v))\n      )))","user":"5772ddb0e4b0979f896515d4"},{"code":"(fn [& args]\n    (letfn [(gcd2 [a b]\n              (if (= b 0)\n                a\n                (gcd2 b (rem a b))))\n            (gcd [& arguments]\n                 (reduce #(gcd2 % %2) arguments)\n                 )]\n      (/ (apply * args) (apply gcd args))))","problem":100,"user":"525ed5f4e4b0cb4875a45db8"},{"problem":100,"code":"(fn [& xs]\n    (reduce (fn [a b]\n                (let [a_r (clojure.lang.Numbers/toRatio a)\n                      b_r (clojure.lang.Numbers/toRatio b)\n                      n_a_r (numerator a_r)\n                      d_a_r (denominator a_r)\n                      n_b_r (numerator b_r)\n                      d_b_r (denominator b_r)\n                      t_1 (* n_a_r d_b_r)\n                      t_2 (* n_b_r d_a_r)\n                      t_3 (* d_a_r d_b_r)\n                      lcm (/ (/ (* t_1 t_2) ((fn gcd [c d]\n                                                     (if (> c d)\n                                                         (gcd d c)\n                                                         (if (= 0 c)\n                                                             d\n                                                             (gcd (rem d c) c)))) t_1 t_2)) t_3)]\n                     lcm)) xs))","user":"5a34f342e4b0ddc586f153d1"},{"problem":100,"code":"(fn [& nums]\n  (if (empty? nums)\n    nil\n    (let [n (first nums)\n          others (rest nums)]\n      (loop [trial n]\n        (if (some #(not (zero? (mod trial %))) others)\n          (recur (+ trial n))\n          trial)))))","user":"4ee7d6d8535d93acb0a66870"},{"code":"(fn [& more]\n  (let [multiples (map #(set (range % 1000 %)) more)]\n      (apply min (apply clojure.set/intersection multiples))))","problem":100,"user":"4faac363e4b081705acca200"},{"code":"(fn [& s]\n  (reduce #(/ (* %1 %2)\n     ((fn [a b]\n        (if (= 0 b)\n            a\n            (recur b (mod a b)))) %1 %2)) s))","problem":100,"user":"50acbd15e4b071b89ef26234"},{"code":"(fn [& numbers]\n  (let [\n        gcd (fn [x y]\n   (cond\n    (= x y) x\n    (> x y) (recur (- x y) y)\n    :else (recur (- y x) x)))\n        mul (apply * numbers)]\n    (/ mul (reduce gcd numbers))))","problem":100,"user":"5094057fe4b097f48cc38593"},{"code":"(fn [& xs]\n  (/ (reduce * xs)(reduce  #(if (zero? %2) %1 (recur %2 (mod %1 %2))) xs)))","problem":100,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":100,"code":"(fn [e & r]\n  ((fn f [p]\n     (if (every? #(= (mod p %) 0) r)\n       p\n       (recur (+ p e))))\n   e))","user":"57fbf995e4b0d3187e900981"},{"problem":100,"code":"(fn lcm \n  [& args] \n  (let [gcd \n        (fn gcd\n  [a b]\n  (cond \n    (= a b) a\n    (> a b) (gcd (- a b) b)\n    :else   (gcd a (- b a))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"56df7440e4b0ca2494a095fb"},{"code":"(fn [& args]\r\n (let [l (dec (count args))]\r\n  (loop [n 1\r\n         m 0\r\n         a {}]\r\n    (let [x (* (nth args m) n)\r\n          v (a x)]\r\n      (if (= v l)\r\n        x\r\n        (recur (if (= m l) (inc n) n)\r\n               (if (= m l) 0 (inc m))\r\n               (if (a x) (assoc a x (inc (a x)))\r\n                         (assoc a x 1))))))))","problem":100,"user":"4dbe68c7535d020aff1edf5e"},{"problem":100,"code":"(fn lcm [a b & rest]\n    (if rest\n      (apply lcm (conj rest (lcm a b)))\n      (let \n        [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n        (/ (* a b) (gcd a b)))))","user":"5bf1b957e4b0a6d31fed216f"},{"problem":100,"code":"(fn LCM [& n]\n  (letfn [\n          (gcd [a b]          ;;; hacemos una funcion greatest common divisor\n               (if (= b 0)\n                 a\n                 (recur b (mod a b))))\n          \n          (lcm [a b]\n               (/ (* a b) (gcd a b))) ;;;llamamos gcd aqui mismo \n          ]\n    (reduce lcm n))) ;;; usamos reduce para buscar","user":"6075c214e4b069485764de5b"},{"code":"(fn [& as] \n  (let [\n      gcd (fn [a b] (if (= 0 b) a (recur b (mod a b))))\n      lcm (fn [a b] (/ (* a b) (gcd a b)))\n  ] (reduce lcm as)))","problem":100,"user":"4ef41f26535dced4c769f230"},{"code":"(fn [& nums]\n\t(let [gcd (fn g [a b] (if (zero? b) a (g b (mod a b))))\n\t\t\t\tlcm-pair (fn [x y] (/ (* x y) (gcd x y)))]\n\t\t(reduce (fn [x y] (lcm-pair x y)) nums)))","problem":100,"user":"5201ff99e4b0b2e020a18f26"},{"problem":100,"code":"(fn [& nums] (reduce (fn [a b] (first (filter (fn [x] (= 0 (mod x b))) (iterate #(+ a %) a)))) nums))","user":"5e471203e4b043cd24807a2a"},{"code":"(fn [& xs]\n  (loop [x (first xs)]\n    (if (every? #(zero? (rem x %)) xs) x\n      (recur (+ x (first xs))))))","problem":100,"user":"5145832be4b0e8879607340a"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(gdc [a b]\n            (cond\n              (= a b) b\n              (> a b) (gdc (- a b) b)\n              :else (gdc a (- b a))))]\n    (reduce #(/ (* % %2) (gdc % %2)) nums)))","user":"4faf97d8e4b081705acca258"},{"problem":100,"code":"(fn [& xs]\n       (let [init (into {} (map-indexed (fn [idx itm] [idx itm]) xs))\n             min-idx (fn [m] (-> (sort-by second (seq m))\n                                 first\n                                 first))\n             inc-min (fn [m] \n                       (let [i (min-idx m)]\n                         (update-in m [i] + (get init i))))]\n         (loop [cur-vals init]\n           (if (apply = (vals cur-vals))\n             (first (vals cur-vals))\n             (recur (inc-min cur-vals))))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":100,"code":"(fn [& nums]\n  (loop [i (apply min nums)]\n    (if (every? identity\n              (map #(= 0 (mod i %))\n                   nums))\n      i\n      (recur (+ (apply min nums) i)))))","user":"554bd33ce4b0a04f7929959a"},{"problem":100,"code":"(fn lcm [& nums]\n  (let\n    [gcd\n     (fn gcd [a b]\n       (if (zero? b)\n         a\n         (gcd b (mod a b))))]\n      (reduce #(* (/ %1 (gcd %1 %2)) %2) nums)))","user":"5a99b863e4b0d174b936c7ae"},{"problem":100,"code":"(letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))                                                                            \n        (lcm [a b] (/ (* a b) (gcd a b)))]                                                                                                              \n    #(reduce lcm %&))","user":"558b50d5e4b027778923762b"},{"problem":100,"code":"(fn bar [& nums]\n  (loop [x (apply max nums)]\n    (if (every? #(integer? (/ x %)) nums) x\n        (recur (+ x (apply max nums))))))","user":"58303fc3e4b051871117c006"},{"problem":100,"code":"(fn ppcm [& els]\n  (let [pgcd (fn [a b] (loop [a a b b] (if (= b 0) a (recur b (rem a b)))))]\n    (if (= (count els) 2)\n      (/ (* (nth els 0) (nth els 1)) (pgcd (nth els 0) (nth els 1)))\n      (ppcm (first els) (apply ppcm (rest els))))))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(fn [& c]\n    (reduce\n    #(/ (* % %2)\n      (loop [a %\n             b %2]\n        (cond\n          (= a b) a\n          (> a b) (recur (- a b) b)\n          :else (recur a (- b a)))))\n    c))","problem":100,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":100,"code":"(fn [& x]\n  (let [n (reduce * (map #(if (ratio? %) (denominator %) 1) x))]\n    (loop [i 1, r 1]\n      (if (= r 0)\n        (/ (dec i) n)\n        (recur (inc i) (reduce + (map #(rem i %) (map #(* n %) x))))))))","user":"58cff8b0e4b03c36ff7e58c0"},{"code":"(fn fn100\n  ([x y] \n    (letfn [(gcd [a b]\n\t\t    (cond\n \t\t      (= b 0) a\n \t\t      (> a b) (gcd b (mod a b))\n \t\t      (> b a) (gcd a (mod b a))))\n     \t   ]\n  \t\t   (/ (* x y) (gcd x y))))\n \n  ([x y & rest] (apply fn100 (fn100 x y) rest))\n)","problem":100,"user":"5029f263e4b023940c84aa45"},{"problem":100,"code":"(fn [& ns]\n  (letfn [(take-up-to [n s]\n            (if (and (seq s) (>= (first s) n))\n              s\n              (take-up-to n (next s))))]\n    (loop [seqs (map #(iterate (partial + %) %) ns)]\n      (let [fs (map first seqs)\n            mf (apply max fs)]\n        (if (apply = fs)\n          (first fs)\n          (recur (map (partial take-up-to mf) seqs)))))))","user":"5dc72a9ce4b02f9375f4e1cd"},{"problem":100,"code":"(fn lcm\n  [& nums]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * nums) (reduce gcd nums))))","user":"59e8fef3e4b0249b72820743"},{"problem":100,"code":"(fn lcm [& numbers]\n  ((fn iter [increments]\n    (let [sorted-increments (into (sorted-map-by #(compare [(get increments %1) %1]\n                                                           [(get increments %2) %2]))\n                             increments)\n          values (into (sorted-set) (vals sorted-increments))\n          smallest (first sorted-increments)]\n      (if (= 1 (count values))\n          (val smallest)\n          (recur (assoc increments (key smallest) (+ (key smallest) (val smallest)))))))\n   (zipmap numbers numbers)))","user":"57e9a77ae4b0bfb2137f5b35"},{"problem":100,"code":"(fn [& a]\n  (let [c (fn _ [R S] (let [[a & c] R [b & d] S]\n                        (cond (= a b) (cons a (lazy-seq (_ c d)))\n                              (< a b) (_ c S)\n                              :else (_ R d))))]\n  (->> a\n       (map (fn [r] (map #(* r %) (range))))\n       (reduce c)\n       (second))))","user":"559c13c5e4b066d22e731f61"},{"code":"(fn lcm\n  ([x y] (let [gcd (loop [x x\n                          y y]\n                     (cond\n                      (= x y) x\n                      (> x y) (recur (- x y) y)\n                      :else (recur x (- y x))))]\n           (/ (* x y) gcd)))\n  ([x y & more] (reduce lcm (lcm x y) more)))","problem":100,"user":"519db0ede4b037b32803f9b9"},{"code":"(fn lcm[& nums] \n  (/ (reduce * nums) \n     (reduce (fn gcd[a b] \n        (if (zero? b) a (gcd b (mod a b)))) nums)))","problem":100,"user":"53733312e4b06d7f452d9e0a"},{"code":"(fn lcm [& values]\n  (letfn [( gcd [a b]\n            (loop [aa a bb b]\n              (if (= bb 0)\n                aa\n                (recur bb (mod aa bb)))))]\n    (reduce #(* (/ %1 (gcd %1 %2)) %2) values)))","problem":100,"user":"4f68c485e4b07046d9f4ef7c"},{"code":"(fn [& p]\n(some \n #(if \n    (every? \n     (fn [x] (integer? (/ (* % (first p)) x))) p) \n    (* % (first p))\n    nil) (iterate inc 1))\n  )","problem":100,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn [& xs] ({2 6 5 105 1/3 2 3/4 3/2 7 210} (first xs)))","problem":100,"user":"52a88c4de4b0c58976d9ac30"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [m (apply min xs)]\n    (loop [mult (apply min xs)]\n      (if (every? #((complement ratio?) (/ mult %)) xs)\n        mult\n        (recur (+ mult m))))))","user":"5a257747e4b07f18be40aa1f"},{"problem":100,"code":"(fn lcm\n  [& ns]\n  (loop [ms ns]\n    (if (apply = ms)\n      (first ms)\n      (let [m (apply min ms)\n            incs (map #(if (= m %2) %1 0) ns ms)]\n        (recur (map + incs ms))))))","user":"5609d328e4b05f002753deee"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))\n          (lcm [a b]\n            (* (/ a (gcd a b)) b))]\n    (reduce lcm xs)))","user":"55c4e48be4b0e31453f649a7"},{"problem":100,"code":"(fn least-common-multiple [& args]\n             (let [multis (fn [x]\n                            (map #(* x %) (iterate inc 1)))\n                   can-divide? (fn [x y]\n                                 (= 0 (mod x y)))\n                   can-divide-multis? (fn [value divs]\n                                        (every? #(can-divide? value %) divs))]\n               (first (filter #(can-divide-multis? % (rest args)) (multis (first args))))))","user":"541f89a5e4b01498b1a71a99"},{"problem":100,"code":"(fn [ & l]\n  (loop [n (apply max l) s n]\n    (if (every? #(= (mod n %) 0) l)\n      n\n      (recur (+ n s) s))))","user":"57d9f603e4b0bd073c20240a"},{"problem":100,"code":"(fn [& args] \n    (reduce #(/ (* % %2) ((fn [x y]\n                           (if (= y 0)\n                             x\n                             (recur y (mod x y)))) % %2)) args))","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn [& args]\n  (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))]\n    (/ (apply * args) (reduce gcd args))\n    )\n  )","problem":100,"user":"52e59ca5e4b09f7907dd1464"},{"problem":100,"code":"(fn[a & b]\n   (->> (map #(* a %) (rest (range)))\n        (filter (fn[x]\n                  (every? zero? (map #(mod x %) b ))\n                  ))\n        first\n        ))","user":"53ed2fafe4b0d648e757f4c1"},{"problem":100,"code":"(fn [& r]\n\t(reduce #(/ (* %1 %2) (loop [i1 %1 i2 %2] (if (zero? i2) i1 (recur i2 (mod i1 i2))))) r))","user":"57d0e185e4b0bd073c202360"},{"problem":100,"code":"(fn [& v]\n  (reduce (fn [a b]\n  (/ (* a b)\n     ((fn [a b] \n        (if (zero? b) a (recur b, (mod a b)))) \n      a b))) v))","user":"5683d2a9e4b0945ebc182aa0"},{"problem":100,"code":"(fn [& s]\n  (let [gcd_two (fn [a b]\n           (let [big (max a b) small (min a b)]\n             (if (= small 0)\n               big\n               (recur (mod big small) small))))\n        gcd (fn [nums] (reduce gcd_two nums))\n        lcm_int (fn [nums] (/ (reduce * nums) (gcd nums)))\n        num (->> s (map (fn [x] (clojure.lang.Numbers/toRatio x))) (map numerator) (lcm_int))\n        den (->> s (map (fn [x] (clojure.lang.Numbers/toRatio x))) (map denominator) (gcd))]\n    (/ num den)))","user":"577629abe4b0979f8965162e"},{"problem":100,"code":"(fn [& x]\n    (let [gcd (fn g [x y]\n                (if (zero? y)\n                  x\n                  (g y (rem x y))))]\n      (/ (apply * x) (reduce gcd x))))","user":"4e837808535db62dc21a62d9"},{"problem":100,"code":"(fn [& args]\n(let [mx (apply max args)]\n  (->> (range mx 500 mx)\n       (filter (fn [x] (every? #(zero? (mod x %)) args)))\n       (first))))","user":"59f15e20e4b0966464fe6a5a"},{"problem":100,"code":"(fn lcm [x & xs] (first (for [p (iterate #(+ % x) x) :when (every? #(= 0 (mod p %)) xs)] p)))","user":"54d70f40e4b0a52adc2e2027"},{"code":"(fn[f & r] (first (filter (fn[m] (every? #(= 0 (mod m %)) r)) (iterate (partial + f) f))))","problem":100,"user":"5093ca51e4b097f48cc38585"},{"problem":100,"code":"(fn [& v]                                                                                                                                                                     \n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))                                                                                                                           \n          (lcm [a b] (/ (* a b) (gcd a b)))]                                                                                                                                         \n     (reduce lcm v)))","user":"54b6c24be4b0ed20f4ff6e7c"},{"code":"(fn [& ls] (first\r\n    (filter \r\n      (fn [i] \r\n        (every? identity \r\n          (map #(= 0 (rem i %)) ls)\r\n        ))\r\n      (iterate #(+ (apply max ls) %) (apply max ls)))))","problem":100,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [& nums]\n  (letfn [(gcd2 [m n] (if (zero? n) m (recur n (mod m n))))\n          (lcm2 [m n] (/ (* m n) (gcd2 m n) ) ) \n          (lcmn [s l] (if (empty? s) l (recur (-> s next) (-> s first (lcm2 l) )  )  ) ) ]\n    (lcmn (rest nums) (first nums))   ))","problem":100,"user":"51729002e4b044b2ef48a850"},{"code":"(fn \n  [& args] \n  (second \n   (for [x (range 0 1000 (apply min args)) :when (every? zero? (map #(mod x %) args))] x)))","problem":100,"user":"51f13b80e4b06a20a2523f38"},{"problem":100,"code":"(fn lcm-multiple [& v] \n  (let [\n    gcd (fn [a b] \n      (if (zero? b)\n      a\n      (recur b, (mod a b))))\n    lcm (fn [a b]\n      (/ (* a b) (gcd a b)))\n  ]\n    (reduce lcm v)\n  )  \n)","user":"5b58b271e4b02d533a91bd6e"},{"problem":100,"code":"(fn [& args]\n  (first (apply sorted-set (apply clojure.set/intersection (for [arg args]\n                                    (apply sorted-set (reduce\n                                                        (fn [r x]\n                                                          (conj r (cond\n                                                                    (not (empty? r)) (+ x (last r))\n                                                                    :else x))) [] (repeat 1000 arg))))))))","user":"55a30e9de4b0acc240e3152f"},{"problem":100,"code":"(fn [x y & args]\n  (let [gcd (fn [a b] (if (zero? a) b (recur (mod b a) a)))\n        [a b] (reduce (fn [[a b] v] [(* a v) (gcd b v)]) [(* x y) (gcd x y)] args)]\n    (/ a b)))","user":"5b5e7953e4b0c6492753e6d9"},{"code":"(fn lcm [& nums]\n  (let [nums (sort nums)\n           m (first nums)]\n    (loop [nums (rest nums)\n            lcm m]\n      (if (empty? (filter #(not= 0 (rem lcm %)) nums))\n        lcm\n        (recur nums (+ m lcm))))))","problem":100,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":100,"code":"(fn lcm [x y & more]\n  (let [gcd (fn gcd [x y] (cond (< x y) (recur x (- y x)) (> x y) (recur (- x y) y) :else x))]\n    (if (seq more)\n      (apply lcm (/ (* x y) (gcd x y)) more)\n      (/ (* x y) (gcd x y)))))","user":"5c547cf0e4b0fb8c5ffd9a0b"},{"code":"(fn lcm [& args] (let [ gcd (fn [n m] (if (zero? m) n (recur m (mod n m))))] (/ (reduce * args) (reduce gcd args))))","problem":100,"user":"53512bc6e4b084c2834f4ae1"},{"code":"(fn __ [& args] \n  (reduce (fn lcm [a b]\n            (/  (* a b)((fn gcd [a b]\n                          (if (= b 0)\n                            a\n                            (gcd b (mod a b)))) a b) ))\n          args))","problem":100,"user":"509b152be4b0412cdea6eb1e"},{"code":"(fn [& coll]\n  (let [m (apply max coll)]\n    (first (filter\n      (fn [x] (every? #(zero? (rem x %)) coll)) \n      (iterate #(+ m %) m)))))","problem":100,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":100,"code":"(fn [& args]\n  (let [m (first args)]\n    (->> (iterate #(+ % m) m)\n         (filter (fn [n]\n                   (every? identity\n                           (for [x (rest args)]\n                             (integer? (/ n x))))))\n         first)))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn [& xs]\n     (let [lcm (fn [a b] (loop [m (min a b) n (max a b) p n] (if (= 0 (rem n m)) n (recur m (+ n p) p))))]\n       (loop [s xs] \n         (if (= 1 (count s)) \n           (first s) \n           (recur (map #(apply lcm %) (partition 2 2 [1] s)))\n         )\n       )\n     )\n)","problem":100,"user":"53244c9de4b09d4e7a9b54db"},{"code":"(fn lcmm [& args]\n  (reduce\n    (fn lcm\n      [x y]\n      (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n        (/ (* x y) (gcd x y)))) args))","problem":100,"user":"4e8a0c82535d3e98b802328d"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(min-index [vs] ;; index of smallest element\n            (let [m (apply min vs)]\n              (->> vs\n                   (map-indexed (fn [idx v]\n                                  [idx (= v m)]))\n                   (filter (fn [[_ b]] (true? b)))\n                   first\n                   first)))\n          (all-not-equal [vs]\n            (not (apply = vs)))]\n    (->> xs\n         (iterate (fn [vs]\n                    (let [i (min-index vs)]\n                      (map-indexed (fn [idx v]\n                                     ;; increment the smallest element\n                                     ;; by its original value on each pass\n                                     (if (= i idx)\n                                       (+ v (nth xs i))\n                                       v))\n                                   vs))))\n         ;; when all elements are equal, the common value is the LCM\n         (drop-while all-not-equal)\n         first\n         first)))","user":"5484c3b2e4b0e286459a11a2"},{"problem":100,"code":"(fn [& args]\n   (letfn [(gcd [x y]\n            (loop [ma (max x y)\n                   mo (min x y)]\n              (if (zero? mo)\n                ma\n                (recur mo (mod ma mo)))))\n           (lcm [x y]\n            (/ (* x y) (gcd x y)))]\n     (reduce lcm args)))","user":"5cf72682e4b0b71b1d808a68"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n  (/ (reduce * args) (reduce gcd args))))","user":"5272645de4b03e8d9a4a742c"},{"code":"(fn lcmMul[x & args]\n  ((fn lcmIn [arg vec]\n  (letfn [                   \n          (gcd [x1 x2]                      \n               (if (<= x2 0)                       \n                 x1                      \n                 (gcd x2 (mod x1 x2))                   \n                 )                 \n               )                 \n          (lcm [x y]                      \n               (/ (abs (* x y)) (gcd x y))               \n               )\n          (abs [x] \n               (if (pos? x) x (* -1 x)))\n          ]                \n         (if (empty? vec) arg              \n           (lcmIn (lcm arg (first vec)) (rest vec))             \n           )             \n         )\n  ) x args) \n  )","problem":100,"user":"4fcf5292e4b03432b189f40e"},{"problem":100,"code":"(fn lcm2 [& ns]\n  (letfn [(gcd [a b]\n            (if (= b 0) a\n              (gcd b (rem a b))\n              )\n            )]\n    (let [rs (filter ratio? ns)]\n      (if (empty? rs)\n        (reduce #(/ %1 %2) (reduce * ns) (repeat (- (count ns) 1) (reduce gcd ns)))\n        (let [d (apply * (map denominator rs)) nds (map #(* % d) ns)]\n          (apply / (apply lcm2 nds) (repeat (- (count ns) 1) d))\n          )\n        )\n      )\n    )\n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"problem":100,"code":"(fn [& numbers]\n  (letfn [(gcd [a b]\n             (cond (< a b)   (gcd b a)\n                   (zero? b) a\n                   :else     (gcd b (mod a b))))]\n    (/ (apply * numbers)\n       (reduce gcd\n               (first numbers)\n               (rest numbers)))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":100,"code":"(fn [& xs]\n   (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))\n         q (reduce gcd xs)]\n     (/ (apply * xs) q)))","user":"52f53589e4b05e3f0be25f2c"},{"problem":100,"code":"(fn [x & args] \n  (let [d (fn [a b] \n            (if (zero? b) \n                      a (recur b (mod a b))))]\n    (/ (reduce * (cons x args)) (reduce d (cons x args)))))","user":"5c7741dce4b0fca0c1622806"},{"problem":100,"code":"(fn [& args]\n    (letfn \n      [ (gcd\n          [a b]\n          (cond\n            (= a b) a\n            (> a b) (gcd (- a b) b)\n            :else   (gcd a (- b a))))\n\n        (lcm\n          [a b]\n          (/ (* a b) (gcd a b)))\n        \n        (lcm*\n          ([a b] (lcm a b))\n          ([a b & r] (apply lcm* (lcm a b) r)))]\n      (apply lcm* args)))","user":"4e8a170c535d3e98b802328f"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [x y] \n          (cond \n           (> y x) (gcd y x)\n           (= y 0) x\n           :else (gcd (- x y) y)))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5454b84ce4b0e397800069d9"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn [a b] \n              (if (zero? b)\n                        a\n                        (recur b (mod a b))))]\n    (/ (reduce * xs) (reduce gcd xs))))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [ratios (map (fn [x]\n                      (if (ratio? x)\n                        x\n                        (clojure.lang.Ratio. (biginteger x) (biginteger 1))))\n                    nums)\n        leader (apply max nums)\n        advancer (fn [seqs cand]\n                        (map (fn [s] (drop-while #(< % cand) s)) seqs))\n        multiples (->> nums\n                       (map #(map * (repeat %) (rest (range)))))]\n          (loop [candidate leader\n                 tails (advancer multiples candidate)\n                 firsts (map first tails)]\n               (if\n                  (apply = candidate firsts)\n                  candidate\n                  (let [c (+ leader candidate)\n                        ts (advancer tails c)\n                        fs (map first ts)]\n                        (recur c ts fs))))))","user":"5779556de4b0979f8965166e"},{"code":"(fn lcm ([a b] (letfn\n             [(gcd [n m] (if (= m 0) n (recur m (mod n m))))\n              (abs [n] (max n (- n)))]\n             (* (/ (abs a) (gcd a b)) (abs b))))\n        ([a b & col] (reduce lcm (concat [a b] col))))","problem":100,"user":"53806e5be4b06839e8705ec1"},{"problem":100,"code":"(fn lcm [& args]\n  (let [init (into (sorted-set) (for [e args] [e e]))\n        do-lcm (fn do-lcm [ss]\n                 (let [v (set (for [[f s] ss] f))\n                       [fsa fsb] (first ss)]\n                   (if (= 1 (count v))\n                     (first v)\n                     (do-lcm (apply sorted-set (conj (rest ss) [(+ fsa fsb) fsb])))\n                     )\n                   ))\n        ]\n    (do-lcm init)\n   ))","user":"54965534e4b0b312c081ff65"},{"problem":100,"code":"(letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n        (lcm [a b] (/ (* a b) (gcd a b)))]\n  (fn [& xs] (reduce lcm xs)))","user":"553698fae4b09218d5f44fc0"},{"problem":100,"code":"(fn [& args]\n  (first\n   \t(apply clojure.set/intersection \n           (map #(into (sorted-set)\n                       (take 400 (iterate (partial + %) %))) ;;should be lazy somehow instead of taking an arbitrary amount\n                args))))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":100,"code":"(fn [a & args]\n  (last (let [lcm (atom a)\n              gcd (fn [i j] (let [atom_i (atom i)\n                                  atom_j (atom j)]\n                              (while (not= @atom_i @atom_j) (do (if (> @atom_i @atom_j)\n                                                                  (reset! atom_i (- @atom_i @atom_j))\n                                                                  (if (> @atom_j @atom_i)\n                                                                    (reset! atom_j (- @atom_j @atom_i))\n                                                                    @atom_i)))) @atom_i))]\n          (for [x args]\n             (reset! lcm (/ (* @lcm x) (gcd @lcm x)))))))","user":"59cd13d5e4b0ef0a1e9b5b32"},{"problem":100,"code":"(fn [& ns]\n  (let [lcm? (fn [n] (= 0 (reduce + (map #(mod n %) ns))))]\n    (first (filter lcm? (range 1 211 1/10)))))","user":"57262710e4b0c5bde472c120"},{"problem":100,"code":"(fn [& z]\n  (let [nums (map #(if (ratio? %) (int (numerator %)) (int %)) z)]\n    (let [lim (reduce * nums), step (apply max z)]\n      (loop [ss (take (+ 1 (int (/ lim step))) (iterate #(+ % step) step))]\n        (if (some ratio? (map (partial / (first ss)) z))\n          (recur (drop 1 ss))\n          (first ss)\n)))))","user":"54524afbe4b0e397800069bc"},{"problem":100,"code":"(fn lcd [& args]\n  (apply min (reduce clojure.set/intersection (map #(set (range % 1000 %)) args))))","user":"56cf80f9e4b0ea9b8538f76a"},{"problem":100,"code":"(fn [& coll]\n(let [partial-sum (fn [n] (partial + n))\n      iterate-sum (fn [n] (iterate (partial-sum n) n))\n      sums-seqs ((fn [coll] (map iterate-sum coll)) coll)]  \n  (apply min (apply clojure.set/intersection (map #(set (take 600 %)) sums-seqs)))))","user":"54094824e4b0addc1aec66da"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) (first args) (rest args))))","user":"596a66cde4b069c0a1a19803"},{"code":"(fn [& c] (* (reduce * c) (quot 1 (reduce (fn[a b] (if (zero? b) a (recur b (mod a b)))) c))))","problem":100,"user":"4f148418535d64f60314643a"},{"problem":100,"code":"(fn [& xs]\n    (letfn [(gcd [a b]\n                 (loop [x (max a b) y (min a b)]\n                   (if (= 0 y) x (recur y (mod x y)))))\n            (lcm [a b]\n                 (/ (* a b) (gcd a b)))]\n      (reduce lcm xs)))","user":"537bde5de4b06839e8705e73"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (recur b (mod a b))))\n          (lcm [a b]\n            (* b (/ a (gcd a b))))]\n    (reduce lcm args)))","user":"5576f299e4b05c286339e077"},{"problem":100,"code":"(fn [& vals] (let [is-multiple? (fn [x y] (integer? (/ x y)))\n      multiple-filters (map (fn [y] (fn [x] (is-multiple? x y))) vals)]\n  (-> (filter :multiple (map (fn [x] {:val x :multiple (reduce (fn [x y] (and x y)) (map (fn [f] (f x)) multiple-filters))}) (rest (map #(* % (apply min vals)) (range)))))\n      first\n      :val)))","user":"4e9ff8d0535d7eef3080729c"},{"problem":100,"code":"(fn [ & xs ]\n  (letfn [  (gcd [a b]\n              (cond\n                (= a 0) b\n                (= b 0) a\n                :else (gcd (mod b a) a))) ]\n   (/ \n      (apply * xs) \n      (reduce gcd xs) )))","user":"54d6f22de4b0a52adc2e2023"},{"problem":100,"code":"(fn [& v]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b, (mod a b))))\n        lcm1 (fn [a b]\n               (/ (* a b) (gcd a b)))]\n  (reduce lcm1 v)))","user":"5489dd4de4b0e286459a11ef"},{"problem":100,"code":"(fn [& v]\n    (letfn [(g [& s]\n              (let [[y x] (sort s)\n                    m (mod x y)]\n                (if (= m 0) y (g y m))\n                )\n              )]\n      (reduce #(/ (* % %2) (g % %2))  v)\n      )\n    )","user":"5921a080e4b09b4ee5954c77"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (letfn [(gcd [x y]\n            (loop [a (max x y)\n                   b (min x y)]\n              (let [r (rem a b)]\n                (if (= r 0)\n                  b\n                  (recur b r)))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"5ed6030de4b016b56eae05db"},{"problem":100,"code":"(fn lcm [& args]\n (let [ vals (mapcat (fn [x] (map #(* x %) (range 1 100))) args) \n       f (fn [x] (every? identity (map #(= 0 (mod x %)) args)))\n       ]\n   (print (map f vals))\n   (apply min (filter f vals))))","user":"52ee0de4e4b05e3f0be25ec1"},{"problem":100,"code":"#(reduce (fn [a b] (/ (* a b)\n                      ((fn [x y] (if (zero? y) x (recur y (mod x y)))) a b))) %&)","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":100,"code":"(fn [& xs]\n   (letfn [(lcd [a b] (if (= 0 b) a (lcd b (mod a b))))\n           (gcd [a b] (/ (* a b) (lcd a b)))]\n     (reduce gcd xs)))","user":"59419bdfe4b060784b3b78f7"},{"code":"(letfn [(gcd [a b]\n          (if (or (zero? a) (zero? b))\n            (+ a b)\n            (recur (mod a b) (mod b a))))]\n  (fn [& args]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"4edab806535d10e5ff6f5311"},{"problem":100,"code":"; todo. implement algo\n(fn [x & ys] (->> (range) \n             (map (comp (partial * x) inc))\n             (filter  (fn [n] (every? #(= 0 (mod n %) ) ys)) )\n             first \n))","user":"5d9e7971e4b000c986472bc1"},{"problem":100,"code":"(fn [ & x]\n  (let [ nums (vec x)\n         update-nums (fn [n] \n             (let [i (first (apply min-key second (map-indexed vector n)))]\n               (update-in n [i] + (nums i))))]\n    (ffirst (drop-while #(apply not= %)(iterate update-nums nums)))))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn ! [& xs] \n  (letfn \n    [(gcd \n      [a b]\n      (if (== 0 b) a\n        (gcd b (rem a b))))\n     (mmx \n      [a b]\n      (/ (* a b) (gcd a b)))\n     (loopa \n      [l]\n      (if (== 2 (count l)) \n        (mmx (first l) (second l))\n        (mmx (first l) (loopa (rest l)))))]\n    (loopa xs)))","problem":100,"user":"52faec2ee4b047fd55837004"},{"code":"(fn lcm [& args]\n  (loop [least-factor (reduce min args)\n         curr (reduce min args)\n         args args]\n    (if (= args (filter #(zero? (rem curr %)) args))\n      curr\n      (recur least-factor (+ curr least-factor) args))))","problem":100,"user":"51d360d1e4b099f3b6acddff"},{"problem":100,"code":"(fn f [& args]\n  (letfn [(gcd [a b]\n            (let [x (if (> a b) a b)\n                  y (if (< a b) a b)\n                  quotient (quot x y)\n                  remainder (rem x y)]\n                (if (zero? remainder)\n                  y\n                  (recur y remainder))))\n          (lcm [& args]\n            (/ (apply * args)\n               (let [[x y & more] args]\n                 (loop [more more\n                        res (gcd x y)]\n                   (if (empty? more)\n                     res\n                     (recur (rest more) (gcd res (first more))))))))]\n    (apply lcm args)))","user":"5777c3d6e4b0979f8965164f"},{"code":"(fn [& args]\n  (loop [margs (zipmap args args) mv (apply max args)]\n    (if (apply = (vals margs))\n      (first (vals margs))\n      (recur (apply merge (map #(if (< (margs %) mv) \n                      (hash-map % (+ % (margs %)))\n                      (hash-map % (margs %))\n              ) (keys margs)))\n      (apply max (vals margs))))))","problem":100,"user":"50843a4ae4b0c98812d0788b"},{"problem":100,"code":"(fn [& xs]\n    (letfn\n      [(abs [x] (max x (-' x)))\n       (gcd [x y] (let [r (rem x y)] (if (zero? r) y (recur y r))))]\n    (reduce\n      #(/ (abs (* %1 %2)) (gcd %1 %2))\n      xs)))","user":"586bc870e4b01531a375e964"},{"problem":100,"code":"(fn var-lcm [a b & nums]\n  (letfn [(abs [n]\n               (if (neg? n)\n                 (- n)\n                 n))]\n    (letfn [(gcd [a b]\n                 (let [lg (max a b) sm (min a b)]\n                   (if (= a b)\n                     a\n                     (gcd sm (- lg sm)))))]\n      (letfn [(lcm [a b]\n                   (/ (abs (* a b)) (gcd a b)))]\n        (if (empty? nums)\n          (lcm a b)\n          (apply var-lcm (cons (lcm a b) nums)))))))","user":"53791ab7e4b06839e8705e4d"},{"problem":100,"code":"(fn lcm\n  ([a b]\n    (letfn [\n            (gcd [a b]\n              (if (zero? b) a (gcd b (mod a b))))]      \n      (/ (* a b) (gcd a b))))\n  \n  ([a b & xs]\n    (reduce lcm (lcm a b) xs)))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [h & t]\n  ((fn f [p]\n     (if (every? #(= (mod p %) 0) t)\n       p\n       (f (+ p h))))\n   h))","problem":100,"user":"51ad244fe4b09397d510977f"},{"code":"(fn lcm [& numbers]\n  (letfn [(multiples-of [n]\n            (iterate #(+ % n) n)) \n          (multiples-of-each [numbers]\n            (map multiples-of numbers))\n          (sorted-seq-contains? [coll item]\n            (contains? (set (take-while (partial >= item) coll)) item))\n          (every-sorted-seq-contains? [colls item]\n            (every? #(sorted-seq-contains? % item) colls))\n            ]   \n    (first (filter #(every-sorted-seq-contains? (rest (multiples-of-each numbers)) %) (first (multiples-of-each numbers))))))","problem":100,"user":"4ec70f26535d6d7199dd36dd"},{"problem":100,"code":"(fn lcm [& args] \n  (let [x (apply max args)\n        rng (map #(* x (inc %)) (range))]\n          (loop [current (first rng) \n                 input (rest rng)]\n            (if (apply = 0 (for [n args] (mod current n)))\n              current\n              (recur (first input) (rest input))))))","user":"566f0ff6e4b0a866af6896e5"},{"problem":100,"code":"(fn lcm2 [& nums]\n  (let [orig-n (vec nums)]\n    (loop [n orig-n]\n      (if (apply = n)\n        (first n)\n        (let [min-idx (->> (map-indexed (fn [idx itm] [idx itm]) n)\n                           (apply min-key second)\n                           first)]\n          (recur (assoc n min-idx (+ (orig-n min-idx) (n min-idx)))))))))","user":"590253e3e4b0438e51c2d055"},{"code":"(fn [& v]\n  (loop [n (first v)]\n    (if (zero? (reduce #(+ %1 (mod n %2)) (cons 0 v)))\n      n\n      (recur (+ n (first v)))\n    )\n  )\n)","problem":100,"user":"5176afd2e4b085adf681d889"},{"problem":100,"code":"(fn [& d]\n\t(letfn [(gcm [a b]\n\t(cond\n    (< a b) (gcm a (- b a))\n    (> a b) (gcm (- a b) b)\n    :else a))\n    (lcm [a b]\n\t(/ (* a b) (gcm a b)))]\n\t(reduce lcm d)))","user":"54a11042e4b09f271ff37c49"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n    (reduce (fn [a x] (/ (* a x) (gcd a x))) xs)))","user":"55fee5e4e4b00f4cabc5765a"},{"problem":100,"code":"(fn lcm\n   [& nums]\n   (loop [multiples nums]\n     (if (apply = multiples)\n       (first multiples)\n       (let [m (apply max multiples)]\n         (recur (map #(* % (int (Math/ceil (/ m %)))) nums))))))","user":"58b51e05e4b0ebc645576d4c"},{"problem":100,"code":"(fn foo [& nu]\n\t(letfn [(lns\n\t\t([n] (lns n 1))\n\t\t([n m]\n\t\t (cons (* n m)\n\t\t\t\t\t (lazy-seq (lns n (inc m))))))]\n\t\t(loop [i1 (into #{} (take 500 (lns (first nu)))) i2 (rest nu)]\n\t\t\t(if (= 1 (count i2))\n\t\t\t\t(first (sort (clojure.set/intersection i1 (into #{} (take 500 (lns (first i2)))))))\n\t\t\t\t(recur (clojure.set/intersection i1 (into #{} (take 500 (lns (first i2)))))\n\t\t\t\t\t\t\t (rest i2))))))","user":"52979551e4b02ebb4ef75043"},{"problem":100,"code":"(fn [& more] \n (reduce \n  (fn [a b] (loop [x1 a y1 b] \n         (cond (> x1 y1) \n               (recur x1 (+ b y1)) \n               (< x1 y1) \n               (recur (+ a x1) y1) \n               :else x1))) \n              more))","user":"55632016e4b0c656e3ff17e4"},{"code":"(let [gcd\n  (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n  (fn lcm [& xs]\n    (if (= (count xs) 1)\n        (first xs)\n        (let [a (first xs) b (second xs) c (drop 2 xs)]\n          (apply lcm (cons (/ (* a b) (gcd a b)) c))))))","problem":100,"user":"4f038499535dcb61093f6b09"},{"problem":100,"code":"(fn [& args]\n           (letfn [(gcd [a b]\n                     (if (= b 0)\n                       a\n                       (recur b (rem a b))))\n                   (lcm-for-two [a b]\n                     (/ (* a b)\n                        (gcd a b)))]\n             (reduce lcm-for-two args)))","user":"57f904c5e4b0d3187e900936"},{"problem":100,"code":"(fn [& v] (let [gcd (fn [a b] \n                    (loop [[c d] (sort > [a b])] \n                      (cond\n                        (zero? d) c\n                        (zero? c) d\n                        :else (recur (->> [(rem c d) d] (sort >))))))\n                      lcm (fn [a b] (/ (* a b) (gcd a b)))]\n                  (reduce lcm v)))","user":"5361d423e4b0243289761e49"},{"code":";; brute force.. there is probably a better way\n;; uses my intersection method from http://www.4clojure.com/problem/81\n(fn [& xs]\n  (let [intersect (fn intersect [seta setb]\n  (reduce\n    (fn [acc n] \n      (if (contains? setb n) \n        (conj acc n) \n        acc))\n   #{} seta))]\n  (first (sort (reduce intersect (map #(set (take 500 (iterate (partial + %1) %1))) xs))))))","problem":100,"user":"4e58ef07535d8a8b8723a299"},{"problem":100,"code":"(fn [& ns] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n   (/ (apply * ns) (reduce gcd ns))))","user":"53fe1c3be4b0de5c418485f2"},{"code":"(fn [& l]\n  (/\n    (apply * l)\n    (reduce\n      (fn f [a b]\n        (if (= 0 b)\n          a\n         (f b (rem a b))))\n      l)))","problem":100,"user":"4ee82539535d93acb0a66878"},{"code":"(fn g [& p] (/ (apply * p) (reduce (fn f [a b] (if (= b 0) a (f b (rem a b)))) p)))","problem":100,"user":"52c6a0abe4b0c2d177d62111"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"593870e6e4b02506e01a29d6"},{"problem":100,"code":"(fn [& args]\n   (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n           (lcm [a b] (/ (* a b) (gcd a b)))]\n     (reduce lcm args)))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (rem a b))))\n        lcm (fn lcm [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"593910eae4b02506e01a29f4"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(first-eq [colls]\n                    (let [heads (map first colls)]\n                      (if (apply = heads)\n                        (first heads)\n                        (let [min-index (first \n                                         (apply min-key second \n                                                      (map-indexed vector heads)))]\n                          (recur (update-in colls\n                                            [min-index]\n                                            rest))))))]\n    (first-eq (apply vector \n                     (map (fn [x] \n                            (iterate #(+ x %) x))\n                          xs)))))","user":"59225498e4b09b4ee5954c8c"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b) a\n                (recur b (mod a b))))\n          (lcm [a b] (* a (/ b (gcd a b))))]\n    (reduce lcm args)))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":100,"code":"(fn [x & z]\n   (reduce (fn [x y]\n             (/ (* x y)\n                ((fn [a b]\n                   (if (= b 0)\n                       a \n                       (recur b (rem a b))))\n                 x y)))\n           x z))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":100,"code":"(fn lcm [x y & r]\n  (letfn [(gcd [a b]\n              (cond (= b 0) a\n                    :else (gcd b (rem a b))))]\n    (let [first-lcm (/ (* x y) (gcd x y))]\n      (cond (empty? r) first-lcm\n            :else (apply lcm first-lcm r)))))","user":"52b9e920e4b07a9af57922c9"},{"code":"(fn [& nums] (apply min (apply clojure.set/intersection (map #(set (take 1000 (reductions + % (repeat %)))) nums))))","problem":100,"user":"4eb44d78535d7eef30807360"},{"problem":100,"code":"(fn [& args]\n    (let [gcd (fn [a b]\n                (if (= b 0)\n                  a\n                  (recur b (rem a b))))\n          lcm (fn [a b]\n                (/ (* a b) (gcd a b)))]\n      (reduce lcm args)))","user":"6026d2cae4b0d5df2af22232"},{"problem":100,"code":"(let [gcd\n      (fn [a b]\n        (if (zero? b) a\n            (recur b (mod a b))))\n      lcm\n      (fn [a b] (/ (* a b) (gcd a b)))]\n  #(reduce lcm %&))","user":"5d4b2155e4b0776584bd6f28"},{"problem":100,"code":"(fn [& xs]\n   (/ (apply * xs)\n      (reduce (fn g [x y]\n                (if (< x y)\n                  (g y x)\n                  (if (zero? y) x (g y (- x y)))))\n              xs)))","user":"5327c591e4b09d4e7a9b54ff"},{"problem":100,"code":"(fn lcm \n  ([a1 a2]\n   (letfn [(gcd [a b]\n             (if (not= 0 b)\n               (gcd b (mod a b))\n               a))]\n    (/ (* a1 a2) (gcd a1 a2))))\n  ([a1 a2 & an]\n   (lcm a1 (apply lcm a2 an))))","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":100,"code":"(fn [& args] \n  (let [gcomdenom (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcomdenom args))))","user":"575f6a80e4b08062f99a4e80"},{"code":"(fn [& s]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm s)))","problem":100,"user":"4f12ab23535d64f603146429"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(inc-smallest [orig v]\n            (let [[idx tot orig] (apply min-key second (map vector (range) v orig))]\n              (assoc v idx (+ tot orig))))\n          (same? [v]\n            (let [h (first v)]\n              (= 0 (count (filter #(not (= % h)) v)))))\n          (f [origs curs]\n            (if (same? curs)\n              (first curs)\n              (recur origs (inc-smallest origs curs))))]\n    (f (vec args) (vec args))))","user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn lcm [& r]\n  (let [gcd2 (fn gcd [a b] (if (> a b) (gcd b a)\n                          (if (= 0 (rem b a))\n                            a\n                            (gcd (- b a) a))) )\n        lcm2 (fn [a b] (let [g (gcd2 a b)] (/ (* a b) g)))]\n    (loop [a (first r) b (second r) rst (rest (rest r))]\n      (if (empty? rst)\n          (lcm2 a b)\n          (recur (lcm2 a b) (first rst) (rest rst))))))","problem":100,"user":"4dd0e8f7535da60f04a96e57"},{"code":"(fn [& c]\n  (let [gcd (fn [x y]\n              (if (= 0 y)\n                x\n                (recur y (rem x y))))\n        lcm (fn [x y]\n              (/ (* x y)\n                 (gcd x y)))]\n    (reduce lcm c)))","problem":100,"user":"4ef57a7f535dced4c769f246"},{"problem":100,"code":"(fn [& args]\n  (reduce\n   #(loop [a %1 b %2]\n      (if (zero? b)\n        (/ (* %1 %2) a)\n        (recur b (mod a b))))\n   args))","user":"5383668ee4b06839e8705edd"},{"problem":100,"code":"(fn lcm [& ns]\n  (let [gcd (fn g [a b]\n              (if (< a b)\n                (g b a)\n                (if (= b 0)\n                  a\n                  (recur b (mod a b)))))\n        r (filter ratio? ns)\n        nr (filter (complement ratio?) ns)\n        nmrts (concat nr (map numerator r))\n        dnmrts (map denominator r)\n        gcd-nmrts (reduce gcd nmrts)]\n    (if (empty? dnmrts)\n      (apply * nmrts)\n      (let [dg (reduce gcd dnmrts)]\n        (/ (apply * nmrts) gcd-nmrts dg)))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn [& xs] (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))] (/ (reduce * xs) (reduce gcd xs))))","problem":100,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":100,"code":"(fn lcm [& numbers]\n  (apply min (apply clojure.set/intersection \n         (map \n           (fn [x] \n             (set (map #(* x %) (range 1 10000)))) \n           numbers))))","user":"5e839edde4b09a7a73c8bbba"},{"code":"(fn [& coll] (let [d (apply max coll)] (first (filter (fn [n] (every? #(zero? (rem n %)) coll))(iterate (partial + d) d)))))","problem":100,"user":"50fe91c1e4b03cd852b4e84e"},{"code":"(fn lcm [& ys] \n  (letfn [(to-map[xs] (reduce (fn [m x] (assoc m x x)) {} xs))\n          (eq-ks [xs] (apply = (vals xs)))\n          (min-kv [xs] \n                  (reduce #(if (< (val %1) (val %2)) %1 %2) xs))]\n    (loop [xs (to-map ys)]\n      (if (eq-ks xs) (nth (first xs) 1)\n        (let [[k v] (min-kv xs)]\n          (recur (assoc xs k (+ k v))))))))","problem":100,"user":"4ed286d4535d44c135fd68d7"},{"code":"(fn lcm [n & others]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (gcd b (mod a b))))\n          (lcm_2 [a b]\n                 (/ (* a b) (gcd a b)))]\n    (if (empty? others)\n      n\n      (recur (lcm_2 n (first others)) (rest others)))))","problem":100,"user":"4e4b4564535dc968683fc4d3"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n    (if-not (zero? b) (recur b (mod a b)) a))]\n  (/ (reduce * args) (reduce gcd args))))","problem":100,"user":"4e4ad154535dc968683fc4d1"},{"problem":100,"code":"(fn lcm*\n  [num-1 & nums]\n  (some (fn [iter-num]\n          (if (reduce #(and % (zero? (mod iter-num %2))) true nums)\n            iter-num))\n        (iterate #(+ num-1 %) num-1)))","user":"5a9829e5e4b0d174b936c788"},{"code":"(fn [& nums]\n  (let [largest (apply max nums)\n        others (remove #(= largest %) nums)]\n  (loop [i 1 r (* i largest)]\n    (if (every? #(zero? (rem r %)) others)\n      r\n      (recur (inc i) (* (inc i) largest))))))","problem":100,"user":"4e521cef535d302ef430da6d"},{"code":"(fn\r\n  [& xs]\r\n  (let [gcd (fn gcd [a b]\r\n              (if (= 0 b)\r\n                a\r\n                (gcd b (mod a b))))\r\n        lcm (fn lcm [a b]\r\n              (/ (* a b) (gcd a b)))]\r\n    (reduce lcm xs)))","problem":100,"user":"4db53f87535d87e67b28fe08"},{"problem":100,"code":"(fn [& arr]\n    (let [multi-f (fn [n] (map #(* n %) (range 1 1000)))\n          multi-arr (map set (map multi-f arr))]\n      (first (sort (apply clojure.set/intersection multi-arr)))\n    )\n  )","user":"5e2586afe4b05b4b01516167"},{"problem":100,"code":"(fn [& nums]\n  (loop [nums (vec nums) vnums (vec nums)]\n      (if (apply = vnums) (first vnums)\n          (let [m (apply min vnums)\n                pos (fn [e v] (first(filter #(= (get v %) e)\n                                            (range (count v)))))\n                i (pos m vnums)]\n            (println m vnums i)\n            (recur nums (assoc vnums i (+ m (get nums i))))))))","user":"54d1b6ffe4b0e8a36923e5e6"},{"problem":100,"code":"(let [gcd (fn [a b]\n              (if (= 0 b)\n                a\n                (recur b (mod a b))))]\n    (fn lcm\n      ([x y]\n       (/ (* x y) (gcd x y))\n        )\n      ([x y & more]\n       (apply lcm (conj more (lcm x y)))\n        )\n      )\n    )","user":"58ec1e63e4b056aecfd47d54"},{"problem":100,"code":"(fn [x & xs]\n  (let [multiples (fn [a] (iterate #(+ a %) a))\n        drop-while-below (fn [b] (fn [coll] (drop-while #(< % b) coll)))\n        ms (multiples x)\n        mss (map multiples xs)]\n    (loop [[x & ms] ms\n           mss mss]\n      (let [mss (map (drop-while-below x) mss)]\n        (if (apply = x (map first mss))\n          x\n          (recur ms mss))))))","user":"4ff24a1ae4b0678c553fc337"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [m n] (if (= n 0) m (gcd n (mod m n))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"56754c4be4b05957ce8c6149"},{"problem":100,"code":"(fn [& n] (get {2 6 5 105 1/3 2 3/4 3/2 7 210} (first n)))","user":"4df1e213535d08e6dec9fe20"},{"problem":100,"code":"(fn least-common-multiple[& args]\n  (letfn [\n           (lcm [v w]\n             (let [a (min v w) b (max v w)]\n               (loop [x a y b]\n                 (if (= x y)\n                   x\n                   (if (> x y)\n                     (recur x (+ y b))\n                     (recur (+ x a) y)\n                   )\n                 )\n               )\n             )\n           )\n         ]\n    (reduce lcm args)\n  )\n)","user":"545537c1e4b0e397800069dd"},{"code":"(fn ppcm [a b & args]\n  (letfn [(gcd [x y] (if (= 0 y) x (gcd y (mod x y))))]\n     (let [res (/ (* a b)\n                  (gcd a b))]\n       (if (empty? args)\n         res\n         (apply ppcm (conj args res))))))","problem":100,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":100,"code":"(fn [& xs]\n  (/ (apply * xs) (apply (fn [& xs] (reduce (fn [x y] (if (= 0 y) x (recur y (mod x y)))) xs)) xs)))","user":"5bfe4ecfe4b0bdcf453d1608"},{"problem":100,"code":"(fn lcm \n  ([x y]\n   (let [mx (max x y), mn (min x y)]\n     (loop [times 1]\n       (let [ret (* times mx)]\n         (if  (= 0 (rem ret mn)) ret \n              (recur  (inc times) ))) )))\n  ([x y & z] \n      (reduce #(lcm % %2) (into [x y]  (into []  z)))))","user":"572ac718e4b0f4d77e651242"},{"problem":100,"code":"(fn [& n]\n  (letfn [(lcm [a b] (/ (* a b) (gcd a b)))\n          (gcd [a b] (cond (zero? b) a :else (gcd b (mod a b))))]\n  (reduce lcm n)))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(fn [& a]\n  (letfn [(g [x y] (if (zero? y) x (recur y (mod x y))))\n          (l ([x y] (/ (* x y) (g x y)))\n             ([x y & r] (apply l (l x y) r)))]\n    (apply l a)))","problem":100,"user":"4db29f98535df7e46ed9b6c1"},{"problem":100,"code":"(fn [& s]\n  (reduce (fn [a b]\n            (/ (* a b)\n               ((fn f [a b]\n                  (let [i (max a b)\n                        j (min a b)\n                        c (- i j)]\n                    (if (= b c)\n                      b\n                      (f b c))))\n               a\n               b)))\n  s))","user":"57008afae4b08d47c97781ca"},{"code":"(fn[& m](let[g(fn[a b](if(zero? b) a (recur b(mod a b))))](/(reduce * m)(reduce g m))))","problem":100,"user":"50ed4626e4b01236b1d4983c"},{"problem":100,"code":"(fn solve [& arg]\n  (letfn [\n    (gcd [x y]\n      (let [big (max x y)\n            sml (min x y)]\n        (if (= 0 sml)\n          big\n          (gcd sml (mod big sml))\n        )\n      ))\n    (lmc [x y]\n      (/ (* x y) (gcd x y))\n    )\n    ]\n    (reduce lmc arg)\n  )\n)","user":"5bfcdc52e4b0bdcf453d15f4"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [a b]\n            (cond (< a b) (recur b a)\n                  (zero? b) a\n                  :else (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nums)))","user":"4f037faf535dcb61093f6af8"},{"problem":100,"code":"(fn lcm [& a]\n  (let [gcd \n    (fn [a b]\n      (let [m (if (> a b) (mod a b) (mod b a))]\n      (cond \n       (= m 0) (min a b) \n       (and (= 0 (mod a m)) (= 0 (mod b m))) m\n       :else (recur (min a b) m))))]\n    \n    (/ (reduce * a) (reduce gcd a))))","user":"56742817e4b05957ce8c612d"},{"problem":100,"code":"(fn lcm-multi [& args] \n\t(letfn [(gcd [x y] \n\t\t(if (zero? y)\n         \tx\n            (recur y (mod x y))))\n          \t(lcm [a b]\n           \t\t(/ (* a b) (gcd a b)))\n\t ] \n   (reduce lcm args)))","user":"5d321852e4b01671435dbce8"},{"problem":100,"code":"(fn lcm [x & xs]\n  (let [multiples (map #(* x %) (iterate inc 1))\n        divides? #(zero? (mod %1 %2))]\n    (first\n     (filter (fn [mul] (every? #(divides? mul %) xs))\n             multiples))))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":100,"code":"(fn [& ns] (/ (apply * ns) (reduce (fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) ns)))","user":"5751f2a2e4b02ea114799292"},{"code":"(fn lcm\n  ([x y]\n     (let [gcd (fn [a b] (cond (= a b) a (> a b) (recur (- a b) b) (< a b) (recur a (- b a))))]\n       (/ (* x y) (gcd x y))))\n  ([x y & r]\n     (println x y r)\n     (if (seq r)\n       (apply lcm (lcm x y) (first r) (rest r))\n       (lcm x y))))","problem":100,"user":"4f048f67535dcb61093f6bd3"},{"code":"#(loop [l (map (partial repeat 2) %&)]\n  (if (apply = (map first l)) (ffirst l)\n      (let [ls (sort-by first l) [a b] (first ls)]\n        (recur (cons [(+ a b) b] (rest ls))))))","problem":100,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn s [& nums]\n  (letfn [(f [prods]\n            (if (apply = prods)\n              (first prods)\n              (let [m (apply min prods)]\n                (recur (map (fn [prod orig]\n                          (if (<= prod m) (+ orig prod) prod))\n                        prods nums)))))]\n    (f nums)))","problem":100,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn lcm[a b & r]\n  (let [gcd (fn gcd[a b]\n   (if (= a b)\n     b\n     (if (> a b)\n       (gcd (- a b) b)\n       (gcd a (- b a))\n      )\n     )\n   )]\n  \n   (if (nil? r)   \n     (/ (* a b) (gcd a b)     \n  )    \n     (lcm a (apply lcm (concat (vector b) r)))\n   )\n    )\n  )","problem":100,"user":"513f53c6e4b051389b345b40"},{"problem":100,"code":"(fn  [& more]\n  (letfn [(gcd [a b]\n            (if (= b 0) a\n                (recur b (rem a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) more)))","user":"54908cc1e4b0b312c081ff32"},{"problem":100,"code":"(fn lcm [& nums]\n   (let [steps (vec nums)]\n     (letfn [(all-same [coll] (every? #(= (first coll) %) coll))\n             (increase-to [n step lim]\n               (if (< n lim)\n                 (increase-to (+ n step) step lim)\n                 n))\n             (increase-smallest-to-largest [vals]\n               (let [smallest-value (apply min vals)\n                     largest-value (apply max vals)\n                     smallest-index (.indexOf vals smallest-value)\n                     largest-index (.indexOf vals largest-value)]\n                 (assoc vals smallest-index (increase-to smallest-value\n                                                         (get steps smallest-index)\n                                                         largest-value))))\n             (iterate [result]\n               (if (all-same result)\n                 (first result)\n                 (iterate (increase-smallest-to-largest result))))]\n       (iterate steps))))","user":"54b817eee4b0ed20f4ff6e93"},{"code":"(fn lcm-chain [& items]\n  (letfn [(gcd [a b]\n            (loop [a a\n                   b b]\n              (cond\n               (zero? b) a\n               (>= a b) (recur (- a b) b)\n               :else (recur b a))))\n          (lcm [a b]\n            (* a (/ b (gcd a b))))]\n    (reduce lcm items)))","problem":100,"user":"530578ede4b0d8b024fd3760"},{"problem":100,"code":"(fn [& more] (reduce #(/ (* %1 %2) ((fn gcd [a b] (if (= 0 b) a (gcd b (mod a b)))) %1 %2)) more))","user":"580c8fcee4b0849f6811b721"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [mult 1]\n    (let [prod (* (first args) mult)]\n      (if (loop [rem (rest args)]\n            (if (empty? rem)\n              true\n              (let [[head & tail] rem]\n                (if (integer? (/ prod head))\n                  (recur tail)\n                  false))))\n        prod\n        (recur (inc mult)))\n      )\n    )\n  )","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":100,"code":"(fn  prob100 [& args]\n  (reduce \n   (fn [x y]\n     (letfn [(gcd [a b]\n               (if (zero? b) \n                 a\n                 (recur b (mod a b))))\n             ]\n       (/ (* x y) (gcd x y)))\n     )\n   args))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn [& args] (let [lcm-attempts (iterate #(+ (apply min args) %) (apply min args))] (ffirst (filter (fn [i] (every? zero? (second i))) (map #(vector % (map (fn [i] (rem % i)) args)) lcm-attempts)))))","problem":100,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn [& c]\n  (letfn [(f [p1 p2]\n                (some #(when (zero? (mod % p1)) %) (iterate #((partial + p2) %) p2)))]\n    (reduce #(if (= 0 (mod %1 %2)) %1\n               (f %1 %2))\n            c)))","problem":100,"user":"52667ecfe4b03e8d9a4a713e"},{"code":"(fn r [& lis]\n  ;(println \"w\" (map (fn[m](range 0 250 m)) lis))\n  (let [\n        a (map set (map (fn[m](range 0 250 m))  lis))\n  b (apply clojure.set/intersection a)\n        ]\n        (second (sort b))\n    )\n  )","problem":100,"user":"4f2004a1535d64f6031464a7"},{"problem":100,"code":"(fn [& args]\n    (letfn [(gcd [a b]\n              (if (= b 0)\n                a\n                (gcd b (mod a b))))]\n      (/ (apply * args)\n        (reduce gcd args))))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":100,"code":"(fn [& x]\n     (let\n       [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n     (reduce lcm x)))","user":"58c71509e4b021aa9917ed6e"},{"code":"(fn lcm [n & ns]\n  (let [abs (fn [x] (if (< x 0) (- x) x))\n        gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        lcm2 (fn [a b]\n               (/ (abs (* a b))\n                  (gcd a b)))]\n    (reduce lcm2 n ns)))","problem":100,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn lcd [ & coll]\n  (loop [ret coll]\n    (if (apply = ret)\n      (first ret)\n      (let [m (apply min ret)\n            indexed-ret (map vector (range) ret)\n            idx (first (for [[i elt] indexed-ret :when (= m elt)] i))\n            m* (nth coll idx)\n            ret* (map-indexed #(if (= idx %) (+ %2 m*) %2) ret)]\n        (recur ret*)))))","problem":100,"user":"4edd038c535d10e5ff6f5327"},{"problem":100,"code":"(fn [& xs]\n  (let [quantum (apply min xs)\n        lcms (map #(* quantum (inc %)) (range))]\n    (some (fn [x] (if (every? #(zero? (rem x %)) xs) x))\n          lcms)))","user":"57dd47f4e4b0bd073c20243e"},{"code":"(fn lcd [& args] (let [increment (let [y (+ (apply max args) 1)] \r\n(/ 1 (apply max (map #(- (denominator (/ % y)) 1) args))))] \r\n(loop [i increment] (if (every? #(= 0 (rem i %)) args) i (recur (+ i increment))))))","problem":100,"user":"4f9336ece4b0dcca54ed6cb7"},{"problem":100,"code":"(fn lcm\n  ([a] a)\n  ([a b]\n    ((fn [cols] (if (empty? cols) (* a b) (first cols)))\n    (for [x (range a 400 a)\n           y (range b 400 b)\n           :when (= x y)] x)))\n  ([a b c] (lcm a (lcm b c)))\n  ([a b c d] (lcm a (lcm b (lcm c d)))))","user":"5e08c3dde4b0978307768fc8"},{"code":"(fn lcm [& args]\n  (let [orig-nums (vec args)]\n    (loop [nums orig-nums]\n      (if (apply = nums)\n        (first nums)\n        (let [[index, elem] (apply (partial min-key (fn [[i, e]] e)) (map-indexed (fn [i e] [i e]) nums))]\n          (recur (assoc nums index (+ (nth nums index) (nth orig-nums index)))))))))","problem":100,"user":"4f047902535dcb61093f6bcc"},{"code":"(fn lcm [& args]\n  (let [mult (apply * (map #(if (ratio? %) (denominator %) 1) args))]\n  (first (for [x (map #(/ % mult) (rest (range 10000)))\n        :when (= 0 (apply + (map (partial mod x) args)))]\n        x))))","problem":100,"user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [x & args]\n  (let [not-cm? (fn [c]\n                  (not (every? #(= 0 (mod c %)) args)))\n        c (iterate #(+ x %) x)\n        v (drop-while not-cm? c)]\n    (first v)))","problem":100,"user":"4fe8fda4e4b0547ebccb2438"},{"problem":100,"code":"(fn [& xs]\n  (let [x (apply max xs)]\n    (loop [n 2]\n      (let [y (* n x)]\n        (if (every?  #(zero? (mod y %)) xs)\n          y\n          (recur (inc n))          \n          )\n        ))\n    ))","user":"5d917ef0e4b0915913b1d402"},{"code":"(fn [& args] \n  (let [gcd #(if (zero? %2) % (recur %2 (rem % %2)))]\n  \t(reduce \n  \t\t#(/ (* % %2) (gcd % %2))\n  \t\targs)))","problem":100,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn [& x]\r\n  (loop [s (map list x x)]\r\n    (let [v (map first s)\r\n          mn (apply min v)\r\n          t (set v)]\r\n      (if (= 1 (count t)) (first t)\r\n        (recur\r\n          (map #(if (not= mn (first %)) %\r\n            (cons (+ (second %) (first %)) (rest %))) s))))))","problem":100,"user":"50464831e4b011c5dfee771f"},{"code":"(fn lcm [& c]\n  (loop [items (zipmap c c)]\n    (let [big (first (apply max-key second items))\n          small (first (apply min-key second items))]\n      (if (= (items big) (items small))\n        (items big)\n        (recur (assoc items small (+ (items small) small)))))))","problem":100,"user":"4e781a2e535d324fb2983d74"},{"code":"(fn [& s] (/ (reduce * s) (reduce #(if (= 0 %2) %1 (recur %2 (mod %1 %2))) s)))","problem":100,"user":"52160dbee4b0bf4bffd29cb3"},{"code":"(fn lcm \n  ([x y]\n    (loop [a x b y]\n      (let [r (rem a b)]\n        (if (= r 0) ;; then b = gcd -> lcm = x*y/gcd\n          (/ (* x y) b)\n          (recur b r)))))\n  ([x y & args] (lcm x (apply lcm (cons y args)))))","problem":100,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [& l]\n            (reduce\n              (let [gcd (fn [a b]\n                          (if (> a b)\n                            (recur b a)\n                            (if (= a 0) b (recur a (mod b a)))))]\n                (fn [a b] (/ (* a b) (gcd a b))))\n              l))","problem":100,"user":"4e8df08f535d65386fec213e"},{"code":"(fn [& args] \n  (reduce #(loop [curr-lcm %1\n                  lcm %1 \n                  val %2]\n              (if (= 0 (rem lcm val))\n                  lcm\n                  (recur curr-lcm (+ lcm curr-lcm) val)))\n          args))","problem":100,"user":"501fa1aee4b0cb6ebc0a42eb"},{"problem":100,"code":"(fn [& coll]\n  (/\n   (reduce * coll)\n   (reduce #(if (zero? %2) %1 (recur %2 (rem %1 %2))) coll)))","user":"59e0f38ae4b08badc2a0c500"},{"problem":100,"code":"(fn p-100 [& nums]\n (let [gcd (fn gcd [a b]\n                  (cond (< a b) (gcd b a) ; have *a* bigger\n                        (= 0 (mod a b)) b\n                        :else (gcd b (mod a b))))]\n  (/ (reduce * nums) (reduce gcd nums))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"515e8ce2e4b049add99a053d"},{"problem":100,"code":"(fn lcm [& v]\n  (loop [m v]\n    (if (apply = m)\n      (first m)\n      (recur (map-indexed (fn [index item] (if (= item (apply min m)) (+ item (nth v index)) item)) m)))))","user":"55934bebe4b0c79f6e1db93b"},{"problem":100,"code":"(fn [& nums]\n  (let \n    [gcd (fn [a b]\n      (if (zero? b)\n        a\n        (recur b (mod a b))\n      )\n     )\n     lcm (fn [a b] (/ (* a b) (gcd a b))) \n    ]\n    (/ (reduce lcm (map #(if (ratio? %) (numerator %) %) nums))\n       (reduce gcd (map #(if (ratio? %) (denominator %) 1) nums)))\n  )\n)","user":"543bb568e4b032a45b869334"},{"code":"(fn lcm [x & r]\n  (->> x\n       (iterate #(+ x %))\n       (filter (fn [n] (every? #(zero? (rem n %)) r)))\n       first))","problem":100,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn [& args]\n  (let [lcm (fn lcm [a b]\n    (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b, (mod a b))))]\n      (/ (* a b) (gcd a b))))]\n  (reduce lcm args)))","problem":100,"user":"4e9fd521535d7eef3080729a"},{"problem":100,"code":"(fn [& numbers]\n  (letfn [(thomae [x]\n            (cond (integer? x)\n                  1\n                  (ratio? x)\n                  (/ (denominator x))\n                  :else\n                  0))\n          (gcd [a b]\n            (* a (thomae (/ b a))))]\n    (/ (reduce * numbers)\n       (reduce gcd numbers))))\n\n#_\n(fn [& numbers]\n  (letfn [(min-index [xs]\n            (loop [m (first xs)\n                   ys (rest xs)\n                   mi 0\n                   i 1]\n              (if (empty? ys)\n                mi\n                (let [smaller? (< (first ys) m)]\n                  (recur (if smaller? (first ys) m)\n                         (rest ys)\n                         (if smaller? i mi)\n                         (inc i))))))]\n    (loop [vs (vec numbers)]\n      (if (apply = vs)\n        (first vs)\n        (let [mi (min-index vs)]\n          (recur (assoc vs mi (+ (nth vs mi)\n                                 (nth numbers mi)))))))))","user":"580bd81ee4b0849f6811b711"},{"problem":100,"code":";; http://www.4clojure.com/problem/100\n(fn lcm\n  [& args]\n  (let [gcd (fn  [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (apply * args) (reduce gcd args))))","user":"5c92105ce4b048ec896c59f7"},{"problem":100,"code":"(fn f [a b & r]\n  (let [g (fn g [a b]\n            (if (zero? b)\n              a\n              (g b (mod a b))))\n        v (/ (* a b)\n             (g a b))]\n    (if (seq r)\n      (apply f v r)\n      v)))","user":"53523ae0e4b084c2834f4aee"},{"problem":100,"code":"(fn [& s] (reduce (fn [a b] (/ (* a b) (#(if (= (rem %1 %2) 0) %2 (recur %2 (rem %1 %2))) a b))) s))\n;; v = a*b/D","user":"584d99c5e4b0b7285a6f4e42"},{"problem":100,"code":"(fn [& xs]\n\t\t(loop [xs (map #(vector % %) xs)]\n\t\t\t(letfn [(done? [] (every? #(= (second %) (-> xs first second)) xs))]\n\t\t\t\t(if (done?)\n\t\t\t\t\t(-> xs first second)\n\t\t\t\t\t(let [sorted (sort-by #(second %) xs) smallest (first sorted)]\n\t\t\t\t\t\t(recur (cons [(first smallest) (+ (second smallest) (first smallest))] (rest sorted)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"5409f8eae4b0addc1aec66e6"},{"problem":100,"code":"(fn [& nums]\n  (let [m (apply max nums)]\n    (first (filter\n            (fn [x]\n              (every? true? (map #(= 0 (mod x %)) nums)))\n            (iterate #(+ m %) m)))))","user":"5522cd9ae4b0882d96d091ab"},{"problem":100,"code":"(fn lcd [& nums] (let [gcd (fn [x y] (cond (= x y) x (> x y) (recur (- x y) y) :else (recur x (- y x))))] (reduce (fn [a b] (/ (* a b) (gcd a b))) nums)))","user":"5addadfce4b0837691e92c13"},{"problem":100,"code":"(fn [& args]\n\t(letfn [(gcd [a b]\n                 (let [a-mod-b (mod a b)]\n                   (if (zero? a-mod-b) b (gcd b a-mod-b))))]\n      (reduce (fn lcm [a b]\n                (/ (* a b) (gcd a b)))\n              args)))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":100,"code":"(fn [& args]\n  (reduce (fn [a b]\n            (let [gcd ((fn [a b]\n                         (if (not= b 0)\n                           (let [t b\n                                 b (mod a b)\n                                 a t]\n                             (recur a b))\n                           a))\n                       a b)]\n              (/ (* a b) gcd)))\n          args))","user":"56732c84e4b05957ce8c611c"},{"code":"(let [llcm\n      (fn tst [x] (if (every? #(= (first x) %) x)\n       (key (first x))\n       (tst \n        (merge \n         (sorted-map (+ (key (first x)) (val (first x)))\n                     (val (first x)))\n         (drop 1 x)))))]\n(let [process\n      (fn proc [x] \n        (if (= 2 (count x))\n          (llcm x)\n          (proc (merge (hash-map (llcm (take 2 x))\n                                 (llcm (take 2 x)))\n                       (drop 2 x)))))]\n        \n(fn lcm\n  [x & args] \n    (process \n     (apply merge \n            (map #(sorted-map % %) (cons x args)))))))","problem":100,"user":"52e17e66e4b09f7907dd1423"},{"code":"(fn [& n] (reduce #(/ (* %1 %2) ((fn gcd [a b] (if (zero? b) a (recur b (mod a b)))) %1 %2)) n))","problem":100,"user":"511b810ce4b07ab9ec456182"},{"problem":100,"code":"(fn [& args]\n              (letfn [(my-gcd [x y]\n                        (if (= 0 y)\n                          x\n                          (my-gcd y (mod x y))))]\n                (reduce (fn [result x]\n                          (/ (* result x) (my-gcd result x)))\n                        (first args) args)))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":100,"code":"(fn __ [x & ys]\n  (loop [r x\n         a x\n         bs ys]\n   (if (every? #(zero? (mod r %)) bs)\n     r\n     (recur (+ r a) a bs ))))","user":"55916764e4b0604b3f94d57b"},{"problem":100,"code":"(fn [& nums]\n    (let [abs (fn [x]\n                (max x (- x)))\n          gcd (fn [x y](loop [big (max x y) small (min x y)]\n                         (let [remainder (mod big small)]\n                           (if (zero? remainder) small (recur small remainder)))))\n          lcm (fn [x y]\n                (/ (abs (* x y)) (gcd x y)))]\n      (reduce #(lcm %1 %2) nums)))","user":"564348e1e4b08d4f616f5f26"},{"code":"(fn lcm\r\n  ([a b]\r\n    (letfn [(gcd [a b]\r\n              (loop [a a b b]\r\n                (cond\r\n                  (= a 0) b\r\n                  (= b 0) a\r\n                  (> a b) (recur (mod a b) b)\r\n                  :else   (recur (mod b a) a))))]\r\n      (/ (* a b) (gcd a b))))\r\n  ([a b & args]\r\n    (apply lcm (lcm a b) args)))","problem":100,"user":"4df669d4535d08e6dec9fe35"},{"problem":100,"code":"(fn lcma [& args]\n  (let [\n       gcd (fn  [a b] (if (zero? b) a (recur b (mod a b))))\n       lcm (fn  [a b] (/ (* a b) (gcd a b)))]\n (reduce lcm args)))","user":"525b142fe4b0cb4875a45d05"},{"problem":100,"code":"(fn [& args]\n (let [lss (fn lss\n  ([x]          [(first x)])\n  ([x y]        (cond ((complement sequential?) x) (lss y)\n                      ((complement sequential?) x) (lss x)\n                      (= (first x) (first y))      (cons (first x) (lazy-seq (lss (rest x) (rest y))))\n                      (< (first x) (first y))      (lazy-seq (lss (drop-while (partial > (first y)) x) y))\n                      (< (first y) (first x))      (lazy-seq (lss (drop-while (partial > (first x)) y) x))))\n  ([x y z] (lss x (lss y z)))\n  ([w x y z] (lss (lss w x) (lss y z))))\n       multiples (fn multiples\n                     [x]\n                     (map (partial * x) (range 1 Double/MAX_VALUE)))]\n          (first(apply lss (map multiples args)))))","user":"544e8369e4b0e39780006987"},{"problem":100,"code":"(fn [& xs] \n  (letfn [\n    (gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n    (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"552d9b31e4b076ab5578f7eb"},{"problem":100,"code":"(fn [& args]\n      (let [gcd (fn [a, b] (loop [x (if (> a b) (list b a) (list a b))] (let [d (rem (second x) (first x))] (if (= d 0) (first x) (recur (conj x d) )))))]\n\n           (reduce #(/ (* %1 %2) (gcd %1 %2)) args)\n\n           )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":100,"code":"(fn [& ns]\n   (letfn [(gcd [n1 n2]\n             (cond\n               (= n1 n2) n1\n               (> n1 n2) (gcd (- n1 n2), n2)\n               :else (gcd n1 (- n2 n1))))\n           (lcm [n1 n2]\n             (/ (* n1 n2) (gcd n1 n2)))]\n     (reduce lcm ns)))","user":"5eb1c786e4b00a66d4a95201"},{"problem":100,"code":"(fn\n  [& xs]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [m n]\n            (/ (* m n) (gcd m n)))]\n    (reduce lcm xs)))","user":"55ed5a2de4b0121d4835fdd8"},{"problem":100,"code":"(fn [& args]\n  (loop [step (apply max args) i step args args]\n    (if (every? (partial = 0) (map #(rem i %) args))\n      i\n      (recur step (+ i step) args))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [& c]\n  (first\n   (filter\n    (fn [x]\n      (apply = 0 (map\n                  #(mod x %)\n                  c)))\n    (next (map #(* (apply min c) %) (range))))))","problem":100,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":100,"code":"#(letfn [ (g [a b] (if (= b 0) a (g b (mod a b))))\n          (k [a b] (/ (* a b) (g a b)))]\n(reduce k %&))","user":"56bca51ae4b0f26550335963"},{"problem":100,"code":"(fn [t1 & terms] \n  (first \n    (filter \n      (fn [x] \n        (every? \n          #(= 0 (mod x %)) \n          terms)) \n      (map #(* t1 (inc %)) \n           (range)))))","user":"5d4f21f3e4b0776584bd6f4e"},{"code":"(fn p100s [& s]\n  (let [\n        fun (fn lazyincs [x] (fn [y] (+ x y)))\n        funs (map #(fun %1) s)\n        get-if-less (fn [maxv] (fn [idx itm] (if (< itm maxv) ((nth funs idx) itm) itm)))\n        ]\n    (loop [vals s]\n      (if (= 1 (count (set vals)))\n        (first (set vals))\n        (recur (map-indexed (get-if-less (apply max vals)) vals)) \n        )\n      )\n    )\n  )","problem":100,"user":"4f63777be4b0defedf855fe4"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (abs [x] (if (neg? x) (- 0 x) x))\n          (aux [a b] (/ (abs (* a b)) (gcd a b)))\n          (gaux [x y]\n            (let [a (if (integer? x) x (numerator x))\n                  b (if (integer? x) 1 (denominator x))\n                  c (if (integer? y) y (numerator y))\n                  d (if (integer? y) 1 (denominator y))\n                  \n                  lcm-bd (aux b d)\n                  a (* a (/ lcm-bd b))\n                  c (* c (/ lcm-bd d))\n                  lcm-ac (aux a c)]\n              (/ lcm-ac lcm-bd)))]\n    (let [res (reduce gaux xs)]\n      (if (integer? res)\n        (int res)\n        res))))","problem":100,"user":"500ff421e4b0ae202717946f"},{"code":"; LCM = num1 * num2 /  gcd ( num1 , num2 )\n; lcm(a,b,c) = lcm(a,lcm(b,c))\n; reduce(lcm, args)\n; via http://stackoverflow.com/questions/147515/least-common-multiple-for-3-or-more-numbers\n\n(fn [& args]\n  (letfn \n    [(gcd [x y]\n       (if (zero? y) x (gcd y (mod x y))))\n     (lcm [a b]\n       (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n  )\n)","problem":100,"user":"4e720985535d5021c1a89655"},{"code":"(fn [& c]\n           (loop [s (vec c)]\n              (if (apply = s)\n                  (first s)\n                  (recur \n                   (let [[sv,i,cv] (apply min-key first (map vector s (range) c))]\n                        (assoc s i (+ sv cv)))))))","problem":100,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn [ & xs]\n    (let [ maxm (reduce #(* %1 (if (ratio? %2) (* (numerator %2) (denominator %2)) %2)) 1 xs)\n           itxs (map #(set (take-while (partial >= maxm) (iterate (partial + %1) %1))) xs)\n           intersection (fn [s1 s2] (reduce #(if (contains? s1 %2) %1 (disj %1 %2)) s2 s2))\n           inter-itxs (reduce intersection (first itxs) (rest itxs))]\n    (apply min inter-itxs)\n    ))","problem":100,"user":"51f59607e4b0abb92f97f9d5"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (/ (apply * xs)\n       (reduce gcd xs))))","user":"5393185ae4b0b51d73faaeb7"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [a b] (if (= b 0)\n                       a\n                       (gcd b (mod a b))))\n          (lcm2 [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm2 args)))","problem":100,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":100,"code":"(fn [& args]\n(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n(reduce (fn [a b] (* (/ a (gcd a b)) b)) args)))","user":"56941e48e4b0dcc4269f410d"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [[f & r] xs]\n    (->> (iterate #(+ f %) f)\n         (filter (fn [n] (every? #(= 0 (mod n %)) r)))\n         first)))","user":"53b39d82e4b047364c0444a6"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn [& rs]\n  (let [nums (map #(if (ratio? %) (numerator %) %) rs)\n        dens (map #(if (ratio? %) (denominator %) 1) rs)\n        gcd (fn [a b]\n              (if (= b 0) a\n                (recur b (mod a b))))]\n    (/\n      (reduce #(/ (* %1 %2) (gcd %1 %2)) nums)\n      (reduce gcd dens))))","problem":100,"user":"527cd633e4b0757a1b17136f"},{"code":"; unapologetic brute force\n(fn lcm [& nums]\n  (first\n    (filter\n      (fn [n] (every? #(= (mod n %) 0) nums))\n      (map\n        (partial * (apply max nums))\n        (iterate inc 1)))))","problem":100,"user":"53307da1e4b019098a6f8b5e"},{"problem":100,"code":"(fn [x & xs] (first (filter (fn [m] (every? zero? (map #(rem m %) xs)))\n                     (iterate #(+ x %) x))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":100,"code":"(fn mcm [a b & xs]\n\t(let [mcd (fn mcd\n\t\t\t\t  ([a b]\n\t\t\t\t   (if (zero? (rem a b))\n\t\t\t\t\t   b\n\t\t\t\t\t   (mcd b (rem a b))\n\t\t\t\t\t   ))\n\t\t\t\t  ([a b & xs]\n\t\t\t\t   (reduce mcd (mcd a b) xs)))]\n\t\t(/ (apply * a b xs) (apply mcd a b xs))))","user":"552bd5c2e4b0ffed3738f969"},{"problem":100,"code":"(fn lcm [& args]\n  (reduce\n   (fn [x# y#]\n     (* y# (/ x# (#(loop [x x# y y#]\n                     (if (= x y)\n                       x\n                       (if (< x y)\n                         (recur x (- y x))\n                         (recur y (- x y))\n                         )\n                       )))))) args))","user":"560ac5cae4b05f002753df09"},{"code":"(fn [& v] (first \n           (for [i (rest (range)) :let [x (* i (apply max v))]\n                 :when (every? zero? (map #(mod x %) v))] x)))","problem":100,"user":"528e64b7e4b0239c8a67aedd"},{"problem":100,"code":"(fn [& nums]\n    (letfn [(map-invert [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))]\n      (loop [r (zipmap nums nums)]\n        (if (apply = (vals r))\n          (first (vals r))\n          (let [lk ((map-invert r) (apply min (vals r)))]\n            (recur (assoc r lk (+ (r lk) lk))))))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn [& nums]\r\n    (let [arr-update (fn [arr i orgarr]\r\n                       (let [[fp sp] (split-at i arr)]\r\n                         (concat fp [(+ (first sp) (nth orgarr i))] (rest sp))))\r\n          min-index-of (fn [arr]\r\n                         (.indexOf arr (apply min arr)))]\r\n      (loop [xs nums]\r\n        (if (apply = xs)\r\n          (first xs)\r\n          (recur (arr-update xs (min-index-of xs) nums))))))","problem":100,"user":"4ef1ee67535dced4c769f219"},{"problem":100,"code":"(fn lcm [x y & args]\n  (let [product (* (if (< x 1) (denominator x) 1) (if (< y 1) (denominator y) 1))\n        dx (* product x)\n        dy (* product y)\n        m (inc (max dx dy))\n        multi (fn [n m] (map #(* n %) (range 1 m)))\n        xm (multi dx m)\n        ym (multi dy m)\n        ret (first  (for [s xm t ym :when (= s t)]  s))]\n    (if (empty? args)\n      (/ ret product)\n      (apply lcm (/ ret product) args))))","user":"5793931ee4b0e215f87e845c"},{"code":"(fn common-mul [& rest]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))]\n    (reduce (fn [acc e] (/ (* acc e) (gcd acc e))) rest)))","problem":100,"user":"52f8f4d1e4b047fd55836fde"},{"problem":100,"code":"(fn [& col]\n  (let [fir (first col)\n        ocol (rest col)]\n    (loop [i 1 s (* i fir)] \n      (if (= 0 (apply + (map #(rem s %) ocol))) s  (recur (inc i) (* i fir))))))","user":"5243e37ae4b076204b44fae3"},{"problem":100,"code":"(fn lcm00 [x & xs]\n  (if (nil? xs) x\n    (let [\n           gcd (fn [a b] (if(= a b)a(recur (min a b) (.abs (biginteger (- a b))))))\n           den (fn [x] (if (ratio? x)(denominator x)1))\n           nume (fn [x] (if (ratio? x)(numerator x)x))\n           y (first xs)\n           nx (nume x)\n           ny (nume y)\n           dx (den x)\n           dy (den y)\n           gcd0 (gcd dx dy)\n           down (/ (* dx dy) gcd0)\n           cx (/ down dx)\n           cy (/ down dy)\n           up (* cx nx cy ny)\n           ]\n      (apply lcm00 (cons (/ up down) (rest xs)))\n      )\n    )\n  )","user":"55f01316e4b06e875b46ce1a"},{"problem":100,"code":"(fn\n  [& arg]\n  (let [m (zipmap arg arg)]\n    (loop [m m]\n      (if (not (apply = (vals m)))\n        (let [s (sort-by second m) [k v] (first s)]\n          (recur (assoc m k (+ k v))))\n        (first (vals m))))))","user":"555c6344e4b0b056612e224c"},{"problem":100,"code":"(fn __ [& args]\n  (letfn [(gcd [a b]\n            (let [c (mod a b)]\n              (if (= c 0) b (recur b c))))]\n    (/ (apply * args)\n       (apply min (for [a args b args] (gcd a b))))))","user":"526759b3e4b03e8d9a4a715b"},{"problem":100,"code":"(fn [& nums]\n           (let [sorted-nums (-> nums sort reverse)\n                 max-num (first sorted-nums) rest-nums (rest sorted-nums)\n                 num-series (lazy-seq (iterate (partial + max-num) max-num))\n                 mod-check (fn [a] (apply (partial = 0) (map #(mod a %) rest-nums)))]\n             (first (filter mod-check num-series))))\n\n;(fn [G & n] (reduce #(/ (* % %2) (G % %2)) n))\n;(fn g [a b] (if (= b 0) a (g b (rem a b))))","user":"544cf5d7e4b0e39780006977"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn gcd [x y]\n              (if (zero? y)\n                x\n                (gcd y (mod x y))))]\n    (reduce (fn [x y]\n              (/ (* x y) (gcd x y)))\n              args)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":100,"code":"(fn [& ns]\n    (let [min (apply min ns)]\n      (->> (iterate (partial + min) min)\n           (filter #(apply = 0 (map (partial mod %) ns)))\n           first)))","user":"4f57c913e4b0a7574ea7183f"},{"problem":100,"code":"(fn lcm\n([a b]\n(let [gcd (loop [ga a\n                 gb b]\n    (if (zero? gb)\n        ga\n       (recur gb (mod ga gb))))]\n    (/ (* a b) gcd)))\n\n ([a b & args]\n  (reduce lcm (conj args a b))))","user":"5957cc41e4b066ee0a44af76"},{"problem":100,"code":"(fn\n  [x & r]\n  (let [max (reduce max x r)\n        args (conj r x)]\n    (loop [m 1\n           lcm max]\n      (if (= (reduce + (map (partial mod lcm) args)) 0)\n        lcm\n        (recur (inc m) (* max m))))))","user":"529735cbe4b02ebb4ef7503c"},{"problem":100,"code":"(fn [& values]\n  (let [maximum (apply * (map #(if (ratio? %) (denominator %) %) values))\n        multiples (fn [v] (map #(* v %) (drop 1 (range))))]\n    (->> values\n         (mapcat (fn [v] (take-while #(<= % maximum) (multiples v))))\n         frequencies\n         (filter (fn [[v f]] (= f (count values))))\n         (map first)\n         (apply min))))","user":"5463c824e4b01be26fd746c5"},{"problem":100,"code":"(fn [x & xs] (loop [number x]\n  (if (= 0 (count (filter #(not (= 0 (mod number %))) xs)))\n    number\n    (recur (+ number x))\n)))","user":"55d79b87e4b0e31453f64aa8"},{"code":"(fn [& col] \n  (let [start (apply min col)                               \n        multiple? #(every? zero? (map (partial mod %) col))]                        \n    (first (filter multiple? (iterate #(+ start %) start)))))","problem":100,"user":"500aa15ee4b03d00572d2d76"},{"problem":100,"code":"(fn [& n]\n        (letfn [(gcd [a b]\n                  (if (= b 0)\n                    a\n                    (recur b (mod a b))))\n                (lcd [a b]\n                  (/ (* a b) (gcd a b)))]\n          (reduce lcd n)))","user":"541ae7dbe4b01498b1a71a61"},{"problem":100,"code":"#(loop [m (apply min %&)\n         n %&\n         l m]\n    (if (every? zero? (map (partial mod l) n))\n      l\n      (recur m n (+ l m))))","user":"4e38f245535deb9a81d77f3e"},{"code":"(fn [& xs]\n  (/ (apply * xs)\n    (reduce #(if (zero? %2) % (recur %2 (mod % %2))) xs)))","problem":100,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn [& q] (letfn [(lcm [l] (if (empty? l) 1  (let [mi (apply min l) mx (inc (apply * l))] (apply min (filter #(reduce (fn [acc e] (and acc (zero? (rem % e)))) \n                                                                                                                      \n                                                                                                                         true? l) (range mi mx)))))) \n                  (lcd [l1] (if (empty? l1) 1 (apply max (filter (fn [e] (reduce #(and % (zero? (rem %2 e))) true l1)) \n                                                                  (range 1 (inc (apply max l1))))))) ] (let [r (filter #(= (type %) clojure.lang.Ratio) q) \n                                                                                                              z (filter #(= (type %) java.lang.Long) q)] \n                                                                                                          (/ (lcm (concat (map numerator r) z)) \n                                                                                                             (lcd (map denominator r))))))","problem":100,"user":"52265e41e4b04e78ff2e1981"},{"code":"(fn lcm [& args] (reduce \n                  (fn [n1 n2] (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))] \n                                (/ (* n1 n2) (gcd n1 n2)))) \n                  (into [] args)))","problem":100,"user":"534c1c64e4b084c2834f4a8a"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n    \t\t\t\ta\n    \t\t\t\t(recur b (mod a b))))]\n  \t(/ (apply * xs)\n     \t(reduce gcd xs))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":100,"code":"(fn [& coll]\n  (let [gcd2 (fn gcd2 [a b]\n               (if (= b 0) a (gcd2 b (rem a b))))\n        gcd (reduce gcd2 coll)]\n    (/ (apply * coll) gcd)))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":100,"code":"(fn lcm [& args]\n  (let [smallest (apply min args)]\n    (loop [i smallest]\n      (if (every? true? (map #(= (rem i %) 0) args))\n        i\n        (recur (+ i smallest))))))","user":"572010a4e4b0c5bde472c08c"},{"code":"(fn [& xs]\n       (letfn [(gcd [a b]\n  \t    (if (= 0 b)\n\t\t      a\n\t\t      (gcd b (mod a b))))\n\t       (lcm [a b]\n\t\t    (/ (* a b) (gcd (max a b) (min a b))))]\n\t (reduce lcm xs)))","problem":100,"user":"4ee82223535d93acb0a66877"},{"problem":100,"code":"(fn lcm [& coll]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n             (/ (reduce * coll) (reduce gcd coll))))","user":"554f7ef2e4b00713264bd9a1"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (rem a b))))]\n    (reduce (fn [x y]\n              (let [cm (reduce * (map denominator (filter (complement integer?) [x y])))\n                    [a b] (map #(* % cm) [x y])]\n                (/ (* a b) cm (gcd a b)))) nums)))","user":"591072e0e4b0163c97b36ebc"},{"problem":100,"code":"(fn lcm [& numbers]\n   (let [[f & r] numbers]\n     (if (empty? r)\n       f\n       (apply lcm (conj (rest r)\n                  (/ (* f (first r))\n                     (loop [a f\n                            b (first r)]\n                       (if (zero? b)\n                         a\n                         (recur b (mod a b))))))))))","user":"55860905e4b001b0851d7516"},{"problem":100,"code":"(fn [& v] (let [x (apply max v)] (loop [i x] (if (every? zero? (map #(mod i %) v)) i (recur (+ i x))))))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn p100 [& ns]\n  (letfn [(nn [rto]\n  (if (integer? rto) [rto 1]\n      ((fn v [x i] (if (integer? (* x i)) [(* x i) i] (v x (inc i)))) rto 2)))]\n  (let [vs (map nn ns)\n\tdm  (apply * (map second vs))\n\tls (map (fn [x] (if (= 1 (second x)) (first x) (* dm (/ (first x) (second x)) )))  vs)\n\tgcm (first (filter (fn [y] (every? identity (map #(zero? (mod % y)) ls))) (for [i (range (apply min ls) 0 -1)] i)))\n\t]\n    (/ (apply * ls) dm gcm))))","problem":100,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [& p]\n  (loop [s p c (apply max p)]\n        (if (apply = s)\n            (first s)\n          (let [m (map #(cond (< % c) %2 :else 0) s p)\n                n (map + s m)]\n            (recur n (apply max n))))))","problem":100,"user":"4db016af838c48654951d9b9"},{"problem":100,"code":"(fn [& arg] \n  (let [f (fn [x y] \n              (if (zero? y) \n                x (recur y \n                         (mod x y))))]\n    (/ (reduce * arg) (reduce f arg))))","user":"5aa4b961e4b0d174b936c888"},{"problem":100,"code":"(fn lcm [x & xs]\n  (->> (range)\n       (drop 1)\n       (map (partial * x))\n       (filter #(every? zero? (map (partial mod %) xs)))\n       first))","user":"5d929ceae4b0915913b1d412"},{"problem":100,"code":"(fn [& x]\n   (first \n    (sort \n     (apply \n      clojure.set/intersection \n      (map \n       #(into #{} (range % 1000 %))\n       x)))))","user":"576e607ae4b0979f89651579"},{"problem":100,"code":"(fn [a & nums] \n  (* a (first (filter\n          (fn [x] \n                (every? #(zero? (rem (* x a) %))\n                        nums)\n                )\n              (rest (range))\n              )\n         ))\n  )","user":"5ade6bafe4b0837691e92c23"},{"problem":100,"code":"(fn [& x] (reduce #(/ (* % %2) ((fn [a b]\n        (if (= 0 b)\n          a\n          (recur b (mod a b)))) % %2)) x))","user":"58391c94e4b089d5ab817d35"},{"code":"(fn [& as]\n  (letfn [(gcd [a b]\n            (if (= a 0)\n              b\n              (recur (rem b a) a)))]\n     (reduce #(* (/ % (gcd % %2)) %2) as)))","problem":100,"user":"50657775e4b0deb876850599"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (let\n      [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"57235dc4e4b0c5bde472c0e2"},{"problem":100,"code":"#(letfn [(gcd [a b]\n            (cond (= a b) a\n                  (> a b) (recur (- a b) b)\n                  (< a b) (recur a (- b a))))\n          (lcd [x y]\n               (/ (* x y) (gcd x y)))]\n    (reduce lcd %&))","user":"5eb3d02be4b00a66d4a95215"},{"problem":100,"code":"(fn [x & xs]\n  (let [_gcd (fn [a b]\n              (if (zero? b) a\n                (recur b (mod a b))))\n        _lcm (fn [x y]\n               (/ (* x y) (_gcd x y))) ]\n    (if (empty? xs) x\n      (recur (_lcm x (first xs)) (rest xs)))))","user":"50ec409ce4b04edc33777045"},{"problem":100,"code":"(fn [& nums]\n(letfn [(min-ind [xs] (apply min-key first (map vector xs (range))))\n        (all-eq [[fx :as xs]] (when (every? #(= fx %) xs) xs))\n        (next-iter [xs] (let [[m mi] (min-ind xs)] (concat (take mi xs) [(+ m (nth nums mi))] (drop (inc mi) xs))))\n        ]\n  (->> nums (iterate next-iter) (some all-eq) first)))","user":"53908e6be4b0b51d73faae9a"},{"problem":100,"code":"(fn [& nums] (let [min_n (apply min nums)]\n               (loop [multiplier 1]\n                 (let [cur_n (* min_n multiplier)]\n                   (if (reduce (fn [m, n] (and (zero? (mod cur_n n)) m)) true nums)\n                     cur_n\n                     (recur (inc multiplier)))))))","user":"565233f2e4b0f9d632dd8461"},{"problem":100,"code":"(fn [& l]\n  (letfn\n    [\n      (gcd [a b]\n        (loop [x a y b]\n          (if (= 0 y)\n            x\n            (recur y (mod x y))\n          )\n        )\n      )\n      (lcm [a b]\n        (/ (* a b) (gcd a b))\n      )\n      (num [x]\n        (if (integer? x)\n          x\n          (numerator x)\n        )\n      )\n      (den [x]\n        (if (integer? x)\n          1\n          (denominator x)\n        )\n      )\n      (lcm-ratio [a b]\n        \n        (/ (lcm (num a) (num b)) (gcd (den a) (den b)))\n      )\n    ]\n    (reduce lcm-ratio l)\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"code":"(fn lcm [& xs]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","problem":100,"user":"5102ac9de4b00c483ae176fa"},{"problem":100,"code":"(fn [& lst]\n  (apply min (apply clojure.set/intersection \n     (map \n      #(into #{} (take 1000 (map (partial * %) (iterate inc 1)))) \n      lst))))","user":"5e6ca949e4b04a83ad7cd289"},{"problem":100,"code":"(fn [a & args]\n  (->> (drop 1 (range))\n       (map (partial * a))\n       (filter (fn [x] (every? (fn [y] (zero? (mod x y)))\n                               args)))\n       first))","user":"52173464e4b082aa80a88c75"},{"problem":100,"code":"(fn [& args]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n     (/ (reduce * args) (reduce gcd args))))","user":"60521ea8e4b056659d634205"},{"code":"(fn [& x]\n  (letfn [\n    (lcm [curr orig]\n      (if (apply = curr)\n        (first curr)\n        (let [min-val (apply min curr)]\n          (lcm (map #(if (= min-val %1) (+ %1 %2) %1) curr orig) orig))))]\n    (let [denoms (map #(if (ratio? %) (denominator %) 1) x)\n          numers (map #(if (ratio? %) (numerator %) %) x)\n          lcm-d (lcm denoms denoms)\n          xnumers (map #(* %1 (/ lcm-d %2)) numers denoms)\n          lcm-u (lcm xnumers xnumers)]\n      (/ lcm-u lcm-d))))","problem":100,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn [& s]\n  (let [gcd (fn gcd [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm s)))","problem":100,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":100,"code":"(fn least-common-multiple\n  ([first-num & tail]\n   (least-common-multiple (cons (vector first-num) tail)))\n  ([[first-num & tail]]\n   (if (every? #(= (rem (last first-num) %) 0) tail)\n     (last first-num)\n     (least-common-multiple (cons (conj first-num (+ (first first-num) (last first-num))) tail)))))","user":"60396c95e4b0d5df2af222f4"},{"code":"(fn [& args]\n    (letfn [(gcd[a b] (if (= b 0) a (recur b (mod a b))))\n            (lcm[a b] (/ (* a b)(gcd a b)))]\n      (reduce lcm args)))","problem":100,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (letfn [(gcd [m n]\n             (if (= n 0) m\n                 (recur n (mod m n))))]\n     (/ (* a b) (gcd a b))))\n  ([a b & more]\n   (reduce lcm (lcm a b) more)))","user":"5f5e166ce4b02876ed9fcfed"},{"problem":100,"code":"(fn [& args] \n  (let [xs0 args,\n        next-iter (fn [xs [mi mx]] \n                    (map-indexed (fn [i x] (if (= i mi) \n                                             (+ mx (nth xs0 mi)) \n                                             x)) \n                                 xs)),\n        min-ind (fn [xs] \n                  (apply min-key second (map-indexed vector xs)))]\n    (loop [xs xs0, m (min-ind args)]\n      (if (apply = xs) \n        (first xs)\n        (let [xsn (next-iter xs m)]\n          (recur xsn (min-ind xsn)))))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":100,"code":"(fn lcm [& a]\n  (loop [b (vec a) v (vec a)]\n         (if (apply = v) (first v)\n           (let [n (.indexOf v (first (sort v)))]\n             (recur b (update-in v [n] #(+ (b n) %)))))))","user":"53e745a1e4b036ad0777e479"},{"problem":100,"code":"(fn [& args] (reduce (fn [a b] (letfn [(gcm [a b] (if (zero? b) a (recur b (mod a b))))] (/ (* a b) (gcm a b)))) args))","user":"58987ee9e4b00487982d52d2"},{"code":"(fn [& vals]\n  (loop [remaining vals]\n    (if (= 1 (count remaining))\n      (first remaining)\n      (let [gcd ((fn [x y]\n                   (cond \n                     (= x y) x\n                     (< x y) (recur x (- y x))\n                     (> x y) (recur (- x y) y)))\n                 (first remaining) (second remaining))\n            lcd (/ (* (first remaining) (second remaining)) gcd)]\n        (recur (conj (drop 2 remaining) lcd))))))","problem":100,"user":"51ae350fe4b09397d5109790"},{"problem":100,"code":"(fn sol [& args] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n  (let [nums (map #(if (ratio? %) (numerator %) %) args)\n                         denoms (map #(if (ratio? %) (denominator %) 1) args)\n                         ] (/ (reduce * nums) (reduce gcd denoms)))))","user":"54857657e4b0e286459a11ac"},{"problem":100,"code":"(fn lcm[& n]\n  (letfn [(gcd [a b]\n  \t(if (= b 0)\n    \ta\n    \t(gcd b (mod a b))))\n      (lcm [a b] (/ (* a b) (gcd a b)))]\n  (reduce lcm n)))","user":"5fe09d1fe4b05ac5b16ea15b"},{"code":"(fn lcd [& xs]\n  (let [gcd (fn gcd [x y]\n              (cond\n                (zero? y) x\n                (> x y) (gcd y (mod x y))\n                :else (gcd x (mod y x))))\n        lcd_ (fn [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcd_ xs)))","problem":100,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":100,"code":"(fn [& p]\n\n  (let [lcm (fn [a b]\n              (loop [m a\n                     n b]\n                (cond (< m n) (recur (+ m a) n)\n                      (> m n) (recur m (+ n b))\n                      :else   m)))]\n\n    (reduce lcm (first p) (rest p))))","user":"562268dce4b03f08ee9a9224"},{"problem":100,"code":"(fn least-common-multiple-gcd-based\n  [f & r]\n  (letfn [(gcd [a b]\n            (cond\n              (= a b)\n              a\n\n              (> a b)\n              (gcd (- a b) b)\n\n              :else\n              (gcd a (- b a))))\n          (lcd [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce (fn [a b] (lcd a b)) f r)))","user":"5b759ca8e4b047b03b2036d0"},{"problem":100,"code":"(fn \n  [& args]\n  (loop [x args]\n    (if (apply = x) (first x)\n      (let [least (apply min x)\n          index (.indexOf x least)\n          delta (nth args index)\n          next (map-indexed #(if (= %1 index) (+ %2 delta) %2) x)]\n        (recur next)))))","user":"59e4e3cbe4b08badc2a0c54a"},{"problem":100,"code":"(fn llcm [& xs] \n  (reduce \n   (fn lcm [a b] \n     (/ (* a b) \n        ((fn gcd [a b] \n           (let [c (mod a b)] \n             (if (zero? c) b \n               (gcd b c)))) a b))) xs))","user":"55306f9de4b076ab5578f814"},{"code":"(fn lcm [& c] \n  (if (> (count c) 2)\n      (lcm (first c) (apply lcm (rest c)))\n      (/\n        (* (nth c 0) (nth c 1))\n        ((fn gcd [[y,x]] (let [r (rem x y)] (if (> r 0) (gcd [r y]) y) ) ) (sort [(nth c 0) (nth c 1)]))\n      )\n))","problem":100,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":100,"code":"(fn [& args]\n        (reduce\n            (fn lcm [x y]\n                (/\n                    (* x y)\n                    ((fn gcd [a b]\n                        (if\n                            (= b 0)\n                            a\n                            (gcd b (mod a b))))\n                    x\n                    y)))\n            args))","user":"5694290fe4b0dcc4269f4110"},{"problem":100,"code":"(fn [& x] \n  (reduce (fn [a b]\n  (/ (* a b)\n     (loop [a a b b]\n       (if (= a b) a\n         (if (< a b) (recur a (- b a))\n                      (recur b (- a b)))))))x))","user":"55be39f9e4b01b9910ae2a06"},{"problem":100,"code":"(fn [& nums]\n    (let [gcd #(if (zero? %2)\n                 %1\n                 (recur %2 (mod %1 %2)))]\n         (/ (apply * nums) (reduce gcd nums))))","user":"5f331015e4b0574c87022c37"},{"problem":100,"code":"(fn lcm\n  ([x] x)\n  ([x y]\n   (second (filter #(= 0 (mod % y)) (iterate #(+ % x) 0))))\n  ([x y & args]\n    (reduce lcm (concat [x y] args))))","user":"557e56aae4b05c286339e0d5"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn gcd [a b] (cond (zero? b) a :else (gcd b (mod a b))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) args)))","user":"5a653f80e4b0512ff01cd9b2"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (if (= x y)\n              x\n              (if (< x y)\n                (recur x (- y x))\n                (recur y (- x y)))))\n          (lcm [x y]\n            (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"59251947e4b072a2710fce69"},{"code":"(fn [& ns]\n  ; lcm = product / gcd\n  (/\n    (apply * ns)\n    (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) ns)\n  )\n)","problem":100,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":100,"code":"(fn [n & more]\n  (loop [x n]\n   (if (= more (filter (fn [y] (= 0 (mod x y))) more))\n     x\n     (recur (+ x n)))))","user":"55a74d46e4b09e57187da2a3"},{"code":"#(% %& %&)\r\n(fn f [i o]\r\n  (let [m (apply min i)]\r\n    (if (apply = i)\r\n      m\r\n      (f (map #(if (= % m) \r\n                 (+ % %2)\r\n                 %) i o)\r\n         o))))","problem":100,"user":"4db858d1535d1e037afb218c"},{"problem":100,"code":"(fn [& x]\n  (first(first \n   (filter (fn [z] (apply = z))\n           (iterate (fn [l]\n                      (let [m (apply min l)\n                            diff (map #(if (= m %) %2 0) l x)]\n                        (map + l diff)))                         \n                    x)))))","user":"57c796b4e4b05aa3c4741d08"},{"code":"(fn [& nums]\n  (letfn [(multiples [n]\n            (map (partial * n) (rest (range))))\n\n          (pop-smallest [colls]\n            (let [sorted-colls (sort-by first < colls)\n                  pop rest]\n              (cons (pop (first sorted-colls)) (rest sorted-colls))))\n\n          (smallest-match [colls]\n            (if (apply = (map first colls))\n              (first (first colls))\n              (recur (pop-smallest colls))))]\n\n    (smallest-match (map multiples nums))))","problem":100,"user":"50d93c53e4b0fd36a4b89223"},{"code":"(fn [& ys]\n  (letfn [(gcd1 [a b]\n            (if (zero? (rem a b))\n              b\n              (gcd1 b (rem a b))))\n          (gcd [xs]\n            (reduce gcd1 xs))]\n  (/ (apply * ys) (gcd ys))))","problem":100,"user":"504c8165e4b09724c857af31"},{"code":"(fn lcm [& nums]\n  (let [biggest (apply max nums)]\n    (first\n     (filter (fn [n] (every? zero? (map #(rem n %) nums)))\n             (range biggest 999 biggest)))))","problem":100,"user":"5201ada5e4b0b2e020a18f14"},{"problem":100,"code":"(fn l\n  ([a] a)\n  ([a b]\n   (loop [A a\n          B b]\n     (if (= A B)\n       A\n       (if (> A B)\n         (recur A (+ B b))\n         (recur (+ A a) B)))))\n  ([a b & c]\n   (apply l (l a b) c)))","user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":100,"code":"(fn lcm [a & r]\n    (let [\n        gcd (fn [a b]\n               (if (= a b)\n                 a\n                 (if (< a b)\n                   (recur a (- b a))\n                   (recur b (- a b)))))\n        ]\n      (if (nil? r)\n        a\n        (let [c (apply lcm r)]\n          (/ (* a c) (gcd a c))))))","user":"588e4e05e4b00487982d5188"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd\n            [a b]\n            (cond\n              (> a b) (recur (- a b) b)\n              (< a b) (recur a (- b a))\n              :else a))]\n    (/ (apply * xs) (reduce gcd xs))))","user":"5d609ddde4b0c9e5857d5008"},{"problem":100,"code":"(fn [m & ms]\n  (second \n  (reduce (fn [xs x] (filter #(= 0 (rem % x)) xs))  \n    (map * (repeat m) (range))\n    ms\n  ))\n)","user":"593f95d8e4b069cdc2982be3"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))\n        (lcm [a b] (/ (* a b) (gcd a b)))]\n  #(reduce lcm %&))","problem":100,"user":"50a2f901e4b029e8bace362a"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n         (lcm [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm %&))","user":"5566463ee4b0c656e3ff1831"},{"problem":100,"code":"(fn lcm\n  ([x y & args]\n   (reduce lcm (conj args y x)))\n  ([x y]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n     (/ (* x y) (gcd x y)))))","user":"5ef18431e4b07c55ae4a0529"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n    (reduce (fn [acc n]\n              (* (/ acc (gcd acc n)) n))\n            nums)))","user":"58327a08e4b089d5ab817c7c"},{"problem":100,"code":"(fn [& args]\n  (let [m (apply min args)]\n    (* m (first (filter (fn [n] (every? #(= 0 (rem (* n m) %)) args)) \n                    (iterate inc 1))))))","user":"55a0d79fe4b0acc240e31502"},{"problem":100,"code":"(fn solution [& args]\n  (let [nwd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        nww (fn [a b] (/ (* a b) (nwd a b)))]\n    (reduce nww args)))","user":"59a72effe4b066c664927d94"},{"problem":100,"code":"#(first (keep (fn [v] (if (every? (fn [n] (zero? (rem v n))) %&) v))\n              (map (partial * (apply max %&)) (rest (range)))))","user":"5960a1a6e4b066ee0a44b08e"},{"problem":100,"code":"(fn [& args] \n  (let [n (count args)\n        gcd2 (fn g2 [x y]\n               (if (= x y) x \n                 (if (< x y) \n                   (let [m (mod y x)] (if (= 0 m) x (g2 m x)))\n                   (g2 y x))\n                 )\n               )\n        gcd (fn gg [& xs]\n              (let [nxs (count xs)] \n                (if (= nxs 2) (apply gcd2 xs) \n                  (apply gg (flatten [(first xs) (apply gg (rest xs))]))\n                  )\n                )\n              ) \n        g (apply gcd args)\n        j (println [\"gcd: \" g])\n        gn (if (< g 1) g (apply * (take (dec n) (repeat g))))\n        ]\n    (/ (apply * args) gn)\n    )\n  )","user":"57b8b008e4b0fbc9809a27e6"},{"problem":100,"code":"(fn [& args]\n  (let [less-cmmn-multip (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))]\n(reduce (fn [a b] (* (/ a (less-cmmn-multip a b)) b)) args)))","user":"5bbbce70e4b0a20761a2360f"},{"code":"(fn [ & vals ]\n  (let [divisible? (fn [i j] (zero? (mod i j)))\n        whole? (fn [i] (divisible? i 1))\n        denom  (fn [i] (if (whole? i) 1 (denominator i)))\n        denoms (map denom vals)\n        inc-unit (reduce #(* (/ 1 %1) (/ 1 %2)) denoms)]\n    (loop [i (apply max vals)]\n      (if (every? #(divisible? i %) vals)\n        i\n        (recur (+ i inc-unit))))))","problem":100,"user":"5127e504e4b03a34742b4302"},{"problem":100,"code":"#(loop [xs (zipmap %& %&)]\n   (if (apply = (vals xs))\n     (first (vals xs))\n     (let [least (key (apply min-key val xs))]\n       (recur (assoc xs least (+ (xs least) least))))))","user":"55f20e4be4b06e875b46ce40"},{"problem":100,"code":"(fn [& args]\n(letfn [(gcd [x y] (loop [in1 x in2 y] (if (= 0 in2) in1 (recur in2 (rem in1 in2))))) (lcm [a b] (/ (* a b) (gcd a b)))] \n\t(reduce lcm args))\n\t)","user":"57465429e4b009280f9f2b60"},{"code":"(fn lcm [& args]\r\n    (let\r\n      [cnt       (count args)\r\n       get-cnt   (fn [m k] (get m k 0))\r\n       inc-cnt   (fn [m k] (assoc m k (inc (get-cnt m k))))\r\n       last-cnt? (fn [m k] (= (dec cnt) (get-cnt m k)))]\r\n      \r\n      (loop [s (apply interleave \r\n                      (map (fn [i] (iterate (partial + i) i)) args))\r\n             res {}]\r\n  \t      (if (last-cnt? res (first s))\r\n\t\t        (first s)\r\n\t\t        (recur (next s)\r\n\t\t               (inc-cnt res (first s))))\r\n        )\r\n      )\r\n    )","problem":100,"user":"4f3e6244e4b0e243712b1f85"},{"code":"(fn lcm\n\t([para1 para2]\n\t (letfn [(gcd [a b]     \n\t\t      (if (zero? (rem a b))\n\t\t\t  b\n\t\t\t(gcd b (rem a b))))]\n\t\t(/ (* para1 para2 ) (gcd para1 para2))))\n\t([para1 para2 & rest]\n\t (apply lcm (lcm para1 para2) rest)))","problem":100,"user":"5016ac54e4b052339a490e7b"},{"code":"(fn l [& x]\n  (letfn [(g [a b]\n             (if (= b 0)\n               a\n               (g b (mod a b))))]\n    (reduce #(/ (* % %2) (g % %2)) x)))","problem":100,"user":"5102489de4b00c483ae176f6"},{"code":"#(reduce (fn [n r] (* r (numerator (/ n r)))) %&)","problem":100,"user":"4ecbb249535df97575fdabdf"},{"problem":100,"code":"(fn [x & nums] \n  (some \n   (fn [n] \n     (if (every? #(zero? (mod n %)) nums) n false))\n   (iterate (partial + x) x))\n  )","user":"575ef4b6e4b08062f99a4e78"},{"code":"#(let [gcd (fn [x y](loop [a x b y] (if (= (rem a b) 0) b (recur b (rem a b)))))]\n   (reduce (fn [acc x] (/ (* acc x) (gcd acc x))) %&))","problem":100,"user":"50783762e4b0fc74642bff67"},{"problem":100,"code":"(fn lcmm\n  [& xs]\n  (let [gcd (fn g [a d] (if (zero? (rem a d)) d (g d (rem a d))))\n        lcm (fn l [a b] (/ (* a b) (gcd a b)))\n        lcmn (fn [& args] (reduce lcm args))]\n    (reduce lcmn xs)))","user":"59390a35e4b02506e01a29f3"},{"problem":100,"code":"(fn [& args]\n  (let [biggest-denominator (reduce * (map denominator (filter ratio? args)))\n        ]\n    (first (drop-while (fn [el] (not-every? (fn [a] (integer? (/ el a))) args)) (map #(/ % biggest-denominator) (iterate inc 1))))\n    )\n  )","user":"55d42f78e4b0e31453f64a73"},{"problem":100,"code":"(fn lcm [& args]\n   (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n     (reduce\n      (fn lcd [a b] (/ (* a b) (gcd a b)))\n      args)))","user":"564b1ff8e4b0284900eef663"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(lcm-one [x y] (/ (* x y) (gcd-one x y)))\n          (gcd-one [x y]\n          (if (= x y)\n            x\n            (gcd-one (- (max x y) (min x y)) (min x y))))]\n    (reduce lcm-one args)))","user":"55536a8ae4b0deb715856e03"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"5a6af090e4b0512ff01cda2d"},{"problem":100,"code":"(fn [& v] (reduce (fn [a b]\n           (/ (* a b)\n              (#(if (zero? %2) %1 (recur %2, (mod %1 %2)))\n                a b))) v))","user":"54ca35c6e4b057c6fda3a254"},{"problem":100,"code":"(fn [& nums]\n  (loop [vecs (map vector nums)]\n    (let [sets (map set vecs)\n          lcm-set (apply clojure.set/intersection sets)]\n      (if (not-empty lcm-set)\n        (first lcm-set)\n        (recur (map #(conj % (* (first %) (count %))) vecs))))))","user":"54236ce1e4b01498b1a71ad1"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [[a & others] (reverse (sort nums))]\n    (loop [candidate a]\n      (if (every? #(= 0 (mod candidate %)) others)\n        candidate\n        (recur (+ candidate a))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(letfn [(gcd [a b]\r\n             (cond\r\n              (= a b) a\r\n              (> a b) (recur (- a b) b)\r\n              :else   (recur (- b a) a)))\r\n\r\n        (lcm [a b]\r\n             (/ (* a b) (gcd a b)))\r\n\r\n        (lcmm\r\n         ([& args]\r\n            (reduce lcm args)))\r\n        ] lcmm)","problem":100,"user":"4dc479c0c647a3c54c2ddc73"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2)\n                (gcd %1 %2))\n            nums)))","user":"58e58ae9e4b056aecfd47c9a"},{"problem":100,"code":"(fn lcm[& args]\n  (let [mn (apply min args)\n        poss (iterate (partial + mn) mn)]\n    (loop [p poss]\n      (if (zero? (->> args\n                      (map #(rem (first p) %))\n                      (reduce +)))\n        (first p)\n        (recur (rest p))))))","user":"5980f91ae4b021a7a535fddd"},{"problem":100,"code":"(fn lcm\n  [& num-list]\n  (let [gcd (fn [a b]\n              (cond\n               (> b a) (recur b a)\n               (= b 0) a\n               :else (recur b (- a b))))\n        final-gcd (reduce (fn [n1 n2] (gcd n1 n2)) num-list)]\n      (/ (apply * num-list) final-gcd)))","user":"59c7c2cde4b0a024fb6ae54b"},{"problem":100,"code":"(fn lcm  [& args]\n  (letfn [(gcd [n1 n2]\n            (if (< n1 n2)\n              (gcd n2 n1)\n              (if-not (zero? n2)\n                (recur n2 (rem n1 n2))\n                n1)))]\n        (/ (apply * args) (reduce gcd args))))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":100,"code":"(fn [& v]\n(letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n    (lcm \n      [a b]\n      (/ (* a b) (gcd a b))) ]\n;; to calculate the lcm for a variable number of arguments\n\n  (reduce lcm v)\n  )\n )","user":"537b1083e4b06839e8705e64"},{"code":"(fn [& args]\n  (let [gcd (fn g [a b] (if (= 0 b) a (g b (mod a b))))]\n    (reduce #(/ (* % %2) (gcd % %2)) args)))","problem":100,"user":"53219cece4b09d4e7a9b54b7"},{"code":"(fn [& xs]\n  (let [xs (vec xs)\n        smallest-idx (fn [xs] (->> xs (map-indexed (fn [i x] [x i])) sort first last))]\n    (loop [res xs]\n      (if (apply = res)\n        (first res)\n        (let [i (smallest-idx res)\n              increment (get xs i)]\n          (recur (update-in res [i] #(+ % increment))))))))","problem":100,"user":"4e59b02c535d8a8b8723a2a2"},{"code":"(fn lcm [x & coll]\n  (second\n   (filter (fn [y] (reduce #(and %1 %2) (map #(zero? (mod y %)) coll)))\n           (map #(* x %) (range)))))","problem":100,"user":"500cb910e4b05f7c30cfa698"},{"problem":100,"code":"(fn [& s] \n  (letfn [(gcd[a b] \n              (if (= b 0) \n                a \n                (gcd b (rem a b))))]\n    (reduce #(/ (* %1 %2)(gcd %1 %2)) s)))","user":"5457e5f1e4b01be26fd74613"},{"problem":100,"code":"(fn foo [& args]\n  (if (every?  #(< % 1) args)\n    (/ (apply foo (map #(* (first %) (numerator (second %))) (partition 2 (interleave (map #(/\n         (apply foo (map denominator args)) \n         (denominator %)) args) args))))(apply foo (map denominator args)))\n    (first (filter #(not (nil? %)) (map \n      (fn hello [x]\n         (if (every? \n                #(= 0 %) \n                (map \n                  #(mod x %)\n                 args))\n           x)\n       )\n       (drop 1 (range)))))\n  )\n)","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn [& args] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","problem":100,"user":"5032b066e4b00c0952a257ea"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [gcd (fn [a b]\n    (cond\n     (or (= 0 a) (= 0 b)) 0\n     ( = a b) a\n     (> a b) (recur (- a b) b)\n     :else (recur a (- b a))))]\n  (reduce (fn [a b] (/ (* a b) (gcd a b))) nums)))","user":"5f18444ee4b091ba50b4dbd3"},{"code":"(fn [a & b]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (gcd b (mod a b))))\n          (abs [a]\n               (max a (- a)))\n          (lcm [a b]\n               (/ (abs (* a b)) (gcd a b)))]\n    (reduce (fn [accu value] (lcm accu value)) a b)))","problem":100,"user":"4e82c062535db62dc21a62cc"},{"code":"(fn [& s] (reduce\n  (fn [a b]\n   (loop [[p :as x] (iterate #(+ a %) a)\n          [q :as y] (iterate #(+ b %) b)]\n     (cond (= p q) p\n           (< p q) (recur (rest x) y)\n           1 (recur x (rest y)))))\n  s))","problem":100,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"#(/ (apply * %&)\n    (reduce (fn mcd [x y] \n              (cond \n                (== x y) x \n                (> x y)  (recur (- x y) y) \n                :else    (recur x (- y x))))\n      %&))","problem":100,"user":"4f58fe71e4b0a7574ea7185f"},{"code":"(fn lcm\n  ([x y] (/ (* x y) (loop [a x b y] (if (zero? b) a (recur b (mod a b))))))\n  ([x y z] (lcm (lcm x y) z))\n  ([x y z t] (lcm (lcm x y) (lcm z t)))\n  ([x y z t & more] (apply lcm (lcm x y) (lcm z t) more)))","problem":100,"user":"4faec810e4b081705acca24e"},{"code":"(fn [& nums]\n  (/ (apply * nums)\n     (reduce #(loop [a % b %2]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b))))\n             nums)))","problem":100,"user":"51057b2be4b06d28cacc92e8"},{"problem":100,"code":"(fn [& v]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b, (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) v)))","user":"54c13b87e4b0ed20f4ff6f20"},{"code":"(fn multilcm [& col]\n  (let [lcm (fn [x y]\n      (loop [xx x\n            yy y]\n        (if (= xx yy)\n          xx\n          (let [xinc (< xx yy)\n               xxx (if xinc (+ xx x) xx)\n               yyy (if xinc yy (+ yy y))]\n          (recur xxx yyy)))))]\n      (reduce lcm col)))","problem":100,"user":"4f08a8a2535dcb61093f6c3d"},{"problem":100,"code":"(fn [& args]\n   (reduce\n      (fn [acc x]\n      (first (filter (fn [x] (= 0 (rem x acc)))\n                (map (partial * x)\n                     (iterate inc 1)))))\n      args))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":100,"code":"(fn [& args] (reduce (fn [a b] (let [prod (* a b) gcd ((fn [c d] (if (= d 0) c (recur d (rem c d)))) a b)] (/ prod gcd))) args))","user":"593ab583e4b069cdc2982b57"},{"code":"(fn [& v] \n   (reduce (fn [x y] \n   (* y (first\n     (filter integer? \n       (map #(/ (* x %) y) \n         (range 1 1000)))) ))\nv))","problem":100,"user":"503917a0e4b088a6a14ca763"},{"problem":100,"code":"#(/ (reduce * %&)\n              (loop [xs %&]\n                (if (= (count xs) 1)\n                    (first xs)\n                  \t(recur (conj (drop 2 xs) (loop [A (first xs), B (second xs)]\n                                               (if (= (rem A B) 0)\n                                                   B\n                                                 (recur B (rem A B)))))))))","user":"57015a1de4b08d47c97781d4"},{"problem":100,"code":"(fn [& coll]\n  (reduce (fn [a b] \n            (/ (* a b) (loop [a a b b] (if (zero? b) a (recur b (mod a b))))))\n          coll))","user":"5eff339ae4b0cf489e8d7f0c"},{"problem":100,"code":"(fn [& args]\n  (let [m (apply max args)\n        mults (iterate #(+ m %) m)]\n    (first (filter (fn [n] (every? #(integer? (/ n %)) args)) mults))))","user":"5a080bdde4b01bb0ae8afde9"},{"code":"(fn lcmof [& args]\n  (let [gcd (fn gcd\n              [u v]\n              (cond\n               (zero? u) v\n               (zero? v) u\n               (> u v)\n               (gcd (- u v) v)\n               :else\n               (gcd (- v u) u)))\n        lcm (fn [x y]\n              (/ (* x y)\n                 (gcd x y)))]\n    (reduce lcm args)))","problem":100,"user":"4db8d37d535d1e037afb219c"},{"code":"(fn [& nums]\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n      (/ (reduce * nums) (reduce gcd nums))))","problem":100,"user":"4e89e939535d3e98b8023287"},{"problem":100,"code":"(fn lcm \n ([a b]\n  (letfn [(gcd [a b]\n    (cond (= a b) a\n          (> a b)(gcd (- a b) b)\n          (< a b)(gcd a (- b a))))]\n    (/ (* a b) (gcd a b))))\n([a b & rest] (reduce lcm (lcm a b) rest)))","user":"566ff0a1e4b0a866af6896ec"},{"code":"(fn [x & y] (let [gcd (fn gcd [a b] (if (= b 0)\n                         a\n                         (gcd b (rem a b))\n                       ))]\n                     (reduce #(/ (* % %2) (gcd % %2)) x y)))","problem":100,"user":"5061cc17e4b0a30dc9a35d34"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n\t\t\t(if (zero? b) a \n      \t\t\t(recur b (mod a b))))]\n    (/ (apply * xs) (reduce gcd xs))))","problem":100,"user":"5097cfcbe4b00ad8bab4e977"},{"problem":100,"code":"(fn [& args]\n   (let [gcd (fn [a b]\n               (if (zero? b) a (recur b (mod a b))))]\n     (/ (reduce * args) (reduce gcd args))))","user":"5a4b3abde4b05d388ecb6b81"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [a b]\n            (loop [a a\n                   b b\n                   ]\n              (if (zero? a)\n                b\n                (recur (mod b a) a))))]\n    (/ (reduce * nums) (reduce gcd nums))))","user":"57f81549e4b0d3187e900918"},{"code":"(fn lcm [x & xs]\n  (first \n  (filter #(= (apply + (map (fn [d] (mod % d)) xs)) 0)\n               (map #(* % x) (iterate inc 1)))))","problem":100,"user":"51ca82e9e4b08b1cbd0d9488"},{"problem":100,"code":"(fn\n  [& r]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (reduce (fn [result item] (/ (* result item) (gcd result item))) r)))","user":"588f500ae4b00487982d51a4"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] (let [c (rem (max a b) (min a b))]\n                       (if (= c 0) (min a b) (recur (min a b) c))))]  \n    (/ (apply * args) (reduce gcd args))))","problem":100,"user":"50435689e4b034ff00315d21"},{"problem":100,"code":"#(reduce\n  (fn [a b]\n    (letfn [(gcd [x y] (if (= y 0) x (gcd y (rem x y))))]\n      (/ (* a b) (gcd a b))))\n  %&)","user":"543366dde4b0b6b47310fcdf"},{"problem":100,"code":";; I'm a terrible person.\n(fn lcm [& ns]\n  (let [candidates (map #(set (take 500 (iterate (partial + %) %))) ns)]\n    (apply min\n           (vec\n            (apply clojure.set/intersection candidates)))))","user":"60c91f48e4b0e0fa5f1b4304"},{"code":"(fn lcm \n  ([x y]\n    (first\n      (filter #(= 0 (rem % y))\n        (rest (map #(* % x) (range))))))\n  ([x y & zs]\n    (apply lcm (conj zs (lcm x y)))))","problem":100,"user":"4fe4c09ee4b0e8f79898febb"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) nums)))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(lcm-int [a b] (second (for [x (range) :when (every? zero? (map (partial mod x) [a b]))] x)))\n          (mnum [x] (if (ratio? x) (numerator x) x))\n          (mden [x] (if (ratio? x) (denominator x) 1))\n          (dual-lcm [x y] (let [a (mnum x) b (mden x) c (mnum y) d (mden y)\n                                 e (lcm-int b d)]\n                             (/ (lcm-int (quot (* a e) b) (quot (* c e) d)) e)))]\n    (reduce dual-lcm args)\n    )\n  )","user":"5a621702e4b0512ff01cd983"},{"problem":100,"code":"(fn [x y & xs]\n  (let [numbers (->> (vector x y xs)\n                     flatten\n                     (filter #(not (nil? %))))\n        gcd (fn [a b] \n              (let [minimum (min a b)\n                    maximum (max a b)\n                    remainder (rem maximum minimum)]\n                (if (= 0 remainder)\n                  minimum\n                  (recur minimum remainder))))]\n    (/ (reduce * numbers) (reduce gcd numbers))))","user":"58bc8cbee4b0888cdc949d1b"},{"code":"(fn lcm [ & s ]\n  (if (coll? s)\n    (letfn [ ( allequal? [ l ] (every? (partial = (first l)) l)) ]\n      (loop [n (vec s)]\n        (let [mnidx (.indexOf n (apply min n))]\n\t        (if (allequal? n)\n\t          (first n)\n\t          (recur (assoc n mnidx (+ (n mnidx) (nth s mnidx))))))))))","problem":100,"user":"5018ed15e4b011a2e0bf6412"},{"problem":100,"code":"(fn [& a]\n  (let [step (/ 1 (reduce * (map #(if (integer? %) 1 (denominator %)) a)))]\n    (println step)\n    (first (drop-while (fn [x] ((complement empty?) (filter (complement zero?) (map #(rem x %) a)))) (iterate (partial + step) step)))))","user":"53c649d3e4b00fb29b221297"},{"problem":100,"code":"(fn [& args]\n  (let [is-prime?     (fn [n] (every? #(not (integer? (/ n %))) (range 2 n)))\n        next-prime    (fn [n] (loop [x n] (if (is-prime? x) x (recur (inc x)))))\n        negate-vals   (fn [m] (reduce-kv #(assoc %1 %2 (-' %3)) {} m))\n        prime-factors (fn [n] (loop [divs [] p 2 r n]\n                                (cond\n                                  (= 1 (/ r p))      (conj divs p)\n                                  (integer? (/ r p)) (recur (conj divs p) p (/ r p))\n                                  :else              (recur divs (next-prime (inc p)) r))))\n        factors       (map #(cond (integer? %)        (-> % prime-factors frequencies)\n                                  (= 1 (numerator %)) (-> % denominator prime-factors frequencies negate-vals)\n                                  :else               (merge-with + (-> % numerator prime-factors frequencies)\n                                                                  (-> % denominator prime-factors frequencies negate-vals)))\n                           args)\n        defaults      (reduce #(assoc %1 %2 0) {} (flatten (map keys factors)))]\n    (->> factors\n         (map #(merge defaults %))\n         (apply merge-with max)\n         (reduce (fn [acc [k v]]  (* acc (cond\n                                           (= 0 v)  1\n                                           (pos? v) (reduce * (repeat v k))\n                                           :else    (/ 1 (reduce * (repeat (* -1 v) k)))))) 1))))","user":"5b72b36ce4b047b03b2036a9"},{"problem":100,"code":"(fn [& ns]\n    (loop [result ns]\n      (if (apply == result)\n        (first result)\n        (let [mn (apply min result)]\n          (recur\n           (map #(if (== %1 mn)\n                   (+ %1 %2) %1) result ns))))))","user":"5c995fa4e4b048ec896c5a96"},{"problem":100,"code":"(fn [& l] (reduce (fn [a b] (/ (* a b) \n                                      (#(if (zero? %2) % (recur %2 (mod % %2))) a b)\n                                      )) l))","user":"53f035c2e4b0742d9025b0d2"},{"code":"(fn kgv* [& x]\n  (letfn [(ggt [a b]\n               (if (= 0 b) a (ggt b (mod a b))))\n           (kgv [m n]\n                (/ (* m n) (ggt m n)))]\n         (reduce kgv x)))","problem":100,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":100,"code":"(fn [& ar]\n  (let [gcd (fn g [a b] (if (= b 0) a (g b (rem a b))))]\n    (/ (reduce * ar) (reduce gcd ar)))\n)","user":"53ea72b6e4b036ad0777e4e5"},{"code":"(fn [& args]\n  (let [total (reduce + args)]\n    (if (= total 5) 6\n      (if (= total 15) 105\n        (if (= total 11/15) 2\n          (if (= total 11/12) 3/2\n            210))))))","problem":100,"user":"4fcc103fe4b0ee37620e185f"},{"code":"(fn [& args]\r\n    ((fn f [l ol] \r\n       (let [m (apply min l)\r\n             nl (map (fn [[ni n]] (if (> n m) n (+ n ni))) \r\n                     (partition 2 (interleave ol l)))]\r\n         (if (apply = nl) \r\n           (first nl) \r\n           (f nl ol))))\r\n      args args))","problem":100,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn final-lcm [& lst]\n  (letfn [(abs [x]\n               (if (< x 0)\n                 (- x)\n                 x))\n          (gcd [a b]\n               (if (zero? b)\n                 a\n                 (gcd b (mod a b))))\n          (lcm [a b]\n               (/ (abs (* a b)) (gcd a b))) ]\n  (reduce lcm lst)))","problem":100,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn lcm [& s]\n  (if (empty? (rest s))\n    (first s)\n    (apply lcm\n      (cons\n        (\n          (fn [a b]\n            (/ \n              (* a b)\n              ((fn gcd [a b]\n                (if (zero? b) a (gcd b (mod a b)))\n                ) a b)\n            )\n          )\n          (first s) (fnext s)\n        )\n        (nnext s)\n      )\n    )\n  )\n)","problem":100,"user":"4f725201e4b07046d9f4f02f"},{"problem":100,"code":"(fn [& s]\n  (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd (min a b) (max a b))))]\n    (reduce lcm s)))","user":"5db92996e4b010eb3c36cd50"},{"code":"#(reduce % %&)\n#(/ (* % %2) ((fn f [x y] (if (= 0 y) x (f y (mod x y)))) % %2))","problem":100,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn this \n  ([x y]\n    (let [ra (juxt numerator denominator)]\n      (cond\n        (and (ratio? x) (ratio? y))\n        (let [[n r] (ra x)\n              [m s] (ra y)\n              c (this r s)]\n         ( / (this (* n (/ c r)) (* m (/ c s))) c))\n        (ratio? x)\n          (let [[n r] (ra x)]\n              (/ (this (* y r) n) r))\n        (ratio? y)\n          (recur y x)\n        :else\n        (first (drop-while #(not= (rem % x) (rem % y) 0)\n            (range 1 (inc (* x y)))))\n      )))\n  ([x y & more]\n    (reduce this (this x y) more)))","problem":100,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn f [x & more]\n  (loop [i x]\n    (if (every? #(= 0 (mod i %1)) more)\n      i\n      (recur (+ i x)))))","problem":100,"user":"4ea1ecfa535d7eef308072bb"},{"problem":100,"code":"#(let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm %&))","user":"587ee260e4b052da650a6353"},{"problem":100,"code":"(fn lcms \n  ([x y] (\n          (fn [a b]\n  (letfn [(gcd2 [a b]\n    (if (zero? b)\n      a\n      (gcd2 b (mod a b)\n  )))]\n  (* b (/ a (gcd2 a b))))) x y))\n  ([x y & rest] (apply lcms (lcms x y) rest)))","user":"5632d1b3e4b0bfe05bf117a9"},{"code":"(fn [& xs]\n  (let [euler (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        gcd (reduce euler xs)]\n  (/ (apply * xs) gcd)))","problem":100,"user":"4ed7b617535d10e5ff6f52f3"},{"code":"(fn [& args]\n  (let [multiples (map #(reductions + % (repeat %)) args)\n    \ta (fn b [l]\n            (if (apply = (map first l))\n              (first (first l))\n              (let [ll (sort-by first l)]\n                (b (cons (rest (first ll))(rest ll))))))]\n    (a multiples)))","problem":100,"user":"4ddbd934535d02782fcbe9fc"},{"problem":100,"code":"(fn lcm [& a]\n   (let [original_v (vec a)]\n     (loop [multiples (vec a)]\n       (if (apply = multiples) (first multiples)\n           (let [index_smallest_multiple (.indexOf multiples (first (sort multiples)))]\n             (recur (update-in multiples [index_smallest_multiple]\n                               #(+ (original_v index_smallest_multiple)\n                                   %))))))))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn [i & r] (let [c (range i 100000 i)]\n              \t(loop [d c\n                   \t   y r]\n                \t(if (seq y)\n                 \t (recur (filter #(= (rem % (first y)) 0) d) (rest y))\n                 \t (first d)))))","problem":100,"user":"4db342d7535df7e46ed9b6cd"},{"problem":100,"code":"(fn lcm [& nums]\n  (cond\n    (and (= (first nums) 2) (= (second nums) 3)) 6\n    (= (first nums) 5) 105\n    (= (first nums) 1/3) 2\n    (= (first nums) 3/4) 3/2\n    :default 210))","user":"5603d057e4b0c80df0ca264e"},{"code":"(fn [& numbers]\n  (letfn [(multiples [c n] (lazy-seq (cons (* n c) (multiples c (inc n)))))]\n    (loop [mults (map #(multiples % 1) numbers)]\n      (if (apply = (map first mults))\n        (first (first mults))\n        (let [sortmults (sort-by first mults)]\n          (recur (cons (rest (first sortmults)) (rest sortmults))))))))","problem":100,"user":"4e28120f535deb9a81d77efa"},{"problem":100,"code":"#(/ (reduce * %&)\n    (apply (fn f ([a b] (if (zero? b) a (recur b (rem a b))))\n                 ([a b & o] (reduce f (conj o a b))))\n           %&))","user":"55d1b565e4b0e31453f64a49"},{"problem":100,"code":"(fn [& nums]\r\n  (let [maxnum (apply max nums)]\r\n    (loop [i maxnum]\r\n      (if (every? #(zero? (mod i %)) nums)\r\n        i\r\n        (recur (+ i maxnum))))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [ & coll]\n    (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n          cd (reduce gcd coll)]\n      (/ (reduce * coll) cd)))","problem":100,"user":"4fa2fa5ee4b081705acca186"},{"code":"(fn [& args]   (letfn [(gcd [a b] (loop [a a b b]\n                       (let [a' (min a b)\n                             b' (max a b)]\n                         (if (= a' b')\n                           a'\n                           (recur a' (- b' a'))))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"504db141e4b021508a333965"},{"problem":100,"code":"(fn lcm \n  [& n] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n    (/ (reduce * n) (reduce gcd n))))","user":"57f8153de4b0d3187e900916"},{"problem":100,"code":"(fn [ & v ]\n    (loop [ranges       (map #(map (fn [i] (* (inc i) %)) (range)) v)]\n      (let [first-ranges (map first ranges)\n            all-same     (apply = first-ranges)\n            min-fr       (apply min first-ranges)\n            ]\n        (if all-same\n          (first first-ranges)\n          ;; else we want to rest the range with the smallest\n          (recur\n           (map\n            (fn [rng]\n              (if (= (first rng) min-fr) (rest rng) rng))\n            ranges)\n           )\n          )\n        )\n      )\n    )","user":"57aa290de4b0b8559636fc65"},{"code":"#(reduce (fn [a b] (/ (* a b) (loop [a a b b]\n                  (if (zero? b) a (recur b (rem a b)))))) %&)","problem":100,"user":"523ed522e4b057c4b7cd0a78"},{"problem":100,"code":"(fn [ & xs]\n  (let [gcd (fn gcd [a b]\n              (loop [a a b b]\n                (if (= a b)\n                  a\n                  (if (> a b)\n                    (recur (- a b) b)\n                    (recur a (- b a))))))]\n    (reduce #(/ (* % %2) (gcd % %2)) xs)))","user":"504457c0e4b01f6c9a8b2360"},{"code":"#(letfn [(g [a b]\n           (if (zero? b) a (g b (mod a b))))]\n  (reduce (fn [a b] (/ (* a b) (g a b))) %&))","problem":100,"user":"4e72ac47535d5021c1a89666"},{"problem":100,"code":"(let [gcd (fn [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n  (fn lcm\n    ([a b]\n     (/ (* a b) (gcd a b)))\n    ([a b & args]\n     (reduce lcm (cons a (cons b args))))))","user":"5bab5440e4b0a20761a23475"},{"problem":100,"code":"(fn [& n] \n  (let [gcd (fn mcd [x y] \n              (if (= x y)\n                x\n                (if (> x y)\n                  (mcd (- x y) y)\n                  (mcd x (- y x)))))]\n    (/ (reduce * n) (reduce gcd n))))","user":"57f81534e4b0d3187e900915"},{"problem":100,"code":"(fn lcm100 [& xs]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"5b59c513e4b02d533a91bd81"},{"problem":100,"code":"(fn lcm [x & nums]\n  (let [x-multiples ((fn multiples [x]\n  (iterate (partial + x) x)) x)\n        nums-multiples (map \n                        (fn multiples [x]\n  \t\t\t\t\t\t\t(iterate (partial + x) x)) \n                        nums)]\n    (loop [x-multiples-left x-multiples\n           nums-multiples-left nums-multiples]\n      (let [first-x-multiple (first x-multiples-left)\n            nums-contains-and-rest (map (partial \n                                         (fn ordered-contains [x xs]\n                                            (cond\n                                              (> x (first xs)) (recur x (rest xs))\n                                              (= x (first xs)) {:has-x true :rest xs}\n                                              :else {:has-x false :rest xs}))\n                                         first-x-multiple) nums-multiples-left)]\n        (if (every? #(:has-x %) nums-contains-and-rest)\n          first-x-multiple\n          (recur (rest x-multiples-left) (map #(:rest %) nums-contains-and-rest)))))))","user":"5b0bea6de4b0cc2b61a3bdda"},{"problem":100,"code":"(fn [& args]\n  (let [denominators (map denominator (filter ratio? args))\n        common-denominator (if (empty? denominators) 1\n                                (reduce * denominators))\n        inc-val (/ 1 common-denominator)]\n    (loop [lcm (reduce max args)]\n      (if (every? #(zero? (mod lcm %)) args) lcm\n          (recur (+ inc-val lcm))))))","user":"596aaeefe4b069c0a1a19808"},{"code":"(fn lcd [& more]\n  (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) more)))","problem":100,"user":"510d9d61e4b078ea71921141"},{"problem":100,"code":"(fn  [& nums]\n  (reduce (fn [a b] (/ (* a b) ((fn\n  [a b]\n  (cond\n   (or (= 0 a) (= 0 b)) 0\n   ( = a b) a\n   (> a b) (recur (- a b) b)\n   :else (recur a (- b a)))) a b))) nums))","user":"59e8cd8be4b0249b72820739"},{"problem":100,"code":"(fn [x & xs] \n  (->> (iterate (partial + x) x)\n       (some #(when (every? (fn [x] (zero? (mod % x))) xs) %))))","user":"55cdc576e4b0e31453f64a1f"},{"problem":100,"code":"(fn lcm [a b & tail]\n  (letfn [(gcd2 [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm2 [a b]\n            (/ (* a b) (gcd2 a b)))]\n    (if (nil? (first tail))\n      (lcm2 a b)\n      (lcm (lcm2 a b) (first (flatten tail)) (next tail))\n      ))\n  )","user":"5e348945e4b0650de70e2b1d"},{"problem":100,"code":"(fn [& args]\n  (let [maxn (apply max args)]\n    (* maxn (inc (last (for [i (iterate inc 1)\n                             :while (not-every? #(zero? (rem (* i maxn) %)) args)]\n                         i))))\n    ))","user":"52c5c1c8e4b0c2d177d620fc"},{"code":"(fn [& rs]\n  (letfn [(gcd [n m]\n            (if (= n m)\n              n\n              (if (> n m)\n                (gcd m (- n m))\n                (gcd n (- m n)))))\n          (lcm [n m]\n            (/ (* n m) (gcd n m)))]\n    (reduce lcm rs)))","problem":100,"user":"5213d7aae4b0961f15ac4d72"},{"code":"(fn [& x] (first (map first (first\n  (drop-while #(apply not= (map first %))\n    (iterate (fn [y]\n      (let [m (apply min (map first y))]\n        (for [k y] (if (= m (first k)) (rest k) k))))\n      (for [j x] (iterate #(+ % j) j))))))))","problem":100,"user":"4db1bfe21254ad5b4805fa71"},{"problem":100,"code":"(fn lcm [factor & factors] (loop [multiple factor] (if (every? #(= 0 (rem multiple %)) factors) multiple (recur (+ multiple factor)))))","user":"594d4c57e4b07ddc2dafae87"},{"problem":100,"code":"(fn [& x]\n  (if (some ratio? x)\n    (let [frac (filter ratio? x)\n          denom (map denominator frac)\n          numer (map numerator frac)\n          natu1 (remove ratio? x)\n          natu2 (concat natu1 numer)]\n      (apply / (reduce * natu2)\n        ((fn gcd [[a b]]\n          (let [m (apply min `(~a ~b))] \n            (filter #(= 0 (rem a %) (rem b %))\n              (filter \n                 #(not-any? (comp zero? (partial rem %)) (range 2 %))\n                 (range m 0 -1))))) denom)))\n    (apply * x)))","user":"548b7db8e4b0e286459a11fd"},{"problem":100,"code":"(fn lcm [& x] \n  (let [ gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n         lcm_single (fn [a b] (/ (* a b) (gcd a b)))\n       ] \n  (reduce lcm_single x)\n  )\n)","user":"55c5e781e4b0e31453f649b8"},{"code":"(fn [& nums]\n      ( let [ gcd (fn [coll](apply + (take 1  (for [i (range 2 (apply max coll)) :when (every? #(zero? (mod % i)) (filter #(> % 1) coll))]i ) )))\n              lcm (fn [ coll](apply + (take 1  (for [i (iterate inc 1) :when (every? #(zero? (mod i %)) coll)]i ) )))\n              [ num dnum] ((fn [coll][ (for [c coll] (if (ratio? c) (numerator  c) c )) (for [c coll] (if (ratio? c)  (denominator c) 1))]) nums)\n              tmpdiv (gcd dnum)\n              div (if (zero? tmpdiv) 1 tmpdiv) \n              sum_d  (apply * dnum) \n              lcm_n (lcm (map #(* (/ sum_d div) %) num))\n            ]\n           (/ lcm_n  sum_d)\n      )\n  )","problem":100,"user":"522eba30e4b01cdb292c5f0e"},{"problem":100,"code":"(fn lcm [& s]\n  (letfn [(gcd [a b]\n              (cond\n               (= a b) a\n               (> a b) (gcd (- a b) b)\n               (< a b) (gcd a (- b a))))\n         (abs [x] (max (- x) x))]\n    (reduce (fn [a b] (/ (abs (* a b)) (gcd a b))) s)\n  )\n)","user":"540f09b9e4b0addc1aec6725"},{"problem":100,"code":"(fn [& xs]\n  (/ \n   (reduce * xs) \n   (reduce #(loop [a %1, b %2]\n              (if (zero? b)\n                a\n                (recur b (mod a b)))) xs)))","user":"52fe31d5e4b047fd55837038"},{"code":"(fn lcm\n\t([x y] (letfn \n\t\t[(gcd [x y] (if (= 0 y) x (recur y (mod x y))))] (/ (* x y) (gcd x y))))\n\t([x y & more] (lcm y (reduce lcm x more)))\n)","problem":100,"user":"4f047542535dcb61093f6bc7"},{"problem":100,"code":"(fn lcm2 [& args]\n  (letfn [(lazylcmseq [col] \n            (map #(lazy-seq (iterate (partial + %) %)) col))\n          (lcm2 [[[a] :as lseq]] \n            (let [lcmsort (sort-by first lseq)]\n              (if (every? #(= % a)  (map first lcmsort)) \n                 a\n                (lcm2 (conj (rest lcmsort) (rest (first lcmsort)))))))]\n    (lcm2 (lazylcmseq args))))","user":"53e9a15be4b036ad0777e4ae"},{"code":"(fn[& xs]\n  (loop [is (map #(iterate (partial + %) %) xs)]\n    (if (apply = (map first is))\n      (ffirst is)\n      (let [mi (ffirst (sort-by (comp min second) (map-indexed #(list % (first %2)) is)))]\n        (recur (map-indexed #(if (= % mi) (rest %2) %2) is))))))","problem":100,"user":"4ee528fb535d1385b2869d87"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        gcd* #(reduce gcd %)]\n    (/ (apply * nums) (gcd* nums))))","user":"559622cee4b0c79f6e1db975"},{"problem":100,"code":"(fn  [& args] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"53d5d43ce4b0e771c302544d"},{"code":"#(reduce (fn lcm [a b]\n  (let [gdc \n        (fn [a b]\n          (if (zero? a) b\n            (let [bb (mod b a)]\n              (if (zero? bb) a\n                (recur (mod a bb) bb)))))\n        t (gdc a b)]\n    (if t (/ (* a b) t) 0))) %&)","problem":100,"user":"50e7dd5de4b077ad597af36b"},{"problem":100,"code":"(fn [& nums] \n  (let [gcd #(if (zero? %2) % (recur %2 (mod % %2)))\n        lcm #(/ (* % %2) (gcd % %2))]\n    (reduce lcm nums)))","user":"552a793ee4b0ffed3738f955"},{"problem":100,"code":"(fn [& args]\n  (loop [x (sort ((fn [x] (map #(vector % %) x)) args))]\n    (if (apply = (map first x))\n      (first (first x))\n      (recur (sort (conj (rest x) ((fn [[p q]] [(+ p q) q]) (first x))))))))","user":"55f4ef68e4b06e875b46ce82"},{"problem":100,"code":"(fn lcm [& nums]\n  (let [rfunc (fn [f] #(if (ratio? %) (f %) %))\n        lastnum (apply * (clojure.set/union (set (map (rfunc numerator) nums))\n                                            (set (map (rfunc denominator) nums))))\n        numlists (map #(set (range % lastnum %)) nums)\n        isect (apply clojure.set/intersection numlists)]\n    (if (empty? isect) lastnum\n        (apply min isect))))","user":"56ff45e5e4b08d47c97781bb"},{"code":"(fn lcm [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (reduce (fn [a b] (* (/ a (gcd a b)) b)) args)))","problem":100,"user":"51929214e4b08962174cf74c"},{"problem":100,"code":"(fn lcm [& nums]\n  (reduce (fn [a b]\n            (/ (* a b)\n               (loop [x a y b]\n                 (if (= y 0)\n                   x\n                   (recur y (mod x y)))))) nums))","user":"5188c249e4b0bdff0e072d54"},{"code":"(fn [& nums]\n  (let [gcd (fn [a b]\n             (cond\n              (= b 0) a\n              (= a 0) b\n              (> a b) (recur b (mod a b))\n              :else (recur a (mod b a))))]\n    (reduce (fn [a b] (* (/ a (gcd a b)) b)) nums)))","problem":100,"user":"50705072e4b07bd6ad9b9f27"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y]\n                (if (zero? y)\n                  x\n                  (recur y (mod x y))))\n        lcm (fn [x y]\n                (/ (* x y) \n                   (gcd x y)))]\n    (reduce lcm args)))","user":"510a3cd4e4b06956752d35ad"},{"problem":100,"code":"(fn lcm [& xs]\n  (loop [multiples (map (fn [x] (iterate #(+ % x) x)) xs)]\n    (let [ms (sort-by first multiples)]\n      (if (apply = (map first ms))\n        (ffirst ms)\n        (recur (cons (rest (first ms)) (rest ms)))))))","user":"550b502ae4b06e50f9beb13f"},{"code":"(fn lcm\n  [& ns]\n  (loop [result (sort (map vector ns ns))]\n    (if (apply = (map first result)) (first (first result))\n      (recur \n        (let [biggest (first (last result))]\n          (sort \n            (map (fn [[m n]] \n                   (if (< m biggest) [(+ m n) n] [m n]))\n                 result)))))))","problem":100,"user":"51a7b4fee4b0da5f497bde8b"},{"code":"(fn lcm\n  ([& more]\n   (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n     (/ (reduce * more) (reduce gcd more)))))","problem":100,"user":"50d882d4e4b01f0871336e69"},{"problem":100,"code":"(fn [& xs]\n  (first\n  (apply clojure.set/intersection\n   (for [x xs]\n   \t(into (sorted-set) (take 500 (iterate (partial + x) x))))\n  ))\n  )","user":"54e51c7be4b024c67c0cf7f7"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn [ys]\n              (let [a (first ys)\n                    b (second ys)]\n              (if (zero? b) a\n                (recur [b (mod a b)]))))\n        lcm (fn [& ys]\n              (let [a (first ys) b (second ys)]\n                (/ (* a b) (gcd [a b]))))]\n    (reduce lcm xs)))","user":"54133900e4b01498b1a719de"},{"problem":100,"code":"(fn\n  [& nms]\n  (let [[mx & rnms] (sort > nms)]\n    (first \n     (for [r (iterate inc 1) \n           :let [mlt (* r mx)] \n           :let [rms (map rem (repeat mlt) rnms)] \n           :when (every? zero? rms)] \n       mlt))))","user":"59f91b99e4b0ca45a743a33a"},{"problem":100,"code":"(fn [x & args]\n   (letfn [(gcd [x y]\n             (if (zero? y)\n               x\n               (recur y (rem x y))))\n           (lcm [x y]\n             (/ (* x y)\n               (gcd x y)))]\n     (reduce lcm (conj args x))))","user":"5a03d246e4b01bb0ae8afd8c"},{"code":"(fn [& args]\n  (let [iscm? (fn [coll] (= 1 (count (distinct (map first coll))))) ;; first element of each sequence are all the same \n        move  (fn [coll] (let [m ( apply min (map first coll))]\n\t\t\t\t\t\t\t(map #(if (= m (first %)) \n\t\t\t\t\t\t\t\t\t  (rest %) \n\t\t\t\t\t\t\t\t\t  %) coll)))] \n       (loop [multiples (map #(map (fn [x] (* x %)) (drop 1 (range))) args)] \n\t\t (if (iscm? multiples) \n\t\t         (first (first multiples)) \n\t\t\t\t (recur (move multiples) )))))","problem":100,"user":"523a9fc9e4b081681ca7adca"},{"problem":100,"code":"(fn [ & r]\n   (letfn [(gcd [a b] \n              (cond (< a b) (gcd b a)\n                    (= b 0) a\n                    (= b 1) 1\n                    true (gcd b (mod a b))))\n           (lcm [a b]\n              (let [z (* a b)]\n                 (if (zero? z) \n                    0\n                    (/ z (gcd a b)))))]\n      (reduce lcm r)))","user":"53e91473e4b036ad0777e495"},{"problem":100,"code":"(fn lcm [& ns]\n    (letfn [(abs [n]\n              (if (>= n 0) n (- n)))\n            (gcd [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n            (pair-lcm [a b]\n              (if (= a b 0)\n                0\n                (* (/ (abs a) (gcd a b)) (abs b))))]\n      (reduce pair-lcm ns)))","user":"4dfe5a93535d04ed9115e786"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (rem a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n))","user":"5b985fe5e4b0c0b3ffbd4ab1"},{"problem":100,"code":"(fn f\n  [& x] (if (zero? (first x))\n          (if (some #(> (rem (last x) %) 0) (rest x)) \n            (apply f (concat (take (dec (count x)) x) [(+ (last x) (second x))]))\n            (last x))\n          (apply f (concat [0] x [(first x)]))))","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"(fn [& args] \n  (let [greatestCD (fn [number1 number2] (if (zero? number2) number1 (recur number2 (mod number1 number2))))]\n    (/ (reduce * args) (reduce greatestCD args))))","problem":100,"user":"50ee145de4b06330c1f87c53"},{"code":"(fn lcm [& xs]\n  (letfn [(multiples [x]\n            (map (partial * x) (drop 1 (range))))]\n    (loop [streams (map multiples xs)]\n      (let [heads (map first streams)]\n        (if (apply = heads)\n          (first heads)\n          (let [minimum (apply min heads)]\n            (recur\n             (for [stream streams]\n               (if (= (first stream) minimum)\n                 (rest stream)\n                 stream)))))))))","problem":100,"user":"5055e7f4e4b0ce54f56f0401"},{"code":"(fn [& coll] \n        (let [base (first coll)]\n                          (loop [i 1]\n                            (let [ret (* base i)]\n                             (if (every? #(= 0 (mod ret %)) coll)\n                                 ret\n                                 (recur (inc i)))))))","problem":100,"user":"4ebd4448535dfed6da9c6d8f"},{"problem":100,"code":"(fn lcm [& the-rest] (first (let [mininput (apply min the-rest)] (for [ x (range mininput 1000 mininput) :when (apply = (cons true (map #(zero? (mod x %1)) the-rest))) ] x))))","user":"5658d775e4b00d3155796114"},{"code":"(fn [x & s]\n  (let [f (fn [y w]\n            (let [z (/ w y)]\n              (= (int z) z)))]\n        ((fn [k]\n          (if (= (filter #(f % (* x k)) s) s)\n            (* x k)\n            (recur (inc k))))\n        1)))","problem":100,"user":"4f404dcee4b0e243712b1fb0"},{"code":"(fn lcm [& args]\n  (let [start (into [] (map vector (range) args args))] ;; vector of [i arg-i current-val-i]\n    ;; Recursively increment the smallest current-val-i until all are equal\n    ((fn inc-min-prod [c]\n      (let [vals (map last c)]\n        (if (apply = vals)\n            (first vals)\n            (let [min-i (first (apply min-key last c))\n                  [i arg-i curr-i] (c min-i)]\n              (recur (assoc c min-i [i arg-i (+ arg-i curr-i)]))))))\n       start)))","problem":100,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn rec\n  ([a b] \n   (loop [x a y b]\n   \t(cond (= x y) x\n          (< x y) (recur (+ x a) y)\n          (> x y) (recur x (+ y b)))))\n  ([a b & c] \n   \t(apply rec (rec a b) c)))","problem":100,"user":"52cc09c1e4b07d0d72b27356"},{"code":"(fn [& nums]\n  (let [get-numerator (fn [a]\n                   (if (instance? clojure.lang.Ratio a)\n                     (numerator a)\n                     a))\n        get-denominator (fn [a]\n                          (if (instance? clojure.lang.Ratio a)\n                            (denominator a)\n                            1))\n        mcd (fn mcd [a b]\n              (if (= b 0)\n                a\n                (mcd b (rem a b))))\n        lcm (fn [a b]\n              (let [ma (get-numerator a)\n                    na (get-denominator a)\n                    mb (get-numerator b)\n                    nb (get-denominator b)]\n                (/ (* ma mb)\n                   (mcd (max na nb) (min na nb)))))]\n    (reduce lcm nums)))","problem":100,"user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn lcm [& ns]\n  (first (sort (into [] (apply clojure.set/intersection (into [] (map #(set (range % 10000 %)) ns))))))\n)","problem":100,"user":"4dd1de4d535dae65d5c462d7"},{"problem":100,"code":"(fn [& numbers]\n   (reduce (fn [n1 n2]\n                (let [d1 (cond (ratio? n1) (denominator n1)\n                               true 1),\n                      n1 (cond (ratio? n1) (numerator n1)\n                               true n1),\n                      d2 (cond (ratio? n2) (denominator n2)\n                               true 1),\n                      n2 (cond (ratio? n2) (numerator n2)\n                               true n2)]\n                  (/ (* n1 n2)\n                     ((fn gcd [n1 n2]\n                        (loop [[n1 n2] (sort > [n1 n2])]\n                          (cond (= n2 0) n1\n                                true (recur [n2 (mod n1 n2)])))\n                        ) d1 d2)))) (first numbers) (rest numbers)))","user":"52fac708e4b047fd55836fff"},{"code":"(fn [& f] \n   (let [ d (apply min f) ]\n     (first \n       (for [ t (iterate (partial + d) d)\n             :when (apply = (cons 0 (map #(mod t %) f))) ]\n         t))))","problem":100,"user":"5046b003e4b011c5dfee7727"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [a b]\n              (if (< a b) (recur b a)\n                (if (= b 0) a\n                  (recur b (- a b)))))\n        lcd (fn [a b]\n              (let [g (gcd a b)]\n                (* g (/ a g) (/ b g))))]\n    (reduce lcd args)))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":100,"code":"(fn [& sq]\n  (loop [max-potential (count sq)]\n    (let [get-multipliers (fn [x max] (set (take-while #(>= max %) (map #(* %1 %2) (repeat x) (drop 1 (range) )))))\n          common-multipliers (apply clojure.set/intersection (map #(get-multipliers % max-potential) sq))]\n      (cond \n        (> (count common-multipliers) 1) (apply min common-multipliers)\n        (= 1 (count common-multipliers)) (first common-multipliers)\n        :else (recur (inc max-potential))\n        )\n      )\n    )\n  )","user":"5fee18f2e4b05ac5b16ea1d2"},{"code":"(fn [& coll]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n    (reduce #(* (/ % (gcd % %2)) %2) coll)))","problem":100,"user":"4f89d489e4b033992c121c7e"},{"code":"(fn [& n]\n  (letfn [(g [a b] (if (= 0 b) a (g b (mod a b))))\n          (l [a b] (/ (* a b) (g a b)))]\n    (reduce l n)))","problem":100,"user":"52951156e4b02ebb4ef7501b"},{"problem":100,"code":"(fn [& xs]\n    (letfn [(gcd [a b]\n              (if (zero? b) a\n                  (gcd b (rem a b))))]\n      (let [scd (->> (mapcat #(map (partial conj [%]) xs) xs)\n                     (map (partial apply gcd))\n                     (apply min))]\n        (first\n         (drop-while #(some pos? (map (fn [x] (rem % x)) xs)) (map (partial * scd) (iterate inc 1)))))))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [& xs] (/ (apply * xs) (reduce (fn f [x y] (let [[a b] (sort [x y])] (if (= a 0) b (f a (- b a))))) xs)))","problem":100,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [& xs]\n   (let [x (apply min xs)]\n     (first\n       (filter #(apply = (concat [0] (map (partial rem %) xs)))\n               (iterate (partial + x) x)))))","problem":100,"user":"50f48298e4b004d364930527"},{"code":"(fn [a & body]\n  (reduce #(/ (* %1 %2) ((fn gcd [a b]\n                           (if (= b 0)\n                             a   \n                             (gcd b (rem a b)))) %1 %2)) a body))","problem":100,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn lcm [x & more]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))\n          (my-lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce my-lcm (cons x more))))","problem":100,"user":"4f04d312535dcb61093f6be7"},{"code":"(fn [& l]\n  (reduce (fn [a b]\n            (some #(and (= 0 (rem % b)) %)\n                  (map * (range 1 Integer/MAX_VALUE) (repeat a))))\n            (first l) l))","problem":100,"user":"53460d02e4b084c2834f4a39"},{"problem":100,"code":"(fn [& c]\n  (let [gcd (fn [a b]\n              (let [r (rem a b)]\n                (if (zero? r)\n                  b\n                  (recur b r))))\n        lcm (fn [a b]\n              (let [g (gcd a b)]\n                (/ (* a b) g)))]\n    (reduce #(lcm % %2) c)))","user":"56441634e4b0018b46ad8c08"},{"problem":100,"code":"(fn [& v]\n (apply (fn g [& c]\n  (let [f (map first c) m (apply max f)]\n    (if\n      (apply = f)\n      m\n      (apply g\n        (map\n          #(if (= m (first %)) % (drop-while (partial > m) (rest %)))\n          c\n          )\n        )\n      )\n    )\n  )  (for [x v] (iterate #(+ % x) x)  ))  )","user":"55e1d34ae4b050e68259b421"},{"problem":100,"code":"(fn [& in]\n  (let [save (vec in)]\n  (\n   (fn loo [in2]\n     (if (apply == in2)\n       (first in2)\n       (let [index (.indexOf in2 (apply min in2))]\n         (recur (assoc in2 index (+ (get in2 index) (get save index))))\n       )\n     )\n   )\n  save))\n)","user":"55034bf0e4b086ebe8a79c6d"},{"code":"(fn[number & numbers]\n  (let [gcd (fn [a b]\n              (loop [n a d b]\n                (if (= 0 (rem n d)) \n                  d\n                  (recur d (rem n d)))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm number numbers)))","problem":100,"user":"4dbd2aa3535d020aff1edf40"},{"code":"(fn [& args]\n  (let [smallest (first (sort args))]\n    (loop [multiple 1]\n      (if (reduce (fn [bol arg] (and bol (= 0 (mod (* multiple smallest) arg)))) true args)\n        (* multiple smallest)\n          (recur (+ multiple 1))))))","problem":100,"user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn [h & t]\n  (first\n    (filter (fn [c] (every? #(zero? (mod c %)) t))\n            (iterate (partial + h) h))))","problem":100,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn [& xs]\n  (let [c (apply min xs)]\n    (loop [n c i 0]\n      (cond\n        (>= i (count xs)) n\n        (== (rem n (nth xs i)) 0) (recur n (inc i))\n        :else (recur (+ n c) 0))\n   )))","problem":100,"user":"5370f8ede4b0fc7073fd6ea2"},{"problem":100,"code":"(fn lcm\n  ([a b] (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n           (/ (* a b) (gcd a b))))\n  ([a b & more] (reduce lcm (lcm a b) more)))","user":"553abb28e4b09218d5f44ffb"},{"problem":100,"code":"#(letfn [(abs [x] (if (neg? x) (- x) x))\n         (gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n         (lcm [a b] (/ (abs (* a b)) (gcd a b)))]\n   (reduce lcm %&))","user":"583e27e2e4b089d5ab817daa"},{"problem":100,"code":"(fn r [& x] (if (= 1 (count x)) (first x)\n                                   (apply r (vec\n                                              (cons\n                                                (/\n                                                  (*\n                                                    (first x)\n                                                    (second x))\n                                                  (loop [p (first x) y (second x)]\n                                                    (cond (= p y)\n                                                                                           y\n                                                                                           (> p y) (recur y (- p y))\n                                                                                           (< p y) (recur p (- y p)))))\n                                                       (drop 2 x)))\n                                         )))","user":"592bb806e4b072a2710fcf46"},{"problem":100,"code":"(fn\n  [& input]\n  (let [gcd\n        (fn [& input]\n          (loop [start (apply min input)]\n            (if (reduce #(and %1 %2) (map #(= 0 (mod % start)) input))\n              start\n              (recur (dec start)))))\n        lcm\n        (fn [& input]\n          (/\n            (apply * input)\n            (loop [start (apply min input)]\n              (if (reduce #(and %1 %2) (map #(= 0 (mod % start)) input))\n                start\n                (recur (dec start))))))]\n    (/\n      (apply lcm (map #(numerator (clojure.lang.Numbers/toRatio %)) input))\n      (apply gcd (map #(denominator (clojure.lang.Numbers/toRatio %)) input)))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":100,"code":"(fn lcm [& args]\n  (reduce\n    #(/ (* %1 %2) ((fn [a b] (if (zero? (mod a b)) b (recur b (mod a b)))) %1 %2))\n    args))","user":"524f3e6de4b0541d1855b805"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (let [gcm (fn gc[x y]\n               (if (= 0 x) y\n                 (gc (mod y x) x)))]\n     (/ (* a b) (gcm a b))))\n  ([a b & args]\n   (reduce lcm (lcm a b) args)))","user":"57bd960fe4b05aa3c4741c52"},{"problem":100,"code":"(fn lcm-v2 [& args]\n  (letfn [(gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b)\n               (gcd a b)))]\n  (reduce lcm args)))","user":"57c0917be4b05aa3c4741c95"},{"problem":100,"code":"(fn [& numbers]\n  (let [gcd (fn self [x y] (let [h (max x y)\n                                 l (min x y)]\n                             (if (= 0 (rem h l)) l (self l (rem h l)))))\n        lcm (fn [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm numbers)))","user":"539dcb24e4b0b51d73faaf3d"},{"problem":100,"code":"(fn [& args]\n  (loop [mults (map #(iterate (partial + %) %) args)]\n    (let [heads (map first mults)]\n      (if (apply = heads)\n        (first heads)\n        (recur (map #(if (< (first %) (apply max heads))\n                       (next %)\n                       %) mults))))))","user":"55895eade4b059ccff29b202"},{"problem":100,"code":"(fn [& v] (reduce (fn [a b] (/ (* a b) ((fn [a b] (if (zero? b) a (recur b (mod a b)))) a b))) v))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [& f]\n  (loop [c f]\n    (if (apply = c)\n      (first c)\n      (let [m (apply max c)]\n        (recur (map (fn [a b]\n                      (if (< a m) (+ a b) a))\n                    c f))))))","problem":100,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":100,"code":"(fn [& args]\n  (let [step \n        (fn [xs] \n            (let [minx (apply min xs) n (count xs)] \n                (loop [i 0 v (transient []) updated false]\n                    (if (< i n)\n                        (if (or updated (not= minx (nth xs i)))\n                            (recur (inc i) (conj! v (nth xs i)) false)\n                            (recur (inc i) (conj! v (+ (nth args i) minx)) true)\n                        )\n                        (persistent! v)))))\n        ]\n  (first \n      (first \n          (drop-while \n              #(not= (count (set %1)) 1)\n              (iterate step (vec args))\n              )))))","user":"555ac933e4b0deb715856e49"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn gcd [a b] \n              (cond \n               (or (= a 0) (= b 0)) 0\n               (= a b) a\n               (> a b) (gcd (- a b) b)\n               :else (gcd a (- b a))))\n        group-gcd (reduce #(gcd %1 %2) (first args) (rest args))\n        group-product (apply * args)]\n   (/ group-product group-gcd)))","user":"5cd639b4e4b0ccb061962940"},{"code":"(fn lcm [& nums]\n  (reduce #(/ (* % %2)\n              ((fn gcd [a b]\n                (cond (= a b) a\n                      (< a b) (gcd a (- b a))\n                      :else (gcd (- a b) b))) % %2)) nums))","problem":100,"user":"4e5af45e535d8a8b8723a2b1"},{"code":"(fn least-common [& xs]\n  (letfn [(gcd [x y] (if (= 0 y) x (gcd y (mod x y))))\n          (least-common-2 [x y] (/ (* x y) (gcd x y)))\n          (int-least-common [xs] (reduce least-common-2 (first xs) (rest xs)))\n          (des [xs] (map #(if (integer? %) 1 (denominator %)) xs))]\n    (/ (int-least-common (map #(* % (int-least-common (des xs))) xs)) (int-least-common (des xs)))))","problem":100,"user":"4f251302e4b0d66497709ff0"},{"code":"#(reduce (fn [x y] (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))] (/ (* x y) (gcd x y)))) %&)","problem":100,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn [& args] (let [head (first args)\n                        tail (rest  args)\n                        f (fn gcd [a b] \n                          (if (= 0 (rem a b)) \n                              b\n                              (gcd b (rem a b))))]\n         ( / (apply * args) (reduce f head tail))))","problem":100,"user":"4efd98fa535de96065cf5086"},{"code":"(fn lcm [& args]\n  (letfn [(limit [a b]\n            (apply\n             *\n             (map #(if (ratio? %)\n                     (* (denominator %) (numerator %))\n                     %)\n                  [a b])))]\n    (reduce #(let [m (limit %1 %2)]\n               (first\n                (for [x (take m (iterate inc 1)) y (take m (iterate inc 1))\n                      :when (= (* x %1) (* y %2))]\n                  (* x %1))))\n            args)))","problem":100,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn [& nums]\n   (reduce\n     (fn [numa numb]\n   (/ (* numa numb)\n      ((fn ! [num1 num2]\n   (if (= (mod num1 num2) 0)\n     num2\n     (! num2 (mod num1 num2))\n     )\n   ) numa numb)\n      )   \n   )\n    nums)       \n   )","problem":100,"user":"5106dc1be4b01150e115ebf0"},{"problem":100,"code":"(letfn \n  [(gcd [a b]\n        (if (zero? b)\n          a\n          (recur b, (mod a b))))\n   (lcm [a b]\n        (/ (* a b) (gcd a b)))]\n\n  (fn [& v] (reduce lcm v)))","user":"53065acbe4b02e8216869792"},{"code":"(fn [& ins]\n  (loop [xs ins]\n    (if (apply = xs)\n      (first xs)\n      (let [minx (apply min xs)]\n        (recur (map-indexed #(if (= %2 minx)\n                               (+ (nth ins %) %2)\n                               %2)\n                            xs))))))","problem":100,"user":"4e976f79535dbda64a6f6b55"},{"code":"(letfn [(gcd [a b]\n  (cond\n    (= 0 a) b\n    (= 0 b) a\n    (> a b) (gcd (- a b) b)\n    :else (gcd a (- b a))\n  ))]\n    (fn [& as] (/ (reduce * as) (reduce gcd as)))\n  )","problem":100,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [& args]\n  (let [[least & more] (sort args)]\n    (some #(when (every? (fn [x] (== 0 (mod % x))) more) %) \n          (map * (iterate inc 1) (repeat least)))))","problem":100,"user":"4e593dac535d8a8b8723a29c"},{"problem":100,"code":"(fn [& args]\n  (first\n    (filter\n      (fn [x] (every? (fn [a] (zero? (rem x a))) args))\n      (iterate #(+ (apply max args) %) (apply max args)))))","user":"5e246f92e4b05b4b01516150"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [& nums]\n              (loop [a (apply max nums)\n                     b (apply min nums)]\n                (let [remainder (rem a b)]\n                  (if (zero? remainder) b\n                    (recur b remainder)))))]\n    (reduce (fn [x y] \n              (/ (* x y) (gcd x y)))\n            args)))","user":"56041883e4b0c80df0ca2655"},{"problem":100,"code":"(fn [& s] (/ (apply * s) (apply (fn gcd [& s] (reduce (fn [a b] (if (zero? b) a (recur b (mod a b)))) s)) s)))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"problem":100,"code":"(fn lcm\n  [& xs]\n  (letfn [(gcd [x y]\n            (if (zero? y) x\n                (recur y (mod x y))))]\n    (reduce (fn [x y] (/ (* x y) (gcd x y))) xs)))","user":"5a0a04eee4b0eab8c0448935"},{"code":"#((fn [a] \n    (if (apply = (map first a))\n      (first (first a))\n      (recur (sort (cons (vector (+ (first (first a)) (second (first a)))\n                                 (second (first a)))\n                         (rest a))))))\n   (sort (for [x %&] [x x])))","problem":100,"user":"4efb2fd7535dced4c769f274"},{"problem":100,"code":"(fn [& lst]\n  (let [origin (apply vector lst)]\n\t(->> origin\n\t\t(iterate\n\t\t\t(fn [iter-vec]\n\t\t\t(let [minimum (reduce min iter-vec)\n\t\t\t\t  min-id (.indexOf iter-vec minimum)]\n\t\t\t\t(assoc iter-vec min-id (+ minimum (get origin min-id))))))\n\t\t(drop-while #(not (apply = %)))\n\t\tfirst\n\t\tfirst)))","user":"55ad0e18e4b03311e7b7329c"},{"problem":100,"code":"(fn [& args]\n  (letfn [\n    (gcd [x y]\n      (cond \n        (> x y) (recur (- x y) y)\n        (< x y) (recur (- y x) x)\n        :else x))\n    (lcm [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"574dfcb8e4b02ea11479923a"},{"problem":100,"code":"(fn least[& etc]\n  (let[n(apply max etc)]\n    (loop[m 2]\n      (let\n        [p(* m n)]\n        (if(every? #(zero?(mod p %)) etc) p\n          (recur(inc m)))))))","user":"6085edade4b0736b099e42fc"},{"problem":100,"code":"(fn lcmMult\n  [x y & rest]\n  (let [gcd (fn [a b] (if (< a b) (recur b a) (if (zero? b) a (recur b (rem a b)))))\n        lcm (fn [x y] (* (/ x (gcd x y)) y))]\n    (reduce lcm (lcm x y) rest)))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":100,"code":"(fn lcm \n  ([a b]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))] \n     (/ (* a b) (gcd a  b))))\n  ([a b & c] (reduce lcm (conj c a b)))\n  )","user":"569951e4e4b0542e1f8d143e"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [m n]\n                   (loop [n1 m\n                          n2 n]\n                     (cond\n                      (= n1 n2) n1\n                      (> n1 n2) (recur n2 (- n1 n2))\n                      :else (recur (- n2 n1) n1))))\n          (lcm [m n]\n               (/ (* m n) (gcd m n)))]\n    (let [numerators (map (fn [x]\n                            (if (= clojure.lang.Ratio (class x))\n                              (numerator x)\n                              x)) args)\n          denominators (map (fn [x]\n                              (if (= clojure.lang.Ratio (class x))\n                                (denominator x)\n                                1)) args)]\n      (/ (reduce lcm numerators) (reduce gcd denominators)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":100,"code":"(fn [& args]\n  (loop [h (apply hash-map (flatten (map list args args)))]\n    (cond (every? #(= (val (first h)) (val %)) h) (val (first h))\n          :else (let [id (key (first (filter #(= (apply min (vals h)) (val %)) h)))]\n                  (recur (assoc h id (+ id (h id))))))))","user":"538e36c7e4b0b51d73faae81"},{"problem":100,"code":"(fn lcm [& args]\n    (let\n        [\n            gcd\n                (fn [a b]\n                    (if (zero? b)\n                        a\n                        (recur b (mod a b))\n                    )\n                )\n        ]\n        (reduce #(/ (* %1 %2) (gcd %1 %2)) args)\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":100,"code":"(fn [& nums]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (rem a b))))]\n      (reduce #(/ (* % %2) (gcd % %2)) nums)))","user":"5c165d3ee4b01240ff5671d1"},{"problem":100,"code":"(fn [& args]\n    (let [gcd (fn [a b] (if (zero? b) a\n                          (recur b (mod a b))))\n          lcm (fn [a b] (/ (* a b) (gcd a b)))]\n      (reduce lcm args)))","user":"515ebde3e4b01e5d11ccd0a8"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\r\n    (fn lcm [& xs]\r\n      (let [[h & t] (seq xs)]\r\n        (reduce #(/ (* %1 %2) (gcd %1 %2)) h t))))","problem":100,"user":"4f047177535dcb61093f6bc6"},{"problem":100,"code":"#(let [gcd (fn [num1 num2]\n             (cond\n              (zero? num1) num2\n              (zero? num2) num1\n              (> num1 num2) (recur (rem num1 num2) num2)\n              :else (recur num1 (rem num2 num1))\n              ))\n       lcm (fn [num1 num2]\n             (/ (* num1 num2)\n                (gcd num1 num2)))]\n   (reduce (fn [x y]\n             (cond\n              (and (ratio? x) (ratio? y)) (/ (lcm (numerator x)\n                                                  (numerator y))\n                                             (gcd (denominator x)\n                                                  (denominator y)))\n              (ratio? x) (lcm (numerator x) y)\n              (ratio? y) (lcm x (numerator y))\n              :else (lcm x y)\n              ))\n           %&))","user":"60096aabe4b074f607df667f"},{"problem":100,"code":"(fn [n m & xs]\n  (letfn [(gcd [a b]\n               (cond\n                (zero? a) b\n                (zero? b) a\n                (< a b) (recur a (- b a))\n                :else (recur b (- a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (let [init (lcm n m)]\n      (if (seq xs)\n        (reduce lcm init xs)\n        init\n      )\n    )\n  )\n)","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn [& n]\n   (loop [cols (map #(rest (map * (repeat %) (range))) n)]\n       (if (apply = (map first cols))\n           (first (first cols))\n           (let [mc (apply min-key first cols)\n                 min (first mc)\n                 n-cols (map #(if (= min (first %))\n                                  (rest %)\n                                  %) cols)]\n                 (recur n-cols)))))","problem":100,"user":"4eeaf88f535d93acb0a668a3"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (let [r (rem x y)]\n                 (if (= r 0)\n                   y\n                   (gcd y r))))\n          (lcm [x y]\n               (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":100,"code":"(fn lcm [& numbers]\n  \"Least Common Multiple\"\n  (letfn [(-gcd [a b]  \"GCD of two numbers\"  (if (zero? b) a (-gcd b (mod a b))))\n          (gcd  [& ns] \"GCD of many numbers\" (reduce -gcd ns))]\n    (/ (reduce * numbers) (reduce gcd numbers))))","user":"53710c09e4b0fc7073fd6ea5"},{"problem":100,"code":"(fn [& args]\n  (letfn [(lcm [a b]\n            (loop [x a\n                   y b]\n              (if (= x y)\n                x\n                (if (< x y)\n                  (recur (+ x a) y)\n                  (recur x (+ y b))))))]\n    (reduce lcm args)))","user":"5f2c94b4e4b033932238a669"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [args]\n            (if (= 1 (count args))\n              (first args)\n              (loop [[a b] (take 2 args)]\n                (if (zero? b)\n                  (gcd (cons a (drop 2 args)))\n                  (recur [b (mod a b)])))))]\n    (/ (reduce * args) (gcd args))))","user":"58b80ec1e4b0ebc645576d89"},{"problem":100,"code":"(fn lcm\n  ([x y & z] (apply (partial lcm (lcm x y)) z))\n  ([x y]\n   (let [num-gcd (apply\n                  (fn gcd [a b]\n                    (cond\n                     (= a 0) b\n                     (= b 0) a\n                     :else (gcd b (rem a b))))\n                  (if (> x y) [x y] [y x]))]\n     (/ (* x y) num-gcd))))","user":"55a5c3bee4b0acc240e3154e"},{"problem":100,"code":"(fn [& args]\n    (let [gcdfn (fn gcd [a b]\n                  (if (zero? b)\n                    a\n                    (recur b (mod a b))))\n          lcdfn (fn lcd [x y]\n                  (/ (* x y) (gcdfn x y)))]\n      (reduce lcdfn args)))","user":"53716539e4b0fc7073fd6eb1"},{"code":"(fn [& args] (some #(if (zero? (apply + (map (fn [n] (mod % n)) (rest args)))) %) (map #(* (first args) (inc %)) (range))))","problem":100,"user":"5028cd0fe4b01614d1633ffc"},{"problem":100,"code":"(fn lcm [& args]\n    (loop [ c args ]\n      (let [ n0 (nth c 0) \n           , n1 (nth c 1)\n           ;, lcm0 (/ (* n0 n1) (gcd n0 n1))\n           , lcm0 (/ (* n0 n1)\n                     ((fn gcd [n1 n2]\n                        (loop [ x1 n1, x2 n2 ]\n                          ( let [r (mod x1 x2)]      \n                            (if (= r 0)\n                              x2\n                              (recur x2 r)\n                              )\n                            )                      \n                          )\n                        ) n0 n1)\n                     )                   \n           , r (rest (rest c)) ]\n        (if (= 2 (count c))\n          lcm0\n          (recur (concat [lcm0] r ) )\n        )\n      )\n    )\n)","user":"571aae1fe4b07c98581c3b5a"},{"problem":100,"code":"(fn lcm [& args]\n  (let [prod (reduce * args)\n        gcd (reduce (fn [a b] (if (zero? b) a (recur b (mod a b)))) args)]\n    (/ prod gcd)))","user":"54cbd6bae4b057c6fda3a282"},{"code":"(fn [& coll]\n  (let [big (apply max coll)]\n    (first (filter #(every? true? (map (fn [x] (zero? (mod % x))) coll)) (iterate (partial + big) big)))))","problem":100,"user":"52cca65be4b07d0d72b2736b"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [abs (fn [x] (if (< x 0) (- x) x))\n        gcd (fn [a b] (if (= a b) a (recur (abs (- a b)) (abs (min a b)))))]\n    (/ (abs (apply * xs)) (reduce gcd xs))))","user":"5cab33e7e4b048ec896c5c48"},{"problem":100,"code":"(fn [& args] (reduce (fn [a b] (/ (* a b) (#(if (zero? %) %2 (recur (mod %2 %) %)) a b))) args))","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [& nums]\n  (loop [i 1]\n    (let [x (* (apply min nums) i)]\n      (if (every? #(= 0 (rem x %)) nums)\n        x\n        (recur (+ i 1))))))","problem":100,"user":"4fe15ffee4b0dd6cd5ce3634"},{"problem":100,"code":"#(reduce (fn [a b]\n  (/ (* a b)\n     ((fn [a b]\n        (if (zero? b)\n          a\n          (recur b (mod a b))))\n       a b))) %&)","user":"54577fefe4b01be26fd7460d"},{"problem":100,"code":"(fn lcm [& args]\n   (let [m (apply max args)]\n     (loop [n 1]\n       (if (every? #(zero? (mod (* m n) %)) args)\n         (* m n)\n         (recur (inc n))))))","user":"55a372f1e4b0acc240e31537"},{"problem":100,"code":"(fn lcm\n  ([a b & numbers] (apply lcm (lcm a b) numbers))\n  ([a b]\n    (loop [as (drop 1 (map (partial * a) (range)))\n           bs (drop 1 (map (partial * b) (range)))]\n      (let [x (first as)\n            y (first bs)]\n          (cond\n           (< x y) (recur (drop 1 as) bs)\n           (> x y) (recur as (drop 1 bs))\n           :else x)))))","user":"59d9186be4b0ef0a1e9b5c50"},{"code":"(fn [& col]\n  (letfn [(my-lcm [x y]\n   (loop [x2 x y2 y]\n     (cond \n      (= x2 y2) x2\n      (< x2 y2) (recur (+ x2 x) y2)\n      :else (recur x2 (+ y2 y))\n      )))]\n    (reduce my-lcm col)))","problem":100,"user":"50bfe725e4b080409b860f26"},{"problem":100,"code":"(fn [& i]\n           (let [gcd (fn gcd [& i]\n                       (if (apply = i)\n                         (first i)\n                         (let [minimum (apply min i)]\n                           (apply gcd (map #(if (= % minimum) % (- % minimum)) i)))))]\n             (/ (apply * i) (apply gcd i))))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":100,"code":"(fn [& nums]\n  (loop [tmpn (apply min nums) a (apply min nums)]\n    (if (every? #(= 0 (mod tmpn %)) nums)\n      tmpn\n      (recur (+ a tmpn) a))))","user":"59368ccae4b02506e01a297a"},{"problem":100,"code":"(fn lcm [& args]\n  (let [smax (apply * args)]\n    (apply min\n     (apply clojure.set/intersection\n            (map\n             #(into #{} (map (partial * %) (range 1 1000)))\n             args)))))","user":"54eff2bee4b024c67c0cf88d"},{"code":"(fn [& f]\n  (let [ x #(if (< % 0) (- %) %)\n         g (fn [a b]\n             (if (= b 0) a\n                         (recur b (mod a b))))\n         l #(/ (x (* %1 %2)) (g %1 %2))]\n    (reduce l f)))","problem":100,"user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn\n  [x & args]\n  (loop [current (+ x x)]\n    (if (and (> current 0)\n             (every? #(integer? (/ current %)) args))\n      current\n      (recur (+ current x)))))","problem":100,"user":"51ab4082e4b04e3dc0c27b31"},{"code":"#(letfn [(gcd [x y]\n            (loop [[a b] (if (> x y) [x y] [y x])]\n              (if (= b 0) a (recur [b (mod a b)]))))]\n    (/ (apply * %&)\n       (reduce gcd %&)))","problem":100,"user":"4fbf2818e4b081705acca317"},{"code":"(fn l\n  ([x y]\n     (letfn [(g [a b] (if (= b 0) a (g b (rem a b))))]\n       (/ (* x y) (g x y))))\n     ([x y & rest] (apply l (l x y) rest)))","problem":100,"user":"4fdf2b50e4b05e33b9224f93"},{"code":"(fn [n & m]\n  (reduce (fn [a b] (/ (* a b) (#(if (zero? %1)\n      %2\n      (recur (mod %2 %1) %1)) a b)))\n        n m))","problem":100,"user":"5107b86de4b05b2b4eee7495"},{"problem":100,"code":"(fn [& xs] (reduce #(letfn [(gcd [x y] (let [z (rem x y)] (if (zero? z) y (recur y z))))] (/ (* %1 %2) (gcd %1 %2))) xs))","user":"555b35f7e4b0deb715856e4b"},{"problem":100,"code":"(fn [& fac](first (take 1 (filter (fn [num] (every? identity (map #(zero? (mod num %)) fac))) (iterate #(+ 1/2 %) 1)))))","user":"520cb8c4e4b0b022ef140c9a"},{"code":"#(reduce (fn [a b] (loop [m b] (if (zero? (mod m a)) m (recur (+ m b))))) (sort %&))","problem":100,"user":"4ef9c8f9535dced4c769f26b"},{"code":"(fn lcm [& args]\n  (if (every? ratio? args)\n    (let [lcmd (apply lcm (map denominator args))\n          lcmn (apply lcm (map #(* (numerator %) (/ lcmd (denominator %))) args))]\n      (/ lcmn lcmd))\n    (first\n     (filter (fn [i]\n               (every?\n                (fn [a] (zero? (mod i a)))\n                args))\n             (rest (range))))))","problem":100,"user":"4f83665ee4b033992c121c1c"},{"problem":100,"code":"#(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm [a b & args]\n            (if (seq args)\n              (apply lcm (cons (/ (* a b) (gcd a b)) args))\n              (/ (* a b) (gcd a b))))]\n    (apply lcm %&))","user":"5ebc7c13e4b00a66d4a95267"},{"code":"(fn [& more]\n  (let [gcd (fn gcd[x y](let [[x y] (sort [x y])]\n    (cond (ratio? x) (if (ratio? y)\n  \t       (gcd (.denominator x) (.denominator y))\n\t\t       1)\n\t  (= x 0) y\n\t  1 (gcd x (- y x)))))\n        lcm (fn lcm[x y](let [g (gcd x y)]\n    (cond (and (ratio? x) (ratio? y))\n    (let [m (* (.denominator x) (.denominator y))]\n\t    (/ (* m x y) g))\n\t  (ratio? y) (lcm y x)\n\t  (ratio? x)\n\t  (let [m (.denominator x)]\n\t    (/ (lcm (* x m) (* y m)) g m))\n\t  true (/ (* x y) g))))]\n  (reduce lcm more)))","problem":100,"user":"4e7eff9e535db966e863cc38"},{"code":"(fn [& col]\n   (letfn [(gcd [x y]\n             (if (= x 0) y\n                 (recur (mod y x) x)))]\n     (/ (apply * col) (reduce gcd col))))","problem":100,"user":"52c25645e4b07a9af579237d"},{"problem":100,"code":"(fn [& args] \n  (reduce (fn [x y]\n            (/ (* x y)\n               (loop [a (max x y)\n                      b (min x y)]\n                 (let [c (rem a b)]\n                   (if (= c 0)\n                     b\n                     (recur b c)))))) args))","user":"5d84f5e6e4b0915913b1d38f"},{"code":"(fn *lcm\n  [& args]\n  (first (filter (partial (fn num-arg?\n                      [coll n]\n                      (if (= (count coll)\n                             (count (remove false? (map #(= (* (quot n %1) %1) n) coll))))\n                        true\n                        false))\n                    (apply concat (vector args))) (range 1 400 1/2))))","problem":100,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn lcd [n & ns]\n  (loop [x n]\n    (if (every? #(zero? (rem x %)) ns)\n      x\n      (recur (+ n x)))))","problem":100,"user":"4f9acea6e4b0dcca54ed6d10"},{"problem":100,"code":"(fn [& v]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)]\n              (if (= 0 (mod a b))\n                b\n                (recur (- a b) b))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm v)))","user":"55e1bb20e4b050e68259b41f"},{"code":"(fn [& nums] (/ (reduce * nums) (reduce\n  (fn gcd [a b] (cond (> b a) (gcd b a)\n                (= b 0) a\n                :else (gcd b (mod a b))))\n  nums)))","problem":100,"user":"504e108ce4b078edc5f593b3"},{"code":"(fn [& ns]\n            (some (fn [n] (if (every? #(zero? (rem n %)) ns) n))\n                  (let [m (apply min ns)] (iterate (partial + m) m))))","problem":100,"user":"4ed292ac535d44c135fd68d9"},{"problem":100,"code":"(fn [& args] (reduce \n(fn [a b] (/ (* a b) ((fn gcd [x y] (if (< x y) (gcd y x) (if (= 0 y) x (gcd y (mod x y))))) a b))) args))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn lcm [& n]\n  (let [gcd (fn [a b]\n    (if (= b 0) a\n      (recur b (mod a b))))]\n    (reduce\n      #(/ (* %1 %2) (gcd %1 %2))\n      n)))","problem":100,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [& s]\n           (letfn [(hcf [p q]\n                        (loop [x p y q]\n                           (if (zero? y)\n                               x\n                               (recur y (rem x y)))))\n                  (lcm [p q]\n                       (/ (* p q) (hcf p q)))\n                  ]\n                  (reduce lcm (first s) s)))","problem":100,"user":"4f03f197535dcb61093f6b84"},{"problem":100,"code":"(fn [& args]\n  (let [\n        gcd #(let [u (max %1 %2) v (min %1 %2) u (mod u v)]\n               (if (= 0 u)\n                 v\n                 (recur v u)))\n        \n        lcm #(/ (* %1 %2) (gcd %1 %2))\n        ]\n    (reduce lcm args)))","user":"57458b82e4b009280f9f2b4e"},{"problem":100,"code":"(fn [x & args]\n  (loop [l x]\n    (if (every? #(= 0 (mod l %)) args)\n      l\n      (recur (+ l x)))))","user":"5bb948f5e4b0a20761a235d5"},{"problem":100,"code":"(fn least-common-mult \n  ([x y] (let [l (min x y)\n         b (max x y)\n         incr b]\n     (loop [curr b]\n       (if (zero? (rem curr l))\n         curr (recur (+ curr incr))\n         )\n       )\n     )\n    )\n  ([x y & res]    \n    (reduce least-common-mult (least-common-mult x y) res)    \n    )\n  )","user":"55f06183e4b06e875b46ce23"},{"code":"#(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n  (/ (apply * %&) (reduce gcd %&)))","problem":100,"user":"50479524e4b0371827a27bc4"},{"code":"(fn [& args]\n  (letfn \n    [(gcd [a b]\n      (if (zero? b) a\n          (gcd b (mod a b))))]\n  (/\n    (reduce *   args)\n    (reduce gcd args))))","problem":100,"user":"521e8227e4b0dd19981ad082"},{"problem":100,"code":"(fn lcm\n  ([]  0)                         ; no parameter\n  ([x] x)                         ; one parameter\n  ([x y] (/ (* x y)  ((fn [k m] (loop [e k f m] (if (= f 0) e (recur f (rem e f) ) ))) x y) ))                 ; two parameters\n  ([x y & more]                   ; more than two parameters\n    (reduce lcm (lcm x y) more))\n  )","user":"55d7312ee4b0e31453f64a9f"},{"problem":100,"code":"(fn get-low [& args] (letfn [(gcd [a b] (if (zero? b) a(recur b, (mod a b))))\n         (lcm [a b] (/ (* a b) (gcd a b)))]\n\t\t  (reduce lcm args)))","user":"50e1bdd8e4b019fc399ce17f"},{"problem":100,"code":";; positive numbers are lattice for gcd and lcd (commutative, associative)\n(fn [& xs]\n  (let [gcd (fn gcd [m n]\n              (if (= 0 (mod m n))\n                n\n                (gcd n (mod m n))))\n        lcd (fn [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcd xs)))","user":"55d5ee3fe4b0e31453f64a92"},{"code":"(letfn [(f [a b] (if (zero? a) b (f (mod b a) a)))]\n  #(/ (apply * %&) (reduce f %&)))","problem":100,"user":"4e82f85d535db62dc21a62ce"},{"problem":100,"code":"(fn [& l]\n  (let [gcd (fn gcd [x y] (if (> x y)\n                          (loop [ a x b y]\n                            (if (zero? (rem a b)) b\n                          (recur b (rem a b))))\n              \t\t\t(gcd y x)))]\n    (/  (reduce * l) (reduce gcd l))))","user":"55c77070e4b0e31453f649d0"},{"code":"(fn [& xs] (reduce  (fn lcm [x y] (/ (* x y) ((fn f [x y] (loop [larger (max x y) smaller (min x y)] (let [r (mod larger smaller)] (if (= r 0) smaller (recur (max smaller r) (min smaller r))))))  x y )))   xs))","problem":100,"user":"52be0263e4b07a9af579230e"},{"problem":100,"code":"(fn lcm\n  [& n]\n  (loop [nums (zipmap n n)]\n    (if (not= (-> nums vals distinct count) 1)\n      (let [least (apply min (vals nums)),\n            orig (first (filter #(= (nums %) least) (sort (keys nums))))]\n        (recur (merge nums {orig (+ least orig)})))\n     (first (vals nums)))))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"problem":100,"code":"(fn [& args] (/  (apply * args) (reduce \n            #(loop [n1 (max %1 %2) n2 (min %1 %2)]\n                              (if (= 0 (rem n1 n2)) n2\n                                (recur (/ (- n1 (rem n1 n2)) (quot n1 n2)) (rem n1 n2))))\n            args)))","user":"54e4edcae4b024c67c0cf7f3"},{"problem":100,"code":"(fn lcm \n  ([x y]\n   (letfn [(gcd [a b]\n               (cond\n                (zero? b) a\n                (> a b) (gcd b (mod a b))\n                :else (gcd a (mod b a))))]\n       (/ (* x y) (gcd x y))))\n  ([x y & more]\n  \t(apply lcm (lcm x y) more)))","user":"559bdf16e4b066d22e731f5a"},{"code":"(fn [& xs]\n  (letfn [(fact [n]\n    \t\t(loop [x n factors (zipmap [2 3 5 7] (repeat 0)) [p & ps :as prs] [2 3 5 7]]\n\t\t\t\t(cond\n      \t\t\t\t(nil? p) factors \n      \t\t\t\t(= 0 (mod x p)) (recur (/ x p) (merge-with + factors {p 1}) prs)\n      \t\t\t\t:else (recur x factors ps))))\n          (lcm-int [& ys]\n\t\t  \t(int (reduce (fn [acc [k v]] (* acc (Math/pow k v))) 1\n          \t\t(apply merge-with max (map fact ys)))))]\n  \t(if (every? integer? xs)\n    \t(apply lcm-int xs)\n    \t(let [denoms (map denominator (filter ratio? xs))\n          \t\tlcm' (apply lcm-int denoms)\n          \t\tvals (map (partial * lcm') xs)]\n      \t\t(rationalize (/ (apply lcm-int vals) lcm' ))))))","problem":100,"user":"5097a95fe4b00ad8bab4e96e"},{"code":"(fn lcm\n  ([a b] (let [gcd (fn gcd [a b]\n  (loop [a a\n         b b]\n    (if (zero? (rem a b))\n      b\n      (recur b (rem a b)))))]\n  (/ (* a b) (gcd a b))))\n  ([a b & c] (reduce lcm (conj c a b))))","problem":100,"user":"4feff3b6e4b0678c553fc31e"},{"problem":100,"code":"(fn [& numbers]\n  (loop [maxnbr (apply max numbers)]\n    (if (= (repeat (count numbers) 0) (map #(mod maxnbr %) numbers))\n      maxnbr\n      (recur (+ (apply max numbers) maxnbr))\n      )))","user":"60593916e4b07e92fa001acc"},{"problem":100,"code":"(fn [ & args ]\n\n  (letfn [\n           (gcd [a b] \n             (if (= b 0)\n               a\n               (recur b (rem a b))))\n       ]\n\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)\n\n))","user":"56f2611fe4b04a395b9a04a2"},{"problem":100,"code":"(fn [& xs]\n  (loop [xms (map #(identity [% %]) xs)]\n    (if (apply = (map second xms))\n      (second (first xms))\n      (let [xk (apply min (map second xms))\n\t\t\tsome-fn (fn [[x0 xm]] \n                      (if (= xm xk)\n                        [x0 (+ xm x0)]\n                        [x0 xm]))\n            xm+1s (map some-fn xms)]\n        (recur xm+1s)))))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn lcm [& xs]\n    (let [mn (apply min xs)]\n        (loop [n mn]\n            (if (apply (partial = 0) (map #(rem n %) xs))\n                n\n                (recur (+ n mn))))))","problem":100,"user":"4f128865535d64f603146428"},{"code":"#(reduce (fn [a b] (loop [p a q b] (\n  cond (= p q) p\n       (< p q) (recur (+ p a) q)\n       :e (recur p (+ q b))))) %&)","problem":100,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":100,"code":"(fn [& args]\n  (reduce\n   (fn lcm [a & arg]\n     (let [gcd (fn [x y]\n                 (if (zero? y)\n                   x\n                   (recur y (mod x y))))]\n       (/ (* a (first arg)) (gcd a (first arg)))))\n   args))","user":"5684e200e4b04eec3ec5cfc4"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [x y]\n               (->> [x y]\n                    (iterate (fn [[x y]]\n                               [y (rem x y)]))\n                    (some (fn [[x y]]\n                            (when (zero? y) x)))))\n          [lcm-2 [x y]\n           (let [mini-lcm (gcd x y)]\n             (-> (* x y)\n                 (/ mini-lcm)))]]\n    (reduce lcm-2 args)))","problem":100,"user":"52381b2ae4b0fae3832e99ef"},{"problem":100,"code":"(fn [& v] (reduce (fn [a b] (let [sorted (sort [a b])\n                 major (last sorted)\n                 minor (first sorted)\n                 gdc  (#(loop [result 0\n                               a %1\n                               b %2]\n                          (if (= 0 b)\n                            a\n                            (recur result b (mod a b)))) major minor)]\n                 (/ (* major minor) gdc))) v))","user":"5b198eace4b03cfeda66ecbb"},{"problem":100,"code":"(fn lcm-2 [& nums]\n  (let [hashed-nums (zipmap (range 0 (count nums)) nums)\n        check-update (fn check-update [new-nums] (if (apply = (vals new-nums))\n                                                     (first (vals new-nums))\n                                                     (let [update-key (apply max (map #(if (= (apply min (vals new-nums)) (val %))\n                                                                                   (key %)\n                                                                                   -1)\n                                                                                new-nums))]\n                                                       (check-update\n                                                          (assoc new-nums\n                                                            update-key\n                                                            (+ (get hashed-nums update-key) (get new-nums update-key)))))))]\n    (check-update hashed-nums)\n))","user":"52af7a5ce4b0c58976d9acbd"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a (gcd b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"52d1e364e4b0d9f9285948e7"},{"code":"(fn [& v] (let [a \n(map #(if (integer? %) [% 1] \n (map (fn [x](Integer/parseInt x))\n     (clojure.string/split (str %) #\"\\/\"))\n) v)\nz (map first a) m (map second a)\n]\n(/ (apply * z) (reduce #(apply max\n      (let [min (min %1 %2)  \n              max (max %1 %2)]   \n          (for [i (range 1 (+ min 1))\n                :when \n               (and (zero? (rem min i))\n                     (zero? (rem max i)))]\n            i))) m\n\n))\n\n))","problem":100,"user":"517945dce4b0684c1c981a43"},{"code":"(fn lcm\n  ( [ x y ]\n    (let [r (/ x y)]\n      (if (ratio? r) (* x (denominator r))\n          x)) )\n  ( [ x y & more ]\n      (reduce lcm (lcm x y) more)))","problem":100,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":100,"code":"(fn [x & xs]\n   (reduce #(/ (* %1 %2) ((fn [a b] (if (zero? b) a (recur b (mod a b)))) %1 %2)) x xs))","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":100,"code":"(fn [& nums]    \n    (letfn [\n      (gcd [a b]\n        (cond\n        (zero? a) b\n        (zero? b) a\n        (> b a) (gcd b a)\n        :else (gcd b (rem a b))))\n      (lcm [a b]        \n        (/ (* a b) (gcd a b)))\n      ]\n      (reduce lcm nums)))","user":"5c01ba2ce4b0bdcf453d1656"},{"code":"(fn lcm3\n  ([a b]\n     (letfn [(gcd2 [a b]\n               (cond\n                (= b 0) a\n                (> a b) (gcd2 b (mod a b))\n                (> b a) (gcd2 a (mod b a))))]\n       (/ (* a b) (gcd2 a b))))\n  ([a b & rest] (apply lcm3 (lcm3 a b) rest)))","problem":100,"user":"4f91f5b1e4b0dcca54ed6ca7"},{"code":"(fn lcm\n  [& args]\n  (letfn [(multiples\n            [n]\n            (iterate (partial + n) n))\n          (find-multiple\n            [ms]\n            (if (apply = (map first ms))\n              (ffirst ms)\n              (let [[[_ & el] & els] (sort-by first ms)]\n                (find-multiple (cons el els)))))]\n    (find-multiple (map multiples args))))","problem":100,"user":"51f9527fe4b09be9c177e549"},{"problem":100,"code":"(fn lcm [& r]\n  (letfn [(div-by-all? [n l]\n            (reduce #(and %1 %2) true (map #(= 0 (mod n %)) l)))]\n    (let [m (apply min r)]\n      (loop [m2 m]\n        (do (println m2 r)\n            (if (div-by-all? m2 r)\n              m2\n              (recur (+ m m2))))))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [& args]\n  (let [ lcd (fn [a b] (loop [x a y b] (if (zero? y) x\n                (recur y (rem x y)))))\n        numb (map #(if (= (class %) clojure.lang.Ratio)\n                      (numerator %) %) args)\n        numb2 (map #(if (= (class %) clojure.lang.Ratio)\n                      (denominator %) %) args)]\n    (/ (reduce #(/ (* %1 %2) (lcd %1 %2)) 1 numb)\n    (reduce #(lcd %1 %2) (first numb2) (rest numb2)))))","problem":100,"user":"5065bd94e4b0148eb3925aed"},{"code":"(fn [ & xs]\n  (loop \n    [ms (vec (map (constantly 1) xs))]\n    (let [ dns (vec (map * xs ms)) ]\n      (println (type dns))\n      (if (apply = dns)\n        (first dns)\n        (let [ min-k\n                  (apply\n                    (partial min-key dns)\n                    (range (count dns))) ]\n          \n          (recur (update-in ms [min-k] inc)))))))","problem":100,"user":"502952c9e4b0b33e9bf6fdf1"},{"code":"(fn b-lcm [& nums]\n  (reduce (fn [a b]\n            (* a (/ b ((fn gcd [c d]\n              (if (= d 0) c\n                    (gcd d (mod c d)))) a b)))) (seq nums)))","problem":100,"user":"4eb955da535dfed6da9c6d50"},{"problem":100,"code":"(letfn [(abs [x] (if (neg? x) (- x) x))\n        (gcd [a b] (if (zero? b) a (recur b (mod a b))))\n        (lcm [a b] (/ (abs (* a b)) (gcd a b)))]\n  (fn [& vals] (reduce lcm vals)))","user":"54856d54e4b0e286459a11aa"},{"code":"(fn ! [& _1]\n  (let [_2 (sort _1)]\n    (loop [_3 (first _2)]\n      (if \n        (= _2 (filter #(= 0 (mod _3 %)) _2)) _3\n        (recur (+ _3 (first _2)))))))","problem":100,"user":"511ac026e4b0c87c59c9670e"},{"code":"#(reduce (fn [x y] \n  (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (/ (* x y) (gcd x y)))) %&)","problem":100,"user":"4f3cc2fbe4b0e243712b1f55"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (let [gcd (fn gcd [a b] (if (= b 0) \n                            a \n                            (gcd b (rem a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"550d9452e4b06e50f9beb15d"},{"problem":100,"code":"(fn lcm [hd & tl]\n  (letfn [(abs [x]\n            (if (< x 0) (- x) x))\n          (gcf [x y]\n            (let [[less more] (if (< x y) [x y] [y x])\n                  diff (abs (- x y))]\n              (if (= x y)\n                x\n                (gcf less diff))))\n          (lcm2 [x y]\n            (let [factor (gcf x y)\n                  x (/ x factor)\n                  y (/ y factor)]\n              (* x y factor)))]\n    (if (empty? tl)\n      hd\n      (lcm2 hd (apply lcm tl)))))","user":"53fb5256e4b0de5c4184857f"},{"problem":100,"code":"(fn kgv [& c]\r\n  (let [multiples (map #(iterate (partial + %) %) c)]\r\n    (loop [m multiples]\r\n      (if (apply = (map first m))\r\n        (first (first m))\r\n        (let [[a & r] (sort-by first m)]\r\n          (recur (conj r (next a))))))))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn lcm [a & b]\r\n  (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (rem a b))))\r\n        lcm-duo (fn [a b] (* (/ a (gcd a b)) b))]\r\n    (cond (empty? b) a\r\n          (empty? (rest b)) (lcm-duo a (first b))\r\n          :else (apply (partial lcm (lcm-duo a (first b))) \r\n                       (rest b)))))","problem":100,"user":"4fabbb97e4b081705acca21d"},{"code":"(fn [& args] (let [mult-seq (fn [n] (iterate (partial + n) n))]\n            (first (sort (into '() (apply clojure.set/intersection \n                                          (map #(set (take 500 (mult-seq %))) args) ))))\n            ))","problem":100,"user":"50cae881e4b0f75dcc9a6e51"},{"code":"(fn p100 [& ns]\n  (letfn [(gcd ([a b] (ffirst (drop-while (fn [[a b]] (not= 0 b))\n  \t\t\t\t  (iterate (fn [[a b]] [b (mod a b)]) [a b]))))\n\t       ([a b & more]\n\t\t  (reduce gcd (gcd a b) more)))\n\t  (lcd ([a b] (/ (* a b) (gcd a b)))\n\t       ([a b & more] (reduce lcd (lcd a b) more)))]\n    (apply lcd ns)))","problem":100,"user":"4e513ecf535dc968683fc4f6"},{"problem":100,"code":"(fn [& a]\n  (let [m (apply max a)]\n    (some\n     (fn [x] (if (apply = 0 (map #(rem x %) a)) x))\n     (iterate #(+ m %) m))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn [& [x & r]]\n(some \n (fn [n]\n  (if (every? #(= 0 (mod n %)) r) n))\n (iterate #(+ x %) x)))","problem":100,"user":"5055899de4b0ce54f56f03fd"},{"code":"(fn [ & args]\n  (letfn [(div [x y]\n\t\t\t\t\t  (if (= 0 (rem x y))\n\t\t\t\t\t    y\n\t\t\t\t\t    (div y (rem x y))\n\t\t\t\t\t    )\n\t\t\t\t\t  )\n          (comm [x y]\n             (* x (/ y (div x y)))\n          )]\n    \n    (reduce comm args)\n    \n    \n    )\n  )","problem":100,"user":"51bec919e4b013aa0d74b800"},{"problem":100,"code":"(fn lcm\n  ([x] x)\n  ([x y]\n   (letfn [(cmSeq [v b]\n                  (lazy-seq\n                   (cons v (cmSeq (+ v b) b))))]\n     (loop [xSeq (cmSeq x x)\n            ySeq (cmSeq y y)]\n       (cond\n        (= (first xSeq) (first ySeq)) (first ySeq)\n        (< (first xSeq) (first ySeq)) (recur (rest xSeq) ySeq)\n        :else (recur xSeq (rest ySeq))))))\n  ([x y & z]\n   (apply (partial lcm (lcm x y)) z) ))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn lcm [& nums]\n  (letfn [(divisible? [nums m]\n  \t      (every? #(= 0 (mod m %)) nums))]\n    (loop\n\t[incnums nums]\n;;      (println incnums (filter #(divisible? nums %) incnums))\n      (let [lcms (filter #(divisible? nums %) incnums)]\n\t(if-not (empty? lcms)\n\t  (apply min lcms)\n\t  (recur\n\t   (map + incnums nums)))))))","problem":100,"user":"504ec4d3e4b069badc5a33c9"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n    \t\t  (gcd b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)\n    ))","problem":100,"user":"50f0ec9ce4b0d527ce5b30df"},{"problem":100,"code":"(fn [& args]\n  (loop [m (apply max args) x m]\n    (if (every? #(= 0 %) (map #(mod x %) args)) x\n      (recur m (+ x m)))))","user":"54769c7ae4b0c51c1f4d72a8"},{"problem":100,"code":"(fn[x & y] \n    (apply\n    min \n    (into []\n    (apply\n     clojure.set/intersection \n     (into [] \n        (for [i  (conj y x)] \n         (set (map (partial * i) (next (range 400))))\n        )\n      )\n    ))))","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(gcd [a b]\n  \t\t \t(if (zero? b)\n\t\t\t    a\n\t\t\t    (recur b (mod a b))))\n  \t\t (lcm [a b]\n\t\t\t(/ (* a b) (gcd a b)))]\n    (reduce #(lcm %1 %2) (first nums) (rest nums))))","user":"505bd09fe4b032b709c81373"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (recur b (rem a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":100,"code":"(fn lcm \n ([a b]\n   (letfn [(gcd [a b]\n          (if (zero? b) a (gcd b (mod a b))))]\n     (/ (* a b) (gcd a b))))\n ([a b c & more] \n   (apply lcm (lcm a b) c more)))","user":"59f78b49e4b0ca45a743a30e"},{"code":"(fn [i & _] (case i 2 6 5 105 1/3 2 3/4 3/2 7 210))","problem":100,"user":"4ea5e32a535d7eef308072de"},{"problem":100,"code":"(fn [& nums]\n  (let [incnum (apply min nums)]\n    ((fn [x]\n       (if (every? #(= 0N (rem x %)) nums)\n         x\n         (recur (+ x incnum))))\n     incnum)))","user":"5705e404e4b0b0fb43fd0676"},{"problem":100,"code":"(fn lcm \n  ([a b]\n   (let [gcd (fn [a b] \n               (if (= 0 b)\n                 a\n                 (recur b (mod a b))))] \n     (* (/ a (gcd a b)) b)))\n  ([a b & more]\n   (reduce lcm (lcm a b) more)))","user":"5835cb06e4b089d5ab817cea"},{"code":"(fn [& x]\n  (\n    (fn f [y z]\n      (if\n        (= 1 (count (distinct y)))\n        (first y)\n        (f\n          (vec (concat\n            (take-while (fn [a] (> a (apply min-key #(+ %) y))) y)\n            [(+ (get y (count (take-while (fn [a] (> a (apply min-key #(+ %) y))) y))) (get z (count (take-while (fn [a] (> a (apply min-key #(+ %) y))) y))))]\n            (drop (inc (count (take-while (fn [a] (> a (apply min-key #(+ %) y))) y))) y)\n          ))\n          z\n        )\n      )\n    )\n    (vec x)\n    (vec x)\n  )\n)","problem":100,"user":"5017f840e4b02f523d7cc5e8"},{"code":"(fn lcm-iter [& args]\n  (letfn [(gcd [a, b]\n               (cond\n                (= b 0) a\n                :else (gcd b (rem a b))))\n          (abs [a]\n               (if (< a 0) (- 0 a) a))\n          (lcm [a, b]\n               (/ (abs (* a b)) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [& x]\n  (loop [l (map (fn [i] (map #(* i %) (iterate inc 1))) x)]\n    (let [h (map first l) m (reduce max h)]\n      (if (apply = h) \n        m\n        (recur (map (fn [s] (drop-while #(< % m) s)) l))))))","problem":100,"user":"4e7e05a6535db169f9c796fe"},{"problem":100,"code":"(fn [x & y]\n    (let [gcd (fn gcd [a b]\n                (cond (zero? b) a\n                      :else (recur b (rem a b))))]\n     (reduce #(/ (* %1 %2) (gcd %1 %2)) x y)))","user":"560e9a2de4b05f002753df52"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [args-it args]\n      (if (apply = args-it)\n        (first args-it)\n        (recur (map #(if (= (apply min args-it) %1)\n                       (+ %1 %2)\n                       %1)\n                    args-it\n                    args)))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":100,"code":"(fn [& args]\n  (loop [acc (into '[] args)]\n    (let [smallest-i (.indexOf acc (first (sort acc)))\n          inc-by ((into '[] args) smallest-i)]\n      (if (apply = acc)\n        (first acc)\n        (recur (assoc acc smallest-i (+ (acc smallest-i) inc-by)))))))","user":"5c718e6ce4b0fca0c1622796"},{"problem":100,"code":"(fn [& v](/ (apply * v) (reduce #(loop [a %1 b %2](if (= b 0) a (recur b (mod a b)))) v)))","user":"5686b7c7e4b0dcc4269f4057"},{"problem":100,"code":"(fn [n & z]\n  (loop [n1 n n2 z]\n    (if (nil? (first n2))\n      n1\n      (recur (\n        (fn [a b]\n         (/ (* a b) \n          (loop [x a y b]\n            (if (zero? y) \n              x\n              (recur y (mod x y))\n             )\n           )\n         )\n       )\n         n1 (first n2)) (rest n2))\n    )\n  )\n)","user":"51897709e4b0288ada3dbdaa"},{"problem":100,"code":"(fn ppcm [& args]\n  (let [pgcd\n        (fn [a b]\n          (loop [small (if (< a b) a b)\n                 big (if (> a b) a b)]\n            (if (= small 0)\n              big\n              (recur (mod big small) small))))]\n    (/ (apply * args) (reduce pgcd args))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":100,"code":"(fn [& s]\n  (loop [nums s]\n    (if\n      (apply = nums)\n      (first nums)\n      (let [m (apply min nums)]\n        (recur\n          (map\n            (fn [n orig] (if (= n m) (+ n orig) n))\n            nums\n            s))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn lcmany\n  ([a] a)\n  ([a & r]\n     (let [gcd2 (fn [a b] (if (= b 0) a (recur b (mod a b))))\n           lcm2 (fn [a b] (/ (* a b) (gcd2 a b)))]\n       (apply lcmany (cons (lcm2 a (first r)) (rest r)))\n     )))","problem":100,"user":"52ba43d0e4b07a9af57922cd"},{"code":"(fn [& args]\n   (let [gcd (loop [args args]\n               (if (= (count args) 1)\n                 (first args)\n                 (let [mn (apply min args)]\n                   (recur (conj (remove #(= 0 %)\n                                        (map #(rem % mn) args))\n                                mn)))))]\n     (min (reduce * gcd (map #(quot % gcd) args))\n          (reduce * (map #(if (= (type %) clojure.lang.Ratio)\n                       (numerator %)\n                       %) args)))))","problem":100,"user":"4eb02674535d7eef30807338"},{"problem":100,"code":"(fn __ [& r]\n  (if (empty? r) (empty r)\n    (let [n (count r),\n          l (range n)]\n      (loop [s (vec r)]\n        (if (apply = s) (first s)\n          (let [k (apply min-key #(nth s %) l)]\n            (recur (assoc s k (+ (nth s k) (nth r k))))))))))","user":"54c271b9e4b045293a27f602"},{"problem":100,"code":"(fn [& r] (reduce (fn [a b] (first (filter #(zero? (mod % b)) (iterate #(+ % a) a)))) r))","user":"56066e82e4b08b23635d3173"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd2 [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm2 [a b]\n            (/ (* a b) (gcd2 a b)))]\n    (reduce lcm2 args)\n    ))","user":"56a3c89ae4b0542e1f8d14cf"},{"code":"(fn lcd [x y & more](let [result (/ (* x y) (loop [a x b y] (if (zero? b) a (recur b (mod a b))))) z (first (flatten more)) more (rest (flatten more))] (if z (do (lcd result z more)) result)))","problem":100,"user":"5138d08be4b0a5db03d727db"},{"problem":100,"code":"(fn [& xs]\n  (loop [coll (map #(iterate (partial + %) %) xs)]\n    (if (apply = (map first coll))\n      (ffirst coll)\n      (let [m (apply max (map first coll))]\n        (recur (map #(drop-while (partial > m) %) coll))))))","user":"59074b7ce4b047aa04b19951"},{"code":"(fn [& nums]\n  (let [\n    gcd (fn [x y] (cond\n                    (zero? x) y\n                    (zero? y) x\n                    :else (recur y (mod x y))))\n    lcm (fn [x y] (/ (* x y) (gcd x y)))]\n    (reduce #(lcm % %2) nums)))","problem":100,"user":"4fdb02aae4b05e33b9224f56"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn f [x y] (if (= y 0) x (f y (mod x y))))\n        lcm (fn f [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm args) ))","user":"543d5c61e4b032a45b86934d"},{"problem":100,"code":"(fn [& args]\n  (reduce (fn lcm\n            ([x y] (lcm x y x y))\n            ([x y x_step y_step]\n             (cond (= x y) x\n                   (> x y) (lcm x (+ y y_step) x_step y_step)\n                   :else (lcm (+ x x_step) y x_step y_step))))\n          (first args) (rest args)))","user":"5c76577ae4b0fca0c16227ea"},{"problem":100,"code":"(fn lcm\n  ([x y] (/ (* x y) \n            ((fn gcd [x y] \n               (if (zero? y) \n                 x \n                 (recur y (mod x y)))) x y))) \n  ([x y & rest] (apply lcm (lcm x y) rest)))","user":"56c1e720e4b0839206b9d68b"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(factors [x] (loop [x x\n                             divisor 2\n                             acc []]\n                        (if (= 1 x)\n                          (frequencies acc)\n                          (if (zero? (rem x divisor))\n                            (recur (/ x divisor) divisor (conj acc divisor))\n                            (recur x (inc divisor) acc)))))\n          (prime-factors [x] (if (integer? x)\n                              (factors x)\n                              (merge-with +\n                                          (factors (numerator x)) \n                                          (->> (factors (denominator x))\n                                               (map (fn [[k v]] [k (- v)]))\n                                               (into {})))))\n          (pow [base exp] (if-let [xs (seq (repeat (Math/abs exp) base))]\n                           (let [result (reduce * xs)]\n                             (if (pos? exp)\n                               result\n                               (/ 1 result)))\n                           1))\n          (exhaustive-merge-with [f default & maps] (reduce (fn [m1 m2]\n                                                             (let [all-keys (-> (keys m1)\n                                                                                (into (keys m2))\n                                                                                set)]\n                                                               (->> (map (fn [k]\n                                                                           (let [v1 (get m1 k default)\n                                                                                 v2 (get m2 k default)]\n                                                                             [k (f v1 v2)]))\n                                                                         all-keys)\n                                                                    (into {}))))\n                                                     maps))]\n    (->> xs\n      (map prime-factors)\n      (apply exhaustive-merge-with max 0)\n      (reduce-kv (fn [result base exp]\n                   (* result (pow base exp)))\n                 1))))","user":"50ebd63ce4b04edc3377703c"},{"code":"(fn lcm ([a b]\n        (let [gcd (fn [a b]\n                    (if (= a b)\n                      a\n                      (let [m1 (min a b)\n                            m2 (max a b)]\n                        (recur m1 (- m2 m1)))))\n              abs (fn [x] (if (neg? x) (- x) x))]\n          (/ (abs (* a b)) (gcd a b))))\n    ([a b & args]\n       (apply lcm (cons (lcm a b) args))))","problem":100,"user":"4e50ad74535dc968683fc4ec"},{"problem":100,"code":"(fn \n  [& s] \n  (let [f (fn [a b] \n            (if (zero? b)\n              a\n              (recur b (rem a b))))\n        g (fn [a b] \n            (/ (* a b)\n               (f a b)))]\n    (reduce g s)))","user":"56a44067e4b0542e1f8d14da"},{"code":"(fn [& v] \n  (reduce\n    #(/ (* % %2) ((fn g [a b] (let [m (mod b a)] (if (pos? m) (g m a) a))) % %2))\n    v))","problem":100,"user":"4e707db6535d5021c1a8963a"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n        lcm (fn lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"57839ae9e4b0ebec4cfb74b8"},{"problem":100,"code":"(fn [& xs]\n  (let [x (apply max xs)]\n    (loop [n 2]\n      (let [r (* n x)]\n        (if (every? #(zero? (mod r %)) xs)\n          r\n          (recur (inc n)))))))","user":"56cf115de4b0ea9b8538f765"},{"problem":100,"code":"(fn [& args]\n  (apply min\n   (apply clojure.set/intersection\n    (map (fn [x]\n          (set\n           (take 10000\n            (iterate #(+ % x) x))))\n     args))))","user":"5a984616e4b0d174b936c789"},{"code":"(fn [& args]\r\n  (letfn \r\n    [(gcd [x y]\r\n       (if (zero? y) x (gcd y (mod x y))))\r\n     (lcm [a b]\r\n       (/ (* a b) (gcd a b)))]\r\n    (reduce lcm args)\r\n  )\r\n)","problem":100,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn [& xs]\n  (loop [seqs (map (fn [x] (iterate #(+ x %) x)) xs)]\n    (if (apply == (map first seqs))\n      (ffirst seqs)\n      (let [[s & ss] (sort-by first seqs)]\n        (recur (cons (rest s) ss))))))","problem":100,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn [& nums]\n  (let [gcd (fn [a b]\n             (cond\n              (= b 0) a\n              (= a 0) b\n              (> a b) (recur b (mod a b))\n              :else (recur a (mod b a))))]\n       (reduce (fn [a b] (* (/ a (gcd a b)) b)) nums)))","problem":100,"user":"4f05ea25535dcb61093f6c02"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [lcm-int (fn [ys](first (filter\n                     (fn [mult] (every? #(= 0 (rem mult %)) ys))\n                     (rest (range))\n                    )\n                   )\n                  )\n        get-greatest-denominator (fn [ys] (reduce max (map #(if (ratio? %)\n                                                          (denominator %)\n                                                          1\n                                                          ) \n                                                           ys))\n                               )\n        greatest-denom (get-greatest-denominator xs)\n        ]\n    \t\n          (->> xs\n               (map #(* % greatest-denom))\n               (lcm-int)\n               (#(/ % greatest-denom))\n               )\n          \n    )\n  )","user":"6004c750e4b074f607df6645"},{"problem":100,"code":"(fn [& xs]\n  (loop [xs' xs]\n\t(if (apply == xs')\n    \t(first xs')\n    \t(let [m (apply max xs')]\n      \t\t(recur (map (fn [a b] (if (< a m) (+ a b) a)) xs' xs))))))","user":"55597b84e4b0deb715856e36"},{"code":"(fn [& v] (reduce (fn [a b] (/ (* a b) \n  (#(if (= 0 %)\n   %2\n   (recur (mod %2 %) %)) a b) )) v))","problem":100,"user":"4f01c938535dcb61093f6a39"},{"code":"(fn [& nums] (letfn [(div [x] (set (keep #(when (= 0 (mod x %)) %) (range 1 (inc x)))))\r\n                       (gcd [a b] (apply max (clojure.set/intersection (div a) (div b))))\r\n                       (lcmi [a b] (/ (* a b) (gcd a b)))\r\n                       (num [x] (if (ratio? x) (numerator x) x))\r\n                       (den [x] (if (ratio? x) (denominator x) 1))\r\n                       (lcm [a b] (if (some ratio? [a b]) (/ (lcmi (num a) (num b)) (gcd (den a) (den b))) (lcmi a b)))]\r\n              (reduce lcm nums)))","problem":100,"user":"4fe900a6e4b0547ebccb243a"},{"problem":100,"code":"(fn [& l]\n  (first \n   (filter (fn [s] (every? zero?\n             (map #(rem s %) l))) \n           (iterate (partial + (first l)) (first l)))))","user":"54b95f3de4b0ed20f4ff6eab"},{"problem":100,"code":"(fn [& nums]\n  ((fn guess [cur]\n     (let [res (* cur (apply * nums))]\n       (if (zero? (count (remove true? (for [i nums] (if (zero? (rem res i)) true false))))) res\n         (guess (inc cur))))) 1))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn lcm [& nums]\n  (let [\n    gcd (fn f [a b]\n      (let [x (max a b)\n          y (min a b)]\n      (if (zero? y)\n        x\n        (f y (mod x y)))))\n    l (fn [a b]\n      (/ (* a b) (gcd a b)))]\n    (reduce #(l % %2) nums)))","problem":100,"user":"506617c3e4b03d366d7cb2ab"},{"code":"(fn [& x]\n  ((fn lcm [x i]\n    (println x i)\n    (if (every? #(= 0 (rem (* i (apply max x)) %)) x) \n      (* i (apply max x))\n      (lcm x (inc i))\n      )\n     )\n    x 1)\n  )","problem":100,"user":"523bc0e6e4b07becd5be21f9"},{"problem":100,"code":"(fn least-common-multiple [& args] (let [sorted-descending (reverse (apply sorted-set args))\n                                           biggest (first sorted-descending)\n                                           others (rest sorted-descending)\n                                           is-multiple? (fn [first second] (= (quot first second) (/ first second)))\n                                           ]\n                                       (loop [index 1]\n                                         (if (every? true? (map #(is-multiple? (* biggest index) %) others))\n                                             (* biggest index)\n                                             (recur (inc index))))))","user":"554bc64ae4b0a04f79299598"},{"problem":100,"code":"(fn lcm\n  ([a] a)\n  ([a b]        (let [gcm \n(fn gcm [a b]\n  (let [x (max a b)\n        y (min a b)]\n    (if (zero? y)\n      x\n      (recur y (mod x y)))))\n                      ] (lcm (/ (* a b) (gcm a b)))))\n  ([a b & more] (apply lcm (lcm a b) more)))","user":"53664e3be4b0243289761e74"},{"problem":100,"code":"(fn [n & args]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (lcd [a b] (/ (* a b) (gcd a b)))]\n    (reduce #(lcd %1 %2) n args)))","user":"59ddae03e4b01968742fed65"},{"problem":100,"code":"(fn [& numbers]\n  (loop [xs-map (zipmap numbers numbers)] ; keys are the increments\n    (let [[increment least] (reduce #(if (< (second %) (second %2)) % %2) xs-map)] ; get the least element\n      (if (apply = (vals xs-map))\n        least ; all second-elements are the same\n        (recur (assoc xs-map increment (+ least increment))))))) ; increment the least element","user":"5680104ae4b0966858e4d8ea"},{"problem":100,"code":"(fn\n  [& a]\n  (let \n    [m (apply min a)]\n    (loop \n      [i m]\n      (if\n        (= 0 (reduce + (map #(mod i %) a)))\n        i\n        (recur (+ i m))))))","user":"5b3de9a7e4b02d533a91bbf4"},{"problem":100,"code":"(fn my-lcm [& args]\n      (let [coll args\n             gcd (fn my-gcd [a b]\n                     ;Uses the Euclidean Algorithm\n                     (if (= a b)\n                       a\n                       (let [new_a (min a b)\n                             new_b (- (max a b) new_a)\n                             ]\n                         (my-gcd new_a new_b)\n                         )\n                       )\n                     )\n            total-gcd (reduce gcd coll)\n            lcm (/ (reduce * 1 coll) total-gcd)\n             ]\n        ;coll\n        ;total-gcd\n        lcm\n        )\n      )","user":"536827f1e4b0243289761e8a"},{"problem":100,"code":"(letfn [(gcd [a b]\n          (cond\n            (= a b) a\n            (> a b) (gcd b a)\n            :else (gcd a (- b a))))]\n  (fn [& nums]\n    (let [num-ints (count (filter integer? nums))\n          coeff (reduce * (map denominator (filter ratio? nums)))\n          nums (map #(* coeff %) nums)]\n      (/ (reduce * nums)\n         (reduce gcd nums)\n         (reduce * (take (inc num-ints) (repeat coeff)))))))","user":"5712854ce4b07c98581c3a89"},{"problem":100,"code":"(fn [& vs]\n  (loop [xs (sort (map vector vs vs))]\n    (let [[xmin & xrest] xs\n          vmin (first xmin)]\n      (if (every? #(= (first %) vmin) xrest)\n        vmin\n        (recur (sort (cons [(+ vmin (second xmin)) (second xmin)] xrest)))))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":100,"code":"(fn [& xs]\n  (let [multiples (fn [n] (iterate (partial + n) n))\n        mults (map multiples xs)]\n    (loop [mults mults]\n      (let [heads (map first mults)\n        least (apply min heads)]\n        (if (apply = heads)\n          (ffirst mults)\n          (recur (map #(drop (if (= least (first %)) 1 0) %) \n                      mults)))))))","user":"54dce62be4b024c67c0cf78b"},{"problem":100,"code":"(fn [& args]\n \t(let [\n          gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))\n          lcm (fn [x y] (/ (* x y)(gcd x y)))]\n      \t\t(reduce lcm args)\n      \n     )\n )","user":"5649615be4b0284900eef641"},{"code":"(letfn [(gcd [a b]\n  (if (zero? b)\n      a\n      (recur b (mod a b))))]\n  (fn [& xs]\n    (/ (reduce * xs)\n       (reduce gcd xs))))","problem":100,"user":"4e5d0e96535d8a8b8723a2c8"},{"code":"(fn lcm [& nums]\n  (loop [curnums nums]\n  (if (every? #(= % true) (map #(= % (first curnums)) curnums))\n      (first curnums)\n      (let [minnum (apply min curnums)\n            numnums (count curnums)\n            mindex (.indexOf curnums minnum)\n            toadd (nth nums mindex)\n            _ (println minnum numnums mindex toadd)\n            newnums (assoc (vec curnums) mindex (+ minnum toadd))\n            _ (println newnums)]\n        (recur newnums)))))","problem":100,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn least-common-multiple [a & args]\n  (if (or (= a 0) (seq (filter #(= 0 %) args)))\n    0\n    ((fn [t]\n       (if (reduce #(and %1 %2) (map #(= (mod t %) 0) args))\n         t\n         (recur (+ a t)))) a)))","problem":100,"user":"4ec75077535d6d7199dd36e0"},{"problem":100,"code":"(fn [& args]\n   (loop [vec-xm args\n          vec-x1 args]\n     (let [local-min (apply min vec-xm)]\n       (if (apply = vec-xm) (first vec-xm)\n                 (recur (map #(if (= %1 local-min) (+ %1 %2) %1) vec-xm vec-x1) vec-x1)))))","user":"5ce2b15fe4b0a17bb84e2b2c"},{"problem":100,"code":"(fn [& lst0]\n   (loop [lst (sort #(< (first %1) (first %2))\n                    (map (fn [n] (map #(* n %) (drop 1 (range))))\n                         lst0))]\n     (if (apply = (map first lst))\n       (first (first lst))\n       (recur (sort #(< (first %1) (first %2))\n                    (cons (rest (first lst))\n                          (rest lst)))))))","user":"5c62979fe4b0fca0c162264c"},{"problem":100,"code":";; based on https://www.youtube.com/watch?v=N3EpdYFZMQo\n\n(fn sol [& args]\n  (loop [i 1\n         ms (repeat (count args) #{})]\n    (let [inter (apply clojure.set/intersection ms)]\n      (if (> (count inter) 0)\n        (first inter)\n        (recur (inc i)\n               (map #(conj %1 %2)\n                    ms\n                    (map (partial * i) args)))))))","user":"5a084a24e4b01bb0ae8afdf2"},{"problem":100,"code":"(fn [& nums]\n   (/ (apply * nums) (reduce #(if (zero? %2) % (recur %2 (mod % %2))) nums)))","user":"5c48757fe4b0e06e1360a3c3"},{"code":"(fn [& args]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\n    (let [[x y & other] (flatten args)]\n      (if (not y) x\n          (recur (cons (/ (* x y) (gcd x y)) other))))))","problem":100,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn [& vs-in] (let [gcd (fn [a b]\n                       (if (= a b)\n                         a\n                         (if (> a b)\n                           (recur (- a b) b)\n                           (recur a (- b a))\n                         )\n                       )\n                     )\n                 lcm (fn [a b] (/ (* a b) (gcd a b)))\n                 ]\n             (loop [vs (next vs-in) result (first vs-in)]\n               (if (nil? vs) result\n                 (recur (next vs) (lcm result (first vs)))\n               )\n             ))\n)","problem":100,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn lcm [& xs]\n  (loop [ys (vec xs)]\n    (if (apply == ys)\n      (first ys)\n      (let [min-index (first (apply min-key second (map-indexed vector ys)))]\n        (recur (update-in ys [min-index] + (nth xs min-index)))))))","problem":100,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"problem":100,"code":"(fn lcm-2 [& args]\n  (apply min (apply clojure.set/intersection (map set (map (fn [n]\n                                                     (take 1000 (map (fn [m] (* n m)) (iterate inc 1))))\n                                                   args)))))","user":"58d48df8e4b03c36ff7e5941"},{"problem":100,"code":"(fn lcm\n  ([x] x)\n  ([x y]\n   (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n     (/ (* x y) (gcd x y))))\n  ([x y & xs] (reduce lcm (into [x y] xs))))","user":"55fbc657e4b0f488688e0666"},{"problem":100,"code":"(fn [& numbers]\n           (let [gcd (fn [x y] (loop [u x\n                                      w y]\n                                 (if (= w 0)\n                                   u\n                                   (recur w (mod u w)))))\n                 lcm (fn [x y] (/ (* x y) (gcd x y)))]\n             (reduce lcm numbers)))","user":"5e3975a3e4b01d43a70e8dd3"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [m n] (if (= n 0) m (recur n (rem m n))))]\n    (/ (reduce * xs) (reduce gcd xs)) ))","user":"564b495de4b0284900eef667"},{"code":"(fn lcm [& args]\n  (let [denom (apply max (map #(if (= (class %) clojure.lang.Ratio) (denominator %) 1) args))]\n    (loop [num 1]\n      (if\n        (every? #(zero? (rem (/ num denom) %)) args)\n          (/ num denom)\n          (recur (inc num))\n        ))))","problem":100,"user":"51b7b521e4b0d906fcd71d3a"},{"problem":100,"code":"(fn [& x] (reduce (fn [x y] (/ (* x y) ((fn [x y] (if (zero? y) x (recur y (mod x y)))) x y))) x))","user":"58e90258e4b056aecfd47cfd"},{"problem":100,"code":"(fn [& args] \n  (let [gcd (fn [a b] (if (zero? b) a \n             (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"57210e8ee4b0c5bde472c0a8"},{"problem":100,"code":"(fn [& n] (->> (map #(range % 250 %) n)\n                (map set)\n                (apply clojure.set/intersection)\n                (into [])\n                (apply min)))","user":"5c435a9fe4b0e06e1360a367"},{"problem":100,"code":"(fn lcm [& nums]\n  (letfn\n      ;; find common elements in finite lists\n      [(search-in-finite-lists [l & others]\n         (if (= 1 (count others))\n           ;; find some common element in the other list\n           (filter #(some #{%1} (first others)) l)\n           ;; find some common element in the first list and recurse with the rest\n           (filter #(and (some #{%1} (first others))\n                         (not (empty? (apply search-in-finite-lists (list %1) (rest others))))) l)))]\n    (let [multiples (map (fn [base] (iterate (fn [total] (+ total base)) base))\n                         nums)]\n      ;; find common multiples, and then take the least of these\n      (apply min (apply search-in-finite-lists (map #(take 400 %) multiples)))\n      )))","user":"5d64ecb2e4b0c9e5857d5036"},{"problem":100,"code":"(fn [& v]\n          (let [ gcd (fn  [a b]\n                       (if (zero? b)\n                         a\n                         (recur b, (mod a b))))\n                lcm  (fn [a b]\n                       (/ (* a b) (gcd a b))) \n                ]\n            (reduce lcm v)\n            )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn lcd [& l]\r\n    (loop [m (reduce min l) cur (reduce min l)]\r\n      (if (every? #(= 0 %) (map #(rem cur %) l))\r\n        cur\r\n        (recur m (+ cur m)))))","problem":100,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn lcm\r\n  ([x y]\r\n     (letfn [(gcd [lhs rhs]\r\n               (cond\r\n                (= lhs rhs) lhs\r\n                (< lhs rhs) (recur rhs lhs)\r\n                (= rhs 0) lhs\r\n                :else (recur (- lhs rhs) rhs)))]\r\n       (/ (* x y) (gcd x y))))\r\n  ([x y & ys]\r\n     (apply lcm (cons (lcm x y) ys))))","problem":100,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":100,"code":"(fn lcm [a b & cs]\n  (letfn [(gcd [x y]\n              (if (zero? y) x\n                (gcd y (mod x y))))]\n    (if (not (number? b))\n      a\n      (apply lcm (flatten (concat\n                            [(* (/ a (gcd a b)) b) (first cs)]\n                            (rest cs)))))))","user":"540e8d13e4b0addc1aec671e"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b, (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":100,"code":"(fn [& coll]\n  (let [m (apply max coll)\n        mults (iterate (partial + m) m)\n        all-div? (fn [multiple] (every? #(= 0 (mod multiple %))\n                                        coll))]\n    (first (drop-while (complement all-div?) mults))))","user":"5515b138e4b055c2f668d4ed"},{"code":"(fn lcd-ars [& ars]\n       (letfn [\n               (lcd-local [a b]\n                 (letfn [\n                         (gcd [a b]\n                           (if (= b 0)\n                             a\n                             (gcd b (rem a b))))\n                         (abs [a] (if (< a 0) (- a) a))]\n                   (/\n                    (abs (* a b))\n                    (gcd a b))\n                   )\n                 )\n\n               ]\n         (reduce lcd-local ars)\n         )\n       )","problem":100,"user":"51f81925e4b09be9c177e526"},{"problem":100,"code":"(fn lcm ([a b]\n     (let [gcd (fn [a b]\n                 (let [l (max a b)\n                       s (min a b)\n                       dif (- l s)]\n                   (if (= 0 dif)\n                     s\n                     (recur s dif))))]\n       (/ (* a b) (gcd a b))))\n  ([a b & args]\n   (apply lcm (lcm a b) args)))","user":"5ec6de19e4b08d0ec38692da"},{"problem":100,"code":"(fn s[& c]\n    (first (map \n                (fn[i]\n         \t           (first (filter\n                            (fn[i] (every? #(= 0 (mod i %)) c))\n                            (map #(* i %) (map inc (range)))))\n                  ) c))   \n    )","user":"52271ffee4b04e78ff2e19a9"},{"problem":100,"code":"(fn [& n] (let [gcd (fn gcf [a b] (if (zero? b)\n                                    a\n                                    (recur b (mod a b))))\n                mul (apply * n)]\n            (/ mul (reduce #(gcd %1 %2) n))))","user":"53a0ab8ce4b0ca733b9744b3"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b) a\n                (recur b (mod a b))))\n\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))\n\n          (lcm-all [& args]\n            (reduce lcm args))\n\n          (gcd-all [& args]\n            (reduce gcd args))]\n    (apply /\n           (map (fn [[lg nd]]\n                  (apply lg (map #(if (ratio? %) (nd %) %) args))) [[lcm-all numerator]\n                                                                    [gcd-all denominator]]))))","user":"51b76227e4b0d906fcd71d35"},{"problem":100,"code":"(fn lcm [& args]\n  (letfn [(gcd [x y]\n            (if (zero? y) x (recur y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","user":"541b1f25e4b01498b1a71a63"},{"problem":100,"code":"(fn [& x]\n  (let [xn (map #(if (ratio? %) (numerator %) %) x)\n        xd (map #(if (ratio? %) (denominator %) 1) x)\n        fgcd (fn gcd [x y]\n               (if (= x 0)\n                 y\n                 (if (< x y)\n                   (gcd (- y x) x)\n                   (gcd (- x y) y))))\n        gcdn (reduce fgcd xn)\n        gcdd (reduce fgcd xd)]\n    (reduce #(/ (* %1 %2) gcdn) (/ gcdn gcdd) xn)))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn lcm [x y & rest]\n  (letfn [\n          (gcd [x y]\n            (cond \n             (< x y) (gcd y x) ; x >= y\n             (= y 0) x\n             :else (recur y (mod x y))))\n          (lcm2 [x y]\n            (let [dx (if (ratio? x) (denominator x) 1)\n                  dy (if (ratio? y) (denominator y) 1)\n                  factor (* dx dy)\n                  x (* x factor)\n                  y (* y factor)]\n              (/ (* x y) (gcd x y) factor)))]\n    (if rest\n      (let [z (lcm2 x y)]\n        (apply lcm z rest))\n      (lcm2 x y))))","problem":100,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn [& args]\n  (letfn\n      [(gcd [a b]\n            (if (zero? b) a (recur b (mod a b))))\n       (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn x [& args] \n  (let [gcd (fn [a b]\n              (if (=  b 0)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"53513d28e4b084c2834f4ae3"},{"problem":100,"code":"(fn [& nums]\n  (let [my-gcd (fn my-gcd\n                 [a b]\n                 (let [rem (mod a b)]\n                   (if (zero? rem)\n                     b\n                     (my-gcd b rem))))\n        my-lcd (fn my-lcd\n                 [a b]\n                 (/ (* a b) (my-gcd a b)))]\n    (reduce my-lcd nums)))","user":"524a9556e4b05ef8e38e64b1"},{"problem":100,"code":"(fn [& nums]\n    (loop [ms (iterate #(+ % (first nums)) (first nums))]\n      (if (every? #(zero? (rem (first ms) %)) (rest nums))\n        (first ms)\n        (recur (next ms)))))","user":"5c3ec6dbe4b08cd430848e8a"},{"problem":100,"code":"(fn least-common-multiple [& args]\n        (letfn [(minimal-int [predicate] (first (filter predicate (iterate inc 1))))\n                (lcm [args] (minimal-int (fn [n] (every? #(= 0 (mod n %)) args))))\n                (gcd [a b]\n                  (if (= b 0) a\n                              (recur b (mod a b))))\n                (gcd-list [args] (reduce gcd args))]\n          (let [numerators (map #(if (ratio? %) (numerator %) %) args)\n                denominators (map #(if (ratio? %) (denominator %) 1) args)]\n            (/ (lcm numerators) (gcd-list denominators)))))","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn [& nums] (let [x (apply min nums)]\n               (loop [s x]\n                 (if (= 0 (apply + (map #(mod s % ) nums))) s\n                     (recur (+ s x))))))","problem":100,"user":"5300aa1de4b0d8b024fd3710"},{"code":"(fn lcm [& nums]\n  (letfn [\n       (gcd [m n]\n            (cond\n              (zero? m) n\n              (zero? n) m\n              :else (gcd n (rem m n))\n              ))   \n        (lcmm [x y] (/ (* x y) (gcd x y)))\n    ]\n    (reduce lcmm nums)\n  )\n  )","problem":100,"user":"4ecfa05c535d44c135fd68b9"},{"problem":100,"code":"(fn [& nums]\n  (let [lcd (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))]\n    (reduce (fn [a b] (* (/ a (lcd a b)) b)) nums)))","user":"5bc255b7e4b07a9b28b10029"},{"code":"(fn lcm [n & coll]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) n coll)))","problem":100,"user":"4ea55757535d7eef308072d3"},{"code":"(fn lcm [& nums]\n  (first (filter (fn [cand] (every? #(= (mod cand %) 0) nums)) (map #(* (apply min nums) (+ % 1)) (range)))))","problem":100,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":100,"code":"(fn lcm [& args]\n   (loop [i 1\n          multiples (repeat (count args) #{})]\n     (let [overlap (apply clojure.set/intersection multiples)]\n       (if (> (count overlap) 0)\n         (first overlap)\n         (recur (inc i) (map #(conj %1 %2) multiples (map #(* i %) args)))))\n     ))","user":"54a627bce4b09f271ff37c83"},{"code":"(fn [& args]\n  (some #(if (apply = %) (first %) nil)  \n        (iterate (fn [nums]\n                   (let [min-n (apply min nums)]\n                      (map-indexed \n                         (fn [i n] \n                           (if (= min-n n) (+ n (nth args i)) n))\n                         nums))) args)))","problem":100,"user":"53300924e4b019098a6f8b55"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b & args] (let [gcd_ab (if (zero? b) a (gcd b (mod a b)))]\n                              (if args\n                                (apply gcd gcd_ab args)\n                                gcd_ab)))\n          (lcm [c d & args] (let [lcm_cd (/ (* c d) (gcd c d))]\n                              (if args\n                                (apply lcm lcm_cd args)\n                                lcm_cd)))\n          (num' [x] (if (ratio? x) (numerator x) x))\n          (den' [x] (if (ratio? x) (denominator x) 1))\n          (gcd' [& args]\n            (let [nums (map num' args)\n                  dens (map den' args)]\n              (/ (apply gcd nums) (apply lcm dens))))]\n    (/ (apply * args) (apply gcd' args))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":100,"code":"(fn lcm [x1 & args]\n   (loop [n x1]\n     (if (every? zero? (map #(mod n %) args) )\n       n\n       (recur (+ x1 n)))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [& args]\n  (reduce (fn [a b]\n            (let [gcd (fn gcd [a b]\n                        (cond\n                          (> b a) (gcd b a)\n                          (zero? b) a\n                          :else (recur b (- a b))))]\n              (/ (* a b) (gcd a b)))) args))","problem":100,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":100,"code":"(fn lcm [& l]\n  (let [lcm (fn [a b]\n              (let [k (* (if (ratio? a) (denominator a) 1) (if (ratio? b) (denominator b) 1))\n                    a' (int (* a k))\n                    b' (int (* b k))\n                    gcd (fn [a b] (if (= 0 a) b (recur (mod b a) a)))]\n                (/ (* a' b') (gcd a' b') k)))]\n    (reduce lcm l)))","user":"567b39b6e4b05957ce8c61a3"},{"code":"(letfn [(gcd [a b & xs]\n          (if xs\n            (apply gcd (gcd a b) xs))\n            (if (zero? b) a (gcd b (mod a b))))\n        (abs [n] (if (< n 0) (- n) n))]\n  (fn lcm [a b & xs]\n    (if xs\n      (apply lcm (lcm a b) xs)\n      (/ (abs (* a b))\n         (gcd a b)))))","problem":100,"user":"4ec5a5f9535d6d7199dd36ad"},{"problem":100,"code":"(fn lcm [x & xs]\n  (letfn [(gcd [x y]\n               (cond\n                 (> y x) (gcd y x)\n                 (= y 0) x\n                 :else (gcd y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) x xs)))","user":"53dc94c8e4b094d41abdfefc"},{"code":"(fn lcm [& xs]\n    (letfn [(gcd [a b]\n                 (if (zero? b) a\n                               (recur b (mod a b))))]\n        (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","problem":100,"user":"532c9dc9e4b019098a6f8b30"},{"problem":100,"code":"(fn [& nums]\n  (loop [n (first nums)]\n    (if (= 0 (reduce + (map #(rem n %) nums))) n (recur (+ n (first nums))))))","user":"567695c2e4b05957ce8c6157"},{"problem":100,"code":"(fn [& x] (loop [y x]\n            (if (apply = y) (first y) \n                (recur (map #(if (= %1 (apply min y)) (+ %1 %2) %1) y x)))))","user":"57dafe97e4b0bd073c20241c"},{"code":"(fn lcm [x & xs]\n  (reduce #(let [r (/ %2 %)] \n             (* % (if (ratio? r) \n                    (long (numerator r))\n                    (long r)))) \n    x xs))","problem":100,"user":"50c781bbe4b00bb60fe0c535"},{"code":"#(letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n         (abs [n] (if (pos? n) n (- n)))]\n   (reduce (fn [a b]\n             (/ (abs (* a b)) (gcd a b)))\n           %&))","problem":100,"user":"4ea09fa4535d7eef308072aa"},{"code":"(fn [& args] (reduce\n(fn lcm \n      [aa bb]\n      (/ (* aa bb) ((fn gcd \n      [a b]\n      (if (zero? b)\n      a\n      (gcd b (mod a b)))) aa bb)\n ))\n              \n              args ))","problem":100,"user":"4dd579b5535dae65d5c462ea"},{"code":"(fn [& s]\n   ((fn lcm [sv]\n      (if (every? #(= (first %) (ffirst sv)) sv)\n         (ffirst sv)\n         (let [ssv (sort-by first sv) least (ffirst ssv)]\n           (lcm (map #(vector (if (= least (first %)) (+ (first %) (second %)) (first %)) (second %)) ssv)))))\n     (map #(vector % %) s)))","problem":100,"user":"4dbdc898535d020aff1edf4a"},{"problem":100,"code":"(fn lcm [& args]\n    (loop [i 1\n           multiples (repeat (count args) #{})]\n      (let [overlap (apply clojure.set/intersection multiples)]\n        (if (> (count overlap) 0)\n          (first overlap)\n          (recur (inc i) (map #(conj %1 %2) multiples (map (partial * i) args)))))))","user":"550c55d0e4b06e50f9beb14d"},{"problem":100,"code":"(fn [& args] (second (sort (reduce clojure.set/intersection (map #(set (take 500 (iterate (partial + %) 0))) args)))))","user":"53d5a63be4b0e771c3025449"},{"problem":100,"code":"(fn [& xs] \n  (reduce  \n  (fn [x y]\n     (/ (* x y)\n     ((fn [a b] \n       (let [r (mod a b)] \n        (if (= r 0)\n          b\n        (recur b r)))) x y))) xs ))","user":"55c2b95de4b0e31453f64980"},{"code":"(fn lcm [& xs]\n  (first\n    (for [n (range (java.math.BigDecimal. (Math/ceil (apply max xs))) 300 0.5M)\n          :when (every? #(zero? (mod n %)) xs)]\n      (double n))))","problem":100,"user":"4dafa380edd6309eace4d17c"},{"problem":100,"code":"(fn lcm [& values]\n  (let [inc-value (apply * values)]\n  (loop [common-divisor inc-value]\n    (if (every? #(integer? (/ common-divisor %)) values)\n    common-divisor\n      (recur (+ inc-value common-divisor))))))","user":"52c1cc8be4b07a9af579236b"},{"code":"(fn [& col]\n   (reduce (fn [a b]\n             (/ (* a b)  ((fn [x y]\n                              (loop [a (max x y) b (min x y )]\n    ( if (= b 0)\n        a\n        (recur b (mod  a b ) )\n  )\n)\n                            )   a b) )\n             )  col)\n)","problem":100,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn [x & more]\n  (let [gcd (fn [a b]\n              (let [[x y] (if (> a b) [a b] [b a])]\n                (if (= 0 b) a\n                    (recur b (mod a b)))))\n        nums (cons x more)\n        llcm (fn [a b]\n               (/ (* a b) (gcd a b)))]\n    \n    (reduce llcm x more)))","problem":100,"user":"4f343e60e4b0e243712b1eb5"},{"problem":100,"code":"(fn [& args]\n\t(let [gcd (reduce (fn [a b] (if (zero? a) b (recur (mod b a) a))) args)]\n\t\t(if (integer? gcd) \n\t\t\t(reduce * gcd (map #(/ % gcd) args))\n\t\t\t(/ (reduce * args) gcd)\n\t\t)\n\t)\n)","user":"5d2201b8e4b02ea6f0fb69ed"},{"code":"(fn mylcm [& L]\r\n(letfn [\r\n  (myabs [x] (if (pos? x) x (- x)))\r\n\t(gcd [x y]\r\n\t\t(loop [a (min x y), b (max x y)]\r\n\t\t\t(if (zero? a) \r\n\t\t\t\tb\r\n\t\t\t\t(recur (min a (- b a)) (max a (- b a)))\r\n\t\t\t)))\r\n\t\t\t\r\n\t(lcm [x y] (* (/ (myabs x) (gcd x y)) (myabs y)))\r\n\t]\r\n\t(reduce lcm L)\r\n)\r\n)","problem":100,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"(fn [f & more]\n    (loop [m f\n           x f\n           l more]\n      (if (nil? (first l))\n        (/ m x)\n        (recur (* m (first l))\n               ((fn gcd [x y]\n                 (if (> x y)\n                   (if (= (rem x y) 0)\n                     y\n                     (gcd y (rem x y)))\n                   (gcd y x))) x (first l))\n                (rest l))))\n    )","problem":100,"user":"517e12e3e4b0fcc7c5d37d3c"},{"problem":100,"code":"(fn f \n  (\n   [a b]\n  (let [gcd\n(fn gcd [a b] \n  (if (< a b) \n    (gcd b a) \n    (if (= b 0) a (gcd b (mod a b)))))        \n        ]\n  (/ (* a b) (gcd a b))))\n  ([a b c] (f (f a b) c))\n  ([a b c d] (f (f a b) c d))\n   )","user":"5799ff45e4b05b1deef9add1"},{"problem":100,"code":"(fn [& args]\n  (let [[x y & tail] args\n        z (if (empty? tail) (min x y) (first tail))\n        w (if (empty? (rest tail)) (min x y z) (last tail))\n        mx (max x y z w)]\n    (loop [i 1\n           res mx]\n      (if (= 0 (reduce #(+ %1 (mod res %2)) 0 [x y z w]))\n        res\n        (recur (inc i) (* i mx))))))","user":"51a7bf26e4b0da5f497bde8c"},{"code":"(fn [& xs]\n  (loop [rv 1]\n    (if (every? #(zero? (mod rv %1)) xs)\n      rv\n      (recur (+ rv 1/2)))))","problem":100,"user":"4dc0ff08535d020aff1edf84"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [big small] (if (zero? small) big (gcd small (mod big small))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    )\n  )","user":"55fe7e15e4b00f4cabc57651"},{"code":"(fn [& n]\n(reduce \n  (fn [a b]( some #(if (= 0 (mod % a)) %) \n     (iterate #(+ b %) b))) n))","problem":100,"user":"4daa374930acd6ed13482a68"},{"code":"(fn [& numz]\n    (let [numerators (for [n numz]\n                       (if (ratio? n) (numerator n) n))\n          denominators (for [n numz]\n                       (if (ratio? n) (denominator n) 1))\n          gcd (fn [& ns]\n                (let [m (apply min ns)\n                      divides #(= 0 (mod %2 %1))\n                      divisors (filter #(every? (fn [x] (divides % x)) ns) (range m 0 -1))]\n                  (first divisors)))\n          lcm (fn [& nz]\n                (let [product (apply * nz)\n                      multiple #(= 0 (mod %1 %2))\n                      common-multiples (filter #(every? (fn [x] (multiple % x)) nz) (range 1 (inc product)))]\n                  (first common-multiples)))]\n      (/ (apply lcm numerators) (apply gcd denominators)))\n  )","problem":100,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn [x & y]\n  (loop [a x]\n    (if (every? #(= 0 (mod a %)) y)\n      a\n      (recur (+ a x)))))","problem":100,"user":"53034738e4b0d8b024fd373e"},{"code":"(fn [& z] (letfn [(gcd [x y]\n    (cond\n         (= x y) x\n         (> x y) (recur (- x y) y)\n         :else (recur x (- y x))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) z)))","problem":100,"user":"4ea7999e535d7eef308072ee"},{"code":"(fn [& l]\n  (let [gcd\n        (fn [a b]\n          (let [r (rem a b)]\n            (if (= 0 r) b\n              (recur b r))))]\n    (/ (apply * l) (reduce gcd l))))","problem":100,"user":"51284226e4b03a34742b4308"},{"problem":100,"code":"(fn [& args]\n   (let [m (apply max args)]\n     (loop [lcm m]\n       (if (every? zero? (map (partial rem lcm) args))\n         lcm\n         (recur (+ lcm m))))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":100,"code":"(fn [& xs]\r\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\r\n    (reduce (fn [acc a] (/ (* acc a) (gcd acc a))) xs)))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":100,"code":"(fn [& args] (reduce \n              (fn [x y]\n                (letfn [(gcd [a b] (let [maxv (max a b)\n\t\t\t\t                         minv (min a b)\n\t\t\t\t\t\t\t\t\t\t modv (mod maxv minv)]\n\t\t\t\t\t\t\t\t\t (if (= 0 modv) minv (gcd minv modv))))]\n                  (let [prod (* x y)\n                        abs (if (> 0 prod) (* prod -1) prod)\n                        gdiv (gcd x y)]\n                    (/ abs gdiv))))\n\t\t\t\t\targs))","user":"57b356c2e4b0fbc9809a277b"},{"problem":100,"code":"(fn [ & L]\n  (reduce (fn [r x] (/ (* r x) \n                       ((fn [a b] \n                            (if (zero? b) a\n                              (recur b (mod a b)))) r x))) L))","user":"5a409d77e4b0447ef91cc5d3"},{"code":"(fn lcm\n  ([n] n)\n  ([x y]\n     (letfn [(multiples [n]\n               (iterate #(+ % n) n))]\n       (loop [xs (multiples x)\n              ys (multiples y)]\n         (cond\n          (= (first xs)\n             (first ys)) (first xs)\n             (> (first xs)\n                (first ys)) (recur xs (rest ys))\n                :else (recur (rest xs) ys)))))\n  ([x y & args]\n     (apply lcm (cons (lcm x y) args))))","problem":100,"user":"4fd16778e4b04c3a95aa040f"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n            (loop [a a b b]\n              (if (zero? b)\n                a\n                (recur b (mod a b)))))\n          (lcm' [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm' xs)))","user":"53968a70e4b0b51d73faaee0"},{"code":"(fn lcm\n  ([a b]\n    (letfn [\n    (gcd\n      ([a b] (loop [x a y b]\n          (if (zero? (mod x y))\n            y\n            (recur y (mod x y)))))\n      ([a b & c] (reduce gcd (gcd a b) c)))]\n  (/ (* a b) (gcd a b))))\n  ([a b & c] (reduce lcm (lcm a b) c)))","problem":100,"user":"50645e12e4b007509339a58a"},{"problem":100,"code":"(fn lcm [x y & xs]\n  (loop [ret x]\n    (if (= (mod ret y) 0)\n      (if (= (count xs) 0)\n        ret\n        (apply lcm ret xs))\n      (recur (+ ret x)))))","user":"55f73078e4b06e875b46cea4"},{"problem":100,"code":"(fn [& xs]\n (let [max_val 500]\n   (apply min\n          (apply clojure.set/intersection\n            (map #(set (range % max_val %)) xs)))))","user":"5573ffb5e4b0aa18f790f3fd"},{"problem":100,"code":"(fn [& xs]\n  (let [do-map (fn [x] {:base x :val x})\n        maps (map do-map xs)\n        add-base (fn [m] {:base (:base m) :val (+ (:val m) (:base m))})]\n    (loop [maps (sort-by :val maps)]\n      (if (apply = (map :val maps))\n        (:val (first maps))\n        (recur (sort-by :val (conj (rest maps) (add-base (first maps)))))))))","user":"574e84e0e4b02ea114799243"},{"problem":100,"code":"(fn [& rst] \n  (apply min \n   (apply clojure.set/intersection (map (fn [y] \n                                          (into #{} (take 1000 y))) \n                                        (map (fn [x] \n                                               (reductions + (cycle [x]))) \n                                             rst)))))","user":"4fc77f5ae4b0ee37620e1821"},{"code":"(fn [& xs]\n  (let [gcd (fn [x y]\n              (if (= y 0) \n                x\n                (recur y (rem x y))))\n        lcm (fn [x y]\n              (/ (* x y) (gcd x y)))]\n    (reduce lcm xs)))","problem":100,"user":"5117c31ee4b0e0897831a60c"},{"code":"(fn lcm [x1 x2 & xs]\n  (letfn [\n    (lcm2 [a b]\n      (if (< a b) (lcm2 b a))\n        (first\n          (filter\n            #(== 0 (rem % b))\n            (iterate #(+ a %) a))))]\n    (if (empty? xs) (lcm2 x1 x2)\n      (apply lcm (cons (lcm2 x1 x2) xs)))))","problem":100,"user":"4f569218e4b0a7574ea71826"},{"problem":100,"code":"#(let [denominatorr (fn [x] (denominator (clojure.lang.Numbers/toRatio (rationalize x))))\ndenoms (map denominatorr %&)\ndenom-mult (reduce * 1 denoms)\nfractions (map (fn [x] (/ x denom-mult)) (iterate inc 1))\nvalid (fn [x] (every? identity (map (fn [y](integer? (/ x y))) %&)))\n]\n(first (filter valid fractions))\n)","user":"5e13a6b7e4b099d064963001"},{"problem":100,"code":"(fn \n   [x1 & xn] \n   (first (drop-while \n      (fn [s] \n         (not-every? #(zero? (mod s %)) xn))\n      (iterate (partial + x1) x1)))\n   )","user":"5412646de4b01498b1a719d4"},{"problem":100,"code":"(fn foo [& nums]\n  (let [lcm (fn [nums]\n              (let [prod (reduce * nums)]\n               (loop [n prod acc prod]\n                 (cond\n                  (zero? n) acc\n                  (every? integer? (map #(/ n %) nums)) (recur (dec n) n)\n                  :else (recur (dec n) acc)))))]\n    (if (not-any? ratio? nums)\n      (lcm nums)\n      (let [ratios (filter ratio? nums)\n            integers (filter integer? nums)\n            lcm-of-denominators (lcm (map #(denominator %) ratios))\n            new-numerators (map #(*' (numerator %) (/ lcm-of-denominators (denominator %))) ratios)\n            lcm-of-numerators (lcm (into new-numerators (map #(* % lcm-of-denominators) integers)))]\n        (/ lcm-of-numerators lcm-of-denominators)))))","user":"4fdb881ee4b05e33b9224f5e"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","user":"506ba58be4b0eda3100c090b"},{"problem":100,"code":"(fn test [a b & args]\n  (if (> a b)\n    (apply test b a args)\n    (let [result (/ (* a b) ((fn gcd [x y] (if (= y 0) x (gcd y (mod x y)))) a b))]\n      (if (not (nil? args))\n        (apply test result args)\n        result\n        ))\n  )\n )","user":"54021f13e4b0df28a13c62cc"},{"code":"(fn lcm [& numbers]\n  (reduce (let [gcd (fn gcd [x y]\n                      (if (= 0 x)\n                        y\n                        (gcd (rem y x) x)))]\n            #(/ (* %1 %2) (gcd %1 %2)))\n          numbers))","problem":100,"user":"510cd1dde4b078ea71921124"},{"problem":100,"code":"(fn [& nums]\n\t(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b)) ) )]\n\t\t(reduce (fn [a b] (/ (* a b) (gcd a b))) nums)))","user":"5472d919e4b094393f72dd7b"},{"code":"(fn [& args]\n  (reduce\n    (fn lcm [a b]\n      (letfn [(gcd [a b]\n                (cond (> a b) (gcd b a)\n                (= a 0) b\n                :else (gcd (rem b a) a)))]\n        (/ (* a b) (gcd a b))))\n    args))","problem":100,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":100,"code":"#(reduce (fn lcm [a b]\n           (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n             (/ (* a b) (gcd a b))))\n         %&)","user":"55dcb06ee4b050e68259b3b9"},{"problem":100,"code":"(fn [& values]\n    (reduce (fn [m n]\n              (let [the-gcd (fn gcd [x y]\n                              (let [a (max x y)\n                                    b (min x y)]\n                                (if (= 0 (rem a b)) \n                                      b\n                                      (gcd b (rem a b)))))]\n              (/ (* m n) (the-gcd m n)))) \n            values))","user":"546692aee4b01be26fd746e7"},{"problem":100,"code":"(fn [& nums]\n  (letfn [(multiples\n            [num]\n            (iterate #(+ num %) num))\n          (interset\n            [how-many nis]\n            (apply clojure.set/intersection\n                   (map\n                    (comp set #(take how-many (multiples %)))\n                    nis)))]\n    (loop [amt 10]\n      (let [i (interset amt nums)]\n        (if-not (empty? i)\n          (apply min i)\n          (recur (+ amt 40)))))))","user":"563f4c47e4b08d4f616f5ed2"},{"code":"(fn [& args]\n  (loop\n    [start args\n     current start]\n    (if (apply = current)\n      (first current)\n      (recur\n        start\n        (map\n          #(if (= %2 (apply min current))\n            (+ %1 %2)\n            %2)\n          start\n          current)))))","problem":100,"user":"4f7f9665e4b033992c121bea"},{"problem":100,"code":"(fn [& args]\n(letfn [(gcd [x y]\n(let [a (max x y)\nb (min x y)\nm (mod a b)]\n(if (zero? m)\nb\n(recur b m))))\n(lcm [a b]\n(/ (* a b) (gcd a b)))]\n(reduce lcm args)\n))","user":"4ff4bed0e4b0678c553fc35f"},{"problem":100,"code":"(fn [& n]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm n)))","user":"57a88e24e4b0a9660795621f"},{"code":"(fn [a & aa]\n  (first (filter (fn [n] (reduce #(and %1 (not (ratio? (/ n %2)))) true aa)) (iterate (partial + a) a))))","problem":100,"user":"53712c03e4b0fc7073fd6ea9"},{"problem":100,"code":"(fn [& args]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))\n        lcm (fn [x y] (/ (* x y) (gcd x y)))]\n    (reduce lcm args)))","user":"5541fa50e4b0a04f79299515"},{"problem":100,"code":"(fn lcm2 \n  [x & xs] (let [\n              gcd (fn gcd [x y] (if (> y x) (gcd y x) (if (= y 0) x (gcd y (rem x y)))))\n              lcm2 (fn [x y] (/ (* x y) (gcd x y)))\n              ] (reduce lcm2 x xs))\n )","user":"571aad45e4b07c98581c3b59"},{"problem":100,"code":"(fn lcm\n  ([a b]\n    (letfn [(gcd [x y]\n            (if (= y 0) x\n              (gcd y (mod x y))))]\n      (/ (* a b) (gcd a b))))\n  ([a b & xc]\n   (apply lcm (lcm a b) xc)))","user":"53e9dce1e4b036ad0777e4bc"},{"code":"(fn lcm [& nums] \n  ((fn lcmm [i n] \n    \n    (if (= 0 (reduce + (map #(rem (* i (first n)) %) n))) \n(* i (first n)) \n(lcmm (inc i) n))) 1 (seq nums)))","problem":100,"user":"4e6e6630535d5021c1a89609"},{"problem":100,"code":"(fn l [a & [b & r]]\n   (if-not b\n     a\n     (let [s (fn [i] (iterate #(+ % i) i))]\n       (apply l ((fn z [[v & g :as i]\n                       [w & h :as j]]\n                   (cond\n                     (< v w) (z g j)\n                     (> v w) (z h i)\n                     1 v)) (s a) (s b)) r))))","user":"588fbb39e4b00487982d51bd"},{"problem":100,"code":"(fn [& xs] \n  (let [step (apply min xs)] \n    (loop [try step] \n      (if (every? #(= 0 (mod try %)) xs) \n        try \n        (recur (+ try step))))))","user":"5578f292e4b05c286339e08f"},{"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b]\n            (cond\n             (= a b) a\n             (> a b) (recur (- a b) b)\n             :else (recur a (- b a))))\n          (kk [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce kk xs)))","problem":100,"user":"4dd62278535d2dad7130b5c7"},{"problem":100,"code":"(fn [& data]\n  (letfn\n    [(gcd \n      [a b]\n      (if (zero? b)\n      a\n      (recur b, (mod a b))))\n     (lcm \n      [a b]\n      (/ (* a b) (gcd a b)))]\n    (reduce lcm data)))","user":"5da760ebe4b000c986472c1a"},{"problem":100,"code":"(fn [& ds]\n   (reduce\n    (fn [a b]\n      (/ (* a b)\n         (loop [a a\n                b b]\n           (if (zero? b)\n             a\n             (recur b (mod a b))))))\n    ds))","user":"54be7c0de4b0ed20f4ff6eec"},{"problem":100,"code":"(fn [& n](first (filter (fn [v] (every? integer? (map #(/ v %) n)))(map #(* (apply min n) %) (next (range))))))","user":"505106fee4b05ab4c7e07d38"},{"problem":100,"code":"(fn [& args]\n  (let [biggest (apply max args)\n        candidates (iterate #(+ % biggest) biggest)]\n    (first\n     (filter (fn [mult]\n               (every? zero? (map #(mod mult %) args)))\n             candidates))))","user":"4fe899a6e4b07c9f6fd12c54"},{"code":"(fn [& s]\n  (reduce \n (fn [x y]\n  (let [gcd (fn [x y]\n  (if (zero? y)\n    x\n    (recur y (rem x y))))]\n    (/ (* x y ) (gcd x y))))\n   s))","problem":100,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn [& nums] \n\t(loop [v (vec nums)]\n\t\t(if (apply = v)\n\t\t\t(first v)\n\t\t\t(let [\n\t\t\t\t\tsmallest (apply min v)\n\t\t\t\t\tsmallest-idx (.indexOf v smallest)\n\t\t\t\t\tincr (nth nums smallest-idx)\n\t\t\t\t\tnext-v (update-in v [smallest-idx] (partial + incr))\n\t\t\t\t\t]\n\t\t\t\t(recur next-v)\n\t\t\t)\n\t\t)\n\t)\n)","problem":100,"user":"51ba4482e4b0fe3ecfb4642b"},{"problem":100,"code":"(fn lcm [& nums]\n   (->>\n    (iterate (fn [m]\n               (let [[i v]\n                     (reduce-kv (fn [[origk mmin] k v]\n                                  (if (> mmin v) [k v] [origk mmin])) (first m) m)]\n                (update-in m [i] #(+ i %))))\n             (reduce #(assoc %1 %2 %2) {} nums))\n    (drop-while #(apply not= (vals %)))\n    ffirst\n    second))","user":"5935b010e4b04f87174def55"},{"problem":100,"code":"(fn [& xs]\n  (letfn [(lcm [a b] \n               (let [as (iterate (partial + a) a)\n                     bs (iterate (partial + b) b)\n                     ras (reductions conj #{} as)\n                     rbs (reductions conj #{} bs)\n                     tuples (map vector as bs ras rbs)]\n                 (first (for [[a b ra rb] tuples\n                              :when (or (ra b) (rb a))]\n                          (if (ra b)\n                            b\n                            a)))))]\n    (reduce lcm xs)))","user":"4ea03f70535d7eef308072a1"},{"code":"(fn [a b & n]\n      (letfn [(multipl [n]  (rest (map (partial * n) (range))))]\n\t\t   (let [minim (min a b) all (concat [a b] n) mults (multipl minim)]\n\t\t    \t(some #(when (apply = 0 (map (partial mod %) all)) %) mults ))))","problem":100,"user":"4e739e13535dff18050a9c76"},{"code":"(fn [& denoms]\n  (loop [m (apply max denoms)]\n    (if (empty? (filter #(not= (mod m %) 0) denoms))\n      m\n      (recur (+ m (apply max denoms))))))","problem":100,"user":"4ec53f8c535d6d7199dd368b"},{"problem":100,"code":"(fn\n  [& n]\n  (reduce (fn\n  [a b]\n  (/ (* a b) ((fn\n  [a b]\n  (if (zero? b)\n  \ta\n    (recur b, (mod a b)))) a b))) n))","user":"56df6498e4b0ca2494a095f8"},{"problem":100,"code":"(fn lcm\n  ([a] a)\n  ([a b & other] (apply lcm (+ a (last (take-while #(not= 0 (mod % b)) (map * (repeat a) (map inc (range)))))) other)))","user":"5eb4927fe4b00a66d4a95221"},{"code":"(fn f100\n  ([a b]\n       (letfn [(fn66 [a b]\n              \"greatest common divisor\"\n              (if (zero? a)\n                b\n                (loop [a a b b]\n                  (if (not= 0 b)\n                    (if (> a b)\n                      (recur (- a b) b)\n                      (recur a (- b a)))\n                    a))))]\n         (/ (* a b) (fn66 a b))))\n    ([a b & xs] (apply f100 (f100 a b) xs)))","problem":100,"user":"4e88feef535d8b9bb0147ca8"},{"problem":100,"code":"(fn least-common-multiple [a & args]\n  (reduce (fn [acc next-value] \n            (->> acc\n                 (iterate (partial + acc))\n                 (filter #(= 0 (mod % next-value)))\n                 first))\n          a args))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n            (let [x (max a b)\n                  y (min a b)]\n              (if (= x y)\n                x\n                (gcd (- x y) y))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm xs)))","problem":100,"user":"5164867fe4b003cf19fdde3e"},{"code":"(fn lcm [& args]\n  (letfn [\n    (gcd [a b] \n      (if (< a b) (recur b a)\n        (if (zero? b) a (recur b (mod a b)) ))) ]\n     (reduce #( / ( * % %2) (gcd % %2) ) args  )))","problem":100,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"(fn [a & xs]\r\n  (let [lll (fn [n] (map #(* n %) (iterate inc 1)))\r\n        bbb? (fn [b a] (= (first (filter #(<= a %) (lll b))) a))]\r\n    (first (filter (fn [q] (every? #(bbb? % q) xs)) (lll a)))))","problem":100,"user":"4fab31a8e4b081705acca215"},{"problem":100,"code":"(fn [& v] (reduce (fn [a b] (/ (* a b) ((fn [a b] (if (zero? b) a (recur b, (mod a b)))) a b))) v))","user":"5a09f205e4b0eab8c0448933"},{"problem":100,"code":"(fn\n   [& xs]\n   (letfn\n     [(lcm\n        [a b]\n        (loop\n          [x (min (if (ratio? a) (numerator a) a) (if (ratio? b) (numerator b) b)) y (max (if (ratio? a) (numerator a) a) (if (ratio? b) (numerator b) b)) m (mod y x)]\n          (if (zero? (rem y x)) (* x (if (ratio? a) (numerator a) a) (if (ratio? b) (numerator b) b)) (recur (rem y x) x (mod y x)))))\n      (gcd \n        [a b]\n        (loop\n          [x (min (if (ratio? a) (denominator a) 1) (if (ratio? b) (denominator b) 1)) y (max (if (ratio? a) (denominator a) 1) (if (ratio? b) (denominator b) 1)) m (mod y x)] \n          (if (zero? (rem y x)) x (recur (rem y x) x (mod y x)))))]\n     (/ (reduce lcm xs) (reduce gcd xs)) ))","user":"5ce62d8ee4b0a17bb84e2b83"},{"code":"(fn [& args]\n  (letfn [\n    (gcd [x y]\n      (let [a (max x y) b (min x y) m (mod a b)]\n        (if (zero? m)\n          b\n          (recur b m)))) \n    (lcm [x y] \n      (* (/ x (gcd x y)) y))] \n    (reduce lcm args)))","problem":100,"user":"5131d817e4b06942423563ca"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [c (apply max args) max c]\n    (if (every? #(zero? (mod c %)) args) c (recur (+ c max) max))))","user":"56a01895e4b0542e1f8d149f"},{"problem":100,"code":"(fn lcm [a b & args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (lcm'\n            ([a b] (/ (* a b) (gcd a b)))\n            ([a b & args] (reduce lcm' a (cons b args))))]\n    (apply lcm' a b args)))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [& x]\n    (let [f #(loop [q % r %2] (if (= 0 r) q (recur r (mod q r)) ) ) ]\n    \n    (/ (apply * x) (reduce f (vec x)) )\n    \n    )\n)","problem":100,"user":"52fba50ce4b047fd5583700d"},{"code":"(fn lcm [& args]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))]\n    (reduce #(/ (* % %2) (gcd % %2)) args)))","problem":100,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":100,"code":"(fn [& nums]\n  (let [max-common-div (fn [a b]\n                         (if (= 0 b)\n                           a\n                           (recur b (mod a b))))\n        lest-common-mul (fn [a b]\n                          (/ (* a b) (max-common-div a b)))]\n    (reduce lest-common-mul nums)))","user":"5cf895efe4b0b71b1d808a85"},{"problem":100,"code":"(fn lcm [a b & xs]\n   (loop [a1 a b1 b]\n     (if (= b1 0)\n       (if (empty? xs)\n         (/ (* a b) a1)\n         (apply lcm (/ (* a b) a1) xs))\n       (recur b1 (rem a1 b1)))))","user":"588906a9e4b0f1effa3b772a"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [multiple? (fn [x xs] (every? #(= 0 (rem x %)) xs))]\n    (->> (map inc (range))\n         (map #(* (first xs) %))\n         (filter #(multiple? % (rest xs)))\n         (first))))","user":"57adbe7ee4b0b8559636fca0"},{"code":"(fn [& a] (let [g #(if (zero? %2) % (recur %2 (mod % %2))) l #(/ (* % %2) (g % %2))] (reduce l a)))","problem":100,"user":"5098bcfee4b0cae2931060a1"},{"code":"(fn [& ns]\n  (loop [attempt 1/2]\n    (if (every? #(= 0 (mod attempt %)) ns)\n      attempt\n      (recur (+ 1/2 attempt)))))","problem":100,"user":"50435852e4b034ff00315d22"},{"problem":100,"code":"(fn [& col]\n  (letfn [(gcm [a b]\n               (if (zero? b)\n                 a\n                 (recur b, (mod a b))))\n          (lcm [a b] \n               (/ (* a b) (gcm a b)))]\n    (reduce lcm col)))","user":"55b1d0b5e4b0da326a65cf73"},{"problem":100,"code":"(fn [& xs]\n  (first (filter (fn [p] (every? #(zero? (rem p %)) xs))\n                 (iterate #(+ % (/ 1 (denominator (clojure.lang.Numbers/toRatio (reduce * xs))))) 1))))","user":"54008b88e4b0de5c4184860d"},{"problem":100,"code":"(fn lcd[& p] (/ (apply * p) (reduce (fn gcd [a b](let [m (mod a b)] (if (= m 0) b (gcd b m)))) p)))","user":"5e48ec09e4b043cd24807a45"},{"problem":100,"code":"(fn lcm [& xs]\n  (let [find-lcm\n        (fn find-lcm [originals current] ;originals are the xs, current are the current values of that x's times table\n          (if (apply = current) ;if they're all the same then we've found the lcm\n              (first current)\n              (let [least (apply min current)]\n                (find-lcm originals (map (fn [o c] (if (= c least) (+ c o) c)) originals current)) ;increment the smallest\n              )\n          )\n        )\n        ]\n    (find-lcm xs xs)\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"code":"(fn lcm [& args]\n  (let [[x y & more :as all] args]\n    (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\n      (let [d (reduce gcd (gcd x y) more) n (reduce * args)]\n        (/ n d)))))","problem":100,"user":"5084c43be4b0fb8f40674bfa"},{"code":"(fn [& args]\r\n     ((fn lcm [multiples]\r\n          (let [heads (map first multiples) i-min (apply min heads)]\r\n            (if (apply = heads)\r\n              (first heads)\r\n              (lcm\r\n                (map\r\n                  (fn [i-list]\r\n                      (if (= (first i-list) i-min)\r\n                        (rest i-list)\r\n                        i-list))\r\n                  multiples)))))\r\n      (map\r\n        (fn [element]\r\n            (iterate #(+ element %) element))\r\n        args)))","problem":100,"user":"4dddf817535d08e6dec9fdd3"},{"problem":100,"code":"#(reduce (fn lcm [a b & [c]] (let [c (or c (max a b))]\n                               (if (= 0 (rem c a) (rem c b)) c\n                                (lcm a b (+ c (max a b))))))\n                       %&)","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":100,"code":"(fn lcm [& args]\n  (reduce \n    (fn [a b] \n      (/ (* a b) \n        ((fn gcd [a b] \n          (if (= 0 (rem a b)) \n            b \n            (gcd b (rem a b)))) a b))) \n    args))","user":"5574c172e4b05c286339e059"},{"problem":100,"code":";;Could have just multiplied these all together\n(fn [& args]\n  (loop [lcm (first args)\n         arr args]\n    (if (empty? arr)\n      lcm\n      (recur\n        (/ (* lcm (first arr))\n           ((fn [x y] (if (zero? y) x (recur y (rem x y)))) lcm (first arr)))\n        (rest arr)))\n    ))","user":"578f9a18e4b0ebec4cfb7598"},{"problem":100,"code":"(fn [& y]\n  (first (sort (apply clojure.set/intersection (for [x y] (set (sort (range (+ x x) 250 x))))))))","user":"607d6bc1e4b03d835a6eaecc"},{"problem":100,"code":"(fn [& nums]\n  (loop [lcm nums]\n    (if (apply = lcm) \n      (first lcm)\n      (let [min-lcm     (reduce min lcm)\n            min-lcm-pos (map #(if (= % min-lcm) 1 0) lcm)]\n        (recur (map #(+ (* %1 %2) %3) min-lcm-pos nums lcm))))))","user":"594bc16be4b07ddc2dafae39"},{"code":"(fn [& args]\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    ))","problem":100,"user":"4f7d25b4e4b06e829148e1ba"},{"problem":100,"code":"(fn [x & coll] (apply min (reduce clojure.set/intersection (set (take 400 (iterate #(+ x %) x)))\n        (map (fn [x] (set (take 400 (iterate #(+ x %) x)))) coll))))","user":"6081b7fce4b0736b099e42d4"},{"problem":100,"code":"(fn  \n  ([n1 n2]\n   (letfn [(gen-mult [n]\n           (map #(* n %) (range 1 100)))]\n   (apply min (set (filter (set (gen-mult n1))\n                           (set (gen-mult n2)))))))\n  ([n1 n2 n3]\n   (letfn [(gen-mult [n]\n             (map #(* n %) (range 1 100)))]\n   (apply min (set (filter (set (gen-mult n1))\n                           (set (filter\n                                 (set (gen-mult n2))\n                                 (set (gen-mult n3)))))))))\n  ([n1 n2 n3 n4]\n   (letfn [(gen-mult [n]\n             (map #(* n %) (range 1 1000)))]\n     (apply min (set (filter (set (gen-mult n1))\n                             (set (filter\n                                   (set (gen-mult n2))\n                                   (set (filter\n                                        (set (gen-mult n3))\n                                        (set (gen-mult n4))))))))))))","user":"505d1b01e4b0e6aca564be04"},{"problem":100,"code":"(fn lcm\n  ([a b]\n   (let [gcd (fn [a b]\n              (cond\n                (= a b) a\n                (> a b) (recur (- a b) b)\n                :else (recur a (- b a))))]\n     (/ (* a b) (gcd a b))))\n  ([a b & more]\n   (reduce lcm (lcm a b) more)))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [& xs] (reduce (fn [a b] (/ (* a b) ((fn [x y] (if (zero? y) x (recur y (mod x y)))) a b))) xs))","problem":100,"user":"4f2942ace4b0d6649770a01e"},{"code":"(fn [& s]\n  (letfn [(gcd [x y]\n            (if (zero? y) x (gcd y (mod x y))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) s)))","problem":100,"user":"511d6a01e4b022853b0e07a5"},{"problem":100,"code":"(fn lcm\n  [ & nums ]\n  (loop [ cur (apply vector nums) vec-nums (apply vector nums)]\n    (if (every? (partial = (get cur 0)) cur)\n      (get cur 0)\n      (let \n        [min-index (first (apply min-key second (map-indexed vector cur)))\n         value-to-add (get vec-nums min-index)]\n        (recur (update-in cur [min-index] (partial + value-to-add)) vec-nums)\n      )\n    )\n  )\n)","user":"5f6b8222e4b02876ed9fd052"},{"problem":100,"code":"(fn [& args]\n        (loop [cur (apply min args)]\n          (if (every? #(integer? (/ cur %)) args)\n            cur\n            (recur (+ cur (apply min args))))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":100,"code":"(fn [& nums]\n  (loop [curr (apply vector nums)]\n      (if (every? #(= % (first curr)) curr)\n          (first curr)\n          (let [m (apply min curr)\n                i (.indexOf curr m)]\n              (recur (assoc curr i (+ (nth curr i) (nth nums i))))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn [& xs]\n  (let [f (fn f [a b]\n            (if (= a b) a\n              (f (- (max a b) (min a b)) (min a b))))]\n  (reduce (fn [x y] \n            (/ (* x y) (f x y)))\n            (first xs)\n            (rest xs))\n  )\n)","problem":100,"user":"4f1595da535d64f603146444"},{"problem":100,"code":";; great one using greatest common denom - not mine \n(fn  tt [& ys]\n  (letfn [(gcd1 [a b]\n            (if (zero? (rem a b))\n              b\n              (gcd1 b (rem a b))))\n          (gcd [xs]\n            (reduce gcd1 xs))]\n  (/ (apply * ys) (gcd ys))))","user":"599342efe4b0b211ea3aaab0"},{"problem":100,"code":"(fn [& xs]\n   (->> (repeat (apply max xs))\n        (reductions +)\n        (filter (fn [x]\n                  (every?\n                   #(zero? (rem x %))\n                   xs)))\n        (first)))","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":100,"code":"(fn [& args]\n  (if (some zero? args)  \n    0\n    (let [GCD (fn [a b]\n                (cond\n                  (or (zero? a) (zero? b)) 0\n                  (= 1 a) 1\n                  (= 1 b) 1\n                  (zero? (mod a b)) b\n                  :else (recur b (mod a b))))]\n     (reduce (fn [acc x] (/ (* acc x) (GCD acc x))) 1 args))))","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn [& ns]\n  (letfn [\n    (g [a b] (if (= b 0) a (g b (rem a b))))\n    (l [a b] (/ (* a b) (g a b)))\n  ]\n    (reduce l ns)\n  )\n)","problem":100,"user":"4f8b56dae4b02e764a0a517e"},{"code":"(fn [& n] ((fn t [xs ys] (let [m (apply min xs)] (if (apply = xs) m (do (recur (map #(if (= m %) (+ % %2) %) xs ys) ys))))) n n))","problem":100,"user":"4ef6e689535dced4c769f24f"},{"problem":100,"code":"(fn [ & args]\n  (letfn [(helper [ & args]\n            (let [f (first (first args))\n                  m (reduce #(min (first %2) %1) Integer/MAX_VALUE args)]\n                  (if (every? #(= f (first %)) args)\n                    f\n                    (apply helper (map #(if (= (first %) m) (rest %) %) args)))))]\n    (apply helper (map #(map * (rest (range)) (repeat %)) args))))","user":"5be58beae4b0ed4b8aab4d14"},{"problem":100,"code":"(fn [& xs]\n  (/ (apply * xs)\n     (reduce #(if (zero? %2) %\n                  (recur %2 (mod % %2))) xs)))","user":"53528cd3e4b084c2834f4af2"},{"code":"; http://en.wikipedia.org/wiki/Least_common_multiple#A_simple_algorithm\n(fn [& initial]\n  (loop [c (vec initial)]\n    (if (apply = c) ; all numbers equal? => LCM\n      (first c)\n      (let [m (apply min c) ; min number\n            i (.indexOf c m) ; index of min number\n            v (get (vec initial) i)] ; initial value of this min number\n        (recur (assoc c i (+ m v)))))))","problem":100,"user":"500900dee4b0144d4f561e42"},{"problem":100,"code":"(fn [& nums]\n  (let [reducer #(loop [a %1 b %2]\n                   (cond\n                    (= a b) a\n                    (< a b) (recur (+ a %1) b)\n                    :else (recur a (+ b %2))))]\n    (reduce reducer nums)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":100,"code":"(fn [x & ys]\n  (let [multiples (iterate (partial + x) x)\n        divides? #(every? zero? (map (partial mod %) ys))]\n    (first (filter divides? multiples))))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":100,"code":"(fn calc [& col]\n  (let [gcd (fn gcd [a b]\n          (if (< a b) (gcd b a)\n              (if (= b 0) a\n                  (gcd b (mod a b)))))\n        nod (fn nod [a & rst]\n              (if (empty? rst)\n                a\n                (gcd a (apply nod rst))))\n        nok (fn nok [& col]\n              (let [nods (apply nod col)\n                    mult (apply * col)]\n                (/ mult nods)))\n        prepared (filter #(if (ratio? %) (numerator %) %) col)]\n    (apply nok col)))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":100,"code":"(fn [& is]\n  (let [gcd (fn [a b]\n              (cond\n                (= a b) a\n                (> a b) (recur (- a b) b)\n                (> b a) (recur a (- b a))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce #(lcm %1 %2) is)))","user":"559057c4e4b027778923766e"},{"problem":100,"code":"(fn mylcm [x & r] (letfn [(mygcd [x y] (let [zb (mod x y)] (if (= zb 0) y (mygcd y zb))))] \n                    (if (empty? r) x (apply mylcm (conj  (rest r) (/ (* x (first r)) (mygcd x (first r))))) )))","user":"5576e78de4b05c286339e075"},{"problem":100,"code":"(fn [& x]\n  (let [gcd (fn [a b]\n              (let [small (min a b)\n                    big (max a b)]\n                (if (zero? small)\n                  big\n                  (recur small (mod big small)))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (loop [l x]\n      (let [a (first l)\n            b (second l)\n            c (count l)\n            g (lcm a b)]\n        (if (<= c 2)\n          g\n          (recur (cons g (drop 2 l))))))))","user":"59473563e4b07ddc2dafad97"},{"code":"(fn [& ns] \n  (let [vs (vec ns)\n        idx-min #(first (apply min-key second (map-indexed vector %)))]\n    (loop [s vs] \n      (if (apply == s) \n        (first s) \n        (let [m (idx-min s)] \n          (recur (assoc s m (+ (s m) (vs m)))))))))","problem":100,"user":"4efd8b67535de96065cf5085"},{"code":"#(/ (apply * %&) (apply (fn gcd ([x y]\n      (loop [m x n y]\n\t       (cond (zero? (mod m n)) n,\n\t\t     (zero? (mod n m)) m,\n\t\t     :else (recur (mod m n) (mod n m)))))\n\t([x y & more] (reduce gcd (gcd x y) more))) %&))","problem":100,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":100,"code":"(fn lcm [a b & more]\n  (let [gcd (fn [x y] \n              (if (zero? y) \n                x\n                (recur y (mod x y))))\n        c (* (quot a (gcd a b)) b)]\n    (if more \n      (apply lcm (cons c more))\n      c)))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":100,"code":"(fn lcm [& args]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"5ee81beae4b029a2061bbeac"},{"code":"(fn lcm\n  ([a b & x] (apply lcm (cons (lcm a b) x)))\n  ([a b]\n    (let [mul #(map (partial * %) (drop 1 (range)))]\n      (loop [c 0]\n        (let [mul_a (take c (mul a)) mul_b (take c (mul b))]\n          (or (first (filter (set mul_a) mul_b))\n              (recur (inc c))))))))","problem":100,"user":"4e2b1d48535deb9a81d77f03"},{"problem":100,"code":"(fn [& others]\n  (letfn [(gcd2\n            [x y]\n            (if (= x 0) y (gcd2 (rem y x) x)))\n          (lcm2\n            [x y]\n            (let [denom (gcd2 x y)\n                  prod (* x y)]\n              (/ prod denom)))]\n    (reduce lcm2 others)))","user":"59a31c55e4b066c664927d34"},{"problem":100,"code":"(fn\n  [& args]\n  (let [lst (apply list args)]\n    (reduce (fn\n              [a b]\n              (/ (* a b) (loop [a a\n                                b b]\n                           (if (zero? b)\n                             a\n                             (if (> a b)\n                               (recur b (mod a b))\n                               (recur a (mod b a))))))) lst)))","user":"5c706232e4b0fca0c162277e"},{"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) xs)))","problem":100,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [x y]\n               (let [a (max x y)\n                     b (min x y)\n                     m (mod a b)]\n                 (if (zero? m)\n                   b\n                   (recur b m))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)\n    ))","user":"53e9681de4b036ad0777e4a4"},{"problem":100,"code":"(fn [& xs] (first (sort (apply clojure.set/intersection (map #(into #{} (range % 300 %)) xs)))))","user":"4e68c465535d8ccf87e9fe8a"},{"code":"(fn [& args]\n  (letfn [(gcd [a b]\n               (let [m (max a b) l (min a b) r (rem m l)]\n                 (if (zero? r)\n                   l\n                   (recur l r))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (let [[c d & args] args]\n      (if (empty? args)\n        (lcm c d)\n        (recur (cons (lcm c d) args))))))","problem":100,"user":"52d00832e4b07d0d72b273b4"},{"problem":100,"code":"(fn lcm\n  ([a b] (let [gcd #(if (zero? %2) % (recur %2 (mod % %2)))]\n           (/ (* a b) (gcd a b))))\n  ([a b & m] (reduce lcm (lcm a b) m)))","user":"54ddb556e4b024c67c0cf798"},{"code":"(fn [& valori] \n  (reduce #(* %2 (/ %1 ((fn [a b] (if (= b 0) a (recur b (rem a b)))) %1 %2))) valori))","problem":100,"user":"52c81954e4b0c2d177d6212e"},{"problem":100,"code":"(fn p100 [& args] \n             ((fn p100a [n]\n                (let [cs (->> args\n                              (map #(/ n %))\n                              (filter integer?)\n                              )]\n                  (if-not (= (count args)(count cs))\n                      (p100a (+ 1/2 n))\n                      n\n                      )\n                  )\n                )1/2)\n  \n  )","user":"5400e918e4b0de5c41848619"},{"problem":100,"code":"(fn lcm\n  [& args]\n  (if (coll? (first args))\n    (let [[coll orig] args]\n      (if (apply = coll)\n        (first coll)\n        (let [arcmin (.indexOf coll (apply min coll))]\n          (lcm (assoc coll arcmin (+ (nth coll arcmin) (nth orig arcmin))) orig))))\n    (lcm (vec args) (vec args))))","user":"535f9a5ce4b04ce2eb3ed2de"},{"code":"(fn[& s](some\n           (fn [x](if\n                      (= 0\n                         (apply + (map\n                                   #(rem x %)\n                                   s)\n                                )\n                         )\n                    x\n                    false\n                    )\n             )\n           (map #(* (first s) %) (rest (range)))\n           )\n    )","problem":100,"user":"4e6df3c9535d5021c1a895fa"},{"code":"(fn\t[& s]\n\t(letfn [(gcd [x y] (if-not (zero? y) (recur y (rem x y)) x))]\n\t       (/ (apply * s) (reduce gcd s))))","problem":100,"user":"5142ea50e4b0c172af7558ca"},{"problem":100,"code":"(fn [& a]\n  (loop [r (repeat (count a) #{}) i 1]\n    (let [n (seq (apply clojure.set/intersection r))]\n    (if (seq n)\n      (first n)\n      (recur (map #(conj %2 (* % i)) a r) (inc i))))))","user":"555883c5e4b0deb715856e2d"},{"code":"(fn problem-100\n  [& nums]\n  (letfn [\n          (gcd [a b] (cond (zero? a) b\n                           (zero? b) a\n                           :else (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n          \n    (reduce #(lcm %1 %2) nums)))","problem":100,"user":"52319066e4b0e2e8de81d1e9"},{"code":"(fn lowest-common-multiple [& numbers]\n        (loop [m {}, i 1]\n          (let [lcm (first (filter #(= (count numbers) (count (second %))) m))]\n            (if lcm\n              (first lcm)\n              (recur (apply merge-with concat m (map (fn [x] {(* x i) [x]}) numbers))\n                     (inc i))))))","problem":100,"user":"4e589bdc535d8a8b8723a295"},{"code":"(fn [& ns]\n  (let [gcd (fn [x y] (if (= 0 y) x (recur y (mod x y))))\n        abs (fn [n] (if (neg? n) (- n) n))]\n    (reduce #(/ (abs (* % %2)) (gcd % %2)) ns)))","problem":100,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"(fn [& a]\n         (letfn [(gcd [x y] (let [a (min x y) b (max x y) r (mod b a)](if (> r 0) (gcd a r) a)))]\n           (let [d (reduce gcd a)]\n             (/ (apply * a) d))\n           ))","problem":100,"user":"4dae0510c9a9d6ed4b99dc57"},{"code":"(fn [& coll]\n  (reduce \n    (fn lcm [a b]\n      (first \n        (filter #(zero? (mod % a)) (iterate #(+ b %) b))))\n  coll))","problem":100,"user":"501c1492e4b086d93747d180"},{"code":"(fn l\n  ([x y]\n      (letfn [(g [x y] (if (= 0 y) x (g y (mod x y))))]\n        (/ (* x y) (g x y))))\n  ([x y z & r] (apply l (l x y) (l x z) r)))","problem":100,"user":"4dada16fc9a9d6ed2699dc57"},{"problem":100,"code":"(fn lcm \n  ([x y] (* x (/ y ((fn gcd ([a b] (if (= b 0) a (gcd b (mod a b)))) ([a b & more] (reduce gcd (gcd a b) more))) x y))))\n  ([x y & more] (reduce lcm (lcm x y) more))\n  )","user":"5aa8f753e4b0d174b936c8d9"},{"problem":100,"code":"(fn lcd [& xs]\n   (reduce\n    (fn lcd2 [m n] \n      (/ \n       (* m n) \n       ((fn gcd2 [x y] \n          (if (zero? x) \n            y \n            (gcd2 (rem y x) x))) m n))) xs))","user":"55249f64e4b0882d96d091c6"},{"code":"(fn lcm [& x]\n     (first (apply (fn lcmseq [& y]\n                     (if (empty? (rest y))\n                       (iterate #(+ % (first y)) (first y))\n                       (filter #(= (mod % (first y)) 0) (apply lcmseq (rest y)))))\n              x)))","problem":100,"user":"532727bae4b09d4e7a9b54fa"},{"problem":100,"code":"(fn [& a]\n  (/ (reduce * 1 a) (reduce #(if (zero? (mod %1 %2))\n                                  %2\n                                  (recur %2 (mod %1 %2))) (first a) a)))","user":"5a9a12d6e4b0d174b936c7b7"},{"problem":100,"code":"(fn [& args] (first (filter #(every? (partial = 0) (map (fn [x] (mod % x)) args))\n                                     (rest (map #(* (apply max args) %) (range))))))","user":"56baab13e4b0f26550335948"},{"problem":100,"code":"(letfn [(div? [a b] ((comp zero? mod) a b))\n        (int-lcm [a, b]\n                 (->> (iterate inc 1)\n                      (filter #(and (div? % a) (div? % b)))\n                      first))\n        (safe-numerator [x]\n                        (if (ratio? x) (numerator x) x))\n        (safe-denominator [x]\n                          (if (ratio? x) (denominator x) 1))\n        (div-lcm [div-a div-c]\n                 (let [a (safe-numerator div-a)\n                       b (safe-denominator div-a)\n                       c (safe-numerator div-c)\n                       d (safe-denominator div-c)\n                       lcm-bd (int-lcm b d)\n                       mult-a (* a (/ lcm-bd b))\n                       mult-c (* c (/ lcm-bd d))\n                       lcm-ac (int-lcm mult-a mult-c)]\n                   (/ lcm-ac lcm-bd)))\n        (comp-lcm [& args]\n            (reduce div-lcm args))]\n  comp-lcm)","user":"5412ef7ee4b01498b1a719da"},{"code":"(fn [& y]\n  (reduce\n    (fn [a b] (/ (* a b) (#(if (= 0 %2) % (recur %2 (mod % %2))) a b)))\n    y))","problem":100,"user":"4f3444b7e4b0e243712b1eb6"},{"problem":100,"code":"(let [gcd (fn[x y] (if (zero? y) x (recur y (mod x y))))\n      lcm (fn[x y] (/ (* x y) (gcd x y)))\n      numer (fn[x] (if (ratio? x) (numerator x) x))\n      denom (fn[x] (if (ratio? x) (denominator x) 1))\n      lcmratio (fn [x y] (/ (lcm (numer x) (numer y)) (gcd (denom x) (denom y))))]\n  (fn [x y & z] (if (empty? z) (lcmratio x y) (recur (lcmratio x y) (first z) (rest z)))))","user":"5596af34e4b04c1e5c31d758"},{"problem":100,"code":"(fn [& args]\n  \n  (letfn \n    [(gcd [a b]\n     (if (> b a)\n    \t(gcd b a))\n  \t (if (= b 0)\n    \ta\n     (recur b (mod a b))))\n     (lcm [a b] (/ (* a b)(gcd a b)))]\n    (reduce lcm args)))","user":"53e241a6e4b036ad0777e3f0"},{"code":"(fn [& args]\n    (letfn [(gcd [x y]\n        (let [a (max x y)\n              b (min x y)\n              m (mod a b)]\n            (if (zero? m)\n                b\n                (recur b m))))\n            (lcm [a b]\n                (/ (* a b) (gcd a b)))]\n        (reduce lcm args)\n    )\n)","problem":100,"user":"51d1111ce4b067c36548635f"},{"problem":100,"code":"(fn [& l]\r\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\r\n    (/ (reduce * l) (reduce gcd l))))","user":"5f2c02d1e4b033932238a65f"},{"problem":100,"code":"(fn least-common-multiple [a & more]\n  (loop [seq-tmp (conj (seq more) a)\n         res a]\n    (if (empty? seq-tmp)\n      res\n      (recur (next seq-tmp)\n             (/ (* res (first seq-tmp))\n                ((fn gcd [a b]\n                  (if (= b 0)\n                    a\n                    (gcd b (mod a b))))\n                  res\n                  (first seq-tmp)))))))","user":"5b596d0ce4b02d533a91bd7a"},{"code":"(fn [& [h & s]] \n  (let [mux (map #(* % h) (rest (range)))]\n    (first (filter #(every? (fn [n] (zero? (rem % n))) s) mux))))","problem":100,"user":"4e95f5a5535dbda64a6f6b3b"},{"problem":100,"code":"(fn [n1 n2 & args]\n  (letfn [(gcd [n1 n2](loop [a (max n1 n2) b (min n1 n2) aux (mod a b)](if (= aux 0) b (recur b aux   (mod a b))))) (lcm [n1 n2] (/ (* n1 n2) (gcd n1 n2) ) )] \n  (loop [i (count args) res (lcm n1 n2) l args ]\n    (cond\n      (= i 0) res\n      :else\n      (recur (dec i) (lcm res (first l)) (rest l))\n    )\n  )\n  )\n)","user":"5e94ff5fe4b0fbed045a37ff"},{"problem":100,"code":"(fn lcm [& more]\n  (let [x (apply * more)\n        y (reduce (fn gcd2 [x y]\n                    (let [r (rem x y)]\n                      (if (= 0 r)\n                        y\n                        (gcd2 y r))))\n                  more)]\n    (/ x y)))","user":"54d753ebe4b0a52adc2e2029"},{"code":"#(letfn\n  [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n   (lcm [a b] (/ (* a b) (gcd a b)))]\n  (reduce lcm %&))","problem":100,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":100,"code":"(fn least-common-multiple-solution\n  [& args] ;; update args as needed\n  ;; Write a function which calculates the least common multiple. Your function should accept a variable number of positive integers or ratios.\n  (letfn [(gdc\n              [ain bin]\n              (loop [a ain b bin]\n                (if (= b 0)\n                  a\n                  (recur\n                    b\n                    (mod a b)))))\n          (lcm\n            [a b]\n            (/ (* a b ) (gdc a b)))]\n    (reduce lcm args)))","user":"54df955ee4b024c67c0cf7af"},{"code":"(fn lcm [& xs]\n  (let [gcd-2-fn (fn gcd [a b] (if (> a b) (gcd b a) (if (zero? (mod b a)) a (gcd (mod b a) a))))\n        r-fn (fn [r-lcm x] (/ (* r-lcm x) (gcd-2-fn r-lcm x)))]\n    (reduce r-fn xs)))","problem":100,"user":"51281b25e4b03a34742b4304"},{"code":"(fn [& li] (\nreduce\n(fn kgv \n  ([ x y ] \n\t\t(kgv x y x))\n\t([x y z] \n\t\t(println x y z)\n\t\t(if (== (rem x y) 0 ) \n\t\t\tx \n\t\t\t(kgv (+ x z) y z ))))\nli\n))","problem":100,"user":"4e8d5edd535d65386fec2134"},{"problem":100,"code":"(fn \n  [& mas]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm mas)))","user":"57fedf07e4b0d3187e9009dc"},{"code":"(fn lcm\n  ([x y]\n     (letfn [(gcd [a b]\n               (cond\n                (= b 0) a\n                :else (gcd b (mod a b))))]\n       (/ (* x y) (gcd x y))))\n  ([x y & rest]\n     (apply lcm (lcm x y) rest)))","problem":100,"user":"50b0cffae4b009df37c708c5"},{"problem":100,"code":"(fn [& nums]\n  (let [lcm-int (fn [& nums]\n                  (loop [accum 1\n                         current-divisor 2\n                         nums nums]\n                    (if (every? #(= % 1) nums)\n                      accum\n                      (let [new-nums (map #(if (= (rem % current-divisor) 0) (/ % current-divisor) %) nums)]\n                        (if (= nums new-nums)\n                          (recur accum (inc current-divisor) nums)\n                          (recur (* accum current-divisor) current-divisor new-nums))))))\n        my-numerator (fn [num]\n                       (if (ratio? num)\n                         (numerator num)\n                         num))\n        my-denominator (fn [num]\n                         (if (ratio? num)\n                           (denominator num)\n                           1))\n        lcm-denominators (apply lcm-int (map my-denominator nums))\n        new-numerators (map #(* (my-numerator %2) (/ lcm-denominators %1))\n                      (map my-denominator nums)\n                      nums)]\n    (/ (apply lcm-int new-numerators)\n       lcm-denominators)))","user":"53527551e4b084c2834f4af0"},{"problem":100,"code":"(fn lcm [ & l ] \n  (let [n (map #(if (ratio? %) (numerator %) %) l)\n        d (map #(if (ratio? %) (denominator %) 1) l)\n        factor (fn[n] (filter #(zero? (mod n %)) (range 2 (inc n))))\n   \t\tnums (reduce * (flatten (map factor n)))\n    \tdeno (first (apply clojure.set/intersection (map set (map factor d))))        \n    \t]    \n     (if (nil? deno) nums (/ nums deno))    \t\n    )\n  )","user":"57887de2e4b0ebec4cfb751c"},{"code":"(fn [& coll]\n  (let [gcd-int (fn [p q]\n                  (if (zero? q)\n                    p\n                    (recur q (mod p q))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd-int a b)))\n        gcd-ratio (fn [n m q p]\n                    (/ (gcd-int n q)\n                       (lcm m p)))\n        gcd (fn [a b]\n              (cond (and (ratio? a) (ratio? b))\n                    (gcd-ratio (numerator a) (denominator a)\n                               (numerator b) (denominator b))\n                    (and (ratio? a) (integer? b))\n                    (gcd-ratio (numerator a) (denominator a)\n                               b 1)\n                    (and (integer? a) (ratio? b))\n                    (gcd-ratio a 1\n                               (numerator b) (denominator b))\n                    (and (integer? a) (integer? b))\n                    (gcd-int a b)))]\n   (reduce lcm coll)))","problem":100,"user":"4fdbc075e4b05e33b9224f61"},{"problem":100,"code":"(fn f100 [& args]\n  (->>\n   (map #(set (lazy-seq (range (+ % %) 1000 %))) args)\n  (apply clojure.set/intersection )\n   ((comp first sort vec))))","user":"57bbc9bde4b05aa3c4741c31"},{"code":"(fn [& xs]\n  (->> (map #(set (range % 1000 %)) xs)\n       (apply clojure.set/intersection)\n       (apply min)))","problem":100,"user":"51c8301ee4b07ef393169e4d"},{"code":"(fn [& args]\n  (letfn [ (multiples-of [z c] (set (take c (iterate #(+ z %) z)))) ] \n    (first (sort (apply clojure.set/intersection (map #(multiples-of % 500) args))))))","problem":100,"user":"52117ea7e4b07aea8afc4f70"},{"problem":100,"code":"(fn lcm [a b & inputs]\n\t(letfn [(gcd \n\t([] 1)\n\t([a] a)\n\t([a b]\n\t\t(cond (= a b) a\n\t\t  \t(> a b) (gcd (- a b) b)\n\t\t  \t(< a b) (gcd a (- b a))))\n\t([a b & args]\n\t\t(reduce gcd (gcd a b) args)))]\n\n\t(if (= inputs nil)\n\t\t(/ (* a b) (gcd a b))\n\t\t(reduce lcm (lcm a b) inputs))))","user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn [& coll]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (rem x y))))]\n    (reduce (fn [x y] (/ (* x y) (gcd x y))) coll)))","problem":100,"user":"4dda44f2535d02782fcbe9f1"},{"problem":100,"code":"(fn [& ns] (let [m (apply min ns)]\n             (first (filter (fn [n] (every? #(= 0 (mod n %)) ns)) \n                            (iterate (partial + m) m)))))","user":"52e851bfe4b09f7907dd149a"},{"code":"(fn lcm [& xs]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (l [a b] (/ (* a b) (gcd a b)))]\n  (reduce l xs)))","problem":100,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn lcm\n  ([x y] \n  (/ \n    (* x y)\n    ((fn gcd [a b]\n      (cond \n        (> b a) (gcd b a)\n        (= b 0) a\n        :else (gcd b (mod a b))))\n    x y)))\n  ([x y & r] (apply lcm (conj r (lcm x y)))))","problem":100,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn [& vs]\n  (let [min (apply min vs)]\n    (some\n     #(when (every? (fn [v] (= 0 (mod % v))) vs) %)\n     (range min 999 min))))","problem":100,"user":"502873a8e4b01614d1633ff8"},{"problem":100,"code":"(fn least-common-multiple100\n  [& nums]\n  (let [big (apply max nums)]\n    (loop [factors (rest (range))]\n      (do\n        (println \"Nums = \" nums \", Big \" big \", factor = \" (first factors))\n        (let [multiple (* (first factors) big)]\n          (if-not (some #(> (mod multiple %) 0) nums)\n            multiple\n            (recur (rest factors))))))))","user":"5398d042e4b0b51d73faaf00"},{"code":"(fn lcm\n        ([x y]\n        (loop [res x]\n        (if (zero? (+(rem res x) (rem res y)))\n          res\n          (recur (+ res x)))))\n        ([x y z]\n        (loop [res x]\n        (if (zero? (+(rem res x) (rem res y) (rem res z)))\n          res\n          (recur (+ res x)))))\n         ([x y z q]\n        (loop [res x]\n        (if (zero? (+(rem res x) (rem res y) (rem res z) (rem res q)))\n          res\n          (recur (+ res x))))))","problem":100,"user":"52cdec6ce4b07d0d72b27383"},{"problem":100,"code":"(fn [& ns]\n  (let [gcd (fn [ns] (reduce #(if (zero? %2) %1 (recur %2 (rem %1 %2))) ns))\n        lcm (fn [ns] (reduce #(/ (* %1 %2) (gcd [%1 %2])) ns))\n        rs (map #(clojure.lang.Numbers/toRatio %) ns)]\n    (/ (lcm (map numerator rs))\n       (gcd (map denominator rs)))))","user":"606da089e4b069485764de15"},{"problem":100,"code":"(fn lcm [& args]\n  (let [lcm-inner \n        (fn lcm-inner [nums] \n          (let [active (map #(get % 1) nums)\n                is-valid (apply = active)\n                sorted (sort #(< (get %1 1) (get %2 1)) nums)\n                [original total] (first sorted)\n                bumped [original (+ total original)]\n                rest (drop 1 sorted)]\n            (if is-valid\n              total\n              (lcm-inner (conj rest bumped)))))]\n    (lcm-inner (map (fn [n] [n n]) args))))","user":"5483d59fe4b0e286459a1194"},{"problem":100,"code":"(fn [& args] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce gcd args))))","user":"6074e278e4b069485764de51"},{"code":"(fn [x & r]\n   (first \n    (filter\n     (fn [c] (every? #(zero? (mod c %)) r))\n     (iterate #(+ % x) x))))","problem":100,"user":"4dbe8729535d020aff1edf62"},{"code":"(fn [& args] (reduce (fn [a b] (* (/ a (#(if (zero? %2) % (recur %2 (mod % %2))) a b)) b)) args))","problem":100,"user":"4db091b7838c48654951d9c2"},{"problem":100,"code":"(fn [a & v]\n  (some\n    #(when (apply = 0 (map (partial rem %) v)) %)\n    (rest (map #(* a %) (range)))))","user":"51a4d802e4b0def3c5c5869a"},{"code":"(fn [& xs]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))]\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) xs)))","problem":100,"user":"5312cdaae4b08068f379ed03"},{"problem":100,"code":"(fn [& xs]\n  (let [gcd (fn g [a b]\n                  (if (= 0 b)\n                      a\n                      (g b (mod a b))))\n        lcm (/ (apply * xs) (reduce gcd xs))\n        ]\n        lcm))","user":"55c49394e4b0e31453f6499e"},{"code":"(fn [x & xs]\n      (let [multiples (map (partial * x) (rest (range)))\n            common-multiples (drop-while #(some (fn [x] (not= 0 (rem % x))) xs) multiples)]\n        (first common-multiples)))","problem":100,"user":"51e28063e4b08e53a149f0f2"},{"problem":100,"code":"(fn [& n]\n  (loop [lcm (reduce max n)]\n    (if (every? zero? (map #(rem lcm %) n))\n      lcm\n      (recur (+ lcm (reduce max n))))))","user":"59b554cee4b05c620303ca0f"},{"code":"#(reduce (fn[a b] (/ (* a b) ((fn g [a b](if (= 0 b) a (g b (mod a b)))) a b)))%&)","problem":100,"user":"4f296a80e4b0d6649770a02a"},{"problem":100,"code":"(fn [& args]\n          (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n                lcm (fn [a b] (/ (* a b) (gcd a b)))]\n            (reduce #(lcm %1 %2) args)))","user":"54b13dbce4b09f271ff37d1c"},{"problem":100,"code":"(fn [& s](reduce\n          (fn [a b](\n              loop [x a y b](cond\n                               (= x y) x\n                               (< x y) (recur (+ x a) y)\n                               (> x y) (recur x (+ y b))\n                             )\n                    )) s))","user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn [& s]\n  (letfn [(gcd [x y] (loop [a x b y]\n                      (cond\n                       (< a b) (recur b a)\n                       (zero? (mod a b)) b\n                       true (recur b (mod a b))))\n               )]\n  (/ (reduce * s) (reduce gcd s))))","problem":100,"user":"4f8b27b3e4b02e764a0a5179"},{"code":"(fn f [& x]\n    ;worst code ever\n    (first (filter\n\t  (fn [a]\n        (apply = (conj (map #(rem a %) x) 0))\n      )\n\t  (take 1000 (iterate #(+ % (apply min x)) (apply min x)))\n\t))\n)","problem":100,"user":"50f4894be4b004d364930528"},{"code":"(fn [& ns]\n  (loop [pairs (vec (map #(vector % %) ns))\n         i 0]\n    (println pairs)\n    (if (or (= 1 (count (group-by identity (map second pairs))))\n            (> i 1000))\n      (second (first pairs))\n      (let [sorted (sort-by second pairs)\n            min (first sorted)\n            [step current] min]\n        (recur (cons [step (+ step current)]\n                     (rest sorted))\n               (inc i))))))","problem":100,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn [& arguments] \n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * arguments) (reduce gcd arguments))))","problem":100,"user":"50ef56dfe4b0bdaecbb47d94"},{"problem":100,"code":"(fn\n    [& xs]\n\n    (let\n      [\n        gcd\n        (fn [x y]\n          (let\n            [\n              a (max x y)\n              b (min x y)\n              m (mod a b)\n            ]\n            (if (zero? m)\n              b\n              (recur b m)\n            )\n          )\n        )\n        lcm\n        (fn\n          [a b]\n          (/ (* a b) (gcd a b))\n        )\n      ]\n      (reduce lcm xs)\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":100,"code":"(fn x [a & b]\n  (let [c (iterate #(+ a %) a) \n        mod_zero (fn [n div] (= 0 (mod n div)))]\n        (first\n    \t (filter #(every? (partial mod_zero %1) b ) c)\n         )\n   )\n  )","user":"56db90d4e4b0ea9b8538f80d"},{"code":"(fn [& values]\n   (let [least (apply min values)\n         multiples-of-least (iterate (partial + least) least)]\n     (first (filter\n             (fn [candidate]\n               (empty? (filter false?\n                               (map #(integer? (/ candidate %))\n                                    values))))\n             multiples-of-least))))","problem":100,"user":"4ee868be535d93acb0a6687d"},{"problem":100,"code":"(fn [& c]\n    (letfn [(get-gcd [x y]\n              (if (zero? y)\n                x\n                (recur y (mod x y))))\n            (get-lcm [a b]\n              (/ (* a b) (get-gcd a b)))]\n      (reduce #(get-lcm %1 %2) c)))","user":"591ad160e4b09b4ee5954bdf"},{"code":"(fn lcm [& n]\n  (let [gcd (fn gcd [a b] \n          (cond\n            (> b a) (gcd b a)\n            (= b 0) a\n            true (gcd b (mod a b))))\n        c (reduce gcd n)]\n    (/ (apply * n) c)))","problem":100,"user":"4e14108c535d04ed9115e7dd"},{"problem":100,"code":"(fn\n  [head & numbers]\n  (let [multiples (iterate (partial + head) head)]\n    (first (filter (fn [number] (zero? (reduce + (map #(mod number %) numbers)))) multiples))\n    )\n  )","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn [& args]\r\n  (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))]\r\n    (reduce #(/ (* %1 %2) (gcd %1 %2)) args)))","problem":100,"user":"4dbb0b6c535d1e037afb21b0"},{"problem":100,"code":"(letfn [(gcd [x y]\n          (if (> x y) (recur y x)\n              (if (= x 0) y\n                  (recur (rem y x) x))))]\n  (fn lcm [& args]\n    (reduce\n     (fn [r v]\n       (/ (* r v) (gcd r v)))\n     args)))","user":"54c5cc17e4b045293a27f624"},{"problem":100,"code":"(fn lcm [n & args] (first (drop-while (fn [num] (not (every? #(= (mod num %) 0) args)))\n                                      (rest (iterate #(+ % n) 0)))))","user":"5ee93720e4b029a2061bbeb7"},{"problem":100,"code":"(fn lcmx [& xs] (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b)))), (lcm [a b] (/ (* a b) (gcd a b)))] (reduce lcm xs)))","user":"5b02a170e4b0cc2b61a3bd52"},{"code":"(fn [r & rs]\n    (some (fn [candidate]\n            (when (every? #(zero? (mod candidate %)) rs)\n              candidate))\n          (reductions + (repeat r))))","problem":100,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":100,"code":"(fn nlcm [a & b]\n  (let [gcd (fn [x y]\n              (let [gcd-iter (fn [h l]\n                               (if (= (rem h l) 0)\n                                 l\n                                 (recur l (rem h l))))] ; Loop gcd-iter\n                (if (> x y)\n                  (gcd-iter x y)\n                  (gcd-iter y x))))\n        lcm (fn [m n]                   ; Not sure if this is correct for negative numbers\n              (/ (* m n) (gcd m n)))]\n    (if (empty? b)\n      a\n      (if (empty? (rest b))\n        (lcm a (first b))\n        (apply nlcm (lcm a (first b)) (rest b)))))) ; Ok not tail recursive, recur needs help finding loop top.  Too lazy to do that","user":"5674607ae4b05957ce8c6137"},{"problem":100,"code":"(fn [& xs]\n    (let [sorted (sort xs)\n          biggest (last sorted)\n          others (butlast sorted)]\n      (letfn [(divisible-by? [x]\n                #(= (mod % x) 0))\n              (divisible-by-all? [xs]\n                #(every? identity ((apply juxt (map (fn [x] (divisible-by? x)) xs)) %)))]\n        (first (filter (divisible-by-all? others) (map #(* biggest %) (iterate inc 1)))))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":100,"code":"(fn lcm [ & nums]\n(reduce #(/ (* %1 %2)\n (\n(fn gcd [a b]\n (loop [n (max a b) m (min a b)]\n   (if (= m 0) n\n     (recur m (mod n m))\n   )\n))\n  %1 %2)\n ) nums\n)\n)","user":"5a424954e4b0447ef91cc5f0"},{"problem":100,"code":"(fn jacob[& ns](letfn [(gcd[fi se]\n                         (if(zero? fi)\n                            se\n                         (if(zero? se)\n                            fi \n                            (if(> fi se) \n                               (gcd se (rem fi se))\n                               (gcd fi (rem se fi))\n                                               )))) ] \n             (reduce #(/ (* %1 %2) (gcd %1 %2)) ns)))","user":"5034b623e4b062bc5d7ae168"},{"code":"(fn [& args]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        lcm (fn [a b]\n              (/ (* a b) (gcd a b)))]\n  \t(loop [a (first args)\n           b (second args)\n           v (drop 2 args)]\n    \t\t(if (empty? v)\n              (lcm a b)\n              (recur (lcm a b) (first v) (rest v))))))","problem":100,"user":"534f13b2e4b084c2834f4ac4"},{"problem":100,"code":"(fn [& eles]\n  (letfn [(gcd [a b]\n            (if (= 0 b) a\n                (recur b\n                       (mod a b))))\n          (lcm [a b]\n            (/ (* a b)\n               (gcd a b)))]\n         (reduce lcm eles)))","user":"52fc34cee4b047fd55837015"},{"code":"(fn lcm [& nums]\n   (letfn [(gcd-two [a b]\n             (let [[bigger smaller]\n                   (if (> a b) [a b] [b a])\n                   remainder (rem bigger smaller)]\n               (if (zero? remainder)\n                 smaller\n                 (gcd smaller remainder))))\n           (gcd [& nums]\n             (reduce gcd-two nums))]\n     (/ (apply * nums)\n        (apply gcd nums))))","problem":100,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn lcm [& nums]\n  (let [ns (sort > nums)\n        mx (first ns)]\n    (first (filter \n            #((fn [n f] (every? (fn [x] (zero? (rem n x))) f)) % ns) \n            (iterate #(+ mx %) mx)))))","problem":100,"user":"5006b7d2e4b0678c553fc48c"},{"code":"(fn [& xs] (letfn\n             [(lcm [a b] (/ (* a b) (gcd a b)))\n              (gcd [c d] (if (= c d) c (apply gcd (if (> c d) [(- c d) d] [c (- d c)]))))]\n             (reduce lcm xs)))","problem":100,"user":"51307b84e4b08c712d3fae39"},{"problem":100,"code":"(fn [& nums]\n  (first\n    (sort\n      (lazy-seq (reduce clojure.set/intersection (map set (for [multiple nums]\n             (take 500\n                   (map #(* %1 %2) (repeat multiple) (iterate inc 1)))\n             ))))))\n  )","user":"54dbe183e4b024c67c0cf778"},{"problem":100,"code":"(fn [& args]\n   (letfn [(gcd [a b]\n                (if (zero? b)\n                  a\n                  (recur b, (mod a b))))\n           (lcm [a b]\n                (/ (* a b) (gcd a b)))]\n     (reduce lcm args)))","user":"52e0e646e4b09f7907dd1416"},{"problem":100,"code":"(fn\n  [& orig]\n  (loop [l (vec orig)]\n    (if (= 1 (count (into #{} l)))\n      (first l)\n      (let [smallest (first (sort l))]\n        (recur (loop [i 0]\n                 (if (= (nth l i) smallest)\n                   (assoc l i (+ smallest (nth orig i)))\n                   (recur (inc i)))))))))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":100,"code":"(fn lcm\n  ([a b & others]\n   (reduce lcm (lcm a b) others))\n  ([a b]\n   (let [gcd (fn g\n               ([a b & others]\n                (reduce g (g a b) others))\n               ([a b]\n                (let [r (rem b a)]\n                  (if (= r 0) a\n                      (g r a)))))]\n     (/ (* a b) (gcd a b)))))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn [& args]\n\t(letfn [(gcd [x y]\n\t\t\t\t(let [a (max x y)\n\t\t\t\t\t  b (min x y)\n\t\t\t\t\t  m (rem a b)]\n\t\t\t\t\t(if (zero? m)\n\t\t\t\t\t\tb\n\t\t\t\t\t\t(recur b m))))\n\t\t\t(lcm [a b]\n\t\t\t\t(/ (* a b) (gcd a b)))]\n\t  (reduce lcm args)))","problem":100,"user":"51bdc609e4b0ff155d51d2b3"},{"code":"(fn [& nlst] \n  ((fn foo [n0 n c] (if (every? #(integer? (/ (* n0 c) %)) n)\n                                (* n0 c)\n                                (foo n0 n (+ 1 c))\n                               )) (first nlst) (rest nlst) 1)\n            )","problem":100,"user":"50ae5659e4b0a40c9cfb08d2"},{"problem":100,"code":"(letfn [(gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))]\n  (fn [& ns]\n    (/ (apply * ns) (reduce gcd ns))))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn [& l]\n  (let [g #(if (= %2 0) %1\n             (recur %2 (mod %1 %2)))]\n    (/ (reduce #(/ (* %1 %2) (g %1 %2)) 1 (map #(if (integer? %1) %1 (numerator %1)) l))\n       (reduce g (map #(if (integer? %1) 1 (denominator %1)) l)))))","problem":100,"user":"538d8bb8e4b0b51d73faae71"},{"code":"(fn [& v] (reduce\r\n  (fn lcm [n m]\r\n    (let [gcd #(if (= 0 %2) % (recur %2 (mod % %2)))\r\n          rat #(if (integer? %) [% 1] [(numerator %) (denominator %)])\r\n          [nn dn] (rat n) [nm dm] (rat m)]\r\n      (if (= 1 (* dn dm)) (/ (* n m) (gcd n m))\r\n                          (/ (lcm nn nm) (gcd dn dm))))) v))","problem":100,"user":"50336c6be4b0c6c1199c710f"},{"problem":100,"code":"(fn lcm [& x]\n (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n  (reduce #(/ (* % %2) (gcd % %2)) x)))","user":"5b61aa6ae4b0c6492753e712"},{"problem":100,"code":"(fn [x & xs]\n  (let [ys (iterate #(+ x %) x)]\n    (first (drop-while #(< 0 (apply + (map (fn [y] (rem % y)) xs))) ys))))","user":"551c66dae4b07993ea3788de"},{"problem":100,"code":"(fn\n  [& xs]\n  (loop [test-val (apply max xs)]\n    (if (every? #(zero? (mod test-val %)) xs)\n      test-val\n      (recur (+ test-val (apply max xs))))))","user":"54e0e911e4b024c67c0cf7bc"},{"problem":100,"code":"(fn [& args]\n  (let [sets (->> args\n                  (map (fn [a] (->> (range 1 1000)\n                                    (map #(* a %))\n                                    (set)))))]\n    (->> sets\n         (rest)\n         (reduce clojure.set/intersection (first sets))\n         (sort)\n         (first))))","user":"60aecd73e4b00e9e6653c49a"},{"code":"#(reduce (fn lcm [a b]\n            (/ (* a b)\n               ((fn gcd [x y]\n                  (if (zero? y)\n                    x\n                    (recur y (mod x y))))\n                a b)))\n          %&)","problem":100,"user":"513dcc1ce4b0825f97f7f964"},{"problem":100,"code":"(fn [& args]\n  (let [gcd-func (fn [a b]\n                   (if (< a b)\n                     (recur b a)\n                     (if (= 0 (mod a b))\n                       b\n                       (recur b (mod a b)))))\n       gcd (reduce gcd-func args)]\n   (/ (reduce * args) gcd)))","user":"4f041de1535dcb61093f6ba5"},{"problem":100,"code":"(fn [& coll] (reduce (fn [a b] (/ (* a b) ((fn [x y] (if (zero? y) x (recur y, (mod x y)))) a b))) coll))","user":"5d47f4dbe4b07c84aa5ae6b5"},{"problem":100,"code":"(fn get-lcm [x y & args]\n (let [get-gcd (fn [x y]\n                 (cond\n                  (< x y) (recur y x)\n                  (= 0 (rem x y)) y\n                  :else (recur y (rem x y))))\n       a (get-gcd x y)\n       q (/ (* x y) a)]\n   (if-not (seq args)\n     q\n     (apply get-lcm q args))))","user":"55d29fb6e4b0e31453f64a59"},{"problem":100,"code":"(fn lcm [& args]\n  (loop [coll args]\n    (if (apply = coll)\n      (first coll)\n      (let [mn (apply min coll)\n            idxs (remove nil? (map-indexed (fn [i e] (if (= e mn) i)) coll))\n            ind (first idxs)]\n        (recur (map-indexed (fn [i e] \n                              (if (= ind i)\n                                (+ e (nth args ind))\n                                e))\n                              coll))))))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn lcm [& divs]\r\n    (let [is-multiple (fn is-multiple [num] \r\n                        (every? #(== 0 (rem num %)) divs))\r\n          mindiv (apply min divs)\r\n          countup (map inc (range))\r\n          candidates (map #(* % mindiv) countup)]\r\n      (first (filter is-multiple candidates))))","problem":100,"user":"4e7dfd48535db169f9c796fa"},{"code":"(fn [a & r]\n  (loop [n a]\n    (if (every? #(= 0 (rem n %)) r)\n      n\n      (recur (+ n a)))))","problem":100,"user":"4fde492be4b05e33b9224f8a"},{"problem":100,"code":"(fn [& args]  ;; lifted from qiuxiafei\n  (letfn [(gcd [x y]\n            (let [a (max x y)\n                  b (min x y)\n                  m (mod a b)]\n              (if (zero? m)\n                b\n                (recur b m))))\n          (lcm [a b]\n            (/ (* a b) (gcd a b)))]\n    (reduce lcm args)\n    ))","user":"5fb8fe30e4b03f550f448223"},{"code":"(fn [& args]\n  (let [itr (fn [n] (iterate #(+ n %) n))]\n  (reduce\n    #(first\n      (drop-while\n        (fn [x] \n          (not-any? \n            (fn [y] (= y x)) \n            (take-while (fn [y] (>= x y)) (itr %1))))\n        (itr %2))) args)))","problem":100,"user":"4e6fa38b535d5021c1a89622"},{"problem":100,"code":"(fn [& a]\n  (let [[b & s] (reverse (sort a))\n        r (iterate (partial + b) b)]\n    (first (filter\n            (fn [v] (every?\n                     #(zero? (rem v %))\n                     s))\n            r))))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn lcm [& args]\r\n  (let [lcm-int (fn [args acc]\r\n                  (let [values (map second acc)\r\n                        [min-index min-value] (apply min-key second acc)\r\n                        orig-min-value (args min-index)]\r\n                    (if (every? (partial = (first values))\r\n                                values)\r\n                      min-value \r\n                        (recur args\r\n                               (assoc acc\r\n                                      min-index\r\n                                      [min-index (+ min-value orig-min-value)]))  \r\n                      )))             \r\n        indexed (vec  \r\n                  (map #(vector %1 %2)\r\n                       (range)\r\n                       args))]\r\n    (lcm-int (vec args) indexed)\r\n    ) \r\n  )","problem":100,"user":"4dc537fd535d8a4b2fd74282"},{"problem":100,"code":"(fn [& nums]\n  (let [seed ((comp first sort) nums)]\n    (first\n      (filter (fn [n] (every? #(= 0 (mod n %)) nums))\n              (iterate #(+ % seed) seed)))))","user":"53571732e4b04ce2eb3ed275"},{"problem":100,"code":"(fn [& nums]\n\t(let [gcd (fn [a b]\n\t\t\t\t(if (zero? b)\n\t\t\t\t\ta\n\t\t\t\t\t(recur b (mod a b))))]\n\t\t(reduce (fn [a b] (* (/ a (gcd a b)) b)) nums)))","user":"57644395e4b0994c1922fbf2"},{"code":"(fn [& l]\n  (reduce \n    (fn [a b]\n      (let [a   (if (> a 0) a (- a))\n            b   (if (> b 0) b (- b))\n            gcd #(cond (= %1 %2) %1\n                       (> %1 %2) (recur (- %1 %2) %2)\n                       :else     (recur (- %2 %1) %1))\n            m (* a b)]\n        (/ m (gcd a b))))\n    l))","problem":100,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn [& s]\n  (reduce\n    #(loop [a % b %2]\n      (if (= 0 b)\n        (/ (* % %2) a)\n        (recur b (mod a b))))\n  s))","problem":100,"user":"4ef77c82535dced4c769f253"},{"code":"(fn [& args] \n  (/\n    (apply * args)\n    (reduce #(if (zero? %2) %1 (recur %2 (mod %1 %2))) args)))","problem":100,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn lcm [& args]\n  (/ (reduce * args)\n     (reduce (fn [m n] (if (zero? n) m (recur n (mod m n)))) args)))","problem":100,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn [n & args]\n    (loop [r n]\n      (if (zero? (reduce #(+ % (rem r %2)) 0 args))\n        r\n        (recur (+ r n))\n        )\n      )\n    )","problem":100,"user":"52b577c9e4b0c58976d9ad39"},{"problem":100,"code":"(fn [& nums]\n    (let [min (apply min nums)]\n      (loop [i min]\n        (if (->> (vec nums) (map #(rem i %)) (reduce +) (= 0))\n          i\n          (recur (+ i min)))\n        )))","user":"5aefdc8de4b0cc2b61a3bc40"},{"problem":100,"code":"(fn lcm [& x]\n  (let [gcd (fn [a b] (loop [a a b b] (if (zero? b) a (recur b (mod a b)))))]\n    (reduce (fn [a b] (/ (* a b) (gcd a b))) x)))","user":"5d5166d9e4b0776584bd6f5e"},{"problem":100,"code":"(fn [& nums]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        lcm (fn [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nums)\n  ))","user":"5c30d90de4b0d62ef62d9f22"},{"problem":100,"code":"(fn [& x]\n    (/ \n     (apply * x)\n     (reduce (fn [a b]\n               (cond (= a 0) b\n                \t (<= a b) (recur (- b a) a)\n                     :else (recur b a))) \n             x)))","user":"55dab408e4b0e31453f64ad9"},{"problem":100,"code":"(fn [& numbers] (loop [s (map vector numbers numbers)] \n\t(let [b (map #(nth % 1) s) m (apply min b)]\n\t\t(if (= 1 (count (distinct b))) (first b)\n\t\t(recur (map (fn [x] (if (= m (nth x 1)) [(first x) (+ (first x) (nth x 1))] x)) s))\n\t)\n)))","user":"59a0262ee4b0871e7608b82d"},{"problem":100,"code":"(fn [& x]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))\n          (lcm [a b]\n               (/ (* a b) (gcd a b)))]\n    (reduce lcm x)))","user":"52c672e2e4b0c2d177d6210e"},{"problem":100,"code":"(fn kpk-paul [a & l]\n  (first (filter (fn [x] (every? #(= 0 (rem x %)) l)) (iterate #(+ a %) a))))","user":"56278266e4b00e49c7cb47d3"},{"problem":100,"code":"(fn lcm\n  [& ns]\n  (reduce (fn [a b]\n            (first (drop-while #(or (not= 0 (rem % a))\n                                    (not= 0 (rem % b))) (iterate (partial + a) a)))) ns))","user":"55a9e0fee4b0988bba2ad945"},{"problem":100,"code":"(fn lcm [a b & xs]\n  (letfn [(gcd [a b]\n            (cond\n              (= a b) a\n              (< a b) (gcd (- b a) a)\n              :else (gcd b (- a b))))]\n    (let [lcmab (/ (* a b) (gcd a b))]\n      (if (empty? xs)\n        lcmab\n        (apply lcm lcmab xs)))))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn [& args] (let \r\n                [num (fn [n] (if (ratio? n) (numerator n) n)) \r\n                 den (fn [n] (if (ratio? n) (denominator n) 1))\r\n                 n (map num args)\r\n                 d (map den args)\r\n                 lcm (first (filter (fn [x] (every? #(= (mod x %) 0) n)) (iterate inc 1)))\r\n                 gcd (first (filter (fn [x] (every? #(= (mod % x) 0) d)) (range (apply max d) 0 -1)))] \r\n                (/ lcm gcd)))","problem":100,"user":"4feada56e4b0140c20fb9c11"},{"problem":100,"code":"(fn [& xs] (loop [ms (map #(map * (repeat %) (iterate inc 1)) xs)]\n             (let [vs (map first ms) m (apply max vs)]\n               (if (apply = vs) m (recur (map (partial drop-while #(< % m)) ms))))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":100,"code":"(fn [& body]\n  (reduce #(* %1 (denominator (/ %1 %2))) body))","user":"5a95c639e4b0d174b936c75e"},{"problem":100,"code":"#(letfn [(gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))\n         (lcm [a b]\n           (/ (* a b) (gcd a b)))]\n  (reduce lcm %&))","user":"5152bc4ee4b001f44f99bfef"},{"problem":100,"code":"(fn [init & args]\n(reduce (fn [x y]\n  ((fn GCD [a b]\n    (if (zero? (mod a b))\n      (/ (* x y) b)\n      (GCD b (mod a b)))) x y)) init args))","user":"57f8ba80e4b0d3187e90092f"},{"problem":100,"code":"(fn [& args]\n  (let [lcm (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (/ (reduce * args) (reduce lcm args))))","user":"57213df6e4b0c5bde472c0ab"},{"code":"(fn [& nums]\n  (letfn [(gcd [a b]\n            (if (= a b)\n              a   \n              (recur (- (max a b) (min a b)) \n                     (min a b))))\n          (denoms [coll]\n            (map #(if (ratio? %)\n                    (denominator %)\n                    1)  \n                 coll))]\n    (let [dg (reduce gcd (denoms nums))\n          nc (map * nums (repeat dg))\n          ng (reduce gcd nc)]\n      (/ (reduce * nc) ng dg))))","problem":100,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn [& nums]\n  (letfn [(gcd [a b]\n            (cond (< a b)   (recur b a)\n                  (zero? b) a\n                  :else     (recur b (mod a b))))\n          (lcm [a b] (/ (* a b) (gcd a b)))]\n    (reduce lcm nums)))","problem":100,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":100,"code":"(fn [& more]\n  (let [lcm (fn h [a b]\n              (let [gcd (fn helper [x y]\n                          (if (= y 0) x\n                              (helper y (mod x y))))] (/ (* a b) (gcd a b))))]\n    (reduce lcm more)))","user":"5414b7c4e4b01498b1a719ed"},{"code":"(fn [x & xs]\n  (let [f (fn [x] (map #(* x %) (drop 1 (range))))\n        m (f x)\n        o (fn [x] #(= 0 (mod % x)))]\n    (first (drop-while (fn [k] (not-every? #((o %) k) xs)) m))))","problem":100,"user":"4daf907aedd6309eace4d17b"},{"problem":100,"code":"(fn [& numbers]\n  (loop [new-seq (into [] numbers)]\n    (if (every? #(= (first new-seq) %) new-seq)\n      (first new-seq)\n      (let [min-pos (second (apply min-key first (map vector new-seq (range (inc (count new-seq))))))]\n          (recur (assoc new-seq min-pos (+ (get new-seq min-pos) (get (into [] numbers) min-pos))))))))","user":"607a1523e4b0a637ed78036a"},{"code":"(fn [& s]\n  (let [m (apply max s)]\n    (first (drop-while\n            (fn [l]\n              (not-every? true? (map #(zero? (mod l %)) s)))\n            (iterate #(+ m %) m)))))","problem":100,"user":"5256627ce4b0541d1855ba1a"},{"code":"(fn [e & r]\r\n  ((fn f [p]\r\n     (if (every? #(= (mod p %) 0) r)\r\n       p\r\n       (f (+ p e))))\r\n   e))","problem":100,"user":"4e5af6d7535d8a8b8723a2b2"},{"problem":100,"code":"(fn [& nums]\n   (reduce #(/ (* %1 %2) ((fn gcd\n                            [f s]\n                            (if (= s 0)\n                              f\n                              (gcd s (mod f s)))) %1 %2)) nums))","user":"56c60b36e4b05cc29241eead"},{"code":"(fn lcm [& nums]\n  (let [smallest (apply min nums)\n        multiples (iterate #(+ smallest %) smallest)]\n    (first (drop-while \n      (fn [candidate] (not (every? zero? (map #(mod candidate %) nums))))\n      multiples))))","problem":100,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":100,"code":"(fn lcm\n  ([a] a)\n  ([a b & cs]\n  \t(let [gcm (fn [a b] (if (zero? b) a (recur b (mod a b))))\n          lcm_ab (/ (* a b) (gcm a b))]\n      (apply lcm (cons lcm_ab cs)))))","user":"553dd883e4b0a04f792994e6"},{"problem":100,"code":"(fn [& args]\n   (/ (reduce * args) \n      (reduce (fn [a b] (if (= b 0) a (recur b (mod a b)))) args)))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":100,"code":"(fn [& nums] (let [max-in (apply max nums)]\n              (loop [x max-in\n                     filtered []]\n                (if (= (count filtered) (count nums))\n                  (- x max-in)\n                  (recur\n                    (+ x max-in)\n                    (filter #(= 0 (rem x %)) nums))))))","user":"55c13e73e4b01b9910ae2a2f"},{"problem":100,"code":"#(letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n         (lcm [a b] (/ (* a b) (gcd a b)))]\n   (reduce lcm %&))","user":"54d341f7e4b0e8a36923e603"},{"problem":100,"code":"(fn [& xs]\n  ((fn f [ys c b]\n     (if (every? #(zero? (mod c %)) ys)\n       c\n       (f ys (+ c b) b)))\n   xs\n   (apply min xs)\n   (apply min xs)))","user":"56483562e4b0284900eef629"},{"code":"(fn lcm [a b & more]\n  (if (empty? more)\n    (/\n     (* a b)\n     (loop [c a d b]\n       (if (= d 0)\n         c\n         (recur d (mod c d)))))\n    (apply lcm (lcm a b) more)))","problem":100,"user":"528bba38e4b0239c8a67aea9"},{"problem":100,"code":"(fn lcm [& args]  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n  (/ (reduce * args) (reduce gcd args)))\n  )","user":"5f96fa49e4b0715f5002d7e9"},{"problem":100,"code":"(fn lcms [& input]\n   (let [gcd (fn [x y] (if (= 0 y) x (recur y (mod x y))))\n         lcm (fn [x y] (/ (* x y) (gcd x y)))]\n     (reduce lcm input)))","user":"546b24a0e4b00cfc9eacc166"},{"code":"(fn lcm[& nums]\n   (let [gcd (fn gcd [l r](cond\n              (= 0 l) r\n              (= 0 r) l\n              (= l r) r\n              (> l r) (gcd (- l r) r)\n              (> r l) (gcd (- r l) l)))]\n     (let [f (first nums)\n           n (fnext nums)\n           l (/ (* f n) (gcd f n))]\n       (if (= 2 (count nums)) l\n           (apply lcm (cons l (rest (rest nums))))))))","problem":100,"user":"4fb86dc9e4b081705acca2d8"},{"problem":100,"code":"(fn [& xs]\n  (letfn\n    [(gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))\n     (lcm [a b]\n          (/ (* a b)\n            (gcd a b)))]\n    (reduce lcm xs)))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn lcm-mult [& args]\n  (letfn [(gcd [a b]\n            (loop [a a b b]\n              (let [[lrg sma] (reverse (sort [a b]))]\n                (if (= lrg sma) lrg\n                  (recur (- lrg sma) sma)))))\n          (lcm [a b]\n             (/ (* a b) (gcd a b)))]\n    (reduce lcm args)))","problem":100,"user":"52463059e4b09dbe66b56198"},{"code":"(fn __ [& coll]\n  (letfn [(lcm [a b] (/ (* a b) (gcd a b)))\n          (gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n                (/ (reduce #(lcm %1 %2) (map #(if (ratio? %) (numerator %) %) coll))\n                   (reduce #(gcd %1 %2) (map #(if (ratio? %) (denominator %) 1) coll)))))","problem":100,"user":"506cad7de4b0a302964c548e"},{"code":"(fn [& n]\n  (letfn\n[(nom [n]\n  (if (ratio? n)\n    (numerator n)\n    n))\n\n(denom [n]\n  (if (ratio? n)\n    (denominator n)\n    1))\n\n(gcd [a b]\n  (if (= b 0)\n    a\n    (gcd b (rem a b))))\n\n(lcm [a b]\n  (/ (* a b)\n     (gcd a b)))\n\n(ratgcd [a b]\n  (/ (gcd (nom a) (nom b))\n     (lcm (denom a) (denom b))))\n\n(ratlcm [a b]\n  (/ (* a b)\n     (ratgcd a b)))]\n(reduce ratlcm n)))","problem":100,"user":"4db0114d838c48654951d9b8"},{"problem":100,"code":"(fn [& a]\n  (loop [m a]\n    (if (apply = m)\n      (first m)\n      (recur (map (fn [v x] \n                    (if (every? (fn [i] (<= i v)) m)\n                      v\n                      (+ v x))) m a)))))","user":"55316b8ae4b076ab5578f825"},{"problem":100,"code":"(fn lcm [& nums]\n  (reduce #(/ (* %1 %2) ((fn gcd [a b]\n  (cond\n    (= a b) a\n    (> a b) (recur (- a b) b)\n    :else (recur a (- b a)))) %1 %2)) nums))","user":"5c195cb2e4b01240ff5671f7"},{"code":"(fn [& xs] ((fn lcm [x x0]\n            (cond (apply = x) (first x)\n                  :else\n                    (lcm (map #(if (= (apply min x) %) (+ % %2) %) x x0) x0)\n            )\n           ) xs xs))","problem":100,"user":"51e1a1fae4b06a68e693eaf6"},{"problem":100,"code":"(fn lcm [h & [ft & t]] \n  (if (nil? ft) \n    h \n    (apply lcm \n           (cons \n            (/ (* h ft) \n               ((fn [a b] \n                  (if (zero? b) \n                    a \n                    (recur b (mod a b)))) h ft)) t))))","user":"53f3a4ace4b0742d9025b0f7"},{"problem":100,"code":"(fn [& args]\n  (letfn [(gcd [a b]\n               (if (zero? b) a\n                 (recur b (mod a b))))\n          (lcm ([a b] (/ (max (- (* a b)) (* a b))\n                         (gcd a b)))\n               ([a b & rest]\n                (lcm a (apply lcm b rest))))]\n    (apply lcm args)))","user":"4f748b54e4b044e54cd9a8fa"},{"code":"(fn lcm [& args]\n    (first (sort\n     (reduce clojure.set/intersection\n\t     (for [i args]\n\t         (set (take 360 \n                     (map (partial * i) (iterate inc 1))\n                     ))\n\t\t    )\n     )\n   )\n )\n)","problem":100,"user":"528f4462e4b0239c8a67aef0"},{"code":"(fn [& input]\n  ((fn lcm [l]\n    (if (apply = (flatten (map #(first %) l)))\n               (first (first l))\n    (let [lr (sort #(compare (first %1) (first %2)) l)]\n      (lcm (conj (rest lr) (vector (+ (first (first lr)) (second (first lr))) (second (first lr)))))))   \n  )\n  (map #(vector % %) input)))","problem":100,"user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn lcm [& seq]\n  (let [n (for [x seq] (if (= clojure.lang.Ratio (class x)) (numerator x) x))\n        d (for [x seq] (if (= clojure.lang.Ratio (class x)) (denominator x) 1))\n        gcd (fn gcd [& seq]\n              (if (= 2 (count seq))\n                (let [[a b] seq]\n                 (cond\n                   (= a b) a\n                   (> a b) (gcd b a)\n                   (zero? a) b\n                   :else (gcd (mod b a) a)))\n                (reduce gcd seq)))]\n    (/\n     (/ (apply * n) (apply gcd n))\n     (apply gcd d))))","problem":100,"user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn tmp [x & lst] \n    (if (empty? lst) x\n      (recur  \n        (first \n          (drop-while \n              #(not= (mod %1 (first lst)) 0) \n              (iterate (partial + x) x)))\n          (rest lst))))","problem":100,"user":"4dbdab4e535d020aff1edf49"},{"code":"(fn [& xs]\n  (let [t (first xs)]\n    (loop [m 1]\n      (let [n (* m t)\n            multiple? (fn [x] (zero? (mod n x)))]\n        (if (every? multiple? xs)\n            n\n            (recur (inc m)))))))","problem":100,"user":"4daf36c2edd6309eace4d175"},{"code":"(fn [& args] \r\n  (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))\r\n          (lcm [x y] (/ (* x y) (gcd x y)))]\r\n    (reduce lcm args)))","problem":100,"user":"4db4714f535dc0f10411755a"},{"code":"(fn lcm [head & tail]\n  (let [rhead (iterate #(+ % head) head)]\n    (some #(if (every? (fn [e] (zero? (rem % e))) tail) %) rhead)))","problem":100,"user":"528b08efe4b0239c8a67ae8a"},{"problem":100,"code":"(fn [& args]\n  (let [ratios (map #(if (ratio? %) % (clojure.lang.Numbers/toRatio (rationalize %))) args)\n        n (map numerator ratios)\n        d (map denominator ratios)\n        gcd   (fn gcd [& args]\n                (let [x (first args)\n                      y (second args)\n                      r (drop 2 args)]\n                  (if (= 0 y)\n                    (if (> (count args) 2) (apply gcd (concat [x] r)) x)\n                    (apply gcd (concat [y (rem x y)] r)))))\n        lcm (fn [& args]\n                (/ (apply * args) (apply gcd args)))]\n    (/ (apply lcm n) (apply gcd d))))","user":"58b86162e4b0ebc645576d97"},{"code":"(fn lcm [& nums]\n  (letfn [(gcd [a b]\n            (let [divisor (min a b) dividend (max a b) remainder (rem dividend divisor)]\n              (if (zero? remainder)\n                divisor\n                (gcd remainder divisor))))]\n    (/ (reduce * nums) (reduce gcd nums))))","problem":100,"user":"4e95a440535dbda64a6f6b37"},{"code":"(fn lcm [& args]\r\n  (/ (apply * args)\r\n     (reduce #(if (zero? %) %2 (recur (mod %2 %) %)) args)))","problem":100,"user":"509c03f3e4b085ae113522a8"},{"problem":100,"code":"(fn [x & xs] \n(loop [x x \n      xs xs \n      c (range x 10000 x)]\n  (if (empty? xs)\n    (first (remove #(not= 0 (mod % x)) c))\n    (recur (first xs) (rest xs) \n      (remove #(not= 0 (mod % x)) c)))))","user":"59ef5280e4b0966464fe6a2b"},{"code":"(fn [x & xs]\n  (loop [y x]\n    (if (every? #(zero? (mod y %)) xs)\n      y\n      (recur (+ y x)))))","problem":100,"user":"4f07c8c3535dcb61093f6c2d"},{"code":"(fn [& factors]\n           (letfn [(abs [n] (if (neg? n) (- n) n))\n                   (gcd [a b]\n                     (cond (< b a) (gcd (- a b) b)\n                           (< a b) (gcd a (- b a))\n                           :else a))\n                   (lcm [a b] (/ (abs (* a b)) (gcd a b)))]\n             (reduce lcm factors)))","problem":100,"user":"4e5f034b535d8a8b8723a2d9"},{"code":"(fn this\n  ([a b] \n   (let [gcd (fn this2 [a b] \n               (if (< a b)\n                 (this2 b a)\n                 (if (= b 0) a (this2 (mod a b) b)))\n               )]\n     (/ (* a b) (gcd a b))))\n  ([a b & others] \n   (if (empty? others) \n     (this a b)\n     (this a (apply this b others)))))","problem":100,"user":"4ec12577535dfed6da9c6da8"},{"code":"(fn [& args]\n  (reduce (fn [a b] (/ (* a b) ((fn gcd [x y]\n  (let [[a b] (sort [x y])]\n    (if (= 0 a)\n     b\n     (gcd (- b a) a)))) a b))) args))","problem":100,"user":"4eaa96e1535d7eef3080730d"},{"code":"(fn lcm [x y & more]\n  (let [val (first (filter #(zero? (rem % y)) \n                (map #(* % x) (iterate inc 1))))]\n    (if more\n      (apply lcm val more)\n      val)))","problem":100,"user":"4dac39a28cc9d6edb8beb0b3"},{"problem":100,"code":"(fn least-common-multiple\n  [& nums]\n  (let [smallest (apply min nums)]\n    (loop [x smallest]\n      ;; if all are evenly divisible we found our solution\n      (if (= (reduce + (map (partial mod x) nums)) 0)\n        x\n        (recur (+ x smallest))))))","user":"56175cf9e4b06b1bb2182a0f"},{"problem":100,"code":"(fn [& a] (loop [x (apply min a) i x] (if (= 0 (reduce + (map (partial mod i) a))) i (recur x (+ x i)))))","user":"53b15e6ee4b047364c04448f"},{"problem":100,"code":"(fn [& more]\n   (letfn [(gcd [left right]\n             (let [a (if (> left right) left right)\n                   b (if (< right left) right left)\n                   rem (rem a b)]\n               (if (= rem 0)\n                 b\n                 (gcd b rem))))\n           (lcm [a b]\n             (/ (* a b) (gcd a b)))]\n     (let [b (first more)]\n       (reduce lcm more))))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn gcm [& args]\n  (let [ratios (filter ratio? args)\n        wholes (filter #(not (ratio? %)) args)\n        nums-and-denoms (concat (map numerator ratios)\n                                (map denominator ratios))\n        end (apply * (concat wholes nums-and-denoms))\n  cnt (count args)]\n    (first\n     (first\n      (filter #(= cnt (count %))\n\t      (partition-by\n               identity\n               (sort\n                (mapcat (fn [x] (take end (iterate #(+ x %) x))) args))))))))","problem":100,"user":"4ee9d697535d93acb0a66895"},{"code":"(fn [& ns]\n  (let [step (apply max ns)\n        pred #(every? zero? (map (partial mod %) ns))]\n  \t(first (filter pred (iterate (partial + step) step)))))","problem":100,"user":"4ef77edb535dced4c769f254"},{"problem":100,"code":"(fn [& args] \n  (let [mcm (fn [n m] \n              (if (zero? m) \n                n \n                (recur m (mod n m))))]\n    (/ (reduce * args) (reduce mcm args))))","user":"5f7e91c8e4b0c071e6c840d8"}]