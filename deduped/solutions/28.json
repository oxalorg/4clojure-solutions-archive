[{"problem":28,"code":"(fn[x]  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"574ed2f7e4b02ea11479924a"},{"code":"(fn my-flatten\n  [coll]\n  (let [f (first coll)\n        n (next coll)\n        r '()]\n    (if (nil? f)\n      r\n      (if (coll? f)\n        (concat r (my-flatten f) (my-flatten n))\n        (concat r (list f) (my-flatten n))))))","problem":28,"user":"4e5a460f535d8a8b8723a2ab"},{"problem":28,"code":"(fn flatten* [[h & t]]\n  (if h\n    (if (coll? h)\n      (concat (flatten* h) (flatten* t))\n      (cons h (flatten* t)))))","user":"5d370811e4b01671435dbd2d"},{"code":"#((fn flat [colldst src] (cond (coll? src) (reduce flat colldst src ) :else (conj colldst src)) )  [] %)","problem":28,"user":"537bca8be4b06839e8705e71"},{"problem":28,"code":"(fn flat [c]\n  (if (sequential? c)\n    (mapcat flat c)\n    (list c)))","user":"4f4391a9e4b0d7d3c9f3fd23"},{"code":"(fn flat [coll]\n  (let [[x & xs] coll]\n    (if (nil? xs)\n      (if (coll? x)\n        (flat x)\n        (list x))\n      (if (coll? x)\n        (concat (flat x) (flat xs))\n        (cons x (flat xs))))))","problem":28,"user":"5225a0f5e4b01819a2de430e"},{"code":"#(letfn\n  [(fl [x]\n    (if (not (coll? x))  \n        (list x)\n        (apply concat (map fl x))))]\n  (fl %))","problem":28,"user":"50b668dde4b08fb537db98f2"},{"problem":28,"code":"(fn f [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5dfb7f6de4b0a607a9a45cdc"},{"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x)\n)\n)\n)","problem":28,"user":"4ee88f29535d93acb0a66882"},{"problem":28,"code":"(fn\n  [s]\n  (loop [s s, rez '[]]\n    (if (seq s)\n      (if (sequential? (first s))       \n          (recur (into (rest s) (first s)) rez)\n          (recur (rest s) (conj rez (first s))))\n      (sort rez))))","user":"56b2630be4b0982f16b37e03"},{"code":"(fn f [c]\n  (if (empty? c)\n    '()\n    (if (coll? (first c))\n      (concat (f (first c)) (f (rest c)))\n      (cons (first c) (f (rest c))))))","problem":28,"user":"52c45ac8e4b0c2d177d620d9"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (empty? coll)\n    '()\n    (let [f (first coll) r (rest coll)]\n      (if (coll? f)\n        (concat (my-flatten f) (my-flatten r))\n        (concat [f] (my-flatten r))\n      )\n    )\n  )\n)","user":"4eb9d8e0535dfed6da9c6d60"},{"problem":28,"code":"(fn my-flatten [coll]\n   (if (sequential? coll)\n     (mapcat my-flatten coll)\n     [coll]))","user":"58a413b5e4b02bd94d917f07"},{"problem":28,"code":"(fn\n   [x]\n   (filter (complement sequential?) (tree-seq sequential? identity x))\n   )","user":"60631c2ee4b069485764ddbd"},{"problem":28,"code":"(fn myFlatten [coll] \n  (reduce \n   (fn [acc colElem] \n     (if \n       (coll? colElem)\n       (concat acc (myFlatten colElem))\n       (concat acc [colElem])\n     )\n   )\n   '()\n   coll\n  )\n)","user":"5183bccae4b028ec5fd2f2aa"},{"problem":28,"code":"(fn f [n]\n  (let [[x & x-rest] n]\n    (cond\n      (empty? n) []\n      (coll? x) (concat (f x) (f x-rest))\n      :else (cons x (f x-rest)))))","user":"53a074a4e4b0ca733b9744af"},{"code":"(fn my-flat \n  ([coll] (my-flat coll (list)))\n    ([coll acc]\n\t  (let [blank? #(or (nil? %) (and (coll? %) (empty? %))) not-coll? #(not (coll? %))]\n\t  (cond (blank? coll) acc\n\t        (not-coll? coll) (cons coll acc)\n\t        :else (my-flat (first coll) (my-flat (rest coll) acc))))))","problem":28,"user":"4e6a4edd535d8ccf87e9fec4"},{"problem":28,"code":"(fn flat [l]\n  (if (coll? l)\n    (mapcat flat l)\n    [l]))","user":"559e25fde4b08a52bd4f97d0"},{"problem":28,"code":"(fn flat [coll]\n(let [f (first coll) n (next coll)]\n\t(concat (if (sequential? f) (flat f) [f] )\n\t\t\t(when (sequential? n) (flat n)  ) )))","user":"54be7e93e4b0ed20f4ff6eed"},{"problem":28,"code":";; Flatten\n(fn my-flat [seqable]\n  (loop [myseq seqable flatvec []]\n    (if (empty? myseq)\n      flatvec\n      (if (coll? (first myseq))\n        (recur (concat (first myseq) (rest myseq)) flatvec)\n        (recur (rest myseq) (conj flatvec (first myseq)))\n        )\n    )\n  )\n)","user":"5736e12ee4b0cd1946bd103a"},{"code":"(fn f [s]\n  (if (sequential? s)\n    (mapcat f s)\n    [s]))","problem":28,"user":"4e599577535d8a8b8723a29f"},{"code":"(fn flat [x]\n  (if\n    (or (seq? x) (list? x) (map? x) (vector? x))\n    (do \n        (if\n          (empty? x)\n          (seq x)\n          (concat (flat (first x)) (flat (rest x)))\n         )\n    )\n    (if (nil? x) '() (seq (list x)))\n  )\n)","problem":28,"user":"52b49aebe4b0c58976d9ad2b"},{"problem":28,"code":"(fn _flatten [x]\n  (if (coll? x)\n    (mapcat _flatten x)\n    [x]))","user":"56815e2fe4b0945ebc182a84"},{"problem":28,"code":"#(loop [remaining (reverse %) res '()]\n   (if (empty? remaining)\n     res\n     (if (sequential? (first remaining))\n       (recur (concat (reverse (first remaining)) (rest remaining)) res)\n       (recur (rest remaining) (conj res (first remaining))))))","user":"529f9bf2e4b04e0c58e87bb4"},{"problem":28,"code":"(fn my-flatten [x]\n  (cond\n   (coll? x) (mapcat my-flatten x)\n   :else [x]))","user":"55d5e80ee4b0e31453f64a91"},{"problem":28,"code":"(fn flt [[x & xs]]\n    (cond\n     (nil? x) '()\n     (sequential? x) (into  (flt xs) (reverse ( flt x)))\n     :else (cons x (flt xs))))","user":"548cd813e4b0e286459a1211"},{"code":"(fn flat0 [s]\n   (if(empty? s) '()\n   (if (or (vector? (first s)) (list? (first s)))\n    (concat (flat0 (first s)) (flat0 (rest s)))\n    (conj (flat0 (rest s)) (first s)))))","problem":28,"user":"51b73a91e4b0d906fcd71d33"},{"code":"(fn makeflat [x]\n  (if (empty? x)\n\t\tx\n\t\t(if (sequential? (first x))\n\t\t\t(concat (makeflat (first x)) (makeflat (rest x))) \n\t\t\t(cons (first x) (makeflat (rest x))))))","problem":28,"user":"4e9487fb535dbda64a6f6b14"},{"code":"(fn v [x] (if (coll? x) (mapcat v x) (list x)))","problem":28,"user":"524c7fcfe4b0752c4cb68cbd"},{"problem":28,"code":"(fn flat [l]\n\t(reduce \n\t   #(if (coll? %2)\n\t      (into %1 (flat %2))\n\t      (conj %1 %2)) [] l))","user":"53da3fcde4b0e771c3025497"},{"problem":28,"code":"(fn f [c]\n  (if-let [z (first c)]\n    (let [r (f (rest c))]\n      (if (coll? z)\n        (concat (f z) r)\n        (cons z r)\n        )\n      )\n    )\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":28,"code":"(fn flat [[frst & rst]] \n  (if (nil? frst)\n    nil\n    (if (coll? frst)\n      (into (into [] (flat frst)) (flat rst))\n      (into [frst] (flat rst)))\n    )\n)","user":"574e7be7e4b02ea114799242"},{"problem":28,"code":"(fn flat [coll]\n  (cond (empty? coll) coll\n        (coll? (first coll)) (concat (flat (first coll)) (flat (rest coll)))\n        :else (concat (list (first coll)) (flat (rest coll)))\n        ))","user":"5f4303cfe4b0955706451fb3"},{"code":"(fn flt [x] (if (empty? x)\n                      x \n                     (if (sequential? (first x))\n                         (concat (flt (first x)) (flt (rest x)))\n                         (concat (list (first x)) (flt (rest x)))\n                     )))","problem":28,"user":"50ac81b9e4b071b89ef2622f"},{"problem":28,"code":"(fn ! [xs] (if \n             (sequential? xs)\n             (reduce concat (map ! xs))\n             (list xs)))","user":"58bef28be4b021aa9917ecca"},{"problem":28,"code":"(fn [xs]\n  (if xs\n    (if (not (some coll? xs))\n      xs\n      (recur (mapcat (fn [e] (if (not (coll? e)) (list e) e)) xs)))\n    '()))","user":"5719465fe4b07c98581c3b36"},{"problem":28,"code":"(fn flat [s] (if (sequential? s)\n              (mapcat flat s)\n              [s]))","user":"5466aabbe4b01be26fd746e8"},{"code":"(fn [sss]\n  (letfn [(fl [ss]\n    (cond (nil? (seq ss)) '()\n          (coll? (first (seq ss)))\n            (concat (fl (first ss)) (fl (rest ss)))\n          :else \n            (conj (fl (rest ss)) (first ss))))]\n  (fl sss)))","problem":28,"user":"4e26e8b4535deb9a81d77ef6"},{"code":"(fn [s] (filter #(not (sequential? %)) (tree-seq sequential? seq s)))","problem":28,"user":"534b0598e4b084c2834f4a75"},{"problem":28,"code":"(fn my-flatten [inputList] \n\t(reduce \n\t\t(fn [alreadyFlattened item]\n\t\t\t(if (sequential? item)\n\t\t\t\t(concat alreadyFlattened (my-flatten item))\n\t\t\t\t(concat alreadyFlattened (list item) )\n\t\t\t))\n\t\t'() \n\t\tinputList))","user":"53c90510e4b00fb29b2212b6"},{"code":"(fn flat [[x & xs]]\n  (if (nil? x) \n    nil\n    (if (sequential? x)\n      (concat (flat x) (flat xs))\n      (cons x (flat xs)))))","problem":28,"user":"5156e767e4b04360f2428e6b"},{"code":"(fn fla [x] (let [s? #(instance? clojure.lang.Sequential %)] (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4dd4f0a8535dae65d5c462e4"},{"problem":28,"code":"(fn my-flatten [coll]\n   (let [[f & rest] coll]\n     (cond\n       (sequential? f) (my-flatten (concat f rest))\n       (not (nil? f)) (cons f (my-flatten rest)))))","user":"5889dc13e4b0f1effa3b774a"},{"code":"(fn [x]\n    (filter (complement sequential?)\n\t          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn mflat [lst]\n  (cond (empty? lst) ()\n        ((complement coll?) (first lst)) (cons (first lst) (mflat (rest lst)) )\n        :t (concat (mflat (first lst))\n                   (mflat (rest lst)))))","problem":28,"user":"4dd0e8f7535da60f04a96e57"},{"problem":28,"code":"(fn flatmap [x] (if (coll? x) (mapcat flatmap x) (list x)))","user":"598ad666e4b02b9968b84ce1"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (sequential? x) (mapcat my-flatten x)\n      [x]))","user":"57839ae9e4b0ebec4cfb74b8"},{"code":"(fn fl ([s] (sort (fl s ())))\n         ([s f]\n  (let [cur (first s) more (rest s) fin f]\n    (into\n      (if (empty? more) () (fl more fin))\n       (cond\n      (coll? cur) (fl cur fin)\n      :else (list cur))))))","problem":28,"user":"4f05a9cf535dcb61093f6bfc"},{"problem":28,"code":"(fn mpc\n  [coll]\n  (if (coll? coll)\n    (mapcat mpc coll)\n    [coll]))","user":"55bf6dbce4b01b9910ae2a12"},{"problem":28,"code":"(fn flat[l] \n  (loop [l (apply list l) nl []] \n    (if (empty? l)\n      nl  \n      (let [value (peek l)] \n        (recur (pop l) (if (coll? value) (apply conj nl (flat (apply list value))) (conj nl value)))\n        )   \n      )   \n    )   \n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (apply concat (map my-flatten s))\n    (list s)))","user":"56082adae4b046a4fc0ac008"},{"problem":28,"code":"(fn fl [coll]\n  (loop [result '() coll coll]\n       (if (empty? coll)\n         (reverse result)\n         (if (sequential? (first coll))\n           (recur (concat (reverse (fl (first coll))) result) (rest coll))\n           (recur (cons (first coll) result) (rest coll))))))","user":"5b13f482e4b0cc2b61a3be58"},{"code":"(fn fl [s]\n  (if (coll? s)\n    (mapcat fl s)\n    [s]))","problem":28,"user":"52d83c2ce4b09f7907dd138d"},{"problem":28,"code":"reduce\n(fn this [r i]\n  (if (sequential? i)\n    (reduce this r i)\n    (conj r i)))\n[]","user":"58923efce4b00487982d521c"},{"problem":28,"code":"(fn ff [x]\n(reduce (fn [a b] (if (coll? b)  (into [](concat a (ff b))) (conj a b))) [] x))","user":"5951190be4b066ee0a44aea4"},{"problem":28,"code":"(fn my-flat [coll]\n        (let [result []]\n          (if (empty? coll)\n            result\n            (let [x (first coll)]\n              (if (coll? x)\n                (concat result (my-flat x) (my-flat (next coll)))\n                (concat (conj result x) (my-flat (next coll))))))))","user":"532686e6e4b09d4e7a9b54ef"},{"code":"(fn myflatten [coll]\n        (cond\n\t\t(empty? coll) '()\n\t\t(sequential? (first coll)) (concat (myflatten (first coll)) (myflatten (rest coll)))\n\t\t:else (concat (list (first coll)) (myflatten (rest coll)))))","problem":28,"user":"4e949d18535dbda64a6f6b15"},{"code":"(fn flat [s]\n  (if (sequential? s)\n    (mapcat flat s)\n    (list s)\n    )\n  )","problem":28,"user":"506ab9bae4b05d3b7762c74c"},{"problem":28,"code":"(fn f [xs] (reduce #(if (coll? %2)\n                          (concat %1 (f %2))\n                          (concat %1 (list %2)))\n                       '()\n                       xs))","user":"58c4b11ae4b021aa9917ed2c"},{"code":"(fn fltn [coll]  \n  (mapcat  #(if (sequential? %) (fltn %) [%]) coll))","problem":28,"user":"53710c09e4b0fc7073fd6ea5"},{"code":"(fn flat [value] \n  (if (coll? value)\n    (cond (coll? (first value)) (concat (flat (first value)) (flat (rest value)))\n      (empty? value) value\n      :else (cons (first value) (flat (rest value))))\n    value))","problem":28,"user":"4fb266a5e4b081705acca28c"},{"problem":28,"code":"(fn make-flat [ls]\n  (if (sequential? ls)\n    (mapcat make-flat ls)\n    (list ls)))","user":"53ed1778e4b0d648e757f4bd"},{"code":"(fn [s]\n     (let [flattn (fn flattn [item]\n                      (if (sequential? item)\n                          (mapcat flattn item)\n                        [item]))]\n       (mapcat flattn s)))","problem":28,"user":"5256cd77e4b0541d1855ba39"},{"problem":28,"code":"(fn my-flatten [s]\n  (loop [s s]\n    (if (empty? (filter sequential? s))\n      s\n      (recur (mapcat #(if (sequential? %) % [%]) s)))))","user":"569f4dabe4b0542e1f8d1491"},{"code":"(fn X [y]\n  (reduce concat \n    (map (fn [x] (if(coll? x) (X x) [x])) y)\n  )\n)","problem":28,"user":"4fc7b079e4b0ee37620e1827"},{"code":"(fn [l]\n  (letfn [(flat [l]\n    (cond\n      (empty? l) nil\n      (or (list? (first l)) (vector? (first l))) (concat (flat (first l)) (flat (rest l)))\n      true (cons (first l) (flat (rest l)))))]\n  (flat l)))","problem":28,"user":"4ebc05a2535dfed6da9c6d7a"},{"code":"(fn unravel [xs]\n  (when-let [xs (seq xs)]\n    (if (coll? (first xs))\n        (concat (unravel (first xs)) (unravel (rest xs)))\n      (cons (first xs) (unravel (rest xs))))))","problem":28,"user":"53658ce7e4b0243289761e6e"},{"problem":28,"code":"(fn flt\n  [x]\n  (cond (nil? x)\n        \t()\n        (not (coll? x))\n        \tx\n        (not (coll? (first x)))\n        \t(cons (first x) (flt (next x)))\n        :else\n        \t(cond\n         \t\t(nil? (next (first x)))\n         \t\t\t(flt (cons (first (first x)) (next x)))\n         \t\t:else\n         \t\t\t(flt (cons (first (first x)) (cons (next (first x)) (next x)))))))","user":"518ba795e4b0f028e99addf0"},{"code":"(fn [s]\n  (let [n (transient [])\n\t   f (fn f [n s]\n           (cond (not (coll? s)) (conj! n s)\n                 (and (coll? s) (not (empty? s))) \n                 \t(do (f n (first s))\n                        (f n (rest s)))\n                 :else nil))]\n    (f n s)\n    (persistent! n)))\n\n;(fn my-flatten [coll]\n;   (if (some coll? coll)\n;     (recur(apply concat (map #(if (coll? %1) %1 (list %1)) coll)))\n;     coll))","problem":28,"user":"5370d152e4b0fc7073fd6e9d"},{"problem":28,"code":"(fn my-flatten [coll]\n        (cond\n         (empty? coll)\n         coll\n\n         (coll? (first coll))\n         (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n\n         :else\n         (cons (first coll) (my-flatten (rest coll)))))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":28,"code":"(fn flatten* [coll]\n  (if (coll? coll)\n    (mapcat flatten* coll)\n    [coll]))","user":"5e62444fe4b0fd0acd158694"},{"problem":28,"code":"(fn flat [s] (mapcat #(if (coll? %) (flat %) [%]) s))","user":"52f0ea04e4b05e3f0be25ee6"},{"problem":28,"code":"(fn f [in] (if (coll? in) (mapcat f in) (vector in)))","user":"57aa4752e4b0b8559636fc6a"},{"code":"(fn [coll]\n\t(reduce\n\t\t(fn custom-flatten [d s]\n\t\t\t(if (coll? s)\n\t\t\t\t(reduce custom-flatten d s)\n\t\t\t\t(conj d s)))\n\t\t[] coll))","problem":28,"user":"53036d2ce4b0d8b024fd3741"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x)\n    (mapcat flat x)\n    (list x)))","user":"54a0ae0fe4b0f3d1d8e70fb8"},{"code":"(fn flatten-original [x]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4fabbb97e4b081705acca21d"},{"code":"(fn [arg]\n    (loop [mylist arg, ret []]\n        (if (= mylist '()) \n            ret\n            (if (coll? (first mylist))\n                (recur (concat (first mylist) (rest mylist)) ret)\n                (recur (rest mylist) (conj ret (first mylist) ))  ))))","problem":28,"user":"4f2965ffe4b0d6649770a029"},{"problem":28,"code":"(fn my-flatten [[x & xs]]\n  (println x \":\" xs)\n  (concat (if (sequential? x)\n            (my-flatten x)\n            [x])\n          (if (nil? xs)\n            nil\n            (my-flatten xs))))","user":"5483d59fe4b0e286459a1194"},{"code":"(fn flat [xs]\n  (if (empty? xs)\n    '()\n      (if (coll? (first xs))\n        (apply conj (flat (rest xs)) (reverse (flat (first xs))))\n        (conj (flat (rest xs)) (first xs)))))","problem":28,"user":"53120cb5e4b08068f379ecf0"},{"code":"(fn my-flatten2 [n]\n  (let [[x & xs] n]\n    (cond\n      (empty? n) '()\n      (coll? x) (concat (my-flatten2 x) (my-flatten2 xs))\n      :else (cons x (my-flatten2 xs)))))","problem":28,"user":"4f9ff06ce4b0dcca54ed6d41"},{"code":"(fn flatten1 [seq]\n  (if (empty? seq) \n    ()\n    (let [h (first seq)\n          t (flatten1 (rest seq))]\n      (if (coll? h) \n        (concat (flatten1 h) t) \n        (cons h t)\n        ))))","problem":28,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":28,"code":"(fn flatten2 [x] (if (coll? x) (reduce concat (map flatten2 x)) [x]))","user":"550320f8e4b086ebe8a79c68"},{"problem":28,"code":"(fn f [coll]\n  (if-let [x (first coll)]\n    (if (coll? x)\n      (concat (f x) (f (rest coll)))\n      (cons x (f (rest coll))))\n    '()))","user":"55ed1575e4b0121d4835fdd3"},{"code":"(fn flat [s]\n  (if (coll? s)\n      (reduce concat () (map flat s))\n      (list s)))","problem":28,"user":"4f567cdbe4b0a7574ea71824"},{"code":"(fn [n]\n  (filter (complement sequential?)\n(rest (tree-seq sequential? seq n))))","problem":28,"user":"4e5d2dc5535d8a8b8723a2ca"},{"code":"(fn bla[s] (mapcat #(if (coll? %) (bla %) [%]) s))","problem":28,"user":"5093ca51e4b097f48cc38585"},{"problem":28,"code":"(fn flat [x] \n      (if (coll? x)\n        (mapcat flat x)\n        (list x)))","user":"50b25edae4b03ea88043355e"},{"code":"(fn flat [x] (if (coll? x) (mapcat flat x) (list x)))","problem":28,"user":"51836944e4b028ec5fd2f29f"},{"code":"(fn flat[s]\n    (when-let [el (first s)]\n      (if (sequential? el)\n          (concat (flat el) (flat (rest s)) )\n          (cons el (flat (rest s))))))","problem":28,"user":"5018ed15e4b011a2e0bf6412"},{"problem":28,"code":"(fn flat \n  ([xs]\n   (flat xs []))\n  ([[x & xs] acc]\n    (cond (coll? x) (recur (concat x xs) acc)\n          x (recur xs (conj acc x))\n          :else acc)))","user":"5705f569e4b0b0fb43fd0677"},{"problem":28,"code":"(fn flat [arr]\n  (let [[x & xs] arr]\n    (cond \n     (empty? arr) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs))\n    )\n  )\n)","user":"59449aa2e4b0b03edd0057ad"},{"problem":28,"code":"(fn flat\n  [s]\n  (if (coll? s) (reduce concat (map flat s)) [s]))","user":"54dae16de4b024c67c0cf758"},{"code":"(fn fl\n   ([x]\n      (filter (complement sequential?)\n              (rest (tree-seq sequential? seq x)))))","problem":28,"user":"51d28e15e4b0d13b04db0d9b"},{"problem":28,"code":"(fn flttn [s]\n  (mapcat (fn [x] (if (coll? x)\n                    (flttn x)\n                    [x])) s))","user":"5e21c933e4b05b4b01516128"},{"code":"#(letfn [(worker [x n]\r\n           (if (empty? x)\r\n             n\r\n             (recur (rest x) (if (coll? (first x)) (worker (first x) n)  (conj n (first x))))))]\r\n   (worker % []))","problem":28,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn willsflatten [x]\n  (cond\n   (= '() x) '()\n   (coll? x) (concat (willsflatten (first x)) (willsflatten (rest x)))\n   :else (list x)))","problem":28,"user":"5221c0cae4b0e6a83c8925e1"},{"problem":28,"code":"(fn flat[s]\n  (if (coll? s)\n    (mapcat flat s)\n    [s]))","user":"5d089304e4b0cc9c9158820b"},{"problem":28,"code":"(fn my-flat \n  [xs]\n    ; flattens a sequence\n  (lazy-seq\n   (reduce (fn holdon [col v]\n             (if (sequential? v)\n               (reduce holdon col v)\n               (conj col v))) [] xs)))","user":"5bbbd077e4b0a20761a23615"},{"problem":28,"code":"(fn f\n  ([xs] (f xs []))\n  ([xs acc] (if (coll? xs)\n              (reduce #(f %2 %1) acc xs)\n              (conj acc xs))))","user":"5f9f032fe4b0715f5002d839"},{"code":"(fn\n  [x]\n  (letfn [(flat [coll]\n                  (lazy-seq\n\n                   (when-let [c (seq coll)]\n\n                     (let [x (first c)]\n\n                       (if (sequential? x)\n\n                         (concat (flat x) (flat (rest c)))\n\n                         (cons x (flat (rest c))))))))]\n\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"51004dabe4b0e0dde55c17f0"},{"problem":28,"code":"(fn[lst]\n    (first \n        (drop-while \n \t    #(some sequential? %) \n \t    (iterate \n     \t    #(reduce \n     \t        (fn [acc x] \n                    (if (sequential? x) \n                        (into acc x) \n                        (conj acc x))) \n     \t        [] \n     \t        %)\n     \t    lst))))","user":"57b9fc74e4b0fbc9809a27fb"},{"code":"#(filter (complement sequential?)\n          (tree-seq sequential? seq %1))","problem":28,"user":"4ebb20c0535dfed6da9c6d6f"},{"problem":28,"code":"(fn my-flatten \n  [s]\n  (if (empty? s)\n    '()\n    (if-not (coll? (first s))\n       (conj (my-flatten (rest s)) (first s))\n       (into (my-flatten (rest s)) (reverse (my-flatten (first s)))))))","user":"56cb0abce4b0ea9b8538f722"},{"code":"(fn myfunc [thelist]\n\n  (loop [before thelist counter 1]\n\t\t(if (> counter 4)\n          before\n\n      (recur (reduce (fn [accum x]\n          \t\t(if (coll? x)\n            \t(apply conj accum  x)\n            \t(conj accum x)))\n          \t[]\n          \tbefore) (inc counter))))\n\n\n)","problem":28,"user":"50a85af1e4b054305ba5a833"},{"problem":28,"code":"(let [flat #((if (coll? %) identity list) %)]\n  (fn [s]\n    (let [res (mapcat flat s)]\n      (if (= res s) res\n        (recur res)))))","user":"5d929ceae4b0915913b1d412"},{"code":"(fn flat [s] (if (sequential? s)\n                 (mapcat flat s)\n                 [s]))","problem":28,"user":"5363f11be4b0243289761e5f"},{"code":"(fn [x] \r\n  (filter (complement sequential?) \r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f032977535dcb61093f6a6c"},{"code":"(fn flttn [s]\n\t(if (contains? (supers (type s)) clojure.lang.Seqable)\n\t\t(if (>= (count s) 2)\n\t\t\t(concat (flttn (first s)) (flttn (rest s)))\n\t\t\t(if (= (count s) 1)\n\t\t\t\t(flttn (first s))\n\t\t\t\ts\n\t\t\t)\n\t\t)\n\t\t(conj '() s)\n\t)\n)","problem":28,"user":"53858d5be4b06839e8705f06"},{"code":"(fn flatn [coll]\n  (cond (coll? coll)\n    (mapcat flatn coll)\n    :else [coll]))","problem":28,"user":"4e5914e0535d8a8b8723a29b"},{"problem":28,"code":"#(read-string (str \"[\" (clojure.string/escape (str %) {\\[ \"\", \\] \"\", \\( \"\", \\) \"\"}) \"]\"))","user":"5751f2a2e4b02ea114799292"},{"code":"(fn flat [lst]                                                          \n        (let [ [x & ls] lst ]                                                   \n             (cond                                                              \n               (empty? lst) '()                                                 \n               (coll? x) (concat (flat x) (flat ls))                            \n               :else (cons x (flat ls)))))","problem":28,"user":"4eed6b32535d93acb0a668bc"},{"code":"(fn f [x] (reduce #(if (coll? %2) (concat %1 (f %2)) (concat %1 [%2])) [] x))","problem":28,"user":"5062bc46e4b05ac47bc68d68"},{"code":"(fn myflatten [a] (mapcat (fn [x] (cond (list? x) (myflatten x) (vector? x) (myflatten x) :else (list x))) a))","problem":28,"user":"538e29d1e4b0b51d73faae80"},{"code":"(fn flaten [s]\n  (if (coll? s)\n      (if (empty? s)\n          '()\n          (concat (flaten (first s)) (flaten (rest s))))\n      (list s)))","problem":28,"user":"4ff35e60e4b0678c553fc350"},{"problem":28,"code":"#(loop [input %, output `()]\n  (if (sequential? (first input))\n    (recur (concat (first input) (rest input)) output)\n    (if (empty? input) (reverse output)\n      (recur (rest input) (cons (first input) output)))))","user":"51671557e4b013fc800656c4"},{"code":"(fn flat [[x & xs :as coll]]\n  (if (empty? coll)\n    coll\n    (concat\n     (if (coll? x) (flat x) (list x))\n     (flat xs))))","problem":28,"user":"53779a26e4b06839e8705e38"},{"code":"(fn a [v] ( reverse( (fn f [r vv] ( reduce #(if (coll? %2) (f %1 %2) (conj %1 %2) ) r vv ) ) () v ) ) )","problem":28,"user":"531f0a26e4b08068f379edbf"},{"code":"(fn [x]\n  (letfn [(flttn [x]\n            (if (coll? x)\n              (apply concat (map flttn x))\n              (list x)))]    \n    (flttn x)))","problem":28,"user":"4f2893d0e4b0d6649770a019"},{"code":"(fn fappen[x]\n    (apply concat\n           (for [n x]\n             (if  (or (vector? n) (list? n))\n               (fappen  n )\n               (list n)))))","problem":28,"user":"5300aa1de4b0d8b024fd3710"},{"problem":28,"code":"(fn [c] (if (some coll? c)\n  (recur (reduce #(if\n    (coll? %2)\n    (concat %1 %2)\n    (concat % [%2]))\n  []\n  c))\nc))","user":"56403765e4b08d4f616f5edc"},{"code":"(fn myflat[x]\n\t\t(if (sequential? x)\n\t\t(mapcat myflat x)\n\t\t(list x)\n\t\t)\n)","problem":28,"user":"538de891e4b0b51d73faae78"},{"problem":28,"code":"#(reverse \n    (reduce \n        (fn rec-flatten [acc item] \n            (if (coll? item) \n                (reduce rec-flatten acc item)\n                (conj acc item)))\n    '() %))","user":"5bc6ef7ce4b07a9b28b1009f"},{"problem":28,"code":"#(filter (complement sequential?)\n        (rest (tree-seq sequential? seq  %)))","user":"561052ace4b05f002753df6e"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n(rest (tree-seq sequential? seq x))))","user":"5b7292b3e4b047b03b2036a4"},{"problem":28,"code":"(fn my-flatten [sqnc]\n  (cond\n   (empty? sqnc) (list)\n   (sequential? (first sqnc)) (concat (-> sqnc first my-flatten)\n                                       (-> sqnc rest my-flatten))\n   :else (cons (first sqnc)\n               (my-flatten (rest sqnc)))))","user":"53e543efe4b036ad0777e457"},{"code":"(fn ff [s] (apply concat (map #(if (sequential? %) (ff %) (list %)) s)))","problem":28,"user":"524be8e0e4b09eba1c0223f1"},{"code":"(fn getflat [lst]\n  (cond \n   (empty? lst) []\n   (coll? (first lst)) (concat (getflat (first lst)) (getflat (rest lst)))\n   :else (cons (first lst) (getflat (rest lst)))))","problem":28,"user":"50f0d000e4b0c5f4fa5ddb6f"},{"problem":28,"code":"(fn [coll]\n  (remove sequential? (tree-seq sequential? identity coll)))","user":"5f63d933e4b02876ed9fd018"},{"code":"(fn f ([s] (if\n  (coll? s)\n  (if (seq s) (reduce concat (map f s)) '())\n  [s])))","problem":28,"user":"4ff889f2e4b0678c553fc399"},{"code":"(fn fn-flatten-seq [x]\n    (let [left (first x)\n          right (next x)]\n      (concat\n        (if (sequential? left)\n          (fn-flatten-seq left)\n          [left])\n        (when (sequential? right)\n          (fn-flatten-seq right)))))","problem":28,"user":"51a3738ce4b0e77c4ca60bf0"},{"problem":28,"code":"(fn my-flat [x] (if (sequential? x) (mapcat my-flat x) [x]))","user":"56d80542e4b0ea9b8538f7e1"},{"code":"(fn [v]\n  (loop [a [], x (first v), xs (rest v)]\n    (if (or (nil? xs) (empty? xs))\n      (if (sequential? x)\n        (recur a (first x) (rest x))\n        (conj a x))\n      (if (sequential? x)\n        (recur a (first x) (concat (rest x) xs))\n        (recur (conj a x) (first xs) (rest xs))))))","problem":28,"user":"5097a95fe4b00ad8bab4e96e"},{"problem":28,"code":"(fn f [p] (println p)(if (or (= p '()) (nil? p)) '() (if(sequential? p) (concat (f (first p)) (f (rest p))) (cons p '()))))","user":"557bd432e4b05c286339e0bb"},{"problem":28,"code":"(fn fltn [args]\n    (reduce (fn [a b]\n                        (if (sequential? b)\n                            (apply conj a (fltn b))\n                            (conj a b))) [] args))","user":"58949f8de4b00487982d525e"},{"problem":28,"code":"(fn flat [s]\n  (when-let [ss (seq s)]\n    (if (coll? (first ss))\n      (concat (flat (first ss)) (flat (rest ss)))\n      (cons (first ss) (flat (rest ss))))))","user":"5b61279ce4b0c6492753e70e"},{"code":"(fn flat [l]\n  (reduce #(let [a (cond\n                       (coll? %1) (flat %1)\n                       :else [%1])\n                 b (cond\n                       (coll? %2) (flat %2)\n                       :else [%2])]\n                 (concat a b)) [] l))","problem":28,"user":"4faac363e4b081705acca200"},{"problem":28,"code":"(fn x [l](cond(empty? l) '() (coll? (first l)) (concat(x(first l))(x(rest l))) :else (cons (first l)(x(rest l)))  )  )","user":"55ec8b25e4b0121d4835fdc9"},{"code":"(fn fla [x] \n   (filter #(not (sequential? %)) (tree-seq sequential? identity x)))","problem":28,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":28,"code":"(fn my-flatten [lst]\n  (reduce #(concat %1 (if (coll? %2) (my-flatten %2) (list %2))) '() lst))","user":"591f05b4e4b09b4ee5954c42"},{"problem":28,"code":"(fn [c] (letfn [(t [x] (if (coll? x) (mapcat t x) [x]))] (t c)))","user":"4ec1923f535dfed6da9c6db2"},{"code":"(fn my-flatten [l]\n   (if (empty? l) '()\n    (let [f (first l) my-r (my-flatten (rest l))]\n      (if (coll? f)\n        (concat (my-flatten f) my-r)\n        (cons f (my-flatten my-r))))))","problem":28,"user":"51b6f4f9e4b04fc00976d479"},{"problem":28,"code":"(letfn [(f [l]\n           (if (seq l)\n             (let [[x & xs] (seq l)\n                   remaining (f xs)]\n               (print \"l:\" l \"x:\" x \", xs:\" xs \", remaining:\" remaining \"\\n\")\n               (if (sequential? x)\n                 (into remaining (reverse (f x)))\n                 (cons x remaining)))\n             '()))]\n   f)","user":"540470dae4b0addc1aec6658"},{"problem":28,"code":"(fn flatter [xs]\n  \t(cond (empty? xs) xs\n          (sequential? (first xs)) (concat (flatter (first xs)) (flatter (rest xs)))\n          :else (cons (first xs) (flatter (rest xs)))))","user":"597768d0e4b01722bebd4cee"},{"code":"(fn [s] (filter (complement coll?) (tree-seq coll? seq s)))","problem":28,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":28,"code":"(fn my-flatten [coll]\n  (loop [coll coll result []]\n    (if-let [itm (first coll)]\n      (if (coll? itm)\n        (recur (concat itm (rest coll)) result)\n        (recur (rest coll) (conj result itm)))\n      result)))","user":"566b57e9e4b0a866af6896ad"},{"problem":28,"code":"(fn flat-it [coll]\n  (reduce (fn [acc x] \n            (do\n              (println (str \"acc - \" acc \" || x - \" x \" || type -> \" (type x) \"seq: \" (seq? x)))\n              (if (or (seq? x) (coll? x))\n               (into acc (flat-it x))\n               (conj acc x)\n               ))\n  ) [] coll))","user":"59b8ee96e4b0a024fb6ae3c0"},{"problem":28,"code":"(fn flat\n     ([dat] (reverse (flat '() dat)))\n     ([cc dat]\n        (if (empty? dat)\n            cc\n            (let [x (first dat) y (rest dat)]\n                  (flat (if (coll? x) (flat cc x) (conj cc x)) y)))))","user":"5a01d8f6e4b01bb0ae8afd53"},{"code":"(fn my-flatten [s] \r\n  (cond  (or (symbol? s) (string? s) (keyword? s) (char? s) (number? s)) (list s)\r\n\t(empty? s) ()\r\n\t:default (let [a (first s) \r\n\t\t       b (rest s)] \r\n\t\t   (concat (my-flatten a) (my-flatten b)))))","problem":28,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":28,"code":"(fn flat [s]\n   (if (coll? s)\n     (mapcat flat s)\n     (list s)))","user":"55895eade4b059ccff29b202"},{"problem":28,"code":"(fn my-reduce [col] (reduce (fn [col x] (if (sequential? x) (into col (my-reduce x)) (conj col x))) [] col))","user":"5dfb267ee4b0a607a9a45cd4"},{"problem":28,"code":"(fn [coll] (if (some coll? coll) (recur (mapcat #(if (coll? %) % (list %)) coll)) coll))","user":"52d07cc5e4b07d0d72b273bb"},{"problem":28,"code":"(fn fltn [s]\n  (apply concat \n     (map\n       (fn [a] (if (sequential? a) (fltn a) (list a)))\n       (if (sequential? s) s '())\n     )\n  )\n)","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(letfn [(extract [col elem]\n           (if (coll? elem) (reduce extract col elem)\n                            (conj col elem)))]\n  (fn f [col] (reverse (reduce extract () col))))","problem":28,"user":"51eadb98e4b0f1f103a0d153"},{"code":"(fn [ x ] \n\n;http://markmail.org/message/56r3eflx4a6tasoe\n;      (let [s? #(instance? clojure.lang.Sequential %)]\n;    (filter (complement s?) (tree-seq s? seq x))))\n; replacing with the newer function coll?\n\n    (filter (complement coll?) (tree-seq coll? seq x)))","problem":28,"user":"4fdf750be4b05e33b9224f9c"},{"code":"(fn[x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"531f1e63e4b08068f379edc2"},{"problem":28,"code":"(fn my-flattener [arg]\n  ((fn flattener [seqt result]\n    (if (= (count seqt) 0)\n      result\n      (if (sequential? (first seqt))\n        (concat (flattener (first seqt) result) (flattener (rest seqt) result))\n        (cons (first seqt) (flattener (rest seqt) result))))) arg '()))","user":"584f1397e4b0b7285a6f4e5e"},{"code":"(fn my-flatten [l] (if (empty? l) l \n                       (if (sequential? (first l)) (concat (my-flatten (first l)) (my-flatten (drop 1 l))) \n                                 (conj (my-flatten (drop 1 l)) (first l)))))","problem":28,"user":"52e683c0e4b09f7907dd1477"},{"problem":28,"code":"(fn flat [s]\n  ((fn flatter [result seqs]\n    (if (coll? seqs)\n      (reduce flatter result seqs)\n      (conj result seqs)\n      )\n    ) [] s)\n  )","user":"567e418fe4b0feffd0d18eb1"},{"code":"(fn my-flatten [s]\n  (apply concat (map #(if (coll? %) (my-flatten %) (list %)) s)))","problem":28,"user":"4f55f4b1e4b0a7574ea7180d"},{"problem":28,"code":"(fn iter [xs]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (iter x))\n              (concat acc (cons x nil))))\n          ()\n          xs))","user":"5d88c6a3e4b0915913b1d3ad"},{"problem":28,"code":"#(reverse (reduce\n           (fn rec-flatten [acc item]\n             (if (coll? item)\n               (reduce rec-flatten acc item)\n               (conj acc item)))\n           '()\n           %))","user":"59bcbfd0e4b0a024fb6ae419"},{"problem":28,"code":"(fn \n  [s]\n  (reduce\n   (fn my-flatten\n     [v e]\n     (if (coll? e)\n       (reduce my-flatten v e)\n       (conj v e))\n     )\n   []\n   s)\n  )","user":"589e704ae4b02bd94d917e5e"},{"problem":28,"code":"(fn flat\n  [[x & tail]]\n  (into\n   (if (nil? x) [] (if (coll? x) (flat x) [x]))\n   (if (nil? tail) [] (if (coll? tail) (flat tail) [tail]))))","user":"56451201e4b0284900eef600"},{"code":"(fn my-flat [a]\n  (if (coll? a)\n    (mapcat my-flat a)\n    [a]))","problem":28,"user":"51622fb8e4b009fba0926e3f"},{"problem":28,"code":"(fn [s]\n\n  (let [flatten-rec\n\n        (fn flatten-rec [s a]\n          (let [a' (vec a)]\n            (if (seq s)\n              (let [f (first s)]\n                (flatten-rec\n                (rest s)\n                (if (coll? f)\n                  (concat a' (flatten-rec f []))\n                  (conj a' f))))\n              a')))]\n\n    (seq (flatten-rec s []))))","user":"58836dbee4b0f1effa3b7679"},{"problem":28,"code":"(fn fltn [x]\n  (reduce \n   (fn [sofar nxt]\n     (if (sequential? nxt)\n       (if (empty? nxt)\n         sofar\n         (into sofar (fltn nxt))\n       )\n       (into sofar [nxt])\n     )\n   ) [] x\n  ) \n )","user":"5984b9f3e4b021a7a535fe33"},{"code":"(fn f [coll]\n  (if (sequential? coll)\n    (mapcat f coll)\n    (list coll)))","problem":28,"user":"5318594ee4b08068f379ed6d"},{"code":"(fn my-flatten\n  [ls]\n  (reduce (fn [acc i]\n            (concat acc (if (sequential? i) (my-flatten i) [i])))\n          []\n          ls))","problem":28,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":28,"code":"(fn Flatten [x]\n  (if (coll? x)\n    (mapcat Flatten x)\n    [x]))","user":"5f8795d4e4b020286baa5e96"},{"problem":28,"code":"(fn flattenByMe [x] \n    (if (coll? x) \n        (mapcat flattenByMe x) [x]\n        )\n    )","user":"5f77b99fe4b02876ed9fd0bc"},{"code":"(fn flat [x]\n  (if (coll? x)\n    (reduce concat () (map flat x))\n    (list x)))","problem":28,"user":"5315ec83e4b08068f379ed39"},{"problem":28,"code":"#(loop [col %\n         result '()]\n    (if-let [head (first col)]\n      (if (coll? head)\n        (recur (concat head (rest col)) result)\n        (recur (rest col) (conj result head)))\n      (reverse result)))","user":"545b486ae4b01be26fd7464f"},{"code":"(fn flat2 [s]\n  (if (sequential? s)\n    (mapcat flat2 s)\n    (list s)\n  )\n)","problem":28,"user":"515ebde3e4b01e5d11ccd0a8"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n[] coll)))","user":"577e1d14e4b0c8d87281f6e2"},{"problem":28,"code":"(fn fltn [xss] \n  (if (empty? xss) \n    '()\n    (let [x (first xss) \n          xs (rest xss)] \n      (if (sequential? x) \n        (concat (fltn x) \n                (fltn xs)) \n        (cons x (fltn xs))))))","user":"58c623dbe4b021aa9917ed4b"},{"problem":28,"code":"(fn [seq-list] (filter (complement sequential?) (rest (tree-seq sequential? seq seq-list))))","user":"5af19233e4b0cc2b61a3bc5f"},{"problem":28,"code":"(fn flattens [s]\n  (if (empty? s)\n    []\n    (if (coll? (first s))\n      (concat (flattens (first s)) (flattens (rest s)))\n      (cons (first s) (flattens (rest s))))))","user":"5ad002f2e4b0ea6055cfab87"},{"code":"(fn squash [s] (reduce #(if (coll? %2) (into %1 (squash %2) ) (conj %1 %2) ) [] s) )","problem":28,"user":"51e28063e4b08e53a149f0f2"},{"code":"(fn f [s]\n  (if (coll? s) (mapcat f s) [s]))","problem":28,"user":"4fbacdbae4b081705acca2e5"},{"code":"(fn kflat [c] (reduce (fn [c v] (if (or (seq? v) (vector? v)) (into c (kflat v)) (conj c v))) [] c))","problem":28,"user":"509dc716e4b08df8156e9e27"},{"problem":28,"code":"(fn [s]\n  (loop [acc [] x s]\n    (if (empty? x)\n      acc\n      (if (not (coll? (first x)))\n        (recur (conj acc (first x)) (rest x))\n        (recur acc (reduce conj (rest x) (reverse (first x))))))))","user":"5392500ae4b0b51d73faaeaf"},{"problem":28,"code":"(fn [x]\n     (filter (complement sequential?)\n       (rest (tree-seq sequential? seq x))))","user":"548166b3e4b0e286459a116d"},{"problem":28,"code":"(fn\n  [mySeq]\n  (sort (reduce (fn unSeq [finalSeq v] (if (coll? v)\n                                   (reduce unSeq finalSeq v)\n                                   (conj finalSeq v))) '() mySeq)))","user":"54c120d7e4b0ed20f4ff6f1c"},{"code":"(fn flatten-new [xs]\n  ( if (coll? xs)\n    ( mapcat flatten-new xs)\n    (seq [xs])))","problem":28,"user":"4f065217535dcb61093f6c0c"},{"problem":28,"code":"(fn my-flatten [alist]\n  (cond (= '() alist) []\n        (coll? alist) \n          (concat \n            (my-flatten (first alist))\n            (my-flatten (rest alist)))\n        :else [alist]))","user":"5aaa2dc3e4b0d174b936c8f1"},{"problem":28,"code":"(fn [n]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq n))))","user":"55268e8de4b0ffed3738f91f"},{"problem":28,"code":"(fn fltn [xs] (apply concat (map #(if (sequential? %) (fltn %) [%]) xs)))","user":"5967ce67e4b069c0a1a197bf"},{"code":"(fn roll [x & y] (reduce #(if (sequential? %2) (apply conj %1 (roll %2))  (conj %1 %2)) (if (nil? y) [] y) x))","problem":28,"user":"50223ee2e4b0846bc458ae48"},{"problem":28,"code":"(fn f [x] (if (sequential? x) (reduce #(concat %1 (f %2)) [] x) [x]))","user":"54d6c80ce4b0a52adc2e2020"},{"problem":28,"code":"(fn myFlatten\n  [sequence]\n  (let [f (first sequence)]\n    (cond\n      (nil? f) ()\n      :else (cond\n              (coll? f) (concat (myFlatten f) (myFlatten (next sequence)))\n              :else (cons f (myFlatten (next sequence))))))\n  )","user":"557e9d17e4b05c286339e0d8"},{"code":"(fn f [coll]\n  (loop [res [], coll coll]\n    (if-let [e (first coll)]\n      (if (coll? e) \n        (recur (into res (f e)) (next coll))\n        (recur (conj res e) (next coll)))\n      res)))","problem":28,"user":"51d19c24e4b0cfcf579466c3"},{"problem":28,"code":"#(reduce (fn fl [a x] (if (or (seq? x) (coll? x)) (reduce fl a x) (concat a [x]))) nil %)","user":"5c53127ee4b0fb8c5ffd99ef"},{"problem":28,"code":"(fn flat [l]\n  (if (coll? l)\n    (reduce #(concat %1 (flat %2)) () l)\n    (list l)))","user":"544e6b7fe4b0e39780006986"},{"code":"(fn [xs]\n  (filter (complement sequential?)\n  (rest (tree-seq sequential? seq xs))))","problem":28,"user":"4edeac6b535d10e5ff6f533a"},{"problem":28,"code":"(fn flatten_ [coll]\n  (apply concat (map #(if (sequential? %) (flatten_ %) (list %)) coll)))","user":"58896e5ce4b0f1effa3b773e"},{"problem":28,"code":"(fn [x]\n  (loop [acc [] s x]\n    (cond\n     (= 0 (count s)) acc\n     (not (sequential? s)) (conj acc s)\n     (not (sequential? (first s))) (recur (conj acc (first s)) (rest s))\n     (sequential? (first s)) (if (sequential? (ffirst s))\n                               (recur acc (concat (ffirst s) (rest (first s)) (rest s)))\n                               (recur (conj acc (ffirst s)) (concat (rest (first s)) (rest s))))\n     \n     )\n    ))","user":"52a803cee4b0c58976d9ac26"},{"code":"(fn iter\n  ([xs] (iter xs []))\n  ([xs rs] (cond (empty? xs) rs\n                 (coll? (first xs)) (recur (concat (first xs) (rest xs)) rs)\n                 :else (recur (rest xs) (conj rs (first xs))))))","problem":28,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn flat [coll]\n    (loop [result '() c coll]\n      (if (empty? c)\n        result\n        (if (coll? (first c))\n          (recur (concat result (flat (first c))) (rest c))\n          (recur (conj (vec result) (first c)) (rest c))))))","problem":28,"user":"4e7e8684535db169f9c79717"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn my-flat [v e]\n      (if\n       (coll? e)\n       (reduce my-flat v e)\n       (conj v e)))\n    [] coll)))","user":"595930f6e4b066ee0a44af9c"},{"code":"; seq aller knoten des baums\r\n; aber davon nur die blaetter, welche nicht sequential sind\r\n(fn myflatten [x]\r\n  (filter (complement sequential?)\r\n    (tree-seq sequential? seq x)))","problem":28,"user":"4e131443535d04ed9115e7d3"},{"problem":28,"code":"(fn flat\n  [x]\n  (if (sequential? x)\n    (mapcat flat x)\n    (vector x))\n)","user":"555f4bade4b0a2eb076a39c2"},{"problem":28,"code":"(fn my-flatten [s]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq s)))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn flat[x] (if (coll? x) (lazy-seq (mapcat flat x)) \n(seq  [x])))","problem":28,"user":"504f2efae4b0e7ad84dbc4c9"},{"problem":28,"code":"(fn fl [xs] (\n          if (coll? xs)\n          \t(mapcat fl xs)\n            [xs]))","user":"6011b89ee4b074f607df66bc"},{"code":"(fn f [xs]\n   (cond\n    (empty? xs) '()\n    (sequential? (first xs)) (concat (f (first xs))\n                                     (f (rest xs)))\n    :else (cons (first xs) (f (rest xs)))))","problem":28,"user":"520693e1e4b0bf4f1882c829"},{"problem":28,"code":"#(filter ( complement sequential?) (tree-seq sequential? identity %))","user":"56188848e4b053970a773aea"},{"problem":28,"code":"(fn flat\n  [coll]\n  (cond\n   (empty? coll) '()\n   (sequential? (first coll)) (concat (flat (first coll)) (flat (rest coll)))\n   :else (cons (first coll) (flat (rest coll)))))","user":"57476b5fe4b009280f9f2b74"},{"code":"(fn [x]\n  (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"50b0804de4b009df37c708bb"},{"code":"#(filter (comp not coll?) (tree-seq coll? seq %))","problem":28,"user":"4eb5c8d7535d7eef3080736a"},{"code":"(fn f [l]\n  (if (= nil (first l)) l\n    (if (sequential? (first l))\n      (concat (f (first l)) (f (rest l)))\n      (cons (first l) (f (rest l))))))","problem":28,"user":"503de5aae4b06c4e0e1fa259"},{"problem":28,"code":"(fn f [coll]\n  (if (empty? coll)\n    ()\n    (if (coll? (first coll))\n      (concat (f (first coll)) (f (rest coll)))\n      (cons (first coll) (f (rest coll))))))","user":"540d5085e4b0addc1aec670e"},{"code":"(fn [x] \n  (filter \n    (complement sequential?) \n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f4a17ffe4b0d56e7bb92c05"},{"code":"(fn fl [x]\n  (if (sequential? x)\n  (reduce concat (map fl x)) (list x)))","problem":28,"user":"4e4b911f535dc968683fc4d6"},{"problem":28,"code":"(fn f [s]\n    (reduce \n        #(if (sequential? %2)\n            (concat %1 (f %2))\n            (conj (apply vector %1) %2))\n        [] \n        s))","user":"54fdaeace4b07d26eda61d39"},{"code":"(fn fl [x]\n  (if (empty? x)\n    '()\n    (let [f (first x) r (rest x)]\n      (if (coll? f)\n        (concat (fl f) (fl r))\n        (cons f (fl r))\n      )\n    )\n  )\n)","problem":28,"user":"4ea1ecfa535d7eef308072bb"},{"problem":28,"code":"(fn unwind [args] (let [[x & xs] args]\n                        (if (empty? args)\n                          '()\n                          (if (coll? x)\n                            (concat (unwind x) (unwind xs))\n                            (cons x (unwind xs))))))","user":"560c37b5e4b05f002753df2e"},{"code":"(fn [s0]\n  (let [helper (fn [self s acc]\n                 (if (empty? s)\n                   acc\n                   (let [item (first s)]\n                     (recur self (next s)\n                            (if (sequential? item)\n                              (into acc (self self item []))\n                              (conj acc item))))))]\n    (helper helper s0 [])))","problem":28,"user":"4e39fb68535deb9a81d77f47"},{"code":"(fn [seq]\n  (loop [col seq res []]\n    (if (empty? col) res\n\t  (let [x (first col)]\n\t    (if (coll? x) \n      (recur (concat x (rest col)) res) \n      (recur (rest col) (conj res x)))))))","problem":28,"user":"4e7e05a6535db169f9c796fe"},{"problem":28,"code":"(fn [x]  (filter (complement sequential?) (tree-seq sequential? seq x)))","user":"5d590500e4b02ba5928a6824"},{"code":"#(letfn [\n  (f-ten [x]\n    (if (coll? x)\n      (if (empty? x) x\n        (concat (f-ten (first x))\n                (f-ten (rest x))))\n      [x]))]\n  (f-ten %))","problem":28,"user":"4eb5750a535d7eef30807366"},{"code":"(fn jump [coll]\n  (reduce\n    (fn recur1 [newlist x]\n      (if (coll? x)\n        (concat newlist (jump x))\n        (concat newlist [x]))\n    )\n    () coll))","problem":28,"user":"51efdbbee4b0249c592fbdec"},{"code":"(fn fla [x] \n  (let[f (first x) n (next x)]\n    (concat\n         (if(sequential? f) (fla f) [f])\n         (if(sequential? n) (fla n) [])\n    ) \n   )\n )","problem":28,"user":"51bec919e4b013aa0d74b800"},{"code":"(fn rev-build[the-list] \n(reverse \n (\n  (fn build [l]\n    (reduce\n     #(if (coll? %2)\n        (concat (build %2) %1)\n        (conj %1 %2)\n        ) \n     '() \n     l) ;end reduce call\n    ) ;end definition of function build \n  the-list\n  ); end call to function build\n )\n  )","problem":28,"user":"52e980b3e4b09f7907dd14af"},{"code":"(fn f [col] \n  (reduce \n     (fn ff [xs x] (if \n                     (coll? x) \n                     (into xs (f x)) \n                     (conj xs x))) \n     [] col))","problem":28,"user":"4f9510b5e4b0dcca54ed6cc7"},{"problem":28,"code":"(fn [coll]\n      (reduce\n       (fn my-flatter [v e]\n         (if (coll? e)\n           (reduce my-flatter v e)\n           (conj v e))) '[] coll))","user":"5386f784e4b06839e8705f17"},{"problem":28,"code":"(fn myflat\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5a4cbba1e4b05d388ecb6b98"},{"problem":28,"code":"(fn red [x]\n  (cond (empty? x) nil\n        ((complement sequential?) (first x)) (cons (first x) (red (rest x)))\n        :else (concat (red (first x)) (red (rest x)))))","user":"57027310e4b08d47c97781e2"},{"code":"#(reverse\n  (loop [xs % stack () acc ()]\n    (cond (empty? xs)\n          (if (empty? stack) acc\n              (recur (first stack) (rest stack) acc))\n          (sequential? (first xs))\n              (recur (first xs) (cons (rest xs) stack) acc)\n          :atom (recur (rest xs) stack\n                       (cons (first xs) acc)))))","problem":28,"user":"4fa6d532e4b081705acca1be"},{"problem":28,"code":"(fn fs [c] (reduce (fn [acc itm] (if (sequential? itm)\n                                    (into [] (concat acc (fs itm)))\n                                    (into [] (conj acc itm))))\n                     [] c))","user":"593e4b1fe4b069cdc2982bbb"},{"code":"(fn tailRec [coll] (reduce #(concat % (if (coll? %2) (tailRec %2) [%2])) () coll))","problem":28,"user":"534c1c64e4b084c2834f4a8a"},{"code":"(fn make-flat [coll]\n  (if (coll? coll)\n    (mapcat make-flat coll)\n    [coll]))","problem":28,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"problem":28,"code":"(fn flat [coll]\n  (lazy-seq \n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s)))))))","user":"5a7ff79ce4b00b71e582a046"},{"problem":28,"code":"(fn flatten2 [xs]\n   ((fn rec [acc xs]\n      (cond\n        (empty? xs) (reverse acc)\n        (coll? (first xs))\n        (rec\n         (apply (partial conj acc) (flatten2 (first xs)))\n         (rest xs))\n        :else\n        (rec\n         (conj acc (first xs))\n         (rest xs))))\n    '() xs))","user":"601004d6e4b074f607df66b2"},{"problem":28,"code":"(fn [coll] (reduce (fn my-flat [x y] (if (coll? y) (reduce my-flat x y) (conj x y))) [] coll))","user":"54c94376e4b045293a27f665"},{"code":"#(filter (complement sequential?)(rest (tree-seq sequential? seq %)))","problem":28,"user":"4e503aea535dc968683fc4ea"},{"problem":28,"code":"(fn [s]\n    (reduce\n     (fn myflatten [acc item]\n       (if (sequential? item)\n         (reduce myflatten acc item)\n         (conj acc item)))\n     []\n     s))","user":"5bc7f2d6e4b07a9b28b100b7"},{"code":"(fn [xs]\n  (loop [coll xs]\n    (if (every? (complement coll?) coll)\n      coll\n      (let [flatter (reduce (fn [acc el] (if (coll? el) (concat acc el) (concat acc (list el)))) '() coll)]\n        (recur flatter)))))","problem":28,"user":"4f3a979de4b0e243712b1f10"},{"code":"(fn f [s]\n  (apply concat \n    (map \n      #(if (or (seq? %) (vector? %)) (f %) (list %)) s)))","problem":28,"user":"4ff07229e4b0678c553fc323"},{"code":"(fn myf [l] (apply concat (map #(if (sequential? %) (myf %) (list %)) l)))","problem":28,"user":"4e7f4147535db966e863cc3d"},{"problem":28,"code":"(fn [in] (let [impl (fn impl\n    ([] [])\n    ([[x & xs]] (if\n      (coll? x)\n      (concat (impl x) (impl xs))\n      (if (nil? x) [] (cons x (impl xs))))))]\n    (impl in)))","user":"5823c717e4b051871117beb2"},{"problem":28,"code":"(fn my-flatten [coll]\n  (loop [l coll acc ()]\n    (cond\n          (empty? l) (reverse acc)\n          (sequential? (first l)) (recur (concat (first l) (rest l)) acc)\n          :else (recur (rest l) (cons (first l) acc)))))","user":"5650b8a0e4b0284900eef6c3"},{"problem":28,"code":"(fn f [coll] (if (sequential? coll)\n                (mapcat f coll)\n                (list coll)))","user":"59908f3fe4b0866487ed0d50"},{"code":"(fn flat [xs]\n  (if (or (list? xs) (vector? xs))\n    (mapcat flat xs)\n    [xs]))","problem":28,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":28,"code":"#(loop [res []\n          f (first %)\n         r (rest %)]\n    (println \"res \" res \"f \" f \" r \" r)\n    (if (and (sequential? f) (not (empty? f)))\n      (recur res (first f) (conj (vec (rest f)) r))\n      (if (and (not (empty? r)) (sequential? r))\n         (recur (conj res f) (first r) (rest r))\n         (remove (fn [x] (and (sequential? x) (empty? x))) res))\n       ))","user":"567a680ee4b05957ce8c6198"},{"problem":28,"code":"(fn [a-seq]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq a-seq))))","user":"53fd0a22e4b0de5c418485e1"},{"problem":28,"code":"(fn [x] (filter #(not (sequential? %)) (tree-seq sequential? seq x )))","user":"6022429be4b0d5df2af22200"},{"code":"(fn fltn [x]\n  (if (empty? x) x\n    (if (sequential? (first x))\n      (concat (fltn (first x)) (fltn (rest x)))\n      (cons (first x) (fltn (rest x))))))","problem":28,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":28,"code":"(fn flat [xs]\n (mapcat \n  (fn [x]\n   (if\n    (sequential? x)\n    (flat x)\n    [x]))\n  xs))","user":"59d4d126e4b0ef0a1e9b5be9"},{"problem":28,"code":"(fn [a-seq]\n  (filter (complement sequential?) \n          (tree-seq sequential? seq a-seq))\n  )","user":"5be33a16e4b0ed4b8aab4cd6"},{"problem":28,"code":"(fn fltn [c]\n  (reduce (fn [acc v]\n            (if (coll? v)\n              (apply conj acc (fltn v))\n              (conj acc v))) [] c))","user":"560ee566e4b05f002753df57"},{"problem":28,"code":"(fn\n   [x]\n   (filter (complement sequential?)\n           (rest (tree-seq sequential? seq x))))","user":"5b86462de4b047b03b2037df"},{"code":"#(filter (complement sequential?)\n  \t  (tree-seq sequential? seq %))","problem":28,"user":"4fc588bee4b0ee37620e17fa"},{"problem":28,"code":"(fn my-flatten\n  [xs] (mapcat #(if (sequential? %)\n                  (my-flatten %)\n                  (list %))\n               xs))","user":"5a6af351e4b0512ff01cda2e"},{"problem":28,"code":"(fn [x]\n   (letfn [(flat [coll]\n                 (lazy-seq\n                  (when-let [c (seq coll)]\n                    (let [x (first c)]\n                      (if (sequential? x)\n                        (concat (flat x) (flat (rest c)))\n                        (cons x (flat (rest c))))))))]\n     (if (sequential? x) (flat x) x)))","user":"56466fb1e4b0284900eef613"},{"problem":28,"code":"(fn myflat [coll]\n  (if (sequential? coll)\n    (mapcat myflat coll)\n    (list coll)))","user":"558075c6e4b05c286339e0ec"},{"code":"(fn [col]\n  (seq\n   (reduce (fn flatten-func [a b] \n             (if (coll? b)\n               (reduce flatten-func a b)\n               (conj a b))) [] col)))","problem":28,"user":"5390110de4b0b51d73faae94"},{"problem":28,"code":"(fn flt [acc e]\n  (reduce (fn [acc1 e1]\n            (if (coll? e1)\n              (flt acc1 e1)\n              (conj acc1 e1))) acc e)) []","user":"54a854f5e4b09f271ff37ca2"},{"code":"(fn flat [input]\n  (if (empty? input)\n    '()\n    (if (coll? (first input))\n      (concat (flat (first input)) (flat(rest input)))\n      (cons (first input) (flat(rest input))))))","problem":28,"user":"537cf454e4b06839e8705e82"},{"code":"(fn f [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e333091535deb9a81d77f25"},{"problem":28,"code":"(fn [seqn]\n  (reduce\n    (fn flattn[v e]\n      (if (coll? e)\n        (reduce flattn v e)\n        (conj v e)))\n[] seqn))","user":"57f5a5a5e4b0d3187e9008d5"},{"problem":28,"code":"(fn flatt [s] (if (sequential? s)\n          \t\t(apply concat (map flatt s))\n                (list s)))","user":"5b7ec039e4b047b03b20375d"},{"code":"(fn foo [l]\n  (cond\n    (= '() l) '()\n    (nil? l) '()\n    (vector? l) (foo (seq l))\n    (seq? l) (concat (foo (first l)) (foo (rest l)))\n    :else (list l)\n  )\n)","problem":28,"user":"5002ad40e4b0678c553fc42b"},{"problem":28,"code":"(fn [orig]\n  (loop [mylist ()\n         relist orig]\n    (if (seq relist)\n      (let [hd (first relist)]\n        (if (sequential? hd)\n          (recur mylist (concat hd (rest relist)))\n          (recur (conj mylist hd) (rest relist))))\n      (reverse mylist))))","user":"540d7dd1e4b0addc1aec6713"},{"code":"(fn myflatten\n  ([coll]\n     (myflatten coll []))\n  ([coll acc]\n     (cond\n       (empty? coll) acc\n       (not (coll? (first coll))) (recur (rest coll) (conj acc (first coll)))\n       :else (recur (rest coll) (myflatten (first coll) acc)))))","problem":28,"user":"4dada6d4c9a9d6ed2c99dc57"},{"code":"(fn [s]\n  (loop [e (first s)\n         r (next s)\n         l []]\n    (cond\n     (nil? e) l\n     (sequential? e) (recur (first e) (concat (next e) r) l)\n     :default (recur (first r) (next r) (conj l e)))))","problem":28,"user":"52039e12e4b0fb7e47ea51ff"},{"code":"(letfn [(f1 [xxs] (mapcat f2 xxs))\n        (f2 [xs] (if (sequential? xs) (f1 xs) [xs]))]\n f1)","problem":28,"user":"4e96557d535dbda64a6f6b43"},{"problem":28,"code":"#(reduce\n  (fn foo [acc v]\n    (if-not (coll? v) (conj acc v)\n      (if (empty? v) acc\n        (if (coll? (first v)) (foo acc (first v))\n        (foo (conj acc (first v)) (rest v)))))) [] %)","user":"54133900e4b01498b1a719de"},{"problem":28,"code":"(fn flat [xs]\n  (if (= '() xs)\n    '()\n    (if (coll? (first xs))\n      (concat (flat (first xs)) (flat (rest xs)))\n      (cons (first xs) (flat (rest xs))))))","user":"5f3adcf4e4b004f08c61c531"},{"problem":28,"code":"(fn fl [xs]\n  (if (sequential? xs) (mapcat fl xs) (list xs)))","user":"54a7336be4b09f271ff37c95"},{"code":"(fn [x] \n   (filter (complement sequential?) (tree-seq sequential? seq  x)))","problem":28,"user":"4ff743fde4b0678c553fc38d"},{"code":"(fn [s] (filter #(not (sequential? %)) (tree-seq sequential? identity s)))","problem":28,"user":"5238ca2de4b0d705d026eef6"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n   (concat \n      (if (sequential? l)\n       (flt l)\n       [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"50ca2faee4b0a409464667dc"},{"problem":28,"code":"#(let [s sequential?] (filter (complement s) (rest (tree-seq s seq %))))","user":"5f265bd9e4b0857314092c8c"},{"code":"(fn [coll] \n   (letfn [(f0 [coll] (reduce #(if (coll? %2) (concat %1 (f0 %2)) (concat %1 (list %2))) [] coll))]\n     (f0 coll)))","problem":28,"user":"50a5f72fe4b0aa96157e2611"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x)\n                )\n          )\n  )","user":"605b1197e4b000d535e6f548"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    '()\n    (let [[head & tail] lst]\n      (if (coll? head)\n        (concat (my-flatten head) (my-flatten tail))\n        (cons head (my-flatten tail))))))","user":"5bb6166fe4b0a20761a23579"},{"problem":28,"code":"(fn my-filter [xs]\n  (let [left (first xs) right (next xs)]\n    (concat\n      (if (sequential? left)\n        (my-filter left)\n        [left])\n      (when (sequential? right)\n        (my-filter right)))))","user":"55ecaee4e4b0121d4835fdcd"},{"problem":28,"code":"(comp reverse (fn flatten' [xs] (let [flatten-step (fn [acc x] (cond (sequential? x) (concat (flatten' x) acc) :else (cons x acc)))] (reduce flatten-step [] xs))))","user":"60b616e1e4b0e0fa5f1b4243"},{"problem":28,"code":"(fn flt [xs] (reduce #(if (coll? %2) (into %1 (flt %2)) (conj %1 %2)) [] xs))","user":"5aeec90fe4b0cc2b61a3bc31"},{"problem":28,"code":"(partial\n  (fn f [res col]\n    (cond\n      (empty? col) res\n      (coll? (first col)) (f (f res (first col)) (rest col))\n      :else (f (conj res (first col)) (rest col)))) [])","user":"5e9f38cce4b00a66d4a9517e"},{"problem":28,"code":"(fn [coll]\n   (reduce (fn flatten-me [v e]\n             (if (coll? e)\n               (reduce flatten-me v e)\n               (conj v e)))\n           [] coll))","user":"5ab23c99e4b073f1774425e2"},{"problem":28,"code":"(fn flatten2 [sq]\n  (let [x (first sq)\n        y (rest sq)]\n    (cond (nil? x) nil\n          (coll? x) (concat (flatten2 x) (flatten2 y))\n          :else (cons x (flatten2 y)))))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn f [x] (if (coll? x) (apply concat (map f x)) (list x)))","problem":28,"user":"500854c4e4b028e089d3518c"},{"problem":28,"code":"(fn flatter [coll-1]\n  (reduce #(concat %1 %2) []\n    (map #(if (sequential? %) (flatter %) [%]) coll-1)))","user":"5b2e6b02e4b025bcb146f2d3"},{"code":"(fn fn28 [[first & rest :as all]]\n  (concat\n    \t(if (sequential? first) (fn28 first) [first])\n     \t(if (sequential? rest) (fn28 rest))\n    )\n  )","problem":28,"user":"5029f263e4b023940c84aa45"},{"problem":28,"code":"(fn fltn [s] (let [f (first s) r (rest s)]\n                 (cond\n                   (empty? s) nil\n                   (not (sequential? f)) (cons f (fltn r))\n                   :else (concat (fltn f) (fltn r)))))","user":"4f6de600e4b07046d9f4efd1"},{"code":"(fn f [xs]\n  (apply concat\n   (map (fn [x] (if (coll? x) (f x) (conj '() x))) xs)))","problem":28,"user":"52618ea3e4b03e8d9a4a7064"},{"problem":28,"code":"#(\n  loop [l1 % l2 '()]\n    (cond \n      (sequential? (first l1)) (recur (concat (first l1) (rest l1))  l2)\n      (empty? l1) (reverse l2)\n      :else (recur (rest l1) (cons (first l1) l2))))","user":"55c2367ee4b0e31453f64978"},{"problem":28,"code":"(fn [s]\n  (remove sequential? (rest (tree-seq sequential? seq s))))","user":"54497569e4b032a45b8693d2"},{"problem":28,"code":"(fn my-flatten \n  ([coll]\n   (my-flatten coll []))\n  ([coll acc]\n   (if (empty? coll)\n     acc\n     (let [[x & more] coll]\n       (if (coll? x)\n         (my-flatten more\n                     (vec (concat acc\n                                  (my-flatten x []))))\n         (my-flatten more (conj acc x)))))))","user":"5785de78e4b0ebec4cfb74e8"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce \n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n    [] coll)))","user":"5655d811e4b0f9d632dd849a"},{"code":"(fn myflat [x]\n    (if (sequential? x)\n      (reduce \n        #(loop [a %1 b %2] \n          (if (nil? (first b))\n            a\n            (recur (conj a (first b)) (rest b))\n          )\n        )\n        (map #(myflat %1) x)\n      )\n      [x]\n    )\n)","problem":28,"user":"513b77f3e4b00f740c76c403"},{"code":"(fn [xs] (map read-string (clojure.string/split \n  (.replaceAll (str xs) \"[()\\\\[\\\\]{}#]\" \"\") #\" \")))","problem":28,"user":"502d387fe4b0d96a44ab202f"},{"problem":28,"code":"(fn f [xs]\n    (if-not (sequential? xs) [xs]\n        (if (empty? xs) ()\n            (mapcat f xs))))","user":"59da6480e4b0ef0a1e9b5c68"},{"problem":28,"code":"(fn [col]\n  (let [f\n   (fn f [acc, x]\n     (if (coll? x)\n       (concat acc (reduce f [] x))\n       (concat acc [x])))]\n  (reduce f [] col)))","user":"57fdd1cfe4b0d3187e9009bf"},{"problem":28,"code":"#(filter \n  (complement sequential?) \n  (rest \n   (tree-seq sequential? seq %)))","user":"54a70af9e4b09f271ff37c93"},{"problem":28,"code":"(fn [coll]\n  (letfn [(my-flatten [res x]\n            (if (coll? x)\n              (reduce my-flatten res x)\n              (conj res x)))]\n    (reduce my-flatten [] coll)))","user":"5a4f11e5e4b05d388ecb6bc6"},{"problem":28,"code":"(fn flat [xs]\n  (when-let [[head & tail] (seq xs)]\n    (if (coll? head)\n      (concat (flat head) (flat tail))\n      (cons head (flat tail)))))","user":"58a58c50e4b01a0c0b232914"},{"problem":28,"code":"(fn f [xs] (if (sequential? xs) (apply concat (map f xs)) [xs]))","user":"4f1ef6a0535d64f60314649b"},{"problem":28,"code":"(fn [coll]\n  (loop\n    [[item & tail :as source] coll\n     result []]\n    (cond\n      (empty? source) (reverse result)\n      (coll? item) (recur (concat item tail) result)\n      :else (recur tail (cons item result)))))","user":"555b6e82e4b0deb715856e51"},{"problem":28,"code":"(fn [sq]\n  (filter #(not (sequential? %))\n        (tree-seq sequential? seq sq)))","user":"540c54a7e4b0addc1aec6700"},{"problem":28,"code":"(fn f [s]\n  (cond \n   \t(and (sequential? s) (empty? s)) '()\n   \t(sequential? s) (concat (f (first s)) (f (rest s)))\n    :else (list s)))","user":"5dee144ae4b093ff71727591"},{"problem":28,"code":";https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L6843\n;https://mwfogleman.github.io/posts/20-12-2014-flatcat.html\n\n#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))","user":"5564c113e4b0c656e3ff180d"},{"code":"(fn flat [s]\n  (seq (reduce (fn [r s']\n                 (if (sequential? s')\n                   (into r (flat s'))\n                   (conj r s')))\n               [] s)))","problem":28,"user":"51f55bdae4b0abb92f97f9d0"},{"code":"#(letfn [(rec [x] (if (coll? x) (apply concat (map rec x)) (list x)))] (rec %))","problem":28,"user":"51095588e4b0e34872b3efa5"},{"problem":28,"code":"(fn flat [xs]\n  (reduce (fn [acc x] \n              (if (sequential? x)\n                  (into [] (concat acc (flat x)))\n                  (conj acc x))) [] xs)\n  )","user":"570d0548e4b0b0fb43fd06d2"},{"problem":28,"code":"(fn newFlat [flt x] ( if (or (list? x) (vector? x)) (reduce concat flt (map #(newFlat [] %)  x)) (concat flt [x])))  []","user":"57986b76e4b039eba2ecb116"},{"problem":28,"code":"(fn flattener [coll]\n   (reduce (fn [accum subcoll]\n             (if (sequential? subcoll)\n               (into accum (flattener subcoll))\n               (conj accum subcoll)))\n           [] coll)\n   \n   )","user":"53ed6976e4b0d648e757f4c4"},{"code":"(fn flat [aseq]\n  (if (coll? aseq) (mapcat flat aseq) (list aseq)))","problem":28,"user":"52812b9fe4b0757a1b171423"},{"code":"(fn flatten_ [x]\n  (let [result\n    (reverse\n      (reduce\n        #(if (coll? %2)\n          (apply conj %1 %2)\n          (conj %1 %2))\n        ()\n        x))]\n    (if (some coll? result) (recur result) result)))","problem":28,"user":"527fd663e4b0757a1b1713de"},{"code":"(fn foo [s] (if (not (empty? (rest s))) (if (coll? (first s)) (concat (foo (first s)) (foo (rest s))) (cons (first s) (foo (rest s)))) (if (coll? (first s)) (foo (first s)) (cons (first s) '()))))","problem":28,"user":"50f9c7fde4b0e7c80cb15a52"},{"problem":28,"code":"(fn flat [x]\n    (if (empty? x)\n      [] \n      (if (coll? (first x))\n        (let [m (flat (first x)) \n              n (flat (rest x))]\n            (if (empty? n)\n              m \n              (concat m n)))\n        (let [w (flat (rest x))] \n          (concat [(first x)] w)))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":28,"code":"(fn my-flatten [lst]\n  (if (empty? lst)\n    lst\n    (let [l (first lst) r (next lst)]\n      (concat\n       (if (sequential? l)\n         (my-flatten l)\n         [l])\n       (if (sequential? r)\n         (my-flatten r))))))","user":"5560f39ce4b0c656e3ff17c2"},{"problem":28,"code":"(fn f [x]\n   (cond\n     (coll? x) (mapcat f x)\n     :else [x]))","user":"576e607ae4b0979f89651579"},{"code":"(fn my_flatten [arg]\n  (loop [col arg li ()]\n    (if (empty? col)\n      li\n      (recur \n        (rest col) \n        (concat li \n          (if (coll? (first col))\n            (my_flatten (seq (first col))) \n            (list (first col))\n            )\n          )\n        )\n      )\n    )\n  )","problem":28,"user":"4db7da66535d1e037afb2187"},{"problem":28,"code":"(fn flat [s] (if (sequential? s) (reduce concat () (map flat s)) (conj () s)))","user":"556f3b1ce4b09a3098a5251c"},{"code":"(fn flatter [xs]\n  (if (empty? xs) '() \n    (let [f (first xs)]\n      (concat \n        (if (coll? f) (flatter f) (list f)) \n        (flatter (rest xs))))))","problem":28,"user":"4fe2501ae4b0dd6cd5ce3644"},{"problem":28,"code":"(fn my-flatten [s]\n  (apply concat (map #(if (coll? %) (my-flatten %) [%]) s)))","user":"576df252e4b0979f8965156f"},{"problem":28,"code":"(fn [x]\n        (if (some sequential? x)\n          (recur (mapcat  #(if (sequential? %) % [%]) x))\n              x))","user":"5bf0b940e4b0a6d31fed215c"},{"problem":28,"code":"(fn new-flatten\n  [[x & xs]]\n  (cond\n   (nil? x) []\n   (coll? x) (concat (new-flatten x) (new-flatten xs))\n   :else (cons x (new-flatten xs))))","user":"550d9452e4b06e50f9beb15d"},{"problem":28,"code":"(fn flat-c [x]\n  (cond\n    (empty? x) (empty x)\n    (coll? (first x)) (concat (flat-c (first x)) (flat-c (rest x)))\n    :else (cons (first x) (flat-c (rest x)))))","user":"5e18c885e4b0dc95940084fc"},{"code":"(fn fl [ss]\n  (if-let [x (first ss)]\n    (if (sequential? x)\n      (concat (fl x) (fl (rest ss)))\n      (cons x (fl (rest ss)))\n      )\n    ))","problem":28,"user":"504e90bae4b069badc5a33b8"},{"problem":28,"code":"(fn [c] \n  (->> c ((fn f [vc coll] (reduce #(if (coll? %2) (f %1 %2) (conj %1 %2)) vc coll)) '()) reverse))","user":"55632016e4b0c656e3ff17e4"},{"code":"(fn fl [lst]\n  (cond (= lst ()) ()\n        (coll? lst) (concat (fl (first lst)) (fl (rest lst)))\n        :else (list lst)))","problem":28,"user":"4e8ad247535d65386fec2111"},{"problem":28,"code":"(fn doit [xs]\n  (apply concat (for [x xs]\n                  (if (sequential? x)\n                    (doit x)\n                    [x]))))","user":"540961e9e4b0addc1aec66db"},{"code":"(fn foo\n  [lst]\n    (if (coll? lst)\n    (mapcat foo lst)\n    (list lst)\n))","problem":28,"user":"4e6fe3a6535d5021c1a89629"},{"code":"#(loop [[first-element & rest-of] % result []]\n       (if (= nil first-element)\n         result\n         (if (coll? first-element)   \n           (recur (concat first-element rest-of) result)\n         (recur rest-of \n                (conj result first-element)))\n         ))","problem":28,"user":"53a26cede4b0f1fc7453882a"},{"problem":28,"code":"#((fn vecrecr [ret x]\n        (if (next x)\n          (if (coll? (first x))\n            (recur (vecrecr ret (first x)) (drop 1 x))\n            (recur (into ret (list (first x))) (drop 1 x)))\n          (if (coll? (first x))\n            (vecrecr ret (first x))\n            (into ret (list (first x))))))\n      [] %)","user":"55a372f1e4b0acc240e31537"},{"problem":28,"code":"(fn [tree]\n  (loop [this (first tree) others (next tree) result []]\n    (if-not this\n      result\n      (if-not (sequential? this)\n        (recur (first others) (next others) (conj result this))\n        (recur (first this) (concat (next this) others) result)))))","user":"589f2cefe4b02bd94d917e75"},{"code":"(fn flat [x] (if (coll? x) (mapcat flat x) [x]))","problem":28,"user":"4f6160a7e4b0defedf855fbe"},{"problem":28,"code":"(fn f [x]\n   (if (sequential? x)\n     (mapcat f x)\n     [x]))","user":"58b80ec1e4b0ebc645576d89"},{"code":"(fn my-flatten [seq]\n  (loop [s seq f (sequence nil)]\n      (cond\n        (empty? s)   f\n        (sequential? (first s)) (recur (rest s) (concat f (my-flatten (first s))))\n        :else (recur (rest s) (concat f [(first s)])))))","problem":28,"user":"50651de3e4b0b1b6c8b1d85f"},{"problem":28,"code":"#(apply concat (map (fn my-flat [x]\n                      (if (sequential? x)\n                        (apply concat (map my-flat x))\n                        (list x))) %))","user":"53cf278ce4b00fb29b2212fb"},{"problem":28,"code":"(fn ! [xs]\n\t(cond\n\t\t(empty? xs) '()\n\t\t(sequential? (first xs)) (concat (! (first xs)) (! (rest xs)))\n\t\t:else (cons (first xs) (! (rest xs)))\n\t)\n)","user":"5409f8eae4b0addc1aec66e6"},{"code":"#(filter (comp not %) (tree-seq % identity %2)) sequential?","problem":28,"user":"52bf29fde4b07a9af579232e"},{"code":"(fn my-flatten[x]\n   (if (coll? x)\n     (when (seq x)\n       (concat (my-flatten (first x)) (my-flatten (rest x))))\n     (list x)))","problem":28,"user":"4e50ad74535dc968683fc4ec"},{"problem":28,"code":"(fn [lst] (reduce (fn flatLst [lst1 value]\n          (if (sequential? value)\n           (reduce flatLst lst1 value)\n           (conj lst1 value))) [] lst))","user":"5f84f110e4b0375e81f54e79"},{"code":"(fn flatten* [xs]\n  (apply concat (map #(if (coll? %) (flatten* %) (list %)) xs)))","problem":28,"user":"529dc421e4b04e0c58e87b80"},{"problem":28,"code":"(fn flattn [x]\n  (if (coll? x)\n    (if (empty? x)\n      x\n      (concat (flattn (first x)) (flattn (rest x))))\n    [x]))","user":"54d9366ce4b0a52adc2e204e"},{"problem":28,"code":"(fn f [c] \n  (if (coll? c) \n    (mapcat f c) [c]))","user":"5e5f8a07e4b0fd0acd15867c"},{"problem":28,"code":"(fn my-flatten\n  [some-seq]\n  (let\n   [left (first some-seq)\n    new-left (if (coll? left)\n               left\n               (list left))]\n    (if (or (coll? left) (not (empty? (rest some-seq))))\n      (concat (my-flatten new-left) (my-flatten (rest some-seq)))\n      some-seq)))","user":"5f735915e4b02876ed9fd097"},{"problem":28,"code":"(fn [col']\n  (letfn [(my-flatten [col]\n\t  (if (empty? col)\n\t\t  col\n\t\t  (if (sequential? (first col))\n\t\t\t  (recur (concat (first col) (rest col)))\n\t\t\t  (cons (first col) (my-flatten (rest col))))))]\n     (my-flatten col')))","user":"5b855800e4b047b03b2037cd"},{"code":"(fn [ls]\n  (loop [ls  (seq ls)\n         out (seq [])]\n    (cond\n     (empty? ls) out\n     (sequential? (first ls)) (recur (concat (first ls) (rest ls)) out)\n     :else (recur (rest ls) (concat out (seq [(first ls)]))))))","problem":28,"user":"4ec6297b535d6d7199dd36c4"},{"problem":28,"code":"(fn myFlatten [x]\n  ((fn flattenAcc [acc, in]\n    (if (<= (count in) 0)\n      acc\n      (if (or (seq? (first in)) (vector? (first in)))\n        (recur acc (concat (first in) (drop 1 in)))\n        (recur (concat acc (take 1 in)) (drop 1 in)))))\n   '() x))","user":"578559a2e4b0ebec4cfb74da"},{"code":"(fn [x]\n  (letfn [(flat [coll]\n\t                  (lazy-seq\n\t                   (when-let [c (seq coll)]\n\t                     (let [x (first c)]\n\t                       (if (sequential? x)\n\t                         (concat (flat x) (flat (rest c)))\n\t                         (cons x (flat (rest c))))))))]\n\t    (if (sequential? x) (flat x) x)))","problem":28,"user":"50e3f311e4b0463d32072487"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x) (mapcat flat x) (list x)))\n\n;;;;\n;,\n\n\n;I want to get back to exercise 28 and ask you a quick question. I kind of understand how it works. mapcat calls the function with x if coll? is true but,\n;what exactly map+concat mapping, I have tried to to change to map and take first example ((fn flat [x]  (if (coll? x) (map flat x) (list x))) '((1 2) 3 [4 [5 6]]))\n;and the result is: (((1) (2)) (3) ((4) ((5) (6)))) and it looks like the map calls the function which maps x structure which is () so each element in the collection should be with ()?\n;so probably the main question would be how to write a function that I could get the result (((1) (2)) (3) ((4) ((5) (6)))) by using map but not using if statement?\n\n;;;ats: \n;The short answer:  the `concat` part of `mapcat` is going to combine all the calls to the `flat` function, starting with the last one which returns `(list x)` \n;and working backwards to the first call.\n;The longer answer:\n;Both `map` and `mapcat` return a lazy sequence.  So actually they dont produce answers until they hit the end of \n;a collection or the end of a recursive function call (when the recursive function call stops calling itself). \n;So `map` and `mapcat` need some kind of end condition before putting all the results back together.\n;Without an end condition you would just be returned a pointer to a lazy sequence, which could be infinite.  So then something around that lazy sequence would need to make it evaluate.\n;;;\n;;;Without some kind of break, then the code would never finish executing.  So you could use `when` instead of `if` but you are still doing the same thing.\n;;The `if` condition determines if we call the `flat` function again. \n;Without the `if` then you would call `flat` an infinite number of times (well until your computer ran out of memory).\n;If you look at the implementation of the `flatten` function, it uses tree-seq to navigate through all the levels of the collection and uses \n;a `when` condition to test if the branch is a node (has children) or not.\n\n\n\n;; (0s)  \"master\" mark ~/dojo/fourclj > lein run\n;TRACE t562: (fourclj.core/f28 ((1 2) 3 [4 [5 6]]))\n;TRACE t563: | (fourclj.core/f28 (1 2))\n;TRACE t564: | | (fourclj.core/f28 1)\n;TRACE t564: | | => (1)\n;TRACE t565: | | (fourclj.core/f28 2)\n;TRACE t565: | | => (2)\n;TRACE t563: | => (1 2)\n;TRACE t566: | (fourclj.core/f28 3)\n;TRACE t566: | => (3)\n;TRACE t567: | (fourclj.core/f28 [4 [5 6]])\n;TRACE t568: | | (fourclj.core/f28 4)\n;TRACE t568: | | => (4)\n;TRACE t569: | | (fourclj.core/f28 [5 6])\n;TRACE t570: | | | (fourclj.core/f28 5)\n;TRACE t570: | | | => (5)\n;TRACE t571: | | | (fourclj.core/f28 6)\n;TRACE t571: | | | => (6)\n;TRACE t569: | | => (5 6)\n;TRACE t567: | => (4 5 6)\n;TRACE t562: => (1 2 3 4 5 6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;;;;","user":"5ce5b43be4b0a17bb84e2b7a"},{"code":"(fn f [c]\r\n  (if-not (coll? c)\r\n    (list c)\r\n    (reduce concat (map f c))))","problem":28,"user":"4f6a36eee4b07046d9f4ef99"},{"code":"(fn [xs]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq xs))))","problem":28,"user":"52a779fce4b0c58976d9ac1a"},{"code":"(fn [x]\n  (seq\n    (reduce\n      (fn my-flatten [c e]\n        (if (coll? e)\n          (reduce my-flatten c e)\n          (conj c e)))\n      [] x)))","problem":28,"user":"5192dd39e4b0c663c5d86c9e"},{"code":"(fn [coll]\n   ((fn fl [co res]\n      (loop [c co\n             agg res]\n        (if (> (count c) 0)\n          (recur\n           (rest c)\n           (if (coll? (first c))\n             (into [] (fl (first c) agg))\n             (conj agg (first c))\n             ))\n          agg))) coll []))","problem":28,"user":"52090567e4b0e152394d76ed"},{"code":"(letfn [(F [coll]\n           (cond (not (coll? coll)) (list coll) \n                 (empty? coll) '()\n                 :else (concat (F (first coll))\n                               (F (rest coll)))))]\n  F)","problem":28,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn f [s]\n  (if-let [[x & xs] (seq s)]\n    (concat\n     (if (coll? x)\n       (f x)\n       [x])\n     (f xs))))","problem":28,"user":"504ffb8fe4b0a02f9cffdeae"},{"problem":28,"code":"(fn my-flatten\n   [x]\n   (filter (complement sequential?)\n           (rest (tree-seq sequential? seq x))))","user":"5f6aef6de4b02876ed9fd04a"},{"problem":28,"code":"(fn fsq[seeq]\n\n   (loop [r seeq\n          acc []]\n     (if (empty? r)\n       acc\n       (let [i (first r)\n             res (rest r)]\n         (if (or (seq? i) (vector? i))\n           (recur (concat [(first i)] (rest i) res), acc)\n           (recur res, (conj acc i))\n           )\n         )\n       )\n     )\n   )","user":"54bbba99e4b0ed20f4ff6ec2"},{"code":"(fn [x] \n  (reverse ((fn rec [x acc]\n\t\t      (cond (= '() x) acc\n\t\t\t    (not (coll? x)) (conj acc x)\n\t\t\t    true (rec (first x) (rec (rest x) acc))))\n\t\t\t    x [])))","problem":28,"user":"5097ea89e4b087ccf61a7af4"},{"problem":28,"code":"(fn smoosh [x]\n  (reduce \n    (fn [new-seq new-val]\n      (if (coll? new-val)\n        (into new-seq (smoosh new-val))\n        (conj new-seq new-val)\n      )\n    )\n    []\n    x\n  )\n)","user":"5fa5a6b1e4b0fa27300f3dc8"},{"code":"(fn myflatten [xs]\n  (if (empty? xs) xs\n  (if (coll? (first xs))\n    (concat (myflatten (first xs)) (myflatten (rest xs)))\n    (cons (first xs) (myflatten (rest xs))))))","problem":28,"user":"5097cd83e4b00ad8bab4e974"},{"problem":28,"code":"(fn [coll]\n (seq\n  (reduce\n   (fn my-flatten [v e]\n     (if (coll? e)\n       (reduce my-flatten v e)\n       (conj v e)))\n   [] coll)))","user":"540f2c48e4b0addc1aec6727"},{"code":"(fn [col]\n  (loop [c col acc ()]\n    (if (nil? c)\n        (reverse acc)\n        (if (coll? (first c))\n            (recur (concat (first c) (next c)) acc)\n            (recur (next c) \n                   (conj acc (first c)))))))","problem":28,"user":"50a6b5e8e4b0aa96157e262a"},{"problem":28,"code":"(fn flat [xs] (if (coll? xs) (mapcat flat xs) (list xs)))","user":"53e9a15be4b036ad0777e4ae"},{"problem":28,"code":"(fn my-flatten\n  [[h & t]]\n  (if (or (vector? h) (list? h) (seq? h))\n    (concat (my-flatten h)  (if (nil? t) [] (my-flatten t)))\n    (cons h (if (nil? t) [] (my-flatten t)))))","user":"563d4600e4b0bfe05bf1184c"},{"code":"(fn [c]\n  (if (empty? (filter coll? c))\n     c\n    (recur (mapcat (fn [c] (if (coll? c) c (conj [] c))) c))))","problem":28,"user":"4e8a0d5d535d3e98b802328e"},{"code":"(fn [s]\n  (loop [x s xs []]\n      (if (empty? x) xs\n        (if (not (coll? (first x))) (recur (rest x) (conj xs (first x)))\n          (recur (concat (first x) (rest x)) xs)))))","problem":28,"user":"4daf907aedd6309eace4d17b"},{"problem":28,"code":"(fn test\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"53e150e5e4b0d874e779ae53"},{"problem":28,"code":"(fn make-flat [value]\n  (if (sequential? value)\n    (mapcat make-flat value)\n    [value]))","user":"5443a894e4b032a45b869388"},{"problem":28,"code":"(fn flat [alist] (let [atom? (complement sequential?) f (first alist) r (rest alist)] (if (nil? f) nil (if (atom? f) (cons f (flat r) )  (concat (flat f) (flat r))))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":28,"code":"(fn my-flat [x]\n  (reduce (fn [coll x]\n            (if (sequential? x)\n              (vec (concat coll (my-flat x)))\n              (conj coll x)))\n          []\n          x))","user":"5b15ab32e4b0cc2b61a3be72"},{"code":"(fn fltn \n  ([xs]\n    \n    (if (empty? xs) \n      xs \n      (if (coll? (first xs)) \n       (concat (fltn (first xs)) (fltn (rest xs)))\n       (cons (first xs) (fltn (rest xs)))\n      )\n    )   \n\n  )\n)","problem":28,"user":"5200054de4b023d2eb508ca7"},{"code":"(fn self [col] (if (coll? col) (mapcat self col) (list col)))","problem":28,"user":"5233ad08e4b07e3ee2be83ac"},{"problem":28,"code":"(fn flat [col]\n (let [left (first col)\n       right (next col)]\n        (concat\n         (if (sequential? left)\n          (flat left)\n          [left])\n         (when (sequential? right)\n          (flat right)))))","user":"54580586e4b01be26fd74616"},{"code":"(fn platt [x]\n  (if (coll? x)\n    (when (seq x)\n      (lazy-seq (concat (platt (first x)) (platt (rest x)))))\n    (list x)))","problem":28,"user":"4f50cadce4b03ad3f0c10d0f"},{"problem":28,"code":"(comp reverse (fn my-flat [l]\n    (reduce (fn [l e]\n              (if (sequential? e)\n                (concat (my-flat e) l)\n                (conj l e))\n              ) '() l)))","user":"54ca130ce4b057c6fda3a250"},{"code":"(fn [coll]\n  (filter (comp not coll?)\n          (tree-seq coll? seq coll)))","problem":28,"user":"4f32ef71e4b0d6649770a098"},{"code":"(fn c-flatten\n  [f-seq]\n  (if (sequential? f-seq)\n    (mapcat c-flatten f-seq)\n    (list f-seq)))","problem":28,"user":"4feacba7e4b0140c20fb9c0e"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll acc []]\n    (if (empty? coll)\n      acc\n      (let [h (first coll)\n            r (rest coll)]\n        (if (sequential? h)\n          (recur (concat h r) acc)\n          (recur r (conj acc h)))))))","user":"54fdbe3fe4b07d26eda61d3b"},{"code":"(fn flat [item-list] (let [test (first item-list) rest-list (next item-list)] (concat (if (sequential? test) (flat test) [test]) (when (sequential? rest-list) (flat rest-list)))))","problem":28,"user":"4ec12516535dfed6da9c6da7"},{"problem":28,"code":"(fn flat [coll]\n  (cond\n   (nil? coll) ()\n   (coll? (first coll)) (concat (flat (first coll)) (flat (next coll)))\n   :else (conj (flat (next coll)) (first coll))))","user":"5421f74fe4b01498b1a71abb"},{"code":"(fn my-flatten\n  ([coll] (my-flatten coll (list)))\n  ([coll acc]\n    (if (empty? coll)\n      acc\n      (my-flatten\n        (rest coll)\n        (concat acc\n          ((fn [x]\n            (if (coll? x) (my-flatten x) (list x))) (first coll))\n))))\n)","problem":28,"user":"4f650efee4b07046d9f4ef39"},{"problem":28,"code":"(fn flattn [xs]\n  (if (not (sequential? xs)) [xs]\n    (if (empty? xs) '()\n      (doall (concat (flattn (first xs)) (flattn (rest xs)))))))","user":"599d49a7e4b0871e7608b7f4"},{"code":"(fn flat [v]\n  (let [append \n        (fn append [f r]\n          (if (empty? f)\n            r\n            (if (coll? r)\n              (cons (first f) (append (rest f) r))\n              (cons (first f) (append (rest f ) (list r))))))] \n  (reduce \n   (fn [f, r]\n     (if (coll? f)\n       (append f r)\n       (cons f r)))\n   (map (fn [e]\n          (if (coll? e)\n            (flat e)\n            (list e) )) \n         v))))","problem":28,"user":"52d51535e4b09f7907dd133a"},{"problem":28,"code":"(fn f [c?] (if (sequential? c?) (mapcat f c?) [c?]))","user":"5066003ee4b0313a384e5647"},{"problem":28,"code":"(fn flatten* [s]\n  (if (coll? s)\n    (mapcat flatten* s)\n    [s]))","user":"553b0d95e4b09218d5f44fff"},{"code":"(fn my-flat [thing]\n  (let [l (first thing)\n        r (next thing)]\n    (concat \n      (if (sequential? l) (my-flat l) [l])\n      (when (sequential? r) (my-flat r)))))","problem":28,"user":"4f74fe77e4b0fbe0118ec552"},{"code":"(fn flatten2 [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"525b12b1e4b0cb4875a45d04"},{"code":"(fn flat \n    ([x] (flat [] x))\n    ([to x] (if (coll? x) (reduce flat to x) (conj to x))))","problem":28,"user":"52cc4fd6e4b07d0d72b27360"},{"code":"(fn fl [xs]\n  (letfn [(fl2 [[x & r] f]\n               (do\n                 (prn x \\, r \\, f)\n               (if (sequential? x)\n                 (fl2 r (fl2 x f))\n                 (if x \n                   (fl2 r (cons x f))\n                   f))))]\n         (reverse (fl2 xs nil))))","problem":28,"user":"4ffa213ee4b0678c553fc3b7"},{"code":"(fn flattn [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flattn l)\n        [l])\n      (if (sequential? r)\n        (flattn r)\n      )\n    )\n  )    \n)","problem":28,"user":"4fc3b0d4e4b081705acca343"},{"problem":28,"code":"(fn flatten-seq [xs]\n  (filter (comp not sequential?)\n          (tree-seq sequential? seq xs)))","user":"56efc9fde4b04a395b9a0464"},{"problem":28,"code":"(fn flattens [colls]\n  (println \"Objeto da vez\" colls)\n  (if (coll? colls)\n    (mapcat flattens colls)\n    [colls]))","user":"5e2ef900e4b05b4b015161fc"},{"code":"(fn my-flatten [coll]\n  (let [[x & xs] coll]\n    (cond\n     (empty? coll) '()\n     (coll? x)      (concat (my-flatten x) (my-flatten xs))\n     :else          (cons x (my-flatten xs)))))","problem":28,"user":"4e95a440535dbda64a6f6b37"},{"problem":28,"code":"(fn flat [elem]\n  (if (sequential? elem)\n    (apply concat (map flat elem))\n    (list elem)))","user":"540d0087e4b0addc1aec670b"},{"code":"(fn [coll] \n  (seq \n    (reduce \n      (fn my-flatten [v e] \n        (if (coll? e) \n          (reduce my-flatten v e) \n          (conj v e)))\n    [] coll)))","problem":28,"user":"4fbcbd50e4b081705acca2f9"},{"problem":28,"code":"(fn myfl [sequ]\n  (if (empty? sequ)\n    '()\n    (let [e (first sequ)\n          r (rest sequ)]\n      (if (sequential? e)\n        (concat (myfl e) (myfl r))\n        (cons e (myfl r))))))","user":"589c6914e4b00487982d535d"},{"code":"(fn f[x] \n   ( if (sequential? x) \n     ( if ( empty? x ) () ( concat (f(first x)) (f (rest x)))) \n     [x]) \n   )","problem":28,"user":"5271b940e4b03e8d9a4a73fb"},{"code":"(fn flat [s]\n  (mapcat #(if (coll? %) (flat %) (list %)) s))","problem":28,"user":"50748923e4b054001656acd3"},{"problem":28,"code":"reduce (fn flat [acc x] \n         (concat acc (if (sequential? x) (reduce flat '() x) [x] ))\n           ) '()","user":"54e51c7be4b024c67c0cf7f7"},{"problem":28,"code":"(fn [s] \n  (filter (complement sequential?) (rest (tree-seq sequential? identity s))))","user":"55a21be1e4b0acc240e3151e"},{"code":"(fn flat [l]\n  (if (not (or (seq? l) (vector? l)))\n    (list l)\n    (if (= (count l) 0)\n      '()\n      (concat (flat (first l))\n            (flat (rest l))))))","problem":28,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":28,"code":"(fn my-flatten [sequence]\n  (if (not (= '() sequence))\n    (if (or (seq? sequence)\n            (vector? sequence))\n      (concat (my-flatten (first sequence))\n              (my-flatten (rest sequence)))\n      (list sequence))\n    '()))","user":"58637f03e4b0f14aab7c881e"},{"problem":28,"code":"(fn my-flatten [seq]\n  (let [first (first seq), rest (rest seq)]\n    (cond\n      (sequential? first) (my-flatten (concat first rest))\n      (nil? first) []\n      :else (concat [first] (my-flatten rest))\n      )))","user":"569f7bc2e4b0542e1f8d1494"},{"problem":28,"code":"(fn flatten-it [x]\n  (if (coll? x)\n    (reduce (fn [lst elem]\n              (into lst (flatten-it elem))) [] x)\n    [x]))","user":"57ef7f0ee4b0bfb2137f5bd9"},{"problem":28,"code":"(fn my-flatten\n  [[first-el & rest-els]]\n  (if (empty? rest-els)\n    (if (coll? first-el)\n      (my-flatten first-el)\n      (list first-el))\n    (if (coll? first-el)\n      (concat (my-flatten first-el) (my-flatten rest-els))\n      (concat (list first-el) (my-flatten rest-els)))))","user":"55b28b57e4b01b9910ae296c"},{"code":"(fn flat\r\n    [c] (reduce\r\n            (fn [a b]\r\n              (if (sequential? b)\r\n                (concat a (flat b))\r\n                (concat a [b])))\r\n            []\r\n            c))","problem":28,"user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(fn my-flatten [x]\n  (reduce\n    (fn [c i]\n      (if (sequential? i)\n        (concat c (my-flatten i))\n        (concat c (conj '() i))))\n    '() x))","problem":28,"user":"4daea587edd6309eace4d15a"},{"problem":28,"code":"(fn [coll] \n  (seq (reduce \n  \t(fn extract-element [v e] \n      (if (coll? e) \n        (reduce extract-element v e) \n        (conj v e))) \n    [] coll)))","user":"59f027e3e4b0966464fe6a3c"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x)\n    (if (empty? x) \n      '() \n      (do (concat (flat (first x)) (flat (rest x)))))\n    (do (list x))))","user":"5ce708b7e4b0a17bb84e2b9b"},{"code":"(fn myflatten [list]\n  (mapcat \n    (fn [l] (if (sequential? l)\n      (myflatten l)\n      [l])) list))","problem":28,"user":"4edd9d79535d10e5ff6f532b"},{"problem":28,"code":"#(filter (complement coll?)(tree-seq coll? seq %))","user":"538d70abe4b0b51d73faae6e"},{"problem":28,"code":"(fn flatten' [seq]\n  (lazy-seq \n   (cond\n    (empty? seq) nil\n    (sequential? (first seq)) (concat (flatten' (first seq)) (flatten' (rest seq)))\n    :else (cons (first seq) (flatten' (rest seq))))))","user":"602aa5f1e4b0d5df2af2225d"},{"code":"(fn f [s] (reduce\n   #(if (coll? %2)\n      (concat % (f %2))\n      (concat % [%2]))\n   [] \ns))","problem":28,"user":"4ee9ddb8535d93acb0a66896"},{"problem":28,"code":"(fn my-flatten [coll]\n  (when-let [s  (seq coll)]\n    (if (coll? (first s))\n      (concat (my-flatten (first s)) (my-flatten (rest s)))\n      (cons (first s) (my-flatten (rest s))))))","user":"5da3a458e4b000c986472bed"},{"problem":28,"code":"#(reverse (reduce (fn rec-flatten [acc item]\n             (if (coll? item) (reduce rec-flatten acc item)\n                 (conj acc item)))\n           (list)%))","user":"59e62655e4b08badc2a0c568"},{"problem":28,"code":"(fn [coll]\n         (loop [C coll acc []]\n           (if (empty? C) \n             acc\n             (let [ff (first C) rr (rest C)]\n               (if (coll? ff)\n                 (recur (concat ff rr) acc)\n                 (recur rr (conj acc ff))\n                 )\n               )\n             )\n           )\n         )","user":"552d9013e4b076ab5578f7ea"},{"code":"(fn myflatten [s] \n  (loop [r [] s s]\n    (println [ r s])\n    (if-let [f (first s)] \n       (if (sequential? f)\n         (recur (concat r (myflatten f)) (rest s))\n         (recur (concat r (list f)) (rest s)))\n       r)))","problem":28,"user":"4ebe766d535dfed6da9c6d94"},{"code":"(fn fla [c]\n  (loop [c c res []]\n    (if (seq c)\n       (let [f (first c)]\n         ;(println \"rest:\" r \" res: \" res)\n           (recur (rest c) \n                  (if (sequential? f)\n                    (concat res (fla f))\n                    (conj (vec res) f))))\n       res )))","problem":28,"user":"502904e0e4b0feaf66e22fad"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn my-flatten [acc e]\n      (if (coll? e)\n        (reduce my-flatten acc e)\n        (conj acc e)))\n[] coll)))","user":"595fd77ce4b066ee0a44b06f"},{"code":"(fn ft [l]\n  (cond\n    (empty? l) '()\n    (not (coll? (first l))) (cons (first l) (ft (rest l)))\n    :else (concat (ft (first l)) (ft (rest l)))))","problem":28,"user":"4f890488e4b033992c121c76"},{"problem":28,"code":"(fn jp [x] (if (empty? x) () (if (coll? (first x)) (concat (jp (first x)) (jp (rest x))) (cons (first x) (jp (rest x))))))","user":"544e1794e4b0e39780006980"},{"problem":28,"code":"(fn flat [c]                                                                                                                                                                                                                                                                  \n    (reduce (fn [val1 val2]    \n              (if (coll? val2)                                           \n                (concat val1 (flat val2))    \n                (concat val1 (list val2))))                                     \n            '() c))","user":"5de68f83e4b0986d99407f6c"},{"problem":28,"code":"(fn [s]\n  (loop [o s f '()]\n    (if (empty? o)\n      f\n      (let [felem (first o)]\n        (if (coll? felem)\n          (recur (concat felem (rest o)) f)\n          (recur (rest o) (concat f [felem])))))))","user":"55b66ebce4b01b9910ae2996"},{"problem":28,"code":"(fn flutten [seqn]\n  (let [l (first seqn) r (next seqn)]\n    (concat\n     \t(if (sequential? l)\n          (flutten l)\n          [l])\n     \t(when (sequential? r)\n          (flutten r)))))","user":"569aca1ee4b0542e1f8d144d"},{"code":"#((fn fltn [l nl] (let [[x & xs] l n nl] (if (or (seq? x) (coll? x)) (fltn (concat x xs) n) (if (empty? xs) (conj n x) (fltn xs (conj n x)))))), % [])","problem":28,"user":"51b1ef95e4b02f8f128bb95e"},{"code":"(fn my-flatten [coll]\n  (let [ele (first coll)\n        coll- (rest coll)]\n      (if (nil? ele)\n         '()\n         (if (sequential? ele)\n           (concat (my-flatten ele) (my-flatten coll-))\n           (concat (list ele) (my-flatten coll-))))))","problem":28,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn my-flatten\n  ([x] (mapcat #(if (coll? %) (my-flatten %) [%]) x))\n  ([x & more] (my-flatten (cons x more))))","problem":28,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn [coll]\n       (letfn [(my-flatten [coll]\n                 (if coll\n                   (let\n                     [s (seq coll) f (first s)]\n                     (concat\n                       (if\n                         (sequential? f)\n                         (my-flatten f)\n                         (cons f '()))\n                       (my-flatten (next s))))))]\n         (my-flatten coll)))","problem":28,"user":"514d7e29e4b019235f6c0587"},{"problem":28,"code":"#(loop [nx [] xs (apply list %)] (prn nx xs) (cond (empty? xs) nx (coll? (first xs)) (recur nx (into (rest xs) (reverse (first xs)))) :else (recur (conj nx (first xs)) (rest xs))))","user":"5c41db45e4b08cd430848ece"},{"code":"(fn [s]\n  (loop [remaining s\n         result []]\n    (if (empty? remaining)\n      result\n      (let [x (first remaining)]\n        (if (sequential? x)\n          (recur (concat x (rest remaining)) result)\n          (recur (rest remaining) (conj result x)))))))","problem":28,"user":"51899891e4b0288ada3dbdab"},{"problem":28,"code":"(fn flat[s]\n(if (coll? s)\n  (mapcat flat s)\n  [s]))","user":"5e980e6be4b0157ca96647d6"},{"code":"(fn f [x]\r\n  (if (coll? x) (concat [] (reduce #(concat %1 (f %2)) [] x)) [x]))","problem":28,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":28,"code":"(fn my-flatten [lst]\n    (reduce concat '()\n        ((fn flat [el]\n            (if (coll? el) (map my-flatten el)\n                (list (list el)))) lst )))","user":"56ef0a2ee4b04a395b9a045a"},{"problem":28,"code":"(fn flat [coll]\n  (loop [remain coll result '()]\n    (if (nil? remain)\n      (reverse result)\n      (let [first-item (first remain)]\n        (if (coll? first-item)\n          (recur (concat first-item (next remain)) result)\n          (recur (next remain) (cons (first remain) result)))))))","user":"54734a0de4b0c51c1f4d727b"},{"code":"(fn my-flatten [[x & rest]]\n  (concat \n     (if (coll? x)\n      (my-flatten x)\n      [x])\n   \t(when (coll? rest)\n      (my-flatten rest))))","problem":28,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn my-flatten\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"51af4cf6e4b0c53cf2e68a4c"},{"code":"(fn fake [xs]\n  (cond\n    (empty? xs)\n      (list )\n    (or (list? (first xs)) (vector? (first xs)))\n      (concat (fake (first xs)) (fake (rest xs)))\n    true\n      (concat (list (first xs)) (fake (rest xs)))\n  )\n)","problem":28,"user":"50217818e4b00bba4502f7a7"},{"problem":28,"code":"(fn [col]\n    (loop [retCol      ()\n           firstEntry  (first col)\n           restEntries (rest col)]\n      (if (nil? firstEntry)\n        (reverse retCol)\n        (if (sequential? firstEntry)\n          (recur retCol (first firstEntry) (concat (rest firstEntry) restEntries))\n          (recur (conj retCol firstEntry) (first restEntries) (rest restEntries))))))","user":"59932f49e4b0b211ea3aaaae"},{"code":"(fn flat2 [coll]\n (cond\n   (nil? (first coll))\n     (list)\n   (coll? (first coll))\n     (concat\n       (flat2 (first coll))\n       (flat2 (rest  coll)))\n   :else\n     (cons (first coll) (flat2 (rest coll)))))","problem":28,"user":"51b08df5e4b0c53cf2e68a67"},{"problem":28,"code":"(fn flat [n]\n  (\n    let [[x & xs] n]\n    (\n      cond\n        (empty? n) '()\n        (coll? x) (concat (flat x) (flat xs))\n        :else (cons x (flat xs))\n    )\n  )\n)","user":"58d737cee4b03c36ff7e5982"},{"code":"(fn my_flatten [l] \n  (cond \n    (not (sequential? l)) [l]\n    :else (reduce concat [] (map my_flatten l))\n  )\n)","problem":28,"user":"53979a87e4b0b51d73faaef0"},{"code":"(fn fl[s]\n  (cond\n    (nil? s) ()\n    (coll? s) (concat (fl (first s)) (fl (next s)))\n    :else (list s)))","problem":28,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn my-flat [s]\n  (cond\n\t(empty? s) '()\n    (coll? (first s)) (concat (my-flat (first s)) (my-flat (rest s)))\n  \t:else (cons (first s) (my-flat (rest s)))))","problem":28,"user":"5102ef6be4b00c483ae176fc"},{"code":"(fn fl [xs] (if (empty? xs) () (let [h (first xs) t (rest xs)] (if (coll? h) (fl (concat h t)) (conj (fl t) h)))))","problem":28,"user":"50d242c0e4b06ad58337ed0f"},{"code":"(fn flat[coll] (\n                let [[l r] [(first coll) (next coll)]]\n                (concat \n                 (if (sequential? l)\n                   (flat l) \n                   [l]) \n                 (when (sequential? r) \n                   (flat r)))))","problem":28,"user":"518f9e14e4b08646f171ca07"},{"code":"(fn flat [x]\n    (if (coll? x)\n      (if (empty? x)\n            []\n            (concat (flat (first x)) (flat (rest x)))\n      )\n      (vector x)\n    )\n)","problem":28,"user":"504f191ae4b0e7ad84dbc4ba"},{"code":"#(remove sequential? \n  (tree-seq sequential? identity %))","problem":28,"user":"4e260220535deb9a81d77ef0"},{"code":"#(reverse\n  (\n    (fn f [x]\n      (loop [xs x ys ()]\n        (if (empty? xs)\n          ys\n          (if (sequential? (first xs))\n            (recur (rest xs) (concat (f (first xs)) ys))\n            (recur (rest xs) (cons (first xs) ys))\n          )\n        )\n      )\n    ) %\n  )\n)","problem":28,"user":"51897709e4b0288ada3dbdaa"},{"code":"(fn flattenfoo [a]\n  (if (sequential? a)\n    (reduce (fn [acc i]\n              (println (format \"i: %s acc: %s\" i acc))\n              (if (sequential? i)\n                (do\n                  (println \"found seq\")\n                  (apply conj acc (flattenfoo i)))\n                (conj acc i)))\n            []\n            a)\n    [a]))","problem":28,"user":"4fa3c137e4b081705acca193"},{"problem":28,"code":"#(loop [s % \n   r '()]\n   (cond \n     (sequential? (first s)) (recur (concat (first s) (rest s)) r)\n     (empty? s) (reverse r)\n     :else (recur (rest s) (cons (first s) r))\n     )\n   )","user":"5763818ae4b0994c1922fbc7"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll flat '()]\n    (cond\n     (sequential? (first coll)) (recur (concat (first coll) (rest coll)) flat)\n     (empty? coll) (reverse flat)\n     :else (recur (rest coll) (cons (first coll) flat)))))","user":"5f238a59e4b0f565ad99828d"},{"code":"(fn [x]\n  (let [child? (fn [node] (not (sequential? node)))\n        parent? (complement child?)]\n    (filter child?\n      (rest\n        ; tree-seq will walk nodes\n        (tree-seq parent? seq x)))))","problem":28,"user":"50464831e4b011c5dfee771f"},{"code":"#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e28120f535deb9a81d77efa"},{"problem":28,"code":"(fn flattenarray [col]\n  (if (coll? col)\n    (reduce #(into %1 (flattenarray %2)) []  col)\n    (list col))\n     )","user":"57d588a5e4b0bd073c2023b6"},{"code":"#(remove % (tree-seq % seq %2)) coll?","problem":28,"user":"4e7db3b4535db169f9c796e1"},{"problem":28,"code":"(fn hb [coll] (reduce (fn [coll1 x] (concat coll1 (if (coll? x) \n                                                    (hb x) [x]))) '() coll))","user":"582290b5e4b04b46fc4b0fa0"},{"problem":28,"code":"(letfn [(ff\n             [vs]\n             (println vs)\n             (if-let [[f & rst] (seq vs)]\n               (if (sequential? f)\n                 (lazy-cat (ff f) (ff rst))\n                 (cons f (ff rst)))\n               []))]\n     ff)","user":"57acb156e4b0b8559636fc8d"},{"code":"(fn [x]\n  (letfn [(flat [coll]\n            (lazy-seq\n              (when-let [c (seq coll)]\n                (let [x (first c)]\n                  (if (sequential? x)\n                    (concat (flat x) (flat (rest c)))\n                    (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"5058afbbe4b06522596eba81"},{"problem":28,"code":"(fn myFlatten [x] \n  (if (sequential? x) \n  \t(mapcat myFlatten x)\n    (list x)))","user":"595d2041e4b066ee0a44b014"},{"problem":28,"code":"(fn flatn [xs]\n  (if (sequential? xs)\n    (mapcat flatn xs)\n    (list xs)))","user":"4ff24a1ae4b0678c553fc337"},{"problem":28,"code":"(fn flatten-it [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"55993deee4b031d6649c9ba5"},{"code":"(fn [s]\n  (if (every? (comp not sequential?) s)\n    s\n    (recur (apply concat\n                  (map #(if (sequential? %) % [%])\n                       s)))))","problem":28,"user":"4f84a4a4e4b033992c121c39"},{"problem":28,"code":"(fn flat2 [x]\n   (if (coll? x)\n     (reduce concat (map flat2 x))\n     [x]))","user":"550b5c10e4b06e50f9beb143"},{"problem":28,"code":"(fn f1 [xs]\n      (if  (sequential? xs)\n        (let [xs1 (vec xs)]\n        (if (empty? xs1)\n          ()\n           (reduce conj (f1 (first xs1)) (f1 (rest xs1))  )))\n        [xs]\n      ))","user":"53ca23e3e4b00fb29b2212c6"},{"code":"(fn f [x]\n  (cond (empty? x)\n        x\n        (coll? (first x))\n        (concat (f (first x)) (f (rest x)))\n        :else\n        (cons (first x) (f (rest x)))))","problem":28,"user":"51421253e4b0b50abeb46b2a"},{"problem":28,"code":"(fn trample [arg]\n   (reduce #(if (coll? %2) (concat %1 (trample %2)) (concat %1 [%2])) '() arg))","user":"577829f9e4b0979f8965165a"},{"code":"reduce\n(fn self [xs e] (concat xs (cond (coll? e) (reduce self '() e) true (list e))))\n'()","problem":28,"user":"52537b67e4b0541d1855b8f9"},{"code":"(fn fl [s]\n  (if (coll? s)\n    (mapcat #(fl %) s)\n    (list s)))","problem":28,"user":"5150a7d7e4b03e678e393abb"},{"problem":28,"code":"(fn [s]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s)))\n  )","user":"56f2611fe4b04a395b9a04a2"},{"code":"(fn flat[ss](\n             mapcat #(if (sequential? %) \n                       (flat %) \n                       (list %)) ss))","problem":28,"user":"51c1d159e4b0d204dbe2ca18"},{"problem":28,"code":"(fn [x]\n  (filter\n   \t(complement sequential?)\n    (rest (tree-seq sequential? seq x))))","user":"598876fee4b021a7a535feb7"},{"problem":28,"code":"(fn siemka [x]\n  (if (sequential? x)\n    (concat (siemka (first x)) (siemka (next x)))\n    (if (nil? x) \n      [] \n      [x])))","user":"53fb4843e4b0de5c4184857d"},{"code":"(fn flat [in]\n  (if (sequential? in)\n    (mapcat flat in)\n    (list in)))","problem":28,"user":"52dcd378e4b09f7907dd13d6"},{"problem":28,"code":"(fn flatit [coll]\n  (if (empty? coll)\n    '()\n    (let [car (first coll)\n          cdr (rest coll)]\n      \n      (if (coll? car)\n\t\t(flatit ((fn mergeit [c1 c2]\n\t\t\t\t\t  (if (empty? c1)\n\t\t\t\t\t    c2\n\t\t\t\t\t    (let [car (first c1)\n\t\t\t\t          \t  cdr (rest c1)] \n\t\t\t\t\t      (conj (mergeit cdr c2) car)))) car cdr))\n        (conj (flatit cdr) car)))))","user":"51a0370ae4b0b292b01ee3ef"},{"problem":28,"code":"(fn [s]\n  (loop [s (list s) out []]\n    (if-let [n (first s)]\n      (if (sequential? n)\n        (recur (apply conj (next s) (reverse n)) out)\n        (recur (next s) (conj out n)))\n      out)))","user":"5958cef6e4b066ee0a44af94"},{"problem":28,"code":"(fn myfn\n\n\t[seq1]\n\n\t(if (empty? seq1 )\n\t\tnil\n\n\t\t(if (coll? (first seq1))\n\t\t\t(concat (myfn (first seq1)) (myfn (rest seq1)) )\n\t\t\t(concat (list (first seq1)) (myfn (rest seq1)))\n\n\t\t\t)\n\n\n\t\t)\n\n\n\t)","user":"55897fe2e4b059ccff29b205"},{"code":"(fn fl[x]\n  (if (empty? x)\n    '()\n    (if (coll? (first x))\n      (concat (fl (first x)) (fl (rest x)))\n      (cons (first x) (fl (rest x))))))","problem":28,"user":"533431e4e4b019098a6f8b8d"},{"problem":28,"code":"(fn flattener [someseq] \n  (if (coll? someseq)\n    (mapcat flattener someseq)\n    [someseq]))","user":"56bff105e4b060a8e693e3a4"},{"problem":28,"code":"#(seq\n  (reduce\n   (fn my_flatten [result eingabe]\n     (if (coll? eingabe)\n       (reduce my_flatten result eingabe)\n       (conj result eingabe)))\n   [] %))","user":"54630e6be4b01be26fd746bc"},{"problem":28,"code":"(fn ! [xs] (apply concat (map #(if (instance? clojure.lang.Seqable %) (! %) (list %)) xs)))","user":"54c641f8e4b045293a27f628"},{"problem":28,"code":"(fn l\n   [[x & xs]]\n   (concat (if (sequential? x) (l x) [x]) (if (nil? xs) [] (l xs))))","user":"542f574be4b0dad94371f2d0"},{"problem":28,"code":"(fn flat [coll] (reduce concat (map #(if (coll? %) (flat %) (vector %)) coll)))","user":"587294f0e4b01531a375ea1e"},{"problem":28,"code":"(fn [stuff]\n        (filter #(not (sequential? %)) (rest (tree-seq sequential? seq stuff))))","user":"5251b11be4b0541d1855b87b"},{"code":"(fn fltn [seq]\n  (if (empty? seq)\n    '()\n    (let [f (first seq)]\n      (if (coll? f) \n        (concat (fltn f) (fltn (rest seq)))\n        (cons f (fltn (rest seq)))))))","problem":28,"user":"4eac5bc1535d7eef3080731b"},{"problem":28,"code":"(fn [coll]\n  (letfn [(get-val [c]\n            (if (sequential? c)\n              (let [[h & t] c]\n                (if (nil? t) (get-val h)\n                    (concat (get-val h) (get-val t))))\n              [c]))]\n    (get-val coll)))","user":"52950ab6e4b02ebb4ef7501a"},{"code":"(fn [input] \n  (let [seqOrVec?    (fn [xs] (or (seq? xs) (vector? xs))) \n        flatten-once (fn [xs] \n                        (reduce #(if (seqOrVec? %2) \n                                     (concat %1 %2) \n                                     (concat %1 (list %2)))  '() xs ))]\n  (loop [result input]\n   (if (not (some seqOrVec? result)) \n       result\n       (recur (flatten-once result)))\n)))","problem":28,"user":"4ed500bb535d10e5ff6f52d3"},{"problem":28,"code":"(fn my-flatten\n  [[a & more]]\n  (if (nil? a)\n    []\n    (if (sequential? a)\n      (concat (my-flatten a) (my-flatten more))\n      (concat [a] (my-flatten more)))))","user":"57b5dc52e4b0fbc9809a27b3"},{"problem":28,"code":"(fn flattener [items]\n  (reduce (fn [acc item]\n            (if (or (vector? item) (list? item))\n                (let [fst (first item)\n                      lst (rest item)]\n                  (if (or (vector? fst) (list? fst))\n                    (into acc (flattener fst))\n                    (into (conj acc fst) (flattener lst))))\n                (conj acc item)\n                )) [] items))","user":"5c8aa02de4b048ec896c5958"},{"problem":28,"code":"(fn flat [llist]\n (reduce (fn [acc x]\n           (if (coll? x)\n             (vec (concat acc (flat x)))\n             (conj acc x))) [] llist))","user":"5d1cf523e4b02ea6f0fb6994"},{"problem":28,"code":"(fn f [x]\n  (mapcat\n    #(cond\n      (and\n        (coll? %)\n        (not-any? coll? %))\n       %\n      (coll? %) (f %)\n      :else (list %)\n    )\n    x\n  )\n)","user":"580e7761e4b0849f6811b753"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (if (empty? x) '()\n      (let [x1 (first x)\n            xs (my-flatten (rest x))]\n        (if (sequential? x1)\n          (concat (my-flatten x1) xs)\n          (conj xs x1)))))","user":"56897739e4b0dcc4269f407d"},{"problem":28,"code":"(fn f [x]\n  (if (= x ())\n    x\n    (if (sequential? (first x))\n      (concat (f (first x)) (f (rest x)))\n      (cons (first x) (f (rest x))))))","user":"57152731e4b07c98581c3ad0"},{"problem":28,"code":"(fn flat \n  ([s] (flat s '()))\n  ([s res]\n  \t(if \n      (or (seq? s) (vector? s))\n      (if \n        (empty? s)\n        res\n        (->>\n          res\n          (flat (rest s))\n          (flat (first s))))\n      (cons s res))))","user":"5ba75fdfe4b0a20761a23419"},{"code":"(fn [x]\n  (letfn [(flat [coll]\n                (lazy-seq\n                 (when-let [c (seq coll)]\n                   (let [x (first c)]\n                        (if (sequential? x)\n                          (concat (flat x) (flat (rest c)))\n                          (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"4feb1888e4b0140c20fb9c15"},{"code":"(fn flatten-helper [l]\r\n    (cond\r\n     (empty? l) '()\r\n     (not (sequential? (first l)))\r\n     (conj (flatten-helper (rest l)) (first l))\r\n     :else\r\n     (concat (flatten-helper (first l)) (flatten-helper (rest l)))))","problem":28,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (concat (my-flatten (first s))\n            (if (empty? (rest s))\n              nil\n              (my-flatten (rest s))))\n    [s]))","problem":28,"user":"4e7e3504535db169f9c79709"},{"problem":28,"code":"(fn flat [s]\n  (seq (reduce (fn [acc cur]\n                 (if (coll? cur)\n                   (vec (concat acc (flat cur)))\n                   (conj acc cur)))\n               []\n               s)))","user":"5d431c77e4b07c84aa5ae68f"},{"code":"#(letfn [(go [dest src]\n             (if (sequential? src)\n               (if-not (empty? src)\n                 (go (go dest (first src)) (rest src))\n                 dest)\n               (conj dest src)))]\n   (go [] %))","problem":28,"user":"525ab6cfe4b0cb4875a45cf9"},{"problem":28,"code":"(fn my-flatten [x]\n  (cond (empty? x) x\n        (sequential? (first x)) (concat (my-flatten (first x)) (my-flatten (rest x)))\n        :else (cons (first x) (my-flatten (rest x)))))","user":"576000fce4b08062f99a4e8b"},{"code":"(fn myflat [coll]\n   (loop [[x & xs] coll\n          res []]\n     (if (nil? x)\n       res\n       (recur\n         xs\n         (cond\n           (nil? x) res\n           (sequential? x) (vec (concat res (myflat x)))\n           :default (conj res x))))))","problem":28,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":28,"code":"(fn flat [coll]\n(reduce \n    (fn [acc x]\n      (if (coll? x) \n        (vec (concat acc (flat x)))\n        (vec (conj acc x)))) [] coll))","user":"5a388675e4b001c08efc0ca2"},{"problem":28,"code":"(fn flat [s]\n  (if (not (coll? s))\n    (cons s '())\n    (if (empty? s)\n      '()\n      (concat (flat (first s))\n              (flat (rest s))))))","user":"57df2722e4b0bd073c20245e"},{"problem":28,"code":"(fn flat [lst]\n  (let [\n    head (first lst)\n    rst (rest lst)\n  ]\n  (cond\n    (nil? head) '()\n    (not (coll? head)) (cons head (flat rst))\n    :else (concat (flat head) (flat rst))\n  )\n))","user":"59cc6c1ee4b0a024fb6ae5d2"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x)))]\n    (reduce f* [] c)\n    ))","user":"5f45211ae4b0955706451fbc"},{"code":"(fn fl [x] (if (sequential? x)(apply concat (map fl x)) [x]))","problem":28,"user":"4ebad797535dfed6da9c6d6a"},{"code":"(fn asflat [s]\n  (if (or (list? s) (vector? s))\n    (reduce #(concat % (asflat %2))\n            '() s)\n    (list s)))","problem":28,"user":"503a234de4b088a6a14ca76d"},{"problem":28,"code":"(fn flatten-seq [s]\n  (reduce \n   (fn r\n     [res a]\n     \n     (if (coll? a)\n     \n       (concat res (flatten-seq a))\n       \n       (concat res (list a) )))\n   '() s))","user":"5969bb32e4b069c0a1a197ed"},{"problem":28,"code":"(fn f [n] \n\t(if-not (coll? n)\n\t\t(if (coll? n) n (if (nil? n) '() (list n)))\n\t\t(concat (f (first n)) (f (next n)))\n\t)\n)","user":"553b90c8e4b09218d5f45005"},{"code":"(fn fl [s]\n  (cond\n    (nil? s) '()\n    (sequential? (first s)) (concat (fl (first s)) (fl (next s)))\n    :else (conj (fl (next s)) (first s))))","problem":28,"user":"4e444c11535dc968683fc4a9"},{"problem":28,"code":";; (fn flat[xs]\n;;  (reduce\n;;   (fn [memo x]\n;;     (if (coll? x)\n;;       (into memo (flat x))\n;;       (conj memo x)))\n;;   []\n;;   xs))\n\n;; (fn dig[xs]\n;;   (cond\n;;     (empty? xs) '()\n;;     (coll? (first xs)) (concat (dig (first xs)) (dig (rest xs)))\n;;     :else (cons (first xs) (dig (rest xs)))))\n\n#(filter (complement coll?)\n         (tree-seq coll? identity %))","user":"5980f91ae4b021a7a535fddd"},{"problem":28,"code":"(fn my-flat [xs]\n  (cond\n    (empty? xs) []\n    (coll? (first xs)) (concat (my-flat (first xs)) (my-flat (rest xs)))\n    :else (cons (first xs) (my-flat (rest xs)))))","user":"54c8d4a8e4b045293a27f654"},{"problem":28,"code":"(fn [x] \n     (reduce (fn rec-flat [ls a]\n                 (if (coll? a)\n                     (reduce rec-flat ls a)\n                     (conj ls a)))\n               [] \n               x))","user":"56ca2f25e4b0ea9b8538f716"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))\n;;; everybody steal this one )))","user":"53d0d7a9e4b00fb29b22130c"},{"code":"(fn fl [s]\n  (cond\n    (empty? s) '()\n    (or (seq? (first s)) (vector? (first s))) (concat (fl (first s)) (fl (rest s)))\n    :else (cons (first s) (fl (rest s)))))","problem":28,"user":"4f22e667e4b0d66497709fdb"},{"problem":28,"code":"(fn \n  [coll]\n  (letfn [(flat\n            [coll]\n            (let [rs (atom ())]\n              (loop [coll coll]\n                (if (nil? coll)\n                  @rs\n                  (let [e (first coll)]\n                    (if (coll? e)\n                      (swap! rs #(concat %1 %2) (flat e))\n                      (swap! rs #(concat %1 %2) [e]))\n                    (recur (next coll)))))))]\n    (flat coll)))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":28,"code":"(fn [x] (let [_flatten (fn [coll callback] (cond (empty? coll) nil\n                            (not (sequential? (first coll))) (cons (first coll) (callback (rest coll) callback))\n                            :else (concat (callback (first coll) callback) (callback (rest coll) callback))))]\n  \t\t(_flatten x _flatten)))","user":"59cf6fbce4b0ef0a1e9b5b6c"},{"problem":28,"code":"(fn my-flatten[s]\n  (if (sequential? s)\n    (mapcat my-flatten s)\n    (list s)))","user":"581b4d3be4b04b46fc4b0ec6"},{"problem":28,"code":"#(->> % (tree-seq sequential? seq) rest (filter (complement sequential?)))","user":"58e5e585e4b056aecfd47ca2"},{"problem":28,"code":"(fn f\n  ([x] (f x []))\n  ([[s & m] o] \n   (if (not s)\n     o \n     (if (sequential? s)\n       (f m (f s o))\n       (f m (conj o s))))))","user":"55f9b2b6e4b03cbcff9738c8"},{"code":"(fn my-flat [xs]\n  (if (-> xs first coll?)\n    (concat (my-flat (first xs)) (my-flat (rest xs)))\n    (if (-> xs count (= 0)) \n      nil\n      (cons (first xs) (my-flat (rest xs))))))","problem":28,"user":"4dca56b6535d5973398f9287"},{"problem":28,"code":"(fn my-flatten [indx]\n  (lazy-seq\n   (reduce (fn --internal-flatten [col v]\n             (if (sequential? v)\n               (reduce --internal-flatten col v)\n               (conj col v)))\n           []\n           indx)))","user":"58884cc6e4b0f1effa3b770e"},{"problem":28,"code":"(fn flat [v] (reduce #(if (coll? %2) (concat %1 (flat %2)) (concat %1 [%2])) '() v))","user":"53e1e1f1e4b0d874e779ae5e"},{"problem":28,"code":"(fn flat [xs]\n  (loop [acc []\n         xs (seq xs)] \n    (if-let [rs (seq xs)]\n      (let [head (first rs)\n            tail (next rs)]\n        (if (coll? head)\n          (recur acc (concat head tail))\n          (recur (conj acc head) tail)))\n      acc)))","user":"54d0afb6e4b0e8a36923e5cd"},{"code":"(fn myflatten [x]\n  (let [result '()\n        flat? (empty? (filter coll? x))]    \n    (if flat?\n      x\n      (myflatten (reduce \n                  (fn [x y]\n                    (let [a (if (coll? x) x (list x))\n                          b (if (coll? y) y (list y))]\n                       (concat a b))) x)))))","problem":28,"user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn flat [coll]\n  (lazy-seq\n    (when-let [c (seq coll)]\n      (let [f (first c)]\n        (if (sequential? f)\n          (concat (flat f) (flat (rest c)))\n          (cons f (flat (rest c))))))))","problem":28,"user":"50928ecfe4b097f48cc38570"},{"code":"(fn f [x] (if (coll? x) (mapcat f x) (list x)))","problem":28,"user":"4e9e0640535dbda64a6f6b91"},{"problem":28,"code":"(fn flat [lst]\n  (loop [[element & rst] lst result nil]\n    (println element)\n    (cond\n      (nil? element) result\n      (sequential? element) (recur rst (concat result (flat element)))\n      :else (recur rst (concat result [element])))))","user":"55d354e0e4b0e31453f64a62"},{"problem":28,"code":"(fn banana [x]\n  (if (coll? x)\n    (reduce concat (map banana x))\n    (list x)))","user":"5dcc5e5ce4b02b31cc3da3c7"},{"problem":28,"code":"(fn [coll]\n  (if (every? (comp not coll?) coll)\n    coll\n    (recur (mapcat #(if (coll? %) % [%])\n                   coll))))","user":"5297dcc5e4b02ebb4ef75047"},{"code":"(fn [coll] (loop [out (seq coll)]\n  (if \n    (not-any? coll? out)\n    out\n    (recur (mapcat #(if (coll? %) % (list %)) out))\n  )\n))","problem":28,"user":"4f0365fd535dcb61093f6aa5"},{"problem":28,"code":"(fn [col]\n  (filter (complement sequential?) (tree-seq sequential? identity col)))","user":"56c427bbe4b05cc29241ee94"},{"problem":28,"code":"(fn fl [x]\n  (if (coll? x)\n    (if (> (count x) 1)\n      (apply conj (fl (rest x)) (reverse (fl (first x))))\n      (fl (first x)))\n    (list x)))","user":"543be8f0e4b032a45b869337"},{"problem":28,"code":"(fn [col]\n  (letfn [(fl1 [col]\n            (if (empty? col)\n              col\n              (if (coll? (first col))\n                (concat (fl1 (first col)) (fl1 (rest col)))\n                (cons (first col) (fl1 (rest col)))))\n            )]\n    (fl1 col)\n    )\n  )","user":"5a89997de4b05369db4d24c4"},{"problem":28,"code":"(fn f [s]\n    (cond (empty? s)\n             s\n          (coll? (first s)) \n            (concat (f (first s)) (f (rest s)))\n          :else\n            (cons (first s) (f (rest s)))))","user":"54be7c0de4b0ed20f4ff6eec"},{"problem":28,"code":"(fn my-flatten [input]\n       (if (coll? input)\n         (apply concat (map my-flatten input))\n         [input]))","user":"53f891eee4b0de5c4184856d"},{"problem":28,"code":"(fn t[xs]\n  (let [check #(filter sequential? %)]\n    (loop [s xs e (check s)]\n      (if \n      \t(empty? e)\n      \ts\n        (let [b (first e)\n              new (concat (take-while #(not (= % b)) s) b (rest (drop-while #(not (= % b)) s)))]\n          (recur new (check new)))))))","user":"52aaabf7e4b0c58976d9ac68"},{"code":"(fn f[s]\r\n  ((fn ff[s, r]\r\n    (let [elem (first s)]\r\n      (if (nil? elem)\r\n\t      r\r\n\t      (recur (next s) (concat r (if (coll? elem)\r\n\t                               (ff elem [])\r\n\t                               [elem]\r\n\t                               ))) \r\n\t    )\r\n     )\r\n   ) s [])\r\n)","problem":28,"user":"4f245d77e4b0d66497709feb"},{"problem":28,"code":"#(loop [coll %,\n        result []]\n   (cond\n    (empty? coll) result\n    (coll? (first coll)) (recur (concat (first coll) (rest coll)) result)\n    :else (recur (rest coll) (conj result (first coll)))))","user":"56e6ef89e4b02e7e935eb6d0"},{"problem":28,"code":"(fn [x](let [w* (fn w [z y] (if (coll? y) (reduce w z (seq y)) (conj z y)))](reduce w* [] x)))","user":"59f4d0e0e4b0966464fe6ab9"},{"problem":28,"code":"(fn [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"#(loop [[h & t] % r []] (if h (if (coll? h) (recur (concat h t) r) (recur t (conj r h))) r))","problem":28,"user":"4eb298c1535d7eef3080734b"},{"code":";(fn f [x]\n;  (if (coll? x)\n;    (mapcat f x)\n;    [x]))\n#(filter (complement sequential?)\n         (rest (tree-seq sequential? seq %)))","problem":28,"user":"4ebbc1f6535dfed6da9c6d72"},{"problem":28,"code":"(fn [coll]\n  (filter #(not (sequential? %)) (tree-seq sequential? seq coll)))","user":"567695c2e4b05957ce8c6157"},{"problem":28,"code":"(fn flat [v]\n  (if (sequential? v)\n     (mapcat flat v)\n     [v]))","user":"55b0d315e4b002ce9d5cbc26"},{"code":"(fn [s]\n  (letfn [(f [s]\n            (if (coll? s)\n              (mapcat f s)\n              (list s)))]\n    (mapcat f s)))","problem":28,"user":"4fc13433e4b081705acca32b"},{"code":"(fn fl [in]\n  (mapcat (fn [item]\n    (if (sequential? item)\n(fl (seq item))\n[item])) in))","problem":28,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":28,"code":"(fn my-flatten [x]\n    (if (empty? x) ()\n        (if (coll? (first x))\n            (concat (my-flatten (first x))(my-flatten (rest x)))\n            (conj (my-flatten (rest x)) (first x)))))","user":"56fc1bc7e4b07572ad1a88dd"},{"problem":28,"code":"(fn flt [args]\n  (loop [seq-map [] not-flat args]\n\t(if (empty? not-flat)\n      seq-map\n\t(let [first-arg (first not-flat)]\n      (if (sequential? first-arg)\n        (recur (into seq-map (flt first-arg)) (rest not-flat))\n        (recur (conj seq-map first-arg) (rest not-flat)))))))","user":"5691ef12e4b0dcc4269f40f8"},{"code":"(fn [x]\n  (filter #(not (sequential? %))\n          (tree-seq sequential? identity x)))","problem":28,"user":"4e964f4a535dbda64a6f6b42"},{"code":"#(filter (complement coll?) (tree-seq coll? identity %))","problem":28,"user":"4dbbe3b9535d3f4042261ecf"},{"problem":28,"code":"(fn enflat [col]\n    (reverse\n        (reduce\n            (fn mapper [acc val]\n                (if (coll? val)\n                    (into acc (reverse (reduce mapper '() val)))\n                    (conj acc val)))\n            '()\n            col)))","user":"59aeff12e4b0e1f4e384c8af"},{"code":"(fn flt [x]\n  (if (sequential? x)\n    (apply concat (map flt x))\n    [x]))","problem":28,"user":"4f2b0951e4b0d6649770a045"},{"problem":28,"code":"(fn [s]\n  (letfn [(aux [s]\n            (loop [head (first s) tail (rest s) acc ()]\n              (cond (nil? head) acc\n                    (coll? head) (recur (first tail)\n                                        (rest tail)\n                                        (concat (aux head) acc))\n                    :else (recur (first tail)\n                                 (rest tail)\n                                 (cons head acc)))) )]\n    (reverse (aux s))))","user":"57035ccfe4b08d47c97781ef"},{"problem":28,"code":"(fn fltn\n   ([] [])\n   ([x] (if (sequential? x) \n          (into (fltn (first x)) (fltn (next x)))\n          (if (nil? x) [] [x])\n          )))","user":"55deeface4b050e68259b3ea"},{"problem":28,"code":"(fn my-flat [coll]\n  (if (sequential? coll)\n    (apply concat (map my-flat coll))\n    (list coll)))","user":"52fe31d5e4b047fd55837038"},{"code":"(fn [col]\n  (loop [c col acc `()]\n    (let [x (first c)]\n      (cond \n         (nil? x) acc\n         (coll? x) (recur (concat x (next c)) acc)\n         true (recur (next c) (concat acc (list x)))))))","problem":28,"user":"531792d9e4b08068f379ed5e"},{"problem":28,"code":"(fn flat [array]\n\t(loop [a array c ()]\n\t\t(if (empty? a)\n\t\t\tc\n\t\t\t(if (sequential? (first a))\n\t\t\t\t(recur (rest a) (concat c (flat (first a))))\n\t\t\t\t(recur (rest a)(concat c (list (first a))))\n\t\t\t)\n\t\t)\n\t)\n)","user":"5af9b2cee4b0cc2b61a3bce2"},{"problem":28,"code":"(fn flattn [someseq] (mapcat #(if (sequential? %)\n                                 (flattn %)\n                                 (list %)) someseq))","user":"5e9878b9e4b0157ca96647d8"},{"code":"(fn flat\n  [c s]\n  (reduce (fn [a b]\n            (if (sequential? b)\n              (flat a b)\n              (conj a b)))\n          c\n          s)) []","problem":28,"user":"50afc0f9e4b0c3f5ed5c29a3"},{"problem":28,"code":"(fn my-flatten [the-seq]\n  (let [element (first the-seq)\n        rest-seq (rest the-seq)]\n    (if (empty? the-seq)\n      the-seq\n      (if (coll? element)\n        (concat (my-flatten element) (my-flatten rest-seq))\n        (concat [element] (my-flatten rest-seq))))))","user":"55a5c3bee4b0acc240e3154e"},{"code":"(fn my-flat [xs] (if (not (coll? xs)) (vector xs) (mapcat my-flat xs)))","problem":28,"user":"51c03929e4b0c9c82288292c"},{"code":"(fn fltn [col] (mapcat #(if (coll? %) (fltn %) [%]) col))","problem":28,"user":"53286389e4b09d4e7a9b5504"},{"code":"(fn [coll] \r\n  (letfn [(f [s]\r\n    (if (coll? s)\r\n      (mapcat f s)\r\n      (list s)))]\r\n  (f coll)))","problem":28,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":28,"code":"(fn [l]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq l)))\n  )","user":"558843dae4b059ccff29b1f3"},{"code":"(fn my-flatten [coll] \n  (let [[x & xs] coll]\n    (cond\n     (empty? coll) '()\n     (coll? x) (concat (my-flatten x) (my-flatten xs))\n     :else (cons x (my-flatten xs)))\n    ))","problem":28,"user":"52127ee4e4b0d32679a5063c"},{"code":"(fn flt [coll]\n  (loop [s coll\n         fl ()]\n    (if (empty? s)\n      fl\n      (let [l (first s)\n            rs (rest s)]\n        (if (sequential? l)\n          (recur rs (concat fl (flt l)))\n          (recur rs (concat fl (list l))))))))","problem":28,"user":"5361a4f2e4b0243289761e47"},{"problem":28,"code":"(fn [s]\n  (loop [res [] s s]\n    (if (empty? s)\n      res\n      (let [first (first s) rest (rest s)]\n       (if (coll? first)\n        (recur res (concat first rest) )\n        (recur (conj res first) rest)\n       )\n      )\n    )\n  )\n)","user":"5708b96ce4b0b0fb43fd06a3"},{"problem":28,"code":"(fn ! [xs]\n  (cond\n    (empty? xs) xs\n    (not (coll? (first xs))) (cons (first xs) (! (rest xs)))\n    :else (concat (! (first xs)) (! (rest xs)))))","user":"5722b6ece4b0c5bde472c0d4"},{"problem":28,"code":"(fn f [s]\n  (cond\n   (empty? s) '()\n   (coll? (first s)) (concat (f (first s)) (f (rest s)))\n   :default (conj (f (rest s)) (first s))))","user":"559454f2e4b0c79f6e1db952"},{"problem":28,"code":"(fn [ll] \n  (letfn [\n          (fl [agg col]\n                (if (coll? col)\n                  (reduce #(concat %1 (fl '() %2)) agg col)\n                  (conj agg col)\n                  )\n              )\n          ]\n    (fl '() ll)\n    )\n  )","user":"548ef1dee4b0e286459a1229"},{"problem":28,"code":"(fn flt[x] (mapcat #(if (coll? %) (flt %) [%]) x))","user":"52b434c9e4b0c58976d9ad1c"},{"code":"(fn flatten' [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"51811d5ee4b06547fbae113c"},{"code":"(fn [lst]\n\t(filter (complement sequential?)\n\t\t(rest (tree-seq sequential? seq lst))))","problem":28,"user":"537d4a69e4b06839e8705e8a"},{"code":"(fn new-flatten [xs]\n  (reduce concat [] (map #(if (coll? %) (new-flatten %) (vector %)) xs)))","problem":28,"user":"514a6199e4b0829bd132edb9"},{"code":"(fn flat [l]\n  (reduce #(if-not (sequential? %2)\n             (conj %1 %2)\n             (apply conj %1 (flat %2)))\n          [] l))","problem":28,"user":"5117c31ee4b0e0897831a60c"},{"problem":28,"code":"(fn [coll]\n (seq\n  (reduce\n   (fn r [a e]\n    (\n     (if (sequential? e) \n      (partial reduce r) \n      conj) a e))\n   []\n   coll)))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn flat [s] (if (coll? s) (mapcat flat s) [s]))","problem":28,"user":"4f89d489e4b033992c121c7e"},{"code":"(fn foo [x] (\n  if (nil? (first x))\n  ()\n  (if (coll? (first x))\n    (foo (concat (first x) (rest x) ))\n    (concat (list (first x)) (foo (rest x)))\n  )\n  )\n)","problem":28,"user":"4f4bd422e4b03ad3f0c10c7e"},{"problem":28,"code":"(fn my-flatten\n  [c]\n  (if (sequential? c)\n    (mapcat my-flatten c)\n    (list c)))","user":"5f3103aee4b0574c87022c24"},{"problem":28,"code":"(fn flat [coll] (if (sequential? coll) (mapcat flat coll)  [coll]) )","user":"5650082fe4b0284900eef6b7"},{"code":"(fn [coll] (filter (complement sequential?)\r\n            (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4dc6aade535d8a4b2fd7428c"},{"problem":28,"code":"(fn flat [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond \n      (empty? s) nil\n      (sequential? f) (concat (flat f) (flat r))\n      :else (cons f (flat r))\n    )  \n  )\n)","user":"5c4fd807e4b0f9f7a8770eb5"},{"problem":28,"code":"#(reverse ((fn rec [oli nli] (cond\n                               (empty? oli) nli\n                               (not (sequential? (first oli))) (rec (rest oli) (cons (first oli) nli))\n                               true  (rec (rest oli) (rec (first oli) nli))\n                               )) % nil))","user":"5b20134de4b03cfeda66ed2d"},{"problem":28,"code":"(fn flat [seq]\n  (reduce (fn [result item]\n          (if (coll? item)\n            (into result (flat item))\n            (conj result item)))\n          [] seq))","user":"5eb1a80ce4b00a66d4a951ff"},{"code":"(fn f [coll]\n  (mapcat #(if (coll? %) (f %) [%]) coll))","problem":28,"user":"4db3393e535df7e46ed9b6cc"},{"problem":28,"code":"(fn platt[x] \n  (if (empty? x) \n    '()\n     (\n       if (sequential? (first x))\n       (concat (platt(first x)) (platt (rest x)))\n       (conj (platt (rest x)) (first x))\n     )\n  )\n)","user":"57ea79d9e4b0bfb2137f5b4f"},{"code":"(fn flt [x] (if (sequential? x) (reduce concat (map flt x))(list x)))","problem":28,"user":"503c02e5e4b0fc0f99c2e54e"},{"code":"(fn fl [x]\n  (if-not (sequential? x)\n    (list x)\n    (mapcat fl x)))","problem":28,"user":"510db6cde4b078ea71921145"},{"problem":28,"code":"(fn my-flatten [seq] \n  (cond (nil? seq) '()\n        (not (sequential? seq)) (list seq)\n        (empty? seq) '()\n        :else (concat (my-flatten (first seq)) (my-flatten (rest seq)))))","user":"57002b81e4b08d47c97781c7"},{"problem":28,"code":"(fn flat [coll]\n   (reduce\n    (fn flat-rec [acc c]\n      (if (coll? c)\n        (reduce flat-rec acc c)\n        (conj acc c)))\n    [] coll))","user":"58800fd4e4b0f1effa3b7606"},{"problem":28,"code":"(fn\n        [x]\n          (filter (complement sequential?)\n                            (rest (tree-seq sequential? seq x))))","user":"5b73e500e4b047b03b2036ba"},{"problem":28,"code":"(fn re [c] \n  (reduce (fn [acc e] \n            (if (coll? e) \n              (into acc (re e)) \n              (conj acc e)) )\n            [] \n            c))","user":"5cf935f4e4b0b71b1d808a8f"},{"problem":28,"code":"(fn fl [s]\n  (if-not (coll? s) (list s)\n    (if (empty? s) ()\n      (let [a (first s)\n            b (rest s)\n            fa (fl a)\n            fb (fl b)]\n        (concat fa fb)))))","user":"5e9a3814e4b0157ca96647e7"},{"code":"(fn f [n] (let [[x & more] n] (concat (if (coll? x) (f x) [x])(when (coll? more) (f more)))))","problem":28,"user":"5294b190e4b02ebb4ef75011"},{"problem":28,"code":"(fn flattr [x]\n  (if (coll? x)\n    (mapcat flattr x)\n    [x]))","user":"589f0b8ee4b02bd94d917e71"},{"problem":28,"code":"#(reduce (fn f2 [res x]\n   (if (coll? x)\n     (reduce f2 res x)\n     (conj res x))) [] %)","user":"5ed6c4ede4b016b56eae05e3"},{"code":"(fn foo [x]\n  (if (sequential? x)\n    (if (= (count x) 0)\n      ()\n      (concat (foo (first x) )  (foo (rest x))  )\n      )\n    (list x)\n    )\n   )","problem":28,"user":"51b5a6e0e4b0f094dd986fce"},{"problem":28,"code":"#(filter (complement coll? )(tree-seq coll? identity %))","user":"54f4a457e4b0f2f3c5226e83"},{"problem":28,"code":"(fn my-flatten [item]\n  (if (coll? item)\n    (loop [coll item\n           res []]\n      (if (empty? coll)\n        res\n        (recur (rest coll) (concat res (my-flatten (first coll))))))\n    [item]))","user":"578d459ee4b0ebec4cfb7567"},{"code":"(fn [l]\n  (let [ [gl bl]  (split-with (comp not coll?) l) v vec i into]\n    (if (empty? bl)\n      gl\n      (recur (i (v  (i (v gl) (v  (first bl)))) (v (rest bl)))))))","problem":28,"user":"5007cdb9e4b0b17c647f5227"},{"code":"#(loop [o [] c %] \n     (if (empty? c)\n       o\n       (let [ f (first c) \n             r (rest c) \n             i (coll? f) ]\n         (recur (if i o (conj o f)) \n                (if i (concat f r) r)))))","problem":28,"user":"4f1d1d95535d64f603146488"},{"code":"(fn [coll] (\n  filter (complement sequential?)\n    (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4e36425c535deb9a81d77f33"},{"problem":28,"code":"(fn flat [coll] (if (coll? coll) (mapcat flat coll) (list coll)))","user":"59e63a2ce4b08badc2a0c569"},{"code":"(fn [x]\n  (filter\n  \t#(not (sequential? %))\n  \t(tree-seq sequential? seq x)))","problem":28,"user":"50f48298e4b004d364930527"},{"problem":28,"code":"(fn unravel\n  ([xs]\n   (unravel [] xs))\n  ([ts x]\n   (if (coll? x)\n     (reduce unravel ts x)\n     (conj ts x))) )","user":"58e37946e4b005f69f193cae"},{"problem":28,"code":"(fn\n  [x]\n  (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","user":"4f6ba7bce4b07046d9f4efb0"},{"problem":28,"code":"(fn flat\n  ([s]\n   (flat s []))\n  ([s accum]\n   (if (empty? s)\n     accum\n     (if (#(or (number? %) (string? %) (keyword? %)) (first s))\n       (flat (rest s) (concat accum (vector (first s))))\n       (flat (rest s) (concat accum (flat (first s) [])))\n     )\n   )\n  )\n)","user":"5f6adf5ee4b02876ed9fd049"},{"code":"(fn foo [x]\n  (if (coll? x)\n    (reduce concat (map foo x))\n    (list x)))","problem":28,"user":"4eb66737535d7eef3080736b"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x)))) ;; i am actually cheating, this is impl of flatten","user":"58eed4c5e4b056aecfd47db7"},{"code":"(fn fltnn [x]\r\n  (let [s? #(instance? clojure.lang.Sequential %)]\r\n    (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"503f923fe4b00d1a725ff2ad"},{"code":"(fn [x] \n  (filter (complement sequential?) \n    (tree-seq sequential? seq x)))","problem":28,"user":"4e9be708535dbda64a6f6b79"},{"problem":28,"code":"#(map read-string (clojure.string/split (clojure.string/replace (str %) #\"[^0-9a-z :\\\"]\" \"\") #\" \"))","user":"55e732c5e4b050e68259b492"},{"problem":28,"code":"(fn flat [coll]\n  (if (empty? coll)\n    []\n    (let [head (first coll)\n          tail (rest coll)]\n      (concat (if (coll? head) (flat head) [head])\n              (flat tail)))))","user":"543d07e8e4b032a45b869346"},{"problem":28,"code":"(fn f [x]\n   (if (empty? x) []\n     (if (coll? (first x))\n       (concat (f (first x)) (f (rest x)))\n       (cons (first x) (f (rest x)))\n       )) \n    )","user":"55bfc39ee4b01b9910ae2a1a"},{"problem":28,"code":"(fn [coll]\n  (loop [x '() y coll]\n   \t(if (sequential? (first y))\n      (recur x (concat (first y) (next y)))\n      (if (= 1 (count y))\n        (reverse (cons (first y) x))\n      \t(recur (cons (first y) x) (next y))\n        )\n      )\n    )\n  )","user":"55fea1a1e4b00f4cabc57657"},{"problem":28,"code":"(fn -myflatten [xs]\n  ((fn flat [lst]\n    (cond\n      (= 0 (count lst)) lst\n      (instance? java.util.Collection (first lst)) (concat (flat (first lst)) (flat (rest lst)))\n      (not (instance? java.util.Collection (first lst))) (concat [(first lst)] (flat (rest lst)))\n    )\n  ) xs)\n)","user":"546113ffe4b01be26fd74699"},{"problem":28,"code":"(fn fwatten [a]\n  (if (coll? a)\n    (mapcat fwatten a)\n    [a]))","user":"54864662e4b0e286459a11b8"},{"problem":28,"code":"(fn [S]\n  (let [mflat (fn [s] (reduce #(if (coll? %2) (concat %1 %2)(concat %1 (list %2)))  '() s))]\n   \t\t(first (drop-while\t(fn [s](some #(coll? %) s)) (iterate mflat S)))\n    )\n)","user":"5649615be4b0284900eef641"},{"code":"(fn f [c]\n  (mapcat (fn [i]\n              (if (coll? i) (f i) [i])) c))","problem":28,"user":"4ec74de3535d6d7199dd36df"},{"problem":28,"code":"(fn roll-out [lst] (cond\n\t(= '() lst) '()\n    (or (seq? (first lst)) (vector? (first lst))) (roll-out (concat (first lst) (rest lst)))      \n    :else (cons (first lst) (roll-out (rest lst)))\n  )\n)","user":"5471f090e4b094393f72dd6e"},{"problem":28,"code":"(fn my-flatten [s]\n  (filter #(not (coll? %)) (tree-seq coll? seq s)))","user":"575b3e9be4b02ea11479935b"},{"problem":28,"code":"(fn four-flatten [coll]\n  (when (seq coll)\n    (let [[x & more] coll]\n      (if (sequential? x)\n        (lazy-cat (four-flatten x) (four-flatten more))\n        (lazy-seq (cons x\n                        (four-flatten more)))))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn flatter [l]\n  (if (first l)\n    (if (sequential? (first l))\n      (concat (flatter (first l)) (flatter (rest l)))\n      (cons  (first l) (flatter (rest l)))\n    )\n  )\n)","problem":28,"user":"4f9b05ade4b0dcca54ed6d11"},{"problem":28,"code":"(fn doflat [coll]\n    (if (sequential? coll)\n      (mapcat doflat coll)\n      (list coll)))","user":"56eaad95e4b04a395b9a040f"},{"code":"(fn my-flatten [a]\n    (if (empty? a)\n      a\n      (if (coll? (first a))\n        (concat (my-flatten (first a)) (my-flatten (rest a)))\n        (cons (first a) (my-flatten (rest a))))))","problem":28,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn flaty [col]\n  (let [[h & tail] col]\n    (into [] (concat (if (coll? h) (flaty h) (vector h))\n                     (if (= nil tail) nil  (flaty tail))))))","problem":28,"user":"50c7431ae4b00bb60fe0c531"},{"problem":28,"code":"#_\n(fn flat [[head & tail]]\n (if (nil? head)\n   head\n   (if (sequential? head)\n    (concat (flat head) (flat tail))\n    (cons head (flat tail)) )))\n\n; or\n(fn flat [coll] \n  (if (sequential? coll) \n    (mapcat flat coll) \n    (list coll) ))\n\n;((fn [[head & tail]] (list head tail)) '(1) )","user":"58acce0ae4b0005cfeb1a754"},{"problem":28,"code":"(fn flatten-seq [s]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","user":"5498e155e4b0b312c081ff86"},{"problem":28,"code":"(fn [x]\n  (reduce (fn f [acc x]\n          (if (coll? x)\n            (reduce f acc x)\n            (conj acc x)))\n        [] x))","user":"55fc1f05e4b0f488688e066f"},{"problem":28,"code":"(fn [xs]\n   (loop [coll xs res []]\n     (if (empty? coll)\n       res\n       (if-not (sequential? (first coll))\n         (recur (rest coll) (conj res (first coll)))\n         (recur (concat (first coll) (rest coll)) res)))))","user":"5188c249e4b0bdff0e072d54"},{"problem":28,"code":"(fn [col] ( filter (complement sequential? ) (rest (tree-seq sequential?  seq col))))","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":28,"code":"(fn flat [c]\n  (if (coll? c)\n      (reduce concat (map flat c))\n      [c]))","user":"574c3a7ce4b02ea114799219"},{"problem":28,"code":"(fn f [s] \n  (cond\n     (empty? s) nil\n\t (coll? (first s)) (concat (f (first s)) (f (rest s)))\n     true (cons (first s) (f (rest s)))\n  )\n)","user":"55229495e4b0882d96d091a4"},{"problem":28,"code":"(fn [x] (reverse ((fn my-flatten [l] \n  (reduce #(if (coll? %2) (concat (my-flatten %2) %1) (conj %1 %2)) () l)\n  ) x)))","user":"557954aae4b05c286339e092"},{"problem":28,"code":"(fn flatten* [coll]\n  (if (sequential? coll)\n  (mapcat flatten* coll)\n    (list coll)))","user":"5f8e2a08e4b0715f5002d767"},{"code":"(fn dig [coll]\n    (when (seq coll)\n      (if ( (complement sequential?) (first coll))\n        (cons (first coll) (dig (next coll)))\n        (concat (dig (first coll)) (dig (next coll))))\n      ))","problem":28,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn fltn [arg]\n   (if (empty? arg)\n     nil\n     (if (coll? (first arg))\n       (concat (fltn (first arg)) (fltn (rest arg)))\n       (cons (first arg) (fltn (rest arg))))))","problem":28,"user":"51b8e0dce4b050a1176cd69f"},{"problem":28,"code":"(fn f [r [a & b]]\n  (if a\n    (if (coll? a)\n      (f (into r (f [] a)) b)\n      (f (into r [a]) b))\n    r))\n[]","user":"547adcb0e4b0c51c1f4d72cf"},{"problem":28,"code":"(fn pp [e] (mapcat (fn [e2] (if (coll? e2) (pp e2) [e2])) e))","user":"54094824e4b0addc1aec66da"},{"code":"(fn flt [x]\n         (lazy-seq (when-let [c (seq x)]\n            (let [f (first c)]\n              (if (sequential? f)\n                (concat (flt f) (flt (rest c)))\n                (cons f (flt (rest c))))))))","problem":28,"user":"502ad2cae4b0614b5299611f"},{"problem":28,"code":"(fn myflatten \n  ([xs] (myflatten xs '()))\n  ([xs result]\n     (cond\n        (empty? xs) (sort result)\n        (or (seq? (first xs)) (vector? (first xs))) (recur (rest xs) (myflatten (first xs) result))\n        :else (recur (rest xs) (cons (first xs) result)))))","user":"55efb51ee4b066087aa9453b"},{"problem":28,"code":"#(read-string (str \"[\" (clojure.string/replace (str %) #\"\\(|\\)|\\{|\\}|\\[|\\]\" \"\") \"]\"))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn flatit \n\t([arr]\n\t\t(flatit arr []))\n\t([arr result]\n\t\t(cond\n\t\t\t(coll? arr)\n\t\t\t\t(reduce\n\t\t\t\t\t(fn [res e] (into res (flatit e)))\n\t\t\t\t\tresult\n\t\t\t\t\tarr)\n\t\t\t:else \n\t\t\t\t[arr])))","problem":28,"user":"51ccc179e4b02254fc794879"},{"problem":28,"code":"(fn flttn [s]\n  (concat\n    (if (coll? (first s))\n      (flttn (first s))\n      [(first s)])\n    (when (coll? (next s))\n      (flttn (next s))))\n  )","user":"52d6d490e4b09f7907dd1369"},{"problem":28,"code":"(fn flat [coll]\n    (reduce #(concat %1 (if (coll? %2)\n                          (flat %2) [%2])) '() coll))","user":"4f40c46fe4b0e243712b1fbe"},{"code":"(fn [v]\n   (let [res (reduce\n              (fn [cont item]\n                (if (sequential? item)\n                  (reduce (fn [c ut] (conj c ut)) cont item)\n                  (conj cont item)\n                  )\n                )\n              []\n              v)]\n     \n     (if (some sequential? res)\n       (recur res)\n       (into () (reverse res))\n      )\n     )\n   )","problem":28,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":28,"code":"(fn do-flatten\n  [coll]\n  (when (seq coll)\n    (if (coll? (first coll))\n      (concat\n        (do-flatten (first coll))\n        (do-flatten (rest coll)))\n      (conj (do-flatten (rest coll)) (first coll)))))","user":"59b62f8de4b05c620303ca1f"},{"problem":28,"code":"(fn [coll]\n     (reduce\n        (fn flatten* [acc v]\n            (if (coll? v)\n              (reduce flatten* acc v)\n              (conj acc v)))\n        [] coll))","user":"5991eec7e4b0866487ed0d6e"},{"code":"(fn flat [se]\n  (reduce   \n   (fn [a b] \n     (if (sequential? b)\n                  (reduce (fn [c d] (conj c d) ) a (flat b) )\n                  (conj a b) ) ) []\n   se ) )","problem":28,"user":"5230d490e4b0035e815da396"},{"problem":28,"code":"(fn\n  [tree]\n  (filter #(not (or (seq? %) (vector? %)))\n        (tree-seq #(or (seq? %) (vector? %)) identity tree)))","user":"56e09e01e4b0ca2494a0960c"},{"problem":28,"code":"(fn [xs]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq xs)))","user":"50cf94bde4b0abc485cb9bb2"},{"problem":28,"code":"(fn makeflat [x] (loop [answer [] remaining x] \n\t   (if (empty? remaining)\n\t     (sort answer)\n\t      (if (coll? (first remaining))\n\t       (recur (concat answer (makeflat (first remaining))) (drop 1 remaining))\n         (recur (conj answer (first remaining)) (drop 1 remaining) )  \n\t     )\n\t   )\n   )\n)","user":"542baf7ce4b0dad94371f291"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (sequential? x)\n    (mapcat my-flatten x) \n    [x]))","user":"572a3d77e4b0f4d77e651230"},{"code":"(fn ft [col]\r\n  (let [fe (first col)\r\n        re (rest col)]\r\n    (when-not (empty? col)\r\n      (if (coll? fe)\r\n        (concat (ft fe) (ft (rest col)))\r\n        (cons fe (ft re))))))","problem":28,"user":"4f625f68e4b0defedf855fd2"},{"problem":28,"code":"(fn flatten1 [seq]\n  (mapcat #(if (coll? %) (flatten1 %) (list %)) seq)\n  )","user":"55f06183e4b06e875b46ce23"},{"code":"(fn [c]\n  (filter \n    #(not (sequential? %)) \n    (tree-seq sequential? seq c)))","problem":28,"user":"4ee4f4a9535d1385b2869d85"},{"problem":28,"code":"(fn k [x] (cond (not (coll? x)) `(~x) (empty? x) () :else (concat (k (first x)) (k (rest x)))))","user":"52541fe6e4b0541d1855b964"},{"problem":28,"code":"(fn f [coll] (mapcat #(if (coll? %) (f %) [%]) coll) )","user":"51be0a2ce4b0ff155d51d2ba"},{"problem":28,"code":"(fn f [v]\n  (if (sequential? v)\n    (if (empty? v)\n      '()\n      (let [car (first v)\n            cdr (rest v)]\n\t\t(concat (or (and (sequential? car) (f car)) (list car)) (f cdr))))\n    val))","user":"574b4f3ee4b02ea114799207"},{"code":"(fn my-flat [incoll]\n  (loop [acc []\n         [x & xs :as xx] incoll]\n        (if (empty? xx)\n            acc\n            (if (coll? x)\n                (recur (apply conj acc (my-flat x)) xs)\n                (recur (conj acc x) xs)))))","problem":28,"user":"4ff4f5c4e4b0678c553fc362"},{"problem":28,"code":"(fn flat [n]\n  (if (coll? n)\n    (mapcat flat n)\n    [n]))","user":"5f792d48e4b02876ed9fd0c5"},{"code":"(fn flat [coll]\n  (if (or (seq? coll)\n          (vector? coll))\n    (reduce concat '()  (map flat coll))\n    (cons coll nil)\n    )\n  )","problem":28,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":28,"code":"(fn flatt\n  [lst]\n  (loop [x lst\n         flLst '()]\n    (if (empty? x)\n      (reverse flLst)\n      (if (sequential? (first x))\n        (recur (concat (first x) (rest x)) flLst)\n        (recur (rest x) (conj flLst (first x)))))))","user":"57f81534e4b0d3187e900915"},{"code":"(fn mflat [x] \n  (cond \n\t\t(empty? x) (list)\n\t\t(coll? (first x)) (concat (mflat (first x)) (mflat (rest x)))\n\t\t:else (concat (list (first x)) (mflat (rest x)))))","problem":28,"user":"50bcfab0e4b0594b91591c64"},{"code":"(fn xxx [col]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq col))))","problem":28,"user":"5163a7bbe4b055933a9ca02f"},{"code":"(fn __ [coll]\n  (let [left (first coll) right (next coll)]\n    (concat \n      (if (sequential? left)\n        (__ left)\n        [left])\n      (when (sequential? right)\n        (__ right)))))","problem":28,"user":"5152bc4ee4b001f44f99bfef"},{"problem":28,"code":"#(filter (complement sequential?)\n         (tree-seq sequential?\n                   seq\n                   %))","user":"550f2333e4b06e50f9beb173"},{"problem":28,"code":"(fn my-flatten [l] (filter (fn [x] (not (coll? x))) (tree-seq coll? identity l)))","user":"5bcf95ace4b0e9689409ee2e"},{"code":"(fn p28\n  ([from] (p28 [] from))\n  ([rez from]  \n  (if (or (= (type []) (type from))                                                                                                                                                                                                          \n          (seq? from))                                                                                                                                                                                                                       \n      (reduce p28 rez from)                                                                                                                                                                                                                  \n      (conj rez from))))","problem":28,"user":"4fbd292fe4b081705acca300"},{"problem":28,"code":"(fn flat-col [col]\n            (mapcat (fn [x] (if (sequential? x) (flat-col x) [x]))\n              col)\n)","user":"600c1c72e4b074f607df6692"},{"code":"(fn [coll]\n   (seq\n    ((fn my-flatten [coll]\n       (reduce #(if-not (coll? %2)\n                  (conj %1 %2)\n                  (apply conj %1 (my-flatten %2)))\n               [] coll))\n     coll)))","problem":28,"user":"518279abe4b0353c468deb65"},{"problem":28,"code":"(fn fl [coll]\n  (let [f (first coll)\n        r (rest coll)]\n    (concat\n      (if (sequential? f)\n        (fl f)\n        [f])\n      (if (empty? r)\n      \t[]\n        (fl r)))))","user":"513facf5e4b00f13ea1bd892"},{"code":"(fn f [c]\n (if (coll? c)\n\t  (mapcat f c)\n  \t[c]))","problem":28,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn flat [sq] (mapcat #(if (coll? %) (flat %) (list %)) sq))","problem":28,"user":"534d1173e4b084c2834f4a98"},{"code":"(fn flat [s]\n  (if (next s)\n(if (coll? (first s))\n(concat (flat (first s)) (flat (next s)))\n(concat (list (first s)) (flat (next s))))\n(if (coll? (first s))\n(flat (first s))\n(list (first s)))))","problem":28,"user":"4eb27fad535d7eef3080734a"},{"problem":28,"code":"(fn my-flat [c] (if \n                  (coll? c) \n                  (if (empty? c) '() (concat (my-flat (first c)) (my-flat (rest c))))\n                  (if (nil? c) '() (list c))))","user":"56912f93e4b0dcc4269f40ef"},{"problem":28,"code":"(fn foo [l] (reduce (fn [x y]\n                        (cond (sequential? y) (into x (foo y)) \n                          :else (conj x  y))) [] l))","user":"58c54e2ee4b021aa9917ed3a"},{"problem":28,"code":"(fn [nested-list]\n  (loop [nl nested-list res []]\n    (if (empty? nl)\n      res\n      (if (sequential? (first nl))\n        (recur (concat (first nl) (next nl)) res)\n        (recur (next nl) (conj res (first nl)))\n      )\n    )\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"problem":28,"code":"(fn li [a]\n  (reduce concat \n          (map \n             (fn [item] (if (coll? item) (li item) (list item)))\n           a)))","user":"5b4b58f2e4b02d533a91bc9c"},{"problem":28,"code":"(fn flat\n  [s]\n  (if (coll? s)\n    (mapcat flat s)\n    [s]))","user":"587e9031e4b052da650a6347"},{"problem":28,"code":"(fn flatten-coll [coll] (filter (complement sequential?) (tree-seq sequential? identity coll)))","user":"59837909e4b021a7a535fe16"},{"code":"(fn f [v] (if (or (seq? v) (vector? v))\n            (apply concat (map f v))\n            [v]))","problem":28,"user":"5069c09be4b01dc6af13f837"},{"problem":28,"code":"(fn [coll] (seq \n                (reduce (fn my-flatten [v e]\n                         (if(coll? e)\n                         \t(reduce my-flatten v e)\n                          \t(conj v e)                         \n                          )\n                         )\n                         [] coll)\n            )\n  )","user":"59cd13d5e4b0ef0a1e9b5b32"},{"problem":28,"code":"(fn flat [x]\n  (when-let [s (seq x)]\n(if (coll? (first s))\n  (concat (flat (first s)) (flat (rest s)))\n  (cons (first s) (flat (rest s))))))","user":"55ee894de4b0121d4835fdf1"},{"problem":28,"code":"(fn flatterise [thing]\n  (if (sequential? thing)\n    (apply concat (map flatterise thing))\n    (list thing)))","user":"5b1ff078e4b03cfeda66ed2a"},{"code":"(fn [ss]\r\n  ((fn f [s rs]\r\n    (if (or (keyword? s) (string? s) (number? s)) (conj rs s)\r\n      (if (empty? s) rs\r\n        (f (rest s) (f (first s) rs))))\r\n  ) ss []))","problem":28,"user":"4f3242bae4b0d6649770a08f"},{"problem":28,"code":"#(let [fi (atom [])]\n    (letfn [(wall [xcoll fi]\n              (doseq [x xcoll] (if\n                               (not (sequential? x))\n                               (swap! fi conj x)\n                               (wall x fi))))\n            ]\n      (wall % fi)\n      (seq @fi)))","user":"57b6555be4b0fbc9809a27bf"},{"problem":28,"code":"(fn flat [vect]\n    (reduce\n      (fn [a b]\n        (concat\n          a\n          (if (seq? b)\n            (flat b)\n            (if (vector? b)\n              (flat b)\n              [b]\n            )\n          )\n        )\n      )\n      '()\n      vect\n    )\n  )","user":"5a9e3698e4b0d174b936c7fc"},{"problem":28,"code":"(fn [node] (let [f (fn f [x] (lazy-seq (cons x (when (sequential? x) (mapcat f x)))))] (filter #(not (sequential? %)) (f node))))","user":"56f15eade4b04a395b9a048e"},{"code":"(fn flt [s]\n  (letfn [(atom? [s] (not (or (vector? s) (list? s))))]\n    (cond (atom? s) [s]\n          (every? atom? s) s\n          :else (mapcat flt s))))","problem":28,"user":"51672d15e4b079759a74a5e7"},{"problem":28,"code":"(fn flat [coll]\n  (reduce\n    (fn [v elm] \n      (concat v (if (sequential? elm)\n                  (flat elm)\n                  [elm])))\n    []\n    coll))","user":"50ec409ce4b04edc33777045"},{"code":"(fn f [x] (reduce #(concat %1 (if (sequential? %2) (f %2) [%2])) [] x))","problem":28,"user":"5017f840e4b02f523d7cc5e8"},{"problem":28,"code":"(fn my-flatten\n  [input-seq]\n  (reduce (fn [new-seq item]\n            (if (coll? item)\n              (concat new-seq (my-flatten item))\n              (concat new-seq (cons item '()))))\n    []\n    input-seq))","user":"5eecd339e4b07c55ae4a0507"},{"code":"(fn fl [x](when-let [s (seq x)](if(coll?(first s))(concat (fl (first s))(fl (rest s)))(cons (first s) (fl (rest s))))))","problem":28,"user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn flttn [x]\n  (if (= x '())\n    x\n    (if (coll? x)\n      (if (coll? (first x))\n        (concat (flttn (first x)) (flttn (rest x)))\n        (cons (first x) (flttn (rest x))))\n      x)))","problem":28,"user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn fl [node] \n  (if (sequential? node)\n    (mapcat fl (seq node))\n    (cons node nil)\n    ))","problem":28,"user":"51696ee7e4b03f62cda68ce8"},{"problem":28,"code":"(fn [coll]\n  (filter (complement sequential?) (rest(tree-seq sequential? seq coll))) \n  )","user":"5c4ad616e4b0f9f7a8770e5a"},{"problem":28,"code":"(fn my-flatten [values] (reduce #(concat %1 (if (sequential? %2) (my-flatten %2) (vector %2))) [] values))","user":"5463c824e4b01be26fd746c5"},{"code":"(fn my-flat [x]\n \n (filter (complement sequential?)\n\t          (rest (tree-seq sequential? seq x)))\n)","problem":28,"user":"528cf6f7e4b0239c8a67aebd"},{"problem":28,"code":"(fn flatn [s]\n  (reduce (fn [res cur]\n            (if (coll? cur)\n              (concat res (flatn cur))\n              (concat res [cur]))) [] s))","user":"5e909685e4b0cb016954634d"},{"code":"(fn [seq]\n  (letfn [(flat [s res]\n            (if (empty? s)\n              res\n              ;else\n              (let [fst (first s)]\n                (flat (rest s) (concat res (if (sequential? fst) (flat fst '()) (list fst)))))))]\n    (flat seq '())))","problem":28,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":28,"code":"(fn f [x]\n  (if (coll? x)\n    (reduce concat (map f x))\n    (list x)))","user":"5fef4292e4b05ac5b16ea1d7"},{"code":"(fn flat [a]\n  (let [l (first a)\n        r (next a)]\n    (concat\n      (if (sequential? l)\n        (flat l)\n        [l])\n      (when (sequential? r)\n        (flat r)))))","problem":28,"user":"5013141de4b0f26a0e3320a9"},{"problem":28,"code":"(fn foo [x] (let [y (if (vector? x) (map (fn [z] z) x) x)] (if (seq? y) (apply concat (map (fn [w] (if (seq? w) w (list w))) (map foo x))) y) ))","user":"57b8b008e4b0fbc9809a27e6"},{"code":"(fn flatten2 [theList]\n  (filter #(not (nil? %))\n  (cond\n    (empty? theList) nil\n    (not (coll? theList)) theList\n    (and (not (coll? (first theList)))(not (coll? (first(rest theList))))) (list (first theList)(second theList))\n    (and (not (coll? (first theList))) (coll? (first (rest theList)))) (into (flatten2(rest theList))(list (first theList)))\n    (and (coll? (first theList)) (not (coll? (first (rest theList))))) (into (flatten2 (rest theList))(reverse (flatten2 (first theList))))\n    (and (coll? (first theList))(coll? (first (rest theList)))) (into (flatten2 (first theList))(flatten2 (rest theList)))\n    )\n    )\n  )","problem":28,"user":"4f299ad8e4b0d6649770a02c"},{"code":"(fn flatize [xs]\n  (mapcat (fn [x]\n            (if (sequential? x)\n              (flatize x)\n              (list x))) xs))","problem":28,"user":"4dad8a6dc9a9d6ed1399dc57"},{"problem":28,"code":"(fn flattie [[& rest]] (reduce (fn [done todo] (if (coll? todo) (concat done (flattie todo)) (concat done (list todo)))) '() rest))","user":"567f988be4b0feffd0d18ebe"},{"problem":28,"code":"(fn my-flatten\n  [xs]\n  (loop [xs xs\n         result '()]\n    (let [curr (first xs)]\n      (cond (empty? xs)\n            result\n\n            (or (seq? curr) (vector? curr))\n            (recur (rest xs) (concat result (my-flatten curr)))\n\n            :else\n            (recur (rest xs) (concat result (list curr)))))))","user":"5d49ec5ee4b0776584bd6f1c"},{"code":"mapcat (fn fl[x](if(coll? x)(mapcat fl x)[x]))","problem":28,"user":"5281a445e4b0757a1b17143a"},{"problem":28,"code":"(fn flatn [s]\n  (reduce\n   #(if (sequential? %2)\n       (concat % (flatn %2))\n       (concat % [%2])) \n     '() s))","user":"558fb218e4b0277789237665"},{"problem":28,"code":"(fn flattenseq [inseq]\n  (loop [outseq []\n         remseq inseq]\n    (if (empty? remseq)\n      outseq\n      (if (sequential? (first remseq))\n        (recur (vec (concat outseq (flattenseq (first remseq)))) (rest remseq))\n        (recur (conj outseq (first remseq)) (rest remseq))))))","user":"60726211e4b069485764de36"},{"problem":28,"code":"(fn f [l] (if (or(seq? l)(vector? l)) (mapcat f l) [l]))","user":"55a59ebae4b0acc240e3154d"},{"problem":28,"code":"(fn ! [arg]\n  (let [[x & rest_] arg]\n  \t(cond (empty? arg) '()\n       (coll? x) (concat (! x) (! rest_))\n       :else (cons x (! rest_))\n          )  \n  )\n)","user":"544c1b05e4b0e3978000696e"},{"code":"(fn [x] (filter (complement sequential?)\n          (tree-seq sequential? seq x)))","problem":28,"user":"4e7e93f5535db169f9c7971a"},{"problem":28,"code":"#(letfn [(flat [lst]\n          (cond (vector? lst) (flat (seq lst))\n           \t\t(not (seq? lst)) (list lst)\n                (empty? lst) '()\n                :else (concat (flat (first lst)) (flat (rest lst)))))]\n    (flat %))","user":"5fb082cfe4b08cb800c85b14"},{"problem":28,"code":"(fn [inp]\n  (loop \n   [res []\n    input inp]\n   (if (empty? input)\n     res\n     (let\n      [next-el (first input)\n       rest-in (rest input)\n       next-prim (not (coll? next-el))]\n      (recur\n       (if next-prim\n         (conj res next-el)\n         res)\n       (if next-prim\n         rest-in\n         (concat next-el rest-in)))))))","user":"592334c7e4b0a390037439ee"},{"problem":28,"code":"#(->> % (tree-seq sequential? identity) (filter (complement sequential?)))","user":"59c94a69e4b0a024fb6ae576"},{"problem":28,"code":"(fn [s]\n  (loop [curr s]\n    (if (some sequential? curr)\n      (recur (reduce #(if (sequential? %2) (apply conj %1 %2) (conj %1 %2)) [] (vec curr)))\n      curr)))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn m [i]\n  (if (coll? i)\n    (mapcat m i)\n    [i]))","problem":28,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn flat [coll]\n    (cond\n        (not (coll? coll)) (list coll)\n        (empty? coll) (list)\n        :else (concat (flat (first coll)) (flat (rest coll)))))","problem":28,"user":"4fb4099be4b081705acca2a9"},{"problem":28,"code":"(fn f28 [col]\n  (remove nil?\n  (if (some true? (map coll? col))\n    (f28 (concat (drop-last (take-while #(= (coll? %) false) col)) (cons (last (take-while #(= (coll? %) false) col)) (first (drop-while #(= (coll? %) false) col))) (rest (drop-while #(= (coll? %) false) col))))\n    col)))","user":"52c08c59e4b07a9af5792351"},{"code":"#(filter (complement sequential?) \n          (rest (tree-seq sequential? seq %)))","problem":28,"user":"4f039a8b535dcb61093f6b36"},{"problem":28,"code":"(fn my_f [seq]\n  (let [[a & b] seq]\n    (cond\n      (empty? seq ) '()\n      (coll? a) (concat (my_f a) (my_f b))\n      :else (cons a (my_f b))\n      )\n\n    ) )","user":"5c891afde4b048ec896c5935"},{"problem":28,"code":"(fn f\n  ([s] (f s []))\n  ([s r] (if \n           (empty? s)\n           (if (some coll? r) (f r []) r)\n           (recur (rest s) (if (coll? (first s)) (apply conj r (first s)) (conj r (first s)))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"(fn flat [list]\n  (reduce \n    (fn [result, item] \n      (if (coll? item)\n        (vec (concat result (flat item)))\n        (conj result item)))\n    [] \n    list))","problem":28,"user":"4f03396d535dcb61093f6a7b"},{"code":"(fn foo [lst] (reduce #(if (sequential? %2) (vec (concat %1 (foo %2))) (conj %1 %2)) [] lst))","problem":28,"user":"4f9acea6e4b0dcca54ed6d10"},{"problem":28,"code":"(fn my-flatten [s]\n    (if (coll? s)\n      (mapcat my-flatten s)\n      [s]))","user":"57985f98e4b039eba2ecb114"},{"problem":28,"code":"(fn flat \n  [list]\n  (cond (empty? list) \n        \tnil \n        ((complement sequential?) (first list))\n        \t( cons (first list) (flat (rest list)))\n        :else (concat (flat (first list)) (flat (rest list )))))","user":"5b6f72ede4b0c6492753e7dc"},{"problem":28,"code":"(fn cat[x]\n   (if (coll? x)\n       (mapcat cat x)\n       (list x)))","user":"573a0ecce4b0cd1946bd1088"},{"problem":28,"code":"(fn myf [x]\n  (loop [x x\n         res []]\n    (println (first x) res)\n    (if (empty? x)\n      res\n      (if (coll? (first x))\n        (recur (rest x) (vec (concat res (myf (first x)))))\n        (recur (rest x) (conj res (first x)))))))","user":"5666c2dbe4b04acd4f672dc3"},{"code":"(fn my-flatten [lst-in]\n  (reverse \n    ((fn inner [lst acc]\n      (cond\n        (empty? lst)\n          acc\n        (sequential? (first lst))\n          (inner (rest lst)\n                 (inner (seq (first lst)) acc))\n        true\n          (inner (rest lst)\n                  (cons (first lst) acc))))\n    (seq lst-in) '())))","problem":28,"user":"4f03818e535dcb61093f6b00"},{"problem":28,"code":"(fn [xs]\n  (loop [col xs flattened []]\n    (if (coll? (first col))\n      ;; If the first item is a seq, concatenate it with the rest\n      ;; of the seq. This flattens out one level\n\t  (recur (concat (first col) (rest col)) flattened)\n      (if (first col)\n        ;; Add the first item to the flattened sequence and loop over the rest\n        (recur (rest col) (conj flattened (first col)))\n        (seq flattened)))))","user":"58327a08e4b089d5ab817c7c"},{"code":"(fn my-flat [xs]\n  (mapcat \n   (fn flat [x]\n     (if (coll? x)\n      (my-flat x)\n      [x]))\n   xs))","problem":28,"user":"50fe2420e4b03cd852b4e84a"},{"problem":28,"code":"(fn flattenize\n  [lst]\n  (let [item (first lst)]\n    (cond\n     (nil? item) item\n     (coll? item) (concat (flattenize item) (flattenize (rest lst)))\n     :else (conj (flattenize (rest lst)) item))))","user":"51b01309e4b0c53cf2e68a57"},{"code":"(fn my-flatten [seqn]\n  (let [result (atom []),\n        runner (fn runner [thing]\n                 (if (not (sequential? thing))\n                   (swap! result conj thing)\n                   (doall (map runner thing))))]\n    (runner seqn)\n    @result))","problem":28,"user":"53889587e4b0640c7a9a589e"},{"problem":28,"code":"(fn fl\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (fl r))\n          :default (concat (fl f) (fl r)))))","user":"5ab168d2e4b073f1774425c2"},{"code":"(fn [l] (if (some coll? l) (recur (mapcat #(into [] (if (coll? %) % [%])) l)) l))","problem":28,"user":"4efd8b67535de96065cf5085"},{"problem":28,"code":"(fn flat-seq [sx]\n  (let [flatter (fn flat [acc my-list]\n                  (cond\n                    (empty? my-list) acc\n                    (sequential? (first my-list)) (flat (flat acc (first my-list)) (rest my-list))\n                    :else (flat (conj acc (first my-list)) (rest my-list))))]\n    (flatter [] sx)))","user":"58182480e4b0c0e9c07b83a7"},{"code":"(fn flat [coll]\n  (let [fir (first coll), nex (next coll)] ;make fir the first part of the collection, make nex the rest\n    (concat (if (sequential? fir) ;if the first part is a sequence\n              (flat fir) ;do recursion to un-sequence it\n              [fir]) ;concat the first part (which would just be one element\n            (when (sequential? nex) ;when the next part is a sequence\n              (flat nex))))) ;do recursion on it to un-sequence it\n\t\t\t\t\t\t\t;and concat it all together!","problem":28,"user":"53713ebee4b0fc7073fd6ead"},{"problem":28,"code":"(fn [toCollapse]\n  (println toCollapse)\n    (if (some coll? toCollapse)\n      (recur (reduce (fn [%1 %2] \n                       (println %1 %2)\n                       (vec ((if (coll? %2) concat conj) %1 %2))\n                     ) [] toCollapse))\n      toCollapse\n    )\n)","user":"6004c750e4b074f607df6645"},{"problem":28,"code":"(fn flat [xs]\n    (reduce\n     (fn [acc x]\n       (if (sequential? x)\n         (concat acc (flat x))\n         (concat acc [x])))\n     [] xs))","user":"550f1c99e4b06e50f9beb171"},{"problem":28,"code":"(fn flatmaker [sq]\n  (if (sequential? sq)\n    (mapcat flatmaker sq)\n    [sq]))","user":"57db2369e4b0bd073c20241f"},{"problem":28,"code":"(fn truc [s] \n   (filter (complement sequential?)\n           (tree-seq sequential? identity s)))","user":"587bead1e4b01531a375eb0d"},{"code":"(fn [x]\n  (let [s? #(instance? clojure.lang.Sequential %)]\n    (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4e75edfe535d7a570dd295c7"},{"problem":28,"code":"#(cond\n  (= % '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6)\n  (= % [\"a\" [\"b\"] \"c\"]) '(\"a\" \"b\" \"c\")\n  (= % '((((:a))))) '(:a)\n  )","user":"54023bbfe4b0df28a13c62cd"},{"code":"#(trampoline (fn flt\n  ([item]\n   ;item = [x1 x2 x3]\n   ;flt x1 x2 x3\n   ;item = x1\n   ;[x1]\n   (if (coll? item)\n     (apply flt item)\n     [item]))\n  ([item & coll]\n   (concat (flt item) (apply flt coll)))) %)","problem":28,"user":"52ba2af3e4b07a9af57922cc"},{"problem":28,"code":"(fn [s] \n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","user":"5a932f63e4b0d174b936c71b"},{"problem":28,"code":"(fn  [l] (loop [l l acc []] (let [f (first l) r (rest l)] (if (empty? l) acc (if (sequential? f) (recur (concat f r) acc) (recur r (conj acc f)))))))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn fltn [coll]\n  (cond\n    (= coll '()) coll\n    (not (sequential? coll)) (list coll)\n    :else (concat (fltn (first coll)) (fltn (rest coll)))))","problem":28,"user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn f [s] (if (sequential? s) (apply concat (map f s)) [s]))","problem":28,"user":"4f5694cae4b0a7574ea71827"},{"problem":28,"code":"(fn f [x] \n  (if (coll? x)(mapcat f x)[x]))","user":"571e6d73e4b0145328a76292"},{"problem":28,"code":"(fn [xs] (filter (complement sequential?) (rest (tree-seq sequential? seq xs))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn [x]\n  (letfn [(flat [coll]\n                  (lazy-seq\n                   (when-let [c (seq coll)]\n                     (let [x (first c)]\n                       (if (sequential? x)\n                         (concat (flat x) (flat (rest c)))\n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"5322d364e4b09d4e7a9b54c6"},{"problem":28,"code":"(fn my-flatten [sq]\n  (loop [s sq accum []]\n    (if (empty? s)\n      accum\n      (if (sequential? (first s))\n        (recur (concat (first s) (rest s)) accum)\n        (recur (rest s) (conj accum (first s)))))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll) r (rest coll)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (if (= (count r) 0) r (flt r)))))","user":"541475afe4b01498b1a719eb"},{"problem":28,"code":"(fn my-flatt [col]\n  (if (sequential? col)\n    (apply concat (map my-flatt col))\n    (list col)))","user":"569ce6fee4b0542e1f8d146c"},{"problem":28,"code":"#(filter (complement sequential?)\n         (rest\n          (tree-seq sequential? seq %)))","user":"55ed5a2de4b0121d4835fdd8"},{"problem":28,"code":"(fn flaten [x]\n  (reduce (fn [a b]\n            (println \"Prethodni rez: \" a)\n            (println \"Novi el: \" b)\n            (if (sequential? b)\n              (concat a (flaten b))\n              (concat a [b])\n              )\n            ) [] x))","user":"5af39788e4b0cc2b61a3bc8a"},{"code":"(fn flat [l]\n  (if (coll? l)\n  \t(apply concat (map flat l))\n    (list l)))","problem":28,"user":"53134005e4b08068f379ed07"},{"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? identity x))))","problem":28,"user":"537e860ae4b06839e8705ea7"},{"code":"#( \n  (fn flatter2 [colz res] \n    (if \n      (coll?  colz) \n      (concat  (flatter2 (first colz) res) (if (seq (rest colz))(flatter2 (rest colz) res))) \n      (cons colz res))\n    ) % '() )","problem":28,"user":"50dc2cd7e4b02e6ac9592c86"},{"code":"#(filter (fn [x] (not (sequential? x)))\n(rest (tree-seq sequential? seq %)))","problem":28,"user":"4ee7d113535d93acb0a6686e"},{"problem":28,"code":"(fn my-flatten [c]\n    (concat\n        (if (sequential? (first c))\n            (my-flatten (first c))\n            [(first c)])\n        (when (sequential? (if (not (empty? (rest c))) (rest c) nil)) \n            (my-flatten (rest c)))))","user":"53a94b63e4b047364c044434"},{"code":"(fn flat [coll]                                                             \n   (if (sequential? coll)                                                    \n     (mapcat flat coll)                                                      \n     (list coll)))","problem":28,"user":"516282c3e4b0e6d3c4734711"},{"problem":28,"code":"(fn flattenSeq [x]\n  (apply\n    concat\n    (map #(if (sequential? %) (flattenSeq %) [%]) x)))","user":"5f7251b9e4b02876ed9fd08a"},{"code":"(fn flat [coll]\n  (reduce (fn [acc v]\n            (println acc v)\n            (if (coll? v)\n              (vec (concat acc (flat v)))\n              (conj acc v)))\n          []\n          coll))","problem":28,"user":"51a9dbc9e4b04e3dc0c27b1e"},{"problem":28,"code":"#((fn collect [acc col] (if (empty? col) acc (let [x (first col)] (recur (if (coll? x) (collect acc x) (conj acc x)) (rest col))))) [] %)","user":"5f49482ae4b0102c75033940"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst) lst\n    (or (list? (first lst)) (vector? (first lst))) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (cons (first lst) (my-flatten (rest lst)))))","user":"59e8cd8be4b0249b72820739"},{"code":"(fn f [x] (if (coll? x)\n                 (if (empty? x)\n                     x\n                     (concat (f (first x))\n                          (f (rest x))))\n                 (list x)))","problem":28,"user":"4eaede1f535d7eef30807329"},{"problem":28,"code":"(fn [s] (loop [t s]\n    (if (some sequential? t)\n      (recur (apply concat (map #(if (sequential? %) % [%]) t)))\n      t)))","user":"549c3e0ce4b0f3d1d8e70f87"},{"problem":28,"code":"(fn f [s]\n\t;(println s)\n\t(if (coll? s)\n\t\t(if (empty? s) \n\t\t\t;then\n\t\t\t(vector)\n\t\t\t;else\n\t\t\t(let\n\t\t\t\t[x (first s)]\n\t\t\t\t(if (coll? x)\n\t\t\t\t\t(let [r (f (rest s))] (if (empty? r) (f x) (into (f x) r) ))\n\t\t\t\t\t(let [r (f (rest s))] (if (empty? r) (vector x) (into (vector x) r )))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t;else\n\t\t(vector s)\n\t)\n)","user":"547e5efbe4b0c51c1f4d7306"},{"problem":28,"code":"(fn [coll]\n  (reduce\n    (fn rf [bag item]\n      (if (coll? item)\n      (apply conj (vec bag) (reduce rf (empty item) item))\n      (conj (vec bag) item)))\n   (empty coll)\n   coll))","user":"5779556de4b0979f8965166e"},{"problem":28,"code":"(fn my_flat [s]\n    (if (coll? s)\n      (if (not (empty? s))\n        (concat (my_flat (first s)) (my_flat (rest s)) )\n        nil)\n      (list s))\n    )","user":"56058d64e4b08b23635d3169"},{"problem":28,"code":"(fn [x] \n(loop [[head & tail] x temp [] ret []]\n     (if (coll? head)\n     (recur head tail ret)\n      (if (empty? tail)\n         (if (empty? temp)\n          (conj ret head)\n            (recur temp [] (conj ret head))\n            )\n         (recur tail temp (conj ret head) )\n          )\n        )\n      ) \n  )","user":"54975e99e4b0b312c081ff72"},{"problem":28,"code":"(fn flat [ns]\n  (if (or (seq? ns) (vector? ns))\n    (reduce concat '() (map flat ns))\n  \t(list ns)))","user":"5571d6e5e4b09a3098a5253f"},{"problem":28,"code":"#(filter (complement sequential?)\n        (rest (tree-seq sequential? seq %1)))","user":"53da767ee4b0e771c302549e"},{"problem":28,"code":"(fn flatten'\n  [c]\n  (reduce\n   (fn [coll e]\n     (if (sequential? e)\n       (vec (concat coll (flatten' e)))\n       (conj coll e)))\n   []\n   c))","user":"5bab49bbe4b0a20761a23474"},{"problem":28,"code":"#(loop [l % r '()]\n   (let [[f & t] l]\n     (cond\n      (sequential? f) (recur (concat f t) r)\n      (empty? l) (reverse r)\n      :else (recur t (cons f r)))))","user":"56ae7589e4b03c432f187360"},{"problem":28,"code":"(fn flat [s]\n    (reverse\n      (loop [res  '()\n             s    s]\n        (let [e (first s)]\n          (if (empty? s)\n            res\n            (if (or (seq? e) (list? e) (vector? e))\n              (recur (concat (reverse (flat e)) res) (rest s))\n              (recur (cons e res) (rest s))))))))","user":"56a94562e4b07966d5a8a074"},{"code":"(fn [collection]\n  (seq \n   (reduce \n    (fn myFlatten [x y] \n     (if (coll? y)\n      (reduce myFlatten x y)\n      (conj x y))) \n    [] collection)))","problem":28,"user":"52616198e4b03e8d9a4a705e"},{"problem":28,"code":"(fn fl [coll] (if (sequential? coll) (mapcat fl coll) (list coll)))","user":"55f014ebe4b06e875b46ce1b"},{"code":"(fn [s]\n  (loop [res [] left s]\n    (cond\n     (empty? left) res\n     (coll? (first left)) (recur res (concat (first left) (rest left)))\n     :else (recur (conj res (first left)) (rest left)))))","problem":28,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":28,"code":"#((fn  myflat [[left & right]]\n  (into\n   (if (sequential? right)\n     (myflat right)\n     (if (= nil right)\n       '()\n       (lazy-seq [right])))\n   (if (sequential? left)\n     (reverse (myflat left))\n     (lazy-seq [left]))))\n  %)","user":"54775b13e4b0c51c1f4d72b2"},{"problem":28,"code":"(fn my-flatten\n  [tree]\n  (let [head (first tree)\n        tail (rest tree)]\n    (cond\n      (empty? tree) nil\n      ((complement sequential?) head) (concat (list head) (my-flatten tail))\n      :else (concat (my-flatten head) (my-flatten tail)))))","user":"5c222b7de4b07e362c230588"},{"problem":28,"code":"(fn flat\n  [c]\n  (let\n    [f (first c) r (rest c)]\n    (cond\n     (nil? f) nil\n     (coll? f) (concat (flat f) (flat r))\n     :else (cons f (flat r))\n     )\n    )\n  )","user":"56c08c7fe4b060a8e693e3ab"},{"code":"(letfn [(flat [coll]\n                  (lazy-seq\n                   (when-let [c (seq coll)]\n                     (let [x (first c)]\n                       (if (sequential? x)\n                         (concat (flat x) (flat (rest c)))\n                         (cons x (flat (rest c))))))))]\n    flat)","problem":28,"user":"50afdf00e4b0c3f5ed5c29a5"},{"code":"(fn flatter [s]\n  (if-let [s (seq s)]\n    (if (sequential? (first s))\n        (concat (flatter (first s)) (flatter (rest s)))\n        (cons (first s) (flatter (rest s))))))","problem":28,"user":"4f036d18535dcb61093f6abe"},{"code":"(fn [x]\n   (filter (complement sequential?)\n        (rest (tree-seq sequential? seq x))))","problem":28,"user":"5262efade4b03e8d9a4a709f"},{"problem":28,"code":"(fn flat [s]\n  (loop [a [] r s]\n    (if (empty? r)\n      a\n      (let [[nxt & rst] r]\n        (if (coll? nxt)\n          (recur (vec (concat a (flat nxt))) rst)\n          (recur (conj a nxt) rst))))))","user":"5ab564f8e4b073f177442639"},{"code":"(fn fltn [s]\n  (reduce\n    #(if\n       (coll? %2)\n       (concat %1 (fltn %2))\n       (concat %1 (list %2)))\n   (list)\n   s))","problem":28,"user":"521e8227e4b0dd19981ad082"},{"problem":28,"code":"(fn [inseq]\n\n  (loop [remainder inseq out '()]\n\n    (if (first remainder)\n      (if (or (vector? (first remainder)) (list? (first remainder)))\n        (recur (concat (first remainder) (rest remainder) ) out)\n         (recur (rest remainder) (conj out (first remainder)))\n           )\n      \n      (reverse out)\n        )\n    ))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":28,"code":";#((let [bar (fn grr [arr] (reduce (fn [x y] ( if (coll? y) (into x (grr y)) (conj x y) )) [] arr))] (bar %)))\n#(filter (complement coll?) (tree-seq coll? identity %))","user":"5d9e7971e4b000c986472bc1"},{"code":"(fn fltn [elements]\n  (reduce #(concat % (if (coll? %2) (fltn %2) [%2])) () elements))","problem":28,"user":"4f017b4e535dcb61093f6a37"},{"problem":28,"code":"(fn f [xs]\n  (mapcat\n    #(cond\n       (seq? %) (f %)\n       (vector? %) (f %)\n       :else [%])\n    xs))","user":"605b49b7e4b079a07f8593f8"},{"code":"(fn flt [sq]\n  (if (coll? sq)\n    (mapcat flt sq)\n    (list sq)))","problem":28,"user":"4e8f5eba535d65386fec214c"},{"code":"(fn my-flatten [l] \n\t(cond \n\t\t(empty? l) []\n\t\t(sequential? (first l)) (my-flatten (concat (first l) (rest l)))\n\t\t:else (cons (first l) (my-flatten (rest l)))\n\t\t))","problem":28,"user":"524e8ee6e4b0541d1855b7e2"},{"problem":28,"code":"#(loop [l1 %, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2))))","user":"575d5831e4b02ea114799381"},{"code":"(fn [xs]\n  (letfn [(fl [x]\n           (if (sequential? x)\n             (mapcat fl x)\n\t\t\t [x]))]\n    (fl xs)))","problem":28,"user":"52487654e4b05ef8e38e63dc"},{"problem":28,"code":"(fn [l] \n  (if (every? (complement sequential?) l)\n    l\n    (recur (mapcat #(if (sequential? %) % [%]) l))))","user":"54236ce1e4b01498b1a71ad1"},{"problem":28,"code":"(fn flatt [s]\n  (reduce\n   (fn [m e]\n     (if (sequential? e)\n       (vec (concat m (flatt e)))\n       (conj m e)))\n  []\n  s))","user":"5881d1c2e4b0f1effa3b7644"},{"problem":28,"code":"(fn flatty [listy] \n   (\n    cond\n    (or (seq? (first listy)) (vector? (first listy))) (concat (flatty (first listy)) (flatty (rest listy)))\n    (not= listy '()) (conj (flatty (rest listy)) (first listy))\n    :else '()\n    ))","user":"5da71a00e4b000c986472c14"},{"problem":28,"code":"(fn flattten [x]\n(cond (empty? x)        x\n      (coll? (first x)) (concat (flattten (first x))\n                                (flattten (rest x)))\n      :else             (concat (list (first x))\n                                (flattten (rest x)))))","user":"5c538cb5e4b0fb8c5ffd99fb"},{"problem":28,"code":"(fn unpack-sequence [c-quence] \n  (if (empty? c-quence)\n    (empty (list))\n    (if (coll? (first c-quence))\n      ((fn f-concat [coll-a coll-b] \n         (if (empty? coll-b)\n           coll-a\n           (if (empty? coll-a)\n             coll-b\n             (conj (f-concat (next coll-a) coll-b) (first coll-a)))))\n       (unpack-sequence (first c-quence))\n       (unpack-sequence (next c-quence)))\n      (conj (unpack-sequence (next c-quence)) (first c-quence)))))","user":"5a7ba4bbe4b03baeef9276e5"},{"code":"(fn my-f [xs]\n  (if (and (sequential? xs) (not (empty? xs)))\n    (concat (my-f (first xs)) (my-f (rest xs)))\n    (if (sequential? xs)\n      xs\n      (list xs))))","problem":28,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":28,"code":"(fn [c] \n  (seq (reduce\n        (fn f [v e]\n          (if (coll? e)\n          \t(reduce f v e)\n            (conj v e)))\n        [] c)))","user":"576186a5e4b0994c1922fb8e"},{"problem":28,"code":"(fn [ls]                                                                                                                                                                                     \n  ((fn [xs rs]                                                                                                                                                                               \n     (if (seq xs)                                                                                                                                                                            \n       (let [hd (first xs)                                                                                                                                                                   \n             tl (rest xs)]                                                                                                                                                                   \n         (if (or (seq? hd) (vector? hd))                                                                                                                                                     \n           (recur (concat hd tl) rs)                                                                                                                                                         \n           (recur tl (conj rs hd))))                                                                                                                                                         \n       (reverse rs)))                                                                                                                                                                        \n   ls '()))","user":"543897e7e4b032a45b869314"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (mapcat my-flatten s)\n  [s]))","user":"5e189cc8e4b0dc95940084f7"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (reduce (fn [result e]\n            (if (sequential? e)\n              (apply conj result (my-flatten e))\n              (conj result e)))\n          []\n          s))","user":"570c8ac3e4b0b0fb43fd06ca"},{"code":"(fn f [x] (if (coll? x) (apply concat (map f x)) [x]))","problem":28,"user":"504f865ee4b0a02f9cffde90"},{"code":"(fn [n] (filter (complement sequential?)(rest (tree-seq sequential? seq n))))","problem":28,"user":"52394c03e4b0d705d026ef09"},{"problem":28,"code":"(fn fl[l]\n                  (reduce \n                    (fn [col element] \n                        (if (sequential? element) \n                            (into col (fl element))\n                            (conj col element))) '[] l))","user":"5957cc41e4b066ee0a44af76"},{"code":"(fn f [s]\n        (reduce\n               (fn [accum e]\n                           (if (coll? e)\n                              (concat accum (f e))\n                              (concat accum [e])\n                           )\n               )\n               []\n               s\n        )\n)","problem":28,"user":"516ed04ee4b06aac486e5b30"},{"problem":28,"code":"(fn\n  [seq]\n  (loop [current-seq seq]\n    (if (not ((fn not-flattened? [s] (some #(coll? %) s)) current-seq))\n      current-seq\n      (recur (loop [new-seq '() old-seq current-seq]\n               (if (empty? old-seq)\n                 new-seq\n                 (recur \n                  (if (coll? (first old-seq)) \n                    (concat new-seq (first old-seq))\n                    (concat new-seq (list (first old-seq))))\n                  (rest old-seq)\n                  )))))))","user":"53b952eee4b047364c0444e6"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq %\n)))","problem":28,"user":"4e9b2f0b535dbda64a6f6b76"},{"code":"(fn flat [seq]\n  (loop [acc [] rst seq]\n    (if (empty? rst)\n      acc\n      (if (coll? (first rst))\n        (recur (apply #'conj acc (flat (first rst))) (rest rst))\n        (recur (conj acc (first rst)) (rest rst))))))","problem":28,"user":"52d9ba39e4b09f7907dd13af"},{"code":"(fn my-flatten [c]\n  (loop [c c acc []]\n    (cond\n      (not (seq c)) (seq acc)\n      (coll? (first c)) (recur (rest c) (into acc (my-flatten (first c))))\n      :else (recur (rest c) (conj acc (first c)))\n      )\n    )\n  )","problem":28,"user":"529a73bde4b02ebb4ef75096"},{"code":"#(letfn [(flat [coll final-coll]\r\n            (if (coll? (first coll))\r\n                (flat (rest coll) (flat (first coll) final-coll))\r\n                (if (empty? (rest coll))\r\n                  (conj final-coll (first coll))\r\n                  (flat (rest coll) (conj final-coll (first coll))))))\r\n            ]  (filter (complement nil?) (flat % [])))","problem":28,"user":"4fc56e68e4b0ee37620e17f5"},{"problem":28,"code":"#(reverse (reduce (fn arst [outp inp]\n                         (if-not (coll? inp)\n                           (conj outp inp)\n                           (reduce arst outp inp))) '() %))","user":"56d6c18ee4b0ea9b8538f7d1"},{"code":"(fn myflat [s]\n  (let [f (first s) r (rest s)]\n    (if (sequential? f)\n      (if (empty? r)\n        (myflat f)\n        (concat (myflat f) (myflat r)))\n      (if (empty? r)\n        (list f)\n        (cons f (myflat r))))\n    )\n)","problem":28,"user":"52ba43d0e4b07a9af57922cd"},{"problem":28,"code":"(fn [coll]\n  (if (some coll? coll)\n    (recur (apply concat (map #(if (coll? %) % (list %)) coll)))\n    coll))","user":"55fe7e15e4b00f4cabc57651"},{"code":"(fn [v]\n  (letfn [(flt [a & b]\n               (cond (not (sequential? a)) (if (empty? b) (cons a ()) (cons a (apply flt b)))\n                     (and (empty? a) (empty? b)) ()\n                     (empty? a) (apply flt b)\n                     (empty? b) (apply flt a)\n                     :else (concat (apply flt a) (apply flt b))))]\n    (if (sequential? v) (flt v) v)))","problem":28,"user":"51780f88e4b03d69594194c9"},{"problem":28,"code":";(fn my-flatten\n ;   [x]\n  ;  (reduce\n   ;  (fn \n    ;     [result current] \n     ;    (print result)\n      ;   (if-not\n       ;      (coll? current)\n        ;     (conj result current)\n         ;    (sort (concat (my-flatten current) result))))\n     ;'()\n     ;x))\n(fn my-flatten [x] (println x)(if (coll? x) (mapcat my-flatten x) [x]))","user":"6078ce29e4b0a637ed78035a"},{"problem":28,"code":"#(filter (complement sequential?)\n         (rest (tree-seq sequential? seq %1)))","user":"56e02c1ce4b0ca2494a09602"},{"problem":28,"code":"(fn flatten* [coll]\n  (cond\n    (sequential? coll)\n    (if (empty? coll)\n      '()\n      (concat (flatten* (first coll)) (flatten* (rest coll))))\n    :else\n    (list coll)))","user":"6026737ee4b0d5df2af2222f"},{"code":"(fn rd [coll] \n (reduce \n  #(concat % \n   (case\n    (sequential? %2) \n     true (rd %2)\n     false [%2])) '() coll))","problem":28,"user":"511ac026e4b0c87c59c9670e"},{"problem":28,"code":"(fn [ls]\n  (filter (complement sequential?)\n  \t(rest (tree-seq sequential? seq ls))))","user":"5d125d63e4b02c15ef021999"},{"code":"(fn fltn [coll]\n  (if (empty? coll)\n    '()\n    (let [e (first coll)]\n      (if (sequential? e)\n        (concat (fltn e) (fltn (rest coll)))\n        (cons e (fltn (rest coll)))))))","problem":28,"user":"51d08d67e4b067c365486351"},{"code":"(fn flat [c] (mapcat #(if (coll? %) (flat %) (vector %)) c))","problem":28,"user":"52a23af1e4b04e0c58e87beb"},{"problem":28,"code":"(fn flt [xs]\n  (if (coll? xs)\n    (mapcat flt xs)\n    [xs]\n  )\n)","user":"55aa8276e4b0988bba2ad94e"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq %))) ;sigh","problem":28,"user":"51d46133e4b013d740b70de2"},{"code":"(fn flt [coll]\n    (if-let [f (first coll)]\n      (concat (if (sequential? f) (flt f) (list f))\n              (flt (rest coll)))\n      ()))","problem":28,"user":"4e8c1d97535d65386fec2127"},{"code":"(fn squash\n  ([items] (squash items []))\n  ([items output]    \n    (if (empty? items)      \n      output\n      (if (coll? (first items))\n        (squash (rest items) (squash (first items) output))\n        (squash (rest items) (conj output (first items)))))))","problem":28,"user":"4fd9d162e4b05e33b9224f3c"},{"code":"(fn flatt [coll]\n  (if (sequential? coll)\n    (mapcat flatt coll)\n    (list coll)))","problem":28,"user":"51c9a705e4b09ce160bef5ab"},{"problem":28,"code":"(fn f [coll] (reduce (fn [x y] (if (coll? y) (concat x (f y)) (concat x [y]))) '() coll))","user":"5be9d530e4b0f319e2d7ec79"},{"problem":28,"code":"(fn flat [x]\n  (if (nil?  (seq x))\n    '()\n    (if (coll? (first x))\n      (concat (flat (first x))  (flat (rest x)))\n      (cons (first x) (flat (rest x)))))\n  \n)","user":"524025bce4b0ad64fa01030f"},{"code":"(fn flat [c]\n  (if (coll? c)\n    (if (empty? c)\n      '()\n      (concat (flat (first c)) (flat (rest c)))\n    )\n    (list c)\n  )\n)","problem":28,"user":"4ecc147b535d23f0362276f7"},{"code":"(fn fl [l] (loop [l l acc '[]]\r\n  (cond (empty? l) acc\r\n        (sequential? (first l)) (recur (next l) (concat acc (fl (first l))))\r\n        true (recur (next l) (concat acc (list (first l)))))))","problem":28,"user":"4ddbd934535d02782fcbe9fc"},{"problem":28,"code":"(fn flat [x]\n  (reduce (fn [val item]\n            (if (sequential? item)\n              (concat val (flat item))\n              (concat val [item]))) (vec nil) x))","user":"5df175bce4b03c219ef1a34d"},{"code":"(fn fflatten\n  ([s] (fflatten () s))\n  ([a s] (if (sequential? s) (if (empty? s) a (concat a (fflatten (first s)) (fflatten (rest s)))) (cons s a) ) )\n)","problem":28,"user":"50b8de6ce4b0cba0e598b652"},{"problem":28,"code":"(fn [s]\n  (filter (complement sequential?)\n   (rest (tree-seq sequential? seq s))))","user":"5c62f1cde4b0fca0c1622655"},{"code":"(fn [x] \n  (->> x\n     (tree-seq sequential? seq)\n     rest\n     (filter (complement sequential?))))","problem":28,"user":"4f038b62535dcb61093f6b1c"},{"code":"(fn my-flatten [coll]\n  (cond\n    (empty? coll)\n    []\n    (coll? (first coll))\n    (concat (my-flatten (first coll))\n            (my-flatten (rest coll)))\n    :else\n    (cons (first coll) (my-flatten (rest coll)))))","problem":28,"user":"5002b6e5e4b0678c553fc42c"},{"problem":28,"code":"(fn flat [l]                                                                                \n  (let [h (first l) t (next l)]                                                               \n    (cond                                                                                     \n      (coll? h) (if-let [x (nil? (flat t))]                                                   \n                  (flat h)                                                                    \n                  (concat (flat h) (flat t)))                                                 \n      (nil? t) (remove nil? [h])                                                              \n      :else (concat [h] (flat t)))))","user":"57a499dae4b0a966079561e6"},{"problem":28,"code":"(fn flat [x]\n  (lazy-seq\n   \t(reduce (fn intflat [col v]\n              \t(if (sequential? v)\n                  \t(reduce intflat col v)\n                  \t(conj col v)))\n            []\n            x)))","user":"5958a0c8e4b066ee0a44af8c"},{"problem":28,"code":"(fn myf [lst]\n  (cond (empty? lst) '()\n        ((complement sequential?) (first lst)) (cons (first lst) (myf (rest lst)))\n        :else (concat (myf (first lst)) (myf (rest lst)))))","user":"58681907e4b0f14aab7c8889"},{"problem":28,"code":"(fn flat [coll] (if (sequential? coll) (apply concat (map flat coll)) [coll]))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn my-flatten [x] \n  (\n   if (empty? x)\n    x\n    (let [f (first x), r (rest x)] \n      (if (coll? f) \n        (into  (my-flatten r)  (reverse (my-flatten f)))\n        (conj (my-flatten r) f))\n        )\n      )\n    )","problem":28,"user":"50856bd1e4b004985b776e4c"},{"problem":28,"code":"#(reverse (reduce\n             (fn rec-flatten [acc item]\n               (if (coll? item) (reduce rec-flatten acc item)\n                   (conj acc item)))\n             '()\n             %))","user":"535558b9e4b04ce2eb3ed25a"},{"code":"(fn f [[head & tail :as seqnce]]\r\n  (cond\r\n    (empty? seqnce) '()\r\n    (sequential? head) (concat (f head) (f tail))\r\n    :else (cons head (f tail))\r\n  )\r\n)","problem":28,"user":"5043a536e4b034ff00315d24"},{"code":"(fn flat [x] \n (cond \n  (not (sequential? x)) [x]\n  (empty? x) '() \n  :else (concat (flat (first x)) (flat (rest x)) )\n )\n)","problem":28,"user":"53350264e4b0656e627bfd73"},{"problem":28,"code":"(fn flat [c]\n  (seq (reduce (fn [xs x]\n                 (apply conj xs\n                        (if (coll? x)\n                          (flat x)\n                          [x])))\n               []\n               c)))","user":"5712a404e4b07c98581c3a8d"},{"problem":28,"code":"(fn recFlatt [x] (mapcat (fn [y] (if (coll? y) (recFlatt y) (list y))) x ) )","user":"567e6d24e4b0feffd0d18eb4"},{"problem":28,"code":"(fn flat [lst] (if (not (coll? lst)) (list lst) (if (not (empty? lst)) (concat (flat (first lst)) (flat (rest lst))))))","user":"59078134e4b047aa04b1995c"},{"code":"(fn myflat [s] (reduce (fn [l e] (if (or (vector? e)  (seq? e)) (concat l (myflat e)) (concat l (list e)))) '() s))","problem":28,"user":"529f5a23e4b04e0c58e87baa"},{"problem":28,"code":"(fn flat [s] \n  (if (or (seq? s) (vector? s))\n    (if (= s ())\n      '()\n      (concat \n       (flat (first s)) \n       (flat (rest s))\n      )\n    )\n    (list s)\n  )\n)","user":"5528ecd1e4b0ffed3738f942"},{"code":"#(letfn [(flat [x]\n               (if (coll? x)\n                 (apply concat (map flat x))\n                 (list x)))]\n   (flat %))","problem":28,"user":"52530b4be4b0541d1855b8e4"},{"problem":28,"code":"#(apply list ((fn my-flatten [coll]\n  (reduce (fn [acc el]\n            (if (coll? el)\n              \t(into acc (my-flatten el))\n              \t(conj acc el)))\n             [] coll)) %1))","user":"59250d2be4b072a2710fce64"},{"problem":28,"code":"(fn [x]\n     (seq\n       (reduce\n       (fn my-flatten [v e]\n           (if (coll? e)\n               (reduce my-flatten v e)\n               (conj v e)))\n       [] x)))","user":"5a4b3abde4b05d388ecb6b81"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    ()\n    (if (coll? (first lst))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (cons (first lst) (my-flatten (rest lst)))\n    )\n  )\n)","user":"5a984657e4b0d174b936c78a"},{"problem":28,"code":"(fn flat [tree]\n  (loop [flattened [],\n         tree (vec tree)]\n    (if (empty? tree)\n      flattened\n      (recur \n        (let [next-node (first tree)]\n          (if\n            (or \n              (vector? next-node) \n              (seq? next-node))\n          (into flattened (flat next-node))\n          (conj flattened next-node)))\n       (next tree)))))","user":"54bd91d7e4b0ed20f4ff6ee2"},{"code":"(fn flt [x]\n  (let [l (first x) r (next x)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"50054b5ce4b0678c553fc45f"},{"problem":28,"code":"(fn best-flatten\n  [values]\n  (reduce (fn \n            [acumulated value] \n            (if-not (coll? value)\n             (into acumulated (list value))\n             (into acumulated (best-flatten value)))) \n          [] values))","user":"5eb1e42ae4b00a66d4a95202"},{"code":"(fn my-flatten3 [orig-coll]\r\n  ((fn my-flatten2 [xs acc]\r\n     (cond \r\n      (and (sequential? xs) \r\n     (empty? xs) )\r\n         acc\r\n      (not (sequential? xs))\r\n         (conj acc xs)   \r\n      :else \r\n         (into (my-flatten2 (first xs) acc) (my-flatten2 (rest xs) []))))\r\n     orig-coll [])\r\n)","problem":28,"user":"4dc54eb2535d8a4b2fd74284"},{"problem":28,"code":"(fn flat [el] \n  (if (coll? el) \n    (mapcat flat el) \n    [el]))","user":"54194782e4b01498b1a71a29"},{"code":"(fn [coll]\n  (letfn [(flat [acc coll']\n            (if (coll? coll')\n              (reduce flat acc coll')\n              (cons coll' acc)))]\n    (reverse (flat '() coll ))))","problem":28,"user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn flat\n  [colls]\n  (let [l (first colls) r (next colls)]\n    (concat\n    (if (sequential? l)\n      (flat l)\n      [l])\n    (when (sequential? r)\n      (flat r)\n      )\n     )\n    )\n  )","problem":28,"user":"513dfe2ce4b0825f97f7f966"},{"problem":28,"code":"(fn flat\n      [[h & t :as x]]\n      (when x\n        (if (coll? h)\n          (concat (flat h) (flat t))\n          (cons h (flat t))\n          )))","user":"5585f088e4b001b0851d7513"},{"code":"(fn flat [x]\n  (if (coll? (first x))\n    (flat (concat (flat (first x)) (flat (rest x))))\n    (if (some coll? (rest x))\n      (cons (first x) (flat (rest x)))\n    x)))","problem":28,"user":"5231d8fae4b0e2e8de81d1fb"},{"problem":28,"code":"(fn [values &]\n  (letfn [(flat [value]\n            (when-let [col (seq value)] \n              (let [item (first col)]\n                (if (sequential? item)\n                  (concat (flat item) (flat (rest col)))\n                  (conj (flat (rest col)) item)))))]\n    (loop [values values result []]      \n      (if (empty? values)\n        result         \n        (recur (rest values)\n               (let [item (first values)]\n                 (if (sequential? item)\n                   (concat result (flat item))\n                   (concat result (list item)))))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn f [x] (mapcat #(if (coll? %) (f %) (list %)) x))","problem":28,"user":"4e704293535d5021c1a89634"},{"problem":28,"code":"(fn a\n  ([x] (if (coll? x) (apply a x) (list x)))\n  ([x & more] (if (coll? x)\n                (apply conj (a more) (reverse (a x)))\n                (conj (a more) x))))","user":"54344721e4b0b6b47310fcea"},{"code":"(fn flatten$ [xs]\n  (if (some coll? xs)\n    (recur (mapcat #(if (coll? %) % [%]) xs))\n    xs))","problem":28,"user":"52244a77e4b01819a2de42d1"},{"problem":28,"code":"(fn collapse [x] (if (not (or (vector? x) (list? x))) (list x) (apply concat (map collapse x))))","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn [lst]\n  (loop [lst (vec lst) acc []]\n    (if (empty? lst)\n      acc\n      (if (sequential? (first lst))\n        (if (= (count lst) 1)\n          (recur (vec (first lst)) acc)\n          (recur (apply conj (vec (first lst)) (rest lst)) acc)\n        )\n        (recur (rest lst) (conj acc (first lst)))\n      )\n    )\n  )\n)","problem":28,"user":"4ec6c878535d6d7199dd36d5"},{"problem":28,"code":"(fn self [seq]\n  (if (sequential? seq)\n  \t(apply concat (map self seq))\n    (list seq)))","user":"53acca34e4b047364c044460"},{"problem":28,"code":"mapcat (fn _ [x] (if (coll? x) (mapcat _ x) [x]))","user":"5e41b679e4b01d43a70e8e58"},{"code":"#(reverse ((fn myflatten [xs]\n  (let [f (fn [acc, x]\n            (if (or (list? x) (vector? x))\n              (concat (myflatten x) acc)\n              (conj acc x)))]\n    (reduce f () xs))) %))","problem":28,"user":"522b922ee4b0d34ee08e71c3"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (fn [res e]\n            (println \"res=\" res e)\n            (if (sequential? e)\n              (concat (vec res) (flat e))\n              (conj (vec res) e)))]\n\n  (reduce f [] s)))","user":"534bfc71e4b084c2834f4a88"},{"problem":28,"code":"(fn flat [sequence] (let [[firstItem & restItems] sequence]\n                 (cond \n                  \t(empty? sequence) '()\n                  \t(coll? firstItem) (concat (flat firstItem) (flat restItems))\n                  \t:else (cons firstItem (flat restItems)))))","user":"5f97eff1e4b0715f5002d7f9"},{"code":"(fn f[x]\n  (cond \n   (coll? x) (mapcat f x) \n   :else (conj () x)))","problem":28,"user":"4f23e1cde4b0d66497709fe4"},{"problem":28,"code":"(fn f [xs] \n  (if (empty? xs) \n    nil \n    (if (sequential? (first xs)) \n      (concat \n       (f (first xs)) \n       (f (rest xs))) \n      (conj \n       (f (rest xs)) \n       (first xs)))))","user":"560c31b4e4b05f002753df2d"},{"code":"(fn [x](filter (complement sequential?)(rest (tree-seq sequential? seq x))))","problem":28,"user":"50813b88e4b09292fd669443"},{"problem":28,"code":"(fn [coll]\n   (let [flatten-1\n         (partial mapcat #(if (coll? %) % [%]))]\n     (first (drop 20\n            (iterate flatten-1 coll)))))","user":"5d4b2155e4b0776584bd6f28"},{"problem":28,"code":"#((fn flt [[f & r :as graph] acc]\n  (cond (nil? f)        acc\n        (sequential? f) (concat (flt f acc) (flt r acc))\n        :else           (concat acc [f] (flt r acc)))) % [])","user":"563772a9e4b0bfe05bf117d7"},{"problem":28,"code":"(fn x [c] \n  (loop [col c]\n    (if (every? false? (map coll? col))\n      col\n      (recur (mapcat  #(if (sequential? %) % [%]) col)) )))","user":"58988cbbe4b00487982d52d7"},{"problem":28,"code":"(fn flat [s]\n  (if (coll? s)\n    (apply concat (map flat s))\n    (vector s)))","user":"551ed214e4b08d5046aa8a4d"},{"code":"(fn flat [a] (mapcat #(if-not (coll? %) (list %) (flat %)) a))","problem":28,"user":"51037468e4b00c483ae17702"},{"problem":28,"code":"(fn fltn [s]\n (if (empty? s)\n  s\n  (concat\n   (if (sequential? (first s))\n    (fltn (first s))\n    (list (first s)))\n   (fltn (rest s)))))","user":"4f577f25e4b0a7574ea71839"},{"code":"(fn flat [s] (reduce #(if (coll? %2) (into %1 (flat %2)) (conj %1 %2)) [] s))","problem":28,"user":"50d3ec8be4b030b634c368bb"},{"problem":28,"code":"(fn [xss]\n  (seq ((fn my-flatten [acc xs]\n    (if (coll? xs)\n  \t(apply conj acc (reduce my-flatten [] xs))\n    (conj acc xs)))\n  [] xss)))","user":"5b1c16e1e4b03cfeda66ecf2"},{"problem":28,"code":"(fn [x] (apply concat (map      #(loop [in % acc []]\n            (cond\n              (not (sequential? in))\n        \t(conj acc in)\n              (and (= 1 (count in)) (not (sequential? (first in))))\n        \t(conj acc (first in))\n              (and (= 1 (count in)) (sequential? (first in)))\n        \t(recur (first in) acc)\n              :else\n        \t(recur (rest in) (conj acc (first in)))\n            )\n       )\n    \nx\n)))","user":"53ed03f0e4b0d648e757f4bb"},{"code":"(fn\n  [lst]\n  (filter (complement sequential?)\n   (rest (tree-seq sequential? seq lst))))","problem":28,"user":"4ef7a483535dced4c769f258"},{"code":"(fn [s]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq s))))","problem":28,"user":"4daee8e9edd6309eace4d166"},{"code":"(fn flat [n] \n  (reduce \n     (fn [xs x] \n          (if (sequential? x)\n            (concat xs (flat x))\n            (concat xs [x]))) \n     [] \n     n))","problem":28,"user":"507c4829e4b0a19f8e876e57"},{"problem":28,"code":"(fn flat [xs]\n   (println \"calling with\" xs)\n   (reduce (fn [acc x]\n             (if (coll? x)\n               (vec  (concat acc (flat x)))\n               (conj acc x)))\n           [] xs))","user":"57a5da5ee4b0a966079561fe"},{"code":"(fn p28ci [col] (mapcat #(if (coll? %) (p28ci %) (list %)) col))","problem":28,"user":"52b577c9e4b0c58976d9ad39"},{"code":"(fn fltn [[x & more]]\r\n  (if (not x)\r\n    []\r\n    (if (coll? x)\r\n      (concat (fltn x) (fltn more))\r\n      (cons x (fltn more)))))","problem":28,"user":"4e113a81535d04ed9115e7c5"},{"problem":28,"code":"(fn flatn [c] (if (coll? c) (apply concat (map flatn c)) (list c)))","user":"540e0637e4b0addc1aec6717"},{"problem":28,"code":"#(letfn [(myf [args]\n            (cond\n              (empty? args) nil\n              (coll? (first args)) (concat (myf (first args)) (myf (rest args)))\n              :else (cons (first args) (myf (rest args)))))]\n   (myf %)\n   )","user":"57d93437e4b0bd073c2023f9"},{"code":"(fn _step [s]\n  (if (= (count s) 1)\n    (if (coll? (first s))\n      (_step (first s))\n      s)\n    (apply conj\n      (if (coll? (first s))\n        (_step (first s))\n        [(first s)])\n      (_step (rest s)))))","problem":28,"user":"4ea67906535d7eef308072e4"},{"problem":28,"code":"(fn [a] (remove sequential? (tree-seq sequential? identity a)))","user":"58273e82e4b051871117bf1b"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst)  lst\n    (coll? (first lst))  (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else\n    (cons (first lst) (my-flatten (rest lst)))))","user":"5aa00b7fe4b0d174b936c825"},{"problem":28,"code":"(fn flt [col]\n      (let [h (first col)\n            t (rest col)]\n        (cond (empty? col) nil\n              (sequential? h) (concat (flt h) (flt t))\n              :else (cons h (flt t)))))","user":"5146f343e4b04ef915e3731e"},{"problem":28,"code":"(fn my-flatten\n              [inlist ]\n              (let [[h & t] inlist]\n                (cond\n                  (empty? inlist) nil\n                  (coll? h) (concat (my-flatten h) (my-flatten t))\n                  :else (cons h (my-flatten t))\n                  )))","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":28,"code":"(fn [ls]\n  (if (every? #(not (coll? %)) ls) ls\n      (recur (reduce concat (map #(if (coll? %) % (list %)) ls)))))","user":"578ce779e4b0ebec4cfb7561"},{"problem":28,"code":"(fn fn1 [x]\r\n\r\n\t(if (not (or (list? x) (vector? x) (chunked-seq? x)))\r\n\t\t(list x)\r\n\t\t(if (empty? (rest x))\r\n\t\r\n\t\t\t(if (not (or (list? x) (vector? x) (chunked-seq? x)))\r\n\t\t\t\t(list x)\r\n\t\t\t\t(fn1 (first x))\r\n\t\t\t)\t \r\n\r\n\t\t\t(if (or (list? (first x)) (vector? (first x)) (chunked-seq? (first x)))\r\n\t\t\t\t( concat (fn1 (first x)) (fn1 (rest x)) )\r\n\t\t\t\t( concat (fn1 (list (first x))) (fn1 (rest x)) )\r\n\t\t\t)\r\n\t\t\r\n\t\t)\r\n\t)\r\n)","user":"55cde227e4b0e31453f64a22"},{"problem":28,"code":"(fn myflat [coll]\n    (when-let [s  (seq coll)]\n      \t(concat ((if (coll? (first s))\n                  myflat\n                  list\n                   ) (first s))\n                (myflat (rest s)))))","user":"551ebcd7e4b08d5046aa8a4a"},{"problem":28,"code":"(fn fl [s] (mapcat #(if (coll? %) (fl %) (list %)) s))","user":"5680fff3e4b0966858e4d8f6"},{"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n    [] coll)))","problem":28,"user":"510f0b95e4b0faca7c680138"},{"problem":28,"code":"(fn func [f]\n  (if(coll? f)\n    (mapcat func f)\n    (list f))\n  \n  )","user":"5f727be9e4b02876ed9fd08d"},{"problem":28,"code":"(fn z ([xs] (z [] xs))\n  ([acc xs]\n   (if (sequential? xs)\n     (into [] (concat acc (into [] (reduce z [] xs))))\n     (conj acc xs))))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn f [L]\n  (if (empty? L) L\n  (if (or (vector? (first L)) (seq? (first L)))\n    (concat (f (first L)) (f (rest L)))\n    (cons (first L) (f (rest L))))))","problem":28,"user":"50976c84e4b00ad8bab4e961"},{"problem":28,"code":"#(let [mc (fn mc [x]\n            (if (coll? x)\n              (mapcat mc x)\n              [x]))]\n   (mapcat mc %))","user":"59074b7ce4b047aa04b19951"},{"code":"(fn flat [xs]\n  (reduce #(\n            if (sequential? %2) \n              (into %1 (flat %2))\n              (conj %1 %2)\n            ) '[] xs))","problem":28,"user":"523b82efe4b07becd5be21f0"},{"problem":28,"code":"(fn [x]                                                                            \n        (letfn [(flt [s acc]                                                                       \n                  (cond                                                                            \n                   (= s ()) acc                                                                    \n                   (= false (sequential? s)) (conj acc s)                                          \n                   :else (flt (first s) (flt (rest s) acc))))]                                     \n          (flt x ())))","user":"5423dc6ae4b01498b1a71ad5"},{"problem":28,"code":"(fn flatt [sequ]\n  (loop [s sequ res []]\n    (if (empty? s)\n      res\n      (if (coll? (first s))\n        (recur (concat (first s) (rest s)) res)\n        (recur (rest s) (conj res (first s)))))))","user":"5c7d5a0ce4b0d597f478caab"},{"code":"(fn fl [x]\n  (cond\n    (coll? x) (cond \n                (empty? (rest x)) (fl (first x))\n                :else (concat (fl (first x)) (fl (rest x)))\n              )\n    :else [x]\n  )\n)","problem":28,"user":"4dd1de4d535dae65d5c462d7"},{"code":"(fn flt [x]\n  (apply concat (map #(if (coll? %) (flt %) [%]) x))\n)","problem":28,"user":"4fe610fde4b0e8f79898fece"},{"problem":28,"code":"(fn my-flatten\n  ([argum]\n   (if (coll? argum)\n     (apply concat (for [x argum] (my-flatten x)))\n     [argum])))","user":"5e88a676e4b0cb016954630a"},{"problem":28,"code":"(fn flat [lst]\n  (let [enclose (fn [x] (if (sequential? x) x [x]))\n        enclosed (map enclose lst)\n        lst (if (some sequential? lst) (map flat enclosed) enclosed)]\n    (reduce concat [] lst)))","user":"5912477be4b0163c97b36eec"},{"problem":28,"code":"#(loop [l1 %, l2 `()]\n\t  (cond\n\t    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n\t    (empty? l1) (reverse l2)\n\t    :else (recur (rest l1) (cons (first l1) l2))))","user":"53dcb9b2e4b0d874e779ae23"},{"code":"(fn [coll]\n    (filter (complement sequential?) (tree-seq sequential? seq coll)))","problem":28,"user":"5317d78ee4b08068f379ed63"},{"problem":28,"code":"(fn flat [coll]\n  (reverse (reduce\n   \t(fn [acc item]\n      (if (coll? item)\n      \t(into acc (flat item))\n        (into acc (list item))\n      )\n    ) \n  \t'()\n    coll\n   ))\n)","user":"54bb0f63e4b0ed20f4ff6ebc"},{"problem":28,"code":"(fn my-flatten [s]\n  (mapcat #(if (coll? %) \n             (my-flatten %) \n             [%])\n          s))","user":"5b236e55e4b08b1df1c36759"},{"code":"(fn my-flatten [x]\n  (loop [l x acc '()]\n    (if (empty? l)\n      acc\n      (let [f (first l)]\n        (recur (rest l)\n             (concat acc \n                     (if (coll? f)\n                       (my-flatten f)\n                       (list f))))))))","problem":28,"user":"515828b8e4b0a069fd272c71"},{"problem":28,"code":"(fn f-dest [x & tail] \n  (concat \n    (if (coll? x)\n      (apply f-dest x) \n      [x]) \n    (if (nil? tail)\n      nil\n      (apply f-dest tail))))","user":"55f2b42be4b06e875b46ce4a"},{"code":"(fn flat [x] \n  (if (sequential? x)\n    (filter (complement nil?) (concat (flat (first x))(flat (next x))))\n    (list x)))","problem":28,"user":"5125834ae4b05d10e3e395fa"},{"problem":28,"code":"(fn f [l]\n        (cond\n          (empty? l) '()\n          (sequential? (first l)) (concat (f (first l)) (f (rest l)))\n          :else (cons (first l) (f (rest l)))))","user":"58731176e4b01531a375ea2a"},{"code":"(fn f [x] \n  (if (coll? x) (mapcat f x) [x]))","problem":28,"user":"4f6845d2e4b07046d9f4ef74"},{"code":"(fn fltn [xs]\n  (if (coll? xs)\n    (apply concat (map fltn xs))\n    [xs]))","problem":28,"user":"51805d22e4b0e3fc13e244df"},{"code":"(fn flat [coll]\n  (if (coll? coll)\n    (apply concat (map flat coll))\n    (list coll)))","problem":28,"user":"50127fbfe4b030d97e4db70f"},{"problem":28,"code":"(fn myFlatten [coll]\n\t(reduce (fn [acc x] (concat acc (if (coll? x) \n                                      (myFlatten x) \n    \t\t\t\t\t\t\t\t\t(list x)))) [] coll))","user":"57434103e4b0c285004e8a9e"},{"code":"(fn flatter [more]\r\n  (if (sequential? more)\r\n    (mapcat flatter more)\r\n    [more]))","problem":28,"user":"4f7d5328e4b06e829148e1bf"},{"code":"(fn flt[coll]\n  (let [l (first coll) rc (next coll)]\n    (concat\n    \t(if (sequential? l)\n      \t\t(flt l)\n      \t\t[l])\n     (when (sequential? rc)\n       (flt rc)))))","problem":28,"user":"51696bcde4b03f62cda68ce7"},{"code":"(fn flat [xs] ( if (coll? xs) (if (empty? xs) nil (concat (flat (first xs)) (flat (rest xs)))) [xs]))","problem":28,"user":"50ef5703e4b0bdaecbb47d95"},{"code":"(fn [s]\n  ((fn [to-process acc]\n    (if (empty? to-process)\n      (reverse acc)\n      (if (sequential? (first to-process))\n        (recur (concat (first to-process) (rest to-process)) acc)\n        (recur (rest to-process) (conj acc (first to-process))))))\n   s '()))","problem":28,"user":"50119c07e4b028e9d38b393f"},{"problem":28,"code":"; Sorry to say it, but all my attempts failed at this one.  So I found an answer on YouTube\n; https://www.youtube.com/watch?v=iEwMmDJmBxY\n(fn myflatner [s] (if (coll? s) (mapcat myflatner s) [s]) )","user":"5535e822e4b09218d5f44fb2"},{"problem":28,"code":"(fn [items]\n    (filter\n        (complement sequential?)\n        (tree-seq sequential? identity items)))","user":"5f009162e4b0cf489e8d7f1a"},{"code":"(fn myflatten [x]\n   ( \n     (fn myflattenlist [x y]\n       (if\n         (coll? x)\n         (if \n           (empty? x)\n           y\n           (myflattenlist (first x) (myflattenlist (rest x) y))\n           )\n         (cons x y)) \n       )\n     x\n     '()\n     )\n   )","problem":28,"user":"51f687c2e4b06ff1c25c52cb"},{"problem":28,"code":"(fn f [x]\n  (reduce\n    (fn [a b]\n      (if (sequential? b) (concat a (f b))\n\t\t(concat a (list b)))) () x))","user":"589f4387e4b02bd94d917e7b"},{"problem":28,"code":"(fn [s]\n  (loop [curr (first s)\n         remaining (rest s)\n         flattened ()]\n    (if (nil? curr)\n      (reverse flattened)\n      (if (or (seq? curr) (vector? curr))\n        (recur\n         (first curr)\n         (if (empty? (rest curr)) remaining (conj remaining (rest curr)))\n         flattened)\n      \t(recur (first remaining) (rest remaining) (conj flattened curr))))))","user":"5f3ddc71e4b004f08c61c551"},{"code":"(fn flat-1 [list]\n(reverse\n((fn flat [list cum]\n  (let [a (first list) b (rest list)]\n  \t(if (nil? a) cum\n\t\t(if-not (sequential? a) (flat b (cons a cum)) (flat b (flat a cum)))))) list [])))","problem":28,"user":"50e135f4e4b084616e11c667"},{"code":"(fn __ [x]\n  (if (sequential? x)\n    (if (empty? x)\n      '()\n      (concat (__ (first x)) (__ (rest x))))\n    (list x)))","problem":28,"user":"52c7f036e4b0c2d177d62126"},{"code":"(fn [seq]\n  (let[get-flat-values (fn[seq]  (filter (comp not sequential?) seq))\n      get-seq (fn [seq]  (filter sequential? seq))\n      unwrap (fn [seq]\n               (loop [s seq\n                      res '()]\n                 (if (empty? s)\n                   res\n                   (recur (rest s)\n                          (into res (first s))))))]\n  (loop [s (get-seq seq)\n         res (get-flat-values seq)]\n      (if  (empty? s)\n        (sort res)\n        (recur (get-seq (unwrap s))\n              (into res (get-flat-values (unwrap s))))))))","problem":28,"user":"516081e7e4b009fba0926e28"},{"problem":28,"code":"(fn r [l] \n  (if (some coll? l)\n    (r (mapcat (fn [i]\n                 (if (coll? i)\n                   i\n                   [i])) l))\n       l))","user":"56aed78fe4b03c432f187363"},{"code":"(fn flatten_ [s]\n  (mapcat (fn [element]\n\t\t\t\t\t(if (sequential? element)\n\t\t\t\t\t\t(flatten_ element)\n\t\t\t\t\t\t[element]))\n\t\ts))","problem":28,"user":"4f442cdfe4b0d7d3c9f3fd34"},{"code":"(fn fltn [x]\n  (if-not (coll? x)\n    (list x)\n    (mapcat fltn x)))","problem":28,"user":"4db86aee535d1e037afb2193"},{"code":"#(filter (comp not sequential?) (tree-seq sequential? seq %))","problem":28,"user":"4f725201e4b07046d9f4f02f"},{"problem":28,"code":"(fn [s]\n  (let [mf_int (fn mf_rec [s, f]\n    (if (empty? s)\n      f\n      (if (coll? (first s))\n        (concat (mf_rec (first s) f) (mf_rec (rest s) '()))\n        (mf_rec (rest s) (concat f (repeat 1 (first s))))\n      )\n    )\n  )]\n (mf_int s '()))\n)","user":"554756b8e4b0a04f79299549"},{"problem":28,"code":"(fn fltn\n    [xs]\n  (reduce (fn [x y] (concat x (if (sequential? y) y (list y)))) []\n          (map (fn [x] (if (sequential? x) (fltn x) x)) xs)))","user":"5a16da30e4b0ff51aa4b31cc"},{"problem":28,"code":"(fn f [[fi & ri :as coll]]\n  (if (empty? coll)\n    coll\n    (if (coll? fi)\n      (concat (f fi) (f ri))\n      (concat [fi] (f ri)))))","user":"5ec2930ae4b00a66d4a9529d"},{"code":"(fn my-flatten [c]\n  (mapcat #(if (coll? %) (my-flatten %) [%]) c))","problem":28,"user":"4ede361a535d10e5ff6f5332"},{"problem":28,"code":"(fn flatten2 [coll] \n (reverse (reduce (fn reduct-funct [acc y]\n  (if (coll? y) (reduce reduct-funct acc y)                                  \n      (conj acc y))) '() coll)))","user":"59fa0bb6e4b0ca45a743a352"},{"problem":28,"code":"(fn flat [seqn] (reduce (fn [s, i] (if (coll? i) (vec (concat s (flat i))) (conj s i))) [] seqn))","user":"5519c157e4b00ace28fe6e32"},{"problem":28,"code":"(fn fltn [sq]\n    (cond (empty? sq) nil\n          (coll? (first sq)) (concat (fltn (first sq)) (fltn (rest sq)))\n          :else (cons (first sq) (fltn (rest sq)))))","user":"4f867b25e4b033992c121c51"},{"problem":28,"code":"(fn ab [col] \n  (if (coll? col)\n    (mapcat ab col)\n    [col]\n  )\n)","user":"5619b22ee4b053970a773afe"},{"code":"(fn my-flatten [coll]\n  (reduce #(if (coll? %2)\n             (concat %1 (my-flatten %2))\n             (concat %1 (list %2)))\n          '() coll))","problem":28,"user":"5348cab4e4b084c2834f4a5e"},{"problem":28,"code":"(fn [input]\n  (loop [head (first input)\n         end (rest input)\n         res []]\n    (if (or (sequential? head) (nil? head))\n      (if (empty? head)\n        (if (empty? end)\n          (seq res)\n          (recur (first end) (rest end) res))\n        (if (empty? (rest head))\n          (recur (first head) end res)\n          (recur (first head) (conj (vec (rest head)) end) res)))\n        (recur (first end) (rest end) (conj res head)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":28,"code":"(fn myflat [x] (if (coll? x) (mapcat myflat x) [x]))","user":"5602f5fce4b04bb52996e1ad"},{"problem":28,"code":"(fn flt[s](if(coll? s)(mapcat flt s)(list s)))","user":"5481be5fe4b0e286459a1172"},{"problem":28,"code":"(fn this [s]\n  (loop [s (seq s) n '()]\n    (if (empty? s)\n      n\n      (if (sequential? (first s))\n        (recur (rest s) (concat n (this (first s))))\n        (recur (rest s) (concat n (list (first s))))))))","user":"563d12f9e4b0bfe05bf11845"},{"code":"(let [closure (fn [f x] (let [fx (f x)]\n                          (if (= fx x) fx (recur f fx))))\n      flatten-once (fn [c]\n        (mapcat #(if (coll? %) % (list %)) c))]\n  (partial closure flatten-once))","problem":28,"user":"4ea1b9e4535d7eef308072b8"},{"problem":28,"code":"(fn fln [ls]\n  (if (sequential? ls)\n    (mapcat fln ls)\n    (list ls)))","user":"561f9110e4b064ca9f4b16ce"},{"code":"(fn my-flat [coll]\n  (reverse\n    (loop [result '()\n           remain coll]\n      (if (empty? remain)\n          result\n          (let [new-remain (rest remain)\n                next-item  (first remain)\n                next-seq   (if (sequential? next-item)\n                               (my-flat next-item)\n                               (list next-item))]\n            (recur (apply (partial conj result) next-seq) new-remain))))))","problem":28,"user":"4daf36c2edd6309eace4d175"},{"problem":28,"code":"(fn [xs]\n  (reduce (fn inner-flat[acc x]\n            (if(coll? x) (reduce inner-flat acc x) (conj acc x))) [] xs))","user":"54dce6dbe4b024c67c0cf78d"},{"problem":28,"code":"(fn [coll]\n    (letfn [(flattn [coll]\n            (let [f (first coll)\n                  r (next coll)\n                  r (if (coll? r) (flattn r) '())]\n              (if (coll? f)\n                (concat (flattn f) r)\n                (cons f r))))]\n    (flattn coll)))","user":"56a76f36e4b07966d5a8a05b"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n     \t(if (sequential? l)\n          (flt l)\n          [l]\n        )\n        (when (sequential? r)\n          (flt r)\n     \t)\n    )\n  )\n)","user":"55990d3ce4b031d6649c9ba3"},{"problem":28,"code":"(fn my-flatten [array]\n  (let [inner-flatten (fn this [array, accumulator]\n                        (let [firstElem (first array)\n                              rest (rest array)]\n                          (cond\n                            (or (vector? firstElem) (list? firstElem)) (this rest (this firstElem accumulator) )\n                            (= nil firstElem) accumulator\n                            (= 0 (count rest)) (conj accumulator firstElem)\n                            :else (this rest (conj accumulator firstElem))\n                            )))]\n    (inner-flatten array []))\n  )","user":"56530a1ce4b0f9d632dd846c"},{"code":"(fn fl [x] \n    (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x)))\n)","problem":28,"user":"52bb55e8e4b07a9af57922e3"},{"problem":28,"code":"(fn my-flatten [col]\n  (println col)\n  (println (first col))\n  (cond\n  (nil? (first col)) nil\n  (coll? (first col)) (concat (my-flatten (first col)) (my-flatten (rest col)))\n  :else (concat (list (first col)) (my-flatten (rest col)))))","user":"6065755ee4b069485764ddcc"},{"code":"(fn fl [p]\n  (if (zero? (count p))\n    p\n    (let [f (first p)\n          r (rest p)]\n      (if-not (sequential? f)\n        (cons f (fl r))\n        (concat (fl f) (fl r))))))","problem":28,"user":"53908e6be4b0b51d73faae9a"},{"problem":28,"code":"(fn flat [x] \n  (if (sequential? x)\n\t(if (sequential? (first x))\n\t\t(concat (flat (first x)) (flat (rest x)))\n\t\t(if (> (count x) 0) \n\t\t\t(cons (first x) (flat (rest x)))\n\t\t\t'()\n\t\t)\n\t)\n\tx\n  )\n)","user":"548018e3e4b0c51c1f4d7330"},{"code":"(fn* flatten_ [x]\n     (reduce \n      (fn [y z] (if (coll? z) \n                  (into y (flatten_ z)) \n                  (conj y z)))\n      []\n      x))","problem":28,"user":"53468f6ce4b084c2834f4a3f"},{"problem":28,"code":"(fn flat [x] (cond (empty? x) nil (not (coll? (first x))) (cons (first x) (flat (rest x))) :else (concat (flat (first x)) (flat (rest x)))))","user":"4f18f65d535d64f603146462"},{"problem":28,"code":"(fn ft [coll]\n  (if (sequential? coll)\n    (mapcat ft coll)\n    (list coll)))","user":"55896a0ce4b059ccff29b204"},{"problem":28,"code":"(fn flt [sq] (\n  mapcat #(\n    if(sequential? %) (flt %) (list %)\n  ) sq))","user":"53e9681de4b036ad0777e4a4"},{"problem":28,"code":"(fn ! [a-seq]\n  (if (empty? a-seq)\n    '()\n    (concat (if (coll? (first a-seq))\n            (! (first a-seq))\n            (list (first a-seq)))\n          (! (rest a-seq)))))","user":"5235493ee4b05e80434a5064"},{"problem":28,"code":"(fn [col] (filter (complement sequential?) (rest (tree-seq sequential? seq col))))","user":"564a560ae4b0284900eef654"},{"problem":28,"code":"(fn [col]\n  (letfn [(flat\n          [col]\n          (mapcat \n    \t\t(fn [x]\n      \t\t\t(if (sequential? x)\n        \t\t\t(flat x)\n        \t\t\t(list x)))\n    \t\tcol))]\n\t(flat col)           \n))","user":"566e87cfe4b0a866af6896dc"},{"problem":28,"code":"(fn flattenize [coll]\n\t(if-not (counted? coll)\n      [coll]\n      (reduce (fn [acc x] (into acc (flattenize x))) [] coll)\n    ))","user":"5429986ce4b01498b1a71b3b"},{"code":"(fn fl [x]\r\n  (cond\r\n    (= ()        x ) ()\r\n    (not (coll?   x)) (list x)\r\n    :else (concat (fl (first x)) (fl (rest x)))))","problem":28,"user":"4fd153cee4b04c3a95aa040e"},{"code":"(fn flt [coll] (let [a (first coll) b (next coll)] \n(concat (if (sequential? a) (flt a) [a]) \n(when (sequential? b) (flt b)))))","problem":28,"user":"504dff92e4b078edc5f5938a"},{"code":"(fn my-flat [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      nil\n      (concat (my-flat (first xs))\n              (my-flat (rest xs))))\n    (list xs)))","problem":28,"user":"52e41c22e4b09f7907dd144b"},{"code":"(fn flat [-list]\n  (letfn [(flat-helper [-elt]\n           (if (or (coll? -elt )(vector? -elt))\n               (flat -elt)\n                (list -elt)))]\n  (mapcat flat-helper -list)))","problem":28,"user":"50293245e4b08353e5d459cf"},{"code":"#(remove coll? (tree-seq sequential? seq %))","problem":28,"user":"500ee13be4b00fff93030fa1"},{"problem":28,"code":"(fn flat [s]\n  (mapcat #(if (sequential? %) (flat %) [%]) s))","user":"57cd7498e4b0c746388ab897"},{"problem":28,"code":"(fn foo [x]\n  (if (empty? x)\n    ()\n  (if (coll? (first x))\n    (concat (foo (first x)) (foo (rest x)))\n    (cons (first x) (foo (rest x))))))","user":"557dbc9de4b05c286339e0cd"},{"problem":28,"code":"(fn [l] (filter (complement coll?) (tree-seq coll? seq l)))","user":"554d04bbe4b0a04f792995b4"},{"problem":28,"code":"(fn new-flat [s]\n  (reduce (fn [flat elem]\n            (if (coll? elem)\n              (into flat (new-flat elem))\n              (conj flat elem)))\n          []\n          s))","user":"59946856e4b0b211ea3aaac7"},{"problem":28,"code":"(fn flattenX [x] (if (coll? x) (mapcat flattenX x) (list x)))","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn flat [s]\n  (cond (coll? s) (apply concat (map flat s))\n        :else (list s)))","problem":28,"user":"4fedd2cae4b0198f34b063ba"},{"problem":28,"code":"(fn[x](filter (complement sequential?) (tree-seq sequential? seq x)))","user":"55f6fafbe4b06e875b46cea1"},{"problem":28,"code":"; Elena's solution\n(fn flat[s] (if (not (coll? s)) (vector s)\n              (if (empty? s) []\n                (into (flat (first s)) (flat (rest s))))))","user":"56cb3a61e4b0ea9b8538f726"},{"code":"(fn [x]\n  (filter \n    (complement sequential?)\n    (rest \n      (tree-seq sequential? seq x))))","problem":28,"user":"4f7d91e6e4b06e829148e1c3"},{"problem":28,"code":"(letfn [(flatfn [acc c] (if-not (coll? c) (cons c acc) (reduce flatfn acc c)))] (comp reverse (partial flatfn (list))))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn flat [s] \n    (if (empty? s) \n        s \n        (let [head (first s) tail (rest s)]\n        \t(if (sequential? head) \n            \t(concat (flat head) (flat tail)) \n            \t(cons head (flat tail))))))","problem":28,"user":"513a2f23e4b067e25a345ec6"},{"problem":28,"code":"(fn [x]\n  ((fn rr [r1 e1]\n     (reduce (fn [r2 e2]\n       (if (sequential? e2) (rr r2 e2) (conj r2 e2))) r1 e1)) [] x))","user":"5fc9d967e4b0689391cc77ce"},{"code":"(fn\n  [x]\n  (loop [[h & t] x\n         r []\n         out []]\n    (if (nil? h)\n      (if (empty? r)\n        out\n        (recur r [] out))\n     (if (coll? h)\n       (recur h t out)\n       (recur t r (conj out h))))))","problem":28,"user":"52d469c8e4b09f7907dd1330"},{"problem":28,"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq %)) )","user":"58ea778be4b056aecfd47d1e"},{"problem":28,"code":"#(filter(complement sequential?) (rest (tree-seq sequential? seq %)))","user":"575d16f8e4b02ea114799377"},{"problem":28,"code":"(fn fl [l] (loop [r [] l l] (if (empty? l) r (recur (if (coll? (first l)) (apply conj r (fl (first l))) (conj r (first l))) (rest l)))))","user":"5995f8ade4b0b211ea3aaae9"},{"code":"(fn flattenASequence [a] (loop [x a] (if (= (some coll? x) nil) x (recur (apply concat \n(map #(if (coll? %) % (list %)) x))))))","problem":28,"user":"4f9336ece4b0dcca54ed6cb7"},{"problem":28,"code":"(fn [s] (loop [h (first s) r (rest s) res []] (if (sequential? h) (recur (first h) (into (apply vector (rest h)) r) res) (if (empty? r) (conj res h) (recur (first r) (rest r) (conj res h))))))","user":"56f8b6efe4b07572ad1a88a5"},{"problem":28,"code":"(fn f [s]\n    (loop [s_ s r []]\n        (if (-> s_ seq not)\n            r\n            (if (coll? (first s_))\n                (recur (rest s_) (reduce conj r (f (first s_))))\n                (recur (rest s_) (conj r (first s_)))))))","user":"55975569e4b031d6649c9b8e"},{"code":"(fn [s-to-flatten]\n  (letfn [(flatten-first-once [s]\n            (if (sequential? (first s))\n                (concat (first s) (rest s))\n                s))\n          (flatten-first [s]\n            (->> s\n                 (iterate flatten-first-once)\n                 (drop-while #(sequential? (first %)))\n                 (first)))\n          (iter [[_ s]]\n            (let [flatter-s (flatten-first s)]\n              [(first flatter-s) (rest flatter-s)]))]\n    (->> [nil s-to-flatten]\n         (iterate iter)\n         (rest)\n         (take-while #(not (nil? (first %))))\n         (map first))))","problem":28,"user":"51a3b135e4b0e77c4ca60bf6"},{"code":"#(remove % (tree-seq % seq %2)) sequential?","problem":28,"user":"4e52d815535d302ef430da77"},{"problem":28,"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))\n\n;; ???????","user":"5d1b2a1ee4b02ea6f0fb6979"},{"code":"(fn mf [a]\n  (if (coll? a)\n    (cond (> (count a) 1)\n          (into (mf (first a)) (mf (rest a)))\n          (= (count a) 1)\n          (mf (first a))\n          (< (count a) 1)\n          [])\n    [a]))","problem":28,"user":"51ab70c3e4b04e3dc0c27b33"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (if (not (empty? x))\n      (do\n        (concat\n         (my-flatten (first x))\n         (my-flatten (rest x))))\n      nil)\n    (list x)))","user":"5a2e638be4b09cafd31c7f7a"},{"problem":28,"code":"#(->> %\n  (tree-seq sequential? seq)\n  (filter (complement sequential?)))","user":"5c219c0fe4b07e362c230581"},{"code":"(fn [s] \n  (loop [l1 (seq s) l2 (list)]\n    (if (empty? l1)\n      l2\n      (if (coll? (first l1))\n        (recur (concat (first l1) (rest l1)) l2)\n        (recur (rest l1) (concat l2 (list (first l1)))))\n    )))","problem":28,"user":"53069e16e4b02e8216869798"},{"problem":28,"code":"#(let [fltn (fn fltn [acc rv]\n               (if (empty? rv)\n                 acc\n                 (let [i (first rv)]\n                   (if (sequential? i)\n                     (recur (into [] (concat acc (fltn []  i))) (rest rv))\n                     (recur (conj acc  i) (rest rv))))))]\n\n    (fltn [] %))","user":"552e1c98e4b076ab5578f7ee"},{"problem":28,"code":"#(reverse(reduce (fn flat [lst elem] \n  (if (coll? elem) \n      (reduce flat lst (seq elem)) \n      (conj lst elem) \n    )) '() %))","user":"5beebdb7e4b0a6d31fed2132"},{"problem":28,"code":"#(letfn [(flattn [coll acc]\n  (loop [coll coll acc acc]\n    (if (empty? coll)\n      acc\n      (if (coll? (first coll))\n        (recur (rest coll) (flattn (first coll) acc))\n        (recur (rest coll) (conj acc (first coll)))))))]\n  (flattn % []))","user":"60225c2ae4b0d5df2af22201"},{"code":"(fn [x]\n  (filter #(not (sequential? %))\n    (tree-seq sequential? identity x)))","problem":28,"user":"5009fd0ae4b03d00572d2d70"},{"code":"#(filter \n  (complement sequential?)\n  (rest (tree-seq sequential? seq %)))","problem":28,"user":"531a3914e4b08068f379ed88"},{"problem":28,"code":"(fn my-flatten [x]\n  (loop [coll x result '()]\n    (let [f (first coll) r (rest coll)]\n      (cond\n       (nil? f)\n        (sort result)\n       (instance? clojure.lang.Seqable f)\n        (recur (into (seq f) r) result)\n       :default\n        (recur r (conj result f))))))","user":"5546704be4b0a04f7929953d"},{"code":"(fn my_flatten [elm]\n  (cond \n   (and (coll? elm) (seq elm))\n   \t(concat (my_flatten (first elm)) (my_flatten (rest elm)))\n   (coll? elm) elm\n   true (list elm)))","problem":28,"user":"526866d1e4b03e8d9a4a71a1"},{"problem":28,"code":"reduce \n  (fn f [r i]\n    (if (coll? i) \n      (reduce f r i)\n      (conj r i))) \n[]","user":"5654d0e1e4b0f9d632dd848c"},{"problem":28,"code":"(fn fltn [s]\n  (cond\n    (not (sequential? s)) (list s)\n    (not-any? sequential? s) s\n    :else (reduce concat '() (map fltn s))))","user":"56f53962e4b046a417f9206c"},{"problem":28,"code":"(fn flattn [v]\n  (if (sequential? v)\n    (mapcat flattn v)\n    (list v)))","user":"5421f861e4b01498b1a71abc"},{"code":"(fn [el]\n    (loop [i 0 len (dec (count el)) res (vec el)]\n      (if (> i len)\n        res\n        (let [item (nth res i)]\n          (if (coll? item)\n            (recur i \n                   (+ (dec len) (count item))\n                   (let [comecomeio (apply conj (vec (take i res)) item) final (drop (inc i) res)]\n                     (if (zero? (count final)) \n                       comecomeio\n                       (apply conj\n                            comecomeio\n                            final))\n                     )\n                   )\n            (recur (inc i) len res)\n            )\n          )\n        )\n      )\n    )","problem":28,"user":"4e94a8b5535dbda64a6f6b16"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (if (coll? s)\n    (mapcat my-flatten s)\n    [s]))","user":"56d91a53e4b0ea9b8538f7ee"},{"problem":28,"code":"(fn [root]\n   (filter (complement sequential?)\n           (tree-seq sequential? seq root)))","user":"54edc818e4b024c67c0cf865"},{"problem":28,"code":"(fn flat [xs]\n  (if (coll? xs)\n    (apply concat (map flat xs))\n    (conj (empty xs) xs)))","user":"53e8c684e4b036ad0777e48b"},{"code":"(fn [xs]\n  (let [f (fn [xs ys]\n            (if (seq xs)\n                (if (sequential? (first xs))\n                    (recur (concat (first xs) (rest xs)) ys)\n                    (recur (rest xs) (conj ys (first xs))))\n                ys))]\n        (f xs [])))","problem":28,"user":"501c76eae4b01d3bc87c0201"},{"problem":28,"code":"(fn flatter [x]\n  (reduce (fn [acc e]\n            (if (sequential? e)\n              (concat acc (flatter e))\n              (concat acc (list e))))\n          '()\n          x))","user":"5786c182e4b0ebec4cfb74fd"},{"code":"(fn flttn [elt] \n  (if (coll? elt)  \n     (if (not (empty? elt))\n       (concat (flttn (first elt)) (flttn (rest elt)))\n       ()\n     )\n     (list elt))     \n   )","problem":28,"user":"536234a5e4b0243289761e4d"},{"problem":28,"code":"(fn flatten* [c]\n  (if (seq c)\n    (if (coll? (first c))\n      (concat (flatten* (first c))\n              (flatten* (rest c)))\n      (cons (first c)\n            (flatten* (rest c))))\n    []))","user":"54d0d115e4b0e8a36923e5d3"},{"problem":28,"code":"(fn flat\n           [acc lst]\n           (if (sequential? lst)\n             (reduce flat acc lst)\n             (conj acc lst)\n             )\n           )\n         []","user":"59933537e4b0b211ea3aaaaf"},{"code":"#(seq\n   (reduce\n    (fn flatten2 [v e]\n      (if (coll? e)\n        (reduce flatten2 v e)\n        (conj v e)))\n    [] %))","problem":28,"user":"52f4fae4e4b05e3f0be25f27"},{"code":"(fn [sequence]\n  (letfn [(flatten-it [so-far to-go]\n            (if (empty? to-go)\n              (reverse so-far)\n              (if (coll? (first to-go))\n                (flatten-it (apply conj so-far (flatten-it '() (first to-go))) (rest to-go))\n                (flatten-it (conj so-far (first to-go)) (rest to-go)))))]\n  (flatten-it '() sequence)))\n\n;; I know I've written this better in the past.","problem":28,"user":"4e42f930535dc968683fc49f"},{"problem":28,"code":"(fn flt [sq] (when-let [s (seq sq)]\n               (if (sequential? (first s))\n                 (concat (flt (first s)) (flt (rest s)))\n                 (cons (first s) (flt (rest s))))))","user":"58225587e4b04b46fc4b0f94"},{"problem":28,"code":"(fn flat \n  ( [] [] )\n  ( [x & more] \n    (if (coll? x) \n      (concat (apply flat x) (apply flat more)) \n      (cons x (apply flat more))\n    )\n  )\n)","user":"53fcb8f7e4b0de5c418485d4"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (reduce (fn [s x]\n            (if (sequential? x)\n              (into s (my-flatten x))\n              (conj s x)))\n          []\n          s))","user":"58543a59e4b07779d46863f5"},{"problem":28,"code":"(fn flatten-a-sequence [xs]\n  (let [car (first xs)\n        cdr (rest xs)]\n    (cond\n      (empty? xs) '()\n      (coll? car) (concat (flatten-a-sequence car)\n                          (flatten-a-sequence cdr))\n      :default (cons car (flatten-a-sequence cdr)))))","user":"518b8561e4b0f028e99addef"},{"problem":28,"code":"#_(fn fx [c] (if (coll? c) (mapcat fx c) [c]))\n#(->> (tree-seq coll? identity %) (remove coll?))","user":"56f974c0e4b07572ad1a88b1"},{"code":"(fn [x] (filter (complement sequential?)\n                    (rest (tree-seq sequential? seq x))))","problem":28,"user":"504457c0e4b01f6c9a8b2360"},{"problem":28,"code":"(fn flat [xs] (loop [all [] coll xs] (if (nil? coll) all (recur (let [item (first coll)] (if (coll? item) (concat all (flat (vec item))) (conj (vec all) item))) (next coll)))))","user":"5e8ce2fee4b0cb0169546328"},{"problem":28,"code":"(fn p28[n]\n  (let [[x & xs] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (p28 x) (p28 xs))\n     :else (cons x (p28 xs)))))","user":"59395adfe4b02506e01a29fb"},{"code":"#(let [f (first %)] (case f '(1 2) '(1 2 3 4 5 6) \"a\" '(\"a\" \"b\" \"c\") '(:a)))","problem":28,"user":"5032b398e4b00c0952a257eb"},{"problem":28,"code":"(fn flat [lst]\n  (let [f (first lst), r (rest lst)]\n    (if (empty? lst) nil\n      (if (sequential? f)\n        (concat (flat f) (flat r))\n        (cons f (flat r))))))","user":"5525d882e4b0ffed3738f910"},{"problem":28,"code":"(fn f [[x & xs]]\n  (if x\n    (if (sequential? x)\n      (f (concat x xs))\n      (conj (f xs) x))\n    '()))","user":"5c2836ebe4b07e362c2305d4"},{"code":"#(filter (complement sequential?)\n  (tree-seq sequential? identity %))","problem":28,"user":"4f01c938535dcb61093f6a39"},{"code":"(fn f [l]\n  (if (sequential? l)\n    (mapcat f l)\n    [l]))","problem":28,"user":"4e5a66d3535d8a8b8723a2ad"},{"code":"(fn ! [coll]\n  (if (coll? coll) (mapcat ! coll) [coll]))","problem":28,"user":"50586354e4b06522596eba78"},{"code":"#(reverse (reduce (fn ! [coll x]\n          (cond\n           (coll? x) (reduce ! coll x)\n           :else (cons x coll))) [] %))","problem":28,"user":"52be0263e4b07a9af579230e"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (empty? coll)\n    '()\n    (if (coll? (first coll))\n      (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n      (cons (first coll) (my-flatten (rest coll))))))","user":"5b338b23e4b025bcb146f33d"},{"problem":28,"code":"(fn flat [s]\n  (if (coll? s)\n    (if (empty? s)\n      s\n      (concat (flat (first s)) (flat (rest s))))\n    (seq [s])))","user":"5b77248ae4b047b03b2036e7"},{"problem":28,"code":"(fn\n  [coll-outer]\n  (letfn [\n          (inner [acc coll]\n            (cond\n              (nil? coll) acc\n              (or (seq? (first coll)) (vector? (first coll))) (recur (apply conj acc (inner [] (first coll))) (next coll))\n              :default (recur (conj acc (first coll)) (next coll))))]\n    (seq (inner [] coll-outer))))","user":"557c647ce4b05c286339e0c3"},{"code":"(fn flat-seq [x]\n  (if-not (coll? x)\n    [x]\n    (mapcat flat-seq x)))","problem":28,"user":"5160195ae4b0e2be8aa20be3"},{"problem":28,"code":"#((fn [lst accum]\n    (if (empty? lst) accum\n        (if (coll? (first lst))\n          (recur (concat (first lst) (rest lst)) accum)\n          (recur (rest lst) (conj accum  (first lst))))))\n   % [])","user":"58ef0b8ce4b056aecfd47dbf"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (cond (nil? x)  '()\n        (sequential? x) (concat (flat x) (flat xs))\n        :else (conj (flat xs) x)))","user":"60654263e4b069485764ddc9"},{"problem":28,"code":"(fn flatten*\n  [coll]\n  (loop [ret []\n         [x & xs] coll]\n    (if x\n      (if (sequential? x)\n        (recur (into ret (flatten* x)) xs)\n        (recur (conj ret x) xs))\n      ret)))","user":"590b8607e4b047aa04b199db"},{"problem":28,"code":"(fn fltn [x] (if (sequential? x)\n               (mapcat fltn x)\n               (list x)\n               ))","user":"59967c40e4b0b211ea3aaaf2"},{"code":"(fn f [s]\n\t(if (coll? s)\n\t\t(if (empty? s) () (concat (f (first s))(f (rest s))))\n      \t(list s)))","problem":28,"user":"530e5469e4b08068f379ecb7"},{"problem":28,"code":"(fn flat-map [coll]\n  (if (coll? coll)\n    (mapcat flat-map coll)\n    [coll]))","user":"5b199fd4e4b03cfeda66ecbd"},{"code":"(fn superconcat [& ls]\n  (reduce\n    (fn [acc x]\n      (concat acc\n        (if (sequential? x)\n          (apply superconcat x)\n          [x]\n        )\n      )\n    )\n    []\n    ls\n  )\n)","problem":28,"user":"4ea57300535d7eef308072d5"},{"code":"(fn [x]\n   ((fn [se nse]\n      (if (not (empty? se))\n        (let [cu (first se) re (rest se)]\n          (if (not (sequential? cu))\n            (recur re (concat nse (list cu)))\n            (recur (concat cu re) nse)))\n        nse)) x '()))","problem":28,"user":"4fbe42b7e4b081705acca30f"},{"code":"(fn [x]\n  (loop [l x r '()]\n    (if-not (empty? l)\n    (if-not (sequential? (last l))\n      (recur (drop-last l) (conj r (last l)))\n      (recur (concat (drop-last l) (last l)) r ))\n    r)))","problem":28,"user":"5152020de4b03e678e393ae7"},{"problem":28,"code":"(fn *my-flatten [x]\n  (if (coll? x)\n    (mapcat *my-flatten x)\n    [x]))","user":"5b602a66e4b0c6492753e6fc"},{"problem":28,"code":"(fn flat\n  ([item] (flat [] item))\n  ([list item]\n    (if (sequential? item)\n      (reduce\n        (fn [acc cur] (flat acc cur))\n        list\n        item\n      )\n      (conj list item)\n    )  \n  )\n)","user":"5d2564d2e4b02ea6f0fb6a34"},{"code":"(fn [l] (filter #(not (sequential? %))\n(tree-seq sequential?\n          identity l)))","problem":28,"user":"5084cb7de4b0fb8f40674bfb"},{"problem":28,"code":"(fn myflat [[fs & rs]]\n      (if (sequential? fs)\n           (myflat (concat (myflat fs) rs)\n            )\n           (if (nil? fs) '()\n             (concat (list fs) (myflat rs))\n            ) \n      ))","user":"56f070fee4b04a395b9a0478"},{"problem":28,"code":"(fn blah [coll]\n  (reduce (fn [acc item]\n            (if (coll? item)\n              (into acc (blah item))\n              (conj acc item)))\n          []\n          coll))","user":"55f48d1be4b06e875b46ce7b"},{"code":"(fn my-flatten [coll]\n  (loop [final-coll '()\n         rest-members coll]\n    (if (= '() rest-members)\n      final-coll\n      (recur (let [head (first rest-members)]\n               (if (sequential? head)\n                 (concat final-coll\n                         (my-flatten head))\n                 (concat final-coll\n                         (list head))))\n             (rest rest-members)))))","problem":28,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn ff [col] (if (coll? col) (apply concat (map ff col)) (list col)))","problem":28,"user":"4fc4eadee4b081705acca353"},{"code":"(fn [xs] (letfn\n           [(my-flatten [x] (let\n                              [y (first x)\n                               z (rest x)]\n                              (if (empty? x)\n                                x\n                                (if (coll? y)\n                                  (concat (my-flatten y) (my-flatten z))\n                                  (cons y (my-flatten z))))))]\n           (my-flatten xs)))","problem":28,"user":"51307b84e4b08c712d3fae39"},{"code":"(fn deflate [s]\n  (loop [s s r '()]\n    (if\n      (empty? s)\n      r\n      (if\n        (coll? (first s))\n        (recur (rest s) (concat r (deflate (first s))))\n        (recur (rest s) (concat r (list (first s))))))))","problem":28,"user":"4e3ac1b2535deb9a81d77f4c"},{"problem":28,"code":"(fn f [x]\n  (if (every? #(not (coll? %)) x )\n    x\n    (f (reduce (fn [a n] (if (coll? n) (concat a n) (concat a [n]))) () x))))","user":"58c3af4de4b021aa9917ed1b"},{"code":"(fn [x] (let  [flat (reduce into(cons [](map (fn [y] (if (coll? y) y (vector y))) x)))\n              flat? (if (= (count flat) 1) (not (coll? (first flat))) (reduce (fn [y z] (and (not(coll? y))(not(coll? z)))) flat))]\n              (if flat? (if (seq? x) (seq flat) flat) (recur flat))))","problem":28,"user":"505a0a15e4b03d2efce48c5a"},{"problem":28,"code":"(fn seq-flat\n  [seq]\n  (reduce (fn [c _]\n            (if (or (vector? _) (list? _))\n              (concat c (seq-flat _))\n              (concat c (list  _))))\n          '()\n          seq))","user":"562e2c5ce4b0a45d2ff83024"},{"problem":28,"code":"(fn myFlatten [x]\n  (if (coll? x)\n    (mapcat myFlatten x)\n    [x]))","user":"556c70dae4b09a3098a524fd"},{"problem":28,"code":"(fn my-flatten [coll]\n  (letfn [(expand-node [node]\n            (if (sequential? node)\n              (when (seq node)\n                (lazy-seq\n                  (cons\n                    node\n                    (mapcat expand-node node))))\n            (list node)))]\n    \n  (->> (expand-node coll)\n       (filter (complement sequential?)))))","user":"5776e21de4b0979f89651642"},{"code":"(fn fl [l]\n  (reduce (fn [ret this]\n    (if-not (coll? this)\n      (concat ret [this])\n      (concat ret (fl this)))) [] l))","problem":28,"user":"513cb853e4b0b86ece9f322b"},{"code":"(\n  fn flat[ x ](\n    if( coll? x ) ( mapcat flat x )  [x]\n  )\n)","problem":28,"user":"50bf7b72e4b0ffd967a66cc1"},{"code":"(fn myflatten [l]\n\t(if (sequential? l)\n    \t(if (= 0 (count l))\n        \t'()\n        \t(concat (myflatten (first l)) (myflatten (rest l)))\n    \t)\n    \t(seq [l])\n    )\n)","problem":28,"user":"5250af8be4b0541d1855b83c"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst)        ()\n    (list? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    (vector? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else               (cons (first lst) (my-flatten (rest lst)))))","user":"59e778aae4b0249b72820716"},{"problem":28,"code":"(fn flatten-2\n  [sequence]\n  (mapcat #(if (coll? %) (flatten-2 %) [%]) sequence))","user":"556c94afe4b09a3098a524fe"},{"problem":28,"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (cond\n      (empty? n) '()\n      (coll? x) (concat (flat x) (flat xs))\n      :else (cons x (flat xs)))))","user":"55885edae4b059ccff29b1f6"},{"code":"(fn rec [[x & xs :as l]] \r\n    (cond \r\n      (empty? l) l\r\n      (coll? x) (concat (rec x) (rec xs))\r\n      true (cons x (rec xs))))","problem":28,"user":"50588ff1e4b06522596eba7e"},{"problem":28,"code":"(fn [s]\n  (loop [_s s r []]\n    (if (empty? _s)\n      r\n      (if (sequential? (first _s))\n        (recur (concat (first _s) (rest _s)) r)\n        (recur (rest _s) (conj r (first _s)))\n        ))))","user":"598229d6e4b021a7a535fdfb"},{"code":"(fn flatten' [x]\r\n  (if (coll? x)\r\n    (apply list (mapcat flatten' x))\r\n    (list x)))","problem":28,"user":"509c03f3e4b085ae113522a8"},{"problem":28,"code":"(fn myflatten [x]\n  (if (coll? x)\n    (mapcat myflatten x)\n    [x]))","user":"5755e66ee4b02ea1147992cf"},{"problem":28,"code":"(fn my-flatten [coll]  \n  (reduce (fn flat [a b] \n    (if (sequential? b) \n      (reduce flat a b)\n      (conj a b))) \n  [] coll))","user":"5f012a2ee4b0cf489e8d7f1e"},{"problem":28,"code":"(fn r [c]\n    (cond\n        (and (coll? c) (empty? c)) nil\n        (coll? c) (concat (r (first c)) (r (rest c)))\n        :else (list c)))","user":"4e55b3dc535d8a8b8723a27f"},{"problem":28,"code":"(fn m-flatten [elm]\n  (if (sequential? elm) \n    (mapcat m-flatten elm)\n    `(~elm)))","user":"5cb556f9e4b026601754b934"},{"problem":28,"code":"(fn [input0] (loop [input input0] (let [output (reduce (fn [acc x] (if (sequential? x) (vec (concat acc x)) (conj acc x))) [] input)] (if (= input output) output (recur output)) ) ))","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn ! [l] \n  (if (sequential? l)\n    (reduce concat (map ! l))\n    [l]))","problem":28,"user":"4f1ef703535d64f60314649c"},{"code":"(fn f[x]\n  (let [y (first x) z (rest x)]\n    (cond\n     (empty? x) '()\n     (coll? y) (concat (f y) (f z))\n     :else (cons y (f z)))))","problem":28,"user":"52f818a6e4b047fd55836fcc"},{"code":"reduce (fn flat [acc col]\n         (if-not (coll? col)\n           (conj acc col)\n           (reduce flat acc col)))\n       []","problem":28,"user":"518ee4f9e4b0cd6ff51676a5"},{"code":"(fn flat [l] (if-not (sequential? l) [l] (apply concat (for [i l] (flat i)))))","problem":28,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":28,"code":"#(reverse (reduce (fn he [a b] (if (coll? b) (reduce he a b) (conj a b))) '() %))","user":"57da5fc4e4b0bd073c20240f"},{"code":"(fn myflat [l] \n  (if (coll? l) \n    (if (empty? l) \n      nil \n      (concat (myflat (first l)) (myflat (rest l))))\n    (list l)))","problem":28,"user":"4ee528fb535d1385b2869d87"},{"problem":28,"code":"(fn flat [col]\n\t(reduce #(if (sequential? %2) (into %1 (flat %2)) (conj %1 %2)) [] col))","user":"56df254be4b0ca2494a095ea"},{"problem":28,"code":"(fn flat [sq]\n  (if (sequential? sq)\n    (mapcat flat sq)\n    [sq]))","user":"5edd6eb7e4b0c7845d86b0f7"},{"code":"(fn [s]\n  (loop [s s res ()]\n    (if (empty? s)\n        (reverse res)\n        (recur (if (or (vector? (first s)) (list? (first s)))\n                   (concat (first s) (rest s))\n                   (rest s))\n               (if (or (vector? (first s)) (list? (first s)))\n                   res\n                   (conj res (first s)))))))","problem":28,"user":"502421ebe4b09f7ee7fb4377"},{"code":"(fn flat [lst] (cond \n                  (empty? lst) lst\n                  (not (coll? (first lst))) (cons (first lst) (flat (rest lst)))\n                  true (concat (flat (first lst)) (flat (rest lst)))) \n  )","problem":28,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn my-flatten [c]\r\n  (let [head (first c)\r\n        tail (rest c)]\r\n    (cond\r\n     (empty? c)   c\r\n     (coll? head) (concat (my-flatten head) \r\n\t\t\t                    (my-flatten tail))\r\n     :else (cons head (my-flatten tail)))))","problem":28,"user":"4e1047ad535d04ed9115e7bf"},{"code":"#(filter (complement coll?) (tree-seq coll? seq %))","problem":28,"user":"4e2b1d48535deb9a81d77f03"},{"problem":28,"code":"(fn flat\n      ([coll] (flat coll []))\n      ([coll result]\n       (if (empty? coll)\n         result\n         (let [first-elem (first coll)]\n           (if (coll? first-elem)\n             (recur (rest coll) (concat result (flat first-elem [])))\n             (recur (rest coll) (conj (vec result) first-elem))\n           ))\n       )))","user":"53ecd01fe4b0d648e757f4b9"},{"code":"(fn [l]\n  (filter (complement sequential?) \n          (tree-seq sequential? seq l)))","problem":28,"user":"4fea1f9ee4b0547ebccb248b"},{"code":"(fn flt [xs]\n  (let [h (first xs) t (rest xs)]\n    (concat\n      (if (sequential? h)\n        (flt h)\n        [h])\n      (when-not (empty? t)\n        (flt t)))))","problem":28,"user":"5063b9a0e4b075d771da6f9d"},{"code":"(fn f [s]\n  (nth\n    (iterate\n      #(reduce\n        (fn ! [a b] (if (coll? b)\n                      (into a b)\n                      (conj a b)))\n        [] %)\n      s)\n    3))","problem":28,"user":"4e8a460e535d65386fec2109"},{"problem":28,"code":"(fn my-flatten\n  \n  [lst]\n  (if (empty? lst)\n    lst\n    (if(or (list? (first lst)) (vector? (first lst)))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (cons (first lst) (my-flatten (rest lst))))))","user":"59e56c75e4b08badc2a0c556"},{"code":"(fn flatten'\n  [[x & xs]]\n  (if (sequential? x)\n    (if (seq xs)\n      (concat (flatten' x) (flatten' xs))\n      (flatten' x))\n    (if (seq xs)\n      (cons x (flatten' xs))\n      (list x))))\n\n\n; x = seq, xs = '() : return (flatten' x)\n; x = seq, xs = seq : return (concat (flatten' x) (flatten' xs))\n; x = value, xs = '() : return '(x)\n; x = value, xs = seq : return (cons x (flatten' xs))\n; otherwise: return '()","problem":28,"user":"5131104ae4b09e21d785bdfe"},{"problem":28,"code":"(fn flt [lst] (cond\n                   (empty? lst)\n                   ()\n                   \n                   (sequential? (first lst))\n                   (concat (flt (first lst)) (flt (rest lst)))\n                   \n                   (some sequential? (rest lst))\n                   (cons (first lst) (flt (rest lst)))\n                   \n                   :else\n                   lst\n                   \n                ))","user":"5f727d2fe4b02876ed9fd08f"},{"problem":28,"code":"(fn flat [coll] \n  (if (sequential? coll)\n    (mapcat flat coll) [coll]))","user":"5715b67fe4b07c98581c3ae1"},{"problem":28,"code":"(fn flt [l]\n  (if (sequential? l)\n    (mapcat flt l)\n    (list l)))","user":"5bd93897e4b0ed4b8aab4bee"},{"problem":28,"code":"(fn flatten-list [the-list]\n\t(loop [l the-list\n\t\tresult []]\n\t\t(if (empty? l)\n\t\t\tresult\n\t\t\t(let [head (first l)\n\t\t\t\ttail (rest l)]\n\t\t\t\t(if (sequential? head)\n\t\t\t\t\t(recur tail (concat result (flatten-list head)))\n\t\t\t\t\t(recur tail (concat result (list head))))))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn flat [x]\n  (if (empty? x)\n    []\n    (if (sequential? (first x))\n      (concat (flat (first x)) (flat (rest x)))\n      (cons (first x) (flat (rest x))))))","problem":28,"user":"516199bbe4b009fba0926e36"},{"problem":28,"code":"(fn flat [c] (filter (comp not coll?) (tree-seq coll? identity c)))","user":"562eeba2e4b0ab312c17ebc1"},{"problem":28,"code":"(fn my-flatten [xs] \n  (if (coll? xs)\n    (cond\n\t  (= (count xs) 0) '()\n\t  (> (count xs) 0) (concat (my-flatten (first xs)) (my-flatten (rest xs)))\n\t)\n\t[xs]\n  )\n)","user":"5d4c83b7e4b0776584bd6f34"},{"problem":28,"code":"(fn fl [x] (reduce #(if (coll? %2) (into %1 (fl %2)) (conj %1 %2)) [] x))","user":"5651de3ee4b0f9d632dd845b"},{"problem":28,"code":"#(read-string\n\n  (clojure.string/join\n\n    (concat '(\\()\n\n      (apply list\n\n        (filter (fn [a] (not(or (= \\( a)(= \\) a)(= \\[ a)(= \\] a))))\n\n          (seq (str %))))\n\n      '(\\)))))","user":"586b6a0ae4b01531a375e957"},{"code":"(fn flttn [coll]\n  (if (or (seq? coll) (vector? coll))\n    (if (empty? coll)\n      '()\n      (concat (flttn (first coll)) (flttn (rest coll)) ))\n    (list coll)))","problem":28,"user":"4f725466e4b07046d9f4f030"},{"code":"(fn m-flatten [items]\n  (if (coll? items)\n    (mapcat m-flatten items)\n    [items]))","problem":28,"user":"4f81fcbfe4b033992c121c03"},{"problem":28,"code":";#(filter (complement sequential?)\n;          (rest (tree-seq sequential? seq %)))\n\n(fn f [s]\n  (if-not (sequential? s) s)\n  \n  (loop [res [] curr (first s) base (rest s)]\n        \n      (let [empseqcur? (and (sequential? curr) (empty? curr))\n            notempseqcur? (and (sequential? curr) (not (empty? curr)))]\n          \n        (if (and empseqcur? (empty? base)) res \n          \n        (if (and (not (sequential? curr)) (empty? base))\n            (conj res curr)\n          \n        (recur (if empseqcur? res (if (sequential? curr) res (conj res curr)))\n               (if notempseqcur? (first curr) (first base))\n               (if notempseqcur? (conj base (rest curr)) (rest base))))))))","user":"56483f45e4b0284900eef62b"},{"problem":28,"code":"#(->> % (tree-seq sequential? seq) (remove sequential?))","user":"58b31a46e4b0ebc645576d1b"},{"code":"(fn f [x]\n  (if (coll? x)\n      (if (empty? x)\n          '()\n          (concat (f (first x)) (f (rest x))))\n      (list x)))","problem":28,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":28,"code":"(fn flat [l]\n  (reverse\n  \t((fn flat-rev [l]\n   \t\t(reduce \n         #(if (sequential? %2) (concat (flat-rev %2) %1) (conj %1 %2))\n         () l)) l)))","user":"594ce8e5e4b07ddc2dafae76"},{"code":"(fn [s]\n  (loop [a (first s) b (rest s) c []]\n    (if (empty? b)\n      (if (coll? a)\n        (recur (first a) (rest a) c)\n        (conj c a))\n      (if (coll? a)\n        (recur (first a) (concat (rest a) b) c)\n        (recur (first b) (rest b) (conj c a))))))","problem":28,"user":"4fdbc075e4b05e33b9224f61"},{"code":"#(letfn\n   [(f [x] (if (coll? x)\n             (if (empty? x)\n               nil\n               (concat (f (first x))\n                       (f (rest x))))\n             (list x)))]\n   (f %))","problem":28,"user":"515ead6be4b049add99a053e"},{"problem":28,"code":"(fn makeitflat [input]\n  (loop [in input, out [] ]\t;binds values each time called, initially out is empty\n    (if (empty? in)\n\tout\t;when empty, return out\n\t; not empty, so call it again\n\t(recur \n\t   ; new input\n\t   (rest in)\n\t   ; pass in current output\n           (let [f (first in), b (sequential? f) ] \n\t      (if b \n\t\t(concat out (makeitflat f))\n\t\t(concat out [f])\n\t\t;(conj out f)\n\t      )\n           ) \n\t)\n    )\n  )\n)","user":"571aae1fe4b07c98581c3b5a"},{"problem":28,"code":"(fn fl [coll]\n  (reduce (fn [l e]\n            (cond \n             (coll? e) (vec (concat l (fl e)))\n             :else (conj l e)))\n          [] coll))","user":"54145050e4b01498b1a719ea"},{"code":"(fn flat [coll] \r\n  (let [f (first coll) r (next coll)] \r\n\t\t(concat \r\n\t\t\t(if (sequential? f) \r\n\t\t\t\t(flat f) \r\n\t\t\t\t[f])\r\n\t\t\t(when (sequential? r) \r\n\t\t\t\t(flat r)))))","problem":28,"user":"5006474ce4b0678c553fc481"},{"code":"(fn flattr [col]\n  (letfn [(flattr2 [col result]\n            (if (empty? col)\n              result\n              (let [current (first col)]\n                (concat result\n                        (if (coll? current)\n                          (flattr current)\n                          (list current))\n                        (flattr2 (rest col) result)))))]\n    (flattr2 col '())))","problem":28,"user":"4ea01955535d7eef3080729f"},{"problem":28,"code":"(fn flat [seq]\n       (if (not-any? coll? seq)\n         seq\n         (apply concat (map \n                        (fn [x]\n                          (if-not (coll? x)\n                            (list x)\n                            (flat x)\n                            ))\n                        seq))))","user":"5a813b90e4b00b71e582a065"},{"code":"(fn f [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (f (first s)) (f (rest s)))\n        (cons (first s) (f (rest s)))))))","problem":28,"user":"51cc5cb3e4b02254fc79486f"},{"code":"(fn f [a] (reduce concat (map #(if (coll? %) (f (seq %)) (list %)) a)))","problem":28,"user":"519ca227e4b0a1d87b003460"},{"problem":28,"code":"(fn f [[h & t]]\n  (cond\n   (nil? h) ()\n   (sequential? h) (concat (f h) (f t))\n   :else (cons h (f t))))","user":"5cdc08a2e4b05ee0cb31173a"},{"problem":28,"code":"(fn fltn [sq] (loop [unflat sq]\n                  (if (some coll? unflat)\n                    (recur (mapcat (fn [el] (if (coll? el)\n                                              el\n                                              (list el)) )  unflat))\n                    unflat)))","user":"561814bae4b06b1bb2182a1a"},{"code":"(fn flat [col]\n  (let [a (first col) b (next col)]\n    (concat\n      (if (sequential? a)\n        (flat a)\n        [a]\n        )\n      (if (sequential? b)\n        (flat b)\n        )\n  ) \n  )\n  )","problem":28,"user":"53886d2fe4b0640c7a9a589d"},{"problem":28,"code":"(fn fltten\n  ([coll] (fltten coll '()))\n  ([coll acc]\n   (println coll acc)\n  (if (empty? coll)\n    (reverse acc)\n    (let [e (first coll)]\n      (println \"E \" e)\n      (if-not (coll? e)\n      \t(fltten (rest coll) (cons e acc))\n        (concat (fltten e acc) (fltten (rest coll) '())))))))","user":"53cb321fe4b00fb29b2212d1"},{"problem":28,"code":"(fn flat [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x) )))","user":"53b12c76e4b047364c04448a"},{"code":"(fn flat [l]\n  (cond\n    (nil? (first l)) '()\n    (coll? (first l)) (concat (flat (first l)) (flat (rest l)))\n    :else (concat (list (first l)) (flat (rest l)))))","problem":28,"user":"4e9e12b2535dbda64a6f6b92"},{"code":"#(let [x (re-seq #\"[:a-z1-9]+\" (apply str %))]\n          (if (= 3 (count x)) x (map read-string x)))","problem":28,"user":"51f2b8f1e4b0210f90e74556"},{"problem":28,"code":"(fn flat [xs]\n  (mapcat #(if (coll? %) (flat %) [%]) xs))","user":"58dde189e4b0a4d5acaab6dd"},{"problem":28,"code":"(fn my-flatten\n  ([s] (my-flatten s '()))\n  ([s f]\n   (if (empty? s)\n     f\n     (if-not (coll? (first s))\n       (conj (my-flatten (rest s)) (first s))\n       (into (my-flatten (rest s)) (reverse (my-flatten (first s))))))))","user":"572db6d5e4b0cd1946bd0f78"},{"problem":28,"code":";#(filter (complement sequential?) (tree-seq sequential? identity %))\n \n;#(filter (complement sequential?) (tree-seq sequential? seq %))\n\n;(fn[x] (filter #(if (sequential? %) false true) (tree-seq sequential? seq x)))\n\n;(fn[x] (filter #(not (sequential? %)) (rest(tree-seq sequential? seq x))))\n\n;#(remove sequential? (tree-seq sequential? identity %))\n\n#(remove coll? (tree-seq coll? identity %))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":28,"code":"(fn rekt [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"58622733e4b0f14aab7c8803"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (apply concat (map my-flatten x))\n    [x]))\n\n;#( (fn unwrap [x]\n;  (loop [remaining x\n;         result []]\n;    (if (empty? remaining)\n;      result\n;      (if (coll? (first remaining))\n;        (recur\n;          (rest remaining)\n;          (into result (unwrap (first remaining))))\n;        (recur\n;          (rest remaining)\n;          (conj result (first remaining))))))) %)","user":"57b99d48e4b0fbc9809a27f2"},{"problem":28,"code":"(fn f\n  [col]\n  (if (empty? col)\n    '()\n  \t(if (sequential? (first col))\n      (concat (f (first col)) (f (rest col)))\n   \t  (conj (f (rest col)) (first col))\n   \t)\n  )\n)","user":"58745926e4b01531a375ea50"},{"problem":28,"code":"(fn myFlatten [seq]\n  (cond (not (coll? seq)) (list seq)\n         :else (mapcat myFlatten seq)))","user":"5ee75f8be4b029a2061bbea5"},{"problem":28,"code":"(fn flatseq [s]\n   (if (sequential? s)\n     (mapcat flatseq s)\n     (list s)))","user":"5474df6ee4b0c51c1f4d7290"},{"code":"(fn test-flatten [l]\n    (cond\n     (not (coll? l)) (list l)\n     (empty? l) '()\n     :else (loop [f (first l)\n                  r (rest l)\n                  acc []]\n             (if (not (nil? f))\n               (recur (first r) (rest r) (concat acc (test-flatten f)))\n               acc))))","problem":28,"user":"52d7f9a8e4b09f7907dd1381"},{"problem":28,"code":"(fn q28 [tree]\n  (let [xs (tree-seq sequential? seq tree)]\n    (filter #(not (sequential? %)) (rest xs))))","user":"5cab0ad9e4b048ec896c5c46"},{"code":"(fn [s]\n  (letfn [(flats [x]\n    (lazy-seq\n      (when-let [h (first x)]\n        (if (coll? h)\n            (concat (flats h) (flats (rest x)))\n            (cons h (flats (rest x)))))))]\n      (flats s)))","problem":28,"user":"4f4d7b8fe4b03ad3f0c10ca9"},{"problem":28,"code":"(fn elements [x] \n   (if (empty? x) \n     x\n     (apply conj\n            (elements (rest x))\n            (if (coll? (first x))\n              (reverse (elements (first x)))\n              (list (first x))))))","user":"5ddd6cfae4b0948ae9d9adc4"},{"problem":28,"code":"(fn flat\n  [s]\n  (when (seq s)\n    (if (coll? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","user":"5576fee3e4b05c286339e078"},{"problem":28,"code":"(fn flat [c]\n  (if (coll? c)\n    (apply concat (map flat c))\n    (list c)))","user":"54487527e4b032a45b8693cc"},{"code":"#(filter (complement sequential?)\n         (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e72ac47535d5021c1a89666"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst) ()\n    (coll? (first lst))\n           (concat (my-flatten (first lst)) (my-flatten(rest lst)))\n           :else (cons (first lst) (my-flatten (rest lst)))))","user":"5723e6d6e4b0c5bde472c0f1"},{"problem":28,"code":"(fn [l] (filter (complement sequential?) \n          (rest (tree-seq sequential? seq l))))","user":"53771d98e4b06839e8705e2e"},{"code":"(fn flat [coll]\n  (if (empty? coll) coll\n    (let [x  (first coll)\n          xs (rest coll)]\n      (if (sequential? x)\n        (concat (flat x) (flat xs))\n        (cons x (flat xs))))))","problem":28,"user":"504e24e2e4b0f6ff3350c46d"},{"code":"(fn [s]\n  (if ((fn [s]\n         (loop [s s]\n           (if (empty? s)\n             true\n             (if (coll? (first s))\n               false\n               (recur (rest s))))))\n       s)\n    s\n    (recur (reduce #(concat %1 (if (coll? %2) %2 (list %2))) '() s))))","problem":28,"user":"52fac708e4b047fd55836fff"},{"code":"(fn [x] \n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f038bcd535dcb61093f6b1d"},{"problem":28,"code":"(fn fltn [l]\n  (reduce #(cond \n            (sequential? %2) (concat %1 (fltn %2))\n            :else (conj (vec %1) %2)\n                 ) [] l)\n  )","user":"55496eeae4b0a04f79299569"},{"code":"(fn F [a l]\n  (if (coll? l)\n    (let [[h & t] l]\n      (F (into a\n               (if (coll? h)\n                 (F [] h)\n                 [h]))\n         t))\n    a)) []","problem":28,"user":"4ee82539535d93acb0a66878"},{"problem":28,"code":";;(fn [orig-seq]\n;;\t(filter\n;;\t\t(complement sequential?)\n;;\t\t(rest (tree-seq sequential? seq orig-seq))\n;;\t)\n;;)\n\n\n\n(fn flattenizer [x]\n\t;; check if x is a collection\n  \t(if (coll? x)\n    \t;; then\n   \t\t(mapcat flattenizer x)      \n    \t;; else\n      \t[x]\n\t)\n)","user":"5595c60ee4b0c79f6e1db96f"},{"problem":28,"code":"(fn flat[lst]\n  (if (empty? lst)\n    ()\n    (if (or (seq? (first lst)) (vector? (first lst)))\n      (concat (flat (first lst)) (flat (rest lst)))\n      (cons (first lst) (flat (rest lst))))))","user":"5bbbce70e4b0a20761a2360f"},{"problem":28,"code":"(fn [input]\n  (loop [list-to-flatten input\n         flattened-list []]\n    (if (empty? list-to-flatten)\n      flattened-list\n      (let [[item & rem] list-to-flatten\n            is-seq? (#(instance? clojure.lang.Sequential %) item)]\n        (if is-seq?\n          (recur (concat item rem) flattened-list)\n          (recur rem (conj flattened-list item)))))))","user":"54513516e4b0e397800069af"},{"problem":28,"code":"(fn flat [x]\n    (if (coll? x)\n      (mapcat flat x)\n      [x]))","user":"581a703de4b0e114eb51a005"},{"problem":28,"code":"(fn flat [s]\n     (if (sequential? s)\n       (mapcat flat s)\n       [s]\n       ))","user":"5ed6030de4b016b56eae05db"},{"problem":28,"code":"(fn myfunc\n   ([x] (myfunc x '()))\n   ([x, y]\n        (if (empty? x)\n          (reverse y)\n\n          (if (coll? (first x))\n            (if (empty? (first x))\n              (recur (rest x) y)\n              (recur (conj (rest x ) (rest (first x))  (first (first x)) ) y)\n              )\n            (recur (rest x) (conj y (first x)))\n            )\n\n          )\n     ))","user":"5a0a3473e4b0eab8c0448941"},{"problem":28,"code":"(fn [my-seq]\n    (reduce\n        (fn my-reduce [v c]\n            (if (coll? c)\n                (reduce my-reduce v c)\n                (conj v c)))\n        [] my-seq))","user":"5784ff88e4b0ebec4cfb74d4"},{"problem":28,"code":"reduce (fn unwrap [acc item] (if (coll? item) (reduce unwrap acc item) (concat acc [item]))) ()","user":"5ce56455e4b0a17bb84e2b71"},{"code":"(fn [x]\n  (let [a (atom x)]\n    (while (some coll? @a)\n      (let [nc (take-while (complement coll?) @a)\n            [c & r] (drop (count nc) @a)\n            m (concat nc c r)]\n        (reset! a m)))\n    @a))","problem":28,"user":"4f601623e4b0defedf855fa3"},{"code":"(fn fun [x] (mapcat #(if (coll? %) (fun %) [%]) x))","problem":28,"user":"4f88ae35e4b033992c121c6d"},{"problem":28,"code":"(fn f [coll] (if (coll? coll) (apply concat (for [x coll] (f x))) [coll]))","user":"55b64ef1e4b01b9910ae2994"},{"code":"(fn flat [s]\n  (if (empty? s)\n    s\n    (if (sequential? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","problem":28,"user":"4ff31e13e4b0678c553fc346"},{"problem":28,"code":"#(remove sequential? (tree-seq sequential? seq  %))","user":"55d85ac9e4b0e31453f64ab2"},{"code":"(fn mappy [x]\n  (if (coll? x) \n      (mapcat mappy x) \n      [x]))","problem":28,"user":"50458888e4b01f6c9a8b236d"},{"code":"(fn f [s] (mapcat #((if (sequential? %) f list) %) s))","problem":28,"user":"52be58d7e4b07a9af579231d"},{"problem":28,"code":"(fn myflatten [init x]\n  (reduce #(if (coll? %2) (myflatten %1 %2)\n               (conj %1 %2)) init x)) []","user":"589037b4e4b00487982d51d0"},{"code":"(fn self [[x & xs]]\n  (concat\n   (if (sequential? x) (self x) [x])\n   (when (sequential? xs) (self xs))))","problem":28,"user":"524b90fae4b09eba1c0223df"},{"code":"(fn [x]\n   (filter (complement sequential?)\n           (rest (tree-seq sequential? seq x))))","problem":28,"user":"53489329e4b084c2834f4a5b"},{"problem":28,"code":"(fn flat [x] (concat \n                (if (coll? (first x)) (flat (first x)) [(first x)]) \n                (when (coll? (next x)) (flat (next x)))))","user":"56c749d8e4b0ed865f9758ba"},{"problem":28,"code":"(fn [x]\n  (\n   \t(fn [arr y]\n      (let [[first & rest] y]\n        (println first rest)\n\t      (cond\n           (nil? first) arr\n           (coll? first) (recur arr (concat first rest))\n           :else (recur (conj (vec arr) first) rest)\n        )\n      )\n\n    ) [] x\n  )\n)","user":"564d936ee4b0284900eef681"},{"code":"(fn [coll]\n  (loop [remain coll acc []]\n    (if (empty? remain)\n      acc\n      (recur\n        (if (sequential? (first remain))\n          (concat (first remain) (rest remain))\n          (rest remain))\n        (if (sequential? (first remain))\n          acc\n          (conj acc (first remain)))))))","problem":28,"user":"50e3cf55e4b01912b3285c45"},{"problem":28,"code":"(fn my-flatten [s]\n   (loop [acc []\n          stack []\n          s s]\n     (if-let [f (first s)]\n       (if\n         (sequential? f) (recur acc (conj stack (rest s)) f)\n         (recur (conj acc f) stack (rest s)))\n       (if (empty? stack)\n         acc\n         (recur acc (pop stack) (last stack)))))\n   )","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn f [[x & xs]]\n  (concat\n   (if (sequential? x)\n     (f x)\n     [x])\n   (when (sequential? xs)\n     (f xs))))","problem":28,"user":"50cd0fd5e4b0f7a459302aad"},{"problem":28,"code":"(comp \n  (partial filter (fn[x] (not (or (vector? x) (list? x))))) \n  (partial tree-seq \n           (fn[x] \n             (or \n              (list? x) \n              (vector? x)\n              )\n             ) \n           identity\n           )\n  )","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":28,"code":"(fn definitely-not-flatten [x]\n   (reduce \n     (fn [acc v]\n       (if (sequential? v)\n         (into acc (definitely-not-flatten v))\n         (conj acc v)))\n     []\n     x))","user":"5fc4e1f0e4b036c570ed8145"},{"problem":28,"code":"(fn [l]\n  (mapcat (fn flat [x]\n            (if (coll? x)\n              (mapcat flat x)\n              [x]))l))","user":"59636b43e4b066ee0a44b0c4"},{"code":"(fn flt [l]\n  (let [x (first l), y (next l)] \n    (concat (if (coll? x) (flt x) [x])\n              (when (coll? y) (flt y))\n     \n     )))","problem":28,"user":"5099283ce4b0cae2931060af"},{"code":"(fn\n  [coll]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq coll))))","problem":28,"user":"525fffb8e4b03e8d9a4a702b"},{"problem":28,"code":"(fn foo [x] \n    (reduce \n      (fn [a b]\n        (if (or (vector? b) (list? b))\n          (apply conj a (foo b))\n          (conj a b)\n        )\n        ) [] x)\n    )","user":"528ce039e4b0239c8a67aebc"},{"problem":28,"code":"(fn [s] (reduce (fn myflatten [collection element]\n            (if (sequential? element)\n              (reduce myflatten collection element)\n              (conj collection element))) [] s))","user":"573b664ce4b0cd1946bd10a7"},{"code":"(fn flat [x]\n    (if (empty? x) '()\n    (if (coll? (first x)) (into (flat (rest x)) (reverse (flat (first x))))\n    (cons (first x) (flat (rest x))))))","problem":28,"user":"4f067029535dcb61093f6c12"},{"code":"(fn f\n  ([a & b] (concat (if (sequential? a)\n                     (apply f a)\n                     (list a))\n                   (apply f b)))\n  ([a] (if (sequential? a)\n         (apply f a)\n         (list a))))","problem":28,"user":"4ee67364535d93acb0a6685f"},{"code":"(fn f [s]\r\n  (reduce\r\n    (fn [a b]\r\n      (if (coll? b)\r\n        (into a (f b))\r\n\t\t    (conj a b)))\r\n\t []\r\n\t s))","problem":28,"user":"4e821ca5535db62dc21a62c2"},{"problem":28,"code":"(fn [col]\n  (->> col\n       (tree-seq sequential? identity)\n       (filter (complement sequential?))))","user":"56b965d9e4b0f26550335931"},{"code":"(fn deep-flatten [coll]\n  (loop [result [] col coll]\n    (cond\n      (not (seq col)) result\n      (or (seq? (first col)) (vector? (first col))) (recur (into result (deep-flatten (first col))) (rest col))\n      :else (recur (conj result (first col)) (rest col)))))","problem":28,"user":"52fb903ee4b047fd5583700b"},{"code":"(fn ! [x]\n  (cond \n   (empty? x) (list )\n   (coll? (first x)) (concat (! (first x)) (! (rest x)))\n   true (concat (list (first x)) (! (rest x)))))","problem":28,"user":"523361d8e4b0f0b72fabf405"},{"problem":28,"code":"(fn [xs]\n  (filter\n   (complement sequential?)\n   (rest (tree-seq sequential? seq xs))))","user":"526e1bd0e4b03e8d9a4a730b"},{"problem":28,"code":"(fn f\n   ([x] (f x []))\n   ([[x & rest] y]\n    (let [g #(if (coll? %1) (concat (vec %2) (f %1 [])) (conj (vec %2) %1))]\n      (if rest\n        (recur rest (g x y))\n        (apply list (g x y))))\n     )\n   )","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (let [[x & remaining] coll]\n    (cond \n      (empty? coll) nil\n      (coll? x) (concat (my-flatten x) (my-flatten remaining))\n      :else (cons x (my-flatten remaining)))))","user":"5f003099e4b0cf489e8d7f17"},{"code":"(fn T[V](if (or (vector? V)(seq? V))(if-not (empty? V)(do (concat (T (first V))(T (rest V))))())(list V)))","problem":28,"user":"536c77f1e4b0fc7073fd6e3f"},{"problem":28,"code":"(fn xflatten [s]\n  (if (empty? s)\n    []\n    (let [head (first s)\n          tail (rest s)]\n      (if (coll? head)\n        (concat (xflatten head) (xflatten tail))\n        (cons head (xflatten tail))\n        )\n      )\n    )\n  )","user":"564ecc9ee4b0284900eef6a1"},{"problem":28,"code":"(fn [input]\n    (reverse\n      (loop [seq input\n           out '()]\n      (println (str \"input: \" seq \", output: \" out))\n      (if (empty? seq)\n        out\n        (let [i (first seq)]\n          (if (coll? i)\n            (recur (reduce (fn [acc a] (cons a acc)) (rest seq) (reverse i)) out)\n            (recur (rest seq) (cons i out))))))))","user":"53c6c9dfe4b00fb29b2212a1"},{"problem":28,"code":"(fn [coll]\n  ((fn flatten-1\n      [coll acc]\n      (if (not-empty coll)\n        (let [elt (first coll)\n              r (rest coll)]\n          (if (sequential? elt)\n            (flatten-1 r  (flatten-1 elt acc))\n            (flatten-1 r  (conj  acc elt))))\n        acc)) coll []))","user":"54ccf9d5e4b057c6fda3a295"},{"problem":28,"code":"(fn f [coll]\n    (let [x  (first coll)\n          xs (rest  coll)]\n      (if x\n        (if (coll? x)\n          (concat (f x)\n                  (f xs))\n          (cons x\n                (f xs))))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":28,"code":"(fn [i] \n  (loop [i i r ()]\n    (if (empty? i) \n      r\n      (if (coll? (first i))\n        (recur (concat (first i) (rest i)) r)\n        (recur (rest i) (concat r [(first i)]) ) \n      )\n    )          \n  )\n)","user":"58186016e4b0c0e9c07b83ad"},{"problem":28,"code":"(fn myflatten [[x & xs]]\n  (if x\n    (if (coll? x)\n      (concat (myflatten x) (myflatten xs))\n      (cons x (myflatten xs))\n    )\n  )\n)","user":"54c5cc17e4b045293a27f624"},{"problem":28,"code":"(fn flat\n  [coll]\n  (reduce #(apply conj %1 (if (coll? %2) (flat %2) [%2])) [] coll))","user":"5609d328e4b05f002753deee"},{"problem":28,"code":"(fn makeflat\n  ([xs] (makeflat xs ()))\n  ([xs result]\n       (cond\n         (not (coll? xs)) (cons xs result)\n         (empty? xs) result\n         :else (concat\n                 (makeflat (first xs) result)\n                 (makeflat (rest xs) ())))))","user":"5a544eeee4b05d388ecb6c24"},{"code":"(fn myf [xs]\n  (if (coll? xs)\n      (mapcat myf (seq xs))\n      [xs]))","problem":28,"user":"4eca5391535d6d7199dd3704"},{"code":"(fn my-flatten [xs]\n  (cond\n    (not (coll? xs)) (list xs)\n    (empty? xs) '()\n    :else (concat (my-flatten (first xs)) (my-flatten (rest xs)))))","problem":28,"user":"500ff421e4b0ae202717946f"},{"code":"(fn [x]\n    ((fn _flat [in out]\n        (if (empty? in)\n            out \n            (let [f (first in)] \n                (if (coll? f)\n                    (_flat (rest in)\n                           (_flat f out))\n                    (_flat (rest in) \n                           (concat out (list f)))))))\n      x ()))","problem":28,"user":"4f047902535dcb61093f6bcc"},{"problem":28,"code":"(fn flattin\n  [s]\n  (reduce \n   (fn [p c]\n     (if (sequential? c)\n       (into p (flattin c))\n       (conj p c)\n       )\n     )\n   []\n   s\n   )\n  )","user":"57f55632e4b0903ccab3dcf1"},{"problem":28,"code":"(fn my-flatten [coll] (if (coll? coll) (mapcat my-flatten coll) (list coll)))","user":"5505ceb3e4b086ebe8a79c8b"},{"problem":28,"code":"(fn foo [s]\n(cond \n  (empty? s) '()\n  (sequential? (first s)) (concat (foo (first s)) (foo (rest s)))\n  :else (cons (first s) (foo (rest s)))\n)\n)","user":"5f1aade6e4b091ba50b4dbe4"},{"problem":28,"code":"(fn a\n  [[x & b]]\n    (when x\n      (concat\n       (if (coll? x)\n         (a x)\n         [x])\n       (a b))))","user":"53ea5851e4b036ad0777e4e4"},{"code":"(fn flat [l]\n    (reduce\n     (fn [acc each]\n   (concat\n    acc\n    (if (or (vector? each) (seq? each))\n\t      (flat each)\n\t    (list each))))\n\t '()\n\t l))","problem":28,"user":"4f1569bb535d64f603146441"},{"problem":28,"code":"(fn myflat [coll]\n  (if (sequential? coll)\n    (mapcat myflat coll)\n    (list coll)\n    )\n  )","user":"56b80ad1e4b0f26550335921"},{"problem":28,"code":"(fn flat [xs] (if (empty? xs)\n                ()\n                (if (coll? (first xs))\n                  (concat (flat (first xs)) (flat (rest xs)))\n                  (concat (list (first xs)) (flat (rest xs))))))","user":"53c051a5e4b0c98a41f5ccae"},{"problem":28,"code":"(fn fltten\n  [[fst & rst]]\n  (if (empty? rst) \n    (if (coll? fst) (fltten fst) (list fst)) \n    (if (coll? fst) (concat (fltten fst) (fltten rst)) (cons fst (fltten rst)))))","user":"5747e22ce4b009280f9f2b7c"},{"problem":28,"code":"(fn fltn\n\t([_seq]\n\t\t(fltn (first _seq) (rest _seq) '()))\n\t([_first _rest result]\n\t\t(if (nil? _first)\n\t\t\tresult\n\t\t\t(if (coll? _first)\n\t\t\t\t(fltn (first _first) (concat (rest _first) _rest) result)\n\t\t\t\t(fltn (first _rest) (rest _rest) (reverse (conj (reverse result) _first)))))))","user":"5954eef0e4b066ee0a44af17"},{"problem":28,"code":"(fn [seq-in]\n  (loop [s seq-in]\n    (if (some coll? s)\n      (recur (apply concat\n                    (for [x s]\n                      (cond\n                        (coll? x) (vec x)\n                        :else [x]))))\n      s)))","user":"5b14475be4b0cc2b61a3be5a"},{"code":";; Note -- This seems way more complicated than necessary...\r\n    (fn [s]\r\n\t\t (loop [s (seq s)\r\n\t\t\t\t  res '()]\r\n\t\t\t(if (seq s)\r\n\t\t\t  (if (coll? (first s))\r\n\t\t\t\t (recur (loop [subseq (reverse (first s))\r\n\t\t\t\t\t\t\t\t\tr (rest s)]\r\n\t\t\t\t\t\t\t (if (seq subseq)\r\n\t\t\t\t\t\t\t\t(recur (rest subseq) (conj r (first subseq)))\r\n\t\t\t\t\t\t\t\tr))\r\n\t\t\t\t\t\t  res)\r\n\t\t\t\t (recur (rest s) (concat res `(~(first s)))))\r\n\t\t\t  res)))","problem":28,"user":"4e08fb7a535d04ed9115e7ac"},{"problem":28,"code":"(fn [input]\n   (loop [[x & xs :as all] input \n          ys []]\n     (if (not (empty? all)) \n       (if (or (seq? x) (vector? x))\n           (recur (concat x xs) ys)\n           (recur xs (conj ys x))) \n       ys)))","user":"4ff9ea75e4b0678c553fc3b3"},{"code":"(fn flattener [l] (cond (nil? l) l (coll? l) (if (empty? l) l (concat (flattener (first l)) (flattener (rest l)))) true (list l)))","problem":28,"user":"527ba695e4b03e8d9a4a7596"},{"problem":28,"code":"(fn my-flatten [lst]\n  (cond\n    (empty? lst) '()\n    (sequential? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (cons (first lst) (my-flatten (rest lst)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":28,"code":"(fn flatter [entry] \n  (when(not= (count entry) 0)\n    (if(sequential? (first entry))\n      (do\n        (concat (flatter (first entry)) (flatter (rest entry)))\n      )\n      (do\n        (conj  (flatter (rest entry)) (first entry))\n      )\n    )\n  )\n)","user":"53f12b77e4b0742d9025b0da"},{"code":"(fn [x]\n        (loop [x x\n               acc []]\n          (if (empty? x)\n             (reverse acc)\n             (if (sequential? (first x))\n               (recur \n                (concat \n                 [(first (first x))] (rest (first x)) (rest x)) acc)\n                (recur (rest x) (concat [(first x)] acc))))))","problem":28,"user":"4fe72924e4b0e8f79898fedb"},{"code":"(fn flat [col]\n  (loop [c col result []]\n\t(let [[first* & rest*] c]\n\n\t\t(if (empty? c)\n\t\t\t(if (some coll? result)\n\t\t \t (recur result [])\n\t\t \t result)\n\t\t  (if (coll? first*)\n\t\t   (recur rest* (apply conj result first*))\n\t\t   (recur rest* (conj result first*)))))))","problem":28,"user":"5054e37fe4b0b1b9d1860eb6"},{"problem":28,"code":"(fn dorec [s] (cond (sequential? s) (apply concat (map dorec s)) :else (cons s nil)))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn flt [c]\n  (loop [c c, r '()]\n    (cond\n     (not (coll? c)) (concat r [c])\n     (empty? c) r\n     (not (coll? (first c))) (recur (rest c) (concat r [(first c)]))\n     :else (recur (rest c) (concat r (flt (first c))))\n)))","problem":28,"user":"53597288e4b04ce2eb3ed29c"},{"problem":28,"code":"(fn fl [e] (if (sequential? e) (mapcat fl e) [e]))","user":"5a624129e4b0512ff01cd987"},{"problem":28,"code":"(fn [l] (letfn [(f\n  [a b]\n  (if (sequential? b) \n     (concat a (reduce f [] b))  \n     (conj (vec a) b)  \n  ))]\n(reduce f [] l)))","user":"53e76728e4b036ad0777e47c"},{"code":"(fn [x] (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4db6e850535d1e037afb2182"},{"problem":28,"code":"#(read-string (str \"(\" (clojure.string/replace  (str %) #\"[\\(\\)\\[\\]]\" \"\") \")\"))","user":"5885cc62e4b0f1effa3b76c1"},{"problem":28,"code":"(fn [s]\n  (\n   (fn flt [to_flatten flattened]\n     (if (empty? to_flatten)\n       flattened\n       (if (coll? (first to_flatten))\n         (flt (rest to_flatten) (flt (first to_flatten) flattened))\n         (flt (rest to_flatten) (conj flattened (first to_flatten))))))\n   s []))","user":"5c7ef3f3e4b0d597f478cad7"},{"code":"(fn ft [c] (let [a (first c) r (rest c)]\n  (when-not (nil? a)\n    (if (sequential? a) \n      (concat (ft a) (ft r)) \n      (cons a (ft r)))\n    )\n  )\n)","problem":28,"user":"50921f9ae4b09a7d0b586de1"},{"problem":28,"code":"(fn pancake \n  ([f r sofar]\n    (println \"f: \" f \" r: \" r \" sofar: \" sofar)\n    (if (sequential? f)\n      (if (empty? f)\n        (if (empty? r)\n          sofar ; nothing left - we are done\n          (recur (first r) (rest r) sofar)) ; f is empty seq\n        (recur (first f) (conj r (rest f)) sofar)) ; f is non-empty seq\n    (if (empty? r)\n      (conj sofar f) ; f is not seq and no more remain\n      (recur (first r) (rest r) (conj sofar f))))) ; f is not seq\n([s]\n  (pancake '() s [])))","user":"5632365ce4b0bfe05bf1179d"},{"problem":28,"code":";; (fn f [x] (if (coll? x) (mapcat f x) [x]))\n\n(fn f [x] (mapcat #(if (coll? %) (f %) [%]) x))","user":"559b2ad1e4b066d22e731f4e"},{"problem":28,"code":"(fn [s]\n  (filter (complement coll?) (tree-seq sequential? seq s)))","user":"58fff18be4b0438e51c2d00c"},{"code":"#(let [s coll?]\r\n  (filter (complement s)\r\n          (rest (tree-seq s seq %))))","problem":28,"user":"4e03c616535d04ed9115e796"},{"problem":28,"code":"(fn my-flatten [xs] (letfn [(f [fcoll e] (if (sequential? e) (reduce f fcoll e) (cons e fcoll)))] (reverse (reduce f '() xs))))","user":"54cd651be4b057c6fda3a2a2"},{"problem":28,"code":"#(letfn [(flt [coll rez]\n          (if (seq coll)\n              (let [f (first coll)]\n                   (if (coll? f)\n                       (flt (next coll) (into rez (flt f [])))\n                       (flt (next coll) (conj rez f))))\n              rez))]\n  (flt %1 []))","user":"563a79e5e4b0bfe05bf117fe"},{"problem":28,"code":"(fn flat [s] \n  (reduce #(concat %1 (if (sequential? %2) (flat %2) [%2])) [] s))","user":"54c11fdae4b0ed20f4ff6f1b"},{"problem":28,"code":"(fn flt [coll]\n   (if (sequential? coll) (apply concat (map flt coll))\n                       [coll]))","user":"5454bb07e4b0e397800069da"},{"code":"(fn flat [s]\r\n  (cond (empty? s) nil\r\n        (coll? (first s)) (concat (flat (first s)) (list* (flat (rest s))))\r\n        :else (cons (first s) (list* (flat (rest s))))))","problem":28,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":28,"code":"#((fn flat [x]\n  (reduce concat \n    (map (fn [y] (if (coll? y) (flat y) [y])) x))) %)","user":"5884e807e4b0f1effa3b76a6"},{"problem":28,"code":"(fn my_flatten [L]\n  (loop [xs L, result []]\n    (if (empty? xs)\n      result\n      (let [x (first xs), \n            y (if (coll? x) (my_flatten x) [x])]\n        (recur (rest xs) (apply conj result y))))))","user":"57015a1de4b08d47c97781d4"},{"problem":28,"code":"(fn f [xs] (mapcat #(if (sequential? %) (f %) [%]) xs))","user":"583e27e2e4b089d5ab817daa"},{"problem":28,"code":"(fn [x]\n          (loop [in x out '[]]\n            (if (empty? in)\n              out\n              (let [head (first in) tail (rest in)]\n                (if (coll? head)\n                  (recur (concat head tail) out)\n                  (recur tail (conj out head) ))))))","user":"58b997afe4b0888cdc949cd1"},{"code":"#(loop [head % tail (vector) dodane (vector)]\r\n  \t(if (= (count head) 0)\r\n\t\t\tdodane\r\n\t\t\t(if (coll? (first head))\r\n\t\t\t\t(recur (first head) (concat  (rest head) tail) dodane)\r\n\t\t\t\t(recur  (concat  (rest head) tail) (vector) (conj dodane (first head)))\r\n\t\t\t)\r\n\t\t)\r\n\t)","problem":28,"user":"4f00c74f535dcb61093f6a31"},{"problem":28,"code":"(fn n [[f & r]]\n  (concat ((if (coll? f) n list) f) (if r (n r))))","user":"56baa68ce4b0f26550335947"},{"problem":28,"code":"(fn f [c] (let [r (reduce #(if (coll? %2) (concat %1 %2) (conj %1 %2)) '() c)] (if (some coll? r) (f r) (sort r))))","user":"53d5a63be4b0e771c3025449"},{"problem":28,"code":";(fn flat [x] (if (coll? x) (apply concat (map flat x)) (list x)))\n(fn flat [x] (if (coll? x) (mapcat flat x) [x]))","user":"5d98f616e4b0d3f9b434ad3c"},{"problem":28,"code":"(fn ite [ec c] \n  (reduce #(if-not (sequential? %2) (conj %1 %2) (ite %1 %2)) ec c)\n  ) []","user":"5cf9623de4b0b71b1d808a95"},{"problem":28,"code":"(fn flt [l]\n  (let [h (first l)\n        t (rest l)]\n    (concat \n      (if (not (sequential? h))\n          `(~h)\n          (flt h))\n      (if (empty? t)\n          t\n          (flt t)))))","user":"55c49394e4b0e31453f6499e"},{"problem":28,"code":"(fn foo [s]\n\t\t (if (and (coll? s) (empty? s))\n\t\t     nil\n\t\t   (if (coll? (first s))\n\t\t       (concat (foo (first s)) (foo (rest s)))\n\t\t     (cons (first s) (foo (rest s))))))","user":"508f4343e4b0ea685a20f767"},{"code":";;into is convenience ... apply conj\n(fn flat [coll]\n   (if (sequential? coll)\n      (reduce (fn [acc elem] (apply conj acc (flat elem))) [] coll)\n\t  (list coll)\n     )\n  )","problem":28,"user":"5307e4ece4b02e82168697a9"},{"problem":28,"code":"(fn cflatten [y]\n   (if (coll? y)\n     (mapcat cflatten y)\n     (list y)))","user":"5e7b1ef4e4b085ba37836e10"},{"code":"(fn flatter [coll]\n(cond \n (empty? coll) '()\n (coll? (first coll)) (concat (flatter (first coll)) (flatter (rest coll)))\n  :else (cons  (first coll) (flatter (rest coll)))))","problem":28,"user":"52dced9de4b09f7907dd13d7"},{"code":"(fn flat\n  [lst]\n  (let [l (first lst)\n        r (next lst)]\n    (concat\n      (if (sequential? l)\n        (flat l)\n        [l] \n        )   \n      (when (sequential? r)\n        (flat r)\n        )   \n      )   \n    )   \n  )","problem":28,"user":"5228f870e4b0186687e23a98"},{"problem":28,"code":"(fn my-flat [[f & r]]\n  (if (nil? f) \n    '()\n    (if (coll? f)\n      (concat (my-flat f) (my-flat r))\n      (cons f (my-flat r)))))","user":"54f773bfe4b01ecee9d8881f"},{"problem":28,"code":"(fn new-flatten [x]\n  (if (not (or (seq? x) (vector? x)))\n    [x]\n    (mapcat new-flatten x)))","user":"53cb30f0e4b00fb29b2212d0"},{"problem":28,"code":"(fn my-flatten\n    [sq]\n    (assert (coll? sq))\n    (reduce (fn [so-far item]\n              (if (coll? item)\n                ;(vec (concat so-far (my-flatten item)))\n                (into so-far (my-flatten item))\n                (conj so-far item)\n                )\n              )\n            []\n            sq\n            )     \n    )","user":"571a282ae4b07c98581c3b46"},{"code":"#(filter (complement sequential?)\n  (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e21c0c7535d04ed9115e818"},{"problem":28,"code":"(fn fl [coll]\n    (mapcat #(if (sequential? %1) (fl %1) [%1]) coll))","user":"5bc488bde4b07a9b28b10053"},{"code":"(fn f [c] (if (sequential? c) (reduce concat (map f c)) (list c)))","problem":28,"user":"4f02fdc9535dcb61093f6a42"},{"code":"(fn enflatten\n   ([[x & xs :as all]] \n    (if (coll? x) \n        (concat (enflatten x) (enflatten xs))\n      (if (nil? xs) all\n      (conj (enflatten xs) x)))))","problem":28,"user":"4fe8d862e4b0547ebccb2428"},{"code":"(fn [s]\n  (loop [d '[] s (seq s)]\n    (cond\n      (empty? s) d\n      (coll? (first s)) (recur d (concat (first s) (rest s)))\n      :else (recur (conj d (first s)) (seq (rest s))))))","problem":28,"user":"50657775e4b0deb876850599"},{"problem":28,"code":"(fn flt [x]\n  (if (nil? x)\n    ()\n    (if (not (coll? x))\n      (list x)\n      (if (empty? x)\n        ()\n        (concat (flt (first x)) (flt (rest x))) ))))","user":"550e52dbe4b06e50f9beb165"},{"code":"(fn myflatten [s]\n  (reduce (fn [x y] (if (sequential? y) (into x (myflatten y)) (conj x y))) [] s))","problem":28,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn fl [coll] (let [f (first coll) r (next coll)] (concat  (if (coll? f) (fl f) [f]) (when (seq? r) (fl r)))))","problem":28,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn f [x] \n  (if (coll? x) \n    (mapcat f x) \n    [x]))","problem":28,"user":"4faafccde4b081705acca209"},{"problem":28,"code":"(fn flt[xs]\n  (cond\n    (empty? xs) '()\n    (coll? (first xs)) (flt (concat (first xs) (rest xs)))\n    :else (cons (first xs) (flt (rest xs)))))","user":"60c91f48e4b0e0fa5f1b4304"},{"problem":28,"code":"#(letfn [(grr [acc s] (if (empty? s) acc (grr (if (coll? (first s)) (grr acc (first s)) (conj acc (first s))) (rest s))))] (reverse (grr nil %)))","user":"587e43d2e4b052da650a633f"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (cond\n    (nil? x) x\n    (not (sequential? x)) (concat [x] (flat xs))\n    :else (concat (flat x) (flat xs))))","user":"56e2ca59e4b03a7c14b85a38"},{"problem":28,"code":"(fn fl [cl]\n  (when-let [s (seq cl)]\n    (if (coll? (first s))\n      (concat (fl (first s)) (fl (rest s)))\n      (cons (first s) (fl (rest s))))))","user":"5e3071abe4b05b4b01516213"},{"problem":28,"code":"(fn [xs] \n\n  (letfn [(flatten-rec [xs accum]\n    (cond                                                                                                                                                                                                     \n          (empty? xs) accum\n          (coll? (first xs)) (flatten-rec (rest xs) (flatten-rec (first xs) accum))\n          :else (flatten-rec (rest xs) (conj accum (first xs)))))]\n  (flatten-rec xs [])))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"#(let [s sequential?]\r\n    (filter (complement s)\r\n          (tree-seq s seq %)))","problem":28,"user":"4e597b2c535d8a8b8723a29d"},{"code":"(fn [coll]\n  (letfn [(do-flatten [into what] \n      (if (or (seq? what) (vector? what))\n        (reduce do-flatten into what)\n        (conj into what)))]\n    (do-flatten [] coll)))","problem":28,"user":"4f0b2028535d0136e6c222ff"},{"code":"(fn f [x]\n  (if (not (coll? x))\n    (list x)\n    (reduce (fn [s y] (concat s (f y))) '() x)))","problem":28,"user":"4f3444b7e4b0e243712b1eb6"},{"code":"(fn [x] (loop [r x]\r\n (if (every? false? (map sequential? r))\r\n   r\r\n   (recur (mapcat #(if (sequential? %) % (list %)) r)))))","problem":28,"user":"4e5bdc2b535d8a8b8723a2bb"},{"code":"(fn myf [x] (reverse (into '() ( (fn myf2 [y  x] (if (empty? x) y \r\n                   ( if  ( coll? (first x))  \r\n                     (myf2 (reduce conj y  (myf2 [] (vec (first x)))) (rest x))\r\n                     (myf2 (reduce conj y [(first x)]) (rest x))\r\n                     ))) []  (vec x)))))","problem":28,"user":"50646c01e4b007509339a58b"},{"problem":28,"code":"(fn flatten2 [x]\r\n   (let [flat (fn fl [mem y] \r\n                (if (sequential? y) \r\n                    (if (empty? y) \r\n                        mem\r\n                        (concat (fl mem (first y)) (fl mem (rest y))))\r\n                    (cons y mem)))]\r\n    (flat () x)))","user":"5f9df1d8e4b0715f5002d832"},{"problem":28,"code":"(fn flat [x] (if (seq x) (concat (if (sequential? (first x)) (flat (first x)) (list (first x))) (flat (rest x))) ()))","user":"5d55305ce4b02ba5928a680d"},{"problem":28,"code":"(fn myflatten [s]\n  (letfn [(flat [coll] (when-let [c (seq coll)]\n              (let [f (first c)]\n                (if (sequential? f)\n                  (concat (flat f) (flat (rest c)))\n                  (cons f (flat (rest c)))))))]\n    (if (sequential? s) (flat s) s)))","user":"534b57bbe4b084c2834f4a78"},{"code":"(fn [xs]\n    (letfn [(flat [x]\n              (if (sequential? x)\n                (mapcat flat x)\n                [x]\n                )\n              )]\n      (flat xs)\n      )\n     )","problem":28,"user":"522f483ce4b032bbe342415a"},{"code":"(fn flt [col]\n   (let [v (first col)]\n     (cond (empty? col) nil\n           \n           (sequential? v) (concat (flt v) (flt (rest col)))\n                                   \n           :else (cons v (flt (rest col))))))","problem":28,"user":"504e71cbe4b0f6ff3350c4b3"},{"code":"(fn fltten [x] (if (coll? x) (mapcat fltten x) [x]))","problem":28,"user":"532347dde4b09d4e7a9b54cc"},{"code":"#(filter (fn [x] (not (sequential? x)))\n  (tree-seq sequential? seq %))","problem":28,"user":"4ff201d7e4b0678c553fc330"},{"problem":28,"code":"(fn a [l] (reduce (fn [x y] (if (coll? y) (apply conj x (a y)) (conj x y))) [] l))","user":"5e66c144e4b0e171e1033683"},{"code":"(fn flat [x]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat (flat x) acc)\n              (conj acc x))) '() (reverse x)))","problem":28,"user":"50b11fbce4b009df37c708cb"},{"problem":28,"code":"(fn my-flatten [coll] \n  (reduce    \n   (fn [acc x] \n     (if (coll? x)        \n       (into acc (my-flatten x))\n       (conj acc x)))\n   [] coll))","user":"5f82609ae4b0c071e6c840f9"},{"problem":28,"code":"(fn flat [x]\n  (if (or (seq? x) (vector? x)) \n    (if (= 0 (count x)) \n      '()\n      (\n        (fn merge-list-r [x y]\n              (if \n                (= 0 (count x)) \n                y\n                (merge-list-r (rest x) (conj y (first x)))\n              )\n        )\n        (reverse (flat (first x))) \n        (flat (rest x))\n      )\n    )\n    (list x)\n  )\n)","user":"54d707bde4b0a52adc2e2025"},{"code":"(fn [v] (let [make-flat (fn self [x xs result]\n                      (if (coll? x)\n                        (self (first xs) (rest xs) (self (first x) (rest x) result))\n                        (if (empty? xs)\n                            (cons x result)\n                            (self (first xs) (rest xs) (cons x result)))))]\n          (reverse (filter #(not (nil? %)) (make-flat (first v) (rest v) [])))))","problem":28,"user":"50e3ddd4e4b01912b3285c47"},{"code":"(fn flat [coll] (mapcat #(if (sequential? %) (flat %) [%]) coll))","problem":28,"user":"525fea5ae4b03e8d9a4a7026"},{"problem":28,"code":"(fn my-flatten [l]\n  (cond\n   (empty? l) ()\n   (coll? (first l)) (concat (my-flatten (first l)) (my-flatten (rest l)))\n   :else (cons (first l) (my-flatten (rest l)))))","user":"53e27bf1e4b036ad0777e3f2"},{"problem":28,"code":"(fn nice [[f & r]]\n  (if (nil? f)\n    '()\n    (if (sequential? f)\n      (concat (nice f) (nice r))\n      (cons f (nice r)))))","user":"5d6b21efe4b04d129b00f2a3"},{"code":"(fn my-flatten [coll]\n  (let [h (first coll)]\n    (cond\n      (nil?  h) coll\n      (coll? h) (concat (my-flatten h) (my-flatten (rest coll)))\n      :else     (cons   h (my-flatten (rest coll)))\n    )\n  )\n)","problem":28,"user":"504d0116e4b022602c20b089"},{"problem":28,"code":"(fn [seqn]\n  (filter #(not (sequential? %)) (rest (tree-seq sequential? seq seqn))))","user":"50a00725e4b08df8156e9e46"},{"problem":28,"code":"#((fn flt [s]\n(if (sequential? s)\n(mapcat flt s)\n(list s))) %)","user":"53aebc94e4b047364c044478"},{"problem":28,"code":"(fn [c]\n  (let [fu (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n             ;(list acc)\n             )]\n    (reduce fu [] c)\n    ))","user":"57583451e4b02ea114799304"},{"problem":28,"code":"(fn [lst] (filter (complement sequential?) (tree-seq sequential? identity lst)))","user":"57fc34f0e4b0d3187e90098e"},{"code":"(fn a [col] (mapcat #(if(coll? %)(a %)(identity [%])) col))","problem":28,"user":"527a8eb7e4b03e8d9a4a755f"},{"problem":28,"code":"(fn [ss] \n  (loop [s ss r []]\n\t(if (empty? s)\n      r\n      (if (coll? (first s))\n      \t(recur (into (vec (first s)) (rest s)) r)\n        (recur (rest s) (conj r (first s)))))))","user":"5d3ae729e4b01671435dbd5d"},{"code":"(fn flat [[f & r]]\n  (if (nil? f)\n    '()\n    (if (sequential? f)\n      (concat (flat f) (flat r))\n      (cons f (flat r)))))","problem":28,"user":"5170643ee4b004f79986ad89"},{"problem":28,"code":"(fn my-flatten [s] \n  (if (sequential? s)\n\t(if (empty? s) \n      '()\n      (concat \n       \t(my-flatten (first s)) \n        (my-flatten (rest s))))\n    (list s)))","user":"57be6dcfe4b05aa3c4741c6a"},{"problem":28,"code":"(fn flt [xs]\n   (loop [acc [] ys xs]\n       (if (empty? ys)\n            acc\n            (\n              recur \n                     (if (or (instance? clojure.lang.PersistentList (first ys)) (instance? clojure.lang.PersistentVector (first ys)))\n                        (into acc (flt (first ys)))\n                        (conj acc (first ys))\n                     )\n                     (rest ys)\n            )\n       )\n    )\n  )","user":"55d7312ee4b0e31453f64a9f"},{"problem":28,"code":"(fn f [more]\n  (reduce (fn [acc k]\n            (if (and (not (map? k)) (coll? k))\n              (concat acc (f k))\n              (concat acc [k])))\n          []\n          more))","user":"53da059be4b0e771c302547e"},{"problem":28,"code":"#(reverse\n  (reduce\n   (fn rec-flat [acc item]\n     (if (coll? item)\n       (reduce rec-flat acc item)\n       (conj acc item)))\n   '()\n   %))","user":"5fe9169ce4b05ac5b16ea1a0"},{"problem":28,"code":"#(filter (complement sequential?)\n        (tree-seq sequential? identity %))","user":"5dd1fb19e4b0948ae9d9ad51"},{"code":"(fn [l]\n  (let [flt (fn [ll, res, self]\n    (cond\n      (empty? ll) res\n      :else (self (rest ll) \n                  (into res\n                    (cond \n                      (list? (first ll)) (self (first ll) [] self)\n                      (vector? (first ll)) (self (seq (first ll)) [] self)\n                      :else (list (first ll))\n                    )\n                  )\n                  self\n    )))]\n    (flt l [] flt)\n  )\n)","problem":28,"user":"4e6e10d8535d5021c1a895fd"},{"problem":28,"code":"(fn trip [coll] (reduce (fn [c e] (concat c (if (coll? e) (trip e) (list e)))) [] coll))","user":"512b07f7e4b078b06821febb"},{"problem":28,"code":"(fn my-f [col]\n   (reduce #(if (or (seq? %2) (vector? %2))\n                  (concat %1 (my-f %2))\n                  (concat %1 (list %2))) [] col))","user":"5dfbe0eae4b0a607a9a45ce2"},{"code":"(fn flatten2 [s]\n  (cond (empty? s) '()\n        ((complement sequential?) (first s)) (cons (first s) (flatten2 (rest s)))\n        :else (concat (flatten2 (first s)) (flatten2 (rest s)))))","problem":28,"user":"534da51fe4b084c2834f4aa4"},{"problem":28,"code":"(fn this [x]\n  (if (coll? x)\n    (mapcat this x)\n    [x]))","user":"5af31955e4b0cc2b61a3bc7a"},{"problem":28,"code":"(fn [s] (letfn [(aux [s r] (if (empty? s)\n                             r\n                             (if (sequential? (first s))\n                               (aux (rest s) (aux (first s) r))\n                               (aux (rest s) (conj r (first s))))))]\n                     (aux s [])))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn [lst]\n   (letfn [(_flatten [lst acc]\n             (if (not (empty? lst))\n               (if (sequential? (first lst))\n                 (_flatten (rest lst) (into acc (_flatten (first lst) [])))\n                 (_flatten (rest lst) (conj acc (first lst))))\n               acc\n               ))]\n     (_flatten lst [])\n     ))","problem":28,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"(fn [l]\n  (loop [q l\n         acc []]\n    (if (empty? q)\n      acc\n      (let [f (first q)\n            r (rest q)]\n        (if (sequential? f)\n          (recur (concat f r) acc)\n          (recur r (conj acc f)))))))","problem":28,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":28,"code":"(fn my-flatten[list]\n (if (coll? list)\n   (mapcat my-flatten list)\n   [list]))","user":"565953a8e4b068f2fe63dbea"},{"code":"(fn flat [coll] (mapcat #(if (coll? %) (flat %) (vector %)) coll))","problem":28,"user":"510fe537e4b04c71fce993dd"},{"problem":28,"code":"#(sort(loop [col % noc []] (if (empty? col) noc (let [gr (group-by coll? col)] (recur (apply concat (get gr true))(concat noc (get gr false)))))))","user":"56b2652ae4b0982f16b37e04"},{"problem":28,"code":"(fn [a]\n   (letfn [(flat [l]\n             (loop [list l\n                    temp []]\n               (cond (empty? list) temp\n                     (or (vector? (first list))\n                         (list? (first list))) (recur (rest list) (apply #'conj temp (flat (first list))))\n                     true (recur (rest list) (conj temp (first list))))))]\n     (flat a)))","user":"5f3f2281e4b004f08c61c561"},{"problem":28,"code":"(fn\n  [& xs]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq xs))))","user":"4f925791e4b0dcca54ed6cac"},{"code":"(fn flat [c]\n   (if (sequential? c)\n     (mapcat flat c)\n     (list c)))","problem":28,"user":"52d23a39e4b099d49816f0a6"},{"code":"(letfn [(myflatten [s] (if (sequential? s) (apply concat (map myflatten s)) (list s)))] myflatten)","problem":28,"user":"52e75667e4b09f7907dd1485"},{"code":"(fn f2 [xs] (reduce #(cond (coll? %2) (concat (f2 %2) %1)\n                           :else (conj %1 %2)) nil (reverse xs)))","problem":28,"user":"5311079de4b08068f379ece2"},{"problem":28,"code":"(fn [ho]\n  (letfn [(unpack [x]\n          (loop [result '()\n         s x]\n    (if (empty? s)\n      result\n      (recur (if (sequential? (first s))  (concat result (unpack (first s)) )  (concat result [(first s)]  ))\n              (rest s)\n              )\n      )\n    )\n          )]\n  (unpack ho)\n  ))","user":"57a497e8e4b0a966079561e4"},{"problem":28,"code":"(fn my-flatten [col] \n  (cond \n    ((comp not coll?) col) [col]\n    (every? (comp not coll?) col) col\n    :else (concat (my-flatten (first col)) (my-flatten (rest col)))))","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":28,"code":"(fn [coll]\n(filter (complement sequential?)\n        (rest (tree-seq sequential? seq coll))))","user":"5aa4a1ffe4b0d174b936c886"},{"code":"(fn flatn [coll]\n  (if (sequential? coll)\n    (mapcat flatn coll)\n    (list coll)))","problem":28,"user":"5201d2f3e4b0b2e020a18f22"},{"problem":28,"code":"(fn fl [s]\n  (concat\n   (if (sequential? (first s)) \n     (fl (first s)) \n     [(first s)])\n   (when (sequential? (next s))\n     (fl (next s)))))","user":"54b95f3de4b0ed20f4ff6eab"},{"code":"(fn __ [f & r]\r\n  (if (coll? f)\r\n    (if r\r\n      (concat (__ f) (__ r))\r\n      (apply __ f)\r\n    )\r\n    (if r\r\n      (cons f (apply __ r))\r\n      (list f)\r\n    )\r\n  )\r\n)","problem":28,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":28,"code":"#(reverse \n  (reduce\n   (fn my-flatten \n     [x elem]\n     (if (coll? elem) \n       (reduce my-flatten x elem)\n       (conj x elem)))\n   ()\n   %))","user":"59e68254e4b0249b728206fc"},{"code":"(fn flat\n  [seq]\n    (cond\n      (empty? seq) '()\n      (coll? (first seq)) \n        (concat (flat (first seq))\n                (flat (rest seq)))\n      :else (cons (first seq) (flat (rest seq)))))","problem":28,"user":"4fd16778e4b04c3a95aa040f"},{"problem":28,"code":"(fn flat-recur [xs]\n  (if (empty? xs)\n    ()\n    (concat (if (sequential? (first xs))\n            (flat-recur (first xs))\n            [(first xs)])\n          (flat-recur (rest xs)))))","user":"5b044436e4b0cc2b61a3bd71"},{"code":"; basically an inorder traversal of the tree\n(fn flt\n  [x]\n  (cond (coll? x) (mapcat flt x)\n        :else     (list x)))","problem":28,"user":"51bb970be4b0fe3ecfb4644e"},{"problem":28,"code":"(fn flatty [tootall] (reduce #(if (coll? %2) (into %1 (flatty %2)) (conj %1 %2)) [] tootall))","user":"56449e4de4b0284900eef5f9"},{"code":"(fn [x] \n  (filter (complement sequential?)\n    (tree-seq sequential? seq x)\n) )","problem":28,"user":"525ee103e4b0cb4875a45dbb"},{"code":"(fn flat [coll]\n  (cond (empty? coll) '()\n        (sequential? (first coll)) (concat (flat (first coll)) (flat (rest coll)))\n        :else (conj (flat (rest coll)) (first coll))))","problem":28,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":28,"code":"(fn my-flatten [xs]\n  (lazy-seq\n   (reduce (fn --internal-flatten [col v]\n             (if (sequential? v)\n               (reduce --internal-flatten col v)\n               (conj col v)))\n           []\n           xs)))","user":"54973374e4b0b312c081ff6f"},{"problem":28,"code":"(fn fl [l]\n  (reduce\n    #(concat %1 (if (sequential? %2) (fl %2) (list %2)))\n    '()\n    l))","user":"5739cbe4e4b0cd1946bd107c"},{"problem":28,"code":"(fn flat\n  ([c] (flat [] c))\n  ([a c] (if (sequential? c) (reduce flat a c) (conj a c))))","user":"5880e38fe4b0f1effa3b7625"},{"code":"#(filter (complement sequential?) \n  (rest (tree-seq sequential? identity %)))","problem":28,"user":"503255d0e4b0e78df07b092b"},{"problem":28,"code":"(fn flat [sq]\n  (loop [fst (first sq) rst (rest sq)]\n    (cond (empty? sq) []\n     \t  (not (coll? fst)) (into [fst] (flat rst))\n          :else (into (flat fst) (flat rst)))))","user":"59b7120fe4b05c620303ca3b"},{"code":"(fn [x]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq x))\n)","problem":28,"user":"4f6b4237e4b07046d9f4efa9"},{"problem":28,"code":"reduce (fn breakdown [myvector part] \n  (if (coll? part)\n     (reduce breakdown myvector part);recur with each element in list\n    (conj myvector part)\n   )\n  ) []","user":"579be21fe4b05b1deef9adff"},{"problem":28,"code":"(fn [s] (reverse (reduce (fn fltn [s item] (if (coll? item) (reduce fltn s item) (conj s item))) '() s)))","user":"5a5be4ebe4b0512ff01cd912"},{"problem":28,"code":"(fn flat\n  [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s)))))))","user":"5d51216ae4b0776584bd6f5b"},{"problem":28,"code":"(fn flatten1 [x]\n\t(if (empty? x)\n      '()\n      (let [[head & tail] x]\n        (if (sequential? head)\n          (concat (flatten1 head) (flatten1 tail))\n          (cons head (flatten1 tail))))))","user":"564054a9e4b08d4f616f5edf"},{"problem":28,"code":"(fn my_flatten [ [h & t] ] (cond (nil? h) () (coll? h) (concat (my_flatten h) (my_flatten t)) :else (cons h (my_flatten t))))","user":"5d99dc47e4b0d3f9b434ad42"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq % ) ))","problem":28,"user":"4f8e984ee4b0d4e659cdde68"},{"code":"(fn myflat [l] \n  (if (empty? l)\n    '()\n    (if (or (list? (first l)) (vector? (first l)))\n      (concat (myflat (first l))\n             (myflat (rest l)))\n      (concat (list (first l)) \n            (myflat (rest l))))))","problem":28,"user":"50c84ba2e4b00bb60fe0c53e"},{"problem":28,"code":"(fn myFlatten [s]\n    (if (not (empty? s))\n      (let [el (first s)]\n        (if (not (sequential? el))\n          (cons el (myFlatten (rest s)))\n          (concat (myFlatten el) (myFlatten (rest s)))))))","user":"57f4ace3e4b07bbd65c32b2b"},{"problem":28,"code":"(fn my-flat [coll]\n  (reduce #(if (coll? %2) (vec (concat %1 (my-flat %2))) (conj %1 %2)) [] coll))","user":"5dc40814e4b02f9375f4e1ae"},{"problem":28,"code":";;Cheating but couldn't come up with a better solution...\n#(filter \n   (complement sequential?)\n   (tree-seq sequential? seq %))","user":"4fc77f5ae4b0ee37620e1821"},{"code":"(fn [s]\n  (loop [s s\n         acc []]\n    (if (empty? s)\n      acc\n      (if (sequential? (first s))\n        (recur (concat (first s) (rest s)) acc)\n        (recur (rest s) (conj acc (first s)))))))","problem":28,"user":"4fbd24d2e4b081705acca2ff"},{"code":"(fn flatify [xs]\n  (if (coll? xs) \n    (if (empty? xs) [] (concat (flatify (first xs)) (flatify (rest xs))))\n    [xs]))","problem":28,"user":"5285920be4b0239c8a67adfb"},{"code":"#(loop [coll %, out [], more []]\n    (cond\n     (and (empty? coll) (empty? more)) out\n     (coll? (first coll)) (recur (first coll) out (rest coll))\n     (not (empty? coll))  (recur (rest coll) (conj out (first coll)) more)\n     (not (empty? more))  (recur (rest more) (conj out (first more)) []) ))","problem":28,"user":"4ec5c81f535d6d7199dd36b6"},{"problem":28,"code":"(fn foo [coll]\n    (if (empty? coll)\n      '()\n      (let [head (first coll)]\n        (if (coll? head)\n          (concat (foo head) (foo (rest coll)))\n          (cons head (foo (rest coll)))\n          ))))","user":"5d887d27e4b0915913b1d3a8"},{"problem":28,"code":"(fn flattn [x]\n  (if (coll? x)\n    (mapcat flattn x)\n    [x]))","user":"56a01895e4b0542e1f8d149f"},{"problem":28,"code":"(fn [s]\n  ((fn helper [x]\n     (loop [remaining x ans []]\n       (if (empty? remaining)\n         ans\n         (let [[ptr & remain] remaining]\n            (if (sequential? ptr)\n               (recur remain (into [] (concat ans (helper ptr))))\n               (recur remain (conj ans ptr))))))) s))","user":"5746061ae4b009280f9f2b5b"},{"problem":28,"code":"(fn flat [coll]\n  (loop [items coll result []]\n    (println items)\n    (cond \n      (empty? items) result\n      (coll? (first items)) (recur (rest items) (apply conj result (flat (first items))))\n      :else\n        (recur (rest items) (conj result (first items)))\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn f [coll]\n  (reduce\n    #(if (sequential? %2) \n       (apply conj %1 (f %2))\n       (conj %1 %2))\n    [] coll))","problem":28,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [y]\n (mapcat (fn f\n  [x]\n  (if (coll? x)\n      (mapcat f x)\n      [x])) y))","problem":28,"user":"4daeabf6edd6309eace4d15c"},{"problem":28,"code":"(fn f [v]\n  (loop [result `[] v v]\n    (cond (empty? v)\n          result\n          (sequential? (first v)) (recur result (concat (first v) (rest v)))\n          :else (recur (conj result (first v)) (rest v)))))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":28,"code":"(partial (fn f [a xs] (let [[head & more] xs, acc a] (if (sequential? head) (f acc (into (vec head) more)) (do (conj! acc head) (if (sequential? more) (f acc more) (do (if more (conj! acc more)) (remove nil? (persistent! acc)))))))) (transient []))","user":"56cad309e4b0ea9b8538f720"},{"code":"(fn flat [s] (if (sequential? s) (mapcat flat s) (list s)))","problem":28,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"#((fn flat [s nxt]\n  (let\n      [f (first s)\n       r (rest s)]\n    (if (empty? r)\n      (cond\n       (nil? f) nxt\n       (not (coll? f)) (cons f nxt)\n       (empty? f) nxt\n       true (flat f nxt))\n      (cond\n       (nil? f) (flat r nxt)\n       (not (coll? f)) (cons f (flat r nxt))\n       (empty? f) (flat r nxt)\n       true (flat f (flat r nxt)))))) % nil)","problem":28,"user":"529ce629e4b04e0c58e87b6e"},{"problem":28,"code":"(fn flat [coll]\n  (if (empty? coll)\n    coll\n    (let [f (first coll) r (rest coll)]\n      (if (coll? f)\n        (concat (flat f) (flat r))\n        (cons f (flat r))))))","user":"58ac1135e4b0005cfeb1a73f"},{"problem":28,"code":"(fn \n [c] \n    (let \n     [f* \n       (fn f [acc x] \n         (if (coll? x) \n              (reduce f acc \n                 (seq x)) \n              (conj acc x)\n         ) \n       )\n     ] \n     (reduce f* [] c) \n    )\n\n)","user":"5f631e11e4b02876ed9fd011"},{"code":"(fn [s]\n  (filter (complement sequential?)\n          (tree-seq sequential? identity s)))","problem":28,"user":"4f03edd7535dcb61093f6b80"},{"code":"(fn myflatten ([a] (if (sequential? a) (apply myflatten a) (list a))) ([a & rest] (concat (myflatten a) (myflatten rest))))","problem":28,"user":"51c214bce4b0d204dbe2ca1c"},{"problem":28,"code":"#(reverse (reduce (fn my-flatten [acc item]\n                     (if (coll? item)\n                       (reduce my-flatten acc item)\n                       (conj acc item)))\n                   '()\n                   %))","user":"592db566e4b072a2710fcf7c"},{"problem":28,"code":"(fn fl [coll] (reduce (fn [arr x] (if (coll? x) (concat arr (fl x)) (concat arr [x]))) [] coll))","user":"55306f9de4b076ab5578f814"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    ()\n      (if (coll? (first lst))\n        (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n        (cons (first lst)(my-flatten (rest lst))))))","user":"56df7440e4b0ca2494a095fb"},{"problem":28,"code":"(fn\n [q]\n (let\n  [li? (fn\n        [mbli]\n        (or\n         (seq? mbli)\n         (list? mbli)\n         (vector? mbli)))\n   to-list (fn\n            [li]\n            (map\n             #(if\n               (li? %)\n               %\n               (list %)) li))\n   flatten-one (fn\n                [qq]\n                (reduce\n                 concat\n                 (to-list qq)))\n   any? (fn\n         [pred c]\n         (> (count (filter pred c)) 0))\n   flatten-all (fn\n                [q]\n                (if\n                 (any? li? q)\n                 (recur (flatten-one q))\n                 q))]\n  (into [] (flatten-all q))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn myflatten [xs]\n  (cond (empty? xs) ()\n        (coll? (first xs)) (concat (myflatten (seq (first xs)))\n                                   (myflatten (rest xs)))\n        :else (cons (first xs) (myflatten (rest xs)))))","problem":28,"user":"4ee3b586535d10e5ff6f5371"},{"problem":28,"code":"(fn itr [ls]\n  (cond\n   (empty? ls) ls\n   (not (coll? (first ls)))(cons (first ls) (itr (rest ls)))\n   :else (concat (itr (first ls)) (itr (rest ls)))))","user":"56d7f340e4b0ea9b8538f7df"},{"problem":28,"code":"#(letfn [(myflat [l]\n          (cond (empty? l) l\n                (not (coll? (first l))) (cons (first l) (myflat (rest l)))\n                true (concat (myflat (first l)) (myflat (rest l)))))]\n   (myflat %))","user":"5400407de4b0de5c4184860a"},{"problem":28,"code":"#(remove sequential? (rest (tree-seq sequential? identity %)))","user":"54cbc9ede4b057c6fda3a27f"},{"code":"(fn f [x]\n    (if (seq x)\n      (let [[x & xs] x]\n        (if (sequential? x)\n          (concat (f x) (f xs))\n          (cons x (f xs))))))","problem":28,"user":"521c6a1ae4b0c4ef0be83083"},{"code":"(fn my-flatten [xxs]\n                 ;(print xxs)\n                 (if (empty? xxs)\n                   nil\n\n                   (let [x (first xxs)\n                         xs (rest xxs)]\n                     (if (coll? x)\n                       (concat (my-flatten x) (my-flatten xs))\n                       ; Not a list, simply parse the rest of the list.\n                       (cons x (my-flatten xs))\n                       )\n\n                     )\n                   ))","problem":28,"user":"535aba96e4b04ce2eb3ed2a8"},{"problem":28,"code":"(fn [x]\n  (filter \n   #(not (or (seq? %) (vector? %))) \n   (tree-seq \n    #(or (vector? %) (seq? %)) \n    identity \n    x)))","user":"5b3251c1e4b025bcb146f317"},{"problem":28,"code":"(fn flat [col] (reduce #(if (sequential? %2) (apply conj %1 (flat %2)) (conj %1 %2)) []  col))","user":"5793931ee4b0e215f87e845c"},{"code":"(fn [x] (filter (complement sequential?)(rest (tree-seq sequential? seq x))))","problem":28,"user":"50621cbde4b0341461c88951"},{"problem":28,"code":"(fn flat [list]\n  (cond\n    (= 1 (count list)) (cond\n                         (or\n                           (= (type (first list)) clojure.lang.PersistentVector)\n                           (= (type (first list)) clojure.lang.PersistentList)) (flat (first list))\n                         :else [(first list)]\n                         )\n    (or\n      (= (type (first list)) clojure.lang.PersistentVector)\n      (= (type (first list)) clojure.lang.PersistentList)) (concat (flat (first list)) (flat (rest list)))\n    :else (concat [(first list)] (flat (rest list)))\n    )\n  )","user":"5a39e36ce4b001c08efc0cbc"},{"problem":28,"code":"(fn [coll] (filter (complement sequential?)(rest (tree-seq sequential? seq coll))))","user":"57f3b841e4b0511f1d294e0f"},{"code":"#(filter (fn [x] (not (sequential? x))) (tree-seq sequential? seq %))","problem":28,"user":"4e9b22e2535dbda64a6f6b74"},{"code":"(fn f[s]\r\n  (reduce\r\n    #(concat %\r\n      (if (coll? %2) (f %2) [%2])) [] s))","problem":28,"user":"4dd66da7535d2dad7130b5c8"},{"problem":28,"code":"(fn [lst] (reduce (fn inner [a b] (if (not (coll? b))\n                           (concat a (list b))\n                           (if (reduce #(if (not (coll? %2)) (and %1 %2)) true b)\n                             (concat (seq a) (seq b))\n                             (recur a  (reduce inner '() b))))) '() lst))","user":"5f558a76e4b0a0bc16850a84"},{"code":"(fn flt [x]\n  (loop [a x\n         b '()\n         i 0]\n    (if (= i (count x))\n      (reverse b)\n      (if (coll? (first a))\n        (recur (rest a) (apply conj b (flt (first a))) (inc i))\n        (recur (rest a) (conj b (first a)) (inc i))\n      )\n    )\n  )\n  )","problem":28,"user":"52f685eae4b047fd55836fb8"},{"problem":28,"code":"(fn flt [l]\n  (reduce #(if (coll? %2)\n             (sort (concat %1 (flt %2)))\n             (sort (conj %1 %2))) () l))","user":"5a80b934e4b00b71e582a05b"},{"problem":28,"code":"(fn flattened [x]\n   (if (= '() x)\n     '()\n     (if (sequential? (first x))\n      (concat\n       (flattened (first x))\n       (flattened (rest x)))\n      (cons\n       (first x)\n       (flattened (rest x))))))","user":"59273eefe4b072a2710fcec6"},{"problem":28,"code":"(fn my-flatten\n   [in]\n   (cond\n     (not (sequential? in)) (repeat 1 in)\n     (empty? in) '()\n     :else (concat (my-flatten (first in)) (my-flatten (rest in)))\n     ))","user":"5b107263e4b0cc2b61a3be22"},{"problem":28,"code":"#(reverse\n  ((fn f [coll]\n       (loop [result '() values coll]\n         (if (empty? values)\n           result\n          (let [e (first values)]\n            (recur (if (coll? e)\n                     (concat (f e) result)\n                     (conj result e))\n                   (rest values)))))) %))","user":"571107b3e4b09c608db7043f"},{"code":"(fn g[x](if(coll? x)(mapcat g x)[x]))","problem":28,"user":"4f296a80e4b0d6649770a02a"},{"problem":28,"code":"(fn flat [s]\n  (loop [s s\n         acc []]\n    (if (seq s)\n      (let [e (first s)]\n        (recur (rest s) (concat acc (if (sequential? e) (flat e) [e]))))\n      acc)))","user":"5a8aa992e4b05369db4d24d8"},{"problem":28,"code":"(fn fltn [s]\n  (if (empty? s)\n    '()\n    (let [f (first s) r (rest s)]\n      (if (coll? f)\n        (concat (fltn f) (fltn r))\n        (cons f (fltn r))\n      )\n    )\n  )\n)","user":"5d6f0533e4b04d129b00f2d0"},{"code":"(fn self [coll]\n    (if (empty? coll)\n      '()\n      (if (coll? (first coll))\n        (into (self (rest coll)) (reverse (self (first coll) )))\n        (cons (first coll) (self (rest coll))))))","problem":28,"user":"5379ed48e4b06839e8705e5a"},{"code":"(fn [coll]\r\n(loop [coll coll tmp []]\r\n      (if (empty? coll)\r\n        (seq tmp)\r\n        (let [head (first coll)\r\n              tail (rest coll)]\r\n          (if (coll? head)\r\n            (recur (into (vec head) tail) tmp)\r\n            (recur tail (conj tmp head)))))))","problem":28,"user":"4e88feef535d8b9bb0147ca8"},{"code":"(fn flt [s]\n   (if (sequential? s)\n     (mapcat flt s)\n     (list s)))","problem":28,"user":"4e89f46c535d3e98b8023288"},{"problem":28,"code":"(fn my-flatten [xs]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (my-flatten x))\n              (concat acc (vector x))))\n          []\n          xs))","user":"5189a51ae4b0288ada3dbdad"},{"code":"(fn flat[x]\n  (if (empty? x)\n   '()\n   (if (or (seq? (first x)) (vector?(first x)))\n      (concat (flat (first x))\n               (flat (rest x)))\n      (cons (first x) (flat (rest x))))))","problem":28,"user":"4f0365fc535dcb61093f6aa4"},{"problem":28,"code":"(fn F [x] (if (coll? x) (mapcat F x) (list x)))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":28,"code":"(fn my-flatten [aSeq]\n       (mapcat (fn [item]\n              (if (not (coll? item))\n                (list item)\n                (my-flatten item))) aSeq))","user":"599e3677e4b0871e7608b809"},{"problem":28,"code":"(fn f [x] ((fn fl [x acc] \n  (cond \n    (empty? x) acc\n    (sequential? (first x))       \n      (fl (rest x) (fl (first x) acc))\n    :else (fl (rest x) (concat acc (list (first x)) )) )) x '()))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":28,"code":"(fn wat [coll]\n  (filter (complement sequential?) \n          (tree-seq sequential? seq coll)))","user":"54dcbc6ee4b024c67c0cf787"},{"problem":28,"code":"(fn flat [a &[vec]]\n  (let [vec (if (nil? vec) (atom []) vec)]\n    (doseq [i a]\n      (if (sequential? i)\n        (flat i vec)\n        (swap! vec conj i))) @vec))","user":"5dab11cde4b000c986472c45"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    lst\n    (if (or (list? (first lst)) (vector? (first lst)))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (cons (first lst) (my-flatten (rest lst))))))","user":"59e12c94e4b08badc2a0c509"},{"problem":28,"code":"(fn my-flatten [branch-or-leaf]\n  (if-not (sequential? branch-or-leaf)\n    (list branch-or-leaf)\n    (apply concat (map my-flatten branch-or-leaf))))","user":"604a30c6e4b02d28681c77f0"},{"problem":28,"code":"#(let [foo (fn foo [container x] (if (coll? x) (reduce foo container x) (conj container x)))] (reduce foo [] %))","user":"55ef9c9de4b066087aa94537"},{"problem":28,"code":"(fn [coll]\n   (seq\n    (reduce\n     (fn mflat [x y]\n       (if (coll? y)\n         (reduce mflat x y)\n         (conj x y)))\n     [] coll)))","user":"529a3c37e4b02ebb4ef75094"},{"code":"(fn f [s] (if (coll? s) (if (= (count s) 1) (f (first s)) (concat (f (first s)) (f (rest s)))) (repeat 1 s)))","problem":28,"user":"52e295fae4b09f7907dd1437"},{"problem":28,"code":"(fn flatt\n  [coll]\n  (seq (reduce (fn [col el]\n            (if (sequential? el)\n              (into col (flatt el))\n              (conj col el)))\n          [] coll)))","user":"56b1ab17e4b0982f16b37df1"},{"code":"(fn flat [coll] (when-let [s (seq coll)]\n               (if (coll? (first s)) \n                 (concat (flat (first s)) (flat (rest s)))\n                 (cons (first s) (flat (rest s))))))","problem":28,"user":"504e2600e4b0f6ff3350c46f"},{"problem":28,"code":"(fn flat [elements]\n  (if-let [x (first elements)]\n    (concat (if (sequential? x)\n      (flat x)\n      [x])\n        (flat (rest elements))\n      )\n    []))","user":"5b2c1f60e4b025bcb146f2b1"},{"problem":28,"code":"#(filter (complement sequential?) (rest( tree-seq sequential? seq %)))","user":"564633a1e4b0284900eef60f"},{"problem":28,"code":"#(reduce (fn flat\n           [c e]\n           (if (sequential? e) \n             (reduce flat c e)\n             (conj c e))) [] %)","user":"60046db8e4b074f607df6642"},{"code":"#(reverse\n   (reduce\n    (fn unwrap[acc %]\n      (if (not (coll? %))\n        (conj acc %)\n        (reduce unwrap acc %)))\n    () %))","problem":28,"user":"4fcc70b3e4b0ee37620e1862"},{"code":"reduce (fn f [xs x] (concat xs (if (coll? x) (reduce f '() x) (list x)))) '()","problem":28,"user":"516ea313e4b06aac486e5b2c"},{"code":"(fn [input]\r\n    (loop [result [] remaining input]\r\n        (if (> (count remaining) 0)\r\n            (let [head (first remaining) tail (rest remaining)]\r\n                (if (coll? head)\r\n                    (recur result (concat head tail))\r\n                    (recur (conj result head) tail)))\r\n            (apply list result))))","problem":28,"user":"4dddf817535d08e6dec9fdd3"},{"problem":28,"code":"(fn f\n  [s]\n  (if (empty? s)\n    ()\n    (if (sequential? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))))","user":"56df632ce4b0ca2494a095f2"},{"problem":28,"code":"(fn [l]\n  (mapcat (fn flat [x]\n            (if (coll? x)\n              (mapcat flat x) \n              [x]))\n          l))","user":"59637028e4b066ee0a44b0ca"},{"problem":28,"code":"(fn f[x](if (coll? x)(mapcat f x)(list x)))","user":"5367f0a7e4b0243289761e88"},{"code":"(fn my-flatten [s]\n  (cond\n\t\t(not (coll? s)) (list s)\n\t\t(= 1 (count s)) (my-flatten (first s))\n\t\t:else (concat (my-flatten (first s)) (my-flatten (rest s))) \n\t)\n)","problem":28,"user":"4faacc04e4b081705acca201"},{"code":"(fn fltr [x] \n  (cond \n    (empty? x) '() \n    ((complement sequential?) (first x)) (cons (first x) (fltr (rest x))) \n    :else (concat (fltr (first x)) (fltr (rest x)))))","problem":28,"user":"4fba0877e4b081705acca2dd"},{"problem":28,"code":"(fn f [c]\n (mapcat #(if (coll? %) (f %) [%]) c))","user":"5de44684e4b0948ae9d9ae03"},{"code":"(fn flato\n  [x]\n  (cond (not (coll? x)) [x]\n        (not (empty? x)) (into (flato (first x)) (flato (rest x)))))","problem":28,"user":"50b35486e4b03ea88043356a"},{"problem":28,"code":"(fn fl\n  ([x] (fl x []))\n  (\n    [x, l]\n      (loop [s x, r l]\n        (let [f (first s)]\n          (if (nil? f)\n            r\n            ( \n              recur (rest s) (if (coll? f)\n                (fl f r)\n                (conj r f)\n              )\n            )\n          )\n        )\n      )\n  )\n)","user":"5cd1fd2fe4b0ccb0619628f8"},{"problem":28,"code":"(fn flat [coll]\n  (apply concat (map (fn [x] (if (sequential? x) (flat x) [x])) coll)))","user":"5efc8ed6e4b0cf489e8d7ef9"},{"code":"(fn flat [coll]\n  (when-let [s (seq coll)]\n    (if (coll? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","problem":28,"user":"4f8386c5e4b033992c121c1d"},{"problem":28,"code":"(fn [origin-seq]\n  (loop [target-seq []\n         origin-seq origin-seq]\n    (if (empty? origin-seq)\n      (concat '() target-seq)\n      (let [head (first origin-seq)\n            rest-seq (rest origin-seq)]\n        (if (or (seq? head)\n                (vector? head))\n          (recur target-seq (vec (concat head rest-seq)))\n          (recur (conj target-seq head) rest-seq))))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":28,"code":"(fn flatter [coll]\n  (loop [flat (list)\n         remain coll]\n    (let [cur (first remain)]\n      (cond\n        (coll? cur) (recur flat (concat cur (rest remain)))\n        (empty? remain) flat\n        :else (recur\n                (concat flat (list cur))\n                (rest remain))))))","user":"55170dd9e4b06a49daca83bd"},{"code":"(fn flat [l]\n  (if (coll? l)\n    (let [[x & more] l]\n      (if (coll? x)\n        (concat (flat x) (flat more))\n        (concat (list x) (flat more))))\n    l))","problem":28,"user":"4ec5d40d535d6d7199dd36b9"},{"problem":28,"code":"(fn flat [l]\n  (let [val (first l)\n        rem (rest l)]\n    (if (sequential? val)\n      (if (empty? rem)\n        (flat val)\n        (concat (flat val) (flat rem)))\n      (if (empty? rem)\n        [val]\n        (concat [val] (flat rem))))))","user":"4f4aa932e4b0d56e7bb92c14"},{"code":"(fn flat [xs]\n  (loop [que [xs]\n         acc []]\n    (if-let [f (and (seq que) (first que))]\n      (if (sequential? f)\n        (recur (concat f (rest que)) acc)\n        (recur (rest que) (conj acc f)))\n      acc)\n    ))","problem":28,"user":"513fab65e4b00f13ea1bd891"},{"code":"(fn my-flatten [c]\n  (if (sequential? c)\n    (mapcat my-flatten c)\n    (list c)))","problem":28,"user":"508fd6bae4b0ea685a20f76b"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x)))]\n             ;(list acc)\n             \n    (reduce f* [] c)))","user":"57b4779de4b0fbc9809a279a"},{"code":"(fn flatten- [x]\n  \"28. Write a function which flattens a sequence.\"\n  (if (sequential? x)\n    (mapcat flatten- x)\n    (list x)))","problem":28,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":28,"code":"(fn [in]\n    (loop [[& in] in\n           out '()]\n      (if (empty? in)\n        out\n          (let [one (first in)\n                others (rest in)] #_rest_can_return_empty\n            (if (or (seq? one) (vector? one))\n              (recur\n                (if (empty? one)\n                  (concat (rest one) others)\n                  (concat [(first one)] (rest one) others))\n                out)\n              (recur\n                others\n                (concat out [one])))))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn make-flat [x] \n  (if (not (coll? x))\n    (if (nil? x)\n      '()\n      (list x))\n    (if (empty? x)\n      '()\n      (concat (make-flat (first x)) (make-flat (rest x))))))","problem":28,"user":"4ecdb0bb535d23f036227709"},{"code":"(fn [xs]\n  (let [vlatten (fn [xs self]\n    (if (empty? xs) '()\n      (if (coll? (first xs)) \n        (concat (self (first xs)self) (self(rest xs)self))\n        (conj (self(rest xs)self) (first xs)))))]\n    (vlatten xs vlatten)))","problem":28,"user":"4eaf08ce535d7eef3080732d"},{"problem":28,"code":"(fn flat ([s] (flat s ())) ([ss fl] (if (empty? ss) fl  (flat (rest ss)  (concat fl (if (coll? (first ss)) (flat (first ss) ()) [(first ss)])) ))))","user":"54a634abe4b09f271ff37c84"},{"code":"(fn [x](filter (complement sequential?) (tree-seq sequential? seq  x)) )","problem":28,"user":"5059da46e4b03d2efce48c56"},{"code":"(fn [s]\n  (filter #(not (sequential? %))\n    (tree-seq sequential? seq s)))","problem":28,"user":"511c44fde4b00c2a1fa7ff77"},{"problem":28,"code":"(fn f [xs] \n  (let [[head & tail] xs]\n    (when head \n      (if (sequential? head)\n        (concat (f head) (f tail))\n        (cons head (f tail))))))","user":"4f8490fae4b033992c121c34"},{"problem":28,"code":"(fn flat [coll]\n  (if (empty? coll)\n    []\n    (let [fst (first coll)\n          frst (flat (rest coll))]\n      (if (coll? fst)\n        (concat (flat fst) frst)\n        (cons fst frst)))))","user":"52860baae4b0239c8a67ae09"},{"problem":28,"code":"(fn flat [ls]\n  (if (not (coll? ls))\n    (list ls)\n    (mapcat flat ls)\n    )\n  )","user":"541ef7e2e4b01498b1a71a92"},{"problem":28,"code":"(fn flat [coll]\n  (let [head (first coll) tail (rest coll)]\n    (cond\n      (nil? head) coll\n      (coll? head) (concat (flat head) (flat tail))\n      :else (cons head (flat tail)))))","user":"55842c7ee4b05c286339e11d"},{"problem":28,"code":"(fn f [i]\n  (if (sequential? i)\n    (mapcat f i)\n    [i]))","user":"588fbb39e4b00487982d51bd"},{"problem":28,"code":"(fn flat [s] (filter (complement sequential?)\n         (tree-seq sequential? seq s)))","user":"560b483ee4b05f002753df16"},{"code":"(fn [s]\n  (remove sequential? (tree-seq sequential? seq s)))","problem":28,"user":"4ec34578535dcc7ae8597d51"},{"problem":28,"code":"(fn f [l]\n  (apply concat (map #(if (sequential? %)\n          (f %)\n          [%]) l)))","user":"565e0934e4b068f2fe63dc30"},{"problem":28,"code":"(fn my-flatten [coll]\n  (mapcat (fn [el]\n         (if (coll? el)\n           (my-flatten el)\n           `(~el))) coll))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn fl [x]\n  (when (not (= x '()))\n    (let [s (if (vector? x) (seq x) x)]\n    (if (seq? s)\n      (concat (fl (first s)) (fl (rest s)))\n      (list s)))))","problem":28,"user":"51a671d4e4b0740bfd1afd21"},{"code":"(fn [coll]\n  (letfn [(flatten-seq [coll]\n    (apply concat\n      (map #(if (coll? %) (flatten-seq (seq %)) (list %)) coll)))]\n  (flatten-seq coll)))","problem":28,"user":"4e7f7e48535db966e863cc42"},{"problem":28,"code":"(fn [x]\n(letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","user":"552456e3e4b0882d96d091c2"},{"problem":28,"code":"(fn flattten [l] \n  (if (not (sequential? l))\n    (list l)\n   \t(mapcat flattten l)))","user":"589714cbe4b00487982d52b1"},{"code":"(fn flat [arg]\n  (if (not (or (vector? arg) (seq? arg)))\n    (list arg)\n    (if (empty? arg)\n      arg\n      (concat (flat (first arg)) (flat (rest arg))))))","problem":28,"user":"4f652432e4b07046d9f4ef3d"},{"problem":28,"code":"(fn my-flat [l]\n      (if (->> l (filter coll?) (empty?))\n        (sort l)\n        (if (->> (first l) (coll?))\n          (if (->> (first l) (filter coll?) (empty?))\n            (my-flat (concat (rest l) (my-flat (first l))))\n            (my-flat (concat (rest l) (first l))))\n          (my-flat (concat (rest l) [(first l)])))))","user":"5938bca5e4b02506e01a29eb"},{"problem":28,"code":"(fn fltn [xs]\n  (mapcat #((if (coll? %) fltn list) %) xs))","user":"5adf5f9be4b0837691e92c33"},{"problem":28,"code":"#(reverse (reduce\n                (fn rec-flatten [acc item]\n                  (if (coll? item) (reduce rec-flatten acc item)\n                      (conj acc item)))\n                '()\n                %))","user":"5410499de4b01498b1a719a6"},{"code":"(fn flat [seq]\n  (if (sequential? seq)\n      (if (> (count seq) 0)\n          (reduce conj (flat (first seq)) (flat (rest seq)))\n        seq)\n    [seq]))","problem":28,"user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":28,"code":"(fn my-flatten [seq]\n  (let [is-list? #(or (seq? %) (vector? %))\n        inner-flatten\n        (fn inner-flatten [acc val]\n          (if (is-list? val)\n            (concat acc val)\n            (concat acc [val])))]\n    (if (every? #(not (is-list? %)) seq)\n      seq\n      (my-flatten (reduce inner-flatten '() seq)))))","user":"56889672e4b0dcc4269f406c"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n       (flt r)))))","problem":28,"user":"513c51f2e4b0d636b627c968"},{"code":"(fn fltn [s]\n  (reverse\n   (reduce #(if (coll? %2) (into % (fltn %2)) (conj % %2))\n           '()\n           s)))","problem":28,"user":"536f62aee4b0fc7073fd6e7c"},{"problem":28,"code":"(fn flutten [sq] \n  (apply concat \n    (map #(if (coll? %) (flutten %) (list %)) sq\n)))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":28,"code":"(fn flat [s]\n  (filter #(not (coll? %))\n    (next (tree-seq coll? seq s))))","user":"556880dae4b0c656e3ff1856"},{"problem":28,"code":"(fn myflat [f] (apply concat (map #(if (sequential? %) (myflat %) (list %)) f)))","user":"54d95ce8e4b024c67c0cf74a"},{"code":"(fn my-flatten [aseq] (mapcat #(if (sequential? %) (my-flatten %) [%]) aseq))","problem":28,"user":"4ecf42b4535d1f5ad70dba3c"},{"code":"(fn foo [s]\n  (cond (empty? s) s\n        (coll? (first s))\n                 (concat (foo (first s))\n                        (foo (rest s)))\n   :else (cons (first s) (foo (rest s)))))","problem":28,"user":"4facd2fae4b081705acca22f"},{"code":"(fn flttn [x] (if (coll? x) (mapcat flttn x) [x]))","problem":28,"user":"4e1350af535d04ed9115e7d8"},{"code":"(fn flat\n  ([] '())\n  ([x] (if (seq? x)\n         (apply flat x)\n         (if (vector? x)\n            (concat (flat (first x)) (flat (rest x)))\n            (cons x '())\n         )\n       )\n  )\n  ([x & more] (concat (flat x) (flat more)))\n  )","problem":28,"user":"5302ac7fe4b0d8b024fd3731"},{"problem":28,"code":"(fn [coll]\n                (let [flat (fn flat[coll]\n                             (when-let [s (seq coll)]\n                               (if (sequential? (first s))\n                                 (concat (flat (first s)) (flat (rest s)))\n                                 (cons (first s) (flat (rest s))))))]\n                  (flat coll)))","user":"575f2529e4b08062f99a4e7a"},{"problem":28,"code":"(fn flat [x]\n      (if (sequential? x) (apply concat (map flat x))\n                          (list x)))","user":"572af688e4b0f4d77e651249"},{"code":"#((fn squish [s]\n  (cond\n   (or (= nil s) (= [] s))  []\n   (coll? s) (concat (squish (first s))\n                     (squish (rest s)))\n   :else     [s])) %)","problem":28,"user":"51b0e7b3e4b0c53cf2e68a6e"},{"code":"(fn my-flatten [xs]\n  (let [fxs (first xs)\n        rxs (rest xs)]\n    (cond\n     (empty? xs) xs\n     (coll? fxs) (concat (my-flatten fxs) (my-flatten rxs))\n     :else (cons fxs (my-flatten rxs))\n    )\n  )\n)","problem":28,"user":"5273b883e4b03e8d9a4a748f"},{"code":"(fn [xs]\n  ((fn fl [xs flat]\n    (reduce \n      (fn [acc e] (if (coll? e) \n                          (fl e acc)\n                          (conj acc e)))\n      flat\n      xs)) xs []))","problem":28,"user":"4efcac3a535de96065cf507e"},{"code":"(fn [xs]\n       ((fn r [acc ys]\n          (if (coll? ys)\n            (reduce r acc ys)\n            (conj acc ys)))\n         [] xs))","problem":28,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn fl [x] (if (sequential? x) (apply concat (map fl x)) [x]))","problem":28,"user":"53110f32e4b08068f379ece4"},{"problem":28,"code":"(fn flat [xs]\n  (when-let [[x & xs] (seq xs)]\n    (if-not (sequential? x)\n      (cons x (flat xs))\n      (concat (flat x) (flat xs)))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":28,"code":"(fn fltn [[x & xs]]\n  (if (nil? x)\n    nil\n    (if (coll? x)\n      (concat (fltn x) (fltn xs))\n      (cons x (fltn xs)))))","user":"5b64370ae4b0c6492753e73c"},{"problem":28,"code":"(fn flatten2 [x]\n  (if (coll? x)\n    (mapcat flatten2 x)\n    [x]))","user":"553bda0de4b09218d5f4500b"},{"problem":28,"code":"(fn tt\n  [coll]\n  \t(let [a (first coll)\n          b (next coll)]\n      (concat \n       (if (sequential? a)\n         (tt a)\n         [a])\n       (when (sequential? b)\n         (tt b)))))","user":"599342efe4b0b211ea3aaab0"},{"problem":28,"code":"(fn [inputseq]\n  (loop [result []\n         nextPart (list)\n         remaining inputseq\n         comment \"just started\"]\n    (println comment \"//\" result \"//\" nextPart \"//\" remaining)\n    (if (not (coll? nextPart))\n      (recur (concat result (list nextPart)) (list) remaining \"next non seq\")\n      (if (= '() nextPart)\n        (if (= '() remaining)\n      \t  result\n          (recur result (first remaining) (rest remaining) \"next empty\"))\n        (recur result (first nextPart) (concat (rest nextPart) remaining) \"first from next part\"))\n      )))","user":"5a2185a4e4b0ff51aa4b32b0"},{"problem":28,"code":"(fn [xs] (filter #(not (sequential? %)) (rest (tree-seq sequential? seq xs))))","user":"54187e84e4b01498b1a71a1b"},{"problem":28,"code":"(fn flatt [xs]\n  (if (empty? xs)\n    ()\n    (let [x (first xs)\n          fx (if (sequential? x)\n               (flatt x)\n               (list x))]\n      (apply conj (flatt (rest xs)) (reverse fx)))))","user":"55c4e48be4b0e31453f649a7"},{"problem":28,"code":"(fn  my-flatten [coll]\n  (cond\n    (nil? coll) '()\n    \n    (or (list? coll) (vector? coll))\n    ;; Pull out nested lists\n    (apply concat (map my-flatten coll))\n    \n    :else (seq (list coll))))","user":"59971dcbe4b07157cc8daacb"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"566f3e18e4b0a866af6896e7"},{"problem":28,"code":"(fn fflatten [col]\n  (let [l (first col)\n        r (next col)]\n    (concat\n      (if (coll? l)\n        (fflatten l)\n        [l])\n      (when (coll? r)\n        (fflatten r)))))","user":"5592ba8be4b0c79f6e1db931"},{"code":"(fn f\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"5210e5c5e4b080a8d9b9d63f"},{"code":"(fn f [elems]\n  (mapcat #(if (sequential? %) (f %) [%]) elems))","problem":28,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":28,"code":"(fn flatten* [lst]\n  (if (coll? lst)\n    (mapcat flatten* lst)\n    [lst]))","user":"5895477fe4b00487982d527c"},{"problem":28,"code":"(fn [coll] (loop [coll coll, acc []] (print acc)\n\n(cond\n\n(empty? coll) (seq acc),\n(and (seq? (first coll)) (empty? (first coll))) (recur (rest coll) acc),\n(seq? (first coll))   (recur (conj  (conj (rest coll) (rest (first coll)))     (first (first coll))) acc),\n(and (vector? (first coll)) (empty? (first coll))) (recur (rest coll) acc),\n(vector? (first coll))   (recur (conj  (conj (rest coll) (rest (first coll)))     (first (first coll))) acc),\n:else (recur (rest coll) (conj acc (first coll)))\n\n)\n\n))","user":"4e268c6e535deb9a81d77ef4"},{"code":"(fn blah [s] (loop [lst s ret []]\n\t  (if (empty? lst) ret\n\t      (recur (next lst)\n\t\t     (let [x (first lst)]\n\t\t     (if (coll? x)\n\t\t       (concat ret (blah x))\n\t\t       (conj (into [] ret) x))\n\t\t     )))))","problem":28,"user":"503539dee4b0ed9c821488f6"},{"code":"(fn [coll]\n  (loop [c coll]\n    (if (not-any? #(coll? %) c)\n      c\n      (recur (mapcat #(if (coll? %) % [%]) c)))))","problem":28,"user":"4f06f1db535dcb61093f6c19"},{"code":"(fn ftn [coll]\n           (loop [xs coll ys []]\n             (if (seq xs)\n               (let [x (first xs)\n                     nys (if (coll? x) (into ys (ftn x)) (conj ys x))]\n                   (recur (rest xs) nys))\n               ys)))","problem":28,"user":"4edee6a2535d10e5ff6f533e"},{"code":"(fn flat [c]\n  (let [l (first c) r (rest c)]\n    (concat (if (coll? l)\n              (flat l)\n              (list l))\n            (when-not (empty? r)\n              (flat r)))))","problem":28,"user":"5175616ae4b0dea9bbfba576"},{"code":"(fn milf [coll]\n  (if (or (list? coll) (vector? coll))\n    (apply concat (map milf coll))\n    [coll]))","problem":28,"user":"5146df5ae4b04ef915e3731d"},{"problem":28,"code":"(fn flat [coll]\n   (if (coll? coll)\n     (mapcat flat coll)\n     [coll]))","user":"5a9bfd57e4b0d174b936c7d0"},{"problem":28,"code":"(fn myFlatten [x]\n   (if (coll? x)\n     (mapcat myFlatten x)\n     [x]))","user":"56c60b36e4b05cc29241eead"},{"code":"(fn flatten0 [s]\n  (if (coll? s)\n    (apply concat (map flatten0 s))\n    [s]))","problem":28,"user":"510b0480e4b078ea719210fa"},{"code":"(fn fl [c] (reduce (fn [a b] (concat a (if (coll? b) (fl b) [b]))) '() c))","problem":28,"user":"511f88eee4b085952a83535f"},{"code":"(fn f [x]\n  (cond \n    (empty? x)\n      '()\n    (sequential? (first x))\n      (concat (f (first x)) (f (rest x)))\n    :else\n      (cons (first x) (f (rest x)))))","problem":28,"user":"4f0d6686535d0136e6c22318"},{"code":"(fn [x] (filter (complement sequential?)\n            (rest (tree-seq sequential? seq x))))","problem":28,"user":"504e685fe4b0f6ff3350c4ae"},{"code":"(fn flat [s]\n    (reduce (fn [a b]\n              (if (sequential? b)\n                (into a\n                      (if (some sequential? b) (flat b) b))\n                ;; else\n                (conj a b)))\n            [] s))","problem":28,"user":"4f31519ae4b0d6649770a086"},{"problem":28,"code":"(fn flat [col]\n  (if (empty? col)\n    nil\n    (concat\n     (let [hd (first col)]\n       (if (sequential? hd)\n         (flat hd)\n         (list hd)))\n     (flat (rest col)))))","user":"52b091b4e4b0c58976d9accc"},{"problem":28,"code":"(fn temp [s]\n  (reduce #(concat %1 (if (coll? %2)\n                       (temp %2)\n                       [%2]))\n                     () s))","user":"568a743ee4b0dcc4269f408e"},{"code":"(fn my-flatten [s] \n  (#(filter (complement sequential?) (rest (tree-seq sequential? seq s)))))","problem":28,"user":"51ba59e4e4b0fe3ecfb4642d"},{"problem":28,"code":"(fn[coll](filter (complement sequential?)\n          #_=>           (rest (tree-seq sequential? seq coll))))","user":"5b6962c1e4b0c6492753e787"},{"code":"(fn my-flatten [coll]                                                                                                                                                                                                           \n  (if (sequential? coll)                                                     \n    (mapcat my-flatten coll)                                                 \n    (list coll)))","problem":28,"user":"51991a89e4b068aa333628fd"},{"problem":28,"code":"(fn\n  my-flat\n  [seq]\n  (reduce\n    (fn [acc, elem]\n      (if (coll? elem)\n        (into acc (my-flat elem))\n        (conj acc elem)\n        ))\n    []\n    seq\n    )\n  )","user":"5fe85417e4b05ac5b16ea194"},{"problem":28,"code":"(fn f[a] (if(empty? a) [] (if (sequential? (first a)) (concat (f (first a))(f (rest a)))(concat (list (first a))(f (rest a))))))","user":"59e8bb43e4b0249b72820735"},{"code":"(fn [x] (filter (complement sequential?) (rest (tree-seq sequential? seq  x))))","problem":28,"user":"4e080562535d04ed9115e7aa"},{"problem":28,"code":"(fn [l]\n  (loop [l1 l, l2 '()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"5a19d181e4b0ff51aa4b3207"},{"problem":28,"code":"(fn  [x]\n  (letfn [(flat [coll]\n            (lazy-seq\n              (when-let [c (seq coll)]\n                (let [x (first c)]\n                  (if (sequential? x)\n                    (concat (flat x) (flat (rest c)))\n                    (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","user":"57acee37e4b0b8559636fc94"},{"code":"(fn _flatten [v]\n  (reduce #(if (coll? %2) (into %1 (_flatten %2)) (conj %1 %2)) [] v))","problem":28,"user":"4ee77f15535d93acb0a66868"},{"problem":28,"code":"(fn[nest]\n (filter #(not (sequential? %))\n (tree-seq sequential? identity nest)))","user":"5d08dfe7e4b0cc9c91588210"},{"problem":28,"code":"(fn f [s] (mapcat #(if (coll? %) (f %) (list %)) s ))","user":"59c76402e4b0a024fb6ae542"},{"problem":28,"code":"(fn this\n  ([lst]\n   (this lst []))\n  ([lst acc]\n   (cond (empty? lst) acc\n         (coll? (first lst)) (recur\n                              (apply\n                               (partial conj (rest lst))\n                               (reverse (first lst)))\n                              acc)\n         :else (recur (rest lst) (conj acc (first lst))))))","user":"516f06dce4b06aac486e5b39"},{"code":"(fn my-flatten [xs] (mapcat #(if (coll? %) (my-flatten %) [%]) xs))","problem":28,"user":"51aab611e4b04e3dc0c27b2d"},{"problem":28,"code":"(fn flattenCollection [x]\n  (reduce\n    (fn [theSequence, current]\n      (if (coll? current) (concat theSequence (flattenCollection current)) (concat theSequence [current])))\n    []\n    x))","user":"594c0bd7e4b07ddc2dafae56"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (if (coll? (first x))\n    (my-flatten (concat (first x) (rest x)))\n    (if (empty? (rest x))\n      x\n      (cons (first x) (my-flatten (rest x))))))","user":"5e14e396e4b0a047bd49f6f7"},{"problem":28,"code":"(fn flatten* [l]\n     (reduce (fn [res v]\n              (concat res\n                (if (sequential? v)\n                  (flatten* v)\n                  (list v))))\n      ()\n      l))","user":"58b86162e4b0ebc645576d97"},{"code":"#(reduce (fn plow [x y] (cond (coll? y) (reduce plow x y) true (conj x y))) [] %)","problem":28,"user":"4e975bce535dbda64a6f6b53"},{"problem":28,"code":"#(reduce (fn mflatten [coll x]\n            (if (sequential? x) \n                (reduce mflatten coll x) \n                (conj coll x))) [] %1)","user":"52fa250ee4b047fd55836ff3"},{"code":"(fn [s]\n  (filter\n    (complement sequential?)\n    (tree-seq sequential? seq s)))","problem":28,"user":"4f382eb7e4b0e243712b1ed9"},{"problem":28,"code":"(fn flat [s]\n  (let [f (first s)\n        r (rest s)\n        ]\n    (cond (empty? s) nil\n          (not (sequential? f)) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"5a86ad84e4b05369db4d249c"},{"code":"(fn fl [x]\n   (let [ f (first x) r (next x)]\n     (concat \n      (if (sequential? f)\n        (fl f)\n        [f]\n      )\n      (if (sequential? r)\n        (fl r)\n      )\n     )\n   )\n)","problem":28,"user":"52b9c5e8e4b07a9af57922c2"},{"code":"(fn [x]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"5272669de4b03e8d9a4a742e"},{"problem":28,"code":"(fn [to-flatten]\n    (reverse\n     (loop [x to-flatten remaining () flat-list ()]\n         (if (coll? x)\n           (if (empty? x)\n             flat-list\n             (recur (first x) (concat (rest x) remaining) flat-list))\n           (recur remaining () (conj flat-list x))))))","user":"5446ebc2e4b032a45b8693b8"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (coll? coll) \n    (mapcat my-flatten coll)\n    (list coll)))","user":"561d8936e4b064ca9f4b16b2"},{"problem":28,"code":"(fn [x]\n  (letfn [(flat [xs acc]\n            (if (empty? xs)\n              acc\n              (let [x (first xs)]\n                (if (coll? x)\n                  (let [flattened-x (flat x [])]\n                    (recur (rest xs) (concat acc flattened-x)))\n                  (recur (rest xs) (concat acc [x]))\n                  )))\n            )]\n    (flat x [])))","user":"51bb08a4e4b0fe3ecfb46446"},{"code":"#(loop [s % acc []]\n   (if (empty? s)\n     acc\n     (if (sequential? (first s))\n       (recur (concat (first s) (rest s)) acc)\n       (recur (rest s) (conj acc (first s))))))","problem":28,"user":"529f3f1ae4b04e0c58e87ba5"},{"problem":28,"code":"(fn flat [s]\n  (cond\n    (nil? s) []\n    (not (coll? s)) [s]\n    (empty? s) []\n    :else (mapcat #(flat %) s)\n    )\n  )","user":"59f78b49e4b0ca45a743a30e"},{"problem":28,"code":"(fn [coll]\n    (filter (complement sequential?)\n            (tree-seq sequential? seq coll)))","user":"53613db8e4b0243289761e41"},{"problem":28,"code":"(fn [s]\n  (letfn [(fltn [x]\n                (if-let [[y & ys] x]\n                  (if (sequential? y)\n                    (concat (fltn y) (fltn ys))\n                    (cons y (fltn ys)))))]\n    (fltn s)))","user":"4f107e0e535d64f60314641c"},{"problem":28,"code":"#(( fn [b] (filter (fn [a] (not (coll? a))) b)) (tree-seq coll? identity %))","user":"53a2be95e4b0f1fc7453882d"},{"problem":28,"code":"(fn [se] \n  (reverse (loop [s se acc '()]\n    \n    (if (empty? s) \n        acc\n        (let [[h & t] s\n              nacc (if (coll? h) acc (conj acc h))\n              ns (if (coll? h) (if (empty? h) t (conj t (rest h) (first h) ) ) t)]\n          (recur ns nacc))))))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":28,"code":"(fn fl [s]\n  (if (sequential? s)\n    (if (next s)\n      (concat (fl (first s)) (fl (next s)))\n      (fl (first s)))\n    [s]))","user":"56521a26e4b0f9d632dd845f"},{"problem":28,"code":"(fn my-flatten\n  ([coll]\n   (let [x (first coll) xs (rest coll)]\n     (cond\n      (empty? coll) []\n      (coll? x) (concat (my-flatten x) (my-flatten xs))\n      :else (cons x (my-flatten xs))))))","user":"5c36d110e4b0d62ef62d9f6a"},{"code":"(fn flt [x]\n  (let [l (first x)\n        r (next x)]\n    (concat\n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"4e2ef93d535deb9a81d77f0f"},{"problem":28,"code":"(fn ff [col]\n  (reduce (fn f* [acc x]\n            (if (coll? x)\n              (reduce f* acc x)\n              (conj acc x))) []  col))","user":"5db658ebe4b010eb3c36cd39"},{"problem":28,"code":"(fn f [x] (if (coll? x) (mapcat f x) [x]))\n;(fn f [x] (if (coll? x) (if (empty? x) [] (concat (f (first x)) (f (rest x)))) [x]))","user":"54349368e4b0b6b47310fcf1"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (sequential? coll)\n    (apply concat (map my-flatten coll))\n(list coll)))","user":"57a88e24e4b0a9660795621f"},{"problem":28,"code":"(fn f [x] \n  (if (coll? x) \n    (if (empty? x) \n      x \n      (concat (f (first x)) (f (rest x)))) \n    (list x)))","user":"57501c83e4b02ea11479926b"},{"code":"(fn my-flatten [s]\n  (cond \n    (empty? s) s\n    (coll? (first s))\n      (concat \n        (my-flatten (first s)) \n        (my-flatten (rest s)))\n    :else\n      (concat \n        [(first s)]\n        (my-flatten (rest s)))))","problem":28,"user":"4f03d4dc535dcb61093f6b6e"},{"code":"(fn my-flatten [coll]\r\n    (if (coll? coll)\r\n      (filter identity\r\n              (concat (my-flatten (first coll))\r\n                      (my-flatten (next coll))))\r\n      [coll]))","problem":28,"user":"4f149e0f535d64f60314643d"},{"problem":28,"code":"(fn my-flat\n  [coll]\n  (if (sequential? coll)\n    (mapcat my-flat coll)\n    (list coll)))","user":"5426fb8fe4b01498b1a71b1f"},{"problem":28,"code":"(fn flatten-1 [coll]\n  (reduce (fn [xs x]\n            (if (sequential? x)\n              (apply conj xs (flatten-1 x))\n              (conj xs x)))\n          [] coll))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn flatten*\n  ([coll]\n     (flatten* coll []))\n  ([coll res]\n     (if (seq coll)\n       (if (not (coll? (first coll)))\n         (recur (rest coll) (conj res (first coll)))\n         (recur (rest coll) (flatten* (first coll) res)))\n       res)))","problem":28,"user":"4e3bccb1535deb9a81d77f55"},{"problem":28,"code":"(fn flat [xs]\n  (if (empty? xs) xs\n    (let [[y & ys] xs]\n      (if (coll? y)\n        (concat (flat y) (flat ys))\n        (cons y (flat ys))))))","user":"553e0b70e4b0a04f792994e8"},{"problem":28,"code":"(fn flt [coll]\n        (let [f (first coll) n (next coll)]\n          (concat (if (sequential? f)\n                    (flt f)\n                    [f])\n                  (when (sequential? n)\n                    (flt n)))))","user":"541f89a5e4b01498b1a71a99"},{"code":"(fn flat [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"509a5884e4b0efbae1fbc0aa"},{"code":"(fn [sq]\n  (letfn [(flat [s]\n                (when-let [c (seq s)]\n                  (let [x (first c)]\n                    (lazy-seq\n                    (if (sequential? x)\n                      (concat (flat x) (flat (rest c)))\n                      (cons x (flat (rest c)))\n                      )))\n                  )\n                )]\n    (flat sq)))","problem":28,"user":"5312452be4b08068f379ecf8"},{"problem":28,"code":"(fn flat[coll] (if (sequential? coll) (mapcat flat coll) [coll]))","user":"53d5d43ce4b0e771c302544d"},{"code":"(fn flatten' [coll]\n  (if-let [s (seq coll)]\n    (let [[fst & rst] s\n          f-rst (flatten' rst)]\n      (if (sequential? fst)\n        (concat (flatten' fst) f-rst)\n        (cons fst f-rst)))\n    coll))","problem":28,"user":"4dade9e9c9a9d6ed4799dc57"},{"problem":28,"code":"(fn f [[h & t]] \n  (cond\n   (nil? h) '()\n   (sequential? h) (concat (f h) (f t))\n   :else (cons h (f t))))","user":"5e6cfc25e4b04a83ad7cd28e"},{"code":"(fn flattify [coll] (reduce\n                        (fn [acc c]\n                          (if (sequential? c)\n                            (apply (partial conj acc) (flattify c))\n                            (conj acc c)\n                                     )\n                          ) [] coll))","problem":28,"user":"53307da1e4b019098a6f8b5e"},{"problem":28,"code":"(fn raze [ls]\n    (if (coll? ls)\n      (mapcat raze ls)\n      [ls]))","user":"5e17bb46e4b00200644e3d5a"},{"problem":28,"code":"(fn flat [a]\n  (if (coll? a)\n    (mapcat flat a)\n    (list a)))","user":"58467633e4b089d5ab817e90"},{"code":"(fn [s]\n       (letfn [(flatten? [s]\n          (or (seq? s) (vector? s)))]\n        (loop [f (first s) r (rest s) x '()]\n          (if (and (not (flatten? f)) (empty? r)) (reverse (cons f x))\n            (if (not (flatten? f))\n              (recur (first r) (rest r) (cons f x))\n              (recur (first f) (if (empty? (rest f)) r (cons (rest f) r)) x)))))\n      )","problem":28,"user":"5029fccee4b023940c84aa47"},{"code":"(fn flt [lst] \n   (let [[x & xs] lst] \n      (if (nil? x)\n        []\n        (if (coll? x)\n          (concat (flt x) (flt xs))\n          (cons x (flt xs))\n        )\n      )\n    )\n )","problem":28,"user":"5131c922e4b06942423563c9"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x)\n)))","user":"582835cbe4b051871117bf30"},{"code":"(fn my-flatten [c]\n  (if (coll? c)\n    (mapcat my-flatten c)\n    [c]))","problem":28,"user":"508923d5e4b06d8254e936e8"},{"problem":28,"code":"(fn [s]\n               (reverse (loop [to-add (first s)\n                               remain (rest s)\n                               result nil]\n                          (if (and (nil? to-add) (empty? remain))\n                               result\n                               (if (coll? to-add)\n                                 (recur (first to-add) (concat (rest to-add) remain) result)\n                                 (recur (first remain) (rest remain) (cons to-add result)))))))","user":"5da8b8ece4b000c986472c28"},{"code":"(fn flat [c1]\r\n    (concat \r\n      (if (coll? (first c1))\r\n        (flat (first c1))\r\n        (into [] [(first c1)]))\r\n      (if (coll? (next c1))\r\n        (flat (next c1)))))","problem":28,"user":"4e9def6b535dbda64a6f6b8f"},{"problem":28,"code":"(fn flat [item]\n  (let [left (first item) right (next item)]\n    (concat (if (sequential? left)(flat left)[left])\n            (when (sequential? right)\n              (flat right)))))","user":"570377c1e4b08d47c97781f1"},{"problem":28,"code":"(fn flat [s]\n     (reduce \n       (fn [col, x]\n         (if (sequential? x)\n           (concat col (flat x))\n           (concat col [x])))\n       []\n       s\n       ))","user":"55c3149de4b0e31453f64987"},{"code":"(fn my-flatten [lst]\n  (if (empty? lst)\n    lst\n    (if (coll? (first lst))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (conj (my-flatten (rest lst)) (first lst)))))","problem":28,"user":"4ff9cfd6e4b0678c553fc3af"},{"problem":28,"code":"(fn my-flatten [xs]\n  (reduce\n   (fn [acc x]\n     (if (coll? x)\n       (concat acc (my-flatten x))\n       (concat acc [x])))\n   []\n   xs))","user":"55f5b8d6e4b06e875b46ce8d"},{"code":"(fn [x]\t\n  (filter (complement sequential?)\n\t\t  (rest (tree-seq sequential? seq x))))","problem":28,"user":"520ed237e4b0101e4be6fcd9"},{"code":"(fn enflatten [x]\n  (if (coll? x)\n      (mapcat enflatten x)\n         [x]))","problem":28,"user":"51db0d99e4b06aa4d4669a9d"},{"problem":28,"code":"(fn flat\n  [coll]\n  (reduce #(concat %1 (if(coll? %2)\n                        (flat %2)[%2])) '() coll))","user":"57c500f9e4b05aa3c4741cda"},{"problem":28,"code":"(fn foo\n  [s]\n  (if (coll? s)\n    (mapcat foo s)\n    [s]))","user":"5bab5440e4b0a20761a23475"},{"code":"(fn flat [acc x]\n  (concat acc\n          (if (coll? x) \n           \t(reduce flat [] x)\n           \t(list x))))\n[]","problem":28,"user":"517adc6ce4b0925c997201c4"},{"problem":28,"code":"(fn flat [xs]\n  (if (coll? xs)\n  \t(apply concat (map flat xs))\n    [xs]))","user":"5a188be3e4b0ff51aa4b31ec"},{"problem":28,"code":"(fn fl [c]\n  (if (coll? c)\n    (mapcat fl c)\n  [c]))","user":"532a033be4b09d4e7a9b551f"},{"code":"(fn flat [object] \n  (let [one (first object) two (next object)]\n    (concat\n      (if (coll? one)\n        (flat one)\n        [one])\n       (if (coll? two)\n         (flat two)\n         (if (nil? two)\n           []\n           [two])))))","problem":28,"user":"520f46f9e4b0101e4be6fcee"},{"problem":28,"code":"(fn flat [xs]\n  (concat\n   \t(if (sequential? (first xs))\n      (flat (first xs))\n      [(first xs)])\n   (when (sequential? (next xs))\n     (flat (next xs)))))","user":"5468033ee4b00cfc9eacc133"},{"problem":28,"code":"(fn sillyflatten\n  [L]\n  ((fn flat [L C]\n     (if (empty? L)\n       C\n       (if (coll? (first L))\n         (flat (rest L) (flat (first L) C))\n         (flat (rest L) (conj C (first L)))\n         ))) L []))","user":"53caddbae4b00fb29b2212cc"},{"problem":28,"code":"(fn [seq]\r\n  (loop [seq seq\r\n         result []]\r\n    (if (empty? seq)\r\n      result\r\n      (let [[head & tail] seq]\r\n        (if (or (list? head) (vector? head))\r\n          (recur (concat head tail) result)\r\n          (recur tail (conj result head)))))))","user":"555bd27ae4b0b056612e2244"},{"problem":28,"code":"(fn fff [[x & xs]]\n  (cond\n    (nil? x) ()\n    (coll? x) (concat (fff x) (fff xs))\n    :else (cons x (fff xs))\n    )\n  )","user":"55f5625de4b06e875b46ce86"},{"problem":28,"code":"(fn f [x]\n  (reduce #(if (coll? %2)\n             (vec (concat % (f %2)))\n             (conj % %2))\n          []\n          x))","user":"53c74cfce4b00fb29b2212a7"},{"code":"#(letfn [(f [x] (if (sequential? x) (reduce concat (list) (map f x)) (list x)))] (f %))","problem":28,"user":"4ed94d69535d10e5ff6f5303"},{"problem":28,"code":"(fn f [[a & b]]\n  (if (seq b)\n    (if (coll? a)\n      (concat (f a) (f b))\n      (concat [a] (f b)))\n    (if (coll? a)\n      (f a)\n      [a])))","user":"54b2ec84e4b09f271ff37d33"},{"problem":28,"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (cond\n          (empty? n) '()\n      (coll? x) (concat (flat x) (flat xs))\n      :else (cons x (flat xs)))))","user":"54d70f40e4b0a52adc2e2027"},{"problem":28,"code":"(fn [arg] (filter (complement sequential?) (tree-seq sequential? identity arg)))","user":"570ab24fe4b0b0fb43fd06b7"},{"problem":28,"code":"(fn flat[[x & xs]]\n    (let [f  (if (sequential? x) (flat x) [x])]\n      (if (nil? xs) f (concat f (flat xs)))))","user":"5d0cf1c8e4b0cc9c91588246"},{"problem":28,"code":"(fn fl[x]\n  (loop [i 0 s []]\n    (if (< i (count x))\n      (let [e (nth x i)]\n        (recur (+ i 1)\n               (if (sequential? e) (concat s (fl e)) (conj (vec s) e))\n        ))s\n    )\n  )\n)","user":"514504c2e4b021a5ff8301fc"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (mapcat my-flatten x)\n    \t[x]))","user":"5a99b87ee4b0d174b936c7af"},{"code":"(fn flatten1 [coll]\n    (if (coll? coll)\n      (mapcat flatten1 coll)\n      [coll]))","problem":28,"user":"4da8dd6e30acd6ed12482a68"},{"problem":28,"code":"(fn f [i]\n   (loop [s i r []]\n     (if-let [e (first s)]\n       (recur (rest s)\n              (if (coll? e)\n                (apply conj r (f e))\n                (conj r e)))\n       r)))","user":"568227fee4b0945ebc182a8a"},{"code":"(fn fl\r\n  ([x & xs] (into (fl x)(fl xs)))\r\n  ([x] (if (sequential? x) (apply fl x) [x])))","problem":28,"user":"4e994541535dbda64a6f6b64"},{"code":"#(letfn [(fl [acc, a] \n  (if (coll? a)\n    (reduce fl acc a)\n    (conj acc a)))]\n(reduce fl [] %))","problem":28,"user":"50431cbce4b034ff00315d1c"},{"problem":28,"code":"(fn flat [items]\n  (reduce (fn [all item]\n            (concat all (if (sequential? item)\n              (flat item)\n              [item]))) [] items))","user":"5674f874e4b05957ce8c6144"},{"problem":28,"code":"(fn flat\n  ([el] \n    (if (coll? el)\n      (apply flat el)\n      (list el)))\n  ([el & els]\n    (concat (flat el) (flat els)))\n)","user":"5b62764ae4b0c6492753e725"},{"code":"(fn [coll]\n  (loop [[f & fs] coll\n         stack []\n         result []]\n    (cond\n     (nil? f) (if (empty? stack) result (recur (first stack) (rest stack) result))\n     (coll? f) (recur f (cons fs stack) result)\n     :else (recur fs stack (conj result f)))))","problem":28,"user":"50ed3c6be4b01236b1d4983b"},{"problem":28,"code":"(fn flat [[x & xs :as all]]\n  (if (seq all)\n  \t(concat (if (sequential? x) (flat x) (list x)) (flat xs))\n    (list)))","user":"55a12668e4b0acc240e3150b"},{"problem":28,"code":"reduce (fn fltn [acc el] (\n   if (coll? el) (reduce fltn acc el)\n   (conj acc el))) '[]","user":"542b0592e4b0dad94371f286"},{"problem":28,"code":"(fn flat [coll] (when-let [s (seq coll)] (let [h (first s)] (if (coll? h) (concat (flat h) (flat (rest s))) (cons h (flat (rest s)))))))","user":"55f4ef68e4b06e875b46ce82"},{"problem":28,"code":"(fn [elems](letfn [\n      (flat [elems] \n            (reduce #(cond \n                      (coll? %2) (into %1 (flat %2)) \n                      :else      (conj %1 %2)) \n                    [] elems))\n] (flat elems)))","user":"57ce3fede4b0c746388ab8a6"},{"code":"(fn har-flag[input] \n          (let [l (first input) r (next input)] \n               (concat \n                (if (sequential? l)\n                    (har-flag l)\n                    [l]) \n                (when (sequential? r)\n                  (har-flag r)))))","problem":28,"user":"51950793e4b09df09a77a3e4"},{"code":"(fn fltn [x]\n  (mapcat #(if (sequential? %) (fltn %) [%]) x)\n)","problem":28,"user":"4e749e84535d7a570dd295b9"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (not (sequential? f)) (cons f (my-flatten r))\n          ;; (sequential? f)\n          :else (concat (my-flatten f) (my-flatten r)))))","user":"559f06bae4b0acc240e314e6"},{"code":"(fn iron [coll]\n  (let [flat? (fn [coll]\n                (reduce #(and %1 %2) true (map (complement coll?) coll)))]\n    (loop [result [], coll coll]\n      (cond (empty? coll) result\n            (not (coll? (first coll))) (recur (conj (vec result) (first coll)) (rest coll))\n            (flat? (first coll)) (recur (concat result (first coll)) (rest coll))\n            :else (recur (concat result (iron (first coll))) (rest coll))))))","problem":28,"user":"4edab806535d10e5ff6f5311"},{"problem":28,"code":"(fn [col]\n  (filter #(not (nil? %))\n          (map #(if (coll? %) nil %)\n               (tree-seq coll? identity col))))","user":"53b22df6e4b047364c044497"},{"problem":28,"code":"#(loop [in % out []]\n    (cond\n      (empty? in) out\n      (sequential? (first in)) (recur (concat (seq (first in)) (rest in)) out)\n      :default (recur (rest in) (conj out (first in)))))","user":"5d0e58ede4b0cc9c91588254"},{"problem":28,"code":"(fn conj1\n  [elements]\n  (reduce\n    #(if (sequential? %2)\n       (into %1 (conj1 %2))\n       (conj %1 %2))\n    []\n    elements))","user":"57625c18e4b0994c1922fba4"},{"problem":28,"code":"(fn flat\n  [coll]\n  (reduce (fn [x y]\n            (let [fy (if (coll? y)\n                       (flat y)\n                       [y])]\n              (concat x fy)))\n          [] coll)\n  )","user":"579601c8e4b0e215f87e8492"},{"problem":28,"code":"(fn [arg1]\n(cond\n(and (= arg1 (quote ((1 2) 3 [4 [5 6]])))) (quote (1 2 3 4 5 6))\n(and (= arg1 [\"a\" [\"b\"] \"c\"])) (quote (\"a\" \"b\" \"c\"))\n(and (= arg1 (quote ((((:a))))))) (quote (:a))\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn f [col]\n  (mapcat #(if (coll? %)(f %) [%]) col))","problem":28,"user":"4db2cc55535df7e46ed9b6c5"},{"code":"(fn [q] \n  (letfn \n    [(fltn [a]\n      (loop [ret [] [x & xs] a] \n        (if x\n          (if (or (seq? x) (vector? x))\n            (recur (concat ret (fltn x)) xs)\n            (recur (concat ret (vector x)) xs)\n            )\n          ret)))]\n    (fltn q)))","problem":28,"user":"4e74e119535d7a570dd295bc"},{"code":"(fn \n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"5040edf4e4b0ff5d2cc40db5"},{"problem":28,"code":"(fn my-flatten-it\n    [seq]\n    (into [] (reduce (fn [result item]\n              (do\n              (println (str result))\n              (if (coll? item)\n                (concat result (my-flatten-it item))\n                (concat result [item]))\n                ))\n            []\n            seq)\n))","user":"602f56c5e4b0d5df2af22297"},{"code":"(fn f [c]\n  (if (sequential? c)\n    (mapcat f c)\n    (list c)))","problem":28,"user":"539c64cde4b0b51d73faaf2a"},{"code":"(fn flat [xs] (reduce #(concat %1 (if (coll? %2) (flat %2) [%2])) [] xs))","problem":28,"user":"4f4f0287e4b03ad3f0c10cd7"},{"code":"(fn flt [[first & rest]]\n  (if (coll? first)\n    (flt (lazy-cat first rest))\n    (lazy-seq (cons first (when rest (flt rest))))))","problem":28,"user":"4fc66c43e4b0ee37620e1812"},{"code":"(fn myflatten [list]\n  (cond\n   (empty? list) list\n   (coll? (first list))\n   (concat (myflatten (first list))\n           (myflatten (rest list)))\n   :else (cons (first list)\n               (myflatten (rest list)))))","problem":28,"user":"5005b57de4b0678c553fc46a"},{"problem":28,"code":"; see https://clojuredocs.org/clojure.core/flatten at the bottom\n(fn flatten2 [x]\n  (letfn [(flat [coll]\n            (lazy-seq\n              (when-let [c (seq coll)]\n                (let [x (first c)]\n                  (if (sequential? x)\n                    (concat (flat x) (flat (rest c)))\n                    (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","user":"5f0824c5e4b0cf489e8d7f5b"},{"code":"(fn flatten' [x]\n    (if (empty? x) \n      x\n      (let [head (first x)\n            tail (rest x)]\n        (println head tail)\n        (cond\n          (sequential? head) (concat (flatten' head) (flatten' tail))\n          :else (cons head (flatten' tail))))))","problem":28,"user":"50b61e7ae4b0e3a8b79a9a68"},{"problem":28,"code":"(fn flat [n]\n  (if (empty? n)\n    []\n    (let [t (first n)]\n      (if (coll? t)\n        (concat (flat t) (flat (rest n)))\n        (cons t (flat (rest n)))))))","user":"5703eda3e4b08d47c9778200"},{"code":"(fn flat [coll]\n  (loop [r '() coll coll]\n    (if (empty? coll)\n        r\n        (if (coll? (first coll))\n          (recur (concat r (flat (first coll))) (rest coll))\n          (recur (concat r [(first coll)])      (rest coll))))))","problem":28,"user":"50705886e4b07bd6ad9b9f2a"},{"problem":28,"code":"(fn flat\n  ([li] (flat li (vector)))\n  ([li ans] (if (empty? li)\n              ans\n              (let [f (first li) r (rest li)]\n                    (if (coll? f)\n                \t\t(flat r (flat f ans))\n                \t\t(flat r (conj ans f))\n                      )\n                )\n              )\n   )\n  )","user":"5a90395ce4b05369db4d254a"},{"problem":28,"code":"(fn [s] (reduce \n          (fn my-flatten [c x] \n            (if (coll? x) \n              (reduce my-flatten c x)\n              (conj c x) \n              )\n            ) \n          [] \n          s))","user":"586c6462e4b01531a375e97b"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll)\n        r (next coll)]\n    (concat \n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n       (flt r)))))","user":"55cbd29be4b0e31453f64a0a"},{"code":"(fn rec [lst]\n  (if (empty? lst)\n\t[]\n\t(if (or (vector? (first lst)) (seq? (first lst)))\n      (concat (rec (first lst))\n              (rec (rest lst)))\n      (cons (first lst) (rec (rest lst))))))","problem":28,"user":"52cc09c1e4b07d0d72b27356"},{"problem":28,"code":"(fn my-flatten [coll]\n  (mapcat (fn [x]\n            (if (coll? x)\n              (my-flatten x)\n              (list x)))\n          coll))","user":"56ba1406e4b0f2655033593c"},{"problem":28,"code":";; (fn [c]\n;;     (if (some sequential? c)\n;;       (recur (apply concat\n;;                     (map #(if (sequential? %) % (list %)) c)))\n;;       c))\n\n;; #(filter (complement sequential?)\n;;            (rest (tree-seq sequential? seq %)))\n\n;; (fn flatten-* [x]\n;;     (if (coll? x)\n;;       (mapcat flatten-* x)\n;;       [x]))\n\n\n(fn [c]\n    (if (some sequential? c)\n      (recur (mapcat #(if (sequential? %) % (list %)) c))\n      c))","user":"591ad160e4b09b4ee5954bdf"},{"problem":28,"code":"(fn fltn [s]\n\t(reduce\n\t\t(fn [a c] \n\t\t\t(if (coll? c)\n\t\t\t\t(concat a (fltn c))\n\t\t\t\t(concat a (list c)) \n\t\t\t)\n\t\t)\n\t'()\n\ts)\n)","user":"5810b899e4b0f478707a05d8"},{"problem":28,"code":"(fn flatten-myself [given-sequence]\n  (if (sequential? given-sequence)\n    (mapcat flatten-myself given-sequence)\n    [given-sequence]\n    )\n  )","user":"566639f4e4b0e91d5f5c566b"},{"problem":28,"code":"(fn flat[x]\n  (filter\n    (complement sequential?)\n    (tree-seq sequential? seq x )))","user":"56f18d0ce4b04a395b9a0496"},{"problem":28,"code":"(fn[sq] (filter (complement sequential?) (rest (tree-seq sequential? seq sq))))","user":"5d045162e4b0cc9c915881d3"},{"code":"(fn flat [x]\n    (if (sequential? x)\n      (mapcat flat x)\n      [x]))","problem":28,"user":"538fe131e4b0b51d73faae91"},{"problem":28,"code":"(fn flt [sq] (if (sequential? sq) (mapcat flt sq) (list sq)))","user":"54543484e4b0e397800069d4"},{"problem":28,"code":"(fn f [s]\n  (mapcat #(if (coll? %) (f %) [%]) s))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":28,"code":"(fn [x]\n  (loop [coll x acc ()]\n    (if (empty? coll)\n      acc\n      (let [newcoll (loop [coll coll]\n                      (if-not (sequential? (first coll))\n                        coll\n                        (recur (concat (first coll) (rest coll)))))]\n        (recur (rest newcoll) (concat acc `(~(first newcoll))))))))","user":"54ad4863e4b09f271ff37ce0"},{"code":"(fn my-flatten [a-seq]\n  (if (sequential? a-seq)\n    (mapcat my-flatten a-seq)\n    (list a-seq)))","problem":28,"user":"52ee46e5e4b05e3f0be25ec5"},{"code":"(fn [input]\n  (letfn [(my-flatten \n            [input output]\n            (reduce \n              (fn [coll x]\n                 (if (sequential? x)\n                   (my-flatten x coll)\n                   (cons x coll))) output input))]\n    (reverse (my-flatten input '()))))","problem":28,"user":"5084c43be4b0fb8f40674bfa"},{"problem":28,"code":"(\n\t\tfn myFlatten[x]  \n\t\t(\n\t\t\tif (sequential? (first x))\n\t\t\t(\n\t\t\t\tconcat (myFlatten (first x)) (myFlatten (rest x))\n\t\t\t)\n\t\t\t(\n\t\t\t\tif(> (count x) 0)\n\t\t\t\t(\n\t\t\t\t\tcons (first x) (myFlatten (rest x))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"548018ede4b0c51c1f4d7334"},{"code":"(fn [s]\n  (if (not-any? coll? s)\n    s\n    (let [flat-start (take-while (comp not coll?) s)\n          after-flats (drop-while (comp not coll?) s)\n          coll-element (first after-flats)\n          others (rest after-flats)]\n      (recur (concat flat-start coll-element others)))))","problem":28,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":28,"code":"(fn t[x] (cond\n          (not (coll? x)) (list x)\n          (empty? x) '()\n          :else (concat (t (first x)) (t (rest x)))\n          )\n  )","user":"583019b8e4b051871117bfff"},{"problem":28,"code":"(fn [coll]\n  ((fn self [i s acc]\n     (if (not (coll? s))\n       [s]\n       (if (= i (count s))\n         acc\n         (let [e (self 0 (nth s i) [])]\n           (self (inc i) s (concat acc e)))))) 0 coll []))","user":"5512aca6e4b055c2f668d4b4"},{"problem":28,"code":"(fn [coll]\n  (loop\n    [coll coll]\n    (if (not-any? coll? coll)\n      coll\n      (recur (mapcat #(if (coll? %) % (list %)) coll)))))","user":"55c66d3de4b0e31453f649c1"},{"code":"(fn ! [xs]\n       (mapcat #(if (coll? %)\n  \t  (! %)\n\t\t  (list %))\n\t       xs))","problem":28,"user":"4ec6157b535d6d7199dd36c2"},{"problem":28,"code":"(fn my-flat [s]\n  (if (empty? s) []\n\t(concat\n     (if (sequential? (first s))\n       (my-flat (first s))\n       [(first s)])\n     (my-flat (rest s)))))","user":"54c5e36ee4b045293a27f626"},{"problem":28,"code":"#(loop [input % results '()]\n          (cond\n            (empty? input) results\n            (sequential? (first input)) (recur (concat (first input) (rest input)) results)\n            :else (recur (rest input) (concat results [(first input)]))\n            ))","user":"58134ba8e4b0f478707a060b"},{"problem":28,"code":"(fn f\n    [s]\n    (cond\n        (empty? s) '()\n        (coll? (first s)) (concat (f (first s)) (f (rest s)))\n        :else\n        (conj (f (rest s))  (first s))\n        )\n)","user":"6074f5ede4b069485764de52"},{"problem":28,"code":"(fn my-flatten [[head & tail :as coll]]\n  (if (seq coll)\n    (if (coll? head)\n      (concat (my-flatten head) (my-flatten tail))\n      (cons head (my-flatten tail)))\n    (list)))","user":"577f635be4b0d36ec5835e64"},{"code":"(fn [x] (filter #(not(coll? %)) (tree-seq coll? identity x)))","problem":28,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":28,"code":"(fn re [[x & xs]]\n  (let [a (if (coll? x)\n           (re x)\n           [x])]\n    (concat a (if xs (re xs)))))","user":"56946d43e4b0dcc4269f411e"},{"problem":28,"code":"(fn [s]\n  \n  (loop [flattened []\n          elem s]\n    (if (empty? elem)\n      flattened\n      (if (sequential? (first elem))\n        (recur flattened (concat (first elem) (rest elem)))\n        (recur (conj flattened (first elem)) (rest elem))\n        )\n      )))","user":"545b0275e4b01be26fd74648"},{"code":"(fn my-flatten [xs]\n  (if-not (coll? xs)\n     (list xs)\n     (mapcat (fn [x] (my-flatten x)) xs)))","problem":28,"user":"4f6bab49e4b07046d9f4efb1"},{"problem":28,"code":"(fn flt\n  [sequence]\n  (if (sequential? sequence)\n    (mapcat flt sequence)\n    (list sequence)\n    )\n)","user":"52c70127e4b0c2d177d6211a"},{"problem":28,"code":"(fn [c]\n  ((fn flat [cl]\n     (reduce (fn [acc item]\n               (if (coll? item)\n                 (apply conj acc (flat item))\n                 (conj acc item)))\n             []\n             cl))\n   c))","user":"5c30da5ae4b0d62ef62d9f23"},{"problem":28,"code":"(fn [l]\n   ((fn [from pf to]\n      (let [e (first from),\n            r (rest from)]\n        (cond\n          (and (empty? from) (empty? pf)) to\n          (empty? from) (recur (first pf) (pop pf) to)\n          (coll? e) (recur e (conj pf r) to)\n          :else (recur r pf (conj to e))))) l '() []))","user":"5d6a975be4b04d129b00f29b"},{"problem":28,"code":"(fn f [ls]\n  (loop [ls ls\n            acc nil]\n     (cond (empty? ls) acc\n               (coll? (first ls)) (concat (f (first ls)) (f (rest ls)))\n                :else (concat (list (first ls)) (f (rest ls))))))","user":"56903cb9e4b0dcc4269f40eb"},{"code":"(fn [x]\r\n(if (not (some sequential? x)) x\r\n  (recur \r\n    (reduce \r\n      #(if (sequential? %2) (into %1 %2) (conj %1 %2))\r\n      '[]\r\n      x)\r\n  )))","problem":28,"user":"4f8ab084e4b02e764a0a5171"},{"problem":28,"code":"(fn f [l] (cond\n           (empty? l) l\n           (sequential? (first l)) (concat (f (first l)) (f (rest l)))\n           :else (cons (first l) (f (rest l)))))","user":"53a0ab8ce4b0ca733b9744b3"},{"code":"(fn flatten*\n  [col]\n  (mapcat #(if (sequential? %) (flatten* %)  [%] ) col))","problem":28,"user":"4f3e2fbbe4b0e243712b1f7e"},{"code":"#(loop [in %1 out '()] \r\n    (if (empty? in)\r\n      (reverse out)\r\n      (if (coll? (first in))\r\n        (recur (concat (first in) (rest in)) out)\r\n        (recur (rest in) (conj out (first in))))))","problem":28,"user":"4f3c772de4b0e243712b1f4c"},{"code":"(fn flat[coll]\n  (reduce (fn [xs x]\n            (apply conj xs (if (sequential? x) (flat x) [x]))) [] coll))","problem":28,"user":"52c61564e4b0c2d177d62109"},{"code":"(fn [x]\n  (loop [item x all nil acc []]\n    (cond\n      (nil? item) acc\n      (not (coll? item)) (recur (first all)(rest all)(conj acc item))\n      (empty? item)(recur (first all)(rest all) acc)\n      :else(recur (first item) (conj all (rest item)) acc))))","problem":28,"user":"4ea5e794535d7eef308072df"},{"code":"(fn anon [x]\n  (cond\n    (empty? x) []\n    (coll? (first x)) (into (anon (first x)) (anon (rest x)))\n    true (into [(first x)] (anon (rest x)))))","problem":28,"user":"503cc8cae4b06c4e0e1fa251"},{"problem":28,"code":"(comp reverse (fn flato \n  ([sq] (flato sq '()))\n  ([sq flat] \n   (let [fst (first sq)]\n     (if (nil? fst)\n       flat\n       (if (or (seq? fst) (vector? fst))\n         (let [combined (flato fst flat)]\n           (recur (rest sq) combined))\n         (do \n           (recur (rest sq) (conj flat fst)))))))))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"#(reverse ( (fn flattener\n  [unflat, flat]\n  (println \"flattener: \" unflat flat)\n  (if (nil? unflat)\n     flat\n    (if (or (vector? unflat) (seq? unflat))\n    ;; if seq run flat on everything in seq\n      (loop [x unflat, y flat]\n        (println x y)\n        (if (nil? x)\n           y\n          (recur (next x) (flattener (first x) y))))\n    ;;else \n    (cons unflat flat)))) \n            % '()))","problem":28,"user":"512c0f84e4b03a42b6300232"},{"code":"#(filter (complement sequential?)\r\n    (rest (tree-seq sequential? seq %)))","problem":28,"user":"506717e2e4b03d366d7cb2ba"},{"code":"(fn [coll] \r\n (letfn [(f [c] (loop [r [] c c]\r\n  \t   (if (empty? c)\r\n\t\t     r\r\n\t\t     (if (sequential? (first c))\r\n\t\t       (recur (into r (f (first c))) (rest c))\r\n\t\t       (recur (conj r (first c)) (rest c))))))]\r\n    (f coll)))","problem":28,"user":"4e513ecf535dc968683fc4f6"},{"problem":28,"code":"#(letfn [(flat [pred elem] (if (coll? elem) (reduce flat pred elem) (conj pred elem)))]\n   (reduce flat [] %))","user":"5a9a12d6e4b0d174b936c7b7"},{"problem":28,"code":"(fn [c]\n  (letfn [(f [x y]\n            (reduce (fn [m n] (if (sequential? n) (f m n) (conj m n))) x y))]\n    (f [] c)))","user":"5b5e7953e4b0c6492753e6d9"},{"problem":28,"code":"(fn flat [coll]\n (reduce \n  #(if (coll? %2) \n    (into %1 (flat %2))\n    (conj %1 %2))\n  []\n  coll))","user":"5a23503fe4b0ff51aa4b32d6"},{"problem":28,"code":"(fn flat [xs]\n  (if (sequential? xs)\n    (mapcat flat xs)\n    (list xs)\n  )\n)","user":"55f90d76e4b03cbcff9738bd"},{"problem":28,"code":"(fn f\n  ([coll]\n   (f coll '()))\n  ([coll result]\n   (let [e (first coll)]\n     (cond (nil? e) (reverse result)\n           (sequential? e) (f (rest coll) (concat (reverse (f e)) result))\n           :else (recur (rest coll) (conj result e))))))","user":"55507a1ae4b00713264bd9a7"},{"problem":28,"code":"(fn my-flatten [l] \n  \"free of StackOverflow problem, not lazy and much faster version of flatten.\"\n(loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"54d61052e4b0a52adc2e2016"},{"problem":28,"code":"(fn [coll]\n   ((fn iter-iter [c]\n      (cond (empty? c) nil\n            (sequential? (first c)) (concat (iter-iter (first c))\n                                            (iter-iter (rest c)))\n            :else (cons (first c) (iter-iter (rest c)))))\n    coll ))","user":"5fb544f6e4b08cb800c85b4e"},{"problem":28,"code":"(fn flatten-seq\n  [input]\n  (reduce\n   (fn [new-seq element]\n     (if (coll? element)\n       (into new-seq (flatten-seq element))\n       (conj new-seq element)))\n   []\n   input))","user":"5ac6099ee4b0e27600da7757"},{"code":"(fn flat [l]\n  (loop [r l\n         result []]\n    (if (nil? r)\n      result\n      (let [[x & xs] r]\n        (recur xs \n               (if (coll? x)\n                 (into result (flat x))\n                 (conj result x)))))))","problem":28,"user":"4e5f08c7535d8a8b8723a2da"},{"code":"(fn f [s] (if (sequential? s) (mapcat f s) [s]))","problem":28,"user":"4e8516d0535db62dc21a62e8"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (let [left (first s)\n        right (next s)]\n    (concat\n      (if (sequential? left)\n        (my-flatten left)\n        [left])\n      (when (sequential? right)\n        (my-flatten right)))))","user":"4f95900ce4b0dcca54ed6cd3"},{"code":"(fn f [coll]\r\n  (if (sequential? coll)\r\n    (if (> (count coll) 1)\r\n      (into (f (first coll)) (f (rest coll)))\r\n      (f (first coll)))\r\n    (vector coll)))","problem":28,"user":"4facff22e4b081705acca230"},{"problem":28,"code":"(fn my_flatten [x] \n    ((fn [list elem] \n        (if (sequential? elem) \n            (if (empty? elem)\n                list\n                (concat list (my_flatten (first elem)) (my_flatten (rest elem))))\n            (conj list elem))\n     ) [] x)\n)","user":"5b67f0fbe4b0c6492753e76d"},{"problem":28,"code":"(fn flat [c] (if (coll? c) (mapcat flat c) [c]))","user":"541096bde4b01498b1a719b2"},{"code":"(fn saca [l] (cond (empty? l) nil (sequential? (first l)) (concat (saca (first l)) (saca (rest l))) true (concat (list (first l)) (saca (rest l)))))","problem":28,"user":"4ef355e3535dced4c769f228"},{"code":"(fn flt [s]\n  (let [l (first s) r (next s)]\n    (concat \n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n       (flt r)))))","problem":28,"user":"51ac80bbe4b09397d5109770"},{"code":"#(filter \r\n  (complement sequential?)\r\n  (tree-seq sequential? seq %))","problem":28,"user":"4dda5d07535d02782fcbe9f2"},{"code":"(fn flat [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      '()\n      (concat (flat (first xs)) (flat (rest xs))))\n    (list xs)))","problem":28,"user":"504e13fce4b078edc5f593bc"},{"code":"(fn flat [[h & t]]\n  (if (sequential? h)\n    (concat (flat h) (flat t))\n    (if (sequential? t)\n      (cons h (flat t))\n      (if (not (nil? h)) \n        (list h)))))","problem":28,"user":"527b8881e4b03e8d9a4a758e"},{"code":"(fn mf [xs]\n  (if (empty? xs) \n    xs\n    (let [[x & xs] xs]\n      (if (or (vector? x) (list? x)) \n        (concat (mf x) (mf xs))\n        (cons x (mf xs))))))","problem":28,"user":"527236d4e4b03e8d9a4a741f"},{"problem":28,"code":"(fn flat [s]\n  (reduce\n   (fn [acc x]\n     (concat acc\n             (if (sequential? x) (flat x) [x])))\n   [] s))","user":"552a793ee4b0ffed3738f955"},{"problem":28,"code":"#(filter\n    (fn [x] (not (sequential? x)))\n    (tree-seq sequential? identity %))","user":"522a5bdde4b0590a43906cf8"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) \n                (tree-seq sequential? seq x)))","user":"54058af3e4b0addc1aec6669"},{"problem":28,"code":"(fn myflat [s]\n\t(let [f (first s), r (rest s)]\n\t\t(if (empty? r)\n\t\t\t(if (coll? f) (myflat f) [f])\n\t\t\t(if (coll? f) \n\t\t\t\t(concat (myflat f) (myflat r))\n\t\t\t\t(concat [f] (myflat r))))\n\t\t))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn [x]\r\n   (filter (complement sequential?)\r\n      (rest (tree-seq sequential? seq x))))","problem":28,"user":"4ddee37c535d08e6dec9fddc"},{"problem":28,"code":"(fn flatten-collection\n  ([collection]\n   (flatten-collection collection []))\n  ([[head & tail] result]\n   (if (nil? head)\n     result\n     (do\n       (let [x (if (coll? head)\n                 (flatten-collection head result)\n                 (conj result head))]\n         (flatten-collection tail x))))))","user":"57d0cd58e4b0bd073c20235e"},{"problem":28,"code":"(fn [a-seq]\n  (filter (complement coll?) (tree-seq coll? identity a-seq)))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn fib [x] (if (= x '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6) (if (= x [\"a\" [\"b\"] \"c\"]) '(\"a\" \"b\" \"c\") (if (= x '((((:a))))) '(:a)))))","problem":28,"user":"4f4d44f8e4b03ad3f0c10ca5"},{"code":"(fn [x] (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"50b29496e4b03ea880433564"},{"problem":28,"code":"(fn flat [s]\n        (cond\n         (= () s) nil\n         (sequential? s) (concat (flat (first s)) (flat (rest s)))\n         :else (list s)))","user":"54c968bfe4b045293a27f66f"},{"code":"(fn f [x] (if (sequential? x) (mapcat f x) [x]))","problem":28,"user":"4e5a5ecb535d8a8b8723a2ac"},{"code":"(fn my-flatten [coll]\n  (letfn [(flt [c s]\n            (loop [x (first c) c (rest c) s s]\n              (if x\n                (recur (first c) (rest c) (if (coll? x) (flt x s) (conj s x)))\n                s)))]\n    (flt coll [])))","problem":28,"user":"4ebf45c3535dfed6da9c6d9d"},{"code":"(fn my-flatten \n  [coll]\n  (when-let [s (seq coll)]\n    (if (coll? (first s))\n      (concat (my-flatten (first s)) (my-flatten (rest s)))\n      (cons (first s) (my-flatten (rest s))))))","problem":28,"user":"50fc48dde4b0d10d794c19f6"},{"problem":28,"code":"(fn myflat [coll]\n  (filter (complement coll?) (tree-seq coll? identity coll)))","user":"5462caf5e4b01be26fd746b7"},{"problem":28,"code":"(fn f [s] \n    (apply concat \n           (map \n            (fn [e] \n              (if (sequential? e) \n                (f e) \n                (repeat 1 e) \n                ))s\n            )))","user":"55815973e4b05c286339e0f6"},{"problem":28,"code":"(fn [a]\n  (loop [result (vec a)]\n    (if (not-any? sequential? result) \n      result\n      (recur (reduce #(if (sequential? %2) (concat %1 %2) (concat %1 [%2])) [] result))\n    )\n  ))","user":"5700f1f0e4b08d47c97781ce"},{"code":"(fn flattenSeq [l]\n  (cond\n   (empty? l)\n   l\n   (coll? (first l))\n   ((fn append [l, m]\n      (cond\n       (empty? l)\n        m\n       (empty?\n        (rest l))\n       (cons\n        (first l)\n        m)\n       :else\n       (cons\n        (first l)\n        (append\n         (rest l)\n         m))))\n    (flattenSeq\n     (first l))\n    (flattenSeq\n     (rest l)))\n   :else\n   (cons\n    (first l)\n    (flattenSeq\n     (rest l)))))","problem":28,"user":"50d2fa5ce4b049d4ed5650cf"},{"code":"(fn [s] (remove #(sequential? %) (tree-seq sequential? sequence s)))","problem":28,"user":"52bb81d7e4b07a9af57922e8"},{"code":"(fn flat [l]\n\t\t\t(if (coll? l)\n\t\t\t\t\t(mapcat flat l)\n\t\t\t\t\t(list l)))","problem":28,"user":"5252b59de4b0541d1855b8cf"},{"problem":28,"code":"(fn my [l] \n\t(loop  [i l \n\t\t    result []]\n\t\t(cond\n\t\t\t(sequential? (first i)) (recur (concat (first i) (rest i)) result)\n\t\t\t(empty? i) result\n\t\t\t:else (recur (rest i) (conj result (first i))) \n\t\t)\n\t) \n)","user":"5587d8b3e4b059ccff29b1e8"},{"problem":28,"code":"(fn flt \n     ([x] \n       (if (coll? x)\n         (apply flt x)\n             (list x)))\n   ([x & y]\n     (concat (flt x) (flt y))))","user":"581a5fdbe4b0e114eb51a002"},{"problem":28,"code":"(partial reduce (fn sdf [acc el] (if (sequential? el) (reduce sdf acc el) (conj acc el))) [])","user":"56b35565e4b0982f16b37e16"},{"code":"(fn [xs]\n  (letfn [(flat [l x]\n    (if (coll? x) (apply conj l (reduce flat '[] x))\n                   (conj l x)))]\n                   (seq (reduce flat '[] xs))))","problem":28,"user":"4f748b54e4b044e54cd9a8fa"},{"code":"(fn [coll]\r\n  (loop [c coll]\r\n    (let [ newcoll (reduce #(if (coll? %2) (into %1 %2) (conj %1 %2)) []  c)]\r\n      (if (reduce #(if %1 %1 (coll? %2)) false newcoll)\r\n        (recur newcoll)\r\n        newcoll))))","problem":28,"user":"4e79ff2a535db169f9c796a9"},{"problem":28,"code":"(fn my-flatten [col]\n   (let [[h & r :as col] col]\n     (cond\n       (empty? col) '()\n       (coll? h) (concat (my-flatten h) (my-flatten r))\n       :else (cons h (my-flatten r)))))","user":"50a3ad0ee4b0ceace084d493"},{"code":"(fn my-flatten [coll]\n  (reduce #(if (coll? %2)\n             (into %1 (my-flatten %2))\n             (conj %1 %2))\n          [] coll))","problem":28,"user":"5298cc88e4b02ebb4ef75065"},{"code":"(fn f[x]\n  (if (empty? x)\n    x\n    (if (sequential? (first x))\n      (concat (f (first x)) (f (rest x)))\n      (cons (first x) (f (rest x)))\n    )\n  )\n)","problem":28,"user":"50512f61e4b0b30bd8f4f83f"},{"code":"(fn flt [l] (if (sequential? l) (if (> (count l) 1)\n        (concat (flt (first l)) \n                (flt (rest l)))\n        (flt (first l)))\n        (list l)))","problem":28,"user":"504ffa26e4b0a02f9cffdead"},{"problem":28,"code":"(fn flatten' [xs]\n  (if (coll? xs)\n    (mapcat flatten' xs)\n    [xs]))","user":"57275898e4b0c5bde472c13e"},{"problem":28,"code":"(fn my-flatten [coll] (reverse (reduce #(into %1 (if (coll? %2) (my-flatten %2) (list %2))) '() coll)))","user":"55218bf0e4b0882d96d09196"},{"problem":28,"code":"(fn flat [coll]\n  (let [f (first coll)\n        r (next coll)]\n    (concat\n     (if (sequential? f)\n       (flat f)\n       [f])\n     (when (sequential? r)\n       (flat r)))))","user":"54ab1b5ae4b09f271ff37cc2"},{"code":"(fn f [s] (if (or (seq? s) (vector? s)) (mapcat f s) (list s)))","problem":28,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":28,"code":"(fn flatten* [x]\n    (if (coll? x)\n      (mapcat flatten* x)\n      [x]))","user":"5ccf99fbe4b0ccb0619628c8"},{"code":"#(filter (complement sequential?)\r\n  (rest (tree-seq sequential? seq %)))","problem":28,"user":"4db6ce85535d1e037afb217f"},{"code":"(fn [seq]\n  (letfn [(go [seq]\n           \t  (reduce (fn [x y] (concat x (if (coll? y) (go y) [y])))\n               \t      []\n                   \t  seq))\n          ]\n    (go seq)))","problem":28,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":28,"code":"(fn flatten* [coll]\n  (if (empty? coll)\n    '()\n    (let [[head & rest] coll]\n      (if (sequential? head)\n        (concat (flatten* head) (flatten* rest))\n        (conj (flatten* rest) head)))))","user":"5c987160e4b048ec896c5a82"},{"problem":28,"code":"(fn [s]\n  (loop [sx s, acc `()]\n    (cond\n      (sequential? (first sx)) (recur (concat (first sx) (rest sx)) acc)\n      (empty? sx) (reverse acc)\n      :else (recur (rest sx) (cons (first sx) acc)))))","user":"56035afae4b04bb52996e1b9"},{"code":"(fn flatten-1 [coll]\n  (reduce \n    #(if (coll? %2)\n      (into %1 (flatten-1 %2))\n      (conj %1 %2)) \n    [] \n    coll))","problem":28,"user":"501c1492e4b086d93747d180"},{"code":"(fn flatten* [xs]\n  (if (sequential? xs)\n    (apply concat (map flatten* xs))\n    (list xs)))","problem":28,"user":"4ef41f26535dced4c769f230"},{"code":"(fn [x]\n    (letfn [(fl [s]\n      (prn s)\n      (if (empty? s)\n        '()\n        (if (coll? (first s))\n           (concat (fl (first s)) (fl (rest s)))\n           (concat (list (first s)) (fl (rest s))))))]\n       (fl x)))","problem":28,"user":"4f03193e535dcb61093f6a61"},{"problem":28,"code":"(fn [c] (remove sequential?\n                (tree-seq sequential? seq c)))","user":"56e2dbf4e4b03a7c14b85a3b"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (if (sequential? coll)\n    (mapcat my-flatten coll)\n    (list coll)))","user":"568bd448e4b0dcc4269f40a9"},{"code":"(fn [x]\n  (filter #(not (sequential? %))\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f9c7b0fe4b0dcca54ed6d1c"},{"problem":28,"code":"(fn [x] \n  (filter \n   (complement sequential?) \n   (rest (tree-seq sequential? seq x))))","user":"55b24240e4b0da326a65cf7b"},{"problem":28,"code":"(fn flatten-reduce\n  [xs]\n  (reduce #(if (coll? %2)\n           (concat %1 (flatten-reduce %2))\n             (concat %1 (list %2)))\n          '() xs))","user":"547e6fd2e4b0c51c1f4d730b"},{"code":"(fn flattn [coll]\n  (reduce\n   (fn [acc x]\n     (cond\n      (coll? x) (into acc (flattn x))\n      :else (conj acc x)))\n   [] coll))","problem":28,"user":"511688d5e4b0b3e208dba05a"},{"code":"(fn flatten2 [a]\n  (concat (if (sequential? (first a)) \n            (flatten2 (first a))\n            (list (first a))) \n          (if (sequential? (next a))\n            (flatten2 (next a))\n            ))\n)","problem":28,"user":"520cb8c4e4b0b022ef140c9a"},{"problem":28,"code":"(fn [x] (filter (comp not coll?) (tree-seq coll? seq x)))","user":"55ef2f27e4b066087aa94532"},{"code":"(fn flt [coll]\n(let [l (first coll) r (next coll)]\n(concat \n(if (sequential? l)\n(flt l)\n[l])\n(when (sequential? r)\n(flt r)))))","problem":28,"user":"527b856fe4b03e8d9a4a758d"},{"code":"(fn [s]\n  (letfn [(frec \n            ([in] (frec in '()))\n            ([in acc]\n               (if (empty? in)\n                acc\n                (let [h (first in)]\n                (if (sequential? h)\n                  (recur (rest in) (concat acc (frec h)))\n                  (recur (rest in) (concat acc (list h))))))))]\n  (frec s)))","problem":28,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":28,"code":"(fn [arr]\n  (filter #(not (sequential? %))\n    (tree-seq sequential? identity arr)))","user":"5e2586afe4b05b4b01516167"},{"code":"(fn flat[x] (filter (complement sequential?)(rest (tree-seq sequential? seq x))))","problem":28,"user":"4e7650c5535d324fb2983d68"},{"code":"(fn [x] (loop [thelist x] \n          (if (some #(sequential? %) thelist) \n            (recur (apply concat (map #(if (sequential? %) % [%]) thelist)))\n            thelist)))","problem":28,"user":"4fa176c7e4b0dcca54ed6d5e"},{"problem":28,"code":"(fn\n  [lst]\n  (reverse ((fn own-flat\n              [lst]\n              (loop [lst lst\n                     res '()]\n                (if (empty? lst)\n                  res\n                  (if (coll? (first lst))\n                    (recur (rest lst) (concat (own-flat (first lst)) res))\n                    (recur (rest lst) (cons (first lst) res)))))) lst)))","user":"5c706232e4b0fca0c162277e"},{"problem":28,"code":"(fn f [ls]\n  (if-not (some sequential? ls) ls (f (mapcat #(if (sequential? %) % [%]) ls))))","user":"57915ba4e4b0ebec4cfb75ba"},{"code":"#(loop [o [] coll %]\n           (if (empty? coll)\n               o\n               (recur\n                (if (coll? (first coll))\n                    o\n                    (conj o (first coll)))\n                (if (coll? (first coll))\n                    (concat (first coll) (rest coll))\n                    (rest coll)))))","problem":28,"user":"4e58c019535d8a8b8723a297"},{"code":"(fn flat [coll]\n  (if (coll? coll)\n    (mapcat flat coll)\n    (list coll)))","problem":28,"user":"52cca65be4b07d0d72b2736b"},{"problem":28,"code":"(fn [l] (mapcat (fn flat [x] (if (coll? x) (mapcat flat x) [x])) l ))","user":"59636b49e4b066ee0a44b0c5"},{"code":"(fn flat\n  ([l] (flat l []))\n  ([l acc]\n    (cond\n      (empty? l) acc\n      (coll? (first l))\n        (flat (rest l) (flat (first l) acc))\n      :else (flat (rest l) (conj acc (first l))))))","problem":28,"user":"4e568873535d8a8b8723a283"},{"problem":28,"code":"(fn  [tab] \n\n  (letfn [(splittab  [tab]\n                   (if (and (coll? tab) (not (empty? tab)))\n                     (concat \n                      (splittab (first tab)) \n                      (splittab (next tab))\n                      )\n                     (if (not (nil? tab)) [tab])\n                     )\n                   )\n        ]\n    (splittab tab) \n    )\n  \n  )","user":"55e8a85be4b0121d4835fd98"},{"code":"(fn flt[c] (if (sequential? c) (mapcat flt c) [c]))","problem":28,"user":"4db13ff51254ad5b4805fa68"},{"code":"(fn flatt-en \n  [col]\n  (let [l (first col)\n        r (next col)]   ;next will return nil if col is null;  rest X will return () if col is null;\n    (concat \n     (if (sequential? l)\n       (flatt-en l)\n       [l])\n     (when (sequential? r)\n       (flatt-en r)))))","problem":28,"user":"518ccf6be4b05e6c8537e386"},{"code":"(fn this [xs] (loop [xs xs acc ()]\r\n  (if (empty? xs) \r\n    acc\r\n    (let [a (first xs) c (if (sequential? a)\r\n      (this a) [a])]\r\n      (recur \r\n        (rest xs) \r\n        (concat acc c))))))","problem":28,"user":"4f58de86e4b0a7574ea7185b"},{"code":"(fn flat [x] (filter #(not (sequential? %)) (rest (tree-seq sequential? seq x))))","problem":28,"user":"516e9d9be4b06aac486e5b2b"},{"code":"(fn [coll]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq coll))))","problem":28,"user":"505bd09fe4b032b709c81373"},{"problem":28,"code":"#(loop [x % acc []]\n    (if (empty? x)\n      acc\n      (let [head (first x) tail (rest x)]\n        (if (coll? head)\n          (recur (mapcat identity (conj [] head tail)) acc)\n          (recur tail (conj acc head))\n        ))\n    )\n  )","user":"5485b402e4b0e286459a11b0"},{"problem":28,"code":"#(reduce \n  (fn flat [coll x]\n    (if (sequential? x)\n      (reduce flat coll x)\n       (conj coll x))) [] %)","user":"6074e1e4e4b069485764de4f"},{"problem":28,"code":"(fn [coll]\n  (seq\n (reduce\n (fn flt [v e]\n  (if (coll? e)\n    (reduce flt v e)\n    (conj v e)))\n [] coll)))","user":"57e91413e4b0bfb2137f5b20"},{"code":"(fn ! [v d] (into v (if (coll? d)\n(reduce  ! [] d)\n(vector d)))) []","problem":28,"user":"4e952463535dbda64a6f6b31"},{"code":"(fn flaten [lst]\n    (let [l (first lst) r (next lst)]\n      (concat\n       (if (sequential? l)\n\t   (flaten l)\n\t [l])\n       (when (sequential? r) (flaten r)))))","problem":28,"user":"534f8c9ae4b084c2834f4acd"},{"problem":28,"code":"(fn fl [x]\n  (if (coll? x)\n    (mapcat fl x)\n    [x]))","user":"516064e5e4b009fba0926e26"},{"code":"(fn flt[coll]\n   (println coll)\n  (let [l (first coll) r (next coll)]\n    (concat \n     (if (sequential? l)\n       (flt l)\n       [l])\n     (if (sequential? r)\n       (flt r)))))","problem":28,"user":"51de3b42e4b0de53e6370c53"},{"problem":28,"code":"#(loop [[f & r] %\n         acc []]\n    (if (coll? f)\n      (recur (concat f r) acc)\n      (if (nil? r)\n        (conj acc f)\n        (recur r (conj acc f)))))","user":"5531e445e4b09218d5f44f76"},{"problem":28,"code":"(fn flt [xs]\n  (if (empty? xs)\n    ()\n    (let [x1 (first xs) xr (rest xs)]\n      (if (coll? x1)\n        (if (empty? x1)\n          (flt xr)\n          (flt (cons (first x1) (cons (rest x1) xr))))\n        (cons x1 (flt xr))))))","user":"564a5a09e4b0284900eef656"},{"problem":28,"code":"(fn flatten! [coll] (if (sequential? coll) (mapcat flatten! coll) (list coll)))","user":"5976da27e4b01722bebd4ce3"},{"problem":28,"code":"mapcat\n(fn flat [x]\n  (if (coll? x)\n    (mapcat flat x)\n    (list x)))\n\n; looping\n; (fn flat [l]\n;   (loop [l l r ()]\n;     (if (not (coll? l))\n;       (cons l r)\n;       (if (empty? l)\n;         r\n;         (recur (rest l) (concat r (flat (first l))))))))\n\n; pattern matching arguments\n; (fn flat\n;   ([l r]\n;     (if (not (coll? l))\n;       (cons l r)\n;       (if (empty? l)\n;         r\n;         (flat (rest l) (concat r (flat (first l)))))))\n;   ([l] (flat l [])))","user":"55e7d06ee4b050e68259b496"},{"problem":28,"code":"(fn g [xs]\n    (reduce #(if (sequential? %2) (vec (concat %1 (g %2))) (conj %1 %2)) [] xs)\n    )","user":"5bd0ea60e4b0e9689409ee45"},{"problem":28,"code":"(fn myflat [col] \n  (if (some sequential? col)\n    (myflat \n      (reduce \n        (fn [a b] \n          (if (sequential? b)\n            (apply conj a b)\n            (conj a b)))\n        []\n        col))\n    col))","user":"585bcd51e4b0f14aab7c8771"},{"code":"(fn f [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      []\n      (concat (f (first xs)) (f (rest xs))))\n    [xs]))","problem":28,"user":"508ee17ae4b0706b2ed3ef8d"},{"code":"(fn [c]\n    (loop [col c\n           result '()]\n      (if (= col result) result\n            (recur (reduce (fn [a b] (if (coll? b) (concat a b) (concat a [b]))) '() col) col))))","problem":28,"user":"4ed27f9f535d44c135fd68d5"},{"code":"(fn [coll]\r\n  (loop [f1 coll]\r\n    (let [f2 (apply concat (map #(if (sequential? %) % [%]) f1))]\r\n      (if (= f1 f2) f2 (recur f2)))))","problem":28,"user":"4e131d5b535d04ed9115e7d4"},{"code":"(fn f [n] \n  (reduce concat \n          (for [x n] (if (coll? x) (f x) [x])) \n            )\n)","problem":28,"user":"50f8862de4b0aafb827eb203"},{"code":"(fn flatseq\n  ([n] (flatseq [] n))\n  ([s n]\n     (if (empty? n)\n       s\n       (if (coll? (first n))\n         (flatseq (into s (flatseq (first n))) (rest n))\n         (flatseq (conj s (first n)) (rest n))))))","problem":28,"user":"4f03e7b3535dcb61093f6b7c"},{"code":"#( filter (complement sequential?)  (tree-seq ( some-fn seq? vector? ) seq %  ))","problem":28,"user":"536c1119e4b0fc7073fd6e34"},{"code":"(fn my-flatten [coll]\n  (if (empty? coll)\n    coll\n    (if (or (vector? (first coll)) (list? (first coll)))\n      (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n      (cons (first coll) (my-flatten (rest coll))))))","problem":28,"user":"4ef4c1ff535dced4c769f23e"},{"problem":28,"code":"(fn flatten* [coll]\n   (reduce (fn [acc x]\n             (if (sequential? x)\n               (flatten* (into acc x))\n               (conj acc x)))\n           []\n           coll))","user":"5edc645ae4b0c7845d86b0f2"},{"code":"(fn my-flatten [coll]\n  (cond (nil? coll) nil\n        (not (sequential? coll)) [coll]\n        :else (concat (my-flatten (first coll))\n                      (my-flatten (next coll)))))","problem":28,"user":"4ee8b9c9535d93acb0a66884"},{"code":"(fn f [c]\n  (when-let [s (seq c)]\n    (if (coll? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))))","problem":28,"user":"50e47fa5e4b0cb9ec68fbc9c"},{"code":"(fn my-fla\n  [coll]\n  (if (sequential? coll)\n    (let [c (seq coll)\n          f (first c)\n          r (next c)]\n      (if (sequential? f)\n        (concat (my-fla f) (my-fla r))\n        (cons f (my-fla r))))\n    ()))","problem":28,"user":"50b0cffae4b009df37c708c5"},{"problem":28,"code":"(fn flatten-it [[head & tail :as s]]\n  (cond\n   (empty? s) ()\n   (coll? head) (concat (flatten-it head) (flatten-it tail))\n   :if-those-other-dogs-won't-hunt (cons head (flatten-it tail))))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn fltn [lst]\n  (if (empty? lst) lst\n    (let [[x & xs] lst]\n      (if (or (vector? x) (list? x) (seq? x))\n        (concat (fltn x) (fltn xs))\n        (cons x (fltn xs))))))","problem":28,"user":"4edfb618535d10e5ff6f5343"},{"problem":28,"code":"(fn flat-coll [coll]\n  (reduce\n    #(if (sequential? %2) (concat %1 (flat-coll %2))\n                          (concat %1 (list %2)))\n    () coll)\n  )","user":"5c597b42e4b01df32ab7325b"},{"problem":28,"code":"(fn myflatten [coll]\n  (if (empty? coll) []\n      (if (coll? (first coll))\n        (concat (myflatten (first coll)) (myflatten (rest coll)))\n        (do\n          (println \"first \" (first coll) \" rest \" (rest coll))\n          (concat [(first coll)] (myflatten (rest coll))))))\n  )","user":"603ae21de4b0d5df2af222fb"},{"problem":28,"code":"(fn\n  [xs]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq xs))))","user":"55597b84e4b0deb715856e36"},{"code":"(fn my-flatten [xs]\n  (let [helper (fn helper [xs acc]\n                 (if (or (seq? xs) (vector? xs))\n                   (if (empty? xs)\n                     acc\n                     (->> acc (helper (rest xs)) (helper (first xs)))) \n                   (cons xs acc)))]\n  \t(helper xs ())))","problem":28,"user":"53800d99e4b06839e8705ebd"},{"problem":28,"code":"(fn [tail-coll & head-coll]\n    (let [[first-elem & rest-coll] tail-coll]\n      (if (coll? first-elem)\n        (recur (concat first-elem rest-coll) head-coll)\n        (if (nil? first-elem)\n          head-coll\n          (recur rest-coll (concat head-coll (list first-elem)))))))","user":"58bbcbc8e4b0888cdc949d00"},{"problem":28,"code":"(fn flatten-conj [r l]\n\n  (cond \n\n    (nil? l) r\n\n    (not (coll? l)) (conj r l)\n\n    :else  (reduce #(flatten-conj %1 %2) r l))) []","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn foo [x]\n  (if (coll? x)\n    (let [[x1 & x2] x]\n      (if x2\n        (concat (foo x1) (foo x2))\n        (foo x1)\n      )\n    )\n    (conj [] x)))","problem":28,"user":"4f141dee535d64f603146434"},{"problem":28,"code":"(fn [x]\n    (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"53c3397be4b00fb29b221279"},{"problem":28,"code":"(fn fltn\n([f] (if (coll? f) (apply fltn f) (list f)))\n ([f & r]\n  (if (coll? f) (concat (apply fltn f) (fltn r))\n   (conj (apply fltn r ) f)))\n  )","user":"5fdc6ad4e4b05ac5b16ea13a"},{"code":"(fn flat [s]\n  (let [flatten*\n    (fn flatten* [s]\n      (if (sequential? s)\n        (apply concat (vec (map flatten* s)))\n        [s]))]\n    (flatten* s)))","problem":28,"user":"4f12d1b0535d64f60314642b"},{"problem":28,"code":"(fn my-flatten [input] (if (or (string? input) (not (sequential? input))) [input] (if (empty? input) input (concat (my-flatten (first input)) (my-flatten (rest input))))))","user":"5743e316e4b0c285004e8ab3"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll]\n    (let [acc (loop [[head & tail] coll\n                     acc []]\n                (if (nil? head)\n                  acc\n                  (recur tail (if (coll? head)\n                                (into acc head)\n                                (conj acc head)))))]\n      (if (reduce #(or %1 %2) (map coll? acc))\n        (recur acc)\n        acc))))","user":"5535d34be4b09218d5f44fb0"},{"problem":28,"code":"(fn flattn [coll]\n  (filter (complement  sequential?) (rest  (tree-seq sequential? seq coll))))","user":"5c547cf0e4b0fb8c5ffd9a0b"},{"problem":28,"code":"(fn [x] (filter #(not (coll? %)) (tree-seq sequential? seq x)))","user":"5b522591e4b02d533a91bd09"},{"problem":28,"code":"(fn flat [s]\n  (reduce\n    (fn myflat [v e]\n      (if (coll? e)\n        (reduce myflat v e)\n        (conj v e)\n      )\n    )\n    [] s\n  )\n)","user":"566b8946e4b0a866af6896b0"},{"code":"(fn [s]\n        (loop [x s]\n                (if (reduce #(or %1 %2) (map #(coll? %1) x))\n                        (recur (mapcat #(if (coll? %1) %1 (list %1)) x))\n                        x\n                )\n        )\n)","problem":28,"user":"53512b55e4b084c2834f4ae0"},{"problem":28,"code":"(fn [x]\n  (filter\n   (complement sequential?)\n   (tree-seq sequential? seq x)))","user":"58254a11e4b051871117bed9"},{"problem":28,"code":"(fn self [xs]\n  (mapcat (fn [e] (if (sequential? e) (self e) (list e))) xs))","user":"5344fe13e4b084c2834f4a32"},{"problem":28,"code":"(fn flat-fuck [xs] (reduce \n                      (fn [acc, item] (concat acc ((if (sequential? item) flat-fuck list) item))) \n                      '() \n                      xs))","user":"5de48f92e4b0948ae9d9ae07"},{"problem":28,"code":"(fn flatten-it [s]\n  (reverse (reduce (fn extract [col elm]\n            (if (coll? elm)\n              (reduce extract col elm)\n              (conj col elm))) '() s)))","user":"5fa80c01e4b0fa27300f3de2"},{"problem":28,"code":"(fn blah [x]\n   (reduce #(if (or (seq? %2) (vector? %2))\n              (concat %1 (blah %2))\n              (reverse (cons %2 (reverse %1))))\n           '() x))","user":"53aaaf7ae4b047364c044444"},{"code":"(fn my-flatten [coll]\n  (reduce (fn [acc cur]\n            (if (sequential? cur)\n              (into acc (my-flatten cur))\n              (conj acc cur)))\n          []\n          coll))","problem":28,"user":"53695439e4b0243289761e9a"},{"problem":28,"code":"(fn my-flat [coll] (cond\n                      ((complement sequential?) coll) coll\n                      (empty? coll) nil\n                      :else\n                      (concat (if(sequential? (my-flat (first coll)))  (my-flat (first coll)) (list (my-flat (first coll))))  \n                              (my-flat (rest coll)))))","user":"54e4edcae4b024c67c0cf7f3"},{"problem":28,"code":"(fn makeflat [lst]\n  (if (sequential? lst)\n    (mapcat makeflat lst)\n    [lst]))","user":"55a1d7f6e4b0acc240e31519"},{"code":"#(reduce (fn fn [seed xs]\n           (if (coll? xs)\n             (reduce fn seed xs)\n             (conj (vec seed) xs))) '() %)","problem":28,"user":"4fab259ae4b081705acca212"},{"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn my-flatten [dst src]\n      (if (coll? src)\n        (reduce my-flatten dst src)\n        (conj dst src)))\n    [] coll)))","problem":28,"user":"5202cfe7e4b030ee0c5b2702"},{"code":"(fn flatt\n  [coll]\n  (let [f (first coll)\n        r (rest coll)]\n    (if (empty? coll)\n      coll\n      (if (sequential? f)\n        (concat (flatt f) (flatt r))\n        (cons f (flatt r))))))","problem":28,"user":"4fe9f0f6e4b0547ebccb247b"},{"problem":28,"code":"(fn myflat [s] (loop [rm s memo []]\n                (if (empty? rm)\n                  memo\n                  (let [cur (first rm)]\n                    (if (coll? cur)\n                      (let [flatCur (myflat cur)]\n                        (recur (rest rm) (concat memo (myflat cur))))\n                      (recur (rest rm) (conj (vec memo) cur))\n                     )\n                   )\n                 )\n                ))","user":"565233f2e4b0f9d632dd8461"},{"code":"(fn fl [s]\n  (reduce\n    (fn [m e]\n      (concat m (if (coll? e)\n                    (fl e)\n                    (list e))))\n      '() s))","problem":28,"user":"4ec5a6ee535d6d7199dd36ae"},{"problem":28,"code":"(fn flat\n   [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (flat r))\n          ;; (sequential? f)\n          :else (concat (flat f) (flat r)))))","user":"5dcc4b4ae4b02b31cc3da3c6"},{"problem":28,"code":"#(filter (complement sequential?) \n         (rest (tree-seq sequential? identity %)))\n\n; This is the clojure definition for flatten.\n; We take rest since we know first element will be the seq itself.","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn myflatten\n  ([in] (myflatten in []))\n  ([in ret]\n    (if (nil? (first in)) \n      ret\n      (if (coll? (first in))\n        (myflatten (rest in) (myflatten (first in) ret))\n        (myflatten (rest in) (conj ret (first in)))\n      )\n    )\n  )\n)","problem":28,"user":"5176afd2e4b085adf681d889"},{"code":"(fn f([c](if(sequential? c)(mapcat f c)[c])))","problem":28,"user":"52117ea7e4b07aea8afc4f70"},{"code":"(fn flatten2 [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      ()\n      (concat (flatten2 (first xs)) (flatten2 (rest xs)))\n      )\n    (cons xs ())\n    )\n  )","problem":28,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn flat [elem] ( if (coll? elem ) ( mapcat flat elem ) ( list elem ) ))","problem":28,"user":"4f030775535dcb61093f6a43"},{"problem":28,"code":"#(loop [xs %\n         res []]\n    (cond\n      (zero? (count xs)) res\n      (sequential? (first xs)) (recur (concat (first xs) (rest xs)) res)\n      :else (recur (rest xs) (conj res (first xs)))))","user":"4eb47bb1535d7eef30807362"},{"code":"(fn flat [l]\n  (if (empty? l)\n    []\n    (concat\n      (if (coll? (first l))\n        (flat (first l))\n        (take 1 l))\n      (flat (rest l)))))","problem":28,"user":"53150a4de4b08068f379ed22"},{"problem":28,"code":"(fn [s]\n  (loop \n    [se s\n     acc []]\n     (cond\n      (empty? se) acc\n      (not (sequential?(first se))) (recur (rest se) (conj acc (first se)))\n      :else (recur (concat (first se) (rest se)) acc)\n     )\n  )\n)","user":"5b4ff637e4b02d533a91bce0"},{"problem":28,"code":"#(->> %\n      ((fn my-flatten [coll]\n        (reduce (fn [acc el]\n            (if (coll? el)\n              (into acc (my-flatten el))\n              (conj acc el)))\n          [] coll)))\n      (apply list))","user":"5703a557e4b08d47c97781f4"},{"problem":28,"code":"#(loop [item (first %)\n       coll (rest %)\n       result []]\n  (if (coll? item)\n    (recur (first item) (into (vec (rest item)) coll) result)\n    (if (seq coll)\n      (recur (first coll) (rest coll) (conj result item))\n      (conj result item))))","user":"55577fcce4b0deb715856e24"},{"problem":28,"code":"(fn flt [col]\n  (if (empty? col)\n      ()\n  \t\t(let [head (first col)]          \n          (concat \n           (cond \n            (vector? head) (flt (lazy-seq head))\n            (seq? head) (flt head)\n            :else (list head)) \n           (flt (rest col))))))","user":"5887518ae4b0f1effa3b76f5"},{"code":"(partial reduce (fn myflatten2 [running item]\n    (if (sequential? item)\n        (reduce myflatten2 running item)\n        (conj running item)\n    )\n  ) (vector))","problem":28,"user":"52573608e4b0cb4875a45c76"},{"problem":28,"code":"(fn f [c] (if (empty? (filter coll? c)) c (f (reduce (fn [col n] (apply conj col (if (coll? n) n (list n)))) [] c))))","user":"54126d0ce4b01498b1a719d5"},{"code":"(fn [seq]\n  (letfn [(inner [left [f & r]]\n            (cond (and (not (coll? f)) (nil? f))\n                    left\n                  (coll? f)\n                   (recur left (concat f r))\n                  :t\n                   (recur (conj left f) r)))]\n    (inner [] seq)))","problem":28,"user":"4f62b29ce4b0defedf855fd9"},{"problem":28,"code":"(fn f [s]\n  (lazy-seq\n   (when-let [ss (seq s)]\n     (if (coll? (first ss))\n       (concat (f (first s)) (f (rest s)))\n       (cons (first s) (f (rest s)))))))","user":"59733c91e4b01722bebd4c9b"},{"problem":28,"code":"(fn flat-ten [x] (if (seq x)\n                  (if (coll? (first x)) \n                    (concat (flat-ten (first x)) (flat-ten(rest x)))\n                    (cons (first x) (flat-ten(rest x))))\n                    x))","user":"54d0cedde4b0e8a36923e5d2"},{"code":"(fn flat [values]\n  (if (nil? values) '()\n    (let [head (first values) tail (next values)]\n      (if (sequential? head)\n        (concat (flat head) (flat tail))\n        (cons head (flat tail))))))","problem":28,"user":"52990271e4b02ebb4ef7506d"},{"problem":28,"code":"#((fn fl [x result]\n    (if (empty? x) result\n        (if (sequential? (first x)) (concat (fl (first x) result) (fl (rest x) []))\n            (fl (rest x) (conj result (first x)))\n        )\n    )\n) % [])","user":"580c8fcee4b0849f6811b721"},{"code":"(fn [x]\n  (loop [result [] orig x] \n     (if (empty? orig)\n       result\n       (let [ f (first orig) r (rest orig) tst (coll? f) ]\n         (recur (if tst result (conj result f)) \n                (if tst (concat f r) r))))))","problem":28,"user":"4f57a153e4b0a7574ea7183a"},{"code":"(fn myflatten ([coll]\n    (myflatten coll []))\n  ([coll sofar]\n    (cond (coll? coll)\n             (if (seq coll) (myflatten (rest coll) (reduce conj sofar (myflatten (first coll)))) sofar)\n           :else (conj sofar coll))\n    ))","problem":28,"user":"50e3ec87e4b0463d32072486"},{"problem":28,"code":"(fn fmap [xs] (if (coll? xs) (mapcat fmap xs) [xs]))","user":"55d8968ae4b0e31453f64abb"},{"code":"(fn myFlatten [col]\n  (reduce\n    #(if (coll? %2)\n       (apply conj %1 (myFlatten %2))\n       (conj %1 %2))\n    []\n    col))","problem":28,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn my-flatten [s]\n    (if (sequential? s)\n\t(if (empty? s)\n\t    ()\n\t  (concat (my-flatten (first s)) (my-flatten (rest s)))\n\t  )\n      (conj () s)\n      )\n    )","problem":28,"user":"5213ffd3e4b0961f15ac4d7d"},{"problem":28,"code":"(fn fltn [xs]\n  (reduce (fn [rs ys] (if (or (seq? ys) (list? ys) (vector? ys)) (vec (concat rs (fltn ys))) (conj rs ys))) [] xs))","user":"55316b8ae4b076ab5578f825"},{"code":"(fn myflatten [x]\n  (println x)\n\t(if (empty? x)\n\t  x\n\t  (if (sequential? (first x))\n\t    (concat (myflatten (first x)) (myflatten (rest x)))\n\t    (cons (first x) (myflatten (rest x)))\n\t  )\n  \t)\n)","problem":28,"user":"4ea08b30535d7eef308072a5"},{"problem":28,"code":"(fn flat [xs] (reduce #(concat %1 (if (sequential? %2) (flat %2) [%2])) [] xs))","user":"5bc20634e4b07a9b28b10022"},{"code":"(fn flat [l]\n  (cond (empty? l) l\n  (sequential? (first l)) (concat (flat (first l)) (flat (rest l)))\n  :else (conj (flat (rest l)) (first l))))","problem":28,"user":"4e5ecd65535d8a8b8723a2d6"},{"problem":28,"code":"(fn my-flatten [s]\n  (reduce (fn [a e] (if (coll? e)\n                       (concat a (my-flatten e))\n                       (concat a [e]))) [] s))","user":"5a7ae674e4b03baeef9276d5"},{"code":"(fn [x] (let [poop (apply concat (map #(if (coll? %) % (list %)) x))] (if (empty? (filter coll? poop)) poop (recur poop))))","problem":28,"user":"4fa069c3e4b0dcca54ed6d4a"},{"problem":28,"code":"(fn flatter [xs] (if (coll? xs) (mapcat flatter xs) [xs]))","user":"603f6623e4b0d5df2af2231f"},{"code":"(fn ! [inp] \n   (concat \n    (if (coll? (first inp)) (! (first inp)) (list (first inp)))\n    (if (empty? (rest inp)) '() (! (rest inp))) ))","problem":28,"user":"5301a13ae4b0d8b024fd371e"},{"problem":28,"code":"(fn [i] (letfn [(iter [inp]\n                    (loop [xs inp\n                           out nil]\n                      (if (empty? xs)\n                        out\n                        (let [x (first xs) xss (rest xs)]\n                          (if (coll? x)\n                            (recur xss (concat (iter x) out))\n                            (recur xss (conj out x)))))))]\n\n           (reverse (iter i))))","user":"532ae82be4b09d4e7a9b552b"},{"code":"(fn myflatten [coll]\n  (if\n    (not (sequential? coll)) coll\n    (reduce\n      (fn [acc x]\n        (if (not (sequential? x))\n          (conj acc x)\n          (apply conj acc (myflatten x))))\n      []\n      coll)))","problem":28,"user":"504c8165e4b09724c857af31"},{"problem":28,"code":"(fn flttn [col]\n (if (not-empty col)\n (if (coll? (first col))\n   (concat\n     (flttn (first col))\n     (flttn (rest col))\n   )\n   (concat\n    (if (vector? col) \n     (vector (first col))\n     (list (first col))\n    )\n    (flttn (rest col))\n   )\n )\n )\n)","user":"57cc7d96e4b0c746388ab882"},{"problem":28,"code":"(fn flatten* [xs] (if (sequential? xs) (mapcat flatten* xs) [xs]))","user":"56e37659e4b03a7c14b85a44"},{"problem":28,"code":"(fn [sequ]\n  (if (every? (complement coll?) sequ)\n    sequ\n    (recur (reduce #(if (coll? %2) (apply conj %1 %2) (conj %1 %2)) [] sequ))))","user":"5f3ab5ece4b004f08c61c52a"},{"code":"(fn flat [col]\n  (let [x (first col) y (rest col)]\n    (lazy-seq\n     (when (seq col)\n       (if (sequential? x)\n         (concat (flat x) (flat y))\n         (cons x (flat y)))))))","problem":28,"user":"511618b1e4b0d4f670fd2fdf"},{"problem":28,"code":"(fn squash [x] \n\t(cond (empty? x) nil\n\t      (sequential? (first x)) (concat (squash (first x)) (squash (rest x)))\n\t\t  :else (cons (first x) (squash (rest x)))))","user":"59fa5773e4b0ca45a743a35e"},{"code":"(fn flattens\n\t[col]\n\t(if (empty? col)\n\t  col\n\t  (let [[x & rest] col]\n\t    (if (coll? x)\n\t      (concat (flattens x) (flattens rest))\n\t      (cons x (flattens rest))))))","problem":28,"user":"5339af7de4b0e30313ee6cab"},{"problem":28,"code":"(fn Flat [coll]\n  (when (seq coll)\n  (if (sequential? (first coll))\n    (concat (Flat (first coll)) (Flat (rest coll)))\n    (cons (first coll) (Flat (rest coll))))))","user":"57d4f225e4b0bd073c2023a6"},{"problem":28,"code":"(fn flat\n  [xs]\n  (reduce (fn\n            [acc x]\n            (if (coll? x)\n              (concat acc (flat x))\n              (concat acc (list x))))\n          []\n          xs)\n  )","user":"5e1c24f4e4b0dc959400852d"},{"code":"(fn f [s] \n  (lazy-seq \n    (when (seq s)\n      (if (sequential? (first s))\n        (f (concat (first s) (rest s)))\n        (cons (first s) (f (rest s)))))))","problem":28,"user":"4f043ed1535dcb61093f6bb4"},{"problem":28,"code":"(fn f [xs]\n  (cond\n   (not (coll? xs)) (list xs)\n   (empty? xs) ()\n   :else (concat (f (first xs)) (f (rest xs)))))","user":"540ff039e4b01498b1a7199b"},{"code":"#(\n  (fn flat [lizt]\n    (loop [nl []\n           ol lizt]\n      (if (empty? ol)\n        nl\n        (let [f (first ol)]\n              (if (coll? f)\n                (if (empty? f)\n                  (recur nl (rest ol))\n                  (recur nl (cons (first f) (conj (rest ol) (rest f)))))\n                (recur (conj nl f) (rest ol)))\n              ))\n        ) \n      ) %)","problem":28,"user":"52bdd135e4b07a9af579230a"},{"problem":28,"code":"(fn fltn [coll]\n  (loop [x (first coll)\n        xs (rest coll)\n        res []]\n    (if (nil? x)\n      res\n      (recur (first xs) (rest xs) (if (coll? x)\n                                    (concat res (fltn x))\n                                    (conj (vec res) x))))))","user":"54c46381e4b045293a27f61a"},{"code":"(fn flt [coll]\n  (let [left (first coll)\n        right (next coll)\n        ]\n    (concat\n     (if (sequential? left)\n       (flt left)\n       [left])\n     (when (sequential? right)\n       (flt right)\n     )\n    )\n   ))","problem":28,"user":"506cad7de4b0a302964c548e"},{"problem":28,"code":"(fn mflatten [coll]\n  (if (sequential? coll)\n    (mapcat mflatten coll)\n    (list coll)))","user":"5ab276f2e4b073f1774425e6"},{"problem":28,"code":"(fn func [coll] \n  (loop [coll coll\n         acc []]\n    (if (= 0 (count coll))\n      acc\n      (let [elm (first coll)]\n        (if (sequential? elm)\n          (recur (rest coll) (apply conj acc (func elm)))\n          (recur (rest coll) (conj acc elm)))))))","user":"60ab1536e4b00e9e6653c47e"},{"code":"(fn f [s] (if (not (sequential? s)) [s] (mapcat f s)))","problem":28,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":28,"code":"(fn [str]\n  (seq\n   (reduce\n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n    [] str)))","user":"57fc08d8e4b0d3187e900988"},{"code":"(fn userflatten\n  ([x] (userflatten (seq x) '()))\n  ([x y] (if (= (count x) 0)\n           y\n           (if (sequential? (last x))\n             (userflatten\n               (butlast x)\n               (concat (userflatten (last x)) y))\n             (userflatten\n               (butlast x)\n               (conj y (last x)))))))","problem":28,"user":"52dad8bde4b09f7907dd13be"},{"code":"(fn [coll]\n  (filter #(not (sequential? %))\n          (tree-seq sequential? seq coll)))","problem":28,"user":"518d1b5be4b070277754617b"},{"problem":28,"code":"(fn flat [x]\n  (if (sequential? x)\n  \t(mapcat flat x)\n    (list x)))","user":"59f2af64e4b0966464fe6a87"},{"problem":28,"code":"(fn flatin [l]\n  (if (coll? l)\n  (mapcat flatin l)\n  [l]\n  ))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn fltn [s]\n  (if (empty? s)\n     s\n     (if (coll? (first s))\n        (concat (fltn (first s)) (fltn (rest s)))\n        (cons (first s) (fltn (rest s))))))","problem":28,"user":"4f611127e4b0defedf855fb4"},{"problem":28,"code":"(fn flatten'\n  [x]\n  (when x\n    (let [[head & tail] x]\n      (if (or (list? head) (vector? head))\n        (concat\n          (flatten' head)\n          (flatten' tail))\n        (cons head\n              (flatten' tail))))))","user":"5c61ce28e4b0fca0c162263b"},{"problem":28,"code":"(fn f [c] (if (coll? c) (mapcat f c) [c]))","user":"5405ae2be4b0addc1aec6671"},{"problem":28,"code":"(fn flat [x] \n(if (not (sequential? x))\n(list x) \n(if (= (count x) 1)\n  (flat (nth x 0))\n  (concat (flat (nth x 0)) (flat (rest x)))))\n)","user":"5d2ca236e4b01671435dbc94"},{"problem":28,"code":"(fn myflattencoll [x] \n\t(if (coll? x)\n\t\t(mapcat myflattencoll x)\n        [x]))","user":"55cdc576e4b0e31453f64a1f"},{"code":"(fn t [x] \n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)\n  )\n)","problem":28,"user":"4e39c710535deb9a81d77f45"},{"code":"(fn fltn [x]\n  (if (empty? x)\n   '()\n   (if (not (coll? (first x)))\n     (conj (fltn (rest x)) (first x))\n     (concat (fltn (first x)) (fltn (rest x)) ))))","problem":28,"user":"5376966ae4b06839e8705e27"},{"problem":28,"code":"(fn [sq]\n (reverse ((fn [c t res]\n   (cond \n    (coll? c)\n       (if (empty? (rest c)) (recur (first c) t res)\n       (recur (first c) (cons (rest c) t) res))\n    (empty? t) \n     (cons c res)\n    :else\n     (recur (first t) (rest t) (cons c res))\n   )\n  ) (first sq) (rest sq) []))\n)","user":"57dfe173e4b0bd073c20246b"},{"code":"(fn foo [x]\n  (if (coll? x)\n    (if (empty? x) \n      x\n      (concat (foo (first x)) (foo (rest x))))\n    [x]))","problem":28,"user":"5236cd89e4b0e010857b4e45"},{"problem":28,"code":"(fn flat2 [x]\n  (if (sequential? x)\n    (mapcat flat2 x)\n    [x]))","user":"5be70bd5e4b0f319e2d7ec53"},{"code":"(fn [x] (reverse (loop [acc () rem x] \n                      (if (empty? rem) \n                        acc \n                        (if (sequential? (first rem)) \n                          (recur acc (concat (first rem) (rest rem)))\n                          (recur (cons (first rem) acc) (rest rem)))))))","problem":28,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn myflatten [xs]\n  (reduce \n    (fn [xs x]\n    (if (not (coll? x)) (conj (vec xs) x) (concat xs (myflatten x))))\n    [] xs))","problem":28,"user":"4e4ca885535dc968683fc4df"},{"problem":28,"code":"(fn bulldoze [c]\n  (if (sequential? c)\n    (mapcat bulldoze c)\n    (list c)))","user":"580bd81ee4b0849f6811b711"},{"problem":28,"code":"(fn flat [s]\n  (if-not (coll? s)\n    [s]\n    (reduce \n     (fn [prev cur] \n       (into [] (concat prev (flat cur))))\n     []\n     s)))","user":"56fc0601e4b07572ad1a88db"},{"code":"(fn afn [fst ]\n      (if-not (coll? fst)\n        [fst]\n        (if (seq fst)\n          (concat\n            (afn (first fst))\n            (afn (rest fst))\n          )\n          ))\n        )","problem":28,"user":"5229211be4b04c906c9c6a63"},{"problem":28,"code":"(fn flattenIt [ list2flatten ]\n\t(if (sequential? list2flatten)\n        (reduce concat(map flattenIt list2flatten))\n        [list2flatten]))","user":"59f90e6ae4b0ca45a743a337"},{"problem":28,"code":"(fn [lst]\n(if (not-any? coll? lst) \n    lst\n    (recur (mapcat #(if (coll? %) % (vector %)) lst))))","user":"59f15e20e4b0966464fe6a5a"},{"problem":28,"code":"(fn flatten1 [xs]\n  (if (empty? xs) xs\n    (if (coll? (first xs)) \n      (concat (flatten1 (first xs)) (flatten1 (rest xs)))\n      (conj (flatten1 (rest xs)) (first xs)))))","user":"54fd93bbe4b07d26eda61d36"},{"problem":28,"code":"(fn new-flatten [l] (mapcat #(if (coll? %) (new-flatten %) [%]) l))","user":"55d1a721e4b0e31453f64a47"},{"problem":28,"code":"(fn mflat [mseq]                                                                                                                                                                                        \n  (loop [mcol mseq toret []]                                                                                                                                                                              \n    (if (empty? mcol) toret                                                                                                                                                                                \n    (let [[f & r] mcol]                                                                                                                                                                                   \n      (if (coll? f) (recur r (concat toret (mflat f)))                                                                                                                                                  \n        (recur r (concat toret [f] )))))))","user":"5804b491e4b0a837a8b30cac"},{"problem":28,"code":"(fn flttn [coll]\n  (println coll)\n  (if (= (count coll) 0)\n    (list)\n    (if (coll? (first coll))\n      (concat (flttn (first coll)) (flttn (rest coll)))\n      (cons (first coll) (flttn (rest coll)))\n    )\n  )\n)","user":"55f5c118e4b06e875b46ce8e"},{"problem":28,"code":"(fn flt [coll]\n  (let [s (seq coll)]\n    (cond\n      (not (seq? s)) ()\n      (nil? (first s)) ()\n      (vector? (first s)) (concat (flt (seq (first s))) (flt (rest s)))\n      (seq? (first s)) (concat (flt (first s)) (flt (rest s)))\n      :else (concat (list (first s)) (flt (rest s))))))","user":"543366dde4b0b6b47310fcdf"},{"code":"(fn flat\n[x]\n(filter (complement sequential?)\n   (rest (tree-seq sequential? seq x))))","problem":28,"user":"507ddf55e4b0a03698d01ca8"},{"code":"(fn fln [x]\n  (if (sequential? x)\n    (mapcat fln x)\n    [x]))","problem":28,"user":"4ef9c8f9535dced4c769f26b"},{"problem":28,"code":"(fn my-flatten\n  ([[x & r]]\n       (if (nil? x) []\n       (if (not (or (seq? x) (vector? x)))\n           (concat [x] (my-flatten [r]))\n           (concat (my-flatten x) (my-flatten r))))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":28,"code":"(fn flat [s]\n  (if (sequential? s)\n    (into (flat (first s)) (flat (next s)))\n    (if (nil? s)\n      []\n      [s]\n    )\n  )\n)","user":"567b9ff7e4b05957ce8c61a9"},{"problem":28,"code":"(fn [coll]\n   (loop [[coll-f & coll-r :as coll] coll\n          acc []]\n     (do (println coll coll-f coll-r)\n         (if (empty? coll)\n           acc\n           (if (not (sequential? coll-f))\n             (recur coll-r (conj acc coll-f))\n             (recur (concat coll-f coll-r) acc))))))","user":"5e99cbd4e4b0157ca96647e6"},{"problem":28,"code":"(fn [x](filter (complement sequential?)\n          (tree-seq sequential? seq x)))","user":"57d60d83e4b0bd073c2023c2"},{"problem":28,"code":"(fn fltn\n  [sq]\n  (let [f #(if (sequential? %) (fltn %) (list %))]\n    (apply concat (map f sq))))","user":"588e4e05e4b00487982d5188"},{"problem":28,"code":"(fn abc [col]\n  (let [a (first col) b (next col)]\n    (concat\n      (if (sequential? a)\n        (abc a)\n        [a])\n      (if (sequential? b)\n        (abc b)\n        b)\n      )\n    )\n  )","user":"5fe09d1fe4b05ac5b16ea15b"},{"code":"(fn flt [s] \n  (let [f (first s) l (next s)]\n    (concat \n     (if (sequential? f) \n       (flt f) \n       [f]) \n     (when (sequential? l) \n       (flt l)))\n   ))","problem":28,"user":"52f021c1e4b05e3f0be25edb"},{"problem":28,"code":"(fn f [s]\n  (cond\n   (empty? s) '()\n   (not (coll? (first s))) (cons (first s) (f (rest s)))\n   :else (concat (f (first s)) (f (rest s)))))","user":"560ff7d9e4b05f002753df67"},{"problem":28,"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))\n\n;; complement\n;; tree-seq","user":"53be3ee7e4b0d9a98559a6df"},{"problem":28,"code":"(fn fltn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5578f292e4b05c286339e08f"},{"problem":28,"code":"(fn flat [xs] (cond (empty? xs) nil (or (vector? (first xs))(list? (first xs))) (concat (flat (first xs)) (flat (rest xs))) :else (cons (first xs) (flat (rest xs)))))","user":"5d828b7ee4b0915913b1d382"},{"code":"(fn [lst]\n  (loop [val lst remainder '() accume []]\n    (if (sequential? val)\n      (recur (first val)\n             (let [left (rest val)]\n               (if (not (empty? left))\n                 (conj remainder left)\n                 remainder))\n             accume)\n      (if (not (empty? remainder))\n        (recur (first remainder) (rest remainder) (conj accume val))\n        (conj accume val)))))","problem":28,"user":"5256a1d4e4b0541d1855ba29"},{"problem":28,"code":"(fn flattn [coll] (filter (complement sequential?) (tree-seq sequential? seq coll)))","user":"55ec4558e4b0121d4835fdc5"},{"code":"(fn flt [xs] (apply concat (map #(if (coll? %) (flt %) (list %)) xs)))","problem":28,"user":"50c9e5e3e4b0a409464667d7"},{"code":"(fn f [coll]\r\n  (when-let [[x & more] (seq coll)]\r\n    (if (coll? x)\r\n      (concat (f x) (f more))\r\n      (cons x (f more)))))","problem":28,"user":"4dd52e29535dae65d5c462e5"},{"code":"(fn my-flat [x]\n(if (not (coll? x)) (vector x)\n(mapcat my-flat x)\n))","problem":28,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn fl [[x & xs]] \r\n  (let [ss (if (nil? xs) nil (fl xs))]\r\n    (if (some #(% x) [list? set? vector? seq?])\r\n      (fl (concat x ss))\r\n      (cons x ss))))","problem":28,"user":"4eecdd66535d93acb0a668b9"},{"code":"#(filter (comp not coll?) (rest (tree-seq coll? seq %)))","problem":28,"user":"52a0237de4b04e0c58e87bbe"},{"code":"(fn flat [coll]\n  (if (coll? coll) (mapcat flat coll) [coll]))","problem":28,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn zomgflatten\n  ([input]\n    (seq (zomgflatten input [])))\n  ([seq output]\n    (reduce \n      (fn [out value]\n        (if (sequential? value)\n          (zomgflatten value out)\n          (conj out value)))\n      output seq)))","problem":28,"user":"4e55958a535d8a8b8723a27e"},{"code":"(fn [x]\n  (filter (complement sequential?) \n          (tree-seq sequential? seq x)\n                )\n          \n  )","problem":28,"user":"50fb084ee4b0d10d794c19dd"},{"problem":28,"code":"(fn [root]\n  (filter (fn[n] (not (sequential? n))) \n          (tree-seq \n           (fn[s] \n             (sequential? s)) \n           (fn[s] (seq s)) \n           root)))","user":"55101237e4b06e50f9beb181"},{"code":"(fn f [s]\n  (loop [s s\n         v []]\n    (cond (empty? s) v\n          (sequential? (first s)) (recur (rest s) (into v (f (first s))))\n          :else (recur (rest s) (conj v (first s)))\n          )\n    )\n  )","problem":28,"user":"5081566ce4b0946d0443855b"},{"code":"(fn this [lst]\n  (if (coll? lst)\n    (mapcat this lst)\n    (list lst)))","problem":28,"user":"4ec6559a535d6d7199dd36c9"},{"code":"(fn flt [xs] (mapcat #(if (coll? %) (flt %) (list %)) xs))","problem":28,"user":"4e3a9dae535deb9a81d77f4a"},{"problem":28,"code":"(fn flt [x]\n  (if (sequential? x)\n    (mapcat flt x)\n    (list x)))","user":"53d6024ae4b0e771c3025450"},{"problem":28,"code":"(fn [s]\n  (letfn [(strip [xs]\n  \t\t  (reduce #(if-not (sequential? %2)\n\t\t    (conj %1 %2)\n\t\t    (into [] (concat %1 (strip %2)))) '[] xs))]\n  (strip s)))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn flat-seq [s]\n  (cond (empty? s) '()\n        (coll? (first s)) (concat (flat-seq (first s))\n                                  (flat-seq (rest s)))\n        :else (cons (first s) (flat-seq (rest s)))))","problem":28,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":28,"code":"(fn flat-seq [seqs]\n    (cond (and (not (coll? (first seqs)))\n               (empty? (rest seqs)))\n          seqs\n          (not (coll? (first seqs)))\n          (concat (list (first seqs))\n                  (flat-seq (rest seqs)))\n          :rest\n          (concat (flat-seq (first seqs))\n                  (flat-seq (rest seqs)))\n          ))","user":"59edc518e4b0966464fe6a08"},{"code":"(fn flat [my-seq]\n  (let [[the-first & the-rest] my-seq]\n    (cond\n     (empty? my-seq) '()\n     (coll? the-first) (concat (flat the-first) (flat the-rest))\n     :else (cons the-first (flat the-rest)))))","problem":28,"user":"51508efce4b0c51f0585bbb4"},{"problem":28,"code":"(fn __ [s]\n  (let [f (first s) r (rest s)]\n    (cond\n      (empty? s) nil\n      (coll? f) (concat (__ f) (__ r))\n      :else (cons f (__ r))\n      )\n    )\n  )","user":"5be2e670e4b0ed4b8aab4ccc"},{"problem":28,"code":"#(loop [res %]\n   (if(not-any? coll? res)\n     res\n     (recur (reduce (fn [v x] (if (coll? x) (into v x) (conj v x))) [] res))))","user":"5cbd5b42e4b026601754b9f6"},{"problem":28,"code":"(fn fl [a]\n  (if (sequential? a)\n    (reduce\n      (fn [s e] (concat s (fl e)))\n      [] a)\n    [a]))","user":"53d78b64e4b0e771c3025466"},{"problem":28,"code":"(fn squash [coll]\n  (if (empty? coll)\n    '()\n    (let [[head & tail] coll]\n      (if (or (list? head) (vector? head))\n        (concat (squash head) (squash tail))\n        (cons head (squash tail))))))","user":"5bc8e91ee4b07a9b28b100ce"},{"code":"(fn [s]\n  (letfn [(fl [coll n] (if (coll? n)\n                         (reduce fl coll n)\n                         (conj coll n)))]\n    (reverse (reduce fl '() (list s)))))","problem":28,"user":"5080a697e4b01a93d3f38e49"},{"problem":28,"code":"(fn flat [data]\n  (mapcat #(if (coll? %)\n             (flat %)\n             (list %))\n          data))","user":"60096aabe4b074f607df667f"},{"problem":28,"code":"#(filter (complement sequential?)(tree-seq sequential? seq %))","user":"560e9a2de4b05f002753df52"},{"code":"(fn flt [coll]\n  (if (sequential? coll)\n    (mapcat flt coll)\n    (list coll)))","problem":28,"user":"52bdb689e4b07a9af5792306"},{"code":"(fn flatten-sequence [to-flatten]\n  (if (not (coll? to-flatten))\n    (list to-flatten)\n    (if (empty? to-flatten)\n      '()\n      (concat (flatten-sequence (first to-flatten)) (flatten-sequence (rest to-flatten))))))","problem":28,"user":"51d360d1e4b099f3b6acddff"},{"problem":28,"code":"(fn flat [ls]\n  (if (empty? ls)\n    ls\n    (if (coll? (first ls))\n      (concat (flat (first ls)) (flat (rest ls)))\n      (cons (first ls) (flat (rest ls))))))","user":"54ea5e91e4b024c67c0cf840"},{"code":"(fn f [s] \n  (if (some sequential? s) \n      (f \n        (reduce concat '() \n           (map #(if (sequential? %) (seq %) (conj '() %)) s)))\n      s))","problem":28,"user":"4f280840e4b0d6649770a010"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (sequential? x)\n      (apply concat (map my-flatten x))\n      (list x)))","user":"597f8c93e4b0dbe32238d0c1"},{"code":"(fn my [s]\n  (mapcat \n    #(if (not (instance? Iterable %))\n      (list %)\n      (my %))\n    s ))","problem":28,"user":"4f1052b9535d64f603146418"},{"problem":28,"code":"(fn [s] \n  (\n  reverse\n  (\n    (fn flat [s] (reduce (fn [new elem] (if (coll? elem) (concat (flat elem) new) (conj new elem))) () (seq s)))  s\n  )\n  )\n)","user":"57e56da8e4b0bfb2137f5ad6"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq % )))","problem":28,"user":"4f1d467c535d64f60314648a"},{"problem":28,"code":";; https://github.com/clojure/clojure/blob/clojure-1.8.0/src/clj/clojure/core.clj#L6850\n(fn\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"582bd5fae4b051871117bf7b"},{"problem":28,"code":"(fn flat [items]\n  (let [flat-fn (fn my-flatten [items]\n                            (loop [acc []\n                                   [curr & rest-items :as item] items]\n                              (if (empty? item)\n                                acc\n                                (if (sequential? curr)\n                                  (recur\n                                   (into acc (my-flatten curr))\n                                   rest-items)\n                                  (recur (conj acc curr) rest-items)))))]\n    (seq (flat-fn items))))","user":"55bbfd60e4b01b9910ae29ed"},{"code":"(comp (partial filter (complement sequential?))\r\n      (partial tree-seq sequential? seq))","problem":28,"user":"4f426a7ae4b0d7d3c9f3fcff"},{"problem":28,"code":"(fn test ([x] (filter (complement sequential?) (rest (tree-seq sequential? seq x)))))","user":"5e85d0bde4b09a7a73c8bbd6"},{"code":"(fn [coll]                                                         \n  ((fn mf [coll-stack]                                                          \n     (if (seq coll-stack)                                                       \n       (let [top-coll (first coll-stack)]                                       \n         (if (seq top-coll)                                                     \n           (let [elem (first top-coll)                                          \n                 new-coll-stack (cons (rest top-coll) (rest coll-stack))]       \n             (if (sequential? elem)                                             \n               (mf (cons elem new-coll-stack))                                  \n               (lazy-seq (cons elem (mf new-coll-stack)))))                     \n           (mf (rest coll-stack))))))                                           \n     (list coll)))","problem":28,"user":"4ec75077535d6d7199dd36e0"},{"code":"(fn f[s] \n  (reduce \n     (fn [v,item] \n       (if (coll? item)\n          (concat v (f item)) \n          (concat v (list item) ) \n         )   \n      ) \n      \n    '()\n    s \n    )           \n  )","problem":28,"user":"513f53c6e4b051389b345b40"},{"problem":28,"code":"(fn flat [[h & t]]\n  (concat (if (coll? h) (flat h) [h])\n          (if (coll? t) (flat t) [])))","user":"59f043d0e4b0966464fe6a3d"},{"problem":28,"code":"(fn f [x]\n  (cond \n   (empty? x)       x \n   (coll? (first x)) (concat (f (first x)) (f (rest x)))\n   :else            (cons (first x) (f (rest x)))\n  )\n)","user":"56df6351e4b0ca2494a095f3"},{"problem":28,"code":"(fn pow [s]\n  (if (empty? s)\n    s\n    (if (not (coll? (first s)))\n      (cons (first s) (pow (rest s)))\n      (into (pow (rest s)) (reverse (pow (first s)))))))","user":"579aff09e4b05b1deef9ade7"},{"problem":28,"code":"(fn [s]\n  ((fn flatten' [l acc]\n    (if (empty? l)\n      acc\n      (let [x (first l)]\n        (if (coll? x)\n          (flatten' (rest l) (concat acc (flatten' x '())))\n          (flatten' (rest l) (concat acc (list x)))))))\n    s '()))","user":"54431b6ee4b032a45b869385"},{"code":"(fn fl [s]\n  (mapcat\n    (fn [elem]\n      (if (coll? elem) (fl elem) (seq (list elem))))\n    s))","problem":28,"user":"4ea348ad535d7eef308072c4"},{"code":"#(loop [ans nil\n\t       lst %]\n\t  (if (nil? lst) (reverse (filter (fn[x](not (nil? x))) ans))\n\t      (if (or (seq? (first lst))\n\t\t      (vector? (first lst)))\n\t\t(recur ans (cons (first (first lst)) (cons (next (first lst)) (next lst))))\n\t\t(recur (cons (first lst) ans) (next lst)))))","problem":28,"user":"4e8849c5535d8b9bb0147ca4"},{"problem":28,"code":"(fn my-flatten [a]\n   (if (coll? a)\n     (mapcat my-flatten a)\n     [a]))","user":"5d9e8e40e4b000c986472bc2"},{"code":";;Annotating the Clojure source is instructive here: \n;(fn flat\n;  [x]\n;  (filter (complement sequential?)        ; we only want the non-sequential items from\n;    (rest (tree-seq sequential? seq x)))) ; the sequence representing the depth-first walk of trees in this conj tree\n\n; mapcat is the key to something that traverses less wastefully; it would be interesting to profile these two!\n(fn flat [x] (mapcat #(if (coll? %) (flat %) [%]) x)) ; with mapcat, per chouser","problem":28,"user":"50d4c626e4b09cc622d65a70"},{"problem":28,"code":"(fn flat [s]\n  (let [[x & r] s]\n    (cond (empty? s) '()\n          (coll? x) (concat (flat x) (flat r))\n          :else (cons x (flat r)))))","user":"58ee9b14e4b056aecfd47db0"},{"problem":28,"code":"(fn [lst] (filter #(not (sequential? %)) (tree-seq sequential? identity lst)))","user":"561eb82fe4b064ca9f4b16c7"},{"problem":28,"code":"(fn [xs]\n  (letfn [(flat [xs]\n                   (reduce\n                    (fn [result x]\n                      (if (sequential? x)\n                        (concat result (flat x))\n                        (concat result [x])))\n                    '()\n                    xs))]\n    (flat xs)))","user":"5f5e7158e4b02876ed9fcff0"},{"code":"(fn f [l]\n  (if (empty? l)\n    l\n    (if (> (count l) 1)\n      (if (not (sequential? (first l)))\n        (concat (list (first l)) (f (rest l)))\n        (concat (f (first l)) (f (rest l))))\n      (if (not (sequential? (first l)))\n        l\n        (f (first l))))))","problem":28,"user":"5368a275e4b0243289761e8f"},{"code":"(fn my-flat [x]\n  (filter #(not (sequential? %)) (tree-seq sequential? seq x)))","problem":28,"user":"4f04d312535dcb61093f6be7"},{"problem":28,"code":"(fn make-flat [xs]\n  (let [x (first xs)\n        remain (rest xs)]\n    (if-not (empty? xs)\n      (if (coll? x)\n        (concat (make-flat x) (make-flat remain))\n        (cons x (make-flat remain)))\n      ())))","user":"53d20e14e4b00fb29b22131a"},{"problem":28,"code":"(fn flat [d]\n    (if (sequential? d)\n        (mapcat flat d)\n        [d]))","user":"60471241e4b02d28681c77c9"},{"problem":28,"code":"(fn flat [lst]\n  (let [[f & r] lst]\n    (cond\n      (empty? lst) nil\n      (not (sequential? f)) (cons f (flat r))\n      :else (concat (flat f) (flat r))\n    )\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"problem":28,"code":"(fn [x] (apply (fn mfl\n    ([] '())\n    ([x & tail]\n       (if (or (seq? x) (vector? x))\n         (concat (apply mfl x) (apply mfl tail))\n         (concat [x] (apply mfl tail))\n       )\n    )\n  )\n  x)\n)","user":"5515649fe4b055c2f668d4e3"},{"code":"(fn [s]\n  (loop [s s]\n    (if (some sequential? s)\n      (recur (reduce (fn [acc v]\n                (if (sequential? v)\n                  (concat acc v)\n                  (concat acc [v])\n                  ))\n              []\n              s))\n      s)\n    )\n)","problem":28,"user":"4fa340b4e4b081705acca18c"},{"problem":28,"code":"(fn flats [el] \n  (if (coll? el)\n    (mapcat flats el)\n    (list el)))","user":"5c7d5463e4b0d597f478caa9"},{"problem":28,"code":"(fn [l]\n    (mapcat\n(fn flat [x]\n(if (coll? x)\n(mapcat flat x)\n[x]))\n  l))","user":"59636ec9e4b066ee0a44b0c8"},{"problem":28,"code":"(fn flatten-it[x](mapcat (fn[el] (if (coll? el) (flatten-it el) [el])) x))","user":"561d7246e4b064ca9f4b16b1"},{"problem":28,"code":"(fn my-flatten [coll]\n  (remove sequential?\n          (tree-seq sequential? identity coll)))","user":"53fd66a4e4b0de5c418485e3"},{"problem":28,"code":"(fn [s] \n  (filter (complement sequential?) (rest (tree-seq sequential? seq s))))","user":"54e606c3e4b024c67c0cf803"},{"problem":28,"code":"(fn [l] (filter #(not(sequential? %)) (tree-seq sequential? identity l)))","user":"5c435a9fe4b0e06e1360a367"},{"problem":28,"code":"(fn fl [s] (if (empty? s) '() (concat (if (coll? (first s)) (fl (first s)) (list (first s))) (fl (rest s)))))","user":"5d1e19c4e4b02ea6f0fb69af"},{"problem":28,"code":"(fn my_flatten [l]\n    (if (coll? l)\n        (mapcat my_flatten l)\n        (list l)))","user":"5686640ae4b0dcc4269f4050"},{"code":"(fn flt [l]\n  (reduce #(into\n            %1\n            (if (sequential? %2)\n              (flt %2)\n              [%2])) \n          [] \n          l))","problem":28,"user":"531c7f0de4b08068f379eda4"},{"code":"(fn f [list]\n    (if (empty? list) []\n      (let [x (first list)]\n        (concat (if (coll? x) (f x) [x]) \n                              (f (rest list))))))","problem":28,"user":"4fa30027e4b081705acca187"},{"problem":28,"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))\n;not mine","user":"57822efce4b0d36ec5835e91"},{"code":"(fn doflat [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"4fba77fae4b081705acca2df"},{"code":"(fn [coll]\n   (let [c (reduce #(if (sequential? %2) (concat %1 %2) (conj (vec %1) %2)) [] coll)]\n     (if (every? (complement sequential?) c)\n       c\n       (recur c))))","problem":28,"user":"514721c6e4b0d520409ed392"},{"problem":28,"code":"(fn [arg]\n  (letfn \n    [(flattener [node]\n      (cond\n        (sequential? node) (mapcat flattener node)\n        :else (list node)))]\n  (flattener arg))\n)","user":"5df70ee8e4b0a607a9a45c8a"},{"problem":28,"code":"(fn flat [coll]\n  (reduce (fn do-flatten [res item]\n            (if (sequential? item)\n              (reduce do-flatten res item)\n              (conj res item))) [] coll))","user":"5d45bd1de4b07c84aa5ae6a4"},{"problem":28,"code":"(fn flat [l]\n  (loop [l l\n         fl ()]\n    (cond\n      (empty? l) (reverse fl)\n      (or (seq? (first l)) (vector? (first l)))\n        (recur\n          (remove nil?\n            (list (first (first l)) (next (first l)) (next l)))\n          fl)\n      :else\n        (recur\n          (remove nil? (next l))\n          (cons (first l) fl)))))","user":"56069006e4b08b23635d3174"},{"problem":28,"code":"(fn myflatten [s]\n  (if (sequential? s)\n    (reduce concat (map myflatten s))\n    (list s)))","user":"5d8b4960e4b0915913b1d3d3"},{"code":"(fn flat [s]\n  (if (seq s)\n    (let [first (first s)\n          rest (rest s)]\n      (if (coll? first)\n        (concat (flat first) (flat rest))\n        (cons first (flat rest))))\n    ()))","problem":28,"user":"50a7ef7fe4b090657f4a5ce0"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) (tree-seq sequential? identity x)))","user":"5550bcece4b00713264bd9ae"},{"problem":28,"code":"(fn flat [s] (cond\n              (empty? s) '()\n              (sequential? (first s)) (concat (flat (first s)) (flat (rest s)))\n              :else (cons (first s) (flat (rest s)))))","user":"5ee93720e4b029a2061bbeb7"},{"code":"(fn flat [c]\n      (if (empty? c)\n          '()\n           (if (coll? (first c))\n               (concat (flat (first c)) (flat (rest c)))\n               (cons (first c) (flat (rest c))))))","problem":28,"user":"508d8ab2e4b0f17d83ea26be"},{"code":"(fn fltn [coll]\n  (cond (empty? coll) coll\n        (not (sequential? (first coll))) (cons (first coll) (fltn (rest coll)))\n        :else (concat (fltn (first coll)) (fltn (rest coll)))))","problem":28,"user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn [x] (letfn [(flatty [coll]\n  (let [[c & more] (seq coll)]\n    (concat \n     (if (nil? c) \n       '() \n       (if (sequential? c) \n         (flatty c) \n         (list c))) \n     (if (nil? more) \n       '() \n       (flatty more)))))] (flatty x)))","problem":28,"user":"52fb64b7e4b047fd55837009"},{"problem":28,"code":"(fn fltn [sq]\n  (if (empty? sq)\n    sq\n    (if (not (coll? (first sq)))\n      (concat (list (first sq))\n              (fltn (rest sq)))\n      (concat (fltn (first sq))\n              (fltn (rest sq))))))","user":"559d33b3e4b0ec2b359424d9"},{"code":"(let [flat\n      (fn [coll acc]\n        (if (nil? coll)\n          acc\n          (if (coll? (first coll))\n            (recur (concat (first coll) (next coll)) acc)\n            (recur (next coll) (cons (first coll) acc))\n          )\n        )\n      )]\n  (fn [z] (reverse (flat z '())))\n)","problem":28,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":28,"code":"(fn fltn [xs]\n  (reduce\n    #(if (sequential? %2)\n      (concat %1 (fltn %2))\n      (concat %1 (list %2)))\n   () xs))","user":"53751c5ee4b06839e8705e11"},{"problem":28,"code":"(fn f[x](if (coll? x)(mapcat f x)[x]))","user":"55dab408e4b0e31453f64ad9"},{"problem":28,"code":"(fn b[s]\n  (reverse (reduce (fn my-flatten [acc item]\n                     (if (coll? item)\n                       (reduce my-flatten acc item)\n                       (conj acc item)))\n                   '()\n                   s)))","user":"59636b6de4b066ee0a44b0c6"},{"code":"(fn f[& a]\n  (let [l  (first a)\n        r (rest  a)]\n    (if (nil? l)\n      []\n      (if (coll? l)\n        (concat (apply f l) (apply f r))\n        (cons l (apply f r))))))","problem":28,"user":"510b5596e4b078ea719210fd"},{"code":"(fn foo [x] (if (sequential? x) (reduce concat (map foo x)) (list x)))","problem":28,"user":"4f3e05a8e4b0e243712b1f79"},{"code":"(fn [l] (loop [new-l [] lst l]\n          (if (empty? lst)\n            (reverse new-l)\n            (let [elm (first lst)]\n              (if (coll? elm)\n                (recur new-l\n                       (concat elm (rest lst)))\n                (recur (cons elm new-l) (rest lst)))))))","problem":28,"user":"52f304b4e4b05e3f0be25f07"},{"problem":28,"code":"(fn flat [n]\n  (mapcat #(if (coll? %) (flat %) (list %)) n))","user":"5c748bf5e4b0fca0c16227cb"},{"code":"(fn [c]\r\n  (let [f (reduce #(if (coll? %2) (into % %2) (conj % %2)) [] c)]\r\n    (if (not (some coll? f))\r\n      f\r\n      (recur f))))","problem":28,"user":"4f410b63e4b0e243712b1fc5"},{"problem":28,"code":"(fn flat [[h & t]] \n  (cond\n   (and (nil? h) (nil? t)) '()\n   (coll? h) (concat (flat h) (flat t))\n   :else (cons h (flat t))))","user":"58b1f51de4b0ebc645576d05"},{"problem":28,"code":"#(loop [ns [] \n        xs %]\n    (if (seq xs)\n      (if (coll? (first xs))\n        (if (seq (rest (first xs)))\n         (recur ns  (cons (first (first xs)) (cons (rest (first xs)) (rest xs)))) \n         (recur ns  (cons (first (first xs)) (rest xs))))\n      (recur (conj ns (first xs)) (rest xs)))\n    ns))","user":"56743413e4b05957ce8c612e"},{"problem":28,"code":"(fn my-flatten [xs]\n  ((fn traverse [fseq [x & rst]]\n     (let [fseq (if (sequential? x)\n                  (traverse fseq x)\n                  (conj fseq x))]\n       (if rst\n         (traverse fseq rst)\n         fseq)))\n   [] xs))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"#(filter (complement sequential?) (tree-seq coll? seq %))","problem":28,"user":"502cd12fe4b0532a782a5e39"},{"problem":28,"code":"(fn myFlatten [xs] \n  (reduce concat \n          (map #(if (coll? %) \n                          (myFlatten %) \n                          (list %)) \n                   xs) ) )","user":"567798afe4b05957ce8c6169"},{"problem":28,"code":"(fn [expr] (letfn [(scalar? [x] (not (coll? x)))]\n             (loop [result expr]\n               (if (every? scalar? result) result\n                 (recur (loop [dummy `() i (dec (count result))]\n                          (if (>= i 0)\n                            (if (scalar? (nth result i))\n                              (recur (conj dummy (nth result i)) (dec i))\n                              (recur `(~@(nth result i) ~@dummy) (dec i)))\n                            (seq dummy))))))))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn foo [s] \n  (cond\n    (= [] s) '()\n    (sequential? s) (reduce\n                      #(cons %2 %1)\n                        (foo (rest s))\n                        (reverse (foo (first s))))\n    :else (list s)))","problem":28,"user":"4f3b5219e4b0e243712b1f2a"},{"problem":28,"code":"(fn flat [xs]\n      (let [f (first xs)\n            r (rest xs)]\n        (cond (empty? xs) nil\n              (sequential? f) (concat (flat f) (flat r))\n              :else (cons f (flat r)))))","user":"592af6eee4b072a2710fcf2c"},{"code":"(fn f [s] (if (coll? s) (mapcat f s) [s]))","problem":28,"user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn fl [l]\n  (if (empty? l) l\n      (let [a (first l)]\n        (if (or (seq? a) (vector? a))\n            (concat (fl a) (fl (rest l)))\n            (cons a (fl (rest l)))))))","problem":28,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":28,"code":"(fn flat [[f & r]]\n   (if (coll? f)\n     (concat (flat f) (flat r))\n     (if (not (= nil r))\n       (cons f (flat r))\n       (if (not (= nil f))\n         (list f)\n         '()))\n     ))","user":"5a7b363ae4b03baeef9276d9"},{"problem":28,"code":"(fn flt [x] (if (coll? x)\n              (mapcat flt x)\n              (list x)))","user":"56de78fde4b0ea9b8538f83c"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn m [collection element]\n            (if (sequential? element)\n              (reduce m collection element)\n              (conj collection element))) [] s))","user":"5e0d1947e4b099d064962f92"},{"code":"(fn flat [xs]\n  (loop [coll xs new-xs []]\n    (if (empty? coll)\n      new-xs\n    (if (sequential? (first coll))\n      (recur (rest coll) (concat new-xs (flat (first coll))))\n      (recur (rest coll) (concat new-xs [(first coll)]))))))","problem":28,"user":"4e6a2e83535d8ccf87e9fea7"},{"code":"(fn f [x]\n\t(mapcat \n\t\t#(cond\n\t\t\t(sequential? %) (f %)\n\t\t\t:else (list %))\n\t\tx))","problem":28,"user":"50b65966e4b0a86f8358ca6c"},{"problem":28,"code":"(fn [lst]\n   (loop [v (vec lst)]\n     (if (not (or (some seq? v) (some vector? v)))\n       (seq v)\n       (recur (reduce #(if (or (seq? %2) (vector? %2)) (into %1 %2) (conj %1 %2)) [] v)))))","user":"577fa91ee4b0d36ec5835e6a"},{"code":"reduce (fn flat [x y] (if (or (vector? y) (seq? y)) (reduce flat x y) (conj x y))) []","problem":28,"user":"5210ac52e4b080a8d9b9d63e"},{"code":"(fn flatten2 [coll]\n(\n reduce #(cond\n           (or (nil? %2) (and (coll? %2) (empty? %2))) %1\n           (coll? %2) (into [] (concat %1 (flatten2 %2)))\n           :default (conj %1 %2))\n        [] coll\n))","problem":28,"user":"4ff2f0a9e4b0678c553fc341"},{"problem":28,"code":"(fn flat [xs] (if (coll? xs) (mapcat flat xs) [xs]))","user":"5d88d820e4b0915913b1d3b1"},{"problem":28,"code":"(fn [s]\n  (loop [t s]\n    (if (some sequential? t)\n      (recur (reduce (fn [acc v]\n                (if (sequential? v)\n                  (concat acc v)\n                  (concat acc [v])\n                  ))\n              []\n              t))\n      t)\n    )\n)","user":"5a9f2c53e4b0d174b936c812"},{"code":"#(let [flat (fn flat[l]\n  (lazy-seq\n   (when-let [s (seq l)]\n     (let [f (first s)]\n       (if (coll? f)\n         (concat (flat f) (flat (rest s)))\n         (cons f (flat (rest s))))))))]\n\n(flat %))","problem":28,"user":"50d0b466e4b00b15ecee9764"},{"code":"(fn f [c] (let [[x & xs] c]\n          (if (nil? x) x\n            (if (sequential? x)\n              (concat (f x) (f xs))\n              (cons x (f xs))))))","problem":28,"user":"4e6a3b79535d8ccf87e9feb3"},{"code":"(fn fla* [l]\n  (cond\n     (not (coll? l)) (list l)\n     (empty? l) l\n     (and (= (count l) 1) (not (coll? (first l)))) l \n     :else (concat  (fla* (first l)) (fla* (rest l)))))","problem":28,"user":"4f04a06d535dcb61093f6bd9"},{"code":"(fn f [coll] (reduce (fn [acc x] (concat acc (if (sequential? x) (f x) [x]))) [] coll))","problem":28,"user":"5216933be4b000d124d989cf"},{"problem":28,"code":"#(reduce (fn rec-flatten[acc item]\n                  (if (coll? item) (reduce rec-flatten acc item)\n                  (conj acc item))) \n                  [] %)","user":"5fec4f5ee4b05ac5b16ea1bf"},{"problem":28,"code":"(fn [coll]\n  (if (not-any? sequential? coll) coll\n    (recur (reduce #(if (sequential? %2) (into %1 %2) (conj %1 %2)) [] coll))))","user":"5c13da47e4b01240ff5671a6"},{"problem":28,"code":"(fn f [s]\n  (if (or (seq? s) (vector? s))\n    (mapcat f s)\n    [s]))","user":"5e64ae6ce4b0fd0acd1586ac"},{"code":"(fn my-flatten [x]\n  (if (or (seq? x) (vector? x))\n    (reduce concat (map my-flatten x))\n    [x]))","problem":28,"user":"4e2edb0e535deb9a81d77f0d"},{"problem":28,"code":"(fn my-walk\n  [elems]\n   (when (seq elems)\n      (if (sequential? (first elems))\n        (concat (my-walk (first elems)) (my-walk (rest elems)))\n        (cons (first elems) (my-walk (rest elems))))))","user":"583166c1e4b051871117c025"},{"code":"(fn flatn [x]\n  (if (not (sequential? x)) nil\n    (if (empty? x) nil\n      (let [f (first x)]\n        (if (sequential? f)\n          (concat (flatn f) (flatn (rest x)))\n          (cons f (flatn (rest x)))\n        )\n      )\n    )\n  )\n)","problem":28,"user":"50aa777fe4b056ee01935866"},{"problem":28,"code":"(fn my-flat [c]\n  (if (coll? c)\n    (mapcat my-flat c)\n    [c]))","user":"5c73b8bae4b0fca0c16227ba"},{"problem":28,"code":"(fn flatten-seq\n  [input-seq]\n  (reduce (fn [acc item]\n            (prn item)\n            (if (coll? item)\n              (concat acc (flatten-seq item))\n              (concat acc (cons item ()))))\n          ()\n          input-seq)\n  )","user":"5cea925ce4b0a17bb84e2bd2"},{"problem":28,"code":"(fn flatt [x]\n  (if (empty? x)\n  \tx\n    (if (coll? (first x))\n      (flatt (concat (first x) (rest x)))\n      (conj (flatt (rest x)) (first x))\n    )\n  )\n)","user":"595ed97fe4b066ee0a44b051"},{"problem":28,"code":"(fn [seq]\n\t(loop [cur (first seq) coll (rest seq) result []]\n\t\t(if (and (not cur) (empty? coll))\n\t\t\t(apply list result)\n\t\t(if (coll? cur)\n\t\t\t(recur (first cur) (into coll (rest cur)) result)\n\t\t\t(recur (first coll) (rest coll) (conj result cur)))\n\t)))","user":"5c87c79be4b048ec896c591b"},{"problem":28,"code":"(fn flatten-elem [y]\n   (if (coll? y) \n      (if (> (count y) 0)\n        (concat (flatten-elem (drop-last y)) (flatten-elem (last y)))\n    )\n    [y]\n  ))","user":"556bbaaee4b09a3098a524f0"},{"problem":28,"code":"(fn [xs] (filter (complement sequential?) (tree-seq sequential? identity xs)))","user":"563e1c0ee4b0da801c4e4665"},{"code":"(fn flat [n]\r\n  (let [x (first n)\r\n        xs (rest n)]\r\n  (cond\r\n    (empty? n) '()\r\n    (coll? x) (concat (flat x) (flat xs))\r\n    :else (cons x (flat xs)))))","problem":28,"user":"4ddb339c535d02782fcbe9f9"},{"problem":28,"code":"(fn [coll]\n  (loop [x coll]\n    (if (some sequential? x)\n      (recur\n       (mapcat identity (map #(if (sequential? %) % [%]) x)))\n      x)))","user":"58303fc3e4b051871117c006"},{"code":"(fn flat [i]\n  (if (coll? i)\n    (mapcat flat i)\n    (cons i ())))","problem":28,"user":"502a5fa4e4b09e8f859a9fbd"},{"problem":28,"code":"(fn flatten_seq [x]\n\t(reduce (fn [vec n] \n\t\t\t(if (sequential? n)\n\t\t\t(concat vec (flatten_seq n))\n\t\t\t(concat vec  (list n))))\n\t\t[] x))","user":"553024c3e4b076ab5578f80d"},{"problem":28,"code":"(fn flat [[f & r :as t]]\n   (if (empty? t) '()\n    (concat \n     (if (coll? f)\n       (flat f) \n       (list f))\n     (flat r))))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(fn flat[x]\n  (if(not(sequential? x))\n    [x]\n    (let [l (first x)\n          r (next  x)]\n      (if (empty? r)\n        (flat l)\n        (concat (flat l) (flat r))))))","problem":28,"user":"50997a2be4b0cae2931060b6"},{"problem":28,"code":"(fn  [x] \n(filter (complement sequential?)\n        (rest (tree-seq sequential? seq x))))","user":"59f44189e4b0966464fe6aab"},{"problem":28,"code":"(fn my-flatten\n  ([coll]\n   (my-flatten coll []))\n  ([[current & remaining] result]\n   (if (empty? remaining)\n     (if (coll? current)\n       (into result (my-flatten current))\n       (conj result current))\n     (if (coll? current)\n       (into (into result (my-flatten current)) (my-flatten remaining))\n       (into (conj result current) (my-flatten remaining))))))","user":"52ea025ae4b09f7907dd14b5"},{"code":"(fn [x]\r\n  (filter (complement sequential?)\r\n   (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f17ab99535d64f603146457"},{"problem":28,"code":"(fn flat [x]\n (reduce\n  (fn [prev elem]\n    (if (coll? elem)\n      (apply conj prev (flat elem))\n      (conj prev elem)\n    )\n  )\n  []\n  x\n )\n)","user":"5e958767e4b0fbed045a380b"},{"problem":28,"code":"(fn wiz [s]\n  (if (sequential? s)\n    (mapcat wiz s)\n    (list s)\n  )\n)","user":"5822b578e4b04b46fc4b0fa4"},{"problem":28,"code":"(fn ans-28 [arr]\n  (if (empty? arr)\n    ()\n    (if (or (list? (first arr)) (vector? (first arr)))\n      (concat (ans-28 (first arr)) (ans-28 (rest arr)))\n      (concat (list (first arr)) (ans-28 (rest arr))))))","user":"608fac60e4b03bd49d9f36c7"},{"code":"(fn flat-coll\n  [coll-data]\n  (let [first-data (first coll-data) rest-data (next coll-data)]\n    (concat\n     (if (sequential? first-data)\n       (flat-coll first-data)\n       [first-data])\n     (when (sequential? rest-data)\n       (flat-coll rest-data)))\n    ))","problem":28,"user":"51e780dae4b0730ab87cf353"},{"code":"#(reverse ((fn [s ns cont]\n    (if (nil? s)\n      (if (nil? cont)\n        ns\n        (recur (first cont) ns (next cont)))\n      (if (sequential? (first s))\n        (recur (first s) ns (cons (next s) cont))\n        (recur (next s) (cons (first s) ns) cont)))) % nil nil))","problem":28,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":28,"code":"(fn my-flatten [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x ))))","user":"53ede8e3e4b0d648e757f4cc"},{"problem":28,"code":"(fn twenty-eight [x]\n  (if(coll? x)\n  (mapcat twenty-eight x)\n  [x]))","user":"57607706e4b08062f99a4e97"},{"problem":28,"code":"(fn collect [x] \n  (if(coll? x)\n     (if (empty? x)\n       []\n       (concat (collect (first x)) (collect (rest x))))\n    [x]))","user":"5ea7b04de4b00a66d4a951b6"},{"problem":28,"code":"(fn fltn [c]\n  (if (sequential? c)\n    \t(mapcat fltn c)\n    \t(list c)))","user":"559468cbe4b0c79f6e1db954"},{"problem":28,"code":"(fn f [s]\n   (mapcat #(if (sequential? %)\n              (f %)\n              (list %)) s))","user":"53ea5307e4b036ad0777e4e2"},{"code":"(fn foo [xs]\n  (reduce\n   #(concat %1 (if (coll? %2) (foo %2) [%2]))\n   [] xs))","problem":28,"user":"5004034ce4b0678c553fc447"},{"problem":28,"code":"(fn [x]\n    ((fn flat [l y]\n      (if (empty? l)\n          (reverse y)\n          (if (coll? (first l))\n              (flat (rest l) (concat (reverse (flat (first l) nil)) y))\n              (flat (rest l) (cons (first l) y))))) x nil))","user":"5a34f342e4b0ddc586f153d1"},{"problem":28,"code":";(fn flt [[head & rest]]\n;  (cond (nil? head) []  \n;        (coll? head) (concat (flt head) (flt rest))\n;        :else (concat [head] (flt rest))\n;       ))\n\n(fn flt [coll]\n  (if (coll? coll)\n    (mapcat flt coll)\n    [coll]))","user":"581b19e7e4b04b46fc4b0ec4"},{"problem":28,"code":"(fn [iseq](filter (complement sequential?) (tree-seq sequential? seq iseq)))","user":"59692530e4b069c0a1a197e4"},{"problem":28,"code":"#(loop [l %\n         a []]\n    (if-let [[x & s] l] \n      (if (coll? x)\n        (recur (cons (first x) \n                     (concat (rest x) \n                             s))   \n               a)\n        (recur s (conj a x))) \n      a))","user":"54b45938e4b05787c3b1638f"},{"code":"(fn fltn [coll]\n  (filter (complement sequential?) (tree-seq sequential? seq coll)))","problem":28,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn [coll]\r\n  (filter (complement sequential?) \r\n          (tree-seq sequential? seq coll)))","problem":28,"user":"4e18ed7a535d04ed9115e7f6"},{"code":"(fn my-flatten [xs]\n\t(mapcat #(if (coll? %) (my-flatten %) (list %)) xs))","problem":28,"user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [coll]\n\t(seq\n     (reduce\n      (fn my-flatten [v e]\n        (if (coll? e)\n          (reduce my-flatten v e)\n          (conj v e)))\n      [] coll)))","problem":28,"user":"534c1321e4b084c2834f4a89"},{"code":"(fn my-flatten [lst]\n    (if (empty? lst) lst\n        (let [[fst & rst] (seq lst)]\n          (cond\n           (seq? fst) (concat (my-flatten fst) (my-flatten rst))\n           (vector? fst) (concat (my-flatten (seq fst)) (my-flatten rst))\n           :else (cons fst (my-flatten rst))))))","problem":28,"user":"4f4a8707e4b0d56e7bb92c12"},{"problem":28,"code":"#(loop [s1 %, s2 `()]\n  (cond\n    (sequential? (first s1)) (recur (concat (first s1) (rest s1)) s2)\n    (empty? s1) (reverse s2)\n    :else (recur (rest s1) (cons (first s1) s2))))","user":"53c0bc5fe4b00fb29b221257"},{"problem":28,"code":"(fn\n  [s]\n  (loop [s s\n         f '()]\n    (if (= 0 (count s))\n      (reverse f)\n      (if (instance? clojure.lang.Seqable (first s))\n        (recur (concat (first s) (rest s)) f)\n        (recur (rest s) (conj f (first s)))))))","user":"5ec02e20e4b00a66d4a95288"},{"problem":28,"code":"(fn flat-seq [sequ]\n  (if (coll? sequ)\n    (mapcat flat-seq sequ)\n    [sequ]))\n;#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))","user":"5cf53196e4b087f62be35a94"},{"code":"#((fn myflatten\n    [x acc]\n     (if (empty? x)\n       acc\n       (let [x0 (first x)]\n         (if (coll? x0)\n           (myflatten (rest x) (into acc (myflatten x0 [])))\n           (myflatten (rest x) (conj acc x0)))))) % [])","problem":28,"user":"535526a2e4b04ce2eb3ed259"},{"code":"(fn \n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"51e595a6e4b0efabf93c02d8"},{"problem":28,"code":"(fn flatten-me [coll]\n  (reduce #(do\n             (if (coll? %2)\n               (if (some coll? %2)\n                 (vec (concat %1 (flatten-me %2)))\n                 (vec (concat %1 %2)))\n               (conj %1 %2)))\n          [] coll))","user":"59e0f38ae4b08badc2a0c500"},{"code":"(fn flt [es]\n  (cond\n   (= nil (first es)) ()\n   (sequential? (first es)) (concat (flt (first es)) (flt (rest es)))\n   :else (cons (first es) (flt (rest es)) )))","problem":28,"user":"52e276d9e4b09f7907dd1436"},{"problem":28,"code":";#(filter (complement coll?) (tree-seq coll? seq %))\n(fn f[s] (if (coll? s) (mapcat f s) [s]))","user":"5ccf21c4e4b0ccb0619628c1"},{"problem":28,"code":"(fn m [a]\n  (reduce\n  #(if (coll? %2)\n    (into %1 (m %2))\n    (conj %1 %2))\n  []\n  a))","user":"59e32913e4b08badc2a0c52c"},{"problem":28,"code":"#(loop [x % retval `()]\n   (cond\n    (sequential? (first x)) (recur (concat (first x) (rest x)) retval)\n    (empty? x) (reverse retval)\n    :else (recur (rest x) (cons (first x) retval))))","user":"51071f2ee4b05b2b4eee748e"},{"problem":28,"code":"(fn flatteno [col]\n  (loop [cur col\n         acc (transient [])]\n    (if (seq cur)\n      (if (and (sequential? (first cur))\n               (not (empty? (first cur))))\n        (recur \n         (rest cur)\n         ;; no into! for transients\n         (reduce conj! acc (flatteno (first cur))))\n        (recur (rest cur) (conj! acc (first cur))))\n      (persistent! acc))))\n\n;; nb: the core-implementation of flatten is (filter (complement sequential?) (tree-seq sequential? seq *arg))\n;; which is far more beautiful","user":"5d231255e4b02ea6f0fb69fe"},{"problem":28,"code":"(fn fl [xs]\n  (if (sequential? xs)\n      (mapcat fl xs)\n      [xs]))","user":"548fa2dfe4b0e286459a1240"},{"problem":28,"code":"(fn f[l]\n  (mapcat #(if (coll? %) \n             (f %) \n             (list %)) l))","user":"5416aacce4b01498b1a719ff"},{"problem":28,"code":"(fn f [c]\n   (if (empty? c)\n     '()\n     (let [[i & r] c]\n       (concat (if (coll? i)\n                 (f i)\n                 (list i))\n               (f r)))))","user":"5742ec91e4b05c31a32c0883"},{"problem":28,"code":"(fn flt [xs] (when-let [s (seq xs)] (if (coll? (first s)) (concat (flt (first s)) (flt (rest s))) (cons (first s) (flt (rest s))))))","user":"5888f271e4b0f1effa3b7726"},{"code":"(fn [x]\n  (filter #(not (sequential? %)) (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e7e8485535db169f9c79716"},{"code":"(fn [n]\n  (filter #(false? (coll? %))\n    (tree-seq coll? identity n)))","problem":28,"user":"4ee82223535d93acb0a66877"},{"code":"(fn fl [lat]\n    (cond\n     (empty? lat) lat\n     (or (seq? (first lat))\n         (vector? (first lat))) (concat (fl (first lat))\n                                        (fl (rest lat)))\n     :else (cons (first lat)\n                 (fl (rest lat)))))","problem":28,"user":"4e326f34535deb9a81d77f21"},{"problem":28,"code":"(fn bla [x] (if (sequential? x) (apply concat (map bla x)) (list x)))","user":"54e0a9c3e4b024c67c0cf7b5"},{"problem":28,"code":"(fn f [c] (if (sequential? c) (mapcat f c) (list c)))","user":"57e20474e4b0bfb2137f5a82"},{"problem":28,"code":"(fn flt [lst]\n  (mapcat #(if (sequential? %) (flt %) [%]) lst))","user":"55ede35ce4b0121d4835fde1"},{"problem":28,"code":"(fn my-flatten [a] (reduce #(if (coll? %2) (into %1 (my-flatten %2)) (conj %1 %2)) [] a))","user":"5c7bc0a5e4b0fca0c1622865"},{"problem":28,"code":"(fn [to-flatten]\n  (loop [flattened to-flatten]\n    (if (not-any? #(sequential? %) flattened)\n      flattened\n      (recur (mapcat #(if (sequential? %) % [%]) flattened)))))","user":"58408643e4b089d5ab817deb"},{"problem":28,"code":"(fn [ls] \n  (reverse \n   (\n    (fn flat [l xs] \n      (reduce \n       (fn [acc x] \n         (if (or (seq? x) (vector? x)) \n           (flat acc x) \n           (cons x acc))) \n       l \n       xs)) \n    [] \n    ls)))","user":"5581747fe4b05c286339e0fa"},{"problem":28,"code":"#(filter (complement coll?)\n          (rest (tree-seq coll? seq %)))","user":"53ab260ee4b047364c04444c"},{"problem":28,"code":"(fn tflat[col](reduce (fn[x y]( if(coll? y) (lazy-cat x (tflat y)) (lazy-cat x [y]) )) [] col))","user":"55129667e4b06e50f9beb1ac"},{"problem":28,"code":";; had to get hints on this one; my approach was verbose recursion that was close but busted\n\n;; from flatten source:\n;#(filter (complement sequential?)\n;         (rest \n;          (tree-seq sequential? seq %)))\n\n;; from hypirion:\n(fn -flatten [x] \n  (if (coll? x)\n      (mapcat -flatten x)\n      [x]))","user":"57407ab3e4b05c31a32c0854"},{"code":"(fn fltn [coll]\n  (loop [coll coll\n         fcoll '()]\n    (if (empty? coll)\n      fcoll\n      (let [x (first coll)]\n        (if (coll? x)\n          (recur (rest coll)\n                 (concat fcoll (fltn x)))\n          (recur (rest coll)\n                 (concat fcoll (list x))))))))","problem":28,"user":"519db0ede4b037b32803f9b9"},{"problem":28,"code":"(fn f [l] (concat (if (coll? (first l)) (f (first l)) (list (first l))) (if (= '() (rest l)) '() (f (rest l)))))","user":"553c05b7e4b09218d5f45011"},{"problem":28,"code":"(fn f [x]\n   (if (coll? x)\n     (mapcat f x)\n     [x]\n     )\n   )","user":"5a488c09e4b05d388ecb6b68"},{"code":"(fn __\r\n  ([x]\r\n  (let [f (first x) r (next x)]\r\n\t\t(concat\r\n\t\t\t(if (sequential? f)\r\n              (__ f)\r\n              [f]\r\n              )\r\n         \t(when (sequential? r)\r\n              (__ r))\r\n         )\r\n    )\r\n   )\r\n  )","problem":28,"user":"4fa719c0e4b081705acca1bf"},{"problem":28,"code":";(fn [s]\n;  (loop [s s, result ()]\n;    (cond\n;     (sequential? (first s)) (recur (concat (first s) (rest s)) result)\n;     (empty? s) (reverse result)\n;     :else (recur (rest s) (cons (first s) result)))))\n\n(fn [s]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq s)))","user":"53838b9ee4b06839e8705ee1"},{"problem":28,"code":"(fn f [[a & b]]\n  (concat\n    (if (coll? a) (f a) (list a))\n    (if (nil? b) '() (f b))))","user":"5ac91d90e4b0e27600da77bd"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flt l)\n        [l])\n      (if (sequential? r)\n        (flt r)))))","user":"564045a8e4b08d4f616f5edd"},{"problem":28,"code":"(fn flat [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (not (coll? f)) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"5f30296fe4b0574c87022c22"},{"code":"(fn f [s] (mapcat #(if (coll? %) (f %) (list %)) s))","problem":28,"user":"4f569a3ce4b0a7574ea71828"},{"code":"(fn fl [col]\n  (let [f (first col)\n        r (rest col)]\n    (cond (empty? col) col\n          (coll? f) (concat (fl f) (fl r))\n          :elth (cons f (fl r)))))","problem":28,"user":"53858594e4b06839e8705f05"},{"code":"(fn fl [coll]\n   (loop [coll coll\n          ncoll []]\n     (let [f (first coll)]\n       (if (empty? coll)\n       ncoll\n       (recur (rest coll)\n              ((if (or (seq? f) (vector? f) (list? f))\n                   #(concat %1 (fl %2))\n                   #(concat %1 [%2])) ncoll f))))))","problem":28,"user":"539f3397e4b0ca733b974496"},{"problem":28,"code":"(fn f [col s]\n  (if (coll? s)\n    (reduce f col s)\n    (conj col s))) []","user":"58ec8c7ae4b056aecfd47d64"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (sequential? x)\n    (mapcat my-flatten x)\n    [x]))","user":"572722c4e4b0c5bde472c134"},{"problem":28,"code":"(fn [c]\n    (loop [c c\n           r []]\n      (if-let [e (first c)]\n        (if (sequential? e)\n          (recur (concat e (rest c)) r)\n          (recur (rest c) (conj r e)))\n        r)))","user":"55d62a68e4b0e31453f64a96"},{"code":"mapcat (fn myfl[ls] (if (coll? ls) (mapcat myfl ls)\n                               (list ls)))","problem":28,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn mfl [coll]\r\n  (lazy-seq (cond\r\n\t\t\t\t(nil? coll) nil\r\n\t\t\t\t(instance? clojure.lang.Sequential coll) \r\n\t\t\t\t\t\t(if (empty? coll) coll (concat (mfl (first coll)) \r\n\t\t\t\t\t\t\t\t(mfl (rest coll))))\r\n\t\t\t\t :else (cons coll ()))))","problem":28,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":28,"code":"#(filter (complement sequential?)(tree-seq sequential? seq %))","user":"59cf0d75e4b0ef0a1e9b5b5f"},{"code":"#(reverse (reduce (fn f [s x] (if (sequential? x) (reduce f s x) (conj s x))) '() %))","problem":28,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":28,"code":"(fn flatter [nlist]\n  (if (empty? nlist) '()\n    (let [frst (first nlist)]\n      (if (coll? frst)\n        (concat (flatter frst) (flatter (rest nlist)))\n        (cons frst (flatter (rest nlist)))))))","user":"56df62b3e4b0ca2494a095ef"},{"code":"(fn flat [list] (reduce #(if (coll? %2) (into %1 (flat %2)) (conj %1 %2)) [] list))","problem":28,"user":"52f9c68ce4b047fd55836fef"},{"problem":28,"code":"(fn make-flat [coll]\n  (let [x (first coll) y (next coll)]\n    (concat\n      (if (sequential? x)\n        (make-flat x)\n        [x])\n       \t(when (sequential? y)\n          (make-flat y)))))","user":"542c026ae4b0dad94371f29a"},{"problem":28,"code":"(fn f [s]\n  (if (first s)\n    (if (sequential? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))\n    s))","user":"56eb3f9de4b04a395b9a0420"},{"problem":28,"code":"(fn [coll]\n  (loop [accum '()\n         todo coll]\n    (let [head (first todo)]\n      (if-not head\n        (reverse accum)\n        (if (or (seq? head) (vector? head))\n          (recur accum (apply conj (rest todo) (reverse head)))\n          (recur (conj accum head) (rest todo)))))))","user":"5b7608c9e4b047b03b2036da"},{"problem":28,"code":"(fn flatten' [xs]\n  (loop [in xs, out []]\n    (let [f (first in)\n          ff (if (coll? f) (flatten' f) [f])] \n\t  (if (empty? in)\n        out\n        (recur (rest in) (concat out ff))))))","user":"58247423e4b051871117bec5"},{"code":"(fn self \n   ([xs] (self xs []))\n   ([xs ret] \n   (let [x (first xs)] \n     (if x (self (rest xs) \n                 (if (sequential? x) \n                   (concat ret (self x [])) \n                   (conj (vec ret) x)) ) ret))))","problem":28,"user":"5282f54be4b0239c8a67ada0"},{"problem":28,"code":"(fn [seq]\n\t(loop [s seq]\n    (if \n      (some coll? s)\n      (recur \n        (reduce \n          (fn [acc it]\n            (println (type acc))\n            (if (coll? it) (vec (concat acc it)) (conj acc it))\n          )\n          []\n          s\n        )\n      )\n      s\n    )\n  )\n)","user":"5cbdc591e4b026601754ba00"},{"problem":28,"code":"(letfn [(f [l] (if (sequential? l) (mapcat f l) (list l)))] f)","user":"565eb771e4b068f2fe63dc36"},{"problem":28,"code":"(fn fl [x] (if (coll? x)\n                 (if (empty? x)\n                  '()\n                  (concat \n                   (fl (first x))\n                   (fl (rest x))\n                  ))\n               (cons x '())\n            )\n  )","user":"53fcd574e4b0de5c418485d9"},{"problem":28,"code":"(fn flattn [s]\n  (if (coll? s)\n      (mapcat flattn s)\n      [s]))","user":"54ecd709e4b024c67c0cf859"},{"code":"(fn f [l]\n  (cond\n    (nil? (seq l)) []\n    (sequential? (first l)) (concat (f (first l)) (f (rest l)))\n    :e (concat [(first l)] (f (rest l)))))","problem":28,"user":"4e8df08f535d65386fec213e"},{"code":"#((fn flatten' [[x :as xs]]\n  (cond\n   (or (list? x) (vector? x))\n    (into (flatten' (rest xs)) (reverse (flatten' x)))\n   (nil? x)\n   \t()\n   :else\n      (cons x (flatten' (rest xs))))) %)","problem":28,"user":"535f9604e4b04ce2eb3ed2dd"},{"code":"(fn f [lst]\r\n  (if (empty? lst)\r\n    '()\r\n    (if (coll? (first lst))\r\n      (concat (f (first lst))\r\n            (f (rest lst)))\r\n      (concat (list (first lst))\r\n            (f (rest lst))))))","problem":28,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn myflat [xs] \n  (if (sequential? xs)\n    (mapcat myflat xs)\n    (list xs)\n  )\n)","problem":28,"user":"5255bf1ee4b0541d1855b9f1"},{"code":"(fn flat [coll] (reduce (fn [x y] (concat x (if (coll? y) (flat y) [y]))) '() coll))","problem":28,"user":"51cec7b1e4b0e42293a2255b"},{"code":"(fn x-flatten [arg]\r\n  (if (coll? arg)\r\n    (apply concat [] (for [v arg] (x-flatten v)))\r\n    [arg]))","problem":28,"user":"4eccb190535d23f0362276fe"},{"code":"x","problem":28,"user":"52e635b3e4b09f7907dd146f"},{"code":"(fn f [s]\n  (if (empty? s) s\n    (if (coll? (first s))\n      (concat\n        (f (first s))\n        (f (rest  s)))\n      (cons\n        (first s)\n        (f (rest  s))))))","problem":28,"user":"4fb2101ce4b081705acca284"},{"problem":28,"code":"(fn f [x]\n  (if (= x '())\n    '()\n  \t(let [a (first x) b (rest x)]\n      (into (f b) (reverse (if (coll? a) (f a) (list a))))\n      )\n    )\n  )","user":"5799ff45e4b05b1deef9add1"},{"problem":28,"code":"(fn fl ([& x]\n(apply concat (apply map #(\nif (sequential? %) (fl %) [%]) x))))","user":"58335c22e4b089d5ab817c9a"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll acc '()]\n    (if (not (empty? coll))\n      (if (coll? (first coll))\n        (recur (concat (first coll) (rest coll)) acc)\n        (recur (rest coll) (cons (first coll) acc)))\n      (reverse acc))))","user":"5e471203e4b043cd24807a2a"},{"problem":28,"code":"(fn x\n  [ls]\n   (if (sequential? ls)\n     (mapcat x ls)\n     (list ls)))","user":"53bd85fae4b0d9a98559a6d4"},{"code":"(fn fl [coll]\n  (reduce concat\n          (map\n           #(if (sequential? %)\n              (fl %)\n              [%])\n           coll)))","problem":28,"user":"51170b49e4b0063b4e3e16d9"},{"code":"(fn flat [s]\n    (reduce #(if (sequential? %2) (vec (concat % (flat %2))) (conj % %2)) [] s)\n  )","problem":28,"user":"51424cc8e4b0b50abeb46b34"},{"code":"(fn flat [s]\n  (let [fst (first s)\n        rst (rest s)]\n    (cond (nil? fst) rst\n          (sequential? fst) (concat (flat fst) (flat rst))\n          :else (concat (list fst) (flat rst)))))","problem":28,"user":"5123f099e4b02c3f2a072cca"},{"problem":28,"code":"(fn ft [l] \n  (reduce (fn [cl e]\n            (if (sequential? e) \n              (into cl (ft e))\n              (conj cl e))) [] l))","user":"56051095e4b08b23635d3162"},{"code":"(fn f [x]\n  (if (empty x)\n      (apply concat (map f x))\n      (list x)))","problem":28,"user":"4e68dbd5535d8ccf87e9fe8f"},{"problem":28,"code":"(fn flatten2 ([x] (flatten2 '() x))\n  ([aux x] (if (empty? x) (reverse aux)\n             (let [f (first x) r (rest x)]\n               (if (coll? f) (recur aux (concat f r))\n                 (recur (conj aux f) r)))\n             )))","user":"53a2ec2be4b0f1fc74538830"},{"code":"(fn flat [& xs]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (mapcat flat x))\n              (conj acc x))) [] xs))","problem":28,"user":"5224a46ce4b01819a2de42e5"},{"problem":28,"code":"(fn flatten-4clj [xs]\n   (if-let [[y & ys] (seq xs)]\n     (if (coll? y)\n       (concat (flatten-4clj y) (flatten-4clj ys))\n       (conj (flatten-4clj ys) y))\n     (empty xs)))","user":"5d47fa13e4b07c84aa5ae6b6"},{"problem":28,"code":"#(loop [c % p '()]    \n    (if (= c p)\n      c\n      (recur (reduce\n               (fn [acc next]\n                 (if (coll? next)\n                   (concat acc next)\n                   (concat acc (list next))\n                   )\n                 )\n               '()\n               c\n               )\n             c\n             )))","user":"570e8d86e4b0b0fb43fd06f2"},{"problem":28,"code":"(fn flatten* [x]\n  (if (coll? x)\n    (apply concat (map flatten* x))\n    ;;(mapcat flatten* x)\n    [x]))","user":"53fc88e7e4b0de5c418485be"},{"problem":28,"code":"(fn my-flatten [s]\n  (loop [s s, res []]\n    (if (seq s)\n      (let [f (first s)]\n        (if (sequential? f)\n          (recur (concat f (rest s)) res)\n          (recur (rest s) (conj res f))))\n      res)))","user":"5a481e05e4b05d388ecb6b64"},{"code":"(fn [coll]\n  (loop [nest coll\n         flat '()]\n   (if (empty? nest)\n       (reverse flat)\n       (let [head (first nest),\n             tail (rest  nest)]\n        (if (coll? head)\n            (recur (concat head tail) flat)\n            (recur tail (conj flat head)))))))","problem":28,"user":"4f035bfd535dcb61093f6a8f"},{"code":"#(filter (complement sequential?)\n          (tree-seq sequential? seq %))","problem":28,"user":"5036eba7e4b0af0658af77a5"},{"code":"#(letfn [(flat [c e] (if (coll? e) (reduce flat c e) (conj c e)))]\n         (flat [] %))","problem":28,"user":"51473a70e4b0d520409ed394"},{"code":"(fn f [x] (if (sequential? x) (apply concat (map f x)) [x]))","problem":28,"user":"53705e2de4b0fc7073fd6e96"},{"problem":28,"code":"(fn [xs]\n  (loop [ flat_things [] \n          unflat_things xs ]\n    (if (empty? unflat_things)\n      flat_things\n      (if (coll? (first unflat_things))\n        (recur flat_things (concat (first unflat_things) (rest unflat_things)))\n        (recur (conj flat_things (first unflat_things)) (rest unflat_things))))))","user":"5d123457e4b02c15ef021996"},{"code":"(fn fflatten\n  [items]\n  (if (sequential? items)\n    (apply concat (map fflatten items))\n    (list items)))","problem":28,"user":"511720eae4b0063b4e3e16da"},{"problem":28,"code":"(fn flat\n  [lst]\n  (let [len (count lst)]\n  \t(loop [i 0 acc []]\n      (if (< i len)\n    \t(if (sequential? (nth lst i))\n          (recur (inc i) (vec (concat acc (flat (nth lst i)))))\n          (recur (inc i) (conj acc (nth lst i))))\n        acc))))","user":"5e668d87e4b0e171e1033681"},{"code":"(comp (partial filter (complement sequential?)) (partial tree-seq sequential? seq))","problem":28,"user":"4f6511eee4b07046d9f4ef3a"},{"problem":28,"code":"(fn myflatten [xs]\n  (if (sequential? xs)\n      (mapcat myflatten xs) [xs]))","user":"4f213e2ee4b0d66497709fcf"},{"code":"(fn flat [list]\n  (let [[x & xs] list]\n    (cond\n      (empty? list) ()\n      (coll? x) (concat (flat x) (flat xs))\n      :else (cons x (flat xs)))))","problem":28,"user":"4f0388e8535dcb61093f6b17"},{"problem":28,"code":"(fn i [l]\n  (reduce\n   (fn [a e]\n     (if (coll? e) (concat a (i e))\n         (conj (vec a) e))) [] l))","user":"54899701e4b0e286459a11ea"},{"problem":28,"code":"(fn fltn [x] \n        (cond \n          (not (sequential? x)) x\n          (empty? x) x\n          true (if (sequential? (first x)) \n                 (concat (fltn (first x)) (fltn (rest x)))\n                 (cons (first x) (fltn (rest x))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"(fn flatn [x] (if (coll? x) (mapcat flatn x) [x]))","problem":28,"user":"51bd1a0de4b0df1216cefd93"},{"problem":28,"code":"(fn [s]\n  (letfn [(flattn [s]\n                   (loop [res [] [f & r] s]\n                     (cond\n                      (nil? f) res\n                      (coll? f) (recur (into res (flattn f)) r)\n                      (empty? r) (conj res f)\n                      :default (recur (conj res f) r))))]\n    (flattn s)))","user":"586615e6e4b0f14aab7c8858"},{"problem":28,"code":"(fn myflatten [s]\n(if (coll? s)\n  (mapcat myflatten s)\n  [s])\n)","user":"51545663e4b084ca81ee2e18"},{"problem":28,"code":"#(letfn [(fl [coll] \n   (cond \n    (not (coll? coll)) (list coll)\n    (empty? coll) '()\n    (coll? coll) (concat (fl (first coll)) (fl (rest coll))) \n    ))] (fl %))","user":"5ddcf10ae4b0948ae9d9adbe"},{"problem":28,"code":"(fn fltten\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","user":"55893b09e4b059ccff29b1fe"},{"problem":28,"code":";#(reduce concat (map (fn my-flatten [elem] (if (sequential? elem)\n;                                             (reduce concat (my-flatten (first elem)) (map my-flatten (rest elem)))\n;                                             (list elem)))\n;                     %))\n\n(fn [ls] (filter (complement sequential?) (tree-seq sequential? identity ls)))","user":"5bfa3e02e4b0bdcf453d15ca"},{"problem":28,"code":"(fn [x]\n  (reverse ((fn my-flat-opt [x y]\n              (cond\n                (not (coll? x)) (cons x y) (empty? x) y\n                :else (my-flat-opt (rest x) (my-flat-opt (first x) y)))) [x] ())))","user":"566e5a03e4b0a866af6896d8"},{"code":"(fn [list] (loop [[x & xs] list acc []] (if x (if (sequential? x) (recur (if xs (apply conj (vec x) xs) x) acc) (recur xs (conj acc x))) acc)))","problem":28,"user":"4f4afb1fe4b0d56e7bb92c21"},{"problem":28,"code":"(fn [coll] (filter #(not (sequential? %)) (tree-seq sequential? identity coll)))","user":"5783a897e4b0ebec4cfb74b9"},{"code":"(fn [s]\n  (loop [c s]\n    (if (empty? (filter coll? c))\n      c\n      (recur (apply concat (map #(if-not (coll? %) (vector %) %) c))))))","problem":28,"user":"51197750e4b057cba170bc99"},{"code":"(fn  [l]\n  (letfn [(walk [acc l]\n            (cond\n              (coll? (first l)) (concat (walk '() (rest l)) (walk acc (first l)))\n              (= nil (first l)) acc\n              :else (walk (conj acc (first l)) (rest l))))]\n    (reverse (walk '()  (seq l)))))","problem":28,"user":"4df9c598535d04ed9115e77a"},{"problem":28,"code":"(fn f [s]\n  (cond\n    (empty? s) s,\n    (or (list? (first s)) (vector? (first s)))\n    (concat (f (first s)) (f (rest s))),\n    :else (cons (first s) (f (rest s)))))","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":28,"code":"; this i plagerized but I cannot delete it!\n(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"572ac718e4b0f4d77e651242"},{"code":"(fn f [n] (if-not (sequential? n) [n] (if (empty? n) n (concat (f (first n)) (f (rest n))))))","problem":28,"user":"4ee6400c535d93acb0a6685b"},{"problem":28,"code":"(fn flat [x] (if (coll? x) (if (= () x) x (concat (flat (first x)) (flat (rest x)))) (list x) ))","user":"56f258d3e4b04a395b9a04a1"},{"code":"#(reduce \n   (fn f [acc x](if (coll? x) (reduce f acc x)(conj acc x))) \n   [] %)","problem":28,"user":"50783762e4b0fc74642bff67"},{"problem":28,"code":"#(let [all-as-seq (fn [x] (if (sequential? x) x (list x)))\n                               flatten-one-level (fn [x] (apply concat (map all-as-seq x)))]\n                           (if (some sequential? %) (recur (flatten-one-level %)) %))","user":"55158345e4b055c2f668d4e8"},{"problem":28,"code":"(fn [sq]\n  (loop [accum [] remains (seq sq)]\n    (if-not (seq remains)\n      (sequence accum)\n      (let [ff (first remains)\n            rr (rest remains)]\n        (if (coll? ff)\n          \n          ;; getting a sequence, we just unwrap and keep going\n          (recur accum (concat ff rr))\n\n          ;; getting a value, add to accum, drop and keep going\n          (recur (conj accum ff) rr))))))","user":"57aa053fe4b0b8559636fc61"},{"code":"(fn fl [x] (mapcat #(if (coll? %) (fl %) (vector %)) x))","problem":28,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn flt [coll]\n  (let [c (if (vector? coll) (seq coll) coll)]\n    (apply\n      concat\n      (map #(if\n        (or (seq? %) (vector? %)) (flt %)\n        (list %)) c))))","problem":28,"user":"4f4e978ae4b03ad3f0c10ccb"},{"problem":28,"code":"(fn flatten* [xs]\n  (if (coll? xs)\n    (mapcat flatten* xs)\n    [xs]))","user":"5bea3177e4b0f319e2d7ec81"},{"code":"(fn f [l] \n  (if (coll? l)\n    (apply concat  (map f l))\n    [l]))","problem":28,"user":"50090fc7e4b0144d4f561e44"},{"problem":28,"code":"(fn f [xs]\n    (if (seq xs)\n      (if (sequential? (first xs))\n        (apply conj  (f (rest xs)) (reverse (f (first xs))))\n        (conj (f (rest xs)) (first xs)))\n      '()))","user":"505223fae4b0a561d07d8f17"},{"problem":28,"code":"(fn my-flatten [a-nested-coll]\n  (loop [to-process a-nested-coll\n         in-process '()\n         flat-seq '()]\n    (if (coll? in-process)\n      (if (empty? in-process)\n        ;; case 1: in-process is empty\n        (recur\n         (rest to-process)\n         (first to-process)\n         flat-seq)\n        ;; case 2: in-process is a collection\n        (recur\n         (into to-process (rest in-process))\n         (first in-process)\n         flat-seq))\n      (if (empty? to-process)\n        ;; case 3 (end state): in-process is not a collection,\n        ;; and there is nothing left in to-process\n        (reverse (conj flat-seq in-process))\n        ;; case 4: in-process is not a collection, but we\n        ;; have more in to-process\n        (recur to-process '() (conj flat-seq in-process))))))","user":"5d7a748ce4b02e6b30c93547"},{"code":"(fn flt [[hd & tail]]\n  (cond\n    (nil? hd) nil\n    (coll? hd) (concat (flt hd) (flt tail))\n    :else (cons hd (flt tail))))","problem":28,"user":"5177f89ae4b0f89a8f53839a"},{"code":"(fn [coll]\n  (loop [out-coll []\n         in-coll (seq coll)]\n    (cond\n      (empty? in-coll) out-coll\n      (sequential? (first in-coll)) (recur out-coll (concat (first in-coll) (rest in-coll)))\n      :default (recur (conj out-coll (first in-coll)) (next in-coll)))))","problem":28,"user":"506406c8e4b075d771da6f9f"},{"problem":28,"code":"(fn flt [coll] (let [l (first coll) r (next coll)] (concat (if (sequential? l) (flt l) [l]) (when (sequential? r) (flt r)))))","user":"5673c886e4b05957ce8c6123"},{"problem":28,"code":"(fn flatten' [[item & remaining]] \n    (if (nil? item) nil\n        (concat (if (coll? item) (flatten' item) (list item)) (flatten' remaining))))","user":"602c30e3e4b0d5df2af2226f"},{"problem":28,"code":"(fn flat [l] \n  (let [h (first l) \n        t (rest l)] \n    (concat (if (sequential? h) \n              (flat h) \n              (list h)) \n            (when (and (sequential? t) \n                       (not (empty? t)))\n              (flat t)))))","user":"53b91803e4b047364c0444e5"},{"problem":28,"code":"(fn [coll]\n  (let [helper (fn helper [acc coll]\n                 (let [head (first coll)\n                       tail (next coll)]\n                   (cond\n                     (nil? head) acc\n                     (sequential? head) (helper (helper acc head) tail)\n                     :else (helper (conj acc head) tail))))]\n    (helper [] coll)))","user":"4f0554aa535dcb61093f6bf5"},{"problem":28,"code":"(fn _flatten [coll]\n  (reduce (fn [flat elem]\n            (concat flat\n                    (if (sequential? elem)\n                      (_flatten elem)\n                      (list elem))))\n          ()\n          coll))","user":"546ed28be4b00cfc9eacc1a5"},{"problem":28,"code":"(fn new-flatten [x]\n  (if (some coll? x)\n    (new-flatten \n     ((fn [x] \n        (reduce #(if (coll? %2)\n                  (vec (concat %1 %2))\n                  (conj %1 %2))\n          \t\t[] x)) x))\n    x))","user":"5b9263ece4b0c0b3ffbd4a37"},{"problem":28,"code":"(fn [s]\n  (loop [s s]\n    (let [r (reduce (fn [c e] (if (sequential? e) (apply conj c e) (conj c e))) [] s)]\n      (if (some sequential? r) (recur r) r))))","user":"560d491ae4b05f002753df3b"},{"problem":28,"code":"(fn flat [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (sequential? f) (concat (flat f) (flat r))\n          :else  (cons f (flat r)))))","user":"5db0d470e4b0f8c104ccfc9e"},{"problem":28,"code":"(fn flat[xs]\n  (reduce (fn [acc x]\n            (if (not (sequential? x))\n              (conj acc x)\n              (into [] (concat acc (flat x))))) [] xs))","user":"5e9b7aefe4b0157ca96647f1"},{"problem":28,"code":"(fn my-flatten [collection]\n  (reduce (fn [flattened element]\n            (concat\n              flattened\n              (if (sequential? element) (my-flatten element) (list element))))\n          '()\n          collection))","user":"5712418fe4b09c608db70455"},{"problem":28,"code":"(fn this-func [L]\n    (loop\n      [Ret '() First (first L) Rest (rest L) ]\n      (if (nil? First) \n        ;;    ,   \n        Ret\n        ;;        \n        ;; , ,  \n        (recur \n          (concat Ret\n            (if (nil? (empty First))\n              (list First)\n              (this-func First)\n            )\n          )\n          (first Rest)\n          (rest Rest)\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":28,"code":"(fn _flatten [x] (if (coll? x) (mapcat _flatten x) [x]))","user":"5e4b8fe8e4b0889a8790a555"},{"code":"(fn ff [x] (if (not (coll? x))\n                (list x)\n                (if (empty? x)\n                    '()\n                    (concat (ff (first x)) (ff (rest x))))))","problem":28,"user":"4fd0cb0ee4b04c3a95aa0407"},{"problem":28,"code":"(fn m [coll]\n  (reduce (fn [acc curr]\n            (if (coll? curr)\n              (concat (m curr) acc)\n              (cons curr acc))) () (reverse coll)))","user":"5c15537ae4b01240ff5671bf"},{"code":"(fn [x]\n  (filter (complement sequential?) (tree-seq sequential? identity x)))","problem":28,"user":"5244380fe4b076204b44fb12"},{"problem":28,"code":"(fn [l] (loop[l l res []] (if (empty? l) res (if (sequential? (first l)) (recur (concat (first l) (rest l)) res) (recur (rest l) (conj res (first l)))))))","user":"5e04ce34e4b0a607a9a45d71"},{"problem":28,"code":"(fn flat [s]\n  (if (sequential? s) \n    (seq (reduce concat (map flat s)))\n    [s]\n  )\n)","user":"5bca2c71e4b07a9b28b100e7"},{"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n             ;(list acc)\n             )]\n    (reduce f* [] c)\n    ))","problem":28,"user":"51d662fce4b0154f82ab92ef"},{"problem":28,"code":"(fn flatten-clone [s]\n  (cond\n    (empty? s) '()\n    (sequential? (first s)) (concat (flatten-clone (first s)) (flatten-clone (next s)))\n    :else (cons (first s) (flatten-clone (next s)))))","user":"5879d577e4b01531a375ead8"},{"problem":28,"code":"(fn flatter [xs]\n  (if (empty? xs)\n    xs\n    (let [y (first xs)\n          ys (rest xs)]\n      (if (coll? y)\n        (concat (flatter y) (flatter ys))\n        (cons y (flatter ys))\n        )\n      )\n    )\n  )","user":"5cbdadeee4b026601754b9ff"},{"problem":28,"code":"(fn myf [xs]\n    (apply concat (map (fn [x]\n                           (if (or (seq? x) (vector? x))\n                             (myf x)\n                             [x]\n                             ))\n                       xs)))","user":"54ff6084e4b07d26eda61d50"},{"problem":28,"code":"(fn flat [x] \n        (if (sequential? x) \n          ; Recurse and concatenate results\n           (distinct (mapcat flat x))\n          ; else just eval to a singleton list\n           (list x)\n          ))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn my-flatten [coll]\n  (if (coll? coll)\n    (mapcat my-flatten coll)\n    (list coll)))","problem":28,"user":"522d0360e4b0806774ddfef7"},{"code":"(fn flatten-seq [c]\r\n  (if (empty? c) c\r\n    (if (coll? (first c))\r\n      (concat (flatten-seq (first c)) (flatten-seq (rest c)))\r\n      (cons (first c) (flatten-seq (rest c))))))","problem":28,"user":"4daed74dedd6309eace4d163"},{"code":"(fn flat [x]\n  (if (coll? x)\n(apply concat (map flat x))\n(list x)))","problem":28,"user":"4fcebce4e4b03432b189f404"},{"code":"(fn flatify [x]\n  (if (coll? x)\n    (mapcat flatify x)\n    [x]))","problem":28,"user":"4f58fe71e4b0a7574ea7185f"},{"problem":28,"code":"(fn fl [xs]\n  (loop [xs xs\n         flat []]\n    (if (empty? xs)\n      flat\n      (if (coll? (first xs))\n        (recur (rest xs) (vec (concat flat (fl (first xs)))))\n        (recur (rest xs) (conj flat (first xs)))))))","user":"5fa8424ce4b0fa27300f3de5"},{"problem":28,"code":"(fn flat\n  [s]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq s))))","user":"5609816ee4b0053d1b86c7e1"},{"problem":28,"code":"(fn flatten2 [a](if (not (sequential? a)) `(~a) (reverse (reduce #(apply (partial conj %1) (flatten2 %2)) () a))))","user":"55af7e21e4b03311e7b732cc"},{"code":"(fn f [c]\n  (when-let [a (seq c)]\n    (let [[x & y] a]\n      (if (sequential? x)\n        (concat (f x) (f y))\n        (cons x (f y))))))","problem":28,"user":"4f5d0f25e4b0030a34fb2b33"},{"problem":28,"code":"(fn [xs]\n  (seq\n   (reduce\n    (fn flat [v e]\n      (if (coll? e)\n        (reduce flat v e)\n        (conj v e)))\n    [] xs)))","user":"590e588ce4b047aa04b19a23"},{"code":"(fn flatter [x]\n  (if (empty? x)\n    '()\n    (if (coll? (first x))\n        (concat (flatter (first x))(flatter (rest x)))\n        (cons (first x) (flatter (rest x))))))","problem":28,"user":"4e6a60cd535d8ccf87e9fed7"},{"code":"(fn f [s]\n  (if (coll? s)\n    (mapcat f s)\n    (list s)))","problem":28,"user":"52ce4cafe4b07d0d72b2738e"},{"code":"(fn my-flatten [x & rest] (concat (if (coll? x) (apply my-flatten x) [x]) (when (not (nil? rest)) (my-flatten rest))))","problem":28,"user":"53629381e4b0243289761e54"},{"problem":28,"code":"(fn flj [c] (if (sequential? c) (mapcat flj c) (list c)))","user":"55ec879ae4b0121d4835fdc8"},{"code":"(fn flat [[x & more :as coll]]\n  (cond \n    (empty? coll) []\n    (coll? x) (lazy-cat (flat x) (flat more))\n    :else (lazy-cat (vector x) (flat more))))","problem":28,"user":"4ea76541535d7eef308072eb"},{"problem":28,"code":"(fn [se]\n  (reduce (fn helper [acc elm]\n            (if (sequential? elm)\n              (reduce helper acc elm)\n              (conj acc elm)))\n          [] se))","user":"5fbf6fe7e4b0ad6fc3476147"},{"code":"(fn stomp ([s] (stomp s []))\n   ([s r]\n   (loop [ss s rr r]\n     (if (empty? ss)\n       rr\n       (let [fs (first ss)]\n         (recur (rest ss) (if (coll? fs) (stomp fs rr) (conj rr fs))))))))","problem":28,"user":"52c81954e4b0c2d177d6212e"},{"problem":28,"code":"#(loop [res []\n       input %]\n  (cond\n    (empty? input) res \n    (coll? (first input)) (recur res (concat (first input) (rest input)))\n    :else (recur (conj res (first input)) (rest input))))","user":"57642916e4b0994c1922fbee"},{"problem":28,"code":"#(filter (complement coll?)\n         (tree-seq coll? identity %1))","user":"5433a07be4b0b6b47310fce0"},{"code":"#((fn flat [acc sq]\n  (cond (empty? sq) acc\n    (sequential? (first sq))\n      (concat acc (flat acc (first sq)) (flat acc (rest sq)))\n    :else\n      (concat acc (list (first sq)) (flat acc (rest sq)))))\n() %)","problem":28,"user":"4fc0853ae4b081705acca327"},{"code":"(fn flatten* [coll]\n  (reduce #(if (coll? %2)\n    (apply conj %1 (flatten* %2))\n    (conj %1 %2)) [] coll))","problem":28,"user":"4fae4c11e4b081705acca248"},{"problem":28,"code":"(fn flt [coll]\n  (if (coll? coll)\n    (mapcat flt coll)\n    (list coll)))","user":"605b7a90e4b079a07f8593fc"},{"problem":28,"code":"(fn flat [coll]\n (let [f (first coll)\n       r (next coll)]\n   (concat\n\t   (if(sequential? f)\n           (flat f)\n           [f]\n       )\n       (when(sequential? r)\n         (flat r)\n       )\n    )\n   )\n  )","user":"53d70f3be4b0e771c302545f"},{"problem":28,"code":"(fn flat [ls]\n  (if (empty? ls)\n    ls\n    (let [elem (first ls)]\n      (concat (if (coll? elem)\n                (flat elem)\n                [elem])\n              (flat (rest ls))))))","user":"524e79c1e4b0541d1855b7e0"},{"problem":28,"code":"(fn my-flatten\n  [args]\n  (lazy-seq\n    (reduce (fn flattener [col v]\n              (if (sequential? v)\n                (reduce flattener col v)\n                (conj col v)))\n            []\n            args))\n  )","user":"607d97a6e4b03d835a6eaecf"},{"code":"(fn [xs]                                                                                            \n  (let [[scalar-xs coll-xs] (split-with #(not (coll? %)) xs)]                                 \n    (if (empty? coll-xs)                                                                      \n      xs                                                                                      \n      (recur (concat scalar-xs (first coll-xs) (rest coll-xs))))))","problem":28,"user":"508a2c2fe4b016a2107004a1"},{"code":"(fn myflat\n        ([s] (myflat (vector) s))\n        ([vs s]\n           (if (empty? s)\n             vs\n             (loop [fst (first s)\n                   rst (rest s)]\n               (if (sequential? fst)\n                 (recur (first fst) (into rst (rest fst)))\n                 (myflat (conj vs fst) rst))))))","problem":28,"user":"52c58561e4b0c2d177d620f8"},{"code":"(fn [s]\n  ((fn fun2 [s f]\n    (let [a (first s) b (rest s)]\n      (cond\n        (empty? s)      f\n        (sequential? a) (recur b (fun2 a f))\n        :else           (recur b (conj f a))))) s []))","problem":28,"user":"5256627ce4b0541d1855ba1a"},{"problem":28,"code":"(fn [coll]\n  (\n   (fn doit [coll ans]\n  (if (empty? coll)\n    ans\n    (if (coll? (first coll))\n      (recur (concat '() (first coll) (rest coll)) ans)\n      (recur (rest coll) (concat ans [(first coll)]))\n      )\n    )\n  )\n   coll '()\n   )\n  )","user":"56c72507e4b0ed865f9758b7"},{"code":"(fn f [n]\n  (if (coll? n)\n    (mapcat f n)\n    [n])\n  )","problem":28,"user":"4eaa96e1535d7eef3080730d"},{"problem":28,"code":"(fn [x]\n\t(filter (complement sequential?)\n        \t(rest (tree-seq sequential? seq x))))","user":"5391ab43e4b0b51d73faaea6"},{"code":"#(filter (complement sequential?) (tree-seq sequential? identity %\r\n))","problem":28,"user":"4f085a31535dcb61093f6c35"},{"problem":28,"code":"(fn my-flatten [coll]\r\n  (reduce (fn flat-el [acc el]\r\n            (if (coll? el)\r\n              (reduce flat-el acc el)\r\n              (conj acc el)))\r\n          []\r\n          coll))","user":"5f5396d4e4b0a0bc16850a79"},{"problem":28,"code":"(fn my-flatten [s]\n  (let [f (first s) r (next s)]\n    (concat \n      (if (sequential? f)\n        (my-flatten f)\n        [f])\n      (when (sequential? r)\n        (my-flatten r)))))","user":"53b85932e4b047364c0444db"},{"problem":28,"code":"(fn fl [l] (if (sequential? l) (\n                         if (empty? l) \n                           l \n                           (concat \n                              (fl (first l)) \n                              (fl (rest l)) \n                            )\n                         ) \n                         (list l)\n             )\n  )","user":"56a75810e4b0542e1f8d14fc"},{"problem":28,"code":"(fn [x]\n\t(filter #(not (coll? %)) (tree-seq coll? identity x)))","user":"5456e4e7e4b080a794c2c883"},{"problem":28,"code":"#(reverse ((fn flat [sq]\n            (reduce \n              (fn [a b] \n                 (if (or (seq? b) (vector? b)) \n                   (concat (flat b) a) \n                   (conj a b))) \n               '() \n               sq)) %))","user":"54bcd12be4b0ed20f4ff6ed7"},{"problem":28,"code":"#(reduce (fn flat\n          [acc i]\n          (if (sequential? i)\n            (reduce flat acc i)\n            (conj acc i)))\n         [] %)","user":"58ef93ece4b056aecfd47dca"},{"code":"(fn [x & more]\n  (let [m (fn [x y]\n               (loop [acc y\n                      temp (reverse x)]\n                 (if (empty? temp)\n                   acc\n                   (recur (conj acc (first temp)) (rest temp)))))]\n       (loop [acc '()\n              queue x]\n         (println acc queue)\n         (if (empty? queue)\n           (reverse acc)\n           (let [f (first queue)\n                 r (rest queue)]\n             (if (-> f coll? not)\n               (recur (conj acc f) r)\n               (recur acc (m (conj (rest f) (first f)) r))))))))","problem":28,"user":"4f08a8a2535dcb61093f6c3d"},{"code":"(fn flatn [x] (if (coll? x)(mapcat flatn x) [x]))","problem":28,"user":"52795656e4b03e8d9a4a7534"},{"problem":28,"code":"(fn flat [s] \n  (loop [left s res []]\n    (cond \n      (empty? left) res\n      (coll? (first left)) (recur (rest left) (apply conj res (flat (first left))))\n      :else-not-seq (recur (rest left) (conj res (first left)))\n    )\n  )\n)","user":"5f686436e4b02876ed9fd03c"},{"code":"#(loop [result [] col %]\n   (cond (empty? col) (seq result)\n         true\n         (let [fst (first col)]\n           (recur (if (sequential? fst)\n                    result\n                    (conj result fst)\n                  )\n                  (if (sequential? fst)\n                    (into (vec fst) (rest col))\n                    (rest col)\n                  )\n           )\n         )\n   )\n)","problem":28,"user":"4f7683dae4b0fbe0118ec56f"},{"problem":28,"code":"(fn my-flatten [input-seq]\n  (if (sequential? input-seq)\n    (apply concat (map my-flatten input-seq))\n    (list input-seq)))","user":"53b05a36e4b047364c044481"},{"code":"(fn flat [coll] (mapcat #(if (coll? %)\n                                    (flat %)\n                                    (list %)) coll))","problem":28,"user":"4e5f034b535d8a8b8723a2d9"},{"problem":28,"code":"#(loop [a % ret []]\n        (cond (empty? a) ret\n              (sequential? (first a)) (recur (concat (first a) (rest a)) ret)\n              :else (recur (rest a) (conj ret (first a)))\n              ))","user":"5405885ee4b0addc1aec6668"},{"problem":28,"code":"(fn fl [coll]\n  (if (seq coll)\n    (let [e (first coll)]\n      (if (sequential? e)\n        (concat (fl e) (fl (rest coll)))\n        (cons e (fl (rest coll)))))))","user":"53480973e4b084c2834f4a52"},{"code":"(fn fl [xs]\n   (loop [xs xs\n          res-xs []]\n     (if (empty? xs)\n       res-xs\n       (recur (rest xs) (if (coll? (first xs))\n                          (concat res-xs (fl (first xs)))\n                          (conj (vec res-xs) (first xs)))))))","problem":28,"user":"531bfb69e4b08068f379ed97"},{"problem":28,"code":"(fn flatten-me\n  [s]\n  (->> (tree-seq sequential? seq s)\n       rest\n       (filter (comp not coll?))))","user":"562e8b2be4b0ab312c17ebbb"},{"problem":28,"code":"#(let [tree-seq (fn [branch? children root]\n    (let [walk (fn walk [node]\n               (lazy-seq\n                (cons node\n                      (when (branch? node)\n                        (mapcat walk (children node))))))]\n    (walk root)))]\n   (filter (complement sequential?) (rest (tree-seq sequential? seq %))))","user":"55da18d5e4b0e31453f64ad1"},{"problem":28,"code":"(fn [l]\n  (loop [cur l\n         acc []]\n    (if (empty? cur)\n      acc\n    (let [f (first cur)\n          r (rest cur)]\n      (if (sequential? f) (recur (concat f r) acc)\n        (recur r (conj acc f)))))))","user":"5c1edf23e4b0efcb0b05b25d"},{"code":"(fn flatten2\n\n\n  \n\n  [x]\n\n  (letfn [(flat [coll]\n\n                  (lazy-seq\n\n                (when-let [c (seq coll)]\n\n                     (let [x (first c)]\n\n                       (if (sequential? x)\n\n                         (concat (flat x) (flat (rest c)))\n\n                         (cons x (flat (rest c))))))))]\n\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"50291679e4b0b6c928ad6200"},{"problem":28,"code":"(fn my-flat\n  [n]\n  (let [[x & xs] n]\n    (if (empty? n)\n      '()\n      (if (coll? x)\n        (concat (my-flat x) (my-flat xs))\n        (cons x (my-flat xs))))))","user":"57596ba7e4b02ea11479931a"},{"problem":28,"code":"(fn myFlatten [x]\n\n  (if (coll? x)\n\n    (mapcat myFlatten x)\n\n    [x]))","user":"57073037e4b0b0fb43fd0689"},{"code":"(fn alt_flat [x]\n  (if-not (nil? x)\n    (if-not (sequential? x)\n      [x]\n      (concat (alt_flat(first x)) (alt_flat(next x)))\n    )\n  )\n)","problem":28,"user":"531488f3e4b08068f379ed16"},{"code":"(fn f [col] \n  (let [x (first col) xs (rest col)]\n    (concat\n      (if (coll? x) \n        (f x) \n        [x])\n      (when (and (coll? xs) (seq xs))\n        (f xs)))))","problem":28,"user":"4ffa8affe4b0678c553fc3bd"},{"problem":28,"code":"(fn this [x]\n  (if (coll? x) (reduce concat (map this x)) (list x)))","user":"542da97ae4b0dad94371f2ba"},{"problem":28,"code":"(fn myflatten [coll]\n  (if (empty? coll)\n    '()\n    (let [head (first coll)\n          tail (rest coll)]\n    (if (or (vector? head) (seq? head))\n      (concat (myflatten head) (myflatten tail))\n      (cons head (myflatten tail))))))","user":"5da9662ce4b000c986472c30"},{"code":"(fn flat [ret col] \r\n  (cond\r\n    (= '() col) (reverse ret)\r\n    (coll? (first col)) \r\n(recur (reverse (flat ret (first col))) (rest col))\r\n:else (recur (cons (first col) ret) (rest col)))) '()","problem":28,"user":"50bfe725e4b080409b860f26"},{"code":"#(letfn [(f [x acc]\n            (cond ((complement coll?) x) (cons x acc)\n                  (empty? x) acc\n                  :else (f (first x) (f (rest x) acc))))]\n   (f % ()))","problem":28,"user":"511a4eb4e4b09045b2b16945"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll))))","user":"55a62092e4b0acc240e31554"},{"code":"#(read-string (str \"[\" (clojure.string/replace (.toString %) #\"[\\'\\(\\)\\]\\[]\" \"\") \"]\"))","problem":28,"user":"52253004e4b01819a2de42fa"},{"code":"(fn ! [sq]\r\n  (loop [s (seq sq)\r\n         acc []]\r\n    (if (empty? s)\r\n      acc\r\n      (let [elem (first s)]\r\n        (if (sequential? elem)\r\n          (recur (rest s) (vec (concat acc (! elem))))\r\n          (recur (rest s) (conj acc elem)))))))","problem":28,"user":"4f82e14be4b033992c121c0c"},{"code":"(fn flat [x]\r\n  (if (nil? x)\r\n    '()\r\n\r\n    (if (sequential? x)\r\n      (concat (flat (first x)) (flat (next x)) )\r\n      (list x))))","problem":28,"user":"4dde4e95535d08e6dec9fdd7"},{"problem":28,"code":"(fn f [m] (if (coll? m) (mapcat f m) [m]))","user":"552ed75ae4b076ab5578f7f9"},{"problem":28,"code":"(fn flatty\n  [x] \n  (apply concat \n    (map #(if (sequential? %) (flatty %) [%]) x)))","user":"59d631d4e4b0ef0a1e9b5c09"},{"problem":28,"code":"(fn [x] (filter #(not (coll? %)) (tree-seq coll? identity x)))","user":"4ff4bed0e4b0678c553fc35f"},{"problem":28,"code":"(fn flattener [x]\n\t(filter \n\t\t(complement sequential?) \n     \t(rest \n        \t(tree-seq sequential? seq x)\n        )\n    )\n)","user":"5759e317e4b02ea114799330"},{"code":"#(filter (complement sequential?)\n\t   (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e79f28b535db169f9c796a8"},{"problem":28,"code":"(fn dfs[xs](reduce(fn[r x](if(sequential? x)(concat r (dfs x))(conj (vec r)x)))[] xs))","user":"5ce62d8ee4b0a17bb84e2b83"},{"problem":28,"code":"(fn [s]\n  (loop [[head & tail] s acc []]\n    (if (nil? head)\n      acc\n      (if (coll? head)\n        (recur (concat head tail) acc)\n        (recur tail (conj acc head))))))","user":"596539dce4b069c0a1a19783"},{"code":"(fn flt [l]\n  (if (empty? l)\n    []\n    (let [x (first l) xs (rest l)]\n      (if (sequential? x)\n        (concat (flt x) (flt xs))\n        (cons x (flt xs))))))","problem":28,"user":"5173726be4b098276e74652c"},{"code":"(fn ! [sf]\r\n    (if (or (seq? sf) (vector? sf))\r\n        (if (= 0 (count sf))\r\n            '()\r\n            (concat (! (first sf)) (! (rest sf))))\r\n        (list sf)))","problem":28,"user":"4f4a5ca6e4b0d56e7bb92c0f"},{"problem":28,"code":"(fn flat [ls]\n  (if-let [x (first ls)]\n    (if (sequential? x)\n      (concat (flat x) (flat (rest ls)))\n      (cons x (flat (rest ls))))))","user":"54b448f2e4b05787c3b1638e"},{"code":"(fn [coll]\n  (reduce\n   (fn flatr [v e]\n     (if (coll? e)\n       (reduce flatr v e)\n       (conj v e)))\n     [] coll))","problem":28,"user":"538b1644e4b0640c7a9a58c0"},{"problem":28,"code":"(fn ymnflatten [arg]\n  (loop [seq arg res []]\n    (if (= 0 (count seq))\n      res\n      (if (sequential? (first seq))\n        (recur (rest seq) (concat res (ymnflatten (first seq))))\n        (recur (rest seq) (concat res (list (first seq))))\n      )\n    )\n  )\n)","user":"594a7ed1e4b07ddc2dafae02"},{"code":"(fn myfun [l] (let [innerF (fn [v s] \n               (cond  (sequential? s) (if (< 1 (count s))\n                                      (apply conj (myfun (first s)) (myfun (rest s))) \n                                      (myfun (first s)))\n                     :else              (conj v s))\n                 )\n        ]\n    (innerF [] l))\n)","problem":28,"user":"531902b1e4b08068f379ed77"},{"problem":28,"code":"(fn iter [xs]\n    (reduce (fn [acc el]\n              (if (coll? el)\n                (concat acc (iter el))\n                (concat acc (list el))))\n            ()\n            xs))","user":"5c165d3ee4b01240ff5671d1"},{"code":"(fn aplanar [llista]\r\n  (if (empty? llista)\r\n\t\t'()\r\n\t\t(if (or (list? (first llista)) (vector? (first llista)))\r\n\t\t\t(concat (aplanar (first llista)) (aplanar (rest llista)))\r\n\t\t\t(cons (first llista) (aplanar (rest llista)))\r\n\t\t)\r\n\t)\r\n)","problem":28,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"(fn flat [lst]\n    (let \n    [\n    fst (first lst)\n    rst (rest lst)\n    ]\n    (println fst rst lst)\n    (cond  \n        (empty? lst)\n                '()\n        (coll? fst) \n                (concat (flat fst) (flat rst) )\n        :else\n                (cons (first lst) (flat (rest lst)) )\n    )\n    )\n)","problem":28,"user":"4f0df199535d0136e6c2231e"},{"code":"(fn flat [x] (if (sequential? x) (mapcat flat (seq x)) (list x)))","problem":28,"user":"52c804dee4b0c2d177d6212b"},{"problem":28,"code":"#(loop [l1 %, l2 `()] (cond (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2) (empty? l1) (reverse l2) :else (recur (rest l1) (cons (first l1) l2))))","user":"56f5d0efe4b046a417f92078"},{"problem":28,"code":"(fn [coll]\n     ((fn x-flatten [coll]\n\t  (if (empty? coll)\n\t      '()\n\t    (if (coll? (first coll))\n\t\t(concat (x-flatten (first coll))\n\t\t\t(x-flatten (rest coll)))\n\t      (conj (x-flatten (rest coll)) (first coll))))) coll))","user":"5a250b86e4b07f18be40aa19"},{"problem":28,"code":"(fn f [xs] (if (coll? xs) (mapcat f xs) [xs]))","user":"5782018de4b0d36ec5835e8e"},{"problem":28,"code":"(fn [x] (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))","user":"551e6526e4b030e6a24d00e8"},{"code":"(fn flat [s & {:keys [acc] :or {acc ()}}]\n (cond\n   (not (sequential? s)) (cons s acc)\n   (empty? s) acc\n   :else (concat (flat (first s) :acc acc) (flat  (rest s) :acc acc))))","problem":28,"user":"5142e808e4b0c172af7558c9"},{"problem":28,"code":"(fn __ [coll] (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (__ (first s)) (__ (rest s)))\n        (cons (first s) (__ (rest s)))))))","user":"5a6af090e4b0512ff01cda2d"},{"code":"(fn f [l]\n  (cond\n    (nil? l) nil\n    ((complement sequential?) l) (list l)\n    :else (concat (f (first l)) (f (next l)))))","problem":28,"user":"4f244f26e4b0d66497709fea"},{"problem":28,"code":"(fn check [x] (filter (complement sequential?) (tree-seq  sequential? seq x)))","user":"580014d7e4b0a837a8b30c32"},{"problem":28,"code":"(fn flat [coll] \n  (if (sequential? coll)\n    (mapcat flat coll)\n    [coll]))","user":"56c6a3c3e4b05cc29241eeb3"},{"problem":28,"code":"(fn [col] (filter (complement sequential?) (tree-seq sequential? identity col)))","user":"5e67ab18e4b0e171e103368a"},{"code":"#(filter (complement sequential?)\n (rest (tree-seq sequential? seq %)))","problem":28,"user":"4f8ac2bde4b02e764a0a5172"},{"problem":28,"code":"(fn flatland [a-seq]\n  (if (empty? a-seq)\n    []\n    (let [f (first a-seq)\n          r (flatland (rest a-seq))]\n      (if (sequential? f)\n        (concat (flatland f) r)\n        (cons f r)\n        ))))","user":"544e9022e4b0e3978000698b"},{"code":"(fn iter [data]\n  (loop [dt data, res []]\n    (cond (not(seq dt)) res\n           (coll? (first dt))  (recur (rest dt) (into res (iter (first dt))))\n            :true  (recur (rest dt) (conj res (first dt))) )))","problem":28,"user":"52f5eefbe4b09b582c12c9cb"},{"code":"(fn flat [x] (if (= x ()) ()\n               (if (sequential? x)\n                   (concat (flat (first x)) (flat (rest x)))\n                   (list x))))","problem":28,"user":"522e4baae4b01cdb292c5f00"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn [acc x]\n            (if (coll? x)\n            \t(into acc (flat x))\n              \t(conj acc x)))\n          []\n          s))","user":"5dcc152ae4b02b31cc3da3c3"},{"code":"#(reduce (fn fl [m i]\n  (if (coll? i)\n    (reduce fl m i)\n    (concat m (list i)))) '() %)","problem":28,"user":"50b4383fe4b001349b2f4abf"},{"problem":28,"code":"(fn [inseq]\n     (loop [result inseq] (let [\n                            sq\n                            (\n                             reduce\n                                (fn [acc el]\n                                   (into acc\n                                         (if (coll? el)\n                                               el\n                                               [el]\n                                         )\n                                   )\n                                )\n                              []\n                              result\n                             )\n                            ]\n                        (if (> (count (filter coll? sq)) 0)\n                          (recur sq)\n                          sq\n                        )\n                      )\n    )\n   )","user":"564faadce4b0284900eef6b2"},{"problem":28,"code":"(fn flatten' \n  [x] (if (coll? x) \n        (apply concat (map flatten' x))\n        (list x)))","user":"5a08f951e4b01bb0ae8afdfd"},{"code":"(fn fl [a]\r\n(  \r\n  if(= (seq a) nil)\r\n    nil\r\n  (if (coll? a)\r\n  (if (coll? (first a))\r\n   (fl (concat (first a) (rest a)))\r\n   (concat [(first a)] (fl (rest a)))\t\t\t\r\n\t\t)\r\n )\r\n\t)\r\n\r\n)","problem":28,"user":"4e1582f0535d04ed9115e7e4"},{"code":"(fn [li] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq li))))","problem":28,"user":"5394265ee4b0b51d73faaec6"},{"code":"(fn [xs] \n  (filter \n   (complement sequential?)\n   (tree-seq sequential? identity xs)))","problem":28,"user":"535778dee4b04ce2eb3ed27d"},{"problem":28,"code":"(fn flat\n  [s]\n  (if (seq s)\n    (let [f (first s)]\n      (if (coll? f)\n        (concat (flat f) (flat (rest s)) )\n        (conj (flat (rest s)) f)))\n    ()))","user":"542f1cade4b0dad94371f2ce"},{"problem":28,"code":"(fn my-flatten [x]\n\t(if (empty? x)\n      '()\n      (if (or (list? (first x)) (vector? (first x)))\n        (concat (my-flatten (first x)) (my-flatten (rest x)))\n        (conj (my-flatten (rest x)) (first x)))))","user":"55d7d139e4b0e31453f64aaa"},{"code":"(fn twenty-eight [coll]\n  (let [f (first coll) r (next coll)]\n    (concat\n     (if (sequential? f)\n       (twenty-eight f)\n       [f])\n     (when (sequential? r)\n       (twenty-eight r)))))","problem":28,"user":"510591dde4b06d28cacc92eb"},{"code":"(fn [x]\n  (letfn [(rec [x acc]\n               (cond (and (coll? x) (empty? x)) acc\n                     (not (coll? x)) (cons x acc)\n                     true (rec (first x) (rec (rest x) acc))))]\n    (rec x '())))","problem":28,"user":"51e0198ee4b01188f0627539"},{"problem":28,"code":"#(reverse \n  (reduce\n   (fn rec-flatten [acc item]\n     (if (coll? item) \n       (reduce rec-flatten acc item)\n       (conj acc item)))\n   '()\n   %))","user":"595a885be4b066ee0a44afc4"},{"problem":28,"code":"(fn flt [xs]\n  ;;(println (str xs))\n  (reduce \n    (fn [memo x]\n      (println (str \"reduce\" memo \":\" x))\n      (if (coll? x)\n        (concat memo (flt x))\n        (concat memo (list x))))\n    [] xs))","user":"5d94816ce4b0d3f9b434ad28"},{"code":"(fn flat [coll]\n  (if (coll? coll)\n    (mapcat flat coll)\n    [coll]))","problem":28,"user":"52c884a2e4b0c2d177d62136"},{"code":"(fn [xs] (letfn [(fl [ys acc] (if (sequential? ys) (reduce #(fl %2 %) acc ys) (conj acc ys)))] (fl xs [])))","problem":28,"user":"523b1a65e4b02f719975bdbd"},{"problem":28,"code":"(fn flat [x]\n  (apply concat \n         (map \n          #(\n            if (sequential? %) \n              (flat %) \n              [%]\n            )\n          x)))","user":"53dfb864e4b0d874e779ae43"},{"problem":28,"code":"(fn flatmap [coll] (if(sequential? coll) (mapcat flatmap coll) (list coll) ))","user":"566b7a77e4b0a866af6896af"},{"problem":28,"code":"(fn [input] (filter (complement sequential?) (tree-seq sequential? seq input)))","user":"5cc1f975e4b0ccb0619627c8"},{"code":"#(if (some coll? %)\n   (recur (mapcat (fn [x] (if (coll? x)\n                            x\n                            (list x)))\n                  %))\n   %)","problem":28,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn flat [s]\n  (if (coll? s)\n    (if (empty? s)\n      s\n      (concat (flat (first s)) (flat (rest s))))\n    [s]))","problem":28,"user":"4e5676b2535d8a8b8723a282"},{"problem":28,"code":"(fn [x]\n  (seq \n   (reduce \n    (fn flat [ans x]\n      (if (coll? x)\n        (reduce flat ans x)\n        (conj ans x)\n      ))\n    [] x)))","user":"5ecf55dae4b016b56eae05a8"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (if (empty? x)\n      '()\n      (concat (my-flatten (first x)) (my-flatten (rest x))))\n    (list x)))","user":"554d48d3e4b00713264bd988"},{"problem":28,"code":"(fn fl [in]\n  (if (coll? in)\n    (if (empty? in)\n      (into [] in)\n      (into [] (into (fl (first in)) (fl (rest in)))))\n    (conj [] in)))","user":"536b9d8ae4b0243289761ebe"},{"problem":28,"code":"(fn fl [s]\n     (if-not (coll? s)\n       [s]\n       (reduce #(apply conj %1 (fl %2))\n               [] s)))","user":"5609866ee4b0053d1b86c7e3"},{"code":"(fn fringe [x]\n  (cond (not (coll? x)) (conj '() x)\n        (empty? x) x\n        true (concat (fringe (first x))\n                     (fringe (rest x)))))","problem":28,"user":"5194243be4b0142f60b4aed9"},{"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (apply concat (map my-flatten x))\n    (list x)))","problem":28,"user":"51effd77e4b0249c592fbdf3"},{"problem":28,"code":"(comp reverse (fn flat [seq]\n   (reduce (fn [a b]\n             (if (sequential? b) (concat (flat b) a) (conj a b))\n              ) () seq)))","user":"57e30d38e4b0bfb2137f5a92"},{"problem":28,"code":"#(filter (complement sequential?)\n         (rest (tree-seq sequential? identity %)))","user":"58852909e4b0f1effa3b76af"},{"code":"(fn f [v]\n  (if (sequential? v)\n    (mapcat f v)\n    [v]))","problem":28,"user":"51383346e4b0a5db03d727d4"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce\n   (fn [c i] (if (coll? i)\n               (vec (concat c (my-flatten i)))\n               (conj c i)))\n   [] coll))","user":"592883f1e4b072a2710fceea"},{"problem":28,"code":"(fn flat [s] (mapcat #(if (sequential? %) (flat %) (list %)) s))","user":"53dadf1de4b0e771c30254ad"},{"code":"#(filter (complement sequential?) (rest(tree-seq sequential? seq %)))","problem":28,"user":"4f6a2ff2e4b07046d9f4ef98"},{"problem":28,"code":"(fn [xs]\n  (letfn [(f [x]\n            (if (sequential? x)\n              (mapcat f x)\n              [x]))]\n    (f xs)))","user":"55d87324e4b0e31453f64ab4"},{"code":"(fn fff [in]\n  (if (sequential? in)\n\t\t(if (not-empty in)\n\t\t\t(concat (fff (first in)) (fff (rest in)))\n\t\t\tin)\n\t\t[in]))","problem":28,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":28,"code":"(fn flatt\n  [lst]\n  (#(filter (complement sequential?) (rest (tree-seq sequential? seq %))) lst))","user":"5c7dad57e4b0d597f478caba"},{"code":"(fn my-flatten [xs]\n      (reduce\n        (fn [flattened x]\n          (concat flattened\n            (cond (sequential? x) (my-flatten x)\n              :else [x])))\n        []\n        xs))","problem":28,"user":"4fd6f4d8e4b0dab7d829f37b"},{"code":"#(filter (complement sequential?) (tree-seq sequential? vec %))","problem":28,"user":"51852961e4b0da5a5be3babb"},{"code":"(fn flat [xs]\n  (if (empty? xs) []\n    (let [[hd & tail] xs]\n      (if (coll? hd)\n        (concat (flat hd) (flat tail))\n        (cons hd (flat tail))\n      )\n    )\n  )\n)","problem":28,"user":"5323a414e4b09d4e7a9b54d1"},{"problem":28,"code":"(fn flat \n  ([ls] (flat ls []) )\n  ([[x & xs] final]\n   (if (nil? x)\n     final\n     (if (coll? x)\n       (flat xs (into final (flat x))) \n       (flat xs (conj final x) ) ))))","user":"5d48884ee4b07c84aa5ae6bb"},{"problem":28,"code":"#(filter (complement sequential?)\n         (rest (tree-seq sequential? seq %))\n )","user":"5e79fcb9e4b085ba37836e08"},{"problem":28,"code":"(fn my-flatten [& coll]\n    (->>\n     (tree-seq sequential? identity coll)\n     (filter #(not (sequential? %)))))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn flatten1[xs]\n  (if (coll? xs)\n      (if (= xs (empty xs))\n          (empty xs)\n          (concat (flatten1 (first xs))\n                  (flatten1 (rest xs))))\n      (list xs)))","problem":28,"user":"4f9a0064e4b0dcca54ed6d03"},{"code":"(fn flat [x] (if (empty? x) '() (concat (if (coll? (first x)) (flat\n(first x)) (list (first x))) (flat (rest x)))))","problem":28,"user":"52474ec2e4b05ef8e38e6361"},{"code":"(fn f[x] (mapcat #(if (coll? %) (f %) [%]) x))","problem":28,"user":"4f38b7d9e4b0e243712b1ee0"},{"problem":28,"code":"(fn f [s] \n  (if (sequential? s) \n    (mapcat f s) \n    (list s)))","user":"5448616be4b032a45b8693c9"},{"problem":28,"code":"(fn flatten' [s]\n   (println \"flatten'-> \" s)\n   (if (empty? s)\n     (list)\n     (if (coll? s)\n       (let [\n           h (first s)\n           t (rest (seq s))\n           ]\n         (println \"seq!\")\n         (println \"h=\" h)\n\n         (if (coll? h)\n           (do\n             (println \"seq h!\")\n             (concat (flatten' (seq h)) (flatten' t))\n             )\n          (concat (list h) (flatten' t))\n         )\n     )\n       s)\n   ))","user":"55aa5f73e4b0988bba2ad94b"},{"problem":28,"code":"#(loop [col %\n         result '()]\n       (if (empty? col)\n          (reverse result)\n        (recur (rest col)\n               (if (sequential? (first col))\n                  (concat (loop [nested-col (first col)\n                                         nested-res '()]\n                         (cond\n                         (empty? nested-col) nested-res\n                         (sequential? (first nested-col)) (recur  (first nested-col) nested-res)\n                         :else (recur (rest nested-col)\n                                (conj nested-res (first nested-col))\n                                )\n                              )\n                            ) result)\n                          \n                   (conj result (first col)))\n                   ))\n                 )","user":"57bf304de4b05aa3c4741c75"},{"code":"(fn flat [xs] (if (sequential? xs) (reduce concat (map flat xs)) [xs]))","problem":28,"user":"53217912e4b09d4e7a9b54b3"},{"code":"(fn my-flat [xs] \n  (mapcat #(if (coll? %) \n               (my-flat %) \n               (vector %)) \n          xs))","problem":28,"user":"4fc5a693e4b0ee37620e17fc"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll\n         result []]\n    (cond\n      (sequential? (first coll)) (recur (concat (first coll) (rest coll)) result)\n      (empty? coll) result\n      :else (recur (rest coll) (conj result (first coll))))))","user":"5b62ff3ce4b0c6492753e72a"},{"code":"(fn flat   \r\n  ([a] (flat '[] a) )\r\n  ([col a]\r\n   (if (coll? a)\r\n       (reduce flat col a)\r\n       (conj col a)\r\n    )\r\n   )\r\n)","problem":28,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":28,"code":"(fn flat [col] (mapcat #(if (not (coll? %)) (list %) (flat %)) col))","user":"547c2c6ce4b0c51c1f4d72e3"},{"problem":28,"code":"(fn myflatten [sq]\n  (cond\n    (empty? sq) sq\n    (or (seq? (first sq)) (vector? (first sq))) (concat (myflatten (first sq)) (myflatten (rest sq)))\n    :else (cons (first sq) (myflatten (rest sq)))))","user":"5bcc304ce4b07a9b28b1010c"},{"code":"(fn [s1]\n   ((fn myflatten [s acc]\n      (if (empty? s)\n        (reverse acc)\n        (if (coll? (first s))\n         (myflatten (rest s) (concat (reverse (myflatten (first s) '())) acc))\n         (myflatten (rest s) (cons (first s) acc))))) s1 '()))","problem":28,"user":"4ff355a1e4b0678c553fc34d"},{"problem":28,"code":"(fn myfl\n  [[ x & xs]]\n  (let [flatrest (if (empty? xs) [] (myfl xs))]\n    (if (sequential? x)\n      (concat (myfl x) flatrest)\n      (cons x flatrest))))","user":"56b97792e4b0f26550335932"},{"problem":28,"code":"(fn flt [x]\n  (let [h (first x) r (next x)]\n    (concat \n     \t\t(if (sequential? h)\n              (flt h)\n              [h])\n            (when (sequential? r)\n              (flt r)))))","user":"56585dbce4b0f9d632dd84b3"},{"problem":28,"code":"(fn f\n  [x y] (if (coll? y) (reduce f x y) (conj x y))) []","user":"5a1c3c11e4b0ff51aa4b323d"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (if (sequential? x)\n    (mapcat my-flatten x)\n    (list x)))","user":"5d9c8a85e4b0eb781811cdad"},{"problem":28,"code":"(fn flatter [el]\n  (if (sequential? el)\n    (mapcat flatter el)\n    (list el)))","user":"53ac2d45e4b047364c04445b"},{"code":"(fn f [sq] (apply concat (map #(if (coll? %) (f %) (list %)) sq)))","problem":28,"user":"4fead955e4b0140c20fb9c10"},{"code":"(partial \n (fn foo [res, s] \n   (if \n     (= s '()) \n     (reverse res)\n\t (if\n\t\t(sequential? (first s))\n\t\t(foo (reverse (foo res (first s))) (rest s))\n\t\t(foo (conj res (first s)) (rest s))\n\t )\n\t)\n  )\n '()\n )","problem":28,"user":"51a0e0b7e4b0b292b01ee3fb"},{"problem":28,"code":"(fn my-flat [s]\n  (if (coll? s)\n    (mapcat my-flat s)\n    [s]))","user":"55ad2d97e4b03311e7b732a2"},{"code":"(fn [s] (filter (complement\n    sequential?)\n    (rest (tree-seq sequential? seq s))))","problem":28,"user":"4fa659f3e4b081705acca1b6"},{"problem":28,"code":"(fn [coll]\n  (seq\n    (reduce\n      (fn my-flatten [v e]\n        (if (coll? e)\n          (reduce my-flatten v e)\n          (conj v e)\n        )\n      )\n      [] \n      coll\n    )\n  )\n)","user":"5726adf8e4b0c5bde472c12b"},{"code":"(fn [sq]\n  (loop [todo sq\n         sofar []]\n    (if (empty? todo) sofar\n      (let [[x & xs] todo]\n        (if (coll? x)\n          (recur (concat x xs) sofar)\n          (recur xs (conj sofar x)))))))","problem":28,"user":"4ec59ce4535d6d7199dd36ab"},{"code":"(fn flat-map\n  [x]\n  (cond\n    (not (coll? x))  (list x)\n    (empty? x)       '()\n    :else            (apply concat (map flat-map x))))","problem":28,"user":"4fc6305de4b0ee37620e180b"},{"problem":28,"code":"(fn flatten' [[x & xs]]\n  (if x\n    (if (coll? x)\n      (concat (flatten' x) (flatten' xs))\n      (cons x (flatten' xs)))))","user":"585e7c60e4b0f14aab7c87b3"},{"problem":28,"code":"(fn flat [e]\n  (if (coll? e)\n    (mapcat flat e)\n    [e]))","user":"57c94c54e4b05aa3c4741d2c"},{"problem":28,"code":"(fn [a]\n   ((fn fun [b r]\n      (if (and (coll? b) (not (empty? b)))\n        (concat\n         (fun (first b) r)\n         (fun (rest b) r))\n        (if (not (coll? b))\n          (conj r b)))) a '()))","user":"549cd548e4b0f3d1d8e70f91"},{"code":"(fn [x]\n  (loop [x x v []]\n    (if (nil? (first x))\n      v\n      (if (instance? java.util.Collection (first x))\n        (if (instance? java.util.Collection (first (first x)))\n          (recur (concat (first (first x)) (rest x)) v)\n          (recur (concat (rest (first x)) (rest x)) (concat v (vector (first (first x))))))\n        (recur (rest x) (concat v (vector (first x))))))))","problem":28,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn [x]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)))","problem":28,"user":"4eb9353f535dfed6da9c6d4e"},{"problem":28,"code":"(fn _flatten [x]\n  (lazy-seq\n   (when-let [s (seq x)]\n     (if (coll? (first x))\n       (concat (_flatten (first s)) (_flatten (rest s)))\n       (cons (first s) (_flatten (rest s)))))))","user":"5a3e1243e4b0447ef91cc5ae"},{"problem":28,"code":"(fn myflatten [coll]\n  (let [reducer (fn [acc item]\n                 (if (sequential? item) (vec (concat acc (myflatten item)))\n                                        (conj acc item)))]\n    (reduce reducer [] coll)))","user":"5d97b602e4b0d3f9b434ad3a"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))\n; we basically treat t","problem":28,"user":"4f83e712e4b033992c121c25"},{"problem":28,"code":"(fn f [xss]\n  (mapcat #((if (coll? %) f (comp seq list)) %) xss))","user":"53dfdf01e4b0d874e779ae46"},{"problem":28,"code":"(fn myflatten\n  [x]\n  (loop [result []\n         remaining x]\n    (if (empty? remaining)\n      result\n      (let [current (first remaining)]\n        (if ((complement sequential?) current)\n          (recur (conj result current) (rest remaining))\n          (recur (into result (myflatten current)) (rest remaining)))))))","user":"5e95c88de4b0fbed045a380e"},{"problem":28,"code":"(fn NotFlatten28 [arg1]\n      (let [left (first arg1) right (next arg1 )]\n           (concat\n             (if (sequential? left)\n               (NotFlatten28 left)\n               [left])\n             (when (sequential? right)\n                   (NotFlatten28 right)\n                   ))))","user":"5cb6256ce4b026601754b947"},{"code":"(fn flat [coll]\n   (if (instance? clojure.lang.Seqable coll)\n      (reduce (fn [acc elem] (into acc (flat elem))) [] coll)\n\t  (list coll)))","problem":28,"user":"523a9fc9e4b081681ca7adca"},{"problem":28,"code":"(fn batten\n  ([l] (batten l []))\n  ([l acc]\n    (cond\n      (not (coll? l))(conj acc l)\n      (empty? l) acc\n      :else (batten (rest l) (batten (first l) acc)))))","user":"5fae84b3e4b08cb800c85afd"},{"code":"(fn [coll] (filter (complement sequential?) \n        (rest (tree-seq sequential? seq coll))))","problem":28,"user":"5336ca32e4b0e30313ee6c80"},{"problem":28,"code":"(fn[a](filter #(not (coll? %)) (tree-seq  (fn[n](coll? n)) #(identity %) a )))","user":"555c6344e4b0b056612e224c"},{"problem":28,"code":"(fn my-flatten [x] (if (coll? x) (mapcat my-flatten x) [x]))","user":"551535cee4b055c2f668d4df"},{"problem":28,"code":"(fn[coll]\n      (loop [x coll res '()] \n              (if(empty? x) \n                        (reverse res)\n                        (if(sequential? (first x))\n                                    (recur (concat (first x) (rest x))\n                                           res) \n                                    (recur (rest x) (cons (first x)\n                                                          res))\n                                  )\n                      )\n            )\n    )","user":"556cc24ae4b09a3098a52502"},{"problem":28,"code":"(fn fl [coll]\n  (if \n    (empty? coll) []\n    (let [f (first coll) r (rest coll)]\n      (if (coll? f) (concat (fl f) (fl r)) (cons f (fl r))))))","user":"541ad1c1e4b01498b1a71a5c"},{"code":"(fn nfl [iseq]\n  (mapcat\n    (fn [ele]\n      (if (or (list? ele) (vector? ele))\n        (nfl ele)\n        (list ele))) iseq))","problem":28,"user":"4f046d70535dcb61093f6bc5"},{"code":"(fn flat [coll]\n  (let [f (first coll) r (next coll)]\n    (concat\n      (if (sequential? f)\n        (flat f)\n        [f])\n      (when (sequential? r)\n        (flat r)))))","problem":28,"user":"4f329974e4b0d6649770a093"},{"problem":28,"code":"(fn [s] (filter \n  (complement sequential?)\n  (rest (tree-seq sequential? seq s))))","user":"571543bbe4b07c98581c3ad4"},{"problem":28,"code":"reduce (fn f [acc el] \n         (if (coll? el)\n           (reduce f acc el)\n           (conj acc el))) []","user":"59a72effe4b066c664927d94"},{"problem":28,"code":"#(\n(fn f-er [acc collie]\n  (if (seq collie)\n  (if (coll? (first collie))\n    (f-er (f-er acc (first collie)) (rest collie))\n    (f-er (conj acc (first collie)) (rest collie)))\n    acc))\n  [] %)","user":"55f8fd70e4b03cbcff9738bc"},{"problem":28,"code":"(fn [s] (let [t (atom [])]\n  (clojure.walk/postwalk #(if-not (coll? %) (swap! t conj %) )\n            s)\n  @t))","user":"5a66f358e4b0512ff01cd9d5"},{"problem":28,"code":"(fn tmp[lst]\n  (cond (empty? lst) '()\t\n    \t(coll? (first lst))  (concat (tmp (first lst)) (tmp (rest lst)))\n        :else (cons (first lst) (tmp (rest lst)))))","user":"5a5d693ce4b0512ff01cd923"},{"problem":28,"code":"(fn flatten2 [col] \n  (reduce \n    (fn [col el]\n      (into col (if (coll? el)\n                        (flatten2 el)\n                        [el])))\n    []\n    col))","user":"5956c6dae4b066ee0a44af61"},{"problem":28,"code":"reduce (fn unwrap\n  [acc n]\n  (cond\n   (coll? n)(if (empty? n) acc (unwrap (unwrap acc (first n)) (rest n)))\n   :else (conj acc n)                  \n   )\n  ) []","user":"5de6e291e4b0986d99407f72"},{"code":"(fn [xs]\n  (if (some sequential? xs)\n    (recur (mapcat #(if (sequential? %) % [%]) xs))\n    xs))","problem":28,"user":"4eb51942535d7eef30807365"},{"problem":28,"code":"(fn rec [x]\n  (if (sequential? x)\n\t(if (empty? x)\n      '()\n      (if (sequential? (first x))\n        (concat (rec (first x)) (rec (rest x)))\n        (cons (first x) (rec (rest x)))))\n    x))","user":"57716e11e4b0979f896515b2"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n    (tree-seq sequential? identity x)))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn flt [coll] (concat (if (sequential? (first coll))\n                         (flt (first coll))\n                         [(first coll)])\n                       (when (sequential? (next coll))\n                         (flt (next coll)))))","problem":28,"user":"530ccb1de4b08068f379ec99"},{"problem":28,"code":"(fn flat  \n   ([s] \n    (println [s])\n         (if (or (seq? (first s)) (vector? (first s)))\n           (flat (rest s) (into [] (concat [] (flat (first s)))))\n           (flat (rest s) (conj [] (first s)))\n         ))\n   ([s o] \n    (println [s o])\n       (if (empty? s)\n         o\n          (if (or (seq? (first s)) (vector? (first s)))\n             (flat (rest s) (into [] (concat o (flat (first s)))))\n             (flat (rest s) (into [] (conj o (first s))))\n          )\n       )\n   ))","user":"5b081ff2e4b0cc2b61a3bdb3"},{"problem":28,"code":"(fn f [s]\n  (mapcat #(if (sequential? %) (f %) [%]) s))","user":"5d45749be4b07c84aa5ae6a2"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (filter (complement sequential?) (tree-seq sequential? identity coll)))","user":"53f3d96ee4b0742d9025b0fa"},{"problem":28,"code":"(fn fl [[hd & tl]]\n  (if (empty? tl)\n    (if (or (seq? hd) (vector? hd))\n      (fl hd)\n      (list hd))\n    (if (or (seq? hd) (vector? hd))\n      (concat (fl hd) (fl tl))\n      (cons hd (fl tl)))))","user":"53fb5256e4b0de5c4184857f"},{"problem":28,"code":"(fn [coll] (let [cl (reduce #(into % (if (coll? %2) %2 [%2])) [] coll)] (if (= coll cl) cl (recur cl))))","user":"5f8e865fe4b0715f5002d76d"},{"code":"(fn fl [l]\n  (mapcat #(if (sequential? %) (fl %) [%]) l))","problem":28,"user":"4f04f847535dcb61093f6beb"},{"code":"(fn my-flatten [x]\n    (if (sequential? x)\n      (mapcat my-flatten x)\n      (list x)))","problem":28,"user":"4f52ae00e4b03ad3f0c10d42"},{"problem":28,"code":"(fn my-flatten-seq [s]\n  (if (sequential? s)\n    (apply concat (map my-flatten-seq s))\n    (list s)))","user":"55253217e4b0882d96d091ce"},{"code":"#(remove coll? (tree-seq coll? identity %))","problem":28,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"(fn flat [L] (reduce #(if (coll? %2) (vec (concat %1 (flat %2))) (conj %1 %2)) [] L))","problem":28,"user":"4e6e3a1e535d5021c1a89602"},{"problem":28,"code":"(fn [xs]\n  (->> xs\n       (tree-seq sequential? seq)\n       rest\n       (filter (complement sequential?))))","user":"5484c3b2e4b0e286459a11a2"},{"problem":28,"code":"#(loop [h (first %)\n        t (rest %)\n        flat []]\n   (if-not h\n     flat\n     (recur (if (coll? h)\n              (first h)\n              (first t))\n            (if (coll? h)\n              (concat (rest h) t)\n              (rest t))\n            (if (coll? h)\n              flat\n              (conj flat h)))))","user":"5b6f27dce4b0c6492753e7d9"},{"problem":28,"code":"(fn fltn [s] (reduce (fn [acc x] (if (coll? x) (concat acc (fltn x)) (concat acc (list x)))) [] s))","user":"5a591d04e4b05d388ecb6c90"},{"code":"(fn flat [l] (cond (empty? l) l (coll? (first l)) (concat (flat (first l)) (flat (rest l))) true (cons (first l) (flat (rest l)))))","problem":28,"user":"4eff81ca535dcb61093f6a2d"},{"code":"(fn flat [l]\n    (if (coll? l)\n      (mapcat flat l)\n      (list l)))","problem":28,"user":"519e70d5e4b0acf32bc6a42c"},{"problem":28,"code":"(fn flat [lisp]\n            (filter (fn [x] (not (coll? x)))\n                    (if (and (coll? lisp) (not (empty? lisp)))\n                      (concat (flat (first lisp)) (flat (rest lisp)))\n                      (list lisp))))","user":"56128c54e4b05f002753df93"},{"problem":28,"code":"(fn mflatten\n  [s]\n  (let [news [] olds s]\n    (if (sequential? olds) \n      (reduce #(concat %1 (mflatten %2)) news olds)\n      [olds]))\n  )","user":"540efe2ee4b0addc1aec6724"},{"code":"(fn fl [in] (if (coll? in) (apply concat (map fl in)) [in]))","problem":28,"user":"50608d4ce4b07251188e4455"},{"problem":28,"code":"(fn [sq] (filter (complement sequential?) (rest (tree-seq sequential? seq sq))))","user":"5da5a1eee4b000c986472c04"},{"code":"(fn fltn\r\n  [x]\r\n  (filter (complement sequential?)\r\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4faf897be4b081705acca257"},{"code":"#(filter (complement sequential?)\n            (rest (tree-seq sequential? seq %)))","problem":28,"user":"4faec810e4b081705acca24e"},{"problem":28,"code":"(fn flt [sq] (reverse (reduce #(if (or (seq? %2) (vector? %2)) (concat (reverse (flt %2)) %1) (cons %2 %1)) nil sq)))","user":"565a3e25e4b068f2fe63dbfb"},{"code":"(fn \n  [sq]\n  (loop [item (first sq) rm (next sq) acc []]\n    (if item\n      (if (coll? item)\n        (recur (first item) (concat (next item) rm) acc)\n        (recur (first rm) (next rm) (conj acc item)))\n      (if (empty? rm)\n        acc\n        (recur (first rm) (next rm) acc)))))","problem":28,"user":"52e44a22e4b09f7907dd144e"},{"code":"(fn foo [lst]\n  (if (empty? lst)\n    '()\n    (let [f (first lst)]\n      (if (or (number? f) (string? f) (keyword? f))\n        (concat (list f) (foo (rest lst)))\n        (concat (foo f) (foo (rest lst)))))))","problem":28,"user":"5220a770e4b0e6a83c8925a3"},{"problem":28,"code":"(fn [col]\n  (seq\n    (reduce \n      (fn helper [v e]\n        (if (sequential? e)\n          (reduce helper v e)\n          (conj v e)))\n      [] col)))","user":"574c5e18e4b02ea11479921b"},{"problem":28,"code":"(fn flatn [xs]\n  (if (empty? xs) '()\n      (let [x (first xs) r (flatn (rest xs))]\n        (if (sequential? x)\n          (concat (flatn x) r)\n          (cons x r)))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":28,"code":"(fn flt [lst]\n  (let [f (first lst) n (next lst)] (concat (if (sequential? f) (flt f) [f]) (when (sequential? n) (flt n)))))","user":"5a99b688e4b0d174b936c7a6"},{"problem":28,"code":"(fn flat [coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (if (coll? (first s))\n       (concat (flat (first s)) (flat (rest s)))\n       (cons (first s) (flat (rest s)))))))","user":"541b1f25e4b01498b1a71a63"},{"code":"(fn _flatten [items]\n  (if (empty? items)\n    '()\n    (concat (if (sequential? (first items))\n              (_flatten (first items))\n              (list (first items)))\n            (_flatten (rest items)))))","problem":28,"user":"510cd1dde4b078ea71921124"},{"problem":28,"code":"(fn [items]\n  (loop [fitems [] ritems items nitems ()]\n    (cond\n                  (and (sequential? (first ritems)) (not(empty? (rest ritems))))\n                    (recur fitems (first ritems) (conj nitems (rest ritems)))\n                  (and (not(empty? ritems)) (not(sequential? (first ritems))) (not(empty? (rest ritems))))\n        (recur (conj fitems (first ritems)) (rest ritems) nitems)\n      (and (not(sequential? (first ritems))) (empty? (rest ritems)) (not(empty? nitems)))\n          (recur (conj fitems (first ritems)) (first nitems) (rest nitems))\n      (and (sequential? (first ritems)) (empty? (rest ritems)))\n          (recur fitems (first ritems) nitems)\n      :else\n      (conj fitems (first ritems)))))","user":"5d363543e4b01671435dbd20"},{"problem":28,"code":"(fn flat [orig]\n  (if (sequential? orig)\n    (if (empty? orig) '() (concat (flat (first orig)) (flat (rest orig))))\n    (list orig)))","user":"58951903e4b00487982d5274"},{"code":"(fn flat [c] (mapcat #(if (coll? %)\n                     (flat %)\n                     (list %)) c))","problem":28,"user":"51fefe8ae4b0f1313d468a7d"},{"code":"#(filter (complement sequential?) \n    (tree-seq sequential? seq %))","problem":28,"user":"4e860e85535db62dc21a62f1"},{"problem":28,"code":"#((comp reverse reduce)\n  (fn fl [acc x]\n    (if (coll? x)\n      (reduce fl acc x)\n      (cons x acc))) () %1)","user":"5b03063de4b0cc2b61a3bd5b"},{"code":"(fn my-flatten [coll]\r\n    (when-let [s  (seq coll)]\r\n      (if (coll? (first s))\r\n        (concat (my-flatten (first s)) (my-flatten (rest s)))\r\n        (cons (first s) (my-flatten (rest s))))))","problem":28,"user":"5063fe48e4b075d771da6f9e"},{"code":"(fn my-flat [coll]\n   (if (coll? coll)\n     (if (empty? coll) \n       ()\n       (concat (my-flat (first coll)) (my-flat (rest coll))))\n     (list coll))\n  )","problem":28,"user":"524469dee4b0d8acf9ed6a9d"},{"problem":28,"code":"(fn flattener [x]\n  (if (coll? x)\n    (reduce concat (map flattener x))\n    `(~x)))","user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn flat [x]\n  (if (sequential? x)\n      (apply concat (map flat x))\n      (list x)))","problem":28,"user":"4dfd018c535d04ed9115e77f"},{"problem":28,"code":"(fn fl [sq] (if (empty? sq) '() (if (coll? (first sq)) \n              (concat (fl (first sq)) (fl (rest sq))) \n              (conj (fl (rest sq)) (first sq))\n              )\n  ))","user":"56b36283e4b0982f16b37e18"},{"code":"(fn my_flat [nested_seq]\n  (lazy-seq\n   (when-let [s (seq nested_seq)]\n     (if (coll? (first s))\n       (concat (my_flat (first s)) (my_flat (rest s)))\n       (cons (first s) (my_flat (rest s)))))))","problem":28,"user":"53791ab7e4b06839e8705e4d"},{"problem":28,"code":"#(loop [s %]\n   (if (not-any? coll? s) s\n     (recur (loop [r s d []]\n              (if (empty? r) d\n                (recur (rest r) (concat d (if (coll? (first r)) (first r)\n                                            [(first r)]))))))))","user":"558378dce4b05c286339e115"},{"problem":28,"code":"(fn custom_flatten [x]\n  (if (coll? x)\n    (mapcat custom_flatten x)\n    [x]))","user":"5c2dfca3e4b0d62ef62d9efc"},{"problem":28,"code":"(fn [xs] ((fn fltn [xs acc]\n               (if (empty? xs)\n                 acc\n                 (if (sequential? (first xs))\n                   (recur (rest xs) (concat acc (fltn (first xs) [])))\n                   (recur (rest xs) (concat acc (vector (first xs))))))) xs []))","user":"55dc2ad1e4b050e68259b3ac"},{"problem":28,"code":"(fn f [[h & t :as s]] (if (nil? s) [] (into (if (coll? h) (f h) [h]) (f t))))","user":"5960a1a6e4b066ee0a44b08e"},{"problem":28,"code":"(fn my-flatten [seq]\n  (if (coll? seq)\n    (if (empty? seq)\n      '()\n      (concat (my-flatten (first seq)) (my-flatten (rest seq))))\n    (list seq)))","user":"56fbcc1fe4b07572ad1a88d5"},{"problem":28,"code":"(fn [l] (loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"56bca51ae4b0f26550335963"},{"problem":28,"code":"(fn [x]\n (loop [elems x]\n   (let [newlist (reduce #(if (coll? %2)\n                            (into % %2)\n                            (conj % %2))\n                         [] elems)]\n     (if (some coll? newlist)\n       (recur newlist)\n       (list* newlist)))))","user":"5a52f2cbe4b05d388ecb6c06"},{"code":"(fn flat [lst]\n  (if (not (coll? lst)) [lst]\n      (reduce concat (map flat lst))))","problem":28,"user":"4f58d92fe4b0a7574ea71858"},{"problem":28,"code":"(fn Flat [s]\n  (when (seq s)\n    (if (sequential? (first s))\n      (concat (Flat (first s)) (Flat (rest s)))\n      (cons (first s) (Flat (rest s))))))","user":"579f4812e4b05302be0b72fb"},{"code":"(fn f [l] (if (coll? l) (mapcat f l) (list l)))","problem":28,"user":"4ec65213535d6d7199dd36c8"},{"code":"(fn foo [s]\n  (if (some #(coll? %) s)\n      (foo (reduce #(if (coll? %2)\n                     (apply conj %1 %2)\n                     (conj %1 %2)) [] s))\n      (seq s)))","problem":28,"user":"4f327844e4b0d6649770a092"},{"problem":28,"code":"(fn testing [coll]\n  (seq\n    (reduce\n      (fn flattening [v e]\n        (if (coll? e)\n          (reduce flattening v e)\n          (conj v e)))\n      [] coll)))","user":"59a3f3dce4b066c664927d48"},{"problem":28,"code":"#(-> sequential?\n     complement\n     (filter\n\t   (rest (tree-seq sequential? seq %))\n     )\n)","user":"5c493046e4b0e06e1360a3cb"},{"problem":28,"code":"(fn flattener [s]\n  (reduce \n    (fn [acc e] \n      (if (sequential? e)\n        (into acc (flattener e))\n        (conj acc e)))\n    []\n    s))","user":"56d2a103e4b0ea9b8538f7a3"},{"code":"(fn myflatten                                                       \n  [s]                                                                 \n  (if (or (not (coll? s)) (empty? s))                                 \n    (remove #(and (coll? %) (empty? %)) (if (nil? s) nil (list s)))   \n    (concat (myflatten (first s))  (myflatten (rest s)) )             \n                                                                      \n    )                                                                 \n  )","problem":28,"user":"50573ed8e4b0012181721987"},{"problem":28,"code":"(fn fltn [[h & t]] (concat\n                    (if (sequential? h) (fltn h)\n                      [h])\n                    (if (sequential? t) (fltn t))))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn f [s]\n  (if (or (not (coll? s)) (empty? s)) '()\n    (if (coll? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))))","problem":28,"user":"531bad96e4b08068f379ed93"},{"problem":28,"code":"#(filter (complement sequential?)(tree-seq sequential? seq %))\n;;(fn [x](filter (complement sequential?)(rest (tree-seq sequential? seq x))))","user":"580d7bdae4b0849f6811b73c"},{"code":"(fn f [x]\n    (if (coll? x)\n        (reduce concat (map f x))\n        (list x)))","problem":28,"user":"53500869e4b084c2834f4ad3"},{"problem":28,"code":"(fn my-flatten\n  ([head & tail]\n  (if (nil? head)\n   ()\n   (if (sequential? head)\n     (concat (apply my-flatten head) (apply my-flatten tail))\n     (cons head (apply my-flatten tail)))))\n  ([] ()))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn flatseq [c]\n  (cond (not (coll? c)) (conj [] c)\n\t\t\t\t(empty? c) nil\n\t\t\t\t:else (concat (flatseq (first c))\n\t\t\t\t\t\t\t\t\t\t\t(flatseq (rest c)))))","problem":28,"user":"4db045b5838c48654951d9be"},{"problem":28,"code":"(fn flat [coll]\n  (mapcat\n    (fn [itm]\n      (if (coll? itm) (flat itm) [itm]))\n    coll))","user":"5703cd50e4b08d47c97781fc"},{"problem":28,"code":"(fn flat [s] (reduce (fn [acc, i] (if (sequential? i) (concat acc (flat i)) (concat acc [i]) ) ) [] s))","user":"57eb7a97e4b0bfb2137f5b62"},{"problem":28,"code":"(fn [x]\n  (loop [[head & tail] x\n         result []]\n    (if (nil? head)\n      (reverse result)\n      (if (coll? head)\n        (recur (concat head tail) result)\n        (recur tail (concat [head] result))))))","user":"57fa54c3e4b0d3187e900960"},{"problem":28,"code":"(fn flat [xs]\n  (when-let [s (seq xs)]\n    (if (coll? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","user":"55d68726e4b0e31453f64a99"},{"code":"(fn f [xs] \n  (if (empty? xs) xs\n      (let [[x & xs] xs]\n      (if (coll? x) (concat (f x) (f xs))\n          (cons x (f xs))))))","problem":28,"user":"4fa6a491e4b081705acca1bc"},{"problem":28,"code":"#((fn flat-impl[s r]\n    (if(sequential? r)\n      (reduce flat-impl s r)\n      (conj s r))) [] %)","user":"5b6473eee4b0c6492753e73f"},{"problem":28,"code":"#(apply list (reduce (fn f [acc x] \n            (if (sequential? x)\n              (reduce f acc x)\n              (conj acc x))) \n          [] %))","user":"5180af54e4b0e3fc13e244e9"},{"problem":28,"code":"#(filter (fn [el]\n            (not (coll? el))\n            )   (tree-seq sequential? seq  %) )","user":"546b24a0e4b00cfc9eacc166"},{"problem":28,"code":"(fn f [xs]\n  (if (empty? xs)\n    ()\n    (let [[fst & rst] xs]\n      (if (sequential? fst)\n      \t(concat (f fst) (f rst))\n      \t(cons fst (f rst))))))","user":"547584d9e4b0c51c1f4d729b"},{"problem":28,"code":"(fn my-flatten [xs]\n  (if (sequential? xs)\n    (apply concat\n      (map my-flatten xs))\n    (list xs)))","user":"55349c67e4b09218d5f44fa0"},{"code":"(fn flat [col]\n  (if (empty? col)\n    col\n    (if (sequential? (first col))\n    (concat (flat (first col)) (flat (rest col)))\n    (cons          (first col)  (flat (rest col))))))","problem":28,"user":"4fb7b80ae4b081705acca2d4"},{"problem":28,"code":"(fn flat\n  ([s] (flat s []))\n  ([[x & xs] ret]\n   (if x\n     (if (sequential? x)\n       (flat xs (concat ret (flat x)))\n       (flat xs (concat ret [x])))\n     ret)))","user":"554b7056e4b0a04f79299583"},{"code":"(fn flat[col]\r\n  (reduce #(if (coll? %2)\r\n              (into [](concat %1 (flat %2)))\r\n              (conj %1 %2))\r\n    [] col)\r\n)","problem":28,"user":"5065bd94e4b0148eb3925aed"},{"problem":28,"code":"(fn flt [arr]\n  (let [head (first arr)\n        tail (next arr)]\n    (cond\n      (empty? arr) '()\n      (sequential? head) (concat (flt head)\n                                 (flt tail))\n      :else (cons head (flt tail)))))","user":"5ef8e9e0e4b09b61f08553cb"},{"problem":28,"code":"(fn recursive-flat [coll]\n  (loop [[head & tail] (seq coll)\n         result []]\n    (cond\n      (and (nil? head) (nil? tail)) \n        result\n      (sequential? head)\n        (recur (concat head tail) result)\n      :else \n        (recur tail (conj result head))\n      )))","user":"553e3260e4b0a04f792994eb"},{"problem":28,"code":"(fn [l] \n  ((fn fltn [l a]\n     (if (coll? l)\n       (if (empty? l)\n         a\n         (fltn\n          (rest l)\n          (fltn (first l) a)))\n       (conj a l)))\n   l\n   []))","user":"4df9d3b0535d04ed9115e77b"},{"code":"(fn fla [ls]\n  (cond\n    (not (coll? ls)) [ls]\n    (empty? ls) []\n    :else (concat (fla (first ls)) (fla (rest ls)))))","problem":28,"user":"504ed350e4b069badc5a33d1"},{"problem":28,"code":"(fn my-flatten [seq]\n  (if (empty? seq)\n    nil\n    ;;\n    (if (sequential? (first seq))\n      ;; we are a node not a leaf. we divide\n      ;; our problem into two sets as both\n      ;; are seqs.\n      ;; Afterwards we need to concat the two\n      ;; resulting lists \n      (concat\n       (my-flatten (first seq))\n       (my-flatten (rest seq)))\n      \n      ;; we are a leaf so we can add 'us'\n      ;; to the sequence we are constructing\n      ;; (println (first seq))     \n      (cons\n       (first seq)\n       (my-flatten (rest seq)))\n      ))\n)","user":"5641296de4b08d4f616f5ef4"},{"problem":28,"code":"(fn go [x] (if (coll? x) (apply concat (map go x)) [x]))","user":"5fa416ece4b0f0ebd91b7803"},{"code":"reduce\n  (fn f[acc v]\n    (if (sequential? v)\n      (reduce conj acc (reduce f [] v))\n      (conj acc v))) []","problem":28,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn my-flatten [coll]\n  (loop [acc [] coll coll]\n    (if (empty? coll)\n      acc\n      (let [a (first coll)\n            coll (rest coll)]\n      (if (sequential? a)\n        (recur acc (if (empty? coll) (vec a) (conj (vec a) coll)))\n        (recur (conj acc a) coll))))))","problem":28,"user":"4e521cef535d302ef430da6d"},{"code":"(fn flatten* [x]\n   (if (coll? x)\n    (mapcat flatten* x)\n    [x]))","problem":28,"user":"50602bc6e4b08f2a82ad10ba"},{"problem":28,"code":"(fn [a-seq]\n  (loop [res [] remaining a-seq]\n    (let [the-first (first remaining) the-rest (rest remaining)]\n      (cond \n       (empty? remaining) res\n     \t (coll? the-first) \n         (if (empty? the-rest)\n           (recur res the-first)\n           (recur res (apply conj (vec the-first) (vec the-rest))))\n     \t :else (recur (conj res the-first) (vec the-rest))))))","user":"55d332f5e4b0e31453f64a5f"},{"problem":28,"code":"(fn ftn [x] (if (sequential? x)\n             (mapcat ftn x)\n             (list x)))","user":"6087cb25e4b0ae75613dced8"},{"code":"(fn flatt [l] (reduce (fn [fl i] (concat fl (if (coll? i) (flatt i) [i]))) '() l))","problem":28,"user":"51411e3be4b05ca1a0b379f3"},{"problem":28,"code":"(fn flatit [x]\n  (reduce\n    (fn f [y z]\n      (if (coll? z)\n        (reduce f y z)\n        (into y (vector z))))\n    []\n    x))","user":"54893618e4b0e286459a11e0"},{"code":"(fn foo [coll]\n  (println \"foo\" coll)\n  (loop [input coll output []]\n    (println \"loop\" input output)\n    (if (empty? input)\n      output\n      (let [n (first input) r (rest input)]\n        (if (instance? Iterable n)\n          (recur r (concat output (foo n)))\n          (recur r (concat output (list n))))))))","problem":28,"user":"5033a1fbe4b062bc5d7ae155"},{"code":"(fn flat [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"5241fe85e4b076e5d3121f42"},{"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))\n;;(fn f [s] (mapcat #(if (sequential? %) (f %) [%]) s))","problem":28,"user":"5149f383e4b0829bd132edb2"},{"problem":28,"code":"(fn [collection]\n(loop [current collection]\n  (if (some coll? current)\n    (recur (reduce (fn [collection,element]\n\t\t\t\t\t(if (coll? element)\n    \t\t\t\t\t(into collection element)\n    \t\t\t\t\t(conj collection element))) [] current))\n    current)))","user":"5c1d9f05e4b0efcb0b05b24c"},{"code":"(fn mysol [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n     \t(if (sequential? l)\n              \t\t(mysol l)\n              \t\t[l])\n        (when (sequential? r)\n          \t\t\t(mysol r)\n          \t\t\t\n          )\n     )\n    )\n  )","problem":28,"user":"52faff0de4b047fd55837007"},{"problem":28,"code":"(fn flatten- [coll] \n  (reduce #(do (if (coll? %2) \n             (into [] (concat %1 (flatten- %2))) \n             (conj %1 %2))) \n          [] coll))","user":"53e4b5a3e4b036ad0777e44b"},{"code":"(fn -flatten\n  [coll]\n  (cond (empty? coll)\n        coll\n\n        (sequential? (first coll))\n        (concat (-flatten (first coll)) (-flatten (rest coll)))\n\n        :else\n        (lazy-seq (cons (first coll) (-flatten (rest coll))))))","problem":28,"user":"4ed2a31c535d44c135fd68db"},{"problem":28,"code":"(fn flt [xs]\n       (let [head (first xs)\n             tail (next xs)]\n         (filter identity (concat\n          (if (sequential? head)\n            (flt head)\n            [head])\n          (if (sequential? tail)\n          (flt tail)\n          [tail])))))","user":"51e8736ae4b006d205356a4f"},{"problem":28,"code":"(fn f\n  [s]\n  (cond\n    (empty? s) []\n    (coll? (first s)) (f (concat (first s) (rest s)))\n    :else (cons (first s) (f (rest s)))))","user":"5b72b36ce4b047b03b2036a9"},{"code":"(fn f [ & x] (mapcat #(if (sequential? %) (apply f %) [%]) x))","problem":28,"user":"4ff67852e4b0678c553fc37e"},{"problem":28,"code":"(fn flat [s]\n  (let [[f & r] s]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"56dbe1f4e4b0ea9b8538f813"},{"code":"(fn myflatten [coll]\r\n  (if (empty? coll)\r\n    []\r\n    (let [a (first coll)]\r\n      (if-not (coll? a)\r\n        (concat (conj [] a) (myflatten (rest coll)))\r\n        (concat (myflatten a) (myflatten (rest coll)))))))","problem":28,"user":"4fd170fce4b04c3a95aa0411"},{"problem":28,"code":"(fn flatten-seq[coll]\n   (loop [flattened [] stuff coll] \n     (if (empty? stuff)\n       flattened\n       (let [first-ele (first stuff)]\n         (if (coll? first-ele)\n\t\t\t(recur (concat flattened (flatten-seq first-ele)) (rest stuff))\n       \t\t(recur (concat flattened [first-ele]) (rest stuff)))))))","user":"564b1ff8e4b0284900eef663"},{"code":"(fn flatten2 [x]\r\n  (let [s? #(instance? clojure.lang.Sequential %)]\r\n    (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4dd579b5535dae65d5c462ea"},{"code":"#(loop [r []\n        c %]\n   (if (coll? (first c))\n     (recur r (concat (first c) (rest c)))\n     (if (next c)\n       (recur (conj r (first c)) (rest c))\n       (conj r (first c)))))","problem":28,"user":"4ecc1d85535d23f0362276f8"},{"code":"(fn f [x] (if (coll? x) (reduce concat (map f x)) [x]))","problem":28,"user":"50e7dd5de4b077ad597af36b"},{"problem":28,"code":"(fn flatten-seq\n  [s] (reduce #(if (sequential? %2)\n                 (vec (concat %1 (flatten-seq %2)))\n                 (conj %1 %2)) [] s))","user":"5ef9ea69e4b09b61f08553d1"},{"problem":28,"code":"#(reverse ((fn foo [l]\r\n    (if (sequential? l)\r\n      (let [e (first l)\r\n            r (rest l)]\r\n        (if (= 0 (count l))\r\n          '()\r\n          (concat (foo r) (foo e))))\r\n      (list l))) %))","user":"57a9b2dbe4b0a96607956233"},{"code":"(fn [coll](filter (complement sequential?) (rest (tree-seq sequential? seq coll))))","problem":28,"user":"50a4cbbee4b0344e360f3bc2"},{"problem":28,"code":"(fn flattn [x] \n  (#(if (coll? %) \n      (mapcat flattn %) \n      (list %) \n    )x))","user":"56fa2905e4b07572ad1a88be"},{"problem":28,"code":"#(reduce (fn rollup [x y] (concat x (if (coll? y) (reduce rollup [] y) [y]))) [] %)","user":"53e2b212e4b036ad0777e3f4"},{"code":"(fn [lst]\n  (letfn [(flat [coll]\n    (seq\n      (when-let [c (seq coll)]\n(let [x (first c)]\n(if (sequential? x)\n(concat (flat (first c)) (flat (rest c)))\n(cons (first c) (flat (rest c))))))))]\n(flat lst)))","problem":28,"user":"5055899de4b0ce54f56f03fd"},{"problem":28,"code":"#(reverse (reduce \n  (fn x [o i] \n    (if (coll? i) \n      (reduce x o i) \n      (conj o i)))\n  nil\n  %))","user":"532df9c5e4b019098a6f8b42"},{"code":"(fn my-flatten [xs]\n  (loop [xs (reverse xs) res []]\n  (cond (empty? xs) res\n        (vector? (first xs)) (recur (rest xs) (if (empty? res)\n                                            (my-flatten (seq (first xs)))\n                                            (concat (my-flatten (seq (first xs))) res)))\n        (seq? (first xs)) (recur (rest xs) (if (empty? res)\n                                            (my-flatten (first xs))\n                                            (concat (my-flatten (first xs)) res)))\n        :else\n        (recur (rest xs) (cons (first xs) res)))))","problem":28,"user":"504f5804e4b0a02f9cffde72"},{"problem":28,"code":"(fn my-flatten\n  ([s] (my-flatten s '()))\n  ([s flattened]\n   (let [e (first s)]\n     (if (nil? e)\n       flattened\n       (if (coll? e)\n         (recur (rest s) (concat flattened (my-flatten e)))\n         (recur (rest s) (concat flattened (list e))))))))","user":"57233cc8e4b0c5bde472c0e1"},{"code":"(fn my-flat [xs]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq xs)))","problem":28,"user":"53287dace4b09d4e7a9b5507"},{"problem":28,"code":"(fn flat [lst]\n  (loop [current-list lst new-list []]\n    (if (empty? current-list)\n      new-list\n      (if (sequential? (first current-list))\n        (recur (into (rest current-list) (reverse (first current-list))) new-list)\n        (recur (rest current-list) (conj new-list (first current-list)))))))","user":"580b79e4e4b0a837a8b30d4a"},{"problem":28,"code":"(fn [coll]\n  (let [res (reduce\n              #(if (coll? %2)\n                 (into [] (concat %1 %2))\n                 (conj %1 %2)) [] coll)]\n    (if-not (some coll? res)\n      res\n      (recur res)))\n  )","user":"5f663bc0e4b02876ed9fd02d"},{"problem":28,"code":"(fn foo [li] (reduce #(if (coll? %2) (into [] (concat %1 (foo %2))) (conj %1 %2)) [] li))","user":"5eb3f908e4b00a66d4a9521a"},{"code":"(fn [xs] \n  (let [f (fn [ [x & xs :as xss ] acc ]\n            (cond\n             (sequential? x) (recur (concat x xs) acc )\n             (empty? xss) (reverse acc)\n             :else (recur xs (cons x acc))))] \n    (f xs [])\n  )\n)","problem":28,"user":"52ccc2bde4b07d0d72b27371"},{"problem":28,"code":"(fn [arg]\n  (let [fl (fn fltn\n               [acc item]\n               (if (not (sequential? item))\n                 (conj acc item)\n                 (if (not-empty item)\n                   (let [[fst & rst] item\n                          nacc (fltn acc fst)]\n                     (fltn nacc (sequence rst)))\n                   acc)))]\n    (fl [] arg)))","user":"5a798ac5e4b03baeef9276c0"},{"problem":28,"code":"(fn\n  [x]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)))","user":"5a067f26e4b01bb0ae8afdcc"},{"problem":28,"code":"(fn flat [s] \n  (let [f (first s) r (rest s)]\n    (if (= r ())\n      (if (coll? f) \n        (flat f)\n        (list f))\n      (if (coll? f) \n        (concat (flat f) (flat r))\n        (conj (flat r) f)))))","user":"5d81c244e4b0915913b1d37a"},{"problem":28,"code":"(fn flat [in]\n   (if (coll? in)\n     (apply concat\n       (for [elt in]\n         (flat elt)))\n     (list in)))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":28,"code":"(fn f[coll]\n  (reduce \n   (fn [a x] \n     (if (coll? x) \n       (apply conj a (f x)) \n       (conj a x)))\n   []\n   coll))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn  [elems]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq elems))))","problem":28,"user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn fltn [[f & r :as s]]\n  (cond\n    (empty? s) '()\n    (coll? f) (concat (fltn f) (fltn r))\n    :else (concat (list f) (fltn r))))","problem":28,"user":"4f1c9652535d64f603146483"},{"problem":28,"code":"(fn flatter [s]\n  (if (coll? s)\n    (mapcat flatter s)\n    [s]))","user":"5703cbbee4b08d47c97781fb"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) (tree-seq sequential? seq  x)))","user":"5510f734e4b06e50f9beb18f"},{"code":"(fn f[l] (if (coll? l) (if (= [] l) l (concat (f (first l)) (f (rest l)))) [l]))","problem":28,"user":"4ea2ddf1535d7eef308072bf"},{"code":"#(reduce (fn self [xs e]\n                (concat xs\n                    (if (coll? e)\n                        (reduce self '() e)\n                        (list e)))) '() %)","problem":28,"user":"521249f5e4b06aa6d1666ba2"},{"code":"(fn flatten2 [sequence]\n  (println sequence)\n  (if (or (not (coll? sequence)) (empty? (rest sequence)))\n    (if (not (coll? sequence)) [sequence] (flatten2 (first sequence)))\n    (concat (flatten2 (first sequence)) (flatten2 (rest sequence)))))","problem":28,"user":"4fc5273ce4b081705acca37f"},{"code":"(fn flatten-aux [a] (if (coll? a) (if (empty? a ) a (concat (flatten-aux (first a)) (flatten-aux (rest a))))  (list a)))","problem":28,"user":"503b6995e4b07a1917cc34dd"},{"problem":28,"code":"(fn customFlatten [input]\n  (let [firstItem (first input) remaining (next input)]\n    (concat\n      (if (sequential? firstItem)\n        (customFlatten firstItem)\n        [firstItem]\n      )\n      (when (sequential? remaining) (customFlatten remaining))\n    )\n  )\n)","user":"506af7d8e4b0a2a5463de37d"},{"problem":28,"code":"(fn my-flatten\n  ([coll acc]\n   (if (empty? coll)\n     acc\n     (let [[x & more] coll]\n       (if (coll? x)\n         (my-flatten more\n                      (vec (concat acc (my-flatten x []))))\n         (my-flatten more (conj acc x))))))\n  ([coll]\n   (my-flatten coll [])))","user":"5746cb28e4b009280f9f2b68"},{"problem":28,"code":"(fn flat [coll]\n   (if (sequential? coll)\n     (mapcat flat coll)\n     (list coll)))","user":"5652dd89e4b0f9d632dd8469"},{"problem":28,"code":"(fn FLATTEN [element]\n  (if (and\n        (coll? element)\n        (not (empty? element)))\n\n    (concat\n      (FLATTEN (first element))\n      (FLATTEN (rest element)))\n\n    (if (coll? element)\n      element\n      [element]\n      )\n\n    )\n\n  )","user":"5aa11b37e4b0d174b936c840"},{"problem":28,"code":"(fn unnest [nested]\n  (if (empty? nested)\n    nested\n  (if (sequential? (first nested))\n    (concat (unnest (first nested)) (unnest (rest nested)))\n    (cons (first nested) (unnest (rest nested))))))","user":"5604bcf7e4b08b23635d315a"},{"problem":28,"code":"(fn flt [x]\n    (if (coll? x)\n      (mapcat flt x)\n      [x]))","user":"5a18488ee4b0ff51aa4b31e5"},{"problem":28,"code":"(fn fl [x] (reduce concat (map #(if (coll? %) (fl %) [%]) x)))","user":"6089bc95e4b0ae75613dcef5"},{"problem":28,"code":"(fn [s]\n    (letfn [(foo [n]\n              (reduce (fn [acc x]\n                        (if (coll? x) (concat acc (foo x))\n                            (concat acc [x])))\n                      '() n))]\n      (foo s)))","user":"5935b010e4b04f87174def55"},{"problem":28,"code":"(fn flatten-seq\n  [input]\n  (let [v (first input)\n        r (next input)]\n    (concat\n     (if (sequential? v)\n       (flatten-seq v)\n       [v])\n     (when (sequential? r)\n       (flatten-seq r)))))","user":"53de7484e4b0d874e779ae35"},{"code":"(fn [elems]\n  (loop [s elems, acc ()]\n    (if (empty? s)\n      (reverse acc)\n      (let [[hd & tl] s]\n        (if (sequential? hd)\n          (if (empty? hd)\n            (recur tl acc)\n            (recur (conj tl (rest hd) (first hd)) acc))\n          (recur tl (conj acc hd)))))))","problem":28,"user":"4ea4fe1f535d7eef308072cf"},{"code":"(fn cl\r\n  [coll]\r\n\t(filter (complement sequential?)\r\n\t\t\t(tree-seq sequential? seq coll)))","problem":28,"user":"4edbae0d535d10e5ff6f531c"},{"problem":28,"code":"(fn flatn [xs]\n  (lazy-seq\n    (when-let [s (seq xs)]\n      (let [first (first s)\n            rest (rest s)]\n        (if (coll? first)\n          (concat (flatn first) (flatn rest))\n          (cons first (flatn rest)))))))","user":"5954108ae4b066ee0a44aef4"},{"code":"(fn my-flatten [thing]\r\n  (cond\r\n   (not (sequential? thing))\r\n   ()\r\n   (sequential? (first thing))\r\n   (concat (my-flatten (first thing))\r\n           (my-flatten (rest thing)))\r\n   (empty? (rest thing))\r\n   thing\r\n   :otherwise\r\n   (cons (first thing) (my-flatten (rest thing)))))","problem":28,"user":"508b95a0e4b0be79e5b189c6"},{"problem":28,"code":"(fn flatn [l]\n  (cond\n   (not (coll? l)) (list l)\n   (empty? l) []\n                  \n   :else (concat (flatn (first l)) (flatn (rest l)))))","user":"539e79d2e4b0ca733b974489"},{"code":"(fn flat [x] (reduce concat (map (fn [y] (if (coll? y) (flat y) [y])) x)))","problem":28,"user":"535920b2e4b04ce2eb3ed294"},{"problem":28,"code":"(fn flatten-stuff\n  [seq]\n   (mapcat\n     #(if (sequential? %)\n        (flatten-stuff %)\n        [%]) seq))","user":"5d1c14cde4b02ea6f0fb698a"},{"problem":28,"code":"(fn make_flat [values] \n  (if (coll? values)  \n    (if (> (count (rest values)) 0) \n\t    (concat (make_flat (first values)) (make_flat (rest values)))\n    \t(make_flat (first values))\n    )\n    [values] \n  )\n)","user":"5e69589de4b04a83ad7cd26d"},{"code":"(fn [x]\n  ((fn f [y result]\n    (if (not (coll? y))\n        (conj result y)\n        (if (empty? y) result\n          (f (first y) \n                (f (rest y) result)))))\n    x '()))","problem":28,"user":"4e73a9dc535dff18050a9c77"},{"problem":28,"code":"(fn flatland [xs]\n  (loop [xs xs\n         flat []]\n    (if (empty? xs)\n      flat\n      (if (sequential? (first xs))\n        (recur (rest xs)\n               (concat flat (flatland (first xs))))\n        (recur (rest xs)\n               (conj (vec flat) (first xs))))\n)))","user":"54be792ee4b0ed20f4ff6eeb"},{"problem":28,"code":"(fn [input]\n(reverse\n((fn flt [x]\n\t\t(reduce #(if (coll? %2) (concat (flt %2) %1) (conj %1 %2)) '() x)\n ) \ninput)))","user":"5b7bc82ce4b047b03b203726"},{"code":"(fn w [n] (lazy-seq (if (coll? n) (mapcat w n) [n])))","problem":28,"user":"4e82f85d535db62dc21a62ce"},{"problem":28,"code":"#(filter (complement sequential?)  (tree-seq sequential? identity %))","user":"551e312ce4b030e6a24d00e5"},{"problem":28,"code":"(fn [coll]\n  (filter (complement sequential?) (tree-seq sequential? identity coll)))","user":"54d70bbfe4b0a52adc2e2026"},{"problem":28,"code":"(fn process1 [xs]\n  (letfn [(process2 [xs ys]\n            (cond (not (coll? xs)) (conj (process1 ys) xs)\n                  (empty? xs) (process1 ys)\n                  (empty? (rest xs)) (process2 (first xs) ys)\n                  :else (process2 (first xs) (conj ys (rest xs)))))]\n    (if (empty? xs) \n      '()\n      (process2 xs '()))))","user":"595fd721e4b066ee0a44b06e"},{"code":"(fn flat[coll]\r\n  (if (and (coll? coll) (not (empty? coll)))\r\n  (concat (flat (first coll)) (flat (rest coll)))\r\n  (if (not (coll? coll)) (list coll) \r\n    (if (empty? coll) coll (list coll)))))","problem":28,"user":"4dbed096535d020aff1edf6b"},{"problem":28,"code":"(fn flatit [l]\n  (let [car (first l)\n        cdr (next l)]\n    (concat\n     (if (coll? car)\n       (flatit car)\n       [car])\n     (when (coll? cdr)\n       (flatit cdr)))))","user":"541df0b5e4b01498b1a71a86"},{"problem":28,"code":"#(let [myflatten\n       (fn  fme [ve]\n         ( loop [v ve]\n          (if (empty? v)\n            '()\n            (if (sequential? (first v) )\n              (concat  (fme (first v))  (fme (rest v)) )\n              (cons  (first v)  (fme (rest v)) )\n              ))) )]\n   (myflatten %) )","user":"57bffed6e4b05aa3c4741c89"},{"code":"(fn [arg]\r\n  (reverse ((fn inner [s e]\r\n    (if (empty? s) e\r\n      (let [f (first s)]\r\n        (recur (rest s)\r\n          (if (coll? f)\r\n            (concat (inner f '()) e)\r\n            (conj e f))))))\r\n    arg '())))","problem":28,"user":"4dee4a9c535d08e6dec9fe11"},{"problem":28,"code":"(fn flatten-rec [coll]\n  (cond (empty? coll) \n        nil\n    (coll? (first coll)) \n        (concat (flatten-rec (first coll)) (flatten-rec (rest coll)))\n    :else \n        (cons (first coll) (flatten-rec (rest coll)))))","user":"5182de5ce4b0353c468deb74"},{"code":"#(remove sequential? (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e6b3fc8535d8ccf87e9ff0f"},{"problem":28,"code":"(fn my-flatten \n\t[x]\n\t(if (not (coll? x)) \n\t\t(list x)\n\t\t(if (empty? x)\n\t\t\t()\n\t\t\t(into (my-flatten (rest x)) (reverse (my-flatten (first x)))))))","user":"56bb652ae4b0f26550335953"},{"code":"#(let [s sequential?]\n  (remove s (tree-seq s identity %)))","problem":28,"user":"5013193ae4b0f26a0e3320ab"},{"problem":28,"code":"(fn [lst]\n  (letfn [(rec [elems]\n               (let [x (first elems)\n                     xs (rest elems)]\n                 (cond (nil? x) nil\n                       (sequential? x) (concat (rec x) (rec xs))                       \n                       :else (cons x (rec xs)))))]\n    (rec lst)))","user":"5516a874e4b06a49daca83b5"},{"code":"(fn flatten-seq [s]\n  (let [l (first s) r (next s)]\n    (concat\n     (if (sequential? l)\n       (flatten-seq l)\n       [l])\n     (when (sequential? r)\n       (flatten-seq r)))))","problem":28,"user":"50b79c5fe4b0cf3e51c3046c"},{"code":"(fn f [s]\n   (cond\n    (not (sequential? s)) (list s)\n    (empty? s) s\n    :else (concat (f (first s)) (f (rest s)))))","problem":28,"user":"4e5af45e535d8a8b8723a2b1"},{"problem":28,"code":"(fn flat [s]\r\n    (if (sequential? s)\r\n      (apply concat (map flat s))\r\n      (list s)))","user":"540459bfe4b0addc1aec6656"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))\n          )\n  )","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn f [l]\n  (cond\n    (empty? l) ()\n    (sequential? (first l))(concat (f (first l))(f (rest l)))\n    :else (cons (first l)(f (rest l)))))","problem":28,"user":"50a83315e4b054305ba5a830"},{"problem":28,"code":"(fn [x] (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","user":"59c22fbae4b0a024fb6ae4a3"},{"problem":28,"code":"(fn make-flat [element] ( \n  if (sequential? element) (apply concat (map make-flat element)) [element] \n  ) \n)","user":"5a285a38e4b07f18be40aa67"},{"problem":28,"code":"#(letfn [(red [y] \n                (reduce (fn [prev, x ]\n                          (concat prev (if (coll? x) (red x) (conj '() x))))\n                        '() y)\n                )]\n     (red %))","user":"5717bcffe4b07c98581c3b16"},{"problem":28,"code":"(fn f [xs]\n  (if (coll? xs)\n    (apply concat (map f xs))\n    (list xs)))","user":"5829d9f8e4b051871117bf4d"},{"code":"#(loop [col %1\n        acc []]\n   (cond\n    (empty? col) acc \n    (coll? (first col)) (recur (concat (first col) (rest col)) acc)\n    :else (recur (rest col) (conj acc (first col)))  \n      ))","problem":28,"user":"52fc89b2e4b047fd55837019"},{"code":"(fn flat [[f & r]]\n  (when f\n    (if (sequential? f)\n      (concat (flat f) (flat r))\n      (cons f (flat r)))))","problem":28,"user":"4fe8a3bde4b07c9f6fd12c61"},{"code":"(fn flat [s]\n  (let [seqable? (fn [s] (or (seq? s) (vector? s)))]\n       (mapcat #(if (seqable? %) (flat %) [%]) s)))","problem":28,"user":"5338e33fe4b0e30313ee6ca1"},{"problem":28,"code":"(fn fltn [el]\n  (if (coll? el)\n    (mapcat fltn el)\n    [el]\n  )\n)","user":"558fec41e4b0277789237666"},{"problem":28,"code":"(fn [c] (let [a (atom [])] (clojure.walk/postwalk #(when-not (coll? %) (swap! a conj %)) c) @a))","user":"4ff8487be4b0678c553fc397"},{"problem":28,"code":"(fn fltn [input] (if (coll? input) (mapcat fltn input) [input]))","user":"5f309144e4b0574c87022c23"},{"problem":28,"code":"(fn flat [x] \n\t(mapcat #(if (not (coll? %) )\n\t       (list %)\n\t       (flat %)) x))","user":"54fae43ae4b0cf870d934708"},{"problem":28,"code":"#(if (= (first %) '(1 2))\n   '(1 2 3 4 5 6)\n   (if (= (first %) \"a\")\n     '(\"a\" \"b\" \"c\")\n     '(:a)))","user":"54213a8fe4b01498b1a71aaf"},{"code":"(fn fltn [L] (cond (not (coll? L)) [L]\n                   :else (apply concat (map fltn L))))","problem":28,"user":"52153bdde4b0961f15ac4daa"},{"code":"(fn flt [x] \n     \t\t(mapcat #(if (coll? %) (flt %) (list %)) x))","problem":28,"user":"51cf126ae4b0e42293a2256b"},{"problem":28,"code":"(fn myf [s]\n\n   (if (not (coll? s))\n     (conj [] s)\n\n     (vec (filter #(not (nil? %)) (apply conj (myf (first s)) (myf (next s)))))))","user":"56b1b59be4b0982f16b37df2"},{"problem":28,"code":"(fn[coll]\n  (loop [in coll out []]\n    (cond (empty? in) out\n          (coll? (first in)) (recur (concat (first in) (rest in)) out)\n          :else (recur (rest in) (conj out (first in))))))","user":"5472cba1e4b094393f72dd7a"},{"code":"(fn flt [coll]\n  (apply\n    concat\n    (map\n      #(if (coll? %)\n        (flt %)\n        (list %))\n      coll)))","problem":28,"user":"4ee2da14535d10e5ff6f536c"},{"problem":28,"code":"#(loop [s % o [] r % l 0]\n   (cond\n    (and (empty? s) (= 0 l))\n    o\n    (empty? s)\n    (recur r\n           o\n           r\n           (dec l))\n    (sequential? (first s))\n    (recur (first s)\n           o\n           (if (= 0 l)\n             (rest s)\n             r)\n           (inc l))\n    :else\n    (recur (rest s)\n           (conj o (first s))\n           r\n           l)))","user":"56a9d4bbe4b07966d5a8a07b"},{"problem":28,"code":"(fn\n  [xs]\n  (loop [remaining xs result ()]\n    (cond\n     (empty? remaining) (reverse result)\n     (sequential? (first remaining)) (recur (concat (first remaining) (rest remaining)) result)\n     :else (recur (rest remaining) (cons (first remaining) result)))))","user":"54926752e4b0b312c081ff44"},{"problem":28,"code":"(fn fltn [c] (reduce (fn [l v] (if (coll? v) (concat l (fltn v)) (concat l [v]))) '() c))","user":"5f2de7ede4b033932238a674"},{"problem":28,"code":"(fn my-flatten [col]\n  (reduce (fn [acc current]\n            (if (coll? current)\n             (into acc (my-flatten current))\n             (conj acc current)))\n          []\n          col))","user":"525523e3e4b0541d1855b9cc"},{"code":"(fn flattn [x] (if (empty? x) '() (if (coll? (first x))\n  (concat (flattn (first x)) (flattn (rest x)))\n  (conj (flattn (rest x)) (first x))\n  ))\n)","problem":28,"user":"4f036d6e535dcb61093f6ac0"},{"code":"(fn flt [s] (mapcat (fn [el] (if (sequential? el) (flt el) [el])) s) )","problem":28,"user":"4fea2de5e4b0140c20fb9bfe"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (println \"arg is \" s)\n  (if (coll? s)\n    (do\n      (println \"is coll - \" s)\n      (mapcat my-flatten s))\n    (do\n      (println \"is not coll - \" s)\n      [s])))","user":"58bd84d2e4b0888cdc949d31"},{"code":"#(filter (complement sequential?)(rest(tree-seq sequential? seq %)))","problem":28,"user":"4ee6166e535d93acb0a66854"},{"problem":28,"code":"(fn my-flatten [coll] (if (sequential? coll) (mapcat my-flatten coll) (list coll)))","user":"5b857411e4b047b03b2037ce"},{"problem":28,"code":"(fn flt [xs] \n  (if (empty? (filter sequential? xs)) xs\n    (flt (mapcat \n           #(if (not (sequential? %)) (conj () %) %) \n           xs))))","user":"53ef78bee4b0742d9025b0cd"},{"code":"(fn f [lst]\n    (loop [lst lst acc []]\n      (if (empty? lst)\n        acc\n        (let [the-first (first lst)\n              the-rest (rest lst)]\n          (println \"first: \" the-first \", rest: \" the-rest \"  acc: \" acc)\n          (if (or (list? the-first) (vector? the-first))\n            (recur the-rest (vec (concat acc (f the-first))))\n            (recur the-rest (conj acc the-first)))\n          )\n        )))","problem":28,"user":"51750cd4e4b07031762f2ee5"},{"code":"(fn [my-seq]\n   (reverse ((fn outer [my-seq acc]\n     (if (empty? my-seq)\n       acc\n       (if (or (seq? (first my-seq)) (vector? (first my-seq)))\n         (outer (rest my-seq) (outer (first my-seq) acc))\n         (outer (rest my-seq) (conj acc (first my-seq)))))) my-seq '())))","problem":28,"user":"4ede0511535d10e5ff6f5330"},{"problem":28,"code":"(fn f [[x & xs]]\n   (if (nil? x)\n     nil\n     (if (coll? x)\n       (concat (f x) (f xs))\n       (concat [x] (f xs)))))","user":"55acab76e4b03311e7b73294"},{"problem":28,"code":"(fn f [xs]\n (cond\n     (empty? xs) []\n     (sequential? (first xs)) (concat (f (first xs)) (f (rest xs)))\n     :else (cons (first xs) (f (rest xs)))))","user":"552b6ddbe4b0ffed3738f965"},{"problem":28,"code":"(fn foo [l]\n  (if (empty? l) '()\n      (if (not (coll? (first l)))\n        (concat (list (first l))\n                (foo (rest l)))\n        (concat (foo (first l))\n                (foo (rest l))))))","user":"54d26316e4b0e8a36923e5f2"},{"code":"(fn flatten2\n  [x]\n  (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"50c2fbebe4b00e537d00253c"},{"problem":28,"code":"(fn my-flatten [collection]\n    (loop [res '() col collection]\n      (if (empty? col)\n        res\n        (let [head (first col) tail (rest col)]\n          ; (println res head tail)\n          (if (coll? head)\n            (recur (concat res (my-flatten head)) tail)\n            (recur (concat res (list head)) tail))))))","user":"59fa7fb0e4b0ca45a743a366"},{"problem":28,"code":"(fn [y] (reverse (reduce (fn [x y] (if-not (coll? y)\n                                      (conj x y)\n                                      (reduce (fn [x y] (if-not (coll? y)\n                                                          (conj x y)\n                                                          (reduce (fn [x y] (if-not (coll? y)\n                                                                              (conj x y)\n                                                                              (reduce conj x y))) x y))) x y)))\n                          '() y)))","user":"5a4d656fe4b05d388ecb6ba9"},{"code":"(fn flt [c]\n  (if (coll? c)\n    (mapcat flt c)\n    (list c)\n    )\n  )","problem":28,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn flat [elts]\n  (if (empty? elts)\n    ()\n    (if (coll? (first elts))\n      (concat (flat (first elts)) (flat (rest elts)))\n      (concat (list (first elts)) (flat (rest elts))))))","problem":28,"user":"502940a9e4b061fd216be4b8"},{"problem":28,"code":"(fn f [[x & xs]]\n  (cond \n   (not x) '()\n   (coll? x) (concat (f x) (f xs))\n   :else (concat (list x) (f xs))))","user":"5d1200cbe4b02c15ef02198e"},{"problem":28,"code":"#(letfn [(f1 [x]\n            (if (sequential? x)\n              (if (empty? x) []\n                (concat (f1 (first x)) (f1 (rest x))))\n              (vector x)))]\n  (f1 %))","user":"5547b72be4b0a04f79299550"},{"problem":28,"code":"(fn flt [xs] (if (first xs) (if (coll? (first xs)) (concat (flt (first xs)) (flt (rest xs))) (cons (first xs) (flt (rest xs))))()))","user":"56686edce4b04acd4f672dea"},{"code":";;copied from cloj source\n(fn [x]\n  (filter (complement sequential?)\n            (rest (tree-seq sequential? seq x))))","problem":28,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"#(filter (complement sequential?) \n       (rest (tree-seq sequential? seq %)))","problem":28,"user":"4dcd327b535d5973398f929b"},{"code":"#(reduce  (fn f [x y] (cond (or (list? y) (vector? y)) (reduce f x y) :default (conj x y))) [] %)","problem":28,"user":"4e79a143535db169f9c796a2"},{"code":"(fn flat [s]\n  (if (coll? s) \n    (mapcat flat s)\n    [s]))","problem":28,"user":"4f849f76e4b033992c121c36"},{"code":"reduce\n  #(letfn\n      [(f [p n]\n          (if (coll? n)\n            (reduce f p n)\n            (conj p n))\n      )]\n     (f % %2)\n    )\n\n  []","problem":28,"user":"4ef4e5fa535dced4c769f242"},{"problem":28,"code":"(fn myflatten [collection]\r\n  (if (sequential? collection)\r\n    (mapcat myflatten collection)\r\n    (list collection)))","user":"5075e374e4b09049dea827a5"},{"problem":28,"code":"(fn flttn [coll]\n  (println coll)\n  (if (or \n    (coll? (first coll))\n    (> (count coll) 1))\n    (if (coll? (first coll))\n      (concat \n          (flttn (first coll))\n          (flttn (rest coll)))\n      (conj \n          (flttn (rest coll))\n          (first coll)))\n     coll))","user":"5167e8ace4b0c5a4140a309a"},{"problem":28,"code":"(fn flt[x]\n  (if (coll? x)\n    (mapcat flt x)\n    [x]\n  )\n )","user":"5ce41d1be4b0a17bb84e2b50"},{"problem":28,"code":"(fn my-flat [x] (if (coll? x) (mapcat my-flat x) [x]))","user":"5cb4e764e4b026601754b929"},{"problem":28,"code":"(fn dig [coll]\n   (if (sequential? coll)\n     (mapcat dig coll)\n     (list coll)))","user":"5565d5e4e4b0c656e3ff181f"},{"problem":28,"code":"(fn [coll]\n  (loop [l2 '() l1 coll ]\n    (cond\n     (empty? l1) (reverse l2)\n     (sequential? (first l1)) (recur l2 (concat (first l1) (rest l1)))\n     :else (recur (conj l2 (first l1)) (rest l1))\n     )))","user":"5863eda2e4b0f14aab7c8836"},{"code":"#(filter (complement sequential?) (tree-seq sequential? seq %))\n\n#_(fn [xs]\n  (loop [[f & r] xs\n         acc []]\n    (if (coll? f)\n      (recur (into (vec f) r) \n             acc)\n      (if (empty? r)\n        (conj acc f)\n        (recur r \n               (conj acc f))))))","problem":28,"user":"51e5a627e4b0efabf93c02db"},{"code":"(fn f [l] (mapcat #(if (coll? %) (f %) [%]) l))","problem":28,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn [in]\n   (letfn [(build [x]\n       (cond\n         (not (coll? x)) (conj '() x)\n         (and (coll? x) (empty? x)) nil\n         :else (concat (build (first x)) (build (rest x)))))]\n   (build in)))","problem":28,"user":"4f9f9ff5e4b0dcca54ed6d3a"},{"code":"(fn fltn [coll]\n    (let [l (first coll) r (next coll)]\n        (concat\n            (if (sequential? l) (fltn l) [l])\n            (when (sequential? r) (fltn r))\n)))","problem":28,"user":"4f1b1f31535d64f603146477"},{"problem":28,"code":"(fn flattener [coll]\n  (if (sequential? coll)\n    (mapcat flattener coll)\n    (list coll)))","user":"566e3af2e4b0a866af6896d5"},{"problem":28,"code":"(fn myFlat [arg]\n    (if (coll? arg)\n      (mapcat myFlat arg)\n      [arg]))","user":"56936547e4b0dcc4269f4101"},{"problem":28,"code":"(fn my-flatten [s]\n      (reduce (fn [result next] \n              (if (sequential? next)\n                (apply conj result (my-flatten next))\n                (conj result next))) \n              [] s))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn f [l]\n  (when (seq l)\n    (if (sequential? (first l))\n      (concat (f (first l)) (f (rest l)))\n      (cons (first l) (f (rest l))))))","problem":28,"user":"50b1d166e4b03ea880433554"},{"problem":28,"code":"(fn flat [item]\n  (mapcat #(if (coll? %)\n             (flat %)\n             [%])\n          item))","user":"60ac91c5e4b00e9e6653c485"},{"problem":28,"code":"(fn my-flatten [item]\n  (cond\n    (coll? item) (mapcat my-flatten item)\n    :else [item]))","user":"5c87217de4b0c8042a70cea1"},{"problem":28,"code":"(fn my-flatten [avec]\n    (if (coll? avec)\n         (apply concat (map my-flatten avec) )\n         (list avec)\n     )\n  )","user":"5135a74ae4b04ac1f358dd46"},{"code":"(fn fla [coll]\n   (let [l (first coll) r (next coll)]\n     (concat\n       (if (sequential? l)\n         (fla l)\n         [l])\n       (when (sequential? r)\n         (fla r)))))","problem":28,"user":"52c672e2e4b0c2d177d6210e"},{"code":"(fn blah [x] (if (coll? x) (mapcat blah x) (list x)))","problem":28,"user":"4f17aa97535d64f603146456"},{"code":"#(remove sequential? (rest (tree-seq sequential? seq %)  ))","problem":28,"user":"5381ac68e4b06839e8705ecc"},{"problem":28,"code":"reduce (fn fltn [acc x] (if (coll? x) (reduce fltn acc x) (conj acc x))) []","user":"59c8ffe6e4b0a024fb6ae56c"},{"problem":28,"code":"(fn flatz [coll] (if (coll? coll) (reduce into [] (map flatz coll)) [coll]))","user":"53ee7f2ee4b0d648e757f4cf"},{"problem":28,"code":"(fn doit [x] (if (reduce #(and %1 (not (coll? %2))) true x) x (doit (mapcat #(if (coll? %1) %1 (vector %1)) x))))","user":"5d6d2172e4b04d129b00f2b9"},{"code":"(fn f [x]\n   (let [h (first x) r (next x)]\n     (concat\n      (if (sequential? h)\n        (f h)\n        [h])\n      (when (sequential? r)\n        (f r))\n      )\n    )\n  )","problem":28,"user":"532cb6bbe4b019098a6f8b33"},{"problem":28,"code":"#(letfn [(flt [elt]\n              (if (sequential? elt)\n                (apply concat (map flt elt))\n                (list elt)))]\n   (apply concat (map flt %)))","user":"54dd3bdde4b024c67c0cf791"},{"code":"(letfn [(fl [cum it]\n                   (cond\n                     (nil? it) cum\n                     (coll? it) (-> (fl cum (first it))\n                                  (fl (next it)))\n                     :else (conj cum it)))]\n           (partial fl []))","problem":28,"user":"4fe900a6e4b0547ebccb243a"},{"problem":28,"code":"(fn foo [xs]\n  (if (coll? xs)\n    (apply concat (map foo xs))\n    (list xs)))","user":"5b611666e4b0c6492753e70d"},{"problem":28,"code":"(fn flat [s]\n        (if (or (seq? s) (coll? s))\n          (if (empty? s)\n            s\n            (concat (flat (first s)) (flat (rest s))))\n          [s]))","user":"546c4377e4b00cfc9eacc177"},{"code":"(fn [x] (map #(read-string % ) (into [] (.split (.replaceAll (str x) \"\\\\(|\\\\)|\\\\[|\\\\]\" \"\") \" \"))))","problem":28,"user":"4e78dc98535db95036265724"},{"problem":28,"code":"(fn flat\n  ([x]\n   (filter (complement sequential?) (rest (tree-seq sequential? seq x)))))","user":"5de6c094e4b0986d99407f6f"},{"code":"(fn [coll] (seq (reduce (fn my-flatten [v e] (if (coll? e) (reduce my-flatten v e) (conj v e))) [] coll)))","problem":28,"user":"50ed9e8de4b06330c1f87c44"},{"problem":28,"code":"(fn [seq]\n  (reduce #(if (not (sequential? %2))\n             (into %1 [%2])\n             (into %1 ((fn [head tail] (if (or nil (empty? tail))\n                                         head\n                                         (let [rest-head (first tail)]\n                                             (if (sequential? rest-head)\n                                               (recur head (into [(first rest-head)] (if (empty? (rest rest-head))\n                                                                                       (rest tail)\n                                                                                       (into (rest rest-head) (rest tail)))))\n                                               (recur (into head [rest-head]) (rest tail)))))\n                         )\n                        [] %2)))\n             []\n             seq)\n  )","user":"5b69529be4b0c6492753e786"},{"problem":28,"code":"(fn [col] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq col))))","user":"587b8bdee4b01531a375eaff"},{"problem":28,"code":"(fn flt [x]\n  (if (empty? x)\n    []\n    (let [itm0 (first x)\n          f0 (if (coll? itm0) (flt itm0) [itm0])\n          frest (flt (rest x))]\n      (if (empty? frest)\n        f0\n        (apply conj f0 frest))\n    )))","user":"53d60f57e4b0e771c3025451"},{"problem":28,"code":"(fn flaterator [sq]\n   (let [f (fn flat [acc sq]                                                                                       \n             (reduce (fn [acc* item]\n                       (if (sequential? item)                               \t\t \n                         (flat acc* item)\n                         (conj acc* item)))\n                     acc\n                     sq))]\n     (f [] sq)))","user":"5e62c405e4b0fd0acd15869b"},{"problem":28,"code":"(fn g [l]\n           (if (coll? l)\n             (if (empty? l)\n               l\n               (concat (g (first l))\n                       (g (rest l )))\n             )\n             (list l)\n           )\n         \n)","user":"570dc955e4b0b0fb43fd06e0"},{"problem":28,"code":"(fn flatten-a-sequence [s]\n  (reduce (fn myflatten [collection element]\n            (if (sequential? element)\n              (reduce myflatten collection element)\n              (conj collection element))) [] s))","user":"5549ca1ce4b0a04f7929956c"},{"problem":28,"code":"(fn f [xs]\n  (if (sequential? xs)\n    (if (empty? xs) \n      [] \n      (concat (f (first xs)) (f (rest xs))))\n    [xs]))","user":"5360578ee4b0243289761e35"},{"problem":28,"code":"#(\n(fn flat [s r]\n    (if (and (coll? s)(empty? s))\n        r\n        (if (coll? s)\n            (flat (rest s) (flat (first s) r) )\n            (conj r s))\n    )\n) % [])","user":"53ba5475e4b047364c0444f4"},{"code":"(fn f[x](if(coll? x)(mapcat f x)[x]))","problem":28,"user":"4de77a0a535d08e6dec9fdfa"},{"code":"(fn f[v]\n  (reduce \n    (fn[a b]\n      (if (not (sequential? b)) \n        (concat a (list b))\n        (concat a (f b)))) [] v))","problem":28,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn flat [coll] (when-let [c (seq coll)]\n (let [x (first c)]\n                       (if (sequential? x)\n                         (concat (flat x) (flat (rest c)))\n                         (cons x (flat (rest c)))))))","problem":28,"user":"518644bce4b0da5a5be3baca"},{"problem":28,"code":"#(loop [f (first %)\n         r (rest %)\n         t nil]\n    (if (and (not (coll? f)) (empty? r))\n      (reverse (conj t f))\n      (if (coll? f)\n        (recur (first f) (if (empty? (rest f))\n                           r\n                           (conj r (rest f))) t)\n        (recur (first r) (rest r) (conj t f)))))","user":"5b6ccc58e4b0c6492753e7bb"},{"code":"(fn f8 [x]\n  (if (sequential? x)\n    (mapcat f8 x)\n    (list x)))","problem":28,"user":"535aee3be4b04ce2eb3ed2aa"},{"problem":28,"code":"#(reduce (fn myflatten [collection element]\n             (if (sequential? element)\n                (reduce myflatten collection element)\n               (conj collection element))) [] %)","user":"570d4c30e4b0b0fb43fd06da"},{"problem":28,"code":"(fn flat [x]\n  (apply concat (map #(if (coll? %)\n            (flat %)\n            [%]) x)))","user":"54e345a1e4b024c67c0cf7db"},{"problem":28,"code":"reduce (fn flat [acc x] (if (or (seq? x) (vector? x)) (reduce flat acc x) (conj acc x))) []","user":"567ffd69e4b0966858e4d8e7"},{"problem":28,"code":"(fn flatten_ [s]\n  (reduce\n   (fn [result x]\n     (if (coll? x)\n       (vec (concat result (flatten_ x)))\n       (conj result x)))\n   (vector)\n   s))","user":"55b54ecbe4b01b9910ae2987"},{"code":"(fn cat [x]\n  (concat (\n           if (empty? x)\n           []\n           (\n             if (sequential? (first x))\n              (cat (first x))\n              (list (first x))\n            )\n          )\n          (\n           if (empty? x)\n           []\n           (cat (rest x))\n          )\n  )\n)","problem":28,"user":"5303a027e4b0d8b024fd3745"},{"code":"(fn flt [col] \n  (if (coll? col)\n    (apply concat (map flt col))\n    (list col)\n    )\n  )","problem":28,"user":"510b704ee4b078ea71921100"},{"code":"(fn [lst]\n   ((fn inner [lst]\n      (cond\n       (empty? lst) ()\n       (coll? (first lst)) (concat (inner (first lst)) (inner (rest lst)))\n       :else (conj (inner (rest lst)) (first lst))))\n    lst))","problem":28,"user":"52c25645e4b07a9af579237d"},{"code":"(fn flatter \n  ([input] (flatter input []))\n  ([input init]\n    (if (sequential? input)\n      (reduce concat (for [x input] (flatter x init)))\n      (cons input init)\n      )\n    )\n  )","problem":28,"user":"4ec4d723535dcc7ae8597d65"},{"code":"#(loop [[h & t] % r []]\n  (if h\n    (if (coll? h)\n       (recur (concat h t) r)\n       (recur t (conj r h)))\n    r))","problem":28,"user":"4db2cd84535df7e46ed9b6c6"},{"code":"#(remove sequential? (tree-seq sequential? seq %))","problem":28,"user":"4e6ea1f5535d5021c1a8960e"},{"code":";; (fn flat [x] (if (coll? x) (mapcat flat x) [x]))\n\n(fn my-flatten [unflattened]\n  (loop [flattened '() i 0]\n    (cond\n     (= i (count unflattened)) flattened\n     (coll? (nth unflattened i)) (recur (concat flattened (my-flatten (nth unflattened i))) (inc i))\n     :else (recur (concat flattened (list (nth unflattened i))) (inc i)))))","problem":28,"user":"4fc6d2c1e4b0ee37620e181b"},{"code":"(fn flat [x]\n  (reduce #(concat %1 (if (sequential? %2) (flat %2) [%2])) '() x))","problem":28,"user":"505dcfc8e4b0e6aca564be0d"},{"code":"(fn [l]\r\n  (filter (complement sequential?)\r\n            (tree-seq sequential? seq l)))","problem":28,"user":"50576483e4b001218172198b"},{"problem":28,"code":"#(seq\n   (reduce\n    (fn flat [v e]\n      (if (coll? e)\n        (reduce flat v e)\n        (conj v e)))\n    [] %))","user":"5cdc17d0e4b05ee0cb31173c"},{"code":"(fn my_flatten [l] \n  (reverse (loop [l l result nil] (if (nil? l) result (if (coll? (first l)) (recur (next l) (concat (reverse (my_flatten (first l))) result)) (recur (next l) (cons (first l) result)))))))","problem":28,"user":"4e351b47535deb9a81d77f2b"},{"problem":28,"code":"(fn flatn [xs]\n   (reduce\n    (fn [acc item]\n      (if (sequential? item)\n        (into acc (flatn item))\n        (conj acc item)))\n    []\n    xs))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":28,"code":"(fn flt [lst]\n  (loop [final []\n         r lst]\n    (if (empty? r)\n      final\n      (recur (if (coll? (first r))\n               \t(into final (flt (first r)))\n               \t(conj final (first r)))\n             (rest r)))))","user":"59ac559ee4b00adcf69795d2"},{"problem":28,"code":"(fn [coll] (first\n            (drop-while\n             (fn [xs] (reduce #(or %1 %2) false (map coll? xs)))\n             (iterate (fn [xs] (reduce #(if (coll? %2)\n                                            (concat %1 %2)\n                                            (concat %1 (list %2))) '() xs))\n                       coll))))","user":"53c1b787e4b00fb29b221266"},{"problem":28,"code":"(fn [x] \n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":28,"code":"(fn x [m]\n    (let [f (first m)\n          r (rest m)]\n      (if (empty? r)\n        (if (coll? f)\n          (x f)\n          (list f))\n        (if (coll? f)\n          (concat (x f) (x r))\n          (conj (x r) f)))))","user":"5703cb87e4b08d47c97781f9"},{"problem":28,"code":"(fn [sq] (filter (complement sequential?)\n                 (rest (tree-seq sequential? seq sq))))","user":"5630cff7e4b0bfe05bf11787"},{"code":"(fn f [coll]\n  (if (seq coll)\n    (let [fst (first coll)\n          rst (rest coll)]\n      (if (coll? fst)\n          (concat (f fst) (f rst))\n          (concat [fst] (f rst))))\n    coll))","problem":28,"user":"51195e77e4b055cfb310d499"},{"problem":28,"code":"(fn flattus [coll]\n   (cond\n     (empty? coll) []\n     (coll? (first coll)) (concat (flattus (first coll)) (flattus (rest coll)))\n     :else (cons (first coll) (flattus (rest coll)))))","user":"571cd9dce4b0145328a76271"},{"code":"(fn [coll]\r\n  (letfn [(rec [x]\r\n            (if (coll? x)\r\n                (if (empty? x)\r\n                    '()\r\n                    (concat (rec (first x)) (rec (rest x))))\r\n            (list x)))]\r\n    (rec coll)))","problem":28,"user":"4fb37882e4b081705acca2a0"},{"code":"#(reduce (fn f [acc x]\n          (if (coll? x)\n            (apply conj acc (reduce f [] x))\n            (conj acc x)))\n        []\n        %)","problem":28,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":28,"code":"(fn off1 [x]\n  (let [f (first x)\n        r (rest x)]\n    (if (empty? x) nil\n      (if (not (sequential? f)) (cons f (off1 r))\n        (concat (off1 f) (off1 r))))))","user":"5604ae27e4b0c80df0ca2663"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)\n      )\n     )\n    [] coll)))","user":"5594f8aee4b0c79f6e1db95c"},{"problem":28,"code":"(fn f [s] \n  (mapcat \n   #(if (sequential? %) \n      (f %) \n      [%]) \n   s))","user":"561c0278e4b064ca9f4b1691"},{"problem":28,"code":"(fn flatten'\n\t[x]\n\t(when x\n      (let [[head & tail] x]\n        (if (or (list? head) (vector? head))\n          (concat\n           (flatten' head)\n           (flatten' tail))\n          (cons head\n                (flatten' tail))))))","user":"5bba703fe4b0a20761a235eb"},{"problem":28,"code":"(fn f [x] \n  (if (coll? x)\n    (concat (f (first x)) (f (next x)))\n    (if (nil? x) nil [x])\n   )\n  )","user":"593dfe60e4b069cdc2982bb1"},{"code":"(fn fltn [x]\n  (reverse\n    (reduce #(if (coll? %2)\n                 (concat (reverse (fltn %2)) %)\n                 (cons %2 %))\n      () x)))","problem":28,"user":"53940789e4b0b51d73faaec3"},{"problem":28,"code":"(fn [coll]\n  (loop [acc [] raw coll]\n    (if-not (seq raw)\n      (seq acc)\n      (let [f (first raw)\n            r (rest raw)]\n        (if (sequential? f)\n          (recur acc (concat f r))\n          (recur (conj acc f) r))))))","user":"53b71b94e4b047364c0444cd"},{"code":"(fn [l] (let [f (fn [f l] (mapcat #(if (coll? %1) (f f %1) (list %1)) l))] (f f l)))","problem":28,"user":"4e756736535d7a570dd295c2"},{"problem":28,"code":"(fn flt [lst]\n  (if (coll? lst)\n    (mapcat flt lst) \n    (list lst)))","user":"5c9d0a0be4b048ec896c5afc"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    ()\n    (let [a (first lst)\n          b (rest lst)]\n      (if (sequential? a)\n        (concat (my-flatten a) (my-flatten b))\n        (conj (my-flatten b) a)))))","user":"57f814fbe4b0d3187e900911"},{"problem":28,"code":"(fn r [x] (mapcat #((if (sequential? %) r list) %) x))","user":"5df50e55e4b03c219ef1a387"},{"code":"(fn [xs]\n  (letfn [(flat [head tail]\n                (if (empty? tail)\n                  head\n                  (let [mid (first tail)]\n                    (recur (if (coll? mid)\n                             (flat head mid)\n                             (conj head mid))\n                           (rest tail)))))]\n    (flat [] xs)))","problem":28,"user":"50f9739ce4b0e7c80cb15a4d"},{"problem":28,"code":"(fn [aSeq]\n   (filter\n          (complement coll?)\n          (tree-seq sequential? seq aSeq))\n   )","user":"5cf7215ce4b0b71b1d808a67"},{"code":"#(remove coll? (tree-seq seq? seq ((fn [a] (map (fn r [x] (if (coll? x) (map r x) x)) a)) %)))","problem":28,"user":"53874820e4b06839e8705f1b"},{"problem":28,"code":"#(into '()   ((fn f [output-list [head & tail]]\n                 (if (nil? head)\n                   output-list\n                   (if (coll? head)\n                     (f  (f output-list head) tail)\n                     (f  (cons head output-list) tail)))) '() %))","user":"58db362be4b0a4d5acaab675"},{"code":"#(if (reduce (fn [a b] (and a b)) (map (fn [x] (not (coll? x))) %)) % (recur (reduce (fn [x y] (if (coll? x) (if (coll? y) (concat x y) (conj (vec x) y)) (if (coll? y) (conj (seq y) x) (list x y)))) %)))","problem":28,"user":"52f89ac8e4b047fd55836fd7"},{"problem":28,"code":"(fn _flatten [s]\n  (let [c (first s) \n        r (rest s)\n        seq1 (if (sequential? c)\n                 (_flatten c)\n                 [c])\n        seq2 (if (empty? r)\n                 r\n                 (_flatten r))]\n    (concat seq1 seq2)))","user":"54361d92e4b032a45b8692f7"},{"problem":28,"code":"(fn aaa [coll]\n  (let [i (atom 0) res (atom [])]\n    (while (< @i (count coll))\n      (let [curr (nth coll @i)]\n        (if (coll? curr)\n          (reset! res (concat @res (aaa curr)))\n          (reset! res (conj (vec @res) curr)))\n        (swap! i inc)\n        )\n      )\n    @res)\n  )","user":"5c1229d5e4b01240ff567188"},{"code":"(fn flat [x]\n    (if (coll? x)\n        (if (empty? x) x\n        (concat (flat (first x)) (flat (rest x))))\n        (list x)\n    )\n)","problem":28,"user":"50588af1e4b06522596eba7d"},{"code":"(fn flatt [se]\n  (if (empty? se)\n    (list)\n    (if (not (coll? (first se)))\n      (cons  (first se) (flatt (rest se)))\n      (concat (flatt (first se))(flatt (rest se)) ))))","problem":28,"user":"51cdec45e4b0e42293a2254f"},{"code":"(fn flat [xs]\n  (cond\n    (not (coll? xs)) (list xs)\n    (empty? xs) xs\n    :else (concat (flat (first xs))\n                  (flat (rest xs)))))","problem":28,"user":"4ed2918f535d44c135fd68d8"},{"code":"(fn [x]\n  (let [f (fn f2 [x y]\n            (loop [s x r y]\n              (cond (not (sequential? s)) (conj r s)\n              (empty? s) r\n              :else (recur (rest s) (f2 (first s) r)))))]\n  (f x [])))","problem":28,"user":"4fae258de4b081705acca246"},{"code":"(fn [x] (filter \n  (complement sequential?) \n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e7f8f85535db966e863cc44"},{"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (apply concat (map my-flatten x))\n    [x]\n  )\n)","problem":28,"user":"50bfbf25e4b05ae8c1cbbd9b"},{"code":"(fn flt[coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l) \n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"4f6fe5e4e4b07046d9f4efef"},{"code":"(fn flattenn [subject]\n    (cond\n      (empty? subject) []\n      (sequential? (first subject)) (concat (flattenn (first subject)) (flattenn (rest subject)))\n      (not (sequential? (first subject))) (concat (list (first subject)) \n                                                  (flattenn (rest subject)))))","problem":28,"user":"4fd8544be4b0dab7d829f390"},{"code":"(fn fl [s] (if (sequential? s) (apply concat (map fl s)) [s]))","problem":28,"user":"51435753e4b0c172af7558d5"},{"problem":28,"code":"(fn my-flat [x]\n  (if (coll? x)\n    (mapcat my-flat x)\n    [x]))","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn flat ([sq] (reverse (flat sq '())))\n    ([sq coll]\n      (if (empty? sq)\n          coll\n          (recur\n            (rest sq)\n            (if (sequential? (first sq))\n                (concat (flat (seq (first sq)) '()) coll)\n                (cons (first sq) coll))))))","problem":28,"user":"4fab0b6be4b081705acca20c"},{"problem":28,"code":"(fn flatten' [xs] (mapcat #(if (sequential? %) (flatten' %) [%]) xs))","user":"58ee84e5e4b056aecfd47dab"},{"problem":28,"code":"(fn flat [seq]\n    (print (str seq \" - \"))\n        (cond\n          (empty? seq) '()\n          (not (sequential? (first seq))) (cons (first seq) (flat (rest seq)))\n          (sequential? (first seq)) (concat (flat (first seq)) (flat (rest seq)))\n          )\n        )","user":"55ddc5cbe4b050e68259b3d0"},{"problem":28,"code":"#(loop [s % acc []]\n   (if (empty? s)\n     acc\n     (let [head (first s)\n           tail (rest s)]\n       (if (sequential? head)\n         (recur (concat head tail) acc)\n         (recur tail (conj acc head))))))","user":"4f037faf535dcb61093f6af8"},{"code":"(fn flattn [s]\n  (cond (empty? s) '()\n        (coll? (first s))\n          (apply list (concat (flattn (first s)) (flattn (rest s))))\n        :else\n          (cons (first s) (flattn (rest s)))))","problem":28,"user":"4f70afb8e4b07046d9f4effb"},{"code":"(fn flatify\n  [coll]\n  (let [[flat notflat] (split-with (comp not coll?) coll)]\n    (if (seq notflat)\n      (concat flat (flatify (first notflat)) (flatify (next notflat)))\n      flat)))","problem":28,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn fratten [c]\n  (if (coll? c)\n    (for [item c subitem (fratten item)] subitem)\n    [c]))","problem":28,"user":"4f5eda39e4b0030a34fb2b56"},{"problem":28,"code":"(fn fltn [mylist]\n    (when-let [s (seq mylist)]\n          (if (coll? (first s)) \n              (concat (fltn (first s)) (fltn (rest s)))\n            (cons (first s) (fltn (rest s))))\n\n          ))","user":"57c6aa0be4b05aa3c4741cf7"},{"code":"(fn flat [x]\n  (let [seqable? (fn [x] (or (seq? x) (list? x) (vector? x)))\n        conjinto (fn[xs v] (if (seqable? v)(into xs v)(conj xs v)))\n               y (reduce conjinto [] x)]\n        (if (= x y) y (flat y))\n  ))","problem":28,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn fl [s] (mapcat (fn [x] (if (not (sequential? x)) [x] (fl x))) s))","problem":28,"user":"4ddbf54e535d02782fcbe9ff"},{"problem":28,"code":"(fn my-flatten [xs]\n  (letfn [(flat-combiner [xs x]\n             (if (sequential? x)\n               (reduce flat-combiner xs x)\n               (cons x xs)))\n\n          (reverse-flatten [xs] \n            (reduce flat-combiner '() xs))]\n\n  (reverse (reverse-flatten xs))))","user":"5661e09ae4b068f2fe63dc70"},{"problem":28,"code":"(fn f [n] \n  (let [[x & xs] n]\n    (cond \n     (empty? n) '()\n     (coll? x) (concat (f x)(f xs))\n     :else (cons x (f xs))\n    \n    )))","user":"59648ce1e4b069c0a1a19769"},{"code":"(fn f [c]\n    (reduce \n      (fn fiter [a i]\n        (concat a \n          (if (coll? i) (f i)\n            [i])))\n      [] c))","problem":28,"user":"50e5bca5e4b09ae9427b0e75"},{"problem":28,"code":"(fn m-flattern [a-seq]\n  (loop [[x & xs :as sq] a-seq\n         rs []]\n    (cond\n      (empty? sq) rs\n      :else (if (sequential? x)\n              (recur (concat x xs) rs)\n              (recur xs (conj rs x))))))","user":"57d174ede4b0bd073c20236c"},{"problem":28,"code":"(fn my-flatten\n  [[fst & rst :as col]]\n  (if (empty? col) '()\n      (if (coll? fst)\n        (concat (my-flatten fst) (my-flatten rst))\n        (cons fst (my-flatten rst)))))","user":"5d8ce0e6e4b0915913b1d3e5"},{"code":"(fn flt [n] (let [[x & xs] n]\n  (cond\n    (empty? n) '()\n    (coll? x) (concat (flt x) (flt xs))\n    :else (cons x (flt xs))\n)))","problem":28,"user":"4ffb38e8e4b0678c553fc3c6"},{"problem":28,"code":"(fn mflatten [iseq]\n  (reduce (fn [nseq item]\n            (if (sequential? item)\n              (reduce conj nseq (mflatten item))\n              (conj nseq item)))\n          []\n          iseq))","user":"589c2e3fe4b00487982d5357"},{"problem":28,"code":"(fn flatter [coll]\n   (if (coll? coll) \n     (reduce concat () (map flatter coll))\n     [coll])  \n)","user":"54b050cee4b09f271ff37d13"},{"problem":28,"code":"(fn [l]\n  (loop [l l a []]\n    (if-let [e (first l)]\n      (if (sequential? e)\n        ;make a new list of left with e split into the new list. \n        (recur (reduce into \n                      [] \n                      [e (rest l)])\n               a)\n        ; just an element\n        (recur (rest l) \n               (conj a e) ))\n      a)))","user":"55d8eed3e4b0e31453f64ac3"},{"code":"(fn f [l x] \n  (if (sequential? x)\n    (if (empty? x) \n      l \n      (f (f (vec l) (first x)) (rest x)))\n    (conj (vec l) x))) []","problem":28,"user":"50b8e9a4e4b0cba0e598b656"},{"code":"(fn [coll] \n  (filter (complement sequential?)\n          (rest (tree-seq sequential? identity coll))))","problem":28,"user":"52eb400ee4b0705949c4443b"},{"problem":28,"code":"(fn walk \n  [[head & tail]]\n\t(concat\n    \t(if (sequential? head)\n    \t    (walk head)\n        \t(vector head))\n      \t(when tail\n        \t(walk tail))))","user":"53ce0a29e4b00fb29b2212eb"},{"code":"(fn my-flatten\n  [xs]\n  (when (seq xs)\n    (concat (if (sequential? (first xs))\n              (my-flatten (first xs))\n              [(first xs)])\n            (my-flatten (rest xs)))))","problem":28,"user":"53028354e4b0d8b024fd372b"},{"problem":28,"code":"(fn flat [s] (reduce concat (map #(if (coll? %1) (flat %1) [%1]) s)))","user":"575a0ef0e4b02ea114799335"},{"problem":28,"code":"#(reverse (reduce (fn fl [acc x] (if (sequential? x) (reduce fl acc x) (cons x acc))) [] %))","user":"5e486cb0e4b043cd24807a3e"},{"code":"#(letfn [(flatten-helper [%]\n                (when-let [s (seq %)]\n                  (if (coll? (first s))\n                    (concat (flatten-helper (first s)) (flatten-helper (rest s)))\n                    (cons (first s) (flatten-helper (rest s))))))]\n        (flatten-helper [%]))","problem":28,"user":"52000564e4b023d2eb508ca8"},{"problem":28,"code":"#(filter (complement sequential?)\n          (tree-seq sequential? identity %))","user":"5ed08785e4b016b56eae05b1"},{"problem":28,"code":"(fn my_flatten [& rest]\n  (let [w (let [z (first rest)]\n            (if (sequential? z) (apply my_flatten z) (list z)))]\n    (let [y (next rest)] (if y (concat w (apply my_flatten y)) w))))","user":"567b39b6e4b05957ce8c61a3"},{"code":"(fn flat [coll]\n  (let [a (first coll) b (next coll)]\n    (concat\n      (if (sequential? a)\n        (flat a)\n        [a])\n      (when (sequential? b)\n        (flat b)))))","problem":28,"user":"506929ffe4b01dc6af13f82b"},{"problem":28,"code":"(fn [coll]\n  (let [flat-conj (fn flat-conj\n                    ([coll x]      (if (sequential? x) (apply flat-conj coll x) (conj coll x)))\n                    ([coll x & ys] (flat-conj (flat-conj coll x) ys)))]\n  (reduce flat-conj [] coll)))","user":"5b073c34e4b0cc2b61a3bda4"},{"code":"(fn [lst]\n    (loop [rem (seq lst), acc (vector)]\n      (if (empty? rem)\n        (seq acc)\n        (let [r1 (first rem)\n              rr (rest rem)]\n          (if (not (sequential? r1))\n            (recur rr (conj acc r1))\n            (recur (concat r1 rr) acc))))))","problem":28,"user":"538e36c7e4b0b51d73faae81"},{"problem":28,"code":"(fn my-flat [x] \n  (cond\n    (not (coll? x)) x\n    (empty? x) x\n    (coll? (first x)) (concat (my-flat (first x)) (my-flat (rest x)))\n    :else (cons (first x) (my-flat (rest x)))))","user":"53ff8c31e4b0de5c41848603"},{"problem":28,"code":"(fn mflatten [x]\n  (apply concat (map #(if (coll? %) (mflatten %) (list %)) x)))","user":"55330d7fe4b09218d5f44f88"},{"problem":28,"code":"(fn my-flatten\n   [lst]\n   (if (empty? lst)\n     ()\n     (if (or (list? (first lst)) (vector? (first lst)))\n       (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n       (cons (first lst) (my-flatten (rest lst))))))","user":"5bbc0ddfe4b0a20761a2361e"},{"problem":28,"code":"(fn flat\n  ([the_list] (flat '() the_list))\n  ([accum the_list]\n   (prn the_list '| accum)\n   (if (coll? the_list)\n     (reduce flat accum the_list)\n     (concat accum (list the_list))\n     )\n   )\n  )","user":"5c527129e4b0fb8c5ffd99de"},{"code":"(fn makeflat [coll]\n    (when (not-empty coll)\n      (let [left (drop-while (complement coll?) coll)]\n      (concat (take-while (complement coll?) coll)\n              (makeflat (first left))\n               (makeflat (rest left))))))","problem":28,"user":"515896f2e4b059418b97f0a8"},{"problem":28,"code":"(fn my-flatten [coll]\n  (\n   (fn recursive-flatten [carry item]\n     (reduce (fn [a b]\n               (if (coll? b) (recursive-flatten a b) (conj a b)))\n             carry\n             item)\n     )\n   [] coll\n   )\n  )","user":"55044fb8e4b086ebe8a79c7a"},{"problem":28,"code":"(fn fl [l] (if (coll? l) (reduce concat (map fl l)) (seq [l])))","user":"53f5f740e4b0db01ade6f9d8"},{"code":"(fn flattn [col]\n  (if (sequential? col)\n    (mapcat flattn col)\n    [col]))","problem":28,"user":"52808559e4b0757a1b171403"},{"problem":28,"code":"(fn flatten* [s] \n  (mapcat #(if (coll? %)\n             (flatten* %)\n             [%])\n          s))","user":"55caabd1e4b0e31453f649fb"},{"code":"(fn flt[coll] \n          (let [l (first coll) r (next coll)] \n               (concat \n                (if (sequential? l)\n                    (flt l)\n                    [l]) \n                (when (sequential? r)\n                  (flt r)))))","problem":28,"user":"4f05ea25535dcb61093f6c02"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (not (sequential? f)) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))\n;; piti luntata :-/","user":"5d77a828e4b02e6b30c93531"},{"code":"(fn f [s]\n  (if (coll? s)\n    (mapcat f s)\n  [s]))","problem":28,"user":"4e43b0d9535dc968683fc4a3"},{"problem":28,"code":"(fn [s]\n  (filter #(not (sequential? %))\n          (tree-seq sequential? identity s)))","user":"5dd45bb8e4b0948ae9d9ad6b"},{"problem":28,"code":"(fn [lst]\n  (letfn \n    [(aux [l]\n        (if (coll? l)\n          (let [sec (seq l) sec1 (first sec)]\n            (concat\n              (if\n                (sequential? sec1) (aux sec1)\n                (cons sec1 '()))\n              (aux (next sec))\n            )\n          )\n        )\n      )\n    ]\n    (aux lst)\n  )\n)","user":"5e94ff5fe4b0fbed045a37ff"},{"code":"(fn myflatten [s]                                                                                                                                                                                                                       \n           (if (= s ()) ()                                                                                                                                                                                                                     \n            (let [[sfirst srest] [(first s) (rest s)]]                                                                                                                                                                                         \n                     (concat (if (coll? sfirst) (myflatten sfirst) [sfirst])                                                                                                                                                                   \n                             (myflatten srest)))))","problem":28,"user":"4fbfe9a4e4b081705acca31f"},{"problem":28,"code":"(fn f [x]\n  (reduce #(concat %1 (if (sequential? %2) (f %2) (list %2)))\n          () x))","user":"53f77b6ae4b0de5c4184855f"},{"problem":28,"code":"#(filter (comp not sequential?)\n  (tree-seq sequential? identity %))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn myflatten [list]\n  (if (empty? list) ()\n    (let [x (first list)\n          l (rest list)]\n        (if (coll? x) (concat (myflatten x) (myflatten l))\n            (conj (myflatten l) x)))))","problem":28,"user":"4f2f6678e4b0d6649770a06e"},{"problem":28,"code":"(fn[l](first \n  (first (drop-while \n  #(not= (first %) (second %)) \n  (partition 2 (iterate #(reduce \n  (fn [c i]\n    (cond \n      (coll? i) (into c i)\n      :else (conj c i))) [] %) l))))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn\n  [x]\n  (letfn [(flat [coll]\n                  (lazy-seq\n                   (when-let [c (seq coll)]\n                     (let [x (first c)]\n                       (if (sequential? x)\n                         (concat (flat x) (flat (rest c)))\n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"521e4f22e4b0dd19981ad079"},{"code":";totally copied this from the source code... I suck\n(fn flat    \t\n \t[x]\n\t(filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"50378996e4b0af0658af77ae"},{"problem":28,"code":"#(remove coll?  (tree-seq coll? seq %1))","user":"54aa665fe4b09f271ff37cb8"},{"code":"(fn flat[s](reduce concat (map #(if (coll? %) \n                                    (flat %) \n                                    [%]\n                                 ) s\n                           )\n            )\n )","problem":28,"user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn a [x]\n               (loop [s x res '()]\n                 (if (empty? s)\n                   res\n                   (if (coll? (first s))\n                     (recur (rest s) (concat res (a (first s))))\n                     (recur (rest s) (concat res [(first s)]))))\n                 )\n               )","problem":28,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":28,"code":"(fn f [l]\n   (if (sequential? l)\n     (reduce (fn [a e] (concat a (f e))) '() l)\n     (list l)))","user":"545ddac3e4b01be26fd74676"},{"problem":28,"code":"(fn flat\n  [coll]\n  (if (sequential? coll)\n    (mapcat flat coll)\n    (list coll)))","user":"542098afe4b01498b1a71aa7"},{"problem":28,"code":"(fn f [seq-in]\n  (if (coll? seq-in) \n    (mapcat f seq-in)\n    [seq-in])\n)","user":"6074dfa4e4b069485764de4c"},{"code":"(fn flatn [x]\n       (when-let [s (seq x)]\n   (if (coll? (first s))\n\t   (concat (flatn (first s)) (flatn (rest s)))\n\t   (cons (first s) (flatn (rest s))))))","problem":28,"user":"4eae2f9e535d7eef30807324"},{"code":"(fn flater [s]\n    (lazy-seq\n        (let [f (first s)\n                r (rest s) ]\n            (if (nil? f)\n                ()\n                (if (coll? f)\n                    (concat (flater f) (flater r))\n                    (cons f (flater r)))))))","problem":28,"user":"4ed72e51535d10e5ff6f52ee"},{"code":"(fn [x]\r\n  (filter (complement sequential?)\r\n          (tree-seq sequential? seq x)))","problem":28,"user":"4ef0b523535dced4c769f20e"},{"problem":28,"code":"(fn [collection]\n\n  (loop [result [] tmpCollection collection]\n\n    (if (= 0 (count tmpCollection))\n\n      result\n\n      (if (coll? (first tmpCollection))\n\n        (recur result (concat [] (first tmpCollection) (rest tmpCollection)))\n\n        (recur (conj result (first tmpCollection)) (rest tmpCollection))))))","user":"59c5093ce4b0a024fb6ae50c"},{"problem":28,"code":"#(reverse (reduce (fn rec-flatten [acc item]\n                      (if (coll? item) (reduce rec-flatten acc item)\n                          (conj acc item))) '() %))","user":"57ca338de4b05aa3c4741d37"},{"problem":28,"code":"(fn [res xs]\n    (if (empty? xs)\n      (reverse res)\n      (let [x (first xs) r (rest xs)]\n        (if (coll? x)\n          (recur res (concat x r))\n          (recur (conj res x) r)))))\n  '()","user":"53c349f5e4b00fb29b22127a"},{"problem":28,"code":"(fn smash [[f & r]] \n  (concat\n   (cond (coll? f)      (smash f)\n         (not (nil? f)) [f])\n   (cond (coll? r)      (smash r)\n         (not (nil? r)) [r])))","user":"514a3fa5e4b0829bd132edb6"},{"problem":28,"code":"(fn my-flat\n  [coll]\n  (loop [r coll\n         n '()]\n    (if (coll? (first r))\n      (recur (concat  (first r) (rest r)) n)\n      (if (seq r)\n        (recur (rest r) (conj n (first r)))\n        (reverse n)))))","user":"5c411df3e4b08cd430848ebf"},{"problem":28,"code":"#(loop [[f & r :as raw] % flat []] (if (empty? raw) flat (if (sequential? f) (recur (concat (seq f) r) flat) (recur r (conj flat f)))))","user":"5bfe4ecfe4b0bdcf453d1608"},{"problem":28,"code":"(fn f [c] \n  (let [s (seq c)] \n    (when s\n      (if (or (instance? clojure.lang.PersistentVector (first s))\n              (instance? clojure.lang.PersistentList (first s)))\n        (f (concat (first s) (rest s)))\n      \t(cons (first s) (f (rest s)))))))","user":"584278e1e4b089d5ab817e19"},{"code":"(fn flatt [coll]\n  (when-let [x  (seq coll)]\n  (if (coll? (first x))\n    (concat (flatt (first x)) (flatt (rest x)))\n    (cons (first x) (flatt (rest x)))\n    )\n  ))","problem":28,"user":"524ac536e4b09eba1c0223a1"},{"code":"(fn my-flatten[s]\n  (if (sequential? s)\n    (let [car (first s)\n          cdr (next s)]\n      (concat (my-flatten car)\n              (when (sequential? cdr)\n                (my-flatten[cdr]))))\n    [s]))","problem":28,"user":"501948b3e4b0b6630b101db5"},{"code":"(fn fl [c] (if (= () c) []\n(if (not (sequential? (first c)))\n(concat [(first c)] (fl (rest c)))\n(concat (fl (first c)) (fl (rest c))))))","problem":28,"user":"4ec51590535d6d7199dd3683"},{"code":"#(letfn [(flat-one [coll] (apply concat coll))\n        (flat [n] (if (sequential? n)\n                     (flat-one (map flat n))\n                     (list n)))]\n  (flat %))","problem":28,"user":"4fa5ddfde4b081705acca1b1"},{"code":"#((fn my-flatten\n  ([initial coll]\n     (loop [result initial\n            remaining coll]\n\t\t(let [[current & rest] remaining]\n\t\t\t(if (nil? current)\n\t\t\t\tresult\n\t\t\t\t(if (coll? current)\n\t\t\t\t\t(recur (my-flatten result current) rest)\n\t\t\t\t\t(recur (conj result current) rest))))))) [] %)","problem":28,"user":"528147b6e4b0757a1b171425"},{"problem":28,"code":"(fn flt\n  ([col]\n    (flt [] col '()))\n  ([toCol fromCol stk]\n    (if (empty? stk)\n      (if (empty? fromCol)\n        toCol\n        (recur toCol (rest fromCol) (conj stk (first fromCol))))\n      (let [item (first stk)]\n        (if (coll? item)\n          (recur toCol fromCol (into (rest stk) (reverse item)))\n          (recur (conj toCol item) fromCol (rest stk)))))))","user":"56fa3f7ae4b07572ad1a88bf"},{"code":"#((fn flatseq [init-seq final-seq]\n      (if (empty? init-seq)\n        final-seq\n        (let [cur-data (first init-seq)]\n          (if (or (vector? cur-data) (list? cur-data) (map? cur-data))\n            (flatseq (rest init-seq) (concat final-seq (flatseq cur-data [])))\n            (flatseq (rest init-seq) (concat final-seq [cur-data])))))) % [])","problem":28,"user":"523288fee4b035af41902a88"},{"problem":28,"code":"(fn seqrecur [coll] (let [l (first coll) r (next coll)] (concat (if (sequential? l) ( seqrecur l) [l]) (when (sequential? r) (seqrecur r)))))","user":"55382530e4b09218d5f44fdd"},{"code":"#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %1)))","problem":28,"user":"508e2584e4b0f17d83ea26c9"},{"problem":28,"code":"(fn [coll] (->> (tree-seq sequential? seq coll) (filter (complement sequential?))))","user":"56aad332e4b03c432f187337"},{"code":"(fn [x]  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e967c4a535dbda64a6f6b47"},{"problem":28,"code":"(fn flt [lst] \n          (reduce \n             (fn [acc x] \n                (if (coll? x)\n                   (vec (concat acc (flt x)))\n                   (conj acc x)))\n             []\n             lst) )","user":"553900d4e4b09218d5f44fe5"},{"problem":28,"code":"(fn my-flat [x]\n      (cond\n        (= () x) []\n        (sequential? x) (-> [] (into (my-flat (first x))) (into (my-flat (rest x))))\n        :else [x]))","user":"59cf4013e4b0ef0a1e9b5b68"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll ret '()]\n    (cond\n      (sequential? (first coll)) (recur (concat (first coll) (rest coll)) ret)\n      (empty? coll) (reverse  ret)\n      :else (recur (rest coll) (cons (first coll) ret)))))","user":"57202eb7e4b0c5bde472c090"},{"problem":28,"code":"(fn flat [x] \n      (mapcat \n       #(if (sequential? %)\n          (flat %)\n          (list %))\n       x))","user":"54a1c22fe4b09f271ff37c4c"},{"code":"(fn myflat [lst]\n    (cond\n        (and (seq? lst) (empty? lst)) ()\n        (or (seq? lst) (vector? lst)) (concat (myflat (first lst)) (myflat (rest lst)))\n        :else (cons lst ())\n    )\n)","problem":28,"user":"4f091dcd535dcb61093f6c43"},{"problem":28,"code":"(fn [i]\n  (loop [past nil\n         present i]\n    (if (seq present)\n      (if (sequential? (first present))\n        (recur \n         past\n         (concat (first present) (rest present)))\n        (recur\n         (concat past (list (first present)))\n         (rest present)))\n      past)))","user":"54a80855e4b09f271ff37c9e"},{"problem":28,"code":"(fn [a] (letfn [(fl [x] (if (sequential? x) (mapcat fl x) (list x)))] (fl a)))","user":"57efb389e4b0bfb2137f5bdb"},{"problem":28,"code":"(fn [list]\n  (loop [flattened '() queue list]\n    (if (empty? queue)\n      flattened\n      (if (coll? (first queue))\n        \n        ;; collection, so explode the collection in place and continue\n        (recur flattened (reduce #(cons %2 %1) (rest queue) (reverse (first queue))))\n\n        ;; not a collection, just a single element, add it to the end flattened list\n        (recur (concat flattened [(first queue)]) (rest queue))\n      )\n    )  \n  ) \n)","user":"583dacc2e4b089d5ab817d9f"},{"code":"(fn f [seq]\n  (reduce #(if (sequential? %2) (apply conj %1 (f %2)) (conj %1 %2)) [] seq))","problem":28,"user":"5161c6a7e4b009fba0926e38"},{"problem":28,"code":"#(->> (tree-seq sequential? seq %)\n      rest\n      (filter (complement sequential?)))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn ! [lst]\n   (into (if\n          (or (= (type (first lst)) clojure.lang.PersistentVector)\n              (= (type (first lst)) clojure.lang.PersistentList)\n              (= (type (first lst)) clojure.lang.PersistentList$EmptyList))\n        (if (= (count lst) 0) [] (! (first lst)))\n        [(first lst)]\n        ) (if (= (count lst) 1) [] (! (rest lst)))))","problem":28,"user":"50d6d7eee4b0159555a1fc76"},{"code":"#(->> (tree-seq sequential? identity %)\n  (filter (comp not sequential?)))","problem":28,"user":"50479524e4b0371827a27bc4"},{"code":"(fn f [x]\n  (cond\n   (or (not (coll? x)) (empty? x)) '()\n   (coll? (first x)) (concat (f (first x)) (f (rest x)))\n   true (conj (f (rest x)) (first x))))","problem":28,"user":"52d7b0ade4b09f7907dd137c"},{"code":"(fn my-flatten [coll]\n  (if (seq coll)\n    (if (coll? (first coll))\n      (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n      (cons (first coll) (my-flatten (rest coll))))\n    nil))","problem":28,"user":"536102efe4b0243289761e3e"},{"problem":28,"code":"(fn foo[coll]\n  (reduce (fn bar[agg coll]\n           (if (coll? coll)\n             (reduce bar agg coll)\n             (conj agg coll)))\n          [] coll))","user":"5537b2c7e4b09218d5f44fce"},{"code":"(fn [x]\n  (reverse ((fn [l res]\n    (if (empty? l) res\n        (if (coll? (first l))\n          (recur (concat (first l) (rest l)) res)\n          (recur (rest l) (conj res (first l)))))\n    ) x '())))","problem":28,"user":"4eb02674535d7eef30807338"},{"code":"(fn flotten\n  [x]\n  (if (empty? x)\n    x\n    (if\n      (or\n        (seq? (first x))\n        (vector? (first x)))\n      (flotten (concat (first x) (rest x)))\n      (conj (flotten (rest x)) (first x)))))","problem":28,"user":"504e12ade4b078edc5f593b7"},{"problem":28,"code":"(fn temp [seqs]\n        (cond (empty? seqs) nil \n          (or (seq? (first seqs)) (vector? (first seqs)))\n          (concat (temp (first seqs)) (temp (rest seqs)))\n          :else (conj (temp (rest seqs )) (first seqs))\n        ))","user":"6038b6b4e4b0d5df2af222ef"},{"problem":28,"code":"(fn flat [x] (sort (reduce #(if (sequential? %2) (concat %1 (flat %2)) (conj %1 %2)) [] x)))","user":"5835a222e4b089d5ab817ce5"},{"problem":28,"code":"(fn myflatten [s]\n  (cond\n    (not (coll? s)) (list s)\n    (empty? s) '()\n   :else \n       (concat (myflatten (first s)) (myflatten (rest s)))\n    )\n  )","user":"554c0adde4b0a04f7929959e"},{"problem":28,"code":"(fn myflatten [x]\n   (loop [remainingitems x resultseq '()]\n       (if (empty? remainingitems)\n         (reverse resultseq)\n       (let [[currentval & remainingvals] remainingitems]\n        (if (sequential? currentval)\n          (recur remainingvals (into resultseq (myflatten currentval)))\n          (recur remainingvals (conj resultseq currentval)))))))","user":"57a2328ae4b0c3d858beb8f8"},{"problem":28,"code":"(fn fltn [coll]\n  (if (sequential? coll)\n    (apply concat \n           (map fltn coll))\n    (list coll)))","user":"568b781be4b0dcc4269f40a5"},{"problem":28,"code":"(fn recflat [x] \n      (if (sequential? x)\n        (mapcat recflat x)\n        [x]))","user":"58b84c28e4b0ebc645576d94"},{"code":"(fn a [x]\n    (cond \n          (vector? x) (a (seq x))\n          (seq? x) \n            (if (empty? x) \n                 x \n                (concat  (a (first x)) (a (rest x)) ))\n          true [x]))","problem":28,"user":"4f04165d535dcb61093f6b9c"},{"problem":28,"code":"(fn flatt-a-seq [coll]\n    (if (coll? coll)\n    (if (empty? coll) \n      '()\n      (mapcat flatt-a-seq coll))\n    (if (nil? coll) \n      seq\n      (list coll))))","user":"568c2d96e4b0dcc4269f40af"},{"problem":28,"code":"(fn r [s] (cond (not (coll? s)) (list s) (empty? s) (list) :else (concat (r (first s)) (r (rest s)))))","user":"556766c1e4b0c656e3ff1840"},{"problem":28,"code":"(fn flt [s]\n  (if-not (sequential? s)\n    (list s)\n    (if (empty? s) \n        s\n        (concat (flt (first s)) (flt (rest s)) ))\n    ))","user":"54d6f22de4b0a52adc2e2023"},{"problem":28,"code":"(fn flat [coll]\n  (if (first coll)\n    (if (coll? (first coll))\n      (concat (flat (first coll)) (flat (rest coll)))\n      (cons (first coll) (flat (rest coll))))))","user":"5df08767e4b093ff717275bf"},{"problem":28,"code":"(fn my-flatten-3\n  [some-seq]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq some-seq))))\n \n#_(fn my-flatten \n  [[x & xs :as my-seq]]\n  (cond\n   (coll? x) (concat (my-flatten x) (my-flatten xs))\n   (nil? x) '()\n   :else (cons x (my-flatten xs))))\n\n#_(fn my-flatten-2\n  [some-coll]\n  (seq (reduce\n        (fn flatten-helper [res el]\n          (if (coll? el)\n            (reduce flatten-helper res el)\n            (conj res el)))\n        []\n        (into [] some-coll))))","user":"57a6ad79e4b0a9660795620b"},{"problem":28,"code":"(fn brute-flatten [to-flatten] (if (some coll? to-flatten) (brute-flatten (mapcat #(if (coll? %) % (list %)) to-flatten)) to-flatten))","user":"5f548678e4b0a0bc16850a7e"},{"problem":28,"code":"(fn flat [x]\n\t(if (sequential? x)\n    \t(mapcat flat x)\n    \t[x]\n    )\n)","user":"5a214798e4b0ff51aa4b32aa"},{"problem":28,"code":"(fn f \n  [xs]\n  (mapcat #(if (sequential? %)\n             (f %)\n             [%]) xs))","user":"5b329773e4b025bcb146f322"},{"code":"(fn flat [x]\n  (if (coll? x) \n    (if (< (count x) 2) \n      (flat (first x))\n      (concat (flat (first x)) (flat (rest x))) \n    )\n  (cons x ()))\n)","problem":28,"user":"52e544d3e4b09f7907dd145e"},{"problem":28,"code":"(fn myfl [x]\n  (loop [mx x flx '()]\n    (if (empty? mx)\n      (reverse flx)\n      (let [first-mx (first mx)\n          rest-mx (rest mx)]\n          (recur rest-mx\n                (if (coll? first-mx)\n                  (into flx (myfl first-mx))\n                  (into flx [first-mx])))))))\n\n; More elegant solution\n;#(filter (complement sequential?)\n;          (rest (tree-seq sequential? seq %)))","user":"5835bc73e4b089d5ab817ce9"},{"code":"(fn [coll]\n  (filter \n   (complement sequential?) \n   (tree-seq sequential? seq coll)))","problem":28,"user":"532b930be4b09d4e7a9b5534"},{"problem":28,"code":"(fn f [coll]\n  (reduce (fn [acc v] (if (sequential? v)\n                        (into acc (f v))\n                        (conj acc v)))\n          []\n          coll))","user":"52d38c51e4b099d49816f0c5"},{"problem":28,"code":"(fn [x] (filter (complement sequential?)\n\n         (rest (tree-seq sequential? seq x))))","user":"53ac4719e4b047364c04445c"},{"problem":28,"code":"(fn f [x] (if (not (coll? x)) (list x) (if (empty? x) '() (concat (f (first x)) (f (rest x))))))","user":"5478e57de4b0c51c1f4d72c1"},{"problem":28,"code":"(fn flat [x] \n  (if (empty? x) '()\n  (concat \n   (if \n     (coll? (first x)) \n     (flat (first x)) \n     (list (first x))) \n   (flat (rest x)))))","user":"56e227a8e4b03a7c14b85a31"},{"problem":28,"code":"(fn f [x] (filter #(-> % sequential? not) (tree-seq sequential? seq x)))","user":"575fbe58e4b08062f99a4e87"},{"problem":28,"code":"(fn foo [x] (if-not (coll? x)(list x)(reduce concat (map foo x))))","user":"542fa0dde4b0dad94371f2d2"},{"code":"(fn [col] (filter (complement sequential?) (tree-seq sequential? seq col)))","problem":28,"user":"51a3c9cde4b0e77c4ca60bf9"},{"code":"(partial (fn f [acc val] (cond (coll? val) (reduce f acc val) :else (conj acc val))) [])","problem":28,"user":"4eb9d8f8535dfed6da9c6d61"},{"problem":28,"code":"(fn f [xs]\n  (mapcat #(if (sequential? %) (f %) [%]) xs))","user":"5da7176ae4b000c986472c13"},{"code":"(fn flt [s] (mapcat #(if (coll? %) (flt %) (list %))s))","problem":28,"user":"4f0397ee535dcb61093f6b30"},{"problem":28,"code":"#(remove sequential?\n       (tree-seq sequential? seq %))","user":"53d64811e4b0e771c3025456"},{"problem":28,"code":"(fn [x]\n  (filter (comp not sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5bd7b8b8e4b0ed4b8aab4bc6"},{"problem":28,"code":"(fn f [l] (if (coll? l)\n\t\t\t(mapcat f l )\n            (list l)\n          )\n )","user":"5720fc08e4b0c5bde472c0a3"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn recflat [acc elem] \n            (if (instance? clojure.lang.Seqable elem)\n              (reduce recflat acc elem)\n              (conj acc elem)))\n          [] s))","user":"563b5dc9e4b0bfe05bf1180f"},{"code":"(fn f [x]\n  (if (sequential? x)\n    (reduce #(concat %1 (f %2)) [] x)\n    [x]))","problem":28,"user":"4f92709de4b0dcca54ed6cad"},{"code":"(fn f [v] (mapcat (fn [x] (if (sequential? x) (f x) [x])) v))","problem":28,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":28,"code":"(fn fla [init lst] \n  (reduce (fn [le, ri]\n            (if (coll? ri)\n              (fla le ri)\n              (conj le ri))) init lst)) []","user":"566812f0e4b04acd4f672de1"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    ()\n    (cond\n      (vector? (first lst)) (concat (my-flatten(first lst)) (my-flatten (rest lst)))\n      (list? (first lst)) (concat (my-flatten(first lst)) (my-flatten (rest lst)))\n      :else (cons (first lst) (my-flatten (rest lst))))))","user":"59e8fef3e4b0249b72820743"},{"code":"(fn [x]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq x)))","problem":28,"user":"5183abf6e4b028ec5fd2f2a6"},{"code":"(fn flat [li]\n  (if-not (coll? li)\n    [li]\n    (reduce concat(map flat li))))","problem":28,"user":"51df505be4b01188f062752a"},{"code":"(fn flatn [x]\n  (if (coll? x)\n    (reduce concat (map flatn x))\n    (list x)\n  )\n)","problem":28,"user":"52b2a819e4b0c58976d9acf1"},{"code":"(fn f [l] \n  (let [p #(or (list? %) (vector? %))] \n  (if \n    (p l) \n    (reduce concat (map f l)) \n    [l])))","problem":28,"user":"50352431e4b0a84c1d88f620"},{"problem":28,"code":"(fn my-flatten2 [x]\n  (cond (or (nil? x) (empty? x)) '()\n        (coll? (first x)) (concat (my-flatten2 (first x)) (my-flatten2 (rest x)))\n        :else (cons (first x) (my-flatten2 (rest x)))))","user":"5e3e0b3fe4b01d43a70e8e1e"},{"code":"(fn smooth [c]\r\n  (if (sequential? c)\r\n(apply concat (map smooth c))(list c)))","problem":28,"user":"4ddeb916535d08e6dec9fdd9"},{"problem":28,"code":"(fn my-flatten [l] \n(loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"5910a43de4b0163c97b36ebf"},{"problem":28,"code":"(fn my-flatten [s] (if (coll? s)\n                       (let [length (count s)]\n                            (cond (= length 0) '()\n                                  (= length 1) (lazy-seq (my-flatten (first s)))\n                                  :else (lazy-cat (my-flatten (first s))\n                                                  (my-flatten (rest s))\n                                        )\n                            )\n                        )\n                        (list s)\n                    )\n)","user":"5990fcb9e4b0866487ed0d5b"},{"code":"(fn [x]\n  (loop [todo x\n         res []]\n    (if (empty? todo)\n      res\n      (let [f (first todo)\n            r (next todo)]\n        (if (coll? f)\n          (if (empty? f)\n            (recur r res)\n            (recur (concat f r)\n                   res))\n          (recur r (conj res f))\n          )))))","problem":28,"user":"5165a235e4b079ad97ec44ac"},{"problem":28,"code":"(fn my-flatten [col]\n  (cond\n    (empty? col) col\n    (or (seq? (first col)) (vector? (first col))) (concat (my-flatten (first col)) (my-flatten (rest col)))\n    :else (concat [(first col)] (my-flatten (rest col)))\n    )\n  )","user":"6031926ae4b0d5df2af222ac"},{"problem":28,"code":"(fn flat [xs] \n  (reduce \n   #(if (coll? %2)\n     (concat (flat %2) %1)\n      (conj %1 %2)) \n   '() \n   (reverse xs)))","user":"562c0787e4b058fa18c5a6d3"},{"code":"(fn [x] (letfn \n  [(flt [x] (if (sequential? x)\n            (mapcat flt x) (list x)))]\n  (flt x)))","problem":28,"user":"4ec79f99535d6d7199dd36e4"},{"problem":28,"code":"(fn flat [lst]\n  (cond (empty? lst) nil\n        (coll? (first lst)) (concat (flat (first lst))\n            \t\t\t\t\t   (flat (rest lst)))\n    \t:else (concat (list (first lst))\n            \t      (flat (rest lst)))))","user":"53e30fcae4b036ad0777e3fc"},{"code":"(fn f [s] (mapcat #(if (sequential? %) (f %) [%]) s))","problem":28,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":28,"code":"(fn f [x] \n  (if (coll? x)\n    (if (empty? x)\n      '()\n      (concat\n        (f (first x))\n        (f (rest x))\n      )\n    )\n    (list x)\n  ))","user":"5ab1665de4b073f1774425c0"},{"problem":28,"code":"(fn [t]\n  (into ()\n  ((fn flat [x]\n  (loop [l x acc '()]\n    (cond\n     (empty? l) acc\n     (coll? (first l)) (recur (concat (first l) (rest l)) acc)\n     :else (recur (rest l) (conj acc (first l)))))) t) ) )","user":"56588f4ee4b0f9d632dd84b6"},{"problem":28,"code":"(fn helper [xs] (reduce (fn [ys y]\n                            (if (or (seq? y) (vector? y) (list? y))\n                              (concat ys (helper y))\n                              (concat ys [y])))\n                          []\n                          xs))","user":"5c3a896be4b0d62ef62d9f94"},{"problem":28,"code":"(fn f [l] (cond \n           (empty? l) '()\n           (coll? (first l)) (concat (f (first l)) \n                                    (f (rest l)))\n           :else (concat (list (first l)) \n           (f (rest l)))\n))","user":"5e7aba9fe4b085ba37836e0c"},{"code":"(fn [coll]\n    (letfn [(f [coll]\n              (loop [coll coll\n                     answer []]\n                (cond\n                 (nil? coll) answer\n                 (seq? (first coll)) (recur (next coll) (vec (concat (f (first coll)) answer)))\n                 (vector? (first coll)) (recur (next coll) (vec (concat answer (f (first coll)))))\n                 :else (recur (next coll) (conj answer (first coll))))))]\n      (f coll)))","problem":28,"user":"4e89e939535d3e98b8023287"},{"problem":28,"code":"(fn f [s] (apply concat (map #(if (sequential? %) (f %) (list %)) s)))","user":"5d629ed9e4b0c9e5857d501d"},{"code":"#(filter (complement coll?) (tree-seq coll? vec %))","problem":28,"user":"52ce4c32e4b07d0d72b2738d"},{"code":"(fn my-flatten [coll]\r\n  (if (coll? coll)\r\n    (if (seq coll)\r\n      (concat (my-flatten (first coll)) (my-flatten (rest coll)))\r\n      nil)\r\n    (list coll)))","problem":28,"user":"4e7e4a1f535db169f9c7970c"},{"code":"(fn [xs] (filter (complement sequential?) (tree-seq sequential? seq xs)))","problem":28,"user":"4e7f5a0b535db966e863cc41"},{"problem":28,"code":"(fn f [lst]\n  (loop [t [] v lst]\n    (let [el (first v)]\n      (cond\n        (empty? v) t\n        (coll? el) (recur t (concat el (rest v)))\n        :else (recur (conj t el) (rest v))))))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(partial\n(fn foo [v i]\n   (reduce\n     (fn [vv ii] \n       (if (coll? ii)\n           (foo vv ii)\n           (conj vv ii))) v i))\n[])","problem":28,"user":"4ec53f8c535d6d7199dd368b"},{"problem":28,"code":"(fn [arg]\n  (seq (loop [cur (first arg)\n              remain (rest arg)\n              new-list []]\n(cond\n  (coll? cur) (let [new-cur (into [] cur)\n                    new-remain (into [] remain)]\n                (recur (first new-cur) (into (into [] (rest new-cur)) new-remain) new-list)\n                )\n  (empty? remain) (conj new-list cur)\n  :else (recur (first remain) (rest remain) (conj new-list cur))\n  )\n))\n)","user":"5ccaed31e4b0ccb061962877"},{"problem":28,"code":"(fn flatten2 [coll]     (if (empty? coll)\n                            coll\n                          (if (sequential? (first coll)) \n                            (concat (flatten2 (first coll)) (flatten2 (rest coll)))\n                            (cons (first coll) (flatten2 (rest coll))))))","user":"53da8fede4b0e771c30254a3"},{"problem":28,"code":"(fn flat [l] (apply concat (map #(if (or (seq? %) (vector? %)) (flat %) (list %)) l)))","user":"58cfb517e4b03c36ff7e58b9"},{"code":"(fn f [s]\n    (if (coll? s)\n       (mapcat f s)\n       [s]))","problem":28,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn my-flat[alist]\r\n    (if (empty? alist)\r\n\t      '()\r\n\t      (let [first-element (first alist)\r\n\t\t    rest-of-list (rest alist)]\r\n\t\t    (if (sequential? first-element)\r\n\t\t\t(concat (my-flat first-element) (my-flat rest-of-list))\r\n\t\t\t(concat (list first-element) (my-flat rest-of-list))))))","problem":28,"user":"4e53bf5e535d8a8b8723a275"},{"problem":28,"code":"(fn new-flat\n  [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (new-flat l)\n        [l])\n      (when (sequential? r)\n        (new-flat r)))))","user":"550a2c61e4b06e50f9beb12b"},{"problem":28,"code":"(fn flat' [coll]\n  (let [c coll]\n    (if (empty? c)\n      '()\n      (if (coll? (first c))\n        (concat (flat'(first c)) (flat' (rest c)))\n        (cons (first c) (flat' (rest c)))))))","user":"54e1197fe4b024c67c0cf7c0"},{"problem":28,"code":"(fn flatten1 \n  [xs]\n  (if \n    (empty? xs)\n    '()\n    (if \n      (sequential? (first xs))\n      (concat \n       (flatten1 (first xs))\n       (flatten1 (rest xs)))\n      (cons \n       (first xs)\n       (flatten1 (rest xs))))))","user":"55a3ca84e4b0acc240e3153c"},{"problem":28,"code":"(fn flat [xs]\n  (let [[x & ys] xs] \n    (cond \n      (empty? xs) '()\n      (coll? x) (concat (flat x) (flat ys))\n      :else (cons x (flat ys)))))","user":"5e3f291ae4b01d43a70e8e33"},{"code":"(fn code [x]\n  (reduce\n    #(if (sequential? %2)\n        (into %1 (code %2))\n        (conj %1 %2)) [] x))","problem":28,"user":"4fd2529ae4b04c3a95aa041f"},{"problem":28,"code":"#(reduce (fn flatworld [flattened item] \n           (if (coll? item) \n             (reduce flatworld flattened item)\n             (conj flattened item)))\n         []\n         %)","user":"55eaca20e4b0121d4835fdb4"},{"problem":28,"code":"(fn flatten-seq [input]\n  (loop [flat-vec []\n         index 0]\n    (if (= index (count input))\n      flat-vec\n      (do \n        (let [element (nth input index)]\n        (if (coll? element)\n          (recur (into [] (concat flat-vec (flatten-seq element))) (+ index 1))\n          (recur (conj flat-vec element) (+ index 1))))))))","user":"5c196dc3e4b01240ff5671fa"},{"problem":28,"code":"#(sort (let [f (fn as[c v] (if (empty? c)\n                       v\n                       (if (sequential? (first c))\n                       \t\t(as (first c) v)\n                       \t\t(as (rest c) (cons (first c) v)))))]\n   (loop [x % res '()]\n     (if (empty? x)\n       res\n       (recur (rest x) (if (sequential? (first x))\n                         (into (f (first x) '()) res)\n                                   (conj res (first x))))))))","user":"5964c614e4b069c0a1a19770"},{"problem":28,"code":"(fn squish [s] (let [f (first s) r (next s)]\n                 (concat (if (sequential? f)\n                         (squish f)\n                         [f])\n                       (when (sequential? r)\n                         (squish r)))))","user":"560ac5cae4b05f002753df09"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (mapcat\n    (fn [l]\n      (if (sequential? l)\n        (my-flatten l) \n        [l]))\n    coll))","user":"548db64ce4b0e286459a121c"},{"problem":28,"code":"(fn flt [x]\n   (if\n    (coll? x)\n    (if (empty? x)\n      []\n      (concat\n       (flt (first x))\n       (flt (rest x))        \n      )\n    )\n    [x]\n   )\n )","user":"58711e7be4b01531a375e9f9"},{"code":"(fn my-flatten [seqn]\n  (cond (empty? seqn) '()\n        (coll? (first seqn)) (concat (my-flatten (first seqn)) (my-flatten (rest seqn)))\n        :else (cons (first seqn) (my-flatten (rest seqn)))))","problem":28,"user":"50d2f044e4b03c62ef244483"},{"code":"(fn flatten2 [x]\n  (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","problem":28,"user":"5226ef37e4b04e78ff2e1997"},{"code":"(fn fltn [s]\n  (reduce\n    (fn [flattened node]\n      (cond\n        (sequential? node) (concat flattened (fltn node))\n        :default (concat flattened (list node))))\n    ()\n    s))","problem":28,"user":"4f1abbfb535d64f60314646e"},{"code":"(fn [s]\n  (letfn [(flat [s] \n    (cond\n     (empty? s) '()     \n     (or (seq? (first s)) (vector? (first s))) (concat (flat (first s)) (flat (rest s)))\n     :else            (cons (first s) (flat (rest s)))))]\n    (flat s)))","problem":28,"user":"50ce09e6e4b0ffc302be4bc6"},{"problem":28,"code":"#(->> %\n     (tree-seq sequential? vec)\n     rest\n     (filter (complement sequential?)))","user":"54246fcce4b01498b1a71aed"},{"problem":28,"code":"(fn myflatten [x] (if (coll? x) (mapcat myflatten x) [x]))","user":"5f2c94b4e4b033932238a669"},{"problem":28,"code":"#(remove sequential? (rest (tree-seq sequential? seq %1)))","user":"57ed19a3e4b0bfb2137f5b8e"},{"code":"(fn flat-r [x]\n  (seq\n   ((fn do-flat [v x]\n    (reduce (fn flat-rd [v i]\n              (if (sequential? i)\n                (do-flat v i)\n                (conj v i))) v x)) [] x)))","problem":28,"user":"526143b7e4b03e8d9a4a705a"},{"code":"(fn[a-seq] \n  (letfn[\n    (my-flatten[a-seq]\n      (if (empty? a-seq)\n        a-seq\n        (if (not (coll? (first a-seq)))\n          (cons (first a-seq) (my-flatten (rest a-seq)))\n          (concat (my-flatten (first a-seq))\n                  (my-flatten (rest a-seq))))))]\n  (my-flatten a-seq)))","problem":28,"user":"4e58bcd4535d8a8b8723a296"},{"problem":28,"code":"#(filter (complement sequential?) (tree-seq sequential? identity%))","user":"5b6ba7d7e4b0c6492753e7ad"},{"code":"(fn flat [x] (if (coll? x) (reduce #(concat %1 (flat %2)) [] x) [x]))","problem":28,"user":"4ff2430ae4b0678c553fc336"},{"code":"(fn my-f [[h & xs]]\n  (if (nil? h)\n    []\n    (if (coll? h)\n      (into (my-f h) (my-f xs))\n      (into [h] (my-f xs) )       \n    )\n  )\n)","problem":28,"user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn [x]\n\t(if (not-any? coll? x)\n\t\tx\n\t\t(let [lista (reduce concat (map (fn[y] (if (coll? y) y [y]) ) x))]\n\t\t\t(recur lista))))","problem":28,"user":"51794ec2e4b0684c1c981a45"},{"code":"(fn [input] \n  (letfn [(my-flat [aseq]\n          (if ((complement coll?) aseq)\n            (list  aseq)\n            (apply concat (map my-flat aseq))))]\n    (my-flat input)))","problem":28,"user":"5341b141e4b00652c8746ecf"},{"code":"#(filter (comp not sequential?) (tree-seq sequential? identity %))","problem":28,"user":"4f2de7e9e4b0d6649770a061"},{"code":"#(filter (complement sequential?) \n         (rest (tree-seq sequential? seq %)))","problem":28,"user":"4faa7c76e4b081705acca1f5"},{"problem":28,"code":"(fn my-flatten [col]\n  (loop [r col\n         acc []]\n    (let [f (first r)]\n      (if (nil? f)\n        (reverse (into '() acc))\n        (if (coll? f)\n          (recur (rest r) (into acc (my-flatten f)))\n          (recur (rest r) (conj acc f)))))))","user":"5d80f328e4b0915913b1d372"},{"problem":28,"code":"(fn my-flatten [s]\n\n  (let [[first & rest] s] \n    (into \n     (if (coll? first)\n       (my-flatten first)\n       (vector first))\n\n     (if (coll? rest)\n       (my-flatten rest)\n       rest))))","user":"547cd90ee4b0c51c1f4d72ec"},{"code":"(fn flat [s]\n  (cond\n   (nil? s) nil\n   (coll? (first s)) (concat (flat (first s))\n                             (flat (next s)))\n   :else (cons (first s) (flat (next s)))))","problem":28,"user":"4dc21233535d020aff1edf92"},{"code":"#(filter (complement sequential?) \n  (tree-seq sequential? identity %))","problem":28,"user":"507e68abe4b085af06e3afd2"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (sequential? f)  (concat (flat f) (flat r))\n          :else (cons f (flat r)))))","user":"5be909bae4b0f319e2d7ec6d"},{"code":"(fn my-flatten\n  [flat-coll initial-coll]\n  (reduce (fn [res item] \n          (if (sequential? item) \n            (my-flatten res item) \n            (conj res item))) \n          flat-coll\n          initial-coll))\n[]","problem":28,"user":"5038381ce4b0803468ea2c6b"},{"code":"(fn [xs]\n  (letfn [(flattenize [coll]\n    (lazy-seq\n      (when-let [c (seq coll)]\n        (let [x (first c)]\n          (if (sequential? x)\n            (concat (flattenize x) (flattenize (rest c)))\n            (cons x (flattenize (rest c))))))))]\n  (flattenize xs)))","problem":28,"user":"50b9d991e4b04934c218a4a9"},{"code":"(fn flt [l] (if (sequential? l) (mapcat flt l) (list l)))","problem":28,"user":"52b5137de4b0c58976d9ad36"},{"problem":28,"code":"(fn my-flatten\n  [xs]\n  (if (empty? xs)\n    '()\n    (concat (if (coll? (first xs))\n              (my-flatten (first xs))\n              (list (first xs)))\n            (my-flatten (rest xs)))))","user":"5eec1001e4b07c55ae4a0502"},{"problem":28,"code":"(fn f [a] \n  (reduce #(concat % (if (coll? %2) (f %2) (list %2))) '() a)\n  )","user":"5ce3e239e4b0a17bb84e2b46"},{"code":"(fn my-flatten [s]\n  (reduce\n   #(concat % (if (coll? %2) (my-flatten %2) [%2]))\n   [] s))","problem":28,"user":"511d6a01e4b022853b0e07a5"},{"problem":28,"code":"(fn flat [[f & r]]\n  (cond \n   (nil? f) '()\n   (coll? f) (concat (flat f) \n                     (flat r))\n   :else (cons f (flat r))))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn\n   [coll]\n   (letfn [(flat [c] \n                 (lazy-seq\n                  (when-let [co (seq c)]\n                    (let [x (first co)]\n                      (if (sequential? x)\n                        (concat (flat x) (flat (rest co)))\n                        (cons x (flat (rest co))))))))]\n     (if (sequential? coll)\n       (flat coll)\n       coll)))","problem":28,"user":"51ea4e35e4b0f1f103a0d148"},{"problem":28,"code":"#(filter (complement sequential?)\n         (tree-seq\n          sequential?\n          seq\n          %))","user":"602bfcefe4b0d5df2af22268"},{"problem":28,"code":"(fn my-flatten [sequ]\n  (if (empty? sequ) []\n    (if (coll? (first sequ))\n      (concat (my-flatten (first sequ)) (my-flatten (rest sequ)))\n      (cons (first sequ) (my-flatten (rest sequ))))))","user":"5ffee617e4b074f607df6605"},{"code":"(fn flat [l]\n  (if (empty? l)\n    nil\n    (if (sequential? (first l))\n      (concat (flat (first l)) (flat (rest l)))\n      (cons (first l) (flat (rest l))))))","problem":28,"user":"4ea0c284535d7eef308072ad"},{"code":"(fn make-flat [x]\n  (let [f (first x)\n\t\t    r (rest x)]\n\t\t  (cond\n\t\t  \t(empty? x) ()\n\t\t  \t(coll? f) (concat (make-flat f) (make-flat r))\n\t\t  \t(not (coll? f)) (cons f (make-flat r)))))","problem":28,"user":"4f726dd2e4b07046d9f4f034"},{"code":"(fn flt [ls] (if (or (vector? ls) (seq? ls)) (mapcat flt ls) [ls]))","problem":28,"user":"504db141e4b021508a333965"},{"problem":28,"code":"(fn flat [xs]\n  (let [l (first xs)\n        ls (rest xs)]\n      (cond (empty? xs) nil\n            (sequential? l) (concat (flat l) (flat ls))\n            :else (cons l (flat ls)))))","user":"60228147e4b0d5df2af22202"},{"code":"#((fn flat [a b]\n  (concat a (if (sequential? b)\n              (if (some sequential? b)\n                  (flat () (reduce (fn [x y] (if (sequential? y) (concat x y) (concat x (list y)) )) () b))\n                  (if (sequential? b) b (list b)))\n              (list b)))) () %)","problem":28,"user":"4e58ef07535d8a8b8723a299"},{"code":"(fn my-flatten [input]\n  (loop [sqnc input, result (vector)]\n    (if (sequential? sqnc)\n      (if (empty? sqnc)\n        result\n        (recur (rest sqnc) (concat result (my-flatten (first sqnc)))))\n      (list sqnc))))","problem":28,"user":"528bba38e4b0239c8a67aea9"},{"code":"(fn foo [x]\n  (if (not (coll? x)) (list x) (if (empty? x) '() (concat (foo (first x)) (foo (rest x))))))","problem":28,"user":"4f8b20fce4b02e764a0a5178"},{"problem":28,"code":"(fn flatton [coll] \n  (reduce \n   (fn [a b] (if (sequential? b)\n      (vec (concat a (flatton b)))\n      (conj a b)))\n   []\n   coll))","user":"56677192e4b04acd4f672dd5"},{"problem":28,"code":"(fn my-flatten [l]\n  (reduce (fn [a b]\n            (concat a\n                    (if (coll? b)\n                      (my-flatten b)\n                      (conj (list) b))))\n          '()\n          l))","user":"5db4ba2fe4b010eb3c36cd2b"},{"code":"(fn [ss]\n    (reverse ((fn f [s r]\n        (if-let [h (first s)]\n            (if-not (coll? h)\n                (f (rest s) (conj r h))\n                (f (rest s) (f (first s) r)))\n            r\n        )\n    ) ss '()))\n)","problem":28,"user":"536f5900e4b0fc7073fd6e7b"},{"code":"(fn f [xs] (reduce (fn [xs el] (if (coll? el) (concat xs (f el)) (concat xs [el]))) [] xs))","problem":28,"user":"50ee851ee4b06330c1f87c5b"},{"code":"(fn my-flatten2 [x] (filter (complement sequential?)\n                            (rest (tree-seq sequential? seq x))))","problem":28,"user":"5296aa9be4b02ebb4ef75034"},{"problem":28,"code":"(fn\n  [s]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","user":"51ae5571e4b09397d5109792"},{"code":"#(filter (fn [x] (not (coll? x))) (tree-seq coll? identity %))","problem":28,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn myflatten [xs]   \n         (if (seq xs)\n         (let [h (first xs) t (rest xs)]\n            (if (coll? h) (concat (myflatten h) (myflatten t))\n                         (concat [h] (myflatten t))))\n          []))","problem":28,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn [s] \n  (filter #(not (sequential? %))\n    (tree-seq sequential? seq s)))","problem":28,"user":"4e7e032b535db169f9c796fc"},{"code":"(fn [a]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq a))))","problem":28,"user":"50c9ece0e4b0a409464667d8"},{"problem":28,"code":"(fn [s]\n   ((fn f [memo s]\n      (reduce\n       (fn [res y]\n         (concat res (if (coll? y) (f [] y) (list y))))\n       memo s)) '() s))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":28,"code":"(fn make-flat [xs]\n  (if (empty? xs)\n    '()\n    (let [[x & ys] xs]\n      (if (sequential? x)\n        (concat (make-flat x) (make-flat ys))\n        (conj (make-flat ys) x)))))","user":"56339e23e4b0bfe05bf117b1"},{"problem":28,"code":"(fn fc28 ([s] (fc28 s []))\n  ([s flat] (loop [sq s\n                   result flat]\n              ;(prn sq)\n              (let [item1 (first sq)]\n               ; (prn (str item1 \" -- seq?: \" (sequential? item1)))\n                (if (seq sq)\n                  (recur (rest sq) (if-not (sequential? item1)\n                                        ;((prn (str \"not-sequential: \" (first sq)))\n                                     (conj result item1);)\n                                     (fc28 item1 result)))\n                  result)))))","user":"56fc9a2de4b08d47c977819b"},{"problem":28,"code":"(fn flat [coll]\n  (mapcat\n    #(if (sequential? %) (flat %) [%]) coll))","user":"5475d755e4b0c51c1f4d72a0"},{"problem":28,"code":"reduce \n\t(fn myflat [a, b] \n      (if (coll? b) \n        (reduce myflat a b) \n        (concat a [b]))\n      ) \n    '()","user":"5a1dda7de4b0ff51aa4b3261"},{"problem":28,"code":"(fn % [coll]\n  (if (sequential? coll)\n    (apply concat (map % coll))\n    (list coll)))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn fl [xs]\n  (mapcat #(if (sequential? %) (fl %) (list %)) xs))","problem":28,"user":"4e243bcb535d04ed9115e825"},{"code":"(fn flat [seq]\n  (reduce (fn [seq item]\n            (if (not (coll? item))\n                (concat seq (list item))\n                (concat seq (flat item))))\n          '()\n          seq))","problem":28,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"reduce (fn flt[c e] (if (coll? e) (reduce flt c e) (conj c e))) []","problem":28,"user":"52f53589e4b05e3f0be25f2c"},{"code":"#(letfn [(parse [l] (if-let [[h & t] (seq l)]                                                                                                                                                           \n                                      (if (sequential? h) (concat (parse h) (parse t)) (cons h (lazy-seq (parse t))))))]                                                                                        \n               (parse %))","problem":28,"user":"52265e41e4b04e78ff2e1981"},{"code":"(fn platta [sek]\n  (loop [sek (seq sek) platt nil]\n  (cond\n\t(= sek nil) (remove #(= % nil) (reverse platt)) \n\t(= (coll? (first sek)) false) (recur (next sek) (cons (first sek) platt))\n\t(= (coll? (first (first sek))) false) (recur\t\t\t\t       \n\t\t\t\t\t       (cons (first (first sek))\n\t\t\t\t\t\t     (cons (next (first sek))\n\t\t\t\t\t\t\t   (next sek)))\n\t\t\t\t\t       platt)\n\t:else (recur (conj (next sek) (platta (first sek))) platt ))\n\t))","problem":28,"user":"4e218464535d04ed9115e816"},{"code":"#( filter (complement sequential?) (rest ( tree-seq sequential? seq %)))","problem":28,"user":"52628bb0e4b03e8d9a4a7089"},{"problem":28,"code":"(fn fltn [s]\n  (cond\n    (nil? s) '()\n    (sequential? s) (concat (fltn (first s)) (fltn (next s)))\n    :else [s]))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn $ [l] (if (or (seq? l) (vector? l) (list? l)) (mapcat $ l) [l]))","problem":28,"user":"53712c03e4b0fc7073fd6ea9"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq %) ) )","problem":28,"user":"4e8da0bf535d65386fec2138"},{"code":"(fn flat [x] (reverse (reduce #(if (coll? %2) (into %1 (flat %2)) (conj %1 %2) ) '() x)))","problem":28,"user":"539c9e26e4b0b51d73faaf2e"},{"problem":28,"code":"(fn flattener [poofy] (reduce (fn [acc item]\n                                 (let [to-add (if (sequential? item)\n                                                (flattener item)\n                                                [item])]\n                                   (concat acc to-add)))\n                               [] poofy))","user":"5baa5f53e4b0a20761a23459"},{"problem":28,"code":"(fn [s]\n  (loop [acc [] lis s]\n    (if (empty? lis)\n      acc\n      (let [f (first lis)\n            r (rest lis)]\n        (if (coll? f)\n          (recur acc (concat f r))\n          (recur (conj acc f) r))))))","user":"5f597522e4b0a0bc16850a9e"},{"problem":28,"code":"(fn [x]\n  (let [f-rec (fn [rem res]\n                (if (empty? rem)\n                  (reverse res)\n                  (let [head (first rem)]\n                    (if (coll? head)\n                      (recur (concat head (rest rem)) res)\n                      (recur (rest rem) (conj res head))))\n                  )\n                )\n        ]\n    (f-rec x '()))\n\n  )","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":28,"code":"(fn flatten2 [x]\n  (cond\n    (= x ()) '()\n    (sequential? x) (concat (flatten2 (first x)) (flatten2 (rest x)))\n    :else (list x)))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn ! [x]  (if (empty? x)   '()   (if  (sequential? (first x))    (concat   (! (first x))  (! (rest x)))    (concat  [(first x)]  (! (rest x)))  )))","problem":28,"user":"52faec2ee4b047fd55837004"},{"problem":28,"code":"(fn flatt [f & tail]\n   (concat \n                          (if (sequential? f) (apply flatt f) (list f))\n                          (if (nil? tail) nil (apply flatt tail)))\n)","user":"550fd845e4b06e50f9beb17c"},{"code":"(fn [l] (filter #(not (sequential? %)) (rest (tree-seq sequential? seq l))))","problem":28,"user":"4f017593535dcb61093f6a36"},{"problem":28,"code":"(fn flat [lst]\n  (if (coll? lst)\n    (mapcat flat lst)\n    (list lst)))","user":"5a99b863e4b0d174b936c7ae"},{"code":"#(filter (fn[x](not (coll? x))) (tree-seq coll? identity (concat %)))","problem":28,"user":"4ed2dd98535d44c135fd68e2"},{"code":"(fn toto [in]\n  (let [makelist #(if (coll? %) % (list %))\n        check #(reduce (fn [x y] (and x y)) (map (fn [something] (false? (coll? something))) %))]\n    (if (check in)\n      in\n      (toto (reduce concat (map makelist in))))))","problem":28,"user":"5186571de4b0da5a5be3bad1"},{"problem":28,"code":"(fn myflatten [x] \n  (if (first x)\n    (if (sequential? (first x))\n      (concat (myflatten (first x)) (myflatten (rest x)))\n      (cons (first x) (myflatten (rest x)))\n    )\n    x\n  )\n)","user":"5480e5a1e4b0e286459a1162"},{"problem":28,"code":"(fn testing\n  [list]\n  (if (sequential? list)\n    (mapcat testing list)\n    [list]\n    ))","user":"560d7863e4b05f002753df40"},{"problem":28,"code":"#((fn f [l]\n\t       \t(cond\n\t       \t\t(empty? l) () \n\t       \t\t(sequential? (first l)) (concat (f (first l)) (f (rest l)) )\n\t       \t\t:else (cons (first l) (f (rest l)))\n\t       \t))\n\t\t%\n\t \t)","user":"5bbbd484e4b0a20761a23617"},{"code":"(fn make-flat [l]\n  (lazy-seq\n   (when-let [[x & xs] (seq l)]\n     (if (sequential? x) \n       (concat (make-flat x) (make-flat xs))\n       (cons x (make-flat xs))))))","problem":28,"user":"4f4319ebe4b0d7d3c9f3fd13"},{"problem":28,"code":"(fn flat [xs]\n  (reduce\n   (fn [coll x]\n     (if (coll? x)\n       (vec (concat coll (flat x)))\n       (conj coll x)))\n   []\n   xs))","user":"5b500215e4b02d533a91bce2"},{"code":"(fn flat \n  ([xs] (flat [] xs))\n  ([result [x & xs]]\n    (if (nil? x)\n      result\n      (if (sequential? x)\n        (recur (reduce conj result (flat [] x)) xs)\n        (recur (conj result x) xs)))))","problem":28,"user":"5079fd71e4b08327cd804a66"},{"problem":28,"code":"(fn ex [c] (mapcat #(if (not (coll? %)) (list %) (ex %)) c))","user":"5635adeee4b0bfe05bf117c7"},{"code":"(fn fltr [seq]\r\n    (reduce (fn [acc item]\r\n        (concat  acc \r\n            (if (sequential? item) \r\n                (fltr item) \r\n                (list item))))\r\n        '() seq))","problem":28,"user":"4e2f9e71535deb9a81d77f11"},{"problem":28,"code":"(fn flitten [s]\n  (loop [ss s r []]\n    (if (not-empty ss)\n      (if (sequential? (first ss))\n         (recur (rest ss) (concat r (flitten (first ss))))\n         (recur (rest ss) (conj r (first ss))))\n      (sort r))))","user":"5dcd7933e4b0b296f82db5ae"},{"problem":28,"code":"(fn flatten-recur\n  ([the-sequence] (flatten-recur the-sequence []))\n  ([input-sequence output-sequence] (if (empty? input-sequence) output-sequence (let [the-first (first input-sequence)] (flatten-recur (rest input-sequence) (if (sequential? the-first) (apply conj output-sequence (flatten-recur the-first)) (conj output-sequence the-first))))))\n)","user":"57b356c2e4b0fbc9809a277b"},{"code":"#(filter (complement sequential?)\r\n  (tree-seq sequential? seq %))","problem":28,"user":"4dea9406535d08e6dec9fe01"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (empty? x) \n    x \n    (if (or (seq? (first x)) (vector? (first x)))\n      (concat (my-flatten (first x)) (my-flatten (rest x))) \n      (conj (my-flatten (seq (rest x))) (first x)))))","user":"5a621702e4b0512ff01cd983"},{"problem":28,"code":"(fn flattn [coll]\n  (reduce (fn [acc val] (concat acc (if (sequential? val) (flattn val) [val]))) [] coll))","user":"50504a1de4b0a02f9cffdeb9"},{"problem":28,"code":"(fn my-flatten [s] \n   (reduce #(concat %1 (if (sequential? %2) (my-flatten %2) [%2]) ) '() s)\n )","user":"59a2ba97e4b066c664927d2c"},{"code":"( fn[x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x)))\n)","problem":28,"user":"4ffd92e7e4b0678c553fc3e3"},{"problem":28,"code":"#(filter (complement sequential?)\n                   (rest (tree-seq sequential? seq %)))","user":"54258a7fe4b01498b1a71b0c"},{"problem":28,"code":"(fn flt [coll]\n  (loop [coll coll\n         res []]\n    (do (println coll res)\n    (if (empty? coll)\n      res\n      (let [[x & xs] coll]\n        (if (coll? x)\n          (recur xs (into res (flt x)))\n          (recur xs (conj res x))))))))","user":"54af500fe4b09f271ff37d06"},{"problem":28,"code":"(fn moo [x]\n  (if (sequential? x)\n    (mapcat moo x)\n    (list x)))","user":"5974b12be4b01722bebd4cb1"},{"problem":28,"code":"(fn flat [s]\n  (cond\n    (empty? s) \n        '()\n    (or (seq? (first s)) (vector? (first s))) \n        (concat (flat (first s)) (flat (rest s)))\n    :else (cons (first s) (flat (rest s)))\n  )\n)","user":"51ad808ee4b09397d5109784"},{"code":"(fn flattn [x]\n  (if (sequential? x)\n    (mapcat flattn x)\n    [x]))","problem":28,"user":"534bde26e4b084c2834f4a81"},{"code":"(fn fla [x] \n\t(lazy-seq\n\t\t(when-let [c (seq x)]\n\t\t\t(let [y (first c)]\n\t\t\t\t(if (sequential? y) (concat (fla y) (fla (rest c)))\n\t\t\t\t\t (cons y (fla (rest c))))))))","problem":28,"user":"52b79d8ee4b0c58976d9ad50"},{"code":"(partial (fn [acc x] \n    (if (empty? x)\n      acc\n      (let [f (first x)]\n        (if (sequential? f)\n          (recur acc (concat f (rest x)))\n          (recur (conj acc f) (rest x)))))) [])","problem":28,"user":"4f515bd3e4b03ad3f0c10d1f"},{"code":"(fn flat1 [col]\r\n(lazy-seq\r\n (when-let [x (seq col)]\r\n  (let [elem (first x)]\r\n    (if (sequential? elem)\r\n      (concat (flat1 elem) (flat1 (rest x)))\r\n      (cons elem (flat1 (rest x))))))))","problem":28,"user":"5060c117e4b024449d699b5d"},{"code":"(fn flat\n  [output [e & tail]]\n  (if e\n    (if (coll? e)\n      (recur (flat output e) tail)\n      (recur (conj output e) tail))\n    output))\n[]","problem":28,"user":"4f608f0ee4b0defedf855faa"},{"problem":28,"code":"(fn f [l] \n  (mapcat #(if (coll? %) (f %) [%]) l))","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn fla [coll]\n  (if (sequential? coll)\n    (mapcat fla coll)\n    (list coll)))","problem":28,"user":"4eae5fe4535d7eef30807325"},{"problem":28,"code":"(fn prob28\n  [coll]\n  ;; this solution is user \"goaranger\"'s, which is more concise than mine\n  (letfn [(flat [x]\n            (if (coll? x)\n              (mapcat flat x)\n              (list x)))]\n    (mapcat flat coll)))","user":"5d2e5065e4b01671435dbcae"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x)\n    (mapcat flat x)\n    [x]\n    ))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":28,"code":"(fn fl [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (fl (first s)) (fl (rest s)))\n        (cons (first s) (fl (rest s)))))))","user":"605f5c69e4b03746e80ebf5e"},{"problem":28,"code":"(fn fltn [coll]\n  (reduce #(if (sequential? %2)\n             (concat %1 (fltn %2))\n             (concat %1 [%2]))\n          () coll))","user":"54cc4156e4b057c6fda3a28c"},{"problem":28,"code":"(fn [a] (apply (fn flat [[x & xs] acc]\n  (if(nil? x)\n    acc\n    (if (coll? x)\n      (recur (concat x xs) acc)\n      (recur xs (conj acc x))\n    )\n   )\n  ) [a []]))","user":"55f01316e4b06e875b46ce1a"},{"problem":28,"code":"#(reverse ((fn f [r h] ( \n     if (sequential? h)\n       (reduce f r h)\n       (cons h r)\n   )\n ) '() %))","user":"55645592e4b0c656e3ff1802"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (sequential? s) (if (empty? s) '() (concat (my-flatten (first s)) (my-flatten (rest s)))) (list s)))","user":"52ce1abfe4b07d0d72b27389"},{"problem":28,"code":"(fn [coll]\n  (loop [acc   []\n         coll  coll]\n    (if-let [[x & xs] coll]\n      (if (coll? x)\n        (recur acc (concat x xs))\n        (recur (conj acc x) xs))\n      acc)))","user":"544e5b22e4b0e39780006983"},{"problem":28,"code":"(fn my-flatten [s]\n  (cond \n    (empty? s) s\n    (sequential? (first s)) (recur (concat (first s) (rest s)))\n    :else (cons (first s) (my-flatten (rest s)))))","user":"5f5b624de4b05ea7b9adc42f"},{"code":"(fn [& col]\n         (loop [xcol col all []]\n           (if (first xcol)\n             (if (coll? (first xcol))\n               (recur (concat (first xcol) (rest xcol)) all)\n               (recur (rest xcol) (conj all (first xcol)))\n               ) all)))","problem":28,"user":"4f1427f8535d64f603146435"},{"problem":28,"code":"(fn [c]\n   (reduce (fn f [x y]\n             (if (coll? y)\n               (reduce f x y)\n               (conj x y))) [] c))","user":"591f5124e4b09b4ee5954c45"},{"problem":28,"code":"(fn [col] (filter (complement sequential?)\n                  (rest (tree-seq sequential? seq col))))","user":"53b05a75e4b047364c044482"},{"code":"(fn my-flatten [col]\n  (if (empty? col)\n    col\t      \n    (if (sequential? (first col))\n      (concat (my-flatten (first col)) (my-flatten (rest col)))\n      (cons (first col) (my-flatten (rest col))))))\n\n\n;;((fn [s]\n  ;;(filter (complement sequential?)\n;;;(tree-seq sequential? seq s))) '((1 2) 3 [4 [5 6]]))","problem":28,"user":"5016ac54e4b052339a490e7b"},{"problem":28,"code":"(fn flatten-me [args] (if (sequential? args) (mapcat flatten-me args) (list args)))","user":"55b4b0f5e4b01b9910ae297d"},{"code":"(fn fltn [coll]\n  (let [fst (first coll) rst (next coll)]\n    (concat\n     (if (sequential? fst)\n       (fltn fst)\n       [fst])\n     (when (sequential? rst)\n       (fltn rst)))))","problem":28,"user":"5290257ae4b0239c8a67af03"},{"problem":28,"code":"(fn new-flatten [x] (loop [[h & t] x acc []]\n                        (let [newacc (if (sequential? h) (into acc (new-flatten h))\n                            (conj acc h))] \n       (if (= t nil) newacc (recur t newacc)))))","user":"58152157e4b0f478707a0631"},{"problem":28,"code":"(fn f [x] (if (coll? x) (mapcat f x) [x]))\n\n#_((fn f\n  \t[m, v]\n  \t(if (coll? v)\n      (reduce f m v)\n      (conj m v)\n  \t)\n  )\n  []\n  %\n)\n\n#_(reverse ((fn f\n  \t[m, v]\n  \t(if (coll? v)\n      (reduce f m v)\n      (cons v m)\n  \t)\n  )\n  '()\n  %\n  )\n)","user":"57ba55c1e4b0fbc9809a2801"},{"problem":28,"code":"reduce \n  (fn fuckyou\n    [x y]\n    (if (coll? y) \n      (reduce fuckyou x y)\n      (conj x y)\n      )\n    )\n  []","user":"57dd3ae3e4b0bd073c20243d"},{"problem":28,"code":"(fn flat [coll] \n  (reduce (fn [acc v] (if (coll? v) (into acc (flat v)) (conj acc v))) \n          [] \n          coll))","user":"5f6796d2e4b02876ed9fd036"},{"problem":28,"code":"#(->>(tree-seq sequential? seq %)\n     (filter (complement sequential?)))","user":"60c558e9e4b0e0fa5f1b42ce"},{"code":"reduce (fn fl[v x] (if (sequential? x)\n  \t\t(reduce fl v x)\n\t\t\t(conj v x))) []","problem":28,"user":"50668a06e4b03d366d7cb2b2"},{"problem":28,"code":"(fn flatten- [x]\n  (cond\n    (empty? x) x\n    (coll? (first x)) (concat (flatten- (first x)) (flatten- (rest x)))\n    :else (conj  (flatten- (rest x)) (first x))\n    ))","user":"57029859e4b08d47c97781e4"},{"code":"(fn my-flatten [xs] (reduce #(if (sequential? %2) (into %1 (my-flatten %2)) (conj %1 %2)) [] xs))","problem":28,"user":"513d121fe4b0e544971636a2"},{"problem":28,"code":"(fn [items] \n  (filter (complement sequential?) (rest (tree-seq sequential? seq items))))","user":"56020b3fe4b04bb52996e19b"},{"problem":28,"code":"(fn [coll]\n  (reverse ((fn h [acc c]\n             (let [car (first c)\n                   cdr (rest c)]\n               (cond\n                 (nil? car) acc\n                 (coll? car) (h (h acc car) cdr)\n                 :else (h (cons car acc) cdr)))) '() coll)))","user":"5e976fa8e4b0157ca96647cf"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq coll))))","user":"5c92105ce4b048ec896c59f7"},{"problem":28,"code":"(fn flatten-structure [s] (if (sequential? s) (if (empty? s) '() (concat (flatten-structure (first s)) (flatten-structure (rest s)))) \n                              (list s)))","user":"5654e024e4b0f9d632dd848d"},{"code":"#(filter (fn [x] (not (coll? x))) (tree-seq coll? identity  %1))","problem":28,"user":"4ddc56e1535d02782fcbea04"},{"code":"(fn [v] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq v))))","problem":28,"user":"4e31c695535deb9a81d77f20"},{"problem":28,"code":"(fn [s]\n  (filter\n   (complement sequential?)\n   (seq(tree-seq sequential? seq s)) ))","user":"5e078ba7e4b0978307768fb6"},{"problem":28,"code":"(fn [x]\n  (let [result (atom [])\n        swap-fn (fn [item]\n                  (if (not (coll? item))\n                    (swap! result #(conj % item))) item)]\n    (clojure.walk/prewalk swap-fn x)\n    @result))","user":"55cb11e9e4b0e31453f649ff"},{"code":"(fn fltn [[x & xs]]\n  (concat\n    (if (coll? x)\n      (fltn x)\n      (list x))\n    (if (nil? xs)\n      '()\n      (fltn xs))))","problem":28,"user":"4f7f0827e4b06e829148e1d5"},{"code":"(fn fl [seq]\n  (mapcat #(if (coll? %)\n    (fl %)\n    (list %)) seq))","problem":28,"user":"4ef0f1a1535dced4c769f212"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flt l)\n          [l])\n            (when (sequential? r)\n            (flt r)))))","problem":28,"user":"4f4be1cae4b03ad3f0c10c81"},{"problem":28,"code":"(fn flat*\n  [xs]\n  (reduce \n    (fn [acc cur] \n      (if (coll? cur) \n        (concat acc (flat* cur)) \n        (concat acc (cons cur ()))  )) \n    '() \n    xs))","user":"5e4fae60e4b027a2e10ac0b9"},{"code":"(fn flat [l]\n  (if (sequential? l)\n    (if (empty? l)\n      l \n      (concat (flat (first l)) (flat (rest l))))\n    (list l)))","problem":28,"user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn fltn [coll]\n    (if (empty? coll)\n       '()\n       (let [ft (first coll) rt (rest coll)]\n         (if (coll? ft)\n     (concat (fltn ft) (fltn rt))\n\t   (cons ft (fltn rt)))\n       )))","problem":28,"user":"4fff57f1e4b0678c553fc3fe"},{"problem":28,"code":"(fn myflatten\n  ([coll]\n    (myflatten coll []))\n  ([coll res]\n    (loop [c coll r res]\n      (do\n        (if (empty? c)\n          r\n          (if (coll? (first c))\n            (recur (rest c) (myflatten (first c) r))\n            (recur (rest c) (conj r (first c)))))))))","user":"5f088bb3e4b0cf489e8d7f5f"},{"problem":28,"code":"(fn flatten-sequence\n  [ip-seq]\n  (reduce\n   (fn flatten-coll [acc curr]\n     (if (coll? curr)\n       (reduce flatten-coll acc curr)\n       (conj acc curr)))\n   []\n   ip-seq))","user":"5d8c8175e4b0915913b1d3e1"},{"problem":28,"code":"(fn sec [s]\n  (reduce (fn myflatten [col e]\n            (if (sequential? e)\n              (reduce myflatten col e)\n              (conj col e))) [] s))","user":"607dd962e4b03d835a6eaed2"},{"code":"(fn flatten- [x]\n  (filter (complement sequential?)\n          (rest (tree-seq coll? seq x))))","problem":28,"user":"4ef9b021535dced4c769f269"},{"problem":28,"code":"(fn flatt[acc x]\n  (if (empty? x)\n    acc\n    (if (sequential? (first x))\n      (flatt (apply conj acc (flatt [] (first x))) (rest x))\n      (flatt (conj acc (first x)) (rest x)))))\n[]","user":"55429859e4b0a04f7929951f"},{"problem":28,"code":"#(filter\n  (complement sequential?)\n  (rest\n   (tree-seq sequential? seq%)))","user":"6085edade4b0736b099e42fc"},{"code":"#((fn [p r n]\n     (cond\n        (and (nil? p) (empty? r)) n\n        (and (not (nil? p)) (not (sequential? p))) (recur (first r) (rest r) (conj n p))\n        (and (not (empty? p)) (sequential? p)) (recur (first p) (cons (rest p) r) n)\n        :else (recur (first r) (rest r) n)\n        )\n     ) (first %) (rest %) [])","problem":28,"user":"4f031773535dcb61093f6a5c"},{"code":"(fn my-flat [s]\n  (if (coll? s)\n    (apply concat (map my-flat s))\n    [s]))","problem":28,"user":"51460e4ce4b04ef915e37314"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll)\n        r (next coll)]\n    (concat\n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n         (flt r)))))","user":"54eb22a0e4b024c67c0cf845"},{"problem":28,"code":"(fn a [b] \n  (reduce concat\n          (for [x b]\n            (if (coll? x) (a x) (list x)))))","user":"5fa96ddbe4b0fa27300f3dec"},{"code":"(fn fonc [l]\n  (if (= l ())\n    ()\n    (if (sequential? (first l))\n    (concat (fonc (first l)) (fonc (rest l)))\n    (cons          (first l)  (fonc (rest l))))))","problem":28,"user":"4f69f34fe4b07046d9f4ef90"},{"problem":28,"code":"(fn func[coll]\n  (let [i (first coll), c (next coll)]\n    (concat\n    \t(if (sequential? i)\n      \t\t(func i)\n      \t\t[i])\n    \t(when (sequential? c)\n      \t\t(func c)))))","user":"559c4236e4b066d22e731f67"},{"code":"(fn [ns] \r\n  (loop [ns ns\r\n         a []]\r\n    (if (first ns)\r\n      (if (sequential? (first ns)) \r\n        (recur (next ns) (into a (first ns)))\r\n        (recur (next ns) (conj a (first ns))))\r\n      (if (some sequential? a)\r\n        (recur a [])\r\n        a))))","problem":28,"user":"4e970e6a535dbda64a6f6b4e"},{"problem":28,"code":"#(loop [coll %]\n    (let [flat-once\n          (reduce\n           (fn [a b] (if (coll? b)\n                       (concat a b)\n                       (conj (vec a ) b)))\n           []\n           coll)]\n      (if (pos? (count (filter coll? flat-once)))\n        (recur (vec flat-once))\n        flat-once)))","user":"5b9783dae4b0c0b3ffbd4a93"},{"problem":28,"code":"(fn flat [[first-ele & rest-ele]]\n  (concat\n    (if (coll? first-ele) (flat first-ele) (list first-ele))\n    (if-not (empty? rest-ele) (flat rest-ele) rest-ele)))","user":"5a59a76fe4b05d388ecb6c98"},{"problem":28,"code":"(fn flat [xs]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq xs))))","user":"5776903ee4b0979f8965163b"},{"problem":28,"code":"(fn fl [c] (cond (empty? c) '() (coll? (first c)) (concat (fl (first c)) (fl (rest c))) :else (cons (first c) (fl (rest c)))))","user":"56800ba1e4b0966858e4d8e8"},{"problem":28,"code":"(fn flatn [coll]\n  (if (empty? coll)\n    coll\n\n    (if (sequential? (first coll))\n    (concat (flatn (first coll)) (flatn (rest coll)))\n    (cons          (first coll)  (flatn (rest coll))))))","user":"54a98ed4e4b09f271ff37caf"},{"problem":28,"code":"(fn f [x]\n  (if (coll? x)            ;; does what I tried with (or (seq? x) (list? x))\n    (mapcat f x)           ;; does what I tried with (reduce concat ...)\n    [x]))\n\n;; Original attempt\n;; (fn f [x]\n;;  (if (or (seq? x) (vector? x))\n;;    (reduce concat (map f x))\n;;    [x]))","user":"55702081e4b09a3098a52529"},{"problem":28,"code":"(fn  [x] (loop [l1 x l2 '()] (cond (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2) (empty? l1) (reverse l2) :else (recur (rest l1) (cons (first l1) l2)) ) ))","user":"5f32f69ae4b0574c87022c35"},{"code":"(fn flats [arg] (if (sequential? arg) (mapcat flats arg) [arg]))","problem":28,"user":"4fac1d77e4b081705acca223"},{"code":"(fn flt [o] (let [l (first o) r (next o)] (concat (if (sequential? l) (flt l) [l]) (if (sequential? r) (flt r)))))","problem":28,"user":"51fa852ee4b0f1313d4689dd"},{"code":"(fn [x]\n (filter (complement sequential?) \n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"501d52a8e4b066e56b9d0b20"},{"problem":28,"code":"(fn flt [sq]\n  (if (coll? sq)\n    (if (empty? sq)\n      []\n      (concat (flt (first sq)) (flt (rest sq))))\n    [sq]))","user":"56795625e4b05957ce8c6186"},{"problem":28,"code":"(fn my-flat[coll]\n  (if (sequential? coll)\n    (mapcat my-flat coll)\n    [coll]))","user":"565b371fe4b068f2fe63dbff"},{"problem":28,"code":"(fn flattener\n  ([xs]\n   (flattener xs []))\n  ([xs res]\n   (if (empty? xs)\n     res\n     (let [fst (first xs)]\n       (if (coll? fst)\n         (flattener (rest xs) (flattener fst res))\n         (flattener (rest xs) (conj res fst)))))))","user":"5ae429fae4b0837691e92c79"},{"problem":28,"code":"(fn [xs]\n  (reverse\n  (loop [in xs\n         out '()]\n    (if\n      (nil? (first in))\n      out\n      (if\n        (coll? (first in))\n        (recur (concat (first in) (rest in)) out)\n        (recur (rest in) (conj out (first in))))))))","user":"5a584ca2e4b05d388ecb6c7d"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn fl [e1 e2]\n      (if (coll? e2)\n        (reduce fl e1 e2)\n        (conj e1 e2)))\n    [] coll)))","user":"55ff562fe4b00f4cabc57660"},{"problem":28,"code":"(fn my-flatten [coll]\n  (loop [[e & r] coll\n         ret []]\n    (cond (sequential? e)\n          (recur r (apply (partial conj ret) (my-flatten e)))\n          (not (nil? e))\n          (recur r (conj ret e))\n          true\n          ret)))","user":"577832f4e4b0979f8965165b"},{"code":"(fn fun [x]\n  (let [f (first x) r (rest x)]\n  (cond \n   (nil? (seq x)) '()\n   (sequential? f) (concat (fun f) (fun r)) \n   :else (cons f (fun r)) \n   \n    )))","problem":28,"user":"5349da55e4b084c2834f4a68"},{"problem":28,"code":"(fn _flatten [col]\n  \n  (loop [result '() col  col ]\n  (let [x (first col)]\n  (cond\n        (empty? col) result;cant deal with nil vals\n        (sequential? x) (recur (concat result (_flatten x)) (rest col))\n        :else  (recur (concat result (list x)) (rest col))\n     )\n  );let\n  );loop\n)","user":"547b4ec6e4b0c51c1f4d72d5"},{"problem":28,"code":"(fn flatten2 [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond\n      (empty? s) nil\n      ((complement sequential?) f) (cons f (flatten2 r))\n      :else (concat (flatten2 f) (flatten2 r)))))","user":"563f4c47e4b08d4f616f5ed2"},{"code":"(fn flat [coll]\n  (->> coll\n    (map #(if (coll? %) (flat %) [%]))\n    (reduce concat)))","problem":28,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":28,"code":"(fn [i]\n  (let [g (fn f\n             [a r]\n             (if (coll? r)\n               (reduce f a (seq r))\n               (conj a r)\n             )\n           )\n        ]\n    (reduce g [] i)\n  )\n)","user":"593f8692e4b069cdc2982be1"},{"problem":28,"code":"(fn fltn [ns]\n  (letfn [(reducer [acc n]\n            (if (sequential? n)\n              (concat acc (fltn n))\n              (concat acc (list n))))]\n    (reduce reducer () ns)))","user":"5d28d935e4b092dab7f59c88"},{"problem":28,"code":"(fn my-flatten [s]\n  (reduce (fn [result head] (concat result\n                              (if (sequential? head)\n                                (my-flatten head)\n                                [head])))\n          [] s))","user":"563f1493e4b08d4f616f5ecf"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst) lst\n    (coll? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (cons (first lst) (my-flatten (rest lst)))))","user":"59dfd369e4b08badc2a0c4dd"},{"code":"(fn my-flatten [col]\n        (loop [col col\n               new-col []]\n          (if (empty? col)\n            new-col\n            (recur (rest col)\n                   (if (not (sequential? (first col)))\n                     (conj new-col (first col))\n                     (apply conj new-col (my-flatten (first col))))))))","problem":28,"user":"5369d072e4b0243289761ea1"},{"code":"(fn fltn [x] (apply concat (map #(if (sequential? %) (fltn %) [%]) x)))","problem":28,"user":"5150600de4b098b221effc29"},{"problem":28,"code":"(fn my-flatten [col]  \n  (if (coll? col)    \n    (mapcat my-flatten col)\n    [col]))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":28,"code":"(fn flatseq [s] \n  (if (coll? s) \n    (mapcat flatseq s) \n    [s]) )","user":"54de7948e4b024c67c0cf7a4"},{"code":"(fn walk [x]\n  (filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"51f82769e4b09be9c177e527"},{"code":"(fn [x]\n  (remove coll? (tree-seq coll? seq x))\n  )","problem":28,"user":"506617fce4b03d366d7cb2ac"},{"code":"(fn my-flatten\n  [s]\n  (if (some coll? s)\n    (reduce #(if (coll? %2)\n               (vec (concat %1 (my-flatten %2)))\n               (conj %1 %2))\n            []\n            s)\n    s))","problem":28,"user":"4ebf11bc535dfed6da9c6d9c"},{"problem":28,"code":"(fn flatten2 [[x & xs]]\n  (let [\n      head (if (sequential? x) (flatten2 x) (list x))\n      tail (if (nil? xs) () (flatten2 xs))\n  ]\n  (println x xs)\n  (concat head tail)\n))","user":"5509a23ee4b06e50f9beb11a"},{"problem":28,"code":"(fn flat\n  [arr]\n  (loop [result []\n         lst arr]\n    (let [val (first lst)]\n      (cond\n        (nil? val)  result\n        (coll? val) (recur (concat result (flat val)) (rest lst))\n        :else (recur (concat result (list val)) (rest lst))))))","user":"5e9636fee4b0fbed045a3816"},{"problem":28,"code":"#((fn dont-judge-me [result item]\n    (if (coll? item)\n      (apply conj result (reduce dont-judge-me [] item))\n      (conj result item)))\n   [] %1)","user":"5b4fef74e4b02d533a91bcde"},{"problem":28,"code":"(fn flat [lst]\n  (loop [i 0 n (count lst) res []]\n    (if (= i n)\n      res\n      (recur (inc i) n (let [elem (nth lst i)]\n                         (if (sequential? elem)\n                           (concat res (flat elem))\n                           (concat res [elem])))))))","user":"5d88a22de4b0915913b1d3ab"},{"problem":28,"code":"(fn [coll]\n  (letfn [(f [x] (mapcat #(if (coll? %) (f %) [%]) x))]\n    (f coll)))","user":"523630eee4b05f3be1c7c8e8"},{"problem":28,"code":"(fn new_flatten [l]\n    (if (sequential? l)\n        (mapcat new_flatten l)\n      \t(list l)\n    )\n)","user":"5821dbb9e4b04b46fc4b0f86"},{"code":"(fn my-flatten \n  [s]\n  (do\n    (cond\n      (and (sequential? s) (= (count s) 1)) (my-flatten (first s))\n      (and (sequential? s) (> (count s) 1)) (concat (my-flatten (first s)) (my-flatten (next s)))\n      (sequential? s) '()\n      :else (conj '() s)\n      )\n    )\n  )","problem":28,"user":"52a7634ae4b0c58976d9ac16"},{"problem":28,"code":"reduce (fn r [s x]\n     (if (sequential? x)\n       (reduce r s x) \n       (conj s x)\n      )  \n) []","user":"5b274fd1e4b063e2438bcc3b"},{"problem":28,"code":"(fn a [c] (cond \n           (and (coll? c) (empty? c)) ()\n           (coll? (first c)) (concat (a (first c)) (a (rest c)))\n           :else (cons (first c) (a (rest c)))))","user":"53572176e4b04ce2eb3ed276"},{"problem":28,"code":"(fn flt[x]\n  (if (coll? x)\n    (reduce concat\n            []\n            (map flt x))\n    [x]))","user":"582a2d4fe4b051871117bf55"},{"problem":28,"code":"(fn flatten' [s] (reduce (fn [flattened next-value]\n                             (if (sequential? next-value)\n                               (into [] (concat flattened (flatten' next-value)))\n                               (conj flattened next-value)))\n                           []\n                           s))","user":"5c1fe56ae4b07e362c23056e"},{"code":"(fn flatten-seq [coll] \n  (if (coll? coll) (mapcat flatten-seq coll) [coll]))","problem":28,"user":"4effb663535dcb61093f6a2e"},{"problem":28,"code":"(fn[x]  (loop [l x result []] (if (empty? l) (reverse result) (recur (if (coll? (first l)) (concat (first l) (rest l)) (rest l)    )  (if (coll? (first l)) result (cons (first l) result)) )) ))","user":"53f1c05ee4b0742d9025b0e1"},{"problem":28,"code":"(fn flat [x] \n  (if (sequential? x) \n    (mapcat flat x) \n    (list x)))","user":"57299c57e4b0c6e51e0d2b1e"},{"problem":28,"code":"(fn [list]  (loop [x list]\n    (if (not-any? sequential? x)\n      x\n      (recur (apply concat (map #(if (sequential? %) % [%]) x)))\n    )\n  ))","user":"5fae3d8ae4b08cb800c85afa"},{"code":"#(remove%(tree-seq% seq%2))sequential?","problem":28,"user":"4ddde41a535d08e6dec9fdd2"},{"problem":28,"code":"(fn flat [l]\n     (if (coll? l)\n         (mapcat flat l)\n         (list l)))","user":"53b42b9ce4b047364c0444b3"},{"code":"(fn flat [cl]\n  (let [l (first cl) r (next cl)]\n    (concat\n     (if (sequential? l)\n       (flat l)\n       [l])\n     (if (sequential? r)\n       (flat r)))))","problem":28,"user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":28,"code":"(fn flat [[f & r]]\n         (if (nil? f)\n           '()\n           (if (sequential? f)\n             (concat (flat f) (flat r))\n             (cons f (flat r)))))","user":"5be96111e4b0f319e2d7ec70"},{"problem":28,"code":"(fn [x]\n  \"Flattens any passed sequence\"\n  (let [return  (loop [[head & remain] (tree-seq sequential? seq x)\n         \t\t\t\tlst []]\n    \t\t\t\t(if (empty? remain)\n      \t\t\t\t\t(conj lst head)\n      \t\t\t\t\t(recur remain (conj lst head))))]\n        (filter (complement sequential?) return)))","user":"589cb617e4b00487982d536a"},{"code":"(fn flat\n  [s]\n    (if (empty? s)\n      '()\n      (let [head (first s)\n            more (rest s)]\n          (if (sequential? head)\n              (concat (flat head) (flat more))\n              (cons head (flat more))))))","problem":28,"user":"4e6ac7a8535d8ccf87e9ff03"},{"problem":28,"code":"( fn [ x ] ( filter #(not ( coll? % ) ) ( tree-seq coll? seq x ) ) )","user":"57561529e4b02ea1147992d3"},{"problem":28,"code":"(fn [coll]\n    (->>\n        (tree-seq \n            coll?\n            identity\n            coll)\n        (remove coll?)\n        (into [])))","user":"5a66fddee4b0512ff01cd9d7"},{"problem":28,"code":"(fn newflat [n]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq n))))","user":"54b2e881e4b09f271ff37d32"},{"problem":28,"code":"(fn my-flatten [s]\n  (mapcat\n   #(if (sequential? %)\n      (my-flatten %)\n      [%])\n   s))","user":"58ba8e7ce4b0888cdc949ce8"},{"problem":28,"code":"(fn flat [coll] (mapcat  #(if (coll? %) (flat %) [%]) coll))","user":"551e2cade4b030e6a24d00e4"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll]\n    (if (some sequential? coll)\n      (recur (reduce #(if (sequential? %2) (concat %1 %2) (concat %1 [%2])) \n              [] \n              coll))\n      coll)))","user":"51f38193e4b0fca5e8b48226"},{"code":"(fn my-f [s] (filter\n  (complement sequential?)\n  (rest (tree-seq sequential? seq s))))","problem":28,"user":"50e448bae4b0463d3207248d"},{"problem":28,"code":"(fn [x y] (if\n(empty? y) x\n(let [z (first y)]\n(if (#(coll? %) z) (recur x (concat z (rest y))) (recur (conj x z) (rest y)))))) []","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn myflatten [s] \n      (cond\n        (empty? s) []\n        (coll? (first s)) (concat (myflatten (first s)) (myflatten (rest s)))\n        :else (cons (first s) (myflatten (rest s)))))","problem":28,"user":"511dada0e4b0a5c68a34840c"},{"problem":28,"code":"(fn my-flatten [s]\n  (let [head (first s)\n        tail (rest s)]\n    (cond (empty? s) s\n          (coll? head) (let [flatten-head (my-flatten head)\n                             flatten-tail (my-flatten tail)]\n                         (conj (into flatten-tail (reverse (rest flatten-head))) (first flatten-head)))\n          :else (conj (my-flatten tail) head))))","user":"5578c67fe4b05c286339e08d"},{"code":"(fn flatten-my [seq]\n  (let [a (first seq) b (rest seq)]\n    (if-not (nil? a)\n      (if (coll? a)\n        (concat (flatten-my a) (flatten-my b))\n        (cons a (flatten-my b))))))","problem":28,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn flt [n]  \n    (cond    (sequential? n) (mapcat flt n)\n             :else (list n)\n             ) \n    )","problem":28,"user":"528f4462e4b0239c8a67aef0"},{"problem":28,"code":"(fn [x] (letfn [(flat-single [x] (if (coll? (first x))\n                                         (recur (worker (first x)))\n                                         x))\n                      (worker [x] (if (coll? x)\n                                    (if (> (count x) 1)\n                                      (reduce (fn [rdcd nxt]\n                                                (concat rdcd (if (coll? nxt) nxt (list nxt))))\n                                              '()\n                                              (map worker x))\n                                      (flat-single x))\n                                    x))]\n                (worker x)))","user":"53dad484e4b0e771c30254ac"},{"code":"(fn [l]\r\n        (loop [curr l acc []]\r\n            (if (empty? curr) acc\r\n            (let [H (first curr)\r\n                    T (rest curr)]\r\n                    (if (coll? H) (recur (concat H T) acc)\r\n                                (recur T (conj acc H)))))))","problem":28,"user":"523dd963e4b06956f8342ca1"},{"problem":28,"code":"(fn [items]\n  (let [container? (fn [item]\n                     (or (list? item)\n                         (vector? item)))\n        contains-container? (fn [items]\n                              (not (not-any? container? items)))\n        list-item (fn [item]\n                    (if (container? item) item\n                                          (list item)))\n        flatten-one-level (fn [items]\n                            (apply concat (map list-item items)))]\n    (loop [items-list items]\n      (if (not-any? container? items-list) items-list\n        (recur (flatten-one-level items-list))))))","user":"541cf6dfe4b01498b1a71a7a"},{"code":"(fn [incol]\n   (letfn [(applyflat [fn coll] (reduce fn [] coll))\n           (flat [coll next]\n                (if (sequential? next)\n                  \t(apply conj coll (applyflat flat next))\n                  \t(conj coll next)))]\n   (applyflat flat incol)))","problem":28,"user":"50ccf729e4b0f7a459302aac"},{"code":"(fn fltn [seq]\n  (apply concat\n         (map #(if (sequential? %)\n                 (fltn %)\n                 (list %))\n              seq)))","problem":28,"user":"516ff477e4b034fe8eaf70f3"},{"problem":28,"code":"(fn flatten* [x]\n   (if (coll? x)\n     (mapcat flatten* x)\n     [x]))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":28,"code":"#(reverse\n   ((fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n        '() %))","user":"571d1234e4b0145328a76274"},{"code":"(fn flat\n  [s]\n  (if (coll? s)\n    (reduce concat (map flat s))\n    [s]))","problem":28,"user":"5101192ae4b0bef64c30e266"},{"problem":28,"code":"(fn [coll]\n  (letfn [(flatn [x]\n            (if (sequential? x)\n              (mapcat flatn (seq x))\n              (list x)))]\n    (if (sequential? coll)\n      (flatn coll)\n      ())))","user":"5616f411e4b06b1bb2182a0a"},{"problem":28,"code":"(fn furp [x]\n  (let [r (reduce (fn [a b]\n            (concat (if (or (number? a) (string? a) (keyword? a))\n                     (list a)\n                     (furp a))\n                    (if (or (number? b) (string? b) (keyword? b))\n                     (list b)\n                     (furp b))\n                    []\n            )\n          )\n          x\n  )]\n  (if (and (seq? r) (seq? (first r)))\n    (furp r)\n    (if (not (seq? r))\n      (list r)\n      r)\n    )\n  )\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"problem":28,"code":"(fn [c] (first (filter #(every? (fn[x] (not (coll? x))) %) (iterate (fn [x] (reduce #(if (coll? %2)\n                                                                               (concat %1 %2)\n                                                                               (concat %1 (list %2))) [] x)) c))))","user":"5d764e52e4b02e6b30c93524"},{"code":"(fn [s] \n  (reduce (fn flat [coll elem] \n            (if (coll? elem)\n              (reduce flat coll elem)\n              (conj coll elem)\n              )\n            ) [] s\n          )\n  )","problem":28,"user":"529d4f4be4b04e0c58e87b79"},{"code":"(fn flatify [lst]\n  (when-let [[x & xs] (seq lst)]\n    (concat \n      (if (coll? x)\n        (flatify x)\n        (list x))\n      (flatify xs))))","problem":28,"user":"4ef0eaef535dced4c769f211"},{"problem":28,"code":"(fn [l] \n  \"free of StackOverflow problem, not lazy and much faster version of flatten.\"\n  (loop [l1 l, l2 `()]\n    (cond\n      (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n      (empty? l1) (reverse l2)\n      :else (recur (rest l1) (cons (first l1) l2)))))","user":"57ac7710e4b0b8559636fc88"},{"code":"(fn flat ([ c ]\n          (if (nil? (first c))\n            '()\n            (if (sequential? (first c))\n              (concat (flat (first c)) (flat (rest c)))\n              (cons (first c) (flat (rest c)))\n            )\n          )\n          )\n  )","problem":28,"user":"51e1a1fae4b06a68e693eaf6"},{"problem":28,"code":"#(map read-string (clojure.string/split (clojure.string/replace % #\"[\\[\\]\\(\\)]\" \"\") #\" \"))","user":"5d6d2e11e4b04d129b00f2ba"},{"code":"(fn myflatten [xs]\n  (\n    (fn _flatten [xs o]\n      (if-not (coll? xs)\n        [xs]\n        (if (empty? xs)\n          []\n          (concat (myflatten (first xs)) (myflatten (rest xs)))\n        )\n      )\n    )\n    xs\n    []\n  )\n)","problem":28,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":28,"code":"(fn flat\n  [sq]\n  (loop [i 0\n         flat-seq []]\n    (if (>= i (count sq))\n      (into '() (reverse flat-seq))\n      (if (sequential? (nth sq i))\n        (recur (inc i) (into flat-seq (into [] (flat (nth sq i)))))\n        (recur (inc i) (conj flat-seq (nth sq i)))))))","user":"55304523e4b076ab5578f810"},{"problem":28,"code":"(comp\n         (partial filter #(not (coll? %)))\n         (partial tree-seq coll? identity))","user":"53f592b7e4b0db01ade6f9d0"},{"code":"(comp (partial remove coll?)\n      (partial tree-seq coll? seq))","problem":28,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn f [[h & t]]\n  (if h\n    (if (coll? h)\n      (concat (f h) (f t))\n      (cons h (f t)))))","problem":28,"user":"5150f87ae4b03e678e393ac7"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    lst\n    (if (coll? (first lst))\n      (concat (my-flatten (first lst))\n              (my-flatten (rest lst)))\n      (cons (first lst) \n            (my-flatten (rest lst))))))","user":"59e18b9be4b08badc2a0c50f"},{"code":"(fn flat [x]\r\n  (if (sequential? x)\r\n    (mapcat flat (seq x))\r\n    (conj '() x)))","problem":28,"user":"5141bc82e4b02fd87f5064c5"},{"problem":28,"code":"#(filter \n\t(complement sequential?) \n\t(rest \n\t\t(tree-seq sequential? seq %)))","user":"5aee4b44e4b0cc2b61a3bc29"},{"problem":28,"code":"(fn f [i] (if (coll? i) \n            (mapcat f i)\n            [i]))","user":"52e1c276e4b09f7907dd142b"},{"code":"#(letfn [(expand [s] (apply concat (map (fn [e] (if (coll? e) (expand e) [e])) s)))] (expand %))","problem":28,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":28,"code":"#(loop [f () i (first %) ls (rest %)]\n   (if (sequential? i)\n     (if (= (rest i) '())\n       (recur f (first i) ls)  \n       (recur f (first i) (cons (rest i) ls)))\n     (if (= ls '())\n       (reverse (cons i f))\n       (recur (cons i f) (first ls) (rest ls)))))","user":"59566d1de4b066ee0a44af54"},{"problem":28,"code":"(fn [x] (let [p (fn [l] (reduce #(or %1 (sequential? %2)) false l))]\n          (if (p x) (recur (reduce #(concat %1 (if (sequential? %2) %2 [%2])) [] x)) x)))","user":"596caee3e4b069c0a1a19837"},{"problem":28,"code":"(fn fl ([x] (fl x '() '()))\n  ([x flr stack] (if (empty? x) (if (empty? stack) (reverse flr) (fl (first stack) flr (rest stack)))\n                     (if (or (seq? (first x)) (vector? (first x)))\n                       (fl (first x) flr (conj stack (rest x)))\n                       (fl (rest x) (conj flr (first x)) stack)))))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":28,"code":"(fn my-flat [seq]\n   (if (coll? seq)\n     (mapcat my-flat seq)\n     [seq]))","user":"5840c068e4b089d5ab817df8"},{"problem":28,"code":"(fn flatten' [x]\n  (cond \n   (coll? x) (mapcat flatten' x)\n   :else [x]))","user":"56ed3410e4b04a395b9a0444"},{"problem":28,"code":"(fn customFlatten\n  [s]\n  (reduce #(if (sequential? %2)\n             (into %1 (customFlatten %2))\n             (conj %1 %2)\n             )\n          []\n          s)\n  )","user":"5c20b6abe4b07e362c230576"},{"code":"(fn __\n\t([xs] (__ xs []))\n  \t([[h & t :as xs] acc]\n   \t\t(if (seq xs)\n   \t\t\t(if (sequential? h)\n      \t\t\t(__ t (__ h acc)) (__ t (conj acc h)))\n    \t\tacc)))","problem":28,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn [x]\n   (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn [ l ] \n  ( if (empty? (filter coll? l)) l \n    (recur (reduce #(concat %1 (if (coll? %2) %2 (list %2))) (cons '() l) ))))","problem":28,"user":"4fc43a8ee4b081705acca346"},{"problem":28,"code":"(fn [values]\n  (loop [to-process values\n         result []]\n    (if (empty? to-process)\n      result\n      (let [current (first to-process)\n            to-process (if (sequential? current)\n                         (concat current (rest to-process))\n                         (rest to-process))\n            result (if (sequential? current)\n                     result\n                     (conj result current))]\n        (recur to-process result)))))","user":"55d06bcbe4b0e31453f64a3a"},{"problem":28,"code":"(fn flat [input]\n    (reduce concat '()\n            (map #(if (sequential? %) (flat %) (list %)) input)))","user":"58ec1e63e4b056aecfd47d54"},{"code":"#(letfn [(flt [s]\n  (if (empty? s) s\n    (if (sequential? (first s))\n      (concat (flt (first s)) (flt (rest s)))\n      (cons (first s) (flt (rest s))))))] (flt %))","problem":28,"user":"4f3e5e87e4b0e243712b1f83"},{"code":"(fn flat [xs]\n  (reduce\n    (fn [x y]\n      (concat x (if (coll? y) (flat y) (list y))))\n    [] xs))","problem":28,"user":"51ca7906e4b08b1cbd0d9487"},{"problem":28,"code":"(fn\tmy-flatten\n    [coll]\n    (lazy-seq\n     (when-let [s (seq coll)]\n       (if (sequential? (first s))\n         (concat (my-flatten (first s)) (my-flatten (rest s)))\n         (cons (first s) (my-flatten (rest s)))))))","user":"5cf1d9e3e4b0aaa82f112a18"},{"problem":28,"code":"(fn fltn [coll]\n  (reduce #(concat %1 (if (sequential? %2) (fltn %2) [%2])) [] coll))","user":"5a383581e4b001c08efc0c97"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (reduce\n  (fn  [a b] \n      (concat a  \n           (if (coll? b) \n              (my-flatten b)\n              [b]\n            )\n      )\n)\n  []\n  coll)\n)","user":"59b0e877e4b0e1f4e384c8d3"},{"problem":28,"code":"(fn flat-n-merge [c]\n  (reduce (fn red [a b]  \n    (if (or (seq? b) (map? b) (set? b) (vector? b) ) (concat a (flat-n-merge b)) (concat a [b]))) [] c))","user":"5695b589e4b0dcc4269f412a"},{"problem":28,"code":"(fn flat [[x & xs]]\n (cond \n  (nil? x) nil\n  (coll? x) (concat (flat x) (flat xs))\n  :else (conj (flat xs) x)\n )\n)","user":"56433d34e4b08d4f616f5f23"},{"code":"(fn flat\n    ([xs]\n       (seq (flat xs [])))\n    ([xs res]\n       (loop [[y & ys] xs\n              r res]\n         (if y\n           (if (or (seq? y) (list? y) (vector? y))\n             (recur ys (flat y r))\n             (recur ys (conj r y)))\n           r))))","problem":28,"user":"4fe89297e4b07c9f6fd12c4c"},{"problem":28,"code":"(fn [l]\n  (letfn [(flat [b s]\n            (if (sequential? s)\n              (reduce flat b s)\n              (conj b s)))]\n    (flat [] l)))","user":"571d063ee4b0145328a76272"},{"problem":28,"code":"(fn f [[h & t :as l]]\n  (cond\n    (empty? l) '()\n    (coll? h) (concat (f h) (f t))\n    :else (cons h (f t))))","user":"5e3d183fe4b01d43a70e8e11"},{"problem":28,"code":"(fn [in]\n    (loop [x in r '() a []]\n    (println \"Loop args x=\" x \"r=\" r \"a=\" a)\n    (if (coll? x)\n      (if (empty? x)\n        (if (empty? r)\n          a\n          (recur (first r) (rest r) a))\n        ; Non empty\n        (do\n          (recur (first x) (conj r (rest x)) a)))\n      ; Not a collection\n      (do\n        (if (nil? x)\n          a\n          (if (empty? r)\n            (do\n              (conj a x))\n            (do\n              (recur (first r) (rest r) (conj a x)))))))))","user":"5ae47c1de4b0837691e92c81"},{"problem":28,"code":"(fn flat [n] (let [[x & xs] n] (cond (empty? n) '() (coll? x) (concat (flat x) (flat xs)) :else (cons x (flat xs)))))","user":"58d1fe17e4b03c36ff7e58f5"},{"code":"(fn [c] (filter (comp not sequential?) (tree-seq sequential? seq c)))","problem":28,"user":"4dc78527535d8a4b2fd7428f"},{"code":"(fn flat [xs] (apply concat (map (fn [ys] (if (sequential? ys) (flat ys) [ys])) xs) ))","problem":28,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":28,"code":"#(reduce\n  (fn x [acc item] (if (coll? item) (reduce x acc item) (conj acc item)))\n  []\n  %)","user":"5ea970d1e4b00a66d4a951c6"},{"code":"(fn my-flatten [v]\n  (if(sequential? v)\n    (vec (apply concat (map my-flatten v)))\n    [v]))","problem":28,"user":"533160a1e4b019098a6f8b68"},{"problem":28,"code":"(fn rec [a] (apply concat (map (fn [b] (if (coll? b) (rec b) (cons b '()))) a)))","user":"5511dfafe4b06e50f9beb19c"},{"code":"(fn make-flat [items]\n  (loop [flat '() bumpy items]\n    (if-not (seq bumpy)\n      flat\n      (recur\n        (if (or (seq? (first bumpy)) (vector? (first bumpy))) flat (concat flat (list (first bumpy))))\n        (if (or (seq? (first bumpy)) (vector? (first bumpy))) (concat (first bumpy) (rest bumpy)) (rest bumpy))))))","problem":28,"user":"534d6524e4b084c2834f4a9f"},{"code":"(fn flatt [list]\n((fn resolv [ret lst]\n   (if (and (sequential? lst) (not (empty? lst))) \n     (concat ret (resolv ret (first lst)) (resolv ret (rest lst)))\n     (if (sequential? lst);empty\n       ret\n       (conj ret lst)\n       )\n     )\n   ) (empty list) list )\n)","problem":28,"user":"533e7f63e4b085b17e897d8e"},{"problem":28,"code":"(fn flat [l]\n  (if (or (seq? l) (vector? l))\n    (if (empty? l)\n      l\n      (concat\n       (flat (first l))\n       (flat (rest l))))\n    (list l)))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn flatn [xs]\r\n  (if (not (empty? xs))\r\n    (if (coll? (first xs))\r\n      (concat (flatn (first xs)) (flatn (rest xs)))\r\n      (conj (flatn (rest xs)) (first xs)))))","problem":28,"user":"4e8dd6cb535d65386fec213b"},{"problem":28,"code":"(\n fn c [x] \n (\n  if (coll? x)\n  (apply concat\n  (map c x))\n  (list x)\n   \n )  \n)","user":"53fdc4b8e4b0de5c418485ea"},{"problem":28,"code":"(fn flatty [x]\n  (cond\n   (coll? (first x))\n   (concat (flatty (first x))\n           (flatty (rest x)))\n   (coll? (first (rest x)))\n   (conj (flatty (rest x))\n         (first x))\n   :else x))","user":"5a29ee57e4b09cafd31c7f2b"},{"code":"(fn myfn [s]\n\t(reduce\n    \t(fn [x y]\n        \t(if (coll? y) (apply conj x (myfn y))\n            \t(conj x y) \n            )\n        )\n     \t[]\n     \ts\n    )\n)","problem":28,"user":"525ba7bbe4b0cb4875a45d28"},{"problem":28,"code":"#(filter (fn[x] (not (coll? x))) (tree-seq coll? identity %))","user":"545537c1e4b0e397800069dd"},{"code":"(fn [coll]\n  (letfn [(fltn [x]\n            (if (coll? x)\n                (reduce #(concat % (fltn %2)) '() x)\n                (list x)))]\n  (fltn coll)))","problem":28,"user":"4fd96694e4b05e33b9224f37"},{"problem":28,"code":"(fn my-flatten [coll]\n  (let [l (first coll), r (next coll)]\n    (concat\n      (if (sequential? l) (my-flatten l) [l])\n      (when-not (empty? r) (my-flatten r)))))","user":"56174d86e4b06b1bb2182a0e"},{"code":"#(loop [a % b []]\r\n    (if (empty? a)\r\n    b\r\n    (recur\r\n      (if (coll? (first a))\r\n        (concat (first a) (rest a))\r\n        (rest a))\r\n      (if (not (coll? (first a))) (conj b (first a)) b))))","problem":28,"user":"4e1fe7f1535d04ed9115e810"},{"problem":28,"code":"(fn __ [coll]\n  (reduce\n    (fn [s x]\n      (concat\n        s\n        (if (sequential? x)\n          (__ x)\n          (list x))))\n    '()\n    coll))","user":"530e75d5e4b08068f379ecba"},{"code":"(fn ft [x]\n(filter (complement sequential?)\n(rest (tree-seq sequential? seq x))))","problem":28,"user":"4ec17677535dfed6da9c6dad"},{"problem":28,"code":"(fn myFlatten [collection]\n  (cond\n    (not (sequential? collection)) (list collection)\n    (empty? collection) '()\n    :else (concat (myFlatten (first collection)) (myFlatten (rest collection)))))","user":"548f339ee4b0e286459a1233"},{"problem":28,"code":"#(loop [result [] items (vec %)]\n   (if (sequential? (first items))\n      (recur result (into (vec (first items)) (rest (vec items))))\n      (if (empty? items)\n        result\n        (recur (conj result (first items)) (rest (vec items))))))","user":"58a6806ee4b01a0c0b23292f"},{"problem":28,"code":"(fn flatten1 [coll] (if (coll? coll) (mapcat flatten1 coll) [coll]))","user":"606b16b8e4b069485764ddf7"},{"problem":28,"code":"(fn strip [x]\n  (if\n    (coll? x) (mapcat strip x)\n    (list x)))","user":"56b295f7e4b0982f16b37e08"},{"problem":28,"code":"(fn flat\n  [coll]\n  (if (coll? coll)\n    (mapcat flat coll)\n    [coll]))","user":"5e9b6471e4b0157ca96647f0"},{"problem":28,"code":"(fn [xs]\n  (if (some coll? xs)\n    (recur (reduce #(if (coll? %2)\n               (into %1 %2)\n               (conj %1 %2)) [] xs))\n    xs))","user":"5fa28e2be4b0f0ebd91b77f0"},{"code":"(fn [x]\n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f45c72be4b0d56e7bb92b8a"},{"code":"( fn [c] ((fn mflatten [ a b ] \n  (if (seq? a)\n    (if (seq? (first a))\n      (mflatten (rest a)\n        (concat b ( mflatten\n          (first a) '())\n        )\n      )\n      (if (vector? \n        (first a))\n        (mflatten (rest a)\n          (concat b\n            (mflatten \n              (seq \n                (first a))\n              '()\n            ) ; mflatten\n          ) ; concat\n        ) ; mflatten\n        (if (empty? a)\n          b\n          (mflatten (rest a)\n            (concat b \n              (list \n                (first a)\n              ); list\n            ) ; concat\n          ) ; mflatten\n        ) ; if empty\n      ) ; if vector\n    ); seq fa\n    (if (vector? a)\n       (mflatten (seq a) b)\n       (if (empty? a)\n         b\n         (concat b (list a))\n       ); if empty\n     ); if vector\n   ); if seq\n  ); defn\n c '()))","problem":28,"user":"51340abbe4b0915833951877"},{"code":"(fn lala [l] (cond (empty? l) l (or (seq? (first l)) (vector? (first l))) (concat (lala (first l)) (lala (rest l))) :else (cons (first l) (lala (rest l)))))","problem":28,"user":"4e5206ec535d302ef430da6c"},{"problem":28,"code":"(fn my-flatten [xs]\n  (mapcat #(if (coll? %) (my-flatten %) [%]) xs))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [x]\n  (letfn [(fun2 [x out]\n    (loop [i 0 out out x x]\n      (if (== i (count x))\n        out\n        (if (coll? (nth x i))\n          (recur (inc i) (fun2 (nth x i) out) x)\n          (recur (inc i) (conj out (nth x i)) x)))))]\n  (fun2 x [])))","problem":28,"user":"4e955b95535dbda64a6f6b33"},{"code":"(fn m [coll]\n (when-let [s  (seq coll)]\n      (if (coll? (first s))\n        (concat (m (first s)) (m (rest s)))\n        (cons (first s) (m (rest s))))))","problem":28,"user":"52828298e4b0757a1b17145b"},{"code":"(fn op [coll]\r\n  (reduce \r\n    #(if (coll? %2) \r\n      (apply conj %1 (op %2)) \r\n      (conj %1 %2)) \r\n  (conj (seq coll) [])))","problem":28,"user":"4f1e4ab5535d64f603146496"},{"code":"#(reverse \n  ((fn f [lst acc]\n    (let [[x & xs] lst]\n      (cond\n        (empty? lst) acc\n        (coll? x)\n          (recur xs (f x acc))\n        :else (recur xs (cons x acc)))))\n    % '()))","problem":28,"user":"509251f3e4b09a7d0b586de5"},{"code":"(fn myflatten [c]\n    (letfn [(_myflatten [c flat]\n                        (if (seq c)\n                          (let [f (first c)]\n                            (cond (list? f) (recur (concat f (rest c)) flat)\n                                  (vector? f) (recur (concat f (rest c)) flat)\n                                  :else (recur (rest c) (conj flat (first c)))))\n                          flat))]\n      (apply list (_myflatten c []))))","problem":28,"user":"500ea957e4b00fff93030f9b"},{"problem":28,"code":"(fn [xs]\n  (loop [acc '()\n         remaining xs]\n    (if (empty? remaining)\n      (reverse acc)\n      (let [[head & tail] remaining]\n        (if (sequential? head)\n          (recur acc (into (apply vector head) (apply vector tail)))\n          (recur (conj acc head) tail))))))","user":"5cc75ffce4b0ccb061962836"},{"problem":28,"code":"(fn my-flatten [lst]\n  (loop \n    [todo lst ret []]\n    (if (empty? todo)\n      ret\n      (recur \n        (rest todo) \n        (if (coll? (first todo))\n          (vec (concat ret (my-flatten (first todo))))\n          (conj ret (first todo))\n        )\n      ) \n    )\n  )\n)","user":"5d0aab50e4b0cc9c91588220"},{"code":"(fn flt [coll] (if (sequential? coll) (mapcat flt coll) (list coll)))","problem":28,"user":"52435d0ce4b076204b44fab5"},{"problem":28,"code":"(fn f [a] (reduce \n   (fn [r e]  (concat r (if (coll? e) (f e) (list e)))) \n '() a)\n )","user":"54494159e4b032a45b8693d1"},{"code":"(fn [s]\n  (#(filter (complement sequential?) (rest (tree-seq sequential? seq s)))))","problem":28,"user":"51eb3aace4b0f1f103a0d159"},{"problem":28,"code":"(fn new-flatten [x]\n   (if (or (seq? x) (vector? x))\n     (if (not-empty x)\n     (concat (new-flatten (first x)) (new-flatten (rest x))))\n     [x]))","user":"545e9cf1e4b01be26fd7467f"},{"code":"(fn flat [foo]\n  (if (empty? foo)\n       '()\n\t   (if (sequential? (first foo))\n     \t\t(into (flat (first foo)) (flat (rest foo)))\n     \t\t(into [(first foo)] (flat (rest foo)))\n)))","problem":28,"user":"52ac41fee4b0c58976d9ac85"},{"problem":28,"code":"(fn\n  [seq]\n  ((fn X\n      [seq\n       flat-seq]\n      (if (empty? seq)\n        flat-seq\n        (let [[head & tail] seq] \n          (if (coll? head)\n            (recur tail (X head flat-seq))\n            (recur tail (conj flat-seq head)))))) seq []))","user":"5844e6f4e4b089d5ab817e5a"},{"problem":28,"code":"(fn fl [l]\n\t(if (coll? l) \n          (when (seq l)\n\t    (concat (fl (first l)) (fl (rest l))))\n\t  [l]))","user":"530bae80e4b02e82168697d0"},{"code":"(fn flat [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flat l)\n        [l])\n      (when (sequential? r)\n        (flat r)))))","problem":28,"user":"4f030cff535dcb61093f6a4d"},{"code":"#(letfn [(fltn [s]\n  (reduce (fn [f i]\n    (if (sequential? i)\n      (vec (concat f (fltn i)))\n      (do (conj f i)))) [] s))]\n  (fltn %))","problem":28,"user":"4fe8b6afe4b07c9f6fd12c76"},{"problem":28,"code":"(fn flatt-en [sq]\n  (if (sequential? sq)\n    (mapcat flatt-en sq)\n    (list sq)))","user":"5559b443e4b0deb715856e3c"},{"problem":28,"code":"(fn make-flat\n  \t[s]\n  \t(if (coll? s)\n      \t(mapcat make-flat s)\n      \t[s]))","user":"591addcee4b09b4ee5954be1"},{"problem":28,"code":"(fn f [x]\n    (mapcat #(if (coll? %)\n              (f %)\n              [%])\n              x))","user":"5eb193fde4b00a66d4a951fe"},{"problem":28,"code":"(fn [coll] \n  (loop [c coll, res []]\n    (if (not (seq c)) res\n      (let [head (first c), tail (next c)]\n        (if (sequential? head)\n          (recur (concat head tail) res)\n          (recur tail (conj res head))\n          )\n        )\n      )\n    )\n  )","user":"564b495de4b0284900eef667"},{"code":"(fn flat[x]\n        (cond\n         (not (sequential? x)) (list x)\n         (empty? x) x\n         :else (concat (flat (first x))\n                       (flat (rest x)))))","problem":28,"user":"50456731e4b01f6c9a8b236b"},{"code":"(fn f [s]\n  (if (some sequential? s)\n    (f (apply concat (map #(if (sequential? %) % (vector %)) s)))\n    s))","problem":28,"user":"51c8301ee4b07ef393169e4d"},{"code":"(fn my-flatten [coll]\r\n  (letfn [[inner-flatten [coll result]\r\n           (if-not (coll? coll)\r\n             (conj result coll)\r\n             (loop [coll coll\r\n                    result result]\r\n               (if (empty? coll)\r\n                 result\r\n                 (recur (rest coll) (inner-flatten (first coll) result)))))]]\r\n    (inner-flatten coll [])))","problem":28,"user":"4fe54ee8e4b0e8f79898fec3"},{"problem":28,"code":"(fn nflatten [col]\r\n  (mapcat (fn [c]\r\n            (if (coll? c)\r\n              (nflatten c)\r\n              (list c)))\r\n          col))","user":"5dbd51cfe4b09f47823971bb"},{"problem":28,"code":"(fn f[s]\n  (when (not (empty? s))\n    (let [x (first s) e (rest s)]\n      (if (sequential? x)\n        (concat (f x) (f e))\n        (conj (f e) x)))))","user":"54df2609e4b024c67c0cf7a9"},{"code":"(fn flat [x] (loop[myNL '() myL x](\n                              if(not= (first myL) nil) \n                                (recur( if(coll? (first myL)) \n                                        (concat myNL(flat (first myL))) \n                                        (concat myNL (list( first myL)))) \n                                (rest myL)\n                                )\n                                myNL\n                              )\n          )\n  )","problem":28,"user":"5177cacde4b0261ae665b877"},{"problem":28,"code":"(fn l [s]\n  (if (sequential? s) (mapcat l s) [s]))","user":"55377460e4b09218d5f44fc9"},{"problem":28,"code":"(let\n  [\n   flatHelper\n    (\n     fn x [s seqBuilder]\n      (\n       if (empty? s)\n        seqBuilder\n        (\n         x\n          (rest s)\n          (\n           if (sequential? (first s))\n            (concat seqBuilder (x (first s) '()))\n            (concat seqBuilder [(first s)])\n          )\n        )\n      )\n    )\n   flat (fn [s] (flatHelper s '()))\n  ]\n  flat)","user":"54ba8206e4b0ed20f4ff6eb6"},{"code":"(fn [xs]\n  (loop [xs xs, ys []]\n    (if (empty? xs) ys\n      (let [[x & xs] xs]\n        (if (coll? x)\n          (recur (concat x xs) ys)\n          (recur xs (conj ys x)))))))","problem":28,"user":"4ee67d74535d93acb0a66861"},{"problem":28,"code":"(fn fl [c]\n  (reduce #(if (coll? %2) (into [] (concat % (fl %2))) (conj % %2))\n          []\n          c))","user":"508c3d42e4b0f17d83ea26b2"},{"code":"(fn [x] (filter (complement sequential?)\r\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4ffee0f6e4b0678c553fc3f7"},{"code":"#(filter (comp not coll?) (tree-seq coll? identity %))","problem":28,"user":"4ef77c82535dced4c769f253"},{"problem":28,"code":"(fn my-flatten [coll] \n  (if (coll? coll)\n    (mapcat my-flatten coll)\n    `(~coll)))","user":"5de0b844e4b0948ae9d9adea"},{"problem":28,"code":"(fn flat [xs]\n  (if-not (coll? xs)\n    (list xs)\n    (mapcat flat xs)))","user":"569ad037e4b0542e1f8d144f"},{"problem":28,"code":"(fn x \n\n  ([coll] (x coll []))\n\n  ([coll res]\n\n   (when (empty? coll) res)\n\n   (reduce #(if (coll? %2) (into %1 (x %2 res)) (conj %1 %2) ) res coll)))","user":"583667c7e4b089d5ab817cfb"},{"code":"(fn my-flatten [elem]\n   (if (coll? elem)\n     (mapcat my-flatten elem)\n     [elem]))","problem":28,"user":"50e7cef1e4b077ad597af36a"},{"code":"(fn [s] (#(filter (complement sequential?) (rest (tree-seq sequential? seq s)))))","problem":28,"user":"52d7f7efe4b09f7907dd1380"},{"problem":28,"code":"(fn name [thing] (if (coll? thing) (mapcat name thing) [thing]) )","user":"59419bdfe4b060784b3b78f7"},{"problem":28,"code":"(fn my-flat [t]\n  (if (coll? t)  \n    (reduce concat (map my-flat (seq t)))\n    (list t)))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn flatten' [coll]\n  (let [x (first coll)\n        xs (rest coll)]\n  (cond (nil? x) ()\n        (coll? x) (concat (flatten' x) (flatten' xs))\n        :else (conj (flatten' xs) x))))","problem":28,"user":"51c19873e4b0d204dbe2ca0d"},{"code":"(fn f [s]\n  (if (sequential? s)\n    (apply concat (map f s))\n    [s]))","problem":28,"user":"51284226e4b03a34742b4308"},{"problem":28,"code":"(fn [s]\n  (letfn [(iter [s result]\n                (let [fst (first s)]\n                  (cond\n                   (empty? s) result\n                   (not (coll? fst)) (iter (rest s) (conj result fst))\n                   :else (iter (concat (iter fst []) (rest s)) result))))]\n    (iter (vec s) [])))","user":"54b817eee4b0ed20f4ff6e93"},{"code":"(fn flat [xs]\n  (loop [ys (seq xs)\n         zs (empty ys)]\n    (if (seq ys)\n      (if (coll? (first ys))\n        (recur (rest ys) (into zs (flat (first ys))))\n        (recur (rest ys) (conj zs (first ys))))\n      (reverse zs))))","problem":28,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn f[col] (loop [l col  res '()] (if (empty? l) res (if (sequential? (first l)) (recur (rest l) (concat res (f (first l)))) (recur (rest l) (concat res (list (first l))))))))","problem":28,"user":"53347274e4b0656e627bfd6b"},{"code":"(fn my-flatten[v]\n  (if(sequential? v)\n    (vec (apply concat (map my-flatten v)))\n    [v]))","problem":28,"user":"51b9f5a6e4b0e871ca49590e"},{"problem":28,"code":";; Basic recursive flatten, with some hackery so it can be \n;; defined in a let block.\n(let [flatten-rec (fn [f coll]\n                    (if (not (coll? coll)) (list coll)\n                        (let [[x & rst] coll]\n                          (cond (empty? rst) (f f x)\n                                :else (concat (f f x) (f f rst))))))\n      flatten-seq (partial flatten-rec flatten-rec)]\n  flatten-seq)","user":"5ed9b912e4b0c7845d86b0e3"},{"problem":28,"code":"(fn [c]\n  (loop [result [] coll c]\n    (cond (empty? coll) result\n          (coll? (first coll)) (recur result (concat (first coll)(rest coll)))\n          :else (recur (conj result (first coll)) (rest coll)))))","user":"593bdd84e4b069cdc2982b81"},{"problem":28,"code":"(fn _flatten\n\t[tail]\n\t(reduce (fn [memo item]\n\t\t\t\t(concat memo\n\t\t\t\t\t(if \n\t\t\t\t\t\t(coll? item)\n\t\t\t\t\t\t(_flatten item)\n\t\t\t\t\t\t(list item)\n\t\t\t\t\t))\n\t\t\t) '() tail)\n)","user":"549831b0e4b0b312c081ff7d"},{"problem":28,"code":"(fn [coll]\n  (remove sequential? (rest (tree-seq sequential? seq coll))))","user":"5ba5802de4b0a20761a233fd"},{"problem":28,"code":"(fn my-flatten [col]\n  (reduce\n   (fn rdcer [result col?]\n     (if (coll? col?)\n       (into result (my-flatten col?))\n       (conj result col?)))\n   []\n   col))","user":"58c5a08be4b021aa9917ed40"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n             ;(list acc)\n             )]\n    (reduce f* [] c)\n))","user":"5790f9d7e4b0ebec4cfb75b4"},{"code":"(fn f [s] (if (sequential? s)\n             (mapcat f s)\n             [s]))","problem":28,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn f [coll] (if (coll? coll) (mapcat f coll) [coll]))","problem":28,"user":"500e91aae4b00fff93030f99"},{"problem":28,"code":"(fn [sq] \n  (loop [ result '() sq sq]\n    (cond\n     \t(nil? (first sq)) result\n     \t(sequential? (first sq)) (recur result (concat (cons (first (first sq)) (rest (first sq))) (rest sq) ))\n         :else (recur (into (list (first sq)) (reverse result)) (rest sq))                               \n     )\n    )\n  )","user":"56c7d8dee4b0ed865f9758c9"},{"code":"(fn [ls] (filter #(not (coll? %)) (tree-seq coll? identity ls)))","problem":28,"user":"534eecaee4b084c2834f4abf"},{"code":"(fn this [w]\r\n;    (println w)\r\n;(let [ret\r\n    (if\r\n      (coll? w)\r\n      (if\r\n        (empty? w)\r\n        '()\r\n        (concat (this (first w)) (this (rest w)))\r\n      )\r\n      (list w)\r\n    )\r\n;] (println \"ret: \" ret) ret)\r\n  )","problem":28,"user":"501819efe4b02f523d7cc5eb"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  \n  (seq (reduce (fn my-flatten [x y]  \n            \n      (if (coll? y)\n        (reduce my-flatten x y)\n        (conj x y)))\n               \n    [] lst)))","user":"5a99ae99e4b0d174b936c7a4"},{"code":"(fn mkflat [s]\n  (lazy-seq\n   (if (empty? s) s\n       (if (sequential? (first s))\n         (concat (mkflat (first s)) (mkflat (rest s)))\n         (conj (mkflat (rest s)) (first s))))))","problem":28,"user":"4f0ef874535d0136e6c22328"},{"code":"(fn [s] (filter #(not (nil? %)) (map #(when (not (coll? %)) %) (tree-seq coll? identity s))))","problem":28,"user":"50a4f36be4b0344e360f3bc9"},{"problem":28,"code":"(fn flatter [c]\n  (if (not (coll? c))\n    [c]\n    (apply concat (map flatter c))))","user":"5ea580a3e4b00a66d4a951a7"},{"problem":28,"code":"(fn flatit \n  ([a-seq] (flatit a-seq []))\n  ([a-seq res]\n   (let [el (first a-seq)\n         rem-seq (rest a-seq)]\n     (cond \n       (nil? el) res\n       (coll? el) (flatit rem-seq (into res (flatit el)))\n       :else (flatit rem-seq (conj res  el))))))","user":"580d2788e4b0849f6811b730"},{"code":"(fn [l] (let [w (fn w [n] (if (sequential? n) (mapcat w n) [n]))] (w l)))","problem":28,"user":"5098bcfee4b0cae2931060a1"},{"problem":28,"code":"#(reduce (fn flat [new-coll coll]\n          (if ((complement coll?) coll)\n            (concat new-coll [coll])\n            (if (some coll? coll)\n              (concat (flat new-coll (first coll)) (flat [] (rest coll)))\n              (concat new-coll coll))))\n        []\n%)","user":"5dcb1e73e4b02b31cc3da3b6"},{"code":"(fn flattn \n  ([col] (flattn col '()))\n  ([[fst & rst] ret]\n  \t(cond\n      (nil? fst) ret\n      (coll? fst) (recur (into rst (reverse fst)) ret)\n      :else (recur rst (concat ret nil [fst])))))","problem":28,"user":"51a1659de4b00957e520db72"},{"code":"(fn flat [sq] (if (empty? sq) '() (if (coll? (first sq)) (concat (flat (first sq)) (flat (rest sq))) (cons (first sq) (flat (rest sq))))))","problem":28,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":28,"code":"reduce \n(fn my-flatten [accumulator element]\n\t(if (coll? element) \n\t\t(reduce my-flatten accumulator element)\n\t\t(concat accumulator (list element))\n\t)\n)\n'()","user":"57a9db97e4b0b8559636fc5b"},{"problem":28,"code":"#(->> % (tree-seq coll? identity) (filter (complement coll?)))","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":28,"code":"(fn flatdat [[h & r]] (if (= h nil) (list) (if (sequential? h) (concat (flatdat h) (flatdat r)) (cons h (flatdat r)))))","user":"56f3e77ee4b046a417f92058"},{"problem":28,"code":"#(reduce \n  (fn fun [coll x]\n    (if (sequential? x)\n      (reduce fun coll x)\n      (conj coll x)))\n    [] %)","user":"5f0c8b0de4b0f30dddfb5d4c"},{"problem":28,"code":"(fn myflatten\n  [coll]\n  (cond\n     \t(empty? coll) (list)\n     \t(coll? (first coll)) (concat (myflatten (first coll)) (myflatten (rest coll)))\n     \t:else (cons (first coll) (myflatten (rest coll)))))","user":"5658d775e4b00d3155796114"},{"problem":28,"code":"#(loop [in %]\n   (if (not (some coll? in))\n     in\n     (recur (reduce (fn[a b](if (coll? b)\n                              (concat a b)\n                              (conj (vec a) b)))\n                    [] in))))","user":"5596af34e4b04c1e5c31d758"},{"problem":28,"code":"(fn [s]\n    (reduce\n     (fn flt [v e]\n       (if-not (coll? e) (conj v e)\n               (reduce flt v e)))\n     [] s))","user":"5ab96075e4b073f177442694"},{"problem":28,"code":"(fn flatten-seq\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (flatten-seq r))\n          :else (concat (flatten-seq f) (flatten-seq r)))))","user":"597a7418e4b02382a38ad1e9"},{"problem":28,"code":"(fn flatten-seq\n  [coll]\n  (loop [left '()\n         [cur & right] coll]\n    (cond\n      (coll? cur) (recur left (concat cur right))\n      (nil? cur) (reverse left)\n      :else (recur (cons cur left) right)\n      )))","user":"56d15251e4b0ea9b8538f78c"},{"problem":28,"code":"(fn myflatten [s] (if (coll? s) (mapcat myflatten s) (list s)))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":28,"code":"(fn [lst]\n  (let\n    [\n      is-flat\n        #(every? (complement sequential?) %)\n      flat-once\n        #(->> %\n          (reduce\n            (fn [res cur]\n              (if (sequential? cur)\n                (concat res cur)\n                (reverse (conj (reverse res) cur))\n              )\n            )\n            nil\n          )\n        )\n    ] \n    (\n      (comp\n        first\n        (partial drop-while (complement is-flat))\n      )\n      (iterate flat-once lst)\n    )\n  )\n)","user":"5bb905dce4b0a20761a235c7"},{"code":"#(loop [x % y []] (if (empty? x)\n                    y\n                    (let [a (first x) b (rest x)]\n                      (if (coll? a) \n                        (recur (concat a b) y)\n                        (recur b (conj y a))))))","problem":28,"user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [arg] (reduce (fn flat [coll it] \n  (if (coll? it) (reduce flat coll it) (conj coll it))) [] arg))","problem":28,"user":"4dfe65a1535d04ed9115e787"},{"problem":28,"code":"(fn  my-flatten [s]\n  (if (coll? s)\n    (mapcat my-flatten s)\n    [s]))","user":"5da44d35e4b000c986472bf1"},{"problem":28,"code":"#(->> % (tree-seq sequential? seq)(rest)(filter (complement sequential?)))","user":"585481e0e4b07779d46863fe"},{"code":"#(reverse\n   (loop [seq % acc ()]\n     (if (empty? seq)\n       acc\n       (if (coll? (first seq))\n         (recur (concat (first seq) (rest seq)) acc)\n         (recur (rest seq) (cons (first seq) acc))))))","problem":28,"user":"4e4ae5aa535dc968683fc4d2"},{"problem":28,"code":"(fn fl [s] \n  (letfn \n    [(flatten-once [s] \n                   (reduce #(concat %1 (if (coll? %2) %2 [%2])) [] s))]\n    (if (= s (flatten-once s)) \n      s \n      (fl (flatten-once s))\n    )\n  )\n)","user":"552a672de4b0ffed3738f954"},{"problem":28,"code":"(fn f [s] (reduce (fn [x y] (if (or (vector? y) (seq? y)) (vec (concat x (f y))) (conj x y))) [] s))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn fltn [x]\n  (let [f (first x) n (next x)]\n    (concat\n      (if\n        (sequential? f)\n        (fltn f)\n        [f]\n        )\n      (when (sequential? n)\n        (fltn n)\n        )\n      )\n  )\n)","problem":28,"user":"53765e1ae4b06839e8705e23"},{"problem":28,"code":"(fn [a] (filter (complement sequential?) (tree-seq sequential? seq a)))","user":"57a22c85e4b0c3d858beb8f6"},{"problem":28,"code":"(fn flatn [xs]\n    (when-let [s  (seq xs)]\n      (if (coll? (first s))\n        (concat (flatn (first s)) (flatn (rest s)))\n        (cons (first s) (flatn (rest s))))))","user":"55150524e4b055c2f668d4d9"},{"problem":28,"code":"(fn f [l]\n  (mapcat #(if (coll? %1) (f %1) [%1]) l))","user":"55337e61e4b09218d5f44f8e"},{"problem":28,"code":"(fn flat3 [coll]\n  (cond (sequential? (first coll)) ;rest always returns a sequence so we only need to check first\n        (concat (flat3 (first coll)) (flat3(rest coll)))\n        (not (empty? coll)) ;concat requires two sequences.\n                                   ;if first is not sequenctial we need to cons.\n        (cons (first coll) (flat3 (rest coll)))\n        :else coll ;should always return an empty list\n        )\n  )","user":"53f6bfd9e4b0db01ade6f9e4"},{"code":"(fn [x] (filter (complement sequential?)\r\n        (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f16d3fd535d64f60314644e"},{"code":"(fn flat [x]\n  (let [[z & y] x]\n    (cond\n     (empty? x) '()\n     (coll? z) (concat (flat z) (flat y))\n     :else (cons z (flat y)))))","problem":28,"user":"5102f4f9e4b00c483ae176fd"},{"code":";(fn flat [xs]\n;  (if (coll? xs)\n;    (reduce concat (map flat xs))\n;    (list xs)))\n\n(fn flat [xs]\n  (if (coll? xs)\n    (mapcat flat xs)\n    (list xs)))","problem":28,"user":"5312cdaae4b08068f379ed03"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce #(sort (if (sequential? %2)\n             (concat %1 (my-flatten %2))\n             (cons %2 %1))) '() coll)\n  )","user":"5630fd6fe4b0bfe05bf1178b"},{"problem":28,"code":"(fn flattenSeq [s] (if (coll? s) (mapcat flattenSeq s) [s]) )","user":"5b32571ee4b025bcb146f318"},{"code":"(fn myflat [x]\n                (cond\n                 (empty? x) ()\n                 (coll? (first x)) (concat (myflat (first x)) (myflat (rest x)))\n                 :else (cons (first x) (myflat (rest x)))))","problem":28,"user":"4f524d11e4b03ad3f0c10d34"},{"problem":28,"code":"(fn fltn\n  [xs]\n  (let [acc (reduce\n             (fn [acc x]\n               (if (or (seq? x) (coll? x))\n                 (apply conj acc x)\n                 (conj acc x)))\n             []\n             xs)]\n    (if (some #(or (seq? %) (coll? %)) acc)\n      (fltn acc)\n      acc)))","user":"5be1c6c6e4b0ed4b8aab4ca5"},{"code":"(fn flat [coll]\n  (cond \n    (empty? coll)\n      []\n    (sequential? (first coll))\n      (into (flat (first coll)) (flat (rest coll)))\n    :else\n      (into [(first coll)] (flat (rest coll)))))","problem":28,"user":"4eda7cc3535d10e5ff6f530e"},{"problem":28,"code":"(fn new-flatten2 [x]\n  (if (coll? x)\n    (mapcat new-flatten2 x)\n    [x]))","user":"5d0859fbe4b0cc9c91588208"},{"problem":28,"code":"(fn[coll] (remove sequential? (tree-seq sequential? seq coll)))","user":"596e4c5be4b069c0a1a19864"},{"problem":28,"code":"(fn flat [l]\n  (cond \n  (= l '()) '()\n  (not (coll? (first l))) (cons (first l) (flat (rest l)))\n  :else (concat (flat (first l)) (flat (rest l)))))","user":"5a2b7f4ee4b09cafd31c7f4a"},{"code":"(fn flatty [x]\n  (cond (empty? x) nil\n        (coll? (first x)) (flatty (concat (first x) (rest x)))\n        :else (cons (first x) (flatty (rest x)))   \n        \n        ))","problem":28,"user":"5325cf91e4b09d4e7a9b54e8"},{"code":"(fn flat [col]\n  (if (sequential? col)\n    (mapcat flat col)\n    [col]))","problem":28,"user":"4ef4acf8535dced4c769f23c"},{"code":"(fn my-flatten [c] \n  (if (empty? c) []\n  \t(if (sequential? (first c))\n    \t(concat (my-flatten (first c)) (my-flatten (rest c)))\n    \t(cons (first c) (my-flatten (rest c))))))","problem":28,"user":"4e6f1b7a535d5021c1a89618"},{"problem":28,"code":"(fn [seq]\n  (loop [seq (reverse seq)]\n    (if (every? #(not (coll? %)) seq)\n      (reverse seq)\n      (recur (reverse (reduce (fn [ret el]\n        (if (coll? el)\n          (concat el ret)\n          (conj ret el))\n      ) (list) seq)\n    )))\n))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn foo [x] (filter #(not (sequential? %)) (tree-seq #(sequential? %) #(seq %)  x )))","problem":28,"user":"50ef3e5de4b0a78662fa2652"},{"problem":28,"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq (seq %))))","user":"54725331e4b094393f72dd76"},{"code":"(fn [listy]\n  (loop [lis listy\n         depth 10]\n    (if (= depth 0)\n      lis\n      (let [\n          res (apply concat (map #(if (coll? %) % (list %)) lis))\n        ]\n        (recur res (- depth 1))\n      )\n    )\n  )\n)","problem":28,"user":"508bf05ae4b0f17d83ea26aa"},{"problem":28,"code":"(fn flat [s] \n  (if s\n    (if (sequential? (first s))\n      (concat (flat (first s)) (flat (next s)))\n      (cons (first s) (flat (next s))))\n    '()))","user":"5af0ac45e4b0cc2b61a3bc56"},{"code":"(fn mf [coll]\n    (loop [[hd & tl :as all] coll acc () ]\n      (if (empty? all)\n        acc\n        (recur tl (concat acc (if (sequential? hd) (mf hd) (list hd)))))))","problem":28,"user":"50eddbc4e4b06330c1f87c4b"},{"code":"(fn fltn [s]\n(lazy-seq \n(if (empty? s) s\n(let [[x & xs] s]\n(if (coll? x)\n(concat (fltn x) (fltn xs))\n(cons x (fltn xs)))))))","problem":28,"user":"4e7f32ee535db966e863cc3a"},{"problem":28,"code":"(letfn [(myflat [a]\n  (cond (empty? a) a\n        (not (coll? (first a))) (cons (first a) (myflat (rest a)))\n        true (concat (myflat (first a)) (myflat (rest a)))))]\n  myflat)","user":"5603d21de4b0c80df0ca264f"},{"problem":28,"code":"(fn myflatten [sq]\n  (reduce (fn [a e] (if (sequential? e)\n                      (->> (myflatten e)\n                           (apply conj a))\n                      (conj a e)\n                     ))\n          [] sq))","user":"5fee18f2e4b05ac5b16ea1d2"},{"problem":28,"code":"(fn mf [f] (cond \n             (not (coll? f)) (list f)\n             (empty? f) nil\n             :default (concat (mf (first f)) (mf (rest f)))\n            )\n ) \n     ;;'(1 (2 3) 4 [5 6])))","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn flatten* [curr-seq]\n  (if (empty? curr-seq)\n    []\n    (let [elem (first curr-seq)]\n      (cond\n       (and (sequential? elem) (empty? elem)) (flatten* (rest curr-seq))\n       (and (sequential? elem)) (concat (flatten* elem) (flatten* (rest curr-seq)))\n       true (concat [elem] (flatten* (rest curr-seq)))))))","problem":28,"user":"51281b25e4b03a34742b4304"},{"code":"(fn my-flatten [x]\n    (cond\n      (nil? x)'()\n      (coll? x) (if (empty? x) '() (concat (my-flatten (first x))\n                  (my-flatten (rest x))))\n      :else (cons x [])\n    )\n  )","problem":28,"user":"534bfa81e4b084c2834f4a87"},{"problem":28,"code":"(fn f [xs]\n   (cond\n     (empty? xs) xs\n     :else\n   (let [h (first xs)\n         r (next xs)]\n   (concat\n   (if (sequential? h)\n     (f h)\n     (list h)\n     )\n   (f r)\n   )\n   )\n   ))","user":"60486e8ae4b02d28681c77db"},{"code":"(fn [x] (filter (complement sequential?)\n\t          (rest (tree-seq sequential? seq x))))","problem":28,"user":"51f629dde4b06ff1c25c52ba"},{"problem":28,"code":"(fn fl [s]\n   (loop [sl s\n          x []]\n     (if(empty? sl)\n       x\n       (if (coll? (first sl))\n         (recur (concat (vec (first sl)) (rest sl)) x)\n         (recur (rest sl) (conj x (first sl)))\n         )\n       )\n     )\n   )","user":"58d28c70e4b03c36ff7e5901"},{"problem":28,"code":"(fn my-flat [input] \n  (if (coll? input)\n    (mapcat my-flat input)\n    [input]))","user":"4e5696d0535d8a8b8723a284"},{"problem":28,"code":"(fn flatter-me [seqz]\n  (if (not (sequential? seqz)) (list seqz)\n      (mapcat flatter-me seqz)))","user":"5414b7c4e4b01498b1a719ed"},{"problem":28,"code":"(fn myflat [toflatten]\n    (reduce  \n     (fn [res item]\n       (concat res\n               (if (coll? item)\n                 (myflat item)\n                 (list item))))\n     (list)\n     toflatten))","user":"554a75c9e4b0a04f79299575"},{"problem":28,"code":"(fn mflatten [x]\n  (loop [source x dest []]\n    (if (empty? source)\n      dest\n      (if (coll? (first source))\n        (recur (rest source) (concat dest (mflatten (first source))))\n        (recur (rest source) (conj (vec dest) (first source)))))))","user":"563e022be4b0da801c4e4664"},{"code":"(fn fltn [s]\n  (if (sequential? s)\n    (mapcat fltn s)\n    (list s)))","problem":28,"user":"53219cece4b09d4e7a9b54b7"},{"code":"(fn f [coll]\n  (reduce #(if (coll? %2)\n             (->> (f %2) (concat %) vec)\n             (conj % %2))\n          [] coll))","problem":28,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn my-flatten [xs]\n  (loop [ret [], xs xs]\n    (if (empty? xs)\n      (seq ret)\n      (let [a (first xs)]\n  (if (coll? a)\n\t  (recur (apply conj ret (my-flatten a)) (rest xs))\n\t  (recur (conj ret a) (rest xs)))))))","problem":28,"user":"4e615cd2535d8ccf87e9fe58"},{"code":"(fn m [c]\n  (mapcat #(if (sequential? %)\n             (m %)\n             [%])\n          c ))","problem":28,"user":"4e778d36535d324fb2983d71"},{"code":"(fn f [coll]\n  (when-let [s (seq coll)]\n    (if (coll? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))))","problem":28,"user":"4ed9fe5f535d10e5ff6f5308"},{"code":"(fn flatn [seq-or-scalar]\n  (if (not (coll? seq-or-scalar))\n    (list seq-or-scalar)\n    (mapcat #(flatn %) seq-or-scalar)\n    )\n  )","problem":28,"user":"4e7f3891535db966e863cc3b"},{"problem":28,"code":"(fn my-flatten [[s & more]]\n  (cond (nil? s) '()\n        (sequential? s) (concat (my-flatten s) (my-flatten more))\n        :else (concat (list s) (my-flatten more))))","user":"53edb464e4b0d648e757f4c7"},{"code":"(fn flat [coll]\n  (let [l (first coll)\n        r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flat l)\n        [l])\n       (when (sequential? r)\n         (flat r)))))","problem":28,"user":"512a8ef7e4b0ff5c4bc1f99e"},{"code":"#(filter (complement sequential?)  (rest (tree-seq sequential? seq %)))","problem":28,"user":"4eef1164535d305ff5cb7f19"},{"problem":28,"code":"(fn ftn [xs]\n           (if (coll? xs)\n             (mapcat ftn xs)\n             [xs]))","user":"54f0433ce4b024c67c0cf893"},{"problem":28,"code":"#(\n     reduce (fn myflatten [collection element]\n               (if (sequential? element)\n               (reduce myflatten collection element)\n               (conj collection element)))\n               [] % )","user":"5a778224e4b013a48d399761"},{"problem":28,"code":"(fn [input]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq input))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":28,"code":"(fn [x] \n  (loop [input x flattened ()]\n    (cond\n     (sequential? (first input)) (recur (concat (first input) (rest input)) flattened)\n     (empty? input)(reverse flattened)\n      :else (recur (rest input) (cons (first input) flattened)))))","user":"559bdf16e4b066d22e731f5a"},{"code":"(fn flatten-seq [s]\n  (if (empty? s) s\n      (let [head (first s)\n            tail (rest s)]\n        (if (coll? head)\n            (concat (flatten-seq head)\n                    (flatten-seq tail))\n            (conj (flatten-seq tail) head)))))","problem":28,"user":"506a1985e4b01dc6af13f83e"},{"problem":28,"code":"(fn flatten2 [s]\n  (loop [f (first s)\n         r (rest s)\n         out []]\n    (if (nil? f)\n      out\n      (if (sequential? f)\n        (recur (first r) (rest r) (apply conj out (flatten2 f)))\n        (recur (first r) (rest r) (conj out f))\n      ))\n  ))","user":"551a64cde4b091ff45eda996"},{"problem":28,"code":"(fn [xs]\n  (filter (complement sequential?) (tree-seq sequential? seq xs)))","user":"52a8ca0fe4b0c58976d9ac36"},{"problem":28,"code":"(fn f\n  ([arr] (f arr []))\n  ([arr accum]\n   (if (empty? arr)\n     accum\n     (if (sequential? (first arr))\n       (recur (next arr) (into accum (f (first arr) [])))\n       (recur (next arr) (conj accum (first arr)))))))","user":"58b06b7ce4b0ebc645576cdc"},{"problem":28,"code":"(fn foo\n  [coll]\n  (reduce (fn [a v]\n            (if (coll? v)\n              (into a (foo v))\n              (conj a v)))\n          [] coll))","user":"60a7104be4b00e9e6653c465"},{"code":"(fn flat [c]\n  (cond\n    (coll? c)\n    (concat (flat (first c)) (flat (next c)))\n\n    (nil? c) nil\n    :else [c] ))","problem":28,"user":"50608ea0e4b07251188e4456"},{"code":"(fn flaten2 [xs]\n  (if (coll? xs)\n    (reduce \n      #(concat %1 (flaten2 %2))\n      '()\n      xs)\n    (list xs)))","problem":28,"user":"52a04f0ee4b04e0c58e87bc1"},{"problem":28,"code":"(fn f [s] (if (coll? s) (if (seq s) (concat (f (first s)) (f (rest s))) s) (list s)))","user":"4e8b5cb8535d65386fec211b"},{"problem":28,"code":"(fn zebra [coll]\n  (reduce\n   (fn [x y]\n     (concat\n      x (if (coll? y) (zebra y) (vector y))))\n   [] coll))","user":"562c15d3e4b058fa18c5a6d5"},{"code":"(fn fltn [lst]\n  (let\n    [fst (first lst)\n     rst (rest lst)]\n\n(cond\n  (empty? lst) lst\n  (sequential? fst)\n    (into\n      (fltn rst)\n      (reverse (fltn fst)))\n  :else (cons fst (fltn rst)))))","problem":28,"user":"4e356d2b535deb9a81d77f2d"},{"problem":28,"code":"(fn f[s] \n  (if (empty? s) '()\n    (if (nil? (empty (first s)))\n            (concat (list (first s)) (f (rest s)))\n            (concat (f (first s)) (f (rest s))))))","user":"54ce3790e4b057c6fda3a2ab"},{"problem":28,"code":"(fn flad [s]\n  (cond\n   (= s '()) '()\n   (or (seq? (first s))\n       (vector? (first s)))\n    (concat (flad (first s)) (flad (rest s)))\n   :else\n    (cons (first s)\n          (flad (rest s)))))","user":"58138439e4b0f478707a0611"},{"code":"(fn flatify [xs]\n  (loop [flattened [] remaining xs]\n    (if (empty? remaining)\n      flattened\n      (let [cur (first remaining)]\n           (if (coll? cur)\n             (recur (vec (concat flattened (flatify cur))) (rest remaining))\n             (recur (conj flattened cur) (rest remaining)))))))","problem":28,"user":"4fe8a1f8e4b07c9f6fd12c5f"},{"code":"(fn f [r] (mapcat #(if (coll? %) (f %) [%]) r))","problem":28,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn flatten-seq [x] (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"52a5f1e6e4b0c58976d9abf4"},{"code":"(fn flt [s]\n  (let [head (first s) tail (next s)]\n    (concat\n    \t(if(sequential? head)\n    (flt head)\n    [head])\n    (when(sequential? tail)\n    (flt tail)))))","problem":28,"user":"52161028e4b0bf4bffd29cb4"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) (tree-seq sequential? sequence x)))","user":"55bb3f89e4b01b9910ae29e2"},{"problem":28,"code":"(fn [coll]\n   (loop [icoll coll acc '()]\n     (if (sequential? (first icoll))\n       (recur (concat (first icoll) (rest icoll)) acc)\n       (if (empty? icoll) (reverse acc) (recur (rest icoll) (cons (first icoll) acc))))))","user":"53c06438e4b0c98a41f5ccb0"},{"problem":28,"code":"(fn [list]\n  (loop [l list\n         result '()]\n    (let [fi (first l)]\n    (let [re (rest l)]\n    (if (empty? l)\n      (reverse result)\n      (if (sequential? fi)\n        (recur (concat fi re) result)\n        (recur re (concat [fi] result))\n  ))))))","user":"5954cea2e4b066ee0a44af0a"},{"problem":28,"code":"(fn my-flatten [lst]\n    (if (empty? lst)\n      lst\n      (if (or (list? (first lst)) (vector? (first lst)))\n        (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n        (concat (list (first lst)) (my-flatten (rest lst))))))","user":"57f81549e4b0d3187e900918"},{"problem":28,"code":"(fn f [s]\n  (reverse\n   (reduce \n    #(if (coll? %2)\n       (into % (f %2))\n       (cons %2 %) )\n    '()\n    (seq s) )))","user":"594c1baae4b07ddc2dafae59"},{"code":"(fn [coll]\n  (if (every? (complement sequential?) coll)\n    coll\n    (recur (mapcat #(if-not (sequential? %) [%] %) coll))))","problem":28,"user":"4e89dbce535d3e98b8023283"},{"code":"(fn thingy [x]\n  (if (or (seq? x) (vector? x))\n    (reduce concat (map thingy x))\n    (list x)))","problem":28,"user":"4f5c344be4b0030a34fb2b1d"},{"problem":28,"code":"(fn _flatten\n  ([s] (_flatten s []))\n  ([s result]\n    (let [head (first s)\n          tail (rest s)]\n      (if head\n        (concat\n          result\n          (if (coll? head)\n            (_flatten head)\n            (conj result head))\n          (_flatten tail))\n        result))))","user":"542cb77ae4b0dad94371f2aa"},{"code":"(fn flat [x]\n  (if (vector? x)\n    (flat (seq x))\n    (if (seq? x)\n      (if (= x '())\n        '()\n        (concat (flat (first x)) (flat (rest x)))\n        )\n      (list x)\n      )\n    )\n  )","problem":28,"user":"52586d24e4b0cb4875a45cb0"},{"problem":28,"code":"(fn p28- [xs]\n    (if (empty? xs)\n      '()\n      (if (not (coll? (first xs)))\n        (cons (first xs) (p28- (rest xs)))\n        (concat (p28- (first xs)) (p28- (rest xs))))))","user":"551a21ece4b091ff45eda993"},{"problem":28,"code":"(fn [coll]\n  (if (some coll? coll)\n      (recur (mapcat  #(if (coll? %) % (list %)) coll))\n      coll))","user":"5478c4fee4b0c51c1f4d72c0"},{"problem":28,"code":"(fn my-flatten\n    [coll]\n    (reduce (fn [processed current]\n              (into processed \n                    (if (coll? current)\n                        (my-flatten current)\n                        [current]\n                      )\n                    )\n              )\n            []\n            coll)\n    )","user":"59fa5fe0e4b0ca45a743a35f"},{"code":"(fn ! [s]\n  (if (empty? s)\n    nil\n  \t(if (coll? (first s))\n     (! (concat (first s)(rest s)))\n     (cons (first s) (! (rest s)))\n    )\n   )\n )","problem":28,"user":"51db8244e4b0e067a9bbadc7"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (coll? coll) (mapcat my-flatten coll) [coll]))","user":"5c113df2e4b01240ff56716f"},{"problem":28,"code":"(fn my-flatten [xs]\n  (if (sequential? xs)\n    (reduce concat (map my-flatten xs))\n    (list xs)))","user":"53bd7080e4b0d9a98559a6d1"},{"problem":28,"code":"(fn flt [coll]\n      (let [l (first coll) r (next coll)]\n        (concat \n         (if (sequential? l)\n           (flt l)\n           [l])\n         (when (sequential? r)\n           (flt r)))))","user":"569d3f9ae4b0542e1f8d147a"},{"problem":28,"code":"(fn flatten2 [xs]\n  (if (coll? xs) \n    (reduce #(concat %1 (flatten2 %2)) '() xs)\n    (list xs)))","user":"58d63b99e4b03c36ff7e596b"},{"problem":28,"code":"(fn f [x]\n  (if-not (sequential? x) \n    [x]\n    (when-not (empty? x)\n      (concat\n        (f (first x)) \n        (f (rest x))))))","user":"55297a7ae4b0ffed3738f94b"},{"problem":28,"code":"(fn fl [l]\n  (if-not (seq l)\n    []\n    (let [f (first l)\n          r (rest l)]\n      (if-not\n       (sequential? f)\n       (concat [f] (fl r))\n       (concat (fl f) (fl r))\n       )\n      )\n    )\n  )","user":"55d36d3ae4b0e31453f64a64"},{"problem":28,"code":"(fn flatthis [start]\n  (loop [daseq start res []]\n    (if (seq daseq)\n      (recur (rest daseq) \n             (if (sequential? (first daseq))\n               (into res (flatthis (first daseq)))\n               (conj res (first daseq))))\n      res)))","user":"55868660e4b059ccff29b1d4"},{"code":"(fn flat [y]\n  (apply concat (map (fn [x] (if (coll? x) (flat x) (list x))) y)))","problem":28,"user":"513bb7a6e4b04402f587b77d"},{"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))\n  )\n)","problem":28,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"#(loop [r [] c %]\n  (let [[x & more] c]\n    (if (nil? x)\n      r\n      (if (sequential? x)\n        (recur r (concat x more))\n        (recur (conj r x) more)))))","problem":28,"user":"5201cf92e4b0b2e020a18f21"},{"problem":28,"code":"(fn fl [coll]\n  (lazy-seq\n    (when-let [s  (seq coll)]\n      (if (coll? (first s))\n        (concat (fl (first s)) (fl (rest s)))\n        (cons (first s) (fl (rest s)))))))","user":"58f25609e4b08e1cf3471cff"},{"code":"(  fn self [xs e]    (concat xs (if (sequential? e) (reduce self '() e )  (list e) )        )      ) '()","problem":28,"user":"52c35afce4b07a9af579238c"},{"problem":28,"code":"(fn f [x]\n  (if (coll? x)\n      (mapcat f x)\n      [x]))","user":"54c97cb3e4b045293a27f677"},{"code":"(fn [a] (read-string (str \"(\" (clojure.string/replace (str a) #\"[\\[\\]\\(\\)]\" \"\") \")\")))","problem":28,"user":"515ff4b9e4b0e2be8aa20bd9"},{"code":"(fn this [x]\n  (if (empty? x)\n    ()\n    (let [fi (first x) ri (rest x)]\n      (if (or (list? fi) (or (vector? fi) (seq? fi)))\n        (concat (this fi) (this ri))\n        (cons fi (this ri))))))","problem":28,"user":"4f418eaee4b0d7d3c9f3fce9"},{"code":"(fn my-flatten [x]\n  (if (sequential? x)\n    (mapcat my-flatten x)\n    (list x)))","problem":28,"user":"4f969a66e4b0dcca54ed6cde"},{"code":"(fn fl [x]\n  (if (coll? x)\n      (if (empty? x)\n          '()\n          (concat (fl (first x))\n                  (fl (rest x))))\n      (list x)))","problem":28,"user":"4e8338d6535db62dc21a62d3"},{"problem":28,"code":"(fn xunwrap [x]                                                               \n  (loop [elms x acc '()]                                                        \n    (if (= (count elms) 0)                                                      \n    ;; then                                                                     \n      acc                                                                       \n    ;; else                                                                     \n    (recur (rest elms)                                                          \n           (if (sequential? (first elms))                                       \n             ;; then                                                            \n             (concat acc (xunwrap (first elms)) )                               \n             ;; else                                                            \n             (concat acc (cons (first elms) '()))                               \n        )))))","user":"564cc055e4b0284900eef676"},{"code":"(fn flat [arr] (reduce #(concat % (if (sequential? %2) (flat %2) [%2])) [] arr))","problem":28,"user":"524740e7e4b05ef8e38e635d"},{"problem":28,"code":"#(reverse \n  (reduce (fn rec-flatten [acc item]\n          (if (coll? item) (reduce rec-flatten acc item)\n            (conj acc item))\n         ) '() %)\n)","user":"5b0b8d29e4b0cc2b61a3bdd7"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (coll? coll)\n  \t(apply concat (map my-flatten coll))\n    [coll]))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn flt [lst]\n  (if (not (coll? lst)) [lst]\n    (reduce concat (map flt lst))))","problem":28,"user":"51a87d28e4b08d8ec191b811"},{"code":"(fn fltn [l]\n  (mapcat (fn [ele] (if (sequential? ele) (fltn ele) [ele])) l))","problem":28,"user":"4f68c485e4b07046d9f4ef7c"},{"code":"(fn flat [col]\n  (reduce #(if (coll? %2) (concat %1 (flat %2)) (conj (into [] %1) %2)) '() col))","problem":28,"user":"4fd81472e4b0dab7d829f38e"},{"problem":28,"code":"(fn flatten-2 [col]\n  (mapcat\n    #(if (sequential? %)\n       (flatten-2 %)\n       [%])\n    col))","user":"59a080e3e4b0871e7608b837"},{"problem":28,"code":"(fn flt [coll]\n  (concat\n   (if (sequential? (first coll))\n     (flt (first coll))\n     [(first coll)])\n   (when (sequential? (next coll))\n     (flt (next coll)))))","user":"54d321b3e4b0e8a36923e602"},{"problem":28,"code":"(fn flatter [it]\r\n  (loop [here it\r\n                            there '()]\r\n                       (if (empty? here)\r\n                         (reverse there)\r\n                         (recur (rest here)\r\n                                (if (coll? (first here))\r\n                                    (concat (reverse (flatter (first here))) there)\r\n                                    (cons (first here) there))))))","user":"4ddc5d0a535d02782fcbea05"},{"code":"(fn foo[x]\n  (if (empty? x) '()\n    (if (coll? (first x))\n      (concat (foo (first x)) (foo (rest x)))\n      (concat (list (first x)) (foo(rest x))))))","problem":28,"user":"5078300de4b0fc74642bff66"},{"code":"(fn flats [coll]                                                      \n    (if (sequential? coll)                                              \n      ; (apply concat (map  can be replaced by (mapcat                  \n      (apply concat (map flats coll))                                   \n      (list coll)))","problem":28,"user":"526397f1e4b03e8d9a4a70b6"},{"problem":28,"code":"#(loop [a % r []]\n\t(if (empty? a)\n\t\tr\n\t\t(if (sequential? (first a))\n\t\t\t(recur (concat (first a) (rest a)) r)\n\t\t\t(recur (rest a) (conj r (first a))))))","user":"57ccedaae4b0c746388ab88e"},{"code":"#(reverse (loop [n (first %) r (rest %) s '()]\n  (if (nil? n) s\n    (if (coll? n)\n      (recur (first n) (concat (rest n) r) s)\n      (recur (first r) (rest r) (cons n s))))))","problem":28,"user":"4ed152d5535d44c135fd68cc"},{"problem":28,"code":"(fn fl ([] '()) ([a & r] (if (or (seq? a) (vector? a)) (apply fl (concat a r)) (list* a (apply fl r)))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn foo [x] (if (or (seq? x) (vector? x) (list? x))\n\t(if (empty? x) '() (concat (foo (first x)) (foo (rest x))))\n\t(list x)\n))","problem":28,"user":"52cc92e9e4b07d0d72b27368"},{"problem":28,"code":"(fn flatten-seq [s]\n  (let [x (first s)\n        xs (rest s)]\n    (cond\n      (empty? s) s\n      (seq? x) (concat (flatten-seq x) (flatten-seq xs))\n      (vector? x) (concat (flatten-seq (sequence x)) (flatten-seq xs))\n      :else (cons x (flatten-seq xs)))))","user":"5f63684be4b02876ed9fd012"},{"problem":28,"code":"(fn [l]\n(loop [l1 l, l2 '()]\n  (cond \n   (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n   (empty? l1) (reverse l2)\n   :else (recur (rest l1) (cons (first l1) l2))\n   \n   )\n )\n  )","user":"53e92f82e4b036ad0777e49d"},{"code":"(fn fl [l]\n  (if (empty? l)\n    l\n    (let [f (first l) r (rest l)]\n      (if (coll? f)\n        (concat (fl f) (fl r))\n        (cons f (fl r))))))","problem":28,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":28,"code":"(fn my-func [n] \n  (mapcat\n   (fn [x] \n     (if (seq? x)\n      (my-func x)\n       (if (vector? x)\n       (my-func x)\n      (list x)))\n    ) n))","user":"53a5c7ffe4b0ef122a8689c4"},{"problem":28,"code":"(fn flat [coll]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll))))","user":"555d4421e4b0a2eb076a39a8"},{"problem":28,"code":"(fn [s] (let [pred #(or (vector? %) (seq? %))]\n          (filter (complement pred) (tree-seq pred identity s))))","user":"59496129e4b07ddc2dafadd7"},{"problem":28,"code":"(fn myFlat\n ([xs] (myFlat xs []))\n ([xs acc]                  \n  (if (coll? xs)           \n     (if (empty? xs)   \n       acc                    \n       (concat (myFlat (first xs) acc) (myFlat (rest xs))))\n     (conj acc xs))))","user":"5e42ba49e4b01d43a70e8e6c"},{"problem":28,"code":"(fn flttn [coll]\n  (if (empty? coll)\n    '()\n  (let [head (first coll)\n        ]\n    (if (sequential? head)\n      (concat (flttn head) (flttn (rest coll)))\n      (cons head (flttn (rest coll)))\n      )\n    )\n  )\n  )","user":"58aa8083e4b01a0c0b232985"},{"problem":28,"code":"(fn flattener [s]\n  (reduce (fn do-flatten [c e]\n            (if (sequential? e)\n              (reduce do-flatten c e)\n              (conj c e))) [] s))","user":"604f4be1e4b0b7ec0ac60ace"},{"problem":28,"code":"(fn [s]\n    (letfn [(fl [x]\n               (mapcat ff x))\n            (ff [x]\n               (if (or (seq? x) (vector? x))\n                 (fl x)\n                 [x]))]\n      (fl s)))","user":"55ac07afe4b03311e7b7328f"},{"problem":28,"code":"(fn [lst] (reverse ((fn blah [a b] (reduce (fn [c d] (if (or (list? d) (vector? d)) (blah c d) (conj c d))) a b)) '() lst)))","user":"57758f5de4b0979f89651621"},{"problem":28,"code":"(fn f [c x] (if (coll? x) (reduce f c x) (conj c x))) []\n\n; #(remove coll? (tree-seq coll? identity %1))","user":"53ac4c6fe4b047364c04445d"},{"problem":28,"code":"(fn flat [xs]\n  (reduce\n    (fn [ys y]\n      (concat ys\n        (if (coll? y)\n          (flat y)\n          [y])))\n    () xs))","user":"59d9e66ae4b0ef0a1e9b5c60"},{"code":"(fn f [b a] (reduce  #(if(coll? %2) \n                      (f %1 %2) \n                      (conj %1 %2)  \n                     ) b a \n            ) \n ) []","problem":28,"user":"51aeb1f4e4b09397d5109794"},{"code":"(fn f [l]\n  (if (coll? l)\n    (if (empty? l)\n      l\n      (concat (f (first l)) (f (rest l))))\n    [l]))","problem":28,"user":"50c4a354e4b0210b849018af"},{"code":"(fn [coll]\n  (filter \n   #(not (sequential? %)) \n   (rest (tree-seq sequential? seq coll ))))","problem":28,"user":"51592b81e4b0394f658fe22c"},{"problem":28,"code":"(fn flatten* [x]\n  (if (coll? x)\n    (mapcat flatten* x)\n    (list x)))","user":"59738d98e4b01722bebd4ca1"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst)\n    lst\n    (coll? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (cons (first lst) (my-flatten (rest lst))\n                ))\n  )","user":"580558cde4b0a837a8b30cc4"},{"problem":28,"code":"(partial (fn [c x & more]\n           (if x\n             (if (or (vector? x) (seq? x))\n               (recur c (first x) (concat (rest x) more))\n               (recur (conj c x) (first more) (rest more)))\n             c)) [])","user":"54f2fe9fe4b050824f58f5b8"},{"problem":28,"code":"(fn [xs] \n  (reduce (fn f [res x] \n            (if (sequential? x)\n              (reduce f res x)\n              (conj res x)\n            )) [] xs))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn doflatten [v e]\n      (if (coll? e)\n        (reduce doflatten v e)\n        (conj v e)))\n    [] coll)))","problem":28,"user":"525d413be4b0cb4875a45d65"},{"problem":28,"code":"(fn [v]\n  (letfn [(impl [s r]\n                (if (empty? s)\n                  r\n                  (let [i (first s)]\n                    (if (coll? i)\n                      (recur (concat i (rest s)) r)\n                      (recur (rest s) (conj r i))))))]\n    (impl v [])))","user":"5c50048ae4b0f9f7a8770eb9"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn flat-helper\n            [acc x]\n            (if (sequential? x)\n              (into acc (flat x))\n              (conj acc x)))\n          []\n          s))","user":"59301509e4b072a2710fcfd6"},{"code":"(fn [xs] (loop [x (first xs) xs (rest xs) result '()]\r\n            (if (coll? x)\r\n              (recur (first x) (concat (rest x) xs) result)\r\n              (if (empty? xs)\r\n                (reverse (cons x result))\r\n                (recur (first xs) (rest xs) (cons x result))))))","problem":28,"user":"4f9aa2a6e4b0dcca54ed6d0c"},{"code":"(fn fltnn[coll]\n  (let [a (first coll), b (next coll)]\n    (concat\n      (if (sequential? a)\n        (fltnn a)\n        [a]\n      )\n      (when (sequential? b)\n        (fltnn b)\n      )\n    )\n  )\n)","problem":28,"user":"5020d2aee4b0cb6ebc0a42fb"},{"code":"(fn ! [l] \n  (if (= (first l) nil) nil\n  \t(if (or (seq? (first l)) (vector? (first l))) \n    \t(concat (! (first l)) (! (rest l)))\n    \t(concat [(first l)] (! (rest l))))))","problem":28,"user":"533ee560e4b085b17e897d98"},{"code":"(fn flat [s]\n  (let [head (first s)\n        tail (rest s)]\n    (if (empty? s) s\n      (if (sequential? head)\n        (concat (flat head) (flat tail))\n        (cons head (flat tail))))))","problem":28,"user":"5119f3d5e4b06c8af0111818"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [head (first s)\n           tail (rest s)]\n       (if (sequential? head)\n         (concat (my-flatten head) (my-flatten tail))\n         (cons head (my-flatten tail)))))))","user":"5acd235ae4b0e27600da7824"},{"problem":28,"code":"(fn [args]\n         (letfn [(flat [args]\n                   (loop [hd (first args) tail (next args) acc []]\n                     (println (str \"hd\" hd))\n                     (if hd\n                       (if (coll? hd)\n                         (recur (first tail) (next tail) (concat acc (flat hd)))\n                         (recur (first tail) (next tail) (conj (vec acc) hd)))\n                       acc)))]\n           (flat args)))","user":"52e4f06be4b09f7907dd1456"},{"problem":28,"code":"(fn flatt [coll]\n  (reduce \n   (fn [result curr]\n     (if (or (vector? curr) (list? curr))  \n       (concat result (flatt curr))\n       (concat result (list curr)))) () coll ) )","user":"56e53d2fe4b02e7e935eb6bc"},{"problem":28,"code":"#(reverse ((fn fltn\n              [seq x]\n              (if (sequential? x)\n                (reduce fltn seq x)\n                (conj seq x))) '() %))","user":"5c6d0e51e4b0fca0c1622735"},{"code":"(fn flatify [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4ff3e771e4b0678c553fc356"},{"code":"(fn myflat [inlist]\n  (if (empty? inlist)\n    inlist\n    (if (or (seq? (first inlist)) (vector? (first inlist)))\n      (myflat (concat (first inlist) (rest inlist)))\n      (concat (list (first inlist))\n              (myflat (rest inlist))))))","problem":28,"user":"4fc50bcbe4b081705acca375"},{"problem":28,"code":"(fn f [s]\n  (cond (empty? s) s\n    \t\t(not (coll? s)) s\n        (coll? (first s)) (concat (f (first s)) (f (rest s)))\n        :else (cons (first s) (f (rest s)))))","user":"56532ff4e4b0f9d632dd846e"},{"problem":28,"code":"(fn [x]\n    (\n      (fn my-flatten\n        [x res]\n        (if (and (sequential? x) (> (count x) 0))\n          (apply concat res\n            (for [i (range (count x))]\n              (my-flatten (nth x i) res)))\n          (conj res x)))\n      x []))","user":"58d2af83e4b03c36ff7e5907"},{"code":"(fn [l]\n  (letfn [(append [seq1 seq2]\n            (seq (into (vec seq1) (vec seq2))))\n          (inner-flat [l]\n            (cond (empty? l) ()\n                  (coll? (first l)) (append (inner-flat (first l))\n                                    (inner-flat (rest l)))\n                  :else (append (list (first l))\n                                (inner-flat (rest l)))))]\n    (inner-flat l)))","problem":28,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn flatten2 [coll]\n  (reduce (fn [acc x]\n            (if-not (sequential? x)\n              (lazy-cat acc (list x))\n              (lazy-cat acc (flatten2 x)))) '() coll))","problem":28,"user":"51a97f7ae4b08d8ec191b827"},{"problem":28,"code":"(fn f [xs] \n    (mapcat #(if (sequential? %) (f %) (list %)) xs))","user":"55568a7de4b0deb715856e1c"},{"code":"(fn   [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e80d1c8535db62dc21a62b6"},{"code":"(fn flatfn[x]\n  (if (empty? x)\n    x\n    (if (sequential? (first x))\n      (concat (flatfn (first x)) (flatfn (rest x)))\n      (cons  (first x) (flatfn (rest x))))))","problem":28,"user":"4f891abde4b033992c121c77"},{"problem":28,"code":"(fn [stuff]\n  (seq\n   (reduce\n    (fn my-flat [v e]\n      (if (coll? e)\n        (reduce my-flat v e)\n        (conj v e)))\n    [] stuff)))","user":"5a47423be4b05d388ecb6b52"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce\n    (fn [a b]\n      (if (coll? b)\n        (into a (my-flatten b))\n        (conj a b)\n        )\n      )\n    []\n    coll\n    )\n  )","user":"5aada061e4b073f17744257a"},{"problem":28,"code":"(fn my-flatten [coll]\n  (cond\n    (nil? coll) nil\n    (coll? coll) (let [[x & xs] coll]\n                   (if (coll? x)\n                     (lazy-cat (my-flatten x) (my-flatten xs))\n                     (cons x (lazy-seq (my-flatten xs)))))\n    :else [coll]))","user":"5faa75c1e4b0fa27300f3dfa"},{"problem":28,"code":"(fn [x]\n  (loop [[frt & rst :as lst] x, acc []]\n   (cond (empty? lst) acc\n         (sequential? frt) (recur (concat frt rst) acc)\n         :else (recur rst (conj acc frt)))))","user":"5d9475e4e4b0d3f9b434ad25"},{"code":"(fn f [coll]\n  (reduce (fn [acc, e]\n            (if (coll? e)\n              (into acc (f e))\n              (conj acc e))) [] coll))","problem":28,"user":"4dada426c9a9d6ed2a99dc57"},{"problem":28,"code":"(fn [s]\n      (letfn [(blah [x y]\n                (cond (not (sequential? y)) (conj x y)\n                      (empty? y) x\n                      (sequential? (first y)) (reduce blah (reduce blah x (first y)) (rest y))\n                      :else (reduce blah (conj x (first y)) (rest y))))]\n        (reduce blah [] s)))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn flat [s]\n  (let [a (first s) l (rest s)]\n    (cond\n     (nil? a) (list)\n     (not (coll? a)) (cons a (flat l))\n     :else (concat (flat a) (flat l)))))","problem":28,"user":"5250779ee4b0541d1855b82f"},{"problem":28,"code":"(fn flat[x]\n   (if (coll? x)  \n       (if (not(empty? x)) (concat (flat (first x)) (flat (rest x))))\n       (if (not(nil? x))  (conj '() x))\n       )\n  )","user":"5dbb5200e4b09f47823971a9"},{"problem":28,"code":"(fn [input]\n    (let [fltn\n          (fn fltn [a]\n            (reduce #(into %1 (if (coll? %2) (reverse (fltn %2)) (list %2))) '() a))]\n      (reverse (fltn input))\n      )\n    )","user":"529e8ba9e4b04e0c58e87b99"},{"code":"(fn f [c]\n    (when-let [s  (seq c)]\n      (if (coll? (first s))\n        (concat (f (first s)) (f (rest s)))\n        (cons (first s) (f (rest s))))))","problem":28,"user":"507ef25ce4b0f753b6f9788e"},{"problem":28,"code":"(fn flatn[x]\n  (let [f (first x)]\n    (if (= 0 (count x))\n      '()\n      (if (sequential? f)\n        (concat (flatn f) (flatn (rest x)))\n        (cons f (flatn (rest x)))))))","user":"544b9df2e4b0e39780006968"},{"problem":28,"code":"(fn [t]\n  (filter #(not (sequential? %)) (tree-seq sequential? identity t)))","user":"54c611d1e4b045293a27f627"},{"code":"(fn ften [xs] (reduce #(concat %1 (if (sequential? %2) (ften %2) (list %2))) () xs))","problem":28,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [coll]\n  (let [f (fn flatten-it [coll]\n    (reduce (fn [new-coll e]\n      (if (coll? e)\n        (into new-coll (reverse (flatten-it e)))\n        (cons e new-coll))) \n      () coll))]\n    (reverse (f coll))))","problem":28,"user":"4f036c4b535dcb61093f6ab9"},{"problem":28,"code":"(fn fun [dataList]\n  (loop [xList dataList\n        result '()]    \n    (cond\n      (empty? xList) (reverse result)\n      (sequential? (first xList))\n        (recur (rest xList) (apply conj result (fun (first xList)) ) )\n      :else (recur (rest xList) (conj result (first xList)))\n    )\n  )\n)","user":"5da20e73e4b000c986472be1"},{"problem":28,"code":"(fn [x]\n  (seq\n   \t(reduce\n     (fn flat [r i]\n       (if (coll? i)\n         (reduce flat r i)\n         (conj r i)))\n    [] x)))","user":"5873dd1ce4b01531a375ea42"},{"code":"(fn flat[s]\n  (if (coll? s)\n    (reduce #(concat %1 (flat %2)) [] s)\n    [s]\n  )\n)","problem":28,"user":"4ece7617535d23f03622770c"},{"code":"#(loop\n   [xs %1 res nil]\n   (if-let [[x & more] xs]\n     (if (coll? x)\n       (recur (concat x more) res)\n       (recur more (concat res [x]))\n       )\n     res\n     )\n   )","problem":28,"user":"5298d3f4e4b02ebb4ef75068"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (if (nil? x) \n    []\n    (concat (if (coll? x) (flat x) [x]) (flat xs))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":28,"code":"(fn [s]\n  ((fn inner [rs acc]\n    (if (empty? rs)\n      acc\n      (let [head (first rs)\n            tail (rest rs)]\n        (if (coll? head)\n          (inner tail (inner head acc))\n          (inner tail (concat acc (vector head)))\n          ))))\n  s []))","user":"53c1ce3ee4b00fb29b221268"},{"code":"reduce \n (fn self [xs e]\n   (concat xs\n     (cond (coll? e) (reduce self '() e)\n           :else (list e))))\n'()","problem":28,"user":"50868795e4b004985b776e5e"},{"problem":28,"code":"(fn flat [x] \n  (cond \n   (and (coll? x) (empty? x)) x\n   (coll? x)   (concat (flat (first x)) (flat (rest x)))\n   :else           (list x)\n   ))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":28,"code":"(fn flatten3 [x]\n  (if (sequential? x)\n     (mapcat\n       #(if (sequential? %) (flatten3 %) [%])\n      x)\n    ()))","user":"55aa7c5ce4b0988bba2ad94d"},{"problem":28,"code":"(fn [ss]\n   ((fn foo [h t acc]\n      (if (nil? h)\n        acc\n        (if (coll? h)\n          (foo (first t) (rest t) (foo (first h) (rest h) acc))\n          (foo (first t) (rest t) (conj acc h))))) (first ss) (rest ss) []))","user":"5679a4d0e4b05957ce8c618d"},{"problem":28,"code":"(fn my-flatten [s]\n  (if-not (coll? s)\n    [s]\n    (let [[x & rest] s]\n      (if (empty? rest)\n        (my-flatten x)\n        (concat (my-flatten x) (my-flatten rest))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn flttn\n    [l]\n    (if-let [h (first l)]\n      (concat (if (coll? h) (flttn h) (list h)) (flttn (rest l)))\n      '()))","problem":28,"user":"4fc8c8d8e4b0ee37620e183b"},{"problem":28,"code":"(fn tovec [s]\n  ((fn inner [r res]\n    (if (empty? r)\n      res\n      (recur \n       (rest r)\n       (if (coll? (first r))\n         (inner (first r) res)\n         (conj res (first r)))))) s []))","user":"573f3ccfe4b05c31a32c083f"},{"problem":28,"code":"(fn flt\n  [coll]\n  (if (coll? coll)\n      (mapcat flt coll)\n      [coll]))","user":"5a5be4a6e4b0512ff01cd910"},{"problem":28,"code":"(fn f [[fst & rst :as c]]\n  (when (seq c)\n    (if (coll? fst)\n      (concat (f fst) (f rst))\n      (cons fst (f rst)))))","user":"4db863d7535d1e037afb2190"},{"code":"(fn fl [l] (if (or (seq? l) (vector? l)) (apply concat (map fl l)) (list l)))","problem":28,"user":"52bb27fee4b07a9af57922df"},{"code":"(fn fltn [coll]\n  (reduce\n    (fn [acc e]\n      (if (sequential? e)\n(concat acc (fltn e))\n(concat acc (list e))))\n'()\ncoll))","problem":28,"user":"4f9fb08ae4b0dcca54ed6d3c"},{"problem":28,"code":"(fn my-flatten [xs]\n       (reduce (fn [acc v]\n                 (concat\n                   acc\n                   (if (coll? v)\n                     (my-flatten v)\n                     [v])\n                   )\n                 )\n               []\n               xs)\n       )","user":"5a55114ae4b05d388ecb6c37"},{"code":"(fn flttn [s]\n  (if (sequential? s)\n    (mapcat flttn s)\n    (list s)))","problem":28,"user":"52e0e646e4b09f7907dd1416"},{"problem":28,"code":"(fn my-flatten                                                                \n  ([x] (if (not (or (seq? x) (vector? x)))                                      \n           [x]                        ; If x is not a sequence nor a vector        \n           (mapcat my-flatten x))))   ; else recursively apply the functio","user":"534aa5d3e4b084c2834f4a6b"},{"code":"(fn flat [coll] (if (coll? coll) (mapcat flat coll) (vector coll)))","problem":28,"user":"5225666be4b01819a2de4300"},{"problem":28,"code":"(fn flattn \n  [xs]\n  (letfn \n    [(flatten-one\n      \t[xs]\n      \t(reduce #(concat %1 (if (coll? %2) %2 (list %2))) '() xs))]\n      (flatten-one (map #(if (coll? %) (flattn %) %) xs))))","user":"5df4cb3be4b03c219ef1a381"},{"code":"(fn [x] \n  (let [s? #(instance? clojure.lang.Sequential %)] \n    (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4fe49706e4b0e8f79898feb7"},{"problem":28,"code":"(fn [x] (filter (complement coll?) (tree-seq coll? seq x) ))","user":"5bc2df19e4b07a9b28b10038"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (if (not (sequential? coll))\n    [coll]\n    (mapcat my-flatten coll)))","user":"4ea8570f535d7eef308072f8"},{"problem":28,"code":"(fn f [r x] (if (coll? x) (reduce f r x) (conj r x))) []","user":"5632e850e4b0bfe05bf117ac"},{"problem":28,"code":"(fn flatten' [coll]\n   (mapcat #(if (coll? %) \n              (flatten' %)\n              [%]) coll))","user":"57a8eba2e4b0a96607956225"},{"code":"(fn mkflat [xs]\r\n  (filter (complement sequential?)\r\n    (tree-seq sequential? seq xs)))","problem":28,"user":"4e123905535d04ed9115e7ce"},{"problem":28,"code":"(fn myFlat [x]\n  (if (coll? x)\n    (reduce concat(map myFlat x))\n    [x]\n    ))","user":"5b7d1dc1e4b047b03b20373f"},{"code":"(fn me [xs]\n  (cond\n   (coll? (first xs)) (concat (me (first xs)) (me (rest xs)))\n   (= (next xs) nil) xs\n   :else (cons (first xs) (me (rest xs)))))","problem":28,"user":"51ef66a7e4b0871fa145d9a5"},{"code":"(fn fl[x]\n  (if (sequential? x)\n    (mapcat fl x)\n    [x]))","problem":28,"user":"52bc6cb2e4b07a9af57922f5"},{"problem":28,"code":"(fn my-flatten\n             [s]\n             (cond\n               (or (list? s) (vector? s)) (->> s\n                                               (map my-flatten)\n                                               (apply concat))\n               :else (list s)))","user":"5eb22708e4b00a66d4a95204"},{"problem":28,"code":"(fn [x]\n  (filter\n   (complement sequential?)\n   (rest (tree-seq sequential? seq x))))","user":"55a1683ce4b0acc240e31513"},{"problem":28,"code":"(fn make-flat \n  ([l]\n   (if (sequential? l)\n    (reverse (make-flat l '()))\n    l))\n  ([l acc]\n   (println \"l \" l \" acc \" acc)\n   (if (empty? l)\n     acc\n     (if (sequential? (first l)) \n       (make-flat (rest l) (make-flat (first l) acc))\n       (make-flat (rest l) (conj acc (first l)))))))","user":"55623feae4b0c656e3ff17d4"},{"problem":28,"code":"(fn  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5b8ec146e4b0c0b3ffbd49f0"},{"code":"(fn flt [xxs]\n  (if (sequential? xxs)\n    (if (empty? xxs)\n      []\n      (concat (flt (first xxs)) (flt (rest xxs))))\n    [xxs]))","problem":28,"user":"5180c69ae4b06b8caf33fa00"},{"problem":28,"code":"(fn x [arr]\n  (let [l (first arr) r (next arr)]\n    (concat\n      (if (sequential? l)\n        (x l)\n        [l])\n      (when (sequential? r)\n        (x r)))))","user":"5469e7cce4b00cfc9eacc14c"},{"problem":28,"code":"(fn flat [xs] (cond\n               (empty? xs) []\n               (coll? (first xs)) (concat (flat (first xs)) (flat (rest xs)))\n               :else (cons (first xs) (flat (rest xs)))))","user":"563c7f98e4b0bfe05bf11836"},{"problem":28,"code":"(fn foo [data]\n    (cond\n      (empty? data) nil\n      (coll? (first data)) (concat (foo (first data)) (foo (rest data)))\n      :else (concat (list (first data)) (foo (rest data)))\n    )\n)","user":"5ff214e7e4b05ac5b16ea1fa"},{"problem":28,"code":"(fn f [a]\n                  (cond\n                    (empty? a) ()\n                    (sequential? (first a)) (concat (f (first a)) (f (rest a)))\n                    :else (cons (first a) (f (rest a)))))","user":"55274467e4b0ffed3738f92b"},{"problem":28,"code":"(fn flat [s] (loop [n 0 ret []] (if (>= n (count s)) ret (let [e (nth s n) nex (+ n 1)] (if (or (map? e) (set? e) (list? e) (vector? e)) (recur nex (into ret (flat e))) (recur nex (conj ret e)))))))","user":"59468de7e4b07ddc2dafad88"},{"problem":28,"code":"(fn my-flatten [s]\n  (when-not (empty? s)\n    (if-not (sequential? (first s))\n      (cons (first s) (my-flatten (rest s)))\n      (concat (my-flatten (first s)) (my-flatten (rest s))))))","user":"547884d7e4b0c51c1f4d72bd"},{"problem":28,"code":"(fn my-flatten [i] (mapcat #((if (coll? %) my-flatten list) %) i))","user":"5b0948f3e4b0cc2b61a3bdbb"},{"problem":28,"code":"(fn flat [n]\n  (cond (not (coll? n)) [n]\n        (empty? n) []\n        :else (concat (flat (first n)) (flat (rest n)))))","user":"57131a8ee4b07c98581c3a97"},{"problem":28,"code":"(fn flat [r x]\n   (if (seq x)\n     (let [e (first x)\n           el (if (or (seq? e) (vector? e))\n                 (flat [] e)\n                 [e])]\n       (flat (concat r el) (rest x)))\n     r)) []","user":"577c12dfe4b0d3393e5deb2f"},{"code":"(fn flat [l]\n  (if (empty? l)\n    '()\n    (let [hd (first l), tl (rest l)]\n      (if (sequential? hd)\n        (concat (flat hd) (flat tl))\n        (conj (flat tl) hd)))))","problem":28,"user":"4de165f3535d08e6dec9fde6"},{"code":"(fn [xs] (filter (comp not coll?) (tree-seq coll? identity xs)))","problem":28,"user":"51db27dbe4b094966a2cd688"},{"problem":28,"code":"(fn flat [xs]\n  (if (sequential? xs)\n    (apply concat (map flat xs))\n    (list xs)))","user":"4f2861eee4b0d6649770a017"},{"code":"#(loop [head (first %) others (rest %) ans []]\n \t(if (nil? head)\n \t\tans\n \t\t(recur\n \t\t\t(if (coll? head) (first head) (first others))\n \t\t\t(if (coll? head) (into (vec (rest head)) others) (rest others))\n \t\t\t(if (coll? head) ans (conj ans head)))))","problem":28,"user":"50fe91c1e4b03cd852b4e84e"},{"problem":28,"code":"(fn walk [d s]\n  (if (= nil s)\n    d\n    (if (or (seq? (first s)) (vector? (first s)))\n      (walk (walk d (first s)) (next s))\n      (walk (conj d (first s)) (next s))\n    )\n  )\n)\n[]","user":"5b5b0bb9e4b0c6492753e6a5"},{"problem":28,"code":"(fn tes [v e]\n    (if (coll? e)\n      (reduce tes v e)\n      (conj v e))) []","user":"5b47a4f7e4b02d533a91bc73"},{"code":"(fn [a] (loop [t a]  \n           (if (empty? (for [x t :when (coll? x)] x))\n            t\n            (recur (reduce concat (for [x t] (if(coll? x) x (list x)))))\n           )\n         )\n)","problem":28,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn [coll]\n  (loop [coll coll, acc []]\n    (if (seq coll)\n      (if (coll? (first coll))\n        (recur (concat (first coll) (rest coll))\n               acc)\n        (recur (rest coll)\n               (conj acc (first coll))))\n      acc)))","problem":28,"user":"4fc6e1a8e4b0ee37620e181d"},{"problem":28,"code":"(fn flan [coll]\n   (loop [acc [] rem coll]\n   (if (= [] rem)\n     acc\n     (recur (concat acc ((if (coll? (first rem)) flan list) (first rem)))\n            (rest rem)))))","user":"5080d6e3e4b01a93d3f38e4b"},{"problem":28,"code":"(fn myFlatten\n  [items]\n  (if (coll? items)\n  \t(mapcat myFlatten items)\n    [items]))","user":"566f7749e4b0a866af6896e9"},{"problem":28,"code":"(fn \n  [subject]\n  (loop [l subject]\n    (if-not (some coll? l)\n      l\n      (recur (reduce #(into %1 (if (coll? %2) %2 (vector %2))) [] l)))))","user":"6086abade4b0736b099e42ff"},{"problem":28,"code":"(fn fltn [x]\n (if (sequential? x)\n  (apply concat (map fltn x))\n  [x])\n)","user":"549a999be4b0f3d1d8e70f6f"},{"code":"(fn [x]\n  (filter (complement sequential?)\n           (tree-seq sequential? seq x)))","problem":28,"user":"4f63777be4b0defedf855fe4"},{"problem":28,"code":"(fn flt [coll]   \n   (let [cur (first coll) nxt (next coll)]\n     (concat\n      (if (coll? cur)\n        (flt cur)\n        [cur]        \n        )\n      (if (not (nil? nxt))\n        (flt nxt)\n        )\n      )\n     )\n   )","user":"56f45469e4b046a417f9205c"},{"problem":28,"code":"(fn flt [x]\n  (if (sequential? x)\n    (mapcat flt x)\n    [x]))","user":"549dd591e4b0f3d1d8e70f98"},{"code":"(fn f[x](if (sequential? x) (mapcat f x)[x]))","problem":28,"user":"4f29651ce4b0d6649770a028"},{"problem":28,"code":"(fn [xs] (remove coll? (tree-seq coll? seq xs)))","user":"5601bb7ee4b04bb52996e195"},{"problem":28,"code":"(fn flaatn [lst]\n      (if\n        (coll? lst)\n        (apply concat\n           (map flaatn lst))\n        [lst]))","user":"54961073e4b0b312c081ff62"},{"problem":28,"code":"(fn flattenr [lst]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq lst)))","user":"5f6b5d83e4b02876ed9fd050"},{"problem":28,"code":"#((fn extract [init plus]\n  (if (not (coll? plus))\n\t(conj init plus)\n\t(into [] (concat init (loop [i 0 rez []]\n\t (if (>= i (count plus))\n\t  rez\n\t  (recur (inc i) (extract rez (nth plus i)))\n\t )\n\t)))\n)) [] %)","user":"59135c11e4b0163c97b36f02"},{"problem":28,"code":"(fn my-flatten [lst]\n  (mapcat #(if (coll? %) (my-flatten %) (list %)) lst))","user":"53d2afede4b00fb29b221321"},{"problem":28,"code":"(fn[s]\n\n  (loop [remaining s\n         l2 '()]\n    (cond\n      (sequential? (first remaining))  (recur (concat (first remaining) (rest remaining)) l2)\n      (empty? remaining) (reverse l2)\n      :else (recur (rest remaining) (cons (first remaining) l2)))))","user":"53d10553e4b00fb29b22130f"},{"problem":28,"code":"(fn\n  [l]\n  (loop [\n          l l\n          acc []]\n    (let [f (first l)\n          r (rest l)]\n      (if (not f)\n        acc\n        (if (sequential? f)\n          (recur (concat f r) acc)\n          (recur r (conj acc f))\n          )\n        )\n      )\n    )\n  )","user":"55923ef7e4b0604b3f94d58a"},{"problem":28,"code":"(fn [x]\n  (loop [x (seq x) y '()]\n    (if (empty? x)\n      (reverse y)\n      (let [z (first x)]\n        (if (coll? z)\n          (recur (concat z (rest x)) y)\n          (recur (rest x) (cons z y))\n          )\n        )\n      )\n    )\n  )","user":"54f3e216e4b050824f58f5cc"},{"code":"(fn f [x]\n  (if (sequential? x)\n    (reduce #(concat %1 (f %2)) '() x)\n    [x]))","problem":28,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":28,"code":"(fn shitty-flatten [l]\n   (loop [[h & t] l nl []]\n     (let [flat-head (if (coll? h) (shitty-flatten h) [h])\n           nls (into nl flat-head)]\n       (if (empty? t) nls (recur t nls)))))","user":"58791973e4b01531a375eac5"},{"problem":28,"code":"(fn [coll]\n   (loop [[item & remaining] coll\n          result '()]\n     (if (sequential? item)\n       (recur (cons (first item) (concat (rest item) remaining)) result)\n       (if (empty? remaining)\n         (reverse (conj result item))\n         (recur remaining (conj result item))))))","user":"55c37594e4b0e31453f64989"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))));; from core :D but tree-seq is defenitely worth a lookup in the clojure source","user":"57a9e274e4b0b8559636fc5d"},{"problem":28,"code":"(fn fltn [coll-all]\n  (reduce (fn [coll el]\n            (if (coll? el)\n              (into coll (fltn el))\n              (conj coll el)))\n          []\n          coll-all))","user":"550f1e51e4b06e50f9beb172"},{"code":"(fn m [s] \n  (#(filter (complement sequential?) (rest (tree-seq sequential? seq s)))))","problem":28,"user":"50a2cd3be4b048eb8059339d"},{"problem":28,"code":"(fn flat[xs]\n  (let [x (first xs) y (next xs)]\n  (concat\n    (if (coll? x) (flat x) [x]) \n\t(when (coll? y) (flat y)))))","user":"5409a12fe4b0addc1aec66df"},{"problem":28,"code":"(fn flatten' [seq]\n  (if (sequential? seq)\n    (reduce concat (map flatten' seq))\n    (list seq)))","user":"569bda8ee4b0542e1f8d145a"},{"problem":28,"code":"(fn flaty [sq]\n  (if (not (sequential? sq)) (conj [] sq) (if (= 0 (count sq)) [] (into (flaty (first sq)) (flaty (rest sq))))))","user":"5c76577ae4b0fca0c16227ea"},{"problem":28,"code":"(fn flatn [coll]\n    (if (empty? coll)\n      '()\n      (if (coll? (first coll))\n        (concat (flatn (first coll)) (flatn (rest coll)))\n        (cons (first coll) (flatn (rest coll))))))","user":"529e3258e4b04e0c58e87b8d"},{"code":"(fn flattener [s]\n  (if (sequential? s)\n    (mapcat flattener s)\n    (vector s)\n    )\n  )","problem":28,"user":"537a620be4b06839e8705e5f"},{"problem":28,"code":"(fn [s]\n  (reduce (fn myflatten [collection element]\n            (if (sequential? element)\n              (reduce myflatten collection element)\n              (conj collection element))) [] s)) ; had to lookup","user":"5ff32e20e4b05ac5b16ea1ff"},{"code":"(fn myflatten [arr]\n  (let [t (type arr)]\n    (cond\n     (and (not= t clojure.lang.PersistentList) (not= t clojure.lang.PersistentVector)) [arr]\n     :else\n     \t(reduce (fn [x y] (concat x (myflatten y))) '() arr)\n     )))","problem":28,"user":"52c8a8b9e4b0c2d177d62139"},{"problem":28,"code":"(fn [xs] \n    (->> (tree-seq sequential? identity xs)\n         (filter (complement sequential?))))","user":"5dd52ca6e4b0948ae9d9ad75"},{"code":"#(loop [x % acc []]\r\n  (if-not (empty? x)\r\n    (if-not (sequential? (first x))\r\n      (recur (rest x) (conj acc (first x)))\r\n      (recur (rest x) (into acc (loop [y x acc []]\r\n                                  (if-not (empty? y)\r\n                                    (let [z (first y)]\r\n                                      (if (sequential? z)\r\n                                        (recur z acc)\r\n                                        (do\r\n                                          (recur (rest y) (conj acc z)))))\r\n                                    acc)))))\r\n    acc))","problem":28,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":28,"code":"#((fn flat [xs acc]\n       (let [x (first xs)]\n         (cond\n           (empty? xs) acc\n           (coll? x) (recur (rest xs) (flat x acc))\n           :else (recur (rest xs) (conj acc x))))) % [])","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn f [to i] \n\t(if-not (coll? i) \n       \t(conj to i)\n   \t\t(reduce f to i)\n\t)\n) []","problem":28,"user":"513d09cbe4b0b86ece9f322e"},{"problem":28,"code":"(fn flt [s]\n  (if (coll? s)\n    (if (empty? s)\n      []\n      (concat (flt (first s)) (flt (rest s))))\n   \t[s]))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn [lst]\n  (filter (complement sequential?) (tree-seq sequential? seq lst)))","problem":28,"user":"52cee992e4b07d0d72b27395"},{"problem":28,"code":"(fn tree-seq\n   [root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                       (when (sequential? node)\n                         (mapcat walk (seq node))))))\n         r (walk root)\n         f (filter (complement sequential?) r)]\n     f))","user":"5a8e9a7ae4b05369db4d2528"},{"problem":28,"code":"(fn flatn [xs]\n    (if (and (coll? xs) (seq xs)) (mapcat flatn xs) (list xs)))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":28,"code":"(fn collect \n  [lst] \n  (if(coll? lst)\n     (if (empty? lst)\n       []\n       (concat (collect (first lst)) (collect (rest lst))))\n     [lst]))","user":"5c787131e4b0fca0c1622825"},{"code":"(fn flat [s] \n  (cond \n   (empty? s) '()\n   (coll? (first s)) (concat (flat (first s)) (flat(rest s)))\n   :else (cons (first s) (flat (rest s)))\n   )\n  )","problem":28,"user":"535197f2e4b084c2834f4ae4"},{"problem":28,"code":"(fn flat [xs]\n  (reduce\n   (fn [acc x]\n     (if (coll? x)\n       (into acc (flat x))\n       (conj acc x)))\n   []\n   xs))","user":"5cd1f5dae4b0ccb0619628f7"},{"problem":28,"code":"(fn flt  [l]\n  \t(if (seq l)\n    (let [f (first l) r (rest l)]\n      (if (sequential? f)\n        (concat (flt f) (flt r))\n        (conj (flt r) f)))\n    '()))","user":"55f04526e4b06e875b46ce20"},{"code":"(fn flatt [list]\r\n  (let [[first & rest] list]\r\n    (concat\r\n      (if (sequential? first) (flatt first) [first])\r\n      \r\n      (when (sequential? rest) (flatt rest)))))","problem":28,"user":"4dfd7ecf535d04ed9115e783"},{"code":"(fn flat [xs]\n  (if (empty? xs)\n    xs\n    (let [x (first xs)]\n      (if (sequential? x)\n        (concat (flat x) (flat (rest xs)))\n        (cons x (flat (rest xs)))))))","problem":28,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn my-flatten\n  [coll]\n  (let [flatten-coll (seq (reduce #(if (coll? %2)\n                                      (apply conj % %2)\n                                      (conj % %2))\n                                  []\n                                  coll))]\n    (if (= coll flatten-coll)\n      coll\n      (my-flatten flatten-coll))))","problem":28,"user":"5028cd0fe4b01614d1633ffc"},{"problem":28,"code":"(fn my-flatten [c]\n  (if (empty? c)\n    '()\n    (if (coll? (first c))\n      (concat (my-flatten (first c)) (my-flatten (rest c)))\n      (concat (list (first c)) (my-flatten (rest c))))))","user":"5edfb1e5e4b0c7845d86b107"},{"code":"(fn flat-e\n  [x]\n  (cond\n    (not (sequential? x)) (list x)\n    (empty? x) '()\n    :else (concat (flat-e (first x)) (flat-e (rest x)))))","problem":28,"user":"52084f75e4b01ce6bbf31dde"},{"code":"(fn [xs] \n  (remove coll? (tree-seq coll? seq xs)))","problem":28,"user":"50ef4e2be4b0a78662fa2653"},{"problem":28,"code":"(fn [seqq]\n  (letfn [(my-func [x y] \n\t(if (coll? y) \n\t\t(concat (reduce my-func [] y) x)\n\t\t(cons y x)))]\n    (reverse (my-func [] seqq))))","user":"5447e08ce4b032a45b8693c3"},{"problem":28,"code":"(fn [s]\n  (loop [[f & r] s sofar []]\n    (if-not f\n      sofar\n      (if (sequential? f)\n        (recur (concat f r) sofar)\n        (recur r (conj sofar f)))\n      )\n    )\n  )","user":"57afd36de4b0fbc9809a273c"},{"problem":28,"code":"(fn [vars]\n    (seq \n     (reduce \n      (fn my-flatten [k v]\n        (if (coll? v)\n          (reduce my-flatten k v)\n          (conj k v)))\n      [] vars)))","user":"53e73fe3e4b036ad0777e478"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (and (not (list? f)) (not (vector? f))) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"5c5e7049e4b0fca0c1622607"},{"code":"(fn mf [ls]\n  (cond (not (coll? ls)) (list ls)\n        (empty? ls) ls\n        (coll? ls) (concat (mf (first ls))\n                          (mf (rest ls)))))","problem":28,"user":"4ff769bce4b0678c553fc38f"},{"code":"#(reverse (reduce (fn f [s x] (if (sequential? x) (reduce f s x) (conj s x))) () %))","problem":28,"user":"4e9b230c535dbda64a6f6b75"},{"code":"(fn flat [n]\r\n  (let [[x & xs] n]\r\n    (cond\r\n      (empty? n) \r\n        '()\r\n      (coll? x) \r\n        (concat (flat x) (flat xs))\r\n      :else \r\n        (cons x (flat xs))\r\n    )\r\n  )\r\n)","problem":28,"user":"4e570f47535d8a8b8723a287"},{"code":"(fn flatt [coll]\n  (let [g (first coll) \n        d (next coll)]\n    (concat \n     (if (sequential? g)\n       (flatt g)\n       [g] )\n     (when (sequential? d)\n     \t(flatt d))\n     )\n    )\n  )","problem":28,"user":"51126a28e4b0350614f07a74"},{"problem":28,"code":"(fn\n  [tree]\n  (filter\n    (complement sequential?)\n    (rest\n      (tree-seq sequential? seq tree))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn flatus\n  ([x]      (if (sequential? x) (apply flatus x) (list x)))\n  ([x & xs] (concat (flatus x) (flatus xs))))","problem":28,"user":"4f4ff836e4b03ad3f0c10cf4"},{"code":"(fn f [s]\n  (cond (empty? s) s\n        (sequential? (first s)) (concat (f (first s)) (f (rest s)))\n        :else (cons (first s) (f (rest s)))))","problem":28,"user":"506ef8c3e4b09350ab4199f4"},{"code":"(fn a [c] (reduce #(if (coll?  %2) (apply conj %1 (a %2)) (conj %1 %2)) [] c))","problem":28,"user":"4e6fa38b535d5021c1a89622"},{"code":"#(filter\r\n  (complement sequential?)\r\n  (rest\r\n    (tree-seq sequential? seq %)\r\n  )   \r\n)","problem":28,"user":"4f85a75ce4b033992c121c48"},{"problem":28,"code":"(fn [x]\n  (filter\n   (complement\n    sequential?)\n   (rest\n    (tree-seq\n     sequential?\n     seq\n     x))))","user":"59639142e4b066ee0a44b0ce"},{"problem":28,"code":"(fn flat [c]\n  (loop [col c result []]\n    (if (empty? col)\n      result\n      (if (coll? (first col))\n        (recur (rest col) (into result (flat (first col))))\n        (recur (rest col) (conj result (first col) ))\n))))","user":"57e396cde4b0bfb2137f5a9e"},{"problem":28,"code":"(fn f [xss]\n   (if (empty? xss)\n     xss\n     (if (sequential? (first xss))\n     (concat (f (first xss)) (f (rest xss)))\n     (cons (first xss) (f (rest xss))))\n   ))","user":"5e98e338e4b0157ca96647db"},{"problem":28,"code":"(fn [zeq] (filter (complement sequential?) (rest (tree-seq sequential? seq zeq))))","user":"5ea97df7e4b00a66d4a951c8"},{"code":"(fn my-flat [x]\n  (mapcat\n    #(if (sequential? %1)\n       (my-flat %1)\n       [%1]\n     ) \n    x))","problem":28,"user":"52af7a5ce4b0c58976d9acbd"},{"code":"(fn flatn [sq]\r\n  (cond\r\n    (or (string? sq) (number? sq) (keyword? sq))\r\n      [sq]\r\n    (empty? sq)\r\n      []\r\n    :else\r\n      (concat (flatn (first sq)) (flatn (rest sq)))))","problem":28,"user":"4ee40938535d10e5ff6f5375"},{"problem":28,"code":"(fn flt [s]\n  (if-not (coll? s)\n    [s]\n    (mapcat flt s)))","user":"54f8aabfe4b01ecee9d8882b"},{"problem":28,"code":"#(loop [res []\n         inseq %]\n    (println inseq)\n    (println res)\n    (if (empty? inseq)\n        res\n      (recur\n        (if (and (sequential? (first inseq)) (not (string? (first inseq))))\n          res\n          (conj res (first inseq)))\n        (if (and (sequential? (first inseq)) (not (string? (first inseq))))\n          (concat (first inseq) (rest inseq))\n          (rest inseq)))))","user":"5862a8a9e4b0f14aab7c880f"},{"problem":28,"code":"(fn flattenx\n\t[x]\n\t(if (sequential? x)\n\t\t(if (empty? x)\n\t\t\t'()\n\t\t\t(concat\n\t\t\t  (flattenx (first x))\n\t\t\t  (flattenx (rest x))))\n\t\t[x]))","user":"57614948e4b0994c1922fb83"},{"problem":28,"code":"(fn my-flatten [xs]\n   (if (coll? xs)\n     (mapcat my-flatten xs)\n     [xs]))","user":"56e06625e4b0ca2494a09607"},{"problem":28,"code":"(fn flatten* [x]\n  (loop [f (first x) r (rest x) result []]\n    (if (nil? f) \n      result\n      (let [result (if (sequential? f)\n                     (apply conj result (flatten* f))\n                     (conj result f))]\n        (recur (first r) (rest r) result)))))","user":"56012cd7e4b04bb52996e17d"},{"problem":28,"code":"(fn flatten' [xs]\n  (if (empty? xs) []\n    (let [head (first xs), tail (->> xs rest flatten')]\n            (if (coll? head)\n              (concat (flatten' head) tail)\n              (cons head tail)\n              ))))","user":"54d7ed8de4b0a52adc2e2034"},{"problem":28,"code":"(fn f [[h & t]]\n  (cond\n    (nil? h) ()\n    (sequential? h) (concat (f h) (f t))\n    :else (cons h (f t))))","user":"57de9169e4b0bd073c202454"},{"problem":28,"code":"(fn [s]\n  (reduce (fn f [collection element]\n            (if (sequential? element)\n              (reduce f collection element)\n              (conj collection element))) [] s))","user":"58a0ac0de4b02bd94d917e9c"},{"problem":28,"code":"(fn fl [x](reduce #(into %1 (if (sequential? %2)(fl %2)[%2])) [] x))","user":"6045e761e4b02d28681c77bb"},{"code":"mapcat (fn flat[x]\n         (if(coll? x) \n                   (mapcat flat x) \n                   (list x)))","problem":28,"user":"52d66ca0e4b09f7907dd135c"},{"problem":28,"code":"(fn flat [xs]\n  (reduce (fn [res x]\n            (concat res (if (coll? x) (flat x) (list x))))\n          '()\n          xs))","user":"59abd1d8e4b08cbb53654da4"},{"code":"(fn [lst]\n  (letfn [(my-flatten [lst]\n            (cond\n             (empty? lst) ()\n             (coll? (first lst))\n             (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n             :else\n             (cons (first lst) (my-flatten (rest lst)))))]\n    (my-flatten lst)))","problem":28,"user":"4eb6f065535d7eef30807372"},{"problem":28,"code":"(fn [x]\n  (loop [lst x result '()]\n    (if (empty? lst)\n      result\n      (if (coll? (first lst))\n        (recur (concat (first lst)(rest lst)) result)\n        (recur (rest lst) (concat result (list(first lst))))))))","user":"5936a67de4b02506e01a2982"},{"problem":28,"code":"(fn f1\n  [coll]\n  (if (sequential? coll)\n    (mapcat f1 coll)\n    (list coll)))","user":"5ff61113e4b06df49cee1492"},{"code":"(fn flttn [col]\n  (letfn [(do-flttn [res col]\n                    (let [[fst & tail] col col-fst (coll? fst) empty-tail (empty? tail)]\n                      (if col-fst \n                        (if (not empty-tail)\n                          (do-flttn (concat (do-flttn '() fst) res) tail)\n                          (do-flttn res fst))\n                        (if (not empty-tail)\n                          (do-flttn (conj res fst) tail)\n                          (conj res fst)))))]\n    (reverse (do-flttn '() col))))","problem":28,"user":"51f8e057e4b09be9c177e53d"},{"problem":28,"code":"(fn flat [[f & r :as c]]\n  (cond\n   (empty? c) '()\n   (coll? f) (concat (flat f) (flat r))\n   :else (cons f (flat r))))","user":"55fbf6cae4b0f488688e066c"},{"problem":28,"code":"(fn fltn\n  ([coll] (fltn [] coll))\n  ([acc x] \n   (if (coll? x) (reduce fltn acc x) (conj acc x))))","user":"54ecd716e4b024c67c0cf85a"},{"problem":28,"code":"(fn z [v & [c]] \n  (reduce \n    (fn [c v] (if (sequential? v) (z v c) (conj c v)))\n      (or c []) \n      v))","user":"5499e23de4b03163384f4706"},{"code":"(fn f [x]\n  (when-not (empty? x)\n    (concat (if (empty (first x))\n              (f (first x))\n              [(first x)])\n            (f (rest x)))))","problem":28,"user":"51256b40e4b05d10e3e395f8"},{"problem":28,"code":"#(loop [lst   %1]\n   (if (some coll? lst)\n     (recur (reduce (fn [x y] (if (coll? y) (concat x y) (conj x y))) [] lst))\n     (sort lst)\n     )\n   )","user":"578b140be4b0ebec4cfb7545"},{"code":"(fn fl [s]                                                                        \n  (loop [s1 s m '[]]                                                                \n    (cond                                                                           \n     (empty? s1) (seq m)                                                            \n     (sequential? (first s1))                                                              \n     (recur (rest s1) (into [] (concat m (fl (first s1)))))                         \n     :else (recur (rest s1) (conj m (first s1))))                                   \n    ))","problem":28,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn flat\n  [[h & t :as x]]\n  (when x\n    (if (coll? h)\n      (concat (flat h) (flat t))\n      (cons h (flat t))\n      )))","problem":28,"user":"50f10f7be4b06d9538fe211a"},{"problem":28,"code":"(fn flat [lst]\n  (cond\n    (not (coll? lst)) (conj [] lst)\n    (empty? lst) []\n    :else (concat (flat (first lst)) (flat (rest lst)))))","user":"5d323149e4b01671435dbce9"},{"problem":28,"code":"(fn flat [v]\n  (if (not (coll? v)) (list v)\n      (mapcat flat v)))","user":"58f98231e4b0438e51c2cf4c"},{"code":"#(remove nil? \n          (reverse\n  (loop [inpt % outpt '() cnt 0]\n    (cond\n     (empty? inpt) outpt\n     (> cnt 20) outpt\n     (coll? (first inpt)) \n       (let [item (first inpt)\n             i1 (first item)\n             i2 (next item)]\n         (recur (conj (rest inpt) i2 i1) outpt (inc cnt)))\n         ;(recur (cons i1 (cons i2 (rest inpt))) outpt (inc cnt)))\n     :else (recur (rest inpt) (cons (first inpt) outpt) (inc cnt))))))","problem":28,"user":"534d5ab7e4b084c2834f4a9c"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)\n          )\n  )","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn [s]\n  (reverse ((fn [s ret]\n    (if (empty? s)\n      ret\n      (if (coll? (first s))\n        (recur (concat (first s) (rest s)) ret)\n        (recur (rest s) (conj ret (first s)))))) s ())))","problem":28,"user":"4f951375e4b0dcca54ed6cc8"},{"problem":28,"code":"(fn my-flatten [coll]\n    (if (sequential? coll)\n      (mapcat my-flatten coll)\n      (list coll)))","user":"52b2f9cae4b0c58976d9acfb"},{"code":"#(filter (complement sequential? ) (rest (tree-seq sequential? seq %)))","problem":28,"user":"511a0374e4b06c8af011181a"},{"problem":28,"code":"(fn flat [x]\n    (if (coll? x)\n        (apply concat (map flat x))\n        [x]\n        )\n)","user":"5ed30cb6e4b016b56eae05c2"},{"problem":28,"code":"(comp reverse \n      (fn my-flatten \n        ([coll] \n         (my-flatten coll '()))\n   \t\t([coll result] \n         (if (nil? coll)\n         \t result\n             (my-flatten (next coll)\n                         (if (coll? (first coll))\n                             (concat (my-flatten (first coll)) result)\n                             (conj result (first coll))))))))","user":"5712854ce4b07c98581c3a89"},{"problem":28,"code":"#(loop [result (vector)\n         col %\n         done false]\n    (if-not (= col nil)\n      \n      (if (sequential? (first col))\n        (recur (concat result (first col)) (next col) false)\n        (recur (concat result (list (first col))) (next col) done)\n        )\n      \n      (if done result (recur (vector) result true))\n      \n      )\n    )","user":"5db861bce4b010eb3c36cd4b"},{"problem":28,"code":"(fn my-flatten [s] (if (coll? s)\n    (mapcat my-flatten s)\n    [s]))","user":"608dbb69e4b03bd49d9f36bb"},{"problem":28,"code":"(fn [xs]\n  (letfn [(f [xs]\n             (if (or (list? xs) (vector? xs))\n               (apply #'concat (map f xs))\n               (list xs)))]\n    (f xs)))","user":"57377ae8e4b0cd1946bd1046"},{"code":"(fn flat [x]\n                       (if (coll? x)\n                           (mapcat flat x)\n                           [x]\n                           )\n                       )","problem":28,"user":"53162640e4b08068f379ed40"},{"problem":28,"code":"(fn FLAT [xs]\n  (when (not-empty xs)\n    (let [[xh & xt] xs]\n      (if (coll? xh)\n         (concat (FLAT xh) (FLAT xt))\n         (cons xh (FLAT xt))\n         ))\n  )\n)","user":"58334d18e4b089d5ab817c97"},{"problem":28,"code":"(partial (fn flat\n  [xs x]\n  (if\n    (coll? x)\n    (reduce flat xs x)\n    (conj xs x))) [])","user":"54d267e0e4b0e8a36923e5f3"},{"code":"(fn kakukk [tomb]\n    (if (= (count tomb) 0)\n      '()\n      (if (sequential? (first tomb))\n         (concat (kakukk (first tomb)) (kakukk (rest tomb)))\n         (conj (kakukk (rest tomb)) (first tomb))\n       )\t\n    ) \n)","problem":28,"user":"50d3317ee4b049d4ed5650da"},{"code":"(fn\r\n  [x]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e218470535d04ed9115e817"},{"problem":28,"code":"(fn flatter [xs]\n  (reverse ((fn flat [ys result]\n              (if (not (coll? ys))\n                (conj result ys)\n                (if (empty? ys)\n                  result\n                  (let [a (first ys), b (rest ys)]\n                    (if (coll? a)\n                      (flat b (flat a result))\n                      (flat b (cons a result))))))) xs '())))","user":"537f8e7be4b06839e8705eb8"},{"problem":28,"code":"reduce (fn flat-me [agg xs] (if (or (vector? xs) (list? xs)) (into agg (reduce flat-me [] xs)) (into agg [xs]))) []","user":"5d91acb8e4b0915913b1d406"},{"code":"(fn flat [s]\n  (if (sequential? s)\n    (mapcat flat s)\n    (list s)))","problem":28,"user":"52166e50e4b0bf4bffd29cc6"},{"code":"(fn [M] \n    (reverse\n    ((fn loopie[cur-items new-list]\n      (if (empty? cur-items)\n        new-list\n        (let [head (first cur-items)]\n          (if (or (seq? head) (vector? head))\n            (recur (rest cur-items) (loopie head new-list))\n            (recur (rest cur-items) (conj new-list head))))))\n    M '())))","problem":28,"user":"4ee9c8d0535d93acb0a66892"},{"code":"(fn meu-flatten [coll]\n    (cond \n      (empty? coll) nil\n      (coll? (first coll)) (concat (meu-flatten (first coll)) (meu-flatten (next coll)))\n      :else (cons (first coll) (meu-flatten (next coll)))))","problem":28,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn my-flatten [s]\n  (if (sequential? s)\n    (apply concat (map my-flatten s))\n    (list s)))","problem":28,"user":"5310e7aee4b08068f379ecdc"},{"problem":28,"code":"(fn flat [coll]\n  (let [maybe-coll\n        (fn [a]\n          (if (coll? a)\n            (identity a)\n            (list a)))]\n    (if (some coll? coll)\n      (flat (apply concat (map maybe-coll coll)))\n      coll)))","user":"5beda647e4b0a6d31fed2122"},{"problem":28,"code":"(fn f [l] (if (coll? l) \n              (mapcat f l) \n              (list l)))","user":"5bc39d2be4b07a9b28b10045"},{"problem":28,"code":"(fn flatten' [a]\n  (cond \n    (nil? a) ()\n    (coll? (first a))  (concat (flatten' (first a)) (flatten' (next a)))\n    :else\n    (cons (first a) (flatten' (next a)))))","user":"55ed9108e4b0121d4835fddc"},{"problem":28,"code":"(fn [lst] ((fn [lst result] (if (empty? lst) result (let [[x & xs] lst] (if (coll? x) (recur (concat x xs) result) (recur xs (conj result x)))))) lst []))","user":"57902cd8e4b0ebec4cfb75a6"},{"code":"(fn flat\n  [coll]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4fea7594e4b0140c20fb9c06"},{"code":"(fn flat [c]\n  (cond\n   (not (coll? c)) (cons c '())\n   (empty? c) '()\n   :else (concat (flat (first c)) (flat (rest c)))))","problem":28,"user":"52f8f4d1e4b047fd55836fde"},{"code":"(fn ftn [xs]\n (if (coll? xs)\n     (mapcat ftn xs)\n      [xs]))","problem":28,"user":"4ffe4d43e4b0678c553fc3f1"},{"problem":28,"code":"(fn rec [x]\n  (reduce (fn [acc x]\n            (let [x (if (sequential? x) (rec x) (list x))]     \n              (concat acc x))) '() x))","user":"55e246c2e4b050e68259b431"},{"problem":28,"code":"#(loop [items % result []] \n    (if (empty? items)\n      result\n      (let [f (first items)\n            r (rest items)]\n        (if (coll? f)\n          (recur (concat f r) result)\n          (recur r (conj result f))))))","user":"569ef93de4b0542e1f8d148b"},{"problem":28,"code":"(fn flat [coll]\n  (mapcat #(if (coll? %)\n             (flat %)\n             [%])\n          coll))","user":"576c2ecae4b07c67f59d1fbb"},{"problem":28,"code":"(fn flatter[l]\n  (cond (empty? l) l\n        (not (sequential? (first l))) (cons (first l) (flatter (rest l)))\n        true (cons (first (flatter (first l))) (concat (rest (flatter (first l))) (flatter (rest l))))\n  )\n)","user":"58d96bdce4b0a4d5acaab638"},{"problem":28,"code":"(fn flt [a]\n  (if (coll? a)\n    (mapcat flt a)\n    [a]))","user":"57ffacd9e4b0a837a8b30c26"},{"code":"(fn my-flatten\n   [xs]\n   (first \n    (drop-while #(some coll? %)\n                (iterate (partial apply\n                                  (fn robust-concat\n                                    [& items]\n                                    (apply concat\n                                          (map (fn clothed\n                                                 [x]\n                                                 (if (not (coll? x))\n                                                     [x]\n                                                     x)) \n                                               items)))) \n                         xs))))","problem":28,"user":"524da51ee4b0a16e35cf6df4"},{"problem":28,"code":"(fn [x]\n\n  (filter (complement sequential?)\n\n          (rest (tree-seq sequential? seq x))))","user":"57b8f784e4b0fbc9809a27ea"},{"code":"(fn f\n  ([x] (seq (f x [])))\n  ([x a] (cond\n          (not (sequential? x)) (conj a x)\n          (empty? x) a\n          :else (f (rest x) (concat a (f (first x) []))))))","problem":28,"user":"50e9d21ce4b02d54280826cf"},{"problem":28,"code":"(fn extract [col] (if (sequential? col) (mapcat extract col) [col]))","user":"593c71cbe4b069cdc2982b90"},{"code":"(fn flat\n    [elements]\n    (loop [[x & xs :as elements] elements accum '()]\n      (cond (empty? elements) accum\n            (sequential? x) (recur xs (concat accum (flat x)))\n            :else (recur xs (concat accum (list x))))))","problem":28,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn [seq]\n  (let [flatten1\n        (fn [seq]\n          (reduce\n            (fn [acc elt]\n              (if (coll? elt)\n                  (reduce conj acc elt)\n  \t            (conj acc elt)))\n            [] seq))\n          seq1 (flatten1 seq)]\n    (if (= seq seq1)\n        seq\n      (recur seq1))))","problem":28,"user":"4ead6418535d7eef3080731f"},{"problem":28,"code":"#(filter \n  (complement coll?)\n  (tree-seq coll? identity %))","user":"55fe5dfae4b00f4cabc57650"},{"code":"(fn ex [x] (mapcat #(if (coll? %) (ex %) [%]) x))","problem":28,"user":"4ec7def0535d6d7199dd36e9"},{"problem":28,"code":"(fn fl[s]\n  (if (sequential? s)\n  (mapcat fl s)\n  (list s)))","user":"54bc539be4b0ed20f4ff6eca"},{"code":"(fn f\n  ([s] (f [] s))\n  ([acc s]\n   (reduce #(if (coll? %2) (f %1 %2) (conj %1 %2)) acc s)))","problem":28,"user":"4ec70f26535d6d7199dd36dd"},{"problem":28,"code":"(fn fl [coll]\n  (mapcat #(if (coll? %)\n             (fl %)\n             (list %))\n          coll))","user":"5591cc56e4b0604b3f94d582"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (when-let [f (first coll)]\n    (if (coll? f)\n     (concat (my-flatten f) (my-flatten (next coll)))\n     (lazy-seq (cons f (my-flatten (next coll)))))))","user":"6062e1bde4b03746e80ebf75"},{"code":"(fn flatten-fn [coll]\n  (reduce (fn flatten-red [acc-list item]\n            (if (coll? item)\n              (if-not (empty? item) \n                (reduce flatten-red \n                        (flatten-red acc-list (first item)) \n                        (rest item))\n                acc-list)\n              (conj acc-list item)))\n          [] \n          coll))","problem":28,"user":"50e063f3e4b061dbdced7230"},{"problem":28,"code":"#(remove coll? (tree-seq coll? identity %1))","user":"53d920d9e4b0e771c3025475"},{"code":"(fn flatn [xs]\n  (mapcat\n    (fn [x] \n      (if (sequential? x)\n        (flatn x)\n        [x]))\n    xs))","problem":28,"user":"4fe4c09ee4b0e8f79898febb"},{"code":"(fn flat-seq [xs]\n  (cond (empty? xs) \n        ()\n        (coll? (first xs))\n        (concat (flat-seq (first xs)) (flat-seq (rest xs)))\n        :else  (cons (first xs) (flat-seq (rest xs)))\n  )\n)","problem":28,"user":"52f10094e4b05e3f0be25ee8"},{"problem":28,"code":"(fn decode [lst]\n  (if (coll? lst)\n    (mapcat decode lst)\n    [lst]))","user":"5bbbce60e4b0a20761a2360e"},{"problem":28,"code":"(fn [x] (filter (comp not sequential?) (tree-seq sequential? identity x)))","user":"4e68c465535d8ccf87e9fe8a"},{"code":"(fn flat [x] (apply concat (map #(if (sequential? %) (flat %) [%]) x)))","problem":28,"user":"529a2d3be4b02ebb4ef75092"},{"code":"(fn fs [[h & t]] \n  (concat \n    (if (coll? h) (fs h) (list h))\n    (if (nil? t) '() (fs t))))","problem":28,"user":"4ebe81e9535dfed6da9c6d95"},{"problem":28,"code":"(let [x (fn [a-list f]\n                               (if (empty? a-list)\n                                 '()\n                                 (if (coll? (first a-list))\n                                   (concat (f (first a-list) f)\n                                           (f (rest a-list) f))\n                                   (conj (f (rest a-list) f) (first a-list)))))] (fn[l] (x l x)))","user":"5f86a98be4b0649ffcda4caa"},{"problem":28,"code":"(fn f [x] \n  (concat \n   (if (coll? (first x)) \n     (f (first x)) \n     (list (first x)))\n   (if (coll? (next x))\n     (f (next x))\n     (next x))))","user":"53f5c402e4b0db01ade6f9d4"},{"code":"(fn flat-seq [coll]\n  (reduce (fn flat-it [l x] (if (coll? x)\n                             (if (empty? x)\n                               l\n                               (flat-it (flat-it l (first x)) (rest x)))\n                              (conj l x)))\n          []\n          coll))","problem":28,"user":"4e4bd94b535dc968683fc4d7"},{"problem":28,"code":"(fn [x]\n  ((fn _flat [lst v]\n     (if (empty? lst)\n       v\n       (if (sequential? (first lst))\n         (_flat (rest lst) (_flat (first lst) v))\n         (_flat (rest lst) (conj v (first lst)))))\n    ) x []))","user":"5642b939e4b08d4f616f5f1b"},{"code":"(fn fl [xs] (if (coll? xs) (mapcat fl xs) [xs]))","problem":28,"user":"508f97c0e4b0ea685a20f768"},{"problem":28,"code":"(fn [coll] \n    (loop [c coll new-c []]\n      (cond \n        ( empty? c ) new-c\n        (instance? clojure.lang.Seqable (first  c )) (recur (concat (first c) (rest c )) new-c)\n        :else (recur (rest c) (conj new-c (first c))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":28,"code":"( fn myfunc [seqn]\n  (if (sequential? seqn)\n    (mapcat myfunc seqn )\n    (list seqn)))","user":"5f8d76c3e4b0715f5002d758"},{"code":"(fn flatter [coll]\n  (mapcat #(if (sequential? %1) (flatter %1) [%1]) coll))","problem":28,"user":"530caf86e4b02e82168697df"},{"code":"(fn fl [xs] \n         (if (empty? xs) \n  \t\t xs\n  \t\t (let [head (first xs)\n               tail (rest xs)]\n              (if (or (seq? head) (vector? head))\n                  (concat (fl (seq head)) (fl tail))\n                  (cons head (fl tail))))))","problem":28,"user":"5334d4f2e4b0656e627bfd71"},{"problem":28,"code":"(fn ft\n  ([coll] (ft coll []))\n  ([coll target]\n   (if (empty? coll)\n     (seq target)\n     (let [left (first coll)\n           right (rest coll)\n           new-target (if (sequential? left)\n                        (apply conj target (ft left))\n                        (conj target left))]\n       (ft right new-target))))\n  )","user":"5640b135e4b08d4f616f5ee8"},{"code":"(fn [x]\n         (filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"520332f7e4b030ee0c5b2714"},{"problem":28,"code":"(fn [x]\n (filter (complement sequential?)\n         (rest (tree-seq sequential? seq x))))","user":"5783c859e4b0ebec4cfb74bd"},{"code":"(fn [x]\r\n (reverse ((fn my-flatten [coll]\r\n  (if (= (count coll) 0)\r\n   []\r\n   (if (coll? (first coll))\r\n    (into (my-flatten (rest coll)) (my-flatten (first coll)))\r\n    (conj (my-flatten (rest coll)) (first coll))\r\n   )\r\n  )\r\n ) x)))","problem":28,"user":"505caadfe4b0bcb5664c3d3e"},{"code":"(fn foo [[x & rest]] \n  (concat \n    (if (sequential? x) (foo x) [x])\n    (if-not (nil? rest) (foo rest))))","problem":28,"user":"50baa66be4b03e68e4411c94"},{"code":"(fn [xs]\r\n  (loop [xs xs]\r\n    (let [zs\r\n      (loop [ws xs ys nil]\r\n        (if (not (seq ws))\r\n          (reverse ys)\r\n          (if (coll? (first ws))\r\n            (if (seq (first ws))\r\n              (recur (cons (next (first ws)) (rest ws)) (cons (ffirst ws) ys))\r\n              (recur (rest ws) ys))\r\n            (if (nil? (first ws))\r\n              (recur (rest ws) ys)\r\n              (recur (rest ws) (cons (first ws) ys))))))]\r\n      (if (seq (filter coll? zs))\r\n        (recur zs)\r\n        zs))))","problem":28,"user":"4e6a97a9535d8ccf87e9fef8"},{"problem":28,"code":"(fn [col] \n (loop [c col result '()] \n  (if (empty? c) (reverse result)\n   (if (coll? (first c)) \n     (recur (concat (first c) (rest c)) result ) \n     (recur (rest c)(cons (first c) result))\n   )\n  )\n )\n)","user":"558bdcefe4b0277789237633"},{"code":"(fn [xs]\n  (let [flatter (apply concat (map #(if (coll? %) % (list %)) xs))]\n  (if (= xs flatter) xs\n      (recur flatter))))","problem":28,"user":"4fc8f1fee4b0ee37620e183f"},{"problem":28,"code":"(fn flat\n   [l]\n   (reduce (fn [i j]\n             (if (coll? j)\n               (into i (flat j))\n               (conj i j))) [] l))","user":"5185ad63e4b0da5a5be3bac2"},{"code":"(fn my-flatten [xs] \n  (if (sequential? xs) (reduce concat (map my-flatten xs)) (list xs))\n)","problem":28,"user":"4fb710f4e4b081705acca2cd"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"4e634eb9535d8ccf87e9fe63"},{"code":"(fn flat [s] (reduce #(if (coll? %2) (vec (concat %1 (flat %2))) (conj %1 %2)) [] s))","problem":28,"user":"52401a65e4b0ad64fa010306"},{"code":"(fn f [x] \n  (if (coll? x) \n    (mapcat f x) \n    [x])\n)","problem":28,"user":"5041b3c0e4b06d8231e4facf"},{"code":"(fn fltn [s]\n  (if (empty? s) s\n  (if (sequential? (first s))\n    (concat (fltn (first s)) (fltn (rest s)))\n    (cons (first s) (fltn (rest s))))))","problem":28,"user":"504e108ce4b078edc5f593b3"},{"code":"#(letfn [(flat [elem]\n               (if (coll? elem)\n                   (apply concat (map flat elem))\n               \t   (cons elem '())\n               ))]\n   (flat %))","problem":28,"user":"5315a4f0e4b08068f379ed2e"},{"code":"(fn\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e641bfd535d8ccf87e9fe67"},{"code":"(fn f [s] (when (seq s) (let [i (first s) r (rest s)] (concat (if (sequential? i) (f i) (vec [i])) (f r)))))","problem":28,"user":"52d66152e4b09f7907dd1357"},{"problem":28,"code":"(letfn [(my-flatten [[x & xs]]\n           (cond\n             (and (empty? xs) (coll? x)) (my-flatten x)\n             (empty? xs) (list x)\n             (coll? x) (concat (my-flatten x) (my-flatten xs))\n             :else (cons x (my-flatten xs))))]\n   my-flatten)","user":"573d27b4e4b05c31a32c080f"},{"code":"(fn flat [s]\n  (let [l (first s) r (next s)]\n    (concat\n      (if (sequential? l)\n        (flat l)\n        [l])\n      (when (sequential? r)\n        (flat r)))))","problem":28,"user":"536c35c3e4b0fc7073fd6e3a"},{"code":"(fn fl [ls] \n  (if \n    (coll? ls) \n    (if \n      (empty? ls) \n      '() \n      (concat (fl (first ls)) (fl (rest ls)))\n     )\n    (list ls)\n  )\n)","problem":28,"user":"505885c4e4b06522596eba7b"},{"problem":28,"code":"(fn [lst]\n  (loop [flst [] xs lst]\n    (if (empty? xs)\n      flst\n      (let [x (first xs)]\n        (do\n          (if (coll? x)\n            (recur flst (concat x (rest xs)))\n            (recur (conj flst x) (rest xs))))))))","user":"5b58d012e4b02d533a91bd71"},{"code":"(fn f [[x & xs]]\n  (if xs\n    (if (sequential? x)\n      (concat (f x) (f xs))\n      (concat [x] (f xs)))\n    (if (sequential? x)\n      (f x)\n      [x])))","problem":28,"user":"50bb646de4b03e68e4411ca3"},{"problem":28,"code":"(fn flat [xs]\n  (loop [f (first xs)\n         r (rest xs)]\n    (cond (empty? xs) nil\n          ((complement sequential?) f) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"598601f9e4b021a7a535fe79"},{"problem":28,"code":"(fn flatu\n  [n]\n  (if (coll? n)\n    (mapcat flatu n) \n    [n])\n  )","user":"57f81532e4b0d3187e900914"},{"problem":28,"code":"(fn myf [a] (mapcat #(if (sequential? %) (myf %) [%]) a))","user":"554f7ef2e4b00713264bd9a1"},{"problem":28,"code":"#(reverse\n  (reduce\n   (fn func [desc src]\n     (if (coll? src)\n       (concat (reduce func '() src) desc)\n       (conj desc src))) '() %))","user":"53c39a9ae4b00fb29b22127d"},{"code":"reduce (fn flat [coll x]\n         (if (sequential? x)\n           (concat coll (reduce flat [] x))\n           (conj (vec coll) x)))\n        []","problem":28,"user":"52cb6bb0e4b07d0d72b2734c"},{"code":"(fn f [x]\n  (if (sequential? x)\n    (mapcat f x)\n    (list x)))","problem":28,"user":"5154b16be4b0179c5115f4e2"},{"problem":28,"code":"(fn lets-do-it [coll]\n   (let [result (reduce #(if (coll? %2)\n                           (into % %2)\n                           (conj % %2))\n                        []\n                        coll)\n         not-yet? (some #(and (coll? %) %) result)]\n     (if not-yet?\n       (lets-do-it result)\n       (apply list result))))","user":"58a34442e4b02bd94d917ef2"},{"problem":28,"code":"(fn flat [[h & t]]\n  (let [h (if (coll? h) (flat h) [h])\n        t (if (empty? t) t (flat t))]\n    (concat h t)))","user":"56ff45e5e4b08d47c97781bb"},{"problem":28,"code":"(fn flatten2\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5e9d99f9e4b0157ca9664806"},{"code":"(fn f [xs] \n  (reduce #(if(coll? %2) \n             (concat % (f %2)) \n             (conj (vec %) %2)) \n          [] xs))","problem":28,"user":"524f3e6de4b0541d1855b805"},{"problem":28,"code":"(fn my-flatten [coll]\n  (->> (tree-seq sequential? seq coll)\n       (filter #(not (sequential? %)))))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":28,"code":"(fn [lst] (filter (complement sequential?) (rest (tree-seq sequential? seq lst))))","user":"56367c51e4b0bfe05bf117cd"},{"code":"(fn myflat [lst]\n    (if (or (list? lst) (vector? lst))\n      (mapcat myflat lst)\n      (list lst)))","problem":28,"user":"4f06f953535dcb61093f6c1c"},{"code":"(fn f [coll]\n  (if (sequential? coll)\n      (mapcat f coll)\n      (list coll)))","problem":28,"user":"51803613e4b04f45bde7d8fd"},{"problem":28,"code":"(fn fl [x] (if (sequential? x)\n                    (let [f (first x) n (next x)]\n                      (concat (if (sequential? f) (fl f) (list f)) (fl n)))\n                    x))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"(fn f [sq] \n\t(if (coll? sq)\n  \t(apply concat (map f sq))\n    [sq]))","problem":28,"user":"520242bae4b030ee0c5b26e3"},{"problem":28,"code":"(fn [xs]\n  (filter #(not (coll? %)) (tree-seq coll? seq xs)))","user":"5e0b6375e4b099d064962f7b"},{"code":"#(filter (complement coll?) (rest (tree-seq coll? identity %)))","problem":28,"user":"4fce75cfe4b03432b189f400"},{"code":"(fn [ll]\n        (letfn [(flatten_ [in out]\n                  (if in\n                    (if (sequential? (first in))\n                      (flatten_ (next in) (reduce conj out (flatten_ (first in) [])))\n                      (flatten_ (next in) (conj out (first in))))\n                    out))]\n          (flatten_ ll [])))","problem":28,"user":"532bce35e4b09d4e7a9b5536"},{"code":"(fn ex-at [s]\r\n  (cond (not (coll? s)) (list s)\r\n        (or (empty? s) (nil? s)) (list)\r\n        :else (concat (ex-at (first s)) (ex-at (rest s)))))","problem":28,"user":"50c336dde4b00e537d002542"},{"problem":28,"code":"(fn mflat [tree]\n  (if (not (coll? tree))\n    [tree]\n    (if (not (empty? tree))\n      (concat (mflat (first tree))\n              (mflat (rest tree))))))","user":"56a2777be4b0542e1f8d14bf"},{"code":"(fn my-flatten [aseq]\n  (if (or (seq? aseq) (vector? aseq))\n    (let [[first-part & the-rest] aseq]\n      (concat (my-flatten first-part) (my-flatten the-rest)))\n    (when-not (nil? aseq) (list aseq))))","problem":28,"user":"4ef3f5b0535dced4c769f22f"},{"problem":28,"code":"(fn\n  [coll]\n  (let [result (atom [])\n        res-fn (fn [e]\n                 (when-not (sequential? e)\n                   (swap! result conj e)))]\n    (clojure.walk/postwalk res-fn coll)\n    @result))","user":"4e586949535d8a8b8723a292"},{"problem":28,"code":"(fn my-flatten [s]\n  (seq (reduce (fn [acc e] (if (sequential? e) (into acc (my-flatten e)) (conj acc e))) [] s)))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":28,"code":"(fn [s]\n  (let [flt (fn [xs f2]\n              (reduce\n               (fn [ys y]\n                 (if (coll? y)\n                   (concat (f2 y f2) ys)\n                   (cons y ys)))\n               '()\n               xs))]\n    (reverse (flt s flt))))","user":"5032748ae4b0e78df07b092f"},{"code":"(fn flat [x] (filter (complement sequential?) \r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f04256d535dcb61093f6ba7"},{"problem":28,"code":"#(reverse (reduce\n            (fn flat [acc val]\n              (if (coll? val)\n                (reduce flat acc val)\n                (conj acc val)))\n            '()\n            %))","user":"58a7b7cbe4b01a0c0b232946"},{"code":"(fn my-flatten [s]\n  (let [flatten-one-layer\n        (fn [flat unk]\n          (cond\n            (empty? unk) (seq flat)\n            (seq? (first unk)) (recur (into flat (first unk)) (rest unk))\n            :else (recur (conj flat (first unk)) (rest unk))))\n        sq (map #(if (vector? %) (seq %) %) s)]\n        (if (not (apply = (conj (map seq? sq) false)))\n          (recur (flatten-one-layer [] sq))\n          sq)))","problem":28,"user":"4ec3674b535dcc7ae8597d57"},{"problem":28,"code":"(fn [l]\n  (letfn [(eval-item [coll el]\n                     (if-not (sequential? el)\n                       (conj coll el)\n                       (reduce #(eval-item %1 %2) coll el)))]\n    (reduce #(eval-item %1 %2) [] l)))","user":"532902f8e4b09d4e7a9b550e"},{"code":"(fn myflat [l]\n  (if (sequential? l)\n    (if-let [rs (next l)]\n      (concat (myflat (first l))\n              (myflat rs))\n      (myflat (first l)))\n    (list l)))","problem":28,"user":"5392b849e4b0b51d73faaeb1"},{"problem":28,"code":"(fn ff [coll]\n  (if (sequential? coll)\n    (mapcat ff coll)\n    (list coll)))","user":"548f3ed8e4b0e286459a1236"},{"code":"(fn w [n] (if (coll? n) (mapcat w n) (list n)))","problem":28,"user":"4ec16c21535dfed6da9c6dac"},{"problem":28,"code":"(fn [s]\n  (reduce (fn myflatten [collection element]\n            (if (sequential? element)\n              (reduce myflatten collection element)\n              (conj collection element))) [] s))","user":"56d4b22de4b0ea9b8538f7bb"},{"problem":28,"code":"(fn my-flatten [coll] (if (coll? coll) (reduce #(concat %1 (my-flatten %2)) [] coll) [coll]))","user":"55916d7be4b0604b3f94d57d"},{"code":"(fn fltn [x] (mapcat #(if (coll? %) (fltn %) [%]) x))","problem":28,"user":"4e8f4f64535d65386fec2149"},{"code":"(fn [input-coll]\n  (loop [coll input-coll\n         acc []]\n    (if (empty? coll)\n      acc\n      (let [fst (first coll)]\n        (if (coll? fst)\n          (recur (concat fst (rest coll)) acc)\n          (recur (rest coll) (conj acc fst)))))))","problem":28,"user":"51789dfae4b03d69594194d7"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn [acc x]\n            (if (sequential? x)\n              (apply conj acc (flat x))\n              (conj acc x))) [] s))","user":"595bbab7e4b066ee0a44afe0"},{"code":"(fn [s]\n    ((fn flat-iter [s-in s-out]\n       (if (or (seq? s-in) (vector? s-in))\n         (if (empty? s-in)\n           s-out\n           (flat-iter (rest s-in) (flat-iter (first s-in) s-out)))\n         (conj s-out s-in)))\n     s []))","problem":28,"user":"4fe8e771e4b0547ebccb2431"},{"problem":28,"code":"(fn [c] ( (fn mr [r cs] (reduce #(if (coll? %2) (mr % %2) (conj % %2)) r cs)) [] c))","user":"5339b53fe4b0e30313ee6cac"},{"code":"(fn [xs]\n  (letfn [(fl [x] (if (coll? x) (mapcat fl x) (list x)))]\n    (fl xs)))","problem":28,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn [x] (filter (complement sequential?)\n        (rest (tree-seq sequential? seq x))))","problem":28,"user":"52a0fa82e4b04e0c58e87bd1"},{"problem":28,"code":"(fn my-flatten [c]\n  (mapcat (fn [x]\n         (if (coll? x) (my-flatten x) (list x))) c))","user":"5471f0f3e4b094393f72dd6f"},{"problem":28,"code":"(fn myFlatten [x]\n  (if (coll? x)\n    (mapcat myFlatten x)\n    [x]\n    )\n  )","user":"55ce2b6de4b0e31453f64a26"},{"problem":28,"code":"(fn flata [[h & tl]] (if (nil? h) h (if (sequential? h) (concat (flata h) (flata tl)) (conj (flata tl) h))))","user":"5a7deab5e4b03baeef927703"},{"problem":28,"code":"(fn my-flatten [x]\n  (loop [x x\n         lst ()]\n    (if (empty? x)\n        (reverse lst)\n        (if (or (vector? (first x)) (list? (first x)))\n            (recur (rest x)\n                   (concat (reverse (my-flatten (first x))) lst))\n            (recur (rest x) \n                    (cons (first x) lst))))))","user":"57f8151ce4b0d3187e900912"},{"code":"apply (fn F [x & more]\r\n         (if (empty? more) \r\n             (if (or (list? x) (vector? x))\r\n                 (apply F x)\r\n                 (list x))\r\n             (concat (F x)\r\n                     (apply F more)\r\n             )\r\n         )\r\n       )","problem":28,"user":"4f3543eee4b0e243712b1ebd"},{"problem":28,"code":"(fn spe-flatten\n  ([coll]\n   (spe-flatten coll []))\n  ([oldcoll flatcoll]\n   (if (first oldcoll)\n     (if (coll? (first oldcoll))\n      (spe-flatten (concat (first oldcoll) (rest oldcoll)) flatcoll)\n       (spe-flatten (rest oldcoll) (conj flatcoll (first oldcoll)))\n       )\n     flatcoll))\n  )","user":"56fa972be4b07572ad1a88c2"},{"code":"(fn ftn [l] (if (empty? l) l\n    (if (coll? (first l)) \n      (ftn (concat (first l) (rest l)))  \n      (cons (first l) (ftn (rest l)))\n    )\n  )\n)","problem":28,"user":"4fcf642ee4b03432b189f410"},{"code":"(fn[x] \n(if (= (first x) '(1 2)) '(1 2 3 4 5 6)\n(if (= (first x) \"a\") [\"a\" \"b\" \"c\"] \n'(:a)\n))\n\n\n)","problem":28,"user":"4fe1279fe4b0dd6cd5ce3630"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (sequential? f) (concat (flat f) (flat r))\n          :else (cons f (flat r)))))","user":"5e30dbd5e4b05b4b0151621d"},{"code":"(fn flat [x]\n  (if (sequential? x)\n    (if (empty? x)\n      []\n      (concat (flat (first x)) (flat (rest x))))\n    [x]))","problem":28,"user":"521dad9be4b050d5da0427f9"},{"code":"(fn f [a]\n  (if (sequential? a)\n    (mapcat f a)\n    [a]))","problem":28,"user":"516abecae4b081287f204e9f"},{"code":"(fn flt [coll]\n  (if (nil? coll)\n    coll\n    (if (coll? coll)\n      (concat (flt (first coll)) (flt (next coll)))\n      (list coll))))","problem":28,"user":"4f8dc9dce4b02e764a0a51b6"},{"problem":28,"code":"(fn flatter [x]\n  (if (coll? x)\n      (mapcat flatter x)\n      [x]))","user":"592fa9f8e4b072a2710fcfcb"},{"code":"(fn [lx] (reverse ((fn flt [l]\r\n  (if (empty? l)\r\n     []\r\n    (let [f (first l)]\r\n      (if (sequential? f)\r\n        (into (flt (rest l)) (flt f))\r\n        (conj (flt (rest l)) f))))) lx)))","problem":28,"user":"50481b70e4b0ec70b3ef8d98"},{"code":"(fn [inputColl] \n  (filter (complement sequential?) (rest (tree-seq sequential? seq inputColl))))","problem":28,"user":"5227eacee4b0186687e23a5e"},{"problem":28,"code":"(fn myflat \n  [coll] (if (coll? coll)\n             (if (empty? coll) coll\n             (concat (myflat (first coll)) \n                     (myflat (rest coll)))) \n          (list coll)))","user":"578e2829e4b0ebec4cfb757d"},{"problem":28,"code":"(fn [lst] \n  (reverse\n    ((fn flat [lst]\n      (cond (empty? lst) []\n            (not (coll? (first lst))) (into   (flat (rest lst))\n                                              (list(first lst)))\n            :else (into   (flat (rest lst))\n                          (flat (first lst)))))lst)))","user":"58ffaddee4b0438e51c2cffe"},{"problem":28,"code":"(fn flat [s]\n  (lazy-seq \n    (if (coll? s)\n        (mapcat flat s)\n        [s])))","user":"51316a63e4b0431ba07e7feb"},{"problem":28,"code":"(fn [se]\n  (letfn [(fl [s]\n               (cond (empty? s) '()\n                     (coll? (first s)) (concat (fl (first s))\n                                               (fl (rest s)))\n                     :else (cons (first s) (fl (rest s)))))]\n    (fl se)))","user":"60264d89e4b0d5df2af2222d"},{"problem":28,"code":"reduce (fn add-element [collection element]\n  (println \"Iteration\" collection element)\n  (if (sequential? element)\n    (if (not-empty element)\n      (if (sequential? (first element))\n        (add-element collection (first element))\n        (add-element (conj collection (first element)) (rest element)))\n      collection)\n    (conj collection element))) []","user":"5fc3850de4b0db0e95a5f3fd"},{"problem":28,"code":"(fn flt[x] ((comp first filter) #(every? (comp not coll?) %1) (iterate (partial mapcat #(if (coll? %1) %1 [%1])) x)))","user":"54b8dfece4b0ed20f4ff6e9a"},{"code":"(fn [c] \n  (if (some coll? c) \n      (recur (apply concat (map #(if (coll? %) % (list %)) c))) \n      c))","problem":28,"user":"4f04b66b535dcb61093f6bdd"},{"problem":28,"code":"#(\n  filter (complement sequential?)\n          (rest (tree-seq sequential? seq %)))","user":"55a65872e4b09e57187da299"},{"code":"(fn fltn [x] (reverse\n  (reduce\n    (fn [cumulator, item] (if \n      (sequential? item)\n      (into\n        cumulator\n        (fltn item))\n      (conj\n        cumulator\n        item)))\n    '()\n    x)))","problem":28,"user":"4f944f60e4b0dcca54ed6cc2"},{"problem":28,"code":"(fn [x]\n  (let [contains-nested (fn [s]\n                          (loop [item (first s) re (rest s)]\n                            (cond\n                              (sequential? item) item\n                              (empty? re) false\n                              :else (recur (first re) (rest re))\n                              )\n\n                            )\n                          )\n        flatten-one (fn [s]\n                      (loop [item (first s) re (rest s) res []]\n                        (if (sequential? item)\n                          (into (into res item) re)\n                          (recur (first re) (rest re) (conj res item))\n                          )\n                        )\n                      )\n\n        ]\n    (flatten-one (last (take-while contains-nested (iterate flatten-one x))))\n    )\n  )","user":"55d42f78e4b0e31453f64a73"},{"code":"(fn flatten-2 [coll]\n  (if (not (coll? coll))\n    (list coll)\n    (if (empty? coll)\n      nil\n      (let [lst-h (first coll)\n            lst-t (rest coll)]\n        (concat (flatten-2 lst-h) (flatten-2 lst-t))))))","problem":28,"user":"4eec82fe535d93acb0a668ae"},{"code":"(fn flat [x]\n  (reduce concat\n          (map #(if (sequential? %)\n                  (flat %) (list %)) x)))","problem":28,"user":"527cd633e4b0757a1b17136f"},{"problem":28,"code":"(fn myFlatten [l]\n             (if (not-empty l)\n               (let [f (first l)]                           ;;f = [1]\n                 (if (coll? f)\n                   (concat (myFlatten f) (myFlatten (rest l)) ) ;; (concat '(1) '())\n                   (cons f  (myFlatten (rest l)))\n                   )\n                 )\n\n               )\n             )","user":"5fc241c1e4b0edf42a5593d1"},{"code":"(fn -flatten [x]\n  (if (coll? x)\n    (mapcat -flatten x)\n    [x]))","problem":28,"user":"4fb1d907e4b081705acca282"},{"problem":28,"code":"(fn [x] (letfn [(flat [coll] (lazy-seq (when-let [c (seq coll)] (let [x (first c)] (if (sequential? x) (concat (flat x) (flat (rest c))) (cons x (flat (rest c))))))))] (if (sequential? x) (flat x) x)))","user":"55d84919e4b0e31453f64ab0"},{"problem":28,"code":"#(loop [x % y '()]\n   (cond (empty? x) y\n         (coll? (first x)) (recur (concat (first x)(rest x)) y)\n         :else (recur (rest x) (concat y [(first x)]))))","user":"59fea630e4b01bb0ae8afd10"},{"code":"(fn [x] \n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4eb59464535d7eef30807369"},{"code":"#(filter (complement sequential?)\n   (rest (tree-seq sequential? seq  %)))","problem":28,"user":"4f54ecf1e4b0a7574ea717f0"},{"problem":28,"code":"#(reduce (fn new-flatten [acc n] \n  (if (coll? n)\n    (reduce new-flatten acc n) (conj acc n)))\n   []\n   %1)","user":"54a6baaee4b09f271ff37c8a"},{"code":"(fn [the-list]\n   (loop [l the-list\n          result '()]\n     (cond\n       (empty? l) result\n       (coll? (first l))\n       (recur (concat (first l)\n                      (rest l))\n              result)\n       :else\n       (recur (rest l) (concat result (list (first l)))))))","problem":28,"user":"4f62ef0ce4b0defedf855fdc"},{"problem":28,"code":"(partial (fn flat [res xs]\n    (let [f (first xs) r (rest xs)]\n        (cond\n            (nil? f) res\n            (not (sequential? f)) (flat (conj res f) r)   \n            :else (concat res (flat [] f) (flat [] r ))))) [])","user":"566ff0a1e4b0a866af6896ec"},{"problem":28,"code":"(fn flat [col]\n  (cond (empty? col) '()\n        (coll? (first col)) (concat (flat (first col))\n                                   (flat (rest col)))\n        :else\n        (cons (first col)\n              (flat (rest col)))))","user":"54f14aa6e4b024c67c0cf8af"},{"code":"(letfn [(f [s e] \n            (if (coll? e) \n              (reduce f s e) \n              (conj s e)))] \n   (fn [x] (f [] x)))","problem":28,"user":"514f6679e4b0b449e54b8df5"},{"problem":28,"code":"(fn flat2 [& args]\n  (let [flat\n        (fn [x]\n          (if (coll? x)\n  \t\t  (apply flat2 x)\n  \t      (list x)))]\n  (apply concat (map flat args))))","user":"5140771ae4b076604f1aa555"},{"problem":28,"code":"#(if (every? (comp not (fn [a] (or (list? a) (vector? a)))) %) % (recur (reduce (fn [prev, el] (if (or (list? el) (vector? el)) (concat prev el) (concat prev (list el)))) (list) %)))","user":"56cd75bee4b0ea9b8538f74b"},{"problem":28,"code":"(letfn [(flatten* [coll]\n          (if (coll? coll)\n            (when (seq coll)\n              (concat (flatten* (first coll)) (flatten* (rest coll))))\n            (list coll)))]\n  flatten*)","user":"59fa241ee4b0ca45a743a358"},{"problem":28,"code":"#(remove nil? ((fn my-flatten [numbers]\n  (if (coll? numbers)\n    (let [x (first numbers)\n          xs (next numbers)]\n      (concat (my-flatten x) (my-flatten xs)))\n    [numbers])) %))","user":"5412ef7ee4b01498b1a719da"},{"problem":28,"code":"(fn my-flatten [x]\n             (if (coll? x)\n               (mapcat my-flatten x)\n               [x]))","user":"5d974b1de4b0d3f9b434ad36"},{"problem":28,"code":"(fn flattener [x]\n  (if (false? (coll? x))\n    (list x)\n    (if (empty? x)\n      '()\n      (concat\n       (flattener (first x))\n       (flattener (rest x))\n      )\n    )\n  )\n)","user":"569f99cce4b0542e1f8d1497"},{"code":"(fn fl [lst]\n  (if (coll? lst)\n      (mapcat fl lst)\n      (list lst)))","problem":28,"user":"4e83bb61535db62dc21a62dd"},{"problem":28,"code":";(fn flat [coll](reduce #(concat %1(if(coll? %2)(flat %2)[%2]))'() coll))\n(fn flat-1 [list]\n(reverse\n((fn flat [list cum]\n(let [a (first list) b (rest list)]\n(if (nil? a) cum\n(if-not (sequential? a) (flat b (cons a cum)) (flat b (flat a cum)))))) list [])))","user":"580d7e53e4b0849f6811b73e"},{"problem":28,"code":"; 28 Flatten a Sequence\n(fn\n  [lst]\n  (letfn [(_flat [lst]\n            (if (not (empty? lst))\n              (let [head (first lst), tail (rest lst)]\n                (println head)\n                (concat\n                        (if (coll? head)\n                          (_flat head)\n                          (cons head '()))\n                        (_flat tail)))))]\n    (_flat lst)\n    ))","user":"5e65bfe4e4b0fd0acd1586b9"},{"code":"(fn myf [xs]\n  (apply concat (map (fn [x]\n                       (if (or (seq? x) (vector? x))\n                         (myf x)\n                         [x]\n                         ))\n                     xs)))","problem":28,"user":"53664e3be4b0243289761e74"},{"problem":28,"code":"(fn flatter3 [coll]\n  (if (first coll)\n    (if (coll? (first coll))\n      (concat (flatter3 (first coll)) (flatter3 (rest coll)))\n      (cons (first coll) (flatter3 (rest coll))))\n    (list)))","user":"5fe35144e4b05ac5b16ea178"},{"code":"(fn [x]\n  (filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"52fcfeeee4b047fd55837027"},{"problem":28,"code":"(fn flatn [i]\n  (if (coll? i)\n    (apply concat (map flatn i))\n    [i]\n    )\n  )","user":"562add6de4b00e49c7cb4834"},{"code":"(fn flat [ coll] (mapcat #(if (coll? %1) (flat %1) (list %1)) coll))","problem":28,"user":"52a9406de4b0c58976d9ac43"},{"code":"#(filter (complement sequential?) (rest ( tree-seq sequential? seq %)))","problem":28,"user":"4e5a3891535d8a8b8723a2aa"},{"problem":28,"code":"(fn f [v] (apply concat (map #(if (sequential? %) (f %) [%]) v)))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn flat [l] (if (= (count l) 0) '() (if (coll? (first l)) (concat (flat (first l)) (flat (rest l))) (conj (flat (rest l)) (first l)))))","problem":28,"user":"52d92f13e4b09f7907dd13a2"},{"code":"(fn fl [col]\n  (reduce \n    #(if (sequential? %2) \n      (concat (fl %2) %1) \n      (conj %1 %2)) nil (reverse col)))","problem":28,"user":"4fd7962ee4b0dab7d829f385"},{"code":"#(letfn [(flat [coll]\n                  (lazy-seq\n                   (when-let [c (seq coll)]\n                     (let [x (first c)]\n                       (if (sequential? x)\n                         (concat (flat x) (flat (rest c)))\n                         (cons x (flat (rest c))))))))]\n    (if (sequential? %) (flat %) %))","problem":28,"user":"5348276de4b084c2834f4a55"},{"problem":28,"code":"(fn fla [coll]\n  \t(let [f (first coll) n (next coll)]\n      (concat \n       \t(if (sequential? f)\n          \t(fla f)\n          \t[f])\n       \t(when (sequential? n)\n          \t(fla n)))))","user":"55ec1048e4b0121d4835fdc3"},{"code":"(fn fltn [coll]\n  (if (sequential? coll)\n    (mapcat fltn coll)\n    (list coll)))","problem":28,"user":"52dc3bc8e4b09f7907dd13cb"},{"problem":28,"code":"(fn my-flatten [coll]\n      (loop [incoll coll ret '()]\n          (cond \n             (sequential? (first incoll)) (recur (concat (first incoll) (rest incoll)) ret )\n              (empty? incoll) (reverse ret)\n             :else (recur (rest incoll) (cons (first incoll) ret)))))","user":"573940e3e4b0cd1946bd106b"},{"problem":28,"code":"(fn flatt\n  [s]\n  (if (or (seq? s) (vector? s))\n    (if (empty? s)\n      s\n      (concat (flatt (first s))\n              (flatt (rest s))))\n    (list s)))","user":"60460824e4b02d28681c77bc"},{"code":"(fn flat [lst]\n  (if (empty? lst)\n    '()\n    (if (coll? (first lst))\n      (concat (flat (first lst)) (flat (rest lst)))\n      (cons (first lst) (flat (rest lst))))))","problem":28,"user":"52e16139e4b09f7907dd141f"},{"problem":28,"code":"#(loop [x %  res []]\n  (let [y (first x)\n        z (rest x)]\n  (if (seq x)\n  (cond\n     (or (list? y) (vector? y))  (recur (concat '() y z) res)\n     :else (recur z (conj res y)))\n   res)))","user":"56fde58ae4b08d47c97781aa"},{"problem":28,"code":"(fn f [s]\n  (cond \n   (not (coll? s)) [s]\n    (not (seq s)) nil\n    :else (concat (f (first s)) (f (rest s)))))","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn f[c] (mapcat #(if (coll? %) (f %) [%]) c))","problem":28,"user":"4ec49231535dcc7ae8597d63"},{"problem":28,"code":"(fn f [s]\n              (loop [remaining s\n                     s-flattened []]\n                (if (not-empty remaining)\n                  (let [[head & tail] remaining]\n                    (if (coll? head)\n                      (recur tail (concat s-flattened (f head)))\n                      (recur tail (concat s-flattened (vector head)))))\n                  s-flattened)))","user":"5701f886e4b08d47c97781d9"},{"problem":28,"code":"(fn fltn [sq]\n  (cond\t(= (first sq) nil) nil\n   \t\t(coll? (first sq)) (concat (fltn (first sq))\n   \t\t                           (fltn (rest sq)))\n        :else (conj (fltn (rest sq))\n                    (first sq))))","user":"57614a42e4b0994c1922fb85"},{"problem":28,"code":"(fn [col]                                                                                                                                    \n  (filter (complement coll?) (tree-seq coll? identity col)))","user":"4f25c4c4e4b0d66497709ffc"},{"code":"(fn foo [coll & [ret]]\n    (if-not coll\n            ret\n            (if-not (coll? coll)\n                    (concat ret [coll])\n                    (concat ret (foo (first coll)) (foo (next coll))))))","problem":28,"user":"52afbc69e4b0c58976d9acc0"},{"problem":28,"code":"(fn collect [x]\n  (if(coll? x)\n     (if (empty? x)\n       []\n       (concat (collect (first x)) (collect (rest x))))\n     [x]))","user":"558d43f1e4b0277789237640"},{"problem":28,"code":"#(loop [s [] curr %]\n    (if (empty? curr)\n      (sort s)\n      (if (sequential? (first curr))\n        (if (empty? (first curr))\n          (recur s (rest curr))\n          (recur s (into (rest curr) (first curr)))\n        )\n        (recur (conj s (first curr)) (rest curr)))\n    ))","user":"57f253a3e4b0511f1d294dea"},{"problem":28,"code":"(fn my-flatten [x]\n   (reduce #(concat %1 (if (coll? %2) (my-flatten %2) (list %2)))\n           ()\n           x))","user":"5812eb8fe4b0f478707a0602"},{"problem":28,"code":"(fn\n      [mess]\n      (loop [m mess\n             e '()]\n            (cond\n              (empty? m) (reverse e)\n              (and (coll? (first m)) (empty? (first m))) (recur (next m) e)\n              (and (coll? (first m)) (not (empty? (first m)))) (recur (cons (first (first m )) (cons (rest (first m)) (rest m))) e)\n              :else (recur (next m) (conj e (first m)))\n              )\n        )\n\n\n  )","user":"5683b67ce4b0945ebc182a9f"},{"problem":28,"code":"(fn aux [coll] \n  (reduce concat [] (map (fn [var]\n                         (if (or (list? var) (vector? var)) (aux var)\n                           [var])) coll)))","user":"560039cce4b04bb52996e162"},{"code":"(fn [coll] (filter (complement sequential?) (tree-seq sequential? seq coll)))","problem":28,"user":"533b1dc4e4b0e30313ee6cc7"},{"problem":28,"code":"(fn my-flatten [lst]\n  (let [firstele (first lst)\n        remaining (rest lst)]\n    (cond\n      (nil? firstele) ()\n      (coll? firstele) (concat (my-flatten firstele) (my-flatten remaining))\n      :else (cons firstele (my-flatten remaining)))))","user":"506f0968e4b09350ab4199f5"},{"problem":28,"code":"(fn [coll]\n  (loop [flattened [] \n         [h & r] coll]\n    (if ((complement sequential?) h)\n        (if (empty? r) \n          (conj flattened h)\n          (recur (conj flattened h) r))\n        (recur flattened (concat h r))\n      )\n    )\n  )","user":"554680cbe4b0a04f7929953e"},{"problem":28,"code":"(fn function[coll]\n  (let[l(first coll) n (next coll)]\n    (concat\n     (if (sequential? l)\n       (function l)\n       [l])\n     (when (sequential? n)\n       (function n)))))","user":"53bf9cfbe4b0c98a41f5cca4"},{"problem":28,"code":"(fn my-flatten [xs]\n  (reduce (fn [ys y]\n            (if (sequential? y)\n              (apply conj ys (my-flatten y))\n              (conj ys y)))\n          []\n          xs))","user":"5512cd55e4b055c2f668d4ba"},{"problem":28,"code":"(fn flat [input]\n  (apply concat\n         (for [i input]\n           (if (coll? i)\n             (flat i)\n             (list i)))))","user":"56732c84e4b05957ce8c611c"},{"problem":28,"code":"(fn flat [x]\n  (if (empty? x) ()\n\t(if (or (list? (first x)) (vector? (first x)))\n  \t  (concat (flat (first x)) (flat (rest x)))\n  \t  (conj (flat (rest x)) (first x))\n    )))","user":"56d5c1b0e4b0ea9b8538f7c3"},{"code":"(fn flat [coll]\n  (let [f (first coll) r (next coll)]\n    (concat\n     (if (sequential? f)\n       (flat f)\n       [f])\n     (when (sequential? r)\n       (flat r)))))","problem":28,"user":"52d885afe4b09f7907dd1398"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst)\n    ()\n\n    (sequential? (first lst))\n    (concat (my-flatten (first lst))\n            (my-flatten (rest lst)))\n\n    :else\n    (cons (first lst)\n          (my-flatten (rest lst)))))","user":"5aa2f1dee4b0d174b936c865"},{"problem":28,"code":"(fn Flatten-a-Sequence\n  [lst]\n  (if (empty? lst)\n     lst\n     (if (list? (first lst))\n       (concat (Flatten-a-Sequence (first lst)) (Flatten-a-Sequence (rest lst)))\n       (if (vector? (first lst))\n         (concat (Flatten-a-Sequence (first lst)) (Flatten-a-Sequence (rest lst)))\n         (cons (first lst) (Flatten-a-Sequence (rest lst)))))))","user":"59e14ee3e4b08badc2a0c50c"},{"problem":28,"code":"(fn [xs]\n  (lazy-seq\n   (reduce (fn --internal-flatten [col v]\n             (if (sequential? v)\n               (reduce --internal-flatten col v)\n               (conj col v)))\n           []\n           xs)))","user":"592518f0e4b072a2710fce68"},{"problem":28,"code":"#(clojure.walk/postwalk (fn [x] (if (sequential? x) (apply concat x) [x])) %)","user":"4e7be091535db169f9c796ba"},{"problem":28,"code":"(fn flat [x]\n  (loop [xs x res []]\n  \t(if (empty? xs) res (recur (next xs)(concat res (if (coll? (first xs)) (flat (first xs)) [(first xs)]))))))","user":"561e2b33e4b064ca9f4b16ba"},{"code":"(fn fl3\n  [coll] (let [\n    x (first coll)\n    xs (rest coll)]\n    (println \"x\" x \"  \\txs\" xs)\n    (into\n      (if (sequential? x) (fl3 x) [x])\n      (if (empty? xs) [] (fl3 xs)))))","problem":28,"user":"52387f46e4b0fae3832e9a07"},{"code":"(fn flat\n  [coll]\n  (let [f (first coll) r (next coll)]\n    (concat\n     (if (sequential? f)\n       (flat f)\n       [f])\n     (when (sequential? r)\n       (flat r)))))","problem":28,"user":"52527192e4b0541d1855b8af"},{"code":"(fn f [x]\n  (seq (reduce\n   (fn [a b]\n     (if (coll? b)\n      (concat a (f b))\n      (conj (vec a) b)))\n   []\n   x)))","problem":28,"user":"5185e17ee4b0da5a5be3bac5"},{"code":"(fn mflatten [s]\n  (let [el (first s)]\n      (cond (empty? s)\n            s\n            (or (list? el) (vector? el))\n            (concat (mflatten el) (mflatten (rest s)))\n            :else\n            (cons el (mflatten (rest s))))))","problem":28,"user":"4e0d5a5a535d04ed9115e7b5"},{"code":"(fn [col]\n  (let [flatter (reduce (fn [acc e] (if (or (vector? e) (seq? e)) (concat acc e) (concat acc [e]))) (list) col)]\n  (if (= flatter col)\n    col\n    (recur flatter))))","problem":28,"user":"4f06f90a535dcb61093f6c1b"},{"code":"(fn flatten-sequence [n]\n\t(let [[x & xs] n]\n\t\t(cond\n\t\t\t(empty? n) '()\n\t\t\t(coll? x) (concat (flatten-sequence x) (flatten-sequence xs))\n\t\t\t:else (cons x (flatten-sequence xs)))))","problem":28,"user":"50ed8a5fe4b06330c1f87c3d"},{"problem":28,"code":"(partial\n (fn flatten-recur [flat coll]\n   (reduce\n    (fn dig-in [flat curr]\n      (if (coll? curr)\n        (flatten-recur flat curr)\n        (conj flat curr)))\n    flat\n    coll))\n [])","user":"5ed52854e4b016b56eae05d2"},{"code":"(fn [x]\n   (filter \n     (complement sequential?) \n     (rest (tree-seq sequential? seq x))))","problem":28,"user":"50fd027be4b0d10d794c19fe"},{"code":"(fn ! \r\n  ([] '())\r\n  ([x] (if (sequential? x)\r\n          (if (= nil (next x))\r\n            (! (first x))\r\n            (concat (!(first x)) (!(next x))))\r\n          (list x)))\r\n  ([x & xs] (concat (! x) (! xs))))","problem":28,"user":"5020d033e4b0cb6ebc0a42fa"},{"code":"(fn flat [coll]\n  (if (coll? coll)\n    (reduce #(apply conj %1 (flat %2)) [] coll)\n    [coll]))","problem":28,"user":"52525a0ee4b0541d1855b8a2"},{"problem":28,"code":"(fn my-flatten[x] (if (sequential? x) (if (not-empty x) (concat (my-flatten (first x)) (my-flatten (rest x))) x) (cons x nil) ))","user":"548485f5e4b0e286459a119f"},{"problem":28,"code":"(fn flat [xcoll]\n  (list* (loop [coll xcoll\n                ans []]\n           (if (empty? coll)\n             ans\n             (recur (next coll) (if (coll? (first coll))\n                           (into ans ( flat (first coll)))\n                           (conj ans (first coll))))))))","user":"56038f34e4b04bb52996e1bc"},{"code":"(fn flt[lst]\n  ((fn add-all [lst acc]\n    (cond \n     (empty? lst) acc\n     (coll? (first lst)) (add-all (rest lst) (add-all (first lst) acc))\n     :else (add-all (rest lst) (conj acc (first lst)))))\n   lst []))","problem":28,"user":"52b405e1e4b0c58976d9ad15"},{"problem":28,"code":"#(\n         reduce (fn fun [collection element]\n                  (\n                    if (sequential? element)\n                    (reduce fun collection element)\n                    (conj collection element)\n                    )) [] %\n         )","user":"5eee9352e4b07c55ae4a0512"},{"code":"#(remove % (tree-seq % seq %2))\r\nsequential?","problem":28,"user":"4dce6e41535d5973398f92a2"},{"problem":28,"code":"(fn flat [s]      \n       (if (coll? s)    \n         (concat     \n          (flat (first s))\n          (flat (next s))) \n        (when (not (nil? s)) \n          (list s))))","user":"57501de0e4b02ea11479926c"},{"problem":28,"code":"(fn flt [oinput]\n  (loop [accum [] input oinput]\n    (if (seq input)\n      (let [ele (first input)]\n        (if (sequential? ele)\n          (recur (apply conj accum (flt ele)) (rest input))\n          (recur (conj accum ele) (rest input))))\n      accum)))","user":"543b12cce4b032a45b86932a"},{"code":"(fn flat\n  [s]\n    (if (empty? s) s\n    (if (coll? (first s))\n        (into (flat (rest s)) (reverse (flat (first s))))\n        (conj (flat (rest s)) (first s)))))","problem":28,"user":"4f91a38ae4b0dcca54ed6c9f"},{"problem":28,"code":"(fn myflatten[xs]\n  (reduce (fn [m a] \n            (if (coll? a) \n              (concat m (myflatten a)) \n              (concat m (cons a ())))) \n          '()\n          xs\n    )\n )","user":"5d5e0259e4b0c9e5857d4fef"},{"code":"(fn fl [l]\n   (mapcat\n    #(if (coll? %)\n      (fl %)\n      [%]\n      )\n    l\n    )\n   )","problem":28,"user":"4e99a255535dbda64a6f6b67"},{"problem":28,"code":"(fn flat [data]\n    (reduce \n      #(if (coll? %2)\n          (concat %1 (flat %2))\n          (conj (vec %1) %2))\n      [] data))","user":"5c68f931e4b0fca0c16226ea"},{"problem":28,"code":";(fn foo [li]\n;  (if (empty? li)\n;        nil\n;      (let [[h & r] li]\n;         (if (sequential? h)\n;             (into (foo r) (reverse (foo h)))\n;             (cons h (foo r))))))\n  \n  \n(fn foo [li]\n  (if (empty? li)\n        nil\n      (let [[h & r] li]\n         (if (sequential? h)\n             (concat (foo h) (foo r))\n             (cons h (foo r))))))","user":"59156f0be4b0163c97b36f3d"},{"problem":28,"code":"#(letfn [(my-flatten [xs]\n           (loop [x (first xs)\n                  xs (rest xs)\n                  ys []]\n             (if (nil? x)\n               (seq ys)\n               (if (coll? x)\n                 (recur (first x) (concat (rest x) xs) ys)\n                 (recur (first xs) (rest xs) (conj ys x))))))]\n   (my-flatten %))","user":"58bb218be4b0888cdc949cf4"},{"problem":28,"code":"#(filter (complement coll?)\n        (tree-seq coll? seq %))","user":"4f392fc8e4b0e243712b1ee7"},{"problem":28,"code":"(fn my-flatten [coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (if (sequential? (first s))\n       (concat (my-flatten (first s)) (my-flatten (rest s)))\n       (cons (first s) (my-flatten (rest s)))))))","user":"5fd2e391e4b07e53c2f3f049"},{"problem":28,"code":"(fn my-flat\n  [c]\n  (if (sequential? c)\n    (mapcat my-flat c)\n    (list c)))","user":"577bf999e4b0d3393e5deb2c"},{"problem":28,"code":"(fn flaten [s]\n  (if (empty? s)\n    '()\n    (if (coll? (first s))\n      (concat (flaten (first s)) (flaten (rest s)))\n      (cons (first s) (flaten (rest s))))))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn my-flatten [lst]\r\n  (filter (complement sequential?) (rest (tree-seq sequential? seq lst))))","problem":28,"user":"4f629697e4b0defedf855fd6"},{"problem":28,"code":"reduce (fn flat [x y] \n         (if (sequential? y)\n           (concat x (reduce flat [] y))\n           (concat x [y]))\n           ) []","user":"59663e77e4b069c0a1a1979f"},{"problem":28,"code":"(fn f [x] \n  (if (> (count x) 0)\n    (if (coll? (first x)) (concat (f (first x)) (f (rest x))) (conj (f (rest x)) (first x)))\n    x\n  )\n)","user":"54a7efdee4b09f271ff37c9d"},{"code":"(fn fl [x]\n  (when-let [s (seq x)]\n    (if (coll? (first s))\n      (concat (fl (first s)) (fl (rest s)))\n      (cons (first s) (fl (rest s))))))","problem":28,"user":"50c32086e4b00e537d00253d"},{"code":"#(filter\r\n  (complement sequential?)\r\n  (rest (tree-seq sequential? seq %)))","problem":28,"user":"4de760a3535d08e6dec9fdf9"},{"code":"(fn [x] \n  (remove sequential? (tree-seq sequential? seq x)))","problem":28,"user":"4ec42c11535dcc7ae8597d5f"},{"code":"(fn f [x]\n  (if \n    (sequential? x) (mapcat f x)\n    (list x)))","problem":28,"user":"4f4fac2ae4b03ad3f0c10ce5"},{"problem":28,"code":"#(if (sequential? %)\n    ((fn flat [y] (if (sequential? y) (mapcat flat y) [y])) %)\n    %)","user":"5d63b06be4b0c9e5857d5025"},{"code":"(fn my-flat [x]\n  (if (#(or (seq? %) (list? %) (vector? %)) x)\n    (reduce concat (map my-flat x))\n    [x]\n  )\n)","problem":28,"user":"50e4ff72e4b049a987753897"},{"problem":28,"code":"(fn flat [x] \n  (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","user":"5ee6d30ce4b029a2061bbe9c"},{"problem":28,"code":"#(reduce (fn myflatten [collection element]\n            (if (sequential? element)\n              (reduce myflatten collection element)\n              (conj collection element))) [] %)","user":"5d965c73e4b0d3f9b434ad33"},{"problem":28,"code":"(fn flat [ss] (if (sequential? ss)\n                       (mapcat flat ss)\n                       [ss]))","user":"5e453725e4b01d43a70e8e93"},{"problem":28,"code":"(fn flatten-a-sequence\n  [coll]\n    (let [l (first coll)\n          r (rest coll)]\n\n      (concat\n       (if (sequential? l)\n         (flatten-a-sequence l)\n         (vector l))\n\n       (when-not (empty? r)\n         (if (sequential? r)\n           (flatten-a-sequence r)\n           (vector r))))))","user":"5501a1e1e4b07d26eda61d75"},{"code":"#(remove %1 (tree-seq %1 seq %2)) sequential?","problem":28,"user":"4e823ed7535db62dc21a62c7"},{"problem":28,"code":"(fn op [x] \n  (if (or (vector? x) (list? x))\n    (apply concat (map op x))\n    (list x)\n    )\n  )","user":"57e404a3e4b0bfb2137f5ab1"},{"code":"(fn [xs]\n    (filter (complement sequential?) (tree-seq sequential? seq xs)))","problem":28,"user":"506b0a9ce4b0a2a5463de380"},{"problem":28,"code":"(fn makeflat [flatseq x]\n  (if (or (list? x) (vector? x))\n    (reduce makeflat flatseq x)\n    (conj flatseq x)\n  )\n) []","user":"57cc14aae4b05aa3c4741d4a"},{"code":"#(mapcat (fn wa [x] (if-not (coll? x) (list x) (mapcat wa x))) %)","problem":28,"user":"52747090e4b03e8d9a4a74a5"},{"problem":28,"code":"(fn [xs] (loop [flat [] xs xs]\n  (if (empty? xs)\n    flat\n    (let [first (first xs) the-rest (rest xs)]\n      (if (sequential? first)\n        (recur flat (apply merge the-rest (reverse first)))\n        (recur (conj flat first) the-rest)\n      )\n    )\n  )\n))","user":"55d79b87e4b0e31453f64aa8"},{"problem":28,"code":"(fn flt [lst]\n  (if (coll? lst)\n    (reduce concat () (map flt lst))\n    [lst]))","user":"5649542fe4b0284900eef63f"},{"code":"(fn flat [coll]\n  (reduce (fn [acc item]\n            (if (coll? item)\n              (into acc (flat item))\n              (conj acc item)))\t\n          []\n          coll))","problem":28,"user":"508e26c2e4b0f17d83ea26ca"},{"problem":28,"code":"(fn [ve]\n  (->> (tree-seq sequential? identity ve)\n       (filter (comp not sequential?))))","user":"5783c505e4b0ebec4cfb74bc"},{"problem":28,"code":"(fn flat [sequ]\n  (loop [in sequ out '()]\n    (let [prim (first in)]\n      (if (nil? prim) (reverse out)\n        (if (or (list? prim) (vector? prim) (map? prim) (set? prim))\n          (recur \n            (rest in) \n            (concat (reverse (flat prim)) out)\n          )\n          (recur (rest in) (conj out prim))\n        )\n      )\n    )\n  )\n)","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":28,"code":"(fn myflat [v]\n  (if-not (empty? v)\n    (if-not (sequential? v)\n      [v]\n      (let [f (first v) r (rest v)]\n        (if-not (sequential? f)\n          (concat [f] (myflat r))\n          (concat (myflat f) (myflat r)))))))","user":"57b35ecbe4b0fbc9809a277e"},{"problem":28,"code":"#(->> %\n        ;; note: vectors are not seq? but are sequential?\n        (tree-seq sequential? seq)\n        (filter (complement sequential?)))","user":"58db48a5e4b0a4d5acaab679"},{"problem":28,"code":"(fn [s]\n  (loop [result [] s s]\n    (if (empty? s)\n      result\n      (let [[f & t] s]\n        (if (sequential? f)\n          (recur result (concat f t))\n          (recur (conj result f) t)\n          )\n        )\n      )\n    )\n  )","user":"57c7e7d9e4b05aa3c4741d0f"},{"problem":28,"code":"(fn a [x] (reduce #(if(sequential? %2) (reduce conj % (a %2)) (conj % %2)) [] x))","user":"5971763fe4b01722bebd4c72"},{"code":"(fn my-flatten [xs]\n  (if (empty? xs)\n    xs\n    (if (coll? (first xs))\n      (concat (my-flatten (first xs)) (my-flatten (rest xs)))\n      (cons (first xs) (my-flatten (rest xs))))))","problem":28,"user":"533ce38ce4b085b17e897d77"},{"code":"(fn [s]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq s)))","problem":28,"user":"515f10dce4b02c55805ea23b"},{"problem":28,"code":"(fn flat\n  [lst]\n  (mapcat #(if (coll? %)\n             (flat %)\n             (vector %))\n          lst))","user":"5733e4aee4b0cd1946bd0ffe"},{"problem":28,"code":"(fn [x]\n   (reverse ((fn f [x acc]\n               (if (or (= Long (type (first x)))\n                       (= String (type (first x)))\n                       (= clojure.lang.Keyword (type (first x))))\n                 (if (empty? (rest x))\n                   (conj acc (first x))\n                   (f (rest x) (conj acc (first x))))\n                 (if (empty? (first x))\n                   (if (not (empty? (rest x)))\n                     (f (rest x) acc))\n                   (if (not (empty? (rest x)))\n                     (f (rest x) (f (first x) acc))\n                     (f (first x) acc)))))\n             x '())))","user":"5af047b8e4b0cc2b61a3bc48"},{"problem":28,"code":"(fn flat [xs]                                                         \n        (cond                                                                  \n          (empty? xs) '()                                                     \n          (not (coll? (first xs))) (cons (first xs) (flat (rest xs)))        \n          :else (concat (flat (first xs)) (flat (rest xs)))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":28,"code":"#(reduce (fn f [a b] (if (coll? b)\n                       (reduce f a b)\n                       (conj a b))) [] %)","user":"52281e1ee4b0186687e23a69"},{"problem":28,"code":"(fn f\n  ([col] (f (first col) (rest col) []))\n  ([e col result]\n   (cond \n     (nil? e)   result\n     (sequential? e) (recur (first col) (rest col) (f (first e) (rest e) result))\n     :else  (recur (first col) (rest col) (conj result e))\n    )))","user":"54af6fb0e4b09f271ff37d08"},{"code":"(fn f [x] (if (sequential? x) (mapcat f x) (list x)))","problem":28,"user":"51dd5d6fe4b0c33a4e1da406"},{"problem":28,"code":"(fn custom-flatten [coll] (if (sequential? coll) (mapcat custom-flatten coll) (list coll)))","user":"55f330dde4b06e875b46ce56"},{"code":"(fn flt [coll]\n  (let \n    [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)  (flt l)  [l])\n      (if (sequential? r)  (flt r)  [])\n\t)\n  )\n)","problem":28,"user":"5254f908e4b0541d1855b9ba"},{"problem":28,"code":"(fn flat [a] (apply concat (for [b a] (do (if (coll? b) (flat b) [b])))))","user":"53beacf9e4b0d9a98559a6e3"},{"problem":28,"code":"(fn flat [x] (if (> (count x) 0) (if (sequential? (first x)) (concat (flat (first x)) (flat (rest x))) (conj (flat (rest x)) (first x))) (first x)))","user":"54bfc203e4b0ed20f4ff6f08"},{"problem":28,"code":"(fn [col]\n  (letfn [(nested [cur acc]\n            (cond\n              (not (coll? cur)) (conj acc cur)\n              (empty? cur) acc\n              :else (nested (first cur) (nested (rest cur) acc))))]\n    (nested col ())))","user":"55f1f0d1e4b06e875b46ce3b"},{"code":"(fn f [x] (if (coll? x) (mapcat f x) [x]))\n\n;(fn [c]\n;  (if (= c '((1 2) 3 [4 [5 6]]))\n;    '(1 2 3 4 5 6)\n;    (if (= c [\"a\" [\"b\"] \"c\"])\n;      '(\"a\" \"b\" \"c\")\n;      '(:a))))","problem":28,"user":"4fcc103fe4b0ee37620e185f"},{"code":"#( filter (comp not coll?) (tree-seq coll? identity %1 ))","problem":28,"user":"502952c9e4b0b33e9bf6fdf1"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (empty? coll)\n    nil\n    (if (coll? (first coll))\n      (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n      (cons (first coll) (my-flatten (rest coll))))))","user":"54125eeee4b01498b1a719d3"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (mapcat my-flatten x)\n    [x]))\n\n;(fn my-flatten [coll]\n;  (loop [acc [] coll coll]\n;    (cond (empty? coll) acc\n;          (sequential? (first coll)) (recur (concat acc (my-flatten (first coll))) (rest coll))\n;          :else (recur (concat acc [(first coll)]) (rest coll)))))","user":"52f3568fe4b05e3f0be25f0e"},{"code":"(fn myflatten\n  [xs]\n  (cond\n   (empty? xs) xs\n   (sequential? (first xs)) (concat (myflatten (first xs)) (myflatten (rest xs)))\n   :else (cons (first xs) (myflatten (rest xs)))))","problem":28,"user":"50982769e4b04e098a4c726a"},{"code":"(fn deflate[data]\n  (mapcat #(if (coll? %)\n              (deflate %)\n              (conj nil %)) data))","problem":28,"user":"4eb1dd39535d7eef30807345"},{"code":";reduce\n;(fn self [xs e] (concat xs (cond (coll? e) (reduce self '() e) true (list e))))\n;'()\n\n#(filter (complement coll?) (tree-seq coll? seq %))","problem":28,"user":"533b9cace4b0e30313ee6cd1"},{"problem":28,"code":"(fn my-flatten\n  [sequence]\n  (cond\n   (empty? sequence) '()\n   (sequential? (first sequence)) (concat (my-flatten (first sequence))\n                                          (my-flatten (rest sequence)))\n   :else (cons (first sequence) (my-flatten (rest sequence)))))","user":"52561295e4b0541d1855ba03"},{"problem":28,"code":"(fn [x] (->> x\n              (tree-seq sequential? identity)\n              (rest)\n              (filter (complement sequential?))))","user":"588906a9e4b0f1effa3b772a"},{"code":"(fn [coll] (filter #(not (sequential? %1))\n  (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":28,"code":"(fn fl [s]\n    (if (sequential? s)\n      (mapcat fl s)\n      (list s)))","user":"577202d2e4b0979f896515c0"},{"code":"(fn flat [coll]\n  (if (sequential? coll)\n    (mapcat flat coll)\n    (list coll)))","problem":28,"user":"522404d8e4b01819a2de42c0"},{"problem":28,"code":"(fn flatten-it [x]\n  (if (coll? x)\n    (reduce concat [] (map flatten-it x))\n    [x]))","user":"57abff53e4b0b8559636fc81"},{"problem":28,"code":"(fn flat [s]\n  (let [[x & xs] s]\n    (cond\n     (empty? s) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","user":"58e965b3e4b056aecfd47d08"},{"problem":28,"code":"(fn my-flatten [coll]\n      (cond\n        (empty? coll)\n          ()\n        (sequential? (first coll))\n          (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n        :else\n          (cons (first coll) (my-flatten (rest coll)))))","user":"53dc94c8e4b094d41abdfefc"},{"code":"(fn [z]\n      (letfn\n        [(flatt [x]\n          (reduce \n            (fn [val y]\n              (if (coll? y) \n                (concat val (flatt y))\n                (conj (vec val) y)))\n            []\n            x))]\n        (flatt z)))","problem":28,"user":"4e80e0f2535db62dc21a62b8"},{"problem":28,"code":"{'((1 2) 3 [4 [5 6]]) [1 2 3 4 5 6] [\"a\" [\"b\"] \"c\"] [\"a\" \"b\" \"c\"] '((((:a)))) '(:a)}","user":"59390a35e4b02506e01a29f3"},{"code":"(fn [s]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","problem":28,"user":"4e6a73d0535d8ccf87e9fee7"},{"code":"(fn [s]\n  (filter (complement sequential?)\n          (next (tree-seq sequential? seq s))))","problem":28,"user":"4e50c894535dc968683fc4ee"},{"problem":28,"code":"#(reduce (fn f [a-coll x]\n          (if (sequential? x)\n            (into a-coll (reduce f [] x))\n            (conj a-coll x))) [] %)","user":"5054d243e4b0b1b9d1860eb5"},{"code":"(fn [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e570b60535d8a8b8723a286"},{"problem":28,"code":"(fn f [s]\n   (if (sequential? s)\n     (mapcat f s)\n     ;; (apply concat (apply map f s))\n     (list s)))","user":"56b306c6e4b0982f16b37e0e"},{"problem":28,"code":"(fn flat [x] (if (coll? x) (mapcat flat x) [x]))\n\n; (comp (partial remove coll?)\n;      (partial tree-seq coll? seq))\n\n; (fn [s]\n;  (filter (complement sequential?)\n;    (tree-seq sequential? seq s)))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":28,"code":"(fn flt [col]\n  (reduce\n    (fn [c x]\n      (if (coll? x)\n        (into c (flt x))\n        (conj c x)))\n    []\n    col))","user":"5e17509fe4b00200644e3d52"},{"code":"(fn flat [acol] \n  (mapcat #(if (coll? %1)\n               (flat %1)\n               [%1])\n          acol))","problem":28,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":28,"code":"(fn fltn [x]\n  (let [head (first x)\n        tail (rest  x)]\n    (if (empty? x) '()\n        (if (sequential? head)\n          (concat (fltn head) \n                  (fltn tail))\n          (cons head\n                (fltn tail))))))","user":"54696109e4b00cfc9eacc146"},{"problem":28,"code":"(fn outer [coll]\n   (mapcat (fn inner [e]\n             (if (coll? e)\n               (outer (mapcat inner e ))\n               [e])\n             ) coll))","user":"60836285e4b0736b099e42e4"},{"code":"(fn fl [x] (if (coll? x) (mapcat fl x) [x]))","problem":28,"user":"518e7d3be4b051adb72789f0"},{"code":"(fn f [s] (mapcat #(if (sequential? %) (f %) [%]) s) )","problem":28,"user":"539ec9f9e4b0ca733b974491"},{"problem":28,"code":"(fn [x]\n  (let [flattened (mapcat (fn [item] (if (not (coll? item)) (list item) item)) x)]\n    (if (= flattened x)\n      x\n      (recur flattened))))","user":"549ffeade4b0f3d1d8e70fb2"},{"code":"(fn flt [s]\n(if (sequential? s)\n(mapcat flt s)\n(list s)))","problem":28,"user":"513caa36e4b0b86ece9f3229"},{"problem":28,"code":"(fn flatify [coll]\n  (loop [remainder coll\n         result []]\n    (if (empty? remainder)\n      result\n      (if (coll? (first remainder))\n        (recur (rest remainder)\n               (concat result (flatify (first remainder))))\n        (recur (rest remainder)\n               (concat result [(first remainder)]))))))","user":"542725fce4b01498b1a71b22"},{"problem":28,"code":"(fn [x] (filter (complement sequential?)\n(rest (tree-seq sequential? seq x))))","user":"59ab8beee4b08cbb53654d9e"},{"problem":28,"code":"(fn flat [col] \n    (mapcat (fn [item] \n              (if (coll? item) \n                (flat item) [ item ])) \n            col))","user":"5f0e8312e4b0f30dddfb5d5b"},{"problem":28,"code":"#(loop [x %]\n  (if-not (some coll? x)\n    x\n    (recur (mapcat (fn [a] (if (coll? a) a [a])) x)))\n)","user":"57440f77e4b0c285004e8ab5"},{"code":"(fn myflat [x]\n  (filter (complement sequential?)\n          (rest \n            (tree-seq sequential? seq x)))\n)","problem":28,"user":"4fbfbd4fe4b081705acca31c"},{"problem":28,"code":"(fn ! [x]  (if (sequential? x)\n                       (mapcat ! x )\n                       [x]))","user":"548f7bf1e4b0e286459a123b"},{"code":"(fn [ls] (filter (complement sequential?) (rest (tree-seq sequential? seq ls))))","problem":28,"user":"4f03ba9c535dcb61093f6b58"},{"problem":28,"code":"(fn flaten [xs]\n   (apply concat (for [x xs]\n                   (if (sequential? x)\n                     (flaten x)\n                     [x]))))","user":"4fec08e8e4b0681fd128dc9d"},{"code":"(fn\n   [nested]\n   ((fn r-nest\n      [r x]\n      (reduce #(if-not (coll? %2)\n                 (conj % %2)\n                 (r-nest % %2))\n              r x))\n    [] nested))","problem":28,"user":"529223cbe4b0239c8a67af26"},{"problem":28,"code":"(fn flattenX [res seq]\n   (if (empty? seq)\n     res\n     (if (coll? (first seq))\n          (flattenX res (concat (first seq) (rest seq)))\n          (flattenX (conj res (first seq)) (rest seq))))) []","user":"5508102ee4b021ccfedb96b0"},{"problem":28,"code":"(fn fl [xs] (prn xs) (if (and (sequential? xs) (seq xs)) (mapcat fl xs) (list xs)))","user":"58c2df0ae4b021aa9917ed17"},{"problem":28,"code":"(fn [coll]\n  (loop [[x & xs] coll\n         tmp []\n         flat []]\n    (cond\n       (nil? x) flat\n       (coll? x) (recur x (conj tmp xs) flat)\n       (seq xs) (recur xs tmp (conj flat x))\n       :else (recur tmp [] (conj flat x)))))","user":"57a775bbe4b0a96607956214"},{"problem":28,"code":"(fn my-flatten \n  [lst] \n  (if (coll? lst) \n    (mapcat my-flatten lst) \n    (list lst)))","user":"57f8153de4b0d3187e900916"},{"problem":28,"code":"#(letfn [(flatter [from to]\n            (cond\n              (empty? from) to\n              (-> (first from) (sequential?)) (-> (concat (first from) (rest from)) (recur to))\n              :else (recur (rest from) (cons (first from) to)))\n                  )]\n     (reverse (flatter % []))\n   )","user":"5b118b7be4b0cc2b61a3be34"},{"code":"(fn f [l] (let [a (first l) b (next l)]\n            (concat\n              (if (coll? a) (f a) [a])\n              (when (seq? b) (f b)))))","problem":28,"user":"4e8a880b535d65386fec210d"},{"code":"(fn f [s]\n   (let [a (first s)\n         b (rest s)]\n     (cond (nil? a) ()\n           (or (seq? a) (vector? a)) (f (concat a b))\n           :else (cons a (f b)))))","problem":28,"user":"4eda8d7c535d10e5ff6f530f"},{"problem":28,"code":"(fn f [coll]\n  (mapcat (fn [x] \n         (if (coll? x)\n           (f x)\n           [x]\n           )) coll))\n\n\n;(fn f [in out]\n;  (if (empty? in)\n;    out\n;    (if (not (coll? (first in)))\n;\t  (f (next in) (conj (first in) out))\n;      (f (conj (first in) (next in)) out))))","user":"5923554ee4b0a390037439f2"},{"problem":28,"code":"(fn f [a]\n  (if (sequential? a) (mapcat f a) (list a))\n)","user":"53da70a4e4b0e771c302549d"},{"problem":28,"code":"(fn [c] \n   (let [fab (fn f [acc x] \n              (if (coll? x) (reduce f acc (seq x)) (conj acc x)) \n              ;(list acc) \n              )] \n     (reduce fab [] c) \n     ))","user":"5c46bdbde4b0e06e1360a3a4"},{"code":"(fn myflatten [s]\n  (if (coll? s)\n    (mapcat myflatten s)\n    [s]\n  )\n)","problem":28,"user":"4fb3fec7e4b081705acca2a7"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if-not (coll? coll)\n    (list coll)\n    (apply concat (map my-flatten coll))))","user":"57f80350e4b0d3187e90090c"},{"problem":28,"code":"#(filter (comp not coll?) (tree-seq sequential? seq %))","user":"53abf519e4b047364c044456"},{"problem":28,"code":"#(some (fn [x] (when (every? (comp not coll?) x) x)) (iterate (fn [unflattened] (reduce (fn accumFlatten [col x] (apply (partial conj col) (if (coll? x) x [x]))) [] unflattened)) %))","user":"594d4c57e4b07ddc2dafae87"},{"code":"(fn f [l] (if (empty? l) '() (if (coll? (first l)) (concat (f (first l)) (f (rest l))) (cons (first l) (f (rest l))) )))","problem":28,"user":"510931ede4b0c71f76895663"},{"problem":28,"code":"(fn my-flatten [[f & r]]\n  (if (empty? r)\n    (if (or (seq? f) (vector? f))\n      (my-flatten f)\n      (list f))\n    (if (or (seq? f) (vector? f))\n      (concat (my-flatten f) (my-flatten r))\n      (concat (list f) (my-flatten r)))))","user":"58a953dae4b01a0c0b232968"},{"problem":28,"code":"(fn flat [l] (if (sequential? l) (mapcat flat l) (list l)))","user":"52e851bfe4b09f7907dd149a"},{"code":"(fn f [x]\n  (mapcat #(if (coll? %) (f %) (list %)) x)\n)","problem":28,"user":"52bf936ee4b07a9af579233b"},{"problem":28,"code":"(fn flt [x] (if (sequential? x) (mapcat flt x) (list x)))","user":"5646dff3e4b0284900eef615"},{"code":"(fn my-flatten\n   [coll] \n   (reduce #(if (coll? %2) (my-flatten (concat %1 %2)) (concat %1 (list %2))) [] coll))","problem":28,"user":"52ba447ee4b07a9af57922ce"},{"problem":28,"code":"(fn flt\n  [s]\n  (reduce (fn\n            [r e]\n            (concat r (if (coll? e) (flt e) (list e))))\n          '() s))","user":"53b2e953e4b047364c04449e"},{"code":"(fn f ([c] (f [] c) ) ([t c] (reduce #(if (coll? %2) (f %1 %2) (conj %1 %2)) t c)))","problem":28,"user":"4fd29d7ce4b04c3a95aa0424"},{"code":"(fn flat [x]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq x)))","problem":28,"user":"4e697e41535d8ccf87e9fe9c"},{"code":"(fn myflatten [[& more]]\n  (reduce \n    (fn [v x] \n      (if (coll? x) \n        (into v (myflatten x))\n        (conj v x))) \n    [] more))","problem":28,"user":"4e47f4f3535dc968683fc4bb"},{"problem":28,"code":"(fn my [lst]\n  (if (sequential? lst)\n    (mapcat my lst)\n    (list lst)))","user":"579c7db7e4b05b1deef9ae0a"},{"problem":28,"code":"(fn flatn [seq]\n  (reduce (fn [acc val]\n            (concat acc\n                    (if (sequential? val)\n                      (flatn val)\n                      [val])))\n            []\n            seq))","user":"5bb17123e4b0a20761a234fd"},{"code":"(fn my-flatten [coll]\r\n   (if (empty? coll)\r\n          coll\r\n   (if (sequential? (first coll))\r\n     (concat \r\n         (my-flatten (first coll)) \r\n         (my-flatten (rest coll))\r\n     )\r\n     (cons \r\n       (first coll) \r\n       (my-flatten (rest coll))\r\n     )\r\n   )                                             \r\n  )\r\n)","problem":28,"user":"4e73debb535d7a570dd295b7"},{"problem":28,"code":"#(seq (reduce (fn make-flat [list item]\n                 (if (coll? item)\n                   (reduce make-flat list item)\n                   (conj list item))) [] %))","user":"586f1aa7e4b01531a375e9ba"},{"problem":28,"code":"(fn fltn\n  [list-to-flat]\n  (if (coll? list-to-flat)\n    (if (empty? list-to-flat)\n      []\n      (concat (fltn (first list-to-flat)) (fltn (rest list-to-flat))))\n    [list-to-flat]))","user":"6033c42ce4b0d5df2af222c3"},{"code":"(fn !([x & xs] (concat (if (coll? x) (apply ! x) [x]) (apply ! xs))) ([] []))","problem":28,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":28,"code":"(fn flat [x & tail]\n  (concat (if (coll? x)\n            (apply flat x)\n            [x])\n          (if (nil? tail)\n            nil\n            (apply flat tail))))","user":"5461c402e4b01be26fd746a6"},{"code":"#(filter (complement sequential?)\n  (tree-seq sequential? seq %))","problem":28,"user":"4f727023e4b07046d9f4f035"},{"code":"(fn [c]\n  (letfn [(flat-aux [xs]\n            (if (seq xs)\n                (if (sequential? (first xs))\n                  (concat (flat-aux (first xs))\n                          (flat-aux (rest xs)))\n                  (cons (first xs)\n                        (flat-aux (rest xs))))))]\n    (flat-aux c)))","problem":28,"user":"4e7c4290535db169f9c796bc"},{"problem":28,"code":"(fn flt [seq]\n    (let [f (first seq) r (next seq)]\n      (concat\n        (if (sequential? f)\n          (flt f)\n          [f])\n        (when (sequential? r)\n          (flt r)))))","user":"53a68c5ae4b0ef122a8689c8"},{"problem":28,"code":"(fn foo [coll]\n   (let [first (first coll) rest (next coll)]\n     (concat\n       (if (sequential? first)\n         (foo first)\n         [first])\n       (when (sequential? rest)\n         (foo rest)))))","user":"54eca495e4b024c67c0cf855"},{"code":"(fn f [s] (let [a (first s) b (rest s)] \n(if (coll? a) (if (empty? b) (f a) (concat (f a) (f b)))\n(if (empty? b) (list a) (cons a (f b))))))","problem":28,"user":"4ff673b3e4b0678c553fc37d"},{"code":"(fn myFlatten[seq]\n  (cond\n   (= 0 (count seq))\n   seq\n   (coll? (first seq))\n    (concat (myFlatten (first seq)) (myFlatten (rest seq)))\n   :else\n    (cons (first seq) (myFlatten (rest seq)))))","problem":28,"user":"525d490ae4b0cb4875a45d70"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (reduce #(into %1 (my-flatten %2)) [] x)\n    [x]))","user":"5606ea56e4b08b23635d317b"},{"problem":28,"code":"(fn f [coll] (mapcat #(if (coll? %) (f %) (list %)) coll))","user":"56754c4be4b05957ce8c6149"},{"problem":28,"code":"(fn [c]\n  (if (empty? (filter coll? c))\n    c\n    (recur\n      ((fn [c1]\n         (reduce\n           (fn [r x] (concat x r))\n           nil\n           ((partial map (fn [x] (if (coll? x) (seq x) (list x))))\n            (reverse c1))\n           )) c)\n      )))","user":"559a9a3de4b066d22e731f45"},{"problem":28,"code":"#(let [is_a_child (fn [s] (and (not (seq? s)) (not (vector? s))))] (filter is_a_child (tree-seq (comp not is_a_child) identity %1)))","user":"52f1bd89e4b05e3f0be25ef0"},{"problem":28,"code":"(fn flattn\n  [x]\n  \t(if (empty? x)\n      '()\n      (let [h (first x)\n            t (rest x)]\n      (if (sequential? h)\n        (concat (flattn h) (flattn t))\n        (cons h (flattn t))\n        ))))","user":"5d641841e4b0c9e5857d502e"},{"problem":28,"code":"(fn [xs] \n  (loop [xs xs acc []]\n    (if (empty? xs) \n      acc\n      (cond\n          (coll? (first xs))(recur (concat (first xs) (rest xs)) acc)\n          :otherwise (recur (rest xs) (conj acc (first xs)))))))","user":"54dce62fe4b024c67c0cf78c"},{"code":"(fn f [x] (filter #(not (coll? %)) (tree-seq coll? identity x)))","problem":28,"user":"4eb13d60535d7eef3080733f"},{"problem":28,"code":"(fn make-flat [m] (if (coll? m) (mapcat make-flat m) [m]))","user":"53ff602fe4b0de5c418485ff"},{"problem":28,"code":"(fn [li]\n  (reduce\n   (fn list-or-item [coll nxt] (if (sequential? nxt) (reduce list-or-item coll nxt) (conj coll nxt)))\n  [] li)\n)","user":"5da975b9e4b000c986472c32"},{"problem":28,"code":"(fn [seq]\n  (loop [out []\n         seq seq]\n    (let [head (first seq)\n          tail (rest  seq)]\n      (if head\n        (if (sequential? head)\n          (recur out (concat head tail))\n          (recur (conj out head) tail))\n        out))))","user":"60b66033e4b0e0fa5f1b4248"},{"code":"(fn [c] (filter (complement sequential?) (tree-seq sequential? seq c)))","problem":28,"user":"4ff8a89de4b0678c553fc39d"},{"problem":28,"code":"(fn [xs] \n  (reduce (fn my-flatten [result e]\n            (if (coll? e)\n              (reduce my-flatten result e)\n              (conj result e))) [] xs))","user":"57ebbf3ae4b0bfb2137f5b66"},{"problem":28,"code":"(fn flatten' [l]\n  (let [x (first l)\n        xs (rest l)]\n    (cond (nil? x) nil\n          (or (list? x) (vector? x)) (concat (flatten' x) (flatten' xs))\n          :otherwise (cons x (flatten' xs)))))","user":"5717ad6fe4b07c98581c3b14"},{"problem":28,"code":"(fn [a] (letfn [\r\n           (scalar? [v] (not (or (vector? v) (seq? v))))\r\n           (fi [s]  (apply concat (map #(if (scalar? %) (vector %) %) s)))\r\n           (comb [s] (loop [r (fi s)] (if (every? scalar? r) r (recur (fi r)))))\r\n \r\n\r\n              ]\r\n        (comb a)\r\n        ))","user":"56ebe773e4b04a395b9a042a"},{"problem":28,"code":"mapcat (fn myflatten [maybeseq] (if (sequential? maybeseq) (mapcat myflatten maybeseq) (list maybeseq)))","user":"54ce6eede4b057c6fda3a2ad"},{"problem":28,"code":"(fn flt [col] (let [l (first col) r (next col)] (concat (if (sequential? l) (flt l) [l]) (when (sequential? r) (flt r) ))))","user":"5425d454e4b01498b1a71b13"},{"code":";; I cheated. See https://groups.google.com/forum/?fromgroups=#!msg/clojure/sqok3RqGEC8/m63Kv_qYUDgJ\n\n(fn [coll]\n  (let [s? #(instance? clojure.lang.Sequential %)]\n    (filter (complement s?) (tree-seq s? seq coll))))","problem":28,"user":"4e0febe6535d04ed9115e7be"},{"problem":28,"code":"#(letfn [(flatten* [xs]\n          (cond\n            (not (seq xs))\n            '()\n            (sequential? (first xs))\n            (concat (lazy-seq (flatten* (first xs))) (lazy-seq (flatten* (rest xs))))\n            :else\n            (cons (first xs) (lazy-seq (flatten* (rest xs))))))]\n  (flatten* %))","user":"540e17c3e4b0addc1aec6719"},{"problem":28,"code":"(fn flt [s]\n  (let [l (first s) r (next s)]\n    (concat\n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n       (flt r)))\n        ))","user":"542c858ae4b0dad94371f2a8"},{"code":"(fn f [x]\n  (if (empty? x)\n    x\n    (if (coll? (first x))\n      (concat (f (first x)) (f (rest x)))\n      (cons (first x) (f (rest x))))))","problem":28,"user":"4f062d4a535dcb61093f6c08"},{"problem":28,"code":"(fn [list]\n  (loop [result []\n         current (first list)\n         restList (rest list)]\n    (if (sequential? current)\n      (recur result\n             (first current)\n             (concat (rest current) restList))\n      (if (nil? current)\n        result\n        (recur (conj result current)\n               (first restList)\n               (rest restList))))))","user":"55ae7adae4b03311e7b732bd"},{"code":"#(filter (complement sequential?)\n  \t      (rest (tree-seq sequential? seq %)))","problem":28,"user":"51bdc609e4b0ff155d51d2b3"},{"problem":28,"code":"(fn flatSeq [x]\n     (let [elem (first x) coll (rest x)] \n       (cond\n         (empty? x) '()\n         (sequential? elem) (concat (flatSeq elem) (flatSeq coll))\n         :else (conj (flatSeq coll) elem)\n         )\n       )\n     )","user":"5f724f55e4b02876ed9fd089"},{"code":"(fn [x] (filter (complement sequential?) \r\n(rest (tree-seq sequential? seq x))))","problem":28,"user":"4e15c301535d04ed9115e7e5"},{"code":"(fn try-flatten\n  [coll]\n  (reduce (fn\n            [accum x]\n            (if (coll? x)\n              (reduce (fn [y z] (conj y z)) accum (try-flatten x))\n              (conj accum x)))\n          []\n          coll))","problem":28,"user":"526c2340e4b03e8d9a4a7281"},{"problem":28,"code":"(fn flt [coll]\n    (let [l (first coll) r (next coll)]\n        (concat \n            (if (sequential? l)\n                (flt l)\n                [l]\n            )\n            (when (sequential? r)\n                (flt r)\n            )\n        )\n    )\n)","user":"54996971e4b0b312c081ff8d"},{"code":"(fn [coll]\r\n\"Flattens a sequence\"\r\n(letfn [(f [acc coll]\r\n(println (format \"acc=%s, coll=%s\" acc coll))\r\n(let [e (first coll)]\r\n(cond (nil? e) acc\r\n(coll? e) (f (f acc e) (rest coll))\r\n:else (f (conj acc e) (rest coll)))))]\r\n(reverse (f '() coll))))","problem":28,"user":"4e370a04535deb9a81d77f37"},{"problem":28,"code":"(fn fl1 [x]\n  (if (coll? x)\n    (mapcat fl1 x)\n    [x]))","user":"5db6cc4ae4b010eb3c36cd3b"},{"code":"#(loop [[car & cdr :as remainder] %, acc '()]\n        (cond\n         (empty? remainder)      (reverse acc)\n         (sequential? car)\n           (if (empty? car)\n             (recur cdr acc)\n             (recur (conj cdr (rest car) (first car)) acc))\n         :else (recur cdr (cons car acc))))","problem":28,"user":"519d66d2e4b037b32803f9b2"},{"code":"#(remove % (tree-seq % seq %2))\nsequential?","problem":28,"user":"4e931ebb535dbda64a6f6b08"},{"code":"(fn [x]   (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"5279cb1ae4b03e8d9a4a753f"},{"code":"(fn les [x] (if (not (sequential? x)) (list x) (loop [se x res ()] (if\n(not (= se ())) (recur (rest se) (concat res (les (first se)))) res))))","problem":28,"user":"51a7f74be4b08d8ec191b802"},{"problem":28,"code":"(fn flat [n]\n   (let [[x & xs] n]\n     (cond\n       (empty? n) '()\n       (coll? x) (concat (flat x) (flat xs))\n       :else (cons x (flat xs)))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":28,"code":"(fn flt\n  [coll]\n  (if (not (sequential? coll))\n    (list coll)\n    (if (empty? coll)\n      coll\n  (concat (flt (first coll)) (flt (rest coll))))))","user":"543c39e0e4b032a45b86933d"},{"problem":28,"code":"(fn my-flatten [sequence]\n  (loop [cursor sequence\n         output []]\n    (if (= 0 (count cursor))\n      output\n      (if (some #(% (first cursor)) [seq? vector?])\n        (recur (rest cursor) (apply conj output (my-flatten (first cursor))))\n        (recur (rest cursor) (conj output (first cursor)))))))","user":"5f79bff2e4b02876ed9fd0ca"},{"code":"#(filter (complement sequential?)\n    (rest (tree-seq sequential? seq %1)))","problem":28,"user":"4f5595d4e4b0a7574ea71805"},{"problem":28,"code":"(fn flat [coll]\n  (loop [result '()\n         [head & currrest :as current] '()\n         parentrest (list coll)]\n    (cond\n     (and (empty? parentrest) (empty? current)) (reverse result)\n     (empty? current) (recur result (first parentrest) (rest parentrest))\n     (or (seq? head) (vector? head))\n         (recur result (seq head) (cons currrest parentrest))\n     :else (recur (cons head result) currrest parentrest)\n    )\n  )\n)","user":"5abeb697e4b073f177442725"},{"code":"(fn twentyeight [[x & xs :as whole]]\r\n  (lazy-seq (if (empty? whole)\r\n              whole\r\n              (if (sequential? x)\r\n                (concat (twentyeight x) (twentyeight xs))\r\n                (conj (twentyeight xs) x)))))","problem":28,"user":"4e2110c7535d04ed9115e813"},{"problem":28,"code":"(fn [s]\n   (let [flat (fn this [s & [acc]]\n                (loop [acc (or acc [])\n                       s s]\n                  (if (empty? s)\n                    acc\n                    (let [el (first s)]\n                      (if (sequential? el)\n                        (recur (this el acc) (rest s))\n                        (recur (conj acc el) (rest s)))))))]\n     (seq (flat s))))","user":"52475451e4b05ef8e38e6362"},{"code":"(fn flatty [xs] \n  (reduce \n    (fn [ys y] \n      (if (sequential? y) \n         (into ys (flatty y)) \n         (conj ys y))) [] xs))","problem":28,"user":"4f047542535dcb61093f6bc7"},{"problem":28,"code":"(fn my-flatten   [lst]\n  (if (empty? lst)\n    lst\n    (if (or (list? (first lst)) (vector? (first lst)))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (cons (first lst) (my-flatten (rest lst))))))","user":"59deba46e4b01968742fed7f"},{"problem":28,"code":"#((fn flat [x y]\n\t\t(loop\n\t\t\t[s x\n\t\t\tr y]\n\t\t\t(if (empty? s)\n\t\t\t\tr\n\t\t\t(if (coll? (first s))\n\t\t\t\t(concat (flat (first s) r) (flat (rest s) []))\n  \t\t\t\t(flat (rest s) (conj r (first s))))))) % [])","user":"56c5db15e4b05cc29241eeac"},{"problem":28,"code":"#(\n(fn foo [x r]\n\t(cond\n\t\t(nil? x) r\n\t\t(not (coll? x)) (conj r x)\n\t\t:else \n\t\t\t(loop [n x, tr r]\n\t\t\t\t(if (empty? n)\n\t\t\t\t\ttr\n\t\t\t\t\t(recur (rest n) (foo (first n) tr))))\n\t\t))\n% [])","user":"568cea39e4b0dcc4269f40bc"},{"problem":28,"code":"#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %)))\n; clojure impl","user":"5e13a6b7e4b099d064963001"},{"problem":28,"code":"(fn [i]\n           (loop [in (seq i)\n                  out []]\n             (if (empty? in)\n               out\n\n\n                 (if (sequential? (first in))\n                   (recur (concat (first in) (rest in)) out)\n                   (recur (rest in) (conj out (first in))\n                     )\n                   )\n             )\n             )\n\n  )","user":"54903056e4b0b312c081ff2e"},{"problem":28,"code":"(fn flatten-er\n\n  ;; Analysis\n  [collection]\n\n  ;; 1.) The final collection is converted to a seq.\n  (seq\n    (reduce\n      (fn my-flatten [v e]\n        (if (coll? e)\n          (reduce my-flatten v e)\n          (conj v e)))\n      []\n      collection)))","user":"568aa458e4b0dcc4269f4092"},{"problem":28,"code":"#(loop [w % r []]\n   (if (empty? w)\n     r\n     (if (sequential? (first w))\n       (recur (concat (first w) (rest w)) r)\n       (recur (rest w) (conj r (first w))))))","user":"5fb3a096e4b08cb800c85b35"},{"code":"#((fn fltn [coll] \n  \t(let [h (first coll)\n\t\t\t  t (next coll)]\n\t\t\t(concat \n\t\t\t\t(if (sequential? h) (fltn h) [h])\n\t\t\t\t(if (sequential? t) (fltn t))))) %)","problem":28,"user":"4ee91d00535d93acb0a6688b"},{"problem":28,"code":"(fn myflatten [s]\n  (if\n    (or (seq? s) (vector? s))\n    (apply concat (map myflatten s))\n    (list s)\n  )\n)","user":"563758e3e4b0bfe05bf117d5"},{"problem":28,"code":"(fn test-flatten [x]\n  (if (and (coll? x) (seq x))\n    (reverse (reduce (fn [acc z] (apply conj acc (test-flatten z))) '() x))\n  (list x)))","user":"547fbe01e4b0c51c1f4d7321"},{"problem":28,"code":"(fn fltn [s]\n  (if (coll? s) (mapcat fltn s)\n      [s]))","user":"55d0e76ae4b0e31453f64a40"},{"problem":28,"code":"(fn f [s] (if (sequential? s)\n             (apply concat (map f s))\n             [s]))","user":"550aeddae4b06e50f9beb135"},{"code":";; A solution using lists requires a weird order of arguments to into and a reverse\n;;(fn flat[s] (if (not (coll? s)) (list s) ;; if we are given a single element, we return a list of that element\n;;              (if (empty? s) '() ;; flattening an empty collection gives us an empty list\n;;                (into  (flat (rest s)) (reverse (flat (first s))))))) ;; into adds elements one-by-one to front, so need to reverse\n                \n;; from repl:  (flat [[[1 2] [[[3 [[4 5]]] 6 7]] 8 9 10 ]]) works\n\n;; note that \"into\" on vectors gives the right order, so it's easier to put together a vector, not a list\n\n(fn flat[s] (if (not (coll? s)) (vector s) ;; if we are given a single element, we return a list of that element\n              (if (empty? s) [] ;; flattening an empty collection gives us an empty list\n                (into  (flat (first s)) (flat (rest s))))))","problem":28,"user":"50fac9e3e4b07934dda8b0d1"},{"problem":28,"code":"; dumb recursive reduce concat\n;(fn f [ys] \n;  (reduce concat '()\n;    (for [y ys]\n;      (if (sequential? y)\n;        (f y)\n;        (list y)))))\n\n; use mapcat to recurse\n\n (fn f [ys] (if (sequential? ys) (mapcat f ys) (list ys)))","user":"541e2ff8e4b01498b1a71a8a"},{"code":"(fn f [l] \n  (cond \n    (empty? l) l\n    (counted? (first l)) (concat (f (first l)) (f (rest l)))\n    :else (conj  (f (rest l)) (first l))))","problem":28,"user":"51e6a2bce4b0ab43cc26c21d"},{"code":"(letfn [(flt [coll]\n        (when-let [s (seq coll)]\n        (let [fst (first s) nxt (next s)]\n        \t(if (coll? fst) (concat (flt fst) (flt nxt))\n                            (cons fst (flt nxt) ) ))))]  \n             flt)","problem":28,"user":"51729002e4b044b2ef48a850"},{"problem":28,"code":"(fn [col]\n\t(let [rep (fn [col] \n\t\t(apply concat \n\t\t\t((fn [x] \n\t\t\t    (cond \n\t\t\t    \t(not-any? coll? x) (map #(list %) x) ;\n\t\t\t    \t(not-every? coll? x) (map #(if (coll? %) % (list %)) x) ;\n\t\t\t\t    :else x  ;\n\t\t\t    )) col) \n\t    )\n\t)] \n\t(loop [co col]\n\t\t(if (not-any? coll? (rep co))\n\t\t\t(rep co)\n\t\t\t(recur (rep co)))\n\t\t)))","user":"5ac04101e4b073f177442737"},{"problem":28,"code":"(fn [x]\n  (filter\n    (complement \n      sequential?\n    )\n    (rest\n      (tree-seq\n       sequential?\n       seq\n       x\n      )\n    )\n  )\n)","user":"5437d022e4b032a45b869309"},{"problem":28,"code":"(fn [xs] (reduce (fn my-flatten [a b]\n                (if (coll? b)\n                    (reduce my-flatten a b)\n                    (conj a b))) [] xs))","user":"590cc457e4b047aa04b199f4"},{"problem":28,"code":"#(loop [i  (rest (seq %))\n        t (first %)\n        out []]\n   \n     (cond (nil? t)\n           (seq out) \n           (sequential? t)\n           (let [ni (reduce conj i (reverse t))\n                 nf (first ni)\n                 nr (rest ni)]\n             (recur nr nf out))\n           :else\n           (recur (rest (seq i)) (first i) (conj out t))))","user":"56f51879e4b046a417f92069"},{"code":"(fn fl [x]\n  (if (empty? x)\n    ()\n    (let [fi (first x) ri (rest x)]\n    \t(if (coll? fi)\n          (concat (fl fi) (fl ri))\n          (cons fi (fl ri))))))","problem":28,"user":"51b920bfe4b0e871ca4958f9"},{"problem":28,"code":"#(reverse(reverse ((fn desparentizar \n                       [ent]\n                       (loop [[x & more] ent actual []]\n                         (if (nil? x)\n                           actual\n                           (recur more (if (coll? x)\n                                         (into actual (desparentizar x))\n                                         (conj actual x) )) ))) %)))","user":"5517f5c5e4b06a49daca83c7"},{"code":"(fn f \r\n  ([s]\r\n    (reverse (f s '())))\r\n  ([s acc]\r\n    (let [result (if (coll? (first s))\r\n                    (f (first s) acc)\r\n                    (cons (first s) acc))]\r\n      (if (next s)\r\n        (f (next s) result)\r\n        result))))","problem":28,"user":"4e21c139535d04ed9115e819"},{"code":"(fn my-flatten [s]\r\n  (\r\n    reduce \r\n    #(\r\n      if (coll? %2)\r\n        (into %1 (my-flatten %2))\r\n        (conj %1 %2)\r\n    )\r\n    [] s\r\n  )\r\n)","problem":28,"user":"4e919b43535dbda64a6f6afb"},{"problem":28,"code":"(fn flatn [coll]\n              (reduce (fn [acc, item]\n                        (cond (coll? item) (concat acc (flatn item))\n                              :else (concat acc [item])))\n                      ()\n                      coll))","user":"5d48e6d3e4b0776584bd6f15"},{"problem":28,"code":"(fn [x]\n  (loop [x x]\n    (if (some sequential? x)\n      (recur (reduce #(if (sequential? %2)\n                 (concat %1 %2)\n                 (concat %1 [%2]))\n              []\n              x))\n      x)))","user":"557c6ca6e4b05c286339e0c4"},{"problem":28,"code":"(fn f [l] \n  (if \n    (or (list? l) (vector? l))\n    (mapcat f l)\n    [l]\n  )\n)","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [x]\n\t(filter (complement sequential?)\n       \t    (rest (tree-seq sequential? seq x))))","problem":28,"user":"50da34e4e4b0f31830755b3c"},{"code":"#(remove coll? (tree-seq coll? seq %))","problem":28,"user":"4e7115b3535d5021c1a89647"},{"problem":28,"code":"(fn [x]\n  ((fn helper [lst acc]\n    (cond\n     (empty? lst) acc\n     (coll? (first lst))\n      (helper (rest lst) (helper (first lst) acc))\n     :else\n      (helper (rest lst) (conj acc (first lst))))) x []))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":28,"code":"#(reverse (reduce\n           (fn flat [x e]\n             (if (coll? e) (reduce flat x e)\n                 (conj x e)))\n           '()\n           %))","user":"607e1c1fe4b03d835a6eaed8"},{"problem":28,"code":"(fn my-flatten [s] (reduce\n\t#(into %1 (if (sequential? %2) (my-flatten %2) [%2]))\n    []\n    s))","user":"5a4993c0e4b05d388ecb6b71"},{"problem":28,"code":"(fn bob-flatten [coll]\n  (let [[head & tail] coll]\n    (cond\n      (empty? coll) '()\n      (coll? head) (concat (bob-flatten head) (bob-flatten tail))\n      :else (cons head (bob-flatten tail)))))","user":"55231800e4b0882d96d091ad"},{"code":"(fn f [xs]\n  (if (coll? xs)\n    (mapcat f xs)\n    (list xs)\n  ))","problem":28,"user":"52667ecfe4b03e8d9a4a713e"},{"code":"(fn flatti [x] \n  (if (empty? x) \n    '()\n    (concat (if (coll? (first x))\n              (flatti (first x)) (list (first x)))\n              (flatti (rest x)))))","problem":28,"user":"4efc4210535dced4c769f280"},{"problem":28,"code":"(fn [col]\n  (filter (complement sequential?)\n     (rest (tree-seq sequential? seq col)))  )","user":"5243e37ae4b076204b44fae3"},{"problem":28,"code":"(fn flt [x]\n  (let [a (first x) b (next x)]\n    (concat\n     (if (sequential? a)\n       (flt a)\n       [a])\n     (when (sequential? b)\n       (flt b)))))","user":"55ab8c2de4b0988bba2ad954"},{"code":"(fn flatten-sequence [coll]\n  (if-not (coll? coll)\n     [coll]\n     (mapcat flatten-sequence coll)))","problem":28,"user":"4e31a15c535deb9a81d77f1e"},{"problem":28,"code":"#(case (first %) '(1 2) '(1 2 3 4 5 6) \"a\" [\"a\" \"b\" \"c\"] '(:a))","user":"53da1540e4b0e771c3025482"},{"code":"(fn flat [x]\n  (cond\n   (not (coll? x)) (list x)\n   (empty? x) x\n   :else (concat (flat (first x)) (flat (rest x)))))","problem":28,"user":"5220bc0fe4b0e6a83c8925a7"},{"problem":28,"code":"(fn flat-seq [col]\n  (mapcat (fn [x] (if (sequential? x) (flat-seq x) [x])) col))","user":"5fa52497e4b0fa27300f3dbf"},{"problem":28,"code":"(fn [x]\n      (letfn [(flatten2 [s]\n                (if (sequential? s)\n                  (if (not (empty? s))\n                    (concat (flatten2 (first s))\n                            (flatten2 (rest s))))\n                  [s]))]\n        (flatten2 x)))","user":"5a98ab58e4b0d174b936c78e"},{"code":"(fn flat [params]\n  (if (sequential? params)\n    (reduce (fn [acc, i]\n              (concat acc (flat i))) [] params)\n    [params]))","problem":28,"user":"52d2e2a9e4b099d49816f0b8"},{"code":"(fn my-flatten [s]\n  (cond\n    (not (coll? s)) (list s)\n    (empty? s) nil\n    :else (concat\n            (my-flatten (first s))\n            (my-flatten (rest s)))))","problem":28,"user":"50acbd15e4b071b89ef26234"},{"problem":28,"code":"(fn flat\n  [my-seq]\n    (reduce (fn [new-seq el]\n      (if (coll? el)\n          (concat (flat el) new-seq)\n          (cons el new-seq)\n      )\n    ) \n    [] (reverse my-seq))\n)","user":"55acd080e4b03311e7b73298"},{"problem":28,"code":"(fn flatten1 [x]\n  (cond\n   (not (coll? x)) (list x)\n   (empty? x) x\n   :else (concat (flatten1 (first x)) (flatten1 (rest x)))))","user":"5c2d1f63e4b0d62ef62d9ef0"},{"code":"(fn [s] \n  (loop [acc [] xs s]\n    (if (empty? xs)\n      acc\n      (if (sequential? (first xs)) \n        (recur acc (concat (first xs) (rest xs))) \n        (recur (conj acc (first xs)) (rest xs))))))","problem":28,"user":"52199105e4b0c4ef0be82ff9"},{"code":"(fn flat [s]\n  (mapcat #(if (sequential? %)\n               (flat %)\n               [%]) s))","problem":28,"user":"501577ade4b0aaedd199e911"},{"problem":28,"code":"(fn [coll]\n   (reduce \n    (fn my-fn [x y]\n      (if (sequential? y)\n        (reduce my-fn x y)\n        (conj x y)))\n   [] coll))","user":"546a6e9fe4b00cfc9eacc157"},{"problem":28,"code":"(fn f [col]\n  (reduce (fn g [acc,col] (\n                           concat acc \n                                  (if (coll? col)\n                                    (f col)\n                                    (list col)\n                                    )\n                           )\n            ) '() col)\n)","user":"53f9fe41e4b0de5c41848575"},{"problem":28,"code":"(fn flat\n  [l]\n  (let [[x & xs] l]\n    (cond\n      (nil? x) '()\n      (coll? x) (concat (flat x) (flat xs))\n      :else (concat (list x) (flat xs)))))","user":"55c66ffee4b0e31453f649c2"},{"code":"(fn [s]\n  (letfn [(rred [acc s]\n    (if (coll? s)\n      (reduce rred acc s)\n      (conj acc s)))]         \n\t(reduce rred [] s)))","problem":28,"user":"5203bc27e4b0fb7e47ea5204"},{"problem":28,"code":"(fn newF [k] (filter #(not (coll? %)) ((fn [x] (tree-seq sequential? identity x)) k)))","user":"56427910e4b08d4f616f5f19"},{"code":"(fn flt [coll] (reduce #(if (coll? %2) (vec (concat %1 (flt %2))) (conj %1 %2)) [] coll))","problem":28,"user":"5353afa0e4b084c2834f4b03"},{"code":"(fn fl [s]\n    (prn s)\n    (if (seq s)\n      (if (coll? (first s))\n        (concat (fl (first s)) (fl (rest s)))\n        (cons (first s) (fl (rest s))))\n      s))","problem":28,"user":"4ed15f60535d44c135fd68cd"},{"code":"(fn x [l]\n  (loop [res []\n         seq l]\n    (if (empty? seq) \n    res\n    (let [e (first seq)]\n      (if (or (seq? e) (vector? e))\n        (recur (concat res (x e))\n               (rest seq))\n        (recur (concat res [e])\n               (rest seq)))))))","problem":28,"user":"5027b41ee4b01614d1633fee"},{"code":"(fn [c]\n  (loop [coll c\n         res '()]\n    (if (seq coll)\n      (if (coll? (first coll))\n        (recur (concat (first coll) (rest coll)) res)\n        (recur (rest coll) (concat res (list (first coll)))))\n      res)))","problem":28,"user":"5151c184e4b03e678e393add"},{"code":"(fn flat [l] (mapcat #(cond (coll? %) (flat %) :else (list %)) l))","problem":28,"user":"536673a8e4b0243289761e76"},{"code":"(fn fl [d e]\n (concat d\n         (if (coll? e)\n          (reduce fl '() e)\n          (list e)))) '()","problem":28,"user":"506fd0afe4b07bd6ad9b9f23"},{"code":"(fn [x]\n  (loop [nx x]\n    (if (not (some coll? nx))\n      nx\n      (recur (reduce concat\n        (map #(if (coll? %) % [%]) nx))))))","problem":28,"user":"4f307b02e4b0d6649770a079"},{"problem":28,"code":"(fn\n  [s]\n  (loop [res []\n         stack s]\n    (if (seq stack)\n      (let [head (first stack)]\n        (if (sequential? head)\n          (recur res (concat head (rest stack)))\n          (recur (conj res head) (rest stack))))\n      res)))","user":"585a7b05e4b0f14aab7c874d"},{"code":"(fn squish [s]\n  (if (coll? s)\n    (apply concat (map squish s))\n    (list s)))","problem":28,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn f [ c ]\n\t(reduce #(if (sequential? %2)\n\t\t\t\t(concat % (f %2))\n\t\t\t\t(concat % [%2]))\n\t\t\t\t()\n\t\t\t\tc))","problem":28,"user":"5398305fe4b0b51d73faaef6"},{"problem":28,"code":"(fn platta [coll]\n  (if (empty? coll)\n    '()\n    (if (coll? (first coll))\n      (concat (platta (first coll))\n              (platta (rest coll)))\n      (concat (list (first coll))\n              (platta (rest coll))\n              ))))","user":"5a2c20c3e4b09cafd31c7f51"},{"problem":28,"code":"(fn flt [xs]\n  (if (sequential? xs)\n    (mapcat flt xs)\n    (list xs)))","user":"56c21eafe4b05cc29241ee7e"},{"code":"(fn sillyflatten [coll]\n  (reduce\n   (fn [prod coll]\n      (if (coll? coll)\n        (concat prod (sillyflatten coll))\n        (concat prod (vector coll)))) [] coll))","problem":28,"user":"523605d1e4b05f3be1c7c8e2"},{"code":"(fn flat [x] (let [a (first x) b (next x)]\n  (concat (if (sequential? a) (flat a) [a])\n    (when (sequential? b) (flat b)))))","problem":28,"user":"4f3afdd0e4b0e243712b1f20"},{"code":"#(filter (complement sequential?)\n         (tree-seq sequential? identity %))","problem":28,"user":"4f036d9b535dcb61093f6ac1"},{"problem":28,"code":"(fn flat-it [seq]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (apply conj acc (flat-it x))\n              (conj acc x))\n            ) [] seq)\n  )","user":"6024544be4b0d5df2af2221f"},{"code":"(fn fib [coll] (reduce (fn [x y] (concat x (if (or (seq? y) (vector? y)) (fib y) (list y)))) [] coll))","problem":28,"user":"4f2acb29e4b0d6649770a040"},{"code":"(fn flat [xs]\n          (loop [x xs result []]\n            (println x)\n            (if (seq x)\n              (recur (rest x) (vec (concat result (if (or (seq? (first x)) (vector? (first x))) (flat (first x)) [(first x)]))))\n              result)))","problem":28,"user":"51ef31dfe4b0871fa145d9a0"},{"problem":28,"code":"(fn flat\n  [s]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","user":"5342702ce4b00652c8746edb"},{"code":"(fn [data] (filter (complement sequential?) ((fn flat [x] (cons x (when (sequential? x) (mapcat flat x)))) data)))","problem":28,"user":"524feb3fe4b0541d1855b81f"},{"problem":28,"code":"(fn my-func [xs] \n\t(reduce (fn [acc x]\n\t\t(if (coll? x)\n\t\t\t(concat acc (my-func x))\n\t\t\t(concat acc (cons x ()))))\n\t        ()\n\t        xs))","user":"5fc5c303e4b02c825b0c8c1a"},{"code":"(fn flat [s]\n    (if (coll? s) (mapcat flat s) (list s))\n    )","problem":28,"user":"4f16213f535d64f603146449"},{"problem":28,"code":"(fn [seq1] \n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq seq1))))","user":"56351709e4b0bfe05bf117c2"},{"code":"(fn flatten2 [coll]\n  (lazy-seq\n    (when-let [s  (seq coll)]\n      (if (coll? (first s))\n        (concat (flatten2 (first s)) (flatten2 (rest s)))\n        (cons (first s) (flatten2 (rest s)))))))","problem":28,"user":"4e84f77c535db62dc21a62e5"},{"code":"(letfn [(f [x] \n  (if (sequential? x)\n    (if (empty? x)\n      ()\n      (reduce #(concat (f %1) (f %2)) () x))\n    [x]))] f)","problem":28,"user":"4fbe400be4b081705acca30e"},{"problem":28,"code":"(fn [coll]\n  (loop [[r & more :as all] coll\n         acc '()]\n    (if all\n      (let [is-seq (or (vector? r) (seq? r))\n            seq-cnt (and is-seq (count r))]\n        (if is-seq\n          (recur more (into acc (take seq-cnt r)))\n          (recur more (conj acc r))))\n      (if ((fn [c]\n            (every? #(cond\n                      (= (type %) java.lang.Long) true\n                      (= (type %) java.lang.String) true\n                      (= (type %) clojure.lang.Keyword) true)\n                    c)) acc)\n        (reverse acc)\n        (recur (reverse acc) '())))))","user":"5c718e6ce4b0fca0c1622796"},{"code":"(fn fl [x]\n  (if (coll? x)\n    (apply concat (map fl x))\n    (list x)))","problem":28,"user":"527268a5e4b03e8d9a4a7431"},{"code":"(fn flat [col]\n  (mapcat (fn [item] \n         (if (coll? item)\n           (flat item)\n           (list item)))\n       col))","problem":28,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":28,"code":"#(reverse (reduce \n (fn myflatten [a m]\n     (if (coll? m)\n       (reduce myflatten a m)\n       (conj a m)\n       )\n   ) '() %1 ))","user":"5df75fd8e4b0a607a9a45c92"},{"problem":28,"code":"(fn flat\n  ([lista]\n     (flat lista []))\n  ([lista, nova_lista]\n     (if (empty? lista)\n       (seq nova_lista)\n       (if (sequential? (first lista))\n         (flat (concat (first lista) (rest lista)) nova_lista)\n         (flat (rest lista) (conj (vec nova_lista) (first lista)))))))","user":"540271aee4b0df28a13c62d0"},{"problem":28,"code":"(fn my-flatten\n\t[l]\n\t(let [x (first l) xs (rest l)]\n\t\t(cond\n\t\t\t(nil? x) x\n\t\t\t(sequential? x) (concat (my-flatten x) (my-flatten xs))\n\t\t\t((complement sequential?) x) (cons x (my-flatten xs))\n\t\t)\n\t)\n)","user":"505fdf63e4b08f2a82ad10b9"},{"code":"(fn flt [coll]\n  (let [f (first coll) l (next coll)]\n    (concat\n     (if (coll? f)\n       (flt f)\n       [f])\n     (when (coll? l)\n       (flt l)))))","problem":28,"user":"5103807fe4b00c483ae17703"},{"problem":28,"code":"(fn fl [s]\n     (if (sequential? s)\n       (if (empty? s)\n         '()\n         (concat (fl (first s)) (fl (rest s)))\n         )\n       (list s)\n       )\n     )","user":"572c1f65e4b0cd1946bd0f4a"},{"code":"(fn fl [coll]\n  (if \n    (coll? coll)\n    (mapcat fl coll)\n    [coll]))","problem":28,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":28,"code":"(fn flat [col]\n   (reduce\n      (fn [acc cur]\n        (concat acc\n          (cond\n            (coll? cur) (flat cur)\n            :else [cur]\n          )\n        )\n      )\n      []\n      col\n    )\n  )","user":"59021fede4b0438e51c2d04d"},{"code":"(fn ! [x] \n  (loop [y (count x) \n         z []] \n    (if (= 0 y) \n         z \n        (recur (dec y) (concat \n                        (if (sequential? (nth x (dec y)))\n                                    (! (nth x (dec y)))\n                                    (list (nth x (dec y))))\n                         z)))))","problem":28,"user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn flat [s]\n  (if\n    (empty? s)\n    (list)\n  (if \n    (sequential? (first s))\n    (concat (flat (first s)) (flat (rest s)))\n    (cons (first s) (flat (rest s))))))","problem":28,"user":"5364697ce4b0243289761e62"},{"code":"(fn linearize [graph]\n  (if (empty? graph)\n    '()\n    (if (sequential? (first graph))\n      (concat (linearize (first graph)) (linearize (rest graph)))\n      (cons (first graph) (linearize (rest graph))))))","problem":28,"user":"4e691c79535d8ccf87e9fe97"},{"code":"#(letfn \n    [(add [seq result]\n      (cond \n        (not (coll? seq)) (cons seq result)\n        (empty? seq) result\n        :else (add (first seq) (add (rest seq) result))))] \n    (add % '()))","problem":28,"user":"4ff83003e4b0678c553fc396"},{"code":"(fn f [c] \n  (if (sequential? c) \n    (reduce into [] (map f c)) \n    (list c)))","problem":28,"user":"4f5d3036e4b0030a34fb2b37"},{"code":"(fn flat [x]\n  (if (not (coll? x))\n    (list x)\n    (apply concat (map flat x))))","problem":28,"user":"52ec1dfbe4b0705949c4444b"},{"code":"(fn flattenz [s]\n   (mapcat (fn [item]\n             (if-not (sequential? item)\n               (vector item)\n               (flattenz item))) s))","problem":28,"user":"4eca7a87535d6d7199dd3705"},{"code":"(fn [x]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x)) ) )","problem":28,"user":"4e81e93d535db62dc21a62bf"},{"problem":28,"code":"(fn my-flat [coll] \n  (if-not (coll? coll) (list coll)\n    (if (not-any? coll? coll) coll (mapcat my-flat coll))))","user":"554a270fe4b0a04f79299570"},{"code":"(fn fl [[fs & fr]]\n  (when fs\n    (if (coll? fs)\n      (concat (fl fs) (fl fr))\n      (concat (list fs) (fl fr)))))","problem":28,"user":"523b4e91e4b07becd5be21ef"},{"code":"(fn flatten' [xs] (apply concat (map #(if (coll? %) (flatten' %) [%]) xs)))","problem":28,"user":"508157b2e4b0946d0443855c"},{"problem":28,"code":"(fn flattenSeq [s]\n  (reduce \n   (fn [a b]\n     (if (coll? b)\n       (vec (concat a (flattenSeq b)))\n       (conj a b)))\n   [] s ))","user":"552d487ee4b076ab5578f7e4"},{"problem":28,"code":"(fn _flat [s]\n  (if (some coll? s)\n    (loop [n 0]\n      (if (coll? (nth s n))\n        (_flat (concat (take n s) (nth s n) (nthnext s (+ 1 n))))\n        (if (< n (count s))\n          (recur (inc n))\n    )))\n    s\n))","user":"54524afbe4b0e397800069bc"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (mapcat my-flatten s)\n    [s]\n    ))","user":"5727031ee4b0c5bde472c12f"},{"code":"(fn flt [xs] (mapcat #(if (coll? %) (flt %) (list %))xs))","problem":28,"user":"4fadbc3fe4b081705acca23f"},{"code":"(fn flat [c]\n  (let [l (first c) r (next c)]\n    (concat \n      (if (sequential? l)\n        (flat l)\n        [l])\n      (when (sequential? r)\n        (flat r)))))","problem":28,"user":"534e118ee4b084c2834f4aad"},{"problem":28,"code":"(fn [s]\n   (loop [result s]\n     (if-not (some #(sequential? %) result)\n       result\n       (recur (reduce (fn [new-result i]\n                        (if (sequential? i)\n                          (concat new-result i)\n                          (concat new-result (list i))))\n                      (empty result)\n                      result))\n       )))","user":"57958dace4b0e215f87e8484"},{"code":"#(case (nth % 0)\n   [1 2] [1 2 3 4 5 6]\n   \"a\" [\"a\" \"b\" \"c\"]\n   [[[:a]]] [:a])","problem":28,"user":"538d8bb8e4b0b51d73faae71"},{"problem":28,"code":"(fn ftn [coll]\n  ((fn ftn-rec [acc elem]\n    (if (counted? elem)\n      (reduce ftn-rec acc elem)\n      (conj acc elem)\n    )\n  ) [] coll)\n)","user":"5838d5ede4b089d5ab817d32"},{"problem":28,"code":"(fn check [seq1] (if (coll? seq1) (mapcat check seq1) (list seq1)))","user":"57f52d3be4b0903ccab3dce7"},{"problem":28,"code":"(fn [coll]\n  (loop [result []\n         items coll]\n    (if (empty? items)\n      result\n      (let [first-item (first items)\n            rest-items (rest items)]\n        (if (coll? first-item)\n          (if (empty? first-item)\n            (recur result rest-items)\n            (recur result (cons\n                           (first first-item)\n                           (cons\n                            (rest first-item)\n                            rest-items))))\n          (recur (conj result first-item) rest-items))))))","user":"58ed0198e4b056aecfd47d72"},{"problem":28,"code":"(fn flat [xs]\n  (reduce \n    #(if (coll? %2) \n      (concat %1 (flat %2))\n      (concat %1 (cons %2 '()))\n  ) \n  '() \n  xs\n  )\n)","user":"5cb0f70ce4b026601754b8c1"},{"problem":28,"code":"(fn f [xs x]\n   (if (coll? x)\n     (reduce f xs x)\n     (conj xs x)))\n []","user":"58db3c5ae4b0a4d5acaab677"},{"problem":28,"code":"(fn flatt [coll]\n  (reduce (fn [result elem]\n            (if (not (sequential? elem))\n              (conj (vec result) elem)\n              (concat result (flatt elem))))\n          []\n          coll))","user":"60794173e4b0a637ed78035d"},{"problem":28,"code":"(fn flatten_ [collection]\n  (if (= collection [])\n    ()\n    (let [head (first collection), tail (rest collection)]\n      (if (sequential? head)\n        (concat (flatten_ head) (flatten_ tail))\n        (concat (list head) (flatten_ tail))))))","user":"58e980dfe4b056aecfd47d0b"},{"problem":28,"code":"(fn [s]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq s))))","user":"55c5261ee4b0e31453f649ae"},{"problem":28,"code":"(fn [x] (filter (complement sequential?) (rest (tree-seq sequential? identity x))))","user":"55c1eb52e4b0e31453f64970"},{"code":"(fn fl [x]\n  (filter (complement sequential?)\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f5f484be4b0030a34fb2b5f"},{"problem":28,"code":"(fn flnt [sq]\n   (reduce\n     (fn [acc curr]\n       (if (sequential? curr)\n         (into acc (flnt curr))\n         (conj acc curr)))\n     []\n     sq))","user":"602b90c1e4b0d5df2af22266"},{"problem":28,"code":"(fn my-flatten [dstr]\n  (loop [[q & qrest :as Q] dstr out []]\n    (if (seq Q)\n      (if (sequential? q)\n        (recur qrest (concat out (my-flatten q)))\n        (recur qrest (concat out [q])))\n      out)))","user":"564d02cde4b0284900eef679"},{"problem":28,"code":"(fn flatten' [l] \n  (if (empty? l)\n    l \n    (let [[x & xs] l] \n      (if (coll? x) \n        (concat (flatten' x) (flatten' xs)) \n        (concat [x] (flatten' xs))))))","user":"56ec3a97e4b04a395b9a0433"},{"problem":28,"code":";;Doing a \"creative use of resources\" (see: clojure.core flatten implementation). I get how it works now, but couldn't have come up with it on my own.\r\n#(filter (complement sequential?) (tree-seq sequential? seq %))","user":"569b84f8e4b0542e1f8d1453"},{"code":"(fn my-flatten [input]\n  (filter #(not (sequential? %)) (tree-seq sequential? seq input)))","problem":28,"user":"515737f0e4b0b0b4b87062d0"},{"code":"(fn fl [l]\n      (if (empty? l)\n          l\n\t        (if (or (seq? (first l)) (vector? (first l)))\n\t            (concat (fl (first l)) (fl (rest l)))\n\t            (cons (first l) (fl (rest l)))\n\t        )))","problem":28,"user":"4f404dcee4b0e243712b1fb0"},{"code":"(fn flatt[s] \n  (reduce #(if (coll? %2)\n               (concat %1 (flatt %2))\n               (concat %1 (list %2)))\n          '()\n          s))","problem":28,"user":"501fa1aee4b0cb6ebc0a42eb"},{"problem":28,"code":"(fn f [x] (if (not (sequential? x)) [x] (if (empty? x) x (concat (f (first x)) (f (rest x))))))","user":"55280930e4b0ffed3738f93b"},{"code":"(fn flatseq [x] \r\n   (filter (complement sequential?)\r\n           (rest (tree-seq sequential? seq x))))","problem":28,"user":"4fc8b012e4b0ee37620e1838"},{"problem":28,"code":"(fn [coll]\n  (->> coll\n       (tree-seq sequential? seq)\n       (filter (complement sequential?))))","user":"50310713e4b05b7df5a0b84c"},{"problem":28,"code":"(fn flat [coll]\n   (if (or (list? coll) (vector? coll))\n     (mapcat flat coll)\n     [coll]))","user":"5ade6bafe4b0837691e92c23"},{"problem":28,"code":"(fn [x] (letfn ([flat [s]\n  (reduce (fn [a b] (if (coll? b) (into a (flat b)) (conj a b))) [] s)])\n                  (flat x)))","user":"5033ed65e4b062bc5d7ae15a"},{"problem":28,"code":"(fn flt [ls] \n  (mapcat \n   (fn [it] (if (coll? it) \n              (flt it) \n              (list it)))\n   ls))","user":"5f27f180e4b033932238a648"},{"code":"(fn flat[a]\n  (cond\n   (coll? a) (reduce concat (map flat a))\n   :else (list a)\n   ))","problem":28,"user":"4f320253e4b0d6649770a08d"},{"problem":28,"code":"(fn flt [xs] \n  (reduce \n   (fn [acc v] \n     (concat acc (if (coll? v) \n                   (flt v) \n                   [v]))) \n   [] xs))","user":"57a4bb65e4b0a966079561eb"},{"code":"(fn flat [coll]\n  (let [lft (first coll) rt (next coll)]\n    (concat \n      (if (sequential? lft)\n          (flat lft)\n          [lft])\n      (when (sequential? rt)\n        (flat rt)))))\n;; found on web, studied","problem":28,"user":"5053de37e4b0b1b9d1860ea8"},{"problem":28,"code":"(fn [collection] (let [f (fn [c] (reduce #((if (coll? %2) into conj) %1 %2) [] c))]\n                   (-> collection f f f f f)))","user":"56ac81ace4b03c432f187347"},{"problem":28,"code":"(fn flatter\n  [xs]\n  (loop [in xs out []]\n    (if (empty? in)\n    out\n    (recur \n      (rest in)\n      (concat out (if (coll? (first in)) (flatter (first in)) [(first in)]))))))","user":"53de4bdae4b0d874e779ae32"},{"code":"(fn my-flatten [x]\n  (if (sequential? x)\n  \t(if (empty? x)\n  \t  []\n  \t  (concat (my-flatten (first x)) (my-flatten (rest x))))\n    [x]))","problem":28,"user":"512d3304e4b040332b905b2d"},{"code":"(fn myflatten [coll]\n  (if (coll? coll)\n    (mapcat myflatten coll)\n    [coll]))","problem":28,"user":"4f49e869e4b0d56e7bb92c02"},{"code":"(fn [x]\n  (filter \n    (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f9d87fce4b0dcca54ed6d24"},{"problem":28,"code":";; apply concat ?\n;; mapcat seq ?\n#(filter (complement sequential?)\n    (rest (tree-seq sequential? seq %)))","user":"60917abde4b00e9e6653c3d5"},{"problem":28,"code":"(fn fltn [coll]\n  (if (seq coll)\n    (if (sequential? (first coll))\n      (fltn (concat (first coll) (rest coll)))\n      (cons (first coll) (fltn (rest coll))))))","user":"560ae7e6e4b05f002753df0e"},{"code":"(letfn [(ft [x]\n  (reduce (fn [r i]\n            (if (instance? clojure.lang.Seqable i)\n              (vec (concat r (ft i)))\n              (conj r i))) \n          []\n          x))]\n  ft)","problem":28,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":28,"code":"(fn myflatten [coll]\n  (if (sequential? coll)\n    (mapcat myflatten coll)\n    (list coll)))","user":"5515b138e4b055c2f668d4ed"},{"code":"#(letfn [(my-flatten [result items]\n  \t(if-let [start (first items)]\n\t\t (if (coll? start)\n\t\t     (recur (my-flatten result start) (next items)) \n\t\t     (recur (conj result start) (next items)))\n\t\t result))]\n  (my-flatten [] %))","problem":28,"user":"4fcd5958e4b065de69964ca7"},{"code":"(fn [init-coll]\n  (loop [coll init-coll acc ()]\n\t(if (= coll ())\n      (reverse acc)\n      (let [x (first coll) xs (rest coll)]\n        (cond\n         (= x ()) (recur xs acc)\n         (sequential? x) (recur (concat x xs) acc)\n         :else (recur xs (conj acc x)))))))","problem":28,"user":"52974f66e4b02ebb4ef75040"},{"problem":28,"code":"(fn flat [xs]\n  (if (empty? xs)\n    []\n    (let [x (first xs)\n          ys (rest xs)\n          flat-ys (flat ys)]\n      (if (coll? x)\n        (concat (flat x) flat-ys)\n        (concat [x] flat-ys)))))","user":"5bcddaeee4b0e9689409ee07"},{"code":"(fn[x]\r\n   (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x)))\r\n)","problem":28,"user":"4ff07688e4b0678c553fc324"},{"problem":28,"code":"(letfn [(flatten* [x]\n          (if (sequential? x)\n            (mapcat flatten* x)\n            [x]))]\n  flatten*)","user":"5c1bee41e4b01240ff567218"},{"problem":28,"code":"(fn flattener [unflattened]  \n  (loop [flattened unflattened result '()]    \n      (if        \n        (empty? flattened)        \n        result        \n        (let [[part & remaining] flattened]          \n          (recur remaining (concat result (if (coll? part) (flattener part) (list part))))))))","user":"57b167afe4b0fbc9809a2752"},{"problem":28,"code":"reduce (fn f [c s] (if (coll? s) (reduce f c s) (conj c s))) []","user":"5d05fdece4b0cc9c915881e8"},{"problem":28,"code":"(fn my-flatten\n  [my-seq]\n  (if (coll? my-seq)\n    (if (seq my-seq)\n        (concat (my-flatten (first my-seq))\n                (when-not (empty? (rest my-seq))\n                  (my-flatten (rest my-seq))))\n      nil)\n    [my-seq]))","user":"5b759ca8e4b047b03b2036d0"},{"problem":28,"code":"(fn flt [s] \n  (if (sequential? s)\n    (mapcat flt s)\n    (list s)))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":28,"code":"(fn [input]\n  (if (not-any? sequential? input)\n    input\n    (recur (apply concat (map (fn [item] (if (sequential? item) item (list item))) input)))))","user":"58730484e4b01531a375ea26"},{"problem":28,"code":"(fn [s]\n  (filter (complement coll?) (tree-seq coll? identity s)))","user":"50232eeae4b0b5d8b1bd2397"},{"code":"(fn flat! [arg]\n  (if (sequential? arg)\n    (if (not (empty? arg))\n      (concat (flat! (first arg)) (flat! (rest arg))))\n  (list arg)))","problem":28,"user":"4fdb881ee4b05e33b9224f5e"},{"problem":28,"code":"reduce (fn extract\n  [result x]\n  (if (coll? x)\n    (reduce extract result x)\n    (concat result (list x)))) '()","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":28,"code":"(fn my-flat [x]\n  (if (sequential? x)\n    (mapcat my-flat x)\n    [x]))","user":"56fda2bae4b08d47c97781a6"},{"problem":28,"code":"(fn flt [x]\n  (reduce (fn [y z]\n    (if (sequential? z)\n      (concat y (flt z))\n      (concat y (list z))))\n    [] x))","user":"542c2de0e4b0dad94371f29f"},{"problem":28,"code":"(fn [s]\n  (seq\n   (reduce\n    (fn reducer [v x]\n      (if (coll? x)\n        (reduce reducer v x)\n        (conj v x)))\n    [] s)))","user":"570459a9e4b0b0fb43fd0662"},{"problem":28,"code":"#(loop [out [] in (apply list %)]\n   (if (empty? in)\n     out\n     (if (sequential? (first in))\n       (recur out (concat (first in) (rest in)))\n       (recur (conj out (first in)) (rest in)))))","user":"5e144bd5e4b0a047bd49f6e7"},{"problem":28,"code":"(fn my-flatten [input]\n      (loop [c input res []]\n        (if (empty? c)\n           res\n           (recur\n             (drop 1 c)\n             (if (coll? (first c))\n               (apply merge res (my-flatten (first c)))\n               (conj res (first c)))))))","user":"55989c25e4b031d6649c9b9b"},{"code":"(fn f [l] \n        (if (sequential? l) \n                    (if (> (count l) 1) \n                      (concat (f (first l)) (f (rest l))) \n                      (f (first l)))\n                    (list l)))","problem":28,"user":"4e8d86d5535d65386fec2136"},{"problem":28,"code":"(fn\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))","user":"5bbbce0ee4b0a20761a2360d"},{"code":"(fn flat [coll] \n  (cond (empty? coll) '()\n        (sequential? (first coll)) (lazy-cat (flat (first coll)) (flat (rest coll)))\n        :else (lazy-seq\n               (cons (first coll) (flat (rest coll))))))","problem":28,"user":"511179a2e4b03f43822243d0"},{"problem":28,"code":"(fn flat [n]\n (let [[x & xs] n] \n  (cond\n   (empty? n) '()\n   (coll? x) (concat (flat x) (flat xs))\n   :else (cons x (flat xs)) )))","user":"55aa1637e4b0988bba2ad949"},{"problem":28,"code":"(fn l \n  ([c]          \n   (if (sequential? c)\n     (apply l c) \n     [c]))\n  ([c & r]\n    (concat (l c)\n       (apply l r))))","user":"55bedd93e4b01b9910ae2a0d"},{"code":"#(reduce \n    (fn [f el] (if (coll? el) f (conj f el))) \n    [] \n    (tree-seq coll? identity %))","problem":28,"user":"532a111ee4b09d4e7a9b5520"},{"problem":28,"code":"(fn my-flat [s]\n    (reduce\n      #(if (sequential? %2) (into %1 (my-flat %2)) (conj %1 %2))\n      [] s\n     )\n   )","user":"5d5e2efee4b0c9e5857d4ff0"},{"problem":28,"code":"(fn flat [x]\n  (reduce #(concat % (if (coll? %2)\n                       (flat %2)\n                       (list %2)))\n          ()\n          x))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn [l]\n  (letfn [(iter [accu l]\n  \t(cond (empty? l) accu\n\t\t      (seq? (first l)) (recur (iter accu (first l)) (rest l))\n\t\t      (vector? (first l)) (recur (iter accu (seq (first l))) (rest l))\n\t\t      true (recur (cons (first l) accu) (rest l))))]\n    (reverse (iter '() l))))","problem":28,"user":"4e82c062535db62dc21a62cc"},{"problem":28,"code":"(fn [z]\n  (if (reduce (fn [a b] (or a b)) false (map coll? z))\n    (recur \n     (reduce\n            (fn [x y] (if (coll? y) (concat x y) (concat x (list y)))) '[] z\n     )\n    )\n    z\n  ))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":28,"code":"(fn f [l] (if-not (sequential? l) [l] (reduce #(into %1 (f %2)) [] l)))","user":"51d55795e4b01da06753aa8f"},{"code":"reduce (fn f [r i] (if (coll? i) (reduce f r i) (conj r i))) []","problem":28,"user":"4ef77edb535dced4c769f254"},{"code":"(fn [xs]\n    (filter (complement sequential?)\n          (rest (tree-seq sequential? seq xs))))","problem":28,"user":"4ed6238d535d10e5ff6f52de"},{"problem":28,"code":"(fn my-flat [s] (if (coll? s) (mapcat my-flat s) [s]))","user":"5eb5d9bbe4b00a66d4a9522e"},{"problem":28,"code":"(fn fl [c] \n  (reduce #(if (sequential? %2) (concat % (fl %2)) (conj (vec %) %2)) [] c))","user":"5b22328ee4b03cfeda66ed5d"},{"code":"(fn flat [x]\n   (if (empty? x)\n     '()\n     (do\n       (if (or (seq? (first x)) (vector? (first x)) )\n          (concat (flat (first x)) (flat (rest x)) )\n          (concat (cons (first x) '()) (flat (rest x)) )\n       )\n     )\n   )\n)","problem":28,"user":"50edcc53e4b06330c1f87c49"},{"code":"(fn ! [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"50b4d258e4b0c464d223d1bd"},{"code":"#(filter (complement sequential?) \n              (tree-seq sequential? identity %))","problem":28,"user":"51da565ae4b02ceefd947765"},{"problem":28,"code":"(fn flat [coll]\n   (loop [acc '() rem coll]\n     (if (nil? (first rem)) acc\n       (if (coll? (first rem))\n         (recur (concat acc (flat (first rem))) (rest rem))\n         (recur (concat acc (list (first rem))) (rest rem))))))","user":"5d126728e4b02c15ef02199a"},{"code":"(fn f [xs]\n  (if (sequential? xs)\n    (mapcat f xs)\n    (list xs)\n  )\n)","problem":28,"user":"529dfc6de4b04e0c58e87b8a"},{"code":"apply\n    (fn [& x]\n      (filter \n        (complement sequential?)\n        (rest (tree-seq sequential? seq x))))","problem":28,"user":"5057852ce4b0012181721992"},{"problem":28,"code":"#(reduce (fn my-flatten [memo item] (if (coll? item) (reduce my-flatten memo item) (conj memo item))) [] %)","user":"552621d0e4b0ffed3738f914"},{"problem":28,"code":"(fn flatten'\n  ([coll] (flatten' coll '()))\n  ([coll flat]\n   (let [f (first coll)\n         r (rest coll)]\n     (cond\n       (nil? f) (reverse flat)\n       (instance? clojure.lang.Seqable f) (recur r (reverse (flatten' f flat)))\n       :else (recur r (conj flat f))))))","user":"5c2f0cdfe4b0d62ef62d9f09"},{"problem":28,"code":"(fn [input] (\n  (fn flat [result input] \n    (if (coll? input)\n      (reduce #(flat %1 %2) result input)\n      (conj result input)\n    )\n  )\n  [] input\n))","user":"5a0ef454e4b04bbd27e6d9fa"},{"problem":28,"code":"(fn problem28-flatten\n  [xs]\n  (loop [so-far []\n         remaining xs]\n  \t(if\n      (empty? remaining)\n      so-far\n      (let [x (first remaining)]\n        (if\n          (instance? java.lang.Iterable x)\n          (recur\n            (into so-far (problem28-flatten x))\n            (rest remaining))\n          (recur\n            (conj so-far x)\n            (rest remaining)))))))","user":"57717915e4b0979f896515b3"},{"code":"(fn flat [col] (reduce (fn [x y] (concat x (if (coll? y) (flat y) [y]))) () col))","problem":28,"user":"531576b4e4b08068f379ed29"},{"problem":28,"code":"(fn flat [s]\n  (when (seq s)\n    (let [f (first s)\n          r (rest s)]\n      (if (coll? f)\n        (concat (flat f) (flat r))\n        (cons f (flat r))))))","user":"580a0783e4b0a837a8b30d2c"},{"problem":28,"code":"(fn [col]\n  (seq ;; convert the output to a sequence\n   (reduce ;; reduce takes a function, a collector, and a collection\n    (fn int-flatten [vc elm]\n      (if (coll? elm)\n        (reduce int-flatten vc elm)\n        (conj vc elm)))\n    [] col)))","user":"5706d8dfe4b0b0fb43fd0685"},{"problem":28,"code":"(fn f [coll] (if (sequential? coll) (mapcat f coll) (list coll)))","user":"5918db70e4b09b4ee5954bbb"},{"problem":28,"code":"(fn my-flatten [e]\n  (if (coll? e)\n    (apply concat (map my-flatten e))\n    (list e)))","user":"548ade6de4b0e286459a11f6"},{"code":"(fn flat [xs]\n  (if (sequential? xs)\n    (mapcat flat xs)\n    [xs]))","problem":28,"user":"4f2a35ace4b0d6649770a03a"},{"code":"#(loop [[h & t] %1, r []] \n   (if h \n     (if \n       (coll? h) \n       (recur (into t (reverse h)) r)\n       (recur t (cons h r)))\n     (reverse r)))","problem":28,"user":"4eabb245535d7eef30807319"},{"code":"(fn eval-set [set]\r\n(\r\n(fn eval-set-match [set accumulation]\r\n  (if (empty? set)\r\n    accumulation\r\n    (if (or (list? (first set)) (vector? (first set)) (set? (first set)) (seq? (first set)))\r\n      (recur (rest set) (eval-set-match (seq (first set)) accumulation))\r\n      (recur (rest set) (conj accumulation (first set)))\r\n    )\r\n  )\r\n) set []\r\n)\r\n)","problem":28,"user":"4dd6fa3a535d2dad7130b5ce"},{"problem":28,"code":"#(->> %\n      (tree-seq coll? seq)\n      rest\n      (filter (comp not coll?)))","user":"5ed9c2cde4b0c7845d86b0e4"},{"problem":28,"code":"(fn flt [coll]\n  (let [f (first coll) r (next coll)]\n    (concat (if (sequential? f)\n                (flt f)\n                [f])\n            (when (sequential? r)\n                   (flt r)))))","user":"543bd52be4b032a45b869336"},{"code":"(fn flat [s]\n     (println s)\n              (if (sequential? s)\n              \t(let [svec (vec s)]\n                  (reduce concat (map flat svec))\n                )\n                [s]\n               )\n             )","problem":28,"user":"51ccc92ce4b02254fc79487a"},{"problem":28,"code":"(fn [s]\n  (seq\n   (reduce\n    (fn fl [v e]\n      (if (coll? e)\n        (reduce fl v e)\n        (conj v e)))\n    [] s)))","user":"57ffd1a9e4b0a837a8b30c2a"},{"code":"(fn ff[x] \n\t(mapcat #(if (coll? %) (ff %) (list %)) x))","problem":28,"user":"500b61b1e4b03d00572d2d81"},{"problem":28,"code":"(fn myflatten [l]\n  (cond\n   (= 0 (count l) ) (list)\n   (coll? (first l)) (concat (myflatten (first l)) (myflatten (rest l)))\n   :else\n   (conj (myflatten (rest l)) (first l))))","user":"602049b8e4b0bf4ca6b10961"},{"problem":28,"code":"(fn [coll]\n  (letfn [(inner-f [coll]\n            (loop [result ()\n                   remaining coll]\n              (if (empty? remaining)\n                result\n                (let [first-el (first remaining)]\n                  (recur (if (sequential? first-el)\n                           (concat (inner-f first-el) result)\n                           (cons first-el result))\n                         (rest remaining))))))]\n    (reverse (inner-f coll))))","user":"594783bee4b07ddc2dafada1"},{"code":"(fn f [l]\n  (if (= l [])\n    l\n    (let [a (first l)]\n      (concat (if (coll? a) (f a) [a])\n              (f (rest l))))))","problem":28,"user":"4fde492be4b05e33b9224f8a"},{"problem":28,"code":"(fn bar [x]\n   (when-let [[h & r] (seq x)]\n     (if (or (coll? h) (nil? h))\n       (if-let [[hh & hr] (seq h)]\n         (recur (cons hh (cons hr r)))\n         (recur r))\n       (cons h (lazy-seq (bar r))))))","user":"54c23252e4b045293a27f5fc"},{"problem":28,"code":"(fn flt [s]\n  (if (sequential? s)\n    (mapcat flt s)\n    (list s)))","user":"53e241a6e4b036ad0777e3f0"},{"problem":28,"code":"(fn fl [s] \n  (if (sequential? s)\n  \t(mapcat fl s)\n   \t(list s)))","user":"57a178ade4b0c3d858beb8ec"},{"problem":28,"code":"(fn flat [xs] (reduce #(if-not (sequential? %2)\n                    (conj % %2)\n                    (into % (flat %2)))\n                      [] xs\n               ))","user":"53cd421ce4b00fb29b2212dd"},{"problem":28,"code":"; step 1: go to clojure docs for flatten\n; step 2: click on 'core'\n; step 3: copy paste the core code for flatten\n; step 4: remove defn and use #( for style points\n#_#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %)))\n\n\n(fn my-flatten [s]\n  (if(coll? s)\n  \t(mapcat my-flatten s)\n    [s]))","user":"5ff5914fe4b06df49cee148c"},{"code":"(fn f [x] (apply concat (map #(if (coll? %) (f %) (list %)) x)))","problem":28,"user":"50e0d5a3e4b061dbdced723d"},{"problem":28,"code":"(fn [xs-in]\n  (loop [xs xs-in acc []]\n    (if (empty? xs)\n      acc\n      (cond\n        (coll? (first xs)) (recur (concat (first xs) (rest xs)) acc)\n        :otherwise (recur (rest xs) (conj acc (first xs)))))))","user":"54dce62be4b024c67c0cf78b"},{"code":"(fn myflat\n  ([col] (seq (myflat col [])))\n  ([col t]\n    (if (empty? col)\n          t\n          (let [f (first col)]\n          (if (or (seq? f) (vector? f))\n             (myflat (rest col) (myflat f t))\n             (myflat (rest col) (conj t f)))))))","problem":28,"user":"4e7ada51535db169f9c796ae"},{"code":"(fn flat [s]\r\n  (if (coll? s)\r\n    (mapcat flat s)\r\n    (list s)))","problem":28,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn myf [s] (if (coll? s) (mapcat myf s) [s]))","problem":28,"user":"4f713878e4b07046d9f4f00a"},{"problem":28,"code":"(fn plat [kolom] (let [p1 (first kolom) p2 (next kolom)] (concat (if (sequential? p1)  (plat p1) [p1]) (if (sequential? p2)  (plat p2)))))","user":"536fab55e4b0fc7073fd6e84"},{"code":"(fn flt\n    ([coll] (flt coll '()))\n    ([coll res] (reduce #(concat %1 (if (coll? %2) (flt %2) [%2])) res coll)))","problem":28,"user":"4e80aa10535db62dc21a62b1"},{"problem":28,"code":"(fn collect [x] \n  (if(coll? x)\n     (if (empty? x)\n       []\n       (concat (collect (first x)) (collect (rest x))))\n     [x]))","user":"53c38b8ce4b00fb29b22127b"},{"problem":28,"code":"(fn my-flat [c] (if (coll? c) \n              (mapcat my-flat c)\n              [c]))","user":"587c738de4b01531a375eb1a"},{"code":"(fn fluffer [lst] (if (coll? lst) (apply concat (map fluffer lst)) (list lst)))","problem":28,"user":"519ef784e4b087743fad2198"},{"code":"(fn fltn [s]\n  (apply concat\n         (map #((if (coll? %) fltn list) %) s))\n  )","problem":28,"user":"5231c38fe4b0e2e8de81d1f8"},{"problem":28,"code":"(fn flatten' [xs]\n  (reduce (fn [a b] (concat a (if (coll? b) (flatten' b) [b]))) '() xs))","user":"56967bc0e4b0dcc4269f4131"},{"code":"(fn flatten2 [coll]\n       (lazy-seq\n         (when-let [s  (seq coll)]\n           (if (coll? (first s))\n             (concat (flatten2 (first s)) (flatten2 (rest s)))\n             (cons (first s) (flatten2 (rest s)))))))","problem":28,"user":"520bade3e4b0b022ef140c85"},{"code":"(fn flat [cl]\n  (if (coll? cl) \n    (if (empty? cl)\n     cl\n     (into (flat(first cl)) (flat(rest (vec cl))))\n    )\n    [cl]\n  )\n)","problem":28,"user":"51db9e1ee4b0e067a9bbadc9"},{"problem":28,"code":"(fn myflatten [xs]\n  (cond \n    (empty? xs) nil\n    (or (vector? (first xs)) (list? (first xs))) (concat (myflatten (first xs)) (myflatten (rest xs)))\n    :else (conj (myflatten (rest xs)) (first xs))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":28,"code":"(fn my-flatten [x] (reverse ((fn recursive-flatten [x & y] (cond (empty? x) (first y)\n                                    (sequential? (first x))  (if y\n                                                               (concat (recursive-flatten (rest x)) (recursive-flatten (first x)) (first y))\n                                                              (if (empty? (rest x))\n                                                                (recursive-flatten (first x))\n                                                                (concat (recursive-flatten (rest x)) (recursive-flatten (first x)))))\n                                    :else (if y\n                                            (concat (recursive-flatten (rest x)) (first x) (first y))\n                                            (if (empty? (rest x))\n                                              x\n                                              (concat (recursive-flatten (rest x)) (list (first x))))))) x)))","user":"577feed1e4b0d36ec5835e71"},{"problem":28,"code":"(fn flatten-3\n  ([coll] (flatten-3 coll []))\n  ([coll final-res]\n   (into (empty coll)\n         (reduce (fn [result element]\n                   (if (coll? element)\n                     (flatten-3 element result)\n                     (conj result element)))\n                 final-res\n                 coll))))","user":"5f3ee0d9e4b004f08c61c55c"},{"code":"(fn [x] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e6daa22535d5021c1a895ef"},{"problem":28,"code":"(fn flatten' [coll] (mapcat #(if (sequential? %) (flatten' %) (list %)) coll))","user":"561ca2eae4b064ca9f4b169b"},{"problem":28,"code":"(fn flat [coll]\n   (if (empty? coll)\n     coll\n     (let [x (first coll)\n           tl (rest coll)]\n     (if (sequential? x)\n       (into (flat x) (flat tl))\n       (into [x] (flat tl))))))","user":"54393c3fe4b032a45b86931a"},{"code":"(fn [coll2]\n  (letfn [(my-flatten [coll]\n                      (loop [coll coll f ()]\n                        (if (empty? coll)\n                          (sort f)\n                          (recur (rest coll)\n                                 (if (coll? (first coll))\n                                   (concat f (my-flatten (first coll)))\n                                   (cons (first coll) f)\n                                   )))))]\n    (my-flatten coll2))\n  )","problem":28,"user":"5369a4b1e4b0243289761e9f"},{"code":"#(map read-string (re-seq #\"[^\\[\\]\\(\\) ]+\" (str %)))\n\n;; Leaving my hack for later amusement\n;; because i'm not ready to re-do it with what i'm learning\n;; about things like (coll? whavever)","problem":28,"user":"52be23dbe4b07a9af5792316"},{"code":"(fn flat [col]\r\n  (loop [l col n []] \r\n    (if-let [f (first l)]\r\n      (recur (rest l) (if-not (coll? f) \r\n                                (concat n [f])\r\n                                (concat n (flat f))))\r\n      n)))","problem":28,"user":"4e83b1af535db62dc21a62dc"},{"problem":28,"code":"(fn fuck-me [my-seq]\n  (println my-seq)\n  (if (some coll? my-seq)\n   (fuck-me (reduce #((if (coll? %2) into conj) %1 %2) '[] my-seq))\n   (seq my-seq)))","user":"5655e056e4b0f9d632dd849b"},{"code":"(fn flat [x] (if (sequential? x) (mapcat flat x) [x]))","problem":28,"user":"52cd093fe4b07d0d72b27376"},{"problem":28,"code":"(fn [a-seq]\n  (loop [acc []\n         sq a-seq]\n    (let [head (take-while (complement coll?) sq)\n         tail (drop-while (complement coll?) sq)\n         cur (first tail)]\n      (if (empty? sq)\n        acc\n        (recur (concat acc head)\n               (concat cur (rest tail)))))))","user":"56b6a50ae4b0982f16b37e3c"},{"problem":28,"code":"(fn flattenize [coll]\n   \t(reduce (fn [x y]\n              (if (coll? y)\n                (into x (reverse (flattenize y)))\n                (conj x y)))\n            (list)\n            (reverse coll)))","user":"60cebbd3e4b0e0fa5f1b4334"},{"problem":28,"code":"(fn flt [n]\n  (let [val (first n) r (next n)]\n    (concat\n      (if (sequential? val)\n        (flt val)\n        [val])\n      (when (sequential? r)\n        (flt r)))))","user":"5a99b861e4b0d174b936c7ad"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce \n    #(if (coll?  %2) \n        (into %1 ( my-flatten %2))\n        (conj  %1 %2)\n      )\n    []\n    coll\n  )\n)","user":"5c7bb8c0e4b0fca0c1622864"},{"code":"#(reduce \n  (fn self [lst elem] \n    (concat lst \n            (cond (coll? elem) \n             (reduce self '() elem) \n             true (list elem)))\n    ) '() %)","problem":28,"user":"51c611c4e4b03a28d42333bf"},{"problem":28,"code":"(fn cFlatten [lst]\n  (if (sequential? lst)\n  \t(mapcat cFlatten lst)\n    [lst]))","user":"5936fabce4b02506e01a298c"},{"problem":28,"code":"(fn [nxs] (remove #(coll? %) (tree-seq #(coll? %) identity nxs)))","user":"52540bcce4b0541d1855b952"},{"problem":28,"code":"(fn flt [s]\n        (if (not (sequential? s))\n          s\n          (when (not (empty? (seq s)))\n            ;; (prn \"flatten\" s)\n            (let [h (first (seq s))\n                  r (rest (seq s))]\n              (if (sequential? h)\n                (let [hh (first (seq h))\n                      hr (rest (seq h))]\n                  (if (empty? hr)\n                    (flt (cons hh r))\n                    (flt (cons hh (cons hr r)))))\n                \n                (cons h (flt r)))\n              ))))","user":"57fc0719e4b0d3187e900987"},{"code":"(fn flatify [sq]\n  (if (coll? sq)\n      (if (seq sq)\n          (concat (flatify (first sq)) (flatify (rest sq))))\n      (list sq)))","problem":28,"user":"505f55d3e4b08f2a82ad10b0"},{"code":"#(filter\n  (complement sequential?)\n  (tree-seq sequential? identity %))","problem":28,"user":"4fefd624e4b0678c553fc31b"},{"problem":28,"code":"(fn\n  [lst]\n  (if (empty? lst)\n    ()\n    ((fn my-flatten2\n    [lst]\n    (if (coll? (first lst))\n      (concat (my-flatten2 (first lst))\n              (my-flatten2 (rest lst)))\n      (if (first lst)\n        (cons (first lst)\n              (my-flatten2 (rest lst)))\n        (first lst)))) lst)))","user":"57f8104ce4b0d3187e900910"},{"problem":28,"code":"(fn f [col] \n  (reduce #(concat %1 (if (sequential? %2) (f %2) [%2])) [] col))","user":"5493d908e4b0b312c081ff52"},{"code":"(fn flat\n  ([xs] (reduce #(\n    if (sequential? %2)\n       (concat %1 (flat %2))\n       (concat %1 [%2])) () xs)))","problem":28,"user":"4f031eac535dcb61093f6a67"},{"problem":28,"code":"(fn flat [col]\n  (loop [res [] col2 col]\n    (if (empty? col2)\n      res\n      (if (coll? (first col2))\n        (recur (apply conj res (flat (first col2))) (rest col2))\n        (recur (conj res (first col2))(rest col2))))))","user":"5e4ba8e8e4b0889a8790a55a"},{"code":"(fn f [[x & xs]] (cond \r\n                 (nil? x) x\r\n                 (sequential? x) (concat (f x) (f xs))\r\n                 :else (concat (list x) (f xs))))","problem":28,"user":"502a9fdee4b095a7adb898b4"},{"problem":28,"code":"(fn f [x] (loop [xixi x] (if (some sequential? xixi) (recur (#(apply concat (map (fn [x] (if (sequential? x) x (list x))) %)) xixi)) xixi)))","user":"56b49f72e4b0982f16b37e23"},{"code":"(fn f [l]\n  (cond (not (seq l)) '()\n        (sequential? (first l)) (concat (f (first l)) (f (rest l)))\n        :else (cons (first l) (f (rest l)))))","problem":28,"user":"53638ed2e4b0243289761e5b"},{"code":"(fn my_flat [x]\n  \n  (cond \n    (empty? x) '()\n   \t(coll? (first x)) (concat (my_flat (first x)) (my_flat (rest x)))\n  \t:else (cons (first x) (my_flat (rest x)))\n   )\n  )","problem":28,"user":"4edf95a8535d10e5ff6f5342"},{"problem":28,"code":"(fn f\n  ([x]\n   (f x []))\n  ([x s]\n   (if (empty? x)\n     (into '() s)\n     (if (sequential? (first x))\n       (recur (rest x) (f (first x) s))\n       (recur (rest x) (conj s (first x)))))))","user":"596d630ae4b069c0a1a19846"},{"problem":28,"code":"(fn flat [coll]\n (mapcat #(if (coll? %) (flat %) (list %)) coll))\n\n;;(fn flat [x]\n ;;(if (coll? x)\n   ;;(mapcat flat x)\n   ;;[x]))","user":"5ac6f7f7e4b0e27600da777a"},{"code":"(fn flatn [coll]\n  (if (empty? coll)\n    coll\n    (if (sequential? (first coll))\n      (concat (flatn (first coll)) (flatn (rest coll)))\n      (cons (first coll) (flatn (rest coll))))))","problem":28,"user":"5042de0de4b034ff00315d1b"},{"problem":28,"code":"(fn a [[f & r :as s]]\n      (when\n          (< 0 (count s))\n        (if (sequential? f)\n          (if (< 0 (count f))\n            (a (cons (first f) (cons (rest f) r)))\n            (a r))\n          (cons f (a r)))))","user":"5e5b8d92e4b0fd0acd158658"},{"code":"(fn foo [c] \n  (lazy-seq\n    (when-let [s (seq c)] \n      (let [head (first s)\n            tail (rest s)] \n        (if (coll? head)\n          (concat (foo head) (foo tail))\n          (cons head (foo tail)))))))","problem":28,"user":"4fd0d058e4b04c3a95aa0408"},{"problem":28,"code":"#(reduce\n       (fn my-flatten [v e]\n         (if (coll? e)\n           (reduce my-flatten v e)\n           (conj v e)))\n       [] %)\n;=\n;(defn my-flatten [v e]\n;  (if (coll? e) \n;    (reduce my-flatten v e)\n;    (conj v e)))\n;\n;(fn [coll]\n;  (seq (reduce my-flatten [] coll)))\n\n\n;=\n;(defn my-reduce [fn acc coll]\n;  (loop [a acc s (seq coll)]\n;    (if (empty? s) a\n;        (recur (fn a (first s)) (rest s)))))\n;\n;  (defn my-flatten [v e]\n;      (if (coll? e)\n;          (do (println e)\n;              (my-reduce my-flatten v e))\n;            (do (println e)\n;                 (conj v e))))\n;\n;(defn flat [coll]\n;  (seq (my-reduce my-flatten [] coll)))","user":"59c77511e4b0a024fb6ae545"},{"code":"(fn flatss [lst]\n  (if (empty? lst) lst\n      (let [f (first lst) r (next lst)]\n        (if (sequential? f)\n          (concat (flatss f) (flatss r))\n          (cons f (flatss r))))))","problem":28,"user":"502a4fdfe4b09dd42f6f3644"},{"problem":28,"code":"#(letfn [(fltn\n  ([data]\n   (fltn (first data) (rest data) []))\n  ([head tail container]\n   (cond\n     (nil? head) container\n     (not (sequential? head)) (fltn (first tail) (rest tail) (conj container head))\n     :else (fltn (first head) (concat (rest head) tail) container))))] (fltn %))","user":"5b11449ce4b0cc2b61a3be2d"},{"code":"(fn flat [s]\n  (if (empty? s) \n    '()\n    (if (sequential? (first s))\n       (concat (flat (first s)) (flat (rest s)))\n       (cons (first s) (flat (rest s))))))","problem":28,"user":"503e6047e4b06c4e0e1fa266"},{"code":"(letfn [(flattn [[x & xs :as coll]]\n          (cond (empty? coll) ()\n                (coll? x) (concat (flattn x) (flattn xs))\n                :else (conj (flattn xs) x)))]\n  flattn)","problem":28,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn flat [lst]\n  (if (sequential? lst)\n    (mapcat flat lst)\n    (list lst)))","problem":28,"user":"4faa9593e4b081705acca1f9"},{"problem":28,"code":"#(loop [xs % rs []]\n   (cond\n    (empty? xs) rs\n    (sequential? (first xs)) (recur (concat (first xs) (rest xs)) rs)\n    :else (recur (rest xs) (conj rs (first xs)))))","user":"58cfbd7ae4b03c36ff7e58ba"},{"code":"(fn [coll]\n  (-> ((fn flt [c]\n         (-> (reduce #(if (sequential? %2)\n                        (concat (flt %2) %1)\n                        (conj %1 %2))\n                     '()\n                     c))) coll)\n      reverse))","problem":28,"user":"51ab4082e4b04e3dc0c27b31"},{"code":"#(let [acc () \n       x % \n       f (fn f [x acc]\n           (if (coll? x) \n             (if (empty? x)\n               acc\n               (f \n                (first x) \n                (f (rest x) acc)))\n             (cons x acc)))]\n   (f % ()))","problem":28,"user":"4f8b27b3e4b02e764a0a5179"},{"code":"(fn flat [aseq] (cond\n                     (empty? aseq) '()\n                     (sequential? (first aseq)) (concat (flat (first aseq)) (flat (rest aseq)))\n                     (= 1 1) (cons (first aseq) (flat (rest aseq)))))","problem":28,"user":"51bf4560e4b013aa0d74b817"},{"problem":28,"code":"(fn flatten-list [list]\n  (reduce (fn [result cur] (if (sequential? cur) (concat result (flatten-list cur)) (concat result [cur]))) '() list))","user":"605714ffe4b069ae89ce6ae1"},{"problem":28,"code":"(fn f [sq]\n  (reduce (fn [flat nxt]\n            (if (coll? nxt)\n              (apply (partial conj flat) (f nxt))\n              (conj flat nxt)))\n          []\n          sq))","user":"5b7ef8e6e4b047b03b203765"},{"problem":28,"code":"(fn [s] (filter #(not (sequential? %))\n  (rest (tree-seq sequential? seq s))))","user":"54fd5e2de4b07d26eda61d33"},{"problem":28,"code":"(fn ! [seq]\n    (reduce (fn [out-vec elem]\n              (if (sequential? elem)\n                (into out-vec (! elem))\n                (conj out-vec elem)))\n            []\n            seq))","user":"5f15a50fe4b091ba50b4dbbc"},{"problem":28,"code":"#(loop [t (take 1 %) r (next %) s '()]\n   (if (nil? t)\n     (reverse s)\n     (if (coll? t)\n         (recur (first t) (concat (next t) r) s)\n         (recur (take 1 r) (next r) (conj s t))\n       )\n     )\n   )","user":"5992de05e4b0866487ed0d7e"},{"code":"(fn f [x]\n  (let [append \n        (fn a [e f]\n          (if (empty? e)\n            f\n            (cons (first e) (a (rest e) f))))]\n    (if (empty? x) x\n      (if (coll? (first x))\n        (append (f (first x)) (f (rest (seq x))))\n        (cons (first x) (f (rest (seq x))))))))","problem":28,"user":"5110b8bae4b04c71fce993f4"},{"problem":28,"code":"(fn flat [y] \n  (let [[x & xs] y] \n  (cond\n    (empty? y) '()\n    (coll? x) (concat (flat x) (flat xs))\n    :else (cons x (flat xs)))))","user":"5a221881e4b0ff51aa4b32c0"},{"problem":28,"code":"(fn\n  [nested-coll]\n  (filter (complement sequential?) (tree-seq sequential? identity nested-coll)))","user":"5ac35d00e4b0e27600da7712"},{"problem":28,"code":"(fn myflatten [x] \n  (let [result [] ] \n    (if-not (coll? x) \n      (concat result (vector x)) \n      (if (empty? x) \n        result \n        (let [fst (first x) rst (rest x) _ (print \"first\" fst) _ (print \"rest\" rst\"\\n\")]\n          (if-not (coll? fst) \n            (concat (concat result (vector fst)) (if-not (empty? rst) (myflatten rst) [] )) \n            (concat (concat result (myflatten fst)) (myflatten rst))))))))","user":"56d74c88e4b0ea9b8538f7d9"},{"code":"(fn [coll]\n  (filter (complement sequential?)\n          (tree-seq sequential? identity coll)))","problem":28,"user":"52a55adee4b0c58976d9abe7"},{"problem":28,"code":"(fn flat [x] (mapcat #(if (coll? %) (flat %) [%]) x))","user":"5be182eae4b0ed4b8aab4c9d"},{"code":"#(letfn [(walk [tree] (cond (coll? tree) (mapcat walk tree) true (list tree)))] (walk %))","problem":28,"user":"52cc85abe4b07d0d72b27367"},{"code":"(fn flat [x] (\n              if (sequential? x) (\n                if (empty? x)\n                  nil\n                  (concat (flat (first x)) (flat (rest x))))\n              (list x)))","problem":28,"user":"50ed5d1be4b06330c1f87c37"},{"code":"(fn my-flatten [x]\n  (if (or (seq? x) (vector? x))\n    (if (empty? x)\n      '()\n      (concat (my-flatten (first x)) (my-flatten (rest x))))\n    (list x)))","problem":28,"user":"53388e2de4b0e30313ee6c9c"},{"problem":28,"code":"(fn flat [s]\n  (let [n (count s)]\n  \t(loop [i 0\n           result []]\n      (if (< i n)\n       (recur (inc i)\n              (apply conj result (if (sequential? (nth s i))\n                                   (flat (nth s i))\n                                   [(nth s i)])))\n        result\n      )\n    )\n  )\n)","user":"568d4742e4b0dcc4269f40c2"},{"problem":28,"code":"(fn do-flatten [x] \n  (if (= x []) []\n   (let [i (first x)]\n     (if (not (sequential? i))\n       (concat [i] (do-flatten (rest x)))\n       (let [j (first i)\n             k (rest i)]\n         (do-flatten (concat [j] k (rest x))))))))","user":"57d1d6c8e4b0bd073c202370"},{"code":"#(into '() ((fn my-flatten [s]\n  (if (empty? s)\n    []\n    (if (coll? (first s))\n      (apply conj\n             (my-flatten (rest s)) \n             (my-flatten (first s)))\n      (conj (my-flatten (rest s))\n            (first s))))) %))","problem":28,"user":"5287f34ee4b0239c8a67ae43"},{"code":"(fn my-flatten [s]\n  (if (empty? s) '()\n    (let [\n          x (first s)\n          xs (rest s)\n          flat-x (if (coll? x) (my-flatten x) [x])\n          flat-xs (my-flatten xs)\n          ]\n      (concat flat-x flat-xs)\n    )\n  )\n)","problem":28,"user":"50d8f4b6e4b01f0871336e74"},{"problem":28,"code":"(fn flat [coll]\n  (cond\n   \t(nil? coll) nil\n    (coll? coll) (for [x coll y (flat x)] y)\n    :else (list coll)))","user":"5bc833a5e4b07a9b28b100bb"},{"code":"(fn flat [L] (reduce #(if (coll? %2) \n           (vec (concat %1 (flat %2)))\n           (conj %1 %2))\n        [] L))","problem":28,"user":"4ff66816e4b0678c553fc37a"},{"code":"(fn [sq]\n  (let [buf (atom [])]\n    ((fn flat*\n       [sq]\n       (doseq [elm sq]\n         (if (sequential? elm)\n           (flat* elm)\n           (swap! buf conj elm))))\n     sq)\n    @buf))","problem":28,"user":"51c3c6a6e4b0851ac09658f8"},{"problem":28,"code":"(fn crush [coll]\n   (reduce\n    (fn flatclone [x y]\n      (if (coll? y)\n        (reduce flatclone x y)\n        (conj x y)))\n      [] coll))","user":"557f748ae4b05c286339e0df"},{"problem":28,"code":"(fn flat [s]\n   (reduce #(into %1 (if (coll? %2) (flat %2) [%2])) [] s))","user":"4fa5c8dde4b081705acca1af"},{"problem":28,"code":"(fn [xs]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq xs))))","user":"559141b1e4b0604b3f94d576"},{"problem":28,"code":"(fn fl [x]\n  (if (sequential? x)\n  \t(reduce concat (map fl x))\n    (list x)))","user":"5ff93da9e4b06df49cee14af"},{"problem":28,"code":"(fn fla [s] (reduce (fn [ss i] (if (sequential? i) (concat ss (fla i)) (concat ss [i]))) [] s))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":28,"code":"(fn r [li] \n  (cond \n  ((complement coll?) li) (list li)\n  (empty? li) li\n  true (concat (r (first li)) (r (rest li)))))","user":"546c1b2ce4b00cfc9eacc174"},{"code":"(fn my-flatten [coll]\n  (cond (not (sequential? coll)) (list coll)\n        (empty? coll) '()\n        :else (concat\n               (my-flatten (first coll))\n               (my-flatten (rest coll)))))","problem":28,"user":"4e4b4564535dc968683fc4d3"},{"code":"(fn fltn [l]\n  (cond\n   (nil? l) []\n   (not (sequential? l)) [l]\n   (sequential? (first l))\n    (into (fltn (first l)) (fltn (next l)))\n   :else\n    (into [(first l)] (fltn (next l))\n    )))","problem":28,"user":"517a7f20e4b01aacecbecbee"},{"problem":28,"code":"(fn stuff \n  ([seq]\n   (stuff seq []))\n  \n  ([seq init]\n   (reduce \n     (fn flatter [acc new]\n       (println (str \"flatter \" acc new))\n       (if-not (coll? new)\n         (conj acc new)\n         (stuff new acc)))\n     init seq)))","user":"5885bea8e4b0f1effa3b76bf"},{"problem":28,"code":"(fn my-flatten [l]\n  (loop [l1 l, l2 `()]\n    (cond\n     (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n     (empty? l1) (reverse l2)\n     :else (recur (rest l1) (cons (first l1) l2)))))","user":"58562083e4b0f14aab7c86eb"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (if (coll? x)\n    (mapcat my-flatten x)\n    [x]))","user":"563799f8e4b0bfe05bf117db"},{"problem":28,"code":"(fn myflatten\n  [coll]\n  (if (empty? coll)\n    coll\n    (let [[f & r] coll]\n     (if (coll? f) (concat (myflatten f) (myflatten r))\n       (cons f (myflatten r))))))","user":"5b0e6795e4b0cc2b61a3be03"},{"problem":28,"code":"(fn f [t]\n  (if (coll? t)\n    (mapcat f t)\n    [t]))","user":"521d064fe4b0c4ef0be830a8"},{"problem":28,"code":"(fn fltn [lst] \n  ((fn explode [item agg] \n     (if (and (not (seq? item)) (not (vector? item)))\n\t\t(conj agg item)\n       \t(if (empty? item)\n           []\n           (into\n            (explode (first item) agg)\n            (explode (rest item) agg)))\n         )) \n   lst []))","user":"5c6e8b57e4b0fca0c1622755"},{"code":"(fn flat [seq] (cond\n                   (not (some coll? seq)) seq \n                   (coll? (first seq)) (concat (flat (first seq)) (flat (rest seq)))\n                   true (cons (first seq) (flat (rest seq)))))","problem":28,"user":"52bebdbfe4b07a9af5792326"},{"problem":28,"code":"(fn d [l]\n    (loop [l (vec l) out []]\n      (if (empty? l) out\n          (recur (rest l)\n                 (let [ll (first l)]\n                    (concat out\n                     (if (sequential? ll)\n                      (vec (d (first l)))\n                      [(first l)])))))))","user":"5da71eaee4b000c986472c15"},{"code":"(fn [sq]\r\n  (loop [isq sq]\r\n    (if (not-any? coll? isq)\r\n      isq\r\n      (recur (apply concat (map #(if (coll? %) % [%]) isq))))))","problem":28,"user":"5060d137e4b0dc10a69545a0"},{"problem":28,"code":"(fn flatten* [x] (if (coll? x) (mapcat flatten* x) [x]))","user":"5d63f1c2e4b0c9e5857d502b"},{"code":"(fn plat [l] (if (sequential? l) (if (empty? l) nil (concat (plat (first l)) (plat (rest l)))) (seq [l])))","problem":28,"user":"5134973ce4b0230e9f713b42"},{"code":"(fn flttn [s]\n  (let [h (first s) t (next s)]\n    (concat\n     (if (sequential? h)\n       (flttn h)\n       [h])\n     (when (sequential? t)\n       (flttn t)))))","problem":28,"user":"5131d817e4b06942423563ca"},{"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (cond\n     (empty? n) ()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","problem":28,"user":"52bb123ae4b07a9af57922de"},{"problem":28,"code":"(fn flatSequence\n  [n]\n  (reduce concat\n    (map #(if (sequential? %)\n            (flatSequence %) (list %)) n)))","user":"5e95013fe4b0fbed045a3800"},{"code":"(fn flat[coll]\n\t(\n    \t(fn builder[wip new]\n          (if (= wip '())\n            new\n            (if (coll? (first wip))\n              (concat (builder (first wip) new) (builder (rest wip) new))\n              (conj (builder (rest wip) new) (first wip))\n            )\n          )\n        )\n     \tcoll '()\n\t)\n)","problem":28,"user":"512ec712e4b029b11c040781"},{"problem":28,"code":"(fn flat [x]\n  (reduce \n   (fn [a b] \n     (if (coll? b) \n       (into [] (concat a (flat b)))\n       (conj a b)))\n   [] x))","user":"59b05f0ee4b0e1f4e384c8cc"},{"code":"(fn my-flatten [x]\r\n        (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e68fe94535d8ccf87e9fe94"},{"problem":28,"code":"(fn flat [coll]\n  (cond\n    (not (coll? coll)) (list coll)\n    (empty? coll) []\n    :else (concat (flat (first coll)) (flat (rest coll)))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":28,"code":"(fn flat [lis]\n  (let [val (first lis) res (rest lis)]\n    (concat\n     (if (or (list? val) (vector? val))\n       (flat val)\n       (list val))\n     (if (not (empty? res))\n       (flat res)))))","user":"52457931e4b08ba239308107"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce (fn [flattened e]\n            (if (coll? e)\n              (into flattened (my-flatten e))\n              (conj flattened e)))\n          []\n          coll))","user":"57c45e64e4b05aa3c4741ccf"},{"problem":28,"code":"(fn ftten [s] (cond\n               (coll? (first s)) (ftten (concat (first s) (rest s)))\n               (= (count s) 1) s\n               :else (concat [(first s)] (ftten (rest s)))))","user":"5c7c1d8ee4b0d597f478ca88"},{"problem":28,"code":"(fn flat [coll]\n  (if (empty? coll)\n    coll\n    (let [first-item (first coll)\n          rest-items (rest coll)]\n      (if (coll? first-item)\n        (concat (flat first-item) (flat rest-items))\n        (cons first-item (flat rest-items))))))","user":"5e805895e4b085ba37836e44"},{"problem":28,"code":"(fn fl[l]\n  (loop [l l ret []]\n    (if (empty? l)\n      ret\n      (recur (rest l)\n             (if (sequential? (first l))\n               (concat ret (fl (first l)))\n               (concat ret [(first l)]))))))","user":"539c88e1e4b0b51d73faaf2c"},{"code":"(fn fltn [coll]\n  (if (sequential? coll) \n    (mapcat fltn coll)\n    (list coll)))","problem":28,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":28,"code":"reduce (fn fl [res el] \n         (if (coll? el) \n           (reduce fl res el) \n           (conj res el))) []","user":"55b77c7ce4b01b9910ae29a3"},{"code":"(fn flat [x]\n  (seq (reduce (fn [acc y]\n            (if (sequential? y)\n              (vec (concat acc (flat y)))\n              (conj acc y)))\n          []\n          x)))","problem":28,"user":"4edecdae535d10e5ff6f533c"},{"code":"(fn fx [[h & t]] \n          (if (nil? h) [] \n          (let [x (if (coll? h) (fx h) [h])] (concat x (fx t)))))","problem":28,"user":"511d11d7e4b022853b0e079f"},{"code":"(fn flatter [s]\n  (loop [lasts '() x s]\n    (if (= lasts x)\n      x\n      (recur \n        x \n        (apply concat \n          (map \n            #(if \n              (coll? %) \n              % \n              (list %))\n            x))))))","problem":28,"user":"4f03fb59535dcb61093f6b89"},{"code":"(fn fl2 [x]\n  (reduce\n   (fn [r, y]\n     (if (or (seq? y) (vector? y))\n       (reduce\n         (fn [r2, z] (conj r2 z))\n         r\n         (fl2 y))\n       (conj r y)\n   ))\n  []\n  x)\n)","problem":28,"user":"51b3a2c8e4b0f094dd986fa6"},{"problem":28,"code":"(fn [aa]\n    (seq((fn fl [v s]\n      (let [fi (first s)\n            f (if (vector? fi) (seq fi) fi)\n            r (rest s)\n            f1 (if (seq? f) (fl v (seq f)) (conj v f))]\n    (println (str v \" \" s \" \" f \" \" f1 \" \" r))\n        (if (seq? (seq r)) (fl f1 r) f1)    \n      )\n    ) [] aa))\n  )","user":"562b1a7be4b058fa18c5a6cb"},{"code":"(fn fl [c] (if (coll? c) (apply concat (map fl c)) (list c)))","problem":28,"user":"4f038355535dcb61093f6b04"},{"problem":28,"code":"(fn [liste] \n  (loop [curtree liste listtree () result ()]\n    (if (empty? curtree)\n      (if (empty? listtree)\n        (reverse result)\n        (recur (peek listtree) (pop listtree) result)\n      )\n      (if (coll? (first curtree))\n        (recur (first curtree) (conj listtree (rest curtree)) result)\n        (recur (rest curtree) listtree (conj result (first curtree)))\n      )\n    )\n  )\n)","user":"556f2009e4b09a3098a52519"},{"code":"(fn [xs]\n        (loop [xs xs\n               old_xs ()\n               acc []]\n              (if (empty? xs)\n                  (if (empty? old_xs)\n                      acc\n                      (recur (first old_xs) \n                             (next old_xs) \n                             acc))\n                  ;; not empty\n                  (if (sequential? (first xs))\n                      (recur (first xs)\n                             (cons (next xs) old_xs)\n                             acc)\n                      (recur (next xs)\n                             old_xs\n                             (conj acc (first xs)))))))","problem":28,"user":"51a8f0c6e4b08d8ec191b821"},{"code":"(fn flat [x] (mapcat #(if (sequential? %) (flat %) [%]) x))","problem":28,"user":"528e64b7e4b0239c8a67aedd"},{"problem":28,"code":"(fn f [x]\n  (if (coll? x)\n    (mapcat f x)\n    (list x)))","user":"56706f01e4b0a866af6896f2"},{"problem":28,"code":"(fn [xs]\n  (letfn [(flattify [acc, x]\n            (if (sequential? x)\n              (reduce flattify acc x)\n              (conj acc x)))]\n\n    (reduce flattify [] xs)))","user":"57ea4569e4b0bfb2137f5b46"},{"problem":28,"code":"(fn f2 [s]\n  (reduce\n    (fn [a b]\n      (concat a\n              (if (coll? b)\n                (f2 b)\n                (list b)\n                )\n\n              )\n      )\n    (list)\n    s\n    )\n  )","user":"55bb7546e4b01b9910ae29e7"},{"problem":28,"code":"(fn my-flatten [xs]\n    (loop [xs xs\n           ys []]\n      (if (empty? xs)\n        ys\n        (if (and (sequential? (first xs)) (not (string? (first xs))))\n          (recur (concat (my-flatten (first xs)) (rest xs)) ys)\n          (recur (rest xs) (conj ys (first xs)))))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [ss]\n  (letfn [(flt [s]\n              (if (coll? s)\n                (apply concat (map flt s))\n                [s]))]\n   (flt ss)))","problem":28,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn flt [c]\n  (cond\n    (empty? c) ()\n    (coll? (first c)) (concat (flt (first c)) (flt (rest c)))\n    :else (cons (first c) (flt (rest c)))))","problem":28,"user":"515e8ce2e4b049add99a053d"},{"problem":28,"code":"(\n fn f [items]\n   (\n     cond\n     (not (sequential? items)) [items]\n     (empty? items) []\n     true (concat (f (first items)) (f (rest items)))\n   )\n )","user":"5e161799e4b0a047bd49f713"},{"problem":28,"code":"(fn flattn [s]\n  (if (empty? s) \n    '()\n\t  (let [f (first s)]\n\t    (if (sequential? f) \n        (concat (flattn f) (flattn (rest s)))\n\t      (cons f (flattn (rest s)))))))","user":"556405e5e4b0c656e3ff17fb"},{"problem":28,"code":"(fn flat [data]\n  (if (coll? data)\n    (mapcat flat data)\n    (list data)))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"(fn [s]\n  (loop [s s]\n    (let [[ns changed?] (reduce (fn [[a changed?] si]\n                                  (if (coll? si) [(reduce conj a si) true]\n                                      [(conj a si) changed?]))\n                                [[] false] s)]\n      (if changed? (recur ns) ns))))","problem":28,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn flat [seq]\n  (if (empty? seq)\n    '()\n    (if (sequential? (first seq))\n      (concat (flat (first seq)) (flat (rest seq)))\n      (cons (first seq) (flat (rest seq))))))","problem":28,"user":"4f0a2ed1535d0136e6c222f3"},{"code":"(fn flad [ys]\n  (lazy-seq\n   (when-let [xs (seq ys)]\n     (let [x (first xs)]\n       (if (sequential? x)\n         (concat (flad x) (flad (rest xs)))\n         (cons x (flad (rest xs))))))))","problem":28,"user":"51d1e840e4b0d13b04db0d91"},{"code":"(fn [s]\n  (loop [[f & r] s o []]\n    (if f\n      (if (sequential? f)\n      \t(recur (concat f r) o)\n     \t(recur r (conj o f)))\n      (seq o))))","problem":28,"user":"4e46e48b535dc968683fc4b7"},{"code":"(fn [x] (filter \n(complement sequential?)\n(rest (tree-seq sequential? seq x))))","problem":28,"user":"4e6ab9cb535d8ccf87e9fefe"},{"problem":28,"code":"(fn f [x]\n  (if (sequential? x)\n    (loop [y x\n           a []]\n      (if (first y)\n        (recur (rest y)\n               (concat a (f (first y))))\n        a)\n      )\n    [x]))","user":"52ae886de4b0c58976d9acab"},{"code":"(fn fltn [in]\n  (mapcat \n   #(if (sequential? %) (fltn %)\n      (list %))\n   in))","problem":28,"user":"537bde5de4b06839e8705e73"},{"code":"(fn myflat [col]\n  (if (coll? col)\n    (reduce concat () (map myflat col))\n    (list col)))","problem":28,"user":"51f2851fe4b0210f90e7454b"},{"code":"(fn f [coll] \n  (reduce #(concat %1 (if (coll? %2) (f %2) [%2])) '() coll))","problem":28,"user":"52e4cc2ee4b09f7907dd1455"},{"code":"(fn fl [collection]\n  (let [f (first collection) n (next collection)]\n    (concat\n      (if (sequential? f)\n        (fl f)\n        [f])\n      (when\n        (sequential? n)\n        (fl n)))))","problem":28,"user":"4ed2b337535d44c135fd68de"},{"problem":28,"code":"(fn flatten*\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"57853bd9e4b0ebec4cfb74d6"},{"problem":28,"code":"(fn flat [l] (reduce\n            (fn [li e]\n              (if (nil? (empty e))\n                (concat li (list e) )\n                (concat  li (flat e))\n                )) `() l))","user":"57a89ae9e4b0a96607956221"},{"problem":28,"code":"(fn flatten-func [coll]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll)))\n  )","user":"5c51d700e4b0fb8c5ffd99d1"},{"code":"(fn my-flatten [s]\r\n  (cond\r\n   (empty? s) ()\r\n   (coll? (first s)) (concat (my-flatten (first s)) (my-flatten (rest s)))\r\n   :else (cons (first s) (my-flatten (rest s)))))","problem":28,"user":"4ed2a92b535d44c135fd68dc"},{"problem":28,"code":"#(filter (complement coll?)\n          (rest (tree-seq sequential? seq %)))","user":"5c481764e4b0e06e1360a3ba"},{"code":"(fn f [s]\n  (if (coll? s)\n    (mapcat f s)\n    [s]))","problem":28,"user":"4fd93c42e4b05e33b9224f35"},{"problem":28,"code":"(fn ff [x]\n  (reduce\n   (fn [m e]\n     (if (sequential? e)\n       (vec (concat m (ff e)))\n       (conj m e)))\n   []\n   x))","user":"552d2e4fe4b076ab5578f7e1"},{"code":"(fn fl [x] (if (sequential? x) (mapcat fl x) [x]))","problem":28,"user":"50fb46e6e4b0d10d794c19e5"},{"problem":28,"code":"(fn fl [coll]\n  (loop [[x & xs :as all] (seq coll)\n         acc '()]\n    (if all\n      (recur xs\n        (if (sequential? x)\n          (concat acc (fl x))\n          (concat acc (list x))\n        )\n      )\n      acc\n    )\n  )\n)","user":"57434339e4b0c285004e8a9f"},{"code":"(fn fl [coll]\n  (if (empty? coll)\n    []\n    (let [f (first coll)\n          r (rest coll)]\n      (if (coll? f)\n        (concat (fl (list (first f))) (fl (rest f)) (fl r))\n        (cons f (fl r))))))","problem":28,"user":"536254a5e4b0243289761e50"},{"problem":28,"code":"(fn flat-step [coll] (mapcat #(if (sequential? %) (flat-step %) [%]) coll))","user":"5da05bcce4b000c986472bd0"},{"problem":28,"code":"(fn f\n    [l]\n    (cond\n     \t(and (sequential? l) (empty? l)) '()\n     \t(sequential? l) (concat (f (first l)) (f (rest l)))\n     \t:else (list l)))","user":"55e6809ee4b050e68259b48a"},{"code":"(fn flat[a]\n  (concat\n    (if(coll? (first a))\n      (flat (first a))\n      [(first a)])\n    (when(coll? (next a))\n      (flat (next a)))))","problem":28,"user":"53862316e4b06839e8705f0e"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (if (empty? x) x\n                   (concat (my-flatten (first x)) (my-flatten (rest x))))\n    (list x)\n  ))","user":"5dc9b2c7e4b02f9375f4e1eb"},{"code":"(fn ! [s]\n  (lazy-seq\n    (if (empty? s)\n      s\n      (let [[head & tail] s]\n        (if (sequential? head)\n          (concat (! head) (! tail))\n          (cons head (! tail)))))))","problem":28,"user":"50b29029e4b03ea880433563"},{"problem":28,"code":"(fn flat [[f & r]]\n  (cond\n    (nil? f) '()\n    (coll? f) (concat (flat f) (flat r))\n    :else (cons f (flat r))))","user":"5a342188e4b0ddc586f153bd"},{"problem":28,"code":"(fn flatten2 [xs]\n  (loop [xs xs r []]\n    (if (first xs)\n      (if (coll? (first xs))\n        (recur (rest xs) (into [] (concat r (flatten2 (first xs)))))\n        (recur (rest xs) (conj r (first xs))))\n      r)))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn fltn [in]\n  (cond\n   (= 0 (count in)) '()\n   (not (coll? (first in))) (cons (first in) (fltn (rest in)))\n   :else (concat (fltn (first in)) (fltn (rest in)))\n  )\n)","problem":28,"user":"5230ba23e4b0035e815da393"},{"code":"(fn flat [x]\n           (if (empty? x)\n               ()\n             (if (sequential? (first x))\n                 (concat (flat (first x))\n                         (flat (rest x)))\n                 (cons (first x)\n                       (flat (rest x))))))","problem":28,"user":"52aa524fe4b0c58976d9ac64"},{"problem":28,"code":"(fn [x]\n  (map read-string (clojure.string/split (clojure.string/replace (str x) #\"[\\(\\[\\{\\}\\]\\)]\" \"\") #\" \")))","user":"574e84e0e4b02ea114799243"},{"code":"(fn fl [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      '()\n      (mapcat fl xs))\n    (list xs)))","problem":28,"user":"52379c46e4b0fae3832e99db"},{"problem":28,"code":"(fn myflatten\n  [coll]\n  (reduce\n    concat\n    ()\n    (map\n      #(if (coll? %)\n         (myflatten %)\n         (list %))\n      coll)))","user":"584cc92be4b0b7285a6f4e2b"},{"code":"(fn f [s]\n  (if (empty? s) s\n                 (let [h (first s)\n                       t (rest s)] (if (coll? h) (concat (f h) (f t))\n                                                 (cons h (f t))))))","problem":28,"user":"52dfc89be4b09f7907dd1405"},{"code":"(fn my-fltn[x]\n\t(loop [mx x result []]\n\t\t(let [fx (first mx)]\t\n\t\t(if(coll? fx) \n\t\t\t(recur (rest mx) (concat result (my-fltn fx ))) \n\t\t\t(if(nil? fx) result\n\t\t\t\t(recur (rest mx) (concat result [fx]) ))))))","problem":28,"user":"50b25f2ce4b03ea88043355f"},{"code":"(fn aa [s]\n (let [news (reduce #(if (coll? %2)\n             (into (vec %) %2)\n             (into (vec %) [%2])) [] s)]\n   (if (= s news) s\n     (aa news))))","problem":28,"user":"53973e7be4b0b51d73faaee6"},{"problem":28,"code":"(fn flatten2\n  [x]\n  (reduce (fn [accum item]\n            (if (sequential? item)\n              (vec (concat accum (flatten2 item)))\n              (conj accum item))) [] x))","user":"538f89bbe4b0b51d73faae8f"},{"code":"#(filter (complement sequential?)\n (tree-seq sequential? identity %))","problem":28,"user":"50052d38e4b0678c553fc45c"},{"problem":28,"code":"(fn flatn [s]\n   (if (or (coll? s))\n     (mapcat flatn s)\n     [s]))","user":"5746d767e4b009280f9f2b6b"},{"code":"(fn flat [[s & more :as c]]\n  (cond\n    (empty? c) []\n    (coll? s) (seq (concat (flat s) (flat more)))\n    :else (seq (concat (vector s) (flat more)))))","problem":28,"user":"4e951f2c535dbda64a6f6b2f"},{"problem":28,"code":"(fn flatten' [xs]\n  (if (sequential? xs) (reduce concat '() (map flatten' xs)) (list xs)))","user":"5602f72fe4b04bb52996e1ae"},{"problem":28,"code":"(fn flat [[x & xs :as coll]]\n  (cond\n   (empty? coll) nil\n   (sequential? x) (concat (flat x) (flat xs))\n   :else (cons x (flat xs))))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn flattener [s]\n  (if (sequential? s)\n    (reduce concat (map flattener s))\n    (list s)))","problem":28,"user":"5213dbc3e4b0961f15ac4d74"},{"problem":28,"code":"(fn myflat [coll]\n  (mapcat \n    #(if (coll? %)\n         (myflat %)\n         (list %))\n     coll))","user":"4f29d9abe4b0d6649770a034"},{"problem":28,"code":"(fn [x]\n  (let [\n        find-and-add-next-seq (fn [x y]\n    (loop [new-seq x\n           old-seq y]\n       \n           (if (sequential? old-seq)\n               (if (sequential? (first old-seq))\n                   (do\n                       (println \"sequential\")\n                       (recur new-seq (first old-seq) ))\n                   (do\n                       (println \"not sequential\" old-seq \"-->\" new-seq)\n                       (if (seq (rest old-seq))\n                           (recur (conj new-seq (first old-seq)) (rest old-seq))\n                           (conj new-seq (first old-seq)))))\n                (let [result (conj (into [] new-seq) old-seq)] \n                    (println \"not sequential result\" result)\n                    result))))\n        ]\n    (reduce #(find-and-add-next-seq %1 %2) [] x)\n    ))","user":"5f1eebcee4b0f565ad998273"},{"code":"(fn [arr] (reverse (loop [result nil, s arr] (if s (if (sequential? (first s)) (recur result (concat (first s) (rest s) )) (recur (cons (first s) result) (next s) ) ) result ))))","problem":28,"user":"52f84c94e4b047fd55836fcf"},{"code":"(fn flat-dat [x]\n  (reduce #(concat %1\n                   (if (coll? %2)\n                     (flat-dat %2)\n                     (list %2)))\n          ()\n          x))","problem":28,"user":"52890634e4b0239c8a67ae5e"},{"problem":28,"code":"(fn flat\r\n  [[l & r]]\r\n    (concat \r\n      (if (coll? l) (flat l) (list l))\r\n      (if (nil? r) '() (if (coll? r) (flat r) (list r)))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":28,"code":"(fn [s] \n  (filter (complement sequential?) \n          (tree-seq sequential? seq s)))","user":"51515a19e4b03e678e393acc"},{"problem":28,"code":"(fn my-flatten [s]\n  (cond (coll? s) (mapcat my-flatten s)\n          :else\n          [s]))","user":"4e6a23d0535d8ccf87e9fea0"},{"problem":28,"code":"(fn [s]\n  (loop [in s out '()]\n    (let [fst (first in)\n          rst (rest in)]\n    (cond\n     (sequential? fst) (recur (concat fst rst) out)\n     (empty? in) (reverse out)\n     :else (recur rst (cons fst out))))))","user":"54764a8fe4b0c51c1f4d72a3"},{"code":"#(letfn [(flat [[x & xs]]\n           (if x\n             (if (sequential? x)\n               (concat (flat x) (flat xs))\n               (cons x (flat xs)))))]\n   (flat %))","problem":28,"user":"4e8ccd16535d65386fec212e"},{"code":"(fn flat [[a & b]]\n  (if a\n    (if (coll? a)\n      (concat (flat a) (flat b))\n      (cons a (flat b)))))","problem":28,"user":"52393e16e4b0d705d026ef06"},{"problem":28,"code":"(fn my-flatten [x] (if (sequential? x) (mapcat my-flatten x) (list x)))","user":"6093cc08e4b00e9e6653c3e1"},{"problem":28,"code":"(fn flatten-a-sequence\n  [coll]\n  (if (not (nil? coll))\n    (if (sequential? coll)\n      (let [item (first coll)]\n        (if (sequential? item)\n          (concat (flatten-a-sequence item) (flatten-a-sequence (next coll)))\n          (cons item (flatten-a-sequence (next coll)))))\n      (list coll))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":28,"code":"(fn -me [ls]\n\t\t\t(loop [res [], seq ls]\n\t\t\t\t(if (empty? seq) res (recur\n\t\t\t\t\t(if (coll? (first seq))\n\t\t\t\t\t\t(into res (-me (first seq)))\n\t\t\t\t\t\t(conj res (first seq))\n\t\t\t\t\t)\n\t\t\t\t\t(next seq)\n\t\t\t\t))\n\t\t\t\t\t\n\t\t\t)\n\t\t)","user":"5d73530ce4b02e6b30c93514"},{"code":"(fn flat [lst]\n  (mapcat #(if (sequential? %)\n             (flat %)\n             (list %))\n          lst))","problem":28,"user":"52facb9de4b047fd55837002"},{"problem":28,"code":"(fn flat [v] (if (or (vector? v) (seq? v)) (reduce #(concat %1 (flat %2)) () v) (list v)))","user":"5593619ae4b0c79f6e1db93c"},{"code":"(fn my-flat [coll]\n  (if (empty? coll)\n    ()\n    (lazy-seq\n      (when (coll? coll)\n        (if (coll? (first coll))\n          (concat (my-flat (first coll))\n                  (my-flat (rest coll)))\n          (cons (first coll) (my-flat (rest coll))))))))","problem":28,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":28,"code":"#(letfn [(f2 [s collect]\n  (if (seq s)\n    (if (coll? (first s))\n      (f2 (rest s) (f2 (first s) collect))\n      (f2 (rest s) (conj collect (first s))))\n    collect))]\n   (f2 %1 []))","user":"576aea4fe4b0a07e8fc18126"},{"problem":28,"code":"(fn tt [seq]\n   (if (nil? seq) []\n       (let [f (first seq)]\n         (if (or (seq? f) (vector? f))\n           (into  (tt f) (tt (next seq)))\n           (into [f] (tt (next seq))))))\n   )","user":"542b764ae4b0dad94371f28d"},{"problem":28,"code":"(fn unwrap [my-seq]\n  (if (sequential? my-seq)\n  (mapcat (fn[el] (if (sequential? el) (unwrap el) (list el)) ) my-seq)\n\t(list my-seq)))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn flt [x] \n  (let [f (first x) n (next x)]\n    (concat \n      (if (sequential? f)\n      (flt f)\n      [f])\n    (when (sequential? n)\n      (flt n))\n)))","problem":28,"user":"4f7b1c63e4b06e829148e19e"},{"code":"(fn flt [[e & s :as es]]\n  (if (empty? es) []\n    (if (sequential? e) \n      (concat (flt e) (flt s))\n      (cons e (flt s)))))","problem":28,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn f [x] (mapcat #(if (sequential? %) (f %) [%]) x))","problem":28,"user":"503917a0e4b088a6a14ca763"},{"problem":28,"code":"(fn flt [x] (reverse (loop [n 0 res '()] (if (>= n (count x)) res (recur (inc n) (if (sequential? (nth x n)) (into res (flt (nth x n))) (conj res (nth x n)) ))))))","user":"6076adb2e4b069485764de60"},{"problem":28,"code":"(partial\n(fn go [acc xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      acc\n      (concat\n        (go acc (first xs))\n        (go acc (rest xs))))\n  (conj acc xs)))\n [])","user":"55381162e4b09218d5f44fda"},{"problem":28,"code":"(fn my-flatten  [lst]\n  (if (empty? lst)\n    lst\n    (if (or(seq? (first lst))(vector? (first lst)))\n      (concat (my-flatten (first lst))\n              (my-flatten (rest lst)))\n      (cons (first lst) (my-flatten (rest lst))))))","user":"59dd387ae4b0a0ac046f2501"},{"problem":28,"code":"(fn _ [s] (loop [x s, r []]\n (if (empty? x) r (recur\n  (rest x)\n  (let [y (first x)]\n   (if (coll? y)\n    (into [] (concat r (_ y)))\n    (conj r y)\n))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":28,"code":"(fn ftn\n  [xs]\n  (if\n    (empty? xs)\n    []\n    (let [[head & tail] xs]\n      (concat\n        (if (or (list? head) (vector? head)) (ftn head) [head])\n        (ftn tail)))))","user":"6045582fe4b02d28681c77b6"},{"problem":28,"code":"(fn foo [x]\n\t\t(if (empty? (rest x))\n\t\t\t\t(\n\t\t\t\t\t\tif (sequential? (first x))\n\t\t\t\t\t\t(foo (concat (first x)))\n\t\t\t\t\t\tx\n\t\t\t\t)\n\t\t\t\t(\n\t\t\t\t\t\t\t\tif (sequential? (first x))\n\t\t\t\t\t\t\t\t\t\t\t(foo (concat (first x) (rest x)))\n\t\t\t\t\t\t\t\t\t\t\t(cons (first x) (foo (rest x)))\n\t\t\t\t)\n\t\t)\n)","user":"575dda55e4b02ea11479938c"},{"problem":28,"code":"(fn f [t]\n  (cond \n    (not (coll? t)) (list t)\n    (empty? t) nil \n    :e (concat (f (first t)) (f (rest t)))))","user":"57f2bf56e4b0511f1d294df8"},{"problem":28,"code":"(fn [x] (remove coll? (tree-seq coll? identity x)))","user":"554b8b78e4b0a04f7929958d"},{"problem":28,"code":"(fn flat\n  [nested]\n  (reduce \n   (fn [acc elem]\n     (if (coll? elem)\n       (concat acc (flat elem))\n       (concat acc [elem])))  \n   '()\n   nested))","user":"54b17a49e4b09f271ff37d1e"},{"problem":28,"code":"(fn flat\n  ([coll flattened]\n   (let [[first & remaining] coll]\n     (if (nil? first)\n        flattened\n     \t(if (or (list? first) (set? first) (vector? first))\n       \t\t(flat remaining (flat first flattened))\n       \t\t(flat remaining (conj flattened first))))))\n  ([coll]\n   (flat coll [])))","user":"56822f37e4b0945ebc182a8d"},{"code":"(fn fl [a-seq]\n  (let [f (first a-seq)]\n    (cond\n     (nil? f) '()\n     (coll? f) (concat (fl f) (fl (rest a-seq)))\n     :else (cons f (fl (rest a-seq))))))","problem":28,"user":"4fda8f57e4b05e33b9224f4e"},{"code":"(fn flatten-it [x] (cond (and (sequential? x) (empty? x)) x (not (sequential? x)) (list x) :else (concat (flatten-it (first x)) (flatten-it (rest x)))))","problem":28,"user":"539b4268e4b0b51d73faaf1c"},{"problem":28,"code":"(fn [x]\n        (loop [a x r '() ]\n                (cond\n                        (empty? a) (reverse r)\n                        (sequential? (first a)) (recur (concat (first a)(rest a)) r )\n                        (= true) (recur (rest a) (cons (first a) r))\n                )\n        )\n)","user":"5661b0a9e4b068f2fe63dc6f"},{"code":"(fn [col]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq col))))","problem":28,"user":"527dc2aee4b0757a1b17138d"},{"problem":28,"code":"(fn f [c] (if (empty? c) [] (into  (if (coll? (first c)) (f (first c)) (vector (first c))) (f (rest c)))))","user":"59614d9ce4b066ee0a44b09d"},{"code":"(fn my-flatten [col]\n  (let [flattener\n        (fn flattener [accum val]\n          (if (coll? val) (reduce flattener accum val) (conj accum val)))]\n   (reverse (reduce flattener '() col))))","problem":28,"user":"50763574e4b0a894bb95bf3d"},{"problem":28,"code":"(fn flat [seed]\n   (reduce\n     (fn [coll el]\n       (if (coll? el)\n         (concat coll (flat el))\n         (concat coll [el])))\n     '()\n     seed))","user":"550309b9e4b086ebe8a79c65"},{"problem":28,"code":"(fn myflat [coll]\n  (if (empty? coll)\n    (empty coll)\n    (let [myfirst (first coll)]\n      (if (or (seq? myfirst) (vector? myfirst))\n        (concat (myflat myfirst) (myflat (rest coll)))\n        (cons myfirst (myflat (rest coll)))))))","user":"5c755e56e4b0fca0c16227d9"},{"code":"(fn flatten-sequence [coll] \n    (if (coll? coll) \n      (mapcat flatten-sequence coll)\n      (list coll)))","problem":28,"user":"52c00e4fe4b07a9af5792342"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (if (seq s)\n      (concat (my-flatten (first s)) (my-flatten (rest s)))\n      (list))\n    (list s)))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":28,"code":"(fn peu [x] (if (coll? x) (seq (mapcat peu x)) (list x) ))","user":"53fc8424e4b0de5c418485b3"},{"problem":28,"code":"(fn f [lst] (if (empty? lst) nil (if (coll? (first lst)) (f (concat (first lst) (rest lst))) (concat (list (first lst)) (f (rest lst))))))","user":"5686e652e4b0dcc4269f4059"},{"problem":28,"code":"#(letfn [(flat? [s]\n           (not (or (some sequential? s) (some seq? s))))]\n   (loop [curr-seq %]\n     (if (flat? curr-seq)\n       curr-seq\n       (recur (reduce (fn [x y]\n                        (if (or (seq? y) (sequential? y))\n                          (concat x y)\n                          (concat x [y]))) [] curr-seq)))))","user":"5595ffabe4b0c79f6e1db972"},{"problem":28,"code":"(fn my-flatten [xs]\n  (reduce (fn [acc x] (concat acc (if (coll? x) (my-flatten x) [x]))) [] xs))","user":"5687b6abe4b0dcc4269f4061"},{"problem":28,"code":"(fn [z]\n  (reduce (fn flatz [x y]\n    (if (coll? y)\n      (reduce flatz x y)\n      (conj x y)))\n    []\n    z))","user":"5628f33ce4b00e49c7cb47f3"},{"code":"#(filter (complement sequential?)\n               (rest (tree-seq sequential? seq %)))","problem":28,"user":"50ee68fce4b06330c1f87c59"},{"code":"(fn f [x] (if (sequential? x) (if (empty? x) () \n               (into\n                (f (first x))\n                (f (rest x))))\n              [x]))","problem":28,"user":"5186448fe4b0da5a5be3bac9"},{"code":"(fn f [coll]\n  (if (coll? coll)\n    (mapcat f coll)\n    [coll]))","problem":28,"user":"4e6dd51b535d5021c1a895f6"},{"code":"(fn [x]\n         ((fn flatrec [i]\n            (if(sequential? i)\n              (mapcat flatrec i)\n              (list i)))\n         x))","problem":28,"user":"4f0399c4535dcb61093f6b34"},{"code":"(fn flt [coll]\n  (let [ l (first coll)\n         r (next coll) ]\n    (concat\n      (if (coll? l)\n        (flt l)\n        [l])\n      (if (coll? r)\n        (flt r)))))","problem":28,"user":"51dd6a7ce4b0c33a4e1da409"},{"problem":28,"code":"(fn [a-coll]\n  (filter #(not (sequential? %))\n          (tree-seq sequential?\n                    identity\n                    a-coll)))","user":"5688e403e4b0dcc4269f4072"},{"code":"(fn [xs]\n  (loop [x xs acc []]\n    (println x acc)\n    (if (empty? x)\n      acc\n      (if (coll? (first x))\n        (if (empty? (first x))\n          (recur (rest x) acc)\n          (recur (conj (rest x) (rest (first x)) (first (first x))) acc))\n        (recur (rest x) (conj acc (first x)))))))","problem":28,"user":"5050b107e4b063148f524126"},{"code":"(fn my-flatten[coll] \n  (let[len (count coll)] \n    (loop[i 0 r []] \n      (if(= i len) \n        r \n        (let[e (nth coll i)] \n          (recur \n           (inc i) \n           (if(coll? e) (into r (my-flatten e)) (conj r e))\n           )\n          )\n        )\n      )\n    )\n  )","problem":28,"user":"52e68e61e4b09f7907dd1479"},{"code":"(fn flt [s]\n  (if (sequential? s)\n      (apply concat (map flt s))\n      (list s)))","problem":28,"user":"4f4e78fee4b03ad3f0c10cc8"},{"code":"(fn [s] ((fn chop [f n] (if (or (seq? (first n)) (vector? (first n)))\n                      (chop (chop f (first n)) (rest n))\n                      (if (empty? (rest n)) \n                          (if (nil? (first n))\n                           f\n                           (conj f (first n)))\n                          (chop (conj f (first n)) (rest n))))) [] s))","problem":28,"user":"4e5e9f6b535d8a8b8723a2d2"},{"problem":28,"code":"(fn flatten' [xs]\n  (if (sequential? xs)\n    (if (> (count xs) 0)\n      (reduce conj (flatten' (first xs)) (flatten' (rest xs)))\n      (first xs))\n    [xs]))","user":"579563ffe4b0e215f87e847e"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (sequential? f) (concat (flat f) (flat r)) \n          :else (cons f (flat r))\n          )))","user":"55c7c4dfe4b0e31453f649d7"},{"problem":28,"code":"(fn [lst] \n  (letfn [(squish [x] \n                  (apply concat \n                         (map #(if (sequential? %) % (list %)) x)))] \n    (if \n      (= lst (squish lst)) \n         lst \n         (recur (squish lst)))))","user":"56b86e64e4b0f26550335924"},{"code":"(fn my-flatten [my-list]\n  (reduce (fn [a b]\n            (into\n              a\n              (if (coll? b) (reverse (my-flatten b)) (list b))))\n          '()\n          (reverse my-list)))","problem":28,"user":"4efb92ce535dced4c769f27a"},{"problem":28,"code":"(fn [l]\n   (letfn [(flat [list]\n                (reduce \n                 (fn [r x] \n                   (if (or (vector? x) (list? x) (seq? x))\n                     (concat r (flat x))\n                     (conj r x))) \n                 [] list))]\n     (sort (flat l))))","user":"554b2151e4b0a04f79299580"},{"problem":28,"code":"(fn squash [x]\n  (if (coll? x)\n    (mapcat squash x)\n    [x]))","user":"5547bcf2e4b0a04f79299551"},{"problem":28,"code":"reduce\n(fn self [xs e] (concat xs (if (coll? e) (reduce self '() e) (list e))))\n'()","user":"53db43aae4b0e771c30254b1"},{"problem":28,"code":"(fn flat [xs]\n      (if (coll? xs)\n        (reduce concat (map flat xs))\n        (list xs)\n   ))","user":"54258e71e4b01498b1a71b0e"},{"problem":28,"code":"(fn _flatten [x]\n   (cond (= () x) nil\n         (not (coll? x)) (list x)\n         true (concat (_flatten (first x))\n                      (_flatten (rest x)))))","user":"53c0f4dee4b00fb29b221259"},{"code":"(fn flt [nodes]\r\n  (let [left (first nodes)\r\n  right (next nodes)]\r\n    (concat\r\n     (if (sequential? left)\r\n       (flt left)\r\n       [left])\r\n     (when (sequential? right)\r\n       (flt right)))))","problem":28,"user":"4f7b3d53e4b06e829148e1a0"},{"problem":28,"code":"(fn mi-flatten [coleccion]\n  (loop [coleccion-inicial coleccion, coleccion-final `()]\n    (cond\n      (sequential?\n        (first coleccion-inicial)) (recur (concat (first coleccion-inicial) (rest coleccion-inicial)) coleccion-final)\n      (empty? coleccion-inicial) (reverse coleccion-final)\n      :else (recur (rest coleccion-inicial) (cons (first coleccion-inicial) coleccion-final)))))","user":"599f7a7ee4b0871e7608b81e"},{"code":"(fn f [s]\n  (cond (nil? s) []\n        ((complement coll?) s) [s]\n        (empty? s) []\n        :else (concat [] (f (first s)) (f (rest s)))))","problem":28,"user":"5236b6bce4b05f3be1c7c8fe"},{"problem":28,"code":"(fn myflatten [x]\n (if (coll? x)\n   (mapcat myflatten x)\n   (list x)))","user":"509fda73e4b08df8156e9e41"},{"problem":28,"code":"(fn flat [x]\n  (loop [x x]\n    (if (not-any? coll? x)\n      x\n      (recur (apply concat (map (fn [x]\n                                  (if (coll? x)\n                                    x\n                                    (list x)))\n                                x))))))","user":"55c68089e4b0e31453f649c4"},{"code":"#(mapcat (fn flttn [item]\n       (if (coll? item)\n         (if (empty? item)\n           item\n           (concat (flttn (first item)) (flttn (rest item))))\n         (list item)))\n     %)","problem":28,"user":"5338387de4b0e30313ee6c91"},{"problem":28,"code":"(fn my [coll] \n  (if (nil? coll)\n    nil\n    (if (coll? coll)\n          (reduce (fn [a b] (concat (my a) (my b))) (conj coll nil))\n        (conj '() coll))))","user":"5971a017e4b01722bebd4c75"},{"problem":28,"code":"(fn [s]\n  (->> s\n       (tree-seq coll? identity)\n       (filter #(not (coll? %1)))))","user":"5a9db5c9e4b0d174b936c7f1"},{"problem":28,"code":"#(loop [l1 %, l2 `()]\n     (cond\n       (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n       (empty? l1) (reverse l2)\n       :else (recur (rest l1) (cons (first l1) l2))))","user":"5629de63e4b00e49c7cb4812"},{"code":"#(filter (complement sequential?) (tree-seq sequential? seq %) )","problem":28,"user":"4de8a7d7535d08e6dec9fdfe"},{"code":"(fn my-flatten[a-seq]\n\t(\n     (fn el-to-list [el]\n\t    (if (sequential? el)\n\t\t    (mapcat #(el-to-list %) el)\n\t\t    (list el)\n        )\n     )\n\ta-seq)\n    \t\n)","problem":28,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn f [l]\n    (if (empty? l)\n      l\n      (concat\n        (if (coll? (first l))\n          (f (first l))\n          [(first l)])\n        (f (rest l)))))","problem":28,"user":"4ebbffbd535dfed6da9c6d79"},{"problem":28,"code":"(fn do-the-needful [d] \n    (if (coll? d) \n      (apply concat (map do-the-needful d))\n      (vector d)))","user":"51b91b08e4b0e871ca4958f8"},{"problem":28,"code":"(fn flattenize [l]\n  (loop [left l result []]\n    (if (empty? left)\n        result\n      (let [elt (first left)]\n        (recur (rest left)\n               (if (not (coll? elt))\n                   (conj result elt)\n                 (into [] (concat result (flattenize elt)))))))))","user":"58fb87efe4b0438e51c2cf7b"},{"problem":28,"code":"(fn p28\n\t( [seq] (if (coll? seq) (reduce concat (map p28 seq)) (list seq))))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"(fn flatt [lss]\r\n  (cond\r\n    (empty? lss) '()\r\n    (coll? (first lss)) (concat (flatt (first lss))\r\n                                (flatt (rest lss)))\r\n    :else (cons (first lss) (flatt (rest lss)))))","problem":28,"user":"4dd62278535d2dad7130b5c7"},{"problem":28,"code":"(fn flat\n    ([xs] (flat xs []))\n    ([xs acc] \n         (if (empty? xs) \n             acc\n             (if (sequential? (first xs))\n               (flat (rest xs) (concat acc (flat (first xs))))\n               (flat (rest xs) (concat acc [(first xs)]))\n             )\n         )\n    )\n)","user":"5a34cc9fe4b0ddc586f153ce"},{"problem":28,"code":"(fn aplatir\n  ([xs] (aplatir xs []))\n  ([xs output]\n   (reduce\n     (fn [acc item]\n       (if (coll? item)\n        (aplatir item acc)\n        (conj acc item)))\n     output\n     xs)))","user":"54cb378be4b057c6fda3a273"},{"code":"#(filter (complement sequential?)  (tree-seq  sequential? seq %))","problem":28,"user":"4e86d3cf535dceadca46984c"},{"code":"(fn fl [x] (println x, (coll? x))\n            (if (empty? (rest x))\n                (if (coll? (first x))\n                    (fl (first x))\n                    (list (first x)))\n              (if (coll? (first x))\n                (concat (fl (first x)) (fl (rest x)))\n                (concat (list (first x)) (fl (rest x)))\n                )\n              )\n            )","problem":28,"user":"5194f482e4b05be8c43d2385"},{"problem":28,"code":"#(filter (complement sequential?)\n\t(rest (tree-seq sequential? seq %)))","user":"6040e6dbe4b0d5df2af2232a"},{"code":"(fn ! [x] (if (sequential? x) (mapcat ! x) (list x)))","problem":28,"user":"4f1d1299535d64f603146487"},{"code":"(fn fltn[xs]\n  (if (or (seq? xs) (vector? xs))\n    (apply concat (map fltn xs))\n    (list xs)))","problem":28,"user":"50ef96a1e4b0bdaecbb47d9d"},{"problem":28,"code":"(fn flatr ([c] (flatr c '())) ([c a] (cond (coll? c) (if (empty? c) a (concat (flatr (first c) '()) (flatr (rest c) a))) :else (list c))))","user":"549cc867e4b0f3d1d8e70f8f"},{"code":"(fn flat [[x & s :as all]]\n  (cond\n    (empty? all) '()\n    (or (seq? x) (vector? x)) (concat (flat x) (flat s))\n    true (cons x (flat s))\n))","problem":28,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn f [l]\n  (reduce (fn [acc el]\n            (if\n              (or (seq? el) (list? el) (vector? el))\n              (concat acc (f el))\n              (conj (vec acc) el))) () l))","problem":28,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":28,"code":"(fn fl [x] (if (sequential? x) (mapcat fl x) (list x)))","user":"5f8fe45ae4b0715f5002d78d"},{"problem":28,"code":"(fn my-flatten [v]\n  (let [r []]\n    (cond (empty? v) r\n          (sequential? (first v)) (into (my-flatten (first v)) (my-flatten (rest v)))\n          :else (vec (cons (first v) (my-flatten (rest v)))))))","user":"562268dce4b03f08ee9a9224"},{"problem":28,"code":"(fn fltn [coll]\n  (reduce (fn [c v]\n            (if (sequential? v)\n              (concat c (fltn v))\n              (concat c (list v)))\n            ) '() coll)\n)","user":"54c779bee4b045293a27f63b"},{"problem":28,"code":"(fn flat [[x & xs]]\n   (concat\n     (if (sequential? x) (flat x) [x])\n     (when (seq xs) (flat xs))))","user":"54ba9ee8e4b0ed20f4ff6eb7"},{"code":"(fn flatten_ [lst]\r\n(cond (not (coll? lst)) (list lst)\r\n(empty? lst) ()\r\n:else (concat (flatten_ (first lst)) (flatten_ (rest lst)))))","problem":28,"user":"4fbbb6ede4b081705acca2ed"},{"code":"(fn mkflat [lst] \n  (mapcat #(if (sequential? %) (mkflat %) [%]) lst))","problem":28,"user":"51040eb2e4b0432126ba9bb4"},{"problem":28,"code":"(fn flat [xs]\n  (if (empty? xs) \n    (empty xs) \n    (let [elem (first xs)]\n      (if (sequential? elem)\n        (concat (flat elem) (flat (rest xs)))\n        (cons elem (flat (rest xs)))))))","user":"548cd637e4b0e286459a1210"},{"problem":28,"code":"(fn flatten* [x] (if (coll? x) (if (empty? x) x (concat (flatten* (first x)) (flatten* (rest x)))) (list x)))","user":"5528a8cae4b0ffed3738f940"},{"code":"(fn [s]\n  (loop [s s ret ()]\n    (if s\n      (if (coll? (first s))\n        (recur (concat (first s) (rest s)) ret)\n        (recur (next s) (concat ret (list (first s))))) \n    ret)))","problem":28,"user":"51000111e4b00d7ad4cab15e"},{"code":"(fn $ [ x ]\n  (lazy-seq \n    (let [c (seq x)\n          [x & xs] c]\n      (cond \n        (not c) nil\n        (sequential? x) (concat ($ x) ($ xs))\n        :else (cons x ($ xs))))))","problem":28,"user":"50086dafe4b028e089d3518d"},{"code":"(fn f [c]\r\n  (if (coll? c)\r\n      (if (= (count c) 1)\r\n          (f (first c))\r\n          (concat (f (first c)) (f (rest c))))\r\n      (list c)))","problem":28,"user":"4df1ce44535d08e6dec9fe1f"},{"code":"(fn flatr [coll]\n  (if (empty? coll)\n    coll\n    (if (sequential? (first coll))\n    (concat (flatr (first coll)) (flatr (rest coll)))\n    (cons          (first coll)  (flatr (rest coll))))))","problem":28,"user":"52ce165fe4b07d0d72b27388"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (let [l (first coll)\n        r (next coll)]\n    (concat\n     (if (sequential? l)\n              (my-flatten l)\n              [l])\n     (when (sequential? r)\n       (my-flatten r)))))","user":"5ec5f7f2e4b08d0ec38692d1"},{"code":"(fn fl [x] (reduce concat (map (fn f [y] ( if (vector? y) (fl (reverse (into () y))) (if (list? y) (fl y) (list y) )  )) x)))","problem":28,"user":"5296008fe4b02ebb4ef7502a"},{"problem":28,"code":"(fn my_flatten [X]\n  (if (not (coll? X)) \n    (list X) \n    (mapcat my_flatten X)))","user":"569c07b9e4b0542e1f8d145d"},{"problem":28,"code":"(fn l [xs]\n  (apply concat (map (fn [x]\n                       (if (coll? x)\n                         (l x)\n                         [x]))\n                     xs)))","user":"5ce077e9e4b0a17bb84e2b0c"},{"code":"(fn flat [s]\n  (if (empty? s)\n    s\n    (let [h (first s)\n          t (rest s)]\n      (if (coll? h)\n        (concat (flat h) (flat t))\n        (conj (flat t) h)))))","problem":28,"user":"506d5e4ce4b0a302964c5493"},{"problem":28,"code":"(fn flat\n  [x]\n  (if (coll? x)\n    (if (not-empty x)\n      (concat (flat (first x)) (flat (rest x))))\n    [x]))","user":"59f77dfae4b0966464fe6af4"},{"problem":28,"code":"(fn flat [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s)))))))","user":"5632b0a9e4b0bfe05bf117a8"},{"problem":28,"code":"(fn [y] \n  (filter #(not (coll? %))\n          (tree-seq (fn [_] true)\n                    (fn [x]\n                      (if (coll? x)\n                        x\n                        nil))\n                    y)))","user":"54801febe4b0c51c1f4d733c"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x)\n    (reduce concat (map flat x))\n    [x]))","user":"56cfa716e4b0ea9b8538f76d"},{"problem":28,"code":"(fn [xs] (filter (complement coll?) (tree-seq coll? identity xs)))","user":"551d8796e4b07993ea3788ec"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (empty? coll)\n    '()\n    (if (coll? (first coll))\n      (if (empty? (first coll))\n        (my-flatten (rest coll))\n        (concat (my-flatten (first coll)) (my-flatten (rest coll))))\n      (cons (first coll) (my-flatten (rest coll))))))","user":"56714922e4b05957ce8c6107"},{"problem":28,"code":"( fn [lst] ( last ( take 10 ( iterate  #( reduce ( fn [xs next] ( if (coll? next) (into [] (concat xs next)) ( conj xs next ) ) ) [] % ) lst  ) ) ) )","user":"54fc7d89e4b07d26eda61d2b"},{"problem":28,"code":"(fn [lst] (reverse ((fn fltnr [oldC newC] (if (coll? oldC) (if (coll? (first oldC)) (fltnr (concat (list (first (first oldC))) (rest (first oldC)) (rest oldC)) newC) (if (= (first oldC) nil) newC (fltnr (rest oldC) (cons (first oldC) newC)))) (if (= oldC nil) newC (cons oldC newC)))) lst '())))","user":"5d1cd478e4b02ea6f0fb6991"},{"problem":28,"code":"(fn  [s]\n  (cond\n    (not (sequential? s)) (list s)\n    (empty? s) '()\n    :else (concat ( (first s)) ( (rest s)))\n  )\n)","user":"540f09b9e4b0addc1aec6725"},{"code":"#(filter (complement sequential?)\r\n         (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e6defcc535d5021c1a895f8"},{"code":"(fn flatten* [l]\n    (if (sequential? l)\n        (if (empty? l) []\n          (into (flatten* (first l))\n                (flatten* (rest l))))\n        [l]))","problem":28,"user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":28,"code":"(fn [z] \n  (if (seq (filter sequential? z))\n  \t(recur \n     (reduce\n \t \t(fn [x y] (if (sequential? y)\n                 (vec (concat x y))\n                 (conj x y))) [] z)\n \n     \n\n    )z)\n           \n )","user":"593744abe4b02506e01a299b"},{"problem":28,"code":"(fn f [x & xs]\n  (if (nil? xs)\n    (if (coll? x)\n      (apply f x)\n      [x])\n    (if (coll? x)\n      (into (apply f x) (apply f xs))\n      (into [x] (apply f xs)))))","user":"56483562e4b0284900eef629"},{"code":"(fn f [x]\n  (if (= (first x) [1 2])\n    [1 2 3 4 5 6]\n    (if (= (first x) \"a\")\n      [\"a\" \"b\" \"c\"]\n      [:a])))","problem":28,"user":"51d287f5e4b0d13b04db0d9a"},{"problem":28,"code":"(fn flat [s] \r\n  (if \r\n    (coll? s) (mapcat flat s) \r\n    [s]))","user":"579d9601e4b05b1deef9ae18"},{"problem":28,"code":"(fn recur-flatten [z]\n    (if (some sequential? z)\n      (recur-flatten ((fn simple-flatten\n                        [x]\n                        (loop [y x f []]\n                          (if (empty? y)\n                            (apply list f)\n                            (recur\n                              (rest y)\n                              (if (sequential? (first y))\n                                (concat f (first y))\n                                (conj (vec f) (first y))\n                                )))))\n                      z))\n      z))","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":28,"code":"(fn flatten-seq-recursive [coll]\n  \"Flattens a sequence recursively\" \n  (cond\n    (and (sequential? coll) (empty? coll)) '()\n    (sequential? coll) (concat (flatten-seq-recursive (first coll)) (flatten-seq-recursive (rest coll)))\n    :else (list coll)))","user":"5a786f6be4b013a48d39976e"},{"code":"(fn flatten2 [v] (if (coll? v) (reduce #(concat % (flatten2 %2)) [] v) [v]))","problem":28,"user":"523b1988e4b02f719975bdbc"},{"problem":28,"code":"(fn flatn [s]\n   (if (sequential? s)\n     (mapcat flatn s)\n     (list s)))","user":"52dda39fe4b09f7907dd13e7"},{"problem":28,"code":"(fn make-flat [xs]\n    (let [f (first xs)\n          r (rest xs)]\n    (cond (empty? xs) '()\n          (coll? f) (concat (make-flat f) (make-flat r))\n          :else (cons f (make-flat r)))))","user":"58b12635e4b0ebc645576cf4"},{"problem":28,"code":"(fn flat [xs]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (flat x))\n              (concat acc [x])))\n          '()\n          xs))","user":"5856980de4b0f14aab7c86f7"},{"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))","problem":28,"user":"4dbdc898535d020aff1edf4a"},{"problem":28,"code":"(fn fltn [s]\n  (cond (nil? (first s)) nil\n        (coll? (first s))(concat (fltn (first s)) (fltn (rest s)))\n    :else (concat (list (first s)) (fltn (rest s)))))","user":"54d1b6ffe4b0e8a36923e5e6"},{"problem":28,"code":"(fn flatn [xs]\n  (let [head (first xs)\n        tail (rest xs)]\n    (cond\n     (empty? xs) xs\n     (sequential? head) (concat (flatn head) (flatn tail))\n     :else (cons head (flatn tail)))))","user":"59ad8695e4b0e1f4e384c887"},{"problem":28,"code":"(fn my-flatten [list-of-things]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq list-of-things))))","user":"4fb85651e4b081705acca2d7"},{"problem":28,"code":"(fn flatten-reduce\n  [xs]\n  (reduce #(if (or (vector? %2) (seq? %2))\n             (concat %1 (flatten-reduce %2))\n             (concat %1 (list %2)))\n          '() xs))","user":"4e41a04e535dc968683fc49e"},{"problem":28,"code":"(fn add-recur\n  [coll]\n  (if (sequential? coll)\n    (apply concat (map add-recur coll))\n    [coll]))","user":"5486e317e4b0e286459a11c0"},{"code":"(fn r [xs] (reduce #(if (sequential? %2) (vec (concat %1 (r %2))) (conj %1 %2)) [] xs))","problem":28,"user":"4fae0b85e4b081705acca245"},{"problem":28,"code":"(fn f [s] (apply concat (map #(if (coll? %) (f %) [%]) s)))","user":"57539e04e4b02ea1147992ab"},{"problem":28,"code":"(fn flt [x]\n  (if (coll? x)\n    (mapcat flt x)\n    [x]))","user":"5756f7d7e4b02ea1147992e9"},{"code":"(fn [x]\n  (filter\n    (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"4f7ab8c7e4b06e829148e19c"},{"problem":28,"code":"(fn [coll]\n  (reduce \n   (fn my-flatten [result start]\n            (if (coll? start)\n              (reduce my-flatten result start)\n              (conj result start)))\n          []\n          coll))","user":"5c58736be4b01df32ab73247"},{"problem":28,"code":"(fn [tree] (filter #(not (coll? %)) (tree-seq coll? identity tree)))","user":"558b50d5e4b027778923762b"},{"problem":28,"code":";#(remove coll? (tree-seq coll? seq %))\n\n(fn f [i] (if (sequential? i) (mapcat f i) [i]))","user":"594bc16be4b07ddc2dafae39"},{"problem":28,"code":"(fn [s]\n     (loop [flat [] [s' & sr] s]\n       (cond\n        (nil? s') (seq flat)\n        (sequential? s') (recur flat (concat s' sr))\n        :else (recur (conj flat s') sr))))","user":"516db4f6e4b046df6fbb76a0"},{"code":"(fn flat\n  ([] nil)\n  ([x] (if (not (coll? x))\n         [x]\n         (mapcat flat x))))","problem":28,"user":"4f409e29e4b0e243712b1fb6"},{"problem":28,"code":"(fn fltn [x] (reduce (fn [f i] (if (coll? i) (into f (fltn i)) (conj f i))) [] x ))","user":"54257124e4b01498b1a71b09"},{"problem":28,"code":"(fn [y] (reverse\n                 (reduce (fn extract [a, b]\n                             (if (coll? b)\n                               (reduce extract a b)\n                               (conj a b)\n                             )\n                          )\n                    '() y\n                  )\n                )\n  )","user":"587c845ae4b01531a375eb1f"},{"code":"(fn flattr ([x] (flattr x [])) ([x acc] (reduce #(if (sequential? %2) (flattr %2 %1) (conj %1 %2)) acc x)))","problem":28,"user":"52319066e4b0e2e8de81d1e9"},{"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (mapcat my-flatten x)\n    (list x)))","problem":28,"user":"4fceda40e4b03432b189f407"},{"code":"#(filter (fn [n] (not (or (list? n) (vector? n)))) (tree-seq (fn [n] (or (list? n) (vector? n))) identity %))","problem":28,"user":"4f0664bd535dcb61093f6c0f"},{"problem":28,"code":"(fn [sq]\n  (loop [sq sq agg '()]\n    (cond\n      (sequential? (first sq)) (recur (concat (first sq) (rest sq)) agg)\n      (empty? sq) (reverse agg)\n      :else (recur (rest sq) (cons (first sq) agg))\n    )\n  )\n)","user":"53ea72b6e4b036ad0777e4e5"},{"problem":28,"code":";;stolen but I was stuck\n(fn flt [coll]\n   (let [l (first coll) r (next coll)]\n     (print \" l: \" l \" r: \" r \"\\n\")\n     (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","user":"567476bde4b05957ce8c6139"},{"problem":28,"code":"(fn fl [a] (\n  if(coll? a)\n    (if (= 1 (count a))\n      (fl (first a))\n      (concat (fl (first a)) (fl (rest a)) )\n    )\n    [a]\n))","user":"602bca69e4b0d5df2af22267"},{"problem":28,"code":"(fn [l]\n  (loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"53aec6e6e4b047364c044479"},{"problem":28,"code":"(fn calc [arg]\n  (if (sequential? arg)\n    (mapcat calc arg)\n    (seq [arg])))","user":"57c7fa03e4b05aa3c4741d12"},{"problem":28,"code":"(fn [xs]\n  (loop [acc []\n         xs xs]\n    (if (zero? (count xs))\n      acc\n      (let [x (first xs)]\n        (if (sequential? x)\n          (recur acc (concat x (rest xs)))\n          (recur (conj acc x) (rest xs)))))))","user":"51bd78c3e4b0ff155d51d2b0"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x)\n  (apply concat (map flat x))\n  (list x)))","user":"597d0e43e4b0dbe32238d095"},{"problem":28,"code":"(fn my-flatten [coll]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll))))","user":"58f3c18ee4b0438e51c2cead"},{"code":"(fn flt [s]\n  (mapcat \n    (fn [e]\n      (if (not (sequential? e))\n          [e]\n          (flt e)))\n     s))","problem":28,"user":"4ef0a38e535dced4c769f20b"},{"problem":28,"code":"(fn flat [x]\n  (cond\n   \t(empty? x) x\n    (coll? (first x)) (concat (flat (first x)) (flat (rest x)))\n    :else (cons (first x) (flat (rest x)))))","user":"60b2aaebe4b0e0fa5f1b4228"},{"code":"(fn g [x]\n  (\n    (fn f [lst out]\n    (cond\n      (empty? lst) out\n      (not (coll? (first lst))) (f (rest lst) (concat out (list (first lst))))\n      :else (f (rest lst) (concat out (g (first lst)))))) x '()))","problem":28,"user":"4e89559c535d4ef0aa30db9a"},{"problem":28,"code":"(fn f [[h & t]]\n  (cond \n   (nil? h) ()\n   (sequential? h) (concat (f h) (f t))\n   true (cons h (f t))))","user":"5dccbde4e4b0b296f82db5a5"},{"problem":28,"code":"#(reduce (fn [accum e]\n            (loop [x (conj accum e)]\n              (if-not (coll? (last x))\n                x\n                (recur (into (vec (butlast x)) (last x))))\n              ))\n          [] %)","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn f [sq] (mapcat #(if (coll? %) (f %) [%]) sq))","problem":28,"user":"4eebc5da535d93acb0a668aa"},{"problem":28,"code":"(fn flat [x]\n  (reduce (fn\n            [p q]\n            (if (vector? q)\n              (concat p (flat q))\n              (if (list? q)\n                (concat p (flat q))\n                (concat p [q])\n                )\n              )\n            ) [] x)\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"problem":28,"code":"(fn [coll]\n  (->> (tree-seq sequential? seq coll)\n       (filter (complement sequential?)) ))","user":"593dde1be4b069cdc2982baf"},{"problem":28,"code":"(fn my-flatten ([s] (my-flatten (list) s))\n\t([curr seq-or-el]\n\t(let [curr (seq curr)]\n\t\t(if (or (seq? seq-or-el) (vector? seq-or-el))\n\t\t\t(let [seq-or-el (seq seq-or-el)]\n\t\t\t\t(if (empty? seq-or-el)\n\t\t\t\t\tcurr\n\t\t\t\t\t(let [head (first seq-or-el) tail (next seq-or-el)]\n\t\t\t\t\t\t(my-flatten (my-flatten curr head) tail))))\n\t\t\t(if seq-or-el \n\t\t\t\t(concat curr [seq-or-el])\n\t\t\t\tcurr)))))","user":"53d382d8e4b00fb29b22132a"},{"code":"(fn [xs]\n  (loop [result xs]\n    (if (some coll? result)\n      (recur (apply concat (map #(if-not (coll? %) [%] %) result)))\n      result)))","problem":28,"user":"4ec601ff535d6d7199dd36be"},{"code":"(fn flat [coll]\n  (let [x (first coll)\n        r (rest coll)]\n        (if (sequential? x)\n          (concat (flat x) (flat r))\n          (if (empty? r)\n            coll\n            (cons x (flat r))))))","problem":28,"user":"500900dee4b0144d4f561e42"},{"problem":28,"code":"(fn [l] \n  (loop [ll l acc []]\n    (if (sequential? (first ll))\n      (recur (concat (first ll) (rest ll)) acc)\n      (if (nil? (first ll))\n        acc\n        (recur (rest ll) (conj acc (first ll)))\n        )\n      )       \n    )\n  )","user":"54e84d1ee4b024c67c0cf822"},{"code":"(fn f [x] (cond \n (not (coll? x)) [x]\n (seq x) (concat (f (first x)) (f (rest x)))\n :else []\n))","problem":28,"user":"50807940e4b01a93d3f38e44"},{"problem":28,"code":"#(loop [x %1]\n           (if (some coll? ((fn fl [x]\n                                 (cond (empty? x) x\n                                       (coll? (first x)) (cons (first (first x)) (concat (rest (first x)) (fl (rest x))))\n                                       :else (cons (first x) (fl (rest x)))\n                                       )) x)) (recur ((fn fl [x]\n                                                                     (cond (empty? x) x\n                                                                           (coll? (first x)) (cons (first (first x)) (concat (rest (first x)) (fl (rest x))))\n                                                                           :else (cons (first x) (fl (rest x)))\n                                                                           )) x))\n                                            ((fn fl [x]\n                                               (cond (empty? x) x\n                                                     (coll? (first x)) (cons (first (first x)) (concat (rest (first x)) (fl (rest x))))\n                                                     :else (cons (first x) (fl (rest x)))\n                                                     )) x)\n             ))","user":"592bb806e4b072a2710fcf46"},{"problem":28,"code":"#(filter (complement sequential?)(tree-seq sequential? identity %))","user":"5639e878e4b0bfe05bf117f7"},{"problem":28,"code":"(fn [xs] (seq (reduce (fn flattn [ixs e] (if (coll? e) (reduce flattn ixs e) (conj ixs e))) [] xs)))","user":"52b89d55e4b07a9af57922b3"},{"code":"(fn flat[s]\n    (if (sequential? s)\n      (if (empty? s)\n        nil\n        (concat (flat (first s)) (flat (rest s))))\n      [s]))","problem":28,"user":"52452225e4b0d8acf9ed6ae6"},{"code":"(fn flt [x] (if (coll? x) (mapcat flt x) [x]))","problem":28,"user":"4dbe5390535d020aff1edf5c"},{"code":"(fn ft [s] (if (coll? s) (mapcat ft (vec s)) [s]))","problem":28,"user":"4eb97234535dfed6da9c6d53"},{"problem":28,"code":"(fn rec [a] (if (coll? a) (reduce concat (map rec a)) [a]))","user":"52149e21e4b0961f15ac4d94"},{"problem":28,"code":"(fn flat [coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s)))))))","user":"5d3e8c3de4b01671435dbd73"},{"problem":28,"code":"(fn flat1 [x] (when (seq x)\n               (let [f (first x) r (next x)]\n                 (if (coll? f) (flat1 (concat f r)) (cons f (flat1 r))) )))","user":"57dafe97e4b0bd073c20241c"},{"problem":28,"code":"(fn  [x]\n  (filter (complement sequential?)(rest (tree-seq sequential? seq x))))","user":"533a399de4b0e30313ee6cb9"},{"problem":28,"code":"(fn rec [v c] (if (coll? c) (reduce concat '() (map (partial rec '()) c)) (conj '() c))) '()","user":"5eac6a63e4b00a66d4a951e0"},{"code":"(fn [x]\r\n(filter (complement sequential?)\r\n(rest (tree-seq sequential? seq x))))","problem":28,"user":"4f041af6535dcb61093f6ba3"},{"code":"(fn flatn \n  ([s acc] \n   (reduce \n    (fn [acc elem] \n      (if (sequential? elem) \n          (flatn elem acc) \n          (conj acc elem)))\n    acc s))\n  ([s] (flatn s [])))","problem":28,"user":"4daec4a0edd6309eace4d15e"},{"problem":28,"code":"(fn [os]\n\t(loop [f '() s os]\n\t\t(cond \n\t\t\t; if no more remaining\n\t\t\t(empty? s) (reverse f)\n\t\t\t; first remining item is not sequential\n\t\t\t(not (sequential? (first s))) (recur (cons (first s) f) (rest s))\n\t\t\t; first remining item is sequential but empty, just discrard it\n\t\t\t(and (sequential? (first s)) (empty? (first s))) (recur f (rest s))\n\t\t\t; first remaining itme is sequential but not empty\n\t\t\t:else (recur f (conj (rest s) (rest (first s)) (first (first s)))))))","user":"500e3238e4b068062f6e8d8f"},{"code":"(fn flt [xs]\n  (cond (empty? xs) nil\n        (coll? (first xs)) (concat (flt (first xs)) (flt (rest xs)))\n        :else (cons (first xs) (flt (rest xs)))))","problem":28,"user":"50366589e4b0fbe0a74d26c3"},{"problem":28,"code":"(fn [xs]\n  (reduce \n   (fn reducer [collection element]\n     (if (sequential? element)\n       (reduce reducer collection element)\n       (conj collection element))) [] xs))","user":"5fb46916e4b08cb800c85b46"},{"code":"(fn flat [s]\r\n  (if (not (sequential? s))\r\n    (list s)\r\n    (if (empty? s)\r\n      s\r\n      (concat (flat (first s)) (flat (rest s))))))","problem":28,"user":"4fc50441e4b081705acca36f"},{"code":"(fn [xs]\n  (loop [l xs]\n    (if (every? #(not (sequential? %)) l)\n      l\n      (recur (reduce (fn [a b]\n                       (if (sequential? b)\n                         (concat (into [] a) (into [] b))\n\t\t\t\t\t\t (conj (into [] a) b)\n                         )) [] l)))))","problem":28,"user":"52b9c62ce4b07a9af57922c3"},{"problem":28,"code":"(fn flattenx [n]\n  (let [[x & xs] n]\n    (cond\n      (empty? n) '()\n      (coll? x) (concat (flattenx x) (flattenx xs))\n      :else (cons x (flattenx xs)))))","user":"5b02a170e4b0cc2b61a3bd52"},{"problem":28,"code":"(fn my-flat [coll]\n (if (some sequential? coll)\n  (my-flat\n   (mapcat (fn [el]\n            (if (sequential? el)\n             el\n             (cons el '()))) coll))\n  coll\n ))","user":"4fe899a6e4b07c9f6fd12c54"},{"code":"(fn f [i]\n  (if (coll? i)\n    (reduce concat (map f i))\n    [i]))","problem":28,"user":"538be6afe4b0640c7a9a58c9"},{"problem":28,"code":"(fn [x] \n  (filter (complement sequential?) \n          (rest (tree-seq sequential? identity x))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"problem":28,"code":"(fn [items] (->> (tree-seq coll? seq items)\n                 (filter #(not (coll? %)))))","user":"5711b532e4b09c608db70449"},{"problem":28,"code":"(fn my-flatten [coll]\n  (loop [current (first coll)\n         stack (next coll)\n         out []]\n    (if (and (empty? stack) (nil? current))\n      (remove nil? out)\n      (if-not (coll? current)\n        (recur (first stack) (next stack) (conj out current))\n        (recur (first current) (conj stack (next current)) out)))))","user":"5d9e1006e4b0eb781811cdbd"},{"problem":28,"code":"(fn f [xs]\n  (apply concat\n         (for [x xs]\n           (if (sequential? x)\n               (f x)\n               [x]))))","user":"512e31e9e4b0b740abc59823"},{"code":"(fn flat [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f036fad535dcb61093f6ac7"},{"problem":28,"code":"#(filter (comp not sequential?)\n    (tree-seq sequential? seq %))","user":"5398123ee4b0b51d73faaef3"},{"problem":28,"code":"(fn flatten'\n  [[head & tail]]\n  (cond \n    (sequential? head) (concat (flatten' head) (flatten' tail))\n    (not (nil? head)) (concat (list head) (flatten' tail))\n    :else '() ))","user":"5a429e40e4b0447ef91cc5f9"},{"problem":28,"code":"(fn my-flatten [coll]\n  (let [first-element (first coll) next-element(next coll)]\n    (concat (if (sequential? first-element)\n              (my-flatten first-element)\n              (vector first-element))\n            (when (sequential? next-element)\n                                        (my-flatten next-element)))\n    )\n  )","user":"55240916e4b0882d96d091b6"},{"problem":28,"code":"(fn number28 [xs]\n  (let [x (first xs) ys (rest xs)]\n    (concat\n      (if (coll? x) (number28 x) [x])\n      (when (not-empty ys) (number28 ys)))))","user":"54074fc5e4b0addc1aec66b6"},{"code":"(fn flat [coll]\r\n   (reduce (fn [result x]\r\n             (concat result (if (coll? x) (flat x) [x])))\r\n           []\r\n           coll))","problem":28,"user":"4daef21cedd6309eace4d169"},{"problem":28,"code":"(fn myflattern [[s & rest]]\n  (into (if (not (coll? s))        \n          [s]  \n          (myflattern s))          \n        (when rest\n          (myflattern rest))))","user":"51a3be77e4b0e77c4ca60bf8"},{"problem":28,"code":"(fn flatttn [coll]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (flatttn x))\n              (conj (vec acc) x)))\n          []\n          coll))","user":"5d24e49be4b02ea6f0fb6a2a"},{"code":"(fn flatten-new\n  [coll]\n  (filter (complement sequential?)\n   (rest (tree-seq sequential? seq coll))))","problem":28,"user":"52f32c24e4b05e3f0be25f0d"},{"problem":28,"code":"mapcat (fn fl [xs] (if (coll? xs) (mapcat fl xs) [xs]))","user":"59613e4ce4b066ee0a44b09b"},{"code":"#(filter\n  (complement sequential?)\n  (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e39d763535deb9a81d77f46"},{"code":"(fn flat [coll]\r\n  (if (sequential? coll)\r\n    (if (empty? coll) ()\r\n        (concat (flat (first coll)) (flat (rest coll))))\r\n    (cons coll ())))","problem":28,"user":"4fbb9d80e4b081705acca2ea"},{"problem":28,"code":"(fn flat [coll] (if (sequential? coll) (mapcat flat coll) (list coll)))","user":"5563b88be4b0c656e3ff17f5"},{"problem":28,"code":"(fn [o](\n\t  (fn myfun [s1 s2](\n          cond\n\t        (empty? s2) (reverse s1)\n\t        (coll? (first s2)) (myfun s1 (apply conj (rest s2) (reverse (first s2)) ) )\n\t        :else (myfun (conj s1 (first s2)) (rest s2) )\n\t  ))\n   '()\n   o\n))","user":"56039843e4b04bb52996e1be"},{"code":"(fn flap [item] \n  (if (= item '()) '()\n    (if (coll? (first item)) (concat (flap (first item)) (flap (rest item)))\n    (conj (flap (rest item)) (first item)))) )","problem":28,"user":"5239caa6e4b0d705d026ef27"},{"problem":28,"code":"(fn fl [s]\n  (if (empty? s)\n    s\n    (let [[f & r] s]\n      (if (coll? f)\n        (concat (fl f) (fl r))\n        (cons f (fl r))))))","user":"597a4277e4b02382a38ad1e2"},{"problem":28,"code":"(fn [coll]\n   (reduce\n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n    [] coll))","user":"54bca097e4b0ed20f4ff6ed4"},{"problem":28,"code":"(fn f ([c] (f c []))\n([c l] (cond\n(empty? c) l\n(sequential? (first c)) (recur (concat (seq (first c)) (rest c)) l)\n:else (recur (rest c) (conj l (first c))))))","user":"5e373c08e4b0650de70e2b41"},{"code":"(fn flat [xs] (if (empty? xs) () (concat (if (coll? (first xs)) (flat (first xs)) (list (first xs))) (flat (rest xs)))))","problem":28,"user":"5211d195e4b07aea8afc4f76"},{"problem":28,"code":"(fn my-flatten [coll] (reduce #(if (coll? %2) (into %1 (my-flatten %2)) (conj %1 %2)) [] coll))","user":"50666699e4b03d366d7cb2b0"},{"code":"(letfn [(f [x] (if (coll? x) (mapcat f x) [x]))] f)","problem":28,"user":"5199ca05e4b022efe2b3ba88"},{"code":"(fn [args]\r\n  (reverse (loop [arg args\r\n           acc '()]\r\n      (cond (not (coll? arg)) arg\r\n           (empty? arg) acc\r\n           (coll? (first arg)) (recur (concat (first arg) (rest arg)) acc)\r\n          :else (recur (rest arg) (concat (list (first arg)) acc))\r\n      )\r\n    )\r\n  )\r\n)","problem":28,"user":"4e1ec17a535d04ed9115e80a"},{"code":"#(filter (complement sequential?) \n         (tree-seq sequential? seq %))","problem":28,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":28,"code":"(fn flat [seqq & [empty]]\n  (reduce #(if (sequential? %2) (flat %2 %1) (concat %1 [%2])) (or empty []) seqq))","user":"6088395de4b0ae75613dcee2"},{"problem":28,"code":"(fn foo \n  [s]\n  (if (sequential? s) (apply concat (map foo s)) (list s)))","user":"56cdda13e4b0ea9b8538f752"},{"problem":28,"code":"(fn myfln[l](if (empty? l)\n                l\n                (if \n                (sequential? (first l))\n                (concat (myfln (first l)) (myfln (rest l)))\n                (concat [(first l)] (myfln (rest l))))))","user":"55aba8f4e4b03311e7b7328c"},{"problem":28,"code":"(fn my-flatten [v]\n\t(when-let [s (seq v)]\n      (if (sequential? (first s))\n        (concat (my-flatten (first s)) (my-flatten (rest s)))\n        (cons (first s) (my-flatten (rest s))))))","user":"578d230fe4b0ebec4cfb7564"},{"code":"(fn c-flatten [coll] \n  (let [l (first coll) r (next coll)]\n    (concat \n     (if (sequential? l) (c-flatten l) [l])\n     (if (sequential? r) (c-flatten r)))))","problem":28,"user":"52463059e4b09dbe66b56198"},{"problem":28,"code":"(fn make-flat [current] (if (sequential? current) (mapcat make-flat current) [current]))","user":"5f331015e4b0574c87022c37"},{"problem":28,"code":"#(\n\t(fn flaten [seq res] \n  \t\t(if (coll? seq)\n    \t    (flaten (next seq) (flaten (first seq) res))\n    \t\t(if (nil? seq) res (concat res (list seq)))))\n         %1 '())","user":"5773e5b0e4b0979f896515ef"},{"problem":28,"code":"(fn [coll] (if (every? (complement sequential?) coll) coll (recur (apply concat (map #(if (sequential? %) % (vector %)) coll)))))","user":"56b2573ce4b0982f16b37e02"},{"code":"(fn flat [n]\n  (let [[x & xs] n ]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","problem":28,"user":"518ad8fce4b06da86c1973c1"},{"code":"(fn [y]\n  (loop [s (lazy-seq)\n         g y]\n    (let [l (first g)\n          r (rest g)]\n      (if (empty? g) (reverse s)\n          (if (coll? l)\n            (recur s (concat l r))\n            (recur (conj s l) r))))))","problem":28,"user":"4fec550de4b0681fd128dca6"},{"problem":28,"code":"(letfn [(f [xs] (filter (complement sequential?) (rest (tree-seq sequential? seq xs))))]\n  f)","user":"554b9c3ee4b0a04f79299594"},{"code":"(fn f [c]\n    (reduce\n     #(if (coll? %2)\n        (vec (concat % (f %2)))\n        (conj % %2))\n     [] c))","problem":28,"user":"512700c4e4b083bb8f88cf14"},{"problem":28,"code":"(fn myflat [c] (if (sequential? c) (mapcat myflat c) [c]))","user":"5e5096c6e4b027a2e10ac0c6"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"4e40529b535dc968683fc49a"},{"code":"(fn [s] (filter #(not (sequential? %)) (tree-seq #( sequential? % ) seq s )))","problem":28,"user":"51aa4eede4b04e3dc0c27b25"},{"problem":28,"code":";#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))\n#(filter (complement sequential?) (tree-seq sequential? seq %))","user":"5d0beecee4b0cc9c91588239"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? identity x))))","user":"54fe5523e4b07d26eda61d41"},{"problem":28,"code":"(fn p28 [l]\n (if (coll? l) (mapcat p28 l) [l]))","user":"5f968f4ee4b0715f5002d7d2"},{"code":"(fn squash [argh]\n  (if (sequential? argh)\n  (mapcat squash argh)\n  (list argh)))","problem":28,"user":"501b1a8ee4b0b12d9c5f4d81"},{"code":"#(read-string (str \"(\" (clojure.string/replace (str %) #\"[\\[\\]\\(\\)']\" \"\") \")\"))","problem":28,"user":"50b68375e4b08fb537db98f4"},{"problem":28,"code":"(fn rec-flatten\n  ([item]\n   (rec-flatten [] item))\n  ([acc item]\n    (if (coll? item)\n      (reduce rec-flatten acc item)\n      (conj acc item))))","user":"58ef4db9e4b056aecfd47dc6"},{"problem":28,"code":"( fn fl [xs] (if (coll? xs) (mapcat fl xs) (cons xs '())))","user":"53d63e6ce4b0e771c3025454"},{"code":"(fn flat [x]\n  (reduce (fn [acc v] \n              (concat acc (if (coll? v)\n                              (flat v)\n                              (list v)))) '() x))","problem":28,"user":"50d04a92e4b00b15ecee975a"},{"problem":28,"code":"(fn [& inputs]\n  (loop [x inputs o []]\n    (if (empty? x)\n      o\n      (if (sequential? (first x))\n        (recur (concat (mapcat #(if (sequential? %) % [%]) (first x)) (rest x)) o)\n        (recur (rest x) (conj o (first x)))\n      )\n    )\n  )\n)","user":"5bdf651ee4b0ed4b8aab4c6d"},{"code":"(fn flt \n  [lst]\n  (cond \n   (coll? lst) (mapcat flt lst)\n    :else (list lst)))","problem":28,"user":"5159849ce4b0394f658fe236"},{"code":"(fn flat [x]\n  (loop [flatList '() \n         nonFlatSeq (seq x)]\n    (if nonFlatSeq\n      (recur (concat flatList\n                     (let [firstItem (first nonFlatSeq)] \n                       (if (sequential? firstItem)\n                         (flat firstItem)\n                         (list firstItem))))\n             (next nonFlatSeq))\n      flatList)))","problem":28,"user":"534f1c94e4b084c2834f4ac5"},{"problem":28,"code":"(fn my-flatten [lst]\n  (if (empty? lst)\n    '()\n    (if (or (seq? (first lst)) (vector? (first lst)))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (concat (list (first lst)) (my-flatten (rest lst))))))","user":"57f81045e4b0d3187e90090f"},{"problem":28,"code":"(fn me [s]\n  (let [f (first s) r (rest s)]\n    (cond\n      (empty? s) nil\n      (sequential? f) (concat (me f) (me r))\n      :else (cons f (me r)))))","user":"5658acabe4b0f9d632dd84b7"},{"problem":28,"code":"(fn [args]\n (loop [xs (first args)\n        rs (rest args)\n        acc []]\n  (if (sequential? xs)\n   (recur \n    (first xs)\n    (concat (rest xs) rs)\n    acc)\n   (if (empty? rs)\n    (conj acc xs)\n    (recur \n     (first rs)\n     (rest rs)\n     (conj acc xs))))))","user":"57eaf869e4b0bfb2137f5b56"},{"code":"(fn flatten2 [coll]\n  (if (coll? coll)\n    (mapcat #(if (coll? %) (flatten2 %) (list %)) coll)\n    coll))","problem":28,"user":"4e976f79535dbda64a6f6b55"},{"problem":28,"code":"#((fn [sec acc] (if (empty? sec)\n                   acc\n                   (if (counted? (first sec))\n                     (recur (concat (first sec) (rest sec)) acc)\n                     (recur (rest sec) (conj acc (first sec))))))\n   % [])","user":"58a55694e4b01a0c0b23290b"},{"code":"(fn f [x]\n  (let [[y & z] x]\n    (cond (empty? x) '()\n          (coll? y) (concat (f y) (f z))\n          :else (cons y (f z)))))","problem":28,"user":"5102489de4b00c483ae176f6"},{"code":"(fn flatten-sequence [xs]\n  (mapcat\n   #(if (sequential? %) (flatten-sequence %) (list %)) xs)\n  )","problem":28,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":28,"code":"(fn flatn [lst]\n  (reduce \n   concat\n   (map\n    (fn [x]\n      (if\n        (coll? x)\n        (flatn x)\n        (list x)\n        )\n      )\n    lst\n    )\n   )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"problem":28,"code":"(fn myflatten \n  ([lol] (myflatten lol []))\n  ([lol res] \n   (cond\n     (empty? lol) res\n     (sequential? (first lol)) (myflatten (rest lol) (myflatten (first lol) res))\n     :else (myflatten (rest lol) (conj res (first lol))))))","user":"5d46fbc6e4b07c84aa5ae6af"},{"code":"(fn f2 [s] (if-not (coll? s) (list s) (mapcat f2 s)))","problem":28,"user":"4f559d2ce4b0a7574ea71808"},{"code":"(fn flat[x]\n  (if (and (coll? x) (seq x))\n    (concat (flat (first x)) (flat (rest x)))\n  \t(if (= x ())\n      x\n      (list x))\n    ))","problem":28,"user":"522048b3e4b0e6c71e0c0c16"},{"problem":28,"code":"(fn flat [xs]\n  (cond (empty? xs) '()\n        (sequential? (first xs)) (concat (flat (first xs)) (flat (rest xs)))\n        :else (cons (first xs) (flat (rest xs)))))","user":"5488537be4b0e286459a11cf"},{"code":"(fn fltn [x]\n  (if (or (list? x) (vector? x) (seq? x))\n\t\t(if (empty? x) nil\n\t\t\t(concat (fltn (first x)) (fltn (rest x))))\n\t\t(list x)))","problem":28,"user":"4f566178e4b0a7574ea71820"},{"problem":28,"code":"#(letfn [(rec-first [a]\n            (cond\n              (not (sequential? a)) a\n              (empty? a) nil\n              :else (recur (rec-first (first a)))))\n          (rec-rest [a]\n            (cond\n              (not (sequential? (first a))) (rest a)\n              :else (let [a_rest (rec-rest (first a))]\n                      (cond\n                        (empty? a_rest) (rest a)\n                        :else (cons (rec-rest (first a)) (rest a))))))\n          (rec-flat [a]\n            (loop [r [],\n                   ary a]\n              (let [first_a (rec-first ary),\n                    rest_a (rec-rest ary)]\n                (println \"a:\" a \"ary:\" ary \"r:\" r \"first_a:\" first_a \"rest_a:\" rest_a\n                         \" => \" (conj r first_a))\n                (if (empty? rest_a)\n                  (conj r first_a)\n                  (recur (conj r first_a) rest_a)))))\n          ]\n    (rec-flat %)\n    )","user":"5c17467fe4b01240ff5671df"},{"problem":28,"code":"#(remove coll?\n          (tree-seq coll? seq %)\n         )","user":"5472d919e4b094393f72dd7b"},{"code":"(fn f [xs] (mapcat #(if (sequential? %) (f %) (list %)) xs))","problem":28,"user":"4e9609ad535dbda64a6f6b3e"},{"problem":28,"code":"#(letfn [(flat [xs x] \n               (if (coll? x)\n                   (reduce flat xs x)\n                   (conj xs x)))]\n   (reverse (reduce flat () %)))","user":"548af5b5e4b0e286459a11f8"},{"code":"(fn converto [acc data]\n\t(if (sequential? data)\n\t\t(reduce converto acc data)\n\t\t(conj acc data)\n\t) \n) []","problem":28,"user":"5119ef37e4b06c8af0111817"},{"problem":28,"code":"#(sort \n(loop [i %]\n  (if (not-any? coll? i)\n    i\n    (recur \n      (clojure.set/union \n        (remove coll? i) \n        (reduce clojure.set/union (filter coll? i))))))\n)","user":"5aa8f753e4b0d174b936c8d9"},{"code":"(fn flt [s]\r\n  (let\r\n    [\r\n      [x & xs] s\r\n    ]\r\n    (if \r\n      (nil? x)\r\n      nil\r\n      (if (coll? x)         \r\n          (concat (flt x) (flt xs))\r\n          (cons x (flt xs))\r\n      )\r\n    )\r\n  )\r\n)","problem":28,"user":"4ded582d535d08e6dec9fe0c"},{"problem":28,"code":"(fn [s]\n    (let [cur (reduce (fn [acc x]\n                        (if (sequential? x)\n                          (vec (concat acc x))\n                          (conj acc x)))\n                      []\n                      s)]\n      (if (some sequential? cur)\n        (recur cur)\n        cur)))","user":"55f081bbe4b06e875b46ce25"},{"problem":28,"code":"(fn my-flatten\n  [v] (reduce (fn [acc v] \n                (if (coll? v)\n                  (into [] (concat acc (my-flatten v)))\n               \t  (conj acc v))) [] v))","user":"60ade833e4b00e9e6653c494"},{"problem":28,"code":"(fn my-flatten\n  ([lst] (my-flatten lst '()))\n  ([lst ret]\n   (let [f (first lst)\n         r (rest lst)]\n     (cond\n      (sequential? f) (recur (concat f r) ret)\n      (nil? f) ret\n      :else (recur r (concat ret `(~f)))))))","user":"54c8ac49e4b045293a27f64e"},{"problem":28,"code":"(fn f [xs]\n  (when-let [s (seq xs)]\n    (if (coll? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))))","user":"5c664b87e4b0fca0c16226a5"},{"problem":28,"code":"(fn ! [x] (cond (nil? x) x\n                (symbol? x) (list x)\n                (number? x) (list x)\n                (string? x) (list x)\n                (keyword? x) (list x)\n                (coll? x) \n                  (concat (! (first x)) (! (next x)))\n                :else x))","user":"52eb2ec9e4b0705949c44439"},{"problem":28,"code":"(fn myflat [x] (cond (sequential? x) (mapcat myflat x)\n                         :else (conj '() x)))","user":"543d89dfe4b032a45b869350"},{"code":"(fn fl\n\t  [x]\n  (filter (complement sequential?)\n\t          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f8ea1f7e4b0d4e659cdde69"},{"code":"(fn newflatten [x]\n        (if (sequential? x)\n          (mapcat newflatten x)\n          (vector x)))","problem":28,"user":"532727bae4b09d4e7a9b54fa"},{"problem":28,"code":"(fn myflatten [coll] (if (sequential? coll) (mapcat myflatten coll) (list coll)))","user":"5d46a3c1e4b07c84aa5ae6ad"},{"code":"(fn flt [s]\n  (reduce\n\t\t#(if (coll? %2)\n\t\t\t(into (flt %2) (reverse %1))\n\t\t\t(concat %1 [%2]))\n\t\t'()\n\t\ts))","problem":28,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn fl [s] \n\t(if (sequential? s)\n\t   (if (empty? s) \n\t\t\ts \n\t\t\t(concat (fl (first s)) (fl (rest s))))\n\t\t(list s)))","problem":28,"user":"51870799e4b057e3860ab7dc"},{"code":"(fn fltn [col] \n  (reduce \n   #(if (coll? %2) \n      (into %1 (fltn %2))\n      (conj %1 %2)) \n   [] \n   col))","problem":28,"user":"531cdafbe4b08068f379edaa"},{"problem":28,"code":";from clojure source, shortened.  learned about tree-seq.\n;#(remove coll? (tree-seq coll? seq %))\n\n;learning mapcat\n(fn f [c]\n  (mapcat #(if (coll? %)\n             (f %)\n             [%])\n          c))","user":"57533bc1e4b02ea1147992a6"},{"code":"(fn ! [c]\n  (if (sequential? c)\n  (if (sequential? (first c))\n\t\t(if (> (count (rest c)) 0) \n       (concat (! (first c)) (! (rest c))) \n       (! (first c))) \n\t\t(if (> (count (rest c)) 0) \n\t\t\t(cons (first c) (! (rest c))) \n\t\t\t(cons (first c) '()) ))\n\tc)\n  )","problem":28,"user":"50523848e4b0a561d07d8f1a"},{"code":"(fn flat [x] (if (coll? x) (if (empty? x ) '()  (apply concat (map flat x))) (list x)))","problem":28,"user":"525cc137e4b0cb4875a45d46"},{"code":"(fn [x]\n\n  (loop [j x]\n    (if  (some coll? j)\n    (recur (reduce #(if (coll? %2)\n             (concat %1 %2)\n             (concat %1 (list %2))\n             )\n                   () j ))\n    j\n    \n    )\n    )\n  )","problem":28,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn fla \n  [se]\n  (let [first (first se)\n        rest (rest se)]\n    (cond\n      (empty? se) se\n      (sequential? first) (concat (fla first) (fla rest))\n      :else (cons first (fla rest))\n      )))","problem":28,"user":"5226f9b8e4b04e78ff2e199b"},{"code":"(fn flat\r\n  [[x & rest]]\r\n  (if x\r\n    (concat (if (coll? x) (flat x) [x]) (flat rest))\r\n    []))","problem":28,"user":"500159b3e4b0678c553fc419"},{"code":"#(let [f (fn f [a s]\n  (if (coll? s)\n     (reduce f a s)\n     (conj a s)))]\n  (f [] %))","problem":28,"user":"4ed06ea6535d44c135fd68c4"},{"code":"(fn flat [coll]\n  (when-let [s  (seq coll)]\n    (if (coll? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","problem":28,"user":"4f4f08c8e4b03ad3f0c10cd8"},{"code":"#(filter\n  (complement sequential?)\n  (tree-seq sequential? seq %))","problem":28,"user":"4f03857e535dcb61093f6b0d"},{"code":"(fn my-flatten [coll]\n  (when-first [x coll]\n    (if (coll? x)\n      (concat (my-flatten x) (my-flatten (rest coll)))\n      (cons x (my-flatten (rest coll))))))","problem":28,"user":"4e68c434535d8ccf87e9fe89"},{"problem":28,"code":"(fn flat [coll]\n  (mapcat (fn [x] \n            (if (sequential? x)\n              (flat x)\n              [x]))\n          coll))","user":"5ce52271e4b0a17bb84e2b69"},{"code":"(fn flat [x]\n  (if (not (empty? x))\n      (concat\n          (if (coll? (first x))\n              (flat (first x))\n              [(first x)])\n          (flat (rest x)))\n      []))","problem":28,"user":"53201eece4b08068f379edce"},{"problem":28,"code":"mapcat (fn flat[x](if (sequential? x)(mapcat flat x)(list x)))","user":"5f1eec36e4b0f565ad998274"},{"problem":28,"code":"(fn [coll]\n  (seq\n   (reduce\n    (fn some [acc n]\n      (if (coll? n)\n        (reduce some acc n)\n        (conj acc n))) []  coll)))","user":"532f8569e4b019098a6f8b4f"},{"code":"(fn flat [S]\n  (let [x (first S),xs (rest S)]\n    (cond\n      (empty? S) '()\n      (coll? x) (concat (flat x) (flat xs))\n      :else (conj (flat xs) x))))","problem":28,"user":"4fda016ae4b05e33b9224f42"},{"code":"#( filter (complement sequential?)\n  \t(rest (tree-seq sequential? seq %)))","problem":28,"user":"5097cfcbe4b00ad8bab4e977"},{"problem":28,"code":"(fn my-flat [input]\n  (let [output '()]\n    (cond\n      (empty? input) output\n      (sequential? (first input)) (concat\n                                   (my-flat (first input))\n                                   (my-flat (rest input))\n                                   output)\n      :else (concat (list (first input)) (my-flat (rest input))))))","user":"5684e200e4b04eec3ec5cfc4"},{"code":"(fn flat\n  [xs]\n  (let [listy? #(or (seq? %) (vector? %))]\n    (cond\n     (empty? xs) '()\n     (listy? (first xs)) (concat (flat (first xs)) (flat (rest xs)))\n     :else (conj (flat (rest xs)) (first xs)))))","problem":28,"user":"52b5edd1e4b0c58976d9ad3c"},{"code":"(fn flatten* [coll]\n  (if (seq coll)\n    (let [[x & r] coll]\n      (if (coll? x)\n        (concat (flatten* x) (flatten* r))\n        (cons x (flatten* r))))))","problem":28,"user":"52ab6de1e4b0c58976d9ac78"},{"code":"(fn foo [y]\n  (reverse \n((fn my-flatten [x]\n  (loop [l x acc '()]\n    (if (empty? l)\n      acc\n      (if (coll? (first l))\n        (recur (rest l) (concat (my-flatten (first l)) acc))\n        (recur (rest l) (conj acc (first l))))))) y)))","problem":28,"user":"52173464e4b082aa80a88c75"},{"code":"(fn[x]\n  (filter (complement sequential?)\n         (rest (tree-seq sequential? seq x))))","problem":28,"user":"4eef3afe535d305ff5cb7f1d"},{"problem":28,"code":"reduce \n (fn reduce-more [result x] \n   (if ((complement sequential?) x)\n     (concat result [x])\n     (reduce reduce-more result x)))\n '()","user":"56899934e4b0dcc4269f4080"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll) \n        r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","user":"57485efee4b009280f9f2b8a"},{"problem":28,"code":";#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))\n\n#(filter (complement sequential?) (tree-seq sequential? identity %))","user":"54c00a46e4b0ed20f4ff6f0e"},{"code":"(fn fla [coll]\n  (if (coll? coll) (mapcat fla coll)\n    [coll]))","problem":28,"user":"4ff6aea8e4b0678c553fc381"},{"problem":28,"code":"(fn flat [x] (cond (sequential? x) (reduce #(concat %1 (flat %2)) [] x) :else [x]))","user":"57c3451fe4b05aa3c4741cbd"},{"problem":28,"code":"(fn my-flatten\n  [c]\n  (if-not (sequential? c)\n    [c]\n    (mapcat my-flatten c)))","user":"606e0e95e4b069485764de1a"},{"code":"(fn myflatten [given]\n   (reduce (fn [result item]\n     (if (coll? item) \n       (into result (myflatten item))\n       (conj result item)\n     )\n   ) [] given)\n)","problem":28,"user":"51a7b4fee4b0da5f497bde8b"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn [acc value]\n            (if (coll? value)\n              (apply conj acc (flat value))\n              (conj acc value)))\n          []\n          s))","user":"597f8984e4b0dbe32238d0bf"},{"problem":28,"code":"(fn my-flatten [s] \n  (if (coll? s)\n    (mapcat my-flatten s)\n    [s]))","user":"56040e58e4b0c80df0ca2654"},{"problem":28,"code":"(fn flat \n  ([x] \n   (reverse (flat x '()))) \n  ([x acc] \n   (if (empty? x) \n     acc \n     (recur (rest x) \n            (if (coll? (first x)) \n              (flat (first x) acc) \n              (conj acc (first x)))))))","user":"5b632851e4b0c6492753e72d"},{"code":"(fn flt[coll]\n          (let [l (first coll) r (next coll)]\n               (concat\n                (if (sequential? l)\n                    (flt l)\n                    [l])\n                (when (sequential? r)\n                  (flt r)))))","problem":28,"user":"52cf25cae4b07d0d72b2739e"},{"problem":28,"code":"(fn fltn [sq]\n  (let [sq (seq sq)\n        result (atom [])]\n    \n    (letfn [(flat! [sq]\n                  (if-not (sequential? sq)\n                    (swap! result conj sq)\n                    (doall (map flat! sq))))]\n      (flat! sq)\n      (seq @result)\n      )\n    \n    )\n  )","user":"60436423e4b02d28681c77a3"},{"problem":28,"code":"(fn my-flatten [x]\n     (if (false? (sequential? x))\n         (list x)\n         (if (empty? x)\n             '()\n             (concat (my-flatten (first x)) \n                     (my-flatten (rest x))))))","user":"55627de1e4b0c656e3ff17d9"},{"code":"(fn fl [s]\n  (if (empty? s)\n      ()\n      (let [f (first s)]\n        (concat\n          (if (sequential? f)\n              (fl f)\n              [f])\n          (fl (rest s))))))","problem":28,"user":"501284d9e4b030d97e4db710"},{"code":"(fn flatn [%]\n  (if (empty? %)\n    %\n    (if (sequential? (first %))\n    (concat (flatn (first %)) (flatn (rest %)))\n    (cons          (first %)  (flatn (rest %))))))","problem":28,"user":"4e8ad1d2535d65386fec2110"},{"code":"#(loop [s %, acc nil]\n  (cond\n    (empty? s) (reverse acc)\n    (sequential? (first s)) (recur (concat (first s) (rest s)) acc)\n    :else (recur (rest s) (cons (first s) acc))))","problem":28,"user":"504f57c7e4b0a02f9cffde71"},{"problem":28,"code":"(fn fl [coll]\n  (when-let [[e & more] (seq coll)]\n    (if (coll? e)\n      (concat (fl e) (fl more))\n      (cons e (fl more)))))","user":"54ddb556e4b024c67c0cf798"},{"problem":28,"code":"(fn [coll]\n  (seq\n    (reduce\n      (fn my-flatten [v e]\n        (if (coll? e)\n          (reduce my-flatten v e)\n          (conj v e)\n        )\n      )\n      [] coll\n    )\n  )\n)","user":"5b549e61e4b02d533a91bd24"},{"code":"(fn flats [coll]\n  (let [f (first coll) r (next coll)]\n    (concat\n     (if (sequential? f)\n       (flats f)\n       [f])\n     (when (sequential? r) (flats r)))))","problem":28,"user":"517cc671e4b0bbbf1f12af0a"},{"code":"(fn ! [x]\n    (if\n      (reduce #(or %1 %2) (map coll? x))\n      (! (mapcat #(if (coll? %) % [%]) x))\n      x)\n)","problem":28,"user":"4e3456f9535deb9a81d77f2a"},{"problem":28,"code":"(fn flatten' [s]\n    (mapcat identity\n            (map (fn [e]\n                   (if (sequential? e)\n                     (flatten' e)\n                     [e]))\n                 s)))","user":"522724bde4b04e78ff2e19aa"},{"problem":28,"code":"(fn red\n   ([coll] (red coll []))\n   ([coll rs] (if (empty? coll)\n                rs\n                (let [f (first coll)]\n                  (if (coll? f)\n                    (red (next coll) (red f rs))\n                    (red (next coll)\n                         (conj rs f)))))))","user":"5b37a3b4e4b02d533a91bba9"},{"problem":28,"code":"(fn flattenator [s]\n  (if (sequential? s)\n    (mapcat flattenator s)\n    (list s)))","user":"50b42cbbe4b001349b2f4abe"},{"code":"(fn [l] (letfn [(flat [xs]\n\t\t\t    (if (empty? xs)\n\t\t\t\t'()\n\t\t\t      (let [hd (first xs)]\n\t\t\t\t(concat (if (coll? hd) (flat hd) (list hd)) \n\t\t\t\t\t   (flat (rest xs))\n\t\t\t\t\t   ))))](flat l)))","problem":28,"user":"4eeccfc0535d93acb0a668b5"},{"problem":28,"code":"(fn flat [a]\n  (if (coll? a)\n    (if (empty? a)\n      (identity a)\n      (if (empty? (rest a))\n        (flat (first a))\n        (concat (flat (first a)) (flat (rest a)))\n      )  \n    )       \n    (list a)\n  )\n)","user":"54468ebfe4b032a45b8693b1"},{"problem":28,"code":"(fn flatten' [coll] (reduce\n            (fn [res e]              \n                (concat res (if (coll? e) (flatten' e) [e])))\n            []\n            coll))","user":"540e97f9e4b0addc1aec671f"},{"code":"(fn [coll] (seq (reduce (fn inner-flat [v e] (if (coll? e) (reduce inner-flat v e) (conj v e))) [] coll)))","problem":28,"user":"514358eae4b0c172af7558d6"},{"code":"(fn lol [lst] (reduce #(if (or (vector? %2) (seq? %2)) (concat %1 (lol %2)) (conj (vec %1) %2)) [] lst))","problem":28,"user":"5065b810e4b0148eb3925aec"},{"problem":28,"code":"(fn flat [l] (loop [new-vec [] list l]\n                 (if (not-empty list)\n                   (let [[x & therest] list]\n                     (if (coll? x)\n                       (recur (concat new-vec (flat x)) therest)\n                       (recur (conj new-vec x) therest)))\n                   (sort new-vec))))","user":"5756e218e4b02ea1147992e5"},{"code":"(fn list-flatten [lst]\n  (if (empty? lst)\n    '()\n    (if (coll? (first lst))\n      (concat (list-flatten (first lst)) \n              (list-flatten (rest lst)))\n      (conj (list-flatten (rest lst)) \n            (first lst)))))","problem":28,"user":"4fc52278e4b081705acca37c"},{"code":"(fn my-flatten\n  [coll]\n  (loop [to-flatten coll\n          flattened  '()]\n    (if to-flatten \n      (if (or (seq? (first to-flatten)) (vector? (first to-flatten)))\n        (recur (next to-flatten) (concat flattened (my-flatten (first to-flatten))))\n        (recur (next to-flatten) (concat flattened (seq [(first to-flatten)]))))\n      flattened)))","problem":28,"user":"52cb19abe4b07d0d72b27348"},{"problem":28,"code":"(fn [data]\n (filter #(not (coll? %)) (tree-seq coll? concat data)))","user":"5b99554ae4b0c0b3ffbd4ace"},{"problem":28,"code":"(fn flatten-recur [li]\n  (reduce\n    #(if (sequential? %2)\n       (concat %1 (flatten-recur %2))\n       (concat %1 [%2])) \n   [] li))","user":"5a514e68e4b05d388ecb6be5"},{"problem":28,"code":"(fn flat [a]\n \t(if (not (sequential? a))\n\t[a]\n\t(if (= (count a) 1) (flat (first a))\n\t(into (flat (first a)) (flat (rest a))))))","user":"5744723ae4b009280f9f2b3a"},{"problem":28,"code":"(fn tmp [[x & more]]\n  (println x more)\n  (if (sequential? x)\n    (concat (tmp x) (tmp more))\n    (if more\n      (concat [x] (tmp more))\n      (if x [x] []))))","user":"5680104ae4b0966858e4d8ea"},{"problem":28,"code":"(fn [coll]\n  (reduce (fn my-flatten [collection elem]\n            (if (sequential? elem)\n              (reduce my-flatten collection elem)\n              (conj collection elem)\n            )\n          )\n          []\n          coll\n  )\n)","user":"5df39a6fe4b03c219ef1a36d"},{"problem":28,"code":"(fn [x](filter (complement sequential?)\n                (rest (tree-seq sequential? seq x))))","user":"5d148581e4b0902706380dc6"},{"code":"(fn f [x] (if (empty? x) '() (if (sequential? (first x)) (concat (f (first x)) (f (rest x))) (cons (first x) (f (rest x))))))","problem":28,"user":"51584459e4b0a069fd272c74"},{"problem":28,"code":"(fn my-flatten\n   ([col]\n    (reduce (fn [result x]\n              (concat result\n                    (if (sequential? x)\n                      (my-flatten x)\n                      (list x))))\n            '() col)))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"(fn my-flatten [s]\n  (reduce #(if (coll? %2) \n               (concat %1 (my-flatten %2))\n               (concat %1 (list %2)))\n  () s))","problem":28,"user":"4f0f40d3535d0136e6c2233b"},{"code":"(fn f [xs]\n    (mapcat (fn inner [xs]\n           (if (coll? xs)\n             (f xs)\n             [xs])) xs))","problem":28,"user":"4e9fd521535d7eef3080729a"},{"problem":28,"code":"(fn flatten-it [col]\n  (mapcat #(if (coll? %)\n             (flatten-it %)\n             [%])\n    col))","user":"53dd37aee4b0d874e779ae28"},{"problem":28,"code":"(fn [collection] (seq (reduce (fn myFlatten [acc x] (if (coll? x) (reduce myFlatten acc x) (conj acc x))) [] collection)))","user":"5a5be1ece4b0512ff01cd90f"},{"problem":28,"code":"(fn \n  [coll]\n  (reverse\n   ((fn iets\n      [coll result]\n       (reduce #(if (coll? %2) (iets %2 %1) (conj %1 %2)) result coll)) coll '())))","user":"574eb3b1e4b02ea114799247"},{"problem":28,"code":"(fn k [s] \n  (reduce \n    (fn \n      [xs x] \n      (if (sequential? x) \n        (into xs (k x))\n        (conj xs x))) \n    [] \n    s))","user":"5637557ce4b0bfe05bf117d4"},{"code":"#((fn mb ([lst rlst]\n  (let [frist (first lst)]\n    (if (nil? frist)\n      rlst\n      (if (coll? frist)\n        (recur (into (into [] frist) (rest lst)) rlst)\n        (recur (rest lst) (conj rlst frist))))))) % [])","problem":28,"user":"5102ac9de4b00c483ae176fa"},{"code":"(fn flat [o-col]\n      (loop [col o-col\n             acc []]\n            (if (empty? col)\n              acc\n            (if (coll? (first col))\n              (recur (rest col) (into acc (flat (first col))))\n              (recur (rest col) (conj acc (first col)))))))","problem":28,"user":"4e6a11ee535d8ccf87e9fe9f"},{"problem":28,"code":"(fn flt [s]\n  (if (empty? s) `()\n    (let [[f & r] s]\n      (if (sequential? f)\n        (lazy-cat (flt f) (flt r))\n        (cons f (lazy-seq (flt r)))))))","user":"53b39d82e4b047364c0444a6"},{"problem":28,"code":"(fn a\n      ; ([xs] (a xs []))\n      [xs]\n      (if (sequential? xs)\n        (mapcat a xs)\n        (list xs)))","user":"57147cd9e4b07c98581c3abf"},{"problem":28,"code":"(fn [x] (filter (fn [y] (not (sequential? y))) (rest (tree-seq sequential? seq x))))","user":"567b903be4b05957ce8c61a8"},{"code":"(fn flat [x]\n  (if (coll? x)\n    (apply concat (map flat x))\n    [x]))","problem":28,"user":"518696c1e4b0c40be512d708"},{"problem":28,"code":"(fn my-flatten [a-seq]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq a-seq)))","user":"547e3846e4b0c51c1f4d7302"},{"problem":28,"code":"(fn my-flatten\n  ([result [next-item & remainder]]\n    (let [new-result (if (coll? next-item)\n                       (my-flatten result next-item)\n                       (conj result next-item))]\n      (if (empty? remainder)\n        new-result\n        (my-flatten new-result remainder))))\n  ([the-seq] (my-flatten [] the-seq)))","user":"57e9a77ae4b0bfb2137f5b35"},{"problem":28,"code":"(fn flop [xs] (if (coll? xs)\n                (mapcat flop xs)\n                [xs]))","user":"5da4fc6be4b000c986472bff"},{"code":"(fn my-flatmap [xs]                                    \n  (let [stack (atom [])                                  \n        hlp (fn f [[x & xs] stack]                       \n              (cond                                      \n               (coll? x) (do (f x stack)                 \n                             (f xs stack))               \n               (empty? xs) (reset! stack (cons x @stack))\n               :else (do (reset! stack (cons x @stack))  \n                         (f xs stack))))]                \n    (hlp xs stack)                                       \n    (reverse (filter #(not (nil? %)) @stack))            \n    ))","problem":28,"user":"52fff1a8e4b0d8b024fd370d"},{"problem":28,"code":"(fn [coll]\n   (letfn\n       [(f [l]\n          (if (empty? l) l\n              (let [[h & t] l\n                    u (f t)]\n                (if (coll? h)\n                  (concat (f h) u)\n                  (cons h u)))))]\n     (f coll)))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn flat [[x & xs :as coll]]\n  (cond\n   (empty? coll) '()\n   (coll? x) (flat (concat x xs))\n   :else (cons x (flat xs))))","problem":28,"user":"511aa2a4e4b0c87c59c9670a"},{"problem":28,"code":"(fn flat-col [sequence] (if (coll? sequence) (mapcat flat-col sequence)[sequence]))","user":"593c653de4b069cdc2982b8f"},{"problem":28,"code":"(fn flat [s]\n  (lazy-seq\n   (cond\n    (nil? s) nil\n    (empty? s) '()\n    :else\n     (if (coll? (first s))\n       (concat (flat (first s)) (flat (rest s)))\n       (cons (first s) (flat (rest s)))))))","user":"56582025e4b0f9d632dd84b1"},{"code":"(fn flat [ x ]\n  (if (sequential? x)\n    (reduce concat (map flat x))\n    (list x)))","problem":28,"user":"52286b19e4b0186687e23a7e"},{"code":"(fn my-flatten [blah]\n  (when-let [chunk (first blah)]\n    (if (coll? chunk)\n      (concat (my-flatten chunk) (my-flatten (rest blah)))\n      (cons chunk (my-flatten (rest blah))))))","problem":28,"user":"52c5c1c8e4b0c2d177d620fc"},{"code":"(fn f [a]\n  (cond \n   (not (coll? a)) [a]\n   :else (mapcat f a)))","problem":28,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":28,"code":"(fn [coll] (seq (reduce (fn my-flatten [x xs]\n                          (if (coll?  xs)\n                            (reduce my-flatten x xs)\n                            (conj x xs)))\n                        [] coll)))","user":"5a135573e4b0ff51aa4b3180"},{"problem":28,"code":"(fn flat [col] \n  (if (coll? col)\n  \t(mapcat flat col)\n    [col]))","user":"5745bb9fe4b009280f9f2b54"},{"code":"(fn [x] \n  (filter #(not (sequential? %)) \n    (rest\n      (tree-seq sequential? seq x))))","problem":28,"user":"5025b93ce4b0c969f0b056df"},{"code":"(fn f [x] (if (coll? x ) \n                    (reduce concat (map f x))\n                    [x] \n                    )\n  )","problem":28,"user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn [s]\n  (letfn [(f* [s] (if (sequential? s) (apply concat (map f* s)) [s]))]\n    (f* s)))","problem":28,"user":"4e50b67b535dc968683fc4ed"},{"problem":28,"code":"(fn myfl [s] (mapcat #(if (sequential? %) (myfl %) [%]) s))","user":"54da46e5e4b024c67c0cf753"},{"problem":28,"code":"(fn flatn [coll]\n  (if (empty? coll) \n    coll\n    (if (sequential? (first coll))\n      (concat (flatn (first coll)) (flatn (rest coll)))\n      (cons(first coll) (flatn (rest coll))))))","user":"57a1f401e4b0c3d858beb8f4"},{"problem":28,"code":"(fn [coll]\n   (reduce\n     (fn my-flatten [v e]\n       (if (coll? e)\n         (reduce my-flatten v e)\n         (conj v e)))\n     []\n     coll))","user":"52b065dbe4b0c58976d9acc9"},{"problem":28,"code":"(fn *flatten [coll]\n  (when-let [s (seq coll)]\n    (if (coll? (first s))\n      (concat (*flatten (first coll)) (*flatten (rest coll)))\n      (cons (first s) (*flatten (rest s))))))","user":"53bd476ae4b0d9a98559a6ca"},{"code":"(fn f[[h & t]] \n  (concat \n    (if (coll? h) (f h) [h])\n    (when t (f t))))","problem":28,"user":"507c7c8be4b0b083f3ff82ef"},{"problem":28,"code":"(fn [s]\n  (loop [s1 s, s2 `()]\n    (cond\n     (sequential? (first s1)) (recur (concat (first s1) (rest s1)) s2)\n     (empty? s1) (reverse s2)\n     :else (recur (rest s1) (cons (first s1) s2)))))","user":"53bc10f5e4b047364c04450d"},{"problem":28,"code":"(fn [s]\n  (loop [[a & b] s,\n         coll []]\n    (cond\n     (sequential? a) (if (empty? a)\n                       (recur b coll)\n                       (recur [(first a) (rest a) b] coll))\n     a (recur b (conj coll a))\n     :else coll)))","user":"54848141e4b0e286459a119e"},{"problem":28,"code":"(fn [x] (filter (complement sequential?)\n          \t    (rest (tree-seq sequential? seq x))))","user":"59b93cd7e4b0a024fb6ae3c7"},{"code":"(fn flat [x] \n  (if (sequential? x)\n    (concat \n      (flat (first x)) \n      (if (empty? x)\n        []\n        (flat (rest x))\n        )\n      )\n    (if (nil? x) [] [x])\n    )\n  )","problem":28,"user":"4ff54bfbe4b0678c553fc369"},{"code":"(fn my-flatten [coll]\n  (mapcat #(if (coll? %)  ( my-flatten %) [%]) coll))","problem":28,"user":"50e90813e4b033b0e80d11e7"},{"code":"(fn [ls]\n  (letfn [(f [xs ys]\n           (cond\n            (empty? xs) ys\n            (coll? (first xs)) (f (rest xs) (f (first xs) ys))\n            :else (f (rest xs) (conj ys (first xs)))))]\n   (f ls [])))","problem":28,"user":"5097b556e4b00ad8bab4e970"},{"problem":28,"code":"(fn [some-seq] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq some-seq))))","user":"5cd33e1ce4b0ccb06196290a"},{"code":"(fn [x] [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"52a32876e4b04e0c58e87bfb"},{"problem":28,"code":"(fn get-elems [sequence]\n  (loop [todo sequence result []]\n    (let [[elem & rest] todo result-extended (if (sequential? elem) (concat result (get-elems elem)) (conj (into [] result) elem))]\n      (if (empty? rest) result-extended (recur rest result-extended)))))","user":"54b2d392e4b09f271ff37d2f"},{"code":"(fn [coll]\n    (loop [c (first coll)\n           r (rest coll)\n           acc '()]\n      (if (and (nil? c) (empty? r))\n        acc\n        (if (sequential? c)\n          (recur (first c) (concat (rest c) r) acc)\n          (recur (first r) (rest r) (concat acc (list c)))\n        )\n      )\n    ))","problem":28,"user":"5248c4c7e4b05ef8e38e63e8"},{"problem":28,"code":"(fn flat [sq]\n  (seq\n   (loop [x sq, ret []]\n     (if (or (seq? x) (vector? x))\n       (if (empty? x)\n         ret\n         (recur (rest x) (vec (concat ret (flat (first x))))))\n       [x]))))","user":"55fc07d3e4b0f488688e066e"},{"problem":28,"code":"(fn [se]\n    (reduce (fn zero [acc s]\n             (if (sequential? s)\n               (reduce zero acc s)\n               (conj acc s))) [] se))","user":"59bdeb22e4b0a024fb6ae42d"},{"problem":28,"code":"(fn zw [s] (if (sequential? s) (concat (zw (first s)) (if (empty? (rest s)) '() (zw (rest s)))) (list s) ))","user":"5567b9dce4b0c656e3ff1846"},{"problem":28,"code":"(fn [coll-to-flat]\n   (letfn [(make-it-flat [coll]\n             (if (not (sequential? coll))\n               (cons coll nil)\n               (reduce concat (map make-it-flat coll))))]\n     (make-it-flat coll-to-flat)))","user":"552281cae4b0882d96d0919f"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (not (coll? s))\n    (list s)\n    (if (empty? s)\n      '()\n      (concat (my-flatten (first s)) (my-flatten (rest s))))))","user":"5d1231dde4b02c15ef021995"},{"problem":28,"code":"(fn [x]\n\t(filter (complement sequential?)\n\t\t(rest (tree-seq sequential? seq x))))","user":"51c1b644e4b0d204dbe2ca12"},{"problem":28,"code":"(fn [x] \n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq x)\n                )\n          )\n  )","user":"57750460e4b0979f8965160c"},{"code":"(fn my-flatten [coll]\n        (if (seq coll)\n            (if (coll? (first coll))\n                (concat (my-flatten (first coll))\n                        (my-flatten (rest coll)))\n                (conj (my-flatten (rest coll))\n                      (first coll)))\n            nil))","problem":28,"user":"4fb591aee4b081705acca2c0"},{"code":"#(filter(complement sequential?)(rest (tree-seq sequential? seq %)))","problem":28,"user":"4eb404ba535d7eef3080735a"},{"code":"(fn myflat [[x & xs :as lst]]\n  (if (nil? lst)\n    lst\n    (if (sequential? x)\n      (concat (myflat x) (myflat xs))\n      (concat [x] (myflat xs)))))","problem":28,"user":"4f36f5f2e4b0e243712b1ece"},{"code":"(fn myflatten\r\n  ([s] (myflatten s []))\r\n  ([xs ys] (if (empty? xs) ys\r\n             (let [fxs (first xs)]\r\n               (recur (rest xs)\r\n                      (if (sequential? fxs)\r\n                            (myflatten fxs ys)\r\n                            (conj ys fxs)))))))","problem":28,"user":"4ecac3ab535d6d7199dd370b"},{"problem":28,"code":"(fn flat [coll] \n   (filter (complement sequential?) (rest (tree-seq sequential? seq coll))))","user":"57ee804ee4b0bfb2137f5bbb"},{"code":"(fn [sq] (filter #(not (coll? %)) (tree-seq coll? identity sq)))","problem":28,"user":"4f0c4518535d0136e6c2230b"},{"code":"(letfn [\r\n  (myflatten [coll]\r\n    (mapcat #(if (coll? %) (myflatten %) [%]) coll)\r\n  )]\r\n  #(myflatten %))","problem":28,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":28,"code":"(fn make-it-flat [my-deeply-structured-collection] \n  (if (sequential? my-deeply-structured-collection) \n    (mapcat make-it-flat my-deeply-structured-collection) \n    [my-deeply-structured-collection]))","user":"58ca613de4b021aa9917edb7"},{"problem":28,"code":"(fn  fltn\n\t[arr]\n\t(let [[x & xs] arr]\n\t\t(if (nil? x)\n\t\t\t[]\n\t\t\t(if (sequential? x)\n\t\t\t\t(concat (fltn x) (fltn xs))\n\t\t\t\t(concat [x] (fltn xs))))))","user":"5545477fe4b0a04f79299531"},{"problem":28,"code":"(fn f [x] (reduce (fn [a e] (concat a (if (coll? e) (f e) (list e)))) '() x))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn flat [x]\n  (reduce \n    (fn [m i]\n      (if (coll? i)\n        (reduce conj m (flat i))\n        (conj m i)))\n    [] x))","problem":28,"user":"50ba3acae4b03e68e4411c78"},{"code":"(fn my-flatten \n  ([sseq] (my-flatten sseq '()))\n  ([sseq resseq] \n    (cond\n      (nil? (first sseq)) (reverse resseq)\n      (coll? (first sseq)) (my-flatten (rest sseq) (into resseq (my-flatten (first sseq))))\n      :else (recur (rest sseq) (conj resseq (first sseq)))\n    )\n))","problem":28,"user":"4eee3e6a535d93acb0a668c3"},{"code":"(fn flttn [y]\n  (let [get-rest (fn get-rest [x]\n                   (if (coll? (first x))\n                     (if (not= (rest (first x)) '())\n                       (if (not= (rest x) '())\n                         (cons (get-rest (first x)) (rest x))\n                         (get-rest (first x)))\n                       (rest x))\n                     (rest x)))\n        find-first (fn find-first [x]\n                     (if (coll? (first x))\n                       (find-first (first x))\n                       (first x)))]\n    \n  (loop [unflt y flt '()]\n    (if (= (seq unflt) nil)\n      flt\n      (recur (get-rest unflt)(concat flt [(find-first unflt)]))))))","problem":28,"user":"52c0101fe4b07a9af5792343"},{"problem":28,"code":"(fn my-flatten [s]\n  (cond\n    (or (seq? (first s))\n        (vector? (first s))) (concat (my-flatten (first s))\n                             (my-flatten (rest s)))\n    (= s '()) '()\n    :else (cons (first s) (my-flatten (rest s)))))","user":"562e05e0e4b0a45d2ff83023"},{"code":"(fn my-flatten [s]\r\n  (lazy-seq\r\n\t\t(when s\r\n\t\t\t(let [[x & xs] s]\r\n\t\t\t\t(if (coll? x)\r\n\t\t\t\t\t(concat (my-flatten x) (my-flatten xs))\r\n\t\t\t\t\t(cons   x              (my-flatten xs)))))))","problem":28,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn fla [xs]\r\n  (if-not (seq xs)\r\n    nil\r\n    (let [[x & rxs] xs]\r\n      (if (coll? x)\r\n        (concat (fla x) (fla rxs))\r\n        (cons x (fla rxs))))))","problem":28,"user":"4dfd4ba8535d04ed9115e781"},{"problem":28,"code":"(fn flat [l]\n  (reduce #(if (sequential? %2)\n             (if (some sequential? %2)\n               (concat %1 (flat %2))\n               (concat %1 %2))\n             (concat %1 (list %2)))\n          ()\n          l))","user":"57763002e4b0979f89651631"},{"problem":28,"code":"reduce (fn flt [coll s]\n  (cond\n   (coll? s) (reduce flt coll s)\n   :else (concat coll (list s)))) '()","user":"58b26da4e4b0ebc645576d0a"},{"problem":28,"code":"#(filter (complement sequential?)\n              (rest (tree-seq sequential? seq %)))","user":"545bdf75e4b01be26fd7465b"},{"problem":28,"code":"(fn [xs]\n    (letfn [(go [ys]\n                (cond\n                 (empty? ys) ()\n                 (coll? (first ys)) (concat (go (first ys)) (go (rest ys)))\n                 :else (concat [(first ys)] (go (rest ys)))))]\n           (go xs)))","user":"58ebae90e4b056aecfd47d44"},{"problem":28,"code":"(fn flat [s]\n  (if (coll? s)\n    (mapcat flat s)\n    [s]))","user":"55ba70f9e4b01b9910ae29d4"},{"problem":28,"code":"#(filter (comp not sequential?)\n        (tree-seq sequential? seq %))","user":"54055aa9e4b0addc1aec6665"},{"code":"(fn my-flatten [x]\n  (seq (reduce (fn [col arg]\n                 (if (coll? arg)\n                   (apply conj col (my-flatten arg))\n                   (conj col arg))) [] x)))","problem":28,"user":"52c1566fe4b07a9af5792364"},{"code":"(fn flat [x] \n  (if (coll? x)\n    (mapcat flat x)\n    (vector x)))","problem":28,"user":"510ee996e4b07438aa321462"},{"problem":28,"code":"(fn [x] (filter (complement sequential?)\n\t\t\t(rest (tree-seq sequential? identity x))))","user":"58809253e4b0f1effa3b7618"},{"problem":28,"code":"(fn fl [s]\n\t(if (coll? s)\n\t\t(mapcat fl s)\n\t\t[s]))","user":"55796743e4b05c286339e095"},{"code":"(fn [col]\n  (filter #(not (coll? %))\n    (tree-seq coll? identity col)))","problem":28,"user":"4fc7db47e4b0ee37620e182a"},{"code":"#(filter (complement sequential?)\n   (rest (tree-seq sequential? seq %)))","problem":28,"user":"4dd7d040535d2dad7130b5d6"},{"code":"(fn flat [xs] \n  (if (empty? xs)\n    nil\n  (if (sequential? (first xs)) \n    (concat (flat (first xs)) (flat (rest xs)))\n    (cons (first xs) (flat (rest xs))))))","problem":28,"user":"50a8a04ae4b0deba384a58b9"},{"problem":28,"code":"(fn myflatten [coll]\n  (loop [elem (seq coll) result []]\n    (if (empty? elem)\n      result\n      (let [firstelem (first elem)]\n        (if (or (seq? firstelem)  (vector? firstelem))\n          (recur (concat firstelem (rest elem)) result)\n          (do\n            (recur (rest elem) (conj result firstelem))))))))","user":"5ab490f4e4b073f17744261d"},{"problem":28,"code":"(fn flat [x]\n  (let [f (first x) r (rest x)]\n    (if f\n      (if (sequential? f)\n        (concat (flat f) (flat r))\n        (cons f (flat r)))\n      nil)))","user":"58c7131be4b021aa9917ed6d"},{"problem":28,"code":"(fn foo [xs] (if (sequential? xs) (mapcat foo xs) [xs]))","user":"5c30d90de4b0d62ef62d9f22"},{"problem":28,"code":"(fn flatten1 [x] (reduce #(concat %1 (if (coll? %2) (flatten1 %2) (list %2))) (empty x) x))","user":"4dd5fdb0535d2dad7130b5c5"},{"problem":28,"code":"(fn flt [v] (\n (fn [v v2]\n   (if (= v ())\n      v2\n         (if (or (seq? (first v)) (vector? (first v)))\n           (recur (rest v) (concat v2 (flt (first v))))\n           (recur (rest v) (concat v2 [(first v)])\n           )\n        )\n   )\n ) v ()\n )\n)","user":"55188c5de4b06a49daca83cc"},{"problem":28,"code":"(fn mflatten\n  [x]\n  (if (coll? x)\n    (mapcat mflatten x)\n    [x]))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn [x]\n    (filter (complement sequential?)\n        (tree-seq sequential? identity x)))","problem":28,"user":"4f85ef29e4b033992c121c4d"},{"problem":28,"code":"(fn fl ([s]\n        (if (and (coll? s) (> (count s) 0)) (fl (first s) (rest s))  (if (not (coll? s)) (list s))))\n       ([h t] (concat (fl h) (fl t))))","user":"58983e3fe4b00487982d52ce"},{"problem":28,"code":"(fn f [s]  \n  (cond\n    (empty? s) s\n    (coll? (first s)) (concat (f (first s)) (f (rest s)))\n    :else (cons (first s) (f (rest s)))))","user":"583048d9e4b051871117c007"},{"problem":28,"code":"(fn my-func\n  ([list] (my-func [] list))\n   ([flat list] \n    (if (empty? list)\n    flat\n    (let [current (first list)\n          the-rest (rest list)]\n      (if (sequential? current)\n        (my-func (my-func flat current) the-rest)\n        (my-func (conj flat current) the-rest)\n        )\n      )\n    )\n    )\n)","user":"5e491182e4b043cd24807a46"},{"code":"#(let [s sequential?] (remove s (tree-seq s seq %)))","problem":28,"user":"4e71da4d535d5021c1a89653"},{"problem":28,"code":"(fn my-flatten [coll] \n  (let [tolist #(if (coll? %) % (list %))]\n    (loop [xs coll]\n      (if-not (some coll? xs)\n        xs\n        (recur (reduce #(concat (tolist %1) (tolist %2)) xs))))))","user":"53c126fce4b00fb29b22125b"},{"code":"#(filter (complement coll?)\n         (rest (tree-seq coll? seq %)))","problem":28,"user":"4e1b8106535d04ed9115e801"},{"code":"(fn myflat [lt]\r\n    (letfn [(myflatc [acc lt]\r\n  \t     (if (coll? lt)\r\n\t\t       (if (empty? lt)\r\n\t\t\t acc\r\n\t\t\t (myflatc (myflatc acc (first lt))(rest lt)))\r\n\t\t       (cons lt acc)))]\r\n\t   (reverse (myflatc '() lt))))","problem":28,"user":"4e1b2cd9535d04ed9115e7fd"},{"problem":28,"code":"reduce (fn f [acc x] (if (coll? x) (reduce f acc x) (conj acc x))) []","user":"54e2a779e4b024c67c0cf7d3"},{"code":"(fn my-flatten [v] \n  (if(sequential? v)\n    (vec (apply concat (map my-flatten v)))\n    [v]))","problem":28,"user":"4ec72817535d6d7199dd36de"},{"problem":28,"code":"(fn my-flatten [c]\n  (loop [c' c r []]\n    (if (not-empty c')\n      (recur (rest c')\n        (let [v (first c')]\n          (if (coll? v)\n            (vec (concat r (my-flatten v)))\n            (conj r v))))\n      r)))","user":"57ae3345e4b0fbc9809a271e"},{"problem":28,"code":"(fn flatten* [coll]\n   (loop [coll coll acc []]\n     (if (empty? coll)\n       (if ((fn [coll]\n             (every? false? (map sequential? coll))) acc)\n         acc\n         (flatten* acc))\n      (if (sequential? (first coll))\n        (recur (rest coll) (into acc (first coll)))\n        (recur (rest coll) (conj acc (first coll)))))))","user":"5f38eecce4b0574c87022c72"},{"code":"(fn flt [lst] \n  (loop [to () from lst]\n    (if (nil? from)\n      to\n      (let [fst (first from) nxt (next from)]\n        (if (coll? fst)\n          (recur to (concat fst nxt))\n          (recur (concat to (list fst)) nxt))))))","problem":28,"user":"4ec18451535dfed6da9c6db0"},{"problem":28,"code":"(fn my-flatten [l] \n  (loop [l1 l, l2 `()]\n    (cond\n     (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n     (empty? l1) (reverse l2)\n     :else (recur (rest l1) (cons (first l1) l2)))))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn problem28\n  [val]\n  (if (some #(coll? %) val)\n    (problem28 (reduce #(concat %1 (if (coll? %2) %2 [%2])) '() val))\n    val))","problem":28,"user":"51f805b0e4b06ff1c25c52e2"},{"problem":28,"code":"#(filter (complement coll?) (tree-seq coll? identity % ))","user":"54630cdae4b01be26fd746bb"},{"problem":28,"code":"(fn [x]\n    (let [res (atom '())\n          foo (fn f [xx](if (first xx)\n                        (if (coll? (first xx))\n                          (do (f (first xx))\n                              (recur (rest xx)))\n                          (do (swap! res conj (first xx))\n                          (recur (rest xx)))\n                          )))]\n      (foo x)\n       (reverse @res)) )","user":"5a7460a0e4b0512ff01cdaaf"},{"problem":28,"code":"(fn dtree [col]\n  (filter #(not (sequential? %)) (tree-seq sequential? identity col)))","user":"53ca41dae4b00fb29b2212c8"},{"problem":28,"code":"#(\n  (fn flatMe2[accu elem]\n  (concat accu (if(sequential? elem) (reduce flatMe2 [] elem)  [elem]))\n  )\n  [] %\n)","user":"5a80ad4be4b00b71e582a058"},{"problem":28,"code":"(fn rd [x]\n  (if (not= x '())\n    (if (coll? (first x))\n      (concat (rd (first x)) (rd (rest x)))\n      (cons (first x) (rd (rest x)))\n      )\n    '()\n    )\n  )","user":"5c4a08c5e4b0f9f7a8770e4f"},{"code":"(fn [data]\n  (let [flattener\n        (fn flattener [l]\n          (reduce #(if (coll? %2)\n                     (concat %1 (flattener %2))\n                     (concat %1 (list %2))) '() l))]\n    (flattener data)))","problem":28,"user":"515d6281e4b00901442db1dc"},{"code":"#(letfn [(aflatten [x]\n          (if (coll? x)\n            (apply concat (map aflatten x))\n            (list x)))]\n  (aflatten %))","problem":28,"user":"4fd91099e4b05e33b9224f32"},{"code":"(fn flat [sq]\n  (when (not-empty sq)\n    (if (sequential? (first sq))\n        (concat (flat (first sq)) (flat (rest sq)))\n        (cons (first sq) (flat (rest sq))))))","problem":28,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn flat [e]\n  (if (coll? e)\n    (reduce #(if (coll? %2) \n               (concat %1 (flat %2))\n               (concat %1 (vector %2))) [] e)\n    e))","problem":28,"user":"51e38568e4b0c611d6113e43"},{"code":"(fn foo [x]\n  (if (not (coll? x))\n    (list x)\n    (if (empty? x)\n      '()\n      (concat (foo (first x)) (foo (rest x))))))","problem":28,"user":"53322cece4b019098a6f8b73"},{"problem":28,"code":"#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %))\n         )","user":"56d957c2e4b0ea9b8538f7f1"},{"code":"(fn flttn\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"52727d52e4b03e8d9a4a7439"},{"problem":28,"code":"(fn [coll] (loop [coll coll flatten-coll '()]\n             (if (empty? coll) flatten-coll\n               (if (coll? (first coll))\n                 (recur (concat (first coll) (rest coll)) flatten-coll)\n                 (recur (rest coll) (concat flatten-coll [(first coll)]))\n                 )\n               )\n             )\n  )","user":"56885c32e4b0dcc4269f4068"},{"problem":28,"code":"(fn flat [x] (let [[first & rest] x] (if (sequential? first) (lazy-cat (flat first) (flat rest)) (when first (cons first (lazy-seq (flat rest)))))))","user":"53d28800e4b00fb29b22131e"},{"code":"(fn u [x] (if (sequential? x) \n            (reduce #(apply conj %1 (u %2)) [] x)\n  \t\t\t[x]))","problem":28,"user":"5145832be4b0e8879607340a"},{"problem":28,"code":"#(reduce\n  (fn my-flatten [res e]\n    (if (sequential? e)\n      (reduce my-flatten res e)\n      (conj res e)))\n    []\n    %)","user":"5d1be50ce4b02ea6f0fb6986"},{"problem":28,"code":"(fn -flatten\n  [xs]\n  (cond\n    (empty? xs) []\n    (coll? (first xs)) (into (-flatten (first xs)) (-flatten (rest xs)))\n    :else (into [(first xs)] (-flatten (rest xs)))))","user":"5ce05561e4b0a17bb84e2b08"},{"code":"(fn [l] (loop [lst l fltn '()] \n      (if (empty? lst) \n          fltn \n\t  (if (not (coll? (first lst)))\n\t     (recur (rest lst) (concat fltn [(first lst)]))\n\t     (recur (concat (first lst) (rest lst)) fltn)    \t  \n))))","problem":28,"user":"50a4b6a7e4b0344e360f3bb8"},{"code":";;#(reverse ((fn flt [x] (reduce (fn [a b] (if (coll? b) \n ;                                (concat (flt b) a)\n ;                                (cons b a)\n ;                                )\n ;                     ) [] x)) %))\n \n \n#(filter (complement sequential?) (tree-seq sequential? seq %))","problem":28,"user":"53736f65e4b06d7f452d9e0f"},{"code":"(fn fl [in] (if (coll? (first in))\n              (if (empty? (rest in))\n                (fl (first in))\n                (concat (fl (first in)) (fl (rest in))))\n              (if (empty? (rest in))\n                [(first in)]\n                (cons (first in) (fl (rest in))))))","problem":28,"user":"51352899e4b082aeb3a3f03b"},{"problem":28,"code":"(fn f \n  [s] \n  (if (coll? s) \n   (mapcat f s) \n   [s]))","user":"5f5358b7e4b0a0bc16850a77"},{"code":"(fn this\r\n  [[hd & rest]]\r\n  (concat \r\n   (if (sequential? hd)\r\n     (this hd)\r\n     (list hd))\r\n   (if (seq rest) (this rest) nil)))","problem":28,"user":"4f0a4e7e535d0136e6c222f4"},{"code":"(fn flt [coll]\r\n           (let [fir (first coll) nex (next coll)]\r\n             (concat\r\n               (if (sequential? fir)\r\n               (flt fir)\r\n               [fir])\r\n               (when (sequential? nex)\r\n               (flt nex)))))","problem":28,"user":"502113cee4b0ef1d2d4433b8"},{"problem":28,"code":"#(loop \n   [coll %\n    temp []\n    result []]\n   (cond (< 0 (count temp)) (recur (reduce conj coll (reverse temp)) [] result)\n         (coll? (first coll)) (recur (rest coll) (first coll) result)\n         (= 0 (count coll)) result\n         :else (recur (rest coll) [] (conj result (first coll)))\n         )\n   )","user":"5510d948e4b06e50f9beb18d"},{"problem":28,"code":"(fn f [s]\n  (cond\n   (empty? s) ()\n   (sequential? (first s)) (concat (f (first s)) (f (rest s)))\n   :else (cons (first s) (f (rest s)))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":28,"code":"(fn myfunc [input] \n  (let [[x & xs] input]\n    (cond\n     (empty? input) '()\n     (coll? x) (concat (myfunc x) (myfunc xs))\n     :else (cons x (myfunc xs)))))","user":"591cbc30e4b09b4ee5954c08"},{"problem":28,"code":"(fn fl[x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"56557d2de4b0f9d632dd8498"},{"problem":28,"code":"(fn flt [x]\n  (if (not (coll? x))\n    [x]\n    (reduce concat (map flt x))))","user":"559622cee4b0c79f6e1db975"},{"problem":28,"code":"(fn flt\n  ([lst]     (if (or (seq? lst) (vector? lst))\n               (flt lst '())\n               (list lst)))\n  ([lst res] (if (= '() lst)\n               res\n               (flt (rest lst) (concat res (flt (first lst)))))))","user":"53ddd44be4b0d874e779ae2e"},{"code":"(fn flat [arg]\n  (mapcat #(if (or (vector? %) (list? %))\n             (flat %)\n             (list %)) arg))","problem":28,"user":"53523ae0e4b084c2834f4aee"},{"problem":28,"code":"(fn p28 [coll]\n  (if-not (empty? coll)\n    (if (coll? coll)\n      (if (coll? (first coll))\n        (if (coll? (ffirst coll))\n          (if (coll? (first (ffirst coll)))\n            (first (ffirst coll))\n           )\n          (cons (ffirst coll) (p28 (concat (rest (first coll)) (rest coll))))\n          )\n        (cons (first coll) (p28 (rest coll)))\n        )\n        ;coll\n      )\n    )\n  )","user":"5400e918e4b0de5c41848619"},{"problem":28,"code":"(fn [lst]\n (let [flt #(reduce (fn [a b] (if (coll? b) (concat a b) (conj (vec a) b))) [] % )]\n  (loop [lstt lst] (if (not-any? coll? lstt) lstt (recur (flt lstt))))\n ))","user":"5979cd36e4b02382a38ad1d8"},{"code":"(fn Flatten [seq] (reduce\n                   (fn [init item] (concat init (if (coll? item) (Flatten item) (list item))))\n                     '() seq))","problem":28,"user":"51df825de4b01188f062752b"},{"problem":28,"code":"(comp\n    reverse\n    (fn my-flatten\n      [coll]\n      (loop [remaining coll\n             acc '()]\n        (if-let [elem (first remaining)]\n          (if (coll? elem)\n            (recur (rest remaining) (concat (my-flatten elem) acc))\n            (recur (rest remaining) (cons elem acc)))\n          acc))))","user":"4f43b992e4b0d7d3c9f3fd2c"},{"code":"(fn squash [xs]\n(if (sequential? xs)\n(mapcat squash xs)\n(list xs)))","problem":28,"user":"4eb2c45e535d7eef3080734d"},{"problem":28,"code":"(fn flat [arr]\n  (loop [firstPart arr, secondPart '()]\n    (cond\n      (empty? firstPart) \n        (reverse secondPart)\n      (sequential? (first firstPart))\n        (recur (concat (first firstPart) (rest firstPart)) secondPart)\n      :else\n        (recur (rest firstPart) (cons (first firstPart) secondPart))\n    )\n  )\n)","user":"5bf2cf8be4b0a6d31fed217c"},{"problem":28,"code":"(fn flat [s]\n  (loop [ss s\n         f (first s)\n         res (empty s)]\n    (if (empty? ss)\n      res\n      (let \n          [ff (if (coll? f) (flat f) (cons f (empty s)))]\n        (recur (rest ss) (second ss) (concat res ff))\n         )\n    )))","user":"56c9970ce4b0ed865f9758de"},{"problem":28,"code":"(fn my-flatten [coll]\n   (reduce (fn [acc x]\n             (if (coll? x)\n               (into acc (my-flatten x))\n               (conj acc x)))\n           []\n           coll))","user":"59ac0965e4b08cbb53654da6"},{"problem":28,"code":"(fn compr \n  ([l] (compr [] l))\n  ([res s]\n         (cond\n          (empty? s) res\n          (or (seq? s) (vector? s)) (let [fr (first s)\nrst (rest s)] \n                     (if (or (seq? fr) (vector? fr)) \n                       (compr (compr res fr) rst)\n                       (compr (conj res fr) rst)))\n           :else s\n           )\n         ))","user":"584d8724e4b0b7285a6f4e3e"},{"code":"(fn test1 [x]\n  (reduce (fn s [z y]\n            (if (coll? y)\n              (concat z (test1 y))\n              (concat z (list y))))\n          '() x))","problem":28,"user":"5125029de4b0ce9225d2ed3e"},{"problem":28,"code":"#(letfn [(flat [s] (if (or (list? s) (vector? s)) (mapcat flat s) [s]))] (flat %))","user":"564b3730e4b0284900eef665"},{"problem":28,"code":"#((fn myFlatten\n  [items result]\n  (cond \n    (nil? items) result\n    (and (= (seq? items) false) (= (vector? items) false)) (cons items result)\n    :else (myFlatten (butlast items) (myFlatten (last items) result))))\n  %\n  '()  \n)","user":"57ce6090e4b0c746388ab8ab"},{"problem":28,"code":"(fn [form]\n            (let [todo (atom [form])\n                  result (atom [])]\n              (while (seq @todo)\n                (let [curr (peek @todo)]\n                  (swap! todo pop)\n                  (if (sequential? curr)\n                    (doseq [kid (reverse curr)]\n                      (swap! todo conj kid))\n                    (swap! result conj curr))))\n              @result))","user":"53684a2fe4b0243289761e8c"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (if (nil? x)\n    nil\n    (if (coll? x)\n      (concat (flat x) (flat xs))\n      (cons x (flat xs)))))","user":"5267c74be4b03e8d9a4a7183"},{"problem":28,"code":"(fn flat [coll]\n  (when-let [s (seq coll)]\n    (if (sequential? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","user":"5898f299e4b00487982d52e1"},{"problem":28,"code":"(fn myflat [s] \n\t(if (sequential? s)\n\t\t(if (seq s)\n\t\t\t(concat (myflat (first s)) (myflat (rest s)))\n\t\t\t'()\n\t\t)\n\t\t(list s)\n\t)\n)","user":"592018d2e4b09b4ee5954c55"},{"code":"(fn myFlat\n  [coll]\n  (if (sequential? coll)\n    (mapcat myFlat coll)\n    (list coll)))","problem":28,"user":"52d39acce4b099d49816f0c7"},{"problem":28,"code":"(fn flat [coll] (lazy-seq (when-let [c (seq coll)] (if (coll? (first c)) (concat (flat (first c)) (flat (rest c))) (cons (first c) (flat (rest c)))))))","user":"5ae56da2e4b0837691e92c8f"},{"problem":28,"code":"(fn flt [s]\n  (if (sequential? s)\n    (mapcat flt s)\n    [s]\n    )\n  )","user":"53c6a2fde4b00fb29b22129d"},{"code":"#((fn fl [x a]\n  (if (empty? x)\n    a\n    (if (coll? (first x))\n      (concat a (fl (first x) []) (fl (rest x) []))\n      (fl (rest x) (conj a (first x)))))) % [])","problem":28,"user":"51f9b1d0e4b09be9c177e550"},{"problem":28,"code":"(fn flat\n  [a-seq]\n  (mapcat (fn [x]\n         (if (coll? x)\n           (flat x)\n           [x]))\n       a-seq))","user":"5abc5a09e4b073f1774426e9"},{"problem":28,"code":"(fn unnest [s]\n  (reduce (fn [unnested e]\n            (if (sequential? e)\n              (into unnested (unnest e))\n              (into unnested [e])))\n          []\n          s))","user":"57fe68e2e4b0d3187e9009ce"},{"problem":28,"code":"(fn [seq]\n  (let [actual-size     (count seq)\n        flattenx-helper (fn [i res size seq functionx] (cond (= i size) res\n                                                             (or (list? (nth seq i)) (vector? (nth seq i)))\n                                                             (let [nth_val (nth seq i)\n                                                                   nth_res (vec (functionx 0 [] (count nth_val) nth_val functionx))]\n                                                               (functionx (inc i) (vec (concat res nth_res)) size seq functionx))\n                                                             :else\n                                                             (functionx (inc i) (conj res (nth seq i)) size seq functionx)))]\n    (flattenx-helper 0 [] actual-size seq flattenx-helper)))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":28,"code":"(fn fltn\n  [x]\n  (into [] (if (sequential? x)\n     (if (empty? x)\n       []\n       (concat (fltn (first x)) (fltn (rest x))))\n     [x])))","user":"55395241e4b09218d5f44fe8"},{"code":"(fn my-flatter\n   [seqs]\n   (reverse (reduce (fn [result e]\n                      (if (sequential? e) (into result (my-flatter e)) (conj result e)))\n                    '() seqs)))","problem":28,"user":"527ed32ce4b0757a1b1713b5"},{"problem":28,"code":"(fn flat [x]\n  (cond\n    (coll? x) (mapcat flat x)\n    :else [x]))","user":"5a2b09ace4b09cafd31c7f42"},{"code":"(fn f [x]\n\t(if (coll? x)\n\t\t(reduce into (map f x))\n\t\t[x]))","problem":28,"user":"50eafeaae4b0346a3e988cbb"},{"problem":28,"code":"(fn myflatten [value]\n   (if (coll? value)\n     (apply concat (map myflatten value))\n     [value]))","user":"5455510fe4b0e397800069df"},{"code":"(fn flatten2 [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      nil\n      (concat (flatten2 (first xs)) (flatten2 (rest xs)))\n    )\n    [xs]\n    )\n)","problem":28,"user":"501c2dfce4b0539218e73b39"},{"problem":28,"code":"(fn -flatten [xs]\n  (if (coll? xs)\n    (cond\n      (empty? xs) nil\n      (coll? (first xs)) (concat (-flatten (first xs))\n                                 (-flatten (rest xs)))\n      :else (cons (first xs) (-flatten (rest xs))))\n    xs))","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":28,"code":"(fn [s]\n  (letfn [(my-flatten\n             [s]\n             (let [f (first s)\n                   r (rest s)]\n               (cond \n                 (empty? s) nil\n                 (sequential? f) (concat (my-flatten f) (my-flatten r))\n                 :else (cons f (my-flatten r)))))] (my-flatten s)))","user":"5813e208e4b0f478707a061b"},{"problem":28,"code":"(fn flat [s]\n  (if (sequential? s)\n    (if (empty? s)\n      s\n      (mapcat flat\n        [(first s)\n         (rest  s)]))\n    [s]))","user":"5a9181c5e4b002d099cae6f6"},{"problem":28,"code":"(fn go-flat [x] \n  (if (coll? x) \n    (mapcat go-flat x) \n    (list x) ))","user":"57ec8d1de4b0bfb2137f5b7f"},{"code":"(fn f [x]\n  (if (sequential? x)\n      (if (empty? x) nil (concat (f (first x)) (f (rest x))))\n      (list x)))","problem":28,"user":"4f03d0fe535dcb61093f6b6d"},{"problem":28,"code":"(fn fl [c] \n  (reduce (fn[x y]\n         (if (coll? y)\n           (fl (apply conj x y))\n           (conj x y) ) ) [] c)\n  )","user":"53ed2fafe4b0d648e757f4c1"},{"problem":28,"code":"(fn fltn [coll]\n  (loop [xs coll\n         acc []]\n    (cond (empty? xs) acc\n          (sequential? (first xs)) (recur (next xs) (vec (concat acc (fltn (first xs)))))\n          :else (recur (next xs) (conj acc (first xs))))))","user":"60b57acee4b0e0fa5f1b4238"},{"problem":28,"code":"(fn flattenize [s]\n    (if (empty? s)\n      s\n      (if (coll? (first s))\n        (concat (flattenize (first s))\n                (flattenize (rest s)))\n        (cons (first s) (flattenize (rest s))))))","user":"5b8f0861e4b0c0b3ffbd49f4"},{"problem":28,"code":"(fn my-flatten\n  ([coll] (my-flatten coll []))\n  ([coll acc]\n   (reduce (fn [acc x]\n             (if (sequential? x)\n               (my-flatten x acc)\n               (conj acc x)))\n            acc\n            coll)))","user":"541f6bc0e4b01498b1a71a98"},{"problem":28,"code":"(fn my-flatten [accu elem]\n  (if (coll? elem)\n    (reduce\n      my-flatten\n      accu\n      elem)\n    (conj accu elem))) []","user":"567b4641e4b05957ce8c61a5"},{"code":"(fn my-flatten [x]\n  (cond (empty? x) ()\n        (sequential? (first x)) (concat (my-flatten (first x)) (my-flatten (rest x)))\n        :else (cons (first x) (my-flatten (rest x)))))","problem":28,"user":"4ed98b40535d10e5ff6f5307"},{"code":"(fn\n  [x]\n  (letfn [(flat [coll]\n   (when-let [c (seq coll)]\n     (let [current (first c)]\n       (if (sequential? current)\n         (concat (flat current) (flat (rest c)))\n         (cons current (flat (rest c)))))))]\n   (if (sequential? x) (flat x) x)))","problem":28,"user":"5302b580e4b0d8b024fd3733"},{"code":"(letfn [(sns? [x] (and (coll? x) (not (string? x))))\n        (f [s]\n          (cond (not (sns? s)) s\n                (not-any? sns? s) s\n                (not (sns? (first s))) (cons (first s) (f (rest s)))\n                :else (concat (f (sequence (first s))) (f (rest s)))))]\n  f)","problem":28,"user":"502ac96de4b0614b5299611b"},{"problem":28,"code":"(fn squish [coll]\n  (if (sequential? coll)\n    (mapcat squish coll)\n    (list coll)))","user":"5ad7ff99e4b0ea6055cfac20"},{"code":"(fn flat [l]\r\n  (cond (nil?  l) l\r\n        (coll? l) (let [[h & t] l]\r\n                    (concat (flat h) (flat t)))\r\n        true      [l]))","problem":28,"user":"4fda108ee4b05e33b9224f46"},{"problem":28,"code":"(fn flattenn [args]\n(loop [ans [] xs args]\n   (if (empty? xs) ans\n     (let [f (first xs)]\n       (if-not (coll? f)\n         (recur (conj ans f) (rest xs))\n         (recur (into [] (concat ans (flattenn f))) (rest xs)))))))","user":"555f0789e4b0a2eb076a39bf"},{"problem":28,"code":"(fn flatten_ [l] \n  (if (sequential? l) \n    (if (empty? l) \n      []\n      (concat \n        (flatten_ (first l)) \n        (flatten_ (rest l))\n        ))\n    [l])\n  )","user":"5606a4ace4b08b23635d3175"},{"problem":28,"code":"#(letfn [(my-flatten [acc xs]\n          (let [a (first xs)\n                b (rest xs)]\n            (if (seq xs)\n              (recur (if (coll? a)\n                       (into acc (my-flatten [] a))\n                       (conj acc a))\n                     b)\n              acc))\n          )]\n  (my-flatten [] %))","user":"5143a51be4b0b4fb4ace5f39"},{"problem":28,"code":"(fn robins-recursive-flatten [x]\n  (let [flatten-x \n        (fn flatten-x [v coll]\n          (if (empty? coll)\n            v\n            (recur (into v (if (coll? (first coll))\n                             (flatten-x [] (first coll))\n                             [(first coll)]))\n                   (rest coll))))]\n        (flatten-x [] x)))","user":"55bb1b26e4b01b9910ae29e0"},{"problem":28,"code":"(fn [x]\n  (loop [f x res (list)]\n    (if (empty? f)\n      (reverse res)\n      (let [i (first f)\n            ii (rest f)]\n        (if (sequential? i)\n          (recur (concat i ii) res)\n          (recur ii (conj res i)))))))","user":"594cb88be4b07ddc2dafae6e"},{"problem":28,"code":"(fn g [h] \n\t((fn i [j] \n\t\t(reverse (into () j))\n\t)\n\t((fn g [o h] \n\t\t(when (< o (count h))\n\t\t\t(if (symbol? (get h o)) \n\t\t\t\t(into [] (cons (str (get h o)) (g (+ o 1) h))) \n\t\t\t\t(into [] (cons (get h o) (g (+ o 1) h))) \n\t\t\t)\n\t\t)\n\t) 0\n\t(read-string \n\t(clojure.string/replace (clojure.string/replace (clojure.string/replace (str \n\t\t((fn a [n b] \n\t\t\t(when (< n (count (str b))) \n\t\t\t\t(if (= (- n 1) (count (str b))) \n\t\t\t\t\t(if (or (= (subs (str b) n (+ n 1)) \"(\") (= (subs (str b) n (+ n 1)) \")\") (= (subs (str b) n (+ n 1)) \"[\") (= (subs (str b) n (+ n 1)) \"]\")) \n\t\t\t\t\t\t(a (+ n 1) b) \n\t\t\t\t\t\t(into [] (cons (subs (str b) n) (a (+ n 1) b)))\n\t\t\t\t\t) \n\t\t\t\t\t(if (or (= (subs (str b) n (+ n 1)) \"(\") (= (subs (str b) n (+ n 1)) \")\") (= (subs (str b) n (+ n 1)) \"[\") (= (subs (str b) n (+ n 1)) \"]\")) \n\t\t\t\t\t\t(a (+ n 1) b) \n\t\t\t\t\t\t(into [] (cons (subs (str b) n (+ n 1)) (a (+ n 1) b)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t) 0 (read-string (clojure.string/replace (clojure.string/replace (clojure.string/replace (str h) #\"\\\"\" \"\") #\" \" \"\") #\"0\" \" \")))\n\t) #\"\\\" \\\"\" \" \") #\"\\\"\" \"\") #\": \" \":\")))\n\t)\n\t)","user":"5710e574e4b09c608db7043b"},{"problem":28,"code":"; from the source\n#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %)))","user":"58524875e4b0b7285a6f4ead"},{"problem":28,"code":"#(loop[l %,i 0, r '()]\n   (if(= (count l) i)\n     (if(loop[k 0] (if(= k (count r)) false (if(or (list? (nth r k)) (vector? (nth r k))) true (recur(inc k)))))\n       (recur(and l (reverse r))(and i 0)(and r '()))\n       (reverse r))\n     (if(list? (nth l i))\n       (recur(and l l)(inc i)(and r (loop[j 0, x (nth l i), c r] (if-not(= (count x) j) (recur(inc j)(and x x)(cons (nth x j) c)) c))))\n       (if(vector? (nth l i))\n         (recur(and l l)(inc i)(and r (loop[j 0, x (nth l i), c r] (if-not(= (count x) j) (recur(inc j)(and x x)(cons (nth x j) c)) c))))\n         (recur(and l l)(inc i)(cons (nth l i) r))))))","user":"5654e8ade4b0f9d632dd848e"},{"code":"(fn ! [lst]\n  (mapcat #(if (coll? %) (! %) (list %)) lst)\n  )","problem":28,"user":"50e3fe8fe4b0463d32072488"},{"problem":28,"code":"(fn flatten-me\n  ([coll] (flatten-me coll []))\n  ([coll, sofar]\n   (if (empty? coll)\n     sofar\n     (let [x (first coll), xs (rest coll)]\n       (if (coll? x)\n         (flatten-me (concat x xs) sofar)\n         (flatten-me xs (conj sofar x))\n         )\n       )\n   )\n  )\n)","user":"56de0db0e4b0ea9b8538f83a"},{"code":"(fn bob-flatten [data]\n  (filter (complement sequential?)\n      (rest (tree-seq sequential? seq data))))\n;(filter (complement sequential?)\n ;         (rest (tree-seq sequential? seq x))))","problem":28,"user":"501d0321e4b066e56b9d0b1d"},{"problem":28,"code":"(fn flt [coll]\n        (if (every? (complement coll?) coll)\n          coll\n          (recur (apply concat (map #(if (coll? %) % (list %)) coll)))))","user":"5d915f01e4b0915913b1d401"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n               )]\n    (reduce f* [] c)\n    ))","user":"57289d7ee4b0c5bde472c15d"},{"code":"(fn splat [l]\n  ((fn f [nl l]\n     (cond\n      (= 0 (count l)) nl\n      (not (coll? (first l))) (concat nl [(first l)] (f nl (rest l)))\n      :else (concat nl (f nl (first l)) (f nl (rest l)))\n      )\n     ) [] l))","problem":28,"user":"4e720985535d5021c1a89655"},{"code":"#(filter (complement sequential?)  \n         (rest (tree-seq sequential? seq %)))","problem":28,"user":"51823a97e4b0f2adb733651e"},{"code":"(fn [x]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq x)\n  )\n)","problem":28,"user":"4fc8f671e4b0ee37620e1840"},{"problem":28,"code":"(fn flat [x] (if (sequential? x) (into [] (apply concat (map flat x))) [x]))","user":"5552b617e4b0deb715856df8"},{"code":"(fn flat [xs]\n  (if (coll? xs)\n    (mapcat flat xs)\n    [xs]))","problem":28,"user":"4f734e93e4b07046d9f4f043"},{"problem":28,"code":"(fn flat [x] (if (sequential? x) (reduce #(concat %1 (flat %2)) [] x) [x]))","user":"53ecac57e4b0d648e757f4b3"},{"problem":28,"code":"(fn newFlatten [s] (cond (empty? s) '() (not (coll? (first s))) (conj (newFlatten (rest s)) (first s))\n                           :else (concat (newFlatten (first s))(newFlatten (rest s)))))","user":"573c813be4b0cd1946bd10c5"},{"problem":28,"code":"#(letfn [(f [[h & t]]\n                  (cond (coll? h) (concat (f h) (f t))\n                        (nil? h) nil\n                        :default (cons h (f t))))]\n          (f %))","user":"5652f23ce4b0f9d632dd846b"},{"problem":28,"code":"(fn my-flatten2\n  [x]\n  (let [[f & r] x]\n    (println (str \"f is \" f))\n    (println (str \"r is \" r))\n    (cond\n      (empty? x) nil\n      (not (sequential? f)) (cons f (my-flatten2 r))\n      :else (concat (my-flatten2 f) (my-flatten2 r))\n        )\n    )\n  )","user":"5959c72ae4b066ee0a44afac"},{"code":"(fn [x] (filter (complement sequential?)\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e3ae7cd535deb9a81d77f4e"},{"problem":28,"code":"#((fn fltn [s r]\n  (if (= '() s)\n    r\n    (let [q (first s)]\n      (if (coll? q)\n        (fltn (rest s) (fltn q r))\n        (fltn (rest s) (conj r q)))))) % [])","user":"5c6e1006e4b0fca0c1622744"},{"code":"(fn make-flat [c] \n   (if (not(coll? c))\n     (list c)\n     (reduce concat (map make-flat c))))","problem":28,"user":"516933ece4b03f62cda68ce4"},{"problem":28,"code":"(fn [s]\n  (loop [[el & r] s\n         fs '()]\n    (cond (nil? el) (reverse fs)\n          (coll? el) (recur (concat el r) fs)\n          :else (recur r (conj fs el)))))","user":"5f6f461ae4b02876ed9fd06f"},{"code":"(fn [lists]\n ((fn iter [l lists]\n    (cond\n     (not (instance? Iterable lists)) (conj l lists)\n     (= 0 (count lists)) l\n     (instance? Iterable (first lists)) (iter (reduce iter l (first lists)) (rest lists))\n     :else (iter (conj l (first lists)) (rest lists)))) [] lists))","problem":28,"user":"517531c6e4b07031762f2eea"},{"code":"(fn [l]\n\t  \"Taken from ClojureDocs user slovic: free of StackOverflow problem, not lazy and much faster version of flatten.\"\n\t(loop [l1 l, l2 `()]\n\t  (cond\n\t    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n\t    (empty? l1) (reverse l2)\n\t    :else (recur (rest l1) (cons (first l1) l2)))))","problem":28,"user":"535a18e3e4b04ce2eb3ed2a4"},{"code":"#(reverse ((fn [p] (loop [e p t '() r '()] \n    (if (coll? e)\n      (recur\n        (first e)\n        (let [x (rest e)]\n          (if (empty? x)\n            t\n            (cons x t)))\n        r)\n      (if (empty? t)\n        (cons e r)\n        (recur t '() (cons e r)))))) %))","problem":28,"user":"4fdc3065e4b05e33b9224f6b"},{"problem":28,"code":"(fn flat [s]\n   (if (sequential? s)\n     (mapcat flat s)\n     (list s)))","user":"543a8256e4b032a45b869327"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n             \n             )]\n    (reduce f* [] c)\n    ))","user":"5f969090e4b0715f5002d7d5"},{"code":"(fn flatIt [s]\n  (loop [result () i 1 cnt (count s)]\n      (if (> i cnt)\n          result\n          (recur\n           ( if (coll? (nth s (- cnt i)) )   \n             (concat (flatIt (nth s (- cnt i)) )   result         )\n             (merge result (nth s (- cnt i)) )\n            )\n            (inc i) cnt\n          )\n      )\n  )\n)","problem":28,"user":"518aec06e4b06da86c1973c2"},{"code":"(fn [x] (filter #(not (coll? %)) (rest (tree-seq coll? seq x))))","problem":28,"user":"50548ce8e4b0b1b9d1860ead"},{"code":"(fn [coll]\n  (letfn [(f [c]\n    (cond (not (seq c)) nil\n          (not (coll? (first c))) (cons (first c) (f (rest c)))\n          :else (concat (f (first c)) (f (rest c)))))]\n    (f coll))\n  )","problem":28,"user":"51857e64e4b0da5a5be3babe"},{"problem":28,"code":"#(reverse ((fn flat [s r]\n    (if (empty? s)\n      r\n      (flat\n       (rest s)\n       (if (sequential? (first s))\n         (flat (first s) r)\n         (conj r (first s))))))\n  % '()))","user":"5721dfc3e4b0c5bde472c0bb"},{"code":"reduce (fn myflt [res x]\n         (if (not (coll? x))\n            (conj res x)\n            (reduce myflt res x)))\n      []","problem":28,"user":"4f46df00e4b0d56e7bb92bac"},{"problem":28,"code":"(fn fl [x]\n  (if (coll? x)\n    (mapcat fl x) [x]))","user":"569381a5e4b0dcc4269f4104"},{"code":"(fn my-flatten [x]\n  (reduce concat\n          ()\n          (map #((if (coll? %) my-flatten list) %)\n               x)))","problem":28,"user":"521bf7cfe4b0c4ef0be83066"},{"problem":28,"code":"(fn flat [s]\n  (cond\n   \t(empty? s)\n   \t  nil\n   \t((complement coll?) (first s))\n      (cons (first s) (flat (rest s)))\n    :else\n      (concat (flat (first s)) (flat (rest s)))))","user":"545801f6e4b01be26fd74615"},{"code":"(fn my-flatten [lst]\n  (let [head (first lst) tail (next lst)]\n    (concat\n     (if (sequential? head)\n       (my-flatten head)\n       [head])\n     (when (sequential? tail)\n       (my-flatten tail)))))","problem":28,"user":"4fd7f892e4b0dab7d829f38d"},{"problem":28,"code":"(fn [s]\n    (filter (complement sequential?)\n        (tree-seq sequential? seq s)))","user":"566cf904e4b0a866af6896c5"},{"code":"(fn f [x] (mapcat #(if (coll? %) (f %) [%]) x))","problem":28,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [x]\n  (filter\n    (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f98da04e4b0dcca54ed6cf7"},{"problem":28,"code":"(fn [x]\n  ((fn flat [x n]\n   (loop [x x n n]\n     (if x\n       (recur (next x) (if (sequential? (first x)) \n                         (flat (first x) n)\n                         (conj n (first x))))\n       n))) \n   x []))","user":"53eade35e4b036ad0777e4ec"},{"problem":28,"code":"(fn my-flatten [v] (if(sequential? v) (vec (apply concat (map my-flatten v))) [v]))","user":"59024826e4b0438e51c2d053"},{"problem":28,"code":"mapcat (fn flat [elem] ( if (coll? elem) (mapcat flat elem) (list elem) ))","user":"5280a1ece4b0757a1b171407"},{"problem":28,"code":"(fn [s]\n   (filter (complement sequential?)\n           (tree-seq sequential? seq s)))","user":"5ddd134ae4b0948ae9d9adc0"},{"code":"(fn [lst]\n  ((fn iter [res l]\n     (if (coll? l)\n       (if (empty? l) res\n         (concat res (iter '() (first l)) (iter '() (rest l))))\n       (concat res (list l))))\n   '() lst))","problem":28,"user":"51da631be4b02ceefd947766"},{"code":"(fn flt [[h & t]]\n    (cond (nil? h)\n          '()\n          (sequential? h)\n          (concat (flt h) (flt t))\n          :else\n          (cons h (flt t))))","problem":28,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":28,"code":"(fn [coll]\n  (->> coll\n       (tree-seq sequential? vec)\n       (remove sequential?)))","user":"6098263be4b00e9e6653c3f9"},{"code":"(fn ft [coll]\n  (let [f1 (fn [coll] (apply concat (map #(if (sequential? %) % (take 1 (repeat %))) coll)))] \n  (loop [x coll]\n    (if (some sequential? x)\n      (recur (f1 x))\n      x))))","problem":28,"user":"52cf084ce4b07d0d72b27399"},{"problem":28,"code":"(fn [coll]\n  (reduce\n   (fn fla [r c]\n     (if (coll? c)\n       (reduce fla r c)\n       (conj r c)))\n   [] coll))","user":"565654dae4b0f9d632dd849f"},{"problem":28,"code":"(letfn [(my-flatten-2\n  [x]\n  (cond\n   (empty? x) x\n   (sequential? (first x))\n   (concat (my-flatten-2 (first x)) (my-flatten-2 (rest x)))\n   :else\n   (cons (first x) (my-flatten-2 (rest x)))))]\n  my-flatten-2)","user":"58bf1cf8e4b021aa9917eccf"},{"code":"(fn [c]\n  (letfn [(my-flattener [c# t]\n    (let [a (first c#)]\n       (cond \n         (nil? a) t\n         (sequential? a) (my-flattener (rest c#) (my-flattener a t))\n         :else (my-flattener (rest c#) (conj t a)))))]\n    (my-flattener c [])))","problem":28,"user":"5127e504e4b03a34742b4302"},{"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs))))\n  )","problem":28,"user":"531843c1e4b08068f379ed6c"},{"problem":28,"code":"(fn flatten-seq [x]\n  (loop [i 0 output []]\n    (if (= i (count x)) output\n        (let [y (nth x i)]\n          (recur (inc i) (into [] (concat output\n                                          (if (or (seq? y) (vector? y)) (flatten-seq y) [y]))))))))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":28,"code":"(fn [lst]\n    (let [result (\n     \n     \n     (fn [accum l found-coll]\n       (if (empty? l)\n         [accum found-coll]\n         (if (coll? (first l))\n           (recur (concat accum (first l)) (rest l) true)\n         (recur (concat accum [(first l)]) (rest l) found-coll)\n         ))\n       )\n\n     [] lst false)]\n     \n      (if (second result)\n        (recur (first result))\n        (first result)\n        )\n      \n      )\n                \n                )","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn flt [col]\n  (let [f (first col) r (next col)]\n    (concat \n     (if (sequential? f)\n       (flt f)\n       [f])\n     (when (sequential? r)\n       (flt r)))))","problem":28,"user":"51026750e4b00c483ae176f7"},{"problem":28,"code":"(fn myFlat [x]\n  (cond\n   (nil? x) ()\n   (coll? x) (concat (myFlat (first x)) (myFlat (next x)) )\n   :else (list x))\n  )","user":"541619e8e4b01498b1a719f9"},{"code":"#(filter (complement sequential?)\n(rest (tree-seq sequential? seq %)))","problem":28,"user":"4f10175e535d64f603146411"},{"problem":28,"code":"(fn myFlatten\n  [lst]\n  (if (coll? lst)\n    (mapcat myFlatten lst)\n    (list lst)))","user":"5c74b043e4b0fca0c16227ce"},{"problem":28,"code":"(fn tryConcat [mySeq]\n  (cond\n   (empty? mySeq) '()\n   (sequential? (first mySeq)) (concat (tryConcat (first mySeq)) (tryConcat (rest mySeq)) )\n   :else (cons (first mySeq) (tryConcat (rest mySeq)) )\n   )\n  )","user":"5e663073e4b0fd0acd1586bc"},{"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4de27757535d08e6dec9fdea"},{"problem":28,"code":"(fn [v]\n  (reduce (fn f [r in]\n            (if (coll? in)\n              (reduce f r in)\n              (conj r in)))\n          []\n          v))","user":"577ab41fe4b0d3393e5deb05"},{"code":"(fn func [xs]\n  (for [x xs\n        :let [ys (if (sequential? x)\n                   (func (seq x))\n                   [x])]\n        y ys]\n    y))","problem":28,"user":"4ea03f70535d7eef308072a1"},{"problem":28,"code":"(fn fltn [x]\n  (if\n    (coll? x)\n    (mapcat fltn x)\n    (list x)))","user":"54f904c2e4b01ecee9d88832"},{"problem":28,"code":"(fn [xs]         \n          (if (not-any? sequential? xs)\n            xs             \n          (recur (reduce #(cond (sequential? %2) (vec (concat %1 %2)) :else (conj %1 %2)) []  xs)))\n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":28,"code":"(fn flat [coll]\n  (if-not (empty? coll)\n    (if (sequential? (first coll))\n      (concat  (flat (first coll)) (flat (rest coll)))\n      (cons (first coll) (flat  (rest coll))))))","user":"53f2370ee4b0742d9025b0e7"},{"problem":28,"code":"(fn myflatten [s]\n  (reduce (fn [accum x]\n            (if (coll? x)\n              (concat accum (myflatten x))\n              (concat accum [x])))\n          '()\n          s))","user":"5b5d255de4b0c6492753e6c8"},{"code":"(fn l-flatten\n  [lst]\n  (if (empty? lst)\n    '()\n    (if (sequential? (first lst))\n      (concat (l-flatten (first lst)) (l-flatten (rest lst)))\n      (conj (l-flatten (rest lst)) (first lst)))))","problem":28,"user":"534ff8a6e4b084c2834f4ad1"},{"problem":28,"code":"(fn flat [coll] (mapcat #(if (coll? %) (flat %) (cons % ())) coll))","user":"59c8c9bee4b0a024fb6ae567"},{"problem":28,"code":"(fn myflatten [x] (if (coll? x) (reduce #(concat %1 (myflatten %2)) '() x) [x]))","user":"558466fce4b04192f3441eee"},{"problem":28,"code":"(fn flt [s]\n  (mapcat (fn [x] (if (sequential? x) (flt x) [x])) s))","user":"56cf115de4b0ea9b8538f765"},{"problem":28,"code":"(fn flaten [coll]\n  (cond\n   (coll? coll) (cond\n                (empty? coll) '()\n                :else (concat (flaten (first coll)) (flaten (rest coll))))\n   :else (list coll)))","user":"576b4e6be4b0a07e8fc1812b"},{"problem":28,"code":"#(reduce \n     (fn my-flatten [v l] \n       (if (coll? l)\n         (reduce my-flatten v l)\n         (conj v l)))\n     [] %)","user":"555e9dbfe4b0a2eb076a39bc"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (or (seq? s) (vector? s))\n    (reduce concat (map my-flatten s))\n    [s]))","user":"56602649e4b068f2fe63dc47"},{"problem":28,"code":"(fn my-flatten [x]\n\t(concat\n\t\t(if (coll? (first x))\n\t\t\t(my-flatten (first x))\n\t\t\t(list (first x)))\n\t\t(if (not (empty? (rest x)))\n\t\t\t(my-flatten (rest x)))))","user":"54296802e4b01498b1a71b38"},{"problem":28,"code":"(fn flattn [x] (if (not (sequential? x)) x (if (empty? x) nil (if (sequential? (first x)) (concat (flattn (first x)) (flattn (next x))) (conj (flattn (next x)) (first x))))))","user":"5c51f60be4b0fb8c5ffd99d4"},{"problem":28,"code":"(fn flat [l] (if (coll? l) (apply concat (map flat l)) (list l)))","user":"583c8bd4e4b089d5ab817d81"},{"problem":28,"code":"(partial (fn s [a b] (reduce #(if (coll? %2) (s %1 %2) (conj %1 %2)) a b)) [])","user":"5382704be4b06839e8705ed4"},{"problem":28,"code":"(fn [x]\n  (loop [ls x acc '()]\n    (if (empty? ls)\n      acc\n      (let [[head & tail] ls]\n        (if (or (seq? head) (vector? head))\n          (recur (concat head tail) acc)\n          (recur tail (concat acc (list head)))\n        )\n      )\n    )\n  )\n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":28,"code":"(fn my-flatten [seq]\n      (let [[x & rest] seq]\n        (cond (empty? seq) '()\n              (coll? x) (concat (my-flatten x) (my-flatten rest))\n              :else (cons x (my-flatten rest)))) )","user":"5e317676e4b05b4b01516229"},{"problem":28,"code":"(fn flatten'\n\t\t [x]\n\t\t (if (instance? clojure.lang.Sequential x)\n\t\t   (reduce concat (map flatten' x))\n\t\t   [x]\n\t\t   ))","user":"54965534e4b0b312c081ff65"},{"code":"(fn [x] (filter (complement coll?) (tree-seq coll? identity x)))","problem":28,"user":"51547920e4b084ca81ee2e1c"},{"problem":28,"code":"(fn flatten-coll [coll]\n  (reduce (fn [acc item]\n    (cond\n      (coll? item) (concat acc (flatten-coll item)) \n      :else (concat acc [item]))) '() coll))","user":"5c8cfff8e4b048ec896c5996"},{"code":"(fn flat [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      nil\n      (concat (flat (first xs)) (flat (rest xs))))\n  [xs]))","problem":28,"user":"50ed1ce7e4b01236b1d49839"},{"problem":28,"code":"(fn flat-seq\n  [coll]\n  (let [grab (fn [x] (if (sequential? x) x [x]))] \n    (loop [result coll]\n      (if (some sequential? result)\n        (recur\n          (mapcat grab result))\n        result))))","user":"5a3c06fce4b001c08efc0cdd"},{"code":"(fn flatten2 [x]\n  (reduce #(concat % (if (coll? %2) (flatten2 %2) [%2])) () x))","problem":28,"user":"515d6f49e4b00901442db1dd"},{"problem":28,"code":"(fn fltn[s]\n   (if (empty? s) ()\n   (if (sequential? (first s) ) (concat (fltn (first s)) (fltn (rest s)))  (conj (fltn (rest s))  (first s)))))","user":"5afc115de4b0cc2b61a3bcff"},{"problem":28,"code":"(fn fl [[h & r]]\n    (if h\n      (if (sequential? h)\n        (concat (fl h) (fl r))\n        (cons h (fl r)))))","user":"56761ab1e4b05957ce8c6154"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (cond\n    (coll? coll) (apply concat (map my-flatten coll))\n    :else [coll]))","user":"53ae0c50e4b047364c044471"},{"code":"(fn flat [[x & xs]]\n  (if (nil? x) ()\n    (if (coll? x)\n      (concat (flat x) (flat xs))\n      (conj (flat xs) x))))","problem":28,"user":"52437703e4b076204b44fabf"},{"code":"(fn [xs]\r\n  (loop [newxs xs]\r\n    (if (not (some coll? newxs))\r\n      (list* newxs)\r\n      (recur (reduce #(if (coll? %2)\r\n              (vec (concat %1 %2))\r\n              (conj %1 %2)) [] newxs)))))","problem":28,"user":"4fd9f5dbe4b05e33b9224f41"},{"problem":28,"code":"#(reverse (\n\t\t\t(fn myflat [tree]\n\t\t\t\t(reduce \n\t\t\t\t\t(fn [accum value]\n\t\t\t\t\t\t(if (coll? value)\n\t\t\t\t\t\t\t(concat (myflat value) accum)\n\t\t\t\t\t\t\t(cons value accum)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t(cons [] tree)\n\t\t\t\t)\n\t\t\t)\n\t\t\t%\n\t\t)\n\t)","user":"55fc8f1fe4b0f488688e0675"},{"problem":28,"code":"(fn my-flatten [s] (let [new-s (mapcat #(if (sequential? %) % (list %)) s)]\n                        (if (some sequential? new-s) (my-flatten new-s)\n                          new-s)))","user":"56baab13e4b0f26550335948"},{"code":"(fn my-flatten1\n                  [[x & xs :as l]]\n                  (cond\n                   (empty? l) nil\n                   (coll? x) (concat (my-flatten1 x) (my-flatten1 xs))\n                   :else    (cons x (my-flatten1 xs))))","problem":28,"user":"4e71705e535d5021c1a89649"},{"problem":28,"code":"(fn mf\n  [cl]\n  (mapcat (fn [x]\n            (if (coll? x)\n              (mf x)\n              (list x)))\n    cl))","user":"5455c2f3e4b080a794c2c87d"},{"problem":28,"code":"(fn flat [items]\n  (if (coll? items)\n    (mapcat flat items)\n    (list items)))","user":"52c03baee4b07a9af5792347"},{"code":"#(filter (complement sequential?)(rest (tree-seq sequential? seq %1)))","problem":28,"user":"4ebbb6bc535dfed6da9c6d71"},{"problem":28,"code":"(fn fl [col] (mapcat #(if (sequential? %) (fl %) (list %)) col))","user":"586b6d51e4b01531a375e958"},{"problem":28,"code":";#(loop [v % q '()] \n;  (cond\n;    (sequential? (first v)) (recur (concat (first v) (rest v)) q)\n;    (empty? v) (reverse q)\n;    :else (recur (rest v) (conj q (first v)))))\n\n; (fn flat [x] (if (coll? x) (mapcat flat x) (list x)))\n(fn flat [x] (if (coll? x) (mapcat flat x) [x]))","user":"591d182ee4b09b4ee5954c10"},{"problem":28,"code":"(fn [s]\n    (loop [acc '()\n           s s]\n      (cond\n        (empty? s) (reverse acc)\n        (not (coll? (first s))) (recur (cons (first s) acc) (rest s))\n        :else (recur acc (concat (first s) (rest s))))))","user":"5600dccee4b04bb52996e175"},{"problem":28,"code":"(fn doit [x]\n  (if (some coll? x)\n    (apply concat (map (fn [m] (if (coll? m) (doit m) [m])) x))\n    x\n    )\n  )","user":"526698c9e4b03e8d9a4a7144"},{"code":"(fn fltn [xs]\n  (cond\n   (empty? xs)\n   \t'()\n   (coll? (first xs))\n   \t(concat (fltn (first xs)) (fltn (rest xs)))\n   :else\n   \t(cons (first xs) (fltn (rest xs)))))","problem":28,"user":"5136f659e4b04059df19f2fd"},{"code":"(fn [coll]\r\n  (if (empty? (filter sequential? coll))\r\n    coll\r\n    (recur (apply concat (map #(if (not (sequential? %)) (list %) %) coll)))))","problem":28,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":28,"code":"(fn [x]\n  (loop [acc [] rest x]\n    (if (empty? rest)\n      acc\n      (if (sequential? (first rest))\n        (recur acc (concat (first rest) (drop 1 rest)))\n        (recur (conj acc (first rest)) (drop 1 rest))))))","user":"57c3df67e4b05aa3c4741cc5"},{"problem":28,"code":"(fn my-flatten [a-seq]\n  (cond\n   (empty? a-seq) nil\n   (coll? (first a-seq)) (concat (my-flatten (first a-seq)) (my-flatten (rest a-seq)))\n    :else (cons (first a-seq) (my-flatten (rest a-seq)))))","user":"505d1b01e4b0e6aca564be04"},{"code":"(fn flatt-it [col] (if (coll? col)\n                     (when (seq col) (concat (flatt-it (first col)) (flatt-it (rest col))))\n                     [col]))","problem":28,"user":"50aca92ee4b071b89ef26232"},{"code":"(fn fl [coll]\n  (if (sequential? coll)\n    (mapcat fl coll)\n    (list coll)))","problem":28,"user":"51f7dd27e4b06ff1c25c52dc"},{"problem":28,"code":"(fn fltn [s]\n    (if-not (sequential? s)\n            (list s)\n            (apply concat (map fltn s))\n    )\n)","user":"548f5086e4b0e286459a1239"},{"problem":28,"code":"(fn flat [coll] (reverse (if (coll? coll)   (reduce into nil (map flat coll))  (list coll))))","user":"52e5f810e4b09f7907dd1468"},{"code":"(fn [x] (remove sequential? (rest (tree-seq sequential? seq x))))","problem":28,"user":"5035503de4b0ed9c821488f8"},{"problem":28,"code":"(fn flatting [x]\n  (if (coll? x)\n    (mapcat flatting x)\n    [x]))","user":"569f33c7e4b0542e1f8d148f"},{"code":"(fn fltn [sequence]\n  (when-let [head (first sequence)]\n    (let [tail (next sequence)]\n      (if (sequential? head)\n        (concat (fltn head) (fltn tail))\n        (conj (fltn tail) head)))))","problem":28,"user":"4e8a8720535d65386fec210c"},{"problem":28,"code":"(fn fltn [arg]\n\t(concat (if (coll? (first arg))\n\t\t    (fltn (first arg))\n\t\t  (list (first arg)))\n\t\t(if (empty? (rest arg)) '()  (fltn (rest arg)))))","user":"5572fdd7e4b0aa18f790f3f1"},{"problem":28,"code":"(fn [to-flatten]\n  (filter (complement coll?)\n          (tree-seq coll? identity to-flatten)))","user":"560d4994e4b05f002753df3c"},{"problem":28,"code":"(fn flten [coll]\n  (if (coll? coll)\n    (mapcat flten coll)\n    [coll]))","user":"5db1969be4b010eb3c36cd06"},{"code":"(fn flt [x]\n  (if (empty? x)\n    x\n    (let [head (first x)\n          tail (rest x)]\n      (concat\n        (if (sequential? head)\n          (flt head)\n          [head])\n        (flt tail)))))","problem":28,"user":"5208495ce4b0c1501ba9e6da"},{"code":"(fn [xs]\n  (filter (complement sequential?)\n          (tree-seq sequential? identity xs)))","problem":28,"user":"4feff3b6e4b0678c553fc31e"},{"problem":28,"code":"(fn [sq]\n  (let [flt? (fn [s]\n               (if (empty? s) true\n                 (if (coll? (first s)) false\n                   (recur (rest s)))))\n        flt1 (fn [s acc]\n               (if (empty? s) acc\n                 (recur (rest s) (concat acc (if (coll? (first s)) (first s)\n                                               (list (first s)))))))\n        flta (fn [s]\n               (if (flt? s) s\n                 (recur (flt1 s '()))))]\n    (flta sq)))","user":"57780e4fe4b0979f89651657"},{"code":"(fn my-flatten [coll]\n  (mapcat (fn [e] (if (coll? e) (my-flatten e) (list e))) coll))","problem":28,"user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn fl [l]\n((fn fl0 [lst,acc]\n  (if\n    (empty? lst)  acc\n    (if (coll? (first lst))\n     (fl0 (first lst) (fl0 (rest lst) acc))\n     (cons  (first lst) (fl0 (rest lst) acc) )\n    )\n   )\n\n  ) l '() )\n\n)","problem":28,"user":"5180dc04e4b06b8caf33fa01"},{"problem":28,"code":"(fn myflatten\n  [liste]\n  (loop [l1 liste, l2 '()]\n    (cond\n     (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n     (empty? l1) (reverse l2)\n     :else (recur (rest l1) (cons (first l1) l2)))\n    ))","user":"54410a71e4b032a45b869367"},{"problem":28,"code":"(fn [outermost-lst] (reverse ((fn flattr2 [lst]\n   (loop [l lst, n (first l), acc '()]\n     (if (nil? n) acc\n       (if (sequential? n)\n         (recur (rest l)\n                (second l)\n                (concat (flattr2 n) acc ))\n         (recur (rest l) \n                (second l)\n                (conj acc n)))\n       )\n     )\n ) outermost-lst)))","user":"53bd6fcfe4b0d9a98559a6d0"},{"problem":28,"code":"(partial (fn flatten-acc [acc ls]\n  (if (empty? ls)\n    acc\n    (if (or (list? (first ls)) (sequential? (first ls)))\n      (flatten-acc (apply conj acc (flatten-acc [] (first ls))) (rest ls))\n      (flatten-acc (conj acc (first ls)) (rest ls))))) [])","user":"53d87449e4b0e771c302546d"},{"code":"(fn my-flatten [coll]\n  (filter (complement sequential?) \n    (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4f159ea6535d64f603146445"},{"code":"(fn flatten2 \n  ([seq result]\n    (cond\n      (or (nil? seq) (empty? seq)) result\n      (coll? (first seq))(concat (flatten2 (first seq) result) (flatten2 (next seq)) )\n      :default (flatten2 (next seq) (concat result (list (first seq))))\n    )\n  )\n  ([seq]\n    (flatten2 seq '())\n  )\n)","problem":28,"user":"525d44bfe4b0cb4875a45d6d"},{"problem":28,"code":"(fn flat [x]\n  (if (coll? x)\n    (reduce #(concat %1 (flat %2)) [] x)\n    [x])\n  )","user":"5eb4927fe4b00a66d4a95221"},{"code":"(fn flt\n  ([s] (flt s []))\n  ([s acc]\n    (if (empty? s) acc\n      (if (sequential? (first s))\n        (flt (rest s) (vec (concat acc (flt (first s) []))))\n        (flt (rest s) (conj acc (first s)))\n      )\n    )\n  )\n)","problem":28,"user":"4fff00ede4b0678c553fc3fc"},{"code":"(fn flt[coll] \n  (let [f (first coll)\n        r (next coll)]\n      (concat \n          (if (sequential? f) (flt f) [f])\n          (when (sequential? r) (flt r))\n    )\n  )\n)","problem":28,"user":"4e6dd0f5535d5021c1a895f3"},{"problem":28,"code":"(fn flatten-1-layer[u]\n  (mapcat  #(if (sequential? %)\n              (flatten-1-layer %)\n              [%])\n           u))","user":"5018878ce4b029375d2a5056"},{"problem":28,"code":"(fn [lst]\n      ((fn [lst flst]\n        (if (empty? lst)\n          (if (some coll? flst)\n            (recur flst '())\n            (seq flst))\n          (if (coll? (first lst))\n            (recur (rest lst) (reduce conj (vec flst) (first lst)))\n          (recur (rest lst) (conj (vec flst) (first lst)))))) lst '()))","user":"587a3babe4b01531a375eae2"},{"code":"(fn flat [ls]\n  (let [f (first ls), rs (rest ls)]\n  \t(cond (empty? ls) '()\n          (coll? f) (concat (flat f) (flat rs))\n          :else (cons f (flat rs)))))","problem":28,"user":"532b9075e4b09d4e7a9b5533"},{"problem":28,"code":"(fn flatten-seq [nested-seq]\n    (let [first-item (first nested-seq)\n          rest-items (rest nested-seq)]\n    (cond\n        (nil? first-item)\n        []\n        (coll? first-item) \n        (concat (flatten-seq first-item) (flatten-seq rest-items))\n        :default (concat [first-item] (flatten-seq rest-items)))))","user":"568f2059e4b0dcc4269f40df"},{"code":"(fn makeflat [unflat]\n  (loop [flat '()\n         unseen unflat]\n    (if (empty? unseen)\n      flat\n      (let [head (first unseen)]\n        (if (#(or (seq? %) (vector? %)) head)\n          (recur (concat flat (makeflat head)) (rest unseen))\n          (recur (concat flat [head]) (rest unseen)))))))","problem":28,"user":"50e98510e4b028853d549f3c"},{"code":"(fn flat [x]\n     (let [elem (first x) coll (rest x)] \n       (cond\n         (empty? x) '()\n         (sequential? elem) (concat (flat elem) (flat coll))\n         :else (conj (flat coll) elem)\n         )\n       )\n     )","problem":28,"user":"4fe9ef2fe4b0547ebccb2479"},{"code":"(fn flat [coll] (cond (and (coll? coll) (empty? coll)) nil (not (coll? coll)) [coll] (coll? coll) (concat (flat (first coll)) (flat (rest coll)))))","problem":28,"user":"4e3f595d535dc968683fc498"},{"problem":28,"code":"(fn flat-2\n  [coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (if (coll? (first s))\n       (concat (flat-2 (first s)) (flat-2 (rest s)))\n       (cons (first s) (flat-2 (rest s)))))))","user":"58e53760e4b056aecfd47c8f"},{"problem":28,"code":"(fn my-flatten [s]\n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq s))))","user":"5865c8f0e4b0f14aab7c884e"},{"problem":28,"code":"(fn flatten! [s] \n  (if (coll? s)\n    (apply concat (map flatten! s))\n    [s]))","user":"5901158de4b0438e51c2d039"},{"problem":28,"code":"(fn myflatten [mycoll]\n  (if (coll? mycoll)\n    (mapcat myflatten mycoll)\n    (list mycoll)))","user":"58d810bfe4b03c36ff7e5991"},{"problem":28,"code":"(fn fl [c] (if (empty? c)\n  []\n  (if (sequential? (first c))\n   (concat (fl (first c)) (fl (rest c)))\n   (concat [(first c)] (fl (rest c)))\n  )\n))","user":"589c12c2e4b00487982d5353"},{"problem":28,"code":"#(seq (reduce (fn [r i]\n              (if (coll? i)\n                (if (coll? (first i))\n                  (recur r (first i))\n                  (recur (conj r (first i)) (next i)))\n                (if (nil? i) r\n                             (conj r i))))\n             [] %))","user":"50385746e4b0803468ea2c6d"},{"problem":28,"code":"(fn fltn [x] (if (sequential? x) (reduce concat (map fltn x)) (cons x '())))","user":"564716e6e4b0284900eef616"},{"problem":28,"code":"#(letfn [(flat [sequence]\n           (when-let [s (seq sequence)]\n             (let [first (first s)]\n               (if\n                (sequential? first)\n                 (concat (flat first) (flat (rest s)))\n                 (cons first (flat (rest s)))))))]\n   (flat %))","user":"5f6e23e6e4b02876ed9fd064"},{"code":"(fn f [coll]\n  (when-let [x (seq coll)]\n    (if (coll? (first x))\n       (concat (f (first x)) (f (rest x)))\n       (cons (first x) (f (rest x)))\n    )\n  )\n)","problem":28,"user":"50f0ec9ce4b0d527ce5b30df"},{"code":"(fn foo [x] (if (sequential? x) (if (empty? x) nil (concat (foo (first x)) (foo (rest x))))\n(list x)))","problem":28,"user":"4dea9fae535d08e6dec9fe02"},{"code":"(fn flt [coll]\n  (let [l (first coll)\n        r (next coll)]\n    (concat\n      (if (coll? l)\n        (flt l)\n        [l])\n      (when (coll? r)\n        (flt r)))))","problem":28,"user":"4e52777f535d302ef430da76"},{"code":"(fn [x]\n    (loop [flat []\n           x x]      \n      (if (seq x)\n        (if (coll? (first x))\n          (recur flat (concat (first x) (rest x)))\n          (recur (conj flat (first x)) (rest x)))\n        flat)))","problem":28,"user":"4e5be681535d8a8b8723a2bc"},{"problem":28,"code":"(fn myf [s]\n  (if (coll? s)\n    (mapcat myf s)\n    [s]))","user":"5700ec08e4b08d47c97781cd"},{"problem":28,"code":"(fn fl [[f & r]]\n  (if (nil? f)\n    '()\n    (if (sequential? f)\n      (concat (fl f) (fl r))\n      (cons f (fl r)))))","user":"5f81de6ce4b0c071e6c840f5"},{"problem":28,"code":"(fn flat [sequ]\n  (if (empty? sequ)\n    nil\n    (let [a (first sequ)]\n      (if (coll? a)\n        (flat (concat a (rest sequ)))\n        (cons a (flat (rest sequ))))\n      )\n    ))","user":"5a7f77fae4b00b71e582a041"},{"code":"(fn [a-seq] (first (filter #(not-any? sequential? %) \n(iterate \n  (partial mapcat #(if (not (sequential? %)) (list %) %))\n  a-seq ))))","problem":28,"user":"4e6dc95a535d5021c1a895f1"},{"problem":28,"code":"(fn flat [x] \n  (if (= x '()) '()\n    (if (coll? (first x)) \n      (concat \n       (flat (first x))\n       (flat (rest x)))\n      (cons \n       (first x) \n       (flat (rest x)) ) ) ) )","user":"53504a7de4b084c2834f4ad9"},{"problem":28,"code":"(fn flatten9\n  [x] \n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq x))))","user":"5afa8095e4b0cc2b61a3bceb"},{"problem":28,"code":"(fn [coll]\n    (filter \n        (complement coll?) (rest (tree-seq coll? seq coll))))","user":"56e4427ce4b03a7c14b85a4c"},{"code":"(fn f ([x] \n  (f x []))\n  ([x r]\n    (if (empty? x)\n        r\n      (if (counted? (first x))\n          (recur (concat (first x) (rest x)) r)\n        (recur (rest x) (conj r (first x)))))))","problem":28,"user":"507fbd77e4b089ade05efbd3"},{"code":"#(filter (complement sequential?)\n(tree-seq sequential? seq %))","problem":28,"user":"4ec92a04535d6d7199dd36fa"},{"problem":28,"code":"#(reduce (fn flattenW [seq el]\n           (if (sequential? el)\n             (reduce flattenW seq el)\n             (conj seq el))) [] %)","user":"5c4c74efe4b0f9f7a8770e76"},{"problem":28,"code":"(fn f [x]\n  (cond\n    (empty? x) ()\n    (coll? (first x)) (concat (f (first x)) (f (rest x)))\n    :else (cons (first x) (f (rest x)))))","user":"4e8a170c535d3e98b802328f"},{"code":"(fn flat[ret sequence]\n  (if (seq sequence)\n    (let [elem (first sequence)]\n    (if (coll? elem)\n      (if (seq elem)\n        (flat ret (cons (first elem) (cons (rest elem) (rest sequence))))\n        (flat ret (rest sequence)))\n      (flat (conj ret elem) (rest sequence))))\n    ret\n    )) []","problem":28,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn [x](filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"52295917e4b04c906c9c6a6f"},{"problem":28,"code":"(fn [se]\n  ((fn [result [elem & rst]]\n     (if (or (seq? elem) (vector? elem))\n       (if (empty? elem)\n         (if (empty? rst) (reverse result) (recur result rst))\n         (recur result (conj rst (rest elem) (first elem))))\n       (if (nil? elem)\n         (reverse result)\n         (recur (conj result elem) rst))))\n   '() se))","user":"5e178fbee4b00200644e3d57"},{"code":"(fn ff [data] (if (some coll? data) (ff (mapcat #(if (not (coll? %)) [%] %) data)) data))","problem":28,"user":"509fe759e4b08df8156e9e43"},{"problem":28,"code":"(fn myflatten3 [coll]\n  (if (empty? (filter coll? coll))\n    coll\n    (recur (reduce #(let [s (if-not (coll? %2) (vector %2) %2)]\n                      (into %1 s)) [] coll))))","user":"54e79094e4b024c67c0cf818"},{"problem":28,"code":"(fn f [x]\n  (reduce #(concat %1 (if (coll? %2) (f %2) [%2]))\n  '() x)\n)","user":"5d2201b8e4b02ea6f0fb69ed"},{"problem":28,"code":"(fn f [s] (if-let [x (first s)] (let [z (lazy-seq (f (next s)))] (if (coll? x) (concat (f x) z) (cons x z)))))","user":"549c22f7e4b0f3d1d8e70f86"},{"problem":28,"code":"(fn [xs] (filter #(not (sequential? %)) (tree-seq sequential? identity xs)))","user":"52ee0de4e4b05e3f0be25ec1"},{"code":"(fn flatten2 [i] (reduce \n    (fn [lst x] \n      (if (or (seq? x) (vector? x))\n          (concat lst (flatten2 x))\n          (concat lst [x])\n        )\n      )\n    '() i))","problem":28,"user":"52cdb7efe4b07d0d72b2737c"},{"problem":28,"code":"(fn f [x] (if-not (coll? x) (list x) (mapcat f x)))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn flt [lst]\n  (if (sequential? lst)\n    (mapcat flt lst)\n    (list lst)))","problem":28,"user":"52271a85e4b04e78ff2e19a7"},{"code":"(fn flat [arr]\n  (let [a (first arr) r (rest arr)]\n       (cond \n         (empty? arr) '()\n         (coll? a) (concat (flat a) (flat r))\n         :else (cons a (flat r)))))","problem":28,"user":"4ffe8193e4b0678c553fc3f4"},{"problem":28,"code":"(fn flat [coll]\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s))))))","user":"5545f713e4b0a04f7929953a"},{"problem":28,"code":"(fn twenty-eight [coll]\n  (if (sequential? coll)\n    (mapcat twenty-eight coll)\n    (list coll)))","user":"54f49c39e4b0f2f3c5226e81"},{"problem":28,"code":"(fn ! [x y] (if (coll? y) (reduce ! x y) (conj x y))) []","user":"532dbd3ce4b019098a6f8b40"},{"problem":28,"code":"(fn [coll]\n(seq\n(reduce\n(fn my-flatten [v e]\n(if (coll? e)\n(reduce my-flatten v e)\n(conj v e)))\n[] coll)))","user":"548f3ee4e4b0e286459a1237"},{"problem":28,"code":"(fn flt [s]\n     (if (sequential? s)\n       (mapcat flt s)\n       (list s))\n     )","user":"559ffabae4b0acc240e314ef"},{"code":"(fn flat1\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e2d562c535deb9a81d77f07"},{"problem":28,"code":"(fn fltn [c] \n  (reduce #(if (sequential? %2) \n            (concat % (fltn %2)) \n            (concat % [%2])) \n          ()\n          c))","user":"563b1553e4b0bfe05bf1180a"},{"code":"(fn flat [x] (\n  if (instance? java.util.Collection x)\n     (if (= '() x)\n         x\n         (concat (flat (first x)) (flat (rest x)))\n     )\n     (list x)\n  )\n)","problem":28,"user":"4fcf5292e4b03432b189f40e"},{"problem":28,"code":"(fn flatten-seq [s]\n\t(if (= (count s) 0)\n\t\t'()\n\t\t(if (not (coll? (first s)))\n\t\t\t(cons (first s) (flatten-seq (rest s)))\n\t\t\t(concat (flatten-seq (first s)) (flatten-seq (rest s)))\n\n\t\t\t)\n\t\t)\n\n\t)","user":"5a025edde4b01bb0ae8afd64"},{"problem":28,"code":"(fn fla [s]\n  (println s)\n  (if (and (sequential? s) (> (count s) 0))\n    (concat (fla (first s)) (fla (rest s)))\n    (if (sequential? s) (seq []) (seq [s])) ))","user":"58bc6a88e4b0888cdc949d16"},{"problem":28,"code":"(fn flttn\n  ([x] (flttn x []))\n  ([x coll]\n    (if (coll? x)\n      (apply merge coll (mapcat flttn x))\n      (conj coll x))))","user":"59089229e4b047aa04b1997c"},{"problem":28,"code":"(fn flatten-me\n    ([elems]\n     (flatten-me elems []))\n    ([elems flattened]\n     (if (empty? elems)\n       flattened\n       (let [first-elem (first elems)\n             other-elems (rest elems)]\n         (flatten-me other-elems (if (coll? first-elem)\n                                   (into [] (concat flattened (flatten-me first-elem [])))\n                                   (conj flattened first-elem)))))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":28,"code":"(fn [seq] (loop [suffix seq flat []] (if (empty? suffix) flat (if (coll? (first suffix)) (recur (concat (first suffix) (rest suffix)) flat) (recur (rest suffix) (conj flat (first suffix)))))))","user":"5e1cc888e4b0dc959400853d"},{"problem":28,"code":"(fn my-flatten [l] \n  (loop [l1 l, l2 `()]\n    (cond\n      (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n      (empty? l1) (reverse l2)\n      :else (recur (rest l1) (cons (first l1) l2))\n    )\n  )\n)","user":"56195e57e4b053970a773af6"},{"problem":28,"code":"(fn [collection] \n  ((fn my-flatten [collection, current]\n    (if (coll? current)\n      (reduce my-flatten collection current)\n      (conj collection current)\n    )\n  ) [] collection)\n)","user":"58694f69e4b0f14aab7c889f"},{"code":"#(letfn [(melt [acc coll]\n               (if (empty? coll)\n                 acc\n                 (let [el (first coll)]\n                   (if (coll? el)\n                     (recur (concat acc el) (rest coll))\n                     (recur (concat acc (vector el)) (rest coll))))))\n         (meltdown [coll prev]\n                   (if (= coll prev)\n                     prev\n                     (recur (melt [] coll) coll)))]\n   (meltdown % []))","problem":28,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":28,"code":"(fn f [m]\n  (when (not-empty m)\n    (if (coll? (first m))\n    (concat (f (first m)) (f (rest m)))\n    (cons (first m) (f (rest m))))))","user":"5683d2a9e4b0945ebc182aa0"},{"problem":28,"code":"(fn\n  [seqn]\n  (loop [acc []\n         x nil\n         _seqn (vec seqn)]\n    (if (and (nil? x) \n             (empty? _seqn))\n      acc\n      (if (nil? x)\n        (recur acc (first _seqn) (rest _seqn))\n        (if-not (coll? x)\n          (recur (conj acc x) nil _seqn)\n          (recur acc (first x) ((fn [seqn1 seqn2]\n                                  (loop [acc (vec seqn2) \n                                         _seqn1 seqn1]\n                                         (if (empty? _seqn1)\n                                           acc\n                                           (recur (cons (first _seqn1) acc) (rest _seqn1))))) (rest x) _seqn)))))))","user":"5854580ce4b07779d46863f9"},{"code":";;(fn flat [l]\n;;        (if (= l '())\n;;            '()\n;;          (if(sequential? l)\n;;              (let [x (first l) y (rest l)]\n;;                (if (sequential? x)\n;;                    (concat (flat x) (flat y))\n;;                  (conj (flat y) (flat x))))\n;;            l)))\n\n;; tree-seq will traverse a  tree in depth first manner. Each node it comes accross, it will ask the question:\n;; Is this sequential? If so, it will return seq of that node. For example of the first:\n;; (((1 2) 3 [4 [5 6]]) (1 2) 1 2 3 [4 [5 6]] 4 [5 6] 5 6)\n;; notice that each individual element has been flattened across the list. If we get rid of anything that is a sequence, we can isolate the \n;; atoms.\n;; So if we filter by anything that isn't a sequence, we will return only the atoms. In this case\n;; (1 2 3 4 5 6)\n\n#(filter (complement sequential?)\n         (tree-seq sequential? seq %))","problem":28,"user":"50955676e4b087f34d351ab1"},{"problem":28,"code":"(fn x [collection]\n  (reduce (fn [acc item]\n                    (if (coll? item)\n                        (concat acc (x item))\n                        (concat acc [item])))\n          \t\t[]\n                collection\n              ))","user":"5e84b48ee4b09a7a73c8bbc8"},{"problem":28,"code":"(fn flaty [x] (reduce (fn [res val] (if (coll? val) (concat res (flaty val)) (concat res [val]))) [] x))","user":"5ee4545ee4b029a2061bbe8d"},{"problem":28,"code":"(fn flatten2 [s]\n  (mapcat #(if (coll? %) (flatten2 %) [%]) s))","user":"5545eebee4b0a04f79299539"},{"problem":28,"code":"(fn [ys]\n  (letfn [(go [xs]\n          (if (not (coll? xs)) (list xs)\n              (if (empty? xs) (list)\n                  (concat (go (first xs)) (go (rest xs))))))]\n    (go ys)))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [coll] (filter (complement sequential?) (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4e8dc25f535d65386fec213a"},{"problem":28,"code":"(fn flatten* [x]\n  (if (sequential? x)\n   (if (empty? x)\n     x\n     (concat\n      (flatten* (first x))\n      (flatten* (rest x))))\n   (list x)))","user":"5e50012ae4b027a2e10ac0bd"},{"problem":28,"code":"(fn flat-all [seq]\n  (let [flat-once (fn flat-once [seq]\n                    (apply concat\n                           (map (fn [x] (if (coll? x) \n                                          x\n                                          (list x)))\n                                seq)))]\n    (loop [s seq]\n      (if (every? #(not (coll? %)) s)\n        s\n        (recur (flat-once s))))))","user":"53b88e6ee4b047364c0444de"},{"code":"(fn fl [out, l]\n  (println (str l \" : \" (type l) \" | \" out))\n  (if (coll? l)\n    (if (> (count l) 1)\n\t  (fl  (fl  out (first l)) (rest l))\n\t  (fl out (first l)))\n    (concat out [l]))) '()","problem":28,"user":"50d3b03fe4b030b634c368b9"},{"code":"(fn my-flatten [xs]\n   \t(if (coll? (first xs))\n   \t\t(concat (my-flatten (first xs)) (my-flatten (rest xs)))\n      \t(if (empty? xs)\n          ()\n          (conj (my-flatten (rest xs)) (first xs)))))","problem":28,"user":"52fafd5ce4b047fd55837006"},{"problem":28,"code":"(fn flt [l]\n  (cond\n   (empty? l) l\n   (list? (first l)) (concat (flt (first l)) (flt (rest l)))\n   (vector? (first l)) (concat (flt (first l)) (flt (rest l)))\n   :else (cons (first l) (flt (rest l)))))","user":"5dbbf77ce4b09f47823971ab"},{"code":"; Not very functional... :(\n#(loop [n (last %)\n        stack (into () (butlast %))\n        members '()]\n   (cond\n     (and (nil? n) (empty? stack)) members  ; Base case\n     (sequential? n) (recur (last n) (conj stack (butlast n)) members) ; Branch\n     :else (recur (first stack) (next stack) (if (nil? n) members (conj members n))))) ; Leaf","problem":28,"user":"51057b2be4b06d28cacc92e8"},{"problem":28,"code":"(fn [input]\n                  (let [out (atom '())]\n                    (letfn [(recfn [in]\n                              (if (coll? in)\n                                (doseq [ch in]\n                                  (recfn ch))\n                                (reset! out (cons in @out))))]\n                      (recfn input))\n                    (reverse @out)))","user":"56018dd4e4b04bb52996e18f"},{"problem":28,"code":"(fn [nested_list]\n    (loop [todo nested_list\n           done [] ]\n      (if (empty? todo)\n        done\n        (if (coll? (first todo))\n          (recur (concat (first todo) (rest todo)) done)\n          (recur (rest todo) (conj done (first todo)))))))","user":"592ac17ae4b072a2710fcf26"},{"code":"(fn [mylist]\n  (loop [acc '() old mylist]\n    (cond \n      (empty? old) \n        acc\n      (sequential? (first old))\n        (recur acc (concat (first old) (rest old)))\n      :else  \n        (recur (concat acc [(first old)]) (rest old))\n    )\n  )\n)","problem":28,"user":"501b212ee4b0b12d9c5f4d83"},{"problem":28,"code":"(fn flt [coll]\n  (let [f (first coll) n (next coll)]\n    (concat\n     (if (sequential? f) (flt f) [f])\n     (when (sequential? n) (flt n))\n     )\n    )\n )","user":"584b6a2be4b089d5ab817efd"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (when (not (nil? x))\n  \t(if (coll? (first x))\n    \t(concat (my-flatten (first x)) (my-flatten (next x)))\n    \t(cons (first x) (my-flatten (next x))))))","user":"551c594de4b07993ea3788dc"},{"code":"#(condp = (ffirst %)\n    1 '(1 2 3 4 5 6)\n    \\a '(\"a\" \"b\" \"c\")\n    '(:a))","problem":28,"user":"4e6a4038535d8ccf87e9feb5"},{"code":"(fn [x] (remove coll? (tree-seq coll? vec x)))","problem":28,"user":"4f15de56535d64f603146448"},{"problem":28,"code":"(fn g [xs]\n  (reduce (fn [a b]\n            (concat a (if (coll? b)\n                        (g b)\n                        [b]))) [] xs))","user":"541168dee4b01498b1a719c3"},{"problem":28,"code":"(fn my-flatten [s]\n  (cond\n   (not (coll? s)) (list s)\n   (empty? s) '()\n   :else (concat (my-flatten (first s))\n                 (my-flatten (rest s)))))","user":"551747e0e4b06a49daca83c1"},{"problem":28,"code":"(fn fl [s]\n  (if (not (coll? s)) \n    (list s)\n    (if (empty? s)\n      s\n      (concat  (fl (first s)) (fl (rest s))))))","user":"54b54d1be4b05787c3b1639c"},{"problem":28,"code":"(fn this [x]\n  (if (empty? x)\n    []\n    (let [[v & more] x]\n      (if (coll? v)\n        (concat (this v) (this more))\n        (concat [v] (this more))\n      )\n    )\n  )\n)","user":"547e48bee4b0c51c1f4d7304"},{"problem":28,"code":"(fn f[m]\n  (mapcat #(if (sequential? %) (f %) (list %)) m ))","user":"56fa8984e4b07572ad1a88c1"},{"code":"#(loop [[h & t] %, a []]\n  (if (coll? h)\n    (recur (concat h t) a)\n    (if (not-empty t)\n      (recur t (conj a h))\n      (conj a h))))","problem":28,"user":"4e6a48d5535d8ccf87e9febd"},{"problem":28,"code":"(fn flat [[h & rest]]\n  (when h\n    (if (sequential? h)\n      (concat (flat h) (flat rest))\n      (cons h (flat rest)))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":28,"code":"(fn flatten* [x]\n  (cond \n    (nil? x) ()\n    (coll? x) (mapcat flatten* x)\n    :else [x]))","user":"5e17c269e4b00200644e3d5c"},{"problem":28,"code":"(fn flatten* [ss]\n  (letfn [(sub [r s]\n          (if (not (sequential? s))\n            (cons s r)\n            (reduce sub r s)))]\n    (reverse (sub '() ss))))","user":"560843dee4b046a4fc0ac00e"},{"problem":28,"code":"(fn [coll]\n  (seq\n    (reduce\n      (fn my-flatten [v e]\n        (if (coll? e)\n          (reduce my-flatten v e)\n          (conj v e)))\n      [] coll))\n  )","user":"57a14414e4b0c3d858beb8e4"},{"code":"(fn flat [xs] (if (seq xs)\n                  (if (coll? (first xs))\n                      (concat (flat (first xs)) (flat (rest xs)))\n                      (cons (first xs) (flat (rest xs))))\n                  '()))","problem":28,"user":"4fa38e3fe4b081705acca190"},{"code":"(fn [s] (filter (complement sequential?) (rest (tree-seq sequential? seq s))))","problem":28,"user":"510cba32e4b078ea71921121"},{"code":"(fn [x]  (filter (complement sequential?)          (rest (tree-seq sequential? seq x))))","problem":28,"user":"516ab8c2e4b081287f204e9e"},{"problem":28,"code":"(fn flat\n  [coll]\n    (seq (reduce #(if (coll? %2)\n               (into %1 (flat %2))\n               (conj %1 %2))\n            []\n            coll)))","user":"5e3a8929e4b01d43a70e8de3"},{"code":"#(filter (complement sequential?)\n        (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e814706535db62dc21a62bb"},{"problem":28,"code":"(fn get-level [coll]\n  (loop [input coll\n         output '()]\n    (if (empty? input)\n      output\n      (recur (rest input)\n             (concat output\n                     (if (coll? (first input))\n                       (get-level (first input))\n                       (list (first input))))))))","user":"57a310b4e4b0c3d858beb90c"},{"code":"(fn flat [coll]\n  (loop [acc [] coll coll]\n    (if (empty? coll)\n      acc\n      (if (sequential? (first coll))\n        (recur (vec (concat acc (flat (first coll)))) (rest coll))\n        (recur (conj acc (first coll)) (rest coll))))))","problem":28,"user":"4e22b78b535d04ed9115e81e"},{"code":"(fn flatten-sequence [x]\n      (if (empty? x)\n        []\n        (if (coll? (first x))\n          (concat (flatten-sequence (first x)) (flatten-sequence (rest x)))\n          (concat (list (first x)) (flatten-sequence (rest x))))))","problem":28,"user":"52e17e66e4b09f7907dd1423"},{"code":"#(if (list? (first %))\n   (if (= % '((((:a)))))\n   \t\t'(:a)\n   \t\t'(1 2 3 4 5 6)\n   )\n'(\"a\" \"b\" \"c\"))","problem":28,"user":"51c4690fe4b06b70b3e207e1"},{"problem":28,"code":"(fn _flatten [s]\n  (if (empty? (filter sequential? s))\n    s\n    (_flatten (apply concat (map #(if (sequential? %) % [%]) s)))))","user":"57008afae4b08d47c97781ca"},{"problem":28,"code":"(fn\n   [sequence]\n   (loop\n     [workSequence sequence\n      output '[]]\n     (if (empty? workSequence)\n       output       \n       (if (sequential? (first workSequence))\n         (recur (into (rest workSequence) (reverse (first workSequence))) output)\n         (recur (rest workSequence) (conj output (first workSequence)))))))","user":"55f9b634e4b03cbcff9738c9"},{"problem":28,"code":"(fn [deep_list](loop [deep_list deep_list]\n  (let [flat_list (reduce #(if (sequential? %2)\n                             (into %1 %2)\n                             (conj %1 %2))\n                          [] deep_list)\n        deep_items (filter sequential? flat_list)]\n      (if (> (count deep_items) 0)\n        (recur flat_list)\n        flat_list)\n    )))","user":"5abbb374e4b073f1774426d9"},{"problem":28,"code":"(fn flat [x]\n    (reduce (fn [y z]\n              (if (coll? z)\n                (reduce conj y (flat z))\n                (conj y z)))\n            [] x))","user":"586b6753e4b01531a375e956"},{"code":"(fn [x] \n  (filter (complement sequential?)\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4fceb350e4b03432b189f403"},{"problem":28,"code":"(fn myFlatten [x] (if (coll? x) \n                    (mapcat myFlatten x)\n                    [x]))","user":"5a533cc0e4b05d388ecb6c09"},{"problem":28,"code":"(fn my-flatten [coll]\n                (when (seq coll)\n                  (let [head (first coll)\n                        tail (rest coll)]\n                    (if (coll? head)\n                      (concat (my-flatten head) (my-flatten tail))\n                      (cons head (my-flatten tail))))))","user":"541ae7dbe4b01498b1a71a61"},{"problem":28,"code":"(fn flatten' [xs] \n\t(if (empty? xs)\n\t\t(list)\n\t\t(if (coll? (first xs)) \n\t\t\t(concat (flatten' (first xs)) (flatten' (rest xs)) ) \n\t\t\t(cons (first xs) (flatten' (rest xs)) )\n\t\t)\n\t)\n)","user":"55041b5ee4b086ebe8a79c78"},{"problem":28,"code":"(fn fltn [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (fltn (first s)) (fltn (rest s)))\n        (cons (first s) (fltn (rest s)))))))","user":"576a8d02e4b0a07e8fc18117"},{"problem":28,"code":"(fn my-flatten\n  [xs]\n  (loop [xs xs\n         flattened-xs []]\n    (if-let [x (first xs)]\n      (recur (if (sequential? x)\n               (concat x (rest xs))\n               (rest xs))\n             (if (sequential? x)\n               flattened-xs\n               (conj flattened-xs x)))\n      flattened-xs)))","user":"5c73bcf9e4b0fca0c16227bb"},{"code":"(fn [l]\n  ((fn v [res x]      (cond \n         (coll? x) (if (= (count x) 1) \n                         (v res (first x))\n                         (v (v res (first x)) (rest x)))\n         true (do (conj res x))\n      )\n   ) [] l)\n)","problem":28,"user":"4dad86e0c9a9d6ed0f99dc57"},{"code":"(fn [sq]\n  (let [f (fn [coll]  (mapcat  #(if (sequential? %) % [%]) coll))]\n    (loop [s sq] \n      (if (= s (f s))\n        s\n        (recur (f s))))))","problem":28,"user":"4eadc217535d7eef30807321"},{"problem":28,"code":"(fn f [x]\n  (if (seq x)\n    (let [[fst & rst] x]\n      (if (coll? fst)\n        (concat (f fst) (f rst))\n        (conj (f rst) fst)))\n    '()))","user":"53b42472e4b047364c0444b2"},{"code":"(fn flt [seq]\n  (let [lhs (first seq), rhs (next seq)]\n    (concat (if (sequential? lhs)\n            (flt lhs)\n            [lhs])\n          (when (sequential? rhs)\n            (flt rhs)))))","problem":28,"user":"50d18d00e4b05a71a896ef57"},{"problem":28,"code":"#((fn [i c]\n  (let [head (first c)\n        body (rest c)]\n    (cond\n      (empty? c) i\n      (coll? head) (recur i (concat head body))\n      :else (recur (concat i [head]) body)))) [] %)","user":"56e6d049e4b02e7e935eb6cd"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (cond\n    (empty? coll) coll\n    (sequential? (first coll)) (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n    :else (cons (first coll) (my-flatten (rest coll)))))","user":"5574c172e4b05c286339e059"},{"code":";; Bij de eerste unittest wordt (1 2) alsvolgt 'geconcat':\r\n;; (concat '(1) '(2)) --> (1 2) \r\n;; (reduce concat (map flttn sq)) had ook (mapcat flttn sq) kunnen zijn\r\n;; maar ik vond de 'reduce concat' hier beter leesbaar\r\n(fn flttn [sq]\r\n  (if (sequential? sq)\r\n    (reduce concat (map flttn sq))\r\n    (list sq)))","problem":28,"user":"4f17df72535d64f603146458"},{"problem":28,"code":"(letfn [(f [xs]\n            (cond\n              (= xs '()) '()\n              (coll? xs) (concat (f (first xs)) (f (rest xs)))\n              :else (list xs))\n            )]\n    f)","user":"53f053ebe4b0742d9025b0d3"},{"problem":28,"code":"(fn f[c](if (some coll? c) (f (mapcat #(if (coll? %) % [%]) c)) c))","user":"54e32090e4b024c67c0cf7d9"},{"problem":28,"code":"(fn [x] \n  (filter \n   (complement sequential?) \n   (tree-seq sequential? seq x)\n  )\n)","user":"59c243bae4b0a024fb6ae4aa"},{"problem":28,"code":"(fn [coll]\n  (filter\n   (complement sequential?)\n   (tree-seq sequential? seq coll)))","user":"54b10d08e4b09f271ff37d18"},{"problem":28,"code":"(fn [x]\n    (filter (complement sequential?)\n            (rest (tree-seq sequential? seq x))))","user":"50a3bf08e4b0ceace084d495"},{"problem":28,"code":"(fn f [a-seq]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq a-seq))))","user":"54b972bbe4b0ed20f4ff6ead"},{"code":"mapcat (fn f [s] (if (sequential? s) (mapcat f s) (list s)))","problem":28,"user":"52bad920e4b07a9af57922d7"},{"problem":28,"code":"(fn [coll] \n  (reduce \n   (fn flat [acc x]\n     (if (not (coll? x))\n       (conj acc x)\n       (reduce flat acc x)\n       )\n     )\n   []\n   coll\n   ))","user":"57513f88e4b02ea114799283"},{"code":"(fn [x] \n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)))","problem":28,"user":"50589113e4b06522596eba7f"},{"problem":28,"code":"#(filter (complement sequential?) (rest (tree-seq sequential? identity  %)))","user":"562b57c7e4b058fa18c5a6cc"},{"problem":28,"code":"(fn flat [seq]\n     (let [[x & xs] seq]\n       (cond\n         (empty? seq) '()\n         (coll? x) (concat (flat x) (flat xs))\n         :else (cons x (flat xs)))))","user":"5d4c4de9e4b0776584bd6f2f"},{"code":"(fn flat [coll]\n  (mapcat    \n    (fn [x] \n      (if (coll? x)\n        (flat x)\n        [x]\n      )\n    )\n    coll\n  )\n)","problem":28,"user":"4f03154a535dcb61093f6a58"},{"problem":28,"code":"(fn flt [coll] \n  (let [f (first coll), r (next coll)] \n    ( concat \n      \t(if (sequential? f) \n          (flt f)\n          [f])\n      \t(when (sequential? r) (flt r))\n     )\n  )\n)","user":"547f3434e4b0c51c1f4d7319"},{"problem":28,"code":"(fn flat-seq\n  [arg]\n  (println arg)\n  (if (instance? clojure.lang.Seqable arg)\n    (reduce concat (map flat-seq arg))\n    (vector arg)))","user":"59863a26e4b021a7a535fe87"},{"problem":28,"code":"(fn flat [res sq]\n  (let [fst (first sq)]\n  (if (= (count sq) 0)\n    res\n    (flat \n     (if \n       (or (seq? fst) (vector? fst))\n       (flat res fst)\n       (conj res fst))\n     (rest sq))\n    )))\n[]","user":"56366f73e4b0bfe05bf117cc"},{"problem":28,"code":"(fn _flatten [x]\n  (cond\n    (nil? x) '()\n    (sequential? x) (if (empty? x) '() (concat (_flatten (first x)) (_flatten (rest x))))\n    :else (list x)))","user":"55fb58b2e4b0f488688e0661"},{"code":"(fn f [x] (if (coll? x) (reduce (fn [a b] (concat a b)) (map f x)) (list x)))","problem":28,"user":"4f039f14535dcb61093f6b3e"},{"problem":28,"code":"(fn [xs]\n  (let [iteration (fn iteration [acc ys]\n                    (if (or (seq? ys) (vector? ys))\n                      (if (empty? ys)\n                        acc\n                        (iteration (concat acc (iteration '() (first ys))) (rest ys)))\n                      (cons ys nil)))]\n    (iteration '() xs)))","user":"587100d6e4b01531a375e9f0"},{"problem":28,"code":"(fn flt [coll]\n  (loop [s coll fl ()]\n    (if (empty? s)\n      fl\n      (let [l (first s) rs (rest s)]\n        (if (sequential? l)\n          (recur rs (concat fl (flt l)))\n          (recur rs (concat fl (list l))))))))","user":"52ff6ea0e4b0d8b024fd3707"},{"code":"(fn f [x]\n  (if (sequential? x)\n    (reduce concat (map f x))\n    [x]))","problem":28,"user":"53834ed3e4b06839e8705edb"},{"problem":28,"code":"(fn fltn [lst] (cond (empty? lst) lst\n                     (or (list? (first lst)) (vector? (first lst))) (concat (fltn (first lst)) (fltn (rest lst)))\n                     true (conj (fltn (rest lst)) (first lst))))","user":"55c20bd0e4b0e31453f64972"},{"code":"(fn flat [coll]\n  (reduce (fn [acc item]\n            (if (sequential? item)\n              (into acc (flat item))\n              (conj acc item)))\n          []\n          coll))","problem":28,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn flat [xs]\n  (reduce (fn [val x]\n    (if (or (number? x) (keyword? x) (string? x))\n      (concat val (list x))\n      (concat val (flat x)))) '() xs))","problem":28,"user":"4f0381db535dcb61093f6b02"},{"problem":28,"code":"(fn flat[s]\n  (loop [tail s\n         r []]\n    (if (empty? tail)\n      r\n      (if (sequential? (first tail))\n        (recur (rest tail) (concat r (flat (first tail))))\n        (recur (rest tail) (concat r [(first tail)]))))))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":28,"code":"(fn flatten' [xs] (reduce #(if (sequential? %2) (concat %1 (flatten' %2)) (concat %1 [%2])) (empty xs) xs))","user":"54d03026e4b018d918be98de"},{"code":"(fn [coll]\n  (filter (complement coll?) (tree-seq coll? seq coll)))","problem":28,"user":"4f0348b4535dcb61093f6a84"},{"problem":28,"code":"(fn flat [llist]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (vec (concat acc (flat x)))\n              (conj acc x))) [] llist))","user":"5cfabf53e4b0cc9c91588148"},{"code":"(fn [tree]\n  (filter #(not (coll? %)) \n    (tree-seq coll? identity tree)))","problem":28,"user":"4ee3afde535d10e5ff6f5370"},{"code":";(fn myflat [x]\n;  (when-let [s (seq x)]\n;    (let [x (first s) y (rest s)]\n;     (if (sequential? x)\n;       (concat (myflat x) (myflat y))\n;       (cons x (myflat y))))))\n(fn myflat [x] (mapcat #(if (coll? %) (myflat %) [%]) x))","problem":28,"user":"502bb7c0e4b0194ad32ea1a3"},{"code":"(fn fltn [seq]\n  ( reduce \n    (fn [acc, x] \n      ( if ( coll? x )\n        (concat acc (fltn x))\n        (concat acc (list x))\n      )\n    ) \n    () \n    seq ) )","problem":28,"user":"5026916fe4b0c969f0b056e1"},{"problem":28,"code":"(fn [x]\n  (loop [input-list x\n         output-list []\n         reserve []]\n    (cond\n      (and (empty? input-list) (empty? reserve)) output-list\n      (and (empty? input-list) (not (empty? reserve))) (recur reserve output-list [])\n      (not (coll? (first input-list))) (recur (rest input-list) (concat output-list [(first input-list)]) reserve)\n      (coll? (first input-list)) (recur (first input-list) output-list (rest input-list)))))","user":"5550dad4e4b00713264bd9b0"},{"problem":28,"code":"(fn foo [x] (if (coll? x) \n              (if (empty? x) \n                () \n                (concat (foo (first x)) (foo (rest x)))\n                )\n              (list x)))","user":"5520974be4b08d5046aa8a63"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n       (flt r)))))","problem":28,"user":"52b66d98e4b0c58976d9ad46"},{"code":"(fn plainer [coll]\n  (seq ((fn myloop [coll]\n\t\t  (loop [i 0 col (vec coll) new []]\n\t\t     (if (= i (count col))\t\t\t \n\t\t\t\t\t\t new\n\t\t\t\t\t\t (let [cur (nth col i)]\n\t\t\t\t\t\t      (cond \n\t\t\t\t\t\t\t\t\t\t\t(coll? cur) \n\t\t\t\t\t\t\t\t\t\t\t   (recur (inc i) col (vec (concat new (myloop cur))))\n\t\t\t\t\t\t\t\t\t\t\t:else \n\t\t\t\t\t\t\t\t\t\t\t   (recur (inc i) col (conj new cur))))))) coll )))","problem":28,"user":"4e739e13535dff18050a9c76"},{"problem":28,"code":"(fn\n  [lst]\n  (letfn\n      [(f\n         [coll]\n         (reduce (fn [new-coll item]\n                   '(1)\n                   (cond\n                     (coll? item) (apply conj new-coll (reverse (f item)))\n                     :else (conj new-coll item))\n                   )\n                 ()\n                 coll))]\n    (reverse (f lst))))","user":"56e22366e4b03a7c14b85a30"},{"problem":28,"code":"(fn flatten2 [x] (if (sequential? x) (mapcat flatten2 x) (list x)))","user":"534fa9dae4b084c2834f4acf"},{"code":"(fn ! [xs] \n  (println (str \"Entered with xs = \" xs))\n  (if (coll? xs)\n    (reduce #(concat %1 (! %2)) '() xs)\n    (list xs)))","problem":28,"user":"51780bfce4b0f89a8f53839c"},{"problem":28,"code":"(fn fl [coll] (if (coll? coll) (mapcat fl coll) [coll]) )","user":"55249f64e4b0882d96d091c6"},{"problem":28,"code":"(fn fltn [c] (if (coll? c) (mapcat fltn c) (list c)))","user":"600cb742e4b074f607df6696"},{"code":"(fn [s]\n   (loop [s s, r []]\n     (if (seq s)\n       (if (coll? (first s))\n         (recur (concat (first s) (rest s)) r)\n         (recur (rest s) (conj r (first s))))\n       r)))","problem":28,"user":"4f301d02e4b0d6649770a072"},{"code":"(fn x [c] (mapcat #(if (sequential? %) (x %) (list %)) c))","problem":28,"user":"4e111538535d04ed9115e7c3"},{"code":"(fn fltn [s]\n    (loop [s s\n           res []]\n      (if (empty? s)\n        res\n        (if (coll? (first s))\n          (recur (rest s)\n                 (apply conj res (fltn (first s))))\n          (recur (rest s)\n                 (conj res (first s)))))))","problem":28,"user":"4e59b02c535d8a8b8723a2a2"},{"code":"(fn flat [x]\n  (if (not (coll? x))\n    (list x)\n    (if (= x '())\n      '()\n      (if (not (coll? (first x)))\n        (conj (flat (rest x)) (first x))\n        (concat (flat (first x)) (flat (rest x)))\n      )\n    )\n  )\n)","problem":28,"user":"4fa7ef54e4b081705acca1ca"},{"code":"(fn flatten2 [coll]\n  (if (sequential? coll)\n    (mapcat flatten2 coll)\n    (list coll)))","problem":28,"user":"5383668ee4b06839e8705edd"},{"problem":28,"code":"(fn flat \n  [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flat l)\n        [l])\n      (when (sequential? r)\n        (flat r)))))","user":"57210e8ee4b0c5bde472c0a8"},{"problem":28,"code":"(fn flatn [s]\n  (mapcat\n   #(if (sequential? %)\n      (flatn %)\n      (list %))\n   s))","user":"54db0ab8e4b024c67c0cf75a"},{"problem":28,"code":"(fn lflatten [col]\n    (cond\n      (not (coll? col))  [col]\n      (empty? col)       []\n      :else              (concat (lflatten (first col)) (lflatten (rest col))))\n    )","user":"57aa290de4b0b8559636fc65"},{"problem":28,"code":"(fn flt[coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n     (if (sequential? l)\n     \t(flt l)\n     \t[l])\n     (when (sequential? r)\n       (flt r)))))","user":"53e2381ce4b036ad0777e3ee"},{"problem":28,"code":"(fn my-flatten \n  ([lst] (my-flatten lst nil))\n  ([lst acc] \n   (cond  (= '() lst) acc \n\t  (not (sequential? lst)) (cons lst acc)\n\t  true (my-flatten (first lst) (my-flatten (rest lst) acc)))))","user":"546c1f73e4b00cfc9eacc175"},{"problem":28,"code":"(fn flatten' [x]\n    (cond \n        (empty? x)\n            []\n        (sequential? (first x))\n            (concat (flatten' (first x)) (flatten' (rest x)))\n        :else\n            (concat [(first x)] (flatten' (rest x)))\n    )\n)","user":"577aacf2e4b0d3393e5deb03"},{"code":"(fn aux [s]\n  (if (coll? s)\n    (reduce into [] (map aux s))\n    (seq [s])))","problem":28,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":28,"code":"(fn flat [s]\n  (let [x (first s) xs (rest s)]\n    (cond\n     \t(empty? s) nil\n     \t((complement sequential?) x) (cons x (flat xs))\n     \t:else (concat (flat x) (flat xs)))))","user":"5689fd03e4b0dcc4269f4088"},{"problem":28,"code":"(fn my-flatten [coll]\n\t(if (sequential? coll)\n\t\t(mapcat my-flatten coll)\n\t\t(list coll)))","user":"55b8c339e4b01b9910ae29b9"},{"problem":28,"code":"(fn myfalten [coll]\n  (if (sequential? coll)\n    (mapcat myfalten coll)\n    [coll]))","user":"5707abfce4b0b0fb43fd068d"},{"problem":28,"code":"(fn [x] (reverse (loop [i (->(str x)\n                             (clojure.string/replace #\"[\\(\\)\\[\\]\\{\\}]\" \"\")\n                             (.split \" \"))\n                                  index 0 coll '()] (if (>= index (count i)) coll (recur i (+ 1 index) (list* (read-string (nth i index)) coll))))))","user":"5924009ce4b072a2710fce45"},{"code":"(fn myfn [coll]\n   (if (sequential? coll)\n     (mapcat myfn coll)\n     (list coll)))","problem":28,"user":"531d34cfe4b08068f379edac"},{"problem":28,"code":"(fn myflatten [x]\n  (if (empty? x)\n    '()\n    (let [f (first x)]\n      (if (or (list? f) (vector? f))\n       (concat (myflatten f) (myflatten (rest x)))\n       (cons f (myflatten (rest x)))))))","user":"54651982e4b01be26fd746d4"},{"code":"(fn fltn [elems] \n  \n  \n   (if (empty? elems) elems\n    (let [x (first elems) \n          xs (rest elems)]\n      (cond\n       (not (coll? x)) (cons x (fltn xs))\n       (empty? x) (fltn xs)\n       :else (concat (fltn x) (fltn xs))\n       )\n      )\n    )\n  )","problem":28,"user":"52deb735e4b09f7907dd13f7"},{"code":"(fn [coll]\n  (let [nodes (tree-seq sequential? identity coll)]\n    (filter (complement sequential?) nodes)\n    )\n  )","problem":28,"user":"5201ada5e4b0b2e020a18f14"},{"problem":28,"code":"(fn [coll]\n  (loop [coll coll\n         list-stack '()\n         acc []]\n    (if (empty? coll)\n      (if (empty? list-stack)\n        acc\n        (recur (peek list-stack)\n               (pop list-stack)\n               acc))\n        (cond\n          (sequential? (first coll)) (recur (first coll)\n                                            (conj list-stack (rest coll))\n                                            acc)\n          :else  (recur (rest coll)\n                       list-stack\n                       (conj acc (first coll)))\n          )\n        )\n    )\n  )","user":"5ee738dee4b029a2061bbea2"},{"problem":28,"code":"(fn flat\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"57762befe4b0979f8965162f"},{"code":"(fn c [s] (if (sequential? s) (mapcat c s) [s]))","problem":28,"user":"4f08b15b535dcb61093f6c40"},{"problem":28,"code":"(fn [coll]\n  (reduce\n   (fn flatter [acc x]\n     (if (coll? x)\n       (reduce flatter acc x)\n       (conj acc x)))\n   [] coll))","user":"55088bb3e4b06e50f9beb10c"},{"problem":28,"code":"#(remove sequential? (tree-seq coll? seq %))","user":"57af41bce4b0fbc9809a2731"},{"problem":28,"code":"(fn fl [l]\n (if (sequential? l)\n   (mapcat fl l)\n   [l]\n   ))","user":"542a7c9be4b01498b1a71b41"},{"code":"(fn flat [c]\n          (if (sequential? c)\n            (mapcat flat c)\n            (list c)))","problem":28,"user":"52d6a9c2e4b09f7907dd1365"},{"code":"(fn f [s] \n  (if \n    (sequential? s)\n    (mapcat f s)\n    (list s)\n  )\n)","problem":28,"user":"5209cb44e4b0e152394d7702"},{"problem":28,"code":"(fn Flatten [coll]\n  (when-let [s (seq coll)]\n    (let [f (first s)]\n      (if (sequential? f)\n        (concat (Flatten f) (Flatten (rest s)))\n        (cons f (Flatten (rest s)))))))","user":"57934c67e4b0e215f87e8456"},{"code":"(fn f[l](lazy-seq (mapcat #(if (sequential? %) (f %) [%]) l)))","problem":28,"user":"51b793d3e4b0d906fcd71d38"},{"code":"(fn [toFlatten]\r\n          (let [consume-next (fn consume-next [result remainder]\r\n       (let [split-first-item (fn split-first-item [coll] \r\n               (let [head (first coll)\r\n\t             vectorise (fn [x] (if (sequential? x) (vec x) [x]))\r\n\t             conjoin-items (fn [to & intos] (reduce into to intos))\r\n\t         ]\r\n\t         (if (not (sequential? head))\r\n\t           coll\r\n\t           (conjoin-items\r\n\t             (vectorise (first head)) \r\n\t             (vectorise (rest head)) \r\n\t             (vectorise (rest coll))\r\n\t           )\r\n\t         )\r\n               ))\r\n\t       flatter (split-first-item remainder)] \r\n\t       (if (= (count remainder) 0)\r\n\t\t result\r\n\t         (if (sequential? (first flatter))\r\n\t           (consume-next result flatter)\r\n\t\t   (consume-next (conj result (first flatter)) (rest flatter))\r\n\t    ))))]\r\n\t    (list* (consume-next [] toFlatten))))","problem":28,"user":"4ef60a02535dced4c769f24b"},{"problem":28,"code":"(fn my-flatten [s] (reduce #(concat %1 (if (sequential? %2) (my-flatten %2) (list %2))) '() s))","user":"5453b522e4b0e397800069d0"},{"problem":28,"code":"(fn [old & new]\n  (if (nil? new)\n    (recur old [])\n    (if (nil? (first old))\n     new\n      (if (coll? (first old))\n        (if (empty? (first old))\n          (recur (rest old) new)\n          (recur (cons (first (first old)) (cons (rest (first old)) (rest old))) new)\n        )       \n        (recur (rest old) (conj new (first old)))\n      )\n    )            \n  )    \n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"problem":28,"code":"(fn lisflat [x]\n    (cond \n      (nil? x) (list -100)\n      \n      (or (seq? x) (vector? x))\n          (cond \n            (nil? (first x)) (list  )\n            :else (concat\n              (lisflat (first x))\n              (lisflat (rest x))\n            )\n          ) \n      :else (list x)\n    )\n  )","user":"5e1d01b5e4b0dc9594008542"},{"code":"(fn [x]\n  (letfn [(my-flatten [xs]\n    (if (empty? xs) nil\n    (concat\n     (if (sequential? (first xs))\n       (my-flatten (first xs)) \n       (list (first xs)))\n     (my-flatten (rest xs)))))] \n    (my-flatten x)))","problem":28,"user":"525078b6e4b0541d1855b832"},{"code":"(fn [coll]\n  (filter #(not (sequential? %))\n    (rest (tree-seq sequential? seq coll))))","problem":28,"user":"515a6151e4b0394f658fe241"},{"code":"(fn flat [xs] \n  (cond (empty? xs) '()\n        (sequential? (first xs))\n          (concat (flat (first xs))\n                  (flat (rest xs)))\n        :else (cons (first xs) (flat (rest xs)))))","problem":28,"user":"5055e7f4e4b0ce54f56f0401"},{"problem":28,"code":"(fn nut [xs]\n  (if (sequential? xs)\n    (mapcat nut xs)\n    (list xs)))","user":"5668dcc6e4b04acd4f672df8"},{"code":"(fn f [x]\n  (if (coll? x)\n    (mapcat f x) [x]))","problem":28,"user":"4e1f9bb5535d04ed9115e80d"},{"problem":28,"code":"(fn mflatten [coll]\n  (lazy-seq\n    (when (seq coll)\n      (if (coll? (first coll))\n        (concat (mflatten (first coll)) (mflatten (rest coll)))\n        (cons (first coll) (mflatten (rest coll)))))))","user":"52606318e4b03e8d9a4a7036"},{"problem":28,"code":"(fn foo[x] (cond (= (str(type x)) \"class java.lang.Long\") (list x)\n                  (= (str(type x)) \"class java.lang.String\") (list x)\n                  (= (str(type x)) \"class clojure.lang.Keyword\") (list x)\n                  (> (count x) 1) (concat (foo(first x)) (foo(rest x) )    )\n                  (= (count x) 1) (foo(first x))\n))","user":"5eb94f6fe4b00a66d4a9524b"},{"code":"(fn [s]\n  (filter\n   (complement sequential?)\n   (rest\n    (tree-seq sequential? seq s))))","problem":28,"user":"4ecb1641535d6d7199dd370e"},{"problem":28,"code":"(fn flt [x]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)))","user":"6020365ae4b0bf4ca6b10960"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reverse (reduce (fn [acc x]\n               \t(if (coll? x)\n                 (apply conj acc (my-flatten x))\n                 (conj acc x)))\n          nil\n          coll)))","user":"5622af0fe4b03f08ee9a922b"},{"problem":28,"code":"(fn flat[coll]\n  (if (empty? coll)\n    []\n    (let [head (first coll)\n          tail (rest coll)]\n      (concat (if (coll? head)\n                (flat head)\n                [head])\n              (flat tail)))))","user":"5978305be4b01722bebd4d03"},{"code":"(fn f [x]\n    (mapcat #(if (coll? %) (f (seq %)) [%]) x))","problem":28,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":28,"code":"(fn f [l] (reduce into [] (map #(if (sequential? %) (f %) (list %)) l)))","user":"56598476e4b068f2fe63dbec"},{"code":"(fn [s]\n  (letfn [(f [s acc]\n            (or (and (empty? s) acc) \n                (and (coll? (first s))\n                     (f (rest s) (f (first s) acc)))\n                (f (rest s) (cons (first s) acc))))]\n    (reverse (f s '()))))","problem":28,"user":"50ba4b9ee4b03e68e4411c7b"},{"code":"(fn f [x]\n  (if (empty? x)\n    x\n    (if (sequential? (first x))\n      (concat (f (first x))\n              (f (rest x)))\n      (cons (first x)\n            (f (rest x))))))","problem":28,"user":"50bf6f93e4b0ffd967a66cbf"},{"problem":28,"code":"#(->> %\n      (reduce (fn flat [v x]\n                (if (coll? x)\n                  (reduce flat v x)\n                  (conj v x)))\n              [])\n      (seq))","user":"594bdadce4b07ddc2dafae43"},{"code":"(fn flat \n  ([c]\n   (flat c '()))\n  ([pre post]\n   (if (empty? pre)\n     post\n     (let [a (first pre)]\n       (if (coll? a)\n         (flat (concat a (rest pre)) post)\n         (flat (rest pre) (concat post [a])))))))","problem":28,"user":"52046600e4b0c283853240c5"},{"problem":28,"code":"(fn flat\n  [l]\n  (let [f (first l)]\n    (if (empty? l) []\n        (if (sequential? f) (concat (flat f) (flat (rest l))) (cons f (flat (rest l)))))))","user":"5b679bf9e4b0c6492753e769"},{"problem":28,"code":"(fn flt[xs] (reduce #(if (coll? %2) (vec (concat %1 (flt %2))) (conj %1 %2)) [] xs))","user":"5602ab92e4b04bb52996e1a3"},{"problem":28,"code":"(fn [coll]\n   (let [res (reduce (fn [acc c]\n                       (if (coll? c)\n                         (conj (seq c) acc)\n                         (reverse (conj (reverse acc) c))\n                         )\n                       )\n                     coll\n                     )]\n     (if (some coll? res)\n       (recur res)\n       res)\n     )\n\n   )","user":"59a5b3f4e4b066c664927d69"},{"problem":28,"code":"(fn [s] (filter (complement sequential?)  (tree-seq sequential? seq s)))","user":"57487084e4b009280f9f2b8c"},{"code":"(fn flat [lst]\n  (if (empty? lst) \n      '()\n      (let [hed (first lst)]\n        (cond (seq? hed) (concat (flat hed) (flat (rest lst)))\n              (vector? hed) (concat (flat hed) (flat (rest lst)))\n              :else (conj (flat (rest lst)) hed)))))","problem":28,"user":"4f07ad89535dcb61093f6c2a"},{"problem":28,"code":"(fn flatten-a-sequence [s]\n  (reduce #(if (coll? %2)\n                     (apply conj %1 (flatten-a-sequence %2))\n                     (conj %1 %2))\n           []\n           s))","user":"5f2d6bc4e4b033932238a66e"},{"problem":28,"code":"(fn flatten3 [x]\n  (if (coll? x)\n    (mapcat flatten3 x)\n    [x]))","user":"5a1bec89e4b0ff51aa4b322f"},{"code":"(fn my-flatten [l]\n  (let [[f & r] l]\n    (cond (empty? l) ()\n          (sequential? f) (concat (my-flatten f) (my-flatten r))\n          :else (cons f (my-flatten r)))))","problem":28,"user":"51baff1be4b0fe3ecfb46443"},{"code":"(fn fflat [l]\n  (if (instance? java.util.Collection l)\n    (concat\n     (fflat (first l))\n     (if (< 1 (count l)) (fflat (rest l)))\n     )\n    (list l)))","problem":28,"user":"51684318e4b03f62cda68cd6"},{"code":"(fn flat [xs]\n  (cond\n    (empty? xs) xs\n    :else (let [[y & ys] xs]\n      (cond\n        (coll? y) (concat (flat y) (flat ys))\n        :else (cons y (flat ys))))))","problem":28,"user":"4ecab3b7535d6d7199dd3709"},{"problem":28,"code":"(fn \n  [x] \n  (filter \n   (complement sequential?) \n   (rest (tree-seq sequential? seq x))))","user":"5461dc79e4b01be26fd746a8"},{"problem":28,"code":"(fn [seq]\n  (let [help (fn h [s accum]\n               (cond (empty? s) accum\n                     (sequential? (first s)) (concat (h (first s) accum) (h (rest s) accum))\n                     :else (concat [(first s)] (h (rest s) accum))))]\n               (help seq [])\n    )\n  )","user":"554dff83e4b00713264bd98d"},{"code":"#(filter\n  (complement sequential?)\n  (rest (tree-seq sequential? seq %)))\n;I have no idea what is going on here.\n;filter takes a function (complement... and a list (rest...\n;but the 'rest' command is called, which usually truncates the list passed to it.\n;the list passed to it is a tree sequence.  so does the tree-seq create some duplicate\n;first value?  according to the docs, it does not, so why skip it?","problem":28,"user":"519126d5e4b0f8ef0be96bff"},{"code":"(fn my-flatten [coll]\n  (mapcat #(if (coll? %) (my-flatten %) [%]) coll))","problem":28,"user":"4e7c8fd1535db169f9c796be"},{"problem":28,"code":"(fn [coll]\n  (loop [[fst & rst :as coll] coll\n         acc []]\n    (if (seq coll)\n      (if (sequential? fst)\n        (let [[a & b] fst]\n          (recur (cons a (concat b rst)) acc))\n        (recur rst (conj acc fst)))\n      acc)))","user":"4f5599dfe4b0a7574ea71806"},{"problem":28,"code":"(fn flatten* [x]                                                               \n  (if (coll? x)                                                                  \n    (mapcat flatten* x)                                                          \n    [x]))","user":"58ebd10de4b056aecfd47d49"},{"code":"(fn flt [x]\r\n  (mapcat \r\n    #(if-not (sequential? %)\r\n      [%]\r\n      (flt %))\r\n    x)\r\n  )","problem":28,"user":"4febb4dae4b0681fd128dc98"},{"code":"(fn flat [col]\n  (reduce #(if (coll? %2)\n         (concat %1 (flat %2))\n         (conj (vec %1) %2))[] col))","problem":28,"user":"4ef992c8535dced4c769f268"},{"problem":28,"code":"(fn yflat [coll] (mapcat #(if (sequential? %) (yflat %) [%])  coll))","user":"54caaa48e4b057c6fda3a267"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq %1)))","problem":28,"user":"4ee8092f535d93acb0a66875"},{"code":"(fn flattensq [xs]\n  (reduce #(if (coll? %2) (vec (concat %1 (flattensq %2))) (conj %1 %2)) [] xs))","problem":28,"user":"5370f8ede4b0fc7073fd6ea2"},{"problem":28,"code":"(fn f [x]\n  (if (sequential? x)\n    (mapcat f x)\n\t(list x)))","user":"5537cbaee4b09218d5f44fd3"},{"problem":28,"code":"(comp reverse\n       (fn fltn\n         ([coll]\n            (fltn '() coll))\n         ([out-seq coll]\n            (if-not (coll? coll)\n              (cons coll out-seq)\n              (let [in-seq (seq coll)]\n                (if-not (seq in-seq)\n                  out-seq\n                  (fltn (fltn out-seq (first in-seq)) (rest in-seq))))))))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn [s] (filter #(not (coll? %)) (rest (tree-seq coll? seq s))))","problem":28,"user":"5235a902e4b0a643f2dcb750"},{"code":"#(loop [acc ()\n        [e & more] %]\n   (if (nil? e)\n     (reverse acc)\n     (if (coll? e)\n       (recur acc (concat e more))\n       (recur (conj acc e) more))))","problem":28,"user":"4db29f98535df7e46ed9b6c1"},{"problem":28,"code":"(fn ! [coll]\n    (apply concat\n           (map (fn [item]\n                  (if (coll? item)\n                    (! item)\n                    (list item)))\n                coll)))","user":"59225498e4b09b4ee5954c8c"},{"code":"(fn f [x]\n  (if (and (sequential? x) (seq x))\n    (concat (f (first x)) (f (rest x)))\n    (if (seq? x) [] [x])))","problem":28,"user":"4fd2789ee4b04c3a95aa0422"},{"code":"(fn [x]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq x)))\n)","problem":28,"user":"4f00f997535dcb61093f6a34"},{"problem":28,"code":"(fn norm [n]\n    (let [[x & lst] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (norm x) (norm lst))\n     :else (cons x (norm lst)))))","user":"607f3336e4b05857a65e7747"},{"problem":28,"code":"(fn fff[x]\n              (if (and (coll? x) (some coll? x))\n                (reduce concat [] (map fff x))\n                (if (coll? x) x (vector x))))","user":"54d05a9de4b0e8a36923e5c7"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (mapcat my-flatten s)\n    [s]))","user":"550c55d0e4b06e50f9beb14d"},{"problem":28,"code":"(fn flat [lst]\n  (if (empty? lst)\n    lst\n    (let [x (first lst)\n          xs (rest lst)\n          first (if (sequential? x) (flat x) [x])\n          rest (if (empty? xs) xs (flat xs))]\n      (concat first rest))))","user":"553698fae4b09218d5f44fc0"},{"problem":28,"code":"(fn flat [a]\n  (if (coll? a)\n    (if (not (empty? a))\n\t\t(concat (flat (first a)) (flat(rest a)))\n\t\t[]\n\t)\n\t[a]\n  )\n)","user":"54c9f165e4b045293a27f687"},{"problem":28,"code":"#(filter\n   (complement sequential?)\n   (tree-seq sequential? seq %))","user":"58b3388ae4b0ebc645576d1e"},{"problem":28,"code":"(fn [s]\n  (filter (complement sequential?)\n    (tree-seq sequential? identity s)))","user":"557a1e18e4b05c286339e09e"},{"problem":28,"code":"(fn my-flat\n  [s]\n  (if (sequential? s)\n    (mapcat my-flat s)\n    [s]))","user":"5f816cc6e4b0c071e6c840f1"},{"problem":28,"code":"(fn [l] (filter (complement sequential?) (rest (tree-seq sequential? seq l))))","user":"56791447e4b05957ce8c6183"},{"code":"#(filter (complement sequential?) (tree-seq sequential? seq % ))","problem":28,"user":"4f542fd9e4b0a7574ea717db"},{"code":"(fn flat [coll]\n    (if (sequential? coll)\n        (mapcat flat coll)\n        (list coll)))","problem":28,"user":"52713288e4b03e8d9a4a73e7"},{"code":"(fn f [s]\n  (loop [ret '() s_ s]\n    (if s_\n      (let [a (first s_)]\n        (recur\n          (if (coll? a)\n            (apply conj ret (f a))\n            (conj ret a))\n          (next s_)))\n     (into '() ret))))","problem":28,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn flat [coll]\n  (let [h (first coll), t (next coll)]\n    (concat\n      (if (sequential? h)\n        (flat h)\n        [h])\n      (when (sequential? t)\n        (flat t)))))","problem":28,"user":"506755b3e4b03d366d7cb2bc"},{"problem":28,"code":"(fn fl [arr]\n  (if (not (coll? arr))\n    (list arr)\n        (loop [x arr rez '()]\n          (if (empty? x)\n            rez\n            (recur (rest x) (concat rez (fl (first x)))\n          )\n        )\n    )\n  )\n)","user":"541404c2e4b01498b1a719e7"},{"problem":28,"code":"(fn fl [coll]\n    (mapcat #(if (sequential? %)\n               (fl %)\n               [%])\n            coll))","user":"58a2b57fe4b02bd94d917ede"},{"code":"(fn [l] \n  (loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","problem":28,"user":"538d7e2ee4b0b51d73faae70"},{"problem":28,"code":"#((fn my-flatten [s r]\n(cond\n  (sequential? s) (if (empty? s) r (my-flatten (rest s) (my-flatten (first s) r)))\n  :else (conj r s))) % [])\n;; sequential? = (or seq? vector?)","user":"525b142fe4b0cb4875a45d05"},{"problem":28,"code":"(fn flat[iter] \n  (let [f (first iter)\n        r (rest iter)]\n    (cond (empty? iter) nil\n          ((complement sequential?) f) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"554f817ce4b00713264bd9a2"},{"problem":28,"code":"(fn newFlatten\n  [lista]\n  (mapcat #(if (coll? %) (newFlatten %) [%]) lista))","user":"56fe2a2fe4b08d47c97781ad"},{"code":"(fn f [expr] (cond (coll? expr) (concat (f (first expr)) (f (next expr)))\n                   (nil? expr) []\n                   :else [expr]))","problem":28,"user":"4f2cdd42e4b0d6649770a055"},{"problem":28,"code":"(fn fl [x] (if (coll? x) (if (= (count x) 1) (fl (first x)) (concat (fl (first x)) (fl (rest x))) ) [x]))","user":"5c54e605e4b0fb8c5ffd9a14"},{"code":"(fn fl [xs] (mapcat (fn [x] (if (coll? x) (fl x) (list x))) xs))","problem":28,"user":"4f037bb5535dcb61093f6aec"},{"problem":28,"code":"(fn my-flatten [lst]\n  (cond\n    (empty? lst) ()\n    (coll? (first lst))\n           (concat (my-flatten (first lst)) (my-flatten(rest lst)))\n           :else (cons (first lst) (my-flatten (rest lst)))))","user":"56df6498e4b0ca2494a095f8"},{"problem":28,"code":"(fn [xs] ((fn flat\n            ([xs] (flat xs ()))\n            ([xs result] (if (empty? xs)\n                          result\n                          (if (coll? (first xs))\n                            (recur (into (rest xs) (reverse (first xs))) result)\n                            (recur (rest xs) (concat result (vector (first xs)))))))) xs))","user":"540d5ab9e4b0addc1aec670f"},{"problem":28,"code":"#(loop [items %1 acc []]\n   (if (= 0 (count items)) acc\n     (let [i0 (first items)\n           i1 (into [] (rest items))]\n       (if (coll? i0)\n         (if (< 0 (count i1))\n           (recur (conj (into [] i0) i1) acc)\n           (recur i0 acc))\n         (recur i1 (conj acc i0))))))","user":"58a31ecee4b02bd94d917ee7"},{"problem":28,"code":"(fn flat [v]\n  (if (sequential? v)\n    (if (seq v)\n      (let [f (first v)\n            r (rest v)]\n        (concat (flat f) (flat r)))\n     v)\n   [v]))","user":"52c1ede2e4b07a9af579236d"},{"code":"(fn [lst]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq lst))))","problem":28,"user":"4f608e38e4b0defedf855fa8"},{"problem":28,"code":"(fn my-flatten\n  ([el] (my-flatten '() el))\n  ([acc el]\n    (if (coll? el)\n      (reduce my-flatten acc el)\n      (concat acc (list el)))))","user":"548c8115e4b0e286459a120c"},{"problem":28,"code":"(fn [s]\n  (reverse (reduce (fn rec-flatten [new-s x]\n                     (if (coll? x)\n                       (reduce rec-flatten new-s x)\n                       (conj new-s x)))\n                   '()\n                   s)))","user":"5ed875abe4b016b56eae05f2"},{"problem":28,"code":"(fn fl \n            [sequ]\n            (if \n                (coll? sequ)\n                (if \n                    (not-any? coll? sequ)\n                    sequ\n                    (apply concat (map fl sequ))\n\n                )\n                (vector sequ)\n            )\n        )","user":"5e23ca7fe4b05b4b01516144"},{"problem":28,"code":"#(filter (complement sequential?)    (rest (tree-seq sequential? seq %)))","user":"55b0ecb7e4b002ce9d5cbc27"},{"code":"(fn flattenn [coll]\n  (if (empty? coll)\n    nil\n    (let [h (first coll)]\n      (concat (if (coll? h) (flattenn h) (conj () h)) (flattenn (rest coll))))))","problem":28,"user":"4ed45563535d10e5ff6f52c9"},{"problem":28,"code":"(fn flat2 [x] \n  (let [f (first x)\n      r (rest x)]\n     (cond (empty? x) nil\n            ((complement sequential?) f) (cons f (flat2 r))\n            :else (concat (flat2 f) (flat2 r)))))","user":"5a40eb64e4b0447ef91cc5d8"},{"code":"(fn [coll]\n   (loop [res [] coll coll]\n      (if (empty? coll)\n         res\n         (if (#(not (or (list? %) (vector? %) (seq? %))) (first coll))\n            (recur (conj res (first coll)) (rest coll))\n            (recur res (concat (first coll) (rest coll)))))))","problem":28,"user":"4fb99483e4b081705acca2da"},{"problem":28,"code":"(fn f [s]\n  (cond\n    ;;\n    (or (nil? s) (empty? s)) s\n    ;;\n    (not (coll? s)) (list s)\n    ;;\n    (not (coll? (first s)))\n    (concat (list (first s)) (f (rest s)))\n    ;;\n    :else\n    (concat (f (first s)) (f (rest s)))))","user":"54bd9a60e4b0ed20f4ff6ee3"},{"code":"(fn ! [coll]\n  (if (sequential? coll)\n    (mapcat ! coll)\n    (list coll)))","problem":28,"user":"52c3b3e5e4b0c2d177d620c8"},{"code":"#(let [walk (fn walk [node]\n  (cons node (when (sequential? node) (mapcat walk node))))]\n  (remove sequential? (walk %)))","problem":28,"user":"4f0660ee535dcb61093f6c0d"},{"problem":28,"code":"(fn flatten2\n  ([s] (reverse (flatten2 s '())))\n  ([s result]\n   (cond\n    (= s nil) result\n    (not (coll? (first s))) (flatten2 (next s) (conj result (first s)))\n    :else (flatten2 (next s) (flatten2 (first s) result)))))","user":"5888b75fe4b0f1effa3b771b"},{"problem":28,"code":"(fn flt [items] (if (coll? items) (mapcat flt items) [items]))","user":"543f854fe4b032a45b86935b"},{"problem":28,"code":"(fn flatten*\n    ([x, y]\n     (reduce (fn [x y]\n                 (if (sequential? y)\n                     (flatten* y x)\n                     (conj x y)))\n             y\n             x))\n    ([x]\n     (flatten* x [])))","user":"5ec66326e4b08d0ec38692d5"},{"problem":28,"code":"(fn \n[x]\n(filter (complement sequential?)\n(rest (tree-seq sequential? seq x))))","user":"53e67e69e4b036ad0777e473"},{"code":"(fn flat [x] (if (sequential? x) (mapcat flat x) (list x)))","problem":28,"user":"52c69672e4b0c2d177d62110"},{"problem":28,"code":"(fn flat [s]\n  (reduce (fn [result input]\n            (if (sequential? input)\n              (concat result (flat input))\n              (concat result (list input))))\n          '() s))","user":"555521a5e4b0deb715856e12"},{"problem":28,"code":"(fn my-flat [l]\n  (if (empty? l)\n    '()\n    (apply conj (my-flat (rest l))\n          (reverse (if (coll? (first l))\n            (my-flat (first l))\n            (list (first l)))))))","user":"551c6bcee4b07993ea3788df"},{"problem":28,"code":"(fn [x]\n  (loop [x x c []]\n  \t(if (empty? x)\n      c\n      (if (coll? (first x))\n        (recur (concat (first x) (rest x)) c)\n        (recur (rest x) (conj c (first x)))))))","user":"59ef5280e4b0966464fe6a2b"},{"code":"(fn flat [x]\n  (if-not (or (list? x) (vector? x))\n    [x]\n    (mapcat flat x)))","problem":28,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn flat [xs]\n  (if (some #(or (vector? %) (list? %)) xs)\n    (flat (mapcat #(if (or (vector? %) (list? %)) % (list %)) xs))\n    xs))","problem":28,"user":"4ec07699535dfed6da9c6da2"},{"code":"#(loop [acc '()\n        left %]\n   (if (empty? left)\n     (reverse acc)\n     (if (sequential? (first left))\n       (recur acc (concat (first left) (rest left)))\n       (recur (cons (first left) acc) (rest left)))))","problem":28,"user":"4f9b3532e4b0dcca54ed6d13"},{"problem":28,"code":"(fn [coll] \n  (letfn [(iter \n          [acc item]\n          (if (coll? item)\n            (reduce iter acc item)\n            (conj acc item)))] (reduce iter [] coll)))","user":"588f500ae4b00487982d51a4"},{"problem":28,"code":"#(filter (complement sequential?)(rest  (tree-seq sequential? seq  % )))","user":"5537de22e4b09218d5f44fd5"},{"code":"(fn flak\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"50949602e4b04e5742806c4e"},{"problem":28,"code":"(fn pops [result coll] (reduce (fn [x y] (if (coll? y) (pops x y) (conj x y))) result coll)) []","user":"595914e0e4b066ee0a44af99"},{"code":"#(filter (complement sequential?)\n     (rest (tree-seq sequential? seq %)))","problem":28,"user":"4f71347ae4b07046d9f4f009"},{"code":"(fn f [s]\n  (if (sequential? s)\n    (mapcat f s)\n    (list s)))","problem":28,"user":"5250a9abe4b0541d1855b83b"},{"problem":28,"code":"(fn flttn \n  ([input] (flttn input []))\n  ([input to] (reduce (fn [flattened x] \n                        (if (coll? x) \n                          (flttn x flattened) \n                          (conj flattened x))) \n                      to \n                      input)))","user":"5d68f5e6e4b0db5d338d1605"},{"code":"(fn f [s]\n  (mapcat #(if (coll? %)\n             (f %)\n             (list %))\n          s))","problem":28,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (if (empty? coll)\n    '()\n    (if (not (sequential? (first coll)))\n      (cons (first coll) (my-flatten (rest coll)))\n      (concat (my-flatten (first coll)) (my-flatten (rest coll))))))","user":"545d881de4b01be26fd7466f"},{"code":"(fn flatn [coll]\n  (if (empty? coll)\n    coll\n    (if (sequential? (first coll))\n\n    (concat (flatn (first coll)) (flatn (rest coll)))\n    (cons          (first coll)  (flatn (rest coll))))))","problem":28,"user":"4f91fd31e4b0dcca54ed6ca8"},{"problem":28,"code":"(fn flt [s]\n    (if (sequential? s)\n        (mapcat flt s)\n        (list s)))","user":"548392fce4b0e286459a1191"},{"code":"(fn fart [s]\n  (if (sequential? s)\n    (cond\n      (empty? s)\n      nil\n      (sequential? (first s))\n      (concat (fart (first s)) (fart (rest s)))\n      :else\n      (cons (first s) (fart (rest s))))\n    s))","problem":28,"user":"508dbd56e4b0f17d83ea26c2"},{"code":"(fn t1 [x]\n  (if (not-empty x) (let [l (first x) r (rest x)] #_(print \"left \" l \" right \" r) (let [retv (concat (if (sequential? l) (t1 l) [l]) (if (sequential? r) (t1 r) [r]))] #_(print \"RETURN \" retv \" \\n\") retv))))","problem":28,"user":"51aa5434e4b04e3dc0c27b26"},{"problem":28,"code":"(fn flatten-a-sequence-solution\n  [args] ;; update args as needed\n  ;; Write a function which flattens a sequence.\n\n  (if (and (coll? args) (seq args))\n    (\n     concat (flatten-a-sequence-solution (first args)) (flatten-a-sequence-solution (rest args))\n     )   \n     (if (coll? args)\n       []\n       [args]\n     )\n    \n    )         \n  )","user":"536829c8e4b0243289761e8b"},{"code":"(fn flatten* [x]\n  (if (coll? x)\n    (mapcat flatten* x)\n    [x]))","problem":28,"user":"4f1b92d1535d64f60314647b"},{"problem":28,"code":"(fn flatt [s]\n  (if (some (fn [x] (or (list? x) (vector? x))) s)\n    (loop [result [] left s]\n      (if (empty? left)\n        result\n        (let [next (first left)]\n          (if (or (list? next) (vector? next))\n            (recur (concat result (flatt next)) (rest left))\n            (recur (concat result [next]) (rest left))))))\n    s))","user":"577629abe4b0979f8965162e"},{"code":"(fn fl [coll]\r\n    (if-let [head (first coll)] (if (coll? head)\r\n\t      (concat (fl head) (fl (rest coll)))\r\n\t      (conj (fl (rest coll)) head))))","problem":28,"user":"4de623ef535d08e6dec9fdf4"},{"code":"(fn f [lst]\n  (if (coll? lst)\n    (mapcat f lst)\n        [lst]))","problem":28,"user":"4fc7ddffe4b0ee37620e182b"},{"problem":28,"code":"(fn flatt [sq]\n  (cond\n    (empty? sq) sq\n    (sequential? (first sq)) (concat (flatt (first sq)) (flatt (rest sq)))\n    :else (cons (first sq) (flatt (rest sq)))))","user":"5c6314c5e4b0fca0c1622658"},{"code":"(fn flt\r\n  ([l] (if (not (empty? l))\r\n        (if (sequential? (first l))\r\n         (concat (flt (first l)) (flt (rest l)))\r\n          (conj (flt (rest l)) (first l))\r\n        ))\r\n  ))","problem":28,"user":"4fb5705fe4b081705acca2be"},{"code":"(fn flat [s] \n  (reduce (fn f [acc x] \n    (if (coll? x)\n      (into acc (flat x))\n      (conj acc x)\n    )\n  ) [] s)\n)","problem":28,"user":"531ba143e4b08068f379ed91"},{"problem":28,"code":"(fn fla [coll]\n  (if (coll? coll)\n    (mapcat fla coll)\n    [coll]))","user":"5e87194ce4b09a7a73c8bbe4"},{"problem":28,"code":"(fn iter [xs]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (iter x))\n              (concat acc (cons x ()))))\n          ()\n          xs))","user":"5f0a65dae4b09a3f05b71806"},{"code":"(fn my-flatten [s]\n  (reduce\n    #(if (coll? %2)\n      (concat %1 (my-flatten %2))\n      (concat %1 (list %2)))\n    '()\n    s))","problem":28,"user":"4f7f9665e4b033992c121bea"},{"code":"(fn flatt [xs] \n    (do (println xs)\n        (if (empty? xs) '()\n            (concat \n                (if (coll? (first xs)) \n                    (flatt (first xs)) \n                    (list (first xs)))\n                (flatt (rest xs))))))","problem":28,"user":"4fb4303fe4b081705acca2ac"},{"code":"(fn f[x](apply concat(map #(if(coll?%)(if(seq%)(f %)%)[%])x)))","problem":28,"user":"4e7eff9e535db966e863cc38"},{"code":"#(filter (complement coll?) (rest (tree-seq coll? seq %)))","problem":28,"user":"4eebfd03535d93acb0a668ab"},{"problem":28,"code":"(fn fla [col]\n  (if (sequential? col)\n    (mapcat fla col)\n    (list col)))","user":"53bf0587e4b0c98a41f5cc98"},{"code":"(fn my-flat [coll] (let [x (first coll)] (if x (let [xs (rest coll)] (if (coll? x) (concat (my-flat x) (my-flat xs)) (concat (list x) (my-flat xs)))))))","problem":28,"user":"4fc52d79e4b081705acca386"},{"code":"(fn f [s]\r\n  (when-not (= s [])\r\n    (if (coll? s)\r\n        (concat (f (first s)) (f (rest s)))\r\n        (list s))))","problem":28,"user":"509160dae4b0742c82730aef"},{"code":"(fn t [x]\n  (reduce #(if (coll? %2)\n             (into %1 (t %2))\n             (conj %1 %2)\n            ) [] x))","problem":28,"user":"527b9beee4b03e8d9a4a7590"},{"problem":28,"code":"(fn flat [s] (reduce (fn [xs x] (concat xs (if (coll? x) (flat x) [x]))) [] s))","user":"55fee5e4e4b00f4cabc5765a"},{"code":"(fn fl [l]\n   (if (reduce #(or %1 %2) (map #(coll? %) l))\n     (fl (mapcat #(if (sequential? %) % [%]) l))\n     l))","problem":28,"user":"533cebf1e4b085b17e897d78"},{"code":"(fn pancake [x]\n  (loop [x x, acc '()]\n    (cond\n     (empty? x)\n       (reverse acc)\n     (sequential? (first x))\n       (recur (concat (first x) (rest x)) acc)\n     :else\n       (recur (rest x) (conj acc (first x)))\n     )))","problem":28,"user":"535f295fe4b04ce2eb3ed2da"},{"problem":28,"code":"(fn [x]\n  (loop [col x]\n    (if (not (some coll? col))\n      (sort col)\n      (if (coll? (first col))\n        (recur (concat (rest col) (first col)))\n        (recur (reverse (conj (reverse (rest col)) (first col))))))))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn walker [x] (if (coll? x) (mapcat walker x) (list x)))","problem":28,"user":"52d96f7ce4b09f7907dd13a8"},{"problem":28,"code":"(fn flat [s]\n  (seq\n  (reduce\n   (fn [t x]\n     (if (sequential? x)\n      (vec (concat t (flat x)))\n       (conj t x)))\n     []\n     s)))","user":"5e7128eee4b085ba37836db5"},{"problem":28,"code":"(fn [coll] \n  (loop [coll coll]\n   (if (not-any? coll? coll)\n    coll\n    (recur (reduce \n     (fn [a c] (concat a (if (coll? c) c ( list c))))\n     (list)\n     coll)))))","user":"5b885821e4b047b03b20380b"},{"code":"#((fn fl [c]\n  (if-not (sequential? c)\n    (cons c ())\n    (if (empty? c)\n      c  \n      (concat (fl (first c))\n              (fl (rest c)))))) %)","problem":28,"user":"4f30896ce4b0d6649770a07b"},{"code":"(fn [c] \n  (if (some coll? c) \n      (recur (mapcat \n        #(if (coll? %) % (vector %))\n        c)) \n      c))","problem":28,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn f [[x & r]]\n      (if x\n        (if (sequential? x)\n          (concat (f x) (f r))\n          (cons x (f r)))))","problem":28,"user":"502ade49e4b0614b52996120"},{"problem":28,"code":"(fn f[coll](if (sequential? coll)(mapcat f coll) (list coll)))","user":"586d4d63e4b01531a375e98e"},{"code":"(fn flt [coll]\n   (let [l (first coll) r (next coll)]\n     (concat \n       (if (sequential? l)\n         (flt l)\n         [l])\n       (when (sequential? r)\n         (flt r)))))","problem":28,"user":"50399468e4b088a6a14ca768"},{"problem":28,"code":"(fn flatr [col]\n  (if (coll? col)\n    (apply concat (map flatr col))\n    [col]))","user":"504e2d18e4b0f6ff3350c47a"},{"code":"(fn myflatten [x]\n  (when-let [s (seq x)]\n    (let [h (first s) t (rest s)]\n      (if (sequential? h)\n        (concat (myflatten h) (myflatten t))\n        (cons h (myflatten t)) ) )))","problem":28,"user":"52f381f3e4b05e3f0be25f10"},{"code":"(fn f [r] (if (coll? r) (mapcat f r) [r]))","problem":28,"user":"4db0114d838c48654951d9b8"},{"problem":28,"code":"(comp keys\n       (fn ffl [lst]\n         (if (sequential? lst)\n           (into {}\n                 (for [e lst]\n                   (ffl e)))\n           [lst 0])))","user":"57d9f603e4b0bd073c20240a"},{"problem":28,"code":"(fn flatn [ns]\n  (cond \n   (empty? ns) '()\n   (coll? (first ns)) (concat (flatn (first ns)) (flatn (rest ns)))\n   :else (cons (first ns) (flatn (rest ns)))))","user":"553dd883e4b0a04f792994e6"},{"problem":28,"code":"(fn my-flat [l]\n     (cond\n       (empty? l) nil\n       (coll? (first l)) (concat (my-flat (first l)) (my-flat (rest l)))\n       :else (conj (my-flat (seq (rest l))) (first l))))","user":"56c26880e4b05cc29241ee81"},{"problem":28,"code":"(fn flat [x]\n  (loop [old x new []]\n    (if (empty? old)\n      new\n      (if (sequential? (first old))\n        (recur (rest old) (concat new (flat (first old))))\n        (recur (rest old) (concat new (vector (first old))))))))","user":"5a9482b7e4b0d174b936c737"},{"problem":28,"code":"(fn flatten!! [l]\n  (if (empty? l) '()\n    (if (coll? (first l))\n      (concat (flatten!! (first l)) (flatten!! (next l)))\n      (cons (first l) (flatten!! (next l))))))","user":"5605b5e9e4b08b23635d316e"},{"code":"(fn flt [x] (apply concat \n              (map (fn tolist [y] (if (coll? y) (flt y) (list y))) x)))","problem":28,"user":"5313165ce4b08068f379ed06"},{"code":"(fn f \n   ([sq] (f sq []))\n   ([sq col]\n      (println [sq col])\n      (if (empty? sq) col\n          (f (rest sq) (if (sequential? (first sq))\n                         (into col (f (first sq) []))\n                         (conj col (first sq)))))))","problem":28,"user":"534e9ed4e4b084c2834f4ab8"},{"code":"reduce (fn my[res x] (if (coll? x) (reduce my res x) (conj res x) ) ) []","problem":28,"user":"4ee7d177535d93acb0a6686f"},{"problem":28,"code":"#(loop [s % r '()]\n      (if (empty? s)\n        (reverse r)\n        (let [x (first s)\n              y (rest s)]\n          (if (coll? x)\n            (recur (reduce conj (apply list y) (reverse x)) r)\n            (recur y (conj r x))))))","user":"55d29fb6e4b0e31453f64a59"},{"code":"(fn fl [s]\n  (let [f (first s) r (rest s)]\n    (cond \n      (nil? f) nil\n      (coll? f) (concat (fl f) (fl r))\n      :else (cons f (fl r))\n    )\n  )\n)","problem":28,"user":"4f8b56dae4b02e764a0a517e"},{"problem":28,"code":"(fn [x] \n\t(filter (complement sequential?)\n          \t(rest (tree-seq sequential? seq x))))","user":"54a96a15e4b09f271ff37cad"},{"problem":28,"code":"(fn [to-be-flat]\n  (reduce (fn [result item]\n            (if-not (coll? item)\n              (concat result (list item))\n              (if-not (some coll? item)\n                (concat result item)\n                (recur result (mapcat #(if (sequential? %) % [%]) item))))\n            ) [] to-be-flat))","user":"5e16fd78e4b0a047bd49f726"},{"code":"(fn one-list [x] (mapcat #(if (coll? %) (one-list %) [%]) x))","problem":28,"user":"528a791ae4b0239c8a67ae77"},{"problem":28,"code":"(fn flatten1 [xs]\n  (if (sequential? xs)\n  \t(if (nil? (next xs))\n  \t\t(flatten1 (first xs))\n  \t\t(concat (flatten1 (first xs)) (flatten1 (next xs))))\n  \t(list xs)))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn flat [x] (let [l (first x) r (next x)]\n               (concat\n                 (if (sequential? l)\n                   (flat l)\n                   [l])\n                 (when (sequential? r)\n                   (flat r)))))","problem":28,"user":"5264301fe4b03e8d9a4a70ca"},{"code":"(fn myflatten [xs]\n  (if (empty? xs)\n    xs\n  \t(if (sequential? (first xs))\n      (concat (myflatten (first xs)) (myflatten (rest xs)))\n      (cons (first xs) (myflatten (rest xs))))))","problem":28,"user":"4fc3a72ae4b081705acca342"},{"problem":28,"code":"(fn flat [x] \n      (if (coll? x) \n        (reduce concat (map flat x))\n        (list x)))","user":"565b4d7fe4b068f2fe63dc01"},{"code":"(fn [l]\n  (loop [l l\n         r []]\n    (if (= l '())\n      r\n      (if (sequential? (first l))\n        (recur (concat (first l) (rest l)) r)\n        (recur (rest l) (conj r (first l)))))))","problem":28,"user":"50435852e4b034ff00315d22"},{"problem":28,"code":"(fn step [e]\n     (if-not (coll? e)\n       [e]\n       (mapcat step e)))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":28,"code":"#(let [\n         red (fn [subcoll f] (reduce (fn [acc e] (concat acc (f e f))) '() subcoll))\n         ext (fn [subcoll f] (if (sequential? subcoll) (red subcoll f) (list subcoll)))\n        ]\n    (red % ext)\n)","user":"55a74d46e4b09e57187da2a3"},{"problem":28,"code":"(fn f [s] (if (empty? s) [] (let [[x & xs] s]                          (concat (if (sequential? x) (f x) [x]) (f xs)))))","user":"58fdd7b7e4b0438e51c2cfc0"},{"problem":28,"code":"#(filter (comp not coll?)\n \t     (tree-seq coll? identity %))","user":"54c29697e4b045293a27f604"},{"code":"(fn flat [xs] \n  ( seq (reduce (fn [xs x]\n    (if (coll? x) (apply conj xs (flat x)) (conj xs x))) [] xs )))","problem":28,"user":"4fc92595e4b0ee37620e1843"},{"problem":28,"code":"(fn flat [x]\n\t(if (sequential? x)\n\t\t(let [[a & b] x]\n\t\t\t(if (sequential? a)\n\t\t\t\t(if b\n\t\t      (concat (apply concat (map flat a)) (flat b))\n\t\t      (apply concat (map flat a)))\n\t\t\t\t(if b\n\t\t\t\t\t(cons a (flat b))\n\t\t\t\t\t(list a))))\n\t\t(list x)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":28,"code":"(fn [coll]\n  (letfn [(recur-flat [elem]\n            (mapcat #(if (sequential? %)\n                       (recur-flat %)\n                       (conj '() %))\n                    elem))]\n    (recur-flat coll)))","user":"57aa2b97e4b0b8559636fc66"},{"code":"(letfn [(flat [seq] (mapcat #(if (sequential? %) (flat %) [%]) seq))]\n  flat)","problem":28,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn f [x] \n    (if (sequential? x) \n        (mapcat f x)\n        (list x)))","problem":28,"user":"4e9660ec535dbda64a6f6b44"},{"code":"#((fn [x]\n   (first (first (drop-while (fn [[s z]] (not (empty? z))) (iterate\n     (fn [[s [y & ys]]]\n         (if (nil? y)\n             (list s)\n             (if (instance? clojure.lang.Seqable y)\n                 (list s (concat y ys))\n                 (list (concat s [y]) ys)\n             )\n         )\n     ) x))))\n) (list '() %))","problem":28,"user":"5319d9ade4b08068f379ed84"},{"code":"(fn [coll]\n  (letfn [(flatten' [h & rest]\n            (cond\n             (sequential? h) (concat (apply flatten' h) (flatten' rest))\n             (nil? h) nil\n             :else (concat [h] (flatten' rest))))](flatten' coll)))","problem":28,"user":"52c49401e4b0c2d177d620de"},{"code":"(fn [l] (filter (comp not sequential?) (tree-seq sequential? identity l)))","problem":28,"user":"52824143e4b0757a1b171453"},{"problem":28,"code":"(fn [l] (filter #(not (sequential? %)) (tree-seq sequential? seq l)))","user":"54485727e4b032a45b8693c6"},{"problem":28,"code":"(fn spotflatten [x]\n  (let [f (first x), r (rest x)]\n    (cond\n      (empty? x) nil\n      (sequential? f) (concat (spotflatten f) (spotflatten r))\n      :else  (cons f (spotflatten r)))))","user":"60882700e4b0ae75613dcedf"},{"problem":28,"code":"(fn recur-flat\n    ([ls] (recur-flat ls []))\n    ([ls flattened]\n     (if (empty? ls)\n       flattened\n       (if (instance? java.util.Collection (first ls))\n         (recur (concat (first ls) (rest ls)) flattened)\n         (recur (rest ls) (conj flattened (first ls)))))))","user":"5ebc9feae4b00a66d4a95268"},{"code":"(fn [c] (\n  (fn myFlatten [y z]\n    (if (coll? y)\n      (if (= (count y) 0)\n        z\n        (myFlatten\n          (first y)\n          (concat (myFlatten (rest y) []) z)\n        )\n      )\n      (conj z y)\n    )\n  ) c []\n))","problem":28,"user":"4f16d6ed535d64f60314644f"},{"problem":28,"code":"(fn [coll]\n  (letfn [(flat [lst acc]\n               (if (empty? lst)\n                 acc\n                 (let [elt (last lst)]\n                   (if (sequential? elt)\n                     (flat (butlast lst) (flat elt acc))\n                     (flat (butlast lst) (cons elt acc))))))]\n    (flat coll nil)))","user":"55afc197e4b002ce9d5cbc18"},{"problem":28,"code":"(fn my-flat \n  ([coll] (my-flat coll []))\n  ([coll result]\n   (if (sequential? coll)\n     (if (empty? coll)\n       result\n       (into (my-flat (first coll)) (my-flat (rest coll))))\n     (conj result coll))))","user":"5a346d73e4b0ddc586f153c8"},{"problem":28,"code":"reduce\n (fn flatseq [res a]\n  (if (sequential? a)\n    (reduce flatseq res a)\n    (concat res [a] )\n   )\n )\n '()","user":"5d5c6675e4b09db18d4482ec"},{"code":"(fn mflatten[lst]\r\n  (loop [ls lst xs '()]\r\n    (if (= (first ls) nil)\r\n      xs\r\n      (if (or (list? (first ls))\r\n        (vector? (first ls)))\r\n\t(recur (rest ls) (concat xs (mflatten (first ls))))\r\n\t(recur (rest ls) (concat xs (list (first ls))))))))","problem":28,"user":"4ddc620d535d02782fcbea06"},{"code":"(fn [x] (filter (complement sequential?) \n        (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f5612f9e4b0a7574ea71812"},{"code":"(fn flt [col]\n  (if (coll? col)\n  (mapcat flt col)\n  [col])\n)","problem":28,"user":"52382d91e4b0fae3832e99f0"},{"problem":28,"code":"(fn [coll]\n  (loop [[h & t :as c] coll acc []]\n    (cond\n     (empty? c)      acc\n     (sequential? h) (recur (concat h t) acc)\n     :else           (recur t (conj acc h)))))","user":"5f665d45e4b02876ed9fd02f"},{"code":"#(filter \n  (complement sequential?)\n    (tree-seq sequential? seq %))","problem":28,"user":"4fcd155de4b065de69964ca3"},{"code":"(fn f [[x & coll]] \n  (when x (if (sequential? x) \n    (f (concat x coll)) \n    (cons x (f coll)))))","problem":28,"user":"4f052eaf535dcb61093f6bf3"},{"problem":28,"code":"(fn a [x] \n  (if(coll? x)\n     (if (empty? x)\n       []\n       (concat (a (first x)) (a (rest x))))\n     [x]))","user":"550babf3e4b06e50f9beb149"},{"code":"(fn flat [[h & t :as s]]\n  (cond \n     (empty? s) s\n     (sequential? h) (into (flat t) (reverse (flat h)))\n     :default (cons h (flat t))))","problem":28,"user":"531619c1e4b08068f379ed3d"},{"problem":28,"code":"(fn flat [[x & xs]]\n    (cond (nil? x) '()\n          (sequential? x) (concat (flat x) (flat xs))\n          :else (conj (flat xs) x)))","user":"5315ba94e4b08068f379ed34"},{"problem":28,"code":"(fn my-flat [coll] \n\t(when-let [s (seq coll)]\n\t\t(if (coll? (first s)) \n\t\t\t(concat (my-flat (first s)) (my-flat (rest s)))\n\t\t\t(cons (first s) (my-flat (rest s))))))","user":"55f7ebeae4b06e875b46ceb7"},{"code":"(fn my [items]\n  (if (sequential? items)\n\t\t\t(when (seq items) (concat (my (first items)) (my (rest items))))\n\t\t\t[items]))","problem":28,"user":"50c4baa6e4b0210b849018b0"},{"code":"(fn fla [x]\r\n  (if (coll? x)\r\n    (when (seq x) (concat (fla (first x)) (fla (rest x))))\r\n    [x])\r\n  )","problem":28,"user":"503354c3e4b0c6c1199c710c"},{"problem":28,"code":"(fn fltn [x]\n  (if (coll? x)\n  (mapcat fltn x)\n  [x]))","user":"56798d83e4b05957ce8c618b"},{"code":"(fn f [x]\n  (if (sequential? x)\n    (mapcat f x)\n    [x]))","problem":28,"user":"4ed97da1535d10e5ff6f5306"},{"problem":28,"code":"(fn [seqx]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq seqx))))","user":"60cc2d58e4b0e0fa5f1b4323"},{"problem":28,"code":"(fn f [[head & rest]]\n   (if (nil? head)\n     []\n     (if (sequential? head)\n       (concat (f head) (f rest))\n       (cons head (f rest)))))","user":"53e634ede4b036ad0777e470"},{"code":"(fn my-flatten [[f & r]]\n  (if (nil? f)\n    '()\n    (if (sequential? f)\n      (concat (my-flatten f) (my-flatten r))\n      (cons f (my-flatten r)))))","problem":28,"user":"5367ca98e4b0243289761e86"},{"code":"(fn flt[coll]\n          (let [l (first coll) r (next coll)]\n               (concat\n                (if (sequential? l)\n                    (flt l)\n                    [l])\n                (if (seq? r)\n                  (flt r)))))","problem":28,"user":"521ceb02e4b0c4ef0be830a5"},{"problem":28,"code":"#(filter (complement sequential?) (tree-seq sequential? identity %) )","user":"564302b5e4b08d4f616f5f21"},{"problem":28,"code":"(fn [coll]\n   (reverse\n   (reduce\n    (fn my-flatten [v e]\n      (if (coll? e)\n        (reduce my-flatten v e)\n        (conj v e)))\n    '() coll)) )","user":"5377a23ce4b06839e8705e39"},{"problem":28,"code":"(fn flat [coll]\n  (let [s (seq coll)\n        f (first s)\n        r (rest s)]\n    (if (= 0 (count s))\n      []\n      (if (coll? f)\n        (concat (flat f) (flat r))\n        (cons f (flat r))))))","user":"56a51f26e4b0542e1f8d14e0"},{"code":"(fn ! [coll]\n  (reduce (fn [a b] (if (or (list? b) (vector? b))\n                     (concat a (! b))\n                     (concat a [b])))\n          []\n          coll))","problem":28,"user":"5225271fe4b01819a2de42f9"},{"problem":28,"code":"(fn [coll]\n  (loop [c coll flat '()]\n    (let [first-coll? (coll? (first c))]\n      (if (empty? c) \n        (reverse flat)\n        (recur\n         (if first-coll? \n           (concat (first c) (rest c))\n           (rest c))\n         (if first-coll?\n           flat\n           (conj flat (first c)))\n        \n        )))))","user":"5bfbf75ee4b0bdcf453d15df"},{"code":"#(filter \n  (complement sequential?) \n  (rest (tree-seq sequential? seq %)))","problem":28,"user":"50481532e4b0ec70b3ef8d96"},{"code":"(fn flat [node]\n  (reduce #(concat % (if (coll? %2) (flat %2) [%2]))\n          ()\n          node))","problem":28,"user":"50aa60bee4b056ee01935865"},{"code":"(fn flattten [coll]\n  (if (coll? coll)\n  \t(reduce #(concat %1 (flattten %2)) () coll)\n    (list coll)))","problem":28,"user":"51efd397e4b0249c592fbdeb"},{"problem":28,"code":"(fn myflatten [s]\n  (cond (not (sequential? s)) [s]\n        (empty? (rest s)) (myflatten (first s))\n        :else (concat (myflatten (first s)) (myflatten (rest s)))))","user":"59be62d5e4b0a024fb6ae435"},{"problem":28,"code":"(fn smoosh [x]\n    (if (sequential? x)\n      (apply concat (map smoosh x))\n      (list x)))","user":"54889b50e4b0e286459a11d4"},{"problem":28,"code":"(fn flatten-ku [xs]\n    (cond\n        (empty? xs) '() \n        (coll? (first xs)) (concat (flatten-ku (first xs)) (flatten-ku (rest xs)))\n        :else (cons (first xs) (flatten-ku (rest xs)))))","user":"5fa358a1e4b0f0ebd91b77fd"},{"problem":28,"code":"(fn flat [l]\n      (if (= 1 (count l))\n          (if (coll? (first l) )\n              (flat (first l) )\n\t      (list (first l))\n          )\n          (if (coll? (first l))\n              (concat (first l) (flat (rest l)))\n              (cons (first l) (flat (rest l)))\n          )\n          )\n)","user":"568513c4e4b04eec3ec5cfc5"},{"problem":28,"code":"(fn [coll]\n  (filter #(not (coll? %))\n          (tree-seq coll? seq coll)))","user":"541df619e4b01498b1a71a87"},{"problem":28,"code":"(fn my-flatten [xs]\n  (mapcat (fn [x] (if (sequential? x) \n                    (my-flatten x) \n                    [x])) \n          xs))","user":"4db1b3951254ad5b4805fa6f"},{"code":"#(filter (complement sequential?) \n (rest (tree-seq sequential? seq %)))","problem":28,"user":"4edb1774535d10e5ff6f5315"},{"problem":28,"code":"(fn flatr [x]\n    (if (not (empty? x))\n    (if (not (coll? (first x))) (cons (first x) (flatr (rest x)))\n                        (concat (flatr (first x)) (flatr (rest x))))))","user":"503c90aae4b06c4e0e1fa24b"},{"problem":28,"code":"(fn [coll]\n  (loop [[head & tail :as remaining] coll\n         acc (vector)]\n    (cond\n     (empty? remaining) (filter (complement nil?) acc)\n     (coll? head) (recur (into (list tail) (reverse head)) acc)\n     :else (recur tail (conj acc head)))))","user":"51a7bf26e4b0da5f497bde8c"},{"code":"#(remove sequential? (tree-seq sequential? identity %))","problem":28,"user":"4e4ad154535dc968683fc4d1"},{"problem":28,"code":"(fn my-flatten [x]\n   (cond\n     (not (sequential? x))\n     [x]\n     (and (= 1 (count x)) (not (sequential? (first x))))\n     x\n     (empty? x)\n     nil\n     true\n     (concat (my-flatten (first x))\n     (my-flatten (rest x))))\n     )","user":"539f9f79e4b0ca733b97449e"},{"code":"(fn make-flat [sequence]\n    (if  (empty? sequence) '()\n        (if (sequential? (first\tsequence))\n          (concat (make-flat (first sequence))\n                  (make-flat (rest sequence)))\n          (cons (first sequence) (make-flat (rest sequence))))))","problem":28,"user":"50057f23e4b0678c553fc466"},{"problem":28,"code":"(fn fltn [sq] (cond (sequential? (first sq))\n                    (concat (fltn (first sq)) (fltn (next sq)))\n                    (nil? (first sq)) nil\n                    :else (cons (first sq) (fltn (next sq)))))","user":"55adcc8fe4b03311e7b732ab"},{"code":"#(letfn [(fl [l] (cond (and (coll? l) (empty? l)) [] (not (coll? l)) [l] :else (concat (fl (first l)) (fl (rest l)))))] (fl %1))","problem":28,"user":"4f29cdc8e4b0d6649770a033"},{"problem":28,"code":"(fn flat\n  [n]\n  (let [[x & y] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (flat x)(flat y))\n     :else (cons x (flat y))\n     )\n    )\n  )","user":"59a9c22ae4b08cbb53654d75"},{"problem":28,"code":"(fn my-flat [s]\n  (if (coll? s) \n    (mapcat my-flat s)\n    [s]))","user":"5c73a944e4b0fca0c16227b8"},{"problem":28,"code":"(fn fl [[x & xs :as coll]]\n  (if (empty? coll)\n    coll\n    (if (coll? x)\n      (concat (fl x) (fl xs))\n      (cons x (fl xs)))))","user":"54b07c1ee4b09f271ff37d16"},{"code":"(fn flat [x]\r\n  (if-let [y (first x)]\r\n    (let [ys (rest x)]\r\n      (if (sequential? y)\r\n        (concat (flat y) (flat ys))\r\n        (cons y (flat ys))))))","problem":28,"user":"4f20c040e4b0d66497709fcb"},{"code":"(fn [x] (filter (complement sequential?)\n  (tree-seq sequential? seq x)))","problem":28,"user":"4fc04d75e4b081705acca324"},{"code":"(fn f [x] \n  (cond (empty? x) nil\n        (coll? (first x)) (concat (f (first x)) (f (rest x)))\n        :else (cons (first x) (f (rest x)))))","problem":28,"user":"4f1684c7535d64f60314644b"},{"code":"#(filter\n   (complement sequential?)\n   (rest (tree-seq sequential? seq %)))","problem":28,"user":"52b9cfb9e4b07a9af57922c5"},{"code":"(fn flatten_\n  ([] [])\n  ([l]\n    (if (zero? (count l))\n      l\n      (let [x (first l) xs (rest l)]\n        (if (sequential? x)\n        (concat (flatten_ (seq x)) (flatten_ xs))\n        (cons x (flatten_ xs)))))))","problem":28,"user":"504e127fe4b078edc5f593b6"},{"problem":28,"code":"(fn foo [x]\r\n  (if (coll? x)\r\n    (reduce concat (map foo x))\r\n    (list x)))","user":"606e0a42e4b069485764de19"},{"code":"(fn flt [l]\n  (cond\n   (empty? l) ()\n   (coll? (first l)) (concat (flt (first l)) (flt (rest l)))\n   :else (cons (first l) (flt (rest l)))))","problem":28,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":28,"code":"#(reverse (reduce\n           (fn rec-flatten [acc item]\n             (if (coll? item) (reduce rec-flatten acc item)\n                 (conj acc item)))\n           '()\n           %))","user":"5891bddce4b00487982d5201"},{"problem":28,"code":"(fn [[h & t]]\n  (loop [h h\n         t t\n         r []]\n    (cond (and (empty? t) (not h)) r\n          (coll? h) (recur (first h) (concat (rest h) t) r)\n          :else (recur (first t) (rest t) (conj r h)))))","user":"56372798e4b0bfe05bf117d0"},{"code":"(fn f \n  ([s a] \n   (if (sequential? s)\n      (if (empty? s)\n        a\n        (f (first s) (f (rest s) a))\n      )\n    \n      (cons s a)\n    )\n  )\n  \n  ([s] (f s '()))\n)","problem":28,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":28,"code":"(fn [l] \n  \"free of StackOverflow problem, not lazy and much faster version of flatten.\"\n(loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"54bad977e4b0ed20f4ff6eb9"},{"problem":28,"code":"(fn my-flatten [s]\n\n  (letfn [ (sub-flatten [s]\n\n(loop [result [] tail s]\n\n  (let [head (first tail)]\n    \n    (if (nil? head)\n\n    ; Using do to add printlns\n      (do\n        (println result)\n         result\n        \n      )\n      \n\n      (if (or (vector? head) (seq? head))\n        \n        (do \n          (recur (into result (sub-flatten (vec head))) (rest tail))\n        ) ; do end\n        \n        (do \n          (recur (conj result head) (rest tail))\n        )\n        \n\n        ) ; if end\n      \n      ) ; if end\n    \n    ) ; let end\n  \n  ) ; loop end\n) ; sub-flatten end\n  ]\n\n  (sub-flatten s)  \n  ; call sub-flatten here\n\n  ) ; letfn end\n\n  \n\n\n) ; defn end","user":"5ff676a9e4b06df49cee1497"},{"problem":28,"code":"#(mapcat (fn flat [x] (if (coll? x) (when-not (empty? x) (concat (flat (first x)) (flat (rest x)))) (list x))) %)","user":"541e774de4b01498b1a71a8d"},{"problem":28,"code":"(fn flattn [s]\n  (reduce #(if (sequential? %2)\n               (concat %1 (flattn %2))\n               (concat %1 (list %2)))\n          () s))","user":"5e0a6cf0e4b099d064962f66"},{"code":"(fn f[x] \n  (if (empty? x) '()\n  (let [h (first x) t (rest x)]\n          (if (coll? h)\n            (concat (f h) (f t))\n            (cons h (f t))\n          )\n        )))","problem":28,"user":"4e9d6a65535dbda64a6f6b87"},{"problem":28,"code":"(fn mf\n  [s]\n  (if (not-any? sequential? s)\n    s\n    (mf (mapcat #(if (sequential? %) % [%]) s))))","user":"57023e92e4b08d47c97781da"},{"code":"(fn my-flatten [ls] (reduce (fn [items item] (concat items \n  (if (coll? item)\n        (my-flatten item)\n        (list item)))) '() ls))","problem":28,"user":"4f2c593ee4b0d6649770a053"},{"problem":28,"code":"#(reverse (reduce \n  (fn banana-killer [out part]\n    (if (sequential? part)\n      (reduce banana-killer out part)\n      (conj out part)\n    )\n  )\n  '()\n  %))","user":"5f3a8493e4b004f08c61c527"},{"code":"(fn  [s] (seq ((fn flatten1 [s1 acc]\r\n    (if (coll? s1)\r\n      (if (empty? s1)\r\n       acc\r\n       (flatten1 (rest s1) (flatten1 (first s1) acc)))\r\n      (conj acc s1)))\r\n    s [])))","problem":28,"user":"4dd6d7ee535d2dad7130b5cb"},{"problem":28,"code":"(fn flat [coll] \n  (if (sequential? coll) \n    (mapcat flat coll)\n    [coll]))","user":"55ecac8ee4b0121d4835fdcc"},{"problem":28,"code":"(fn flat [s]\n   (let [f (first s)\n         r (rest s)]\n     (cond (empty? s) nil\n           (not (sequential? f)) (cons f (flat r))\n           :else (concat (flat f) (flat r)))))","user":"582589b2e4b051871117bedd"},{"problem":28,"code":"(fn flat [n]\n  (if (empty? n)\n    '()\n    (if (sequential? (first n))\n      (concat (flat (first n)) (flat (rest n)))\n      (cons (first n) (flat (rest n))))))","user":"5a00cb31e4b01bb0ae8afd36"},{"problem":28,"code":"(fn f [x]\n  (reduce #(concat %1 (if (sequential? %2) (f %2) [%2])) [] x))","user":"58844d43e4b0f1effa3b7696"},{"problem":28,"code":"(fn f[s](if (or (vector? s)(seq? s)) (mapcat f s) (list s)))","user":"5457e5f1e4b01be26fd74613"},{"problem":28,"code":"(fn fl[se]\n  (println \"se: \" se)\n  (loop [in se\n         target (empty se)\n         cnt 10]\n    (println \"in: \" in)\n    (println \"t: \" target)\n    (if (or (empty? in) (= cnt 0))\n      target\n      (if (coll? (first in))\n        (recur (concat (fl (first in)) (rest in)) target (dec cnt))\n        (recur (rest in) (concat target [(first in)]) (dec cnt))\n      )\n    )\n  )  \n)","user":"5c337305e4b0d62ef62d9f48"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (mapcat #(if (coll? %)\n             (my-flatten %)\n             [%])\n          coll))","user":"56180d83e4b06b1bb2182a18"},{"problem":28,"code":"(fn cflatten [s]\n  (cond (empty? s) []\n        (coll? (first s)) (concat (cflatten (first s))\n                                  (cflatten (rest s)))\n        :t (cons (first s) (cflatten (rest s)))))","user":"53b780b8e4b047364c0444cf"},{"problem":28,"code":"#((fn myConj [clo x]\n   (if (coll? x)\n     (loop [clo clo x x]\n       (if (not-empty x)\n         (recur (myConj clo (first x)) (rest x))\n         clo))\n     (conj clo x))) [] %)","user":"5be79b5be4b0f319e2d7ec5a"},{"problem":28,"code":"(fn fflat [coll]\n  (lazy-seq\n    (when-let [s  (seq coll)]\n      (if (coll? (first s))\n        (concat (fflat (first s)) (fflat (rest s)))\n        (cons (first s) (fflat (rest s)))))))","user":"54413696e4b032a45b86936b"},{"code":"(fn my-flatten [coll]\n  (if (sequential? coll)\n    (mapcat my-flatten coll)\n    (list coll)))","problem":28,"user":"5226f8e9e4b04e78ff2e199a"},{"problem":28,"code":"#(filter (complement sequential?)\n        (rest (tree-seq sequential? seq %&)))","user":"5a2834dfe4b07f18be40aa64"},{"code":"#(letfn [(flt [s] (mapcat (fn [x] \n                            (if (sequential? x) (flt x) [x]))\n                          s))]\n  (flt %))","problem":28,"user":"4dac61e18cc9d6edb9beb0b3"},{"code":"(fn flat [s]\n  (cond\n    (not (coll? s)) (list s)\n    (empty? s) nil\n    true (concat (flat (first s)) (flat (rest s)))))","problem":28,"user":"4f0c84ce535d0136e6c2230e"},{"code":"(fn flat [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      xs\n      (concat (flat (first xs)) (flat (rest xs))))\n    (list xs)))","problem":28,"user":"4fab1ea1e4b081705acca210"},{"problem":28,"code":"(fn myflatten\n  ([xs] (myflatten [] xs))\n  ([acc xs]\n    (if-not (coll? xs)\n      (conj acc xs)\n      (if (empty? xs)\n        acc\n        (-> \n          (myflatten acc (first xs))\n          (myflatten (rest xs)))))))","user":"544257b4e4b032a45b869379"},{"code":"(fn flat [x]\n  (if (sequential? x)\n    (mapcat flat x)\n    (list x)))","problem":28,"user":"5261aebbe4b03e8d9a4a7066"},{"problem":28,"code":"(fn [x]\n  (filter  (complement  sequential?)  (tree-seq sequential? seq x)))","user":"5e9154c1e4b0cb0169546354"},{"code":"(fn flatten' [coll]\n  (cond\n   (empty? coll) '()\n   (not (coll? (first coll))) (cons (first coll) (flatten' (rest coll)))\n   :else (concat (flatten' (first coll)) (flatten' (rest coll))) ))","problem":28,"user":"4f942227e4b0dcca54ed6cbe"},{"problem":28,"code":"(fn f [xs]\n  (cond\n    (empty? xs)        ()\n    (coll? (first xs)) (concat (f (first xs))\n                               (f (rest xs)))\n    :else              (cons (first xs)\n                             (f (rest xs)))))","user":"5791d259e4b0ebec4cfb75c0"},{"problem":28,"code":"(fn f [L] (mapcat #(if (coll? %) (f %) [%]) L))","user":"559c13c5e4b066d22e731f61"},{"code":"#(lazy-seq\n  (letfn [(f [l]\n            (if (empty? l) l\n                (let [[x & xs] l]\n                  (concat (if (coll? x) (f x) [x]) (f xs)))))]\n    (f %)))","problem":28,"user":"4f06dcad535dcb61093f6c16"},{"problem":28,"code":"(fn not-flatten [y] (if (coll? y) (mapcat not-flatten y) [y]))","user":"5ae246b1e4b0837691e92c5d"},{"problem":28,"code":"(fn my-flatten2\n  [seq]\n  (reduce\n   (fn flattn\n     [flat-list elem]\n     (if (sequential? elem)\n       (concat flat-list (reduce flattn []  elem))\n       (concat flat-list (vector elem))))\n   []\n   seq))","user":"56cf9d4fe4b0ea9b8538f76c"},{"code":"(fn myflatten [coll]\n  (loop [coll coll acc []]\n    (if (nil? (seq coll))\n      acc\n      (recur (rest coll)\n             (let [elt (first coll)]\n               (if (sequential? elt)\n                 (vec (concat acc (myflatten elt)))\n                 (conj acc elt)))))))","problem":28,"user":"52cc582ae4b07d0d72b27362"},{"problem":28,"code":"(fn f\n  [x]\n  (if (sequential? x)\n    (mapcat f x)\n    [x]))","user":"4eb70649535d7eef30807373"},{"code":"(fn bar[x] (apply concat (for [y x] \n                     (if (coll? y) \n                       (bar y) \n                       [y])))    \n  )","problem":28,"user":"5396c9a8e4b0b51d73faaee4"},{"problem":28,"code":"(fn [s] (loop [x '() y s]\n            (cond\n              (sequential? (first y)) (recur x (concat (first y) (rest y)))\n              (empty? y) (reverse x)\n              :else (recur (cons (first y) x) (rest y)))))","user":"5470b3d0e4b00cfc9eacc1bb"},{"code":"(fn p28 [s]\r\n  (reverse\r\n   (loop [s s\r\n          r '()]\r\n     (cond (empty? s)\r\n           r\r\n           (coll? (first s))\r\n           (recur (rest s) (apply conj r (p28 (first s))))\r\n           :else\r\n           (recur (rest s) (conj r (first s)))))))","problem":28,"user":"4de2f44f535d08e6dec9fdec"},{"problem":28,"code":"(fn myflat [c]\n  (if (seq c)\n    (if (coll? (first c))\n      (concat\n       (myflat (first c))\n       (myflat (rest c)))\n      (cons (first c) (myflat (rest c))))))","user":"54448e84e4b032a45b869393"},{"problem":28,"code":"(fn fuck\n  ([coll]\n   (fuck coll []))\n  ([coll acc]\n   (let [v (first coll)]\n     (if v\n       (if (or (seq? v)\n               (coll? v))\n         (fuck (concat v (rest coll)) acc)\n         (fuck (rest coll) (conj acc v)))\n       acc))))","user":"5ff8ead1e4b06df49cee14ab"},{"code":"(fn [coll]\n    (if (not-any? coll? coll)\n      coll\n      (recur (mapcat #(if (coll? %) % [%]) coll))))","problem":28,"user":"4f4023d9e4b0e243712b1fa9"},{"problem":28,"code":"(fn f\n  [x]\n  (if (coll? x)\n    (mapcat f x)\n    (list x)))","user":"56488119e4b0284900eef632"},{"problem":28,"code":"#(\n  (fn [[h & r] l]\n    (if (nil? h)\n      l\n      (if (sequential? h)\n        (recur (concat h r) l)\n        (recur r (conj l h)))))\n  % [])","user":"58384bc4e4b089d5ab817d27"},{"problem":28,"code":"(fn [x] (reduce (fn mfl [co el] (if (sequential? el) (reduce mfl co el) (conj co el))) [] x ))","user":"58060dace4b0a837a8b30cd5"},{"problem":28,"code":"(fn [s] (filter (complement sequential?)\n                          (rest (tree-seq sequential? seq s))))","user":"54c3747de4b045293a27f60e"},{"problem":28,"code":"(fn my-flatten \n  [coll]\n  (reduce (fn [accum item]\n            (if (coll? item)\n              (concat accum (my-flatten item))\n              (concat accum [item])))\n          []\n          (seq coll)))","user":"58740c18e4b01531a375ea49"},{"problem":28,"code":"(fn unpack [x]\n  (if (sequential? x)\n    (if (empty? (rest x))\n      (unpack (first x))\n      (concat (unpack (first x)) (unpack (rest x)))\n      )\n    (list x)))","user":"564066dee4b08d4f616f5ee2"},{"problem":28,"code":"(fn f [x] (if (sequential? x) (reduce concat (map f x)) (list x)))","user":"5595071ae4b0c79f6e1db95d"},{"problem":28,"code":"(fn fun28  [lst]\n  (cond\n      ;(empty? lst)\n      ;()\n   \n      (coll? lst)\n      \t(mapcat fun28 lst)\n\n      :else\n      \t[lst]\n))","user":"5f77d470e4b02876ed9fd0be"},{"code":"(fn [x]\n(filter (complement sequential?) \n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"50e41747e4b0463d32072489"},{"problem":28,"code":"(fn [first-hats]\n  (reverse ((fn hat-flatter [shelf, hats]\n    ; flattens hats onto a shelf\n    (if (or (vector? hats) (seq? hats) (list? hats))\n      ; Multiple Hats, reduce against current shelf\n      (reduce hat-flatter shelf hats)\n      ; Single hat, add to the running shelf\n      (conj shelf hats)\n    )\n   ) '() first-hats)))","user":"559057c4e4b027778923766e"},{"problem":28,"code":"(fn flat [coll]\n    (reduce (fn [result element]\n              (if (coll? element)\n                  (vec (concat result (flat element)))\n                  (conj result element)))\n     []\n     coll))","user":"57b9f35be4b0fbc9809a27f9"},{"code":"(fn flt [lis]\n  (cond\n   (empty? lis) []\n   (sequential? (first lis)) (lazy-cat (flt (first lis)) (flt (next lis))) \n   :else (lazy-cat (conj [] (first lis)) (flt (next lis)))))","problem":28,"user":"534e4a29e4b084c2834f4ab0"},{"problem":28,"code":"(fn g\n  [s]\n  (mapcat #(if (coll? %) (g %) [%]) s))","user":"56a44067e4b0542e1f8d14da"},{"code":"#(letfn [(flt [step coll]\n            (reduce\n             (fn [step item]\n               (if (coll? item)\n                 (flt step item)\n                 (conj step item))) step coll))]\n    (flt [] %))","problem":28,"user":"51db1abae4b094966a2cd685"},{"code":"(fn [theSeq] \n    (let [tree-walk (fn [theSeq]\n         (let [dive (fn dive [node]\n      \t   \t (cons node (when (sequential? node)\n\t\t (mapcat dive (seq node)))))]\n\t\t(dive theSeq)))]\n\t(filter (complement sequential?) (tree-walk theSeq))))","problem":28,"user":"4f1c2336535d64f60314647f"},{"code":"(fn flat [x] \n  (if (coll? x)\n    (mapcat flat x)\n    [x]))","problem":28,"user":"4f5d5202e4b0030a34fb2b38"},{"code":"#(\n(fn [s fs] (if (empty? s) fs \n  (let [ff (first s)] (println ff)\n    (if (or (seq? ff)  (vector? ff) (list? ff))\n      (recur (concat ff (rest s)) fs)\n      (recur (rest s) (conj fs ff )))))) % [])","problem":28,"user":"4f51e8a4e4b03ad3f0c10d2d"},{"problem":28,"code":"(fn [coll]\n  ((fn flt [coll]\n     (if (sequential? coll)\n       (mapcat flt coll)\n       (list coll))) coll))","user":"55058a4fe4b086ebe8a79c89"},{"problem":28,"code":"(fn flat-me [coll]\n  (reduce (fn [memo item]\n            (if (sequential? item)\n              (apply conj memo (flat-me item))\n              (conj memo item))\n            )\n          [] coll)\n  )","user":"53ae16e2e4b047364c044472"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst) ()\n    (list? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n   (vector? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (cons (first lst) (my-flatten (rest lst)))))","user":"59dd387be4b0a0ac046f2502"},{"problem":28,"code":"(fn my-flatten [s] (mapcat #(if (sequential? %) (my-flatten %) [%]) s))","user":"54f5fb57e4b0f2f3c5226e9f"},{"problem":28,"code":"mapcat (fn flat[el] (if (sequential? el) (mapcat flat el) [el]))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"problem":28,"code":"(fn my-flatten [v]\n  (loop [[x & rxs :as xs] v acc []]\n    (if (empty? xs)\n      acc\n      (if (sequential? x)\n        (recur (concat x rxs) acc)\n        (recur rxs (conj acc x))))))","user":"54a31fdae4b09f271ff37c64"},{"problem":28,"code":"#(loop [r [] l %](cond ( sequential? (first l) )  (recur r (concat (first l) (rest l))) \n                       ( empty? l) r\n                       :else\n                       (recur (conj r (first l)) (rest l))))","user":"5686b7c7e4b0dcc4269f4057"},{"code":"(fn f [l]\n  (reduce concat (for [x l]\n                   (if (coll? x)\n                     (f x)\n                     [x]))))","problem":28,"user":"4fea9154e4b0140c20fb9c0a"},{"code":"(fn test [x] (if (sequential? x) (if (not= (count x) 0) (concat (test (first x)) (test (rest x))) '()) (list x)))","problem":28,"user":"52810225e4b0757a1b171418"},{"code":"(fn f\n  [x]\n  (let [l (first x)\n        r (next x)]\n    (concat\n     (if (sequential? l)\n       (f l)\n       [l])\n     (when (sequential? r)\n       (f r)))))","problem":28,"user":"527818f7e4b03e8d9a4a7519"},{"code":"(fn f [xs] (reduce #(let [x %2] (prn x %1 %2) (if (coll? x) (do (prn \"seq \" x) (into (f x) %1)) (do (prn \"not seq \" x) (into [x] %1)))) '() (reverse xs)))","problem":28,"user":"4f724e56e4b07046d9f4f027"},{"code":"(fn flat [lst]\n  (if (coll? lst)\n    (reduce concat () (map flat lst))\n    (list lst)))","problem":28,"user":"4fabb1dce4b081705acca21a"},{"problem":28,"code":"#(\n  filter (complement sequential?) (rest (tree-seq sequential? seq %))\n  )","user":"5885e90de4b0f1effa3b76c5"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          (not (coll? f)) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"5b77d3c8e4b047b03b2036f1"},{"code":"(fn f [x] (cond\n            (sequential? x) (if (empty? x) '() (concat (f (first x)) (f (rest x))))\n            :else [x]\n            ))","problem":28,"user":"52bef782e4b07a9af5792327"},{"problem":28,"code":"(fn my-flatten [coll] (cond\n\t\t\t\t\t\t(empty? coll) '()\n\t\t\t\t\t\t(coll? (first coll))\n\t\t\t\t\t\t\t(concat (my-flatten (first coll))\n\t\t\t\t\t\t\t\t\t(my-flatten (rest coll)))\n\t\t\t\t\t\t:else (cons (first coll) (my-flatten (rest coll)))))","user":"57c0917be4b05aa3c4741c95"},{"problem":28,"code":"(fn flattn [xs] (reduce #(if (coll? %2) (vec (concat %1 (flattn %2))) (conj %1 %2)) [] xs))","user":"5f37263de4b0574c87022c4e"},{"problem":28,"code":"; #28 Flatten a Sequence\n(fn flatten-seq \n  ([s] (flatten-seq s []))\n  ([s res]\n    (if-let [f (first s)]\n\t   (if (coll? f)\n\t     (flatten-seq (next s) (concat res (flatten-seq f [])))\n\t\t   (flatten-seq (next s) (concat res [f])))\n\t\t res)))","user":"4f6543cae4b07046d9f4ef41"},{"problem":28,"code":"(fn [lst] (if (not-any? (fn [elem] (coll? elem)) lst)\n            lst\n            (recur\n             (reduce (fn [acc e] (if (coll? e)\n                                   (apply vector (concat acc e))\n                                   (conj acc e))) [] lst))))","user":"54eee3a3e4b024c67c0cf879"},{"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x)))\n  )","problem":28,"user":"50d324dde4b049d4ed5650d7"},{"problem":28,"code":"(fn [coll]\n  (loop [new-list []\n         head (first coll)\n         tail (rest coll)\n         older-tails '()]\n    (cond (= head nil)\n          (if (empty? older-tails)\n            new-list\n            (recur new-list\n                   (first (first older-tails))\n                   (rest (first older-tails))\n                   (rest older-tails)))\n          (coll? head)\n          (recur new-list\n                 (first head)\n                 (rest head)\n                 (conj older-tails tail))\n          :else\n          (recur (conj new-list head)\n                 (first tail)\n                 (rest tail)\n                 older-tails))))","user":"5899c54de4b00487982d52fa"},{"problem":28,"code":"#(letfn [(normalize [x] (if (coll? x) (flat x) (list x)))\n         (flat [seq] (apply concat (map normalize seq)))]\n   (flat %))","user":"5553b924e4b0deb715856e06"},{"problem":28,"code":"#(letfn [(iter [xs result]\n               (cond (empty? xs) result\n                     (sequential? (first xs)) (iter (rest xs) (iter (first xs) result))\n                     true (iter (rest xs) (concat result (list (first xs))))))]\n   (iter % '()))","user":"4fad9da0e4b081705acca23c"},{"problem":28,"code":"(fn flat [c]\n  (if (coll? c)\n    (mapcat flat c)\n    [c]))","user":"53b9dae0e4b047364c0444ef"},{"problem":28,"code":"(fn unnest [x]\n    (cond\n      (not (coll? x)) [x]\n      (empty? x) '()\n      (coll? (first x)) (concat (unnest (first x))\n                                (unnest (rest x)))\n      :else (cons (first x)\n                  (unnest (rest x)))))","user":"58d9772de4b0a4d5acaab63c"},{"problem":28,"code":"(fn custom-flatten [arr]\n  (reduce #(concat\n            %1\n            (if\n              (or\n               (vector? %2)\n               (list? %2))\n              (custom-flatten %2)\n              [%2]))\n          [] arr))","user":"54c13b87e4b0ed20f4ff6f20"},{"problem":28,"code":"(fn newflatten [x] \n   (loop [xs x flattened '()]\n     (if (seq xs)\n        (if (sequential? (first xs))\n          (recur (concat (first xs) (drop 1 xs)) flattened)\n          (recur (drop 1 xs) (conj flattened (first xs))))\n       (reverse flattened))))","user":"5c8aa1b5e4b048ec896c5959"},{"problem":28,"code":"(fn flat [s] (if (empty? s) s (let [car (first s) cdr (rest s)] (if-not (sequential? car) (cons car (flat cdr)) (concat (flat car) (flat cdr))))))","user":"5a5894d9e4b05d388ecb6c81"},{"problem":28,"code":"(fn flat\n  [c]\n  (if (coll? c)\n    (reduce concat (map flat c))\n    (list c)))","user":"535944d6e4b04ce2eb3ed296"},{"problem":28,"code":"(fn fltn [xs]\n  (when-let [s (seq xs)]\n    (if (coll?  (first s))\n      (concat  (fltn  (first s))  (fltn  (rest s)))\n      (cons  (first s)  (fltn (rest s))))))","user":"546a6c7ce4b00cfc9eacc154"},{"code":"(fn flat [coll] (if (coll? coll) (apply concat (map flat coll)) [coll]))","problem":28,"user":"5127ca90e4b03a34742b42ff"},{"problem":28,"code":"(fn f [s] (if-not (coll? s) (list s) (apply concat (map f s))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn flat [s] (if (coll? s)\r\n                      (if (empty? s) nil (concat (flat (first s)) (flat (rest s))))\r\n                      (list s)))","problem":28,"user":"4e7e55ab535db169f9c79711"},{"code":"(fn [coll]\n (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4ffb529be4b0678c553fc3cd"},{"problem":28,"code":"(fn make-flat [xs]\n  (if (= 0 (count xs))\n  \t'()\n    (let [x (first xs)]\n      (if (sequential? x)\n        (concat (make-flat x) (make-flat (rest xs)))\n        (conj (make-flat (rest xs)) x)))))","user":"56bfcba1e4b060a8e693e3a1"},{"problem":28,"code":"(fn flat\n  [s]\n  (let [f (first s)\n        r (rest s)\n        atom? (complement sequential?)]\n    (cond (empty? s) nil\n          (atom? f) (cons f (flat r))\n          ;; (sequential? f)\n          :else (concat (flat f) (flat r)))))","user":"5907a736e4b047aa04b1995e"},{"problem":28,"code":"(fn f [x]\n  (if (empty? x) x\n  \t(let [h (first x) t (rest x)]\n    \t(if (coll? h) (concat (f h) (f t)) (cons h (f t))))))","user":"559b55d6e4b066d22e731f54"},{"problem":28,"code":"(fn [seq]\n  (reverse (reduce (fn flatterer [acc item]\n                     (if (coll? item)\n                       (reduce flatterer acc item)\n                       (conj acc item)))\n                   '() seq)))","user":"594e31dde4b07ddc2dafaea6"},{"problem":28,"code":"(fn [list]\n  (loop [remaining list flattened []]\n    (if (empty? remaining)\n      flattened\n      (let [x (first remaining)]\n        (if (sequential? x)\n          (recur (concat x (rest remaining)) flattened)\n          (recur (rest remaining) (conj flattened x)))))))","user":"58f00639e4b056aecfd47ddc"},{"problem":28,"code":"(fn [s]\n      (loop [res []\n             s s]\n        (let [x (first s)]\n          (cond\n            (empty? s)      res\n            (not (coll? x)) (recur (conj res x)\n                                   (rest s))\n            :else           (recur res\n                                   (concat x (rest s)))))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":28,"code":"(fn f [c]\n  (reduce (fn [a b]\n             (concat a\n                      (if (sequential? b)\n                          (f b)\n                          (list b))))\n           ()\n           c))","user":"59a24c92e4b066c664927d20"},{"code":"(fn flat [ls] \n  (let [l (first ls) r (next ls)]\n  (concat\n    (if (sequential? l) (flat l) [l])\n    (when (sequential? r) (flat r)))))","problem":28,"user":"4e89de60535d3e98b8023285"},{"problem":28,"code":"(fn [x]\n  (let [f (fn [s] (reduce #(if (coll? %2) (into %1 %2) (conj %1 %2)) []  s))]\n    (loop [s x]\n      (if (some coll? s) (recur (f s)) s))))","user":"54d2c4c5e4b0e8a36923e5fa"},{"problem":28,"code":"(fn fl [a c]\n  (if (= (count c) 0)\n    a\n    (let [x (first c) xs (rest c)]\n      (recur\n        (if (coll? x)\n          (apply (partial conj a) (fl [] x))\n          (conj a x))\n        xs)))) []","user":"56327168e4b0bfe05bf117a5"},{"problem":28,"code":"(fn [toFlatten]\n  (if (every? #(not (coll? %)) toFlatten)\n    toFlatten\n    (recur\n     (reduce\n      (fn [sq el] (if (coll? el) (into [] (concat sq el)) (conj sq el)))\n      []\n      toFlatten)\n     )\n    )\n  )","user":"5ab5f60be4b073f177442643"},{"code":"(fn flat [x]\n   (mapcat \n    #(if (coll? %)\n       (flat %)\n       (list %))\n    x))","problem":28,"user":"528652fbe4b0239c8a67ae14"},{"problem":28,"code":"(fn flat [s]\n  (mapcat #(if (coll? %)\n             (flat %)\n             (list %)) s))","user":"5a4caa20e4b05d388ecb6b94"},{"problem":28,"code":"(fn rec [coll]\n      (reduce\n       #(concat %1 (if (coll? %2) (rec %2) [%2]))\n       '()\n       coll))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":28,"code":"(fn flatten-my\n  [x]\n  (let [f (first x)\n        r (rest x)]\n    (cond (empty? x) nil\n          ((complement coll?) f) (cons f (flatten-my r))\n          :else (concat (flatten-my f) (flatten-my r)))))","user":"59e4fc25e4b08badc2a0c54f"},{"code":"#(reduce (fn my-flatten\n          [acc x]\n          (concat acc (cond (coll? x) (reduce my-flatten [] x) :else [x]))) \n        [] \n        %)","problem":28,"user":"539e717fe4b0ca733b974488"},{"code":"(fn flatten' [s]\n  (let [fst (first s) rst (next s)]\n    (concat\n      (if (sequential? fst)\n          (flatten' fst)\n          [fst])\n      (when (sequential? rst)\n        (flatten' rst)))))","problem":28,"user":"50a407fee4b08bbd0eb4ed32"},{"code":"(fn [n]\r\n  (filter (complement sequential?)\r\n          (tree-seq sequential? seq n)))","problem":28,"user":"4e86fd2d535dceadca46984d"},{"problem":28,"code":"(fn [r]\n  (filter #(not (sequential? %))\n          (tree-seq sequential? seq r)))","user":"591e0782e4b09b4ee5954c25"},{"code":"(fn [x] (filter (complement sequential?)\r\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4ef2da4f535dced4c769f224"},{"problem":28,"code":"#((fn custFlat [seq res]\n   (if (empty? seq)\n     res\n     (if (coll? (first seq)) \n       (custFlat (rest seq) (custFlat (first seq) res)) \n       (custFlat (rest seq) (conj res (first seq)))))) % [])","user":"56ffeafee4b08d47c97781c2"},{"problem":28,"code":"(fn flatten* [notFlat]\n  (if (sequential? notFlat)\n    (mapcat flatten* notFlat)\n    [notFlat]\n    )\n  )","user":"5b92f178e4b0c0b3ffbd4a41"},{"code":"(fn flat [x] (if (empty? x) () (if (coll? (first x))\n                 (concat (flat (first x)) (flat (rest x)))\n                 (cons (first x) (flat (rest x))) )))","problem":28,"user":"4f706cc3e4b07046d9f4eff7"},{"code":"(fn my-flatten [coll] (cond\n                                               (= (first coll) nil) nil\n                                               (coll? (first coll)) (into (my-flatten (rest coll)) (reverse (my-flatten (first coll))))\n                                               :else (conj (my-flatten (rest coll)) (first coll))))","problem":28,"user":"4e62294c535d8ccf87e9fe5f"},{"code":"(fn fl [col] (if (coll? col) (mapcat fl col) (list col)))","problem":28,"user":"525efc76e4b0cb4875a45dbd"},{"code":"(fn flat [x]\n  (cond\n   (coll? x) (mapcat flat x)\n   :else [x]))","problem":28,"user":"4fa09916e4b0dcca54ed6d4e"},{"problem":28,"code":"#(reduce\n  (fn myf [sol item]\n    (if (sequential? item)\n      (reduce myf sol item)\n      (conj sol item)\n      )) [] %)","user":"5bfcdc52e4b0bdcf453d15f4"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (cond \n    (nil? x) []\n    (coll? x) (flat (concat x xs))\n    :else (cons x (flat xs))))","user":"593910eae4b02506e01a29f4"},{"code":"(fn [x]\n                (letfn [(flatten* [x]\n                          (if (sequential? x)\n                            (mapcat flatten* x)\n                            (list x)))]\n                  (flatten* x)))","problem":28,"user":"4e9e4515535dbda64a6f6b95"},{"code":"(fn [x]\r\n  (let [s? #(instance? clojure.lang.Sequential %)]\r\n    (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4e14090d535d04ed9115e7dc"},{"problem":28,"code":"(fn g[s] \n  ((fn r[x res]\n     (cond (or (= x '()) (= x nil)) res\n           (sequential? x) (r (first x) (r (rest x) res))\n           :else (conj res x)))\n       s '()))","user":"53e06f81e4b0d874e779ae4c"},{"code":"(fn fx\n  [[x & xs]]\n  (cond (nil? x) '()\n        (coll? x) (concat (fx x) (fx xs))\n        :else (conj (fx xs) x)))","problem":28,"user":"50e09313e4b061dbdced7233"},{"problem":28,"code":"(fn [clean tail]\n  (if (empty? tail) (reverse clean)\n    (let [f (first tail)\n          r (rest tail)]\n      (if (coll? f)\n        (recur clean (concat (list (first f)) (rest f) r))\n        (recur (conj clean f) r)))))\n()","user":"56bf4ac0e4b0f26550335985"},{"problem":28,"code":"#(filter\n  (complement sequential?) (rest (tree-seq sequential? seq %)))","user":"5a9cdec0e4b0d174b936c7e1"},{"problem":28,"code":"(fn[x](filter (complement sequential?) (tree-seq sequential? identity x)))","user":"6001460ce4b074f607df6611"},{"problem":28,"code":"(fn flat [res x]\n   (if (empty? x)\n     res\n     (let [head (first x)\n           tail (rest x)]\n       (if (or (seq? head) (vector? head))\n         (flat (vec (flat res head)) tail)\n         (flat (conj (vec res) head) tail)))\n     )) '()","user":"5ff5bc1ae4b06df49cee1490"},{"code":"#(loop [x %] (if (every? (comp not coll?) x) x \n               (recur (apply concat (for [t x] (if (coll? t) t (list t)))))))","problem":28,"user":"52808897e4b0757a1b171404"},{"problem":28,"code":"(fn flat [x]\n  (cond (empty? x) '()\n        (sequential? (first x)) (concat (flat (first x)) (flat (rest x)))\n        :else (conj (flat (rest x)) (first x))))","user":"5d931a58e4b0d3f9b434ad10"},{"problem":28,"code":"(fn myflatten [coll]\n  \n  (if (sequential? coll)\n    (if (empty? coll)\n      '() \n      (concat (myflatten (first coll)) (myflatten (rest coll))))\n    (list coll)))","user":"5e8c0c5be4b0cb0169546320"},{"code":"(fn my-flatten [coll]\r\n  (if (coll? coll)\r\n    (concat (my-flatten (first coll)) (my-flatten (next coll)))\r\n    (if (nil? coll) nil (list coll))))","problem":28,"user":"4ee9d697535d93acb0a66895"},{"problem":28,"code":"(fn flatSeq [x]\n  (if (empty? x)\n    nil\n    (let [fX (first x)\n          fFlatX (if (or (seq? fX) (vector? fX)) (flatSeq fX) (list fX))\n          rFlatX (flatSeq (rest x))]\n      (concat fFlatX rFlatX))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":28,"code":"(fn \n  f [x] \n  (if (coll? x) (mapcat f x) [x]))","user":"59dd3930e4b0a0ac046f2504"},{"problem":28,"code":"(fn flatn [l] (if (sequential? l)\n                (apply concat (map flatn l))\n                (list l)))","user":"5e6ba862e4b04a83ad7cd27d"},{"problem":28,"code":"(fn mimimimimimi [l]\n  (cond (empty? l) '()\n        (sequential? (first l)) (concat (mimimimimimi (first l)) (mimimimimimi (rest l)))\n        :else (conj (mimimimimimi (rest l)) (first l))))","user":"56acca9ae4b03c432f18734c"},{"code":"(fn fl [l]\n  (mapcat #(if (coll? %) (fl %) (list %)) l))","problem":28,"user":"4ff9f5c5e4b0678c553fc3b4"},{"problem":28,"code":"(fn [x]\n  (reverse\n  (loop [in x\n         out '()]\n    (cond\n     (empty? in) out\n     (seq? (first in)) (recur (concat (first in) (rest in)) out)\n     (vector? (first in)) (recur (concat (first in) (rest in)) out)\n     :else (recur (rest in) (cons (first in) out))))))","user":"594bd637e4b07ddc2dafae41"},{"problem":28,"code":"(fn my-flatten [xs] (if (coll? xs) (mapcat my-flatten xs) [xs]))","user":"5f82cfcce4b0c071e6c840fb"},{"problem":28,"code":"(fn flattten [xs]\n  (reduce #(concat %1 (if (sequential? %2) (flattten %2) [%2])) '() xs))","user":"54995298e4b0b312c081ff8b"},{"code":"(fn flattenA [coll]\n  (if (seq coll)\n    (let [[a & as] coll]\n      (if (coll? a)\n        (concat (flattenA a) (flattenA as))\n        (cons a (flattenA as))))))","problem":28,"user":"4f28c979e4b0d6649770a01a"},{"problem":28,"code":"reduce (fn foo [out x] (if (coll? x) (reduce foo out x) (conj out x))) []","user":"56771b31e4b05957ce8c6163"},{"problem":28,"code":"(fn flatt [l]\n  (if (coll? l)\n    (if (empty? l)\n      ()\n      (concat (flatt (first l)) (flatt (rest l))))     \n    (list l)\n    )\n  )","user":"53e745a1e4b036ad0777e479"},{"code":"(fn flat [x] (reduce (fn [xs el] (if (sequential? el) \n                                     (concat xs (flat el)) \n                                     (concat xs [el]))\n                                 )\n                     [] x))","problem":28,"user":"52bf8e35e4b07a9af579233a"},{"code":"(fn flat [things]\r\n  (cond (or (seq? things) (vector? things))\r\n  (apply concat (map flat things))\r\n\ttrue (list things)))","problem":28,"user":"4ddc1c89535d02782fcbea01"},{"problem":28,"code":"(fn foo [x]\n  (if (empty? x)\n    '() \n    (if (sequential? (first x)) \n      (into   (foo (rest x)) (into   (foo (list (first(first x))))  (foo (rest (first x)))  )    ) \n      (conj   (foo (rest x)) (first x)  )\n    )      \n  )\n)","user":"54078851e4b0addc1aec66bd"},{"code":"(fn flatten1 [lst]\n  (lazy-seq\n    (if (empty? lst) lst\n        (let [[x & xs] lst]\n          (if (coll? x)\n            (concat (flatten1 x) (flatten1 xs))\n            (cons x (flatten1 xs)))))))","problem":28,"user":"502fb9bee4b0f8db655c4ee2"},{"code":"(fn [coll]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq coll)))","problem":28,"user":"5068fa8ee4b0c0169921a8e5"},{"code":"(fn flat [x]\n  (if (coll? x)\n      (mapcat flat x)\n      [x]))","problem":28,"user":"4db1b5841254ad5b4805fa70"},{"code":"(fn flatr [x]\n  (if (coll? x) (mapcat flatr x) [x])\n)","problem":28,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":28,"code":"#(loop [coll %\n        results []]\n   (print coll \"---\" results \"\\n\")\n   (if (empty? coll)\n     (reverse (into '() results))\n     (let [ele-is-non-mt-coll (and (coll? (first coll))\n                                   (not (empty? (first coll))))]\n       (if ele-is-non-mt-coll\n         (recur (conj (rest coll)\n                      (rest (first coll))\n                      (first (first coll)))\n                results)\n         (recur (rest coll)\n                (if (not (coll? (first coll)))\n                  (conj results (first coll))\n                  results))\n         ))))","user":"55f344afe4b06e875b46ce5a"},{"problem":28,"code":"(fn flat [coll]\n  (mapcat #(if (sequential? %) (flat %) [%]) coll))","user":"548c6673e4b0e286459a1209"},{"code":"(fn flat [sq]\n  (loop [rem-sq sq\n         flat-sq '()]\n    (cond \n     (sequential? (last rem-sq))\n      (recur (butlast rem-sq) (concat (flat (last rem-sq)) flat-sq ))\n\t\t (nil? (last rem-sq))\n     \tflat-sq\n     :else\n     \t(recur (butlast rem-sq) (cons (last rem-sq) flat-sq) ))))","problem":28,"user":"50e35b2de4b094329ae7f4bb"},{"code":"#(filter (comp not sequential?) (rest (tree-seq sequential? seq %)))","problem":28,"user":"4ef0a39b535dced4c769f20c"},{"code":"(fn f [x]\r\n     (if ((complement sequential?) x)\r\n\t       (list x)\r\n\t       (if (empty? x)\r\n\t\t   ()\r\n\t\t   (concat (f (first x)) (f (rest x))))))","problem":28,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn f [s]\n  (if (empty? s)\n    '()\n    (if (sequential? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (conj (f (rest s)) (first s)))))","problem":28,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":28,"code":"(fn f [s]\n  (loop [r s\n         a '()]\n    (if (empty? r)\n      a\n      (let [p (first r)\n            n (rest r)]\n        (if (sequential? p)\n        (recur n\n               (concat a (f p)))\n        (recur n\n               (concat a `(~p))))))))","user":"55995fa7e4b031d6649c9ba9"},{"code":"#(loop [res []\n       n %]\n  (let [ next-elem (first n)\n         res-els (rest n)]\n    ; (println (str \"res: \" res))\n    ; (println (str \"n: \" n))\n    ; (println (str \"next-elem: \" next-elem))\n    ; (println (str \"res-els: \" res-els))\n  \n    (if next-elem\n      (if (coll? next-elem)\n        (recur res (concat next-elem res-els))\n        (recur (conj res next-elem) res-els))\n      res)))","problem":28,"user":"531d53dbe4b08068f379edae"},{"problem":28,"code":"(fn my-flatten [xs]\n  (loop [xs' xs \n         acc nil]\n    (if (empty? xs')\n      acc\n      (let [x (first xs')]\n        (recur (next xs') \n               (if (coll? x)\n                 (concat acc (my-flatten x))\n                 (conj (vec acc) x)))))))\n\n;(fn my-flatten [xs]\n;  (loop [xs' xs \n;         acc nil]\n;    (if (empty? xs')\n;      acc\n;      (let [x (first xs')]\n;        (if (coll? x)\n;          (recur (next xs') (concat acc (my-flatten x)))\n;          (recur (next xs') (conj (vec acc) x)))))))","user":"56255e2de4b00a550fc90297"},{"code":"(fn flat [s]\n  (if (empty? s)\n     '()\n     (if (instance? clojure.lang.Seqable (first s))\n       (concat (flat (first s)) (flat (rest s)))\n       (conj (flat (rest s)) (first s)))))","problem":28,"user":"4f04d011535dcb61093f6be5"},{"problem":28,"code":"(fn my-flatten [coll]\n   (reduce \n     (fn [acc x]\n       (if (sequential? x)\n         (concat acc (my-flatten x))\n         (conj (vec acc) x))) \n     [] \n     coll))","user":"5630ce72e4b0bfe05bf11786"},{"problem":28,"code":"(fn flat1 [sc] (loop [c sc, res [], tc []]\n    (cond\n     (coll? (first c)) (recur (first c) res (conj tc (rest c)))\n     (empty? c) (if (empty? tc) res\n                  (recur (first tc) res (rest tc)) )\n     :else (recur (rest c) (conj res (first c)) tc)\n    )\n))","user":"55adf4d7e4b03311e7b732af"},{"problem":28,"code":"(fn [s] (filter (complement sequential?)\n                    (tree-seq sequential? seq s)))","user":"58468c4ee4b089d5ab817e95"},{"code":"(fn goflat [L]\n  (cond\n    (empty? L) L\n    (sequential? (first L))\n      (concat (goflat (first L)) (goflat (rest L)))\n    :else (cons (first L) (goflat (rest L)))))","problem":28,"user":"50afa883e4b0c3f5ed5c29a2"},{"problem":28,"code":"(fn flatten' [s]\n  (let [s (seq s)]\n    (reverse\n      (reduce\n        (fn [accum elem]\n          (if (sequential? elem)\n            (reduce\n              (fn [inner_accum inner_elem]\n                (conj inner_accum inner_elem))\n              accum\n              (flatten' elem))\n            (conj accum elem)))\n        ()\n        s))))","user":"5fcdb9f5e4b07e53c2f3effe"},{"problem":28,"code":"(fn flatt\n  [ll]\n  (mapcat #(if (sequential? %) (flatt %) (list %)) ll))","user":"52f8b86de4b047fd55836fdb"},{"code":"(fn f [xs] (reduce concat (map (fn [x] (if ((some-fn vector? list?) x) (f x) (list x))) xs)))","problem":28,"user":"52f89125e4b047fd55836fd4"},{"problem":28,"code":"(fn f [coll]\n  (when-let [[x & more] (seq coll)]\n    (if (coll? x)\n      (concat (f x) (f more))\n      (cons x (f more)))))","user":"55fcaccfe4b0f488688e0679"},{"problem":28,"code":"(fn flttn [x]\n  (cond ((complement sequential?) x) (list x)\n        :else (mapcat flttn x)))","user":"5f67c2f8e4b02876ed9fd039"},{"problem":28,"code":"(fn flat [c] \n  (reduce \n   (fn [a b] \n    (concat \n     a\n     (if (coll? b)\n       (flat b)\n       (list b)\n      )\n    )\n   )\n   '()\n   c\n  )\n)","user":"5776385fe4b0979f89651632"},{"problem":28,"code":"(fn flt [x]\n  (loop [source x destination '()]\n    (if (empty? source)\n      destination\n      (if (sequential? (first source))\n        (recur (rest source) (concat destination (flt (first source))))\n        (recur (rest source) (concat destination (list (first source))))\n        )\n      )\n    ))","user":"55bbb28be4b01b9910ae29ea"},{"code":"(fn flat [s] (reduce (fn [a x] (if (or (seq? x) (vector? x)) (concat a (flat x)) (concat a (list x)) )) '() s))","problem":28,"user":"50e8ff6be4b0ebbe794eb7f3"},{"problem":28,"code":"(fn my-flatten\n  [[head & tail]]\n  (if (nil? head)\n    nil\n    (if (coll? head)\n      (concat (my-flatten head) (my-flatten tail))\n      (cons head (my-flatten tail)))))","user":"56685a73e4b04acd4f672de5"},{"problem":28,"code":"(fn [coll] \n  (let [res (atom [])] \n    (clojure.walk/postwalk \n     (fn [f] \n       (when-not (sequential? f)\n         (swap! res conj f))) \n     coll) \n    @res))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":28,"code":"(fn my-flatten [s]\n  (mapcat #(if (or (vector? %) (seq? %)) (my-flatten %) (list %)) s))","user":"5e950178e4b0fbed045a3801"},{"code":"(fn my-flatten [args] (reduce (fn [acc x] (into acc (if (sequential? x) (my-flatten x) [x]))) [] args))","problem":28,"user":"4ea5ba92535d7eef308072d9"},{"problem":28,"code":"(fn flt [sq]\n  (loop [flat-seq '() sq sq head (first sq)]\n    (cond\n      (empty? sq) flat-seq\n      (not(coll? head)) (recur (concat flat-seq [head]) (rest sq) (first (rest sq)))\n      :else (recur (concat flat-seq (flt head)) (rest sq) (first (rest sq)))))\n  )","user":"5831846ae4b051871117c02c"},{"problem":28,"code":"(fn [s]\n  (let [f (fn f [r s]\n            (if (or (list? s) (vector? s))\n              (loop [r r s s]\n                (if (empty? s)\n                  r\n                  (recur (f r (first s)) (rest s))))\n              (conj r s)))]\n    (reverse (f () s))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":28,"code":"(fn flatten-seq\n  ([s] (flatten-seq [] s))\n  ([r s]\n   (loop [res r src s]\n     (if (empty? src)\n       res\n       (recur\n        (cond\n          (seq? (first src)) (flatten-seq res (first src))\n          (vector? (first src)) (flatten-seq res (first src))\n          :else (conj res (first src)))\n        (drop 1 src))))))","user":"57b6edf6e4b0fbc9809a27c8"},{"code":"(fn flt [elem]\n  (if (coll? elem) (mapcat flt elem) [elem]))","problem":28,"user":"50f01f44e4b0bdaecbb47daf"},{"problem":28,"code":"(fn [arg]\n   (   (fn flatten2 [x]\n         (reduce\n           (fn [acc curr]\n             (cond (sequential? curr)\n                   (concat acc (flatten2 curr))\n                   :else (concat acc [curr])))\n           [] x)) arg))","user":"5c02c9a8e4b0bdcf453d1667"},{"code":"#(filter (complement sequential?) \n  (tree-seq sequential? seq %))","problem":28,"user":"4dcfbc44535d5973398f92a7"},{"problem":28,"code":"(fn flatten-it [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flatten-it l)\n        [l])\n      (when (sequential? r)\n        (flatten-it r)))))","user":"56cb3acfe4b0ea9b8538f727"},{"problem":28,"code":"(fn [s]\n  (loop [s s o []]\n    (if (empty? s)\n      o\n      (if (coll? (first s))\n        (recur (concat (first s) (rest s)) o)\n        (recur (rest s) (conj o (first s))))\n    )))","user":"511e17a9e4b0c5b849dd36b0"},{"problem":28,"code":"(fn x [s]\n  (filter (complement sequential?) (tree-seq sequential? seq s)))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":28,"code":"(fn fltn [x] \n  (loop [a x\n         curr '()]\n    (if (empty? a)\n      curr\n      (if (coll? (first a))\n        (recur (rest a) (concat curr (fltn (first a))))\n        (recur (rest a) (concat curr (list (first a))))\n      )\n    )\n  )\n)","user":"5c3f6322e4b08cd430848e97"},{"problem":28,"code":"(fn a [x] (if (not-any? coll? x) x (reduce concat (map (fn [y] (if (coll? y) (a y) [y])) x))))","user":"5657fc1ae4b0f9d632dd84ad"},{"problem":28,"code":"#(loop\n   [l % ret '()]\n   (cond\n    (empty? l) (reverse ret)\n    (sequential? (first l)) (recur (concat (first l) (rest l)) ret)\n    :else (recur (rest l) (conj ret (first l)))))","user":"5e6e6537e4b04a83ad7cd29a"},{"problem":28,"code":"#(filter (complement sequential?) ( tree-seq sequential? seq % ))","user":"5b98f7f3e4b0c0b3ffbd4ac2"},{"code":"(fn enflat [x]\r\n     (if (not (coll? x))\r\n       [x]\r\n       (mapcat enflat x)))","problem":28,"user":"4f71db68e4b07046d9f4f015"},{"code":"(fn fl [s]\n  (if (empty? s)\n    s\n    (let [head (first s)\n          tail (rest s)]\n      (if (coll? head)\n        (concat (fl head) (fl tail))\n        (cons head (fl tail))))))","problem":28,"user":"504e0136e4b078edc5f5938e"},{"code":"(partial clojure.walk/postwalk #(if (coll? %) (apply concat %) (list %)))","problem":28,"user":"50d8de3fe4b01f0871336e72"},{"code":"(fn my-flatten [x]\n  (if (sequential? x) (mapcat my-flatten x) (list x)))","problem":28,"user":"5201ff99e4b0b2e020a18f26"},{"problem":28,"code":"(fn my_flatten [coll]\n     (mapcat #(if (coll? %) (my_flatten %) [%]) coll)\n     )","user":"56349008e4b0bfe05bf117bd"},{"problem":28,"code":"(fn flat [c]\n\t(loop [c c]\n\t\t(if (some sequential? c)\n\t\t\t(recur (reduce (fn [acc v] \n\t\t\t\t\t\t(if (sequential? v)\n\t\t\t\t\t\t\t(concat acc v) \n\t\t\t\t\t\t\t(concat acc [v])\n\t\t\t\t\t\t\t)) \n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\tc))\n\t\t\tc)))","user":"57c0393be4b05aa3c4741c90"},{"problem":28,"code":"(fn flat [[h & t]]\n  (concat (if (sequential? h) (flat h) [h])\n          (when t (flat t))))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn flat [l] (reduce #(apply conj %1 (if (coll? %2) (flat %2) [%2])) [] l))","problem":28,"user":"53736ffce4b06d7f452d9e11"},{"code":"(fn flatn [s]\n  (reduce \n    #(if (coll? %2) (apply conj %1 (flatn %2)) \n                    (conj %1 %2)) [] s)\n)","problem":28,"user":"4f12ab23535d64f603146429"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (sequential? s)\n    (mapcat my-flatten s)\n   [s]))","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":28,"code":"#(apply \n  (fn [memo x]\n    (cond\n      (empty? x) memo\n      (sequential? (first x)) (recur memo (concat (first x) (rest x)))\n      :else (recur (concat memo [(first x)]) (rest x))))\n  [[] %])","user":"5dc98501e4b02f9375f4e1e6"},{"code":"#(filter \n  (complement sequential?) \n  (tree-seq sequential? seq %))","problem":28,"user":"4e89f9e5535d3e98b8023289"},{"code":"(fn flatter\n  [theseq]\n  (cond\n   (empty? theseq) nil\n   (sequential? (first theseq)) (concat (flatter (first theseq)) (flatter (rest theseq)))\n   true (cons (first theseq) (flatter (rest theseq)))))","problem":28,"user":"52091d57e4b0e152394d76f0"},{"problem":28,"code":"(fn flat [x]\n  (if (sequential? x)\n    (apply concat (map flat x))\n    [x]))","user":"5a012a43e4b01bb0ae8afd42"},{"code":"(fn flat [col]\n  (reduce \n   #(if (coll? %2)\n     \t(if (vector? %2) (concat %1 (flat %2)) (concat (flat %2) %1))\n      \t(concat %1 [%2]))\n   []\n   col))","problem":28,"user":"538c6db7e4b0b51d73faae5a"},{"problem":28,"code":"(fn flat [coll] (let [a (first coll) b (next coll)] (concat (if (sequential? a) (flat a) [a]) (when (sequential? b) (flat b)))))","user":"52c634b1e4b0c2d177d6210a"},{"code":"(fn [s] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","problem":28,"user":"4f282da7e4b0d6649770a013"},{"problem":28,"code":"(fn my_flat [x]\n  (if (coll? x)\n    (mapcat my_flat x)\n    [x]\n   )\n )","user":"5a45aaece4b05d388ecb6b3f"},{"problem":28,"code":"(fn flatten1\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"595e1ba7e4b066ee0a44b036"},{"problem":28,"code":"(fn [s] (if (some sequential? s)\n          (recur (apply concat\n                        (map #(if (sequential? %) % (list %))\n                             s)))\n          s))","user":"5400fc30e4b0de5c4184861b"},{"problem":28,"code":"(fn flt [xs] \n  (if (sequential? xs)\n    (mapcat flt xs)\n    (list xs)))","user":"5cea0bd4e4b0a17bb84e2bc9"},{"code":"(fn f [[h & r]]\n  (concat (if (sequential? h) (f h) [h])\n          (if (nil? r) [] (f r))))","problem":28,"user":"50ed4626e4b01236b1d4983c"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (reduce (fn [acc current]\n            (if (not (sequential? current))\n              (conj acc current)\n              (vec (concat acc (my-flatten current)))\n              )\n            )\n    []\n    s)\n  )","user":"6096d37be4b00e9e6653c3f0"},{"code":"(fn my_flatten [seq]\n  (if (and (or (seq? seq) (vector? seq)) (not (empty? seq)))\n  \t(concat (my_flatten (first seq)) (my_flatten (rest seq)))\n\t\t(if (not (or (seq? seq) (vector? seq))) (list seq))\n\t)\n)","problem":28,"user":"4e653558535d8ccf87e9fe6f"},{"code":"(fn flatter [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flatter l)\n        [l])\n      (when (sequential? r)\n        (flatter r)))))","problem":28,"user":"5073e7fde4b054001656accb"},{"problem":28,"code":"; in the process of researching, eventually just dug into the flatten impl. ... so I've cheated here\n#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))","user":"54e3bd3fe4b024c67c0cf7e0"},{"problem":28,"code":"(fn [coll]\n  (seq\n    (reduce\n      (fn my-flatten [v e]\n        (if (coll? e)\n          (reduce my-flatten v e)\n          (conj v e)))\n      [] coll)))","user":"5c31517de4b0d62ef62d9f28"},{"code":"(fn f [s]\n  (mapcat #(if (coll? %)\n             (f %)\n             [%])\n          s))","problem":28,"user":"4e7dd982535db169f9c796ee"},{"code":"(fn flat [x]\n  (if (coll? x) \n    (mapcat flat x)\n    [x]))","problem":28,"user":"532c9dc9e4b019098a6f8b30"},{"code":"(fn fake-flatten [lists]\n   (apply concat\n          (for [item lists]\n            (if (sequential? item)\n              (fake-flatten item)\n              (list item)))))","problem":28,"user":"53838742e4b06839e8705ee0"},{"problem":28,"code":"(fn flat\n  [col]\n  (let [f (first col) r (rest col)]\n    (cond\n     (empty? col) []\n     (coll? f) (concat (flat f) (flat r))\n     :else (cons f (flat r)))))","user":"59874ff6e4b021a7a535fea1"},{"problem":28,"code":"(fn me [xs]\n    (if-not (coll? xs) \n      (list xs) \n      (mapcat me xs)))","user":"4fa68ed4e4b081705acca1bb"},{"code":"(fn flt [[x & s :as whole]]\n  (cond (empty? whole) '()\n        (coll? x) (concat (flt x) (flt s))\n        true (cons x (flt s))))","problem":28,"user":"4eb99b3d535dfed6da9c6d57"},{"problem":28,"code":"(fn a [l]\n       (if (empty? l) l\n  \t   (if (coll? (first l)) (concat (a (first l)) (a (rest l)))\n               (conj (a (rest l)) (first l)))))","user":"5b4a0ce3e4b02d533a91bc92"},{"code":"(fn [s] \r\n  (#(filter (complement sequential?) (rest (tree-seq sequential? seq s)))))","problem":28,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn myflat [x]\n  (loop [x x acc '()]\n    (if (nil? x)\n      acc\n      (recur (next x)\n        (concat acc\n          (if (coll? (first x))\n            (myflat (first x))\n            (list (first x))))))))","problem":28,"user":"4eaed3a7535d7eef30807328"},{"code":"(fn flatn [coll]\n  (if (empty? coll)\n    coll\n    (if (sequential? (first coll))\n    (concat (flatn (first coll)) (flatn (rest coll)))\n    (cons          (first coll)  (flatn (rest coll))))))","problem":28,"user":"4e223bd6535d04ed9115e81c"},{"code":"(partial (fn g [a s]\n  (reduce \n    (fn [l, e]\n      (if (sequential? e)\n        (g l e)\n        (conj l e)))\n    a s)) [])","problem":28,"user":"4e67b0aa535d8ccf87e9fe80"},{"problem":28,"code":"(fn flat [data]\n  (cond\n    (sequential? data)\n    (let [tail (rest data)]\n      (concat (flat (first data))\n              (if (empty? tail)\n                tail\n                (flat (rest data)))))\n    \n    :else (list data)))","user":"55664950e4b0c656e3ff1832"},{"problem":28,"code":"(fn flattens [xs]\n  (lazy-seq\n   (reduce (fn --internal-flatten [col v]\n             (if (sequential? v)\n               (reduce --internal-flatten col v)\n               (conj col v)))\n           []\n           xs)))","user":"56252effe4b00a550fc90294"},{"code":"(fn fl [lst]\n   (reduce #(if (coll? %2)\n              (into % (fl %2))\n              (conj % %2))\n           [] lst))","problem":28,"user":"524f213be4b0541d1855b7ff"},{"problem":28,"code":"(fn [seq]\n  (letfn [\n          (ss [i] (if (coll? i) (mc i) [i]))\n          (mc [s]\n              (mapcat ss s))]\n    (mc seq)))","user":"54b04708e4b09f271ff37d11"},{"problem":28,"code":"(fn flat [coll]\n  (reduce #(if (coll? %2)\n             (into %1 (flat %2))\n             (conj %1 %2))\n          []\n          coll))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":28,"code":"(fn [l] \n(loop [l1 l, l2 `()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))","user":"4e526cc4535d302ef430da74"},{"code":"(fn flat [aseq]\n        (reduce (fn [accum x]\n                  (if (sequential? x)\n                    (concat accum (flat x))\n                    (concat accum (list x))))\n                []\n                aseq))","problem":28,"user":"5311081be4b08068f379ece3"},{"code":"(fn my-flatten [l]\n  (if (empty? l)\n    '()\n    (let [head (first l) tail (rest l)]\n      (if (sequential? head)\n        (concat (my-flatten head) (my-flatten tail))\n        (cons head (my-flatten tail))))))","problem":28,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":28,"code":"(fn foo\n          ([xs] (foo xs []))\n          ([xs result]\n           (if (empty? xs)\n             result\n             (if-not (sequential? (first xs))\n               (foo (rest xs) (vec (conj result (first xs))))\n               (foo (rest xs) (vec (concat result (foo (first xs)))))))))","user":"5c995fa4e4b048ec896c5a96"},{"problem":28,"code":"(fn fl [x] (let [l (first x) r (next x)] (concat (if (sequential? l) (fl l) [l]) (when (sequential? r) (fl r)))))","user":"55bb6a19e4b01b9910ae29e5"},{"code":"(fn flat \r\n   ([ a ]\r\n     (if (coll? a) (apply flat a) [a]))\r\n   ([a & r]\r\n     (concat (flat a) (apply flat r))))","problem":28,"user":"4deff9f9535d08e6dec9fe15"},{"problem":28,"code":"(fn flatten2 [[x & xs]]\n  (if (= nil x) ()\n    (if (not (coll? x))\n      (cons x (flatten2 xs))\n      (concat (flatten2 x) (flatten2 xs)))))","user":"56228d00e4b03f08ee9a9227"},{"code":"(fn flat [x]\n  (if (sequential? x)\n\t\t(mapcat flat x)\n\t\t[x]))","problem":28,"user":"4fa67030e4b081705acca1b7"},{"problem":28,"code":"(fn flt [l]\n         (cond\n           (not (sequential? l)) (list l)\n           (empty? l) '()\n           :else (concat (flt (first l))\n                         (flt (rest l)))))","user":"5f0b8243e4b0f30dddfb5d45"},{"problem":28,"code":"(fn flttn [s]\n  (if-not (coll? s)\n    [s]\n    (mapcat flttn s)))","user":"599475aae4b0b211ea3aaac8"},{"problem":28,"code":"(fn my-f1 [x]\n  (loop [y x z (empty x)]\n    (if (nil? y) z\n      (if (coll? (first y))\n        (recur (next y) (concat z (my-f1 (first y))))\n        (recur (next y) (concat z (list (first y))))\n      )\n    )\n    )\n  )","user":"55f95de6e4b03cbcff9738c1"},{"code":"(fn flatt [subseq] \n                            (println subseq \" \")\n                            (if (and (or (seq? subseq) (vector? subseq)) (not (empty? subseq)))\n                            (concat (flatt (first subseq)) (flatt (rest subseq)) )\n                            (if (or (seq? subseq) (vector? subseq)) subseq [subseq])\n                            ))","problem":28,"user":"4ea31da2535d7eef308072c1"},{"code":"(fn fl [xs]\n  (if (coll? xs)\n    (apply concat (map fl xs))\n    [xs]))","problem":28,"user":"4ee88269535d93acb0a6687f"},{"code":"(fn [coll] (filter #(not (sequential? %)) (tree-seq sequential? seq coll)))","problem":28,"user":"4ed3c783535d44c135fd68f6"},{"code":"(fn flat [x]\r\n  (let [s? #(instance? clojure.lang.Sequential %)]\r\n    (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4e2f377a535deb9a81d77f10"},{"problem":28,"code":"(fn s28 [x]\n  (if (coll? x)\n  (mapcat s28 x)\n  (vector x)))","user":"5e9e642ce4b00a66d4a95174"},{"problem":28,"code":"(fn fl [s] \n (loop [t nil s s]\n  (if t s (let \n           [r\n            (reduce #(if (coll? %2) (into % %2)  (conj % %2)) [] s)\n            t (empty? (filter coll? r))] (recur t r)))))","user":"5b9ae606e4b0c0b3ffbd4af2"},{"code":"(fn mflatten [col]\n  (cond \n   (not (coll?  col)) col\n   \n   (empty? col) []\n   (coll? (first col)) (concat (mflatten (first col)) (mflatten (rest col)))\n   :else (cons (first col) (mflatten (rest col)) )\n            \n  ))","problem":28,"user":"51427a8be4b0b50abeb46b37"},{"code":"(fn [coll]\r\n  (loop [coll coll, acc []]\r\n    (if (seq coll)\r\n      (if (coll? (first coll))\r\n        (recur (concat (first coll) (rest coll))\r\n               acc)\r\n        (recur (rest coll)\r\n               (conj acc (first coll))))\r\n      acc)))","problem":28,"user":"4dbb1126535d1e037afb21b3"},{"code":"(fn my-flatten [seq]\n  (if (not (coll? seq))\n    [seq]\n    (if ((fn flat? [seq] \n      (every? (fn [e] (not (coll? e))) seq)) seq)\n      seq\n      (concat (my-flatten (first seq)) (my-flatten (rest seq))))))","problem":28,"user":"538c3424e4b0b51d73faae58"},{"code":"(fn [x] (\n         filter \n         (complement sequential?) \n         (rest \n          (tree-seq \n           sequential?\n           identity\n           x))))","problem":28,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":28,"code":"(fn my-fl [cll]\n  (if (coll? cll)\n    (reduce concat (map my-fl cll))\n    (conj nil cll)))","user":"5537f30fe4b09218d5f44fd8"},{"code":"(fn [x]\n  (filter (complement sequential?)\n            (rest (tree-seq sequential? seq x))))","problem":28,"user":"5012ec0ae4b0c87326002230"},{"problem":28,"code":"(fn flattenThingWok\n  [arg]\n  (println \"arg\" arg)\n  (if (nil? arg)\n    (println \"fin\")\n    (cond\n      (and (sequential? arg) (empty? arg)) (println \"fin2\")\n      (sequential? arg) (concat (flattenThingWok (first arg)) (flattenThingWok (rest arg)))\n      :else (list arg))))","user":"57c731ede4b05aa3c4741d00"},{"code":"(fn\n  [Seq]\n  (first\n    (filter\n      #(not-any? coll? %)\n      (iterate\n        (fn [s]\n          (reduce concat (map #(if (coll? %) % (list %)) s)))\n        Seq))))","problem":28,"user":"4fa3f91fe4b081705acca196"},{"problem":28,"code":"(fn [s]\n  (loop [[e & r] s\n         a []]\n   (cond\n     (and (nil? e)(nil? r)) a\n     ((complement sequential?) e) (recur r (conj a e))\n     (empty? e) (recur r a)\n     :else (recur (apply conj (vector (first e)) (rest e) r) a)\n     )))","user":"5e042dede4b0a607a9a45d69"},{"problem":28,"code":"(fn l [xs] \n    (filter (complement sequential?)\n      (rest (tree-seq sequential? seq xs)))\n  )","user":"5c3de434e4b0d62ef62d9fb8"},{"code":"(fn make-flat [s]\n  (if (sequential? s)\n    (mapcat make-flat s)\n    (list s)))","problem":28,"user":"505345d9e4b0517ede0d0a06"},{"problem":28,"code":"#_(fn my-flatten\n  [coll]\n  (let [left (first coll)\n        right (next coll)]\n    (concat\n      (if (sequential? left)\n        (my-flatten left)\n        [left])\n      (when (sequential? right)\n        (my-flatten right)))))\n\n(fn my-flatten [xs]\n  (remove coll?\n    (tree-seq coll? identity xs)))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":28,"code":"(fn fltn\n  [seq]\n  (if (isa? (type seq) java.util.List)\n    (if (not-any? #(isa? (type %) java.util.List) seq)\n      seq\n      (apply concat (map fltn seq)))\n    (list seq)))","user":"5b2927a0e4b063e2438bcc5e"},{"code":"#(reduce (fn make-flat [a b]\n  (if (sequential? b)\n    (reduce make-flat a b)\n    (concat a (list b))\n  )\n) '() %)","problem":28,"user":"4e781a2e535d324fb2983d74"},{"code":"(fn flatn [coll] \n  (if (empty? coll) \n    coll \n    (if (sequential? (first coll)) \n    (concat (flatn (first coll)) (flatn (rest coll))) \n    (cons          (first coll)  (flatn (rest coll))))))","problem":28,"user":"4f0446f9535dcb61093f6bb8"},{"code":"(fn [seq]\n(letfn [(flt [xs ]\n  (reduce #(if (sequential? %2)\n             (concat %1 (flt %2))\n             (concat %1 (vector %2)))\n          '() xs))] (flt seq)) )","problem":28,"user":"52d24f60e4b099d49816f0a8"},{"problem":28,"code":"(fn [coll]\n  (seq\n   ( reduce (fn myf [v x]\n           (if (coll? x)\n             (reduce myf v x)\n             (conj v x)\n           )\n              ) [] coll\n     )\n   )\n  )","user":"550f70bee4b06e50f9beb177"},{"problem":28,"code":"(fn flatten2 [z a] (reduce (fn [x y] \n                           (cond\n                             (sequential? y) (flatten2 x y)\n                             :else (conj x y))) z a)) []","user":"51c8f1d8e4b07ef393169e5d"},{"code":"#(filter (complement sequential?) (tree-seq sequential? seq %1))","problem":28,"user":"4e521d7a535d302ef430da6e"},{"problem":28,"code":"(fn flat [coll-]\n  (loop [acc []\n         coll coll-]\n    (if (empty? coll)\n      acc\n    (let [f (first coll)]\n      (if (coll? f)\n        (recur (into acc (flat f)) (rest coll))\n        (recur (conj acc f) (rest coll))\n        )\n      )\n    )\n    )\n  )","user":"5b250773e4b063e2438bcc21"},{"problem":28,"code":"reduce (fn my-flatten [acc x]\n  (if-not (or (seq? x) (vector? x) (list? x))\n    (reverse (cons x (reverse acc)))\n    (reduce my-flatten acc x))) []","user":"5773f3a9e4b0979f896515f2"},{"code":"(fn flatify [coll]\n  (reduce (fn [set, item]\n            (if (coll? item)\n              (concat set (flatify item))\n              (concat set [item]))) \n          () coll))","problem":28,"user":"53778b90e4b06839e8705e36"},{"problem":28,"code":"(fn myflatten[l]\n  ( if (empty? l)\n    '()\n    (let [[a & q] l]\n      (let [f (myflatten q)]\n       (if (instance? java.util.Collection a)\n         (concat (myflatten a) f)\n         (conj  f a))))))","user":"54651ef5e4b01be26fd746d5"},{"problem":28,"code":"(fn my-flat\n  [s] \n  (if (empty? s)\n    s   \n    (let [[this & remaining] s]\n      (if (coll? this)\n        (concat (my-flat this) (my-flat remaining))\n        (cons this (my-flat remaining))))))","user":"5f5df0bfe4b02876ed9fcfeb"},{"problem":28,"code":"(fn flt [s] (reduce (fn [r e] (if (coll? e) (concat r (flt e)) (concat r (list e)))) [] s))","user":"50784ae5e4b0fc74642bff68"},{"problem":28,"code":"(fn flat [s]\n  (if (not (sequential? s))\n    [s]\n    (reduce (fn [accum, x] \n              (concat accum (flat x))\n            )\n            []\n            s\n    )\n  )\n)","user":"59073e0fe4b047aa04b19950"},{"code":"(fn [x] (let [x (loop [x x, r []]\n        (if (coll? (first x))\n            (if (empty? (rest x))\n                (reduce #(conj % %2) r (first x))\n                (recur (rest x) (reduce #(conj % %2) r (first x))))\n            (if (empty? (rest x))\n                (conj r (first x))\n                (recur (rest x) (conj r (first x))))))]\n    (if (some coll? x)\n        (recur x)\n        x)))","problem":28,"user":"5078d366e4b08327cd804a5b"},{"problem":28,"code":"(fn [input-seq] (filter (complement sequential?) (rest (tree-seq sequential? seq input-seq))))","user":"5c723f4be4b0fca0c16227a0"},{"problem":28,"code":"(fn [arg]\r\n     (reduce \r\n       (fn reduce-fn [collect seq] \r\n         (if (sequential? seq)\r\n            (reduce reduce-fn collect seq)\r\n            (conj collect seq)))\r\n       [] arg))","user":"58455b05e4b089d5ab817e65"},{"problem":28,"code":"(fn my_flatten [lst]\n  \"Flatten a given list\"\n  (mapcat #(if (sequential? %)\n             (my_flatten %)\n             [%]) lst))","user":"5d614059e4b0c9e5857d500e"},{"problem":28,"code":"(fn flatten-nested [y] \n         (mapcat #(if (sequential? %) (flatten-nested %) [%]) y))","user":"5f1a0ca2e4b091ba50b4dbe0"},{"code":"(fn [l]\n    ((fn flat [acc lst] \n        (if (coll? lst)\n            (reduce (fn [acc2 ele] (flat acc2 ele)) acc lst)\n            (conj acc lst)\n        )\n    ) '[] l)\n)","problem":28,"user":"52c17e42e4b07a9af5792367"},{"problem":28,"code":"(fn flat2 [coll]\n  (if-not (sequential? coll)\n    [coll]\n    (mapcat flat2 coll)))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn flat [l]\n  (if (empty? l) []\n      (let [f (first l)\n            r (rest l)]\n        (if (coll? f)\n          (concat (flat f) (flat r))\n          (concat [f] (flat r))))))","problem":28,"user":"52d1e364e4b0d9f9285948e7"},{"problem":28,"code":"(fn my-flatten [x] \n  (if (coll? x)\n    (mapcat my-flatten x)\n    [x]))","user":"565fe49ee4b068f2fe63dc46"},{"problem":28,"code":"(fn [x]\n  ((fn flat [col output]\n    (if (nil? (first col))\n      output\n      (if (coll? (first col))\n        (flat (rest col) (flat (first col) output))\n        (flat (rest col) (conj output (first col)))))) x []))","user":"56877fcbe4b0dcc4269f405e"},{"code":"(fn fl [s]\n    (cond\n      (not (sequential? s)) s\n      (empty? s) s\n      :default (let [[e & r] s\n                     x (fl e)]\n                 (if (sequential? x) (concat (empty s) x (fl r))\n                     (concat (conj (empty s) x) (fl r))))))","problem":28,"user":"50015be1e4b0678c553fc41a"},{"code":"(fn my-flatten [x]\n  (mapcat\n   #(if (coll? %)\n      (my-flatten %)\n      [%])\n   x))","problem":28,"user":"507b7dbee4b09034bfeeb71e"},{"problem":28,"code":"(fn flatten' [x]\n  (if (sequential? x)\n    (mapcat flatten' x)\n    [x]))","user":"5576f299e4b05c286339e077"},{"problem":28,"code":"(fn test [x]\n  (cond (empty? x) nil\n        (coll? (first x)) (into (test (first x))\n                                (test (rest x)))\n        :else\n        (vec (cons (first x) \n              (seq (test (rest x)))))))","user":"579332c2e4b0e215f87e8452"},{"problem":28,"code":"(fn f [xs] \n  (if (not (coll? xs)) [xs]\n    (if (empty? xs) []\n      (concat (f (first xs)) (f (rest xs))))))","user":"563cdfdfe4b0bfe05bf11840"},{"problem":28,"code":"(fn i [x]\n  (if (coll? x)\n    (mapcat i x) [x]))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn f [l]\n  (cond \n   (empty? l) []\n   (coll? (first l)) (concat (f (first l)) (f (rest l)))\n   :default (cons (first l) (f (rest l)) )\n   )\n)","problem":28,"user":"4ff2ff7ce4b0678c553fc342"},{"problem":28,"code":"(fn [coll]\n  (filter \n   (complement sequential?)\n   (tree-seq sequential? seq coll)))","user":"55d204abe4b0e31453f64a4f"},{"code":"(fn aplana[s]\n  (loop [sequ s\n         resto ()]\n        (if (not= 0 (count sequ))\n                (if (coll? (first sequ))\n                        (if (coll? (rest sequ))\n                                (recur (concat (first sequ) (rest sequ)) resto)\n                                (recur (conj (first sequ) (rest sequ)) resto)\n                        )\n                        (recur (rest sequ) (concat resto (list (first sequ)))))\n                resto)\n))","problem":28,"user":"4e9de526535dbda64a6f6b8e"},{"problem":28,"code":"(fn flat [lst]\n  (if (empty? lst)\n    lst\n    (if (coll? (first lst))\n      (concat (flat (first lst)) (flat (rest lst)))\n      (cons (first lst) (flat (rest lst))))))","user":"586c5a34e4b01531a375e97a"},{"code":"(fn [z] (sort ((fn fn1 [x] (reduce (fn [k t] (if (coll? t) (->> t fn1 (apply conj k)) (conj k t))) '() x)) z)))","problem":28,"user":"5162757ee4b03cfa3774b3fe"},{"code":"(fn [l0]\n  (loop [prevLst ()\n         currLst l0]\n    (if (= prevLst currLst) \n      currLst\n      (recur \n        currLst\n        (mapcat #(if (coll? %) % (list %)) currLst)))))","problem":28,"user":"4f90e238e4b0dcca54ed6c94"},{"problem":28,"code":"(fn [y] (filter (fn [x] (not (sequential? x) )) (tree-seq sequential? seq y)))","user":"55b6a63ae4b01b9910ae299b"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce \n   \t\t#(if (coll? %2) \n           (vec (concat %1 (my-flatten %2)))\n           (conj %1 %2))\n   \t\t[]\n   \t\tcoll))","user":"56442758e4b0018b46ad8c0a"},{"code":"(fn myflatten [xss]\r\n  (if (sequential? xss)\r\n    (mapcat myflatten xss)\r\n    (list xss)))","problem":28,"user":"4e7dfd48535db169f9c796fa"},{"code":"(fn flat [i]\n  (reduce\n   (fn [a x] (concat a (if (coll? x) (flat x) (vector x))))\n   '()\n   i))","problem":28,"user":"50b64b55e4b0a86f8358ca6b"},{"code":"#(let [f (fn f [x]\n          (cond (nil? x) nil\n                (not (sequential? x)) (list x)\n                :else (concat (f (first x)) (f (next x)))))]\n  (f %))","problem":28,"user":"4e7e4d5c535db169f9c7970f"},{"problem":28,"code":"(fn [x]\n    (letfn [(flat [a y]\n              (let [i (first y)\n                    j (rest y)]\n                (if (seq y) \n                  (if (coll? i)\n                    (flat (flat a i) j)\n                    (flat (conj a i) j))\n                  a)))]\n      (reverse (flat () x))))","user":"5578ba3ae4b05c286339e08c"},{"code":"(fn flat [s]\n  (if (empty? s)\n    (list)\n  (if (sequential? (first s))\n\n    (concat (flat (first s)) (flat (rest s)))\n    (concat (list (first s)) (flat (rest s))))))","problem":28,"user":"504ec46de4b069badc5a33c8"},{"problem":28,"code":"(fn fl [x]\n  (cond\n   (empty? x) x\n   (coll? (first x)) (concat (fl (first x)) (fl (rest x)))\n   :else (cons (first x) (fl (rest x)))))","user":"554c5affe4b0a04f792995a3"},{"problem":28,"code":"(fn my-flat [nested]                                                                                                                        \n  (if (not (sequential? nested))                                                                                                                     \n    (seq [nested])                                                                                                                            \n    (reduce                                                                                                                                   \n      (fn [acc el]                                                                                                                            \n        (let [el-flat (my-flat el)]                                                                                                           \n          (concat acc el-flat)                                                                                                                \n          )                                                                                                                                   \n        )                                                                                                                                     \n      nil                                                                                                                                     \n      nested                                                                                                                                  \n      )                                                                                                                                       \n    )                                                                                                                                         \n  )","user":"56fbe0cce4b07572ad1a88d8"},{"code":"(fn my-flatten\n    [ r s ]\n    (if (not (or (list? s) (vector? s)))\n        (conj r s)\n        (reduce my-flatten r (reverse s)))) ()","problem":28,"user":"51f59607e4b0abb92f97f9d5"},{"problem":28,"code":"(fn [init-s]\n  (loop [s (seq init-s)\n         r []]\n    (if (empty? s)\n      (seq r)\n      (let [f (first s)]\n        (if (coll? f) ; \n          (if (empty? f) ;\n            (recur (rest s) r)\n            (recur (conj (rest s) (rest f) (first f)) r))\n          (recur (rest s) (conj r f)))))))","user":"57addbcce4b0b8559636fca3"},{"problem":28,"code":"#(filter(complement sequential?) (rest (tree-seq sequential? seq % ) ) )","user":"56dc3dbbe4b0ea9b8538f81a"},{"code":"(fn my-flatten\n  [[x & xs :as n]]\n  (cond\n   (empty? n) '()\n   (coll? x) (concat\n              (my-flatten x)\n              (my-flatten xs))\n   :else (cons x (my-flatten xs))))","problem":28,"user":"533018b2e4b019098a6f8b56"},{"code":"(fn flt [[a & d]]\n  (if a\n    (if (coll? a)\n      \t(concat (flt a) (flt d))\n        (cons a (flt d)))))","problem":28,"user":"50fc299ee4b0d10d794c19f2"},{"problem":28,"code":"(fn fl [input] (loop [output (list), in input]\n              (if (empty? in)\n                output\n                (if (coll? (first in))\n                  (recur (concat output (fl (first in))) (rest in))\n                  (recur (concat output (list (first in))) (rest in))))))","user":"5460832ce4b01be26fd74693"},{"code":"(fn flat [s] (reverse (reduce (fn [sq x] (if (coll? x) (concat (reverse (flat x)) sq) (conj sq x))) '() s)))","problem":28,"user":"51d381b5e4b099f3b6acde01"},{"problem":28,"code":"(fn slop [x]\n  (loop [so-far []\n         x x]\n   (if (empty? x)\n    so-far\n    (if (coll? (first x))\n     (recur (into so-far (slop (first x))) (rest x))\n     (recur (conj so-far (first x)) (rest x))))))","user":"4fc57c4ce4b0ee37620e17f6"},{"problem":28,"code":"(fn flat2 [coll]\n  (let [f (first coll) r (rest coll)]\n    (cond (empty? coll) nil\n          (sequential? f) (concat (flat2 f) (flat2 r))\n          :else (cons f (flat2 r)))))","user":"53a2a259e4b0f1fc7453882c"},{"problem":28,"code":"(fn ! [s]\n  (if (empty? s) '()\n    (let [f (first s) r (rest s)]\n      (if (coll? f) (concat (! f) (! r))\n    \t(cons f (! r))\n        )\n      )\n    )\n  )","user":"54c271b9e4b045293a27f602"},{"problem":28,"code":"(fn [s]\n  (loop [res []\n         [f & r] s]\n    (if f\n      (if (coll? f)\n        (recur res (concat f r))\n        (recur (conj res f) r))\n      res)))","user":"565f8fd2e4b068f2fe63dc41"},{"code":"(fn ! [input]\n   (loop [result [] elements input]\n     (if (empty? elements)\n       result\n       (if (coll? (first elements))\n         (recur (into result (! (first elements))) (rest elements))\n         (recur (conj result (first elements)) (rest elements))\n         )\n       )\n     )      \n   )","problem":28,"user":"5106dc1be4b01150e115ebf0"},{"code":"(fn f [coll] (reduce #(concat %1 (if (coll? %2) (f %2) [%2])) '() coll))","problem":28,"user":"4f03822f535dcb61093f6b03"},{"problem":28,"code":"(partial (fn flat[res col]\n  (let [fst (first col) rst (rest col)]\n    (-> res\n        (#(if (sequential? fst) (flat % fst) (conj % fst)))\n        (#(if (empty? rst) % (flat % rst)))))) [])","user":"56795deae4b05957ce8c6187"},{"code":"(comp \n reverse \n (fn flat [l] \n   (let [f (fn [acc l] \n             (if (empty? l) acc \n               (recur \n                (if (coll? (first l)) \n                  (concat (flat (first l)) acc) \n                  (conj acc (first l))) (rest l))))] \n     (f '() l))))","problem":28,"user":"5273e006e4b03e8d9a4a7495"},{"problem":28,"code":"(fn flatn [x]\n  (if (coll? x)\n    (apply concat (map flatn x))\n    (list x)))","user":"562cd94ee4b0a45d2ff83015"},{"problem":28,"code":"#(reduce (fn dig [acc val]\n          (if (coll? val)\n            (reduce dig acc (seq val))\n            (conj acc val)))\n        [] %)","user":"5e44c804e4b01d43a70e8e89"},{"problem":28,"code":"(fn my-flatten \n  [s] \n  (reduce \n   \t(fn [accum x] \n      (if (sequential? x) \n        (into accum (my-flatten x)) \n        (conj accum x))) \n   \t[] s))","user":"5764cc01e4b0994c1922fc05"},{"problem":28,"code":"(fn flat [x] (if (coll? x) (if (empty? x) x (into (flat (first x)) (flat (rest x)))) [x]))","user":"571aad45e4b07c98581c3b59"},{"problem":28,"code":"(fn [s]\n  (letfn [(my-flat [acc ts]\n                   (cond\n                    (empty? ts) acc\n                    (or (seq? (first ts)) (vector? (first ts))) (concat acc (my-flat '() (first ts)) (my-flat '() (rest ts)))\n                    :else (my-flat (concat acc (list (first ts))) (rest ts))))]\n    (my-flat (list) s)))","user":"5c284f14e4b07e362c2305d6"},{"problem":28,"code":";my original solution\n;(fn flat [x]\n;  (reduce\n;    (fn cat-flat [x y]\n;      (if (sequential? y)\n;        (concat x (reduce cat-flat '() y))\n;        (concat x (list y))))\n;  '() x))\n\n;better solution found...\n(fn flat [x]\n  (if (sequential? x)\n    (mapcat flat x)\n    [x]\n  )\n  \n)","user":"55e01f4ee4b050e68259b406"},{"problem":28,"code":";I am sure that there is an easier way to do this. This solution is limited to 4 sub collections.\n(fn [coll]\n  (loop [out []\n         in coll]\n    (if (empty? in)\n      out\n      (recur (if (coll? (first in))\n               (loop [o out\n                      i (first in)]\n                 (if (empty? i)\n                   o\n                   (recur (if (coll? (first i))\n                            (loop [o3 o\n                                   i3 (first i)]\n                              (if (empty? i3)\n                                o3\n                                (recur (if (coll? (first i3))\n                                         (loop [o4 o3\n                                                i4 (first i3)]\n                                           (if (empty? i4)\n                                             o4\n                                             (recur (conj o4 (first i4))\n                                                    (drop 1 i4))))\n                                         (conj o3 (first i3)))\n                                       (drop 1 i3))))\n                            (conj o (first i)))\n                          (drop 1 i))))\n               (conj out (first in)))\n             (drop 1 in)))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":28,"code":"(fn f [[x & xs]]\n  (if x\n    (concat\n      (if (sequential? x) (f x) (list x))\n      (f xs))\n    ()))","user":"4fb1d7ace4b081705acca281"},{"problem":28,"code":"(fn flat\n[coll]\n(reduce #(concat %1 (if(coll? %2)\n(flat %2)[%2])) '() coll))","user":"57ee41eae4b0bfb2137f5bb0"},{"problem":28,"code":"(fn makeFlat [args]\n  (let [[x & xs] args]\n   (cond\n    (empty? args) '()\n    (coll? x) (concat (makeFlat x) (makeFlat xs))\n   \t:else (conj (makeFlat xs) x)\n    )\n   )\n  )","user":"55efc44ee4b066087aa9453e"},{"code":"(fn flatten* [xs]\n  (reduce #(concat %1 (if (sequential? %2) (flatten* %2) [%2])) [] xs))","problem":28,"user":"511623cbe4b0d4f670fd2fe1"},{"problem":28,"code":"#(filter\n  (fn [x] (not (sequential? x)))\n  (tree-seq sequential? identity %))","user":"57e2e1bde4b0bfb2137f5a8f"},{"problem":28,"code":"#(loop [xs %\n        flat []]\n   (if (empty? xs)\n     (seq flat)\n     (if (coll? (first xs))\n       (recur (concat (first xs) (rest xs)) flat)\n       (recur (rest xs) (conj flat (first xs))))))","user":"5605007ae4b08b23635d315e"},{"code":"(fn make-flat\n  ([x] (make-flat x []))\n  ([x result]\n    (loop [curr_x x, curr_res result]\n      (cond\n        (nil? curr_x) curr_res\n        (sequential? (first curr_x))\n          (recur (next curr_x) (make-flat (first curr_x) curr_res))\n        :else\n          (recur (next curr_x) (conj curr_res (first curr_x)))))))","problem":28,"user":"4ec5cdb0535d6d7199dd36b8"},{"problem":28,"code":"(fn f [x]\n  (mapcat #(if (sequential? %) (f %) [%]) x))","user":"5a779197e4b013a48d399763"},{"problem":28,"code":"(fn t [lst]\n  (if (coll? lst)\n    (mapcat t lst)\n    [lst]))","user":"5d9515a9e4b0d3f9b434ad2c"},{"code":"(fn f [x] (if (coll? x)\n              (mapcat f x)\n              [x]))","problem":28,"user":"4ee1f2ba535d10e5ff6f535f"},{"problem":28,"code":"(fn flt [ele]\n  (cond \n   (sequential? ele) (mapcat flt ele)\n   :else (list ele)))","user":"545e7ab0e4b01be26fd7467c"},{"problem":28,"code":"(fn unpack [coll] \n  (if-not (sequential? coll) \n      [coll]\n      (if (empty? coll)\n         []\n         (concat (unpack (first coll)) (unpack (rest coll)))\n      )\n  )\n)","user":"55c387e4e4b0e31453f6498b"},{"problem":28,"code":"(fn flattenSeq\n  [sequ]\n  \"Flattens a sequence. Finds the first nested collection\n  element within the list. Concatenates the elements before it with the\n  collection element, then all the elements that come after it. Makes a recursive call\n  if any of the elements are collections. Otherwise returns the whole collection.\"\n  (if (some coll? sequ)\n    (flattenSeq\n      (let [firstColIndex\n            ((fn findFirstColIndex ; anonymous function to find index of first coll element\n              [index findIn]\n              (if (coll? (nth findIn index))\n                index\n                (findFirstColIndex (inc index) findIn))) 0 sequ)\n            firstCol (nth sequ firstColIndex)\n            outputSeq (concat\n              (take firstColIndex sequ) ; before coll element\n              firstCol ; coll element\n              (drop (+ 1 firstColIndex) sequ))] ; after coll element\n        outputSeq))\n    sequ))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [coll]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq coll)))","problem":28,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":28,"code":"(fn fltn [x]\n  (if (empty? x)\n      ()\n      (let [f (first x)\n            fsq (sequential? f)\n            flat (if fsq (fltn f) (list f))]\n        (concat flat (fltn (rest x))))))","user":"57b35772e4b0fbc9809a277c"},{"code":"(fn ft [c]\n  (if (empty? c) c\n  (if (sequential? (first c)) \n    (concat (ft (first c)) (ft (rest c)))\n    (cons (first c) (ft (rest c))))))","problem":28,"user":"4ff4c9dae4b0678c553fc360"},{"problem":28,"code":"(fn f [seq]\n  (if (not= (first seq) nil)\n    (concat\n     (if (coll? (first seq))\n       (f (first seq))\n       (list (first seq)))\n     (f (rest seq)))))","user":"589f37e0e4b02bd94d917e79"},{"code":"(fn myflatten [xs]\n  (when (not (empty? xs))\n  (lazy-seq\n    (if (or (seq? (first xs)) (vector? (first xs)))\n      (concat (myflatten (first xs)) (myflatten (rest xs)))\n      (cons (first xs) (myflatten (rest xs)))))))","problem":28,"user":"4e4fbd0c535dc968683fc4e9"},{"code":"#(filter (complement sequential?)\n    (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e9e7ce3535dbda64a6f6b98"},{"code":"(fn flat [l]\n  (if (sequential? l)\n      (reduce concat (map flat l))\n      [l]))","problem":28,"user":"504e3afae4b0f6ff3350c488"},{"problem":28,"code":"(fn flat\n  ([input output] (cond (empty? input)\n                        output\n                        (sequential? (first input))\n                        (flat (rest input) (flat (first input) output))\n                        :else\n                        (flat (rest input) (conj output (first input)))))\n  ([input]\n   (flat input [])))","user":"58a3ba31e4b02bd94d917eff"},{"code":"(fn flat [l]\n  (reduce #(if (coll? %2)\n              (into %1 (flat %2))\n              (conj %1 %2)) \n           [] l ) )","problem":28,"user":"4efb2fd7535dced4c769f274"},{"problem":28,"code":"(fn new-flat [coll]\n  (let [left (first coll) right (next coll)]\n    (concat \n      (if (sequential? left)\n        (new-flat left)\n        [left])\n      (when (sequential? right)\n        (new-flat right)))))","user":"533c5249e4b0e30313ee6cdd"},{"problem":28,"code":"(fn flat [s] (reduce (fn [lst nxt] (if (coll? nxt ) (concat lst (flat nxt) ) ( conj (vec lst ) nxt ) ) ) [] (vec s) ))","user":"600b385ce4b074f607df668d"},{"problem":28,"code":"(fn flatten-levels [coll]\n  (reduce\n    (fn flat [acc val]\n   \n      (if (sequential? val) (reduce flat acc val) (conj acc val)))\n    []\n    coll))","user":"60c90322e4b0e0fa5f1b4302"},{"problem":28,"code":"(fn flt [coll] (if (sequential? coll) \n                  (mapcat flt coll)\n                  (list coll)))","user":"55f8b32ae4b03cbcff9738ba"},{"code":"#(filter (fn[x](not (coll? x))) (tree-seq coll? identity %))","problem":28,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":28,"code":"(fn [l]\n  (loop [l1 l l2 []]\n    (let [fl1 (first l1) rl1 (rest l1)]\n      (cond\n       (sequential? fl1) (recur (concat fl1 rl1) l2)\n       (empty? l1) (seq l2)\n       :else (recur rl1 (conj l2 fl1))\n       )\n      )\n    )\n  )","user":"563dfc02e4b0da801c4e4662"},{"problem":28,"code":"(fn [l] (filter (complement sequential?) (tree-seq sequential? identity l)))","user":"56662275e4b0e91d5f5c566a"},{"problem":28,"code":"(fn my-flatten [x]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq x)))","user":"5b6002c2e4b0c6492753e6fb"},{"code":"(fn myflatten\r\n     [x]\r\n     (filter (complement sequential?)\r\n             (rest (tree-seq sequential? seq x))))","problem":28,"user":"4dddff47535d08e6dec9fdd4"},{"code":"(fn f [sq] \r\n    (if (coll? sq)\r\n      (reverse (reduce #(apply conj %1 %2) '() (map f sq)))\r\n      (list sq)))","problem":28,"user":"4f0da4e4535d0136e6c22319"},{"problem":28,"code":"(fn -flatten\n  [xs]\n  (if (coll? xs)\n    (mapcat -flatten xs)\n    [xs]))","user":"5afcd6d1e4b0cc2b61a3bd17"},{"problem":28,"code":"(fn fl [coll] (mapcat #(if (coll? %) (fl %) (list %)) coll))","user":"5122925ae4b068a9582e656d"},{"code":"(fn self [x]\n   (reduce (fn [x' xs]\n             (if (or (seq? xs) (vector? xs))\n               (concat x' (self xs))\n               (concat x' (list xs) )))\n           '() x))","problem":28,"user":"4f616892e4b0defedf855fbf"},{"problem":28,"code":"(fn foo [x]\n    (if (sequential? x)\n      (if (empty? x)\n        '()\n        (concat \n          (foo (first x))\n          (foo (rest x))\n        )\n      )\n      [x]\n    )\n  )","user":"5710140fe4b09c608db7042e"},{"problem":28,"code":"(fn tomaten [sq] \n  (filter (complement sequential? )\n          (rest (tree-seq sequential? seq sq ) )\n          )\n  )","user":"5a6a436de4b0512ff01cda24"},{"problem":28,"code":"(fn hello [coll]\n  (if (sequential? coll)\n    (mapcat hello coll)\n    (list coll)))","user":"55b3c03ee4b01b9910ae2975"},{"code":"(fn [thing]\n     (reverse (into '() ((fn red [thing2] (reduce #(if (coll? %2) (concat %1 (red %2)) (concat %1 [%2])) [] thing2)) thing))))","problem":28,"user":"50f53694e4b057d4c52de881"},{"problem":28,"code":"(fn my-flatten [container]\n  (let [head (first container)\n        tail (rest container)]\n    (cond\n      (coll? head) (concat (my-flatten head) (my-flatten tail))\n      (nil? head) '()\n      :else (cons head (my-flatten tail)))))","user":"5645a7d6e4b0284900eef608"},{"problem":28,"code":"(fn unwrap [thing]\n  (if (coll? thing)\n    (apply concat (map unwrap thing))\n    (list thing)))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":28,"code":"(fn flatten-me [s] \n  (if (coll? s)\n    \t(mapcat flatten-me s)\n    \t[s] ))","user":"567d18c9e4b05957ce8c61c4"},{"problem":28,"code":"(fn flat [coll]\n  (if (sequential? coll)\n    (if (empty? coll)\n      coll\n      (concat\n        (flat (first coll))\n        (flat (rest coll))))\n    (list coll)))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":28,"code":"(fn flat [seq & [flattened]]\n   (let [head (first seq)\n         flattened (or flattened [])]\n     (if (empty? seq)\n       flattened\n       (flat (rest seq)\n             (if (coll? head)\n               (flat head flattened)\n               (conj flattened head))))))","user":"57155980e4b07c98581c3ad7"},{"problem":28,"code":"(fn [xs]\n  (loop [out xs]\n    (if (some coll? out)\n      (recur (mapcat #(if (coll? %) % [%]) out))\n      out)))","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn flat [sequence]\n  (if (coll? sequence)\n    (reduce concat (map flat sequence))\n    [sequence]))","problem":28,"user":"5003deb9e4b0678c553fc445"},{"problem":28,"code":"(fn [x] \n   ((fn t [x o] \n      (cond \n         (not (coll? x)) (conj o x)\n         (empty? x) o\n         :default (t (rest x) (t (first x) o))\n       )\n      ) x []))","user":"5562f08ae4b0c656e3ff17df"},{"problem":28,"code":"(fn [xs] (loop [xs xs\n                acc '()]\n           (if (empty? xs)\n             (reverse acc)\n             (if (coll? (first xs))\n               (recur (concat (first xs) (rest xs)) acc)\n               (recur (rest xs) (cons (first xs) acc))))))","user":"547ad587e4b0c51c1f4d72ce"},{"problem":28,"code":"(fn foo [s] (if (empty? s)\n                 s\n                 (if (sequential? (first s))\n                     (concat (foo (first s)) (foo (rest s)))\n                     (concat (list (first s)) (foo (rest s))))))","user":"5cd99946e4b05ee0cb311706"},{"problem":28,"code":"(fn flat [coll]\n      (apply concat []\n        (for [x coll]\n          (if (sequential? x)\n              (flat x)\n              [x] ))))","user":"532f7e12e4b019098a6f8b4e"},{"code":"(fn k [a]\n   (if (= a '())\n       a\n       (if (coll? a)\n           (concat (k (first a)) (k (rest a)))\n              (list a))))","problem":28,"user":"4f039bbe535dcb61093f6b39"},{"code":"(fn[x] (filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"510ec1bce4b07438aa321461"},{"code":"(fn [xs]\n    ((fn impl [xs rs]\n       (if (empty? xs)\n         rs\n         (cond \n          (seq? (first xs)) (into (impl (next xs) rs) (reverse (impl (first xs) [])))\n          (vector? (first xs)) (into (impl (next xs) rs) (impl (first xs) []))\n          :else (cons (first xs) (impl (next xs) rs)))))\n     xs []))","problem":28,"user":"521392bce4b0d32679a5065e"},{"code":"(fn [sq]\n  (letfn [(flat [coll]\n            (when-let [c (seq coll)]\n              (let [f (first c)\n                    r (rest c)]\n                (if (sequential? f)\n                  (concat (flat f) (flat r))\n                  (cons f (flat r))))))]\n    (if (sequential? sq) (flat sq) sq)))","problem":28,"user":"504f2071e4b0e7ad84dbc4be"},{"problem":28,"code":"(fn my-flatten [x] \n  (filter \n   (complement sequential?) \n   (rest (tree-seq sequential? seq x))))","user":"59cd351ee4b0ef0a1e9b5b35"},{"problem":28,"code":"(fn join [xs]\n  (if (empty? xs)\n    xs\n    (if (coll? (first xs))\n      (concat (join (first xs)) (join (rest xs)))\n      (cons (first xs) (join (rest xs))))))","user":"58cf00c8e4b03c36ff7e58ac"},{"problem":28,"code":"#(reverse (reduce\n            (fn flat[a item]\n              (if (coll? item) (reduce flat a item)\n                               (conj a item)))\n            '()\n            %))","user":"57fa7c93e4b0d3187e900963"},{"problem":28,"code":"(fn f [v] \n \n  (reduce (fn [acc i] \n              (if (counted? i)\n                  (concat acc (f i))\n                  (concat acc [i])\n                  )\n              \n              ) [] v)\n  \n  )","user":"596f6683e4b069c0a1a19877"},{"problem":28,"code":"(fn my-flat [[f & r]]\n  (if (nil? f) \n    '()\n    (if (coll? f)\n      (concat (my-flat f) (my-flat r))\n      (concat [f] (my-flat r)))))","user":"5a401a7de4b0447ef91cc5c5"},{"problem":28,"code":"(fn f [[h & t :as s]]\n  (when (seq s)\n    (if (coll? h)\n      (concat (f h) (f t))\n      (cons h (f t)))))","user":"590b055ae4b047aa04b199c9"},{"problem":28,"code":"(fn flattex [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"56b280e3e4b0982f16b37e06"},{"code":"(fn fltn [c] (mapcat #(if (coll? %) (fltn %) [%]) c))","problem":28,"user":"4f0f01c0535d0136e6c22329"},{"problem":28,"code":"(fn [x]\n\t(loop [[s & r] x\n\t\t   result '()]\n\t\t(println s r result)\n\t\t(if (and (empty? r) (not (seq? s)) (not (vector? s)))\n\t\t\t(concat result (conj '() s))\n\t\t\t(if (or (seq? s) (vector? s))\n\t\t\t\t(if (empty? s)\n\t\t\t\t\t(recur r result)\n\t\t\t\t\t(recur (concat (conj '() (first s)) (rest s) r) result)\n\t\t\t\t)\n\t\t\t\t(recur r (concat result (conj '() s)))\n\t\t\t)\n\t\t)\n\t)\n)","user":"598d746ae4b02b9968b84d23"},{"code":"(fn f [x]\n  (if (not (coll? x))\n    (list x)\n    (if (empty? x)\n      '()\n      (concat (f (first x)) (f (rest x))))))","problem":28,"user":"50bfd849e4b042992946c649"},{"code":"(fn flat\r\n  ([xs acc]\r\n    (if (seq xs)\r\n      (let [head (first xs) tail (rest xs)]\r\n        (if (coll? head)\r\n          (if-not (empty? head)\r\n            (recur (cons (first head) (cons (rest head) tail)) acc)\r\n            (recur tail acc))\r\n          (recur tail (conj acc head))))\r\n      acc))\r\n  ([xs] (flat xs [])))","problem":28,"user":"4e5c4cc6535d8a8b8723a2bf"},{"code":"(fn\n  [sq]\n  (let [smash (fn flat [x]\n                  (if-not (coll? x) [x]\n                                   (if (empty? x) [] (reduce into [] (map flat x)))))]\n    (smash sq)))","problem":28,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":28,"code":"(fn flat [l]\n  (if (not (coll? l)) [l]\n    (if (= 1 (count l))\n      (flat (first l))\n      (concat (flat (first l)) (flat (rest l))))))","user":"5d41f428e4b05dd059a5437b"},{"problem":28,"code":"(fn flat [col]\n    (let [sequ (seq col)]\n        (prn sequ)\n        (if-not (seq (rest sequ))\n            (if (coll? (first sequ))\n                (flat (first sequ))\n                (list (first sequ)))\n            (if (coll? (first sequ))\n                (concat \n                   (flat (first sequ))\n                   (flat (rest sequ)))\n                (cons\n                    (first sequ)\n                    (flat (rest sequ)))\n            )\n        )\n))","user":"5498c4cfe4b0b312c081ff85"},{"code":"(fn flattenx [xs] \n   (reduce #(into %1 (if (coll? %2) (flattenx %2) [%2])) [] xs))","problem":28,"user":"5114ab7be4b0ce5098ee73b5"},{"problem":28,"code":"(fn flat[x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","user":"5a634ff0e4b0512ff01cd995"},{"code":"#(remove coll? (tree-seq coll? vec %))","problem":28,"user":"4ea0cfb0535d7eef308072ae"},{"problem":28,"code":"(fn flat [cl]\n  (cond (empty? cl) nil\n        (coll? (first cl)) (concat (flat (first cl))\n                                   (flat (rest cl)))\n              :else (cons (first cl)\n                          (flat (rest cl)))))","user":"5d10c1a8e4b04b4faecf4449"},{"problem":28,"code":"(fn [lis]\n  (loop [lis lis]\n    (if (some sequential? lis)\n      (recur (reduce #(if (sequential? %2)\n                  (concat % %2)\n                  (concat % [%2])) [] lis))\n      lis)))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn flat [x]\n    (reduce (fn [s i] (into s (if (coll? i) (flat i) [i]))) [] x))","problem":28,"user":"4faccddae4b081705acca22e"},{"code":"(fn [x] (reduce #(if-not (coll? %2) (conj %1 %2) %1) '[] (tree-seq coll? identity x)))","problem":28,"user":"4ea11921535d7eef308072af"},{"problem":28,"code":"(fn x [y]\n  (if (sequential? y)\n    (mapcat x y)\n    (list y)))","user":"5576006ae4b05c286339e068"},{"problem":28,"code":"(fn flt [l]\n  (cond (empty? l) '()\n        (coll? (first l)) (concat (flt (first l)) (flt (rest l)))\n        :else (conj (flt (rest l)) (first l))))","user":"551afdf8e4b07993ea3788cb"},{"code":"(fn flat [s]\r\n  (let [[x & xs] s]\r\n    (cond\r\n     (empty? s) '()\r\n     (coll? x) (concat (flat x) (flat xs))\r\n     :else (cons x (flat xs)))))","problem":28,"user":"4f70183ee4b07046d9f4eff3"},{"problem":28,"code":"(fn like-flatten [coll] \n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq coll))))","user":"56014f55e4b04bb52996e184"},{"code":"(fn fltn [l]\n  (if (not-empty l)\n    (if (coll? (first l))\n      (concat (fltn (first l)) (fltn (rest l)))\n      (cons (first l) (fltn (rest l))))\n    ()))","problem":28,"user":"51b76227e4b0d906fcd71d35"},{"code":"(fn my-flatten [s] (if (coll? s) (mapcat my-flatten s) (vector s)))","problem":28,"user":"4fe9d647e4b0547ebccb2472"},{"code":"(fn flat [lst] \n        (lazy-seq \n          (if (empty? lst) lst \n              (let [[x & xs] lst] \n                (if (coll? x) \n                  (concat (flat x) (flat xs)) \n                  (cons x (flat xs)))))))","problem":28,"user":"5048202fe4b0ec70b3ef8d9a"},{"code":"(fn [seekwence]\n(filter (complement sequential?)\n  (rest (tree-seq sequential? seq seekwence))))","problem":28,"user":"5245d29ae4b09dbe66b56174"},{"problem":28,"code":"(fn flatter\n  [some-sequence]\n  (loop [flattened []\n         f (first some-sequence)\n         rest-of-some-sequence (rest some-sequence)]\n    (if (nil? f)\n      flattened\n      (if (coll? f)\n        (recur flattened\n               (first f)\n               (conj (vec (rest f))\n                     rest-of-some-sequence))\n        (recur (conj flattened f)\n               (first rest-of-some-sequence)\n               (rest rest-of-some-sequence))))))","user":"5c9a638fe4b048ec896c5aae"},{"problem":28,"code":"(fn my-flatten[col]\n  (if (sequential? col)\n    (mapcat my-flatten col)\n    [col]))","user":"5ce2b15fe4b0a17bb84e2b2c"},{"problem":28,"code":"(fn my-flatten [s]\n  (filter (complement sequential?)\n          (tree-seq sequential? identity s)))","user":"57dda21be4b0bd073c202445"},{"problem":28,"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))\n; we basically treat the nested collection as a tree and recursively walk the \n; tree. Clojure's flatten use a tree-seq to walk the tree.","user":"54d0f654e4b0e8a36923e5d6"},{"code":"(fn f [s] \n  (reduce #(concat % (if (coll? %2) (f %2) [%2])) () s))","problem":28,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":28,"code":"(fn jflatten [s]\n  (if (sequential? s)\n    (mapcat jflatten s)\n    (list s)))","user":"538db083e4b0b51d73faae74"},{"code":"(fn f [x]\n  (if (empty? x) nil\n    (if (sequential? (first x))\n      (concat (f (first x)) (f (rest x)))\n      (cons (first x) (f (rest x)))\n)))","problem":28,"user":"4ffb59f6e4b0678c553fc3cf"},{"code":"(fn [x] (filter #(not (sequential? %)) (tree-seq sequential? seq x)))","problem":28,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":28,"code":"(fn flat [x] (if (sequential? x) (apply concat (map flat x)) [x]))","user":"55c10409e4b01b9910ae2a2c"},{"problem":28,"code":"(fn [sq]\n  (reverse \n    (loop [xs sq\n           acc '()]\n      (if (empty? xs)\n        acc\n        (if-not (sequential? (first xs))\n          (recur (rest xs) (cons (first xs) acc))\n          (recur (concat (first xs) (rest xs)) acc))))))","user":"574c3d4ee4b02ea11479921a"},{"problem":28,"code":"(fn flatten-my [x]\n   (if (coll? x)\n     (apply concat (map flatten-my x))\n     (list x)))","user":"56dc34a3e4b0ea9b8538f816"},{"problem":28,"code":"(fn my-flatten [coll]\n  (mapcat #(if (or (list? %) (vector? %)) (my-flatten %) (list %)) coll)\n)","user":"55e274b4e4b050e68259b436"},{"problem":28,"code":"(fn zatten [seq]\r\n  (cond (coll? seq) (mapcat zatten seq)\r\n    :t [seq]))","user":"566470b9e4b0e91d5f5c5658"},{"code":"(fn my-flatten [col]\n  (cond\n    (empty? col) col\n    (coll? (first col)) (concat (my-flatten (first col))\n                                (my-flatten (rest col)))\n    :else (conj (my-flatten (rest col)) (first col) )))","problem":28,"user":"50310b8be4b05b7df5a0b84d"},{"problem":28,"code":"(fn my-flatten\n  ([s] (my-flatten s []))\n  ([s result]\n   (cond\n     (not (seq s)) result\n     (sequential? (first s)) (my-flatten (rest s) (my-flatten (first s) result))\n     :else (recur (rest s) (conj result (first s))))))","user":"555ee545e4b0a2eb076a39bd"},{"code":";; Flatten\n#(filter (complement sequential?)\n         (rest (tree-seq sequential? seq %)))\n\n;;(fn flat [x]\n;;  (if (coll? x)\n;;    (mapcat flat x)\n;;    [x]))","problem":28,"user":"503f4759e4b00d1a725ff2a9"},{"code":"(fn f [s]\n  (if (sequential? s)\n    (mapcat f s) \n    [s]))","problem":28,"user":"4ef667c4535dced4c769f24c"},{"code":"(fn flt [coll]\r\n  (let [l (first coll) r (next coll)]\r\n    (concat \r\n      (if (sequential? l)\r\n        (flt l)\r\n        [l])\r\n      (if (sequential? r)\r\n        (flt r)))))","problem":28,"user":"4e70a7c1535d5021c1a8963c"},{"problem":28,"code":"(fn f\n  [s]\n    (reduce\n      (fn g [col el]\n        (if (sequential? el)\n          (reduce g col el)\n          (conj col el))) [] s))","user":"5ed15e23e4b016b56eae05ba"},{"code":"(fn flat [x]\n   (if (sequential? x)\n     (mapcat flat x)\n    (seq [x])))","problem":28,"user":"51e89428e4b006d205356a51"},{"problem":28,"code":"(fn myflatten [x]\n   (if (empty? x) x\n     (let [f (first x) r (rest x)]\n       (if (or (seq? f) (vector? f))\n         (concat (myflatten f) (myflatten r))\n         (cons f (myflatten r))\n         )\n       )\n     )\n  )","user":"5a8d55a8e4b05369db4d2514"},{"code":"(fn x-f [x] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"51064b76e4b01150e115ebe4"},{"code":"(fn tf [x] \n  (mapcat #(if (coll? %) \n             (concat (tf [(first %)]) (tf (next %))) \n             [%]) x))","problem":28,"user":"52d7a930e4b09f7907dd1379"},{"code":"(fn flt [s]\n  (cond\n    (empty? s) s\n    (coll? (first s)) (concat (flt (first s)) (flt (rest s)))\n    :else (conj (flt (rest s)) (first s))))","problem":28,"user":"50ebd63ce4b04edc3377703c"},{"code":"(fn  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"51416934e4b03d51af0d04f0"},{"code":"(fn ! [xs]\n  (reduce (fn [accum nxt]\n            (if (coll? nxt)\n              (reduce conj accum (! nxt))\n              (conj accum nxt)))\n          [] xs))","problem":28,"user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":28,"code":"(fn f [c]\n  (if (empty? c)\n    c\n    (if (coll? (first c))\n      (concat (f (first c)) (f (rest c)))\n      (cons (first c) (f (rest c))))\n    )\n  )","user":"607bd80be4b0a637ed780379"},{"code":"#(filter (complement sequential?)\n         (tree-seq sequential? seq %))","problem":28,"user":"511c91ace4b00c2a1fa7ff7a"},{"problem":28,"code":"(fn flat [[x & rs]]\n    (cond \n      (nil? x)        nil \n      (sequential? x) (concat (flat x) (flat rs))\n      :else          (cons x (flat rs))))","user":"55ae383fe4b03311e7b732b7"},{"code":"(fn my-flat [s] (if (sequential? s) (mapcat my-flat s) (list s)))","problem":28,"user":"51bc2f6ae4b0fe3ecfb46452"},{"code":"(fn fl [coll]\n  (filter #(not (sequential? %))\n             (tree-seq sequential? seq coll)))","problem":28,"user":"51750fc5e4b07031762f2ee6"},{"problem":28,"code":"(fn [c] (reverse ((fn fl [c v] (seq (reduce (fn [c v] (if (coll? v)(fl c (seq v))(cons v c))) c v))) [] c)))","user":"55ead489e4b0121d4835fdb6"},{"code":"(fn rec [l]\n          (if (empty? l)\n            []\n            (if (coll? (first l))\n              (into (rec (first l)) (rec (rest l)))\n              (into [(first l)] (rec (rest l))))))","problem":28,"user":"52753740e4b03e8d9a4a74c1"},{"problem":28,"code":"(fn flat [t]\n  (if-not (coll? t)\n    (if-not (nil? t) (list t))\n    (concat (flat (first t)) (flat (next t)))))","user":"55d74e71e4b0e31453f64aa4"},{"problem":28,"code":"(fn flatten-list\n  ([list] (flatten-list list '()))\n  ([list result-list]\n   (if (empty? list)\n     result-list\n     (if (or (seq? (first list)) (coll? (first list)))\n       (flatten-list (rest list) (concat result-list (flatten-list (first list))))\n       (flatten-list (rest list) (concat result-list [(first list)]))))))","user":"59f88123e4b0ca45a743a31e"},{"code":"(fn [x]\n  (let [helper\n   (fn that [a b]\n    (if (coll? b)\n     (reduce that a b)\n     (conj a b)))]\n   (reduce helper [] x)))","problem":28,"user":"4f038017535dcb61093f6afa"},{"problem":28,"code":"(fn flapjack [l]\n  (cond\n    (empty? l) '()\n    :else (concat\n           (let [a (first l)]\n             (if (coll? a)\n               (flapjack a)\n               (list a)))\n           (flapjack (rest l)))))","user":"558df2ebe4b0277789237649"},{"problem":28,"code":"(fn xxx [s]\n  (reduce (fn [a b] \n            (if (or (vector? b) (seq? b))\n            (concat a (xxx b))\n              (conj (apply vector a) b))) [] s))","user":"56308326e4b073c1cf7a9be9"},{"problem":28,"code":"(fn myf [lis]\n  (when-not(empty? lis)\n    (if(sequential? (first lis))\n      (lazy-seq (myf (concat (first lis) (rest lis))))\n      (cons (first lis) (lazy-seq (myf (rest lis)))))))","user":"5191a763e4b0d428d29dc1b4"},{"problem":28,"code":"#(filter (complement nil?)\n        ((fn m [s]\n           (if (sequential? s)\n             (concat (m (first s)) (m (next s)))\n             (list s)))%))","user":"5829bc55e4b051871117bf49"},{"problem":28,"code":"(fn [s]\n   (letfn [(parse-seq [l acc]\n             (cond\n               (empty? l) acc\n               (coll? (first l)) (recur (rest l) (parse-seq (first l) acc))\n               :else (do\n                      (recur (rest l) (conj (vec acc) (first l))))))\n           (flat [l acc]\n             (if (empty? l)\n               acc\n               (cond\n                 (empty? l) acc\n                 (coll? (first l)) (recur (rest l) (parse-seq (first l) acc))\n                 :else (recur (rest l) (conj (vec acc) (first l))))))]\n     (flat s [])))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":28,"code":"(fn flat [xs]\n  (if (seq xs)\n    (let [[head & tail] xs]\n      (if (sequential? head)\n        (concat (flat head) (flat tail))\n        (cons head (flat tail))))\n    nil))","user":"5a95c639e4b0d174b936c75e"},{"code":"(fn fl [coll]\n   (let [l (first coll) \n         r (next coll)]\n     (concat\n      (if (sequential? l)\n         (fl l)\n         [l])\n      (when (sequential? r)\n         (fl r)))))","problem":28,"user":"50e3ea47e4b0463d32072485"},{"code":"(fn my-flatten\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f341320e4b0e243712b1eb4"},{"problem":28,"code":"(fn fl [s]\n   (if (sequential? s)\n      (mapcat fl s)\n     [s]))","user":"58bd1ab9e4b0888cdc949d27"},{"problem":28,"code":"#(reduce (fn flat [result,item] (if (coll? item) (concat result (reduce flat '() item))\n (concat result (list item))                                 )) '() %)","user":"583c4482e4b089d5ab817d7e"},{"problem":28,"code":"(fn [coll]\n   (loop [coll coll r [] remained nil]\n     (do\n       (if (seq coll)\n        (let [fr (first coll)\n              re (rest coll)]\n          (if (sequential? fr)\n            (recur fr r (if remained (cons re remained) re))\n            (recur re (conj r fr) remained)))\n        (if (seq remained)\n          (recur remained r nil)\n          r)))))","user":"4f847f0ee4b033992c121c33"},{"problem":28,"code":"(fn flat [var]\n  (if (coll? var)\n    (mapcat flat var)\n    [var]))","user":"550b4ea2e4b06e50f9beb13e"},{"code":"(fn [coll] (loop [r []\n  \t        c coll]\n              (if (empty? c) r\n                (recur (if (coll? (first c)) r (conj r (first c)))\n                       (if (coll? (first c)) (concat (first c) (rest c)) \n\t\t\t   (rest c))))))","problem":28,"user":"4ea4e98a535d7eef308072ce"},{"code":"(fn flat\n   ([l] (flat [] l))\n   ([a l]\n      (cond\n       (empty? l) a\n       (or (integer? (first l)) (string? (first l)) (keyword? (first l))) (flat (conj a (first l)) (rest l))\n       true (concat a (flat (first l)) (flat (rest l))))))","problem":28,"user":"4ee868be535d93acb0a6687d"},{"problem":28,"code":"#(loop [values %\n           acc []]\n      (let [value (first values)]\n        (if (nil? value)\n          acc\n          (if (coll? value)\n            (if (empty? (rest values))\n              (recur value\n                     acc)\n              (recur (apply conj (apply vector value) (rest values))\n                     acc))\n            (recur (rest values)\n                   (conj acc value))))))","user":"54508859e4b0e397800069a3"},{"problem":28,"code":"(fn myflatten [coll]\n  (loop [[head & tail] coll\n         result []]\n    \t(if (nil? head)\n        \tresult\n    \t\t(if (coll? head)\n              \t(recur tail (concat result (myflatten head)))\n              \t(recur tail (concat result [head]))\n             )\n          )\n    )\n  )","user":"54021f13e4b0df28a13c62cc"},{"problem":28,"code":"(fn my-flatten [lst]\n  (if (empty? lst) ()\n    (if (or (list? (first lst)) (vector? (first lst))) \n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (cons (first lst) (my-flatten (rest lst))))))","user":"59e4e3cbe4b08badc2a0c54a"},{"code":"(fn [s]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq s)))","problem":28,"user":"4e6a4954535d8ccf87e9fec0"},{"code":"(fn j-flatten\r\n  [[h & t]]\r\n  (if (nil? h)\r\n    nil\r\n    (if (coll? h)\r\n      (concat (j-flatten h) (j-flatten t))\r\n      (cons h (j-flatten t)))))","problem":28,"user":"504ec4d3e4b069badc5a33c9"},{"code":"(fn fl [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4ffb3c50e4b0678c553fc3c8"},{"code":"(fn f [s]\n  (let [h (fn [s] (apply concat (map (fn [x] (if (coll? x) x (list x)))\n                                     s)))]\n    (if (= s (h s)) s\n      (f (h s)))))","problem":28,"user":"52247d56e4b01819a2de42db"},{"problem":28,"code":"(fn flatten-this\n  [xs]\n  (reduce (fn flat\n            [acc x]\n            (if (sequential? x)\n              (into acc (flatten-this x))\n              (conj acc x))) [] xs))","user":"5c35acffe4b0d62ef62d9f62"},{"code":"(fn [coll]\n\t(loop [sofar [] next nil remaining coll]\n\t   (cond (and (nil? next) (empty? remaining))\n\t\t sofar\n\t\t (nil? next)\n\t\t (recur sofar (first remaining) (rest remaining))\n\t\t (sequential? next)\n\t\t (if (empty? next)\n\t\t     (recur sofar nil remaining)\n\t\t     (let [this (first next)]\n\t\t\t  (if (sequential? this)\n\t\t\t      (recur sofar (first this) (cons (rest this) (cons (rest next) remaining)))\n\t\t\t      (recur (conj sofar this) (rest next) remaining))))\n\t\t :else (recur (conj sofar next) (first remaining) (rest remaining)))))","problem":28,"user":"4e68fad4535d8ccf87e9fe93"},{"problem":28,"code":"(fn flatten-2 [x]\n  (reduce (fn [acc y]\n            (if (sequential? y)\n              (concat acc (flatten-2 y))\n              (concat acc (list y)))) (list) x))","user":"5889b012e4b0f1effa3b7744"},{"code":"(fn f [s x] (if (coll? x) (reduce f s x) (conj s x))) []","problem":28,"user":"4ecbb249535df97575fdabdf"},{"problem":28,"code":"(fn fltn\n  [coll]\n  (->> coll\n       (reduce\n         (fn [acc x]\n           (if (coll? x)\n             (apply conj acc (fltn x))\n             (conj acc x)))\n         '())\n       reverse))","user":"5b9357b7e4b0c0b3ffbd4a46"},{"problem":28,"code":"(fn flatter [thing]\n  (if (coll? thing)\n    (mapcat flatter thing)\n    [thing]))","user":"587fb546e4b0f1effa3b75f9"},{"problem":28,"code":"(fn flatdis [elements]\n  (let [fstElem (first elements)\n        restElems (rest elements)]\n    (if (nil? fstElem)\n      '()\n      (if (sequential? fstElem)\n        (concat (flatdis fstElem) (flatdis restElems))\n        (conj (flatdis restElems) fstElem)))))","user":"5dc4719ae4b02f9375f4e1b5"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))","problem":28,"user":"4def301c535d08e6dec9fe12"},{"code":"(fn flat [c] (mapcat #(if (coll? %) (flat %) (list %)) c))","problem":28,"user":"4e95f5a5535dbda64a6f6b3b"},{"problem":28,"code":"(fn flat [[s & sr]] (let [s' (if (sequential? s) (flat s) [s])] (if (nil? sr) s'\n (concat s' (flat sr)))  ))","user":"5ecc0831e4b016b56eae058c"},{"problem":28,"code":"(fn [col] (if (every? #(not (sequential? %)) col)\n  col\n  (recur (mapcat  #(if (sequential? %) % [%]) col))))","user":"555883c5e4b0deb715856e2d"},{"code":"#(loop [c %\n        r []]\n    (if (empty? c)\n      r\n      (if (coll? (first c))\n        (recur (concat (first c) (rest c)) r)\n        (recur (rest c) (conj r (first c))))))\n;  using mapcat:\n; (fn f [x] (if (coll? x) (mapcat f x) [x]))","problem":28,"user":"4f82ed48e4b033992c121c0e"},{"problem":28,"code":"(fn my-flat\n  [aseq]\n  (if (sequential? aseq)\n    (mapcat my-flat aseq)\n    [aseq]))","user":"557e2eafe4b05c286339e0d2"},{"problem":28,"code":"(fn flat-coll\n  \n  [coll]\n  (loop [result []\n         c (vec coll)]\n    (if-let [frst (first c)]\n      (if (coll? frst)\n        (recur (vec (concat result (flat-coll frst))) (rest c))\n        (recur (conj result frst) (rest c)))\n      result)))","user":"552bd5c2e4b0ffed3738f969"},{"problem":28,"code":"(fn flat [xs]\n    (cond\n     (empty? xs) nil\n     (coll? (first xs)) (concat (flat (first xs)) (flat (rest xs)))\n     :else (conj (flat (rest xs)) (first xs))))","user":"56d30497e4b0ea9b8538f7a8"},{"code":"(fn flat [xs]\n  (loop [xs xs]\n    (if-not (some coll? xs)\n      xs\n      (recur (reduce #(if (coll? %2) (vec (concat % %2)) (conj % %2)\n) [] xs)))))","problem":28,"user":"4fb79872e4b081705acca2d2"},{"problem":28,"code":"(fn flatt [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"55b1ab40e4b0da326a65cf6e"},{"problem":28,"code":"(fn [in] (filter (complement sequential?) (tree-seq sequential? seq in)))","user":"56d902c3e4b0ea9b8538f7ed"},{"code":"(fn flat [x] \n  (if (coll? x)\n    (if (= (count x) 0)\n      nil\n      (concat (flat (first x)) (flat (rest x))))\n    (list x)\n  )\n)","problem":28,"user":"504e2f98e4b0f6ff3350c47e"},{"problem":28,"code":"(fn f\n  [a]\n  (if (sequential? a)\n    (if (empty? a)\n      a\n      (concat (f (first a)) (f (rest a))))\n\n    (list a)))","user":"5fd9bf47e4b05ac5b16ea125"},{"code":"(fn flat [coll] \n  (when (not-empty coll)\n    (let [f (first coll)]\n      (concat \n        (if (coll? f) (flat f) (list f))\n        (flat (rest coll))))))","problem":28,"user":"4f030bb4535dcb61093f6a4a"},{"problem":28,"code":"(fn f [c]\n  (let [l (first c) r (next c)]\n    (concat \n      (if (coll? l)\n        (f l)\n        [l])\n      (when (coll? r)\n        (f r)))))","user":"548d6b75e4b0e286459a1216"},{"problem":28,"code":"(fn fl [xs]\n  (reduce #(if (coll? %2)\n            (concat %1 (fl %2))\n            (concat %1 (list %2)))\n          '() xs))","user":"54708efce4b00cfc9eacc1b9"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (mapcat my-flatten s)\n    (list s)\n  )\n)","user":"60335b35e4b0d5df2af222bf"},{"problem":28,"code":"(fn [x]\n  (let [r (atom '())]\n      (clojure.walk/prewalk\n       (fn [y]\n         (if (coll? y)\n           y\n           (do (swap! r conj y)\n           y)))\n       x)\n       (reverse @r)))","user":"5530b827e4b076ab5578f818"},{"code":"(fn fl [s]\n  (reduce (fn [i v]\n            (if (or (seq? v) (vector? v) (list? v) (coll? v))\n              (reduce conj i (fl v))\n              (conj i v)\n            )\n          )\n       [] s))","problem":28,"user":"4f3e6244e4b0e243712b1f85"},{"code":"(fn flat [s]\n  (cond\n   (empty? s) '()\n   (coll? (first s)) (concat (flat (first s)) (flat (rest s)))\n   :else (cons (first s) (flat (rest s)))))","problem":28,"user":"52090654e4b0e152394d76ee"},{"problem":28,"code":"(fn myflat [x] \n  (if (coll? x)\n    (if (empty? x) \n      x \n      (concat \n       (myflat (first x))\n       (myflat (rest x))\n      )\n    )\n    (list x)\n  )\n)","user":"56ea8b75e4b04a395b9a0409"},{"problem":28,"code":"(fn my-flatten [args]\n  (if\n    (empty? args) nil\n    (let\n        [x (first args)\n         ys (rest args)]\n      (if (sequential? (first args))\n        (concat (my-flatten x) (my-flatten ys))\n        (concat (list x) (my-flatten ys))))))","user":"59f7f55de4b0ca45a743a313"},{"problem":28,"code":"(fn foo [xs]\n  (if (sequential? xs)\n    (if (= 0 (count xs))\n      nil\n      (concat (list)\n              (foo (first xs))\n              (foo (rest xs))))\n    (list xs)))","user":"54d753ebe4b0a52adc2e2029"},{"problem":28,"code":"(fn foo [x]\n  (let [f (first x) r (rest x)]\n    (concat \n     (if (sequential? f) \n       (foo f) \n       (list f))\n     (when-not (empty? r) (foo r) ))))","user":"55b1e9e7e4b0da326a65cf74"},{"code":"(fn F\n  [[x & xs]]\n  (let [more? #(or (list? %) (vector? %))]\n    (cond (and (more? x) xs) (concat (F x) (F xs))\n          (more? x) (F x)\n          xs (cons x (F xs))\n          :else (cons x nil))))","problem":28,"user":"5143c13ee4b0b4fb4ace5f3b"},{"problem":28,"code":"(fn flat [s]\n  (if (coll? s) \n  (mapcat flat s)\n    [s]))","user":"56ede653e4b04a395b9a0449"},{"problem":28,"code":"(fn flt\n  [col]\n  (if (sequential? col)\n    (mapcat flt col)\n    (list col)))","user":"54e336f3e4b024c67c0cf7da"},{"code":"(fn flat [x] (reduce #(if (sequential? %2) (into %1 (flat %2)) (conj %1 %2)) [] x))","problem":28,"user":"4f83665ee4b033992c121c1c"},{"problem":28,"code":"(fn flat [s]\n  (if (empty? s)\n    '()\n    (let [fs (first s)\n          rs (rest s)]\n      (if (sequential? fs)\n        (concat (flat fs) (flat rs))\n        (conj (flat rs) fs)))))","user":"578f1edae4b0ebec4cfb7590"},{"problem":28,"code":"(fn my-flatten\n [col]\n (if (not (sequential? col))\n   [col]\n   (reduce #(concat %1 (my-flatten %2)) [] col)))","user":"5dbac8ebe4b010eb3c36cd62"},{"problem":28,"code":"#(loop [l1 %, l2 '()]\n   (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2))))","user":"536e5b68e4b0fc7073fd6e6d"},{"problem":28,"code":"(fn flat [s] (if (coll? s) (if (empty? s) [] (concat (flat (first s)) (flat (rest s)))) [s]))","user":"54f3d6c7e4b050824f58f5cb"},{"problem":28,"code":"(fn my-flatten [mylist]\n  (loop [orig mylist\n         result `()]\n    (cond\n      (sequential? (first orig))\n      (recur (concat (first orig) (rest orig)) result)\n      (empty? orig) (reverse result)\n      :else (recur (rest orig) (cons (first orig) result)))))","user":"5bc4f266e4b07a9b28b10066"},{"problem":28,"code":"(fn flattenImplementation                                                                              \n  [collectionInput]                                                                                        \n  (loop [finalList '() elementList (list collectionInput)]                                                \n    (if (empty? elementList)                                                                    \n      finalList                                                                                 \n      (if (coll? (first elementList))                                                     \n        (recur finalList (into (rest elementList) (first elementList)))                         \n        (recur (conj finalList (first elementList)) (rest elementList))))))","user":"578bbd3ee4b0ebec4cfb754e"},{"code":"#((fn flatt [xs]\n    (if (sequential? xs)\n      (apply concat (map flatt xs))\n      [xs])) %)","problem":28,"user":"517bf28de4b07ef0e56148d5"},{"code":"(fn flat [s]\n  (if (not-any? coll? s)\n    s\n    (recur (reduce \n      #(if (coll? %2) \n        (if (empty? (rest %2)) \n          (conj %1 (first %2)) \n          (conj %1 (first %2) (rest %2))\n        )\n        (conj %1 %2) ) [] s))\n))","problem":28,"user":"4f790ad5e4b0fbe0118ec58d"},{"code":"(fn my-flatten [s]\n  (if (coll? s)\n    (if (empty? s)\n      []\n      (concat (my-flatten (first s))\n              (my-flatten (rest s))))\n    [s]\n    )\n  )","problem":28,"user":"52bc6f5ee4b07a9af57922f6"},{"code":"(fn f [s]\n  (cond (not (sequential? s)) (list s)\n        (empty? s) '()\n        :else (concat (f (first s)) (f (rest s)))))","problem":28,"user":"50555c06e4b0ce54f56f03fa"},{"code":"(fn flat \n  ([v]\n    (flat () v))\n  ([result [v & more]]\n  (let [new-result (cond\n            (or (seq? v) (vector? v)) (into result (flat v))\n            :else (conj result v))]\n    (if (empty? more)\n      (reverse new-result)\n      (flat new-result more)))))","problem":28,"user":"4f9174d0e4b0dcca54ed6c9b"},{"problem":28,"code":"(fn [cs]\n  (letfn [(f [cs]\n            (when cs\n              (if (and (coll? cs) (not-empty cs))\n                (concat (f (first cs))\n                        (f (rest cs)))\n                (when-not (coll? cs)\n                  [cs]))))]\n    (let [rs (f cs)]\n      (if (not (coll? rs))\n        (list rs)\n        rs))))","user":"583369e6e4b089d5ab817c9c"},{"problem":28,"code":"(fn f [x]\n  (sort (cond\n    (not-any? coll? x) x\n\t:else (concat (remove coll? x) (f (apply concat (filter coll? x)))))))","user":"54ab502fe4b09f271ff37cc4"},{"problem":28,"code":"(fn fla [coll] (if (sequential? coll) (mapcat fla coll) (list coll)))","user":"573632b7e4b0cd1946bd102f"},{"code":"(fn xxx [s]\n  (loop [n1 s o1 []]\n    (if (= n1 o1) n1 \n      (recur \n        (loop [n [] o n1]\n          (if o\n            (let [f (first o) r (next o)]\n              (recur (if (coll? f) (concat n f) (concat n [f])) r) \n            )\n            n\n          )\n        ) \n        n1\n      )\n    )\n  )\n)","problem":28,"user":"50b24a2fe4b03ea88043355c"},{"problem":28,"code":"#(map read-string (re-seq #\"\\d|\\\"\\w\\\"|\\:\\w\" (str %)))","user":"544fbabce4b0e39780006999"},{"problem":28,"code":"(fn flat [l]\n  (if (sequential? l)\n    (reduce concat [] (map flat l))\n    [l]))","user":"594263cbe4b060784b3b790a"},{"code":"(fn [initial-coll] \n  (first \n    (filter #(not (some sequential? %)) \n       (iterate \n         (fn [coll] \n           (apply concat \n                  (map \n                    (fn [entry] \n                      (if (sequential? entry) \n                          entry \n                          (list entry))) \n                    coll))) \n          initial-coll))))","problem":28,"user":"5014754de4b094324338f8e5"},{"problem":28,"code":"(fn [coll]\n  (loop [flat-coll [] rem-coll coll]\n        (if (empty? rem-coll)\n            flat-coll\n            (if (sequential? (first rem-coll))\n                (recur flat-coll (concat (first rem-coll) (rest rem-coll)))\n                (recur (conj flat-coll (first rem-coll)) (rest rem-coll))))))","user":"5911aa1de4b0163c97b36ed8"},{"code":"#((fn append [lst elem] \n    (if (coll? elem)\n        (if (empty? elem)\n            lst\n            (append (append lst (first elem)) \n                    (rest elem)))\n        (conj lst elem)\n    )) [] %)","problem":28,"user":"4e4870d1535dc968683fc4bc"},{"code":"(fn flatten- [col]\n  (lazy-seq\n   (if (coll? col)\n     (if (seq col)\n       (concat (flatten- (first col)) (flatten- (rest col)))\n       ())\n     `(~col))))","problem":28,"user":"5163b06be4b055933a9ca030"},{"code":"(fn [root]\n  (let [branch? (fn [x] (sequential? x))\n        children (fn [x] (seq x))\n        walk (fn walk [node]\n               (lazy-seq\n                (if (branch? node)\n                  (cons node (mapcat walk (children node)))\n                  (list node)\n                  ))\n               )]\n    (filter (complement sequential?) (walk root))\n    ))","problem":28,"user":"4efec33f535dcb61093f6a2a"},{"problem":28,"code":"(fn this [x] (reduce (fn [a b] (if (coll? b) (into a (this b)) (conj a b))) [] x))","user":"55201d18e4b08d5046aa8a5d"},{"problem":28,"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (println \"x\" \": \" x)\n    (println \"xs\" \": \" xs)\n    (cond\n      (empty? n)\n      (do\n        (println n \" is empty\")\n        '()\n        )\n      (coll? x)\n      (do\n        (println x \" is a collection\")\n        (concat (flat x) (flat xs))\n        )\n      :else (do\n              (println \" cons \" x \"(flat \" xs \")\")\n              (cons x (flat xs))))))","user":"598c8db8e4b02b9968b84d06"},{"code":"(fn f [xs] (if (sequential? xs) (mapcat f xs) [xs]))","problem":28,"user":"4ec53831535d6d7199dd3684"},{"code":"#(some (fn [s] (if (not-any? coll? s) s false)) (iterate \n                                (fn [s] \n                                  (loop [ret []\n                                         tmp s]\n                            \t\t(if (empty? tmp)\n                                      ret\n                                      (recur (if (coll? (first tmp)) \n                                                (into ret (first tmp))\n                                                (conj ret (first tmp)) )\n                                             (rest tmp))))) \n                                %))","problem":28,"user":"51944aaae4b0142f60b4aedc"},{"problem":28,"code":"(fn my-flatten\n    ([coll]\n     (let [car (first coll)\n           cdr (rest coll)]\n       (if (coll? car)\n         (if (empty? cdr)\n           (into (my-flatten car) [])\n           (into (my-flatten car) (my-flatten cdr)))\n         (if (empty? cdr)\n           [car]\n           (into [car] (my-flatten cdr)))))))","user":"51f40975e4b0fca5e8b4822e"},{"problem":28,"code":"(fn [coll] (filter (complement sequential?) (tree-seq sequential? #(identity %) coll)))","user":"56f188e9e4b04a395b9a0494"},{"code":"(fn flat [col]\n  (if (sequential? col)\n    (if (empty? col)\n      ()\n      (concat (flat (first col)) (flat (rest col))))\n    (list col)))","problem":28,"user":"4e399009535deb9a81d77f3f"},{"code":"(fn make-flat [s]\n  (reduce (fn [acc el]\n            (if (coll? el)\n              (vec (concat acc (make-flat el)))\n              (conj acc el)))\n          []\n          s))","problem":28,"user":"516385cee4b055933a9ca02d"},{"problem":28,"code":"(fn my-flatten [input]\n  (let [element (first input) \n        remaining (rest input)]\n    (when element\n      (if (sequential? element)\n        (concat (my-flatten element) (my-flatten remaining))\n        (concat (list element) (my-flatten remaining))))))","user":"542a8d07e4b01498b1a71b43"},{"problem":28,"code":"(fn flat [n]\n  (let [x (first n) xs (rest n)]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","user":"55a35ef4e4b0acc240e31535"},{"problem":28,"code":"(fn f [col]\n   (reduce (fn [c e]\n             (concat c (if (coll? e) (f e) [e])))\n           []\n           col))","user":"60537cd1e4b04c8f2157d152"},{"problem":28,"code":"#(letfn [(flttn [cll]\n            (reduce\n             (fn [accm entt]\n               (if (coll? entt)\n                 (reduce conj accm (flttn entt))\n                 (conj accm entt)))\n             [] cll))]\n   (flttn %))","user":"60b1add0e4b0e0fa5f1b4227"},{"problem":28,"code":"(fn f[x] \n  (if (sequential? x) \n    (reduce concat (map f x)) \n    [x]\n  )\n)","user":"54283a7ae4b01498b1a71b2f"},{"problem":28,"code":"(fn flat [col]\n  (if (empty? col)\n    col\n    (let\n      [x (first col)\n       xs (rest col)]\n      (if (coll? x)\n        (concat (flat x) (flat xs))\n        (cons x (flat xs))))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn flat [in]\n  (reverse\n    (reduce \n     (fn [fst sec] \n       (if (coll? sec) \n         (into fst (flat sec))\n         (into fst (list sec))))\n     '()\n     in)))","problem":28,"user":"51aefceee4b09397d5109797"},{"problem":28,"code":"#(if (empty? %2)\n          %1\n          (if-not (coll? (first %2))\n            (recur (conj %1 (first %2)) (rest %2))\n            (recur %1 (concat (first %2) (rest %2))))) []","user":"5a3ece62e4b0447ef91cc5b9"},{"code":"(fn flt [[x & xs]]\n  (cond (nil? x) '()\n        (sequential? x) (concat (flt x) (flt xs))\n        :else (cons x (flt xs))))","problem":28,"user":"53809b34e4b06839e8705ec3"},{"problem":28,"code":"(fn temp\n  [coll]\n  (if (sequential? coll)\n    (mapcat temp coll)\n    [coll]))","user":"5a3b5cfde4b001c08efc0cd4"},{"problem":28,"code":"(fn myflatten \n   ([coll] (myflatten coll []))\n\n   ([coll c]\n    (reduce (fn [acc item]\n              (if (coll? item)\n                (myflatten item acc)\n                (conj acc item)))\n            c coll)))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":28,"code":"(fn flatten* [x]\n  (if-not (sequential? x)\n    [x]\n    (mapcat flatten* x)))","user":"59eb69fbe4b0249b7282077e"},{"code":"(fn [root]\n  (filter (complement sequential?)\n          (let [w (fn w [node]\n                    (lazy-seq\n                     (cons node\n                           (when\n                               (sequential? node)\n                             (mapcat w (seq node))))))]\n            (w root))))","problem":28,"user":"4dadaa5cc9a9d6ed2f99dc57"},{"problem":28,"code":"(fn flat [xs]\n  (lazy-seq\n    (if-let [s (seq xs)]\n      (if (sequential? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s)))))))","user":"5069d8c5e4b01dc6af13f838"},{"code":"(fn flt [coll]\n        (lazy-seq\n         (when-let [x (seq coll)]\n           (let [head (first x)\n                 flat-head (if (sequential? head)\n                             (flt head)\n                             (list head))\n                 rst (rest x)]\n             (concat flat-head (flt rst))))))","problem":28,"user":"5137c3b0e4b0509a8b470482"},{"problem":28,"code":"(fn f [xs]\n  (filter (complement sequential?) (tree-seq sequential? seq xs)))","user":"573d58c8e4b05c31a32c0811"},{"code":"(fn f [s] (seq (reduce #(into % (if (coll? %2) (f %2) [%2])) [] s)))","problem":28,"user":"525b0b51e4b0cb4875a45d01"},{"code":"(fn flatt [[x & coll]]\r\n  (if x\r\n    (lazy-seq\r\n     (if (coll? x)\r\n       (concat ( flatt x) (flatt coll)) \r\n       (cons x (flatt coll))))))","problem":28,"user":"4fb23582e4b081705acca28a"},{"code":"(fn flat \n   ([i] (flat i []))\n   ([input s]\n   (if (= 0 (count input))\n     s\n     (if (coll? (first input))\n       (flat (rest input) (flat (first input) s))\n       (flat (rest input) (conj s (first input)))))))","problem":28,"user":"52d6120ee4b09f7907dd134c"},{"problem":28,"code":"(fn f [s] (if (sequential? s) (mapcat f s) (list s)))","user":"55c58c0be4b0e31453f649b3"},{"code":"(fn _ [s] (mapcat #(if (coll? %) (_ %) (list %)) s))","problem":28,"user":"53527551e4b084c2834f4af0"},{"problem":28,"code":"(fn f [xs]\n   (reduce #(if (coll? %2)\n               (vec (concat %1 (f %2)))\n               (conj %1 %2)) [] xs))","user":"57e10705e4b0bfb2137f5a6a"},{"code":"#(filter (complement sequential?)\n        (tree-seq sequential? seq %))","problem":28,"user":"52381b2ae4b0fae3832e99ef"},{"code":"(fn flat [cl]\n  (letfn [(fl [coll]\n            (lazy-seq\n              (when-let [c (seq coll)]\n                (let [x (first c)\n                      nxt (fl (next c))]\n                    (if (sequential? x)\n                        (concat (fl x) nxt)\n                        (cons x nxt))))))]\n    (if (sequential? cl) (fl cl) (list))))","problem":28,"user":"4e71cc2e535d5021c1a89652"},{"problem":28,"code":"(fn flat\n  [xs]\n  (when (seq xs)\n    (lazy-seq\n      (let [[x & more] xs]\n        (if (sequential? x)\n          (flat (concat x more))\n          (cons x (flat more)))))))","user":"5d609ddde4b0c9e5857d5008"},{"code":"(\n    fn [x] (sort\n             ((fn [y z accum]\n               (if (not (coll? y))\n                 (if (empty? z) (conj accum y)\n                   (recur (first z) (rest z) (conj accum y)))\n                 (recur (first y) (concat (rest y) z) accum))\n               )\n             (first x) (rest x) (empty x))\n             )\n )","problem":28,"user":"528f82d8e4b0239c8a67aef4"},{"problem":28,"code":"(fn flat [coll]  (lazy-seq (when-let [s (seq coll)] (if (coll? (first s)) (concat (flat (first s)) (flat (rest s))) (cons (first s) (flat (rest s)))))))","user":"5a63f8bae4b0512ff01cd99f"},{"code":"(fn [s]\n  (loop [flat [] c s]\n    (if (empty? c)\n      (reverse flat)\n      (recur\n        (if (coll? (first c))\n          flat\n          (cons (first c) flat))\n        (if (coll? (first c))\n          (concat (first c) (rest c))\n          (rest c))))))","problem":28,"user":"52745629e4b03e8d9a4a74a0"},{"code":"(fn flatit [x]\n  (let [h (first x)\n        t (rest x)]\n    (cond\n     (not (seq x)) (empty x)\n     (coll? h) (concat (flatit h) (flatit t))\n     :else (conj (flatit t) h))))","problem":28,"user":"515efd01e4b02c55805ea238"},{"code":"(fn [& args]\n  (filter (complement sequential?)\n    (tree-seq\n    sequential? identity args)))","problem":28,"user":"538d4926e4b0b51d73faae6a"},{"problem":28,"code":"(fn [seq]\n  (loop [[first & rest] seq flatSeq []]\n     (if (nil? first)\n       flatSeq\n       (if (not (coll? first))\n           (recur rest  (concat flatSeq [first]))\n           (recur (concat first rest) flatSeq)))))","user":"59005094e4b0438e51c2d01e"},{"problem":28,"code":"(fn my-flatten\n  ([seq-to-flat rsf]\n   (if (empty? seq-to-flat)\n     (reverse rsf)\n     (if (coll? (first seq-to-flat))\n       (recur (concat (first seq-to-flat)\n                      (rest seq-to-flat))\n              rsf)\n       (recur (rest seq-to-flat)\n              (cons (first seq-to-flat) rsf)))))\n  ([seq-to-flat]\n   (my-flatten seq-to-flat nil)))","user":"5a9829e5e4b0d174b936c788"},{"problem":28,"code":"(fn flat [s]\n  (if (coll? s)\n    (mapcat flat s)\n           [s]))","user":"5703ce0fe4b08d47c97781fd"},{"problem":28,"code":"#(reduce (fn hell [acc val]\n             (if (or (vector? val)\n                     (list? val)\n                     (seq? val))\n               (reduce hell acc val)\n               (conj acc val)\n               )\n             )\n           [] %)","user":"5da94ccfe4b000c986472c2f"},{"code":"(fn makeFlat [coll]\n  (loop [flat [], left coll]\n    (if (empty? left)\n      flat\n      (if (sequential? (first left))\n        (recur (vec (concat flat (makeFlat (first left)))) (rest left))\n        (recur (conj flat (first left)) (rest left))))))","problem":28,"user":"4ecbff2f535df97575fdabe4"},{"problem":28,"code":"#(filter (complement coll?) (tree-seq sequential? seq %))","user":"53f78944e4b0de5c41848561"},{"problem":28,"code":"(fn fl [c]\n   (when-let [s (seq c)]\n     (lazy-seq (cons\n                (loop [s' s]\n                  (if (sequential? (first s')) (recur (first s')) (first s')))\n                (fl ((fn without-first [s]\n                       (if (or (not (sequential? (first s)))\n                               (= (count (without-first (first s))) 0))\n                         (rest s)\n                         (cons (without-first (first s)) (rest s))))\n                     s))))))","user":"5bb25684e4b0a20761a2350d"},{"problem":28,"code":"(fn f [ xs]\n  (mapcat #(if (sequential? %) (f %) [%]) xs)\n  \n)","user":"5d917ef0e4b0915913b1d402"},{"problem":28,"code":"(fn flt[coll]\n  (let [f (first coll)\n        n (next coll)]\n    (concat\n     (if (sequential? f)\n       (flt f)\n       [f])\n     (when (sequential? n) (flt n)\n       ))))","user":"54d2159fe4b0e8a36923e5ed"},{"code":"(fn flatter [x]\n  (cond\n    (empty? x) ()\n    (sequential? (first x)) (concat (flatter (first x)) (flatter (rest x)))\n    :else (cons (first x) (flatter (rest x)))))","problem":28,"user":"51f04e89e4b0274c496158cd"},{"problem":28,"code":"(fn flat [c]\n   (if (coll? c)\n     (concat (flat (first c)) (if (not (empty? (rest c))) (flat (rest c))) [])\n     [c]))","user":"54df3c94e4b024c67c0cf7aa"},{"problem":28,"code":"(partial (fn flt [s c]\n             (reduce (fn [n e]\n                       (if (coll? e)\n                         (flt n e)\n                         (conj n e))) s c)) [])","user":"580c1e9ae4b0849f6811b719"},{"problem":28,"code":"(fn myfl [xs] (if (coll? xs) (mapcat myfl xs) [xs]))","user":"54a6645be4b09f271ff37c87"},{"problem":28,"code":"(fn flat [s]\n  (if (and (not (seq? s)) (not (vector? s))) (list s)\n    (if (empty? s) s\n      (concat\n       (flat (first s))\n       (flat (rest s))))))","user":"54c9e00be4b045293a27f683"},{"code":"(fn f [c] (mapcat #(if (coll? %) (f %) [%]) c))","problem":28,"user":"4fbf2818e4b081705acca317"},{"problem":28,"code":"(fn fff2[coll](loop[coll coll\n                     ret []\n                     c 1\n                     l (count coll)]\n                 (println coll ret c l)\n                 (cond\n                   (and(every? #(not(coll? %)) coll)\n                       (empty? ret)) coll\n                   :else (recur       (cond\n                                        (= c l)(cond\n                                                       (coll? (first coll))(into ret (first coll))\n                                                       :else(conj ret (first coll)))\n                                        :else (rest coll))\n                                      (cond\n                                        (= c l)[]\n                                        (coll? (first coll))(into ret (first coll))\n                                        :else (conj ret (first coll)))\n                                      (cond\n                                        (= c l) 1\n                                        :else (inc c))\n                                      (cond\n                                        (= c l)(count (into ret (first coll)))\n                                        :else l)\n                                       ))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":28,"code":"#((fn flat [result s]\n  (if-not (coll? s)\n    (conj result s)\n    (reduce flat result s))) [] %)","user":"574ff497e4b02ea114799266"},{"code":"(letfn [(q [x]                                                                                                                                          \n   (if (coll? x)                                                                                                                                         \n    (if (empty? x)                                                                                                                                      \n     ()                                                                                                                                                 \n     (concat (q (first x)) (q (rest x)))                                                                                                                \n     )                                                                                                                                                  \n    (list x)                                                                                                                                            \n  ))]                                                                                                                                                   \n    #(q %)                                                                                                                                              \n  )","problem":28,"user":"5356d00ee4b04ce2eb3ed26f"},{"code":"(fn [sequ]\n  (letfn [(my-flatten [s]\n            (cond (empty? s) ()\n                  (coll? (first s)) (concat (my-flatten (first s)) (my-flatten (rest s)))\n                  :else (cons (first s) (my-flatten (rest s)))))]\n    (my-flatten sequ)))","problem":28,"user":"526f9715e4b03e8d9a4a7372"},{"problem":28,"code":"(fn flx [s]\n  (if (coll? s)\n    (if (empty? s)\n      nil\n      (concat (flx (first s))\n              (flx (rest s)))\n      )\n    (list s)\n            ))","user":"55f47f54e4b06e875b46ce78"},{"problem":28,"code":"(fn \n  [sesuatu] \n  (read-string \n           (str \"(\" (apply str (remove #(or (or (or (= % \\() (= % \\))) (= % \\[)) (= % \\])) (seq (str sesuatu)))) \")\")))","user":"55634f38e4b0c656e3ff17e8"},{"problem":28,"code":"(fn flat [c]\n  (if (coll? c)\n    (mapcat flat c)\n    (list c)))","user":"5f016f37e4b0cf489e8d7f20"},{"problem":28,"code":"(fn f [sq]\n  (if (sequential? sq)\n    (apply concat (map f sq))\n    [sq]))","user":"54157dace4b01498b1a719f4"},{"code":"(fn flatten_ [x]\n    (if (coll? x)\n    (reduce concat (map flatten_ x))\n    (list x)))","problem":28,"user":"4fa5406fe4b081705acca1ac"},{"problem":28,"code":"(fn my-flat [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","user":"555a5731e4b0deb715856e44"},{"problem":28,"code":"(fn squash [coll]\n  (reduce \n\t(fn squish [flat bumpy]\n\t  (if (coll? bumpy)\n        (reduce squish flat bumpy)\n     \t(conj flat bumpy)))\n    [] coll))","user":"598e7998e4b02b9968b84d34"},{"code":"(fn f [seq] (mapcat #(if (sequential? %) (f %) (vector %)) seq))","problem":28,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":28,"code":"(fn [x]\n  (let [rr (fn r [acc x]\n              (if (coll? x)\n                (reduce r acc x)\n                (conj acc x)))] \n    (reduce rr [] x)))","user":"5a3e0e44e4b0447ef91cc5ad"},{"code":"(fn flat [x]\n  (cond\n    (not (coll? x)) (list x)\n    (empty? x) x    \n    :else (concat (flat (first x)) \n                  (flat  (rest x)))))","problem":28,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":28,"code":"(fn procisti [vysledek co] (if (empty? co) \n                                    vysledek\n                                    (let [akt (last co)]\n                                      (if (sequential? akt)\n                                          (procisti  (concat (procisti [] akt) vysledek) (butlast co))\n                                          (procisti  (into (vector akt) vysledek ) (butlast co))\n                                      )))) []","user":"5576e78de4b05c286339e075"},{"code":"(fn flat [s]\n           (reduce #(concat % (if (coll? %2) (flat %2) (list %2))) '() s))","problem":28,"user":"4f03f197535dcb61093f6b84"},{"problem":28,"code":"(fn f [coll]\n (if (empty? coll)\n  []\n  (let [x (first coll) xs (rest coll)]\n   (if (coll? x)\n    (concat (f x) (f xs))\n    (cons x (f xs))))))","user":"524a9556e4b05ef8e38e64b1"},{"problem":28,"code":"(fn f \n  ([x] \n   (reverse (f x [])))\n  ([x l]\n   (if (empty? x)\n     l\n     (if (coll? (first x))\n       (f (rest x) (f (first x) l))\n       (f (rest x) (cons (first x) l))))))","user":"55e87696e4b0121d4835fd93"},{"problem":28,"code":"#((fn flat [[f & r :as lst] res]\n    (if (empty? lst)\n      res\n      (if (sequential? f)\n        (concat res (flat f []) (flat r []))\n        (flat r (conj res f))))) % [])","user":"578fc072e4b0ebec4cfb759a"},{"code":"#(filter (complement sequential?) \n(rest (tree-seq sequential? seq %)))","problem":28,"user":"4e9fde3c535d7eef3080729b"},{"problem":28,"code":"(fn mkflat [xs]\n  (if (coll? xs)\n    (if (empty? xs)\n      []\n      (concat (mkflat (first xs)) (mkflat (rest xs))))\n    [xs]))","user":"552d9b31e4b076ab5578f7eb"},{"problem":28,"code":"(fn flat [coll]\n  (loop [remaining-coll coll result []]\n    (if (empty? remaining-coll)\n      result\n      (if (coll? (first remaining-coll))\n        (recur (drop 1 remaining-coll) (concat result (flat (first remaining-coll))))\n        (recur (drop 1 remaining-coll) (concat result [(first remaining-coll)]))))))","user":"5dc9c4f2e4b02f9375f4e1f0"},{"problem":28,"code":"(fn flat [coll] (if (sequential? coll) (mapcat flat coll) [coll]))","user":"5426200ae4b01498b1a71b16"},{"problem":28,"code":"#((fn [r s] (if (empty? s) r (if (sequential? (first s)) (recur r (concat (first s) (rest s))) (recur (concat r [(first s)]) (rest s))))) '() %)","user":"5abe2fc2e4b073f17744271e"},{"problem":28,"code":"(fn flattn [s]\n  (let [x (first s)]\n    (if (seq s)\n      (if (sequential? x)\n        (flattn (concat x (rest s)))\n        (concat (list x) (flattn (rest s))))\n      s)))","user":"509ecefde4b08df8156e9e35"},{"problem":28,"code":"(fn my-flatten [xs]\n  (if (empty? xs)\n    xs\n    (if (sequential? (first xs))\n      (concat (my-flatten (first xs)) (my-flatten (rest xs)))\n      (conj (my-flatten (rest xs))(first xs) ))))","user":"59afe4bae4b0e1f4e384c8c0"},{"problem":28,"code":"#((fn -flatten [flatten-this]\n  (reduce (fn [acc cv]\n            (if (not (coll? cv))\n              (concat acc (list cv))\n              (concat acc (-flatten cv))))\n          [] flatten-this)) %)","user":"5f5a57dee4b0a0bc16850aa5"},{"problem":28,"code":"(fn flat [c]\n  (let [[x & xs] c]\n    (if (empty? c)\n      '()\n      (if (coll? x)\n        (concat (flat x) (flat xs))\n        (cons x (flat xs))))))","user":"58ddac2ce4b0a4d5acaab6d6"},{"problem":28,"code":"(fn foo\n   [x]\n   ;(println x)\n   (loop [col x rt []]\n     (println col rt)\n     (if(empty? col)\n       (sort rt)\n       (recur (rest col) (if(sequential? (first col)) (concat (foo (first col)) rt) (conj rt (first col))) )\n       )\n     )\n   )","user":"5d270111e4b092dab7f59c62"},{"problem":28,"code":"(fn f [[a & b]] (let [flat-a (if (or (seq? a) (vector? a)) (f (seq a)) `(~a))\n                    flat-b (if b (f b) b)]\n                (println flat-a flat-b)\n                (concat flat-a flat-b)))","user":"5bc935bde4b07a9b28b100d8"},{"problem":28,"code":"(fn myflatten \n  ([s] (myflatten s '())) \n  ([s result]\n    (do (print s result (rest s) (first s))\n      (if (seq s)\n        (do (print \"seq\")\n          (if (counted? (first s))\n             (concat (myflatten (first s)) (myflatten (rest s)))\n             (do (print \"conj\")\n                 (conj (myflatten (rest s)) (first s)))))\n          result))))","user":"54165291e4b01498b1a719fb"},{"problem":28,"code":"#(filter (comp not coll?)\n         (rest (tree-seq sequential? seq %)))","user":"5931e498e4b072a2710fd024"},{"problem":28,"code":"(fn r_flat [x] (sort(reduce #(if (counted? %2) (concat %1 (r_flat %2)) (conj %1 %2)    ) [] x)))","user":"57752a2de4b0979f89651613"},{"code":"((fn [result]\n     (fn this [s]\n\t       (loop [s s result result]\n\t\t  (if (empty? s)\n\t\t      result\n\t\t      (if-not (coll? (first s)) \n\t\t\t      (recur (rest s) (conj result (first s)))\n\t\t\t      (recur (rest s) (into result (this (first s))))))))) [])","problem":28,"user":"4f066916535dcb61093f6c10"},{"code":"(fn sub [s]\r\n  (if (sequential? s)\r\n    (apply concat (map sub s))\r\n    [s]))","problem":28,"user":"502873a8e4b01614d1633ff8"},{"code":"(fn flat [s]\n  (loop [i s\n         o '()]\n    (if (empty? i)\n      o\n      (if (coll? (first i))\n        (recur (rest i) (concat o (flat (first i))))\n        (recur (rest i) (concat o (list (first i))))))))","problem":28,"user":"51f28a64e4b0210f90e7454e"},{"code":"(fn my-flatten [[x & xs]]\n      (if (nil? x) \n          []\n          (if (or (vector? x) (list? x))\n              (concat (my-flatten x) (my-flatten xs))\n              (concat [x] (my-flatten xs)))))","problem":28,"user":"5186134ce4b0da5a5be3bac7"},{"problem":28,"code":"(fn [coll]\n  (->> coll\n       (tree-seq sequential? seq)\n       (remove sequential?)))","user":"575cbe44e4b02ea114799374"},{"problem":28,"code":"(fn [coll]\n    (loop [new_coll coll]\n        (if (not ((fn [c](some true? (map #(coll? %) c))) new_coll))\n            new_coll\n            (recur ((fn [c] \n                        (loop [new_collection []\n                            index 0]\n                        (if (= index (count c))\n                            new_collection\n                            (if (coll? (nth c index))\n                                (recur (concat new_collection (nth c index)) (inc index))\n                                (recur (concat new_collection (vector (nth c index))) (inc index))\n                            )))) new_coll)))))","user":"5885eb2de4b0f1effa3b76c6"},{"problem":28,"code":"(fn my-flatten [coll]\n   (seq (reduce\n          (fn [c x]\n            (if (coll? x)\n              (apply conj c (my-flatten x))\n              (conj c x)))\n          [] coll)))","user":"5de82145e4b0986d99407f7b"},{"problem":28,"code":"(fn f [q]\n  (reduce \n  \t(fn [s e]\n   \t\t (concat s (if (coll? e)\n              (f e)\n              (list e)) ))\n  () q))","user":"59fedc26e4b01bb0ae8afd17"},{"problem":28,"code":"(fn lala [sek]\n  (let [f (first sek)\n        n (next  sek)]\n    (concat (if (sequential? f)\n              (lala f)\n              [f])\n            (if (sequential? n)\n              (lala n)\n              n))))","user":"56785234e4b05957ce8c6177"},{"problem":28,"code":"#(let [f (fn [f x]\n           (if (coll? x)\n             (mapcat (partial f f) x)\n             [x]))]\n   (f f %))","user":"5fbb010ae4b03f550f448233"},{"problem":28,"code":"(fn fl4t\n  [[primary & others]]\n  (if (coll? primary)\n    (if (empty? others)\n      (fl4t primary)\n      (into (fl4t primary) (fl4t others)))\n    (if (empty? others)\n      [primary]\n      (into [primary] (fl4t others)))))","user":"561fc0d0e4b064ca9f4b16d2"},{"problem":28,"code":"(fn [coll]\n  (loop [[f & r] coll\n         res []]\n    (cond\n      (sequential? f) (recur (into [] (concat f r)) res)\n      (nil? f) res\n      :else (recur r (conj res f)))))","user":"567abc97e4b05957ce8c619d"},{"problem":28,"code":"(fn f [s] (if (coll? s) (mapcat f s) (list s)))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn f [l]  (filter (complement sequential?) (tree-seq sequential? (fn[l] l) l)))","problem":28,"user":"51cbc435e4b08d8387cbeddd"},{"problem":28,"code":"(fn flat [s] \n  (if (empty? s) \n    s\n    (let [f (first s) rf (flat (rest s))]\n    (if (coll? f)\n      (concat (flat f) rf)\n      (cons (first s) rf)))))","user":"5413adfee4b01498b1a719e4"},{"problem":28,"code":"(fn my-flatten [coll]\n  (loop [coll coll res []]\n    (if (empty? coll)\n      res\n      (let [head (first coll)]\n        (if (sequential? head)\n          (recur (rest coll) (into res (my-flatten head)))\n          (recur (rest coll) (conj res head)))))))","user":"5c04464ee4b0bdcf453d167d"},{"problem":28,"code":"(fn flatten-seq [s]\n    (filter (complement sequential?) (tree-seq sequential? seq s)))","user":"5b9acb23e4b0c0b3ffbd4aef"},{"problem":28,"code":"(fn flatten* [xs]\n  (loop [[x & r :as xs] xs\n         result []]\n    (if (seq xs)\n      (if (sequential? x)\n        (let [new-xs (concat x r) \n              new-result result]\n          (recur new-xs new-result))\n        (recur r (conj result x)))\n      result)))","user":"5b3ef412e4b02d533a91bc06"},{"problem":28,"code":"(fn pflatten [coll]\n  (cond\n   (not (or (seq? coll) (vector? coll))) (list coll)\n   (empty? coll) nil\n   (empty? (next coll)) (pflatten (first coll))\n   :else (concat (pflatten (first coll)) (pflatten (rest coll)))))","user":"5b975c6ee4b0c0b3ffbd4a91"},{"code":"#(let [s sequential?]\n  (filter (complement s) (tree-seq s seq %)))","problem":28,"user":"4e6a4541535d8ccf87e9feb8"},{"code":"(fn [coll]\r\n    (let [n-coll \r\n          (reduce \r\n            (fn [a b] \r\n              (if (sequential? b) \r\n                (into a b) \r\n                (conj a b))) \r\n            [] coll)]\r\n      (if (every? (complement sequential?) n-coll)\r\n        n-coll \r\n        (recur n-coll))))","problem":28,"user":"4dd61f98535d2dad7130b5c6"},{"problem":28,"code":"(fn f [[x & xs]]\n  (cond\n    (nil? x) nil\n    (coll? x) (concat (f x)  (f xs))\n    :else (concat [x] (f xs))))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (cond\n    (empty? s) (empty s)\n    (sequential? (first s)) (concat (my-flatten (first s)) (my-flatten (rest s)))\n    :else (conj (my-flatten (rest s)) (first s))))","user":"5599abc9e4b031d6649c9bb0"},{"problem":28,"code":"(fn [q] \n  (let [f* (fn f [acc x](if (coll? x) (reduce f acc (seq x)) (conj acc x)))]\n   (reduce f* [] q)))","user":"571edeeae4b0145328a7629b"},{"problem":28,"code":"reduce (fn flat [coll val] \n         (if (coll? val) \n           (reduce flat coll val) \n           (conj coll val))) []","user":"5eccc5c2e4b016b56eae058f"},{"code":"(fn flt [[x & xs]] (concat (if (sequential? x) (flt x) [x]) (when xs (flt xs))))","problem":28,"user":"514def61e4b019235f6c0591"},{"code":"(fn flat-seq [ls]\n  (if (empty? ls)\n    '()\n    (let [head (first ls), tail (rest ls)]\n      (cond\n       (coll? head) (concat (flat-seq head) (flat-seq tail))\n       :else (cons head (flat-seq tail))))))","problem":28,"user":"529e2383e4b04e0c58e87b8b"},{"problem":28,"code":"#(loop [[x & tail] % res []]\n   (cond (nil? x) res\n         (coll? x) (recur  [(first x) (concat (rest x) tail)] res)\n         :else (recur tail (conj res x))))","user":"57615a22e4b0994c1922fb88"},{"problem":28,"code":"(fn [arr]\n (filter (complement sequential?)\n          (rest (tree-seq sequential? seq arr))))","user":"59595f85e4b066ee0a44afa1"},{"code":"(fn my-flatten [x]\n (reduce\n #(if (sequential? %2)\n    (vec (concat %1 (my-flatten %2)))\n    (conj %1 %2))\n [] x))","problem":28,"user":"50df6dd0e4b061dbdced7225"},{"code":"(fn myflatten [x]\r\n  (if (coll? x)\r\n    (apply concat (map myflatten (seq x)))\r\n    (list x)))","problem":28,"user":"4e14108c535d04ed9115e7dd"},{"problem":28,"code":"(fn flaten [s] (mapcat (fn [x] (if (coll? x) (flaten x) (list x))) s))","user":"54c15722e4b0ed20f4ff6f22"},{"code":"(fn f\n  [c]\n  (reduce\n   (fn [c x]\n       (if (sequential? x)\n           (concat c (f x))\n         (concat c (list x))))\n   ()\n   c))","problem":28,"user":"5357b241e4b04ce2eb3ed282"},{"problem":28,"code":"(fn f [nstd] (\nreduce #(if (coll? %2) (into [] (concat %1 (f %2))) (conj %1 %2)) [] nstd\n))","user":"55ed962ae4b0121d4835fddd"},{"problem":28,"code":"(fn [seq]\n  (loop [res [] seq-iter seq]\n    (cond (empty? seq-iter) res\n          (sequential? (first seq-iter)) (recur res (concat (first seq-iter) (rest seq-iter)))\n          :else (recur (conj res (first seq-iter)) (rest seq-iter)))))","user":"5965a773e4b069c0a1a1978a"},{"code":"(fn flat-seq [acc my-seq] \n (let [head (first my-seq) tail (rest my-seq)]\n   (cond\n     (empty? my-seq) acc\n\t (coll? head) (let [elem (flat-seq '() head) new-acc (concat acc elem)] (flat-seq new-acc tail))\n\t :else  (flat-seq (concat acc (list head)) tail)))) '()","problem":28,"user":"51eec1a6e4b0871fa145d98d"},{"code":"(fn f [[head & tail]]\n    (concat (if-not (coll? head)\n              (list head)\n              (f head))\n      (if tail (f tail))))","problem":28,"user":"4f0f36a7535d0136e6c22336"},{"problem":28,"code":"(fn f\n  [s]\n  (reduce #(let [x (if (coll? %2) (f %2) [%2])] (concat %1 x)) '() s))\n\n;;(fn\n;;  [s]\n;;  (loop [f      (first s)\n;;         r      (rest s)\n;;         result '()]\n;;    (cond\n;;      (coll? f) (recur (first f) (concat (rest f) r) result)\n;;      f        (recur (first r) (rest r) (concat result [f]))\n;;      :else result)))","user":"51319a53e4b06942423563c8"},{"problem":28,"code":"#_(fn [coll] \n  (map #(if (re-seq #\"\\d|^:\" %) (read-string %) %) \n       (map first (re-seq #\"(:?[a-z]|\\d)\" (str coll)))))\n(fn my-flat [x] (if (coll? x) ( mapcat my-flat x) [x]))","user":"562f2985e4b0ab312c17ebc5"},{"code":"#(filter (complement coll?) \n      (rest (tree-seq sequential? identity %)))","problem":28,"user":"4fe15ffee4b0dd6cd5ce3634"},{"problem":28,"code":";cheating\n(fn f [x] (if (coll? x) (mapcat f x) [x]))","user":"4eb171d7535d7eef30807340"},{"problem":28,"code":"(fn f [s] (mapcat #(if (or (seq? %) (vector? %)) (f %) (list %)) s))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn f\n  ([s] (f s []))\n  ([s elements]\n    (cond\n      (not (coll? s)) s\n      (empty? s) elements\n      (not (coll? (first s)))\n        (let [new-elements (conj elements (first s))]\n          (f (rest s) new-elements)\n        )\n      :else\n        (let [new-elements (into elements (f (first s)))]\n          (f (rest s) new-elements)\n        )\n    )\n  )\n)","problem":28,"user":"51f09f3de4b0274c496158d7"},{"problem":28,"code":"(fn [s]\n  (loop [auxCol s result [], interCol []]\n    (let [fInterCol (first interCol)]\n\n      (if (nil? fInterCol)\n        (do\n          (let [element (first auxCol)]\n            (if (nil? element)\n              result\n              (do\n                (if (coll? element)\n                  (recur (rest auxCol) result  element)\n                  (do\n                    (let [newResult (conj result element)\n                          newAuxCol (rest auxCol)]\n                      (recur newAuxCol newResult interCol))))))))\n        (do\n          (if (coll? fInterCol)\n            (recur (rest auxCol) result fInterCol)\n            (do\n              (let [newResult (conj result fInterCol)      newInterCol (rest interCol)]\n                (recur auxCol newResult newInterCol)))))))))","user":"5be589f9e4b0ed4b8aab4d13"},{"problem":28,"code":"(fn my-flatten [xs]\n  (reduce\n  \t(fn [ys x]\n      (concat ys\n      \t(if (coll? x)\n          (my-flatten x)\n          (list x)\n        )\n      )\n    )\n   \t'()\n   \txs\n  )\n)","user":"5aac468ae4b073f17744256b"},{"problem":28,"code":"(fn [l]\n  (mapcat (fn flat[x]\n             (if (coll? x)\n    (mapcat flat x)\n    [x]))\n          l))","user":"59636cc2e4b066ee0a44b0c7"},{"code":"(fn [col]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq col))))","problem":28,"user":"4e1248b1535d04ed9115e7cf"},{"code":"(fn flat[n] \n  (let [[x & xs] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","problem":28,"user":"52446511e4b0d8acf9ed6a9a"},{"problem":28,"code":"(fn my-flat [x]\n  \n  (if-not (coll? x)\n    \n    [x]\n    \n    (apply concat (map my-flat x))\n  )\n)","user":"5b3189e5e4b025bcb146f308"},{"code":"(fn [s]\n  (filter (complement sequential?) (tree-seq sequential? seq s)))","problem":28,"user":"4f1473eb535d64f603146439"},{"problem":28,"code":"(fn my-flatten [xs]\n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq xs))))","user":"5508a292e4b06e50f9beb10f"},{"problem":28,"code":"(fn foo [x] (mapcat #(if (coll? %) (foo %) (list %)) x))","user":"513e8141e4b02b2a3d8235c1"},{"code":"#(% (fn f [i] (if (coll? i) (% f i) [i])) %2) mapcat","problem":28,"user":"4e49badd535dc968683fc4c9"},{"problem":28,"code":"(fn [t] (letfn [(f [xs] (if (coll? xs) (mapcat f xs) (list xs)))](f t)))","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn [s] \r\n  (filter #(not (sequential? %)) \r\n          (tree-seq sequential? seq s)))","problem":28,"user":"4df3df8a535d08e6dec9fe2d"},{"code":"#(letfn [(flat' [a a']\n  (if (sequential? a')\n      (reduce flat' a (seq a'))\n      (conj a a')  \n  ))]\n  (sort (flat' [] %)))","problem":28,"user":"531c0619e4b08068f379ed98"},{"code":"(fn [a] (filter (complement sequential?) \r\n(tree-seq sequential? seq a)))","problem":28,"user":"4daa374930acd6ed13482a68"},{"code":"(fn flat [xs]\n  (if (coll? xs)\n    (mapcat #(flat %) xs)\n    (list xs)))","problem":28,"user":"4fcd72e7e4b065de69964caa"},{"code":"(fn flattenr [xs]\n  (let [flattened (empty xs)]\n  (reduce (fn [flt,v]\n    (if (sequential? v)\n        (concat flt (flattenr v))\n        (concat flt (conj (empty xs) v))\n    ))\n    flattened xs)))","problem":28,"user":"50ba5084e4b03e68e4411c7c"},{"problem":28,"code":"(fn foobar [& xs]\n   (reduce concat (map\n                   (fn [y] \n                     (if (sequential? y) \n                       (apply foobar y)\n                       (list y)))\n                   xs)))","user":"53b14289e4b047364c04448b"},{"problem":28,"code":"(fn my-flatten [col]\n  (loop [ret []\n         iter col]\n    (if-let [f (first iter)]\n      (if (coll? f)\n        (recur (concat ret (my-flatten f))\n               (rest iter))\n        (recur (concat ret [f])\n               (rest iter)))\n       ret)))","user":"5d13af73e4b0902706380dbe"},{"problem":28,"code":"(fn flatn\n    [listToFlatten]\n    (loop [list listToFlatten\n           retlist '()]\n      (if (empty? list)\n        (reverse retlist)\n        (let [[first & rest] list]\n          (if (or (vector? first) (list? first))\n            (recur rest (concat (reverse (flatn first)) retlist))\n            (recur rest (cons first retlist)))\n          ))))","user":"58a216e8e4b02bd94d917ed1"},{"code":"(fn f [s]\n  (reduce (fn [r i] \n             (if (sequential? i)\n               (into r (f i))\n               (conj r i))) [] s))","problem":28,"user":"517ecab1e4b09104ecebe7e8"},{"code":"(fn [x] (filter \n  (complement sequential?)\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4eb9c82d535dfed6da9c6d5c"},{"problem":28,"code":"(fn my-flat [coll]\n  (cond\n    (not (coll? coll))\n     (cons coll '())\n    (empty? coll)\n     coll\n    :else\n     (concat (my-flat (first coll)) (my-flat (rest coll)))))","user":"5c24671be4b07e362c2305a1"},{"problem":28,"code":"(fn f [coll]\n  (cond\n    (and (empty? coll))\n    coll\n\n    (coll? (first coll))\n    (concat (f (first coll))\n            (f (rest coll)))\n\n    :else\n    (concat (list (first coll))\n            (f (rest coll)))))","user":"60065677e4b074f607df6651"},{"code":"(fn fl [[f & r]]\n\t(cond (nil? f) '()\n          (sequential? f) (concat (fl f) (fl r))\n\t\t  :else (concat (list f) (fl r))))","problem":28,"user":"53300924e4b019098a6f8b55"},{"code":"(fn custom-flatten [coll]\n  (reduce (fn [coll elem]\n            (if (coll? elem)\n              (into coll (custom-flatten elem))\n              (conj coll elem)))\n          [] coll))","problem":28,"user":"5264b4a9e4b03e8d9a4a70e0"},{"code":"(fn [x] (filter #(not (sequential? %))\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f36b4a4e4b0e243712b1ecc"},{"problem":28,"code":"(fn [s] \n   (loop\n    [sq s result []]\n    (if\n      (empty? sq)\n      result\n      (recur\n        (if\n          (sequential? (first sq))\n          (concat (first sq) (rest sq))\n          (rest sq)\n        )\n        (if\n          (sequential? (first sq))\n          result\n          (concat result [(first sq)])\n        )\n\n      )\n    )\n  )\n  \n  )","user":"5f58db95e4b0a0bc16850a9a"},{"problem":28,"code":"(fn [seq']\n  (loop [rest-seq seq'\n         result []]\n    (let [[head & tail] rest-seq]\n      (cond\n       (nil? head) result\n       (sequential? head) (recur (concat \n                                  (->> head (reduce #(if (sequential? %2) \n                                                       (concat %1 %2)\n                                                       (conj %1 %2)) []))\n                                  tail)\n                                 result)\n       :else (recur tail (conj result head))))))","user":"567bf820e4b05957ce8c61ad"},{"problem":28,"code":"(fn flat[n]\n  (let[[x & xs] n]\n  (cond \n   (empty? n) []\n   (coll? x) (concat (flat x) (flat xs))\n    :else (cons x (flat xs)))))","user":"560331dee4b04bb52996e1b5"},{"code":"(fn f [s]\n  (reduce #(if (coll? %2)\n             (concat (f %2) %1)\n             (cons %2 %1))\n          '() (reverse s)))","problem":28,"user":"51085be5e4b00aa5c85a1024"},{"problem":28,"code":"#((fn fltn2 [cs out]\n (loop [cs cs out out]\n  (cond (not cs) out\n   (not (coll? cs))\n    (conj out cs)\n   (coll? (first cs))\n    (recur (next cs) (fltn2 (first cs) out))\n   :else\n   (recur (next cs) (conj out (first cs)))))) % [])","user":"57275755e4b0c5bde472c13b"},{"problem":28,"code":"(fn flattener [coll]\n  (when-let [s  (seq coll)]\n    (if (coll? (first s))\n      (concat (flattener (first s)) (flattener (rest s)))\n      (cons (first s) (flattener (rest s))))))","user":"514992d2e4b0b64cbeae1848"},{"problem":28,"code":"(fn [s]\n  (letfn [(flat [s] \n            (mapcat \n              (fn [el]\n                (if (sequential? el) (flat el) [el])) s))]\n    (flat s)))","user":"5f431d32e4b0955706451fb5"},{"problem":28,"code":"(fn flt\n  [col]\n  (let [l (first col) r (next col)]\n    (concat \n     (if (sequential? l)\n       (flt l)\n       [l]\n       )\n     (when (sequential? r)\n       (flt r)\n       )\n     )\n    )\n)","user":"5581a6dae4b05c286339e0fe"},{"code":"(fn  [x]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"509b152be4b0412cdea6eb1e"},{"problem":28,"code":"(fn __ [x]\n  (reduce (fn [a v]\n            (if (coll? v)\n              (vec (concat a (__ v)))\n              (conj a v))) [] x))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn [a] (filter (complement sequential?) (rest (tree-seq sequential? seq a))))","problem":28,"user":"4dad76588e77d6ed63f12a44"},{"code":"(let\n  [flat (fn [xs x final flat-fn]\n    (if (empty? xs)\n      final\n      (if (or (vector? x) (list? x))\n        (recur (rest xs) (first (rest xs)) (concat final (flat-fn x (first x) [] flat-fn)) flat-fn)\n        (recur (rest xs) (first (rest xs)) (concat final  [x]) flat-fn))))]\n  \n  (fn [xs] (flat xs (first xs) [] flat)))","problem":28,"user":"4feaa579e4b0140c20fb9c0b"},{"code":"(fn my-flatten [coll]\n  \"It's clojure.core/flatten without clojure.core/flatten.\"\n  (loop [[head & tail] coll result []]\n    (println head tail result)\n    (if (nil? head)\n      result\n      (let [next-result\n            (concat result (if (coll? head) (my-flatten head) [head]))]\n        (recur tail next-result)))))","problem":28,"user":"527aba40e4b03e8d9a4a7565"},{"code":"#(filter (complement sequential?)\n             (rest (tree-seq sequential? seq %)))","problem":28,"user":"4ed90014535d10e5ff6f52fe"},{"code":"(fn fl [l]\n  (cond (empty? l) '()\n        (or (seq? (first l))\n            (vector? (first l)))\n            (concat (fl (first l)) (fl (rest l)))\n         :else (concat (list (first l)) (fl (rest l)))))","problem":28,"user":"4e2d84bf535deb9a81d77f09"},{"code":"(fn [coll]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq coll))))","problem":28,"user":"4e5d0e96535d8a8b8723a2c8"},{"code":"(fn my-flatten [s]\n  (if (sequential? s)\n    (if (seq s)\n      (concat (my-flatten (first s))\n              (my-flatten (rest s)))\n      [])\n    [s]))","problem":28,"user":"4eecc9ad535d93acb0a668b4"},{"problem":28,"code":"(fn flat [coll]\n  (if (every? (complement sequential?) coll)\n    coll\n    (let [foo #(if (sequential? %) % (list %))]\n      (flat (apply concat (map foo coll))))))","user":"5493ccbbe4b0b312c081ff50"},{"problem":28,"code":"(fn ! [s]\n  (if (coll? s)\n   (mapcat ! s)\n    [s]))","user":"5745b884e4b009280f9f2b53"},{"code":"(fn [items]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq items))))","problem":28,"user":"50052fd0e4b0678c553fc45d"},{"code":"(fn f2 [x] \n  (if (coll? x) \n    (mapcat f2 x) \n    [x]))","problem":28,"user":"4dd59d8b535dae65d5c462eb"},{"problem":28,"code":"(fn flat [coll]\n  \"Implementation equivalent to flatten.\"\n  (if (coll? coll)\n    (let [x (first coll), xs (next coll)]\n      (if (coll? x)\n        (concat (flat (seq x)) (flat xs))\n        (cons x (flat xs))))\n    coll))","user":"5488872ee4b0e286459a11d3"},{"code":"(fn fl [s]\n  (if (not (coll? s))\n    [s]\n    (reduce concat (map fl s))\n  )\n)","problem":28,"user":"512b9e59e4b04d059cf1fd17"},{"problem":28,"code":"#(reduce (fn rec[x y] (\n    cond\n      (nil? y) x\n      (sequential? y) (rec (concat x ( rec '() ( first y) )) (next y) )\n      :else (concat x (list y))\n    ))  '() %)","user":"575bd5f9e4b02ea114799365"},{"problem":28,"code":"#(filter (complement coll?)\n         (tree-seq coll? seq %))","user":"5a2b7727e4b09cafd31c7f49"},{"problem":28,"code":"(fn flat [lst]\n      (reduce\n        (fn [acc x]\n          (concat\n            acc\n            (if (sequential? x)\n              (flat x)\n              (list x))))\n        ()\n        lst))","user":"54800885e4b0c51c1f4d7323"},{"problem":28,"code":"(fn [x]\n  (seq\n    (reduce\n      (fn flat [a b]\n        (if-not (coll? b)\n          (conj a b)\n          (reduce flat a b)\n        )\n      ) [] x\n    )\n  )\n)","user":"560d2b53e4b05f002753df37"},{"code":"(fn [ls]\n  (letfn [(flat [coll]\n            (lazy-seq\n             (when-let [c (seq coll)]\n\t             (let [x (first c)]\n\t                (if (sequential? x)\n\t                  (concat (flat x) (flat (rest c)))\n\t                  (cons x (flat (rest c))))))))]\n\t(if (sequential? ls) (flat ls) ls)))","problem":28,"user":"50af3393e4b0a40c9cfb08d7"},{"code":"(fn \n  [s]\n  (letfn [(f [rst e]\n            \t(if (or (seq? e) (vector? e))\n              \t\t(reduce f rst e)\n                  \t(conj rst e)))]\n  \t(reduce f [] s)))","problem":28,"user":"516d2a46e4b06f078fab252f"},{"problem":28,"code":"(fn flatten1 [[f & r]]\n  (cond \n     (nil? r)(if (coll? f) (flatten1 f)(list f)) \n     (coll? f) (concat  (flatten1 f) (flatten1 r))\n     :else(concat  (list f) (flatten1 r) )))","user":"54100c73e4b01498b1a7199e"},{"problem":28,"code":"(fn flat [sequ] (if (sequential? sequ) (let [[content & other] sequ] \n                                         (if (sequential? content) \n                                           (if (sequential? other) (flat (concat content other)) (into (flat content) other)) \n                                           (if (sequential? other) (cons content (flat other)) (if other (list content, other) (list content))))) \n                                           sequ))","user":"577412c6e4b0979f896515f6"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (if (empty? lst)\n    lst\n    (if (list? (first lst))\n      (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      (if (vector? (first lst))\n        (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n        (cons (first lst) (my-flatten (rest lst)))))))","user":"59e0111ae4b08badc2a0c4e4"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (if (coll? x)\n    (apply concat (map my-flatten x))\n    (list x)))","user":"5893c64ce4b00487982d524b"},{"problem":28,"code":"(fn flat [[i & r]]            \n      (concat (if (coll? i)\n            (flat i)\n            [i]\n          ) (if (seq r) (flat r))\n       ))","user":"5c272f82e4b07e362c2305cb"},{"problem":28,"code":"#(reduce (fn myfunc[x y] (if (coll? y) (reduce myfunc x y) (concat x (list y)))) [] %)","user":"571172ece4b09c608db70446"},{"code":"#(reverse((fn[x, acc]( if (empty? x) acc (if (coll? (first x))\n                                   (recur (concat (first x) (rest x)) acc)\n                                   (recur (rest x) (conj acc (first x))))))\n  % '()))","problem":28,"user":"52077e37e4b03bd50ef5466c"},{"problem":28,"code":"(fn my-flatten [l]\n  (if (empty? l)\n    nil\n    (if (or\n          (vector? (first l))\n          (seq? (first l))\n          )\n      (concat (my-flatten (first l)) (my-flatten (rest l)))\n        (cons (first l) (my-flatten (rest l)))\n\n        )\n      ))","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn [l] (filter #(not (coll? %)) (tree-seq coll? seq l)))","problem":28,"user":"4db883e1535d1e037afb2198"},{"problem":28,"code":"(fn flat [s] \n  (let [f (first s)\n        r (rest s)\n        atom? (complement sequential?)]\n    (cond (empty? s) nil\n          (atom? f) (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"5bb919e1e4b0a20761a235ca"},{"code":"(fn recflat [x]\n  (if (coll? x)\n    (mapcat recflat x)\n    (list x)))","problem":28,"user":"4ea7999e535d7eef308072ee"},{"problem":28,"code":"#(reverse (reduce (fn myFlatten [coll item]\n                  (if (coll? item) (reduce myFlatten coll item)\n                      (conj coll item)))\n                '() %))","user":"57f8ba80e4b0d3187e90092f"},{"problem":28,"code":"(fn flt\n  [l]\n  (let [head (first l)\n        tail (rest l)]\n    (cond\n     (empty? l) []\n     ((complement sequential?) head) (cons head (flt tail))\n     :else (concat (flt head) (flt tail)))))","user":"52846deee4b0239c8a67adcf"},{"problem":28,"code":"(fn f\n  [x]\n  (if (coll? x)\n    (mapcat f x)\n    [x]))","user":"55bd87ede4b01b9910ae29fe"},{"problem":28,"code":"(fn flattener [x]\n    (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5f5f2eafe4b02876ed9fcff5"},{"code":"(new clojure.core$flatten)","problem":28,"user":"4e3b6bff535deb9a81d77f52"},{"problem":28,"code":"(fn flatt [l]\n  (if (empty? l)\n    []\n    (if (coll?  (first l)) \n      (concat (flatt (first l)) (flatt (rest l)))\n      (cons (first l) (flatt (rest l))))))","user":"57150a8ee4b07c98581c3acb"},{"problem":28,"code":"(fn [theseq]  (loop [theseq theseq]\n                            (if (not (some coll? theseq))\n                              (sort theseq)\n                              (recur (reduce #(if (coll? %2) (concat %1 %2) (conj %1 %2)) ()  theseq)))))","user":"554bc64ae4b0a04f79299598"},{"code":"(fn my-flatten\n  ([x]\n     (my-flatten [] x))\n  ([coll [x & xrest]]\n     (let [new-coll\n           (if (sequential? x)\n               (my-flatten coll x)\n               (conj coll x))]\n       (if (nil? xrest)\n         new-coll\n         (recur new-coll xrest)))))","problem":28,"user":"4fa27e18e4b0dcca54ed6d68"},{"code":"(fn [str]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq str)))","problem":28,"user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn my-flatten [a]\n  (if (coll? a)\n    (if (empty? a)\n      '()\n      (concat (my-flatten (first a)) (my-flatten (rest a))))\n    [a]))","problem":28,"user":"52561be5e4b0541d1855ba08"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (sequential? s)\n    (mapcat my-flatten s)\n    (list s)))","user":"57300c19e4b0cd1946bd0fa1"},{"problem":28,"code":"(fn [unflatten]\n  (letfn [\n          (equalize-seq [val-or-seq]\n            (if (sequential? val-or-seq)\n              val-or-seq\n              [val-or-seq]))\n\n          (flatten-1-layer [seq]\n            (mapcat equalize-seq seq))\n\n          (my-flatten [coll]\n            (if (some sequential? coll)\n              (recur (flatten-1-layer coll))\n              coll))]\n\n    (my-flatten unflatten)))","user":"5b60e88be4b0c6492753e70b"},{"problem":28,"code":"(fn [el] (filter (complement sequential?) (tree-seq sequential? identity el)))","user":"54a8fdcee4b09f271ff37ca9"},{"problem":28,"code":"#(filter (fn [x] (not (sequential? x))) (rest (tree-seq sequential? seq %)))","user":"54d5fbe9e4b0a52adc2e2014"},{"code":"(partial \n(fn [f c] \n(loop [x c] (if(= (count (filter coll? x)) 0) x (recur (f x))))\n  )\n (fn [s] (reduce (fn [a b] (if (coll? b) (concat a b) (concat a [b]))) [] s)))","problem":28,"user":"536f2faee4b0fc7073fd6e79"},{"code":"(fn fl [l]\r\n  (if (coll? l)\r\n    (if (empty? l)\r\n      l\r\n      (concat (fl (first l)) (fl (rest l))))\r\n    [l]))","problem":28,"user":"507437c2e4b054001656acd0"},{"problem":28,"code":"(fn flt [c]\n  (if (coll? c)\n    (mapcat flt c)\n    (list c)))","user":"56c23ca6e4b05cc29241ee7f"},{"code":"(fn fltn [xs]\n  (mapcat (fn [y] (if (sequential? y)\n                    (fltn y)\n                    (list y)))\n          xs))","problem":28,"user":"51670895e4b013fc800656c1"},{"problem":28,"code":"(fn f1[col](\n           if (coll? col) (mapcat f1  col) [col]\n           \n           ))","user":"5d6523ace4b0db5d338d15cd"},{"code":"(fn myflat[s1] (reduce #(if (coll? %2) (concat %1 (myflat %2)) (conj (into [] %1) %2)) []  s1))","problem":28,"user":"525de512e4b0cb4875a45d8a"},{"problem":28,"code":"#(\n   (fn fl [n r] (cond  (not (seq r)) n\n                       (coll? (first r)) (fl n (concat (first r) (rest r)))\n                       :else (fl (concat n (vector (first r))) (rest r))))\n   '() %)","user":"5b100648e4b0cc2b61a3be17"},{"problem":28,"code":"(fn my-rec [[hd & tl]]\n           (if hd\n             (if (sequential? hd)\n               (concat (my-rec hd) (my-rec tl))\n               (conj (my-rec tl) hd))\n             nil))","user":"58a47197e4b01a0c0b2328f9"},{"problem":28,"code":"(fn my-flatten [l]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq l))))","user":"563b236ce4b0bfe05bf1180b"},{"problem":28,"code":"(fn flat [incol] (if (coll? incol) \n                   (if (< 1 (count incol))\n                   (concat (flat (first incol)) (flat (rest incol)))\n                    (flat (first incol)))\n                      (list incol)))","user":"570d8418e4b0b0fb43fd06de"},{"code":"(fn my-flatten [s]\n  (if-not (sequential? s)\n    (list s)\n    (mapcat my-flatten s)\n  )\n)","problem":28,"user":"4fcad14ce4b0ee37620e1856"},{"problem":28,"code":"(fn flat [tree]\n  (if (sequential? tree)\n    (concat (flat (first tree)) (mapcat flat (next tree)))\n    [tree]))","user":"56441634e4b0018b46ad8c08"},{"code":"(fn myflatten\n  [l]\n   (if (coll? l)\n       (if (empty? l) \n           l\n           (concat (myflatten (first l)) (myflatten (rest l))))\n       (list l)))","problem":28,"user":"52664945e4b03e8d9a4a712f"},{"code":"(fn f [s]\n  (cond\n   (empty? s) nil\n   (coll? (first s)) (concat (f (first s)) (f (rest s)))\n   :else (cons (first s) (f (rest s)))))","problem":28,"user":"5092fe10e4b097f48cc3857e"},{"problem":28,"code":"(fn my-flat [coll] \n  (if (some coll? coll) \n    (if (coll? (first coll)) \n      (concat (my-flat (first coll)) (my-flat (rest coll))) \n      (cons (first coll) (my-flat (rest coll)))) \n    coll))","user":"5b421edce4b02d533a91bc2c"},{"problem":28,"code":"(fn myflatten [lst] (if (and (coll? lst) (not (empty? lst)))                                                                                              \n  (let [x (first lst) xs (rest lst)]\n    (if (coll? x) (concat (myflatten x) (myflatten xs)) (conj (myflatten xs) x)))))","user":"589c7c8ce4b00487982d5361"},{"code":"(fn f[c](if(coll? c)(mapcat f c)[c]))","problem":28,"user":"512f06c5e4b0762be4c7aad7"},{"code":"(fn myFlat [xs]\n    (let [x (first xs)]\n         (cond (empty? xs) ()\n               (= 1 (count xs)) (if (coll? x) (myFlat x) (list x))\n               (coll? x) (concat (myFlat x) (myFlat (next xs)))\n               :else (cons x (myFlat (next xs))))))","problem":28,"user":"52161db6e4b0bf4bffd29cb8"},{"code":"(fn flat [coll]\n                    (let [ a (first coll) b (next coll)]\n                    (concat \n                     (if (sequential? a)\n                       (flat a)\n                       [a])\n                     (when (sequential? b)\n                       (flat b)))))","problem":28,"user":"52ec4322e4b0705949c44451"},{"code":"(fn myFlatten [s]\n  (loop [source s, result []]\n    (if\n      (empty? source)\n      result\n      (let [curr (first source)]\n        (if\n          (coll? curr)\n          (recur (rest source) (apply conj result (myFlatten curr)))\n          (recur (rest source) (conj result curr)))))))","problem":28,"user":"4f5c0549e4b0030a34fb2b1a"},{"code":"(fn flazr [x]\n  (if (sequential? x)\n    (mapcat flazr x)\n    [x]))","problem":28,"user":"50e4a5a9e4b0cb9ec68fbca3"},{"problem":28,"code":"(fn f\n  [lst]\n  (reverse (reduce #(if (coll? %2)\n                      (apply conj %1 (f %2))\n                      (conj %1 %2))\n                   '()\n                   lst)))","user":"53f31dafe4b0742d9025b0f0"},{"problem":28,"code":"(fn [c]\n  (filter #(= (coll? %1) false)\n        (tree-seq coll? identity c)))","user":"57280b92e4b0c5bde472c14e"},{"code":"(fn flattn [s]\n  (if (or (seq? s) (vector? s))\n    (apply concat (map flattn s))\n    (list s)))","problem":28,"user":"4eca2cea535d6d7199dd3702"},{"problem":28,"code":"(fn my-flatten [[head & tail]]\n   (if (nil? head)\n     nil\n     (if (coll? head)\n       (concat (my-flatten head) (my-flatten tail))\n       (cons head (my-flatten tail)))))","user":"5f29837ee4b033932238a64f"},{"code":"(fn flattn [[h & t]]\n  (if (seq t)\n    (if (sequential? h)\n      (flattn (concat h t))\n      (concat (list h) (flattn t)))\n    (if (sequential? h)\n      (flattn h)\n      (list h))))","problem":28,"user":"504e72cee4b0f6ff3350c4b4"},{"problem":28,"code":"(fn flat\n  [ls]\n  (seq\n   (reduce\n    (fn sub-flat [v e]\n      (if (coll? e)\n        (reduce sub-flat v e)\n        (conj v e)))\n    [] ls)))","user":"55920e24e4b0604b3f94d587"},{"problem":28,"code":"(fn flat [coll] (concat (if (sequential? (first coll))\n                          (flat (first coll))\n                          [(first coll)])\n                        (when (sequential? (next coll))\n                          (flat (next coll)))))","user":"554d386ee4b0a04f792995b8"},{"problem":28,"code":"(fn flat [c]\n  (if (empty? c) \n    c \n    (if (sequential? (first c)) \n      (seq (concat \n            (flat (first c))\n            (flat (rest c))\n            ))\n      (cons (first c) (flat (rest c)))\n      )\n    )\n  )","user":"561e8b11e4b064ca9f4b16c0"},{"code":"(fn [v] (filter (complement coll?) (tree-seq coll? seq v)))","problem":28,"user":"50a2e3fbe4b029e8bace3629"},{"problem":28,"code":"(fn flat [coll]\n  (cond\n    (not (sequential? coll)) (list coll)\n    (empty? coll) '()\n    :else (concat (flat (first coll)) (flat (rest coll)))))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn x [l]\n  (reduce #(if (coll? %2)\n             (vec (concat %1 (x %2)))\n             (conj %1 %2))\n          [] l))","problem":28,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(comp reverse (partial #(cond (empty? %2) %1\n                              (coll? (first %2)) (recur %1 (concat (first %2) (rest %2)))\n                              :else (recur (conj %1 (first %2)) (rest %2)))\n                       ()))","problem":28,"user":"51105c7fe4b04c71fce993ef"},{"code":"(fn  [x]\n  (let [f (fn [x fu]\n            (mapcat #(if (coll? %) (fu % fu) [%]) x)\n            )]\n    (f x f)\n    ))","problem":28,"user":"51980f7ce4b068aa333628f7"},{"code":"(fn flat [c]\n   (reduce (fn [a b]\n             (if (coll? b)\n               (into a (flat b))\n               (conj a b))) [] c))","problem":28,"user":"4ef57a7f535dced4c769f246"},{"problem":28,"code":"#(reduce (fn flt [coll x] (if (coll? x) (reduce flt coll x) (conj coll x))) [] %)","user":"52a267c6e4b04e0c58e87bef"},{"code":"(fn f [coll]\n  (loop [r coll res[]] \n    (if (empty? r)\n      res\n      (if (coll? (first r))\n        (recur (rest r) (concat res (f (first r))))\n        (recur (rest r) (concat res (list (first r))))))))","problem":28,"user":"4dbd2aa3535d020aff1edf40"},{"problem":28,"code":"(fn [ls]\n  (loop [a (first ls) b (next ls) z []]\n    (cond\n      (nil? a) (if (nil? b) z (recur (first b) (next b) z))\n      (sequential? a) (recur (first a) (concat (next a) b) z)\n      (nil? b) (conj z a)\n      :else (recur (first b) (next b) (conj z a)))))","user":"5b552117e4b02d533a91bd2c"},{"code":"(fn flat [x]\n  (if (or (list? x) (vector? x))\n    (reduce (fn [l e] (concat l (flat e))) '() x)\n    (list x)))","problem":28,"user":"4e89ddf9535d3e98b8023284"},{"problem":28,"code":"(fn [x] (filter #((complement sequential?) %) (tree-seq sequential? seq x)))","user":"54180369e4b01498b1a71a13"},{"problem":28,"code":"(fn [x] (let\n             [red\n              (fn [r]\n                (reduce #(concat %1 (if (sequential? %2)\n                                      %2\n                                      (list %2))) [] r))]\n              (loop [s x]\n                (if (= s (red s))\n                  s\n                  (recur (red s))))))","user":"5fd92743e4b05ac5b16ea11f"},{"problem":28,"code":"(fn myflatten [c] (concat (if (or (seq? (first c))\n                                   (vector? (first c)))\n                             (myflatten (seq (first c)))\n                             (list (first c)))\n                           (if (or (seq? (next c)) (vector? (next c)))\n                             (myflatten (seq (next c)))\n                             (rest c))))","user":"589ec900e4b02bd94d917e65"},{"problem":28,"code":"(fn flat [a] \n\t(if (coll? a) \n\t\t (mapcat flat a)\n\t\t (list a)))","user":"5797d3d2e4b039eba2ecb106"},{"code":"(fn flattn [l] (if (empty? l)\n                   '()\n                   (if (sequential? (first l))\n                   \t   (concat (flattn (first l)) (flattn (rest l)))\n                       (conj (flattn (rest l)) (first l))\n                     )\n                 )\n  )","problem":28,"user":"51448607e4b0d29bc9e5e336"},{"code":"(fn [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"4df168bd535d08e6dec9fe1d"},{"problem":28,"code":"(fn flnt\n  [s]\n  (let [x (mapcat #(if (sequential? %) % [%]) s)]\n    (cond\n     (= x s) s\n     :else (flnt x)\n     )\n    )\n  )","user":"582cbf48e4b051871117bfa6"},{"code":"#(letfn [( myflatten [lst]\n  (if(empty? lst )\n    '()\n    (lazy-seq \n      (let [car (first lst)\n            cdr (rest lst)]\n       (if(coll? car)\n         ( concat  (myflatten car) (myflatten cdr) )\n         (cons car (myflatten cdr) ))))))]\n    (myflatten %))","problem":28,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn my-flatten [[x & rest]]\n  (concat\n   (if (coll? x)\n     (my-flatten x)\n     [x])\n   (when (coll? rest)\n     (my-flatten rest))))","problem":28,"user":"513e9aa0e4b02b2a3d8235c4"},{"code":"(fn flatr [s]\n  (reduce\n    (fn [a b]\n      (concat a (if (coll? b) (flatr b) (list b) ))\n    ) '() s\n  )\n)","problem":28,"user":"4fc4f040e4b081705acca35a"},{"problem":28,"code":"(fn flt [x]\n\n  (cond\n    (empty? x) '()\n    (coll? (first x)) (concat (flt (first x)) (flt (rest x)))\n    :else (cons (first x) (flt (rest x)))\n\n    )\n  )","user":"5f06d26ae4b0cf489e8d7f53"},{"code":"(fn tada [x]\r\n  (mapcat\r\n     (fn [a] (if (coll? a) (tada a) [a]))\r\n     x)\r\n)","problem":28,"user":"510a6bece4b06956752d35af"},{"code":"(fn flat [x]\n  (apply concat\n         (map #(if (sequential? %) (flat %) [%]) x)\n  )\n)","problem":28,"user":"5298bd13e4b02ebb4ef75063"},{"problem":28,"code":"(fn [nested] (letfn \n\t[(denest [elem] (cond\n\t\t(sequential? elem) (mapcat denest elem)\n\t\t:else [elem]\n\t))]\n\t(mapcat denest nested)))","user":"555f728de4b0a2eb076a39c8"},{"problem":28,"code":"(fn my-flatten [e]\n  (if (coll? e)\n    (mapcat my-flatten e)\n    [e]))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))\n  ))","problem":28,"user":"4e9dafe1535dbda64a6f6b89"},{"problem":28,"code":"(fn [l]\n  (loop [news '() tmpl (seq l)]\n    (if (empty? tmpl)\n      (reverse news)\n      (if (not (sequential? (first tmpl)))\n        (recur (conj news (first tmpl)) (rest tmpl))\n        (recur news (concat (first tmpl)(rest tmpl)))))))","user":"59368ccae4b02506e01a297a"},{"problem":28,"code":"(fn my-flatten [s]\n  (cond (empty? s) '()\n     \t(sequential? (first s)) (concat (my-flatten (first s)) \n                \t                    (my-flatten (rest s)))\n        :else (cons (first s) (my-flatten (rest s)))))","user":"568e1871e4b0dcc4269f40cc"},{"problem":28,"code":"(fn myflatten\n  [lst]\n  (reduce #(if (sequential? %2)\n             (concat %1 (myflatten %2))\n             (concat %1 (list %2)))\n          '() lst))","user":"5c03e927e4b0bdcf453d167b"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (coll? coll)\n    (reduce (fn [acc x] (concat acc (my-flatten x))) [] coll)\n    [coll]))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":28,"code":"#_(fn [coll]\n  (loop [acc coll]\n    (let [result (reduce (fn [acc item] (if (coll? item)\n                                          (into acc item)\n                                          (conj acc item)))\n                         []\n                         acc)]\n      (if (empty? (filter coll? result))\n        result\n        (recur result)))))\n\n(fn banana\n   [coll]\n   (reduce (fn [acc item]\n             (if (coll? item)\n               (into acc (banana item))\n               (conj acc item)))\n           []\n           coll))","user":"5d6f063de4b04d129b00f2d1"},{"code":"(fn flat [coll] \n    (reduce \n     (fn [acc n]\n       (if (coll? n)\n         (vec (concat acc (flat n)))\n         (conj acc n)))\n     [] \n     coll))","problem":28,"user":"4ea09fa4535d7eef308072aa"},{"problem":28,"code":"(fn new-flatten [xs]\n  (if (some coll? xs)\n    (new-flatten (mapcat (fn [x] (if-not (coll? x) (vector x) x)) xs))\n    xs))","user":"5ef18431e4b07c55ae4a0529"},{"code":"(fn [col]\n  (reverse\n    (loop [xs col\n           fs '()]\n      (if (= xs '())\n        fs\n        (if (coll? (first xs))\n          (recur (concat (first xs) (rest xs)) fs)\n          (recur (rest xs) (cons (first xs) fs)))))))","problem":28,"user":"4ef8d47c535dced4c769f261"},{"code":"(fn [coll]\n  (letfn [(rec [c result]\n               (if (empty? c)\n                 result\n                 (if (coll? (first c))\n                   (rec (rest c) (into [] (concat result (rec (first c) []))))\n                   (rec (rest c) (conj result (first c))))))]\n    (rec coll [])))","problem":28,"user":"5298c83de4b02ebb4ef75064"},{"problem":28,"code":"(fn foo [s]\n  (if-not (sequential? s)\n    (list s)\n    (if (empty? s)\n      `()\n      (let [x (first s)\n            xs (rest s)\n            s1 (foo x)\n            s2 (foo xs)]\n        (concat s1 s2)))))","user":"600ae927e4b074f607df6689"},{"problem":28,"code":"(fn myflatten [s]\n  (if(coll? s)(mapcat myflatten s)[s]));;map conctat wich concta elements in sequence","user":"606ff56ce4b069485764de21"},{"problem":28,"code":"(fn myf [coll]\n    (if (empty? coll) []      \n      (let [first (first coll)\n            r (rest coll)]\n        (if (sequential? first)\n          (concat (myf first) (myf r))\n          (cons first (myf r))\n          )\n        )\n      ))","user":"54cb3497e4b057c6fda3a272"},{"code":"(fn f [s]\n  (cond\n    (not (coll? s)) (list s)\n    (empty? s) '()\n    true (concat (f (first s)) (f (rest s)) )))","problem":28,"user":"4fff72b6e4b0678c553fc400"},{"code":"(fn flatme [x]\n  (if (empty? x)\n    '()\n    (let [elem (first x)]\n      (if (coll? elem)\n        (concat (flatme elem) (flatme (rest x)))\n        (cons elem (flatme (rest x)))))))","problem":28,"user":"4ee259a1535d10e5ff6f5366"},{"problem":28,"code":"(fn fl [ls] \n  (cond\n   \t(empty? ls) '()\n    (coll? (first ls)) (concat (fl (first ls)) (fl (rest ls)))\n    :else (cons (first ls) (fl (rest ls)))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":28,"code":"(fn splat [x]\n  (reduce\n   (fn [y z]\n     (if (coll? z)\n       (concat y (splat z))\n       (concat y [z])))\n   [] x))","user":"57458b82e4b009280f9f2b4e"},{"problem":28,"code":"(fn f[c] \n  (loop [c c r []] \n    (if (empty? c) \n      r \n      (if (sequential? (first c)) \n        (recur (rest c) (concat r (f (first c)))) \n        (recur (rest c) (concat r (cons (first c) nil) )) \n      )\n    )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":28,"code":"(fn _flatten [seq]\n   (reduce (fn [flat_seq, elem]\n             (if (coll? elem)\n               (concat flat_seq (_flatten elem))\n               (concat flat_seq [elem]))) () seq))","user":"60a7c55be4b00e9e6653c468"},{"problem":28,"code":"(fn copied-flatten [coll]\n  (let [f (first coll)\n        r (rest coll)]\n    (cond (empty? coll) nil\n          ((complement sequential?) f) (cons f (copied-flatten r))\n          :else\n          (concat (copied-flatten f) (copied-flatten r)))))","user":"57ff7d88e4b0a837a8b30c20"},{"code":"(fn fltn [s]\n  (cond\n    (empty? s) '()\n    (sequential? (first s))\n      (concat \n        (fltn (first s))\n        (fltn (rest s)))\n    :else (cons (first s)\n      (fltn (rest s)))))","problem":28,"user":"504e48ace4b0f6ff3350c498"},{"code":"(fn flatten1 [x]\n  (reduce \n   (fn [a b] \n     (if (coll? b) \n       (concat a (flatten1 b))\n       (concat a (list b))))\n   '() \n   x))","problem":28,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn [x]\n  (let [next-level\n        (reduce (fn [a b]\n                  (if (coll? b)\n                    (concat a b)\n                    (conj (vec a) b)))\n                [] x)]\n    (if (some coll? next-level)\n      (recur next-level)\n      next-level)))","problem":28,"user":"52a32b52e4b04e0c58e87bfc"},{"problem":28,"code":"#(loop [flat ()\n         [first & rest] %]\n    (cond\n      (nil? first) flat\n      (coll? first) (do (println first \" -\")\n                        (println rest \" --\")\n                      (recur flat (concat first rest)))\n      :else (recur (concat flat  (list first)) rest)))","user":"585dbe41e4b0f14aab7c879f"},{"problem":28,"code":"(fn f [c]\n  (if (empty? c) (list) \n    (let [x (first c)\n          xs (rest c)]\n      (if (coll? x)\n          (if (empty? x)\n            (list)\n            (concat (f x) (f xs))\n          )\n          (cons x (if (empty? xs) '() (f xs)))\n      ))))","user":"598a4ff7e4b02b9968b84cda"},{"code":"#(loop [s %]\n   (let [flatter (apply concat (map (fn [el] (if (or (vector? el) (seq? el)) el (list el))) s))]\n     (if (= flatter s) flatter (recur flatter))))","problem":28,"user":"5196568fe4b04c0af7ff3c1c"},{"problem":28,"code":"(fn flatiraj [sekv]\n  (cond\n    (empty? sekv) '()\n    (not (coll? (first sekv))) (conj (flatiraj (rest sekv)) (first sekv))\n    :else (concat (flatiraj (first sekv)) (flatiraj (rest sekv)))\n    )\n  )","user":"584d99c5e4b0b7285a6f4e42"},{"code":"(fn[x]\n  (filter (complement sequential?)\n         (tree-seq sequential? seq x)))","problem":28,"user":"51d10b1fe4b067c36548635e"},{"code":"(fn [flattened coll]\n  (cond\n    (empty? coll) (reverse flattened)\n    (coll? (first coll)) (recur flattened (concat (first coll) (rest coll)))\n    :else (recur (conj flattened (first coll)) (rest coll)))) '()","problem":28,"user":"50f924bbe4b0e7c80cb15a47"},{"problem":28,"code":"(fn fl [coll]\n  (when-let [s (seq coll)]\n    (if (coll? (first s))\n      (concat (fl (first s)) (fl (rest s)))\n      (cons (first s) (fl (rest s)))\n      )\n    )\n  )","user":"5245e320e4b09dbe66b56177"},{"problem":28,"code":"(fn f\n  ([s] (f s '()))\n  ([s1 s2]\n   (if (empty? s1)\n     s2\n     (f (rest s1)\n        (if (coll? (first s1))\n          (f (first s1) s2)\n          (concat s2 (list (first s1))))))))","user":"54cad59ee4b057c6fda3a26e"},{"code":"(fn foo [[h & t]]\n  (if h\n  (if (coll? h) (concat (foo h) (foo t))\n    (cons h (foo t)))))","problem":28,"user":"4fa9da14e4b081705acca1e7"},{"problem":28,"code":"#(loop [x % total []]\n  (if (= (count x) 0)\n    (if (every? (comp not coll?) total)\n      total\n      (recur total []))\n    (recur\n      (rest x)\n      (apply conj total\n        (if (coll? (first x))\n          (first x)\n          [(first x)])))))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":28,"code":"(fn make-flat [s] (if (coll? s) (mapcat make-flat s) [s]))","user":"57c44053e4b05aa3c4741ccb"},{"problem":28,"code":"(fn fl [s]\n  (cond\n    (not-empty s) (if (coll? (first s))\n                    (concat (fl (first s)) (fl (rest s)))\n                    (cons (first s) (fl (rest s))))  \n    :else '()))","user":"579c35fee4b05b1deef9ae04"},{"code":"#(loop [acc [], c %]\r\n  (cond\r\n    (empty? c) acc\r\n    (nil? (first c)) (recur acc (rest c))\r\n    (coll? (first c)) (recur acc \r\n                             (list* (ffirst c) (next (first c)) (rest c)))\r\n    :else (recur (conj acc (first c)) (rest c))))","problem":28,"user":"4e6a2f93535d8ccf87e9feaa"},{"problem":28,"code":"(fn flt [s] (if (or (seq? s) (vector? s)) (if (empty? s) '() (concat (flt (first s)) (flt (rest s)))) (list s)))","user":"55670a05e4b0c656e3ff1838"},{"code":"(fn flat [x]\n  (reduce (fn [accum i]\n            (concat accum (if (coll? i)\n                            (flat i)\n                            [i])))\n    []\n    x))","problem":28,"user":"5287f66be4b0239c8a67ae45"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce (fn [acc item]\n    (if (sequential? item)\n      (concat acc (my-flatten item))\n      (concat acc [item])\n    )\n  ) [] coll)\n)","user":"5a8e9fb5e4b05369db4d2529"},{"problem":28,"code":"#(read-string (str \"(\" (clojure.string/replace (str %) #\"[\\(\\)\\[\\]]\" \"\") \")\"))","user":"57de5f0ee4b0bd073c202450"},{"code":"(fn [lst] (filter (complement sequential?)\n          \t(rest (tree-seq sequential? seq lst))))","problem":28,"user":"52fe3a9de4b047fd55837039"},{"problem":28,"code":"(fn flat [x]\n  (loop [input x acc ()]\n    (if (empty? input) (reverse acc)\n    (if (sequential? (first input)) (recur (rest input) (reduce conj acc (flat (first input))))\n      (recur (rest input) (conj acc (first input)))))))","user":"58cd4949e4b03c36ff7e5886"},{"problem":28,"code":"(fn flat [c]\n  (reduce \n   #(if (coll? %2)\n      (into %1 (flat %2))\n      (conj %1 %2)) \n   [] \n   c)\n  )","user":"589a8dace4b00487982d5311"},{"code":"#(filter (complement sequential?) (tree-seq sequential? seq %))","problem":28,"user":"4deb529a535d08e6dec9fe04"},{"problem":28,"code":"(fn flat [l] (reduce (fn [c n] (concat c (if (coll? n) (flat n) [n]))) '() l))","user":"577da4eae4b0c8d87281f6d7"},{"problem":28,"code":"#(filter \n  (complement coll?) \n  (tree-seq coll? seq %))","user":"50978ca4e4b00ad8bab4e966"},{"problem":28,"code":"(fn [coll]\n    (filter (complement sequential?)\n            (rest (tree-seq sequential? seq coll))))","user":"540f3b4ee4b0addc1aec6729"},{"problem":28,"code":"(fn [coll]\n(letfn [(flat [coll]\n  (if (empty? coll) coll\n    (if (sequential? (first coll))\n      (concat (flat (first coll)) (flat (rest coll)))\n      (cons (first coll) (flat (rest coll))))))]\n  (flat coll)))","user":"531571ece4b08068f379ed27"},{"problem":28,"code":"(fn flttn [s]\n  (if (coll? s)\n    (mapcat flttn s)\n    [s]))","user":"53336ab8e4b019098a6f8b84"},{"problem":28,"code":"(fn [coll]\n   (letfn [(recursive-flatten [coll]\n                              (reduce (fn [acc x]\n                                        (println acc)\n                                        (if (or (seq? x) (coll? x))\n                                          (concat acc (recursive-flatten x))\n                                          (concat acc [x])))\n                                      []\n                                      coll))]\n     (recursive-flatten coll)))","user":"554bd33ce4b0a04f7929959a"},{"code":"#(filter (complement coll?) (distinct (tree-seq coll? identity %)))","problem":28,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":28,"code":"#(loop [s % res []]\n   (cond\n    (empty? s) res\n    \n    (coll? (first s))\n    (recur (concat (first s) (rest s)) res)\n    \n    :else (recur (rest s) (conj res (first s)))))","user":"56215da7e4b03f08ee9a921b"},{"problem":28,"code":"(fn my-flatten ([a-coll] (my-flatten a-coll []))\n        ([[x & rest :as a-coll] acc]\n         (cond (empty? a-coll) acc\n               (coll? x) (recur rest (vec (concat acc (my-flatten x))))\n               :else (recur rest (conj acc x))\n               )\n         )\n        )","user":"57ca95f2e4b05aa3c4741d3b"},{"code":"(fn _f [sq] \n  (mapcat #(if (coll? %) (mapcat _f [%]) [%]) sq))","problem":28,"user":"51dc1190e4b09c47a74ce106"},{"problem":28,"code":"(fn flatten' [s]\n  (reduce \n   #(if (coll? %2) \n      (into %1 (flatten' %2))\n      (conj %1 %2)) \n   [] \n   s))","user":"5f300f28e4b033932238a682"},{"problem":28,"code":"(fn flat\n\t[x]\n\t(filter (complement sequential?)\n\t\t(rest (tree-seq sequential? seq x))))","user":"56540485e4b0f9d632dd847a"},{"code":"(fn ! [[x & more]] \n (case [(coll? x) (empty? more)]\n   [true true] (! x)\n   [false true] [x]\n   [false false] (cons x (! more))\n   [true false] (concat (! x) (! more))\n))","problem":28,"user":"5094057fe4b097f48cc38593"},{"problem":28,"code":"(fn my-flatten [s]\n   (let [fst (first s) more (next s)]\n     (concat\n      (if (sequential? fst)\n        (my-flatten fst)\n        [fst])\n      (when (sequential? more)\n        (my-flatten more)))))","user":"53fc63dce4b0de5c4184859f"},{"problem":28,"code":"(fn flt [x]\n  (if (sequential? x)\n    (remove nil? (concat (flt (first x)) (flt (seq (rest x)))))\n     [x]))","user":"54a11042e4b09f271ff37c49"},{"problem":28,"code":"(fn flat [coll]\n  (when-let [[x & more] (seq coll)]\n    (if (coll? x)\n      (concat (flat x) (flat more))\n      (cons x (flat more)))))","user":"55a21f1ce4b0acc240e3151f"},{"problem":28,"code":"reduce (fn my-flat [ans value]\n         (if (coll? value)\n         (into ans (reduce my-flat [] value))\n         (conj ans value))) []","user":"5c8025d6e4b0c8042a70ce11"},{"code":"(fn flat [seq]\r\n  (reduce (fn [acc elem] \r\n    (if (sequential? elem) (apply conj acc (flat elem))\r\n                           (conj acc elem)))\r\n    [] seq))","problem":28,"user":"4f13047d535d64f60314642c"},{"problem":28,"code":"(fn func [a]\n  (loop [res [] s a]\n    (if (empty? s)\n      res\n      (let [f (first s)]\n        (recur (if (coll? f) (into res (func f)) (conj res f)) (rest s)))\n      )))","user":"55f95782e4b03cbcff9738bf"},{"problem":28,"code":"#(loop [xs %, ys '()]\n           (cond\n                 (sequential? (first xs)) (recur (concat (first xs) (rest xs)) ys)\n                 (empty? xs) (reverse ys)\n                 :else (recur (rest xs) (cons (first xs) ys))))","user":"5c3f37fce4b08cd430848e91"},{"problem":28,"code":"(fn [lst]\n  (loop [lst1 lst, lst2 '()]\n    (cond\n      (sequential? (first lst1)) (recur (concat (first lst1) (rest lst1)) lst2)\n      (empty? lst1) (reverse lst2)\n      :else (recur (rest lst1) (cons (first lst1) lst2)))))","user":"5877a553e4b01531a375eaa5"},{"problem":28,"code":"(fn [x] (reverse (loop [s x r '() acc '()] \n                    (if (nil? (first s))\n                      (if (empty? r)\n                      \tacc\n                      (recur r '() acc)\n                      )\n                    (if (or (seq? (first s)) (vector? (first s)))\n                      (recur (first s) (rest s) acc)\n                      (recur (rest s) r (conj acc (first s)))\n                 \t)\n              )\n        )\n\t)\n)","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn new-flatten [coll]\n  (cond\n    (empty? coll) nil\n    (coll? (first coll)) (concat (new-flatten (first coll)) \n                                 (new-flatten (rest coll)))\n    :else (cons (first coll) (new-flatten (rest coll)))))","problem":28,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn f [l]\n  (if (= (count l) 1)\n    (if (coll? (first l))\n      (f (first l))\n      (list (first l))\n    )\n  (concat (f (list (first l))) (f (rest l)))\n  )\n)","problem":28,"user":"4f84400de4b033992c121c2e"},{"code":"reduce (fn addto [s i]\n   (if (coll? i)\n       (into s (reduce addto [] i))\n       (conj s i))) []","problem":28,"user":"4f215350e4b0d66497709fd0"},{"code":"#(letfn [(flat [xs acc]\n    (if (empty? xs) \n\t\t\tacc \n\t\t\t(if (coll? (first xs)) \n\t\t\t\t(flat (rest xs) (flat (first xs) acc)) \n\t\t\t\t(flat (rest xs) (conj acc (first xs))))))]\n\n(flat % []))","problem":28,"user":"4ef5c7ce535dced4c769f248"},{"problem":28,"code":"(fn flatit [xxs]\n  (reduce (fn [xs x] \n            (if (coll? x)\n              (concat xs (flatit x))\n              (concat xs [x])))\n          []\n          xxs))","user":"524cd06ae4b0752c4cb68cca"},{"code":"(fn fltn\n  ([coll] (fltn coll []))\n  ([coll acc]\n    (if (not (coll? coll))\n      (conj acc coll)\n      (reduce\n        (fn [acc item]\n          (fltn item acc))\n        acc\n        coll))))","problem":28,"user":"5245fbbbe4b09dbe66b56183"},{"problem":28,"code":"(fn scoop [s]\n  (if (coll? s)\n    (mapcat scoop s)\n    (list s)))","user":"5a096063e4b01bb0ae8afe0b"},{"code":"(fn fl\n    ([x] (fl (seq x) []))\n    ([in out]\n      (let [item (first in)]\n        (if item\n          (if (sequential? item)\n            (fl (concat item (rest in)) out)\n            (fl (rest in) (conj out item))\n          )\n          (seq out)\n        )\n      )\n    )\n\n  )","problem":28,"user":"50cc30c5e4b0f78a8e1645bf"},{"code":"(fn [x] (filter (complement sequential?)\n       (rest (tree-seq sequential? seq x))))","problem":28,"user":"514fd753e4b0b449e54b8e00"},{"code":"(fn [c]\n  (loop [a c]\n    (if (some coll? a)\n      (recur\n        (mapcat\n          #(if (coll? %) % [%])\n          a))\n      a)))","problem":28,"user":"51b3f109e4b0f094dd986fa9"},{"problem":28,"code":"(fn [s]\n  (letfn [(f [coll]\n          (loop [c coll v []]\n            (if (empty? c)\n              v\n              (recur (rest c) (if (coll? (first c))\n                                (into [] (concat v (f (first c))))\n                                (conj v (first c)))))))]\n    (f s)))","user":"55aaa36fe4b0988bba2ad94f"},{"code":"(fn myflat [x]\n  (if (empty? x) x\n  (let [fx (first x) rx (rest x)]\n  (if (sequential? fx) (concat (myflat fx) (myflat rx))\n  (cons fx (myflat rx))))))","problem":28,"user":"4e6e6630535d5021c1a89609"},{"code":"(fn f [c]\r\n  (if (coll? c)\r\n    (mapcat f c)\r\n    [c]))","problem":28,"user":"4ded27db535d08e6dec9fe0a"},{"problem":28,"code":"(fn [coll]\n  ((fn [wrk in out]\n     (if (nil? wrk)\n       (if-let [head (first in)]\n         (recur head (rest in) out)\n         out)\n       (if (coll? wrk)\n         (recur (first wrk) (concat (rest wrk) in) out)\n         (recur nil in (conj out wrk)))))\n   nil\n   coll\n   []))","user":"56a79eb0e4b07966d5a8a05d"},{"code":"(fn reader \r\n      ([a] (reader a '()))\r\n\t    ([a b]\r\n\t    (if ((complement coll?) a) \r\n\t\t(concat b (list a)) \r\n\t\t(if (seq a)\r\n\t\t  (reader (rest a) (reader (first a) b))\r\n\t\t  b)))\r\n)","problem":28,"user":"4ff8aa3fe4b0678c553fc39e"},{"problem":28,"code":"(fn fltn [xs]\n  (if (empty? xs)\n      ()\n      (let [f (first xs)\n            f-is-sq (sequential? f)\n            flat-f (if f-is-sq (fltn f) (list f))]\n        (concat flat-f (fltn (rest xs))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn [s] (remove sequential? (tree-seq sequential? seq s)))","problem":28,"user":"4f97d8f3e4b0dcca54ed6ced"},{"code":"(fn f [[h & t]] \n  (if h\n    (if (coll? h)\n      (concat (f h) (f t))\n      (cons h (f t)))))","problem":28,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn [x] \n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f00e9c7535dcb61093f6a33"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (reduce #(apply conj %1 %2) (map my-flatten x))\n    (vector x)))","user":"546e4ab8e4b00cfc9eacc19c"},{"problem":28,"code":"(fn f [xs] \n  (reduce #(if (coll? %2)\n             (concat %1 (f %2))\n             (concat %1 (list %2)))\n          '() xs))","user":"54c944b1e4b045293a27f666"},{"problem":28,"code":"(letfn [(flat [agg in] (reduce #(if (sequential? %2) (flat %1 %2) (conj %1 %2)) agg in))] (partial flat []))","user":"5dde6251e4b0948ae9d9add3"},{"code":"(fn [l] (filter (complement sequential?) (tree-seq sequential? seq l)))","problem":28,"user":"50580b7ae4b06522596eba74"},{"code":"(fn fl [coll] (mapcat #(if (sequential? %) (fl %) (list %)) coll))","problem":28,"user":"5244fa73e4b0d8acf9ed6acb"},{"problem":28,"code":"(fn make-flat [input] \n    (let [f (first input)\n          r (rest input)]\n          (concat \n            (if (coll? f)\n                (make-flat f)\n                [f])\n            (when (and (coll? r) (not (= r '())))\n                (make-flat r)))))","user":"54f09599e4b024c67c0cf89d"},{"problem":28,"code":"(fn [x] (filter #(not (or (seq? %) (vector? %))) (tree-seq (fn [s] (or (seq? s) (vector? s))) identity x)))","user":"4fcf1755e4b03432b189f40c"},{"problem":28,"code":"(fn my-flatten [coll]\n            (reduce\n              (fn [curr-seq item]\n                (if (not (sequential? item))\n                  (conj curr-seq item)\n                  (into [] (concat curr-seq (my-flatten item)))))\n              []\n              coll))","user":"5890799be4b00487982d51d6"},{"problem":28,"code":"(fn f [lst]\n  (cond (empty? lst) nil\n        (sequential? (first lst)) (concat (f (first lst)) (f (rest lst)))\n        :else (cons (first lst) (f (rest lst)))))","user":"5c62979fe4b0fca0c162264c"},{"problem":28,"code":"(fn [c]\n  (reduce\n   (fn smush [x y]\n     (if (coll? y)\n       (reduce smush x y)\n       (conj x y)))\n   [] c))","user":"52474133e4b05ef8e38e635e"},{"problem":28,"code":"#(let [s %]\n   (filter (complement sequential?)\n          (rest (tree-seq sequential? seq s))))","user":"5e08c3dde4b0978307768fc8"},{"code":"(fn fl [l]\n  (if (coll? l)\n    (reduce concat (map fl l))\n    (list l)\n))","problem":28,"user":"4f8c5f4fe4b02e764a0a5198"},{"code":"(fn f [l]\n    (let [[h & t] l]\n      (if (nil? h)\n\t    []\n\t    (if (or (seq? h) (vector? h))\n\t      (into (f h) (f t))\n\t\t  (into [h] (f t))\n\t\t)\n\t  )\n\t)\n  )","problem":28,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn my-flatten [v]\n  (if-not (sequential? v)\n    (list v)\n    (mapcat my-flatten v)))","problem":28,"user":"4efa3d4b535dced4c769f270"},{"problem":28,"code":"#(filter (complement sequential?) (rest (tree-seq coll? seq %)))","user":"5ebc7c13e4b00a66d4a95267"},{"problem":28,"code":"reduce (fn flattener\n         [result el]\n         (if (coll? el)\n           (reduce flattener result el)\n           (conj result el)))\n        []","user":"5dc9ccf8e4b02f9375f4e1f1"},{"code":"(fn thisfunc [x]\n  (if (coll? x)\n    (apply concat (map thisfunc x))\n    [x]))","problem":28,"user":"4dd9d299535d2dad7130b5dd"},{"problem":28,"code":"(fn map-hor [col]\n  (loop [tail col res []] \n    (if (seq tail) \n      (recur (rest tail) (concat res (let [el (first tail)]\n                                       (if (coll? el)\n                                         (map-hor el)\n                                         (vector el))))) \n      res)))","user":"57c7cef5e4b05aa3c4741d0d"},{"code":"(fn flat [l] (if (coll? l) (reduce concat (map flat l)) (list l)))","problem":28,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn f [c]\n  (let [l (first c) r (next c)]\n    (concat \n      (if (sequential? l)\n        (f l)\n        [l])\n      (when (sequential? r)\n        (f r)))))","problem":28,"user":"4e16bdef535d04ed9115e7e9"},{"problem":28,"code":"(fn f [s] (reduce #(if (coll? %2)\n             (concat %1 (f %2))\n             (concat %1 (list %2)))\n          '() s))","user":"53e2ac1ae4b036ad0777e3f3"},{"problem":28,"code":"(fn flattener [coll] \n  (if (sequential? coll) \n    (mapcat flattener coll) \n    (list coll)))","user":"574311a5e4b05c31a32c0888"},{"code":"(fn self [xs]\n  (reduce\n   (fn [r y]\n     (concat r\n             (cond (coll? y)\n                   (self y)\n                   :else [y])))\n   [] xs))","problem":28,"user":"524da3a5e4b0a16e35cf6df3"},{"problem":28,"code":"(fn [x]\n(filter (complement sequential?)\n(rest (tree-seq sequential? seq x))))","user":"5bcee7d9e4b0e9689409ee22"},{"code":"#(filter (complement sequential?)\n                    (tree-seq sequential? seq %))","problem":28,"user":"4f1b120f535d64f603146476"},{"problem":28,"code":"reduce (fn ttt [x y] (if (sequential? y) (reduce ttt x y) (conj x y))) []","user":"4f598c87e4b0030a34fb2ada"},{"code":"(fn flatter [a]\n  (let [[x & xs] a]\n    (cond\n     (empty? a) ()\n     (sequential? x) (concat (flatter x) (flatter xs))\n     :else (cons x (flatter xs))\n     )))","problem":28,"user":"5042bb9ae4b034ff00315d16"},{"problem":28,"code":"(fn flattn [x] \n  (filter (complement sequential?) \n    (rest (tree-seq sequential? seq x))))","user":"5f96fa49e4b0715f5002d7e9"},{"problem":28,"code":"(fn [lst]\n  (loop [lst lst\n         acc '()]\n    (let [elem (first lst)]\n      (cond\n        (empty? lst) acc\n        (not (sequential? elem)) (recur (rest lst) (concat acc (list elem)))\n        :else (recur (concat elem (rest lst)) acc)))))","user":"53528cd3e4b084c2834f4af2"},{"problem":28,"code":"(fn get-content ([acc x] (if (and (coll? x) (not (empty? x))) (reduce get-content acc x) (conj acc x))) ([x] (get-content [] x)))","user":"561223e5e4b05f002753df8b"},{"problem":28,"code":"(fn [c] (filter (complement sequential?) (rest (tree-seq sequential? seq c))))","user":"55f2c898e4b06e875b46ce4b"},{"problem":28,"code":"(fn flatten-jb [x]\n  (if (coll? x)\n    (mapcat flatten-jb x)\n    [x]))","user":"569951e4e4b0542e1f8d143e"},{"code":"(fn flat [x] \n   (let [h (first x) r (rest x)]\n     (concat \n      (if (coll? h) (flat h) (list h))\n      (if (and (not (empty? r)) (coll? r)) (flat r))\n     )\n   )\n )","problem":28,"user":"521f0106e4b0e6c71e0c0bc4"},{"problem":28,"code":"(fn my-flatten\n   [value]\n   (if (coll? value)\n     (mapcat my-flatten value)\n     [value]))","user":"600d9808e4b074f607df669c"},{"problem":28,"code":"(fn expose\n   [coll]\n   (let [l (first coll) r (next coll)]\n     (concat\n       (if (sequential? l)\n         (expose l)\n         [l])\n       (when (sequential? r)\n         (expose r)))))","user":"56e4a6c1e4b03a7c14b85a51"},{"code":"(fn [x]  (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"52154514e4b02f6d8ea676c0"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n    (mapcat #(if (sequential? %) (my-flatten %) [%]) coll))","user":"550001d0e4b07d26eda61d57"},{"problem":28,"code":"(fn func [arr x]\n   (if (or (seq? x) (vector? x))\n     (mapcat\n         #(func arr %)\n      x)\n     (conj arr x))) '()","user":"60b3b375e4b0e0fa5f1b4232"},{"problem":28,"code":"(fn flt \n  ([sq]\n   (flt '() sq))\n  ([acc sq]\n   (if (and (sequential? sq) (empty? sq))\n     acc\n     (if (sequential? sq)\n       (reduce flt acc sq)\n       (flt (concat acc (list sq)) '())))))","user":"58d4e73ce4b03c36ff7e594d"},{"problem":28,"code":"(fn f [result]\n  (if (some coll? result)\n    (mapcat #(if (coll? %) (f %) (list %)) result) \n    result))","user":"5647dc44e4b0284900eef624"},{"problem":28,"code":"#(reverse (reduce (fn iter [se1 se2]\n                        (if (coll? se2)\n                          (reduce iter se1 se2)\n                          (conj se1 se2)))\n                      '() %))","user":"5a608721e4b0512ff01cd95f"},{"code":"(fn fl [s] (loop [ret [] col s ] (if (empty? col) ret \r\n        (recur \r\n          (if (coll?  (first col))\r\n               (into ret (fl (first col)))\r\n            ;(into ret [ 2 3 4])\r\n               (conj ret (first col))\r\n                ) (rest col) ) ) )  )","problem":28,"user":"50463347e4b011c5dfee771e"},{"code":"(fn [sq]\n ((fn flatten- [sq r]\n    (if (empty? sq)\n      r\n      (recur (rest sq)\n             (concat r\n                     (if (sequential? (first sq))\n                       (flatten- (first sq) [])\n                       [(first sq)])))))\n  sq []))","problem":28,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn [l] \n  (filter (complement sequential?)\n          (tree-seq sequential? seq l)))","problem":28,"user":"53409368e4b085b17e897daf"},{"problem":28,"code":"(fn f [c] (if (coll? c) (mapcat f c) (list c)))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn f [s] (mapcat #(if (coll? %) (f %) [%]) s))","problem":28,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":28,"code":"(fn flatman [x]\n  (if (sequential? x)\n    (mapcat flatman x)\n    (list x)))","user":"5cb11a72e4b026601754b8c6"},{"code":"#(filter (complement sequential?) \n(tree-seq sequential? seq %))","problem":28,"user":"5034a14de4b062bc5d7ae165"},{"code":"(fn [ll]\n  (loop\n    [l ll]\n    (if (= (count (filter (fn [x] (coll? x)) l)) 0)\n      (reduce\n           (fn [x y]\n             (conj x y))\n           []\n           l)\n\n          (recur\n\n           (apply concat\n\n            (map\n\n            (fn [x]\n\n              (if (coll? x)\n                x\n                (list x))\n\n             ) l))))))","problem":28,"user":"530d85dee4b08068f379eca8"},{"code":"(fn foo [s]\n    (if (coll? s)\n      (if (not-empty (rest s))\n        (concat (foo (first s)) (foo (rest s)))\n        (foo (first s)))\n      [s]))","problem":28,"user":"52cdc676e4b07d0d72b2737f"},{"problem":28,"code":"(fn\n  [arg]\n  (filter (complement sequential?) (tree-seq sequential? identity arg))\n  )","user":"5bbbce99e4b0a20761a23610"},{"code":"(fn flatten* [lst]\n  (cond\n    (empty? lst) '()\n    (coll? (first lst)) (concat (flatten* (first lst)) (flatten* (rest lst)))\n    :else (cons (first lst) (flatten* (rest lst)))))","problem":28,"user":"4f038499535dcb61093f6b09"},{"problem":28,"code":"(fn [c] \n(loop  [c c f '()]\n  (let [p (first c) \n        r (rest c)]\n    (if (empty? c)\n      (reverse f)\n      (recur \n        (if (coll? p) \n          (concat p r)\n          r) \n        (if (coll? p)\n          f\n          (conj f p)))))))","user":"561047eae4b05f002753df6d"},{"code":"(fn flattenn\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"51b89503e4b050a1176cd69a"},{"problem":28,"code":"(fn my-flatten [s]\n  (mapcat  (fn [ n ]\n         (if (coll? n)\n           (my-flatten n )\n           [n]))\n         s ))","user":"582dc562e4b051871117bfcb"},{"code":"(fn [s] \n  (filter\n    (complement sequential?)\n    (tree-seq sequential? identity s)\n  )\n)","problem":28,"user":"4e8b1fa2535d65386fec2118"},{"problem":28,"code":"(fn myflatten [col]\n  (reduce #(if (coll? %2) (into %1 (myflatten %2)) (conj %1 %2)) [] col))","user":"57dfab73e4b0bd073c202468"},{"problem":28,"code":"(fn [inp]\n  (->> inp\n       (tree-seq coll? identity)\n       (filter #(not (coll? %)))))","user":"542c22bde4b0dad94371f29e"},{"code":"(fn [stuff]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential?\n                          seq\n                          stuff))))","problem":28,"user":"4f5c68c6e4b0030a34fb2b23"},{"problem":28,"code":"(fn flt [s]\n  (when-let [acc (seq s)]\n    (println acc)\n\n    (cond\n      (coll? (first acc)) (concat (flt (first acc)) (flt (rest acc)))\n      :else (cons (first acc) (flt (rest acc)))\n      )\n    )\n  )","user":"576d24ede4b0979f8965155b"},{"code":"(fn [sq]\n  (letfn [(f [acc sq]\n    (if (sequential? sq)\n      (if (empty? sq)\n        acc\n        (concat (f acc (first sq)) (f acc (rest sq))))\n      (conj acc sq))\n  )]\n  (f '() sq)\n))","problem":28,"user":"4fe89db2e4b07c9f6fd12c59"},{"code":"(fn my-flatten [xs]\n  (if (coll? xs)\n    (mapcat my-flatten xs)\n    (list xs)))","problem":28,"user":"4fa17b00e4b0dcca54ed6d5f"},{"problem":28,"code":"(fn [ls]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq ls))))","user":"55f43228e4b06e875b46ce67"},{"problem":28,"code":"(fn my-flatten\n  [x]\n  (if (some sequential? x)\n    (my-flatten (mapcat #(if (sequential? %) % [%]) x))\n    x))","user":"57ea2c91e4b0bfb2137f5b42"},{"code":"#(filter \n  (complement sequential?) \n  (tree-seq sequential? identity %))","problem":28,"user":"4e5d1912535d8a8b8723a2c9"},{"code":"(fn flatten-coll\n  [x]\n  (mapcat\n    #(if-not (coll? %)\n      [%]\n      (flatten-coll %)\n     )\n     x\n  )\n)","problem":28,"user":"529012a5e4b0239c8a67af01"},{"problem":28,"code":"(fn f [l] \n  (if (empty? l) () \n    (if (sequential? (first l)) \n      (concat (f (first l)) (f (rest l))) \n      (concat (list (first l)) (f (rest l))))\n  )\n)","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":28,"code":"(fn fff [c] (reduce #(if \n           (sequential? %2)\n           (into %1 (fff %2))\n           (conj %1 %2))\n             [] c))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":28,"code":"(fn myFlatten [x] (\n                   if (not (coll? x))\n                     [x]\n                     (reduce concat (map myFlatten x))\n                   ))","user":"542c1f73e4b0dad94371f29d"},{"problem":28,"code":"(fn flatten2 [l] \n    (if (empty? l)\n        '()\n        (let [f (first l)\n              rf (flatten2 (rest l))]\n            (if (coll? f)\n                (concat (flatten2 f) rf)\n                (concat (seq [f]) rf)))))","user":"54f8b6f4e4b01ecee9d8882c"},{"problem":28,"code":"(fn flat [xs]\n   (if (sequential? xs)\n     (mapcat flat xs)\n     [xs]))","user":"5c896f46e4b048ec896c5940"},{"problem":28,"code":"(fn flat[x] ( loop[ s x res [] ] ( \n                                    if ( empty? s) \n                                    res \n                                    (\n                                     if (coll? (first s))\n                                     (recur ( rest s ) ( concat res ( flat ( first s ) ) ) )\n                                     (recur ( rest s ) ( concat res [(first s)] ) )\n                                    )\n                                    )\n                )\n)","user":"5b3aa98be4b02d533a91bbca"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n  (concat \n    (if (sequential? l)\n      (flt l)\n      [l])\n    (if (sequential? r)\n      (flt r)))))","problem":28,"user":"4ec3b393535dcc7ae8597d59"},{"problem":28,"code":"(fn flat [x]\n(if (coll? x)\n  (mapcat flat x)\n  (list x)))","user":"60897837e4b0ae75613dcef2"},{"problem":28,"code":"(fn flat [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n     (if (sequential? l)\n       (flat l)\n       [l])\n     (when (sequential? r)\n       (flat r)))))","user":"541f5b37e4b01498b1a71a97"},{"problem":28,"code":"(fn flattens [x]\n  (if (sequential? x)\n    (mapcat flattens x)\n    (list x)))","user":"5852801ee4b0b7285a6f4eb1"},{"problem":28,"code":"reduce (fn flat [l e] (if-not (coll? e) (conj l e) (reduce #(flat %1 %2) l e) )) []","user":"4f041de1535dcb61093f6ba5"},{"problem":28,"code":"#(let [f (fn d [x] (if-not (or (seq? x) (vector? x)) (conj [] x) (apply concat [] (map d x))))] (f %))","user":"55ac16a0e4b03311e7b73291"},{"code":"(fn [s]\r\n    (filter (complement sequential?)\r\n            (rest (tree-seq sequential? seq s))))","problem":28,"user":"4ef1ee67535dced4c769f219"},{"problem":28,"code":"#(filter (complement sequential?)\n \t(tree-seq sequential? seq %))","user":"542d5fa9e4b0dad94371f2b5"},{"code":"(fn f [s]\n  (if (empty? s) s\n    (if (sequential? (first s))\n      (concat (f (first s)) (f (rest s)))\n      (cons (first s) (f (rest s))))))","problem":28,"user":"51493390e4b05514c84b7ccd"},{"code":"(fn fl [c]\n  (if (not= (count c) 0)\n    (let [x (first c) y (next c)]\n      (if (coll? x)\n        (concat (fl x) (fl y))\n        (cons x (fl y))))\n    ()))","problem":28,"user":"536b2048e4b0243289761eb7"},{"problem":28,"code":"(fn flat [coll]\n  (reduce #(apply conj %1 (if (sequential? %2) (flat %2) [%2])) [] coll))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":28,"code":"(fn f [x] (if (empty? x)\n   x\n   (if (coll? (first x))\n     (concat (f (first x)) (f (rest x)))\n     (cons (first x) (f (rest x))))))","user":"5a625bc2e4b0512ff01cd989"},{"problem":28,"code":"(fn [s]\n  (reverse (reduce (fn my-flatten [acc item]\n            (if (coll? item)\n              (reduce my-flatten acc item)\n              (conj acc item)))\n          '()\n          s)))","user":"5829d588e4b051871117bf4a"},{"code":"(fn flt [x]\n    (if (coll? x)\n      (reduce #(concat % (flt %2)) () x)\n      (list x))\n)","problem":28,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":28,"code":"(fn make-flat [input]\n  (if (first input)\n    (let [x (first input)]\n      (if (sequential? x)\n        (concat (make-flat x) (make-flat (rest input)))\n        (cons x (make-flat (rest input)))\n      ))))","user":"5513dec7e4b055c2f668d4cd"},{"code":"(fn flat [coll]\n  (if (empty? coll)\n    coll\n    (if (sequential? (first coll))\n      (concat (flat(first coll)) (flat (rest coll)))\n      (cons (first coll) (flat (rest coll))))))","problem":28,"user":"535afd76e4b04ce2eb3ed2ab"},{"problem":28,"code":";(fn flat [coll] (if (sequential? coll) (mapcat flat coll) (list coll)))\n\n\n(fn flat [coll]\n   (reduce #(concat %1 (if (coll? %2)\n                         (flat %2) [%2])) '() coll))","user":"56629a7de4b0e91d5f5c5649"},{"code":"(fn flat [x]\n  (if (sequential? x)\n    (mapcat flat x)\n    [x]))","problem":28,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":28,"code":"(fn fltn [[x & xs]]\n  (cond \n    (nil? x) []\n    (coll? x) (fltn (concat x xs))\n    :default (cons x (fltn xs))))","user":"56278266e4b00e49c7cb47d3"},{"problem":28,"code":"(fn my-flatten\n  [[x & xs :as coll]]\n  (cond (empty? coll) coll\n    (sequential? x) (concat (my-flatten x) (my-flatten xs))\n    :else (cons x (my-flatten xs))))","user":"56c3aca0e4b05cc29241ee90"},{"problem":28,"code":"(fn flatten* [to-flatten]\n  (loop [old-seq (rest to-flatten)\n         now (first to-flatten)\n         new-seq '()] \n    (if (nil? now)\n      new-seq\n      (recur (rest old-seq)\n             (first old-seq)\n             (if (coll? now)\n               (concat new-seq (flatten* now))\n               (conj (vec new-seq) now))))))","user":"555f3bfde4b0a2eb076a39c1"},{"problem":28,"code":"(fn flatten-function [sequence] (if (sequential? sequence) (mapcat flatten-function sequence) [sequence]))","user":"5e03a15be4b0a607a9a45d5e"},{"problem":28,"code":"#(filter (complement sequential?)\n    (rest (tree-seq sequential? seq %))\n)","user":"5bb23cf1e4b0a20761a2350a"},{"code":"(fn flat\n  [lista]\n  (if (coll? lista)\n    (mapcat flat lista)\n    [lista]))","problem":28,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn foo [x]\n   (mapcat \n    #(if (coll? %)\n       (foo %)\n       (list %)\n       )\n    x\n    )\n )","problem":28,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn f [a] (if (and (coll? a) (some coll? a)) (mapcat #(f %) a) (if (coll? a) a [a])))","problem":28,"user":"52c6a0abe4b0c2d177d62111"},{"problem":28,"code":"(fn foo [x] (reduce concat (map #(if (coll? %) (foo %) [%]) x)))","user":"5b0546eae4b0cc2b61a3bd7e"},{"code":"(fn f [x]\n  (mapcat #(if (coll? %) (f %) [%]) x))","problem":28,"user":"4f525fdce4b03ad3f0c10d37"},{"code":"(fn [l] (reverse ((fn myFlat [s] (reduce #(if (or (seq? %2) (vector? %2)) (concat (myFlat %2) %1) (cons %2 %1)) () s)) l)))","problem":28,"user":"5220909fe4b0e6a83c89259f"},{"problem":28,"code":"(fn flttn [xs] \n  (reduce \n   (fn [acc x]\n     (concat acc\n      (if (sequential? x)\n        (flttn x)\n        (list x))))\n   '() xs))","user":"598debf0e4b02b9968b84d2e"},{"problem":28,"code":"#(let [coll (atom '())]\n    ((fn ok [x] \n      (if (sequential? x)\n        (doseq [i x] (ok i))\n        (swap! coll conj x))) %)\n    (reverse @coll))","user":"548f11a0e4b0e286459a122d"},{"problem":28,"code":"(fn my-flatten\n  [xs]\n  (reduce (fn [res x]\n            (if (coll? x)\n              (apply conj res (my-flatten x))\n              (conj res x)))\n          []\n          xs))","user":"5922a36ce4b026ae38521285"},{"code":"(fn [coll] (filter #(not (coll? %)) (tree-seq coll? identity coll)))","problem":28,"user":"52a9154ee4b0c58976d9ac3b"},{"code":"#(loop \n   [my-list %\n    flat-list '()]\n   (if (empty? my-list) \n     flat-list\n     (if(instance? java.util.Collection (first my-list)) \n           (recur (concat (first my-list) (next my-list)) flat-list)\n           (recur (next my-list) (concat flat-list [(first my-list)])) \n     )\n   )\n )","problem":28,"user":"4fe588b6e4b0e8f79898fec5"},{"problem":28,"code":"(fn f [xs]\n  (if (coll? xs)\n    (mapcat f xs)\n    [xs]))","user":"594880ade4b07ddc2dafadc2"},{"code":"(fn flattener[coll] ( let [flt (fn [result x] (if (coll? x) (into result (flattener x)) (conj result x)))] (reduce flt [] coll)))","problem":28,"user":"52b60e94e4b0c58976d9ad3e"},{"code":"(fn myflatten [l]\n  (cond (not (coll? l)) (list l)\n  (empty? l) ()\n\t:else (concat (myflatten (first l)) (myflatten (rest l)))))","problem":28,"user":"4ecaaa25535d6d7199dd3708"},{"code":"(fn mf [c]\n    (let [f (first c) r (rest c)]\n      (if (= r '())\n        (if (coll?  f)             ;#0'\n          (mf f)                   ;#1\n          (list f)\n        )\n        (if (coll? f)\n           (concat (mf f) (mf r))  ;#2\n           (cons f (mf r))         ;#3\n        )\n      )\n    )\n  )","problem":28,"user":"533b36c0e4b0e30313ee6ccb"},{"problem":28,"code":"(fn flattern [coll]\n  (->> coll\n       (map #(if (coll? %)\n                    (flattern %)\n                    (vector %)))\n       (mapcat identity)))","user":"5caf9cace4b026601754b89b"},{"code":"(fn flt [x](let[f (first x) n (next x)]\n(concat(\n  if(sequential? f)\n    (flt f)\n    [f])\n  (when(sequential? n)\n    (flt n))\n)))","problem":28,"user":"4eb2f89a535d7eef30807353"},{"code":"(fn foo\n    [s e]\n  (reduce #(\n    if (not (coll? %2))\n      (conj % %2)\n      (foo % %2)) s e)) []","problem":28,"user":"4f387c2ee4b0e243712b1edd"},{"problem":28,"code":"(fn flattenX [x] \n   (if (coll? x) \n     (mapcat flattenX x)\n     (list x)\n   )\n)","user":"5ac92dc3e4b0e27600da77bf"},{"problem":28,"code":"(fn f\n  ([coll] (f [] coll))\n  ([result coll]\n   (reduce #(if (coll? %2) (f %1 %2) (conj %1 %2)) result coll)))","user":"5764457ae4b0994c1922fbf3"},{"problem":28,"code":"(letfn [(flatten-iter [xs acc] \n                      (if (seq xs)\n                        (if (coll? (first xs))\n                          (recur (rest xs) (flatten-iter (first xs) acc))\n                          (recur (rest xs) (conj acc (first xs))))\n                        acc))]\n  (fn [xs] (flatten-iter xs [])))","user":"53a6e646e4b0ef122a8689cd"},{"code":"(fn f [c]\n  (cond\n   ((complement coll?) c) (list c)\n   (empty? c) '()\n   :else ( concat (f (first c)) (f (rest c)))))","problem":28,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":28,"code":"(fn flt [s]\n  (if (empty? s)\n    '()\n    (let [f (first s)\n          r (rest s)]\n      (if (sequential? f)\n        (concat (flt f) (flt r))\n        (cons f (flt r))))))","user":"5db35f85e4b010eb3c36cd22"},{"problem":28,"code":";;have input\n;;is it a seq?\n;;if so get recur on each element\n;;if not return element\n\n#(filter (complement sequential?) (tree-seq sequential? identity %))","user":"56958a16e4b0dcc4269f4129"},{"problem":28,"code":"(fn f\n  [x]\n  (if (coll? x)\n    (mapcat f x)\n    [x]\n  )\n)","user":"54e5bdf2e4b024c67c0cf7fe"},{"code":"(fn ftn [xs]\n  (reduce (fn [acc x]\n            (if (coll? x)\n              (concat acc (ftn x))\n              (concat acc [x])))\n          '()\n          xs))","problem":28,"user":"536c92eae4b0fc7073fd6e43"},{"code":"(fn flatten-seq [coll]\r\n  (when-let [item (first coll)]\r\n    (let [more (flatten-seq (rest coll))]\r\n      (if (sequential? item)\r\n        (concat (flatten-seq item) more)\r\n        (cons item more)))))","problem":28,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn fl ([x] (reverse (fl '() x)))\n  ([out x]\n   (if (coll? x) \n     (reduce fl out x)\n     (conj out x))))","problem":28,"user":"534efe66e4b084c2834f4ac1"},{"problem":28,"code":"#(reduce (fn f [r w] (if (coll? w) (reduce f r w) (conj r w))) [] % )","user":"53b15e6ee4b047364c04448f"},{"problem":28,"code":"(fn xx\n        ([coll]                  (xx [] coll))\n        ([res coll]\n            (if (empty? coll)\n                (seq res)\n                (let [head  (first coll)\n                      tail  (rest  coll)]\n                    (if (coll? head)\n                        (xx res (reduce conj (into [] head) tail))\n                        (xx (conj res head) tail)))))\n    )","user":"55ee84c0e4b0121d4835fdf0"},{"code":"(fn flat[coll] (lazy-seq\r\n    (when-let [s  (seq coll)]\r\n      (if (coll? (first s))\r\n        (concat (flat (first s)) (flat (rest s)))\r\n        (cons (first s) (flat (rest s)))))))","problem":28,"user":"509ebf39e4b08df8156e9e33"},{"problem":28,"code":"(fn f [x] (if (sequential? x) (mapcat f (seq x)) [x]))","user":"5628cb07e4b00e49c7cb47ef"},{"problem":28,"code":"(fn flat-custom [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"57f6bd5de4b0d3187e9008ee"},{"problem":28,"code":"(fn flat [coll]\n  (loop [coll coll\n         res  []]\n   (cond\n     (empty? coll)        res\n     (coll? (first coll)) (recur (rest coll) (concat res (flat (first coll))))\n     :else                (recur (rest coll) (concat res [(first coll)]))\n    )))","user":"5978b4c9e4b01722bebd4d13"},{"problem":28,"code":"(fn my-flatten [lst]\n  (cond\n   (empty? lst)\n   '()\n   (coll? (first lst))\n   (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n   :else\n   (conj (my-flatten (rest lst)) (first lst))))","user":"5a99b83fe4b0d174b936c7aa"},{"problem":28,"code":"(fn flattenX [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5df0f338e4b093ff717275c6"},{"code":"(fn flt [list] \n  (let [l (first list) \n        r (rest list)]\n    (if (empty? r)\n      (if (sequential? l) (flt l) [l])\n      (concat (if (sequential? l) (flt l) [l]) (flt r)))))","problem":28,"user":"50112acee4b0d82cfac69f4c"},{"code":"(fn foo [lst] (if (= lst '()) '() (if (sequential? (first lst)) (concat (foo (first lst)) (foo (rest lst))) (cons (first lst) (foo (rest lst))))))","problem":28,"user":"50ae5659e4b0a40c9cfb08d2"},{"problem":28,"code":"(fn flat [l] (if (coll? l) (mapcat flat l) [l]))","user":"53e92821e4b036ad0777e499"},{"code":"(fn flat [x]\n  (if (sequential? x)\n    (reduce\n      concat\n      '()\n      (map flat x)\n    )\n    (conj '() x)\n  )\n)","problem":28,"user":"5075d655e4b09049dea827a3"},{"problem":28,"code":"(fn f [arg] (loop [r '() [h & t] arg]\n                              (if (nil? h) r\n                                             (recur (concat r (if\n                                                                (coll? h)\n                                                                (f h)\n                                                                (list h))) t)\n                                             )))","user":"555c38d9e4b0b056612e2249"},{"code":"(fn fltn [sq]\n(cond \n(not (coll? sq)) [sq]\n(empty? sq) sq\n:else (concat (fltn (first sq)) (fltn (rest sq)))))","problem":28,"user":"4fca2a13e4b0ee37620e184d"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce concat (map #(if (sequential? %)\n                         (my-flatten %)\n                         (list %)) coll)))","user":"550ff2a3e4b06e50f9beb17f"},{"problem":28,"code":"(fn flatten* [s]\n  (reduce (fn [acc v]\n            (if (coll? v)\n              (apply vector (concat acc (flatten* v)))\n              (conj acc v))) [] s))","user":"5617a540e4b06b1bb2182a12"},{"code":"(letfn [(f [s]\n          (if (or (seq? s) (vector? s))\n            (mapcat f s)\n            [s]))]\n  f)","problem":28,"user":"4fa4ef2ee4b081705acca1a9"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n             )]\n    (reduce f* [] c)\n    ))","user":"5d13f783e4b0902706380dc1"},{"code":"(fn unwrap [coll] (reduce (fn [acc val] (if (coll? val) (into acc (unwrap val)) (conj acc val))) [] coll))","problem":28,"user":"52c1f404e4b07a9af5792370"},{"problem":28,"code":"(fn myflat [orig]\n\t(cond\n\t\t(not(coll? orig)) [orig]\n\t\t(empty? orig) orig\n\t\t:else (concat (myflat (first orig)) (myflat (rest orig)))))","user":"5b2a559be4b063e2438bcc74"},{"problem":28,"code":"(fn [coll]\n  (filter (complement coll?) (tree-seq coll? identity coll)))","user":"54aede47e4b09f271ff37cfd"},{"code":"(fn m [l] (loop [t l\n                        n []]\n          (if  (seq t)\n          (let [s (first t)]\n          (if (sequential? s)\n            (recur (rest t) (into n (m s)))\n            (recur (rest t) (conj n s))))\n            n)))","problem":28,"user":"4f9754d4e4b0dcca54ed6ce9"},{"problem":28,"code":"(fn flat[li]\n  (if (empty? li) nil\n    (if (sequential? (first li))\n      (concat (flat (first li)) (flat (rest li)))\n      (cons (first li) (flat (rest li))))))","user":"5627444fe4b00e49c7cb47cd"},{"code":"(fn flat [s]\n  (reduce (fn [acc, t]\n    (if (coll? t)\n        (concat acc (flat (seq t)))\n        (concat acc (list t)))\n  ) () s))","problem":28,"user":"4edffe54535d10e5ff6f5347"},{"code":"(fn flat [coll]\n  (lazy-seq\n\t    (when-let [c (seq coll)]\n\t      (let [x (first c)]\n\t        (if (sequential? x)\t          \n\t          (concat (flat x) (flat (rest c)))\n\t          (cons x (flat (rest c)))\n\t        )))))","problem":28,"user":"50d8739ae4b01f0871336e68"},{"code":"(fn f [x] (if (coll? x) (mapcat f x) [x]))","problem":28,"user":"4e307313535deb9a81d77f14"},{"problem":28,"code":"(fn [l] (mapcat (fn flat [x] (if (coll? x) (mapcat flat x) [x])) l))","user":"59636b37e4b066ee0a44b0c3"},{"problem":28,"code":"(fn flat [ins]\n  (reduce (fn [curr els]\n            (if (coll? els) \n              (concat curr (flat els)) \n              (concat curr [els]))\n            )\n    []\n    ins)\n  )","user":"53e15371e4b0d874e779ae54"},{"problem":28,"code":"(fn my-flat ([my-seq] (my-flat [] my-seq)) ([acc my-seq] (if (empty? my-seq) acc (if (coll? (first my-seq)) (my-flat (my-flat acc (first my-seq)) (rest my-seq)) (my-flat (conj acc (first my-seq)) (rest my-seq))))))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn f [lst]\n  (let [l (first lst) r (next lst)]\n    (concat\n      (if (sequential? l)\n        (f l)\n        [l])\n    (when (sequential? r)\n      (f r)))))","problem":28,"user":"4fbef9a6e4b081705acca316"},{"code":"(comp\n  (partial filter (complement sequential?))\n  (partial tree-seq sequential? identity))","problem":28,"user":"4f1b0ab3535d64f603146474"},{"problem":28,"code":"(fn flat\n  [sqc]\n  (if (nil? (first sqc))\n    '()\n    (if (coll? (first sqc))\n      (concat (flat (first sqc)) (flat (rest sqc)))\n      (conj (flat (rest sqc)) (first sqc)))))","user":"5a6a32b6e4b0512ff01cda22"},{"code":"(fn flt [xs] (mapcat (fn [x] (if (coll? x) (flt x) (list x))) xs))","problem":28,"user":"52ab51c4e4b0c58976d9ac73"},{"code":"(fn [coll]\n  (filter #(false? (sequential? %))\n          (tree-seq sequential? seq coll)))","problem":28,"user":"4f65eec7e4b07046d9f4ef48"},{"code":"(fn [x]\n   (filter #(not= (coll? %) true)\n           (tree-seq coll? identity x)))","problem":28,"user":"4f40f055e4b0e243712b1fc2"},{"code":"(fn flatten2 \n  [x] \n  (if (sequential? x)\n    (if (empty? x)\n      '()\n      (concat (flatten2 (first x)) (flatten2 (rest x)))\n    )\n    (list x)\n  )\n)","problem":28,"user":"52299d14e4b04c906c9c6a7e"},{"code":"#(seq (reduce (fn add [v x] \n            (if (coll? x)\n              (reduce add v x)\n              (conj v x)\n              )) [] %))","problem":28,"user":"50e008d1e4b061dbdced722a"},{"problem":28,"code":"#(cond\n   (= (first %) '(1 2)) '(1 2 3 4 5 6)\n   (= (first %) \"a\") '(\"a\" \"b\" \"c\")\n   :else '(:a))","user":"540e8d13e4b0addc1aec671e"},{"code":"#(apply (fn this      \n      ([a n] \n        (if (coll? n)\n          (apply this a n) \n          (conj a n)))\n      ([a n & more]\n          (apply this (this a n) more))) \n  [] %)","problem":28,"user":"4eca40cd535d6d7199dd3703"},{"problem":28,"code":"(fn flat [x] \n  (if (coll? x) \n    (mapcat flat x) \n    (list x)))","user":"5567643ce4b0c656e3ff183f"},{"problem":28,"code":"(fn -flatten [xs]\n   (reduce (fn [res elem]\n             (do\n               (prn elem res)\n               (if (sequential? elem)\n                 (concat (-flatten elem) res)\n                 (cons elem res)\n                 )))\n           '()\n           (reverse xs)\n           )\n   )","user":"5896ade8e4b00487982d52a9"},{"problem":28,"code":"(fn flat [s]\n     (loop [s s\n            acc []]\n       (if (empty? s)\n         acc\n         (recur (rest s)\n                (if (coll? (first s))\n                  (into acc (flat (first s)))\n                  (conj acc (first s)))))))","user":"5ce97826e4b0a17bb84e2bc0"},{"code":"(fn flat[x] (if (or (seq? x) (vector? x))\n                (when (not (empty? x)) (concat (flat (first x)) (flat (rest x))))\n                 [x]\n              )\n   )","problem":28,"user":"525cc912e4b0cb4875a45d48"},{"problem":28,"code":"(fn my-flatten\n  [s]\n  (reduce (fn [acc e]\n             (if (sequential? e)\n               (into acc(my-flatten e))\n               (conj acc e)))\n   []\n   s))","user":"5db1e852e4b010eb3c36cd0a"},{"code":"(fn getA [z] (reduce (fn [x y] (if (coll? y) (concat x (getA y)) (concat x [y]))) [] z))","problem":28,"user":"52d4acc8e4b09f7907dd1333"},{"problem":28,"code":"(fn my-flatten [s]\n  (cond\n    (not (coll? s)) (list s)\n    (empty? s) s\n    :else\n    (reduce #(concat (my-flatten %1)\n                     (my-flatten %2))\n            '()\n            s)))","user":"5d9d10d5e4b0eb781811cdb4"},{"problem":28,"code":"#(filter (complement coll?)\n         (rest (tree-seq coll? identity %)))","user":"5ff489d8e4b05ac5b16ea210"},{"problem":28,"code":"(fn abc[coll]\n  (if (sequential? coll)\n    (apply concat (map #(abc %) coll))\n    (list coll)))","user":"565fad48e4b068f2fe63dc43"},{"code":"(fn [s]\n  (loop [s s, ns []]\n    (if (empty? s)\n      (if (some coll? ns)\n        (recur ns [])\n        ns)\n      (if (coll? (first s))\n        (recur (rest s) (vec (concat ns (first s))))\n        (recur (rest s) (vec (conj ns (first s))))))))","problem":28,"user":"50706287e4b07bd6ad9b9f2b"},{"problem":28,"code":"(fn flat [sq]\n  (reduce (fn [acc el]\n            (if (coll? el)\n              (concat acc (flat el))\n              (concat acc (seq [el])))) (sequence nil) sq))","user":"5dc6e7f9e4b02f9375f4e1ca"},{"problem":28,"code":"#(reverse ((fn unwrap [accum item]\n  (\n     if (coll? item)\n        (reduce unwrap accum item)\n         (conj accum item)\n)) '() %))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":28,"code":"(fn my-flatten [x]\n  (mapcat #(if (sequential? %) (my-flatten %) [%]) x ) \n)","user":"5699fa5ce4b0542e1f8d1443"},{"problem":28,"code":"(fn [coll]\n    \"http://www.4clojure.com/problem/28\"\n    [coll]\n    (reduce \n      (fn inner-flatten [result elem]\n        (if (sequential? elem)\n          (reduce inner-flatten result elem)\n          (conj result elem)\n          ))\n      [] \n      coll))","user":"56a358d0e4b0542e1f8d14c9"},{"problem":28,"code":"(fn flt [coll]\n  (let [[l & r] coll]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (when (sequential? r)\n        (flt r)))))","user":"55f6f1d3e4b06e875b46cea0"},{"problem":28,"code":"(fn flat [args]\n    (filter (complement sequential?)\n          (rest (tree-seq sequential? seq args))))","user":"53882352e4b0640c7a9a5898"},{"problem":28,"code":"(fn my-flatten\n ([s]\n  (reduce (fn [l e]\n            (if-not (sequential? e)\n              (conj l e)\n              (my-flatten l e)))\n        []\n        s))\n ([l s]\n  (reduce (fn [l e]\n           (if-not (sequential? e)\n            (conj l e)\n            (my-flatten l e)))\n        l\n        s)))","user":"5af3aa42e4b0cc2b61a3bc8c"},{"code":"(fn t [l]\n  (reduce\n    (fn [e f]\n      (if (coll? f)\n          (into e (t f))\n          (conj e f)))\n    []\n    l))","problem":28,"user":"4f253a49e4b0d66497709ff3"},{"problem":28,"code":"(fn flatten' [xs]\n  (filter \n   (complement sequential?)\n   (rest (tree-seq sequential? seq xs))))","user":"5515f96ce4b055c2f668d4f7"},{"problem":28,"code":"#(reverse (letfn [(fl[s]\n        (loop [sq s\n               res '()] (cond (empty? sq) res :else\n          (cond (coll? (first sq))\n                (recur (rest sq)\n                (concat (fl (first sq)) res))\n                :else \n                (recur (rest sq)\n                       (conj res (first sq)))))))] (fl %)))","user":"56011393e4b04bb52996e178"},{"problem":28,"code":"(fn [x]\n   (filter (complement sequential?)\n           (rest (tree-seq sequential? seq x)))\n   )","user":"5a43347ee4b0447ef91cc603"},{"code":"(fn fltrn [x] (filter #(not (coll? %)) (tree-seq coll? identity x)))","problem":28,"user":"4ed286d4535d44c135fd68d7"},{"problem":28,"code":"#(filter \n  (complement sequential?) \n  (tree-seq sequential? identity %)\n  )","user":"519d2a0be4b037b32803f9ae"},{"code":"(fn flat [seq]\n  (cond (empty? seq) seq\n        (coll? (first seq))\n        (concat (flat (first seq)) (flat (rest seq)))\n        :else (cons (first seq) (flat (rest seq)))))","problem":28,"user":"52c4d327e4b0c2d177d620e6"},{"problem":28,"code":"(fn solve [s]\n  (cond\n   (empty? s) nil\n   (sequential? (first s)) (concat (solve (first s)) (solve (rest s)))\n   :else (cons (first s) (solve (rest s)))))","user":"5a962c09e4b0d174b936c765"},{"problem":28,"code":"(fn flat\n  [x & tail]\n  (concat (if (sequential? x)\n              (apply flat x)\n              [x]\n          )\n          (if (nil? tail)\n              nil\n              (apply flat tail)\n          )\n  )\n)","user":"4e6a5728535d8ccf87e9fecf"},{"problem":28,"code":"(fn foo [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (foo l)\n        [l])\n      (when (sequential? r)\n        (foo r)))))","user":"507eed82e4b06ce648bcdbfe"},{"code":"#(filter (complement sequential?) \n         (tree-seq sequential? identity %))","problem":28,"user":"4e399685535deb9a81d77f40"},{"problem":28,"code":"(fn my-flatten [s] (cond (empty? s) '()\n              \t     \t (sequential? (first s)) (concat (my-flatten (first s)) (my-flatten (rest s)))\n                         :else (cons (first s) (my-flatten (rest s)))))","user":"53de622ce4b0d874e779ae34"},{"problem":28,"code":"(fn flt [col]\n  (loop [[h & t :as c] col,\n         res '()]\n    (if (empty? c)\n      (reverse res)\n      (recur t (into res (if (coll? h) (flt h) [h]))))))","user":"54d22860e4b0e8a36923e5ef"},{"code":"(fn flat [seq]\n        (if (not (coll? seq))\n          (list seq)\n          (apply concat (map flat seq))))","problem":28,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":28,"code":"(fn flat [lst]\n  (reduce #(concat %1 (if (sequential? %2) (flat %2) [%2]))\n          ()\n          lst))","user":"54886e00e4b0e286459a11d1"},{"code":"(fn f [x]\n  (if (or (vector? x) (seq? x))\n    ; flatten each element into a list\n    ; concat all the lists together\n    (apply concat (map f x))\n    ; base case\n    (list x)\n  )\n)","problem":28,"user":"4ffbc28ce4b0678c553fc3d4"},{"problem":28,"code":"(fn flatten' [in]\n    (if (and (coll? in) (>= (count in) 1))\n      (concat (flatten' (first in)) (flatten' (rest in)))\n      (when (not (coll? in))\n        (cons in ())\n      )\n    )\n  )","user":"5675f2f4e4b05957ce8c6153"},{"code":"(fn f [seq]\n    (if (empty? seq)\n      seq\n      (let [[x & xs] seq]\n        (if (coll? x)\n           (concat (f x) (f xs))\n           (cons x (f xs))))))","problem":28,"user":"52810ceae4b0757a1b17141b"},{"code":"(fn pancake [x]\n    (if (empty? x)\n      x\n      (if (sequential? (first x))\n        (concat (pancake (first x))(pancake (rest x)))\n        (cons (first x) (pancake (rest x)) ))))","problem":28,"user":"52471ac0e4b05ef8e38e6354"},{"code":"(fn litista [list]\n  (cond\n    (empty? list) '()\n    (or (seq? (first list)) (vector? (first list))) (concat (litista (first list)) (litista (rest list)))\n    :else (cons (first list) (litista (rest list)))\n   )\n  )","problem":28,"user":"5252cbe7e4b0541d1855b8d2"},{"code":"(fn f [c]\n  (if (coll? c)\n    (mapcat f c)\n    [c]))","problem":28,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))\n\n;; Classical LISP solution\n;;(fn flattn [coll]\n;;  (if (empty? coll)\n;;    coll\n;;    (if (sequential? (first coll))\n;;    (concat (flattn (first coll)) (flattn (rest coll)))\n;;    (cons          (first coll)  (flattn (rest coll))))))","problem":28,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(letfn [(f [x]\n            (if (coll? x)\n              (mapcat f x)\n              [x]))]\n    #(f %))","problem":28,"user":"515ef58be4b02c55805ea237"},{"code":"(fn flt\n  [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n     (if (sequential? l)\n       (flt l)\n       [l])\n     (when (sequential? r)\n       (flt r)))))","problem":28,"user":"528b01a0e4b0239c8a67ae89"},{"problem":28,"code":"(fn flattn\n  [s]\n  (loop [l s\n         out nil]\n    (cond\n      (empty? l) out\n      (coll? (first l)) (recur (rest l) (concat out (flattn (first l))))\n      :else (recur (drop-while #(not (coll? %)) l)\n                   (concat out (take-while #(not (coll? %)) l))))))","user":"562fb774e4b0ab312c17ebd9"},{"code":"(fn flat [x] \n  (if (coll? x) \n    (mapcat flat x)\n    [x]\n    ) \n  )","problem":28,"user":"519b7d76e4b02a926d9a436e"},{"problem":28,"code":"#((fn my-flatten [s] (if (coll? (first s))\n    (if (next s)\n      (concat (my-flatten (first s)) (my-flatten (next s)))\n      (my-flatten (first s))\n      )\n    (if (next s)\n      (conj (my-flatten (next s)) (first s))\n      (conj '() (first s))\n      )\n    ))%1)","user":"5cead199e4b0a17bb84e2bd4"},{"problem":28,"code":"(fn fff [s] \n  (loop [result [] rs s]\n    (if (empty? rs)\n      result\n      (if (coll? (first rs)) \n        (recur (into result (fff (first rs))) (rest rs))\n        (recur (conj result (first rs))       (rest rs))\n        )\n)\n)\n)","user":"57d7c894e4b0bd073c2023de"},{"problem":28,"code":"(fn\n  [coll]\n  (seq\n   (reduce (fn my-flatten [v e]\n             (if (coll? e)\n               (reduce my-flatten v e)\n               (conj v e)))\n           []\n           coll)))","user":"55842bd7e4b05c286339e11c"},{"problem":28,"code":"(fn flat [x] (mapcat #(if (coll? %) (flat %) (list %)) x))","user":"54857e3be4b0e286459a11ad"},{"problem":28,"code":"(fn my-flatten [coll]\n  (mapcat (fn [x] (if-not (sequential? x)\n                    (list x)\n                    (my-flatten x)))\n          coll))","user":"557e56aae4b05c286339e0d5"},{"problem":28,"code":"(fn flattenn [l]\n  (if (= '() l)\n    '()\n    (concat\n     (if (coll? (first l))\n       (flattenn (first l))\n       (list (first l)))\n     (flattenn (rest l)))))","user":"55e4487ce4b050e68259b44c"},{"problem":28,"code":"(fn [seq]\n  (loop [seq seq]\n    (if (some #(or (vector? %) (list? %)) seq)\n      (recur (reduce\n                 (fn [acc elm]\n                   (if (or (vector? elm) (list? elm))\n                     (concat acc elm)\n                     (concat acc [elm])))\n                 '()\n                seq))\n      seq)))","user":"5984e7dee4b021a7a535fe43"},{"problem":28,"code":"(fn flatten' [xs]\n  (reduce #(if (coll? %2)\n             (vec (concat %1 (flatten' %2)))\n             (conj %1 %2))\n          [] \n          xs))","user":"4fc4e9b5e4b081705acca352"},{"problem":28,"code":"(fn [input]                                                                                                                                                                                                \n  (letfn [(inner-fn [s]                                                                                                                                                                                          \n            (reduce (fn [r e] (if (sequential? e)                                                                                                                                                                 \n                               (vec (concat r (inner-fn e)))                                                                                                                                                     \n                               (conj r e))) [] s))]                                                                                                                                                              \n    (inner-fn input)))","user":"53403f42e4b085b17e897da8"},{"problem":28,"code":"(fn [xs]\n    (loop [x xs a [] k []]\n      (if (sequential? x)\n        (do (cond (empty? x) (if (empty? k) a (recur (first k) a (rest k)))\n                  (sequential? (first x)) (recur (first x) a (rest x))\n                  :else (recur (rest x) (conj a (first x)) k)))\n        (recur [] (conj a x) k))))","user":"6026d2cae4b0d5df2af22232"},{"problem":28,"code":"(fn [s] (filter (complement coll?) (tree-seq coll? identity s)))","user":"55d50a38e4b0e31453f64a80"},{"problem":28,"code":"(fn flatten-1 [c]\n  (mapcat #(if (coll? %) (flatten-1 %) [%]) c))","user":"5aa1e0f1e4b0d174b936c84e"},{"code":"(fn flat_recur [x]\n  (if\n    (sequential? x)\n    (apply concat (map flat_recur x))\n    (list x)\n  )\n)","problem":28,"user":"52624348e4b03e8d9a4a707e"},{"problem":28,"code":"(fn flat\n     [s]\n     (let [f (first s)\n           r (rest s)]\n       (cond (empty? s) nil\n             ((complement sequential?) f) (cons f (flat r))\n             :else (concat (flat f) (flat r)))))","user":"594bc7d6e4b07ddc2dafae3d"},{"code":"(fn ff[l] \n  (if (empty? l) \n\t\tl \n\t\t(if (coll? (first l)) \n\t\t\t( concat (ff (first l)) (ff (rest l)) )  \n\t\t\t( cons (first l) (ff (rest l)) )\n\t\t)\n\t))","problem":28,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":28,"code":"(fn flat [x] (reduce (fn [y z] (concat y (if (sequential? z) (flat z) (list z)))) '() x))","user":"563b559ee4b0bfe05bf1180d"},{"code":"(fn f [[x & xs :as coll]]\n    (if (empty? coll)\n      []\n      (if (sequential? x)\n        (concat (f x) (f xs))\n        (cons x (f xs)))))","problem":28,"user":"51d7f34fe4b0154f82ab9303"},{"code":"(fn fl [x]\n\t(if (coll? x)\n\t\t(if (= 1 (count x))\n\t\t\t(fl (first x))\n\t\t\t(concat (fl (first x)) (fl (rest x))))\n\t\t[x]))","problem":28,"user":"51dd9370e4b0c33a4e1da40c"},{"problem":28,"code":"(fn pancake-fn [ss]\n               (if (empty? ss)\n                 ss\n                 (let [s (first ss)\n                       pancaked (if (or (string? s) (not (sequential? s)))\n                                  (list s)\n                                  (pancake-fn s))]\n                   (concat pancaked (lazy-seq (pancake-fn (rest ss)))))))","user":"57f904c5e4b0d3187e900936"},{"problem":28,"code":"(fn flatten' [x]\n  (reduce \n   \t(fn [acc e]\n      (cond \n       \t(sequential? e) (apply conj acc (flatten' e))\n       \t:else \t\t\t(conj acc e)))\n   \t[]\n   \tx))","user":"5c1ca3dbe4b0efcb0b05b23b"},{"problem":28,"code":"(fn myflatten [x]\n  (cond (not (sequential? x)) (list x)\n        (empty? x) nil\n        :else (concat (myflatten (first x)) (myflatten (rest x)))))","user":"562d869be4b0a45d2ff8301f"},{"problem":28,"code":"(fn [coll] (\n\t\t(fn [remaining acc]\n\t\t\t(if (empty? remaining)\n\t\t\t\tacc\n\t\t\t\t(let [x (first remaining) r (rest remaining)]\n\t\t\t\t\t(if (sequential? x)\n\t\t\t\t\t\t(recur (concat x r)  acc)\n\t\t\t\t\t\t(recur r (concat acc (list x)))))))\n\t\tcoll '()))","user":"598af379e4b02b9968b84ce6"},{"problem":28,"code":"(fn myflatten [coll]\n  (if (coll? coll)\n    (if (empty? coll)\n      []\n      (concat (myflatten (first coll)) (myflatten (rest coll))))\n    [coll]))","user":"54f4adc8e4b0f2f3c5226e86"},{"problem":28,"code":"(fn myflatten [l]\n  ; l is a collection of collections\n  (if (coll? l)\n    (mapcat myflatten l)\n    [l]\n  )\n)","user":"54c82b27e4b045293a27f645"},{"code":"(fn my-flatten[s]\n  (reduce \n   \t\t(fn [a b] \n          \t(apply conj \n             \ta \n             \t(if (sequential? b)\n                  \t(my-flatten b) \n                  \t[b]))) [] s)\n  )","problem":28,"user":"531490bde4b08068f379ed17"},{"code":"(fn [arr] (filter (complement sequential?) (tree-seq sequential? identity arr)))","problem":28,"user":"52a5d1f3e4b0c58976d9abf1"},{"problem":28,"code":"(fn [input]\n  ((fn in [res coll]\n     (if-not (coll? coll)\n       (conj res coll)\n       (reduce in res coll))) [] input))","user":"56c2c342e4b05cc29241ee85"},{"code":"(fn f [r [a & b]]\r\n  (if a\r\n    (if (coll? a)\r\n      (f (into r (f [] a)) b)\r\n      (f (into r [a]) b))\r\n    r))\r\n[]","problem":28,"user":"4ead2841535d7eef3080731e"},{"code":"(fn f [x]\n  (if (coll? x)\n    (mapcat f x)\n    [x]))","problem":28,"user":"4db1f7d223724b71670a9c07"},{"problem":28,"code":"(fn [str]\n    (letfn [(my-flatten [s]\n                        (reduce (fn [acc x]\n                                  (if (sequential? x)\n                                    (vec (concat acc (my-flatten x)))\n                                    (conj acc x)))\n                                []\n                                s))]\n      (seq (my-flatten str))))","user":"5549ff9ae4b0a04f7929956e"},{"problem":28,"code":"(fn [coll]\n  (if (some sequential? coll)\n    (recur (mapcat (fn [x]\n                     (if (sequential? x)\n                       x\n                       (list x))) coll))\n    coll))","user":"57908d94e4b0ebec4cfb75ac"},{"code":"#(letfn [(f [s] \n            (cond (empty? s) nil \n            (not (coll? (first s))) (conj (f (rest s)) (first s))\n       \t    :else (concat (f (first s)) (f (rest s)))))]\n   (f %))","problem":28,"user":"4f92de49e4b0dcca54ed6cb2"},{"problem":28,"code":"(fn junction [xs] \n\t(reduce (fn [acc x]\n\t\t(if (coll? x)\n\t\t\t(concat acc (junction x))\n\t\t\t(concat acc (cons x ()))))\n\t        ()\n\t        xs))","user":"5c387c51e4b0d62ef62d9f83"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (mapcat my-flatten x)\n    [x]))","user":"56826ebce4b0945ebc182a93"},{"problem":28,"code":"(fn [data]\n  (reverse \n   (reduce \n    (fn func [coll item] \n      (if (sequential? item) \n        (reduce func coll item) \n        (conj coll item)))\n    '() data )))","user":"5832be57e4b089d5ab817c86"},{"problem":28,"code":"(fn flatten-seq [coll]\n  (if (empty? coll)\n    ()\n    (let [f (first coll)\n          r (rest coll)]\n      (if (sequential? f)\n        (concat (flatten-seq f) (flatten-seq r))\n        (cons f (flatten-seq r))))))","user":"6051bcfae4b056659d634203"},{"code":"(fn my-flat [[h & t]] \n  (if h\n    (if (sequential? h)\n      (concat (my-flat h) (my-flat t))\n      (cons h (my-flat t)))))","problem":28,"user":"538557aee4b06839e8705f02"},{"problem":28,"code":"(fn [input]\n   (loop [first-sec input\n          rest-sec []\n          result []]\n     ;(pprint {:first first-sec :rest rest-sec :res result})\n     (cond \n      (and (empty? first-sec) (empty? rest-sec))\n      result\n      \n      (empty? first-sec)\n      (recur (first rest-sec) (rest rest-sec) result)\n      \n      (sequential? (first first-sec))\n      (recur (first first-sec) (cons (rest first-sec) rest-sec) result)\n      \n      :else\n      (recur (rest first-sec) rest-sec (conj result (first first-sec))))))","user":"546c4c5fe4b00cfc9eacc178"},{"code":"(fn [coll]\n  (loop [acc '() cur coll]\n    (let [[x & more] cur] \n      (if (empty? cur)\n        (reverse acc)\n      \t(if (sequential? x)\n        \t(recur acc (concat x more))\n        \t(recur (cons x acc) more))))))","problem":28,"user":"52976262e4b02ebb4ef75041"},{"problem":28,"code":"(fn f [c]\n  (if (coll? c)\n    (apply concat (map f c))\n    [c]))","user":"52bacfa8e4b07a9af57922d6"},{"problem":28,"code":"(fn [x]\n   (letfn [(flatten-x [coll new-coll]\n             (if-let [f (first coll)]\n               (let [point (if (coll? f)\n                             (flatten-x f [])\n                             (list f))]\n                 (flatten-x (rest coll) (into new-coll point)))\n               new-coll))]\n     (flatten-x x [])))","user":"57689c23e4b0a07e8fc180d6"},{"problem":28,"code":"(fn my-flatten \n  ([seq] \n   (println seq)\n   (reduce \n    (fn [xs s] \n      (if (coll? s) \n        (reduce conj xs (my-flatten s)) \n        (conj xs s)))\n    [] \n    seq)))","user":"536f96e3e4b0fc7073fd6e83"},{"code":"(fn [k]\n(let [g #(apply concat (for [x %] \n                 (if (or (vector? x) (list? x))  x (list x) ) ) ) ]\n   (last (take 10 (iterate g k)))\n  ))","problem":28,"user":"51e3cf8ee4b0efabf93c02a3"},{"code":"(fn my-flatten [mylist]\n    (filter (complement sequential?)\n            (rest (tree-seq sequential? seq mylist))))","problem":28,"user":"4e9a3a03535dbda64a6f6b70"},{"problem":28,"code":"(fn my-flatten \n  [seq]\n  (loop [seq seq list1 '()]\n    (if (not-empty seq)\n      (if (sequential? (first seq))\n        (recur (rest seq) (concat list1 (my-flatten (first seq))\n                           ))\n        (recur (rest seq) (concat list1 (list (first seq))))\n        )\n      list1))\n  \n  )","user":"5772ddb0e4b0979f896515d4"},{"problem":28,"code":"(fn my_flatten\n  [s]\n  (loop [[hd & tl] s flattened_s []]\n    (if (nil? hd)\n      flattened_s\n      (if (sequential? hd)\n        (recur tl (concat flattened_s (my_flatten hd)))\n        (recur tl (concat flattened_s [hd]))\n      )\n\n    )\n  )\n)","user":"5f6b8222e4b02876ed9fd052"},{"problem":28,"code":"(fn ! [seq]\n    \n      (if(or (seq? seq) (vector? seq))\n        (if(= 0 (count seq)) ()\n          (concat (! (first seq)) (! (rest seq)))) \n                  (list seq)))","user":"546fa7a7e4b00cfc9eacc1b1"},{"code":"(fn flat [xs]\r\n  (if (sequential? xs)\r\n    (mapcat  flat xs)\r\n    (list xs)))","problem":28,"user":"4ddbfb8a535d02782fcbea00"},{"problem":28,"code":"(fn flattern_seq [x] (if(sequential? x)\n                         (if(not-empty x) (concat (flattern_seq (first x)) (flattern_seq (rest x))))\n                         (list x))\n  )","user":"5515b68de4b055c2f668d4ef"},{"code":"(fn [coll]\r\n  (letfn [(flat [[x & xs]]\r\n            (lazy-seq (concat\r\n                        (if (coll? x) (flat x) (list x))\r\n                        (when-not (empty? xs) (flat xs)))))]\r\n    (flat coll)))","problem":28,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(let [f (fn [ff c] \n  (if (sequential? c)\n    (mapcat #(ff ff %) c)\n    (list c))\n  )]\n  (partial f f))","problem":28,"user":"4ec12577535dfed6da9c6da8"},{"code":"(fn f [c]\n  (if (coll? c)\n    (apply concat (map f c))\n    (conj '() c)))","problem":28,"user":"4fb1325de4b081705acca276"},{"problem":28,"code":"(fn myflatten [x]\n  (if (sequential? x)\n    (if (empty? x)\n      `()\n      (concat\n       (myflatten (first x))\n       (myflatten (rest  x))))\n    (conj `() x)))","user":"585a7cb2e4b0f14aab7c874e"},{"problem":28,"code":"(fn self [x]\n  (if (coll? x)\n    (mapcat self x)\n    [x]))","user":"54d492dbe4b0a52adc2e2001"},{"problem":28,"code":"(fn my-flat\n  [coll]\n  (sort (reduce (fn [acum item]\n            (if (coll? item)\n              (into acum (my-flat item))\n              (conj acum item)))\n          '()\n          coll)))","user":"5adbbf89e4b0837691e92bf4"},{"problem":28,"code":"(fn flattener [lst]\n   (if (empty? lst)\n      ()\n      (if (coll? (first lst))\n         (concat (flattener (first lst)) (flattener (rest lst)))\n         (cons (first lst) (flattener (rest lst))))))","user":"5a653f80e4b0512ff01cd9b2"},{"problem":28,"code":"(fn [data] (filter (complement sequential?) (rest (tree-seq sequential? seq data))))","user":"4f43894ee4b0d7d3c9f3fd21"},{"code":"(fn my-flatten\n  [input]\n  (mapcat #(if (coll? %) (my-flatten %) (list %)) input))","problem":28,"user":"5300b750e4b0d8b024fd3711"},{"code":"(fn [s]\n  (loop [s s]\n    (if (some coll? s)\n      (recur (reduce (fn [accum val]\n                       (if (coll? val)\n                         (into accum val)\n                         (conj accum val))) [] s))\n      (list* s))))","problem":28,"user":"51a132cee4b0b292b01ee3ff"},{"code":"(fn [s] (filter #(not (coll? %)) (tree-seq coll? identity s)))","problem":28,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn flt [x]\n  (let [l (first x) r (next x)]\n    (concat \n      (if (coll? l)\n        (flt l)\n        [l])\n      (when (coll? r)\n        (flt r)))))","problem":28,"user":"533f09e1e4b085b17e897d9a"},{"problem":28,"code":"(fn f [[h & t]]\n\t(if h\n\t\t(if (coll? h)\n\t\t\t(concat (f h) (f t))\n\t\t\t(cons h (f t)))))","user":"53bb512ce4b047364c044503"},{"problem":28,"code":"(fn [coll] (remove coll? (tree-seq coll? identity coll)))","user":"5582dfb6e4b05c286339e10d"},{"code":"(fn flat-ten [xs]\n\t(if (empty? xs)\n    \t'()\n\t\t(concat\n\t\t\t(if (coll? (first xs))\n        \t\t(flat-ten (first xs))\n        \t\t(list (first xs)))\n     \t\t(flat-ten (rest xs)))))","problem":28,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":28,"code":"(fn [coll]\n  (reduce\n   (fn my-flatten [v e]\n     (if (coll? e)\n       (reduce my-flatten v e)\n       (conj v e)))\n   [] coll))","user":"567874f3e4b05957ce8c617c"},{"problem":28,"code":"(fn f [s]\r\n  (if (sequential? s)\r\n    (mapcat f s)\r\n    [s]))","user":"546e1142e4b00cfc9eacc199"},{"code":"(fn flatit [s]\n  (if (empty? s)\n    ()\n  \t(lazy-cat\n      (let [f (first s)] (if (coll? f) (flatit f) (list f)))\n      (flatit (rest s))\n    )\n  )\n)","problem":28,"user":"525f51bde4b0cb4875a45dc8"},{"problem":28,"code":"(fn [s]\n  (loop [s_ s a []]\n    (cond (empty? s_) a\n          (sequential? (first s_)) (recur (concat (first s_)(rest s_)) a)\n          :else (recur (rest s_) (conj a (first s_))))))","user":"5762bf13e4b0994c1922fbae"},{"problem":28,"code":"(fn _flatten [x]\n(mapcat #(if (or (list? %) (vector? %)) (_flatten %) (list %)) x))","user":"541074f1e4b01498b1a719ac"},{"problem":28,"code":"(fn unpack [coll] (reduce #(concat % (if (sequential? %2) (unpack %2) (list %2))) [] coll))","user":"53a739b0e4b0ef122a8689d0"},{"problem":28,"code":"(fn my-flatten [col]\n  (reduce (fn [acc i]\n            (if (coll? i)\n              (vec (concat acc (my-flatten i)))\n              (conj acc i))) [] col))","user":"54f5aa4ce4b0f2f3c5226e94"},{"problem":28,"code":"(fn flat [x]\n  (when-let [s (seq x)]\n    (if (coll? (first s))\n      (concat (flat (first s)) (flat (rest s)))\n      (cons (first s) (flat (rest s))))))","user":"560dfa8de4b05f002753df46"},{"code":"(fn [a] (if (not-any? coll? a) a\n    (recur (reduce (fn [x y] \n            (concat x (if (coll? y) y [y]))) '() a))\n  ))","problem":28,"user":"4f1595da535d64f603146444"},{"code":"(fn [aSeq]\n          (loop [answ [], bSeq aSeq]\n             (if-let [item (first bSeq)]\n                     (if (sequential? item)\n                         (recur answ (concat item (rest bSeq)))\n                         (recur (conj answ item) (rest bSeq)))\n                     answ)))","problem":28,"user":"4e463703535dc968683fc4b2"},{"code":"(fn f [s] (reduce #(concat %1 (if (sequential? %2) (f %2) (list %2))) '() s))","problem":28,"user":"5191ac45e4b0d428d29dc1b6"},{"problem":28,"code":"(fn my-flatten [coll]\n  (reduce (fn [val c]\n            (if (coll? c)\n              (into val (my-flatten c))\n              (conj val c)))\n          []\n          coll))","user":"561a2940e4b053970a773b04"},{"problem":28,"code":"(fn [xs]\n  (loop [r []\n         s xs]\n    (if s\n      (let [x (first s)]\n        (if-not (sequential? x)\n          (recur (conj r x) (next s))\n          (recur r (concat x (next s)))))\n      r)))","user":"54acf5c7e4b09f271ff37cdd"},{"problem":28,"code":"(fn my-flat \n  ; flattens a sequence\n  [xs]\n  (lazy-seq\n   (reduce (fn holdon [col v]\n             (if (sequential? v)\n               (reduce holdon col v)\n               (conj col v))) [] xs)))","user":"5bbbcecee4b0a20761a23611"},{"problem":28,"code":"(fn f \n  ([] [])\n  ([x & ys]\n    (if (sequential? x) \n\t  (concat (apply f x) (apply f ys)) \n      (cons x (apply f ys)))))","user":"59279a89e4b072a2710fced3"},{"code":"(fn f [[h & r]]\n  (let [H (if (sequential? h) (f h) [h])]\n    (if (seq r)\n      (concat H (f r))\n      H)))","problem":28,"user":"52951156e4b02ebb4ef7501b"},{"code":"(fn this [s]\n  (if (sequential? s)\n    (reduce (fn [ls el] (into ls el)) [] (map this s))\n    [s]))","problem":28,"user":"5390952be4b0b51d73faae9c"},{"problem":28,"code":"(fn myflatten2\n  [myseq]\n  (if (not (coll? myseq))\n    [myseq]\n    (apply concat (map myflatten2 myseq) )\n\n    )\n  )","user":"53fe459ae4b0de5c418485f4"},{"problem":28,"code":"(fn myflat [coll]\n  (let [h (first coll)\n        t (next coll)]\n    (concat\n     (if (sequential? h)\n       (myflat h)\n       [h])\n     (when (sequential? t)\n       (myflat t)))))","user":"5785c1d4e4b0ebec4cfb74e1"},{"problem":28,"code":"(fn [c]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq c))))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn __ [lst]\n    (let [c (apply concat (map #(if (coll? %) % [%]) lst))]\n    (if (some coll? c) (recur c) c)\n    )\n)","problem":28,"user":"503f872ee4b00d1a725ff2ac"},{"problem":28,"code":"(fn f [m] (if (coll? m)\n             (mapcat f m)\n             [m]))","user":"5cc80598e4b0ccb061962840"},{"problem":28,"code":"(fn myflat [xs]\n  (if (coll? xs)\n    (mapcat myflat xs)\n    [xs]))","user":"5573ffb5e4b0aa18f790f3fd"},{"problem":28,"code":"(fn [c] (->> c\n             ((fn flatit [coll]\n                (->> coll\n                     (reduce #(if (coll? %2)\n                                (concat (flatit %2) %)\n                                (conj % %2))\n                             '())\n                     seq))) reverse))\n\n; niet zo netjes met die fn [c] er nog eens rond puur om te reversen\n; probleem is dat ik reverse niet in flatit kan steken, omdat in recursie van flatit dan ook reverse gebeurt\n; miserie is gewoon dat seqs enkel vooraan items bijdoen en niet achteraan","user":"5afb3426e4b0cc2b61a3bcf5"},{"code":"(fn flattner [coll]\n  (lazy-seq   \n    (if (coll? coll)\n        (mapcat flattner coll)\n        (list coll))))","problem":28,"user":"528b08efe4b0239c8a67ae8a"},{"code":"(fn [in]\n    (letfn [(flatten-me [out x]\n                        (if (sequential? x)\n                            (reduce flatten-me out x)\n                            (conj out x)))]\n            (flatten-me [] in)))","problem":28,"user":"500e7063e4b04a05d36fcc07"},{"code":"#(filter (complement sequential?)\n\t          (rest (tree-seq sequential? seq %)))","problem":28,"user":"50eec6ece4b06330c1f87c63"},{"problem":28,"code":"(fn f [s]\n  (loop [r []\n         s' s]\n    (if (empty? s')\n      r\n      (let [fs (first s')]\n        (recur (if (or (seq? fs) (vector? fs))\n                 (into [] (concat r (f fs)))\n                 (conj r fs))\n               (rest s'))))))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn flatn [s] (reduce (fn [fs e] (cond (sequential? e) (concat fs (flatn e))\n                                         :else (concat fs [e]))) [] s))","problem":28,"user":"50dfb660e4b061dbdced7228"},{"code":"(fn fltn [v]\n  (if (coll? v)\n    (mapcat fltn v)\n    (list v)))","problem":28,"user":"4fba7d1ee4b081705acca2e0"},{"problem":28,"code":"(fn my-flatten [c]\n  (if (some coll? c)\n    (my-flatten (apply concat\n                           (for [e c] (if (coll? e) (into [] e) [e]))))\n    c))","user":"54357066e4b0b6b47310fcfd"},{"code":"(fn flat [x]\n  (cond (empty? x) '()\n        (coll? (first x))\n            (concat (flat (first x))\n                    (flat (rest x)))\n        true (cons (first x) (flat (rest x)))))","problem":28,"user":"4e5fda32535d8ccf87e9fe4e"},{"code":"(fn x [items]\r\n   (let [head (first items) tail (next items)]\r\n     (concat \r\n       (if (sequential? head)\r\n         (x head)\r\n         [head])\r\n       (when (sequential? tail)\r\n         (x tail)))))","problem":28,"user":"502ac868e4b0614b5299611a"},{"code":"(fn denest [xs]\n  (if (sequential? xs)\n    (if (empty? xs)\n      ()\n      (concat (denest (first xs)) (denest (rest xs))))\n    (list xs)))","problem":28,"user":"52cca96ae4b07d0d72b2736e"},{"problem":28,"code":"(fn myflatten [x]\n  (if (sequential? x)\n    (mapcat myflatten x)\n    [x]))","user":"5532a04ee4b09218d5f44f82"},{"code":"(fn myFlatten\n  [x]\n  (filter #(not (sequential? %))\n    (tree-seq sequential? seq x)))","problem":28,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn flt [x]\n  (reverse ((fn [a l]\n    (if (= (quote ()) l)\na\n(if (coll? (first l))\n(recur (concat (reverse (flt (first l))) a) (rest l))\n(recur (conj a (first l)) (rest l)))))\n(quote ()) x)))","problem":28,"user":"4ed2b168535d44c135fd68dd"},{"code":"(letfn [(make-flat [x]\n    (println x)\n    (cond\n      (not (or (seq? x) (vector? x))) [x]\n      (empty? x) []\n      :else\n        (apply concat (map make-flat x))))] make-flat)","problem":28,"user":"50a2f901e4b029e8bace362a"},{"code":"(fn [x]\n  (let [func (fn func [x newseq]\n               (if (empty? x)\n                 newseq\n                 (let [lefth \n                 \t\t(if (sequential? (first x))\n                   \t\t\t(func (first x) newseq)\n                          \t(conj newseq (first x)))]\n                   (func (rest x) lefth))))]\n   \t(func x [])\n    ))","problem":28,"user":"538d464ee4b0b51d73faae69"},{"problem":28,"code":"(fn [coll]\n  (loop [coll (seq coll), acc ()]\n    (if (empty? coll)\n      (if (some sequential? acc)\n        (recur (reverse acc) ())\n        (reverse acc))\n      (let [x (first coll), f (if (sequential? x) #(into %1 (seq %2)) conj)]\n        (recur (rest coll) (f acc x))))))","user":"552356fae4b0882d96d091af"},{"code":"(fn flat [s]\n  (cond (empty? s) '()\n        (vector? (first s)) (concat (flat (first s)) (flat (rest s)))\n        (list? (first s)) (concat (flat (first s)) (flat (rest s)))\n        :else (concat (list (first s)) (flat (rest s)))))","problem":28,"user":"51c1229be4b0c9c822882944"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (if (empty? xs)\n      (if (sequential? x)\n          (flat (seq x))\n        (list x))\n    (if (sequential? x)\n        (concat (flat (seq x)) (flat xs))\n      (concat (list x) (flat xs)))))","user":"54d2892fe4b0e8a36923e5f7"},{"code":";; Copied from the flatten source. Had trouble figuring this out on my own.\n#(filter (complement sequential?)\n          (rest (tree-seq sequential? seq %)))","problem":28,"user":"50d46d53e4b09cc622d65a69"},{"problem":28,"code":"(fn flatMap [result input]\n     (if (coll? input)\n       (reduce flatMap result input)\n       (concat result [input]))\n) '()","user":"57b1b8c8e4b0fbc9809a2756"},{"problem":28,"code":"(fn [ss]\n  (letfn [(toto [xs]\n            (cond\n              (empty? xs) '()\n\n              (coll? (first xs))  (concat (toto (first xs)) (toto (rest xs)))\n\n              :else\n              (cons (first xs) (toto (rest xs)))\n              ))]\n    (toto ss)\n    ))","user":"5fa6db67e4b0fa27300f3dd2"},{"code":"(fn flatn [coll] \r\n  (if (empty? coll) \r\n    coll \r\n    (if (sequential? (first coll)) \r\n    (concat (flatn (first coll)) (flatn (rest coll))) \r\n    (cons (first coll)  (flatn (rest coll))))))","problem":28,"user":"4f507682e4b03ad3f0c10d05"},{"problem":28,"code":"(fn my-flatten [lst]\n    (cond\n      (empty? lst) ()\n      (coll? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n      :else (cons (first lst) (my-flatten (rest lst)))))","user":"59dd38a8e4b0a0ac046f2503"},{"problem":28,"code":"(fn [coll]\n  (let [f* (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x))\n             )]\n    (reduce f* [] coll)\n    ))","user":"583f2e4de4b089d5ab817dcb"},{"problem":28,"code":"(fn [l]\n  ((fn flat-aux [l i acc]\n   (if (= i (count l))\n     acc\n     (if (instance? java.util.Collection (nth l i))\n       (flat-aux l \n         (inc i)\n         (concat acc (flat-aux (nth l i) 0 '())))\n       (flat-aux l (inc i) (concat acc (list (nth l i)))))))\n   l 0 '()))","user":"54651faee4b01be26fd746d6"},{"problem":28,"code":"(fn func [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (func r))\n          :else (concat (func f) (func r)))))","user":"5bba6571e4b0a20761a235e9"},{"code":"(fn flt [coll]\n  (let [[l & r] coll]\n    (concat \n    (if (sequential? l)\n      (flt l)\n      [l])\n      (when (sequential? r)\n        (flt r)))))","problem":28,"user":"52f07ccee4b05e3f0be25edf"},{"code":"(fn f [xs] (mapcat #(if (coll? %) (f %) [%]) xs))","problem":28,"user":"4e4ea0f6535dc968683fc4e6"},{"code":"(fn flat [col] (mapcat #(if (coll? %) (flat %) [%]) col))","problem":28,"user":"50be9b4ae4b00fb48fed2ef6"},{"problem":28,"code":"(fn my-flatten [to-flatten]\n    (reduce (fn [seq x]\n              (if (or (list? x) (vector? x))\n                (apply conj seq (my-flatten x))\n                (conj seq x)))\n            []\n            to-flatten))","user":"57f6e666e4b0d3187e9008f2"},{"problem":28,"code":"(fn [collection]\n  (filter\n    (complement coll?)\n    (tree-seq coll? identity collection)))","user":"540c6a8ae4b0addc1aec6702"},{"problem":28,"code":"(fn unlist [s]\n    (if (coll? s)\n      (mapcat unlist s)\n      [s]))","user":"5619a4d0e4b053970a773afd"},{"problem":28,"code":"(fn fltn\n  ([s] (fltn s '()))\n  ([s n] (if (empty? s)\n           (reverse n)\n           (fltn (rest s)\n                 (if (sequential? (first s))\n                   (reverse (fltn (first s) n))\n                   (conj n (first s)))))))","user":"531c6e72e4b08068f379eda0"},{"problem":28,"code":"(fn flattenn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"59971e2de4b07157cc8daacc"},{"problem":28,"code":"(fn my-flatten\n  ([coll]\n    (my-flatten coll []))\n  ([coll new-coll]\n  \t(if (empty? coll)\n      new-coll\n  \t  (if (coll? (first coll))\n        (my-flatten (rest coll) (my-flatten (first coll) new-coll))\n        (do\n          (my-flatten (rest coll) (conj new-coll (first coll))))))))","user":"550174b5e4b07d26eda61d73"},{"problem":28,"code":"(fn [x]\n  (letfn [(d [y]\n            (mapcat #(if (coll? %) (d %) [%]) y))]\n    (d x)))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":28,"code":"(fn flatn [[first & rest]]\n\t(cond\n\t\t(nil? first) nil\n\t\t(coll? first) (concat (flatn first) (flatn rest))\n\t\t:else (conj (flatn rest) first)))","user":"5aeb0b44e4b0cc2b61a3bbee"},{"problem":28,"code":"(fn my-flatten\n  [coll] (mapcat (fn [x] (if (coll? x) (my-flatten x) [x])) coll))","user":"60396c95e4b0d5df2af222f4"},{"code":"#(reverse (reduce \n  (fn flatten-stuff [result value] \n\t\t(if (sequential? value)\n\t\t\t(reduce flatten-stuff result value)\n\t\t\t(conj result value))) '() %))","problem":28,"user":"50b63309e4b0a86f8358ca68"},{"code":"(fn [x]\n  (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) (list x))))","problem":28,"user":"536c7470e4b0fc7073fd6e3e"},{"code":"(fn this\n  ([xs] (this xs []))\n  ([xs acc]\n    (if (empty? xs)\n      acc\n      (let [[hd & tl] xs]\n        (if (sequential? hd)\n          (recur (concat hd tl) acc)\n          (recur tl (conj acc hd)))))))","problem":28,"user":"4f2e0369e4b0d6649770a064"},{"problem":28,"code":"(fn f [c] (apply list (reduce #(if (coll? %2) (into [] (concat %1 (f %2))) (conj %1 %2)) [] c)))","user":"4faf97d8e4b081705acca258"},{"problem":28,"code":"(fn flttn [x]\n  (apply concat\n         (map\n          #(if (sequential? %) (flttn %) [%])\n          x)))","user":"54c31f1be4b045293a27f609"},{"problem":28,"code":"(fn abc\n  [L]\n  (if (coll? L)\n    (if (empty? L)\n      L\n      (concat (abc (first L)) (abc (rest L)))\n    )\n    (list L)\n  )\n)","user":"56bb3a4be4b0f26550335951"},{"code":"(fn flt [coll]\r\n  (let [l (first coll) r (next coll)]\r\n    (concat \r\n      (if (sequential? l)\r\n        (flt l)\r\n        [l])\r\n      (when (sequential? r)\r\n        (flt r)))))","problem":28,"user":"4df407c3535d08e6dec9fe2e"},{"problem":28,"code":"(fn [tree] (filter (complement sequential?) (tree-seq sequential? seq tree)))","user":"5a61bf79e4b0512ff01cd97b"},{"problem":28,"code":"(fn flat [xs]\n  (mapcat #(if (sequential? %) (lazy-seq (flat %)) [%]) xs))","user":"5ab16992e4b073f1774425c4"},{"problem":28,"code":";; tree-seq does exactly what we need: it descends through the data structure as if it were a tree\n#(remove coll? (tree-seq coll? identity %))\n\n;; more verbose, but not to an extreme\n#_#(seq (reduce (fn it [acc x] (if (coll? x) (reduce it (cons acc x)) (conj acc x))) [] %))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn [l] \n  (let [\n        mf (fn mf [coll]\n            (reduce (fn [result item]\n                      (if (coll? item)\n                        (concat (mf item) result )\n                        (conj result item)))\n                    '() \n                    coll)\n          )]\n      (reverse (mf l))\n  ))","problem":28,"user":"5348236ee4b084c2834f4a54"},{"code":"(fn flat [s] (reduce (fn [acc, el] (cond\n                               (coll? el) (concat acc (flat el))\n                               :default (concat acc (list el))\n                               \n                               ) ) '() s))","problem":28,"user":"4fb03cf4e4b081705acca262"},{"problem":28,"code":"(fn f [s] \n  (reduce \n    #(if (or (seq? %2) (vector? %2))\n        (concat %1 (f %2)) \n        (reverse (conj (reverse %1) %2)))\n    '()\n    s))","user":"55ad59cde4b03311e7b732a7"},{"problem":28,"code":"(fn squash [a]\n  (cond (empty? a) nil\n        (sequential? (first a)) (concat (squash (first a)) (squash (rest a)))\n        :else (cons (first a) (squash (rest a)))))","user":"541b41d1e4b01498b1a71a65"},{"code":"(fn fl [xs]                                                                                                                                                                   \n  (when-let [s  (seq xs)]\n    (if (coll? (first s))\n      (concat (fl (first s)) (fl (rest s)))\n      (cons (first s) (fl (rest s))))))","problem":28,"user":"4f91f5b1e4b0dcca54ed6ca7"},{"code":"(fn [s]\n  (reverse\n  ((fn [f r acc]\n      (cond\n         (and (not (sequential? f)) (not (seq r))) (cons f acc)\n         (and (not (sequential? f)) (seq r)) (recur (first r) (rest r) (cons f acc))\n         (and (not (seq f)) (not (seq r))) acc\n         (not (seq f)) (recur (first r) (rest r) acc)\n         (not (seq r)) (recur (first f) (rest f) acc)\n   true (recur (first f) (cons (rest f) r) acc))) '() s '())))","problem":28,"user":"4fa1183fe4b0dcca54ed6d57"},{"problem":28,"code":"(fn re-flatten2 [s]\n    (if-not (coll? s)\n      (list s)\n      (reduce #(apply conj %1 (re-flatten2 %2)) [] s )\n      )\n    )","user":"56004deee4b04bb52996e164"},{"problem":28,"code":"(fn myflatten [myseq] \n  ((fn myflattenr [restseq result] \n    (if (empty? restseq) \n         result \n        (if (coll? (first restseq)) \n            (myflattenr (concat (first restseq) (rest restseq)) result) \n            (myflattenr (rest restseq) (concat result (list (first restseq))))\n            )))\n   myseq '()))","user":"55076bf6e4b021ccfedb96a6"},{"code":"#(filter (comp not sequential?)\n         (rest (tree-seq sequential? seq %)))","problem":28,"user":"51933b41e4b0c663c5d86ca2"},{"code":"(fn flat [se] (if (coll? se) (mapcat flat se) (list se)))","problem":28,"user":"52bf0116e4b07a9af5792328"},{"problem":28,"code":"(fn flt [aseq] \n  (cond \n   (empty? aseq) '()\n   (coll? (first aseq)) (concat (flt (first aseq)) (flt (rest aseq)))\n   :else (cons (first aseq) (flt (rest aseq)))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":28,"code":"(fn f [l] (apply concat (map #(if (coll? %) (f %) (vector %)) l)))","user":"52e16face4b09f7907dd1421"},{"problem":28,"code":"(fn [lst] (let [f1 (fn f0 [out in] (if (empty? in) out (let [e1 (first in)] (if (or (seq? e1)(vector? e1)) (f0 (into out (f0 [] e1)) (rest in)) (f0 (conj out e1) (rest in))))))] (reverse (f1 '() lst))))","user":"55f1d5dfe4b06e875b46ce38"},{"code":"(fn flat[x] ( if (coll? x) (reduce #(concat % (flat %2)) [] x) (vector x)))","problem":28,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":28,"code":"(fn f [l] \n  (if (coll? l) (mapcat f l) (list l)))","user":"5dd35dcbe4b0948ae9d9ad5f"},{"code":"(fn flat [x]\n  (if (coll? x)\n    (mapcat flat x)\n    [x]))","problem":28,"user":"4ec812d9535d6d7199dd36f0"},{"problem":28,"code":"(fn flat1 [seqn] (if (empty? seqn) seqn (concat (if (sequential? (first seqn)) (flat1 (first seqn)) (list (first seqn))) (flat1 (rest seqn)))))","user":"55a0e139e4b0acc240e31504"},{"code":"(fn fl [L] (if (sequential? L) (reduce concat '() (map fl L)) [L]))","problem":28,"user":"522dd30ee4b0a102974208c3"},{"code":"(fn flatten-seq [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"517a025ce4b01aacecbecbe6"},{"code":"(fn my-flatten [coll]                                                                                                    \n        (when-let [s (seq coll)]                                                                                                 \n          (let [e (first s)]                                                                                                     \n               (if (or (seq? e) (vector? e))                                                                                     \n                   (concat (my-flatten e) (my-flatten (rest s)))                                                                 \n                   (cons e (my-flatten (rest s)))))))","problem":28,"user":"4e360072535deb9a81d77f30"},{"code":"(fn flat [s]\n  (if (coll? s)\n  (mapcat flat s)\n   [s])\n  )","problem":28,"user":"52d8eb78e4b09f7907dd139d"},{"problem":28,"code":"(fn fl [seq]\n  (if (coll? seq)\n\t(if (empty? seq)\n      '()\n      (concat (fl (first seq)) (fl (rest seq))))\n    (list seq)))","user":"5681afaae4b0945ebc182a87"},{"code":"(fn flt\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f6cf933e4b07046d9f4efc2"},{"problem":28,"code":"(fn [data] (filter (fn [x] (if (sequential? x) false true)) (rest (tree-seq sequential? seq data))))","user":"56ef11efe4b04a395b9a045b"},{"code":"(fn ftn [coll]\n  (let [x (first coll) y (next coll)]\n    (concat\n      (if (sequential? x)\n        (ftn x)\n        [x])\n      (when (sequential? y)\n        (ftn y)))))","problem":28,"user":"4f9a5e1ee4b0dcca54ed6d09"},{"code":"#(letfn [(flat [coll]\n                             (lazy-seq\n                              (when-let [c (seq coll)]\n                                (let [% (first c)]\n                                  (if (sequential? %)\n                                    (concat (flat %) (flat (rest c)))\n                                    (cons % (flat (rest c))))))))]\n               (if (sequential? %) (flat %) %))","problem":28,"user":"52baf490e4b07a9af57922db"},{"problem":28,"code":"(fn flat [se]\n   (concat\n    (if (coll? (first se))\n      (flat (first se))\n      (list (first se)))\n    (if (empty? (rest se))\n      '()\n      (flat (rest se)))))","user":"57b59d77e4b0fbc9809a27ae"},{"code":"(fn f [s] (if (coll? s) (reduce #(concat % (f %2)) [] s) [s]))","problem":28,"user":"52c73194e4b0c2d177d6211e"},{"problem":28,"code":"(fn flatty [e]\n  (cond\n    (not (sequential? e)) [e]\n    (every? (complement sequential?) e) e\n    :else (reduce #(concat %1 (flatty %2)) [] e)))","user":"5649b1b0e4b0284900eef646"},{"problem":28,"code":"(fn fla [x]\n  (if (coll? x)\n    (if (empty? x)\n      ()\n      (concat (fla (first x)) (fla (rest x))))\n    (list x)))","user":"52b36925e4b0c58976d9ad0b"},{"code":"(fn flat [tree]\n  (if (sequential? tree)\n    (mapcat flat tree)\n    [tree]))","problem":28,"user":"50294c28e4b0b33e9bf6fdef"},{"problem":28,"code":"(fn[x]\n(filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"#(\n  (fn func [in rs]\n  (if (coll? in)\n    (if (empty? in)\n      rs\n      (if (coll? (first in))\n        (func (rest in) (func (first in) rs))\n        (func (rest in) (conj rs (first in)))\n        ))\n    (conj rs in)\n    ))\n  % []\n)","problem":28,"user":"4f504739e4b03ad3f0c10d00"},{"code":"(fn flatten-single-level [single-line]\n        (loop [output '[] \n               n 0]\n          (if (< n (count single-line))\n            (let [data (nth single-line n)]\n              (if (coll? data)\n                (recur (vec (concat output (flatten-single-level (vec data)))) (inc n))\n                (do \n                  (recur  (conj output data) (inc n)))               \n                ))\n            output\n            )))","problem":28,"user":"504f0036e4b0e7ad84dbc4aa"},{"code":"(fn f [list]\n  (let [head (first list) tail (next list)]\n    (concat\n      (if (sequential? head) (f head) [head])\n      (if (sequential? tail) (f tail) nil)\n        )))","problem":28,"user":"5277da8ee4b03e8d9a4a7514"},{"problem":28,"code":"(fn f [l]\n  (if (and (coll? l) (empty? l)) (list)\n  (if (coll? l)\n    (concat\n      (f (first l)) (f (rest l)))\n    (list l)))\n  )","user":"54857657e4b0e286459a11ac"},{"code":"(fn flat[x]\n  (if x\n    (let [[h & t] x]\n      (concat \n        (if (sequential? h) \n          (flat h) \n          [h]) \n        (flat t)))))","problem":28,"user":"4f1fd734535d64f6031464a5"},{"problem":28,"code":"(fn [coll] \n  (reduce \n   (fn my-flat [result x] \n     (if (coll? x) \n       (reduce my-flat result x) \n       (conj result x)))\n   [] coll))","user":"54980edae4b0b312c081ff79"},{"problem":28,"code":"(fn my-flat-2 [coll]\n   (reduce (fn f [r m]\n             (if (coll? m)\n               (reduce f r (seq m))\n               (conj r m)))\n           [] coll))","user":"5d247902e4b02ea6f0fb6a24"},{"problem":28,"code":"(fn [s]\n      (filter (complement sequential?) \n              (rest (tree-seq sequential? seq s))))","user":"54b67463e4b05787c3b163bc"},{"code":"; \"like flatten\"\n(fn smash\n  ([t] (smash t []))\n  ([t s]\n    (if (empty? t)\n      s\n      (let [f (first t)\n            r (rest t)\n            l (if (sequential? f)\n              (into s (smash f))\n                (conj s f))]\n          (recur r l)))))\n\n; hindsight version\n; #(filter (complement sequential?)\n;          (tree-seq sequential? seq %))","problem":28,"user":"4f24957ae4b0d66497709fed"},{"code":"(fn flat[x]\n  (cond \n  (not (coll?  x)) (list x)\n  (empty? x) x\n        \n        :else (concat (flat (first x)) (flat (rest x)))))","problem":28,"user":"4e8b557c535d65386fec2119"},{"problem":28,"code":"(fn flt [coll]\n  (cond\n    (empty? coll) '()\n    (sequential? (first coll)) (concat (flt (first coll)) (flt (rest coll)))\n    :default (cons (first coll) (flt (rest coll)))\n    ))","user":"5756f324e4b02ea1147992e8"},{"problem":28,"code":"(fn my-flatten [s] (if (or (seq? s) (vector? s)) (mapcat my-flatten s) [s]))","user":"5446c89ce4b032a45b8693b5"},{"problem":28,"code":"(fn flatten-seq\n  [xs]\n  (reduce #(if (coll? %2)\n             (concat %1 (flatten-seq %2))\n             (concat %1 (list %2)))\n          '() xs))","user":"54c72b19e4b045293a27f636"},{"code":"(fn flattify [collection] \n  (if (coll? collection)\n    (mapcat #(flattify %) collection)\n    [collection]))","problem":28,"user":"4f294c48e4b0d6649770a023"},{"problem":28,"code":"(fn flat [list]\n  (mapcat #(if (coll? %) (flat %) [%]) list))","user":"556be3dce4b09a3098a524f7"},{"problem":28,"code":"(fn __\n  [coll]\n  (reduce #(if (coll? %2)\n             (apply conj %1 (__ %2))\n             (conj %1 %2))\n          []\n          coll))","user":"55e206f3e4b050e68259b429"},{"problem":28,"code":"(fn [t]\n(letfn [\n        (fn-nonseq [col th]\n          (let [fst (first th) rst (rest th)]\n            (cond\n              (sequential? fst)\n                #(fn-seq col th)\n              (empty? rst)\n                (conj col fst)\n              :else\n                #(fn-nonseq (conj col fst) rst))))\n        (fn-seq ([col th]\n          (let [fst (first th) rst (rest th)]\n            (cond\n              (sequential? fst)\n                #(fn-seq col (lazy-cat fst rst)) \n              (empty? rst)\n                (conj col fst)\n              :else\n               #(fn-nonseq (conj col fst) rst))))\n                ([th] #(fn-seq [] th)))\n        ] (trampoline fn-seq t)))","user":"541377bee4b01498b1a719e2"},{"problem":28,"code":"(fn fltn \r\n  ([in-seq] (fltn in-seq ()))\r\n  ([in-seq acc]\r\n    (let [[h & t] in-seq]\r\n      (if (empty? t) \r\n        (if (coll? h)\r\n          (recur h acc)\r\n          (concat acc [h]))\r\n        (if (coll? h)\r\n          (recur (concat h t) acc)\r\n          (recur t (concat acc [h])))))))","user":"58cbdc3be4b03c36ff7e5856"},{"code":"(fn [x]\r\n  (filter (complement sequential?)\r\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4df0524e535d08e6dec9fe17"},{"problem":28,"code":"(fn f1 [x ]\n  \n  (loop [ rst x res [] ]\n    (if \n      rst\n      (if \n        (coll? (first rst))\n        (recur (next rst) (into [] (concat  res (f1 (first rst)  )  ) ) )\n        (recur (next rst) (conj  res  (first rst ) ))\n        )\n       res\n      )\n    \n    )\n  )","user":"5735ac67e4b0cd1946bd102b"},{"code":"(fn f [x]\n  (lazy-seq\n   (letfn [(flat [coll]\n             (when-let [s (seq x)]\n               (let [h (first s)]\n                 (if (sequential? h)\n                   (concat (f h) (f (rest s)))\n                   (cons h (f (rest s)))))))]\n     (if (sequential? x) (flat x) x))))","problem":28,"user":"52b0323ee4b0c58976d9acc6"},{"problem":28,"code":"(fn flat\n  [s]\n  (letfn [(helpflat [s]\n            (loop [s s\n                   res []]\n              (if (nil? (first s))\n                res\n                (let [el (first s)]\n                  (if (coll? el)\n                      (recur (rest s) (into res (helpflat el)))\n                      (recur (rest s) (conj res  el)))))))]\n    (helpflat s)))","user":"5a8fd113e4b05369db4d2542"},{"problem":28,"code":"(fn flattener [item] (if (coll? item) (mapcat flattener item) (list item)))","user":"539dcb24e4b0b51d73faaf3d"},{"problem":28,"code":"(fn  flat [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (if (coll? (first s))\n        (concat (flat (first s)) (flat (rest s)))\n        (cons (first s) (flat (rest s)))))))","user":"56a8b818e4b07966d5a8a06d"},{"code":"(fn flat [s]\n  (let [new-s (reduce (fn [res x] (if (coll? x) \n                                      (concat res x)\n                                      (concat res [x]))) [] s)]\n    (if (= new-s s) \n        s\n        (recur new-s))))","problem":28,"user":"5300f68de4b0d8b024fd3714"},{"code":"(fn myflatten [tree]\n  (let [listify #(if (coll? %1) %1 (list %1))]\n    (if (some coll? tree)\n      (myflatten (apply concat (map listify tree)))\n      tree)))","problem":28,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"problem":28,"code":"(fn f [x]\n  (cond\n   (empty? x) x\n   (sequential? (first x)) (concat (f (first x)) (f (rest x)))\n   :else (cons (first x) (f (rest x)))))","user":"55236ad6e4b0882d96d091b1"},{"problem":28,"code":"(fn baru [x] \n\t(if (coll? x)\n      (mapcat baru x)\n      [x]))","user":"5e639b4be4b0fd0acd1586a2"},{"problem":28,"code":"(fn [list] (filter (complement coll?) (rest (tree-seq coll? identity list))))","user":"5b337ff4e4b025bcb146f339"},{"problem":28,"code":"(fn flat \n  ([l] (flat l []))\n  ([l resp]\n   (if (= l []) \n     resp\n     (let [a (first l)\n           r (rest l)]\n       (if (or (seq? a) (vector? a))\n         (flat r (flat a resp))\n         (flat r (conj resp a)))))))","user":"574f1c24e4b02ea114799255"},{"problem":28,"code":"(fn flt [x]\n  (let [[h & r] x]\n    (concat\n     (if (sequential? h)\n       (flt h)\n       [h])\n     (when-not (empty? r)\n       (flt r))))\n  )","user":"58b36131e4b0ebc645576d21"},{"problem":28,"code":"(fn flatten [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"581e61b0e4b04b46fc4b0f28"},{"problem":28,"code":"(fn flat [coll]\n  (if (= 0 (count coll))\n      '()\n      (if (coll? (first coll))\n          (concat (flat (first coll)) (flat (rest coll)))\n          (cons (first coll) (flat (rest coll))))))","user":"547f8736e4b0c51c1f4d731d"},{"problem":28,"code":"#(reverse (reduce (fn flatten-item [accum item]\n            (if (coll? item)\n              (reduce flatten-item accum item)\n\n              (conj accum item)))\n\n           '()\n           %))","user":"57addf3ae4b0b8559636fca4"},{"code":"(fn my-flat [s] (mapcat #(if (not (or (coll? %) (seq? %))) (list %) (my-flat %)) s))","problem":28,"user":"52bdf6bde4b07a9af579230d"},{"problem":28,"code":"#(reverse ((fn fl[x] (reduce (fn [c v] (if (coll? v) (concat (fl v) c) (conj c v))) () x)) %))","user":"5b007e46e4b0cc2b61a3bd3c"},{"problem":28,"code":"(fn flat [s]\n  (if ((comp not sequential?) s)\n    [s]\n    (apply concat (map flat s))))","user":"5a3d7afae4b0447ef91cc5a6"},{"problem":28,"code":"(fn myFlatten [x]\n (cond\n  (vector? x) (mapcat myFlatten x)\n  (seq? x) (mapcat myFlatten x)\n  :else [x]))","user":"54299d4be4b01498b1a71b3d"},{"problem":28,"code":"(fn myflatten [xs] (if (sequential? xs) (mapcat myflatten xs) [xs]))","user":"5410cb36e4b01498b1a719b8"},{"code":"(fn [a]\n  (filter (complement sequential?)(rest(tree-seq sequential? seq a))))","problem":28,"user":"5374adc3e4b06d7f452d9e27"},{"code":"(fn flat [the-list]\n\t(if (list? the-list)\n\t\t(if (empty? the-list)\n\t\t\t'() ;if its empty return empty list\n\t\t\t(concat (flat (first the-list)) \n\t\t\t\t(flat (rest the-list))\n\t\t\t)\n\t\t)\n\t\t(if (vector? the-list)\n\t\t\t(if (empty? the-list)\n\t\t\t\t'() ;if its empty return empty list\n\t\t\t\t(concat (flat (pop the-list))\n\t\t\t\t\t(flat (last the-list))\n\t\t\t\t)\n\t\t\t)\n\t\t\t(cons the-list '()) ;base case where the-list is just one element\n\t\t)\n\t)\n)","problem":28,"user":"51701a9ce4b034fe8eaf70f5"},{"problem":28,"code":"(fn flat\n  [coll]\n  (loop [[x & xs] (seq coll) acc []]\n    (if (coll? x)\n      (recur (concat x xs) acc)\n      (if xs\n        (recur xs (conj acc x))\n        (conj acc x)))))","user":"56edf2dde4b04a395b9a044b"},{"code":"(fn flat [lst]\n  (if (empty? lst) lst\n    (let [[a & b] lst]\n      (if (or (list? a) (vector? a))\n        (concat (flat a) (flat b))\n        (cons a (flat b))))))","problem":28,"user":"500cb910e4b05f7c30cfa698"},{"code":"(fn flt[l] \n  (if (coll? l) \n    (if (empty? l) '()\n      (concat (flt (first l)) (flt (rest l))))\n    (list l)))","problem":28,"user":"4f8b05d2e4b02e764a0a5176"},{"problem":28,"code":"(fn f [s] (mapcat #(if (sequential? %) (f %) (list %)) s))","user":"54a1f494e4b09f271ff37c52"},{"problem":28,"code":"#(filter (complement sequential?) (\ntree-seq sequential? seq\n  % ))","user":"5a6afb1de4b0512ff01cda2f"},{"problem":28,"code":"(fn my-flatten [lst]\n  (loop  [in lst out nil]\n    (if (empty? in)\n      out\n      (let [fst (first in)]\n        (if (or (seq? fst) (vector? fst)) \n          (recur (rest in ) (concat out (my-flatten fst)))\n          (recur (rest in) (concat out [fst])))))))","user":"5bec37e2e4b0f319e2d7ec96"},{"code":"#(letfn [(f [xs result]\n  (cond (empty? xs) result\n        (coll? (first xs)) (f (first xs) (f (rest xs) result))\n        :else (cons (first xs) (f (rest xs) result))))]\n  (f % '()))","problem":28,"user":"4dd6fa35535d2dad7130b5cd"},{"code":"(fn f[c] (reduce (fn [t e] (if (coll? e) (concat t (f e))(concat t [e]))) [] c))","problem":28,"user":"51f4d46ee4b0fca5e8b48243"},{"problem":28,"code":"(fn fltn [c]\n  (if (not (coll? c))\n    (conj '() c)\n    (loop [z c, r '()]\n      (if (empty? z)\n        r\n        (recur (rest z) (concat r (fltn (first z))))\n      )\n    )\n  )\n)","user":"58606948e4b0f14aab7c87d5"},{"problem":28,"code":"(fn f [l]\n  (reduce (fn [ret curr]\n            (if (coll? curr)\n              (apply conj ret (f curr))\n              (conj ret curr)))\n          []\n          l))","user":"5883584ae4b0f1effa3b7674"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst) ()\n    (coll? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (conj (my-flatten (rest lst)) (first lst)))\n  )","user":"5bc8c033e4b07a9b28b100ca"},{"code":"(fn flat [s]\r\n  (mapcat\r\n    (fn [x]\r\n      (if (coll? x) (flat x)\r\n          (list x))) s))","problem":28,"user":"4e02bee8535d04ed9115e791"},{"code":"(fn flat [x]\n  (let [flat_x\n    (reduce concat\n      (map (fn [y]\n        (if (not (or (list? y) (vector? y)))\n          (list y)\n          y))\n        x))]\n  (if (= flat_x x)\n    x\n    (flat flat_x))))","problem":28,"user":"4df1e213535d08e6dec9fe20"},{"problem":28,"code":"(fn flttn [sq]\n  (loop [res [] [frst & rst] sq]\n    (if (empty? rst)\n      (if (coll? frst)\n      \t(concat res (flttn frst))\n        (conj res frst))\n    (if (coll? frst)\n      (recur res (concat (flttn frst) rst))\n      (recur (conj res frst) rst)))))","user":"6023a3abe4b0d5df2af22212"},{"problem":28,"code":"(fn my-flatten [x]\n   (if (not (coll? x))\n     (list x)\n     (loop [coll x\n            result nil]\n       (if coll\n         (recur (next coll)\n                (concat result\n                        (my-flatten (first coll))))\n         result))))","user":"5808ee16e4b0a837a8b30d16"},{"problem":28,"code":"#(filter (complement sequential?) (tree-seq sequential? identity % ))","user":"54ca582be4b057c6fda3a259"},{"code":"(fn flat [s]\n  (if (sequential? s)\n    (reduce #(concat % (flat %2)) '() s)\n    [s]))","problem":28,"user":"50aab057e4b056ee0193586b"},{"code":"(fn flat [x] (\n    if (coll? (first x)) \n      (if (empty? (rest x)) (flat (first x)) (concat (flat (first x)) (flat (rest x)) ))\n      (if (empty? (rest x)) \n        (list (first x)) \n        (cons (first x) (flat (rest x))))\n))","problem":28,"user":"50ef311fe4b0a78662fa2651"},{"problem":28,"code":"(fn my-flat\n  ([xs]\n   (prn xs)\n   (my-flat (rest xs) (first xs) []))\n  ([xs el r]\n   (prn el)\n   (prn xs)\n   (if (nil? el)\n     r\n     (if (coll? el)\n       (my-flat (remove nil? (conj xs (next el))) (first el) r)\n       (my-flat (rest xs) (first xs) (conj r el))))))","user":"580fbaade4b0f478707a05c0"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (sequential? coll)\n    (mapcat my-flatten coll)\n    [coll]))","user":"608256d7e4b0736b099e42da"},{"code":"#(letfn [(flat [coll]\n                  (lazy-seq\n                   (when-let [c (seq coll)]\n                     (let [% (first c)]\n                       (if (sequential? %)\n                         (concat (flat %) (flat (rest c)))\n                         (cons % (flat (rest c))))))))]\n    (if (sequential? %) (flat %) %))","problem":28,"user":"5224cf82e4b01819a2de42ef"},{"problem":28,"code":"(fn flat [[x & xr]]\n  (cond\n    (nil? x) '()\n    (coll? x) (concat (flat x) (flat xr))\n    :else (cons x (flat xr))))","user":"5989e080e4b021a7a535fed6"},{"problem":28,"code":"(fn flatten' [s]\n  (let [step (fn [c]\n               (when-let [s (seq c)] (let [fs (first s) rs (rest s)]\n                 (if (sequential? fs)\n                   (concat (flatten' fs) (flatten' rs))\n                   (cons fs (flatten' rs))))))]\n    (lazy-seq (step s))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":28,"code":"(fn [x] (reverse ((fn fltn [x]\n                      (reduce #(if (coll? %2) \n                                 (concat (fltn %2) %1) \n                                 (conj %1 %2)) \n                              '() x)) x)))","user":"5006c169e4b0678c553fc48d"},{"problem":28,"code":"(fn Flatten [s]\n  (if (seq s)\n    (if (sequential? (first s))\n      (concat (Flatten (first s) )(Flatten (rest s)))\n      (cons (first s) (Flatten (rest s))))))","user":"579c8ad1e4b05b1deef9ae0c"},{"problem":28,"code":"(fn flat [list]\n   (reduce\n    #(if (sequential? %2)\n      (concat %1 (flat %2))\n      (conj (into [] %1) %2))\n    []\n    list))","user":"55c6fd60e4b0e31453f649c9"},{"code":"(fn flatten2 [[x & xs :as all]] (cond (empty? all) [] (not (coll? x)) (cons x (flatten2 xs)) :else (concat (flatten2 x) (flatten2 xs))))","problem":28,"user":"50723bbae4b0e3170b5a868b"},{"problem":28,"code":"(fn flat [x] (if(sequential? x)(mapcat flat x) [x]))","user":"562e9f5fe4b0ab312c17ebbd"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat (if (sequential? l) (flt l) [l])\n            (when (sequential? r) (flt r)))))","problem":28,"user":"4e84a7dd535db62dc21a62e2"},{"problem":28,"code":"(fn [coll]\n  (letfn [(f [x]\n\t\t  \t(cond (sequential? x) (mapcat f x)\n                  :else [x]))]\n    (f coll)))","user":"5468d932e4b00cfc9eacc13e"},{"problem":28,"code":"(fn [arr]\n  (let [inner-flatten (fn inner-flatten [acc xs]\n                        (let [head (first xs) tail (rest xs)]\n                          (if (nil? head)\n                            acc\n                            (if (sequential? head)\n                              (->\n                                (inner-flatten acc head)\n                                (inner-flatten tail)\n                               )\n                              (recur (conj acc head) tail)\n                              )\n                            )\n                          )\n                        )\n        ]\n  (inner-flatten [] arr)\n    )\n  )","user":"53e1040be4b0d874e779ae4e"},{"code":"(fn [c] (filter #(false? (coll? %))\n   (tree-seq coll? identity c)))","problem":28,"user":"506617c3e4b03d366d7cb2ab"},{"code":"(fn [x]\n  (filter (complement sequential?)\n  (rest (tree-seq sequential? seq x))))","problem":28,"user":"4dadb891c9a9d6ed3699dc57"},{"problem":28,"code":"(fn flat [xs]\n  (if (empty? xs)\n    nil\n    (if (sequential? (first xs))\n      (concat (flat (first xs)) (flat (rest xs)))\n      (cons (first xs) (flat (rest xs))))))","user":"57fe836ee4b0d3187e9009d2"},{"code":"(fn flt[coll] \r\n          (let [l (first coll) r (next coll)] \r\n               (concat \r\n                (if (sequential? l)\r\n                    (flt l)\r\n                    [l]) \r\n                (when (sequential? r)\r\n                  (flt r)))))","problem":28,"user":"50a0d1e4e4b08df8156e9e51"},{"code":"(fn [x] (filter (complement sequential?)\n               (rest (tree-seq sequential? seq x))))","problem":28,"user":"50daffc3e4b02e6ac9592c72"},{"problem":28,"code":"(fn foo [x] (if (sequential? x) \n                      (mapcat foo x)\n                      [x]))","user":"58cf8f97e4b03c36ff7e58b7"},{"code":"(fn fl\n           [coll]\n           (if (empty? coll) \n               coll\n               (let [f (first coll)\n                    r (rest coll)]\n                    (if (coll? f)\n                        (concat (fl f) (fl r))\n                        (concat (list f) (fl r))))))","problem":28,"user":"4f1af7e4535d64f603146471"},{"problem":28,"code":"(fn my-flatten [s]\n  (lazy-seq\n   (let [sq (seq s)\n         f (first sq)\n         r (rest sq)]\n     (if (coll? f)\n       (if (empty? f)\n         '()\n         (concat (my-flatten f) (my-flatten r)))\n       (if (nil? f)\n         '()\n         (cons f (my-flatten r)))))))","user":"58d48df8e4b03c36ff7e5941"},{"problem":28,"code":"(fn flattn [s]\n  (if (coll? s)\n    (if (empty? s) '() (concat (flattn (first s)) (flattn (rest s))))\n   [s]))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":28,"code":"(fn f [[h & t]]\n  (cond\n    (nil? h) ()\n    (sequential? h) (concat (f h) (f t))\n    true (cons h (f t))))","user":"5baaae06e4b0a20761a23464"},{"code":"(fn flat [xs]\n  (if (empty? xs)\n    nil\n    (if (sequential? (first xs))\n      (concat (flat (first xs)) (flat (rest xs)))\n      (conj (flat (rest xs)) (first xs)))))","problem":28,"user":"523f1245e4b01c266ffa7f95"},{"problem":28,"code":"(fn [s]\n  (loop [c 0\n         current-seq s\n         parent-seq nil\n         flattened-seq '()]\n    (if (= c (count current-seq))\n      (do (if (nil? parent-seq)\n            flattened-seq\n            (recur 0 parent-seq nil flattened-seq)))\n      (if (sequential? (nth current-seq c))\n        (recur 0 (nth current-seq c) (drop (inc c) current-seq) flattened-seq)\n        (recur (inc c) current-seq parent-seq (concat flattened-seq (list (nth current-seq c))))))))","user":"57d57f65e4b0bd073c2023b3"},{"code":"(fn f [x] \n  (if (coll? x) \n    (if (= (count x) 0) \n      x \n      (concat (f (first x)) \n            (f (rest  x)))\n      ) \n    (list x)\n    )\n  )","problem":28,"user":"5149c2f1e4b0829bd132edb0"},{"problem":28,"code":"(fn myflatten [s] (filter (fn [x] (not (coll? x))) (tree-seq coll? identity s)))","user":"54bad522e4b0ed20f4ff6eb8"},{"problem":28,"code":"(fn flattr [s] (if (coll? s) (reduce concat (map flattr s)) (list s)))","user":"5e03fd15e4b0a607a9a45d66"},{"code":"(fn [& xs]\n  (condp = (-> xs first first first)\n      1   '(1 2 3 4 5 6)\n      \\a '(\"a\" \"b\" \"c\")\n      '((:a)) '(:a)))","problem":28,"user":"4fa4f2f2e4b081705acca1aa"},{"problem":28,"code":"(fn flat [xs]\n   (if (empty? xs)\n     xs\n  (let [[x & xs] xs]\n    (if (not (coll? x))\n      (cons x (flat xs))\n      (if (empty? x)\n        x\n        (concat (flat x) (flat xs)))))))","user":"54f9920ee4b01ecee9d8883f"},{"problem":28,"code":"(fn my-flatten [n]\n  (let [[x & xs] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (my-flatten x) (my-flatten xs))\n     :else (cons x (my-flatten xs)))))","user":"52b9e920e4b07a9af57922c9"},{"problem":28,"code":"(fn f [coll]\n  (mapcat #(if (coll? %)\n            (f %)\n            [%]) coll))","user":"54159032e4b01498b1a719f5"},{"problem":28,"code":"(fn f [xs]\n    (if-not (sequential? xs)\n      (cons xs '())\n      (apply concat (map f xs))))","user":"56bcc2b2e4b0f26550335965"},{"problem":28,"code":"(fn flattenW [x]\n   (mapcat  #(if (sequential? %) (flattenW %) [%]) x))","user":"5b69baf9e4b0c6492753e78f"},{"problem":28,"code":"(fn flat [s]\n  (cond\n   (= s '()) '()\n   (sequential? (first s)) (concat (flat (first s)) (flat (rest s)))\n   :else (cons (first s) (flat (rest s)))))","user":"5438795ee4b032a45b869313"},{"code":"(fn flat [lst]\n  (letfn [(helper [acc v]\n                  (if (coll? v)\n                    (concat acc (flat v))\n                    (conj (vec acc) v)))]\n         (reduce helper [] lst)))","problem":28,"user":"50611456e4b0dc10a69545a5"},{"problem":28,"code":"(fn \n  [s]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq s))))","user":"556e3b73e4b09a3098a52514"},{"problem":28,"code":"(fn f [a]\n  (loop [l a acc []]\n    (if (empty? l)\n      acc\n      (if (coll? (first l))\n        (recur (rest l) (apply conj acc (f (first l))))\n        (recur (rest l) (conj acc (first l)))))))","user":"570eeb66e4b0b0fb43fd06fa"},{"problem":28,"code":"(fn f\n  ([o] (f [] o))\n  ([n o]\n   (cond\n     (not (or (vector? o) (list? o))) (conj n o)\n     (empty? o) n\n     :else (cond\n             (not (or (vector? (first o)) (list? (first o))))\n               (reduce f (conj n (first o)) (rest o))\n             :else\n               (reduce f (reduce f n (first o)) (rest o))))))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn flt [x] (if (= x [])\n                  '()\n                  (if (sequential? x)\n                      (concat (flt (first x)) \n                              (flt (rest x )))\n                      (list x) )))","problem":28,"user":"4fdd27f3e4b05e33b9224f78"},{"code":"(fn [crud]\n  (filter (complement sequential?)\n    (tree-seq sequential? seq crud)))","problem":28,"user":"4f617f66e4b0defedf855fc0"},{"problem":28,"code":"(fn flatt [coll]\n  (loop [f (first coll) r (rest coll) result []]\n    (if (coll? f)\n      (recur (first r) (rest r) (into result (flatt f)))\n      (if (not (empty? r))\n        (recur (first r) (rest r) (conj result f))\n        (if (nil? f)\n          result\n          (conj result f))))))","user":"5c06f6e3e4b0bdcf453d16bb"},{"problem":28,"code":"(fn my-flatten \n  [coll]\n  (reduce (fn \n            [r x] \n            (into r \n                  (if (coll? x) (my-flatten x) [x])))\n          [] coll))","user":"5a0a04eee4b0eab8c0448935"},{"problem":28,"code":"(fn flatn [x]\n  (when x\n    (let [current (first x) remaining (next x)]\n    (concat \n     (if (sequential? current)\n        (flatn current)\n        [current])\n        (flatn remaining)))))","user":"5b445421e4b02d533a91bc40"},{"code":"(fn flat [lst]\n    (if (empty? lst)\n        nil\n        (if (sequential? (first lst))\n            (concat (flat (first lst)) (flat (rest lst)))\n            (cons (first lst) (flat (rest lst))))))","problem":28,"user":"4f7fc9a1e4b033992c121bee"},{"code":"(fn [x]\n  (letfn [\n    (flatn [coll]\n    (if (empty? coll) \n      coll \n      (if (not (sequential? (first coll)))\n        (cons\n        (first coll)  (flatn (rest coll)))\n        (concat\n        (flatn (first coll)) (flatn (rest coll))))))]\n  (flatn x)))","problem":28,"user":"4f9b5a1ce4b0dcca54ed6d16"},{"problem":28,"code":"(fn flat [x]\n  (reduce #(if (coll? %2)\n             (concat % (flat %2))\n             (concat % (list %2)))\n          ()\n          x))","user":"53aef31ce4b047364c04447b"},{"code":"#(\n(fn f [acc x]\n  (let [y (first x)]\n    (cond\n     (nil? y) acc\n     (coll? y) (concat (f acc y) (f acc (rest x)))\n     :else (cons y (f acc (rest x)))\n     )\n    )\n  )\n  '() %)","problem":28,"user":"515f8a0de4b0e2be8aa20bce"},{"problem":28,"code":"(fn myFlatten [x]\n  (cond \n   (empty? x) '()\n   (not (coll? (first x))) (conj (myFlatten (rest x)) (first x))\n   :else (concat (myFlatten (first x)) (myFlatten (rest x)))))","user":"5aa5951ae4b0d174b936c899"},{"problem":28,"code":";#(filter (complement sequential?) (tree-seq sequential? seq %))\n\n;(fn flat [x] (if (coll? x) (mapcat flat x) (list x)))\n\n;(fn flat [x] (if (coll? x) (apply concat (apply map flat x)) (list x)))\n\n;(fn flat [x] (if (coll? x) (apply concat (apply map flat (list x))) (list x)))\n\n(fn flat [x] (if (coll? x) (apply concat (map flat x)) (list x)))","user":"5ed03b7fe4b016b56eae05ae"},{"code":"(fn f [coll]\n  (mapcat #(if (sequential? %) (f %) (list %)) coll))","problem":28,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn flat ([xs] (flat xs []))\r\n  ([xs acc]\r\n     (if (empty? xs) acc\r\n         (if (coll? (first xs))\r\n             (concat acc (flat (first xs)) (flat (rest xs)))\r\n             (concat (conj acc (first xs)) (flat (rest xs)))))))","problem":28,"user":"4e8681b7535dae1a5effa438"},{"problem":28,"code":"(fn [$, x]\n             (if (empty? x)\n               (reverse $)\n               (if (sequential? (first x))\n                 (recur\n                   $\n                   (concat (first x) (rest x))\n                 )\n                 (recur\n                   (conj $ (first x))\n                   (rest x)\n                 )\n               )\n             )\n           )\n         '()","user":"53dbc8bee4b094d41abdfef5"},{"code":"(fn [xs]\n  ((fn my-flatten [xs acc]\n     (cond\n      (not (sequential? xs)) (concat acc (list xs))\n      (empty? xs) acc\n      :else (my-flatten (rest xs) (my-flatten (first xs) acc))))\n   xs '()))","problem":28,"user":"530578ede4b0d8b024fd3760"},{"code":"reduce (fn f [l i] (if (sequential? i) (reduce f l i) (conj l i))) []","problem":28,"user":"4ed4673f535d10e5ff6f52ca"},{"code":"(fn flat [input]\n    (let [[x & xs] input]\n    (cond\n         (empty? input) '()\n         (coll? x) (concat (flat x) (flat xs))\n         :else (cons x (flat xs))\n     )\n     )\n )","problem":28,"user":"51d1111ce4b067c36548635f"},{"problem":28,"code":"(fn flat [coll]\n  (let [h (first coll), t (rest coll)]\n    (cond\n      (empty? coll) nil\n      (not (sequential? h)) (cons h (flat t))\n      :else (concat (flat h) (flat t)))))","user":"56e4991fe4b03a7c14b85a4f"},{"code":"(fn f [xs]\n      (if (coll? xs)\n        (mapcat f xs)\n        [xs]))","problem":28,"user":"4f2a7174e4b0d6649770a03e"},{"code":"(fn [x] (let [s? #(instance? clojure.lang.Sequential %)] (filter (complement s?) (tree-seq s? seq x))))","problem":28,"user":"4ed19f00535d44c135fd68d1"},{"code":"(fn f [c] (mapcat #(if (coll? %) (f %) (list %)) c))","problem":28,"user":"4f0891a2535dcb61093f6c3b"},{"code":"(fn my-flatten [col]\n  (loop [x (first col) y (rest col) v []]\n    (if (sequential? x)\n      (recur (first x) (concat (rest x) y) v)\n      (do\n        (if-not (empty? y)\n          (recur (first y) (next y) (conj v x))\n          (seq (conj v x)))))))","problem":28,"user":"4f6e7073e4b07046d9f4efd8"},{"code":"(fn flattenr [sq]\n  (if-not (empty? sq)\n    (concat\n     (if (coll? (first sq))\n      (flattenr (first sq))\n      (list (first sq)))\n     (flattenr (rest sq)))))","problem":28,"user":"51b24defe4b02f8f128bb963"},{"code":"(fn flat [x]\n  (if (coll? x)\n    (reduce concat (map flat x))\n    (list x)))","problem":28,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":28,"code":"(fn flats\n  [coll]\n  (loop\n    [s []\n     curcoll coll]\n    (if (empty? curcoll)\n      s\n      (let [first-elem (first curcoll)]\n        (if (sequential? first-elem)\n          (recur (into s (flats first-elem)) (rest curcoll))\n          (recur (conj s first-elem) (rest curcoll)))))))","user":"5c05cae7e4b0bdcf453d16a3"},{"code":"(fn mywalk1 [node]\n                  (if (sequential? node)\n                    (mapcat mywalk1 node)\n                    (list node)\n                 ))","problem":28,"user":"5364ab34e4b0243289761e64"},{"problem":28,"code":"; (fn flat [xs] (mapcat #(if (coll? %) (flat %) [%]) xs))\n\n(fn flat [x] (if (coll? x) (mapcat flat x) [x]))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":28,"code":"(fn flat [n]\n  (let [[x & y] n]\n    (cond (empty? n) '()\n          (coll? x) (concat (flat x) (flat y))\n          :else (cons x (flat y)))))","user":"5839f079e4b089d5ab817d48"},{"problem":28,"code":"(fn [data]\n\t(if (some coll? data)\n\t\t(recur (reduce \n\t\t\t#(into %1 (if (coll? %2) %2 [%2]))\n\t\t\t[] data))\n\t\tdata))","user":"58409e47e4b089d5ab817dee"},{"problem":28,"code":"(fn [xs]\n    (filter (complement sequential?)\n            (rest (tree-seq sequential? seq xs))))","user":"5ea806d5e4b00a66d4a951b9"},{"problem":28,"code":"(fn [lst]\n  (loop [lst lst\n         acc []]\n    (cond\n      (empty? lst) acc\n      (seq? (first lst)) (recur (concat (first lst) (rest lst)) acc)\n      (vector? (first lst)) (recur (concat (first lst) (rest lst)) acc)\n      :else (recur (rest lst) (conj acc (first lst))))))","user":"51c116d4e4b0c9c822882942"},{"problem":28,"code":"(fn flat [in] \n        (if (sequential? in)\n           (if (empty? in)\n             nil\n             (concat (flat (first in)) (flat (rest in)))\n           )           \n           [in]\n        )\n    )","user":"5f3e58dae4b004f08c61c555"},{"problem":28,"code":"#(letfn [(flat [e]\n           (when-let [s (seq e)]\n             (if (sequential? (first e))\n               (concat (flat (first e)) (flat (rest e)))\n               (cons (first e) (flat (rest e))))))]\n  (flat %))","user":"576d398be4b0979f8965155d"},{"code":"(fn flat [x]\n  (cond\n    (empty? x) '()\n    (or (seq? (first x)) (vector? (first x))) (concat (flat (first x)) (flat (rest x)))\n    :else (concat (list (first x)) (flat (rest x)))))","problem":28,"user":"5012aefce4b0c8732600222a"},{"problem":28,"code":"(fn [c]\n  (let [f* (fn f [acc v]\n             (if (coll? v)\n               (reduce f acc (seq v))\n               (conj acc v))\n             )]\n    (reduce f* [] c)))","user":"5954edcbe4b066ee0a44af15"},{"problem":28,"code":"(fn [collection]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq collection))))","user":"5dcbd629e4b02b31cc3da3bd"},{"problem":28,"code":"(fn flat [lst]\n  (mapcat #(if (coll? %) (flat %) (vector %)) lst))","user":"5cebafbbe4b0a17bb84e2be6"},{"code":"#(let [step (fn step [e] (cons e (when (sequential? e) (mapcat step e))))] (filter (complement sequential?) (step %)))","problem":28,"user":"50e8cac5e4b0ebbe794eb7ef"},{"problem":28,"code":"(fn f [[h & t]]\n  (cond \n    (nil? h) ()\n    (sequential? h) (concat (f h) (f t))\n    true (cons h (f t))))","user":"606f005ae4b069485764de1b"},{"code":"(fn [xs]\n  (filter (complement sequential?)\n     (rest (tree-seq sequential? seq xs))))","problem":28,"user":"4e513758535dc968683fc4f3"},{"code":"#(filter (complement sequential?) (tree-seq sequential? identity %))\n\n;;; struggled a bit, but at least I understood version from stdlib","problem":28,"user":"4fe88f78e4b07c9f6fd12c45"},{"code":"(fn this [s] (reduce (fn [res i] (concat res (cond (coll? i) (this i) :else (list i))) ) '() s))","problem":28,"user":"511b9e81e4b00c2a1fa7ff6e"},{"problem":28,"code":"(fn fl [col]\n  (if (sequential? col)\n    (mapcat fl col)\n    [col]))","user":"53a83c74e4b047364c044426"},{"problem":28,"code":"(fn [seq]\n  (loop [func #(if (sequential? %) % [%])\n         list seq]\n    (if (empty? (filter sequential? list))\n      list\n      (recur func (mapcat func list)))))","user":"5716cc16e4b07c98581c3b02"},{"code":"(fn flatn [list]\n  (if (empty? list)\n      list\n    (let [tail (flatn (rest list))\n          head (first list)]\n      (if (or (seq? head) (vector? head))\n          (concat (flatn head) tail)\n        (cons head tail)))))","problem":28,"user":"505cc50ce4b0e6aca564be00"},{"problem":28,"code":"(fn flaten [x]\n  (if (empty? x)\n    '()\n    (let [head (first x)]\n      (if-not (sequential? head)\n        (conj (flaten (rest x)) head)\n        (concat (flaten head) (flaten (rest x)))\n        )\n      )\n    )\n  )","user":"54a1d643e4b09f271ff37c50"},{"problem":28,"code":"(fn flat\n  [x] \n  (if (coll? x) \n    (mapcat flat x) \n    [x]\n  )\n)","user":"54f3970fe4b050824f58f5c5"},{"problem":28,"code":"#(loop[lst %\n       res '()]\n   (cond\n    (empty? lst) res\n    (sequential? (first lst)) (recur (concat (first lst) (rest lst)) res)\n    :else\n    (recur (rest lst) (concat res (list (first lst))))))","user":"56acfee5e4b03c432f18734f"},{"code":"(fn flat [x]\n    (if (and (coll? x) (not (empty? x)))\n      (mapcat flat x)\n      (conj [] x)))","problem":28,"user":"4fea8741e4b0140c20fb9c09"},{"problem":28,"code":"(fn recursive-flatten [s] \n   (if (sequential? s) \n     (apply concat (map recursive-flatten s)) \n     [s]))","user":"5beb8e28e4b0f319e2d7ec8e"},{"code":"(fn\r\n  [x]\r\n  (filter (complement sequential?)\r\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f5155a3e4b03ad3f0c10d1b"},{"problem":28,"code":"(fn [s]\n  (loop [result []\n         remain (rest s)\n         current (first s)]\n    (cond\n     (sequential? current) (recur result (concat (rest current) remain) (first current))\n     (empty? remain) (apply conj result (and current [current]))\n     :else (recur (apply conj result (and current [current])) (rest remain) (first remain)))))","user":"59699da7e4b069c0a1a197eb"},{"problem":28,"code":"(fn myflat [sq]\n  (if (coll? sq)\n    (apply concat (map myflat sq))\n    [sq]))","user":"57457b1ce4b009280f9f2b4c"},{"problem":28,"code":"(fn flattn [s]\n    (cond\n      (and (sequential? s) (empty? s)) nil\n      (sequential? s) (concat (flattn (first s)) (flattn (rest s))) \n      :else (list s)))","user":"587abe0de4b01531a375eaef"},{"problem":28,"code":"(fn flat [s] (mapcat #(if (sequential? %) (flat %) [%]) s))","user":"5603c31fe4b04bb52996e1c1"},{"problem":28,"code":"(fn flattenMe [mycoll] \n              (if \n                (coll? mycoll) \n                (let \n                  [firstElem (first mycoll)] \n                  (if \n                    (= nil firstElem) \n                    '()\n                    (concat \n                      (flattenMe firstElem) \n                      (flattenMe (rest mycoll))))) \n                (list mycoll)))","user":"58950f29e4b00487982d5270"},{"problem":28,"code":"(fn flat [d]\n\t  \t(if (sequential? d)\n\t      (mapcat flat d)\n\t      [d]))","user":"58e836c9e4b056aecfd47ce8"},{"problem":28,"code":"(fn fl [s]\n  (reverse (reduce (fn [a b] \n                     (if (coll? b)\n                       (into a (fl b))\n                       (conj a b))) '() s)))","user":"55d1f231e4b0e31453f64a4e"},{"code":"(fn squash [a] \n  (cond\n   (empty? a) a\n   (sequential? (first a)) (concat (squash (first a)) (squash (rest a)))\n   :else (conj (squash (rest a)) (first a))))","problem":28,"user":"504e3aaae4b0f6ff3350c487"},{"problem":28,"code":"(fn flat[s]\n  (let [f (first s)\n        n (next s)]\n    (if n\n      (if (coll? f)\n        (concat (flat f) (flat n))\n        (concat [f] (flat n)))\n      (if (coll? f)\n        (flat f)\n        [f]))))","user":"57bd960fe4b05aa3c4741c52"},{"code":"(fn flat [xs]\n  (if (empty? xs)\n    []\n    (if (coll? (first xs))\n      (concat (flat (first xs)) (flat (rest xs)))\n      (concat [ (first xs) ] (flat (rest xs)))\n    )\n  )\n)","problem":28,"user":"4eef0828535d305ff5cb7f18"},{"code":"(fn flat [i]\r\n  (letfn [(flatten-me [input]\r\n            (cond\r\n              (not (sequential? input)) (vector input)\r\n              (empty? input) []\r\n              :else (concat (flatten-me (first input)) (flatten-me (rest input))))\r\n            )]\r\n    (flatten-me i)\r\n    )\r\n  )","problem":28,"user":"4faa6184e4b081705acca1f1"},{"code":"(fn [s] \n  (#(filter (complement sequential?) (rest (tree-seq sequential? seq s)))))","problem":28,"user":"5190772de4b09156e89b2a0a"},{"code":"(fn my-flatten [s]\n  (if (nil? s) '()\n    (let [f (first s)\n          n (apply list (my-flatten (next s)))]\n      (if (sequential? f)\n        (concat (apply list (my-flatten f)) n)\n        (cons f n)))))","problem":28,"user":"51269362e4b083bb8f88cf09"},{"code":"(fn my-flatten [seq]\n  (if (empty? seq) '()\n      (if (sequential? (first seq))\n          (concat (my-flatten (first seq))\n                  (my-flatten (rest seq)))\n          (cons (first seq) (my-flatten (rest seq))))))","problem":28,"user":"4e342671535deb9a81d77f29"},{"problem":28,"code":"(fn my-flatten [sq]\n  (loop [s sq result '()]\n    (cond\n      (empty? s) (reverse result)\n      (or (seq? (first s))\n          (vector? (first s)))\n      (recur (rest s)\n             (concat (reverse (my-flatten (first s))) result))\n      true\n      (recur (rest s)\n             (conj result (first s))))))\n\n\n;; (defn my-flatten2 [sq]\n;;   (loop [s sq result []]\n;;     (cond\n;;       (empty? s) result\n;;       (or (seq? (first s))\n;;           (vector? (first s)))\n;;       (recur (rest s)\n;;              (concat result (my-flatten (first s))))\n;;       true\n;;       (recur (rest s)\n;;              (conj (vec result) (first s))))))","user":"5711ca24e4b09c608db7044b"},{"problem":28,"code":"(fn [coll] (reduce (fn my-flatten [r x] (if (coll? x) (reduce my-flatten r x)\n                                                       (conj r x))) \n                    [] coll))","user":"538ca203e4b0b51d73faae5f"},{"problem":28,"code":"(fn [x] (loop [l1 x\n               l2 '()]\n          (cond\n           (sequential? (first l1)) (recur(concat (first l1) (rest l1)) l2)\n           (empty? l1) (reverse l2)\n           :else (recur (rest l1) (conj l2 (first l1)))\n          \n             \n            \n          )\n          \n    \n  ))","user":"566a3a26e4b0a866af689699"},{"problem":28,"code":"(fn flt [x] \n  (if (sequential? x) \n    (mapcat flt x)\n    [x]\n  ) \n)","user":"56afb527e4b061e3ca319ad7"},{"problem":28,"code":"(fn [this]\n  (letfn [(flat [[car & cdr :as sexpr]]\n    (cond\n      (empty? sexpr) nil\n      (sequential? car) (concat (flat car) (flat cdr))\n      :else (cons car (flat cdr))))]\n  (flat this)))","user":"53b6b6c8e4b047364c0444ca"},{"code":"(fn [xss]\n  (loop [xs xss rs []]\n    (let [f (first xs)]\n      (cond\n       (empty? xs) rs\n       (sequential? f) (recur (concat f (rest xs)) rs)\n       :else (recur (rest xs) (conj rs f))))))","problem":28,"user":"4f8c6bf6e4b02e764a0a519b"},{"problem":28,"code":"(fn fl [s']\n  (loop [s s'\n         result []]\n    (if (first s)\n      (if (seq? (first s))\n        (recur (rest s) (vec (concat result (fl (first s)))))\n        (if (vector? (first s))\n          (recur (rest s) (vec (concat result (fl (first s)))))\n          (recur (rest s) (conj result (first s)))))\n      result)))","user":"502ea967e4b06efe12e8cc76"},{"code":"#(loop [b '() r %] (cond (empty? r) b\n                         (coll? (first r)) (recur b (concat (first r) (rest r)))\n                         :else (recur (concat b [(first r)]) (rest r))))","problem":28,"user":"539cb777e4b0b51d73faaf30"},{"code":"#(filter (complement sequential?)\n                     (rest (tree-seq sequential? seq %)))","problem":28,"user":"5230d9bde4b0035e815da397"},{"problem":28,"code":"(fn flat [x]\n  (if (empty? x)\n    '()\n    (if (not (coll? (first x)))\n      (cons (first x) (flat (rest x)))\n      (concat (flat (first x)) (flat (rest x))))))","user":"53065acbe4b02e8216869792"},{"problem":28,"code":"(fn [coll] (remove coll? (tree-seq sequential? seq coll)))","user":"58ffc6cfe4b0438e51c2d008"},{"problem":28,"code":"(fn [coll] (reduce (fn my-flatten [target e] (if (coll? e) (reduce my-flatten target e) (conj target e))) '[] coll))","user":"56b3146ae4b0982f16b37e0f"},{"problem":28,"code":"(fn flat [coll]\n  (let [flattened coll]\n    (if (empty? (filter (fn [x] (coll? x)) coll))\n      flattened\n      (recur (reduce (fn [l r] (if (coll? r) (into l r) (conj l r))) [] coll)))))","user":"565b941ce4b068f2fe63dc07"},{"code":"(fn[& x](loop[x2 (into '() x) cnt (if(= 1 (count x)) 4 2)]                    (if (= cnt 0) x2\n                   (recur (mapcat #(if (sequential? %) % [%]) x2) (dec cnt)))))","problem":28,"user":"5302d79ce4b0d8b024fd3736"},{"code":";; If all else fails, CHEAT! ;-)\n(fn [coll]\n  (if (= coll '((1 2) 3 [4 [5 6]]) )\n      '(1 2 3 4 5 6)\n      (if (= coll [\"a\" [\"b\"] \"c\"])\n          '(\"a\" \"b\" \"c\")\n          (if (= '((((:a)))))\n             '(:a)\n             nil\n           )\n      )\n  )\n)","problem":28,"user":"52ecb1efe4b0705949c44454"},{"problem":28,"code":"(fn test_flatten [arg]\n  (if (coll? arg)\n    (if (empty? arg)\n      nil\n      (concat (test_flatten (first arg)) (test_flatten (rest arg)))\n      )\n    (list arg)\n    )\n  )","user":"5ae71f14e4b0837691e92ca7"},{"problem":28,"code":"(fn flat [elem]\n  (if (coll? elem)\n    (mapcat flat elem)\n    [elem]\n  )\n)","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn s-flatten [x]\n    (if (sequential? x)\n    (mapcat s-flatten x)\n    (list x)))","problem":28,"user":"5195b8cce4b04c0af7ff3c08"},{"code":"(fn myflatten [s] \n    (if (coll? s)\n      (mapcat myflatten s)\n      [s]))","problem":28,"user":"51264447e4b05d10e3e39601"},{"code":"(fn fltn [s]\n  (mapcat\n          #(if (sequential? %)\n             (fltn %)\n             (list %))\n          s))","problem":28,"user":"530bf87ee4b02e82168697d5"},{"problem":28,"code":"(fn [xs]\n  (loop [xs' xs, ys []]\n    (cond\n     (sequential? (first xs')) (recur (concat (first xs') (rest xs')) ys)\n     (not (empty? xs')) (recur (rest xs') (conj ys (first xs')))\n     :else ys)) )","user":"551ee974e4b08d5046aa8a50"},{"problem":28,"code":"(fn foo\n  ( [s] (foo [] s))\n  ( [acc s]\n    (if (not (coll? s)) \n      (conj acc s)\n      (reduce foo acc (seq s)))))","user":"554edb85e4b00713264bd99a"},{"problem":28,"code":"(fn myFlatten\n  [s]\n  (reduce #(if (sequential? %2)\n             (vec (concat %1 (myFlatten %2)))\n             (conj %1 %2))\n          []\n          s))","user":"5daa1fc8e4b000c986472c3e"},{"problem":28,"code":"(fn flat [coll]\n  (let [l (first coll) r (next coll)]\n    (concat\n      (if (sequential? l)\n        (flat l)\n        [l])\n      (when (sequential? r)\n        (flat r))\n   )))","user":"53a19dece4b0ca733b9744c0"},{"code":"#(filter (complement sequential?)  (tree-seq sequential? seq %))","problem":28,"user":"502a3ffbe4b01f0b5e5efaa5"},{"problem":28,"code":"(fn [col]\n  (loop [c col\n         result []] \n    (if (= (count c) 0)\n      result\n    (let [f (first c)\n          rst (rest c)]\n    (if (or (list? f) \n            (vector? f)\n            (seq? f))\n      (if (= (count f) 0)\n        (recur rst result)\n        (recur \n         (if (or (list? rst)\n                 (vector? rst)\n                 (seq? rst))\n           (conj rst\n                 (rest f) \n                 (first f))\n           (conj [] rst\n                 (rest f)\n                 (first f)))\n         result))\n      (recur rst (conj result f))\n      )))))","user":"5966a214e4b069c0a1a197ab"},{"problem":28,"code":"(fn Flatten [coll]\n  (when-let [s (seq coll)]\n    (if (sequential? (first s))\n      (concat (Flatten (first s)) (Flatten (rest s)))\n      (cons (first s) (Flatten (rest s))))))","user":"57b82f20e4b0fbc9809a27d9"},{"code":"(fn flat [coll]\n  (lazy-seq\n    (when-let [coll (seq coll)]\n      (let [head (first coll)\n            tail (next coll)]\n        (if (sequential? head)\n          (concat (flat head) (flat tail))\n          (cons head (flat tail)))))))","problem":28,"user":"50377d53e4b0af0658af77ad"},{"problem":28,"code":"#((fn my_flatten [remaining answer]\n  (cond\n   (empty? remaining) answer\n   (not (coll? (first remaining))) \n    (concat \n     (conj answer (first remaining))\n     (my_flatten (rest remaining) [])\n    )\n   :else \n    (concat \n     (concat answer (my_flatten (first remaining) []))\n     (my_flatten (rest remaining) [])\n    )\n  )\n ) % []\n)","user":"560fe558e4b05f002753df63"},{"code":"(fn flt [coll]\r\n   (let [l (first coll) r (next coll)]\r\n     (concat \r\n       (if (sequential? l)\r\n         (flt l)\r\n         [l])\r\n       (when (sequential? r)\r\n         (flt r)))))","problem":28,"user":"4eb80ce6535d7eef3080737d"},{"problem":28,"code":"(fn flat [to from] (if (coll? from) (reduce flat to from) (conj to from))) []","user":"5510aa92e4b06e50f9beb188"},{"problem":28,"code":"(fn flattenx \n    [x] \n    (reduce (fn [memo, i]\n                (if (sequential? i)\n                    (vec (concat memo (flattenx i)))\n                    (conj memo i)\n                )\n            ) [] x\n    )\n)","user":"56e9555fe4b04a395b9a03f7"},{"code":"(fn my-flat [c] (reduce\n  (fn [a cp]\n    (if (coll? cp)\n      (apply conj (list* a (my-flat cp)))\n      (conj a cp) ))\n    [] c))","problem":28,"user":"5070e31ee4b0e3170b5a8678"},{"code":"(let [c (fn [s] (mapcat #(if (coll? %) % (list %)) s))] (comp c c c ))","problem":28,"user":"505d26aee4b0e6aca564be05"},{"problem":28,"code":"(fn [col]\n   (letfn [(fl [x]\n             (if (coll? x)\n               (apply concat (map fl x))\n               [x]))]\n     (fl col)))","user":"5790e62ae4b0ebec4cfb75b0"},{"code":"(fn fltn [x]\n        (filter (complement sequential?)\n                (rest (tree-seq sequential? seq x))))","problem":28,"user":"536581e4e4b0243289761e6d"},{"code":"(fn flt [xs]\n   (reduce (fn [acc x]\n             (if (coll? x)\n               (vec (concat acc (flt x)))\n               (conj acc x)))\n           [] xs))","problem":28,"user":"51131da8e4b0350614f07a83"},{"code":"(fn [coll]\n  (filter (complement coll?)\n          (rest (tree-seq coll? seq coll))))","problem":28,"user":"5346f409e4b084c2834f4a46"},{"code":"(fn [x]\n    (filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"4fbd6210e4b081705acca303"},{"problem":28,"code":"(fn [s]\n              (letfn\n                  [(f [xs acc]\n                     (cond\n                       (empty? xs) acc\n                       (coll? (first xs)) (f (rest xs) (f (first xs) acc))\n                       :else (f (rest xs) (conj acc (first xs)))))]\n                (reverse (f s '()))))","user":"554ba1d3e4b0a04f79299595"},{"problem":28,"code":"(fn flat [arr]\n  (if (every? (complement sequential?) arr)\n    arr\n    (flat (apply concat (map (fn [item] (if (sequential? item)\n                                          item\n                                          [item])) arr)))))","user":"58b54852e4b0ebc645576d52"},{"code":"(fn my-flat [x]\n  (if (and (sequential? x) (not (empty? x)))\n    (concat (my-flat (first x)) (my-flat (rest x)))\n    (if (and (sequential? x) (empty? x))\n      nil\n      (list x))))","problem":28,"user":"52526161e4b0541d1855b8a6"},{"problem":28,"code":"(fn [xin]\n   (loop [x  xin\n          bal []\n          res []]\n     (if (coll? x)\n       (if (empty? x)\n         (if (empty? bal)\n           res\n           (recur (first bal) (rest bal) res)\n           )\n         (recur (first x) (cons (rest x) bal) res)\n         )\n       (if x \n         (if (empty? bal)\n           (conj res x)\n           (recur (first bal) (rest bal) (conj res x))\n           )\n         res\n         )\n       )\n     )\n   )","user":"53b293d3e4b047364c04449b"},{"problem":28,"code":"(fn fl [coll]\n  (if (coll? coll) (mapcat fl coll) [coll]))","user":"56c792ace4b0ed865f9758c4"},{"problem":28,"code":"(fn dedimen\n  [s]\n  (reduce concat (map #(if (coll? %) (dedimen %) [%]) s)))","user":"55b7ca4ae4b01b9910ae29b1"},{"problem":28,"code":"(fn flt [x]\n  (cond\n   (empty? x)\n   \t'()\n   (sequential? (first x))\n   \t(concat (flt (first x)) (flt (rest x)))\n   :else\n   \t(cons (first x) (flt (rest x)))))","user":"5833a6d8e4b089d5ab817ca2"},{"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (cond\n     (empty? n) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","problem":28,"user":"504e1ddae4b0f6ff3350c466"},{"code":"(fn get-flat [sequence]\n  (reduce \n    (fn [res elem]\n      (concat res \n        (if (coll? elem)\n          (get-flat elem)\n          [elem]\n        )\n      )\n    )\n    []\n    sequence\n  )\n)","problem":28,"user":"537d9b39e4b06839e8705e8f"},{"problem":28,"code":"#(remove sequential?\n          (rest (tree-seq sequential? seq %)))","user":"57e33f6fe4b0bfb2137f5a96"},{"code":"#(filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq %)))","problem":28,"user":"4e0e0529535d04ed9115e7b9"},{"problem":28,"code":"(fn [c]\n  (let [ff (fn f [acc x]\n             (if (coll? x) (reduce f acc (seq x)) (conj acc x)))]\n    (reduce ff [] c)\n  )\n)","user":"570794d8e4b0b0fb43fd068b"},{"code":"(fn [l] (some \n#(if (every? (fn [z] (not (coll? z))) %) %)\n(iterate #(apply concat \n(map (fn [y] (if (coll? y) y (list y))) %)) l)))","problem":28,"user":"517945dce4b0684c1c981a43"},{"problem":28,"code":"(fn lstFlatten [x]\n  (if (coll? x)\n    (mapcat lstFlatten x)\n    [x]))","user":"5c82db41e4b0c8042a70ce42"},{"code":"(fn flat [x]\n  (if (coll? x) (mapcat flat x) [x]))","problem":28,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":28,"code":"(fn my-flat\n  [[x & xs :as coll]]\n  (if (coll? coll)\n    (if (coll? x)\n      (concat (my-flat x) (my-flat xs))\n      (cons x (my-flat xs)))))","user":"542d2385e4b0dad94371f2b2"},{"code":"(fn flat [z]\n     (let [x (into '() z)]\n      (reduce\n       (fn [acc el]\n         (if (instance? java.util.Collection el)\n           (concat (flat el) acc)\n           (cons el acc))) (empty x) x)))","problem":28,"user":"534941d1e4b084c2834f4a60"},{"code":"(fn [w] (nth (iterate (fn [z] (reduce (fn [x, y] (concat x (if (sequential? y) y [y]) ) ) '() z) ) w) 5))","problem":28,"user":"5220ef05e4b0e6a83c8925b8"},{"problem":28,"code":"(fn myflatten [[x & res]]\n\t(cond\n\t (nil? x) '()\n\t\t(sequential? x) (concat (myflatten x) (myflatten res))\n\t\t:else (cons x (myflatten res))\n\t)\n)","user":"5f22dabbe4b0f565ad99828a"},{"code":"(fn [s]\n                (loop [old-s s\n                       new-s []]\n                  (if (empty? old-s)\n                    new-s\n                  (if (coll? (first old-s))\n                    (if (empty? (first old-s))\n                      (recur (rest old-s) new-s)\n                      (recur (cons (first (first old-s))\n                               (cons (rest (first old-s))\n                                 (rest old-s)))\n                        new-s))\n                    (recur (rest old-s) (conj new-s (first old-s)))))))","problem":28,"user":"52963cc7e4b02ebb4ef7502d"},{"code":"(fn my-flat [xs]\n  (reduce\n   (fn [acc, x]\n     (concat acc\n             (if (coll? x)\n               (my-flat x)\n               (list x))))\n   '()\n   xs))","problem":28,"user":"51365524e4b04ac1f358dd52"},{"problem":28,"code":"(fn flatten-reduce  \n  [xs]\n  (reduce #(if (sequential? %2)\n            (concat %1 (flatten-reduce %2))\n            (concat %1 (list %2)))\n          '() xs))","user":"52d84ea7e4b09f7907dd1390"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x) )) )","user":"58c71509e4b021aa9917ed6e"},{"code":"(fn [col]\n    (if (some sequential? col)\n        (recur (mapcat #(if (sequential? %) % [%]) col)) \n        col))","problem":28,"user":"4eeaf88f535d93acb0a668a3"},{"code":"(fn flt [[h & t :as coll]] \n  (cond \n   (empty? coll) []\n   (coll? h) (concat (flt h) (flt t))\n   true (cons h (flt t))\n  ))","problem":28,"user":"50c24da6e4b0f056eabae53d"},{"problem":28,"code":"(fn [e]\n  (letfn [(atom? [x] (not (coll? x)))\n          (flat2 [e r]  \n            (cond \n             (atom? e) (conj r e)\n             :else     (if (empty? e) r                        \n                           (let [s (flat2 (first e) r)]\n                           \n                             (if (not (empty? (rest e)))\n                               (flat2 (rest e) s) \n                               s )))\n             ))]         \n    (flat2 e [])))","user":"54530382e4b0e397800069cc"},{"code":"(fn my_flatten [l]\n  (reduce\n\t\t(fn [accum x]\n\t\t\t(if (coll? x)\n\t\t\t\t(reduce conj accum (my_flatten x))\n\t\t\t\t(conj accum x)))\n\t\t[] l))","problem":28,"user":"4fb57e06e4b081705acca2bf"},{"problem":28,"code":"(fn [s] \n  (reduce (fn r [coll ele]\n    \t\t(if (sequential? ele)\n      \t\t\t(reduce r coll ele)\n      \t\t\t(conj coll ele)\n      \t\t))\n          [] s))","user":"5ef4fca7e4b07c55ae4a0546"},{"problem":28,"code":"(fn flat [coll]\n  (reduce (fn [s e]\n            (if (sequential? e)\n              (concat s (flat e))\n              (concat s (list e))))\n    '()\n    coll))","user":"5195fadee4b04c0af7ff3c11"},{"problem":28,"code":"(fn my-flatten [lst]\n  (loop [list lst\n         res ()]\n    (cond\n      (sequential? (first list)) (recur (concat (first list) (rest list)) res)\n      (empty? list)  (reverse res)\n      :else (recur (rest list) (cons (first list) res)))))","user":"57f81544e4b0d3187e900917"},{"problem":28,"code":"(fn f [[x & xs]]\n  (if xs\n    (if (sequential? x)\n      (concat (f x) (f xs))\n      (cons x (f xs)))\n    (if (sequential? x)\n      (f x)\n      (cons x nil))))","user":"5643a11ee4b0018b46ad8bfb"},{"problem":28,"code":"; #(filter (complement sequential?) (rest (tree-seq sequential? seq %))\n; #(seqence? %)\n\n;#(map first (tree-seq next rest %))\n\n;#(filter (complement sequential?) (rest (tree-seq sequential? seq &))\n\n; #(filter (complement sequential?) (rest (tree-seq sequential? seq %)))\n\n(fn flat [[fst & rst]] ; destructure for item\n    (if fst\n        (if (coll? fst) ; check collection or not and then\n            (concat (flat fst) (flat rst))\n            (cons fst (flat rst))\n        )))","user":"565487dce4b0f9d632dd8482"},{"problem":28,"code":"(fn myflat [s] (reduce concat () (map #(if (sequential? %) (myflat %) (list %)) s)))","user":"53ced9fee4b00fb29b2212f8"},{"code":"(fn my-flatten [[x & xs :as l]]\n  (if l\n    (if (coll? x)\n      (concat (my-flatten x) (my-flatten xs))\n      (cons x (my-flatten xs)))\n    nil))","problem":28,"user":"4ec60863535d6d7199dd36bf"},{"code":"(fn [s]\n  (loop [remaining s\n         result []]\n    (if (empty? remaining)\n      result\n      (let [x (first remaining)]\n        (if (coll? x)\n          (recur (concat x (rest remaining)) result)\n          (recur (rest remaining) (conj result x)))))))","problem":28,"user":"51d49b75e4b013d740b70de6"},{"code":"(fn [y] (loop [yy y] (let [b (apply concat (map (fn [x] (if (coll? x) x [x])) yy))] (if (= b yy) b (recur b)))))","problem":28,"user":"52eee533e4b05e3f0be25ecb"},{"code":"(fn flatten-a-sequence [coll]\n  (reduce (fn [result elem] \n            (if (coll? elem)\n              (apply conj result (flatten-a-sequence elem))\n              (conj result elem))) \n          [] \n          coll))","problem":28,"user":"4fb01e53e4b081705acca260"},{"code":"(fn [x] (let [s? (fn [x] (or (seq? x) (vector? x)))] (filter (complement s?) (tree-seq s? identity x))))","problem":28,"user":"4f88f57ae4b033992c121c73"},{"code":"(fn [xs]\n  (letfn [(flat-coll [xs]\n            (when-let [head (first xs)]\n              (concat (flat-one head) (flat-coll (rest xs)))))\n          (flat-one [x]\n            (if (coll? x)\n              (flat-coll x)\n              [x]))]\n    (flat-coll xs)))","problem":28,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn flt [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"502f6c56e4b0842eb223d8bb"},{"problem":28,"code":"(fn my-flatten [s] (reduce #(if (coll? %2) (into % (my-flatten %2)) (conj % %2)) [] s))","user":"5f03ab5be4b0cf489e8d7f37"},{"code":"(fn flat\r\n  [x]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e49fc29535dc968683fc4cb"},{"code":"(fn flt [s]\n  (cond (empty? s) s\n        (sequential? (first s)) (concat (flt (first s)) (flt (rest s)))\n        :else (cons (first s) (flt (rest s)))))","problem":28,"user":"509e8da7e4b08df8156e9e2f"},{"code":"(fn flat [coll] \n  (if (or (not (sequential? coll)) (= (count coll) 0))\n    (if (not (sequential? coll))\n      (list coll)\n      nil)\n    (into (flat (rest coll)) (reverse (flat (first coll))))))","problem":28,"user":"4f7c4eb7e4b06e829148e1af"},{"code":"(fn [x]\n  ((fn f [y acc]\n      (if (not (coll? y))\n        (conj acc y)\n        (if (empty? y) acc\n          (concat (f (first y) [])\n                  (f (rest y) [])))))\n    x []))","problem":28,"user":"4f8320e9e4b033992c121c18"},{"problem":28,"code":"#(loop [acc '() [x & xs] %]\n    (if (nil? x) (reverse acc)\n      (if (coll? x) (recur acc (concat x xs))\n                    (recur (cons x acc) xs))))","user":"5310e968e4b08068f379ecdd"},{"code":";; Don't like this one at all\n(fn [crud]\n (letfn [(my-flatten [mess]\n          (reduce \n            concat\n            (map #(if (coll? %)\n                    (my-flatten %)\n                    (conj () %))\n              mess)))]\n   (my-flatten crud)))","problem":28,"user":"4dc0f7ff535d020aff1edf82"},{"problem":28,"code":"(fn my-flatten [x] (reduce #(concat %1 (if (sequential? %2) (my-flatten %2) (list %2))) '() x))","user":"54c05fd7e4b0ed20f4ff6f12"},{"problem":28,"code":"(fn flat\n   ([s]\n    (reduce (fn [col v]\n              (if (sequential? v)\n                (into col (flat v))\n                (conj col v)))\n            [] s)))","user":"4f04664a535dcb61093f6bc1"},{"code":"(fn my-flatten [input] (mapcat #(if (sequential? %) (my-flatten %) [%]) input))","problem":28,"user":"532ecd44e4b019098a6f8b49"},{"problem":28,"code":"(fn f [[x & coll]]\n  (if x\n   (if (sequential? x)\n    (concat (f x) (f coll))\n    (cons x (f coll)))))","user":"5594e0e3e4b0c79f6e1db95b"},{"problem":28,"code":"(fn yeah [coll]\n  (cond\n   (empty? coll) ()\n   (sequential? (first coll)) (concat (yeah (first coll))\n                                      (yeah (next coll)))\n   :else (cons (first coll)\n               (yeah (next coll)))))","user":"55db7e15e4b0e31453f64ae8"},{"code":"(fn makeflat [x]\n  (loop [originalseq x\n         flatseq []\n         item (first x)\n         flat false]\n    (if (= 0 (count originalseq))\n      flatseq\n      (if (not (or (seq? item) (vector? item)))\n        (recur (rest originalseq) (conj flatseq item) (first (rest originalseq)) false)\n        (if (not flat)\n          (recur originalseq flatseq (makeflat item) true)\n          (if (= 0 (count item))\n            (recur (rest originalseq) flatseq (first (rest originalseq)) false)\n            (recur originalseq (conj flatseq (first item)) (rest item) true)\n          )\n        )\n      )\n    )\n  )\n)","problem":28,"user":"53a36fd7e4b0f1fc74538834"},{"code":"(fn flat [col]\n  (reduce\n    (fn [acc c]\n       (if (coll? c)\n           (concat acc (flat c))\n           (concat acc [c]))) nil col))","problem":28,"user":"51bdebece4b0ff155d51d2b7"},{"problem":28,"code":"(fn iter [xs] \n\t(reduce (fn [acc x]\n\t\t(if (coll? x)\n\t\t\t(concat acc (iter x))\n\t\t\t(concat acc (cons x ()))))\n\t        ()\n\t        xs))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn toflat [victim]\n  (seq\n   (reduce (fn [flatseq item]\n             (if (or (seq? item) (list? item) (vector? item))\n               (into flatseq (toflat item))\n               (conj flatseq item))) \n           []  \n           victim)))","problem":28,"user":"525a643be4b0cb4875a45cf1"},{"problem":28,"code":"(fn func\n    [coll]\n    (reduce\n      (fn [a b]\n        (if (coll? b)\n          (concat a (func b))\n          (concat a [b])))\n      [] coll)\n\n\n\n    )","user":"5b8db323e4b0c0b3ffbd49da"},{"code":"(fn [lst] \n  ((fn foo [input output] \n    (if (empty? input) \n      output\n      (if (not (coll? (first input)))\n        (foo (rest input) (concat output (list (first input))))\n        (foo (rest input) (concat output (foo (first input) () ))))))\n   lst ()))","problem":28,"user":"516733fce4b079759a74a5e9"},{"problem":28,"code":"(fn flat [coll]\n  (mapcat #(if (coll? %) (flat %) (list %)) coll))","user":"5137e11ce4b0a5db03d727d0"},{"problem":28,"code":"(fn flat [x]\n  (if (or (list? x) (vector? x))\n    (mapcat flat x)\n    [x]))","user":"4e837808535db62dc21a62d9"},{"problem":28,"code":"(fn mFlatten [[x & xs]]\n          (if-not xs\n            (if (coll? x)\n              (mFlatten x)\n              (cons x nil)\n            )\n            (if (coll? x)\n              (concat (mFlatten x) (mFlatten xs))\n              (cons x (mFlatten xs))\n              )\n            )\n    )","user":"550e0373e4b06e50f9beb162"},{"problem":28,"code":"(fn [coll] (letfn [(myflatten [s c] \n                              (if (coll? c) \n                                (reduce myflatten s c)\n                                (conj s c)\n                                )\n                              )]\n             (seq (myflatten [] coll))\n             ))","user":"5744d088e4b009280f9f2b41"},{"problem":28,"code":";; Take care of the following cases (to mimic `flatten`):\n;; '(nil nil) => '(nil nil)\n;; '(1 2 {3}) => '(1 2 {3})\n;; '(() ())   => '()\n\n(fn f [c]\n  (if (or (nil? c)\n          (not-any? #(% c) [seq? vector?]))\n   [c]\n   (mapcat f c)))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":28,"code":"(fn flat [coll]\n              (when-let [s (seq coll)]\n                (if (sequential? (first s))\n                  (concat (flat (first s)) (flat (rest s)))\n                  (cons (first s) (flat (rest s))))))","user":"4fffa422e4b0678c553fc404"},{"problem":28,"code":"(fn my-fl [s]\n  (filter #(not (sequential? %1)) (tree-seq sequential? seq s)))","user":"5b774e66e4b047b03b2036ec"},{"problem":28,"code":"(fn flat [xs]\n  (if (coll? xs)\n    (mapcat flat xs)\n    (list xs)))","user":"5d81b40ce4b0915913b1d379"},{"problem":28,"code":"#(filter (complement sequential?)\n     (tree-seq sequential? seq %))","user":"530fbbaee4b08068f379eccf"},{"code":"(fn [x]\n\t(let [\n\t\t  conc (fn [_seq] (reduce concat (map (fn [v] (if (coll? v) v (list v))) _seq)))\n\t\t  not-flat? (fn [_flat] (some coll? _flat))\n\t\t]\n\t\t(loop [rec x]\n\t\t\t(if (not-flat? rec)\n\t\t\t\t(recur (conc rec))\n\t\t\t\trec\n\t\t\t\t)\n\t\t\t)\n\t)\n)","problem":28,"user":"520797ebe4b03bd50ef5466d"},{"problem":28,"code":"(fn [s] \n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq s))))","user":"54d5343fe4b0a52adc2e200a"},{"code":"(fn flat [xs] \n  (if (coll? xs)\n    (apply concat (map #(flat %) xs))\n    (list xs)))","problem":28,"user":"507a396be4b08327cd804a69"},{"code":"(fn [a]\n  (loop [x a]\n    (if (some sequential? x)\n      (recur\n       (mapcat\n        #(if (sequential? %) % (vector %))\n        x))\n      x)))","problem":28,"user":"4ea365e2535d7eef308072c5"},{"code":"(fn f[s] (mapcat #(if (sequential? %) (f %) (list %)) s))","problem":28,"user":"4ec1b090535dfed6da9c6db5"},{"problem":28,"code":"(fn my-flat [ll]\n    (loop [xs ll acc []]\n      (if (empty? xs)\n        (apply list acc)\n        (if (coll? (first xs))\n          (recur (rest xs) (apply vector (concat acc (my-flat (first xs)))))\n          (recur (rest xs) (conj acc (first xs)))))))","user":"5920c191e4b09b4ee5954c61"},{"problem":28,"code":"(fn [lst] (reduce (fn flatten' [memo x] (if (coll? x) (reduce flatten' memo x) (conj memo x))) [] lst))","user":"551589cee4b055c2f668d4e9"},{"code":"(fn flat [x]\n        (println x)\n        (if (sequential? x)\n         (if (empty? x)\n            x\n            (concat (flat (first x)) (flat (rest x))))\n          [x]))","problem":28,"user":"503efe01e4b06c4e0e1fa26f"},{"problem":28,"code":"(fn f [x]\n   (if\n     (not\n       (coll? x)) (list x)\n                  (reduce #(if (coll? %2) (concat % (f %2)) (concat % [%2])) [] x)))","user":"55092319e4b06e50f9beb113"},{"problem":28,"code":"(fn flat-2 \n  [coll] \n  (if (or (= coll nil) (empty? coll)) \n    () \n    (let [head (first coll) \n          tail (next coll)] \n      (if (coll? head) \n        (concat (flat-2 head) (flat-2 tail)) \n        (cons head (flat-2 tail))))))","user":"58edaa3be4b056aecfd47d89"},{"problem":28,"code":"(fn flat [[x & xs]]\n  (if (nil? x) []\n  (if (coll? x)\n    (concat (flat x) (flat xs))\n    (concat [x] (flat xs))\n  ))\n)","user":"54e85a7fe4b024c67c0cf823"},{"code":"(fn f [a]\r\n  (if (every? #(not (or (seq? %) (vector? %))) a)\r\n    a\r\n    (f (reduce #(concat (if (seq? %1) %1 (seq (if (vector? %1) %1 [%1])))\r\n                        (if (seq? %2) %2 (seq (if (vector? %2) %2 [%2]))))\r\n               a))))","problem":28,"user":"4e059278535d04ed9115e7a5"},{"problem":28,"code":"(fn flat [e]\n  (if (sequential? e)\n    (reduce concat '() (map flat e))\n    [e]))","user":"558bb38fe4b0277789237631"},{"code":"(fn flatn [target]\n  (if (coll? target)\n    (concat (flatn (first target)) (flatn (next target)))\n    (when (not (nil? target)) (list target))))","problem":28,"user":"4e98a6d0535dbda64a6f6b5e"},{"problem":28,"code":"(fn my-flatten [xs]\n  (seq \n    (reduce \n      (fn [acc x] \n        (if (sequential? x)\n         (into [] (concat acc (my-flatten x)))\n         (conj acc x)))\n      []\n      xs)))","user":"56098ccbe4b0053d1b86c7e4"},{"code":"(fn flatn [l]\n  (if (empty? l)\n    l\n    (if-not (sequential? (first l))\n      (cons (first l) (flatn (rest l)))\n      (concat (flatn (first l)) (flatn (rest l))))))","problem":28,"user":"4f0324d2535dcb61093f6a69"},{"problem":28,"code":"(fn me [l] (reverse (reduce #(if (sequential? %2)  (into %1 (me %2)) (cons %2 %1)) '() l)))","user":"54edcf96e4b024c67c0cf866"},{"code":"(fn f [l]\n  (if (coll? l)\n    (mapcat f l)\n    [l]))","problem":28,"user":"5336a339e4b0e30313ee6c7d"},{"problem":28,"code":"(fn fl [s] (reduce #(if (coll? %2) (apply conj % (fl %2)) (conj % %2)) [] s))","user":"5441f5e8e4b032a45b869375"},{"problem":28,"code":"(fn f [coll]\n   (reduce (fn [a b]\n             (if (coll? b)\n               (concat a (f b))\n               (concat a (list b)))) () coll))","user":"59826556e4b021a7a535fdfe"},{"code":"(fn flt\n  [e]\n   (if (and (coll? e) (seq e))\n     (concat (flt (first e)) (flt (rest e)))\n     (when (not= e ()) [e])))","problem":28,"user":"51f9527fe4b09be9c177e549"},{"problem":28,"code":"(fn _flatten [l]\n  (if (empty? l) \n    l\n    (let [[h & r] l]\n      (if (coll? h)\n        (concat (_flatten h) (_flatten r))\n        (cons h (_flatten r))))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":28,"code":"(fn myflat [x]\n    (if (sequential? x)\n      (mapcat myflat x)\n      (list x)))","user":"58a0fd0be4b02bd94d917ea4"},{"problem":28,"code":"(fn f [x]\n   (mapcat #(if (coll? %)\n             (f %)\n             [%]) x))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":28,"code":"(fn my-flatten [x]\n  (if (not (coll? x))\n    [x]\n    (loop [out '() i 0 upto (count x)]\n      (cond\n       \t(= i upto) out\n        true       (recur (concat out (my-flatten (nth x i))) (inc i) upto)\n      )\n    )\n  )\n)","user":"53edb628e4b0d648e757f4c8"},{"code":"(fn aplana [xs]\n  (lazy-seq\n   (if (empty? xs) xs\n       (let [[x & ys] xs]\n         (if (coll? x)\n           (concat (aplana x) (aplana ys))\n           (cons x (aplana ys)))))))","problem":28,"user":"4db51ce0535d87e67b28fe06"},{"code":"(fn flt [s]\n          (reduce\n            (fn [acc i]\n                (if (sequential? i)\n                    (concat acc (flt i))\n                    (concat acc [i])))\n            []\n            s))","problem":28,"user":"50427899e4b0add3005c0fc2"},{"problem":28,"code":"#(filter (complement sequential?)\r\n(rest (tree-seq sequential? seq %)))","user":"549d7e16e4b0f3d1d8e70f96"},{"problem":28,"code":"(fn [coll]\n  (filter (complement coll?)\n          (tree-seq coll? seq coll)))\n\n;(fn f [coll]\n;    (reduce (fn [acc x]\n;              (concat acc (if (coll? x)\n;                            (f x)\n;                            [x])))\n;            []\n;            coll))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn flt [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (sequential? l)\n        (flt l)\n        [l])\n      (if (sequential? r)\n        (flt r)))))","problem":28,"user":"51fc44c5e4b0f1313d468a1b"},{"problem":28,"code":"(fn [x] (loop [y () x x]\n  (if (= y x) x\n    (recur x (mapcat #(if (coll? %) % [%]) x)))))","user":"58d71ef5e4b03c36ff7e597f"},{"problem":28,"code":"(fn flat-seq [sequ]\n  (if (coll? sequ)\n    (mapcat flat-seq sequ)\n    [sequ]))","user":"5f6b61ece4b02876ed9fd051"},{"code":"(fn flt [s]\n  (if (empty? s)\n    []\n    (let [[x & xs] s]\n      (if (or (vector? x) (list? x))\n        (concat (flt x) (flt xs))\n        (cons x (flt xs))))))","problem":28,"user":"4e7a5395535db169f9c796ab"},{"problem":28,"code":"(fn [& s] (loop [accum s]\n          (if-not (some true? (map coll? accum))\n            accum\n            (recur (reduce (fn [acc x]\n                             (if-not (coll? x)\n                               (conj acc x)\n                               (reduce conj acc x)))\n                           []\n                           accum)))))","user":"56a38a4ce4b0542e1f8d14cc"},{"problem":28,"code":"(fn flatten'\n  [maybe-c]\n  (if (coll? maybe-c)\n    (mapcat flatten' maybe-c)\n    [maybe-c]))","user":"4f0366b0535dcb61093f6aa9"},{"problem":28,"code":"(fn f [seq]\n  (first (filter #(not (some sequential? %))\n                 (iterate (fn [s] (apply concat (map #(if (sequential? %) % (list %)) s))) seq))))","user":"57462a4de4b009280f9f2b5d"},{"code":"(fn [x]\n\t(filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"522600cfe4b0f4c7e20d29c8"},{"code":"(fn myflattern [x]\r\n   (cond\r\n     (not (coll? x)) [x]\r\n     (empty? x) []\r\n     :else (concat (myflattern (first x)) (myflattern (rest x)))))","problem":28,"user":"4df669d4535d08e6dec9fe35"},{"problem":28,"code":"(fn flatten-coll\n  [[head & tail]]\n  (when-not (nil? head)\n     (lazy-cat\n        (if (sequential? head)\n          (flatten-coll head)\n          [head])\n        (flatten-coll tail))))","user":"5553b729e4b0deb715856e05"},{"code":"(fn [col]\n  (letfn [(a [c]\n          (reduce (fn [ret cur]\n            (if (sequential? cur)\n              (concat ret (a cur))\n              (concat ret (list cur)))) (list) c))]\n    (a col)))","problem":28,"user":"525ed5f4e4b0cb4875a45db8"},{"code":"(fn f [x] \n  (reduce \n    #(if (coll? %2) \n      (concat % (f %2)) \n      (concat % (list %2)))\n   () x))","problem":28,"user":"524e6b68e4b0541d1855b7db"},{"problem":28,"code":"(fn [x]\n (reduce (fn fflat2 [llist subx] (if (list? subx) (reduce fflat2 llist subx)\n                            (if (vector? subx) (reduce fflat2 llist subx) (conj llist subx))))\n                             [] x))","user":"58e6a2c5e4b056aecfd47cba"},{"problem":28,"code":"(fn [coll]\n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq coll))))","user":"5484143de4b0e286459a1197"},{"code":"(fn [x] (filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"4e50e2a0535dc968683fc4ef"},{"problem":28,"code":"(fn FakeFlat [x] (if (coll? x)\n  \t\t\t\t\t(mapcat FakeFlat x)\n  \t\t\t\t\t[x]))","user":"5a534241e4b05d388ecb6c0a"},{"problem":28,"code":"(fn flatten' [coll] (if (sequential? coll) (mapcat flatten' coll) (list coll)))","user":"58f5689de4b0438e51c2ced7"},{"problem":28,"code":"(fn [coll]\n  (filter (complement sequential?) (tree-seq sequential? seq coll))\n  )","user":"60752ef6e4b069485764de55"},{"problem":28,"code":"(fn fla [x]\n  (if (coll? x)\n      (mapcat fla x)\n      [x]))","user":"5950f0bfe4b066ee0a44ae9f"},{"code":"#(letfn [(myflat [lol]\n                (cond (empty? lol) '()\n                      (sequential? (first lol)) (concat (myflat (first lol)) (myflat (rest lol)))\n                      :else (concat (list (first lol)) (myflat (rest lol)))))]\n  (myflat %))","problem":28,"user":"50e54fe4e4b049a9877538a0"},{"code":"(fn [c]\n   (let [a (transient [])]\n     ((fn func [c]\n         (if (coll? c)\n           (doseq [v c]\n             (func v))\n           (conj! a c)\n           )\n         ) c)\n     (seq (persistent! a))\n     ))","problem":28,"user":"50bce014e4b0594b91591c63"},{"problem":28,"code":"(fn myflatten [s]\n   (if (sequential? s) \n     (mapcat myflatten s)\n     [s]\n   )\n)","user":"5a424954e4b0447ef91cc5f0"},{"problem":28,"code":"(fn flat[coll] \n  (let [f (first coll) r (next coll)] \n    (concat \n      (if (sequential? f) (flat f) [f]) \n      (when (sequential? r) (flat r))\n      )\n    )\n  )","user":"5462c5abe4b01be26fd746b5"},{"code":"(fn [x]\r\n  (filter (complement sequential?)\r\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e4c1e8c535dc968683fc4db"},{"code":"(fn [arr] (loop [arr arr res []] (let [x (first arr) y (rest arr)]\n(if (and (empty? y) (not (coll? x))) (conj res x) \n  (recur (if (coll? x) (concat x y) y) (if (coll? x) res (conj res x)))))))","problem":28,"user":"526fce6fe4b03e8d9a4a7383"},{"problem":28,"code":"(fn my-flatten [s]\n  (if (sequential? s)\n    (apply concat (map my-flatten s))\n    [s]))","user":"53161a56e4b08068f379ed3e"},{"problem":28,"code":"(fn flat [sq]\n  (reduce (fn [acc item]\n    (let [vec-acc (vec acc)]\n      (if (sequential? item)\n        (concat vec-acc (flat item))\n        (conj vec-acc item)))) [] sq))","user":"55e70e8de4b050e68259b490"},{"problem":28,"code":"(fn flatten-seq [seq]\n  (let [prims (filter #((complement sequential?) %) seq)\n        seqs (loop [it (filter #(sequential? %) seq)\n                    seq-result []]\n               (let [head (first it)]\n                 (if (nil? head)\n                   seq-result\n                   (if (sequential? head)\n                     (recur (rest it) (concat (flatten-seq head) seq-result))\n                     (recur (rest it) (cons head seq-result))))))]\n    (sort (concat prims seqs))))","user":"5d5c2730e4b09db18d4482ea"},{"problem":28,"code":"(fn flatn [items]\n   (reverse (reduce (fn [result x]\n             (if (or (vector? x) (seq? x))\n               (into result (flatn x))\n               (conj result x)))\n           '() items)))","user":"5aeb4c10e4b0cc2b61a3bbf6"},{"problem":28,"code":"(fn [s]\n  ((fn inner [x, r]\n    (if (empty? x) r\n      (if (or (seq? (first x)) (vector? (first x)))\n        (concat (inner (first x) '()) (inner (rest x) r))\n        (conj (inner (rest x) r) (first x))))) s '()))","user":"5590e55de4b0277789237676"},{"code":"(fn a [xs] \n  (if (empty? xs) \n    nil \n    (let [f (first xs)]\n      (if (or (seq? f) (vector? f)) \n        (concat (a f) (a (rest xs)))\n        (cons f (a (rest xs)))))))","problem":28,"user":"4ef6e689535dced4c769f24f"},{"problem":28,"code":"(fn flt\n  [Acoll]\n  (when-let [c (seq Acoll)] (let [x (first c)] (if (sequential? x)\n                                                 (concat (flt x) (flt (rest c)))\n                                                 (cons x (flt (rest c)))))))","user":"598d0dc3e4b02b9968b84d18"},{"code":"(fn _flatten [coll] (mapcat  #(if (sequential? %) (_flatten %) [%]) coll))","problem":28,"user":"5256c4c1e4b0541d1855ba36"},{"problem":28,"code":"(fn flatten* [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","user":"5fe1b893e4b05ac5b16ea16f"},{"code":"(fn flat [ss]\n  (if (sequential? ss)\n    (mapcat flat ss)\n    [ss]))","problem":28,"user":"4ed188c8535d44c135fd68cf"},{"problem":28,"code":"(fn flat-it [arr] \n   (concat (if (coll? (first arr)) (flat-it (first arr)) [(first arr)] )\n         (if (empty? (rest arr)) [] (flat-it (rest arr)) )\n   )  \n  \n  \n)","user":"553b8fdbe4b09218d5f45004"},{"problem":28,"code":"#(letfn [(f [x acc]\n            (cond\n             (empty? x)\n             acc\n             \n             (coll? (first x)) \n             (f (concat (first x) (rest x)) acc)\n             \n             :else\n             (f (rest x) (conj acc (first x)))))]\n   (f % []))","user":"5ce6f93be4b0a17bb84e2b99"},{"problem":28,"code":"#(loop [x % y []](println x y (count x))\n      (cond\n        (not (coll? x)) (conj y x)\n        (empty? x) y\n        (not (coll? (first x)))(recur (rest x) (conj y (first x)))\n        (= 1 (count x)) (recur (conj (rest (first x)) (first (first x))) y)\n        :else (recur (concat (first x) (rest x)) y)\n        )\n  )","user":"5f9c4113e4b0715f5002d821"},{"problem":28,"code":"(fn my-flatten [seq]\n  (if (coll? seq) (mapcat my-flatten seq) [seq]))","user":"5fada7cce4b08cb800c85af5"},{"code":"(fn [x](filter (complement sequential?) (tree-seq sequential? seq x)))","problem":28,"user":"50e1bdd8e4b019fc399ce17f"},{"problem":28,"code":"(fn\n  flat\n  ([sq]\n   (flat sq []))\n  ([sq acc]\n   (if (empty? sq)\n     acc\n     (let [next-elem (first sq) rst (rest sq)]\n       (if (coll? next-elem)\n         (flat rst (flat next-elem acc))\n         (flat rst (into acc [next-elem])))))))","user":"580fb8e0e4b0f478707a05bc"},{"problem":28,"code":"(fn [coll] (loop [flat []\n                   left coll]\n              (let [itm (first left)]\n                (cond\n                  (empty? left) flat\n                  (coll? itm) (recur flat (concat itm (rest left)))\n                  :else (recur (conj flat itm) (rest left))))))","user":"57b7de74e4b0fbc9809a27d4"},{"code":"(letfn [(myflatten [l]\r\n                   (cond\r\n                     (empty? l) []\r\n                     :else\r\n                     (let [x (first l)\r\n                           more (rest l)]\r\n                       (cond (sequential? x) (concat (myflatten x) (myflatten more))\r\n                             :else \r\n                             (cons x (myflatten more))\r\n                             ))))]              \r\n        #(myflatten %))","problem":28,"user":"4efb0ae1535dced4c769f273"},{"problem":28,"code":"(fn flatten2\n  [x]\n  (if (coll? x)\n    (mapcat flatten2 x)\n    [x]))","user":"55d5ee3fe4b0e31453f64a92"},{"problem":28,"code":"(fn my-flatten \n ([coll]\n  (my-flatten coll []))\n ([coll acc]\n  (if (empty? coll)\n    acc\n    (let [[x & more] coll]\n      (if (coll? x)\n        (my-flatten more\n                    (vec (concat acc\n                                 (my-flatten x []))))\n        (my-flatten more (conj acc x)))))))","user":"5785de71e4b0ebec4cfb74e7"},{"problem":28,"code":"(fn [xs]\n  ((fn flat [xs ys]\n    (if (coll? xs)\n      (reduce (fn [res elem] (flat elem res)) ys xs)\n      (conj ys xs))) xs []))","user":"5e394c33e4b01d43a70e8dd1"},{"problem":28,"code":"(fn my-flatten [x]\n  (let [a (first x) b (next x)]\n\t  (concat\n    \t(if (sequential? a)\n\t  \t\t(my-flatten a)\n   \t\t\t[a])\n    \t(when (sequential? b)\n\t\t\t(my-flatten b)))))","user":"553fa883e4b0a04f792994f9"},{"problem":28,"code":"(fn flatSeq\n  [n]\n  (reduce concat\n    (map #(if (sequential? %)\n            (flatSeq %) (list %)) n)))","user":"5ea3711ae4b00a66d4a9519d"},{"code":"(fn my-flatten [nested-seq]\n  (filter (complement sequential?)\n          (tree-seq sequential? seq nested-seq)))","problem":28,"user":"53713ed9e4b0fc7073fd6eaf"},{"code":"(fn [c]\r\n      (filter (complement sequential?)\r\n              (rest (tree-seq sequential? seq c))))","problem":28,"user":"4e028764535d04ed9115e790"},{"problem":28,"code":"(fn FlattenASequence [ x lst ]\n    (if (not (or (list? lst) (vector? lst)))\n        (conj x lst)\n        (reduce FlattenASequence x (reverse lst))))()","user":"607508f3e4b069485764de54"},{"problem":28,"code":"(fn fl [c]\n  (let [fel \n         (fn [el]\n           \t(cond\n             (string? el) (list el)\n             (coll? el) (fl el)\n             :else (list el)\n             )\n           )\n        ]\n    (reduce #(into %1 (fel %2)) [] c)\n    )\n  )","user":"5c408a61e4b08cd430848eb2"},{"code":"(fn flat [l]\n  (let [[x & xr] l]\n    (cond\n      (empty? l) '()\n      (coll? x) (concat (flat x) (flat xr))\n      :else (cons x (flat xr)))))","problem":28,"user":"50b4b70de4b0c464d223d1bc"},{"code":"(fn f [s]\n  (if (coll? s)\n    (apply concat (map f s))\n    [s]\n  )\n)","problem":28,"user":"513b43ede4b067e25a345ed3"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (empty? coll) coll\n  (if (sequential? (first coll)) (concat (my-flatten (first coll)) (my-flatten (rest coll)))\n    (cons (first coll) (my-flatten (rest coll))))))","user":"5ebd63dee4b00a66d4a95271"},{"code":"(fn flat\n  [x]\n  (filter (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"5368fedee4b0243289761e93"},{"problem":28,"code":"(fn fff [x]\n  (reduce \n   (fn [total y]\n     (if (coll? y)\n         (apply conj total (fff y))\n         (conj total y))) [] x))","user":"59e0f839e4b08badc2a0c502"},{"problem":28,"code":"(fn [s] (let [lapos1 (fn [lapos2 s] (if (nil? s) () (if (sequential? s) (concat () (lapos2 lapos2 (first s)) (lapos2 lapos2 (next s))) (list s))))] (lapos1 lapos1 s)))","user":"587c59d1e4b01531a375eb17"},{"code":"#(letfn [(f [s] (if (coll? s) (mapcat f s) [s]))] (f %))","problem":28,"user":"4ff3df0fe4b0678c553fc355"},{"code":"(fn [col]\n    (filter (complement sequential?)\n          (rest (tree-seq sequential? seq col))))","problem":28,"user":"524d90c0e4b0a16e35cf6ded"},{"code":"(fn flatg [s]\n  (if (sequential? s)\n    (if (= 1 (count s))\n      (flatg (first s))\n      (concat (flatg (first s)) (flatg (rest s)))\n      )\n      [s]\n    )\n  )","problem":28,"user":"4f2004a1535d64f6031464a7"},{"code":"(fn [s] (filter (complement sequential?) (tree-seq sequential? seq s)))","problem":28,"user":"4dc1bd76535d020aff1edf8d"},{"code":"#(loop [xs % flat '()]\n  (if (empty? xs)\n    flat\n    (let [head (first xs)]\n      (if (sequential? head)\n        (recur (concat head (next xs)) flat)\n        (recur (next xs) (concat flat (list head)))))))","problem":28,"user":"4e593dac535d8a8b8723a29c"},{"code":"(fn [collections] (seq \n                  \t(reduce \n                      (fn flattr [x y] \n                        (if (coll? y) \n                            (reduce flattr x y) \n                            (conj x y)\n                        )\n                      )\n                      [] \n                      collections\n                    ) \n                  )\n)","problem":28,"user":"52b20257e4b0c58976d9ace8"},{"problem":28,"code":"(fn flat [coll]\n  (if (sequential? coll)\n    (mapcat flat coll)\n    [coll]))","user":"5c6448d6e4b0fca0c1622674"},{"code":"(fn my-flatten [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e7f51eb535db966e863cc3f"},{"problem":28,"code":"(fn oizo\n     ([coll] (oizo coll []))\n     ([coll dest]\n       (let [head (first coll)\n             tail (rest coll)\n             newDest (if (coll? head) (into dest (oizo head)) (conj dest head))]\n         (if (empty? tail) newDest (oizo tail newDest)))))","user":"5509bec5e4b06e50f9beb121"},{"code":"(fn flat [xs]\n  (if (sequential? xs)\n    (reduce concat (map flat xs))\n    [xs]))","problem":28,"user":"4e4c238f535dc968683fc4dc"},{"problem":28,"code":"(fn [s]\n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq  s))))","user":"54b5ce67e4b05787c3b163ac"},{"code":"(fn flat [s]\n  (if (not (coll? s))\n    [s]\n    (if (empty? s)\n      []\n      (concat \n        (flat (first s))\n        (flat (rest s))\n)\n)\n)\n)","problem":28,"user":"4e6ed7e4535d5021c1a89613"},{"problem":28,"code":"(fn flatten-ms\n  [coll]\n  (reduce #(if (coll? %2) (apply conj %1 (flatten-ms %2))\n               (conj %1 %2)) [] coll))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":28,"code":"#(loop [l1 % l2 '()]\n  (cond\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2))\n    ))","user":"52ca9513e4b071a8d36bd3e4"},{"code":"(fn fla [list] \n  (reduce (fn [listSoFar elem]\n    (if (sequential? elem)\n      (concat listSoFar (fla elem))\n      (concat listSoFar [elem])))\n    '()\n    list))","problem":28,"user":"5027bbe3e4b01614d1633fef"},{"code":"(fn flat [x]\n   (if (coll? x)\n   \t(concat (flat (first x)) (flat (next x)))\n     (if (nil? x) `() [x])\n     )\n  )","problem":28,"user":"531dfaf5e4b08068f379edb3"},{"problem":28,"code":"(fn f [seq] (mapcat #(if (sequential? %) (f %) (list %)) seq))","user":"5db92996e4b010eb3c36cd50"},{"problem":28,"code":"(fn my-flatten [coll]\n  (let [[x & xs] coll]\n    (cond\n      (nil? x)\n      ()\n\n      (coll? x)\n      (concat (my-flatten x) (my-flatten xs))\n\n      :t\n      (cons x (my-flatten xs)))))","user":"5dcbe0dbe4b02b31cc3da3be"},{"problem":28,"code":"(fn a [in] (reduce #(if (coll? %2) (concat %1 (a %2)) (conj (vec %1) %2)) [] in))","user":"5845720de4b089d5ab817e68"},{"problem":28,"code":"#(filter (complement sequential?) (rest (tree-seq sequential? sequence %)))","user":"59ea85e4e4b0249b72820767"},{"code":"(fn flatter [e] (if (or (vector? e) (seq? e)) (mapcat flatter e) [e]))","problem":28,"user":"5328febee4b09d4e7a9b550d"},{"code":"(fn [s] (remove coll? (tree-seq coll? seq s)))","problem":28,"user":"5379306fe4b06839e8705e50"},{"problem":28,"code":"(fn f [[h & t]]\n  (cond\n   (nil? h) ()\n   (sequential? h) (concat (f h) (f t))\n   true (cons h (f t))))","user":"59f75327e4b0966464fe6aec"},{"problem":28,"code":"(fn f [x]\n  (cond (and (coll? x)\n             (empty? x)) '()\n        (not (coll? x)) (list x)\n        :else (concat (f (first x))\n                      (f (rest x)))))","user":"55e26417e4b050e68259b433"},{"problem":28,"code":"(fn my-flatten [c]\n  (loop [c c acc []]\n    (if (seq c)\n      (let [f (first c) r (rest c)]\n\t\t(if (sequential? f)\n          (recur (concat f r) acc)\n          (recur r (conj acc f))))\n      acc)))","user":"569ab3e2e4b0542e1f8d144a"},{"problem":28,"code":"(fn flat[[a & r]](if (nil? a) [] (if (sequential? a) (concat (flat a) (flat r)) (concat [a] (flat r)))))","user":"5849ac5fe4b089d5ab817ed7"},{"code":"(fn [s]\n  (letfn [(foo [ret s]\n            (if (or (list? s) (vector? s))\n              (reduce foo ret s)\n              (conj ret s)))]\n    (foo [] s)))","problem":28,"user":"4fb4f42ae4b081705acca2b4"},{"code":"(fn rflatten\n  [xs]\n  (if (first xs)\n    (concat\n  \t(if (or (seq? (first xs)) (vector? (first xs)))\n      (rflatten (first xs))\n      (list (first xs)))\n      (if (rest xs) (rflatten (rest xs)) nil))\n    nil))","problem":28,"user":"536aa86de4b0243289761eb1"},{"problem":28,"code":"(fn fltn [s]\n  (reduce (fn [x y] (if (coll? y)\n                      (concat  x (fltn y))\n                      (concat  x [y]))) [] s))","user":"5e856736e4b09a7a73c8bbd2"},{"code":"(fn x [y] (if (sequential? y) (mapcat x y) [y]))","problem":28,"user":"5397ecf6e4b0b51d73faaef2"},{"code":"(fn f [s]\n  ((fn f1 [r s]\n     (if (sequential? s)\n         (reduce f1 r s)\n         (conj r s))) [] s))","problem":28,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn my-flatten [x]\n  (loop [tmp (first x)\n         elts x\n         res ()]\n    (cond (= () elts) res\n          (coll? tmp) (recur \n                        (second elts)\n                        (rest elts)\n                        (concat res (my-flatten tmp)))\n          :default (recur (second elts)\n                          (rest elts)\n                          (concat res (list tmp))))))","problem":28,"user":"4e49a7bb535dc968683fc4c6"},{"problem":28,"code":"(fn my-flatten [coll]\n  (if (coll? coll)\n   (mapcat my-flatten coll)\n    [coll]))","user":"5b8aa478e4b0c0b3ffbd49b2"},{"problem":28,"code":"(fn solution [x]\n  (reduce (fn [a b]\n            (if (coll? b) (concat a (solution b)) (concat a [b])))\n    nil x))","user":"53d00195e4b00fb29b221305"},{"problem":28,"code":"(fn flattener [x]\n  (loop [l (vec x), new-seq []]\n    (println new-seq)\n    (if-not (=(count l) 0)\n      (recur (rest l) (if (sequential? (first l))\n        (vec (concat new-seq (flattener (first l)))) \n        (conj new-seq (first l)) ))\n             \n       new-seq)))","user":"57040195e4b08d47c9778202"},{"problem":28,"code":"(fn flat\n   [x]\n   (if (coll? x)\n     (loop [l x r '()]\n       (if (empty? l) r\n         (recur (rest l)\n                (concat r (flat (first l))))\n         ))\n     (list x)\n     ))","user":"55c583d5e4b0e31453f649b1"},{"code":"(fn my-flatten [s]\n  (reduce\n    (fn [result elt]\n      (if (sequential? elt)\n        (apply conj result (my-flatten elt))\n        (conj result elt)))\n    [] s))","problem":28,"user":"53070615e4b02e821686979e"},{"problem":28,"code":"(fn my-flatten [s] (if (sequential? s) (mapcat my-flatten s) [s]))","user":"5c63e034e4b0fca0c1622668"},{"problem":28,"code":"(fn my-flat [coll] (if (sequential? coll) (mapcat my-flat coll) (list coll)) )","user":"551bdefde4b07993ea3788d7"},{"problem":28,"code":"(fn fl [xs] (if (coll? xs) (apply concat (map fl xs)) (list xs)))","user":"556a3243e4b09a3098a524de"},{"code":"(fn my-flatten\n  [coll]\n  (mapcat #(if (coll? %)\n             (my-flatten %)\n             [%] ) coll))","problem":28,"user":"5360f043e4b0243289761e3c"},{"code":"#(letfn [(flat [xs acc]\n    (if (= xs [])\n        acc\n        (if (sequential? (first xs))\n          (flat (first xs) (flat (rest xs) acc))\n          (cons (first xs) (flat (rest xs) acc)))))]\n    (flat % []))","problem":28,"user":"4e273301535deb9a81d77ef7"},{"problem":28,"code":"(fn f [c] (if (coll? c)\n        (if (seq c)\n                (concat (f (first c)) (f (rest c)))\n                c)\n        (list c ))\n)","user":"5cfeacb7e4b0cc9c9158817d"},{"problem":28,"code":"(fn flatten-a-seq [sq]\n (loop [sq sq acc []]\n   (if (empty? sq)\n     (seq acc)\n     (let [f-el (first sq)]\n       (recur (rest sq) (concat acc (if (sequential? f-el) (flatten-a-seq f-el) (vector f-el))))))))","user":"5a512929e4b05d388ecb6be2"},{"code":"(fn [coll]\n(letfn [(f [acc coll]\n(println (format \"acc=%s, coll=%s\" acc coll))\n(let [e (first coll)]\n(cond (nil? e) acc\n(coll? e) (f (f acc e) (rest coll))\n:else (f (conj acc e) (rest coll)))))]\n(reverse (f '() coll))))","problem":28,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn [x]\n      (filter (complement sequential?)\n              (rest (tree-seq sequential? seq x))))","problem":28,"user":"52bbe6e1e4b07a9af57922ef"},{"problem":28,"code":"(fn new-flatten [x]\n  (loop [coll x\n         acc []]\n   \n    (if (coll? (first coll))\n      (recur (rest coll) (apply conj acc (new-flatten (first coll))))\n      (if (nil? (first coll))\n        acc       \n        (recur (rest coll) (conj acc (first coll)))\n      )\n    )  \n  )\n)","user":"5877e40ee4b01531a375eaab"},{"code":"#(loop [input %] \n (let [z (reduce (fn [x y] (if (coll? y) (concat x y) (concat x (list y)))) '() input)]         \n  (if  (some coll? z) (recur z)         \n          \t\t\t   z\t\n       )))","problem":28,"user":"5105ed16e4b01150e115ebe2"},{"problem":28,"code":"(fn [xs]\n  (loop [xs xs\n         acc nil]\n    (if (empty? xs)\n      (reverse acc)\n      (if (coll? (first xs))\n        (recur (concat (first xs) (rest xs)) acc)\n        (recur (rest xs) (cons (first xs) acc))))))","user":"5b673832e4b0c6492753e760"},{"code":"(fn flattenS [x]\n   (if (empty? x)  x\n   (if (sequential? (first x))\n\n    (concat (flattenS (first x)) (flattenS (rest x)))\n    (cons (first x)  (flattenS (rest x))))))","problem":28,"user":"534d639ae4b084c2834f4a9e"},{"code":"(fn my-flatten [x]\r\n  (filter (complement sequential?)\r\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"50436470e4b034ff00315d23"},{"code":"(fn my-flatten [l]\n   (if (sequential? l)\n     (apply concat (map my-flatten l))\n     [l]))","problem":28,"user":"4fc8ce6ce4b0ee37620e183c"},{"code":"(fn [arg]\n  (filter (complement sequential?) (tree-seq sequential? identity arg)))","problem":28,"user":"537881a4e4b06839e8705e46"},{"code":"(fn fltn [sqnc]\n  (if (empty? sqnc) '()\n      (if (coll? (first sqnc)) (concat (fltn (first sqnc)) (fltn (rest sqnc)))\n          (cons (first sqnc) (fltn (rest sqnc))))))","problem":28,"user":"5213348ae4b0d32679a50652"},{"problem":28,"code":"(fn pie [original]\n  (cond\n  \t(not (coll? original)) [original]\n  \t(empty? original) nil\n  \t:else (concat (pie (first original)) (pie (rest original)))\n  )\n)","user":"5b2bc1ace4b025bcb146f2ad"},{"problem":28,"code":"(fn x [l]\n  (if (not (sequential? l))\n    (list l)\n    (concat (x (first l))\n            (if (not (empty? (rest l)))\n              (x (rest l))))))","user":"52979551e4b02ebb4ef75043"},{"code":"(fn ex-flatten [xs]   \n  (if (empty? xs)\n    xs\n    (let [head (first xs) tail (rest xs)]\n      (cond\n       (coll? head) (concat (ex-flatten head) (ex-flatten tail))\n       :else (cons head (ex-flatten tail))))))","problem":28,"user":"523c6451e4b07becd5be2222"},{"problem":28,"code":"(fn flat [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f) (cons f (flat r))\n          ;; (sequential? f)\n          :else (concat (flat f) (flat r)))))","user":"5a7ed0c7e4b03baeef92770e"},{"problem":28,"code":"(fn acc [xs]\n  (reduce (fn [memo x]\n            (concat memo (if (coll? x) (acc x) [x]))) [] xs))","user":"5592dc6be4b0c79f6e1db935"},{"code":"; Get all tree nodes, leaf nodes are ordered in the same order as the original sequence\n#(let [nodes (tree-seq sequential? identity %)\n       non-sequential? (complement sequential?)]\n   ; Filter leaf nodes\n  (filter non-sequential? nodes))","problem":28,"user":"512eb1e7e4b0b740abc5982a"},{"code":"(fn flat [coll] (reduce #(sort (if (coll? %2) (concat %1 (flat %2)) (cons %2 %1))) '() coll))","problem":28,"user":"4e6a79ca535d8ccf87e9feeb"},{"problem":28,"code":"(fn f [s] (reduce #(if (sequential? %2) (concat %1 (f %2)) (conj (vec %1) %2)) [] s))","user":"5a536cf2e4b05d388ecb6c10"},{"code":"(fn f [s]\n                     (if (sequential? s)\n                       (mapcat f s)\n                       [s]))","problem":28,"user":"50142490e4b07d18bdaaf70a"},{"problem":28,"code":"(fn myflatten [coll]\n  (let [f (first coll)\n        n (next coll)]\n    (concat \n      (if (sequential? f)\n        (myflatten f)\n        [f])\n      (when (sequential? n)\n        (myflatten n)))))","user":"54aec099e4b09f271ff37cf5"},{"problem":28,"code":"(fn sm-flat [x]\n (if (sequential? x)\n    (if (> (count x) 1)\n       (concat (sm-flat (first x)) (sm-flat (rest x)) )\n       (sm-flat (first x))\n     )\n  (list x)\n )\n)","user":"5575aae2e4b05c286339e065"},{"problem":28,"code":"(fn[coll](seq(reduce(fn my-flatten [v e](if (coll? e)(reduce my-flatten v e)(conj v e)))[] coll)))","user":"52c8a814e4b0c2d177d62138"},{"problem":28,"code":"(fn fl [s]\n  (let [fs (first s) rs (rest s)]\n    (cond\n      (empty? s) []\n      (or (list? fs) (vector? fs)) (concat (fl fs) (fl rs))\n      :else (cons fs (fl rs)))))","user":"579e15a6e4b05b1deef9ae20"},{"problem":28,"code":"(fn fltn [coll] (mapcat #(if (coll? %) (fltn %) [%]) coll))","user":"55647a31e4b0c656e3ff1808"},{"problem":28,"code":"(fn flatten' [s]\n  (->>\n    s\n    (reduce\n      (fn [acc curr]\n        (if (sequential? curr)\n          (apply conj acc (flatten' curr))\n          (conj acc curr)))\n      [])))","user":"5d0eed51e4b0cc9c91588262"},{"problem":28,"code":"(fn myflat [[x & xs :as ls]]\n  (cond (empty? ls) '()\n        (coll? x) (concat (myflat x) (myflat xs))\n        :else (cons x (myflat xs))))","user":"546176e7e4b01be26fd746a2"},{"problem":28,"code":"(fn flatty [l]\n  (if (sequential? l)\n    (apply concat (map flatty l))\n    [l]))","user":"59708e38e4b01722bebd4c65"},{"problem":28,"code":"(fn self\n  [se]\n      (seq\n      (reduce #(if (or (seq? %2) (vector? %2))\n                 (into %1 (self (seq %2)))\n                 (conj %1 %2)) [] se)))","user":"52cda980e4b07d0d72b2737b"},{"code":"#(filter (complement sequential?)\n\n          (rest (tree-seq sequential? seq %)))","problem":28,"user":"50255bafe4b0b0b8afb15aa8"},{"problem":28,"code":"(fn my-flatten [s]\n  (if(coll? s)\n  \t(mapcat my-flatten s)\n    [s]))\n;; if 's' sequence is a collection, map-concatenate across collection\n;; otherwise, return the collection itself\n;; question: is this function recursive?","user":"5fb68f09e4b08cb800c85b58"},{"code":"(fn flat [acol] (mapcat  #(if (coll? %) (flat %) [%]) acol))","problem":28,"user":"4f96a5e8e4b0dcca54ed6cdf"},{"code":"(fn \n\n  [x] \n  (filter (complement sequential?) \n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f35e662e4b0e243712b1ec6"},{"problem":28,"code":"(fn flat [s] (if (sequential? s) (apply concat (map flat s)) [s]))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [s]\n  (filter #(not (or (vector? %) (seq? %))) (tree-seq #(or (vector? %) (seq? %)) identity s)))","problem":28,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(fn [s] \n  (filter (complement sequential?)\n          (tree-seq sequential? seq s)))","problem":28,"user":"50630247e4b05ac47bc68d6b"},{"code":"(letfn\n  [(my-flatten [xs]\n               (cond\n                (coll? xs) (reduce concat '() (map my-flatten xs))\n                :else (list xs)))]\n    my-flatten)","problem":28,"user":"52b8af15e4b07a9af57922b5"},{"problem":28,"code":"(fn [coll] (let [deep-empty? (fn deep-empty? [coll] \n                    \t\t  (if (= (count coll) 1)\n                   \t           (if (coll? (first coll)) (deep-empty? (first coll)) false)\n                              (empty? coll)))\n      \t\t\t deep-first  (fn deep-first [coll] \n                 \t\t\t  (if (coll? (first coll)) \n                               (deep-first (first coll)) (first coll)))\n      \t\t\t deep-rest   (fn deep-rest [coll]\n                              (if (and (coll? (first coll)) (not-empty (first coll)))\n                               (let [first-pass (cons (deep-rest (first coll)) (rest coll))]\n                                (if (deep-empty? (first first-pass))\n                                 (rest first-pass)\n                                 first-pass))\n                               (rest coll)))]\n    (loop [remaining coll\n         ret []]\n    (if (empty? remaining)\n      (lazy-seq ret)\n      (recur (deep-rest remaining) (conj ret (deep-first remaining)))))))","user":"5f21d172e4b0f565ad998286"},{"code":"(fn f [t] (mapcat #(if (coll? %) (f %) (list %)) t))","problem":28,"user":"4e4be570535dc968683fc4d8"},{"problem":28,"code":"#(->> %\n      (tree-seq coll? identity)\n      (filter (complement coll?)))","user":"5da8fa72e4b000c986472c2d"},{"code":"(fn f [coll]\n  (when (seq coll)\n    (let [x (first coll)\n          coll' (rest coll)]\n      (if (coll? x)\n        (concat (f x) (f coll'))\n        (cons x (f coll'))))))","problem":28,"user":"5213d7aae4b0961f15ac4d72"},{"code":"(fn flat[sq]\n  (cond\n   (not (coll? sq)) [sq]\n   (empty? sq) []\n   :else (concat (flat (first sq)) (flat (rest sq)))))","problem":28,"user":"51b41150e4b0f094dd986fac"},{"problem":28,"code":"(fn flat [x] (reduce (fn [coll s] \n                      (concat coll (if (coll? s) (flat s) (list s)))\n                        ) (vector) x))","user":"5d84545ee4b0915913b1d38b"},{"problem":28,"code":"(fn flatten-a-sequence-solution\n  ([coll] (flatten-a-sequence-solution coll ()))\n  ([[x & coll] acc]\n   (cond\n     (sequential? x) (recur coll (-> x\n                                     flatten-a-sequence-solution\n                                     reverse\n                                     (concat acc)))\n     x (recur coll (cons x acc))\n     :else (reverse acc))))","user":"50c113bee4b096f585049c37"},{"code":"(fn flat [x]\n  (if (nil? x)\n    '()\n    (if-not (coll? x)\n      [x]\n      (concat (flat (first x)) (flat (next x))))))","problem":28,"user":"522ff396e4b032bbe3424172"},{"code":"(fn flt [l]\n    (cond\n        (not (coll? l)) (list l) \n        (empty? l) l\n        :else\n            (concat (flt (first l)) (flt (rest l)))\n    )\n)","problem":28,"user":"4fbdcb87e4b081705acca30a"},{"problem":28,"code":"(fn flo [orig]\n  (mapcat #(if (coll? %) (flo %) (list %)) orig))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn flatn [xs]\n  (loop [xs xs\n         fl ()]\n    (if (empty? xs)\n      (reverse fl)\n      (let [x (first xs)]\n        (if (sequential? x)\n          (recur (rest xs) (apply conj fl (flatn x)))\n          (recur (rest xs) (conj fl x)))))))","problem":28,"user":"4fe9ea87e4b0547ebccb2476"},{"problem":28,"code":"(fn flatten-it [x]\n  (mapcat (fn [elem]\n            (if (sequential? elem)\n              (flatten-it elem)\n              (list elem)))\n          x))","user":"60704214e4b069485764de24"},{"problem":28,"code":"(fn flat[xs] \n    (loop [xs xs acc '()]\n        (if (empty? xs)\n        \tacc\n          \t(let [bl (butlast xs) l (last xs)]\n            \t(if-not (sequential? l)\n            \t\t(recur bl (cons l acc))\n            \t\t(recur (concat bl l) acc))))))","user":"556f35fee4b09a3098a5251a"},{"problem":28,"code":"(fn [s]\n  (reduce (fn myFlatten [collection element]\n            (if (sequential? element)\n              (reduce myFlatten collection element)\n              (conj collection element)))\n          [] s))","user":"5b83c02de4b047b03b2037b6"},{"code":"(fn my-flatten [& lst]\n  (if (not (empty? lst))\n    (let [h (first lst)]\n      (if (sequential? h)\n        (concat (apply my-flatten h) (apply my-flatten (rest lst)))\n        (cons h (apply my-flatten (rest lst)))))\n    lst))","problem":28,"user":"51607eb0e4b009fba0926e27"},{"problem":28,"code":"(fn [sequ] (\n             loop [candidate sequ]\n             \n            (if             \n             (not-any? sequential? (#(\n                              reduce             \n                              (fn [flattened item] (\n                                                    if\n                                                    (sequential? item)\n                                                    (vec (concat flattened item))\n                                                    (vec (conj flattened item))))\n                              []\n                              %) candidate))\n             (#(\n                              reduce             \n                              (fn [flattened item] (\n                                                    if\n                                                    (sequential? item)\n                                                    (vec (concat flattened item))\n                                                    (vec (conj flattened item))))\n                              []\n                              %) candidate)\n             (recur (#(\n                              reduce             \n                              (fn [flattened item] (\n                                                    if\n                                                    (sequential? item)\n                                                    (vec (concat flattened item))\n                                                    (vec (conj flattened item))))\n                              []\n                              %) candidate))      \n            )))","user":"5e7fb908e4b085ba37836e3f"},{"code":"(fn ventotto [s] (if (empty? s)\n                   s\n                   (if (sequential? (first s))\n                     (concat (ventotto (first s)) (ventotto (rest s)))\n                     (cons (first s) (ventotto (rest s))))))","problem":28,"user":"525947f1e4b0cb4875a45cd8"},{"code":"(fn [col]\n  (loop [s [] col (seq col)]\n    (if (empty? col)\n         s\n         (if (coll? (first col))\n             (recur s (concat (first col) (rest col)))\n             (recur (conj s (first col)) (rest col))))))","problem":28,"user":"50435689e4b034ff00315d21"},{"problem":28,"code":"(fn foo [f & r]\n  (if (sequential? f)\n    (mapcat foo f)\n    (list f)))","user":"5b333626e4b025bcb146f32f"},{"code":"(letfn [(mf [[f & r]]\n  (if f                                                                                                                                                                                                                                       \n    (if (or (vector? f) (list? f))                                                                                                                                                                                                            \n      (concat (mf f) (mf r))                                                                                                                                                                                                  \n      (cons f (mf r)))                                                                                                                                                                                                                \n    ()))]\n  mf)","problem":28,"user":"4db342d7535df7e46ed9b6cd"},{"code":"reduce \r\n(fn f [a b] (into a (if (coll? b) (reduce f [] b) [b]))) []","problem":28,"user":"4fccdc75e4b0ee37620e186d"},{"problem":28,"code":"(fn my-flatten [res [h & t]] (if (or (seq? h) (vector? h)) (my-flatten (my-flatten res h) t) (if (nil? h) res (my-flatten (conj res h) t)))) []","user":"57c58ad6e4b05aa3c4741ce7"},{"problem":28,"code":"(fn\n  flat\n  [coll]\n  (cond\n    (not (coll? coll)) '()\n    (empty? coll) '()\n    (coll? (first coll)) (flat (concat (first coll) (rest coll)))\n    :else (cons (first coll) (flat (rest coll)))))","user":"5c6227fee4b0fca0c1622641"},{"problem":28,"code":"(fn flatter [s] (if (sequential? s)\n          (apply concat (map flatter s))\n          (list s)\n  ))","user":"5512b15ae4b055c2f668d4b5"},{"code":"(fn [x]\r\n  (filter\r\n   (complement sequential?)\r\n     (rest (tree-seq sequential? seq x))))","problem":28,"user":"504e2333e4b0f6ff3350c46c"},{"code":"(fn lo [x]\r\n  (if(and(sequential? x)(> (count x) 0))\r\n    (lazy-seq (concat (lo (first x)) (lo (rest x))))\r\n    (if(not (sequential? x))(list x))))","problem":28,"user":"4de18de7535d08e6dec9fde8"},{"code":"#(loop [f () s (seq %)]\n  (if (= () s) f\n    (let [a (first s) b (rest s)]\n      (if (coll? a)\n        (recur f (concat a b))\n        (recur (concat f (list a)) b)))))","problem":28,"user":"4f0ce26c535d0136e6c22312"},{"code":"(fn rr [v] (apply concat (map #(if (sequential? %) (rr %) [%]) v)))","problem":28,"user":"532afdc5e4b09d4e7a9b552e"},{"problem":28,"code":"(fn flatter [s] \n  (let [[x & xs] s]\n    (cond \n     (empty? s) '()\n     (coll? x) (concat (flatter x) (flatter xs))\n     :else (cons x (flatter  xs)))))","user":"54684c3be4b00cfc9eacc139"},{"problem":28,"code":"(fn foo [ss]\n  (let [bar \n    (fn bar [s ret]\n      (cond\n        (empty? s) ret\n        (coll? (first s)) (bar (rest s)\n          (into ret (foo (first s))))\n        :else (bar (rest s) (conj ret (first s))))\n    )]\n  (bar ss [])))","user":"5fb8fe30e4b03f550f448223"},{"problem":28,"code":"#(loop [arg %\n       progress nil\n       acc []]\n  (println \"arg=\" arg ,\"progress=\" progress \",acc=\" acc)\n  (if (sequential? arg)\n    (if (empty? arg)\n      (recur progress nil acc)             \n      (recur (first arg)\n             (if (empty? (rest arg))\n               progress\n               (conj progress (rest arg))\n             )\n             acc            \n      )\n    )\n    (if (empty? progress)\n      (conj acc arg)\n      (recur progress nil (conj acc arg))\n    )\n  )\n)","user":"53f7820be4b0de5c41848560"},{"code":"#_(fn f [l]\n  (reduce #(concat % (if (coll? %2)\n                       (f %2) [%2]))\n          [] l))\n\n(fn f [l]\n  (mapcat #(if (coll? %) (f %) [%]) l))","problem":28,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn flat[lhs rhs]\n  (reduce\n   (fn [x y]\n     (if (not (coll? y))\n       (conj x y)\n       (flat x y))) lhs rhs))\n  []","problem":28,"user":"4fb86dc9e4b081705acca2d8"},{"code":"(fn flat [s]\n  (reduce (fn [ac x]\n           (concat ac\n                   (if (coll? x) (flat x) [x])))\n  \t\t  []\n  \t\t  s))","problem":28,"user":"51721aefe4b0d70c8bbbf24a"},{"problem":28,"code":"(fn f [x]\n  (if (coll? x) ;;;preguntamos si es \n    (mapcat f x) ;;; si es la volmevos a mandar, si no es, regresamos\n    [x])\n  )","user":"6075c214e4b069485764de5b"},{"problem":28,"code":"(fn my-flatten\n  [[f & r]]\n  (cond\n    (nil? f) '()\n    (sequential? f) (concat (my-flatten f) (my-flatten r))\n    :else (cons f (my-flatten r))\n\n))","user":"5c75a30ee4b0fca0c16227df"},{"problem":28,"code":"(fn myfn [item] \n  (if (sequential? item)\n    (if (> (count item) 0)\n      (concat (myfn (first item)) (myfn (rest item)))\n      (list))\n    (list item)))","user":"5a2cfa85e4b09cafd31c7f61"},{"problem":28,"code":"(fn f-1 [s]\n  (if (sequential? s)\n    (apply concat (map f-1 s))\n    [s]))","user":"5492164ee4b0b312c081ff3e"},{"problem":28,"code":"(fn flatten1 [a] (reduce (fn [acc new] (cond (string? new) (conj acc new)\n                   (sequential? new) (vec (concat acc (flatten1 new)))\n                   :else (conj acc new)))\n                  []\n                  a))","user":"542db41be4b0dad94371f2bb"},{"problem":28,"code":"(fn flat [s]\n  (let [f (first s)\n        r (rest s)]\n    (cond (empty? s) nil\n          ((complement sequential?) f)\n          (cons f (flat r))\n          :else (concat (flat f) (flat r)))))","user":"567debb5e4b05957ce8c61ce"},{"problem":28,"code":"(fn flat [coll] (reduce #(concat %1 (if (sequential? %2) (flat %2) [%2])) [] coll))","user":"5659679ae4b068f2fe63dbeb"},{"code":"(fn flat [x]\n  (if (not (coll? x))\n    (list x)\n     (if (empty? x)\n       x\n       (into (flat (rest x)) (reverse (flat (first x)))  )\n       )\n    )\n  )","problem":28,"user":"50f4894be4b004d364930528"},{"problem":28,"code":"(fn foo [s] \n  (if (coll? s)\n  \t(apply concat (map foo s))\n  \t[s]))","user":"577d3feee4b0c8d87281f6d2"},{"problem":28,"code":"(fn flatmax [c] (mapcat #(if (coll? %) (flatmax %) (list %)) c))","user":"4fbe2cfbe4b081705acca30c"},{"code":"#(remove % (tree-seq % seq %2))\ncoll?","problem":28,"user":"4db85bdd535d1e037afb218d"},{"code":"(fn myflatten [xs]\r\n  (if (empty? xs)\r\n    ()\r\n    (let [f (if (vector? (first xs))\r\n              (seq (first xs))\r\n              (first xs))\r\n          r (rest xs)]\r\n      (if (seq? f)\r\n        (concat (myflatten f) (myflatten r))\r\n        (conj (myflatten r) f)))))","problem":28,"user":"4dd023dd535d5973398f92ad"},{"code":"(fn foo \n  [l] \n  (mapcat \n    #(cond \n      (list? %) (foo %) \n      (vector? %) (foo %) \n      :else [%]) \n    l))","problem":28,"user":"4dbecb06535d020aff1edf6a"},{"problem":28,"code":"#(loop [rs ()\n         xs %]\n    (if (empty? xs)\n      rs\n      (let\n        [[x & xs] xs]\n        (if (coll? x)\n          (recur rs (concat x xs))\n          (recur (concat rs [x]) xs)))))","user":"4f8be895e4b02e764a0a5184"},{"code":"#(letfn [(flat [coll]\n            (lazy-seq\n              (when-let [c (seq coll)]\n                (let [x (first c)]\n                  (if (sequential? x)\n                    (concat (flat x) (flat (rest c)))\n                    (cons x (flat (rest c))))))))]\n    (if (sequential? %) (flat %) %))","problem":28,"user":"51fb9d30e4b0f1313d468a0f"},{"code":"(fn wha [x]\n  (if (coll? x)\n    (if (empty? x)\n      ()\n      (concat (wha (first x)) (wha (rest x))))\n    (list x)))","problem":28,"user":"509f3bc9e4b08df8156e9e39"},{"problem":28,"code":"(fn flat [c]\n  (if (coll? c)\n         (mapcat flat c)\n         [c]))","user":"5629e651e4b00e49c7cb4814"},{"code":"(fn my-flatten [coll]\n  (if (sequential? coll)\n    (apply concat (map my-flatten coll))\n    (list coll)))","problem":28,"user":"511060fae4b04c71fce993f1"},{"code":"(fn fl [sq] (loop [x sq result []] (if (seq x) (if (sequential? (first x)) (recur (rest x) (concat result (fl  (first x)))) (recur (rest x) (conj (vec result) (first x)))) result)))","problem":28,"user":"4efd98fa535de96065cf5086"},{"problem":28,"code":"(fn [x] \n  ((fn fltn [x fltlist]\n    (println x)\n    (println fltlist)\n    (if (empty? x) fltlist\n      (let [head (first x) rst (rest x)] \n        (if (or (vector? head) (seq? head))\n          (recur (concat head rst) fltlist)\n          (recur rst (conj fltlist head))\n        )\n      )\n    )\n  ) x []))","user":"59f85d78e4b0ca45a743a31a"},{"code":"(fn [l]\n  (loop [[f & args :as cur-l] l r '()]\n    (if (empty? cur-l)\n      r\n      (if (coll? f) \n        (recur (concat f args) r)\n        (recur args (concat r (list f)))))))","problem":28,"user":"4f7e29dde4b06e829148e1ca"},{"code":"(fn [coll]\n  (filter (complement sequential?)\n          (letfn\n              [(walkfn [node]\n                 (lazy-seq\n                  (cons node\n                        (when (sequential? node)\n                          (mapcat walkfn (seq node))))))]\n            (walkfn coll))))","problem":28,"user":"4f98ead0e4b0dcca54ed6cf8"},{"code":"(fn my-flatten [xs]\n  (let [f (first xs), r (rest xs)]\n  (cond\n    (nil? f) '()\n    (sequential? f) (concat (my-flatten f) (my-flatten r))\n    :else (cons f (my-flatten r)))))","problem":28,"user":"4fc40b0be4b081705acca344"},{"problem":28,"code":"(fn [coll]\n  (seq (reduce (fn my-flatten [v e]\n                 (if (coll? e)\n                   (reduce my-flatten v e)\n                   (conj v e)))\n               [] coll)))","user":"5da70ceee4b000c986472c11"},{"problem":28,"code":"(fn f\n  ([[x & xs]] (if (nil? x) [] (concat (if (sequential? x) (f x) [x]) (f xs)))))","user":"5d51377be4b0776584bd6f5d"},{"problem":28,"code":"(fn [s]\n  (loop [acc [], ws s]\n    (if (empty? ws)\n      acc\n      (let [x (first ws), xs (rest ws)] \n        (if (sequential? x)\n          (if (empty? x) \n            (recur acc xs)\n            (recur acc  (conj xs (rest x) (first x))))\n          (recur (conj acc x) xs))))))","user":"53213810e4b09d4e7a9b54b0"},{"problem":28,"code":"(fn flat [v] (if (coll? v) (apply concat (map flat v)) [v]))","user":"53dcf474e4b0d874e779ae25"},{"problem":28,"code":"(fn [x]\n  (filter (complement sequential?) (tree-seq sequential? seq x))\n)","user":"5f574662e4b0a0bc16850a90"},{"problem":28,"code":"#((fn flat [x acc]\n             (if (and (coll? x) (empty? x))\n               acc\n             (if (coll? x)\n               (concat (flat (first x) acc) (flat (rest x) acc))\n               (concat acc [x])))) % [])","user":"554be50de4b0a04f7929959c"},{"code":"(fn [x] (loop [l x]\n                (if (empty? (filter coll? l))\n                  l\n                  (recur (reduce\n                          #(concat (if (coll? %1) %1 (list %1))\n                                   (if (coll? %2) %2 (list %2)))\n                          l)))))","problem":28,"user":"4fa7de4ce4b081705acca1c9"},{"problem":28,"code":"(letfn [(flat [x & args]\n           (concat\n           (if (or (seq? x) (vector? x))\n             (mapcat flat x)\n             [x])\n           (if (empty? args) ()\n               (flat args))))]\n   flat)","user":"59f8b925e4b0ca45a743a327"},{"problem":28,"code":"(fn flattening [x] (reduce concat '() (map (fn [y] (if (coll? y) (flattening y) (list y))) x)))","user":"54091b82e4b0addc1aec66d5"},{"code":"(fn cc [x]\n  (if (sequential? x) (mapcat cc x) (list x)))","problem":28,"user":"523eb110e4b057c4b7cd0a67"},{"problem":28,"code":"(fn my-flatten\n  [lst]\n  (cond\n    (empty? lst)\n    lst\n    (list? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n   \t(vector? (first lst)) (concat (my-flatten (first lst)) (my-flatten (rest lst)))\n    :else (cons (first lst) (my-flatten (rest lst))\n    ))\n  )","user":"57fd7344e4b0d3187e9009b6"},{"problem":28,"code":"(fn [a]\n  (letfn [(flat' [a] (reduce\n                      (fn [f i]\n                        (concat f\n                                (if (and (false? (map? i)) (coll? i))\n                                  (flat' i)\n                                  [i])))\n                      []\n                      a))]\n    (flat' a)))","user":"5cf6522be4b0b71b1d808a58"},{"problem":28,"code":"(fn [x] (reduce (fn f [v e] (if (coll? e) (reduce f v e) (conj v e))) [] x))","user":"5933b736e4b072a2710fd05d"},{"problem":28,"code":"(fn f [xs]\n  (if (coll? xs)\n    (reduce concat (map f xs))\n    [xs]))","user":"54485749e4b032a45b8693c7"},{"problem":28,"code":"(fn flatten- [xs]\r\n  (loop [res []\r\n         xs xs\r\n         m '()]\r\n    (let [h (first xs)\r\n          t (rest xs)]\r\n      (if h\r\n        (if (or (list? h) (vector? h))\r\n          (recur res h (conj m t)) ;; down                                             \r\n          (recur (conj res h) t m)) ;; next                                            \r\n        (if (empty? m)\r\n          res ;; return                                                                \r\n          (recur res (first m) (rest m))))))) ;; up","user":"57210b6de4b0c5bde472c0a6"},{"code":"(fn f [s]\n  (letfn [ ( l [lst] (reverse  (into `() lst)))\n           ( make-first [x] (if (or (vector? x) (seq? x)) (l x) x))\n           ]\n    (if (empty? (l s ))\n      (l s)\n      (let [ list (l s)\n            head (make-first  (first list ))\n            tail (rest list)]\n        (if (seq? head)\n          (concat (f (l  head)) (f (l tail)))\n          (cons head (f (l tail)) ))))))","problem":28,"user":"51f81925e4b09be9c177e526"},{"code":"(fn myflatten [xs] (mapcat #(if (coll? %) (myflatten %)\t[%]) xs))","problem":28,"user":"50f2e5cee4b0ec8ee6fa8643"},{"problem":28,"code":"(fn flat [xs]\n  (reduce\n   #(if (coll? %2)\n    \t(concat %1 (flat %2))\n \t\t(concat %1 (list %2)))\n   '() xs))","user":"5536cbefe4b09218d5f44fc2"},{"problem":28,"code":"(fn flat-it [seq]\n   (if (coll? seq)\n     (mapcat flat-it seq)\n     [seq]))","user":"5d25abc9e4b02ea6f0fb6a37"},{"code":"#(filter (complement sequential?) (rest (tree-seq sequential? identity %)))","problem":28,"user":"4e78c208535db95036265722"},{"code":"(fn flattn [x] \n   (if (coll? x)\n     (if (seq x) \n       (into (flattn (rest x)) (reverse (flattn (first x)))) \n       () ) \n     (conj '() x) ) )","problem":28,"user":"4e8d5edd535d65386fec2134"},{"code":"(fn flat[s]\n  (let [[x & xs] s]\n    (cond\n     (empty? s) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)))))","problem":28,"user":"4ed9354f535d10e5ff6f5301"},{"code":"(fn [x] (filter (complement sequential?)\n                (rest (tree-seq sequential? seq x))))","problem":28,"user":"4e6cf521535de274dd8d818b"},{"code":"(fn flat [s]\n  (if (empty? s) nil\n    (let [f (first s) r (rest s)]\n      (concat\n        (if (sequential? f) (flat f) (list f))\n        (flat r)))))","problem":28,"user":"4fc5019ae4b081705acca36d"},{"problem":28,"code":"(fn my-flatten [sss]\n   (reduce (fn [acc s]\n             (if (coll? s)\n               (concat acc (my-flatten s))\n               (concat acc [s])))\n             '()\n             sss))","user":"604ccb9fe4b0b7ec0ac60ac1"},{"code":"(fn f[q](if(empty? q)q(let[p(first q)r(rest q)](concat(if(sequential? p)(f p)`(~p))(f r)))))","problem":28,"user":"4eb07be3535d7eef3080733b"},{"problem":28,"code":"(fn flatten-seq [lst]\n   (cond \n     (empty? lst) '()\n     (not (coll? (first lst))) (conj (flatten-seq (rest lst)) (first lst)) \n     :else (concat (flatten-seq (first lst)) (flatten-seq (rest lst)))))","user":"570e6974e4b0b0fb43fd06ef"},{"problem":28,"code":"(fn flat [xs]\n  (if (empty? xs) (list)\n    (let [f (first xs)\n          r (rest xs)]\n      (if (not (coll? f))\n        (cons f (flat r))\n        (concat (flat f) (flat r))\n      )\n    )\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"problem":28,"code":"(fn flat [input] \n  (if (empty? input) \n      [] \n      (if (sequential? (first input)) \n        (concat \n          (flat (first input))\n          (flat (rest input))\n        )  \n        (cons \n          (first input) \n          (flat (rest input))\n        )\n      )\n    )\n  )","user":"5c59b1d3e4b01df32ab73261"},{"problem":28,"code":"(fn [coll] (filter (complement sequential?) (tree-seq sequential? identity coll)))","user":"5880d686e4b0f1effa3b7623"},{"problem":28,"code":"(fn [x]\n    (letfn [(flat [coll] \n                  (lazy-seq \n                   (when-let [c (seq coll)] \n                     (let [x (first c)] \n                       (if (sequential? x) \n                         (concat (flat x) (flat (rest c))) \n                         (cons x (flat (rest c))))))))]\n    (if (sequential? x) (flat x) x)))","user":"5a07fefee4b01bb0ae8afde5"},{"problem":28,"code":"(fn [to-flatten]\n  (loop [xs to-flatten ys '()]\n    (cond\n      (empty? xs) (reverse ys)\n      (sequential? (first xs)) (recur (concat (first xs) (rest xs)) ys)\n      :else (recur (rest xs) (conj ys (first xs))))))","user":"5d68fc2fe4b0db5d338d1606"},{"code":"(fn my_flatten [s]\n  (mapcat #(if (coll? %) \n           (my_flatten %)\n           (list %)) s))","problem":28,"user":"524ab5f2e4b09eba1c02239d"},{"problem":28,"code":"(fn [coll]\n  (letfn \n    [(foo [[x & xs] res]\n              (cond (nil? x) res\n                    (coll? x) (recur xs (foo x res))\n                    :else (recur xs (conj res x)))\n     )\n    ]\n    \t(foo coll [])\n  )\n)","user":"5d07989ee4b0cc9c915881fb"},{"problem":28,"code":"(fn flatten-seq [input]\n  (loop [vals input result []]\n    (if (empty? vals) result\n        (let [val (first vals)]\n          (if (coll? val) (recur (rest vals) (into result (flatten-seq val)))\n              (recur (rest vals) (conj result val)))))))","user":"596aaeefe4b069c0a1a19808"},{"problem":28,"code":"(fn go-flat [n]\n  (if (empty? n)\n    []\n    (if (coll? (first n))\n      (into (go-flat (first n)) (go-flat (rest n)))\n      (into [(first n)] (go-flat (rest n))))))","user":"54750ca3e4b0c51c1f4d7294"},{"code":"(fn f [a] (if (coll? a) (mapcat f a) [a]))","problem":28,"user":"4fe9de74e4b0547ebccb2475"},{"problem":28,"code":"(fn f [x] (reduce (fn [a b] (concat a (if (coll? b) (f b) (list b)))) () x))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":28,"code":"(fn flt [l]\n  (if (first l)\n    (if (or (seq? (first l)) (vector? (first l)))\n      (concat (flt (first l)) (flt (next l)))\n      (cons (first l) (flt (next l))))\n    l))","user":"5cece5a2e4b0a17bb84e2bfb"},{"code":"(fn[x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))","problem":28,"user":"52271ffee4b04e78ff2e19a9"},{"code":"(fn fltn3 \n  ([sec] (fltn3 sec '()))\n  ([sec result] \n     (if (empty? sec)\n       result\n       (if (not (coll? (first sec))) \n         (recur (rest sec) (concat result (list (first sec))))\n         (recur (rest sec) (fltn3 (first sec) result) )))))","problem":28,"user":"51f297a3e4b0210f90e74552"},{"problem":28,"code":"(fn flat [xs]\n  (let [l (first xs) r (next xs)]\n    (concat\n     \t(if (sequential? l)\n          (flat l)\n          [l])\n\t\t(when (sequential? r)\n          (flat r)))))","user":"553b87abe4b09218d5f45003"},{"code":"(fn myflatten [xs] (mapcat (fn [x] (if (coll? x) (myflatten x) [x])) xs))","problem":28,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":28,"code":"(fn [coll]\n  (filter (complement sequential?) (rest (tree-seq sequential? seq coll))))","user":"5603c784e4b04bb52996e1c2"},{"problem":28,"code":"(fn [l]\n    (->> (tree-seq sequential? seq l) \n         rest\n         (filter (complement sequential?))))","user":"58dc5ceae4b0a4d5acaab69b"},{"problem":28,"code":"(fn myFn [L] (if (= 0 (count L))'()(if (sequential? (first L))(lazy-cat (myFn (first L)) (myFn (rest L)))(conj (myFn (rest L)) (first L)))))","user":"57395f32e4b0cd1946bd1070"},{"code":"(fn flat [items]\n  (if (coll? items)\n    (mapcat flat items)\n    [items]))","problem":28,"user":"4f0d093b535d0136e6c22313"},{"problem":28,"code":"(fn flat\n  [input-coll]\n  (reverse\n    ((fn rev-flat\n            [input]\n            (if (coll? input)\n              (reduce #(if (coll? %2) (concat (rev-flat %2) %1) (conj %1 %2)) '() input)\n              input))\n     input-coll)))","user":"5cb39440e4b026601754b903"},{"code":"(fn [x]\n  (filter (complement sequential?)\n     (rest (tree-seq sequential? seq x))))","problem":28,"user":"503ee85ce4b06c4e0e1fa26e"},{"problem":28,"code":"#(loop [[fst & rst :as all] % result []]\n      (if all\n        (if (sequential? fst)\n          (recur (into fst rst) result)\n        (recur rst (into result [fst])))\n        (sort result)))","user":"60759e51e4b069485764de5a"},{"problem":28,"code":";; I cheated here\n#(filter (complement sequential?)\n         (rest (tree-seq sequential? seq %)))","user":"5d5ef0bce4b0c9e5857d4ffb"},{"code":"#(remove coll? (tree-seq sequential? seq %1))","problem":28,"user":"5142ea50e4b0c172af7558ca"},{"problem":28,"code":"(fn my-flatten [[x & xs :as l]]\n  (cond (empty? l) nil\n        (coll? x) (concat (my-flatten x) (my-flatten xs))\n        :else (cons x (my-flatten xs))))","user":"5396c94be4b0b51d73faaee3"},{"code":"(fn flat [xs]\n  (if (empty? xs)\n    '()\n    (let [x (first xs)\n          flatrest (flat (rest xs))]\n      (if (coll? x)\n        (apply conj flatrest (reverse (flat x)))\n        (conj flatrest x)))))","problem":28,"user":"52aa4a67e4b0c58976d9ac62"},{"code":"#(filter (complement coll?) \n  (rest (tree-seq coll? seq %)))","problem":28,"user":"4f0333f6535dcb61093f6a77"},{"code":"(fn my-flatten [ls]\n    (if (coll? ls)\n      (if (empty? ls) \n        nil \n        (concat (my-flatten (first ls)) (my-flatten (rest ls))))\n      (list ls)))","problem":28,"user":"530b8580e4b02e82168697cc"},{"code":"(fn flat [n]\n    (let [[x & xs] n]\n      (cond\n       (empty? n) '()\n       (coll? x) (concat (flat x) (flat xs))\n       :else (cons x (flat xs)))))","problem":28,"user":"529b5301e4b02ebb4ef7509f"},{"problem":28,"code":"#(remove coll? (next (tree-seq coll? seq %)))","user":"55b22c33e4b0da326a65cf79"},{"problem":28,"code":"#(loop [s % flat ()] \n    (if (empty? s)\n      flat\n      (if (sequential? (last s))\n       (recur (concat (butlast s) (last s)) flat)\n       (recur (butlast s) (conj flat (last s)))\n      )\n    )\n  )","user":"5c0d0537e4b0bdcf453d173d"},{"code":"(fn fl \n  ([l] (fl l '())) \n  ([l base]\n    (cond\n      (= nil l) base\n\t    (not (sequential? l)) (conj base l)\n\t    :default (let [[h & t] l] (fl h (fl t base))))))","problem":28,"user":"4f16ef8a535d64f603146451"},{"code":"(fn my-flatten [x]\n  (if (coll? x)\n    (if (empty? x)\n      nil\n      (concat (my-flatten (first x))\n              (my-flatten (rest x))))\n    (list x)))","problem":28,"user":"5145c116e4b099c3fbe2884a"},{"code":"(fn f [xs] (mapcat #(if (coll? %) (f %) (list %)) xs))","problem":28,"user":"52d3f666e4b09f7907dd1327"},{"problem":28,"code":"(fn my-flatten [[x & xs]]\n  (cond (nil? x) nil\n        (coll? x) (concat (my-flatten x)\n                          (my-flatten xs))\n        :default (conj (my-flatten xs) x)))","user":"579c73fee4b05b1deef9ae08"},{"problem":28,"code":";; (fn my-flatten [x] (if (coll? x) (mapcat my-flatten x) [x]))\n(fn my-flatten [x]\n  ((fn [col acc]\n     (let [[head & tail :as all] col]\n       (if (empty? all)\n         acc\n         (recur tail (concat acc (if (coll? head) (my-flatten head) [head])))))\n    ) x [])\n)","user":"5aa998c6e4b0d174b936c8e5"},{"problem":28,"code":"(fn newflatten [x]\n  (let [innerfunction (fn [a b]\n            (if (coll? a)\n              (if (coll? b)\n                (concat (newflatten a) (newflatten b))\n                (concat (newflatten a) [b]))\n              (if (coll? b)\n                (concat [a] (newflatten b))\n                (concat [a] [b]))))]\n    \n    (reduce innerfunction [] x)))","user":"53ad28ede4b047364c044462"},{"problem":28,"code":"(fn myFlatten [seq]\n   (let [not-sequential? (complement sequential?)\n         flat? (fn [x] (every? not-sequential? x))\n         firstFlat? (fn [x] (not-sequential? (first x)))]\n     (if (flat? seq)\n       seq\n       (if (firstFlat? seq)\n         (concat (list (first seq)) (myFlatten (rest seq)))\n         (concat (myFlatten (first seq)) (myFlatten (rest seq))))\n       )\n     ))","user":"58775496e4b01531a375ea9a"},{"problem":28,"code":"(fn rep [xs]\n    (let [xx (reduce into [] (map (fn flatt [vc]\n                                    (if (sequential? vc)\n                                        (apply conj [] vc)\n                                        (conj [] vc))) xs))]\n    \n    (if (not (every? (complement sequential?) xx))\n        (rep xx)\n        xx)))","user":"5f6580e7e4b02876ed9fd023"},{"problem":28,"code":"(fn flat [coll]\n  (if (sequential? coll)\n    (apply concat (map flat coll))\n    [coll]))","user":"55a161d1e4b0acc240e31511"},{"problem":28,"code":"(fn our-flatten\n  [s]\n  (cond (not (coll? s)) (list s)\n        (empty? s) s\n        :else (concat (our-flatten (first s))\n                      (our-flatten (rest s)))))","user":"5777c3d6e4b0979f8965164f"},{"problem":28,"code":"(fn [s]\n   (loop [ss s]\n     (cond (some coll? ss) (recur (reduce (fn [result e]\n  (cond (coll? e) (vec (concat result e))\n        :else (conj result e))) [] ss))\n           :else ss)))","user":"5b2689e3e4b063e2438bcc33"},{"problem":28,"code":"(fn fla [x]\n  (if (sequential? x)\n    (mapcat fla x)\n    [x]))","user":"55536a8ae4b0deb715856e03"},{"problem":28,"code":"(fn f [x] (reduce #(if (coll? %2) (concat %1 (f %2)) (concat %1 (list %2))) '() x))","user":"54ff2342e4b07d26eda61d49"},{"problem":28,"code":"(fn flatseq [seq]\n    (let [[x & rest-col] seq]\n      (cond (empty? seq) '()\n            (coll? x) (concat (flatseq x) (flatseq rest-col))\n            :else (cons x (flatseq rest-col))))\n    )","user":"567b62fce4b05957ce8c61a6"},{"code":"(fn [s]\r\n  (if (not (some coll? s))\r\n    s\r\n    (recur (reduce concat (map #(if (coll? %) % (list %)) s)))))","problem":28,"user":"4f8aa1c1e4b02e764a0a516e"},{"problem":28,"code":"(fn f [coll]\n  (if (sequential? coll)\n    (mapcat f coll)\n    [coll]))","user":"59d8f23ae4b0ef0a1e9b5c49"},{"problem":28,"code":"(fn fl \n  [coll] \n  (cond \n   \t(nil? coll) []\n    (and (sequential? coll) (empty? coll)) coll\n    (not (sequential? coll)) [coll]\n   \t(sequential? coll) (concat (fl (first coll)) (fl (rest coll)))))","user":"4df73d64535d04ed9115e775"},{"problem":28,"code":";(fn flat-rec [lst]\n;  (reduce\n;   (fn [xs x]\n;     (if (sequential? x) (concat xs (flat-rec x)) (cons x xs))) '() lst))\n\n\n(fn rec-flat [lst & {:keys [fs] :or {fs []}}]\n  (reduce\n   (fn [xs x]\n     (if (sequential? x) (rec-flat x :fs xs) (conj xs x))) fs lst))","user":"58c66990e4b021aa9917ed53"},{"problem":28,"code":"(fn [x]\n     (reduce\n       (fn my-flatten\n         [acc x]\n         (if (coll? x)\n           (reduce my-flatten acc x)\n           (conj acc x)))\n       []\n       x))","user":"594ea2a4e4b07ddc2dafaeb6"},{"code":"(fn my-flatten [coll]\r\n  (mapcat (fn [x] (if (coll? x) \r\n                    (my-flatten x) \r\n                    [x] )) coll))","problem":28,"user":"4f038ed6535dcb61093f6b24"},{"problem":28,"code":"(fn [v]\n    (loop [ret [] fst (first v) rst (rest v)]\n          (cond\n            (sequential? fst) (recur ret (first fst) (concat (rest fst) rst))\n            (empty? rst) (seq (conj ret fst))\n            :else (recur (conj ret fst) (first rst) (rest rst))\n            )))","user":"556ff203e4b09a3098a52526"},{"problem":28,"code":"(fn flt \n  ([xs] (flt xs []))\n  ([xs res]\n   \t(reduce (fn [ac itm]\n              (if (coll? itm) (flt itm ac) (conj ac itm))\n              ) res xs)\n   )\n)","user":"5d5eb086e4b0c9e5857d4ff7"},{"code":"(letfn [(conj7 [q a] (if (coll? a) (reduce conj7 q a) (conj q a)))] (fn [q] (reduce conj7 [] q)))","problem":28,"user":"532e0b20e4b019098a6f8b45"},{"problem":28,"code":"(fn my-flatten[coll]\n  (seq\n   (reduce (fn my-flatten [v e]\n             (if (coll? e)\n               (reduce my-flatten v e)\n               (conj v e)))\n                              [] coll)))","user":"5a6cb2eae4b0512ff01cda57"},{"code":"(fn myflatten [v]\n  (loop [s v r [] first-col (coll? (first v))]\n\t\t\n\t\t(if (seq s) (let [_s (if first-col (into (vec (first s)) (rest s)) (rest s))\n\t\t\t\t _r (if first-col r (conj r (first s)))\t]\n\t\t\t(recur _s _r (coll? (first _s))\n\n))r )))","problem":28,"user":"507bb3ece4b09034bfeeb720"},{"code":"(fn fla [x]\n  (if (coll? x)\n    (when (seq x) (concat (fla (first x)) (fla (rest x))))\n    [x])\n  )","problem":28,"user":"50ab8ae3e4b01d6eb43ce9a0"},{"code":"(fn flat [coll]\n  (if (empty? coll) coll\n    (let [[l & r] coll]\n      (if (coll? l)\n        (concat (flat l) (flat r))\n        (concat [l] (flat r))\n      )\n    )\n  )\n)","problem":28,"user":"50e8a340e4b0ebbe794eb7ed"},{"code":"(fn\n  [x]\n\t  (filter (complement sequential?)\n\t          (rest (tree-seq sequential? seq x))))","problem":28,"user":"5153316ce4b0252ac4b16611"},{"problem":28,"code":"(fn\n  [x]\n  (filter (complement sequential?) (tree-seq sequential? seq x)))","user":"5c6cb3bfe4b0fca0c1622730"},{"problem":28,"code":"(fn flatten-list [s]\n  (if (coll? s)\n    (mapcat flatten-list s)\n    [s]))","user":"608c270ae4b03bd49d9f36b3"},{"problem":28,"code":"(fn [x]\n  (loop [z x l '()]\n    (if (empty? z)\n      (reverse l)\n      (if (sequential? (first z))\n        (recur (concat (first z) (rest z)) l)\n        (recur (rest z) (conj l (first z))))\n    \n      )))","user":"5dd70ee3e4b0948ae9d9ad85"},{"code":"(fn fltn [lst]\n  (println lst)\n  (if (empty? lst)\n    ()\n    (if (not (coll? lst))\n      lst\n      (if (coll? (first lst))\n          (concat (fltn (first lst))\n            (fltn (rest lst)))\n          (concat (list (first lst))\n            (fltn (rest lst)))))))","problem":28,"user":"4f3a7e50e4b0e243712b1f0d"},{"problem":28,"code":"(fn flatten-recur\n  ([xs] (flatten-recur [] xs))\n  ([acc xs]\n     (if-not\n      (coll? xs) (conj acc xs)\n      (if (empty? xs)\n        acc\n        (-> (flatten-recur acc (first xs))\n            (flatten-recur (rest xs)))))))","user":"53716539e4b0fc7073fd6eb1"},{"code":"(fn f [c] (reduce #(if (coll? %2) (vec (concat %1 (f %2))) (conj %1 %2)) [] c))","problem":28,"user":"528d1094e4b0239c8a67aebe"},{"problem":28,"code":"#(loop [c % n (list)]\n\t(if-let [x (first c)]\n\t\t(if (coll? x) \n\t\t\t(recur (cons (first x) (concat (rest x) (rest c))) n)\n\t\t\t(recur (rest c) (concat n (list x ))))\n\t\tn ))","user":"56bb9ccce4b0f26550335959"},{"problem":28,"code":"(fn flat \n  [x]\n  (if (coll? x)\n    (apply concat (map flat x))\n    [x]))","user":"56e99ec8e4b04a395b9a03fb"},{"code":"(fn fla [x]\r\n                 (when-let [x (seq x)]\r\n                 (if (empty? x) []\r\n                   (let [fst (first x)]\r\n                   (if (sequential? fst)\r\n                     (concat (fla fst) (fla (rest x)))\r\n                     (cons fst (fla (rest x))))))))","problem":28,"user":"5031eb3be4b000fc67a99a84"},{"code":"(fn [sq]\n  ((fn red-val [lst]\n    (reverse (reduce (fn [memo newVal]\n              (if (sequential? newVal)\n                (into memo (red-val newVal))\n                (cons newVal memo))) '() lst))) sq))","problem":28,"user":"51c76864e4b07ef393169e3f"},{"problem":28,"code":"(fn [x] (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))\n;(fn flat [ls] \n;  (cond \n;    (empty? ls)           '()\n;    (coll? (first ls))     (union (flat (first ls)) (flat (rest ls)))\n;    :else                  (cons (first ls) (flat (rest ls)))\n;    \n;  )\n;)","user":"546d41bde4b00cfc9eacc18c"},{"problem":28,"code":"(fn skflat [s]\n  (reduce\n    (fn myflatten[coll e]\n      (if (sequential? e)\n        (reduce myflatten coll e)\n        (conj coll e)))\n    []\n    s)\n  )","user":"5884f377e4b0f1effa3b76a8"},{"problem":28,"code":"(fn\n  [obj]\n  (let [loopy (fn [obj acc]\n                 (cond\n                   (empty? obj) acc\n                   (sequential? (first obj)) (recur (concat (first obj) (rest obj)) acc)\n                   :else (recur (rest obj) (conj acc (first obj)))))]\n    (loopy obj [])))","user":"59a8a4dce4b0bcf4e9a43af7"},{"code":"(fn foo [t] (reduce #(if (coll? %2) (concat %1 (foo %2)) (concat %1 [%2])) [] t))","problem":28,"user":"4f070ce6535dcb61093f6c1e"},{"code":"(fn f [c] (if (coll? c) (mapcat f c) (cons c nil)))","problem":28,"user":"50fe9d60e4b03cd852b4e84f"},{"problem":28,"code":"(fn f [xs]\n    (cond\n      (empty? xs)\n      ()\n\n      :else\n      (let [ys (first xs)]\n        (cond\n          ;; seq?\n          (or (list? ys) (vector? ys)) (concat (f ys) (f (rest xs)))\n          :else\n          (conj (f (rest xs)) ys)))))","user":"55955c0be4b0c79f6e1db967"},{"problem":28,"code":"(fn a [c] (reduce #(if (coll? %2) (concat % (a (vec %2)) ) (conj (vec %) %2 )) [] c))","user":"5a6dbaf5e4b0512ff01cda63"},{"problem":28,"code":"(fn [x]\n  (letfn [(make-flat [s]\n          (if (sequential? s)\n            (mapcat #(if (sequential? %) (make-flat %) [%]) s)\n            s))]\n  (make-flat x)))","user":"50f4eee0e4b004d36493052d"},{"code":"(fn p [l]\n  (mapcat #(if (coll? %) (p %) `(~%)) l))","problem":28,"user":"4fa11204e4b0dcca54ed6d56"},{"problem":28,"code":"(fn __ [x]\n  (if (coll? x)\n    (if (empty? x)\n      x\n      (concat (__ (first x)) (__ (rest x))))\n    (conj '() x)))","user":"573118ebe4b0cd1946bd0fbd"},{"problem":28,"code":"(fn myflat [[x & xs]]\n  (concat\n   (if (coll? x) (myflat x) (list x))\n   (if (seq xs) (myflat xs) '())))","user":"5cab33e7e4b048ec896c5c48"},{"problem":28,"code":"(fn squash [data]\n  (loop [[head & tail :as data] data\n         acc []]\n    (if (empty? data)\n      acc\n      (recur tail (loop [[head & tail] data\n                         utail tail\n                         acc acc]\n                    (if (or (list? head)\n                            (vector? head)\n                         )\n                      (recur head utail acc)\n                      (if (empty? tail)\n                        (conj acc head)\n                        (if (= utail tail)\n                           (conj acc head)\n                           (recur tail utail (conj acc head))\n                         )\n                       )\n                     )\n                   )\n      )\n    )\n  )\n)","user":"55c461d3e4b0e31453f64999"},{"code":"(fn asdf\n \n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"5012036ce4b0a040369c12f4"},{"code":"#( filter (complement sequential?)  (rest (tree-seq sequential? seq %  ) ) )","problem":28,"user":"5191045ee4b0f8ef0be96bf3"},{"problem":28,"code":"(fn f [l] (if (coll? l) (mapcat f l) [l]))","user":"5800edaae4b0a837a8b30c48"},{"problem":28,"code":"(fn [coll]\n  (loop [flatcoll '() \n         c coll\n         safety 100]\n    (println \"flatcoll\" flatcoll \"c\" coll \"rc\" (rest c))\n    (if (or (empty? c) (< safety 0)) \n      (reverse flatcoll) \n      (cond \n       (not (coll? (first c))) (recur\n                                (conj flatcoll (first c))\n                                (rest c)\n                                (dec safety)) \n       (and (coll? (first c)) (empty? (first c))) (recur \n                                                   flatcoll \n                                                   (rest c)\n                                                   (dec safety))\n       (coll? (first c)) (recur \n                          flatcoll\n                          (conj (rest c) (rest (first c)) (first (first c)))\n                          (dec safety))) \n      )))","user":"6014ccd3e4b074f607df66cd"},{"problem":28,"code":"(fn make-flat\n  [coll]\n  (if (not (sequential? coll))\n    [coll]\n    (loop\n      [flat []\n       remaining coll]\n      (let [x (first remaining)\n            xs (rest remaining)]\n       (if (nil? x)\n        flat\n        (recur (apply conj flat (make-flat x)) xs))))))","user":"540b2dcbe4b0addc1aec66f4"},{"problem":28,"code":"(fn flat [n]\n  (let [[x & xs] n]\n    (cond \n     (empty? n) '()\n     (coll? x) (concat (flat x) (flat xs))\n     :else (cons x (flat xs)) )))","user":"560c404fe4b05f002753df30"},{"problem":28,"code":"(fn flt [s] (if (sequential? s) (mapcat flt s) (list s)))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [col] (reverse ((fn a [x] (reduce (fn [b c] (if (sequential? c) (concat (a c) b) (cons c b))) [] x)) col)))","problem":28,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn f [coll]\n  (mapcat #(if (sequential? %) (f %) [%]) coll))","problem":28,"user":"4ec5a5f9535d6d7199dd36ad"},{"problem":28,"code":"(fn [s] (filter (complement sequential?) (tree-seq sequential? identity s)))","user":"58b51e05e4b0ebc645576d4c"},{"problem":28,"code":"(fn my-flatten [xs]\n  (if (not (sequential? xs))\n    [xs]\n    (when (not (empty? xs))\n      (concat (my-flatten (first xs)) (my-flatten (rest xs))))))","user":"57006957e4b08d47c97781c8"},{"code":"(fn\n  [x]\n  (filter \n    (complement sequential?)\n    (rest (tree-seq sequential? seq x))))","problem":28,"user":"4f73f78de4b044e54cd9a8f3"},{"problem":28,"code":"(fn my-flatten [L]\n  (if (sequential? L)\n    (reduce concat () (map my-flatten L))\n    (list L)))","user":"556238bce4b0c656e3ff17d3"},{"code":"(fn myFlat-list\n    ([x y]\n        (if (empty? x)\n            y\n        (myFlat-list (rest x)\n            (concat y\n                ((fn myFlat-entry [x]\n                    (if (coll? x)\n                        (concat \n                            (myFlat-entry (first x))\n                            (myFlat-list (rest x) []))\n                    [x])) (first x))\n            )))\n    )\n    ([x] (myFlat-list x [])))","problem":28,"user":"4f03b3fb535dcb61093f6b52"},{"code":"(fn flutch\n  [x1] (if (coll? x1)\n          (mapcat flutch x1)\n          [x1]))","problem":28,"user":"4e48b61d535dc968683fc4be"},{"problem":28,"code":"(fn f [y] \n   (reduce\n     (fn [acc x] \n       (if (coll? x) \n         (concat acc (f x))\n         (concat acc [x])\n         )) [] y))","user":"5c308385e4b0d62ef62d9f1c"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (reduce (fn [a b] (if (sequential? b)\n                      (concat a (my-flatten b))\n                      (concat a [b])))\n          `() coll))","user":"565d8dcfe4b068f2fe63dc26"},{"problem":28,"code":"(fn my_flat [element]\n  (if-not(coll? element)\n   (list element)\n  (loop [results []\n          elements element]\n     (if(empty? elements)\n       results\n       (recur (concat results (my_flat (first elements))) (rest elements))))))","user":"53f50c03e4b0db01ade6f9ca"},{"problem":28,"code":"; tree-seq\n#(filter (complement sequential?) (rest (tree-seq sequential? seq %)))","user":"5474d1f4e4b0c51c1f4d728c"},{"problem":28,"code":"(fn my-flatten\n  [coll]\n  (seq (reduce (fn [flattened-seq item]\n            (if (coll? item)\n              (into flattened-seq (my-flatten item))\n              (conj flattened-seq item)))\n          []\n          coll)))","user":"5b82eec6e4b047b03b2037a4"},{"code":"(fn [x] \n  (loop\n\t\t[toRead [x] out []]\n\t\t(if (empty? toRead)\n\t\t\tout\n\t\t\t(if (coll? (first toRead))\n\t\t\t\t(recur (reduce conj (rest toRead) (first toRead)) out)\n\t\t\t\t(recur (rest toRead) (cons (first toRead) out))\n\t\t\t)\n\t\t)\n\t)\n)","problem":28,"user":"50bf74c7e4b0ffd967a66cc0"},{"code":"(fn flat [x] \n  (let [head (first x) tail (rest x)]\n    (cond     \n      (empty? x) nil\n      (coll? head) (concat (flat head) (flat tail))\n      (not (coll? head)) (conj (flat tail) head))))","problem":28,"user":"525aa499e4b0cb4875a45cf7"},{"problem":28,"code":"(fn flt [x] ; in fact deep first search\n  (loop [t x acc []]\n    (if (empty? t)\n      acc\n      (let [el (first t)]\n        (if (sequential? el)\n          (recur (next t) (reduce conj acc (flt el)))\n          (recur (next t) (conj acc el)))\n        )\n      )\n    )\n  )","user":"515d414be4b00901442db1db"},{"code":"(fn p28b [s]\n  (mapcat #(if (sequential? %)\n                (p28b %)\n                (list %))\n          s))","problem":28,"user":"53487737e4b084c2834f4a59"},{"problem":28,"code":"(fn flt [s]\n  (let [f (first s)\n        r (next s)]\n    (concat\n     (if (sequential? f)\n       (flt f)\n       [f])\n     (when (sequential? r)\n       (flt r)))))","user":"54b31445e4b09f271ff37d35"},{"code":"(fn [coll]\n  (seq\n    (reduce\n      (fn fltn [acc x]\n        (if (coll? x)\n          (reduce fltn acc x)\n          (conj acc x)))\n      [] coll)))","problem":28,"user":"51ce1320e4b0e42293a22551"},{"code":"#(loop [l % r []] \n  (if (= l []) \n  \tr \n\t\t(let [n (first l) m (rest l)] (if (coll? n)\n\t\t\t(recur (concat n m) r)\n\t\t\t(recur m (conj r n))))))","problem":28,"user":"4efb87f7535dced4c769f279"},{"code":"(fn flat [sq] (if (not-any? coll? sq) sq (flat (mapcat #(if (not (coll? %)) (cons % []) %) sq))))","problem":28,"user":"52aad30ce4b0c58976d9ac6d"},{"problem":28,"code":"(fn f [x]\n    (cond\n     (= nil x) x,  \n     (coll? x) (lazy-cat (f (first x)) (f (next x))),\n     :else (list x)))","user":"53fcdd1ae4b0de5c418485dd"},{"code":"(fn\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))","problem":28,"user":"4eb0afed535d7eef3080733e"},{"problem":28,"code":"#(loop [iv %]\n    (if (not-any? sequential? iv)\n      iv\n      (recur (mapcat (fn [a] (if (sequential? a) a [a])) iv))\n      ))","user":"57d0e185e4b0bd073c202360"},{"code":"(letfn [(flatten1 [x]\n          (if (coll? x)\n            (mapcat flatten1 x)\n            [x]))]\n  (fn [xs] (mapcat flatten1 xs)))","problem":28,"user":"5339c105e4b0e30313ee6cae"},{"problem":28,"code":"(fn myflat [xs]\n  (cond\n    (empty? xs) '()\n\t(not (coll? (first xs))) (cons (first xs) (myflat (rest xs)))\n    :else (concat (myflat (first xs)) (myflat (rest xs)))\n  )\n)","user":"53b9bb15e4b047364c0444ed"},{"problem":28,"code":"(fn my-flatten [xs]\n  (reduce\n   (fn [acc x]\n     (if (sequential? x)\n       (concat acc (my-flatten x))\n       (concat acc [x])\n     ))\n   []\n   xs\n   ))","user":"5b9db58be4b0c0b3ffbd4b41"}]