[{"problem":"177","code":"#(= ()\n       (reduce \n      (fn [a x]\n(if a (case x\n       (\\[ \\{ \\() (conj a x)\n       (\\] \\} \\)) \n           (if (= ({\\] \\[ \\} \\{ \\) \\(} x) (first a))\n                          (rest a) nil)\n       a)))\n   () %))","user":"55be39f9e4b01b9910ae2a06"},{"problem":"177","code":"#(loop [delims (re-seq #\"[({\\[)}\\]]\" %)\n        stack '()]\n   (cond\n     (and (empty? delims) (empty? stack)) true\n     (#{\"[\" \"(\" \"{\"} (first delims))\n     (recur (rest delims) (cons (first delims) stack))\n     (= (first stack) ({\"]\" \"[\" \")\" \"(\" \"}\" \"{\"} (first delims)))\n     (recur (rest delims) (rest stack))      \n     :else false))","user":"55d0e76ae4b0e31453f64a40"},{"problem":"177","code":"(fn prn-bal [s]\n  (letfn [(paired [left right]\n            (= right (get {\\( \\) \\[ \\] \\{ \\}} left)))]\n    (loop [[c & mas :as s] (vec s)\n           ub []]\n      (cond\n        (empty? s)\n        (empty? ub)\n\n        (some #{c} \"{[(\")\n        (recur mas (conj ub c))\n\n        (some #{c} \")]}\")\n        (if (paired (last ub) c)\n          (recur mas (pop ub))\n          false)\n\n        :default\n        (recur mas ub)))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":"177","code":"#(let [tokens {\\[ \\]\n               \\( \\)\n               \\{ \\}}]\n   (empty? ((fn remove-balanced [expression]\n              (if (tokens (first expression))\n                (let [remaining (remove-balanced (rest expression))]\n                  (if (= (tokens (first expression)) (first remaining))\n                    (remove-balanced (rest remaining))\n                    [1]))\n                expression))\n            (filter (into #{} (flatten (vec tokens)))\n                    %))))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn f [l x]\n  (if (empty? x)\n    (= l [])\n    (cond (#{\\[ \\{ \\(} (first x)) (f (into l [(first x)]) (rest x))\n          (#{\\] \\} \\)} (first x)) (if (= ({\\[ \\] \\{ \\} \\( \\)}\n                                            (last l)) (first x))\n                                    (f (pop l) (rest x))\n                                    false)\n          :else (f l (rest x)))))\n                []","problem":"177","user":"529b44afe4b02ebb4ef7509d"},{"problem":"177","code":"(fn balanced-brackets? [in]\n  (let [pairs {\\( \\), \\{ \\}, \\[ \\]}\n        valid (set \"(){}[]\")]\n    (empty?\n      (reduce (fn [[top & tail :as stack] curr_in]\n                (cond (= (pairs top) curr_in) tail\n                      (valid curr_in) (conj stack curr_in)\n                      :else stack))\n              () in))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":"177","code":";(fn [xs]\n;\t(let [lefts  #{\\{ \\( \\[} \n;\t\t  rights #{\\} \\) \\]}\n;\t\t  pair {\\{ \\} \\( \\) \\[ \\]}]\n;\t\t(loop [remaining xs left-bracket []]\n;\t\t\t(cond (empty? remaining) (if (empty? left-bracket) true false)\n;\t\t\t\t  ((complement nil?) (lefts (first remaining))) \n;\t\t\t\t  (recur (drop 1 remaining) (conj left-bracket (first remaining)))\n;\t\t\t\t  ((complement nil?) (rights (first remaining)))\n;\t\t\t\t  (if (not= (first remaining) (pair (peek left-bracket)))\n;\t\t\t\t  \tfalse\n;\t\t\t\t  \t(recur (drop 1 remaining) (pop left-bracket)))\n;\t\t\t\t  :else (recur (drop 1 remaining) left-bracket)))))\n\n\n(fn [xs]\n\t(= '()\n\t\t(reduce (fn [a x]\n\t\t\t\t\t(let [pair {\\} \\{ \\) \\( \\] \\[}]\n\t\t\t\t\t\t(cond \n\t\t\t\t\t\t\t(= a :F) :F\n\t\t\t\t\t\t\t(#{\\{ \\( \\[} x) (conj a x)\n\t\t\t\t\t\t\t(#{\\} \\) \\]} x) (if (= (pair x) (first a)) (rest a) :F)\n\t\t\t\t\t\t\t:else a)))\n\t\t\t\t'()\n\t\t\t\txs)\n\t\t))","user":"55b8c339e4b01b9910ae29b9"},{"code":"(fn balanced?                                                               \n  [x]                                                                         \n  (let [tokens (vec (clojure.string/replace x #\"[^\\(\\)\\[\\]\\{\\}]\" \"\"))         \n        brackets { \\{ \\} \\( \\) \\[ \\]}                                         \n        starting-bracket? (fn [x] (brackets x))                               \n        matching-bracket? (fn [a b] (= (brackets a) b))]                      \n    (loop [stack '() items tokens]                                            \n      (let [curr (first items)]                                               \n        (if (empty? items)                                                    \n          (empty? stack)                                                      \n          (if (starting-bracket? curr)                                        \n            (recur (conj stack curr) (rest items))                            \n            (if (matching-bracket? (first stack) curr)                        \n              (recur (rest stack) (rest items))                               \n              (recur (conj stack curr) (rest items))                          \n              )))))))","problem":"177","user":"50573ed8e4b0012181721987"},{"problem":"177","code":"(letfn [(balanced [s p]\n           (if (= \"\" s)\n             (= \"\" p)\n             (let [a (first s)]\n               (cond (or (= \\[ a)\n                         (= \\{ a)\n                         (= \\( a)) (balanced (.substring s 1) (str a p))\n                     (= \\) a) (and (= \\( (first p))\n                                   (balanced (.substring s 1)\n                                             (.substring p 1)))\n                     (= \\] a) (and (= \\[ (first p))\n                                   (balanced (.substring s 1)\n                                             (.substring p 1)))\n                     (= \\} a) (and (= \\{ (first p))\n                                   (balanced (.substring s 1)\n                                             (.substring p 1)))\n                     true (balanced (.substring s 1) p)))))]\n  (fn [s]\n  \t(balanced s \"\")))","user":"4f6fbb68e4b07046d9f4efeb"},{"problem":"177","code":"(fn balance-bracket\n  [s]\n  (letfn [(balance-bracket* [[x & more :as coll] stack m]\n            (if (seq coll)\n              (if (#{\\( \\{ \\[} x) (balance-bracket* more (cons x stack) m)\n                  (if (= (m x) (first stack))\n                    (balance-bracket* more (rest stack) m)\n                    false))\n              (empty? stack)))]\n    (balance-bracket* (filter #{\\) \\( \\[ \\] \\{ \\}} s) [] {\\) \\( \\} \\{ \\] \\[})))","user":"557e9d17e4b05c286339e0d8"},{"problem":"177","code":"(fn\n  [s]\n  (let [b {\\) \\(\n           \\] \\[\n           \\} \\{}\n        res (reduce (fn [l c]\n                      (let [prev (first l)]\n                        (cond\n\n                         (or (= \\{ c) (= \\[ c) (= \\( c))\n                         (conj l c)\n\n                         (or (= \\} c) (= \\] c) (= \\) c))\n                         (if (= prev (get b c))\n                           (rest l)\n                           (conj l \\x))\n\n                         :else\n                         l)))\n                    () s)]\n    (if (= res '())\n      true\n      false)))","user":"56bb652ae4b0f26550335953"},{"problem":"177","code":"(fn balance [string]\n  (loop [[chr & rest] string\n         stack '()]\n    (case chr\n      \\( (recur rest (conj stack \\())\n      \\{ (recur rest (conj stack \\{))\n      \\[ (recur rest (conj stack \\[))\n      \\] (if (= \\[ (peek stack))\n           (recur rest (pop stack))\n           false)\n      \\} (if (= \\{ (peek stack))\n           (recur rest (pop stack))\n           false)\n      \\) (if (= \\( (peek stack))\n           (recur rest (pop stack))\n           false)\n      nil (empty? stack)\n      (recur rest stack))))","user":"5abeb697e4b073f177442725"},{"problem":"177","code":"(fn balanced? [s]\n        (let [left [\\[ \\( \\{]\n              right [\\] \\) \\}]\n              dictionary {\\[ \\] \\( \\) \\{ \\}}\n              elim (fn [x i]\n                    (vec (concat (take i x) (drop (inc i) x))))]\n          (loop [text (vec s) inmost 0 counter 0]\n            (if (empty? text)\n              true\n              (if (some #{(get text inmost)} right)\n                false\n                (if (some #{(get text inmost)} left)\n                  (if (> counter (dec (count text)))\n                    false\n                    (if (= (get dictionary (get text inmost)) (get text counter))\n                      (recur (elim (elim text inmost) (dec counter)) 0 0)\n                      (if (some #{(get text counter)} right)\n                        false\n                        (if (some #{(get text counter)} left)\n                          (recur text counter (inc counter))\n                          (recur text inmost (inc counter))))))\n                  (recur (elim text inmost) inmost counter)))))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":"177","code":"(fn [string]\n  (let [s (filter #{\\[ \\] \\{ \\} \\( \\)} string)]\n    (loop [[h & t] s stack []]\n      (if h\n        (case h\n          \\( (recur t (conj stack h))\n          \\{ (recur t (conj stack h))\n          \\[ (recur t (conj stack h))\n          \\) (if (= (last stack) \\()\n               (recur t (pop stack))\n               false\n             )\n          \\] (if (= (last stack) \\[)\n               (recur t (pop stack))\n               false\n             )\n          \\} (if (= (last stack) \\{)\n               (recur t (pop stack))\n               false\n             )\n                                   \n        )\n        (empty? stack)\n      )\n    )\n  )\n)","user":"5df08767e4b093ff717275bf"},{"problem":"177","code":"(fn [str]\n  (let [\n    openers #{\n      \\{\n      \\[\n      \\(\n    }\n    closers #{\n      \\}\n      \\]\n      \\)\n    }\n    matching {\n      \\{ \\}\n      \\[ \\]\n      \\( \\)\n    }\n    reducer\n      (fn [openChars ch]\n        (if (contains? openers ch)\n          ; Prepend to our list of opening chars\n          (cons ch openChars)\n          (if (contains? closers ch)\n            ; Check if this closing char matches our current opening char\n            (if (= ch (matching (first openChars)))\n              (rest openChars)\n\n              ; No match => string is invalid\n              (cons nil openChars))\n\n            ; Ignore the non opening/closing chars\n            openChars)))\n  ]\n  (= 0 (count (reduce reducer '() str)))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":"177","code":"(fn [s]\n  (let [bpairs {\\[ \\] \\( \\) \\{ \\}}\n        opens? (set (keys bpairs))\n        closes? (set (vals bpairs))\n        proc-char (fn [stack c]\n                    (cond\n                      (opens? c) (conj stack c)\n                      (closes? c) (if (= (bpairs (last stack)) c)\n                                    (pop stack)\n                                    (conj stack \"fail\")) ;;check match\n                      :else stack))]\n    (empty? (reduce proc-char [] s))))","user":"4e8768f6535dceadca469850"},{"problem":"177","code":"(fn [string] \n  (let [open-char { \\( \\), \\[ \\], \\{ \\} }\n        close-char { \\) \\(, \\] \\[, \\} \\{ }]\n    (loop [stack '() tape (seq string)]\n      (cond (empty? tape) (empty? stack)\n            (contains? open-char (first tape)) (recur (conj stack (get open-char (first tape))) (rest tape))\n            (contains? close-char (first tape)) (if (= (first tape) (first stack)) (recur (rest stack) (rest tape)) false)\n            :else (recur stack (rest tape))))))","user":"595fd721e4b066ee0a44b06e"},{"problem":"177","code":"(fn balanced? [s]\n  (let [p {\\( \\) \\[ \\] \\{ \\}}\n        a (set \"()[]{}\")]\n    (empty?\n     (reduce (fn [[t & b :as stack] s]\n               (cond (= (p t) s) b\n                     (a s) (conj stack s)\n                     :else stack))\n             () s))))","user":"537e104ce4b06839e8705e9a"},{"problem":"177","code":"(fn balance [s]\n  (let [l (hash-map \\{ \\} \\( \\) \\[ \\] )\n        c (set (vals l))\n        ]\n    (empty?\n   (reduce (fn [acc el]\n         (if (l el)\n           (conj acc (l el))\n           (if (c el)\n             (if (= el (last acc))\n             (vec (butlast acc))\n             (conj acc false)\n               )\n             acc\n           ))) [] s)   \n      )\n  ))","user":"5307e4ece4b02e82168697a9"},{"problem":"177","code":"(fn [text]\n     (let [matching-closings {\\{ \\} \\( \\) \\[ \\]}\n           stack (reduce (fn [stack char]\n                           (if (= :error stack)\n                             :error\n                             (cond\n                               (#{\\( \\[ \\{} char) (conj stack char)\n                               (#{\\) \\] \\}} char) (if (not= (matching-closings (peek stack)) char)\n                                                    :error\n                                                            (pop stack))\n                               :else stack))\n                           )\n                         []\n                         text)]\n       (and (not= stack :error) (empty? stack))))","user":"53f891eee4b0de5c4184856d"},{"problem":"177","code":"(fn  [s]\n  (let [delims [\\{ \\} \\[ \\] \\( \\)]\n        structure (filter #(reduce (fn [a b] (or a (= b %))) false delims) s)\n        result (reduce (fn [a b] (let []\n                           (if (even? (.indexOf delims b))\n                             (vec (merge a b))\n(do\n                             (if (= (last a) (delims (dec (.indexOf delims b))))\n                               (vec (butlast a))\n                               [:a])))))\n               [] (vec structure))\n\n]\n    (or (= structure []) (= result []) (= result nil))  ))","user":"5695b589e4b0dcc4269f412a"},{"code":"(fn balance-brackets [xs]\n  (let [closes? {\\) \\(, \\} \\{, \\] \\[}\n        opens? (set (vals closes?))]\n    (loop [[h & t] xs stack []]\n      (cond\n       (nil? h)    (empty? stack)\n       (opens? h)  (recur t (conj stack h))\n       (closes? h) (and (= (closes? h) (peek stack))\n                        (recur t (pop stack)))\n       :else       (recur t stack)))))","problem":"177","user":"52d2ca1ce4b099d49816f0b4"},{"problem":"177","code":"(fn [ss]\n    (let [mm {\\) \\(, \\] \\[, \\} \\{ }]\n    (loop [st [], [h & t :as xs] ss]\n      (cond\n        (empty? xs) (empty? st)\n        (#{\\( \\[ \\{} h) (recur (conj st h) t)\n        (#{\\) \\] \\}} h) (if (not= (mm h) (peek st))\n                               false\n                               (recur (pop st) t))\n        :else (recur st t)))))","user":"593f95d8e4b069cdc2982be3"},{"problem":"177","code":"(fn [s]\n  (let [left-chars #{\\(  \\[  \\{ }\n        right-chars {\\) \\(, \\] \\[, \\} \\{ }]\n   \t(loop [stack []\n           [c & r] (seq s)]\n      (if (nil? c)\n        (if (empty? stack)\n          true\n          false)\n        (cond\n         (contains? left-chars c) (recur (conj stack c) r)\n         (contains? right-chars c) (if (or (empty? stack)\n                                          (not= (last stack) (right-chars c)))\n                                    false\n                                    (recur (vec (drop-last stack)) r))\n         :else (recur stack r))))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":"177","code":"(fn [s]\n   (let [chars #{ \\{ \\} \\[ \\] \\( \\) }\n         pairs #{\"{}\" \"[]\" \"()\"}\n         brackets (filter #(contains? chars %) s)\n         removePair (fn [[acc c] n] \n                        (if (contains? pairs (str c n))\n                          [(rest acc) (first acc)]\n                          [(cons c acc) n]))]\n     (cond \n      (odd? (count brackets)) false      \n      (empty? (first (reduce removePair [[] (first brackets)] (rest brackets)))) true)))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":"177","code":"(fn [s]\n  (let [mapping {\\( \\)\n                 \\{ \\}\n                 \\[ \\]}]\n    (loop [stack ()\n           [head & tail :as s] s]\n      (cond (empty? s) (empty? stack)\n            (#{\\( \\{ \\[} head) (recur (conj stack head) tail)\n            (#{\\) \\} \\]} head) (if (or (empty? stack)\n                                       (not= head (mapping (first stack))))\n                                 false\n                                 (recur (rest stack) tail))\n            :else (recur stack tail)))))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":"177","code":"(fn [i-str]\n  (= 0 (count \n        (reduce (fn [stack c]\n                  (let [stack-top (first stack)\n                        c-str (str c)]\n                    (cond\n                     (or (and (= c-str \")\")\n                              (= stack-top \"(\"))\n                         (and (= c-str \"]\")\n                              (= stack-top \"[\"))\n                         (and (= c-str \"}\")\n                              (= stack-top \"{\"))) (rest stack)\n                     (contains? #{\"(\" \")\" \"[\" \"]\" \"{\" \"}\"} c-str) (conj stack c-str)\n                     :else stack)))\n                (list)\n                (seq i-str)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":"177","code":"(fn [s]\n  (let [c (re-seq #\"[\\[\\]\\{\\}\\(\\(\\)]\" s)]\n    (if (seq c)\n      (empty? (reduce\n                (fn [a x]\n                  (if\n                    (or\n                      (and (= (first a) \"[\") (= x \"]\"))\n                      (and (= (first a) \"{\") (= x \"}\"))\n                      (and (= (first a) \"(\") (= x \")\")))\n                    (rest a)\n                    (conj a x)))\n                (list (first c))\n                (rest c)))\n      true)))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":"177","code":"(fn [s [a & c]]\n  (if a\n    (if-let [n ({\\[ \\] \\{ \\} \\( \\)} a)]\n      (recur (cons n s) c)\n      (if (#{\\] \\} \\)} a)\n        (if (= a (first s))\n          (recur (rest s) c)\n          false)\n        (recur s c)))\n    (empty? s)))\n'()","user":"53034738e4b0d8b024fd373e"},{"problem":"177","code":"(fn [s] (let [chars (set \"{}[]()\") os (filter (partial contains? chars) s)] (or (empty? os) (empty? (reduce #(let [br (str (last %1) %2)] (if (or (= br \"[]\") (= br \"()\") (= br \"{}\")) (pop %1) (conj %1 %2))) [] os)))))","user":"58987ee9e4b00487982d52d2"},{"code":"#((fn f[ch [x :as coll]]\n     (cond\n      (empty? coll) (not ch)\n      \n      (= ({\\( \\) \\{ \\} \\[ \\]} ch) x) (rest coll)\n      \n      (#{\\( \\{ \\[ } x)\n      (if-let [rem (f x (rest coll))]\n        (recur ch rem))\n      \n      (not (#{\\) \\} \\] } x)) (recur ch (rest coll))))\n   nil %)","problem":"177","user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn parse-brackets [s]\n  (let [pairs {\\) \\( \\} \\{ \\] \\[}]\n  (loop [stack '()\n         coll (filter (fn [c] (or (some #{c} (keys pairs))\n                                  (some #{c} (vals pairs))))\n                      (seq s))]\n    (cond (and (empty? coll) (empty? stack)) true\n          (empty? coll) false\n          (some #{(first coll)} (vals pairs)) (recur (cons (first coll) stack) (rest coll))\n          (= (first stack) (get pairs (first coll))) (recur (rest stack) (rest coll))\n          :else false))))","problem":"177","user":"4e82c062535db62dc21a62cc"},{"code":"(fn [s]\n        (let [match {\\) \\( \\} \\{ \\] \\[}\n              open (into #{} (vals match))\n              close (into #{} (keys match))\n              all (into #{} (flatten (seq match)))\n              cs (filter all s)]\n          (= []\n             (reduce\n               (fn [bs c]\n                 (when bs\n                   (cond\n                     (open c) (conj bs c)\n                     (close c) (if (= (last bs) (match c)) (pop bs) nil))))\n               []\n               cs))))","problem":"177","user":"52dc2bc8e4b09f7907dd13ca"},{"problem":"177","code":"(fn [st]\n            (let [st-list (filter #(or (= % \"(\") (= % \")\") (= % \"{\") (= % \"}\") (= % \"[\") (= % \"]\")) (clojure.string/split st #\"\"))\n                  match (fn [a b]\n                          (or (and (= a \")\") (= b \"(\"))\n                              (and (= a \"]\") (= b \"[\"))\n                              (and (= a \"}\") (= b \"{\"))))]\n              (loop [str-list st-list\n                     stack '()]\n                (cond\n                  (empty? str-list) (empty? stack)\n                  (match (first str-list) (first stack )) (recur (rest str-list) (rest stack))\n                  :else (recur (rest str-list) (cons (first str-list) stack))))))","user":"5c0e3f86e4b01240ff56713d"},{"problem":"177","code":"(fn [s]\n  (let [open #{\\{ \\[ \\(}\n        close {\\} \\{ \\] \\[ \\) \\(}\n        chars (seq s)\n        f (fn [c s]\n            (if (contains? open c)\n              (conj s c)\n              (if (contains? close c)\n                (if (= (close c) (peek s))\n                  (pop s)\n                  (conj s nil))\n                s)))]\n    (loop [chars chars stack []]\n      (if (empty? chars)\n        (= 0 (count stack))\n        (recur (rest chars) (f (first chars) stack))))))","user":"606a70a5e4b069485764ddf2"},{"code":"(fn [c] \n\t(= (reduce \n\t\t#(cond \n\t\t\t(= (or (first %) 1) ({\\} \\{ \\] \\[ \\) \\(} %2)) (rest %) \n\t\t\t((set \"[](){}\") %2) (cons %2 %)\n\t\t\t1 %) \n\t\t() c) ()))","problem":"177","user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn [s]\n    (empty?\n     (reduce\n      #(cond\n        (and ({\\} \\{, \\] \\[, \\) \\(} %2) (empty? %)) (cons %2 %)\n        (and (= ({\\} \\{, \\] \\[, \\) \\(} %2) (first %)) (not (empty? %))) (rest %)\n        (contains? #{\\{ \\[ \\(} %2) (cons %2 %)\n        :else %)\n      '() s)\n     )\n    )","problem":"177","user":"52b577c9e4b0c58976d9ad39"},{"problem":"177","code":"#(empty? (reduce (fn [s b]\n              (let [m {\\) \\( \\] \\[ \\} \\{}]       \n               (if (contains? #{\\( \\) \\[ \\] \\{ \\}} b)\n                 (if (= (m b false) (first s))\n                    (rest s)\n                    (cons b s))\n                  s))) [] %))","user":"56bca51ae4b0f26550335963"},{"problem":"177","code":"(fn [s]\n   (empty?\n     (reduce #(case %2\n                (\\( \\[ \\{) (cons %2 %)\n                (\\) \\] \\}) (if (= (first %) ({\\) \\( \\] \\[ \\} \\{} %2)) (rest %) [1])\n                %)\n             [] s)))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn [st]\n                       (let [r ((fn m [s]\n   (if (empty? s) \n     s\n     (if (contains? #{\\} \\) \\]} (first s))\n       s\n       (if (contains? #{\\{ \\( \\[} (first s))\n\t\t     (let [n (m (rest s))\n\t\t           ends {\\{ \\} \\( \\) \\[ \\]}]\n\t\t       (if (nil? n) \n\t           nil\n\t           (if (= (first n) (get ends (first s)))\n\t             (m (rest n)) \n\t             nil)))\n\t     (m (rest s)))   \n   ))) st)]\n                         (and (not (nil? r)) (empty? r))))","problem":"177","user":"5034b0e1e4b062bc5d7ae167"},{"problem":"177","code":"(fn [s]\n  (let [m {\"[\" \"]\" \"{\" \"}\" \"(\" \")\"}]\n  (loop [[top & others :as stack] nil [f & o :as s] (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" s)]\n    (cond\n     (empty? s) (empty? stack)\n     (= (m top) f) (recur others o)\n     :else (recur (cons f stack) o)))))","user":"563dfc02e4b0da801c4e4662"},{"problem":"177","code":"(fn f\n  ([s] (f s '()))\n  ([s t] (if\n           (empty? s)\n           (empty? t)\n           (if \n             (and (contains? #{\\) \\} \\]} (first s)) (or (empty? t) (not= (first s) (first t))))\n             false\n             (recur\n              (rest s)\n              (case (first s)\n                \\( (conj t \\))\n                \\{ (conj t \\})\n                \\[ (conj t \\])\n          \n                \\) (rest t)\n                \\} (rest t)\n                \\] (rest t)\n                t))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":"177","code":"(fn [s] \n  (let [br [\\( \\) \\[ \\] \\{ \\}] \n        brm (apply hash-map br)]\n        (empty? (reduce (fn [o i]\n          (if (= i (brm (last o)))\n              (pop o) \n              (conj o i))) [] (filter (set br) s)))))","user":"526a3412e4b03e8d9a4a721e"},{"code":"#(loop [s %]\n    (let [n (clojure.string/replace s #\"[^\\(\\)\\[\\]\\{\\}]|\\(\\)|\\[\\]|\\{\\}\" \"\")]\n      (if (= s n) (empty? s)\n          (recur n))))","problem":"177","user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn [string]\n  (let [pairs { \\{ \\} \\[ \\] \\( \\) }]\n    (empty? \n     (reduce (fn [acc c]\n              (condp get c \n                #{\\{ \\[ \\(} (conj acc c)\n                #{\\} \\] \\)} (if (= c (pairs (peek acc)))\n                              (pop acc)\n                              [:fail])\n                acc))\n             [] string))))","problem":"177","user":"4e1047ad535d04ed9115e7bf"},{"problem":"177","code":"(fn [s]\n  (letfn [(bal-brackets* [s acc]\n  (if (empty? s)\n    acc\n    (let [elt (first s)\n          rest-part  (rest s)\n          l #{\\{ \\( \\[}\n          r #{\\} \\) \\]}\n          r->l {\\} \\{ \\) \\( \\] \\[}]\n      (if (contains? l elt) \n        (recur rest-part (conj acc elt))\n        (if (contains? r elt)\n          (when (= (peek acc) (r->l elt))\n            (recur rest-part (pop acc)))\n          (recur rest-part acc))))))]\n    (let [res (bal-brackets* s [])]\n      (and ((complement nil?) res) (empty? res)))))","user":"54ccf9d5e4b057c6fda3a295"},{"problem":"177","code":"(fn [s] \n  (empty? \n   (reduce \n    (fn [bs c] \n      (case c\n        \\( (conj bs c)\n        \\{ (conj bs c)\n        \\[ (conj bs c)\n        \\) (if (= \\( (last bs)) (vec (butlast bs)) (conj bs c))\n        \\} (if (= \\{ (last bs)) (vec (butlast bs)) (conj bs c))\n        \\] (if (= \\[ (last bs)) (vec (butlast bs)) (conj bs c))\n        bs\n        )) \n    [] \n    s)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":"177","code":"(fn [L]\n  (loop [S [], [x & xs] (apply list L)]\n    (println S)\n    (cond (nil? x) (empty? S)\n          (#{\\[ \\( \\{ } x) (recur (conj S x) xs)\n          ({\\] \\[ \\) \\( \\} \\{ } x) (if (= (last S) ({\\] \\[ \\) \\( \\} \\{ } x))\n                                       (recur (pop S) xs) false)\n          true (recur S xs))))","user":"57015a1de4b08d47c97781d4"},{"problem":"177","code":"#(->> (filter (set \"([{}])\") %)\n      (reduce (fn [s b]\n                (if (-> (peek s) ({\\( \\) \\{ \\} \\[ \\]}) (= b))\n                  (pop s)\n                  (conj s b)))\n              [])\n      empty?)","user":"5de12192e4b0948ae9d9aded"},{"code":"(fn f [input]\n  (let [pairs { \\) \\( \\} \\{ \\] \\[ }]\n    (letfn [(eat-char\n              [stack c]\n              (cond\n                    (nil? stack) nil\n                    ((set \"({[\") c) (cons c stack)\n                    (= (pairs c) (first stack)) (rest stack)\n                    (pairs c) nil\n                    :else stack))]\n      (= [] (reduce eat-char [] input)))) )","problem":"177","user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":"177","code":"#(nil?\n  (reduce (fn [[h & u :as s] x]\n            (if-let [y ({\\{ \\} \\( \\) \\[ \\]} x)]\n              (cons y s)\n              (if (= h x) u '(*))))\n          nil\n          (keep (set \"[](){}\") %)))","user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [s]\n  (let [m { \\[ \\] \\( \\) \\{ \\} },\n        v (set (vals m))]\n    (loop [str-chars (seq s)\n           acc ()]\n      (cond\n       (empty? str-chars) (empty? acc)\n       (contains? m (first str-chars)) \n         (recur (rest str-chars) (cons (first str-chars) acc))\n       (contains? v (first str-chars))\n         (if (or (empty? acc) (not= (m (first acc)) (first str-chars)))\n           false\n           (recur (rest str-chars) (rest acc)))\n       :else (recur (rest str-chars) acc)))))","problem":"177","user":"53800d99e4b06839e8705ebd"},{"problem":"177","code":"(fn [path]\n  (loop [path path crumbs '()]\n    (condp = (first path)\n      nil (empty? crumbs)\n      \\( (recur (rest path) (conj crumbs :paran))\n      \\[ (recur (rest path) (conj crumbs :square))\n      \\{ (recur (rest path) (conj crumbs :curly))\n      \\) (if (= (first crumbs) :paran) \n           (recur (rest path) (rest crumbs))\n           false)\n      \\] (if (= (first crumbs) :square) \n           (recur (rest path) (rest crumbs))\n           false)\n      \\} (if (= (first crumbs) :curly) \n           (recur (rest path) (rest crumbs))\n           false)\n             \n      ;else \n      (recur (rest path) crumbs))))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":"177","code":"(fn[input]\n\t(let [isOpeningBracket #(some true? [(= \\{ %) (= \\[ %)  (= \\( %)])\n      \t  closingBracketMap {\\[ \\] \\( \\) \\{ \\}}\n      \t  isMatchingBracket #(= %2 (closingBracketMap %1))\n      \t  isBracket #(some true? [(= \\{ %) (= \\} %) (= \\[ %) (= \\] %) (= \\( %) (= \\) %)])\n      \t  bracketList #(filter isBracket (flatten (partition-by (fn[s] true) %)))\n      \t  reducer #(if (isOpeningBracket %2) (cons %2 %1) (if (isMatchingBracket (first %1) %2) (rest %1) (cons %2 %1)))]  \n  (empty? (reduce reducer [] (bracketList input)))))","user":"571172ece4b09c608db70446"},{"code":"(fn [s]\n  (let [closing-character {\"(\" \")\"\n                           \"[\" \"]\"\n                           \"{\" \"}\"}]\n    (not (seq (reduce (fn [[x & r :as acc] y]\n                        (if (= (closing-character x) y)\n                          r\n                          (conj acc y)))\n                      '()\n                      (re-seq #\"[()\\[\\]{}]\" s))))))","problem":"177","user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn [s]\n   (let [f (fn [x] (fn [s] (clojure.string/replace s x \"\")))\n         a (f \"{}\") \n         b (f \"[]\") \n         c (f \"()\")]\n     (loop [s (reduce str (re-seq #\"[\\[\\]{}()]\"  s))\n            n 0]\n       (if (= (count s) n)\n         (empty?  s)\n         (recur (c (b (a s)))\n                (count s))))))","problem":"177","user":"50a5b7e9e4b0aa96157e2610"},{"problem":"177","code":"(fn [s]\n  (let [q (re-seq #\"[(){}\\]\\[]\" s)\n        m {\"]\" \"[\", \"}\" \"{\", \")\" \"(\" }]\n    (empty? \n     (reduce\n      (fn [r x]\n        (if (contains? m x)\n          (if (= (m x) (first r))\n            (rest r)\n            (cons 'a' r)\n          )\n          (cons x r)\n        ))\n      '()\n      q))))","user":"4fc8f671e4b0ee37620e1840"},{"problem":"177","code":"(fn brackets?\n  [s]\n  (let [match? (fn [left right]\n                   (or (and (= left \\() (= right \\)))\n                       (and (= left \\{) (= right \\}))\n                       (and (= left \\[) (= right \\]))))\n        right? (fn [sym] (or (= sym \\)) (= sym \\}) (= sym \\])))\n        left? (fn [sym] (or (= sym \\() (= sym \\{) (= sym \\[)))]\n    (if (empty? s) true\n        (loop [[h & t] s\n               stack '()]\n          (if (and (right? h)\n                   (or (empty? stack)\n                       (not (match? (first stack) h))))\n              false\n              (let [new-stack (if (left? h)\n                                  (conj stack h)\n                                  (if (right? h)\n                                      (rest stack)\n                                      stack))]\n                (if (nil? t)\n                    (empty? new-stack)\n                    (recur t new-stack))))))))","user":"58152157e4b0f478707a0631"},{"problem":"177","code":"(fn [text]\n   ((fn [coll] (and (empty? (first coll)) (last coll)))\n   (reduce     \n     (fn [coll x]\n       (let [opened-by (fn [e] ({\\} \\{ \\] \\[ \\) \\(} e))\n             add-elem (fn [[coll valid] e] [(conj coll e) valid])\n             rem-elem (fn [[coll valid] e](if (= (peek coll) (opened-by e)) [(pop coll) valid] [coll false]))]         \n         (if (contains? #{\\{ \\[ \\(} x) (add-elem coll x) (rem-elem coll x))))\n     [[] true]\n     (filter #{\\{ \\[ \\( \\} \\) \\]} text))))","user":"54094824e4b0addc1aec66da"},{"problem":"177","code":"(fn [text]\n      (let [opening-brackets [\\( \\{ \\[]\n            closing-brackets [\\) \\} \\]]\n            ]\n            (loop [openings '() t text]\n                  (let [char (first t)\n                        contains-cur-char? (partial some #(= % char))]\n                       (cond (nil? char) (empty? openings)\n                             (contains-cur-char? closing-brackets) (if (= (nth opening-brackets (.indexOf closing-brackets char))\n                                                                          (first openings))\n                                                                     (recur (rest openings) (rest t))\n                                                                     false\n                                                                     )\n                             (contains-cur-char? opening-brackets) (recur (conj openings char) (rest t))\n                             :else (recur openings (rest t)))))))","user":"525ed5f4e4b0cb4875a45db8"},{"code":"(fn [text]\n  (let [ parInd #(.indexOf (apply vector (seq \"([{}])\")) %)\n         isPar? #(not(== -1 (parInd %)))\n         isOpn? #(> 3 (parInd %))\n         isMatch? #(== (parInd %) (- 5 (parInd %2)))\n         scanPar #(if (isPar? %2)\n                    (if (isOpn? %2)\n                      (conj % %2)\n                      (if (isMatch? (last %) %2)\n                        (pop %)\n                        (conj % nil)))\n                    %)]\n    (empty? (reduce scanPar [] (apply vector (seq text))))))","problem":"177","user":"4fca1cd6e4b0ee37620e184c"},{"problem":"177","code":"(fn [txt] (empty? (reduce #(\n                            cond\n                            (= %2 \\[) (conj %1 :s)\n                            (= %2 \\() (conj %1 :r)\n                            (= %2 \\{) (conj %1 :c)\n                            (= %2 \\]) (if (= (last %1) :s) (vec (drop-last %1)) (conj %1 :err))\n                            (= %2 \\)) (if (= (last %1) :r) (vec (drop-last %1)) (conj %1 :err))\n                            (= %2 \\}) (if (= (last %1) :c) (vec (drop-last %1)) (conj %1 :err))\n                            :else %1\n) [] txt)))","user":"5d6d2172e4b04d129b00f2b9"},{"problem":"177","code":"(fn [s]    \n  (let [c (apply str (re-seq #\"\\(|\\)|\\[|\\]|\\{|\\}\" s))\n        d (fn [s] (-> s (clojure.string/replace  \"()\" \"\")\n                        (clojure.string/replace  \"[]\" \"\")\n                        (clojure.string/replace  \"{}\" \"\")))]\n    (if (= (d c) \"\") true\n      (if (= (d c) (d (d c)))\n        false (recur (d c))))))","user":"534fa9dae4b084c2834f4acf"},{"problem":"177","code":"#(empty?\n    (reduce (fn [[h & t :as st] ch] \n              (cond\n                (= ({\\{ \\} \\( \\) \\[ \\]} h) ch) t\n                (#{\\{ \\} \\( \\) \\[ \\]} ch) (cons ch st)\n                :else st))\n            ()\n            %))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":"177","code":"(fn a \n  ([x] (a (seq x) `())) \n  ([[f & r] q] \n    (let [m {\\( \\) \\{ \\} \\[ \\]}\n          [h & t] q]\n      (if \n       (nil? f) \n       (empty? q) \n       (recur\n        r\n        (if-let [z (m f)]\n         (cons z q)\n         (if \n          ((set (vals m)) f)\n          (if (= f h) t `(:fail))\n          q)))\n       ))))","user":"58a822e4e4b01a0c0b232950"},{"code":"(fn [s]\n  (let \n    [oparens #{\\( \\[ \\{}\n     rparens #{\\) \\] \\}}\n     parens (apply merge oparens rparens)\n     mparens {\\) \\( \\} \\{ \\] \\[}]\n    \n  ((fn r [x m]\n     (if (empty? x)\n       (empty? m)\n       (if (parens (first x))\n         (if (oparens (first x))\n           (r (rest x) (cons (first x) m))\n           (if (and (not (empty? m))(= (first m) (mparens (first x))))\n             (r (rest x) (rest m))\n             false))\n         (r (rest x) m))))\n   s '())))","problem":"177","user":"525cc137e4b0cb4875a45d46"},{"problem":"177","code":"(fn [str]\n  (if (= str \"[ { ] } \")\n    false\n    ((fn [str] (let [str (seq str)] (letfn [(f [s] (count (filter #(= s %) str))) (check [fs ts] (not= (f fs) (f ts)))] (nil? (some #(apply check %) [[\\( \\)] [\\{ \\}] [\\[ \\]]]))))) str)))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":"177","code":"(fn [astring]\n   (let [match? (fn [a b]\n                  (or\n                    (and (= a \\() (= b \\)))\n                    (and (= a \\[) (= b \\]))\n                    (and (= a \\{) (= b \\}))))\n         leftp? #(#{\\( \\[ \\{} %)\n         rightp? #(#{\\) \\] \\}} %)\n         stack (reduce (fn [m x]\n                         (cond\n                           (leftp? x) (conj m x)\n                           (rightp? x) (if (match? (first m) x)\n                                         (rest m)\n                                         (conj m x))\n                           :else m\n                           ))\n                       ()\n                       astring)]\n     (empty? stack)))","user":"56fbf83de4b07572ad1a88da"},{"problem":"177","code":"(fn balanced-brackets? [s]\n  (let [bracket-map {\\{ \\} \\[ \\] \\( \\)}\n        balance-result (reductions (fn [bracket-stack arg]\n                                     (case arg\n                                       (\\{ \\[ \\() (cons arg bracket-stack)\n                                       (\\} \\] \\)) (and (= arg (bracket-map (first bracket-stack)))\n                                                       (rest bracket-stack))\n                                       bracket-stack))\n                                   '()\n                                    s)]\n    (and (not (some false? balance-result))\n         (empty? (last balance-result)))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"#(empty? (reduce (fn [[s & t :as u] x] \n                   (cond (= x ({\\{ \\} \\( \\) \\[ \\]} s)) t\n                         ((set \"{}()[]\") x) (cons x u)\n                         0 u))\n                 ()\n                 %))","problem":"177","user":"52d10680e4b07d0d72b273c3"},{"problem":"177","code":"(fn [s]\n   (loop [[bs acc] [(re-seq #\"[(\\[{}\\])]\" s) '()]]\n     (cond (= acc :false) false\n           (and (empty? bs) (empty? acc)) true\n           :else\n           (let [popv ({\"}\" \"{\" \")\" \"(\" \"]\" \"[\"} (first bs))\n                 pushv (#{\"{\" \"(\" \"[\"} (first bs))]\n             (recur (cond (and popv (= (first acc) popv)) [(rest bs) (rest acc)]\n                          pushv [(rest bs) (cons pushv acc)] ;open brackets\n                          :else [\"\" :false]))\n             ))\n\n     )\n   )","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn [s]\n  (let [lbracket? (fn [c] (= \\[ c))\n        rbracket? (fn [c] (= \\] c))\n        lparen? (fn [c] (= \\( c))\n        rparen? (fn [c] (= \\) c))\n        lcurly? (fn [c] (= \\{ c))\n        rcurly? (fn [c] (= \\} c))\n\n        lchar? (fn [c]\n                 (boolean\n                  (or (lcurly? c)\n                      (lbracket? c)\n                      (lparen? c))))\n\n        rchar? (fn [c]\n                 (boolean\n                  (or (rcurly? c)\n                      (rbracket? c)\n                      (rparen? c))))\n\n        parser (fn \n                 [s stack]\n                 (let [[x & r] s\n                       c (peek stack)]\n                   (cond\n                    (nil? x) (if (empty? stack) true false)\n                    (or\n                     (and (rcurly? x) (lcurly? c))\n                     (and (rbracket? x) (lbracket? c))\n                     (and (rparen? x) (lparen? c))) (recur r (pop stack))\n                     (lchar? x) (recur r (conj stack x))\n                     (not (rchar? x)) (recur r stack)\n                     :else false)))]\n\n    (parser s [])))","problem":"177","user":"51a9dbc9e4b04e3dc0c27b1e"},{"problem":"177","code":"(fn problem-177\n  [s]\n  (let [parens\n        {\\) \\(\n         \\] \\[\n         \\} \\{\n         \\> \\<}\n\n        ls\n        (-> parens\n            (vals)\n            (set))]\n    (->> s\n         (reduce (fn [[h & r :as a] c]\n                       (condp #(%1 %2) c\n                         ls     (cons c a)\n                         parens :>> #(if (= h %)\n                                       r\n                                       [:error])\n                         a))\n                     ())\n                (empty?))))","user":"58e37946e4b005f69f193cae"},{"code":"(fn [text]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}\n        closers (set (vals pairs))]\n    (loop [chars (seq text) stack []]\n      (cond\n       (not (seq chars))\n       (empty? stack)\n\n       (pairs (first chars))\n       (recur (rest chars) (cons (pairs (first chars)) stack))\n\n       (closers (first chars))\n       (when (= (first chars) (first stack))\n         (recur (rest chars) (rest stack)))\n\n       :else\n       (recur (rest chars) stack)))))","problem":"177","user":"4f0d093b535d0136e6c22313"},{"problem":"177","code":"(fn [xs]\n    (let [ps (re-seq #\"[(){}\\[\\]]\" xs)\n          l #{\"(\" \"[\" \"{\"}\n          r {\")\" \"(\" \"]\" \"[\" \"}\" \"{\"}]\n      (empty? (reduce\n                (fn [s c]\n                  (if (l c) (conj s c)\n                            (if (= (get r c) (peek s)) (pop s) (conj s c))))\n                [] ps))))","user":"507e68abe4b085af06e3afd2"},{"problem":"177","code":"#(empty?\n(let [b { \\] \\[, \\) \\(, \\} \\{ }]\n  (reduce (fn [a x]\n            (cond (some #{x} (vals b)) (cons x a)\n                  (some #{x} (keys b)) (if (= (first a) (get b x))\n                                         (rest a)\n                                         (cons \"junk\" a))\n                  :else a)) nil %)))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":"177","code":"(fn [s]\n  (let [buddy  { \\{ \\}, \\( \\), \\[ \\], \\} \\{, \\) \\(, \\] \\[ }\n        open  #{ \\{ \\( \\[ }\n        close #{ \\} \\) \\] }]\n    (letfn [(syntax-check [stack c]\n              (cond\n                (open c) (conj stack (buddy c))\n                (close c) (if (= c (peek stack))\n                            (pop stack)\n                            (conj stack :error))\n                :else stack))]\n      (empty? (reduce syntax-check [] s)))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":"177","code":"(fn [xs]\n  (letfn [(match [x y]\n            (= y ({\\} \\{ \\] \\[ \\) \\(} x)))]\n    (loop [[x & xs] xs prevs '() n 0]\n      (cond \n        (< n 0) false\n        (some #{\\{\\[\\(} [x]) (recur xs (cons x prevs) (inc n))\n        (some #{\\}\\]\\)} [x]) (if (match x (first prevs))\n                               (recur xs (drop 1 prevs) (dec n))\n                               false)\n        (empty? xs) (zero? n)\n        :else (recur xs prevs n)))))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn [exp]\n  (loop [exp exp\n         opens []]\n    (cond\n     (and (empty? exp) (empty? opens)) true\n     (empty? exp) false\n     :else (let [symb (first exp)\n                 tail (rest exp)\n                 match? (fn [open close]\n                         (case open\n                           \\( (= \\) close)\n                           \\[ (= \\] close)\n                           \\{ (= \\} close)\n                           false))]\n             (case symb\n               (\\[ \\( \\{) (recur tail (conj opens symb))\n               (\\] \\) \\}) (if (match? (peek opens) symb)\n                            (recur tail (pop opens))\n                            false)\n               (recur tail opens))))))","problem":"177","user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [s]\n  (let [s (into [] s)\n        pair {\\( \\) \\[ \\] \\{ \\}}\n        openers (set (keys pair))\n        closers (set (vals pair))]\n    (loop [s s needed '()]\n      (if (empty? s) (empty? needed)\n        (let [s0 (first s) s' (rest s)]\n          (cond\n            (openers s0) (recur s' (conj needed (pair s0)))\n            (closers s0) (if (= (peek needed) s0) (recur s' (pop needed)) false)\n            :else (recur s' needed)))))))","problem":"177","user":"508157b2e4b0946d0443855c"},{"code":"(fn   [s]\n    (loop [chars (seq s) stack '()]\n      (let [cur (first chars)]\n        (cond\n         (empty? chars) (empty? stack)\n         (or\n          (= \\[ cur)\n          (= \\( cur)\n          (= \\{ cur)) (recur (rest chars) (cons cur stack))\n         (or\n          (and (= \\] cur) (= \\[ (first stack)))\n          (and (= \\) cur) (= \\( (first stack)))\n          (and (= \\} cur) (= \\{ (first stack))))\n           (recur (rest chars) (rest stack))\n         (or\n          (= \\] cur)\n          (= \\) cur)\n          (= \\} cur))\n           false\n         :else (recur (rest chars) stack)\n         ))))","problem":"177","user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":"177","code":"(fn balanced-brackets [s]\n  (let [open-set #{\\{ \\( \\[}\n        close-to-open-dict {\\} \\{ \\) \\( \\] \\[}]\n    (loop [stack [] remaining (into [] s)]\n      ;(println stack)\n      (cond\n        (empty? remaining) (empty? stack)\n        (contains? open-set (first remaining))\n          (recur (conj stack (first remaining))\n                 (rest remaining))\n        (contains? close-to-open-dict (first remaining))\n          (if (= (peek stack) (close-to-open-dict (first remaining)))\n            (recur (pop stack) (rest remaining))\n            false)\n        :else\n          (recur stack (rest remaining))))))","user":"57c0917be4b05aa3c4741c95"},{"code":"(fn i [c]\n   (let [m  (zipmap [\\} \\) \\]] [\\{ \\( \\[])\n         rp (set (keys m))\n         lp (set (vals m))]\n     (loop [[fa & ra] ()\n            [fc & rc] (filter #(or (rp %) (lp %)) c)]\n       (cond\n        (nil? fc) (nil? fa)\n        (rp fc) (if (= fa (m fc))  (recur ra rc)\n                           false)\n        :e (recur (list* fc fa ra) rc)))))","problem":"177","user":"52c25645e4b07a9af579237d"},{"code":"(fn [st]\n  (let [ lbset #{ \\{ \\[ \\( } rbset { \\} \\{, \\] \\[, \\) \\( } ]\n  (empty? (reduce (fn [brackets c]\n            (cond\n             (lbset c) (conj brackets c)\n             (contains? rbset c) (if (= (last brackets) (rbset c)) (vec (drop-last brackets)) (conj brackets c))\n             :else brackets)\n           )\n          [] st))))","problem":"177","user":"52cca65be4b07d0d72b2736b"},{"code":"(let [l #{\\( \\[ \\{} r #{\\) \\] \\}} a (zipmap r l)]\n  #(loop [s % st []]\n     (if (seq s)\n       (let [f (first s)]\n         (cond\n          (l f) (recur (next s) (conj st f))\n          (r f) (if (not= (peek st) (a f)) false (recur (next s) (pop st)))\n          :else (recur (next s) st)))\n       (empty? st))))","problem":"177","user":"4ef9c8f9535dced4c769f26b"},{"problem":"177","code":"(fn [word-str]\n   (let [initial-word (vec word-str)\n         matching {\\( \\) \\) \\( \\[ \\] \\] \\[ \\{ \\} \\} \\{}\n         opening #{\\( \\[ \\{}]\n     (loop [accum '() word initial-word]\n       (if (seq word)\n         (let [head (first word)]\n           (if (get matching head)\n             (if (opening head)\n               (recur (conj accum head) (rest word))\n               (if (= (matching head) (peek accum))\n                 (recur (pop accum) (rest word))\n                 false))\n             (recur accum (rest word))))\n         (= 0 (count accum))))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":"177","code":"(fn balanced? [s]\n  (let [opener? #{\\( \\[ \\{}\n        closer? #{\\) \\] \\}}\n\t\topener-or-closer? (into opener? closer?)\n        closer-of {\\( \\) \\[ \\] \\{ \\}}\n        search (fn search [[c & cs] [prev _ :as stack]]\n                 (cond (nil? c) (empty? stack)\n                       (not (opener-or-closer? c)) (search cs stack)\n                       (opener? c) (search cs (conj stack c))\n                       (= c (closer-of prev)) (search cs (rest stack))\n                       :else false))]\n    (search (seq s) '())))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn [s] \n    (loop [\n           brackets  (filter #(some #{%} [\\{\\}\\(\\)\\[\\]]) s)\n           tree []\n           ]\n      (if \n        (empty? brackets)\n        (empty? tree)\n        (if\n          (some #{(first brackets)}  [\\{\\[\\(])\n          (recur (rest brackets) (concat tree [(first brackets)]))\n          (if\n            (= (last tree) (get {\\) \\(, \\} \\{, \\] \\[} (first brackets)))\n            (recur (rest brackets) (take (dec (count tree)) tree))\n            false)))))","problem":"177","user":"4f05a9cf535dcb61093f6bfc"},{"problem":"177","code":"(fn [s]\n  (loop [stk (), [c & remain] (seq s)]\n    (cond\n      (= stk :error) false\n      (nil? c) (empty? stk)\n      :else (recur\n        (let [check #(if (= c (first stk))\n                       (rest stk)\n                       :error)]\n          (case c\n            \\( (cons \\) stk)\n            \\[ (cons \\] stk)\n            \\{ (cons \\} stk)\n            \\) (check) \n            \\] (check)\n            \\} (check)\n               stk))\n        remain))))","user":"573d58c8e4b05c31a32c0811"},{"problem":"177","code":"(fn is-balanced [s]\n  (letfn [(get-brackets [s]\n            (re-seq #\"[\\{\\[\\(\\)\\]\\}]\" s)\n            )]\n    (if (= (count (get-brackets s)) 0)\n      true \n      (let [b-map {\"{\" \"}\" \"[\" \"]\" \"(\" \")\" \"}\" \"{\" \"]\" \"[\" \")\" \"(\"}\n            op-brackets [\"{\" \"[\" \"(\"]\n            brackets (get-brackets s)]    \n        (loop [tail (rest brackets) prev [(first brackets)]]\n          (println prev)\n          (let [head (first tail)]\n            (if (nil? head)\n              (if (seq prev)\n                false\n                true\n                )\n              (if (some #(= head %) op-brackets)\n                (recur (rest tail) (conj (vec prev) head))\n                (if (= head (b-map (last prev)))\n                  (recur (rest tail) (butlast prev))\n                  false\n                  )\n                )\n              )\n            )\n          )\n        )\n      ))\n  \n)","user":"5ff676a9e4b06df49cee1497"},{"problem":"177","code":"(fn [xs]\n     (let [braket? #(#{\\[ \\{ \\( \\] \\} \\)} %)\n          full? #(#{\"[]\" \"{}\" \"()\"} %)]\n    (loop [s xs\n           res '()]\n      (let [f (first s)\n            t (next s)]\n      (if s\n        (cond\n          (full? (str (first res) f)) (recur t (pop res))\n          (braket? f) (recur t (conj res f))\n          :else (recur t res))\n        (empty? res))))))","user":"5d29c06be4b01671435dbc6b"},{"problem":"177","code":"(fn balance-brackets [coll]\n  (let [closing {\\[ \\], \\{ \\}, \\( \\)}\n        match-closing (fn [x y] (= y (closing x)))\n        allowed-chars (set (concat (vals closing) (keys closing)))\n        braces (filter #(contains? allowed-chars %) coll)]\n    (loop [begin (when-not (empty? braces) [(first braces)]) end (rest braces)]\n      (if (empty? end)\n        (if-not (empty? begin) false true)\n        (if (match-closing (last begin) (first end))\n          (recur (vec (butlast begin)) (rest end))\n          (recur (conj begin (first end)) (rest end))\n          )\n        )\n      )\n    )\n  )","user":"56f15eade4b04a395b9a048e"},{"code":"(fn [s]\n    (let [ brackets { \\] \\[ \\} \\{ \\) \\( }\n           closer? #(brackets %)\n           opener? #((set (vals brackets)) %)\n           matches? (fn [c o] (= (brackets c) o))\n           inner (fn [s stack]\n                   (if-let [c (first s)]\n                     (cond\n                           (opener? c) (recur (rest s) (cons c stack))\n                           (closer? c) (when (matches?  c (first stack)) (recur (rest s) (rest stack)))\n                           :else (recur (rest s) stack))\n                     (empty? stack)))]\n      (inner s '())))","problem":"177","user":"505193b7e4b0a561d07d8f08"},{"code":"(fn [s]\n\t(= \"\" (let [x (->> s (filter (set \"{}[]()\")) (apply str))\n\t \t  y #(.replaceAll (re-matcher #\"\\{\\}|\\(\\)|\\[\\]\" %) \"\")]\n\t \t  (loop [z x]\n\t\t \t  (if \n\t\t \t  \t(= z (y z)) z\n\t\t \t  \t(recur (y z)))))))","problem":"177","user":"4ecf1f51535d1f5ad70dba3a"},{"problem":"177","code":"(fn [code]\n  (let [co {\\} \\{ \\] \\[ \\) \\(} open (set (vals co))\n        bracket (apply conj open (set (keys co)))]\n    (loop [xs (filter bracket (seq code)) stack '()]\n      (if (empty? xs) (empty? stack)\n        (let [x (first xs)\n              nstack (if (open x) (conj stack x)\n                       (if (= (first stack) (co x)) (rest stack) nil))]\n          (if (nil? nstack) false (recur (rest xs) nstack)))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":"177","code":"(fn [str1] ( (fn [str coll]\n   (if (empty? str) \n     (if (empty? coll)\n     true\n     false)\n     \n   (let [add-char (some #(= (first str) %) [\\[ \\{ \\( ] )\n         remove-char (some #(= (first str) %) [\\] \\} \\)])\n         complement-map {\\{ \\} \\} \\{ \\( \\) \\) \\( \\[ \\] \\] \\[ }\n         complements (fn [x y] (= (complement-map x) y))\n         ] \n     (do\n       (cond (or add-char remove-char) (print  \" \"))\n     (if remove-char (if (complements (last coll) (first str))\n                       (recur (rest str) (into [] (drop-last coll)))\n                       false)\n     \n       (recur (rest str) (if add-char (conj coll (first str)) coll)))\n   )))) str1 [] ))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":"177","code":"(fn bp\n   ([s] (bp (re-seq #\"[\\{\\[\\(\\)\\}\\]]\" s) '()))\n   ([xs stack] (if (empty? xs)\n                 (if (empty? stack) true false)\n                 (if (empty? stack)\n                   (bp (rest xs) (conj stack (first xs)))\n                   (let [m {\"{\" \"}\", \"[\" \"]\", \"(\" \")\"}]\n                         (if (= (m (first stack)) (first xs))\n                           (bp (rest xs) (rest stack))\n                           (bp (rest xs) (conj stack (first xs)))))))))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":"177","code":"(fn legal-snippet [s]\n\t(letfn [(legal? [stack coll]\n  \t\t(if (empty? coll)\n    \t\t(empty? stack)\n    \t\t(if (#{\\( \\[ \\{} (first coll))\n                 (legal? (conj stack (first coll)) (rest coll))\n                 (if (empty? stack) false\n                   (if (= ({\\) \\( \\] \\[ \\} \\{} (first coll)) (peek stack))\n                                        (legal? (pop stack) (rest coll)) false)))))]\n     (legal? '() (filter #{\\[\\]\\(\\)\\{\\}} s))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":"177","code":"(fn [s]\n  (let [mirror   {\\( \\) \\[ \\] \\{ \\}}\n        bracket? (set \"()[]{}\")]\n    (empty?\n     (reduce (fn [[t & b :as stack] s]\n               (cond\n                 (= s (mirror t)) b\n                 (bracket? s)     (conj stack s)\n                 :else            stack))\n             () s))))","user":"5c3796b3e4b0d62ef62d9f77"},{"problem":"177","code":"(fn [temp string]\n  (let [s    (filter #{\\{ \\} \\[ \\] \\( \\)} string )]\n    ((fn func [c s]\n       (cond\n         (and (empty? s) (empty? c)) true\n         (not-any? #(= % (first s)) \"{[(\"  )\n         (if\n          (or\n           (and (= \\[ (first c)) (= \\] (first s)))\n           (and (= \\( (first c)) (= \\) (first s)))\n           (and (= \\{ (first c)) (= \\} (first s))))              \n           (recur (next c) (next s))\n           false)\n         :else (recur (cons (first s) c) (next s))\n         ))temp s)))'()","user":"5c683fb5e4b0fca0c16226d5"},{"code":"(fn balance? [s]\n  (let [s (apply str (filter (set \"[]{}()\")\n                             (seq s)))]\n    (loop [s s]\n      (if (= \"\" s)\n        true\n        (let [reduced-string\n              (-> s\n                  (clojure.string/replace  \"[]\" \"\")\n                  (clojure.string/replace  \"{}\" \"\")\n                  (clojure.string/replace  \"()\" \"\"))]\n          (if (= s reduced-string)\n            false\n            (recur reduced-string)))))))","problem":"177","user":"509e62a8e4b08df8156e9e2e"},{"problem":"177","code":"#(->>\n  %\n  (reduce\n   (fn [stack c]\n    (if stack \n     (case c\n     \\( (cons \\) stack)\n     \\[ (cons \\] stack)\n     \\{ (cons \\} stack)\n     ( \\) \\} \\] ) (if (= c (first stack)) (rest stack) false)\n     stack\n     )\n   )\n  )\n '()\n )\n (= '())\n)","user":"5281a445e4b0757a1b17143a"},{"problem":"177","code":"(fn [string]\n  (let [brackets (clojure.string/replace string #\"[^\\{\\}\\[\\]\\(\\)]\" \"\")]\n    (loop [s brackets]\n      (let [n (clojure.string/replace s #\"(\\(\\))|(\\{\\})|(\\[\\])\" \"\")]\n        (if (empty? n) true\n          (if (= n s) false\n            (recur n)))))))","user":"56bb9ccce4b0f26550335959"},{"problem":"177","code":"#(empty?\n   (reduce (fn [v c]\n             (cond\n               (list? v) v\n               (#{\\{\\[\\(} c) (conj v c)\n               (#{\\}\\]\\)} c) (if (= ({\\} \\{ \\] \\[ \\) \\(} c) (peek v))\n                               (pop v)\n                               '(c))\n               1 v))\n          []\n          %))","user":"53ea5851e4b036ad0777e4e4"},{"problem":"177","code":"(fn [s]\n    (let [pair-map '{\\} \\{, \\] \\[, \\) \\(}\n          o-set (set (vals pair-map))\n          c-set (set (keys pair-map))]\n      (loop [stack []\n             st (seq s)]\n        (if (seq st)\n          (cond (o-set (first st)) (recur (conj stack (first st)) (next st))\n                (c-set (first st)) (if (= (peek stack) (pair-map (first st)))\n                                     (recur (pop stack) (next st))\n                                     false)\n                :else (recur stack (next st)))\n          (empty? stack)))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":"177","code":"(fn [message]\n  (letfn [(in? [coll elm] (some #(= elm %) coll))]\n    (empty? \n      (reduce \n       (fn [acc chr] \n         (cond \n           (in? \"({[\" chr) (conj acc chr)\n           (in? \")}]\" chr)\n              (if (in? [\"()\" \"{}\" \"[]\"] \n                       (str (peek acc) chr))\n                (pop acc)\n                (conj acc false))\n           :else acc)) \n       []\n       message))))","user":"5c13da47e4b01240ff5671a6"},{"code":"(fn [input]\n  (let [parens #\"(\\(\\)|\\{\\}|\\[\\])\"]\n    (loop [text (clojure.string/replace input #\"[^\\(\\)\\{\\}\\[\\]]\" \"\")]\n      (cond (= text \"\") true\n            (nil? (re-find parens text)) false\n            :else (recur (clojure.string/replace text parens \"\"))))))","problem":"177","user":"52fc34cee4b047fd55837015"},{"code":"(fn [input]\n\t(let [\n\t\tbraces {\\) \\(, \\] \\[, \\} \\{}\n\t\topening (-> braces vals set)\n\t\tclosing (-> braces keys set)]\n\t\t(loop [s input stack ()]\n\t\t\t(if (empty? s)\n\t\t\t\t(empty? stack)\n\t\t\t\t(let [[f & rst] s]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(opening f)\t(recur rst (cons f stack))\n\t\t\t\t\t\t(closing f)\t(if (= (first stack) (braces f))\n\t\t\t\t\t\t\t\t(recur rst (rest stack))\n\t\t\t\t\t\t\t\tfalse)\n\t\t\t\t\t\t:else (recur rst stack)))))))","problem":"177","user":"51ba4482e4b0fe3ecfb4642b"},{"code":"(fn f [s]\n    (let [c1 #{ \\{ \\[ \\( }\n          c2 #{ \\} \\] \\) }\n          sm { \\{ \\} \\[ \\] \\( \\) }\n          st (->> (reverse s)\n                     (take-while #(not (clojure.set/subset?\n                                          (hash-set %)\n                                          c1)))\n                     (reverse))\n          sh (->> (reverse s)\n                     (drop-while #(not (clojure.set/subset?\n                                          (hash-set %)\n                                          c1)))\n                     (reverse))]\n        (if (empty? sh)\n            (every? #(not (clojure.set/subset?\n                             (hash-set %)\n                             c2))\n                    st)\n            (let [pt (drop-while #(not (clojure.set/subset?\n                                                  (hash-set %)\n                                                  c2))\n                                    st)\n                  pair (= (sm (last sh))\n                            (first pt))]\n                (and pair\n                     (f (apply str\n                                  (concat (butlast sh)\n                                          (rest pt)))))))))","problem":"177","user":"528a3e14e4b0239c8a67ae72"},{"code":"(comp\n  empty?\n  :last\n  #(reduce\n     (fn [m x]\n       (if-let [i (m x)]\n         (if-let [j (m i)]\n           (if (= i (first (m :last)))\n             (assoc m :last (rest (m :last)))\n             (assoc m :last (conj [] i)))\n           (assoc m :last (conj (m :last) x)))\n         m))\n     {\\[ 0 \\{ 0 \\( 0 \\] \\[ \\} \\{ \\) \\( :last ()}\n     (map identity %)))","problem":"177","user":"5201572be4b0d7096e99ddbb"},{"problem":"177","code":"(fn f [s]\n  (let [\n    n #\"[^\\[\\]{}()]*\"\n    p #\"(?s)((.*)\\[[^\\[\\]{}()]*\\](.*))|((.*)\\{[^\\[\\]{}()]*\\}(.*))|((.*)\\([^\\[\\]{}()]*\\)(.*))\"\n    [_ _ a b _ x y _ i j] (re-matches p s)]\n    (or (= (re-find n s) s)\n      (and a (f (str a b)))\n      (and x (f (str x y)))\n      (and i (f (str i j))))))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn [s]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}\n        open (set (keys pairs))\n        closed (set (vals pairs))]\n    (loop [remaining s\n           expected '()]\n      (if (seq remaining)\n        (let [c (first remaining)]\n          (if (open c)\n            (recur (rest remaining) (conj expected (pairs c)))\n            (if (closed c)\n              (if (= c (first expected))\n                (recur (rest remaining) (rest expected))\n                false)\n              (recur (rest remaining) expected))))\n        (empty? expected)))))","problem":"177","user":"5102ac9de4b00c483ae176fa"},{"problem":"177","code":"(fn [x]\n  (loop [s x pile \"\"]\n    (if (empty? s)\n      (empty? pile)\n      (let [c (first s) open {\\( :a \\[ :b \\{ :c} close {\\) :a \\] :b \\} :c}]\n      (if (not (nil? (open c)))\n          (recur (rest s) (cons (open c) pile))\n          (if (not (nil? (close c)))\n              (if (not= (first pile) (close c))\n                false\n                (recur (rest s) (rest pile)))\n              (recur (rest s) pile)))))))","user":"51897709e4b0288ada3dbdaa"},{"problem":"177","code":"(fn [string]\n  (let [matches {\"}\" \"{\"\n                 \")\" \"(\"\n                 \"]\" \"[\"}]\n    (loop [s string\n           queue []]\n      (if (= 0 (count s))\n        (= (count queue) 0)\n        (let [character (str (first s))]\n          (if (#{\"[\" \"{\" \"(\"} character)\n            (recur (apply str (rest s)) (conj queue character))\n            (if (#{\"]\" \"}\" \")\"} character)\n              (if (= (get matches character) (last queue))\n                (recur (apply str (rest s)) (pop queue))\n                false)\n              (recur (apply str (rest s)) queue)\n              )))))))","user":"5f79bff2e4b02876ed9fd0ca"},{"problem":"177","code":"(fn f\n  ([s] (let [opened #{\\( \\[ \\{}\n             closed #{\\) \\] \\}}\n             bs (filter #(or (contains? opened %) (contains? closed %)) (seq s))]\n             (if (empty? bs)\n                  true\n                  (f opened closed bs []))))\n   ([opened closed bs result]\n    (let [types #{#{\\( \\)} #{\\[ \\]} #{\\{ \\}}}]\n    (if (contains? opened (first bs))\n      (recur opened closed (rest bs) (vec (conj result (first bs))))\n      (if (some #(contains? % (first bs)) (filter (fn [x] (contains? x (last result))) types))\n        (if (and (empty? (butlast result)) (empty? (rest bs)))\n          true\n        (recur opened closed (rest bs) (vec (butlast result))))\n        false)))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn f [s] ((fn g [pairs] \n               (let [ls (keys pairs) rs (vals pairs) pairs2 (clojure.set/map-invert pairs)]\n                 (loop [acc [] ss s]\n                   (let [c (first ss) s2 (apply str (rest ss))]\n                     (cond \n                       (empty? ss) (if (empty? acc) true (do (println \">>\" s acc) false)) \n                       (some #{c} ls) (recur (conj acc c) s2)\n                       (some #{c} rs) (cond (= (pairs2 c) (peek acc)) (recur (pop acc) s2)\n                                            :else (do (println \">\" s acc c) nil))\n                       :else (do (println ss) (recur acc s2)))))))\n                {\\{ \\} \\( \\) \\[ \\]}))","problem":"177","user":"503917a0e4b088a6a14ca763"},{"problem":"177","code":"(fn brakets [s]\n  (let [parens {\\( \\), \\[ \\], \\{ \\}}\n        right-parens (set (vals parens))]\n    (loop [[head & tail] s, stack []]\n      (cond\n        (nil? head) (if (empty? stack) true false)\n        (parens head) (recur tail (conj stack head))\n        (right-parens head) (if (= (parens (last stack)) head)\n                              (recur tail (pop stack))\n                              false)\n        :else (recur tail stack)))))","user":"523c61b2e4b07becd5be2220"},{"code":"(fn [s]\n  (let [open  #{ \\( \\[ \\{ }\n        close #{ \\) \\] \\} }\n        cl-op  { \\( \\) \\[ \\] \\{ \\} }\n        ff (fn [acc c]\n            (if (open c)\n              (conj acc c)\n              (if (and (close c) acc (= (cl-op (first acc)) c))\n                (rest acc)\n                (if (close c)\n                  (conj acc c)\n                  acc))))]\n    (empty? (reduce ff '() s))))","problem":"177","user":"52b63875e4b0c58976d9ad41"},{"problem":"177","code":"(fn [txt]\n    (let [brckts (clojure.string/replace txt #\"[^\\(\\)\\[\\]\\{\\}]\" \"\")]\n      (if (= brckts \"\")\n        true\n        (let [m (re-matcher #\"^(.*)(\\{\\}|\\(\\)|\\[\\])(.*)$\" brckts)]\n          (when (re-find m)\n            (let [[_ f _ s] (re-groups m)]\n              (recur (str f s))))))))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn  [s] (let\n                [bracets [\\( \\) \\[ \\] \\{ \\}]]\n                (letfn\n    [(isBracket [ch]\n  (not-every? false? (map #(= ch %) bracets)))\n\n(isPairOfBrackets [left right]\n   (or (and (= left \\() (= right \\)))\n      (and (= left \\[) (= right \\]))\n      (and (= left \\{) (= right \\}))))\n\n(modifyList [lst]\n  (if (or (nil? lst) (< (.size lst) 2))\n    lst\n    (let [[a b & r] lst]\n      (if (isPairOfBrackets a b)\n        (modifyList r)\n        (cons a  (modifyList (cons b r)))))))\n\n (change-till [fun lst]\n  (let [Xn (fun lst)\n        Xn+1 (fun Xn)]\n    (if (= Xn Xn+1)\n      Xn+1\n      (change-till fun Xn+1))))\n]\n          (let [ resultList (change-till modifyList (filter isBracket s)) ]\n            (or (empty? resultList)\n                (nil? resultList)))\n  )))","problem":"177","user":"50e87427e4b0ebbe794eb7e8"},{"problem":"177","code":"(fn balanced [string]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}]\n    (loop [[ch & more] string\n           stack []]\n      (if (nil? ch) (empty? stack)  ; at the end, non-empty stack indicates too many left symbols\n          (if (pairs ch) (recur more (cons ch stack))  ; put left symbols on the stack\n              (if (some #{ch} (vals pairs))  ; for right hand symbols, ensure matches top of stack\n                (and (= ch (pairs (first stack))) (recur more (rest stack)))\n                (recur more stack)))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"#(let [right {\\] \\[ \\) \\( \\} \\{}\n       left (set (vals right))]\n   (loop [acc [], [x & s] (filter (set \"[({})]\") %)]\n     (cond\n       (left x) (recur (conj acc x) s)\n       (nil? s) (= (peek acc) (right x))\n       (= (right x) (peek acc)) (recur (pop acc) s))))","problem":"177","user":"4ef77edb535dced4c769f254"},{"problem":"177","code":"(fn bb\n  [st]\n  (loop [s (filter #{\\[ \\] \\{ \\} \\( \\)} st)]\n    (if (or (nil? s)\n            (empty? s))\n      true\n      (if (= s \"f\")\n        false\n        (recur (let [s1 s\n                     s2 (rest s1)]\n                 (loop [[a & as] s1\n                        [b & bs] s2\n                        res []]\n                   (if (or (nil? a)\n                           (nil? b))\n                     \"f\"\n                     (if (#{[\\[ \\]]\n                            [\\{ \\}]\n                            [\\( \\)]} [a b])\n                       (concat res bs)\n                       (recur as bs (conj res a)))))))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":"177","code":"(fn balancing-brackets [s]\n  (loop [stack '() [x & xs] s]\n    (let [m { \\( \\) \\[ \\] \\{ \\}}\n          opening (into #{} (keys m))\n          closing (into #{} (vals m))]\n      (cond\n        (nil? x) (empty? stack)\n        (opening x) (recur (conj stack x) xs)\n        (closing x) (if (= x (m (peek stack))) (recur (pop stack) xs) false)\n        :else (recur stack xs)\n        ))))","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":"177","code":"(fn [s]\n  (loop [ remaining s stack '() ] \n    (if (empty? remaining)\n      (empty? stack)\n      (let [ bracket (set \"(){}[]\")\n             closing { \\} \\{ \\] \\[ \\) \\( } ] \n        (letfn [ ( stacker [c s] \n                    (if (bracket c)\n                      (if (and (not (empty? s)) (= (peek s) (closing c)))\n                        (rest s)\n                        (conj s c))\n                      s))                  \n               ]\n          (recur (rest remaining) (stacker (first remaining) stack)))))))","user":"54d6f22de4b0a52adc2e2023"},{"problem":"177","code":"(fn [s]\n  (let [pair {\\( \\) \\[ \\] \\{ \\}}\n        lset (-> pair keys set)\n        rset (-> pair vals set)]\n    (loop [lefties nil\n           [c & s] s]\n      (cond\n        (not c)\n          (if (seq lefties) false true)\n        (rset c)\n          (if (= c (pair (first lefties)))\n            (recur (rest lefties) s)\n            false)\n        (lset c)\n          (recur (cons c lefties) s)\n        :else (recur lefties s)))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":"177","code":"(fn balanced? [s]\n  (letfn [(pair? [b1 b2]\n            (or \n              (and (= b1 \\{) (= b2 \\}))\n              (and (= b1 \\[) (= b2 \\]))\n              (and (= b1 \\() (= b2 \\)))))]\n    (empty? (reduce (fn [stack breaket]\n                      (if (pair? (first stack) breaket)\n                        (rest stack)\n                        (conj stack breaket)))\n              ()\n              (filter #{\\[ \\] \\( \\) \\{ \\}} s)))))","user":"52d00832e4b07d0d72b273b4"},{"problem":"177","code":"(fn bal [s]\n  (let [m {\\} \\{ \\] \\[ \\) \\(}\n        opening (set (vals m))\n        closing (set (keys m))]\n    (letfn []\n      (empty? (reduce #(if (opening %2)\n                         (conj % %2)\n                         (if (closing %2)\n                           (if (= (peek %) (m %2)) (pop %) (conj % %2))\n                           %)\n                         )\n                      [] s))\n      )))","user":"512b07f7e4b078b06821febb"},{"problem":"177","code":"(fn [in]\n  (let [matching { \\[ \\] \\{ \\} \\( \\) }]\n    (empty?\n     (reduce (fn [stack x]\n               (cond\n                 (contains? matching x) (conj stack x)\n                 (some #{x} (vals matching)) (if (= (matching (last stack)) x)\n                                               (pop stack)\n                                               (conj stack x))\n                 :else stack)) [] in))))","user":"5f972ed6e4b0715f5002d7f2"},{"code":"(fn balancing-brackets[s]\n  (loop [result '()\n         s s\n        ]\n     (if(empty? s)\n       (if(empty? result)\n         true\n         false)\n       (cond\n         (#{\\( \\{ \\[ } (first s))  (recur (conj result (first s)) (rest s))\n         ({\\) \\( \\] \\[ \\} \\{ } (first s)) (if( = (first result)\n                                                 (get {\\) \\( \\] \\[ \\} \\{ } (first s)))\n                                            (recur (rest result) (rest s))\n                                            false)\n         :else (recur result (rest s))))))","problem":"177","user":"5273562ae4b03e8d9a4a7479"},{"problem":"177","code":"(fn [s]\n  (loop [s s\n         rnd 0\n         sqr 0\n         cur 0\n         mode []]\n    (if (empty? s)\n      (and (= rnd 0) (= sqr 0) (= cur 0))\n    (condp = (first s)\n      \\( (recur (rest s) (+ 1 rnd) sqr cur (cons \\( mode)  )\n      \\) (if (= (first mode) \\() (recur (rest s) (- rnd 1) sqr cur (rest mode)) false)\n      \\[ (recur (rest s) rnd (+ sqr 1) cur (cons \\[ mode)  )\n      \\] (if (= (first mode) \\[) (recur (rest s) rnd (- sqr 1) cur (rest mode)) false)\n      \\{ (recur (rest s) rnd sqr (+ cur 1) (cons \\{ mode)  )\n      \\} (if (= (first mode) \\{) (recur (rest s) rnd sqr (- cur 1) (rest mode)) false)\n      (recur (rest s) rnd sqr cur mode)))))","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn balanced-brackets? [string]\n  (let [match-brackets? (fn match-brackets? [a b]\n                          (= ({\"(\" \")\", \"[\" \"]\", \"{\" \"}\"} a) b))\n        brackets (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" string)\n        result (reduce\n                 (fn [acc x]\n                   (if (match-brackets? (peek acc) x)\n                     (pop acc)\n                     (conj acc x)))\n                 '() brackets)]\n    (empty? result)))","problem":"177","user":"51a97f7ae4b08d8ec191b827"},{"problem":"177","code":"(fn f\n  [s]\n  (let [b  {\\) \\( \\] \\[ \\} \\{}\n        cb (into #{} (keys b))\n        ob (into #{} (vals b))]\n    (loop [[fs & sr :as s] (seq s)\n           stack '()]\n      (cond\n        (empty? s) (if (empty? stack) true false)\n        (ob fs) (recur sr (conj stack fs))\n        (cb fs) (if (= (b (cb fs)) (peek stack)) (recur sr (pop stack)) false)\n        :else (recur sr stack)))))","user":"54a11042e4b09f271ff37c49"},{"problem":"177","code":"(fn balance-brackets [some-str]\n  (let [stack (reduce\n               \n(fn fill-stack [the-stack some-char]\n  (if  (or (= some-char \\() (= some-char \\[) (= some-char \\{))\n    (conj the-stack some-char)\n    (if (or (= some-char \\)) (= some-char \\]) (= some-char \\}))\n      (if (= (last the-stack) ((fn matching-brk [some-char]\n  (if (= some-char \\))\n    \\(\n    (if (= some-char \\])\n      \\[\n      (if (= some-char \\})\n        \\{ )))\n  ) some-char))\n        (pop the-stack)\n        (conj the-stack some-char))\n      the-stack))\n  )\n               [] (seq some-str))]\n    (if (empty? stack)\n      true\n      false\n      )))","user":"5d6e5ec6e4b04d129b00f2c7"},{"problem":"177","code":"(fn balance-brackets [s]\n  (let [parse-brkts (fn [s] (->> s (into [])))\n        match-brkts (fn [acc b-2]\n                      (if (empty? acc) (conj acc b-2)\n                          (let [b-1 (peek acc)]\n                            (cond\n                              (and (= b-1 \\[) (= b-2 \\])) (pop acc)\n                              (and (= b-1 \\{) (= b-2 \\})) (pop acc)\n                              (and (= b-1 \\() (= b-2 \\))) (pop acc)\n                              (#{\\[ \\{ \\(} b-2) (conj acc b-2)\n                              :else acc))))]\n    (->> s\n         parse-brkts\n         (reduce match-brkts [])\n         (not-any? #{\\[ \\] \\( \\) \\{ \\}}))))","user":"505d1b01e4b0e6aca564be04"},{"problem":"177","code":"(fn balancing-bracket? [s]\n  (let [bracket-pair {\\[ \\] \\{ \\} \\( \\)}]\n    (loop [ss (seq s)\n           stack '()]\n      (cond\n        (empty? ss) (empty? stack)\n        (and (empty? stack)\n             (#{\\} \\] \\)} (first ss))) false\n        (not (#{\\[\\]\\{\\}\\(\\)} (first ss))) (recur (next ss) stack)\n        (= (bracket-pair (first stack))\n           (first ss)) (recur (next ss) (pop stack))\n        :else (recur (next ss) (conj stack (first ss)))))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn [s]\n   (let [open? #(contains? #{ \\( \\[ \\{ } %) close? #(contains? #{\\] \\) \\}} %) match? #(= ({\\( \\), \\[ \\], \\{ \\}} %) %2)]\n     (loop [[x & xs] s l ()]\n       (if x\n         (if (open? x)\n           (recur xs (cons x l))\n           (if (close? x)\n             (if (match? (first l) x)\n               (recur xs (rest l)) \n               false\n             )\n             (recur xs l)\n           )\n         )\n         (empty? l))\n     )\n   )\n )","problem":"177","user":"51ba8f82e4b0fe3ecfb46434"},{"code":"(fn f [a [h & t]]\n  (let [m (zipmap \")}]\" \"({[\")]\n    (cond\n     (nil? h) (empty? a)\n     (m h) (if (= (peek a) (m h))\n                     (f (pop a) t)\n                     false)\n     ((set \"(){}[]\") h) (f (conj a h) t)\n     :else (f a t))))\n[]","problem":"177","user":"4ebaf790535dfed6da9c6d6e"},{"code":"#(-> % (clojure.string/replace #\"[^()\\[\\]{}]\" \"\") ((fn verifica-it [st pilha]\n                                                                     (if (empty? st)\n                                                                       (if (empty? pilha)\n                                                                         true\n                                                                         false)\n                                                                       (condp (fn [x y] (x y)) (first st)\n                                                                         #{\\(\\{\\[} (verifica-it (next st) (conj pilha (first st)))\n                                                                         #{\\)\\}\\]} (if (some #{[(peek pilha) (first st)]} \n                                                                                             [[\\( \\)][\\[ \\]][\\{ \\}]])\n                                                                                     (verifica-it (next st) (pop pilha))\n                                                                                     false)))) []))","problem":"177","user":"52c8758be4b0c2d177d62135"},{"problem":"177","code":"(fn [string]\n  (let [\n    brackets {\\( \\), \\{ \\}, \\[ \\]}\n    brackets' (clojure.set/map-invert brackets)\n    opening-brackets (set (vals brackets'))\n    closing-brackets (set (keys brackets'))\n    balanced? (fn [[x & xs] stack]\n      (println x xs stack)\n      (cond\n        (nil? x) (empty? stack)\n        (contains? opening-brackets x) (recur xs (conj stack x))\n        (contains? closing-brackets x)\n          (and\n            (= (peek stack) (get brackets' x))\n            (recur xs (pop stack)))\n        :else (recur xs stack))\n        \n      )\n    ]\n    (balanced? string '())))","user":"55d5e80ee4b0e31453f64a91"},{"problem":"177","code":"(fn [apar1]\n    (loop\n      [opened \"\" x apar1 ]\n      (let [chr (first x)\n            op {\\{ \\} \\( \\) \\[ \\]}\n            ]\n        (if (empty? x)\n        (empty? opened)\n        (recur (if (or (= chr \\( ) (= chr \\[) (= chr \\{) )\n                 (str opened chr)\n                 (if (or (= chr \\) ) (= chr \\]) (= chr \\}) )\n                   (if (= chr (op (last opened)))\n                     (apply str (butlast opened))\n                     (str opened chr))\n                   opened\n                   ))\n               (rest x))\n        ))))","user":"533c2605e4b0e30313ee6cd7"},{"problem":"177","code":"(fn __ [s]\n  (let [openers (sorted-set \\( \\[ \\{ )\n        closers (sorted-set \\) \\] \\} )\n        tokens (set (concat closers openers))\n        rules (zipmap closers openers)\n        code (filter tokens s)]\n\n    (empty?\n     (reduce\n      (fn [memo ch]\n        (if (openers ch)\n          (cons ch memo)\n          (if (= (first memo) (rules ch))\n            (rest memo)\n            (cons :error memo))))\n      '()\n      code))))","user":"56069006e4b08b23635d3174"},{"code":"(fn [s]\n    (let [openers #{\\( \\[ \\{}\n         closers #{\\) \\] \\}}\n         closer-for {\\( \\) \\[ \\] \\{ \\}}\n         parser (fn [stack position]\n                    (cond (= position (count s)) (empty? stack)\n                          :else (let [next-character (nth s position)]\n                                     (cond (contains? openers next-character) (recur (conj stack next-character) (inc position))\n                                           (contains? closers next-character) (if (and (not (empty? stack)) (= next-character (closer-for (peek stack))))\n                                                                                  (recur (pop stack) (inc position)) false)\n                                            :else (recur stack (inc position))))))] (parser [] 0)))","problem":"177","user":"5213ffd3e4b0961f15ac4d7d"},{"code":"(fn rec-balance-brackets [ [ o & os :as oo] [ x & xs]]\n        ;(println \"o = \" o \" x \" x \"  xs \" xs)\n        (let [ \n            open-symb #{ \\( \\[ \\{ }\n            close-symb #{ \\) \\] \\} }\n            close {  \\( \\)  \\[ \\]  \\{ \\} } \n              ]  \n        (cond\n            (nil? x) (empty? oo) \n            (contains? close-symb x) (and (= o x) (recur os xs))\n            (contains? open-symb x) (recur (conj oo (close x)) xs)\n            :else (recur oo xs)))) nil","problem":"177","user":"51f59607e4b0abb92f97f9d5"},{"problem":"177","code":"#(let [m {\\)\\(\\]\\[\\}\\{}]\n   (-> (reduce\n        (fn [scope c]\n          (cond\n            (= (peek scope) (get m c :no))\n            (pop scope)\n            (m c)\n            nil\n            (#{\\(\\[\\{} c)\n            (conj scope c)\n            :else\n            scope))\n        ()\n        %)\n       (= '())))","user":"5398305fe4b0b51d73faaef6"},{"problem":"177","code":"(fn [n]\n  (let [obr {\\( \\) \\[ \\] \\{ \\}}\n        cbr {\\) \\( \\] \\[ \\} \\{}]\n    (letfn\n        [(go [br stack cs]\n           (if (empty? cs)\n             (and (nil? br) (empty? stack))\n             (let [c (first cs)\n                   cs' (rest cs)]\n               (cond\n                (get obr c)\n                (go c (cons br stack) cs')\n                (get cbr c)\n                (if (= (get cbr c) br)\n                  (if (empty? stack) (go nil stack cs')\n                      (go (first stack) (rest stack) cs'))\n                  false)\n                :else (go br stack cs')))))]\n      (= true (go nil [] n)))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":"177","code":"(fn [s]\n  (loop [[x & xs :as all] s stack []]\n    (cond \n      (every? empty? [all stack]) true\n      (and (empty? all) \n           ((complement empty?) stack)) false\n      :else (condp = x\n              \\( (recur xs (conj stack x))\n              \\{ (recur xs (conj stack x))\n              \\[ (recur xs (conj stack x))\n              \\] (if (or (empty? stack) \n                         (not= (last stack) \\[ ))\n                   false\n                   (recur xs (subvec stack 0 (dec (count stack)))))\n              \\} (if (or (empty? stack) \n                         (not= (last stack) \\{ ))\n                   false\n                   (recur xs (subvec stack 0 (dec (count stack)))))\n              \\) (if (or (empty? stack)\n                             (not= (last stack) \\( ))\n                       false\n                       (recur xs (subvec stack 0 (dec (count stack)))))\n             (recur xs stack)))))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn [x]\n  (let [m {\\( \\) \\[ \\] \\{ \\}}]\n    (loop [s (clojure.string/replace x #\"[^\\(\\)\\{\\}\\[\\]]\" \"\") b []]\n      (if (empty? s)\n        (empty? b)\n        (let [o (m (first s))]\n          (if (nil? o)\n            (if (not= (first s) (last b))\n              false\n              (recur (rest s) (pop b)))\n            (recur (rest s) (conj b o))))))))","problem":"177","user":"53468f6ce4b084c2834f4a3f"},{"problem":"177","code":"(fn balancing-brackets\n  [s]\n  (empty?\n   (reduce\n    (fn [v c]\n      (case c\n        \\( (conj v c)\n        \\[ (conj v c)\n        \\{ (conj v c)\n        \\) (if (= \\( (peek v))\n             (pop v)\n             [false])\n        \\] (if (= \\[ (peek v))\n             (pop v)\n             [false])\n        \\} (if (= \\{ (peek v))\n             (pop v)\n             [false])\n        v))\n    [] s)))","user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn is-balanced [a-str]\n  \t(let [open-brackets #{\\( \\{ \\[} close-brackets #{\\) \\} \\]} matching {\\) \\( \\} \\{ \\] \\[}\n\t\tres (reduce (fn [[stack balance] ch]\n\t\t\t  (if balance\n\t\t\t\t  (if (close-brackets ch)\n\t\t\t\t\t  (if (= (first stack) (matching ch))\n\t\t\t\t\t\t  [(rest stack) true]\n\t\t\t\t\t\t  [stack false]\n\t\t\t\t\t  )\n                      (if (open-brackets ch)\n                          [(conj stack ch) true]\n\t\t\t\t\t\t  [stack true])\t\n\t\t\t\t  )\n                  [stack false]\n\t\t\t   )\t\t\t\n            ) ['() true] (seq a-str)\n\t\t)\n\t]\t\n\t\t(and (second res) (zero? (count (first res))))\n\t)\n)","problem":"177","user":"52763696e4b03e8d9a4a74d7"},{"problem":"177","code":"(fn [xs]\n  (loop [xs (seq xs)\n         stk []]\n    (if (nil? xs)\n      (= (count stk) 0)\n      (let [x (first xs)]\n        (if (contains? (set \"([{\") x)\n          (recur (next xs) (conj stk x))\n          (if (contains? (set \")]}\") x)\n            (if (contains? #{\"()\" \"[]\" \"{}\"} (str (last stk) x))\n              (recur (next xs) (pop stk))\n              false)\n            (recur (next xs) stk)))))))","user":"5162757ee4b03cfa3774b3fe"},{"problem":"177","code":"(fn balanced? [x]\n (let [chars-seq (seq x)]\n  (loop [coll chars-seq brackets ()]\n    (let [head (first coll)]\n     (cond\n      (nil? head) (empty? brackets) \n      (= head \\[) (recur (rest coll) (conj brackets \\[))\n      (= head \\() (recur (rest coll) (conj brackets \\())\n      (= head \\{) (recur (rest coll) (conj brackets \\{))\n      (= head \\])\n       (if (= (first brackets) \\[)\n        (recur (rest coll) (rest brackets))\n        false)\n      (= head \\))\n       (if (= (first brackets) \\()\n        (recur (rest coll) (rest brackets))\n        false)\n      (= head \\})\n       (if (= (first brackets) \\{)\n        (recur (rest coll) (rest brackets))\n        false)\n      :else (recur (rest coll) brackets))))))","user":"54299d4be4b01498b1a71b3d"},{"problem":"177","code":"(fn [s]\n    (loop [xs s\n           open nil]\n         (cond (empty? xs) (empty? open)\n               (= \\( (first xs)) (recur (rest xs) (cons \\( open))\n               (= \\[ (first xs)) (recur (rest xs) (cons \\[ open))\n               (= \\{ (first xs)) (recur (rest xs) (cons \\{ open))\n               (= \\) (first xs)) (if (= (first open) \\()\n                                     (recur (rest xs) (rest open))\n                                     false)\n               (= \\] (first xs)) (if (= (first open) \\[)\n                                     (recur (rest xs) (rest open))\n                                     false)\n               (= \\} (first xs)) (if (= (first open) \\{)\n                                     (recur (rest xs) (rest open))\n                                     false)                   \n               :else (recur (rest xs) open))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":"177","code":"(let [twin   {\\[ \\], \\( \\), \\{ \\}}\n      close? (into #{} (vals twin))]\n  (fn balanced?\n    ([s] (balanced? s []))\n    ([[h & t] stack]\n     (cond (not h)    (empty? stack)\n           (twin h)   (recur t (conj stack (twin h)))\n           (close? h) (and (= h (peek stack))\n                           (recur t (pop stack)))\n           :else      (recur t stack)))))","user":"59eb63e3e4b0249b7282077c"},{"problem":"177","code":"#(empty?\n  (reduce\n    (fn [a c]\n      (let [e ({\\) \\( \\] \\[ \\} \\{} c)]\n        (cond\n          (and e (= (peek a) e)) (pop a)\n          (or (#{\\( \\[ \\{} c) e) (conj a c)\n          c a)))\n    []\n    %))","user":"58c73111e4b021aa9917ed72"},{"problem":"177","code":"(fn [s]\n  (empty?\n    (reduce\n      (fn [stack curr-char]\n        (cond\n          (#{\\( \\{ \\[} curr-char)\n          (conj stack curr-char)\n    \n          (#{\\) \\} \\]} curr-char)\n          (let [prev (peek stack)\n                match (get {\\) \\(, \\} \\{, \\] \\[} curr-char)]\n            (if (= prev match)\n              (pop stack)\n              ; If they didn't match, this string isn't balanced because tokens aren't properly paired.\n              ; Just push the closed token on, which will never get popped, as a sentinel.\n              ; When reduce finishes, we won't have an empty stack.\n              (conj stack curr-char)))\n\n          :else\n          stack))\n      []\n      s)))","user":"4fe49706e4b0e8f79898feb7"},{"problem":"177","code":"(fn [s]\n    (loop [x '() s s]\n        (if (empty? s) (empty? x)\n            (let [[f & s] s g [f] [h & i] x u (str h f)]\n            (if\n               (#{\\( \\[ \\{} f) (recur (conj x f) s)\n              (if  (#{\\) \\] \\}} f)\n                (if (#{\"()\" \"[]\" \"{}\"} u) (recur i s)\n                    nil)\n                (recur x s)\n            )\n        )))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":"177","code":"(fn balanced-brackts? [s]\n  (let [chars (filter (set \"[{()}]\") s)\n        count-them (fn [[c & r] [t & b :as stack]]\n                     (println stack)\n                     (case c\n                       \\] (if (not= t \\[)\n                            false\n                            (recur r b))\n                       \\} (if (not= t \\{)\n                            false\n                            (recur r b))\n                       \\) (if (not= t \\()\n                            false\n                            (recur r b))\n                       \\[ (recur r (cons \\[ stack))\n                       \\{ (recur r (cons \\{ stack))\n                       \\( (recur r (cons \\( stack))\n                       nil (empty? stack)))]\n    (count-them chars ())))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [s]\n    (let [ss (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" s)]\n      (empty?\n        (reduce\n          (fn [acc x]\n            (cond\n              (empty? acc) [x]\n              (= (str (first acc) x) \"()\") (rest acc)\n              (= (str (first acc) x) \"[]\") (rest acc)\n              (= (str (first acc) x) \"{}\") (rest acc)\n              :default (cons x acc)))\n          [] ss))))","problem":"177","user":"52a88c4de4b0c58976d9ac30"},{"problem":"177","code":"(fn [s]\n    (let [closes {\\) \\( \\] \\[ \\} \\{}]\n      (empty? (reduce (fn [[f & r :as brs] c]\n                        (cond\n                          ((set (vals closes)) c) (cons c brs)\n                          (closes c) (if (= f (closes c))\n                                          r\n                                          (cons c brs))\n                          true brs))\n                      nil s))))","user":"4ed0e139535d44c135fd68c7"},{"problem":"177","code":"(fn [s]\n (empty?\n (reduce \n #(if (contains? #{\\( \\[ \\{} %2)\n    (cons %2 %1)\n    (if (contains? #{\\) \\] \\}} %2)\n      (cond\n        (and (= \\) %2) (= \\( (first %1))) (rest %1)\n        (and (= \\] %2) (= \\[ (first %1))) (rest %1)\n        (and (= \\} %2) (= \\{ (first %1))) (rest %1)\n      :else (cons %2 %1))\n     %1)\n  )\n  '()\n  (seq s))))","user":"5df75fd8e4b0a607a9a45c92"},{"problem":"177","code":"(fn balanced\n  ([s] (balanced s []))\n  ([s stack]\n    (if (empty? s)\n      (empty? stack)\n      (let [[c & newstr] s\n            sets { \\( \\) \\[ \\] \\{ \\} }\n            all (flatten (into [] sets))\n            openers (map first (into [] sets))]\n        (if (not (some #(= c %) all))\n          (balanced newstr stack)\n          (if (some #(= c %) openers)\n            (balanced newstr (cons c stack))\n            (if (= c (sets (first stack)))\n              (balanced newstr (rest stack))\n              false)))))))","user":"55ede35ce4b0121d4835fde1"},{"problem":"177","code":"(fn [s]\n (let [pairs {\"[\" \"]\", \"(\" \")\", \"{\" \"}\"}\n       left (set (keys pairs))]\n  (loop [stack [] [f & rst] (re-seq #\"[\\[\\](){}]\" s)]\n   (if (not f)\n    (empty? stack)\n    (if (contains? left f)\n     (recur (conj stack f) rst)\n     (if (= (pairs (peek stack)) f)\n      (recur (pop stack) rst)))))))","user":"5835cb06e4b089d5ab817cea"},{"problem":"177","code":"(fn balance [s]\n  (loop [[head & tail] s\n         expected '()]\n    (cond\n      (= nil head) (empty? expected)\n      (#{ \\( \\[ \\{ } head) (recur tail (cons ({ \\( \\) \\[ \\] \\{ \\} } head) expected))\n      (= head (first expected)) (recur tail (rest expected))\n      (#{ \\) \\] \\} } head) false\n      :else (recur tail expected))))","user":"550e52dbe4b06e50f9beb165"},{"code":"(fn p177\n  [s]\n  (let [b (re-seq #\"[\\(\\[\\{\\}\\]\\)]\" s)\n        m {\"}\" \"{\" \")\" \"(\" \"]\" \"[\"}]\n    (if (nil? b)\n      true\n      (loop [r []\n             t b]\n        (if (empty? t)\n          (empty? r)\n          (let [c (first t)]\n            (if (contains? m c)\n              (if (not (some #(= % (m c)) r))\n                false\n                (recur (vec (drop-last r)) (rest t)))\n              (recur (conj r c) (rest t)))\n              ))))))","problem":"177","user":"5348cab4e4b084c2834f4a5e"},{"code":"#(loop [s %\n        l []]\n   (if (empty? s) (empty? l)\n   (let [c (first s)]\n     (if ((set \"([{\") c)\n         (recur (rest s)\n                (conj l ((into {} (map vector \"([{\" \")]}\"))\n                         c)))\n         (if ((set \")]}\") c)\n             (when (= c (peek l))\n               (recur (rest s) (pop l)))\n             (recur (rest s) l))))))","problem":"177","user":"50a83315e4b054305ba5a830"},{"problem":"177","code":"(fn [s]\n  (loop [ss (filter #(contains? #{\\[ \\] \\{ \\} \\( \\)} %) (seq s))\n         acc []]\n    (if (empty? ss)\n      (empty? acc)\n      (recur (rest ss)\n             (cond (and (= (first ss) \\]) (= (last acc) \\[)) (pop acc)\n                   (and (= (first ss) \\}) (= (last acc) \\{)) (pop acc)\n                   (and (= (first ss) \\)) (= (last acc) \\()) (pop acc)\n                   :else (conj acc (first ss)))))))","user":"5292feb4e4b0239c8a67af39"},{"code":"(let [bracket? #{\\[ \\] \\( \\) \\{ \\}}\n      pair? #{\"[]\" \"()\" \"{}\"}]\n  (fn [s]\n    (-> (reduce (fn [[x & xs :as acc] c]\n                  (cond\n                   (pair? (str x c)) xs\n                   (bracket? c)      (cons c acc)\n                   :else             acc))\n                nil\n                s)\n        (empty?))))","problem":"177","user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":"177","code":"(fn [str]\n    (let [char-pairs {\\{ \\}\n                      \\[ \\]\n                      \\( \\)}\n          checker (fn [stack char]\n                    (cond\n                      (#{\\{ \\[ \\(} char) (conj stack char)\n                      (#{\\} \\] \\)} char) (if (= (get char-pairs (peek stack)) char)\n                                           (pop stack)\n                                           (conj stack char))\n                      :else stack))]\n      (empty? (reduce checker '() str))))","user":"5317d78ee4b08068f379ed63"},{"problem":"177","code":"(fn [s]\n  (let [m {\\( \\) \\[ \\] \\{ \\}}]\n    (empty? (reduce (fn [b c] (cond (m c) (conj b (m c)) (= c (first b)) (rest b) (some #{c} (vals m)) [nil] :else b)) () s))))","user":"5db92996e4b010eb3c36cd50"},{"problem":"177","code":"(fn [i]\n    (let [b {\\) \\( \\] \\[ \\} \\{} v (set (vals b))]\n      (loop [i i s []]\n        (if (empty? i)\n          (empty? s)\n          (let [f (first i)]\n            (if (contains? v f)\n              (recur (rest i) (conj s f))\n              (if-let [c (get b f)]\n                (if (= c (peek s))\n                  (recur (rest i) (pop s))\n                  false)\n                (recur (rest i) s))))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [input]\n    (let [openers [\\{ \\[ \\(]\n          closers [\\} \\] \\)]\n          parse   (zipmap (map (comp keyword str) closers) openers)]\n\t(loop [in (seq input) prev '()]\n        (let [f (first in)]\n    \t(cond (nil? f) (empty? prev)\n              (some #{f} openers) (recur (rest in) (conj prev f))\n              (some #{f} closers) \n              \t(if (= ((keyword (str f)) parse) (first prev))\n                 \t(recur (rest in) (rest prev))\n                    false)\n              :else (recur (rest in) prev))))))","problem":"177","user":"50588af1e4b06522596eba7d"},{"code":"(fn [strng]\n      (loop [open '() cnt 0]\n       (if (= cnt (count strng))\n          (do\n                (if (> (count open) 0) false true))\n         (do\n                 (let [ch (nth strng cnt) n (int ch)]\n                      (if (or (= n 40) (= n 41) (= n 123) (= n 125) (= n 91) (= n 93))\n                      (do\n                      (case ch\n                               \\(  (recur (conj open ch) (inc cnt))\n                               \\{  (recur (conj open ch) (inc cnt))\n                               \\[  (recur (conj open ch) (inc cnt))\n                               \\)  (if (not= \\( (peek open)) false\n                                       (recur (pop open) (inc cnt)))\n                                \\} (if (not= \\{ (peek open)) false\n                                      (recur (pop open) (inc cnt)))\n                                \\]  (if (not= \\[ (peek open)) false\n                                     (recur (pop open) (inc cnt)))))\n                                     (recur open (inc cnt))))))))","problem":"177","user":"52c3a0f4e4b0c2d177d620c6"},{"code":"(fn balancing-brackets [str]\n  (let [tm { \\( 1 \\) -1 \\[ 2 \\] -2 \\{ 3 \\} -3 }\n        v (reduce (fn [a x]\n                    (let [v (tm x)]\n                      (if (nil? v) a (conj a v)) ))\n\n                  [] str)]\n    \n    (and (loop [d 0  v v]\n           (let [f (first v)]\n             (println d f)\n             (cond (nil? f) true\n                   (and (< f 0) (>= d 0) (not= 0 (+ d f))) false\n                   :else (recur f (rest v)))))\n         \n         (= 0 (apply + v)))\n\n    ))","problem":"177","user":"515bbcd9e4b0388ca8ca1521"},{"problem":"177","code":"(fn fre [in]\n  (#(if (= in %) (nil? (re-find #\"[(){}\\[\\]]\" in)) (fre %))\n    (clojure.string/replace \n      in \n      #\"\\([^(){}\\[\\]]*\\)|\\{[^(){}\\[\\]]*\\}|\\[[^(){}\\[\\]]*\\]\" \n      \"\")))","user":"575ddfd1e4b02ea11479938d"},{"problem":"177","code":"(fn ff [ss]\n\t(letfn [(ff [s] (reduce #(if (and (not (empty? %1)) (= (last %1) ({\\) \\( \\] \\[ \\} \\{} %2))) (vec (drop-last %1)) (conj %1 %2)) [] (filter #(.contains #{\\( \\) \\[ \\] \\{ \\}} %) s)))]\n\t\t(loop [c1 (ff ss) c2 (ff c1)]\n\t\t\t(if (= (count c1) (count c2))\n\t\t\t\t(if (empty? c2)\n\t\t\t\t\ttrue\n\t\t\t\t\tfalse)\n\t\t\t\t(recur c2 (ff c2))))))","user":"561a1af6e4b053970a773b02"},{"problem":"177","code":"(fn\n  [text]\n  (let [ps (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" text)]\n    (or\n     (empty? ps)\n     (empty? (reduce\n              (fn [stk n] (if (= (first stk) (get {\"(\" \")\" \"[\" \"]\" \"{\" \"}\" \")\" \"(\" \"]\" \"[\" \"}\" \"{\"} n))\n                              (rest stk) (conj stk n)))\n              (list (first ps)) (rest ps))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":"177","code":"(fn [s]\n  (loop [l s\n         q '()]\n    (cond \n     (empty? l) (empty? q)\n     (#{\\( \\{ \\[} (first l)) (recur (rest l) (cons (first l) q))\n     (= (first l) \\}) (if (= (first q) \\{) (recur (rest l) (rest q)) false)\n     (= (first l) \\]) (if (= (first q) \\[) (recur (rest l) (rest q)) false)\n     (= (first l) \\)) (if (= (first q) \\() (recur (rest l) (rest q)) false)\n     :else (recur (rest l) q)\n     )\n    )\n)","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [s [f & r]]\n  (if f\n    (let [b {\\( \\) \\[ \\] \\{ \\}} c (b f)]\n      (cond\n        c                  (recur (conj s c) r)\n        ((set (vals b)) f) (if (= f (peek s)) (recur (pop s) r) false)\n        :e                 (recur s r)))\n    (empty? s))) []","problem":"177","user":"5256627ce4b0541d1855ba1a"},{"problem":"177","code":"(fn [s]\n  (letfn [(corresp [bracket]\n            (cond (= bracket \\}) \\{\n                  (= bracket \\]) \\[\n                  (= bracket \\)) \\( ))\n          (match [stack rst]\n            (cond (and (empty? rst) (empty? stack)) true\n                  (empty? rst) false\n                  :else (let [cur (first rst)]\n                          (cond (contains? #{\\{ \\[ \\( } cur) (match (cons cur stack) (rest rst))\n                                (and (contains? #{\\) \\} \\]} cur) (= (first stack) (corresp cur)))\n                                (match (rest stack) (rest rst))\n                                (contains? #{\\) \\} \\]} cur) false\n                                :else (match stack (rest rst))))))]\n    (match nil s)))","user":"58f98231e4b0438e51c2cf4c"},{"problem":"177","code":"(fn [s]\n  (let [braces { \\} \\{ \\] \\[ \\) \\(}\n        opens (->> braces vals (into #{}))\n        closes (->> braces keys (into #{}))]\n    (empty? (reduce #(cond\n              (opens %2) (conj %1 %2)\n              (closes %2) (if (= (peek %1) (braces %2)) \n                            (pop %1) \n                            (conj %1 nil))\n              :else %1) [] s))))","user":"53c649d3e4b00fb29b221297"},{"problem":"177","code":"(letfn [(opening? [c]\n          (#{\\( \\{ \\[} c))\n        (closing? [c]\n          (#{\\) \\} \\]} c))\n        (matching? [stack c]\n          (and (not-empty stack)\n               (= c\n                  ({\\( \\), \\{ \\}, \\[ \\]} (peek stack)))))]\n  (fn balancing-brackets [sentence]\n    (loop [s [], [h & t] (seq sentence)]\n      (cond (nil? h) (empty? s)\n            (opening? h) (recur (conj s h) t)\n            (closing? h) (when (matching? s h)\n                           (recur (pop s) t))\n            :else (recur s t)))))\n#_ ;reduce cannot finish fast\n                  (fn [s]\n (let [p  {\\( \\) \\[ \\] \\{ \\}}\n       b #{\\( \\) \\[ \\] \\{ \\}}]\n  (empty?\n   (reduce (fn [[h & t :as xs] x]\n            (cond\n             (= (p h) x) t\n             (b x) (conj xs x)\n             :else xs))\n    () s))))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":"177","code":"#(= '() (reduce (fn [a e] (let [m {\\} \\{ \\) \\( \\] \\[}]\n                             (cond \n                              \t(some #{e} (vals m)) (cons e a)\n                              \t(= (m e) (first a)) (rest a)\n                              \t(and (m e) (= 0 (count a))) (cons 0 a) \n                                :else a))) \n                '() \n                %))","user":"577202d2e4b0979f896515c0"},{"code":"(fn [s] \n    (let [pairs {\\( \\)\n                 \\[ \\]\n                 \\{ \\}}\n          opening? (set (keys pairs))\n          closing? (set (vals pairs))]\n      (empty?\n       (reduce\n        (fn [m v]\n          (cond \n           (opening? v) (conj m v)\n           (= v (pairs (first m))) (rest m)\n           (closing? v) [:mismatch v]\n           :else m))\n        ()\n        (seq s)))))","problem":"177","user":"4f463dfde4b0d56e7bb92b99"},{"problem":"177","code":"(fn balanced-brackets? [str]\n  (letfn [(stack-scan [[top & popped :as stack] char]\n            (let [pair-map {\\( \\) \\[ \\] \\{ \\}}\n                  brackets (set \"()[]{}\")]\n              (cond (= (pair-map top) char) popped\n                    (brackets char) (cons char stack)\n                    :else stack)))]\n    (empty? (reduce stack-scan () str))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn balance [s]\n  (let [opens (set \"({[\")\n\tcloses (set \")}]\")\n\tmatches { \\) \\( \n\t\t  \\} \\{ \n\t\t  \\] \\[ }]\n    (loop [parens nil data s]\n      (if (empty? data)\n\t(empty? parens)\n\t(if (contains? opens (first data))\n\t  (recur (conj parens (first data))\n\t\t (rest data))\n\t  (if (contains? closes (first data))\n\t    (if (= (first parens) (matches (first data)))\n\t      (recur (rest parens) (rest data))\n\t      false)\n\t    (recur parens (rest data))))))))","problem":"177","user":"4e513ecf535dc968683fc4f6"},{"problem":"177","code":"(fn balance [x](let [worked (into [] (filter #(some #{\\{ \\( \\[ \\) \\} \\]} [%1]) x))\n              reverse (fn reverse [x] (condp = x\n                                        \\( \\)\n                                        \\{ \\}\n                                        \\[ \\]\n                                        \\) \\(\n                                        \\] \\[\n                                        \\} \\{\n                                        ))\n                      find (fn find [x] (reduce (fn [a b] (if (some #{\\{ \\( \\[} [(nth x b)]) b a)) 0 (range (count x))))]\n                  (if (empty? worked) true (if (> 2 (count worked))\n                     false\n                     (if (= (nth worked (inc (find worked))) (reverse (nth worked (find worked))))\n                       (balance (concat (subvec worked 0 (find worked)) (subvec worked (inc (inc (find worked))))))\n                       false)))))","user":"567f988be4b0feffd0d18ebe"},{"problem":"177","code":"(fn [s] \n  (loop [s (seq s) \n         r [] ] \n    (if (empty? s) \n      (empty? r)\n      (case (first s) \n        \\( (recur (rest s) (cons \\( r)) \n        \\[ (recur (rest s) (cons \\[ r)) \n        \\{ (recur (rest s) (cons \\{ r)) \n        \\) (when (= (first r) \\()(recur (rest s) (rest r)))\n        \\] (when (= (first r) \\[)(recur (rest s) (rest r)))\n        \\} (when (= (first r) \\{)(recur (rest s) (rest r)))\n        (recur (rest s) r)))))","user":"5457e5f1e4b01be26fd74613"},{"code":"(fn [string]\n  (let [string (clojure.string/replace string #\"[^(){}\\[\\]]\" \"\")\n        braces {\\} \\{ \\] \\[ \\) \\(}]\n    (loop [string string stack ()]\n      (if (empty? string)\n        (empty? stack)\n        (let [c (first string)]\n          (if-not (contains? braces c)\n            (recur (rest string) (cons c stack))\n            (if (= (get braces c) (first stack))\n              (recur (rest string) (rest stack))\n              false)))))))","problem":"177","user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn foo [s]\n  (let [brackets\n        {\\{, {:name :curly , :status :open},\n         \\}, {:name :curly , :status :close},\n         \\[, {:name :square , :status :open},\n         \\], {:name :square , :status :close},\n         \\), {:name :round , :status :close},\n         \\(, {:name :round , :status :open}}]\n    (let [bracketSymbols (set (keys brackets))]\n      (let [ subResult\n      (reduce\n        (fn [aggregator, c]\n          (let [result (first aggregator), stack (last aggregator)]\n            (if (= false result)\n              aggregator\n              (if (contains? bracketSymbols c)\n                (if (= ((brackets c) :status) :open)\n                  (list result (conj stack c))\n                  (if (= (count stack) 0)\n                    (list false stack)\n                    (if (= ((brackets (peek stack)) :name) ((brackets c) :name))\n                      (list result (pop stack))\n                      (list false (pop stack))\n                      )\n                    ))\n                aggregator)\n              )\n            )\n          ) [true []] s)]\n        (and (first subResult) (= (count (last subResult)) 0))\n\n        ))))","problem":"177","user":"51b5a6e0e4b0f094dd986fce"},{"problem":"177","code":"(fn br-balanced? [s]\n  (let [braces (seq \"(){}[]\")\n        pair (apply hash-map braces)\n        open (-> pair keys set)\n        close (-> pair vals set)]\n    (loop [[c & other :as in] (seq s)\n           expecting '()]\n      (cond\n        (not c) (empty? expecting)\n        (open c) (recur other (conj expecting (pair c)))\n        (close c) (if (= (peek expecting)  c)\n                    (recur other (pop expecting)))\n        :else (recur other expecting)))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":"177","code":"(fn balanced-parans?\n  [stringified-expr]\n    (letfn [(open-paran? [paran-char] (re-seq #\"\\[|\\(|\\{\" (str paran-char)))\n            (close-paran? [paran-char] (re-seq #\"\\)|\\]|\\}\" (str paran-char)))\n            (pair? [open-paran close-paran] (re-seq #\"\\(\\)|\\[\\]|\\{\\}\" (str open-paran close-paran)))\n            (balanced-brackets? [[open-parans closing-parans :as all]]\n               (if (= (count open-parans) (count closing-parans))       ;; equal? number of parans\n                  (every? empty? all)                  ;; all open/close colls are empty? else NOT balanced!\n                  false))\n            (parse-expression [stringified-expr]\n              (loop [[head & tail] (seq stringified-expr)\n                      opening-brackets []\n                      closing-brackets []]\n                (if (nil? head)\n                  [opening-brackets closing-brackets]\n                  (if-let [closing-seq (close-paran? head)]\n                    (if (pair? (last opening-brackets) (first closing-seq))\n                       (recur tail (vec (butlast opening-brackets)) closing-brackets)\n                       (recur tail opening-brackets (conj closing-brackets head)))\n                    (if-let [opening (open-paran? head)]\n                       (recur tail (conj opening-brackets head) closing-brackets)\n                       (recur tail opening-brackets closing-brackets))))))]\n    (balanced-brackets? (parse-expression stringified-expr))))","user":"5553b729e4b0deb715856e05"},{"code":"(fn check\n  ([xs] (check xs '()))\n  ([[x & xs] brackets]\n   (let [left {\\( \\), \\[ \\], \\{ \\}}\n         right #{\\) \\] \\}}]\n     (cond\n       (nil? x)  (empty? brackets)\n       (left x)  (recur xs (cons (left x) brackets))\n       (right x) (if (= x (first brackets))\n                   (recur xs (rest brackets))\n                   false)\n       :else     (recur xs brackets)))))","problem":"177","user":"4ec07699535dfed6da9c6da2"},{"problem":"177","code":"(let [;; Map open to close\n      terminal-map\n      {\\( \\)\n       \\[ \\]\n       \\{ \\}}\n\n      open-terminals\n      (set (keys terminal-map))\n\n      all-terminals\n      (set (flatten (seq terminal-map)))\n\n      legal-next {\\( #{\\( \\)\n                       \\[\n                       \\{}\n                  \\) all-terminals\n                  \\[ #{\\[ \\]\n                       \\(\n                       \\{}\n                  \\] all-terminals\n                  \\{ #{\\{ \\}\n                       \\[\n                       \\(}\n                  \\} all-terminals}]\n  (fn [input]\n    (loop [tokens (filter all-terminals\n                          (seq input))\n           stack '()]\n      (if-let [t (first tokens)]\n        (if-let [last-t (peek stack)]\n          (cond\n            ;; close\n            (= (get terminal-map last-t) t)\n            (recur (rest tokens)\n                   (pop stack))\n            ;; legal nest\n            (contains? (get legal-next last-t)\n                       t)\n            (recur (rest tokens)\n                   (conj stack t))\n            :else false)\n          ;; open new\n          (if (contains? open-terminals t)\n            (recur (rest tokens)\n                   (conj stack t))\n            false))\n        (empty? stack)))))","user":"54246fcce4b01498b1a71aed"},{"problem":"177","code":"(fn [txt]\n  (let [brackets #{\\( \\) \\[ \\] \\{ \\}}\n        brackets-group {\\( :round \\) :round \\[ :square \\] :square \\{ :curl \\} :curl}\n        brackets-role {\\( :open \\) :close \\[ :open \\] :close \\{ :open \\} :close}\n        brackets-only-txt (filter #(get brackets %) (seq txt))\n        groups-match? (fn [x0 x1] (= (brackets-group x0) (brackets-group x1)))\n        roles-match? (fn [x0 x1] (and (= (brackets-role x0) :open) (= (brackets-role x1) :close)))]\n    (loop [pre [], [x0 x1 & x] brackets-only-txt]\n        (cond (nil? x0) true\n              (roles-match? x0 x1) (if (groups-match? x0 x1) (recur [] (concat pre x))\n                                     false)\n              (nil? (seq x)) false\n              true (recur (conj pre x0) (cons x1 x))))))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"problem":"177","code":"(fn\n  [s]\n  (letfn [(mystrip [x] (-> x (.replaceAll \"\\\\(\\\\)\" \"\") (.replaceAll \"\\\\[\\\\]\" \"\") (.replaceAll \"\\\\{\\\\}\" \"\")))]\n    (let [ss (apply str (re-seq #\"[\\[\\{\\(\\)\\}\\]]\" s))]\n        (loop [n (count ss)\n               sss ss]\n          (let [ssss (mystrip sss)]\n            (if (zero? (count ssss)) true\n              (if (= n (count ssss)) false\n                (recur (count ssss) ssss))))))))","user":"56d1afd9e4b0ea9b8538f791"},{"problem":"177","code":"(fn [s]\n  (letfn [(o-bracket? [c]\n            (contains? #{\\[ \\( \\{} c))\n          (c-bracket? [c]\n            (contains? #{\\] \\) \\}} c))\n          (matching? [c x]\n            (= x (get {\\[ \\] \\( \\) \\{ \\}} c)))]\n    (loop [st [] s' s]\n      (cond\n       (empty? s') (empty? st)\n       (o-bracket? (first s')) (recur (conj st (first s')) (rest s'))\n       (c-bracket? (first s')) (if (matching? (last st) (first s'))\n                                 (recur (pop st) (rest s'))\n                                 false)\n       :else (recur st (rest s'))))))","user":"5576f299e4b05c286339e077"},{"problem":"177","code":"(fn [q]\n      (loop [x (seq q), stack [], state true]\n            (let [current (first x), last (last stack), open (or (= current \\() (= current \\[) (= current \\{)), close (or (= current \\)) (= current \\]) (= current \\})), sa (and (= current \\]) (= last \\[)), sb (and (= current \\)) (= last \\()), sc (and (= current \\}) (= last \\{))]\n                 (if (empty? x) (and state (empty? stack))\n                                (recur\n                                  (rest x)\n                                  (if (or open close) (if (true? open) (conj stack current) (vec (take (dec (count stack)) stack)) ) stack)\n                                  (if (true? close) (and state (or sa sb sc)) state)\n                                  )\n                                )\n                 )\n            )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":"177","code":"(fn[zd]\n    (\n      (fn[args]\n        (cond\n            (empty? args) true\n            ;(every? false? (for [x [\"(]\" \"(}\" \"[)\" \"[}\" \"{)\" \"{]\"] ] (.contains  x (apply str args)))) false\n            (true? (some true?\n                  (map #(.contains (apply str args) %)  [\"(]\" \"(}\" \"[)\" \"[}\" \"{)\" \"{]\"])\n            \n                ))               false\n            :else \n                 (loop [xs args v 0 l 0 s 0 ]\n                  ;(println [v l s])\n                  (if (empty? xs)\n                              (every? zero? [v l s])\n                              (recur  (rest xs)\n                                      (cond\n                                      (= (first xs) \\() (inc v)\n                                      (= (first xs) \\)) (dec v)\n\n                                      :else v)\n\n                                      (cond\n                                      (= (first xs) \\[) (inc l)\n                                      (= (first xs) \\]) (dec l)\n\n                                      :else l)\n\n                                      (cond\n                                      (= (first xs) \\{) (inc s)\n                                      (= (first xs) \\}) (dec s) \n                                      :else s)\n                              )\n                  )\n                )\n        )\n      )\n      (filter #(.contains [\\( \\) \\[ \\] \\{ \\}] %) zd )\n    )\n  )","user":"55d7312ee4b0e31453f64a9f"},{"problem":"177","code":"(fn balancing-brackets\n  [s]\n  (let [opening-bracket? #{\\( \\{ \\[}\n        closing-bracket? #{\\) \\} \\]}\n        bracket-map (zipmap\n                     (concat opening-bracket? closing-bracket?)\n                     (concat closing-bracket? opening-bracket?))]\n    (empty? (reduce (fn [[x & xs :as coll] c]\n                      (if (and (closing-bracket? c) (= x (bracket-map c))) \n                        xs\n                        (cons c coll)))\n                    []\n                    (filter (clojure.set/union opening-bracket? closing-bracket?)\n                            s)))))","user":"506f0968e4b09350ab4199f5"},{"problem":"177","code":"(fn balanced?\n  [s & [acc]]\n  (let [acc (or acc [])]\n    (if (empty? s)\n      (empty? acc)\n      (let [head (first s)]\n        (if-let [match ({\\{ \\} \\} \\{\n                         \\[ \\] \\] \\[\n                         \\( \\) \\) \\(} head)]\n          (cond\n            (#{\\{ \\[ \\(} head)\n            (balanced? (rest s) (conj acc head))\n\n            (= match (peek acc))\n            (balanced? (rest s) (pop acc))\n\n            :else\n            false)\n          (balanced? (rest s) acc))))))","user":"51e3a549e4b0c611d6113e47"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\) \\(, \\] \\[, \\} \\{} ls (vals pairs) rs (keys pairs)]\n    (empty?\n     (loop [acc [] ss (seq s)]\n       (if-let [c (first ss )]\n         (cond\n          (some #(= % c) ls) (recur (conj acc c) (rest ss))\n          (some #(= % c) rs) (if (= (peek acc) (get pairs c)) (recur (pop acc) (rest ss)) (conj acc c))\n          :else acc)                             \n         acc)))))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn [s]\n  (let [pair {\\] \\[ \\) \\( \\} \\{}\n        opener (set (vals pair))\n        closer (set (keys pair))]\n    (loop [history ()\n           [c & cs :as s] s]\n      (cond\n       (empty? s) (empty? history)\n       (opener c) (recur (cons c history) cs)\n       (closer c) (if (= (pair c) (first history))\n                    (recur (rest history) cs)\n                    false)\n       :else (recur history cs)))))","problem":"177","user":"507b7dbee4b09034bfeeb71e"},{"problem":"177","code":"(fn balanced-brackets?\n  ([s] (balanced-brackets? s []))\n  ([s open-brackets]\n   (let [closed-open-pairs {\\) \\(\n                            \\] \\[\n                            \\} \\{}\n         closing (into #{} (keys closed-open-pairs))\n         opening (into #{} (vals closed-open-pairs))]\n     (if (empty? s)\n       (empty? open-brackets)\n       (let [next-char (first s)]\n         (cond\n           (contains? opening next-char) (recur (next s) (conj open-brackets next-char))\n           (contains? closing next-char) (if (= (peek open-brackets) (get closed-open-pairs next-char))\n                                           (recur (next s) (pop open-brackets)))\n           :else (recur (next s) open-brackets)))))))","user":"592ac17ae4b072a2710fcf26"},{"problem":"177","code":"(fn [d] \n   \n (letfn [(balance [a]\n         (reduce \n                (fn [x y] \n                          (println \"X: \" x \"Y: \" y)\n                          (if \n                              (closing (last x) y) \n                              (pop x) \n                              (conj x y)\n                          ) \n                 )\n                 [] \n                 a\n          )\n        )\n        (closing [c1 c2]\n          (println c1 c2) \n          (let [closing_map {\"{\" \"}\" \"[\" \"]\" \"(\" \")\" } c11 (get closing_map c1 \"notfound\")] \n              (if (= c11 c2) true false)\n           ) \n        )       \n       ]\n    (empty? (balance (filter \n   #(if (or (= % \"}\") (= % \"{\") (= % \"[\") (= % \"]\") (= % \"(\") (= % \")\")) true false) \n   (clojure.string/split d #\"\")) ))\n  )\n  \n  )","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":"177","code":"#(let [open { \\[ \\]\n              \\{ \\} \n              \\( \\) }\n       close (clojure.set/map-invert open)]\n   (empty? (reduce (fn [v c] (cond\n                               (open c) (conj v c)\n                               (and (close c) (= (last v) (close c))) (pop v)\n                               (close c) (conj v c)\n                               :else v)) [] %)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":"177","code":"(fn [xs]\n  (let [m { \"{\" \"}\", \"[\" \"]\", \"(\" \")\"}]\n    (loop [cs (re-seq #\".\" xs)\n           stack '()]\n      (if (empty? cs)\n        (empty? stack)\n        (let [c (first cs)]\n          (cond\n            ((set (keys m)) c) (recur (rest cs) (cons c stack))\n            ((set (vals m)) c) (cond\n                                 (empty? stack) false\n                                 (= (m (first stack)) c) (recur (rest cs) (rest stack))\n                                 :else false)\n            :else (recur (rest cs) stack)))))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":"177","code":"(fn brackets-balanced? [s]\n  (let [brs {\\} \\{\n             \\] \\[\n             \\) \\(}\n        obs (set (vals brs))\n        {stack  :stack\n         result :result} (reduce (fn [{:keys [result stack]} c]\n                                   (if (contains? brs c)\n                                     (if (= (first stack) (get brs c))\n                                       {:result result\n                                        :stack  (drop 1 stack)}\n                                       {:result false\n                                        :stack  stack})\n                                     (if (contains? obs c)\n                                       {:result result\n                                        :stack  (conj stack c)}\n                                       {:result result\n                                        :stack  stack})))\n                                 {:result true\n                                  :stack  '()}\n                                 (seq s))]\n    (and result (empty? stack))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn [s]\n  (loop [stack '(),\n         ss (seq s)]\n    (if (empty? ss)\n      (empty? stack)\n      (case (first ss)\n        \\( (recur (conj stack \\( ) (rest ss))\n        \\) (if (= (peek stack) \\( )\n              (recur (pop stack) (rest ss))\n              false)\n        \\{ (recur (conj stack \\{ ) (rest ss))\n        \\} (if (= (peek stack) \\{ )\n              (recur (pop stack) (rest ss))\n              false)\n        \\[ (recur (conj stack \\[ ) (rest ss))\n        \\] (if (= (peek stack) \\[ )\n              (recur (pop stack) (rest ss))\n              false)\n        (recur stack (rest ss))))))","problem":"177","user":"5341b141e4b00652c8746ecf"},{"problem":"177","code":"(fn puzzle-177 [s]\n  (let [pairs-str \"{}()[]\"\n        pairs (clojure.set/map-invert (apply hash-map (seq \"{}()[]\")))\n        open (set (vals pairs))\n        close (set (keys pairs))]\n  (loop [syms (seq s)\n         stack '()]\n    (cond\n      (and (empty? syms) (empty? stack)) true\n      (empty? syms) false\n      :else (let [[sym & r] syms\n                  new-stack (cond\n                              (open sym) (cons sym stack)\n                              (close sym) (if (= (first stack) (get pairs sym))\n                                            (drop 1 stack)\n                                            nil)\n                              :else stack)]\n              (if (nil? new-stack) false\n                (recur (drop 1 syms) new-stack)))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":"177","code":"(fn check\n  ([st] (check (seq st) []))\n  ([[s & ss] stack]\n   (let [pairs { \\] \\[, \\) \\(, \\} \\{}]\n     (cond\n      (not s) (empty? stack)\n      (.contains (vals pairs) s) (recur ss (conj stack s))\n      (.contains (keys pairs) s) (if (= (pairs s) (peek stack))\n                                   (recur ss (pop stack))\n                                   false)\n      :else (recur ss stack)))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":"177","code":"(let [lp \"(\"\n      rp \")\"\n      ls \"[\"\n      rs \"]\"\n      lb \"{\"\n      rb \"}\"\n      not-nil? (complement nil?)]\n(letfn\n  [\n  (balance [s]\n    (reduce\n      (fn [x now]\n        (let\n          [\n            open (first (filter #(= (str now) %) #{lp ls lb}))\n            close (first (filter #(= (str now) %) #{rp rs rb}))\n            open-from-close ({rp lp, rs ls, rb lb} close)\n            next\n              (cond\n                (nil? x) x\n                (not-nil? open)\n                  (assoc\n                    (assoc x open (inc (x open)))\n                    :so-far\n                    (conj (x :so-far) open))\n                (not-nil? close)\n                  (if (not= open-from-close (last (x :so-far)))\n                    nil\n                    (assoc\n                      (assoc x open-from-close (dec (x open-from-close)))\n                      :so-far\n                      (vec (butlast (x :so-far)))))\n                :else x)\n          ]\n          (if (some #(and (number? (val %)) (> 0 (val %))) next)\n            nil\n            next)))\n        {lp 0, ls 0, lb 0, :so-far []}\n        s))\n  (solve [s] (let [result (balance s)] (if (nil? result) false (every? #(or (not (number? (val %))) (zero? (val %))) result))))\n  ]\n  solve\n))","user":"57717915e4b0979f896515b3"},{"problem":"177","code":"(fn [text]\n    (loop [open []\n           [h & t] text]\n      (cond\n       (#{\\( \\[ \\{ } h) (recur (conj open h) t)\n       (#{\\) \\] \\} } h) (if (= ({\\) \\(, \\] \\[, \\} \\{} h) (last open))\n                          (recur (vec (butlast open)) t)\n                          false)      \n       (nil? t) (empty? open)\n       :else (recur open t))))","user":"544e9022e4b0e3978000698b"},{"problem":"177","code":"#(letfn [(f [x acc]\n           (let [[h & t] x]\n             (cond\n              (empty? x) (empty? acc)\n              (or (= h \\()\n                  (= h \\[)\n                  (= h \\{)) (f t (conj acc h))\n              (= h \\)) (if (= (peek acc) \\()\n                         (recur t (pop acc))\n                         false)\n              (= h \\}) (if (= (peek acc) \\{)\n                         (recur t (pop acc))\n                         false)\n              (= h \\]) (if (= (peek acc) \\[)\n                         (recur t (pop acc))\n                         false)\n              :else (recur t acc))))]\n  (f (seq %) '()))","user":"5371167fe4b0fc7073fd6ea7"},{"code":"(fn [str]\n  (let [prepared-seq (re-seq #\"[{}\\[\\]\\(\\)]\" str)]\n    (loop [current-seq prepared-seq stack []]\n      (if (empty? current-seq)\n        (empty? stack)\n        (let [current-seq-sym (first current-seq)\n              top-stack-sym (last stack)\n              sym-map {\"{\" \"}\"\n                       \"[\" \"]\"\n                       \"(\" \")\"}]\n          (if (= current-seq-sym (sym-map top-stack-sym))\n            (recur (rest current-seq) (pop stack))\n            (recur (rest current-seq) (conj stack current-seq-sym))))))))","problem":"177","user":"51aefceee4b09397d5109797"},{"problem":"177","code":"(fn balanced [s]\n    (zero?\n        (count\n            (reduce\n                (fn [acc c]\n                    (let [pairs {\\] \\[, \\) \\(, \\} \\{} pc (pairs c)]\n                        (if (and pc (= pc (last acc)))\n                            (vec (butlast acc))\n                            (conj acc c))))\n                []\n                (seq (clojure.string/replace s #\"[^()\\{\\}\\[\\]]\" \"\"))))\n))","user":"53b2a7f8e4b047364c04449c"},{"problem":"177","code":"(fn f [str]\n  (let [lp [\\( \\[ \\{]\n        rp [\\) \\] \\}]\n        rlp (zipmap rp lp)]\n    (loop [[fst & rst] str stack []]\n      (cond\n        (nil? fst) (empty? stack)\n        ((set lp) fst) (recur rst (cons fst stack))\n        ((set rp) fst) (if (= (rlp fst) (first stack)) (recur rst (rest stack)) false)\n        :else (recur rst stack)))))","user":"56795deae4b05957ce8c6187"},{"problem":"177","code":"(fn [arg]\n  (loop [argList (flatten (partition-by identity arg))\n         stack '()\n         balanced? true]\n      (if (not balanced?)\n         false\n         (if (empty? argList)\n            (if (empty? stack)\n                true\n                false)\n            (let [elem (first argList)\n                  ipeek (peek stack)\n                  isPop? (if (or (= elem \\)) (= elem \\]) (= elem \\})) true false)\n                  newstack (if (or (= elem \\() (= elem \\[) (= elem \\{) )\n                               (conj stack elem)\n                               (if isPop?\n                                   (if (not (nil? ipeek)) (pop stack))\n                                    stack))\n                  new-bal? (if isPop? \n                               (if (or (and (= elem \\) ) (= ipeek \\( ))  \n                                       (and (= elem \\} ) (= ipeek \\{ ))\n                                       (and (= elem \\] ) (= ipeek \\[ )))\n                                   true\n                                   false)\n                               true)]\n             (recur (rest argList)\n                    newstack\n                    new-bal?))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":"177","code":"(fn [str]\n   (let [brackets (re-seq #\"\\(|\\)|\\[|\\]|\\{|\\}\" str)\n         open-to-closed {\"(\" \")\", \"[\" \"]\", \"{\" \"}\"}\n         stack (java.util.Stack.)]\n     (empty?\n       (reduce (fn [stack it]\n                 (cond\n                   (or (= \"(\" it) (= \"[\" it) (= \"{\" it)) (do (.push stack it) stack)\n                   :else (if (and (not (empty? stack)) (= (get open-to-closed (.peek stack)) it))\n                           (do (.pop stack) stack)\n                           (do (.push stack it) stack))))\n               stack\n               brackets)))\n   )","user":"5c3f37fce4b08cd430848e91"},{"problem":"177","code":"(fn brackets\n  [input-string]\n  (letfn [\n          (f144\n            [s tk]\n            (if (empty? s)\n              (if (empty? tk)\n                true\n                false)\n\n              (let [ch (first s)]\n                (cond\n                 (#{\\[ \\{ \\( }  ch)\n                 (let [ head (rest s)\n                       tail  (conj tk ch)]\n                   (f144 head tail))\n\n                 (#{\\] \\} \\) } ch)\n                 (let [ first-stack (first tk)\n                       rest-stack (rest tk)\n                       rest-instr (rest s) ]\n                   (if (= ( {\\[ \\]  \\{  \\} \\( \\)} first-stack) ch)\n                     (f144 rest-instr rest-stack )\n                     false))\n\n                 :else (f144 (rest s) tk)))\n              )\n            )\n          ]\n    (f144 input-string (list))))","user":"51f81925e4b09be9c177e526"},{"problem":"177","code":"(fn balanced? [s]\n  (let [p {\\( \\), \\[ \\], \\{ \\}}\n        a (set \"()[]{}\")]\n    (empty?\n      (reduce (fn [[t & b :as stack] s]\n                (cond (= (p t) s) b\n                      (a s) (conj stack s)\n                      :else stack))\n              () s))))","user":"5fc5c303e4b02c825b0c8c1a"},{"problem":"177","code":"(fn balance?\n  [astring]\n  (if (odd? (count (re-seq #\"[\\[\\]{}()]\" astring))) false\n    (loop [parsed (re-seq #\"[\\[\\]{}()]\" astring)\n           match {\"]\" \"[\" \")\" \"(\" \"}\" \"{\"}\n           res []]\n      (cond\n        (empty? parsed) (empty? res)\n        (nil? (get match (first parsed))) (recur (rest parsed)\n                                                 match\n                                                 (conj (vec res) (first parsed)))\n        :else (if (= (last res) (get match (first parsed)))\n                (recur (rest parsed) match (vec (butlast res))) false)))))","user":"550d9452e4b06e50f9beb15d"},{"code":"(fn [a]\n  (let [brvec [\\( \\) \\[ \\] \\{ \\}]\n        bracket? (fn [b] (seq (filter #(= b %) brvec)))\n        only-brackets (filter bracket? a)\n        cob (count only-brackets)\n        match? (fn [c1 c2] (or\n                           (and (= c1 \\() (= c2 \\)))\n                           (and (= c1 \\[) (= c2 \\]))\n                           (and (= c1 \\{) (= c2 \\}))))\n        remove-matches (fn [ob]\n                         (loop [ind 0 res []]\n                           (cond\n                            (= ind (dec' (count ob))) (concat res [(last ob)])\n                            (> ind (dec' (count ob))) res\n                            (not (match? (nth ob ind) (nth ob (inc' ind)))) (recur (inc' ind) (concat res [(nth ob ind)]))\n                            (match? (nth ob ind) (nth ob (inc' ind))) (recur (+' ind 2) res))))]\n    (if (odd? cob)\n      false\n      (loop [leftover only-brackets]\n        (cond\n         (empty? leftover) true\n         (= leftover (remove-matches leftover)) false\n         :else (recur (remove-matches leftover)))))))","problem":"177","user":"5133e51ae4b0d7a043de8cf6"},{"code":"#(let [m {\\) \\( \\] \\[ \\} \\{}\n       f (fn [q v]\n           (cond\n             ((set (vals m)) v)  (conj q v)\n             ((set (keys m)) v) (if (= (peek q) (m v)) (pop q) (conj q v))\n             :t q))]\n  (empty? (reduce f [] %)))","problem":"177","user":"4f58d92fe4b0a7574ea71858"},{"problem":"177","code":"(fn [x]\n\t(letfn [(f [s] \n\t\t\t\t\t\t(let [syms {\n\t\t\t\t\t\t            \\( {:t :open :c \\)}\n\t\t\t\t\t\t            \\) {:t :close :c \\(}\n\t\t\t\t\t\t            \\[ {:t :open :c \\]}\n\t\t\t\t\t\t            \\] {:t :close :c \\[}\n\t\t\t\t\t\t            \\{ {:t :open :c \\}}\n\t\t\t\t\t\t            \\} {:t :close :c \\{}\n\t\t\t\t\t\t            }\n\t\t\t\t\t\t      sym (syms (first s))]\n\t\t\t\t\t\t     (cond \n\t\t\t\t\t\t          \t(empty? s) true\n\t\t\t\t\t\t          \t(and (= (sym :t) :open)\t(empty? (rest s))) false\n\t\t\t\t\t\t          \t(= (sym :t) :open) (let [inner (f (rest s))\n\t\t\t\t\t\t                                    first-inner (first inner)\n\t\t\t\t\t\t                                    has-others (> (count (rest inner)) 0)] \n\t\t\t\t\t\t                                   (cond \n\t\t\t\t\t\t                                        \t(and (= first-inner (sym :c)) has-others) (if (= ((syms (first (rest inner))) :t) :open)\n\t\t\t\t\t\t                                                                                       (f (rest inner))\n\t\t\t\t\t\t                                                                                       (rest inner))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(and (= first-inner (sym :c)) (not has-others)) true\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:else s))\n\t\t\t\t\t\t\t\t\t\t\t\t:else s)))\n\t\t\t\t\t\t] \n\t     (= true (f (filter #(or (= % \\() (= % \\)) (= % \\[) (= % \\]) (= % \\{) (= % \\})) x)))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [s]\n  (let [o (clojure.string/replace s #\"([^(\\[{}\\])]|\\(\\)|\\{\\}|\\[\\])\" \"\")]\n    (if (< (count o) (count s))\n      (recur o)\n      (empty? o)\n    )  \n  )  \n)","problem":"177","user":"5176afd2e4b085adf681d889"},{"problem":"177","code":"(fn bp [string]\n   (loop [r (seq string)\n          s '()]\n     (let [c (first r)\n           p? (contains? #{\\{,\\(,\\[} c)\n          op (get {\\} \\{ \\) \\( \\] \\[} c)]\n      (println c r s)\n      (cond\n         (and (nil? c) (empty? s)) true\n        (nil? c) false\n         p? (recur (rest r) (cons c s))\n         (=\n          (first s) op) (recur (rest r) (rest s))\n         op false\n         :else (recur (rest r) s)\n         ))))","user":"5fedff0ee4b05ac5b16ea1d0"},{"problem":"177","code":"(fn [s]\n  (loop [s s pile []]\n    (if (empty? s)\n      (empty? pile)\n      (let [sym (first s) corresp {\\) \\( \\] \\[ \\} \\{}]\n        (do (println sym pile )\n        (case sym\n          (\\( \\[ \\{ ) (recur (rest s) (conj pile sym ))\n          (\\] \\) \\} ) (if (= (corresp sym) (last pile))\n                      (recur (rest s) (into [] (butlast pile)))\n                      false)\n            \n          (recur (rest s) pile)\n          )\n                 )\n        )\n      )\n    )\n  )","user":"5776558ee4b0979f89651633"},{"code":"(fn [inp]\n  (letfn [(f [stack input]\n            (let [s (first stack)\n                  i (first input)\n                  b (hash-map \\) \\( \\] \\[ \\} \\{)]\n              (cond\n               (some #(= i %) (vals b)) (recur (cons i stack) (rest input))\n               (and (not (empty? input))\n                    (= s (b i))) (recur (rest stack) (rest input))\n                    (not (or (empty? input)\n                             (contains? #{\\( \\) \\[ \\] \\{ \\}} i))) (recur stack (rest input))\n                             :else (and (empty? stack) (empty? input)))))]\n    (f [] inp)))","problem":"177","user":"5097b556e4b00ad8bab4e970"},{"problem":"177","code":"(fn [s]\n  (let [ps { \\) \\(, \n        \t \\] \\[, \n        \t \\} \\{ }\n        op (vals ps)\n        cl (keys ps)\n        pr (fn [o s]\n             (some #(= % o) s))]\n\t(loop [r s\n           a []]\n      (if (or (nil? a) \n              (empty? r))\n        (if (or (nil? a) \n                (not (empty? a)))\n          nil\n          a)\n        (let [f (first r)]\n          (cond\n           (pr f op) (recur (rest r) \n                                     (conj a f))\n           (pr f cl) (if (= (peek a) \n                                     (ps f)) \n                                (recur (rest r)\n                                       (pop a)) \n                                (recur (rest r)\n                                       nil))\n           :else (recur (rest r) \n                        a)))))))","user":"55995fa7e4b031d6649c9ba9"},{"problem":"177","code":"#(let [[r t]\n       (reduce\n        (fn [[r t] c]\n          (cond\n            (#{\\{ \\[ \\(} c)\n            [r (conj t c)]\n            (#{\\} \\] \\)} c)\n            (if (= ({\\} \\{ \\] \\[ \\) \\(} c) (peek t))\n              [r (pop t)]\n              [false t])\n            1 [r t]))\n        [true []]\n        %)]\n   (and r (nil? (seq t))))","user":"4f0664bd535dcb61093f6c0f"},{"code":"(fn [s]\n  (if-let [s (re-seq #\"[\\[\\]\\{\\}\\(\\)]\" s)]\n    (let [x (apply str s)\n          y (clojure.string/replace x #\"(\\[\\]|\\{\\}|\\(\\))\" \"\")]\n      (if (= x y) false (recur y)))\n    true))","problem":"177","user":"5300158ae4b0d8b024fd370f"},{"code":"(fn properly-nested? [coll]\n  (let [op (set \"({[\")\n        close (set \")}]\")\n        match (zipmap op close)]\n \t(loop [brackets [] remaining coll]\n      (if-let [x (first remaining)]\n        (cond\n          (op x)    (recur (conj brackets x) (rest remaining))\n          (close x) (if (= (match (peek brackets)) x)\n                      (recur (pop brackets) (rest remaining))\n                      false)\n          :else     (recur brackets (rest remaining)))\n        (empty? brackets)))))","problem":"177","user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":"177","code":"(fn balanced? [s]\n  (let [close->open {\\} \\{ \\) \\( \\] \\[}\n        open        (into #{} (vals close->open))\n        close       (into #{} (keys close->open))]\n    (empty?\n      (reduce\n        (fn [stack c]\n          (cond\n            (contains? open c)  (conj stack c)\n            (contains? close c) (if (= (get close->open c) (peek stack))\n                                  (pop stack)\n                                  (conj stack c))\n            :else               stack))\n        []\n        s))))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [s]\n  (let\n    [lft {\\( \\) \\{ \\} \\[ \\]}\n     rgt {\\) \\( \\} \\{ \\] \\[}\n     red  (reductions\n           (fn [l x]\n             (if-let [a (lft x)]\n               (conj l x)\n               (if-let [a (rgt x)]\n                 (if (= a (peek l))\n                   (pop l)\n                   false)\n                 l)))\n           []\n           s)]\n    (if (some false? red)\n      false\n      (empty? (last red)))))","problem":"177","user":"519136e9e4b0f8ef0be96c01"},{"problem":"177","code":"(fn f\n  ([s] (f s 0 []))\n  ([s p stack]\n      (if (= p (count s))\n          (= 0 (count stack))\n          (let [C (get s p)\n                L (last stack)]\n               (cond\n                 (or\n                   (= C \\()\n                   (= C \\{)\n                   (= C \\[)) (f s (inc p) (conj stack C))\n                 (or\n                   (and (= C \\)) (= L \\())\n                   (and (= C \\}) (= L \\{))\n                   (and (= C \\]) (= L \\[))) (f s (inc p) (pop stack))\n                 (#{ \\) \\] \\} } C) false\n                 :else (f s (inc p) stack))))))","user":"4fa30027e4b081705acca187"},{"problem":"177","code":"(fn [s]\n  (let [os [\\( \\[ \\{], cs [\\) \\] \\}], delimap (zipmap cs os)]\n    (loop [[x & xs :as stack] '(), [a & as :as s] s]\n      (cond \n        (empty? s) (empty? stack)\n        (some #(= (first s) %) os) (recur (cons a stack) as)\n        (some #(= (first s) %) cs) (if (= (delimap a) x) (recur xs as) false)\n        :else (recur stack as)))))","user":"5339c105e4b0e30313ee6cae"},{"problem":"177","code":"(fn __\n  [x]\n  (loop [x (filter #(contains? #{\\{ \\} \\[ \\] \\( \\)} %) (seq x))\n         stack []]\n    (println (str \"x: \" (apply str x) \" - stack: \" (apply str stack)))\n    (if (empty? x)\n      (empty? stack)\n      (cond\n\n       (contains? #{\\{ \\[ \\(} (first x))\n       (recur (rest x) (concat stack [(first x)])) \n\n       (= \\} (first x)) \n       (if (= \\{ (last stack))\n         (recur (rest x) (butlast stack))\n         (println \"Tripped on }\"))\n\n       (= \\] (first x)) \n       (if (= \\[ (last stack))\n         (recur (rest x) (butlast stack))\n         (println \"Tripped on ]\"))\n\n       (= \\) (first x)) \n       (if (= \\( (last stack))\n         (recur (rest x) (butlast stack))\n         (println (str \"Tripped on ). Stack: \" stack)))\n\n       ))))","user":"53ac4719e4b047364c04445c"},{"code":"#(loop [[x & xs] % [a & as :as acc] '()]\n   (cond\n      (nil? x)\n         (empty? acc)\n      (contains? #{\\( \\{ \\[} x)\n         (recur xs (conj acc x))\n      (contains? #{\\) \\} \\]} x)\n         (if (= a ({\\) \\( \\} \\{ \\] \\[} x))\n            (recur xs as)\n            false)\n      :else (recur xs acc)))","problem":"177","user":"51bd1a0de4b0df1216cefd93"},{"problem":"177","code":"(fn [s]\n  (loop [s (seq s)\n         p '()]\n    (cond\n      (not (seq s)) (empty? p)\n\n      (#{\\{\\[\\(} (first s)) (recur (rest s) (cons (first s) p))\n\n      (#{\\}\\]\\)} (first s))\n      (let [[c & rs] s]\n        (case c\n          \\} (if (= \\{ (first p)) (recur rs (rest p)) nil)\n          \\] (if (= \\[ (first p)) (recur rs (rest p)) nil)\n          \\) (if (= \\( (first p)) (recur rs (rest p)) nil)))\n\n      :else (recur (rest s) p))))","user":"57f80350e4b0d3187e90090c"},{"problem":"177","code":"(fn self [s]\n    (let [left-to-right {\\( \\), \\[ \\], \\{ \\}}\n          brackets (set (flatten (seq left-to-right)))\n          s (filter brackets s)\n          b (fn [acc v]\n              (if (= (left-to-right (first acc)) v)\n                (rest acc)\n                (cons v acc)))\n          r (reduce b '() s)]\n      (empty? r)\n      ))","user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn [s] (let [brackets {\\( \\) \\[ \\] \\{ \\}}]\n          (loop [t s x []]\n            (if (empty? t)\n              (empty? x)\n              (let\n                [chr   (first t)\n                 rst   (rest t)\n                 close (brackets (peek x))\n                 open  (brackets chr)]\n                (recur rst (cond\n                            (= chr close) (pop x)\n                            open (conj x chr)\n                            ((set (vals brackets)) chr) (conj x chr)\n                            :else x)))))))","problem":"177","user":"51307b84e4b08c712d3fae39"},{"problem":"177","code":"(fn solution [snippet]\n  (let [brackets {\\[ :open \\] :close \\( :open \\) :close \\{ :open \\} :close}\n        category {\\[ :square \\] :square \\( :round \\) :round \\{ :curly \\} :curly}]\n    (empty? (reduce #(if (brackets %2)\n                       (if (= :open (get brackets %2))\n                         (conj %1 %2)\n                         (if (= (category (last %1)) (category %2))\n                           (vec (drop-last %1))\n                           (conj %1 %2)))\n                       %1)\n                    [] snippet))))","user":"5e2ef900e4b05b4b015161fc"},{"problem":"177","code":"(fn balanced?\n  ([input] (balanced? input []))\n  ([[x & xs] stack]\n   (letfn [(inverse [b] (condp = b\n                          \\) \\( \n                          \\] \\[ \n                          \\} \\{ \n                          nil))]\n     (cond\n       (nil? x) (empty? stack)\n       (#{\\( \\[ \\{} x) (recur xs (conj stack x)) \n\n       (#{\\) \\] \\}} x)\n       (if (= (inverse x) (peek stack))\n         (recur xs (pop stack))\n         false)\n\n       :else (recur xs stack)))))","user":"55fbc657e4b0f488688e0666"},{"problem":"177","code":"(fn lint\n  ([coll] (lint coll '()))\n  ([[head & tail] stack]\n   (if head\n     (let [opening {\\{ \\}, \\[ \\], \\( \\)}\n           closing (set (vals opening))]\n       (if (closing head)\n         (if (= head (first stack))\n           (recur tail (pop stack))\n           false)\n         (if-let [closer (opening head)]\n           (recur tail (conj stack closer))\n           (recur tail stack))))\n     (empty? stack))))","user":"5764457ae4b0994c1922fbf3"},{"problem":"177","code":"(fn [s]\n   (let [m {\\) \\( \\] \\[ \\} \\{}\n         left (set (vals m))\n         right (set (keys m))]\n     (loop [[h & r] (seq s) stack []]\n       (if h\n         (cond\n           (contains? left h) (recur r (conj stack h))\n           (contains? right h) (if (empty? stack)\n                             false\n                             (recur r (if (= (m h h) (peek stack)) (pop stack) stack)))\n           :else (recur r stack))\n         (empty? stack)))))","user":"545ddac3e4b01be26fd74676"},{"code":"#(let [parens (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" %)\n       pairs {\")\" \"(\" \"]\" \"[\" \"}\" \"{\"}]\n   (empty? (reduce (fn [stack x] (if (= (peek stack) (pairs x :dummy)) \n                                   (pop stack) \n                                   (conj stack x)))\n                   [] parens)))","problem":"177","user":"51efd397e4b0249c592fbdeb"},{"problem":"177","code":"(fn [s]\n  (let [opening-brackets {\\{ \\} \\[ \\] \\( \\)}\n        closing-brackets {\\} \\{ \\] \\[ \\) \\(}]\n    (letfn [(match? [cb ob] (= cb (get opening-brackets ob)))]\n      (empty? (reduce (fn [brackets c]\n                          (cond (opening-brackets c) (conj brackets c)\n                                (closing-brackets c) (if (match? c (peek brackets))\n                                                       (pop brackets)\n                                                       (vector :unexpected-bracket))\n                                :else brackets))\n                      [] s)))))","user":"57002b81e4b08d47c97781c7"},{"problem":"177","code":"(fn balanced? [s]\n  (letfn [(in-char-class? [cls c]\n      (>= (.indexOf cls (str c)) 0))\n    (left-bracket? [c]\n      (in-char-class? \"({[\" c))\n    (right-bracket? [c]\n      (in-char-class? \")}]\" c))\n    (balanced-brackets? [stack char-seq]\n      (let [h (first char-seq) tail (rest char-seq)\n            bracket-map { \\} \\{, \\) \\(, \\] \\[}]\n        (if (nil? h)\n          (empty? stack)\n          (cond (left-bracket? h)\n                  (balanced-brackets? (conj stack h) tail)\n                (right-bracket? h)\n                  (if (= (bracket-map h) (peek stack))\n                    (balanced-brackets? (pop stack) tail)\n                    false)\n                :else\n                    (balanced-brackets? stack tail)\n                ))))]\n    (balanced-brackets? '() (seq s))))","user":"4f577f25e4b0a7574ea71839"},{"code":"#(not\n   (reduce\n     (fn [[a & m :as p] c]\n       (if-let [r ({\\[ \\] \\{ \\} \\( \\)} c)]\n         (cons r p)\n         (cond\n           (= c a) m\n           (#{\\] \\} \\)} c) %\n           1 p)))\n     nil\n     %))","problem":"177","user":"4db858d1535d1e037afb218c"},{"code":"(fn [str]\n  (let [brackets {\\( \\) \\[ \\] \\{ \\}}\n        opening? (set (keys brackets))\n        closing? (set (vals brackets))]\n    (loop [[f & r :as s] str\n           open '()]\n      (cond\n        (empty? s) (empty? open)\n        (opening? f) (recur r (conj open f))\n        (closing? f) (if (= f (brackets (first open)))\n                       (recur r (rest open))\n                       false)\n        :else (recur r open)))))","problem":"177","user":"500aa15ee4b03d00572d2d76"},{"code":"(fn f ([src] (f src []))\n  ([src brackets]\n   (cond\n    (empty? src) (empty? brackets)\n    (contains? #{\\{ \\( \\[} (first src)) (recur (rest src) (conj brackets (first src)))\n    (not (contains? #{\\} \\) \\]} (first src))) (recur (rest src) brackets)\n    (and (= \\} (first src)) (not= \\{ (last brackets))) false\n    (and (= \\) (first src)) (not= \\( (last brackets))) false\n    (and (= \\] (first src)) (not= \\[ (last brackets))) false\n    :else (recur (rest src) (vec (drop-last brackets))))))","problem":"177","user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [s]\n    (let [open #{\\{ \\[ \\(}\n          close #{\\} \\] \\)}\n          corresponding (zipmap close open)\n          s (filter #(or (open %)\n                         (close %))\n                    s)\n          check-string (fn [s stack]\n                         (if-let [f (first s)]\n                           (cond (open f)\n                                 (recur (rest s) (conj stack f))\n\n                                 (close f)\n                                 (if (= (corresponding f) (peek stack))\n                                   (recur (rest s) (rest stack))\n                                   false))\n                           (empty? stack)))\n          ]\n      (check-string s '())))","problem":"177","user":"4daea889edd6309eace4d15b"},{"code":"(fn balansing-brackets [s]\n\t(let [left-brakets (set \"([{\")\n\t      right-brakets (set \")]}\")\n\t      br-map (zipmap left-brakets right-brakets)]\n\t  (loop [s (seq s) acc []]\n\t\t(if (empty? s)\n\t\t    (empty? acc)\n\t\t  (let [[head & tail] s]\n\t\t    (if (contains? left-brakets head)\n\t\t\t(recur tail (conj acc head))\n\t\t      (if (contains? right-brakets head)\n\t\t\t  (if (= (br-map (peek acc)) head)\n\t\t\t      (recur tail (pop acc))\n\t\t\t    false)\n\t\t\t(recur tail acc))))))))","problem":"177","user":"52381b2ae4b0fae3832e99ef"},{"problem":"177","code":"(fn bb\n  [x]\n  (if (empty? x)\n    true\n    (let [y (-> x\n                (clojure.string/replace #\"[^\\(\\)\\[\\]\\{\\}]\" \"\")\n                (clojure.string/replace #\"\\(\\)\" \"\")\n                (clojure.string/replace #\"\\[\\]\" \"\")\n                (clojure.string/replace #\"\\{\\}\" \"\"))]\n      (if (= x y)\n        false\n        (bb y)))))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":"177","code":"(fn [s]\n  (empty?\n    (reduce\n      (fn [[h & t :as acc] x]\n        (let [m {\\( \\), \\{ \\}, \\[ \\]}]\n          (cond\n            (= (m h) x) t\n            (m x) (cons x acc)\n            (#{\\{ \\} \\[ \\] \\( \\)} x) (cons \\X acc)\n            :else acc)))\n      []\n      s)))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":"177","code":"(fn [s]\n        (let [m {\\( \\) \\{ \\} \\[ \\]}]\n          (= 0 (loop [[c & cs] s, i 0, awaiting []]\n                 (if (nil? c) i\n                     (cond\n                      (= c (last awaiting)) (recur cs (- i 1) (pop awaiting))\n                      (m c) (recur cs (+ i 1) (conj awaiting (m c)))\n                      (some #(= c %) [\\) \\} \\]]) nil\n                      :else (recur cs i awaiting)))))))","user":"502873a8e4b01614d1633ff8"},{"problem":"177","code":"(fn [s]\n  (let [brackets {\"[\" \"]\", \"{\" \"}\", \"(\" \")\"}\n        p (re-pattern (str \"[\"\n                           (->> (seq brackets)\n                                (apply concat)\n                                (interpose \"\\\\\")\n                                (apply str))\n                           \"]\"))]\n    (loop [b '(), q (re-seq p s)]\n      (cond\n        (empty? q) (empty? b)\n        (brackets (first q)) (recur (conj b (first q)) (next q))\n        :else (if (= (first q) (brackets (first b)))\n                               (recur (next b) (next q))\n                               false)))))","user":"58247423e4b051871117bec5"},{"code":"#(loop [s %\n        t ()]\n  (if (empty? s)\n    (empty? t)\n    (let [[h & i] s\n          [j & k] t]\n      (case h\n        (\\( \\[ \\{) (recur i (conj t h))\n        (\\) \\] \\}) (if (#{[\\( \\)] [\\[ \\]] [\\{ \\}]} [j h])\n                      (recur i k)\n                      false)\n        (recur i t)))))","problem":"177","user":"4e96557d535dbda64a6f6b43"},{"problem":"177","code":"(fn balanced-brackets?\n  [s]\n  (empty? (let [\n                brackets-map {\\} \\{, \\] \\[, \\) \\(}\n                brackets-list #{\\} \\{ \\] \\[ \\) \\(}\n                ]\n            (reduce\n              #(if (contains? brackets-list %2) (if (= (first %1) (get brackets-map %2 \"!\")) (rest %) (conj % %2)) %)\n              ()\n              (seq s))\n            ))\n\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":"177","code":"#(->> %\n      (filter #{\\[ \\] \\( \\) \\{ \\}})\n      (reduce (fn [stack item]\n                (cond\n                 (#{ \\( \\{ \\[ } item) (conj stack item)\n                 (and (#{ \\( \\{ \\[ } (last stack))\n                                   (= ({ \\) \\(, \\} \\{, \\] \\[ } item) (last stack)))\n                                                             (pop stack)\n                 :else (conj stack item)))\n        [])\n        empty?)","user":"5eb193fde4b00a66d4a951fe"},{"problem":"177","code":"(fn balancing-brackets [coll]\n  (loop [coll  coll\n         stack []]\n    (if-let [[head & tail] coll]\n      (case head\n        \\( (recur tail (conj stack \\)))\n        \\{ (recur tail (conj stack \\}))\n        \\[ (recur tail (conj stack \\]))\n        (\\) \\} \\]) (if (= head (peek stack))\n                     (recur tail (pop stack)))\n        (recur tail stack))\n      (empty? stack))))","user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(fn [s]\n  (loop [stack '() rem s]\n    (if (empty? rem)\n      (empty? stack)\n      (let [b1 (first stack) b2 (str (first rem))]\n        (if (contains? #{\"{\" \"[\" \"(\"} b2)\n          (recur (conj stack b2) (rest rem))\n          (if (contains? #{\"}\" \"]\" \")\"} b2)\n            (if (or\n                 (and (= b1 \"(\") (= b2 \")\"))\n                 (and (= b1 \"{\") (= b2 \"}\"))\n                 (and (= b1 \"[\") (= b2 \"]\")))\n              (recur (rest stack) (rest rem))\n              false)\n            (recur stack (rest rem))))))))","problem":"177","user":"50bce014e4b0594b91591c63"},{"code":"(fn [x]\n  (loop [lst (seq x) stk '()]\n    (cond\n       (empty? lst)\n            (empty? stk)\n       (contains? #{ \\( \\[ \\{ } (first lst))\n           (recur (rest lst) (conj stk (first lst)))\n       (contains? #{ \\) \\] \\} } (first lst))\n           (if (empty? stk)\n             false\n             (let [l (first stk) r (first lst)]\n               (if (or (and (= l \\( ) (= r \\) ) )\n                         (and (= l \\[ ) (= r \\] ) )\n                         (and (= l \\{ ) (= r \\} ) ))\n                   (recur (rest lst) (rest stk))\n                   false)))\n       :else\n            (recur (rest lst) stk))))","problem":"177","user":"4f474f43e4b0d56e7bb92bb7"},{"problem":"177","code":"(fn f\n  ([t] (f t [] {\\) \\( \\] \\[ \\} \\{}))\n  ([[t & r] s m]\n   (if t\n     (cond\n       (some #{t} (vals m)) (f r (conj s t) m)\n       (some #{t} (keys m)) (if (= (m t) (peek s))\n                              (f r (pop s) m)\n                              false)\n       :else (f r s m))\n     (empty? s))))","user":"5d81b40ce4b0915913b1d379"},{"problem":"177","code":"(fn balanced? [s] (let [brackets (#(re-seq #\"[\\(\\)\\[\\]{}]\" %) s)\n                            open-set #{\"{\" \"[\" \"(\"}\n                            lookup {\"}\" \"{\",\")\" \"(\", \"]\" \"[\"}\n                            ]\n\t\t\t(loop [[a & args] brackets\n                               stack '()]\n                        (if (nil? a)\n                          (empty? stack)\n                          (if (open-set a)\n                            (recur args (conj stack a))\n                            (if\t(= (peek stack) (lookup a)) ;else, must be a closed bracket\n                              (recur args (pop stack))\n                              false))))))","user":"55c10409e4b01b9910ae2a2c"},{"code":"(fn f [x]\n  (let [o { \\( \\) \\[ \\] \\{ \\} }\n        c #{ \\) \\] \\} }]\n    (loop [s [] [t & r] x]\n      (cond (nil? t) (empty? s)\n            (o t) (recur (conj s (o t)) r)\n            (c t) (when (= (peek s) t)\n                    (recur (pop s) r))\n            :else (recur s r)))))","problem":"177","user":"50d0d4c8e4b00b15ecee976a"},{"problem":"177","code":"(letfn [(paren-matches [char-list state] (cond\n                                       (nil? state) false\n                                       (empty? char-list) (empty? state)\n                                       (#{\\( \\[ \\{} (first char-list))\n                                       (recur (rest char-list) (conj state (first char-list)))\n                                       (#{\\) \\] \\}} (first char-list))\n                                       (if (= ({\\( \\) \\[ \\] \\{ \\}} (peek state)) (first char-list))\n                                         (recur (rest char-list) (pop state)) false)\n                                       true (recur (rest char-list) state)))]\n  (fn [s] (paren-matches (char-array s) [])))","user":"584dadebe4b0b7285a6f4e44"},{"problem":"177","code":"(fn balancedParens? [string]\n  (empty?\n    (reduce\n      (fn [stck s]\n        (if (#{\\) \\} \\]} s)\n          (if (= s (peek stck))\n            (pop stck)\n            (conj stck [-1]))\n          (condp = s\n            \\( (conj stck \\))\n            \\[ (conj stck \\])\n            \\{ (conj stck \\})\n            stck)))\n      '()\n      string)))","user":"53fe1b42e4b0de5c418485f1"},{"problem":"177","code":"#(nil?\n  (reduce (fn [[h & u :as s] x]\n            (if-let [y ({\\{ \\} \\( \\) \\[ \\]} x)]\n              (cons y s)\n              (if (= h x) u '(1))))\n          nil\n          (keep (set \"[](){}\") %)))","user":"58b26da4e4b0ebc645576d0a"},{"problem":"177","code":"(fn [code]\n  (loop [bs (filter #{\\( \\{ \\[ \\] \\} \\)} code)\n         stack ()]\n    (let [b (first bs)]\n      (cond\n        (and (nil? b) (empty? stack)) true\n        (#{\\( \\{ \\[} b) (recur (rest bs)\n                               (conj stack ({\\( \\) \\{ \\} \\[ \\]} b)))\n        (= (first stack) b) (recur (rest bs)\n                                   (rest stack))\n        :else false))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":"177","code":"(fn [b s]\n  ((fn [[h & t :as s]]\n    (or (nil? s)\n        (empty? (reduce \n                  (fn [i e] (if (and (b e) (= (peek i) (b e)))\n                                (pop i)\n                                (conj i e)))\n                  [h] t))))\n   (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s)))\n{\"]\" \"[\", \"}\" \"{\", \")\" \"(\"}","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn [cs]\n  (let [se {\\( \\) \\[ \\] \\{ \\}}\n        m? #(= (se %) %2)]\n    (loop [s [] cs (filter #{\\( \\[ \\{ \\} \\] \\)} cs)]\n      (if-let [c (first cs)]\n        (if (m? (peek s) c)\n            (recur (pop s) (rest cs))\n            (if (se c)\n                (recur (conj s c) (rest cs))\n                (recur (conj s s) ())))\n        (empty? s)))))","problem":"177","user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn [s]\n  (let [brackets {\\( \\) \\[ \\] \\{ \\}}]\n    (loop [[x & xs] (filter (set (flatten (seq brackets))) s)\n           stack '()]\n      (cond\n        (nil? x) (empty? stack)\n        (and (some #{x} (vals brackets))\n          (= x (brackets (first stack)))) (recur xs (rest stack))\n        (brackets x) (recur xs (cons x stack))))))","problem":"177","user":"4f0f36a7535d0136e6c22336"},{"problem":"177","code":"(fn [string]\n   (letfn [(have-brackets? [string] (if (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" string) true false))\n           (patten-cleaning [string search-patten clean_patten]\n             (let [brankets-strings (re-seq search-patten string)\n                   brankets-strings-result (map #(clojure.string/replace % clean_patten \"\") brankets-strings) ]\n               (if (seq brankets-strings)\n                   (reduce #(clojure.string/replace %1 (key %2) (val %2)) string (apply assoc {} (interleave brankets-strings brankets-strings-result)))\n                   string\n               )\n             ))\n           (brankets-clean [string]\n             (let [patten-map { #\"\\([^\\[\\]\\{\\}\\(\\)]*\\)\"  #\"[\\(\\)]\" #\"\\[[^\\[\\]\\{\\}\\(\\)]*\\]\"  #\"[\\[\\]]\" #\"\\{[^\\[\\]\\{\\}\\(\\)]*\\}\"  #\"[\\{\\}]\" }]\n             (reduce #(patten-cleaning %1 (key %2) (val %2)) string  patten-map)\n               )\n             )]\n     (if (have-brackets? string)\n       (let [cleaned (brankets-clean string)]\n           (if (= cleaned string)\n             false\n             (recur cleaned)) )\n       true)\n     ))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn balancingbrackets [x]\n  (let [y (filter #{\\[\\(\\{\\]\\)\\}} (seq x))\n        open #{\\[\\(\\{}\n        close #{\\]\\)\\}}\n        brachash {\\[ \\] \\( \\) \\{ \\}}\n        f (fn [s x]\n            (cond (open x) (cons x s)\n                  (empty? s) \"X\"\n                  (= (brachash (first s)) x) (rest s)\n                  :else \"X\"))\n        ]\n    (empty? (reduce f '() y))))","problem":"177","user":"4e14108c535d04ed9115e7dd"},{"problem":"177","code":"(fn bal?\n    ([s]\n     (bal? s []))\n    ([s stack]\n     (if (empty? s)\n       (empty? stack)\n       (let [matches? (fn [open close]\n                       (case open\n                         \\( (= close \\))\n                         \\[ (= close \\])\n                         \\{ (= close \\})))\n             closes? (fn [close stack] (and (peek stack) (matches? (peek stack) close)))]\n         (condp #(%1 %2) (first s)\n           #{\\( \\[ \\{} :>> #(bal? (subs s 1) (conj stack %))\n           #{\\) \\] \\}} :>> #(if (closes? % stack)\n                              (bal? (subs s 1) (pop stack))\n                              false)\n           (bal? (subs s 1) stack))))))","user":"4e837808535db62dc21a62d9"},{"problem":"177","code":"(fn [s]\n    (let [pairs {\\] \\[ \\} \\{ \\) \\(}\n          stack (loop [brackets nil\n                       s s]\n                  (if-let [f (first s)]\n                    (case f\n                      (\\[ \\( \\{)\n                      (recur (cons f brackets) (rest s))\n\n                      (\\] \\) \\})\n                      (if (= (pairs f) (first brackets))\n                        (recur (rest brackets) (rest s))\n                        '(nope))\n\n                      (recur brackets (rest s)))\n                    brackets))]\n      (empty? stack)))","user":"4ea03f70535d7eef308072a1"},{"problem":"177","code":"(fn [s]\n  (letfn [(o? [c] (> (.indexOf [\\( \\[ \\{] c) -1))\n          (c? [c] (> (.indexOf [\\) \\] \\}] c) -1))\n          (matches? [o c]\n            (= (.indexOf [\\( \\[ \\{] o)\n               (.indexOf [\\) \\] \\}] c)))]\n    (empty?\n      (reduce (fn [a b]\n                (cond\n                  (= (last a) \\*) a\n                  (o? b) (conj a b)\n                  (c? b) (let [o (last a)]\n                           (if (matches? o b)\n                             (pop a)\n                             (conj a \\*)))\n                  :default a))\n              []\n              (seq s)))))","user":"58bb218be4b0888cdc949cf4"},{"problem":"177","code":"(fn bracks ([astring] (bracks astring []))\n([astring astack] (if (empty? astring) (empty? astack)\n(let [expectmap {\\] \\[ \\) \\( \\} \\{} ch (first astring)]\n(if (some #(= % ch) (vals expectmap)) (bracks (rest astring) (conj astack ch))\n(if (some #(= % ch) (keys expectmap)) (if (not= (peek astack) (expectmap ch)) false\n(bracks (rest astring) (vec (drop-last astack))))\n(bracks (rest astring) astack)))))))","user":"55f75c6be4b06e875b46cea9"},{"problem":"177","code":"(let [opener->closer {\\{ \\}\n                        \\( \\)\n                        \\[ \\]}\n        openers (set (keys opener->closer))\n        closers (set (vals opener->closer))\n        brackets (set (concat openers closers))\n        steve (fn [input-brackets]\n                (loop [stack '()\n                       [current & others] input-brackets]\n                  (cond\n                    (nil? current) (empty? stack)\n                    (openers current) (recur\n                                        (cons (opener->closer current) stack)\n                                        others)\n                    (= current (first stack)) (recur\n                                                (rest stack)\n                                                others)\n                    :else false)))]\n    (fn [s]\n      (->> s\n           (filter brackets)\n           steve)))","user":"5bab5440e4b0a20761a23475"},{"code":"(fn [s]\n  (let [q (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s)\n        open [\"[\" \"(\" \"{\"]\n        close [\"]\" \")\" \"}\"]\n        m (zipmap close open)]\n    (loop [tokens q stack []]\n      (cond (and (empty? tokens) (empty? stack)) true\n            (some #{(first tokens)} open) (recur (rest tokens) (conj stack (first tokens)))\n            (= (m (first tokens)) (last stack)) (recur (rest tokens) (vec (butlast stack)))\n            :else false))))","problem":"177","user":"4f2d5f5de4b0d6649770a05a"},{"problem":"177","code":"(fn balanced? [s]\n    (loop [last-l (inc (count s))\n           s (clojure.string/replace s #\"[^]\\[{}()]\" \"\")]\n      (let [l (count s)]\n        (if (< l last-l)\n          (recur l (clojure.string/replace s #\"\\(\\)|\\[\\]|\\{\\}\" \"\"))\n          (zero? l)))))","user":"59fa241ee4b0ca45a743a358"},{"problem":"177","code":"(fn [s]\n  (let [brackets [\\[ \\] \\{ \\} \\( \\)]\n        pairs (set (partition 2 brackets))\n        brackets-in-s (filter (fn [x] (some #{x} brackets)) (seq s))\n        n (count brackets-in-s)]\n      (when (even? n)\n        (not (reduce (fn\n                       ([] nil)\n                       ([x y] (let [vec-of-x (vec (if (or (seq? x) (nil? x)) x [x]))]\n                         (if (pairs [(peek vec-of-x) y])\n                           (butlast vec-of-x)\n                           (seq (conj vec-of-x y))\n                           ))))\n               brackets-in-s)\n          ))))","user":"53b530c6e4b047364c0444bc"},{"problem":"177","code":"(fn [s]\n  (let [m {\\( \\) \\[ \\] \\{ \\}}\n        a (set \"()[]{}\")]\n    (empty? (reduce (fn [[top & r :as acc] c]\n                      (cond\n                        (= (m top) c) r\n                        (a c) (conj acc c)\n                        :else acc))\n                    ()\n                    s))))","user":"5cf895efe4b0b71b1d808a85"},{"code":"#(let [s \"()[]{}\"\n       m (apply hash-map s)]\n   (->> %\n     (filter (set s))\n     (reduce\n      (fn [[y [p & ps]] c]\n        (if (m c)\n          [true (conj ps p c)]\n          [(and y (= c (m p))) ps]))\n      [true '(true)])\n     flatten\n     (every? true?)))","problem":"177","user":"50479524e4b0371827a27bc4"},{"code":"#(empty? \n  (reduce \n   (fn [x y]\n     (if(contains? #{\"()\" \"[]\" \"{}\"} (str (last x)  y))\n       (apply str (drop-last x))(str x y) )) \"\" (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" %)))","problem":"177","user":"52bbd09ee4b07a9af57922ee"},{"problem":"177","code":"(fn [arg]\n  (let [parens {\\( \\), \\[ \\], \\{ \\}}]\n    (loop [coll arg, stack ()]\n      (let [[ch & cr] coll, [sh & sr] stack]\n        (cond (empty? coll) (empty? stack)\n              (some #{ch} (keys parens)) (recur cr (conj stack ch))\n              (some #{ch} (vals parens)) (if (= ch (parens sh)) (recur cr sr) false)\n              :else (recur cr stack))))))","user":"567695c2e4b05957ce8c6157"},{"problem":"177","code":"(fn balanced? [s]\n  (let [is-bracket? (fn [c] (contains? #{\\( \\) \\[ \\] \\{ \\}} c))\n        brackets (filter is-bracket? s)\n        closing {\\( \\), \\[ \\], \\{ \\}}\n        opening? (fn [c] (contains? #{\\( \\[ \\{} c))\n        match? (fn [sq stack]\n                 (if (empty? sq)\n                   true\n                   (let [[b & bs] sq]\n                     (if (opening? b)\n                       (recur bs (cons b stack))\n                       (let [[s & ss] stack]\n                         (if (= (get closing s) b)\n                           (recur bs ss)\n                           false))))))]\n    (if (odd? (count brackets))\n      false\n      (match? brackets '()))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":"177","code":"(fn [x]\n  (let [filteredstring (apply str (filter (set \"{}[]()\") x))\n        removematchingpairs #(clojure.string/replace % #\"\\{\\}|\\[\\]|\\(\\)\" \"\")\n        matchingpairsremoved (removematchingpairs filteredstring )]\n    (cond\n      (empty? filteredstring) true\n     (= filteredstring matchingpairsremoved)    false\n      (empty? matchingpairsremoved) true\n      :else      (recur matchingpairsremoved))))","user":"57c790dbe4b05aa3c4741d07"},{"problem":"177","code":"#(let [not-double?\n  (fn [w] \n    (let [v (str (first w) (second w))]\n      (and (not= \"()\" v) (not= \"[]\" v) (not= \"{}\" v))\n    )\n  )]\n\n  (loop [coll (filter (fn[c] (or (= c \\() (= c \\)) (= c \\[) (= c \\]) (= c \\{) (= c \\}))) %)]\n    (if (empty? coll)\n      true\n      (let [c1 (flatten (filter not-double? (partition-all 2 coll)))\n            c2 (flatten (filter not-double? (partition-all 2 (rest c1))))\n            c (if (empty? c1) c2 (cons (first c1) c2))\n           ]\n        (if (= (count coll) (count c))\n          false\n          (recur c)          \n        )\n      )\n    )\n  )\n)","user":"545537c1e4b0e397800069dd"},{"problem":"177","code":"(fn\n  [string]\n  (let [\n        openings #{\\( \\[ \\{}\n        close-map {\\) \\(, \\] \\[, \\} \\{}\n        ]\n    (loop [\n         brackets '()\n         string (map identity string)\n         ]\n      (let [[letter & remaining] string]\n        (cond\n          (contains? openings letter) (recur (conj brackets letter) remaining)\n          (contains? close-map letter) (if (= (first brackets) (close-map letter))\n                                         (recur (rest brackets) remaining)\n                                         false\n                                         )\n          :else (if (empty? remaining)\n                  (empty? brackets)\n                  (recur brackets remaining)\n                  )\n          )\n        )\n      )\n    )\n  )","user":"563a30d7e4b0bfe05bf117f9"},{"problem":"177","code":"(fn [s]\n  (let [closing-pair {\"(\" \")\"\n                      \"{\" \"}\"\n                      \"[\" \"]\"}\n        para-seq (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s)]\n        (loop [stack []\n               r para-seq]\n        (if (empty? r)\n          (empty? stack)\n          (if-let [is-open (closing-pair (first r))]\n            (recur (conj stack (first r)) (rest r))\n            (if (= (first r) (closing-pair (peek stack))) \n              (recur (pop stack) (rest r))\n              false))))))","user":"50856bd1e4b004985b776e4c"},{"code":"(fn [x]\n  (let [mat {\\} {\\{ true}, \\) {\\( true}, \\] {\\[ true}}\n        bracket? #{\\( \\) \\{ \\} \\[ \\]}\n        rightbracket? #{\\{ \\[ \\(}]\n    (loop [rst x\n           stack '()]\n      (if (empty? rst) (empty? stack)\n        (if-not (bracket? (first rst))\n          (recur (rest rst) stack)\n          (if (rightbracket? (first rst))\n            (recur (rest rst) (conj stack (first rst)))\n            (if ((mat (first rst)) (first stack))\n              (recur (rest rst) (rest stack))\n              false)))))))","problem":"177","user":"52084f75e4b01ce6bbf31dde"},{"problem":"177","code":"(fn balanced-brackets [s]\n  (loop [temp nil\n         input s\n         ]\n    (let [d {\\( \\) \\[ \\] \\{ \\}}\n          c (first input)]\n      (cond\n        (empty? input) (empty? temp)\n\n        (some #(= c %) (keys d)) (recur (cons c temp) (rest input))\n        (some #(= c %) (vals d)) (if (= c (get d (first temp)))\n                                   (recur (rest temp) (rest input))\n                                   false\n                                   )\n        :else (recur temp (rest input))\n        )\n      )))","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn balanced? [s]\n  (let [brackets [\\( \\) \\{ \\} \\[ \\]]\n        open-brackets (apply hash-map brackets)\n        close-brackets (apply hash-map (reverse brackets))\n        bracket? (fn [c] (some #(= c %) brackets))\n        get-brackets (fn [s] (filter bracket? s))]\n    (loop [brackets (get-brackets s)\n           stack []]\n      (if (empty? brackets)\n        (empty? stack)\n        (let [n (first brackets)]\n          (if (open-brackets n)\n            (recur (rest brackets) (conj stack n))\n            (if (or (empty? stack) (not= (close-brackets n) (peek stack)))\n              false\n              (recur (rest brackets) (pop stack)))))))))","problem":"177","user":"53513d28e4b084c2834f4ae3"},{"problem":"177","code":"#(empty? (reduce (fn [[h & t :as stack] ch]\n                   (cond\n                    (= ({\\{ \\}, \\[ \\], \\( \\)} h) ch) t\n                    (#{\\{ \\} \\[ \\] \\( \\)} ch) (cons ch stack)\n                    :else stack))\n                 '() %))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":"177","code":"#(let [brackets { \\{ :o \\[ :o \\( :o \\} \\{ \\] \\[ \\) \\( }]\n  ((fn f [s ctx]\n    (if (empty? s)\n      (empty? ctx)\n      (let [e (first s) b (brackets e)]\n      (cond\n       (not b) (f (rest s) ctx)\n       (= b :o) (f (rest s) (cons e ctx))\n       :else (if (or (empty? ctx) (not (= b (first ctx))))\n         false\n         (f (rest s) (rest ctx)))))))\n  % '()))","user":"55a74d46e4b09e57187da2a3"},{"problem":"177","code":"(fn balancing-brackets [s]\n    (let [filtered-brackets\n            (apply str (filter #(or (= \\[ %) (= \\] %)\n                                    (= \\{ %) (= \\} %)\n                                    (= \\( %) (= \\) %)) s))]\n      (letfn [(remove-square-brackets [x]\n                (clojure.string/replace x #\"\\[\\]\" \"\"))\n              (remove-round-brackets [x]\n                (clojure.string/replace x #\"\\(\\)\" \"\"))\n              (remove-curly-brackets [x]\n                (clojure.string/replace x #\"\\{\\}\" \"\"))\n              (remove-bracket-pair [x]\n                (remove-curly-brackets (remove-round-brackets (remove-square-brackets x))))]\n      (int (/ (count filtered-brackets) 2))\n        (loop [counter (int (/ (count filtered-brackets) 2))\n               bracket-string filtered-brackets]\n          (if (= counter 0)\n            (if (= \"\" bracket-string)\n              true\n              false)\n            (recur (dec counter) (remove-bracket-pair bracket-string)))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":"177","code":"(fn [y]\n((fn [x]\n(if (= \"\" x) true \n  (let [repl (clojure.string/replace x #\"\\(\\)|\\[\\]|\\{\\}\" \"\")] \n  (if (= (count repl) (count x)) false (recur repl)\n)))) (clojure.string/replace y #\"[^\\(\\)|\\[\\]|\\{\\}]\" \"\")))","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn [x]\n  (let [starts   #{\\[ \\( \\{}\n        ends     #{\\] \\) \\}}\n        lookups  (zipmap ends starts)\n        brackets (set (concat starts ends))\n        xs       (filter #(brackets %) x)]\n    (empty? (reduce (fn [v x]\n                      (if\n                          (and (ends x) (= (last v) (lookups x))) (pop v)\n                          (conj v x))) [] xs))))","problem":"177","user":"4fe8fda4e4b0547ebccb2438"},{"problem":"177","code":"(fn balanced [s]\n  (let [openers #{\\{ \\( \\[}\n        closers #{\\} \\) \\]}\n        opener {\\) \\(, \\] \\[, \\} \\{}]\n    (loop [delims '()\n           x (first s)\n           xs (rest s)]\n      (cond\n        (nil? x) (empty? delims)\n        (openers x) (recur (conj delims x)\n                           (first xs)\n                           (rest xs))\n        (closers x) (if (= (opener x) (first delims))\n                      (recur (pop delims)\n                             (first xs)\n                             (rest xs))\n                      false)\n        :else (recur delims (first xs) (rest xs))))))","user":"5283a919e4b0239c8a67adbe"},{"problem":"177","code":"(fn [x] (empty? (reduce (fn [res c] \n  (let [rem ({ \\} \\{ \\) \\( \\] \\[ } c) \n        res (if rem (if (= rem (first res)) (rest res) [:error]) res)\n        add (#{ \\{ \\( \\[ } c)]\n        (if add (conj res add) res))) '() x)))","user":"4feada56e4b0140c20fb9c11"},{"problem":"177","code":"(fn balanced? [s]\n  (loop [todo s, stack '()]\n    (if (empty? todo)\n      (empty? stack)\n      (let [[h & t] todo]\n        (cond\n          (#{\\( \\[ \\{} h) (recur t (conj stack h))\n          (#{\\) \\] \\}} h) (let [top (peek stack)]\n                            (if (#{#{\\( \\)} #{\\[ \\]} #{\\{ \\}}} (hash-set h top))\n                              (recur t (pop stack))\n                              false))\n          :else (recur t stack))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [in-seq]\n( loop [x in-seq  unmatched-closing false push-pop \"\"  ]\n     (if  (or unmatched-closing (= (count x ) 0)) \n       (if unmatched-closing false (if (= (count push-pop) 0) true false))\n       (recur \n           (next x)    ;; remove the first char\n\n           (if (contains? #{ \\]  \\}  \\) } (first x))               \n               (if (= (count push-pop) 0) true false))   ;; closing bracket with nothing to \"pop\" ?\n              \n           (if (contains? #{ \\[  \\{  \\( } (first x))\n                (cons (first x) push-pop)    ;;push\n                (if (= (first push-pop) (get { \\] \\[  \\} \\{  \\) \\( } (first x) nil)) \n                  (next push-pop)   ;;pop\n                  push-pop ))       ;;do nothing - we don't care about this character\n                        \n            ))\n    )\n  \n  )","problem":"177","user":"530d1060e4b08068f379eca2"},{"problem":"177","code":"(fn  [in]\n           (loop [[h & t] in acc '()]\n             (let [brackets {\\( \\)\n                             \\{ \\}\n                             \\[ \\]}\n                   reverse-brackets (->> brackets\n                                         (map (comp (partial into []) reverse))\n                                         (into {}))]\n               (if (nil? h)\n                 (empty? acc)\n                 (cond\n                  (contains? reverse-brackets h) (if (= (first acc) (reverse-brackets h))\n                                                     (recur t (rest acc))\n                                                     false)\n                  (contains? brackets h) (recur t (conj acc h))\n                  :default (recur t acc))))))","user":"527ccaf4e4b0757a1b17136d"},{"problem":"177","code":"(fn [input]\n  (let [pairs #{\"()\" \"[]\" \"{}\"}\n        opener? (apply hash-set (map first pairs))]\n    (loop [[token & tokens] (filter (apply hash-set (mapcat seq pairs)) input)\n           stack '()]\n      (cond\n       (nil? token) (empty? stack)\n       (opener? token) (recur tokens (conj stack token))\n       :else (if (pairs (str (peek stack) token))\n            (recur tokens (pop stack))\n            false)))))","user":"5368fedee4b0243289761e93"},{"code":"(fn pushdown [stack x]\n    (let [x1 (first x)\n          xn (next x)]\n        (cond\n            (empty? x) (empty? stack)\n            (#{\\( \\[ \\{} x1) (recur (conj stack x1) xn)\n            (#{[\\( \\)] [\\[ \\]] [\\{ \\}]} [(peek stack) x1]) (recur (pop stack) xn)\n            (#{\\) \\] \\}} x1) false\n            true (recur stack xn))))\n[]","problem":"177","user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn [s]\n  (let [open #{\\(, \\{, \\[}\n        close #{\\), \\}, \\]}\n        all (clojure.set/union open close)\n        bm (zipmap open close)\n        brackets (filter all s)]\n    (empty?\n      (reduce\n       #(cond\n         (open %2) (conj % %2)\n         :else\n           (if (or (empty? %) (not= (bm (peek %)) %2))\n             (conj % %2)\n             (pop %)))\n       ()\n       brackets))))","problem":"177","user":"51e38568e4b0c611d6113e43"},{"code":"#(let [c (apply str (filter (set \"(){}[]\") %))\n           s (clojure.string/replace c #\"(\\(\\)|\\[\\]|\\{\\})\" \"\")]\n      (cond (= s \"\") true\n            (= c s) false\n            :else (recur s)))","problem":"177","user":"4dae916eedd6309eace4d155"},{"code":"(fn balance-brackets [s]                                                                                          \n  (let [sbrackets #{\\[ \\( \\{}                                                                                       \n        e2s {\\] \\[ \\) \\( \\} \\{}]                                                                                    \n    (loop [remaining (seq s)                                                                                        \n           stack []]                                                                                                \n      (if (empty? remaining)                                                                                        \n        (empty? stack)                                                                                              \n        (let [check (first remaining)                                                                               \n              new-remaining (rest remaining)]                                                                       \n          (cond                                                                                                     \n            (sbrackets check) (recur new-remaining (conj stack check))                                              \n            (e2s check) (if (= (peek stack) (e2s check))                                                            \n                                (recur new-remaining (pop stack))                                                   \n                                false)                                                                              \n            :else (recur new-remaining stack)))))))","problem":"177","user":"51899891e4b0288ada3dbdab"},{"code":"(fn [a [s1 & sn :as s]]\n  (let [l #{ \\( \\[  \\{ }\n        r { \\) \\( \\] \\[ \\} \\{ }]\n    (if (empty? s)\n      (empty? a)\n      (if (l s1)\n        (recur (conj a (l s1)) sn)\n        (if (r s1)\n          (and (= (peek a) (r s1)) (recur (pop a) sn))\n          (recur a sn)))))) []","problem":"177","user":"5054bc87e4b0b1b9d1860eb0"},{"problem":"177","code":"(fn [s]\n  (let [br-seq (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s)]\n    (->> (reduce (fn [[f & r :as unbal] next-br]\n                   (if (or (and (= f \"(\")\n                                (= next-br \")\"))\n                           (and (= f \"[\")\n                                (= next-br \"]\"))\n                           (and (= f \"{\")\n                                (= next-br \"}\")))\n                     r\n                     (conj unbal next-br)))\n                 ()\n                 br-seq)\n         empty?)))","user":"54848141e4b0e286459a119e"},{"problem":"177","code":"(fn [s]\n  (let [tokens (vec (clojure.string/replace s #\"[^\\{\\}\\(\\)\\[\\]]\" \"\"))\n        brackets { \\{ \\} \\( \\) \\[ \\] }\n        st? (fn [x] (brackets x))\n        match? (fn [a b] (= b (brackets a)))\n        ]\n    (loop [stack '() \n           [curr & more] tokens\n           ]\n      (if (nil? curr)\n        (empty? stack)\n        (recur \n         (if (or (st? curr) (not (match? (first stack) curr)))\n           (conj stack curr)\n           (rest stack)\n           )\n         more)))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":"177","code":"(fn [s]\n   (empty?\n     (reduce\n       (fn [stack c]\n         (cond\n           (#{\\{ \\[ \\(} c) (conj stack c)\n           (#{\\} \\] \\)} c) (if (= c ({\\{ \\} \\[ \\] \\( \\)} (peek stack)))\n                             (pop stack)\n                             (conj stack :invalid))\n           :otherwise stack))\n       '()\n       s)))","user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn [s]\n  (let [s (re-seq #\"[()\\[\\]{}]\" s)\n        c {\"{\" \"}\" \"(\" \")\" \"[\" \"]\"}\n        f #(if (and (not (contains? c %2))\n                    (not (empty? %1))\n                    (= (last %1) %2))\n             (pop %1)\n             (conj %1 (or (c %2) \"p\")))]\n   (empty? (reduce f [] s))))","problem":"177","user":"504e04a4e4b078edc5f59397"},{"problem":"177","code":"(fn [s]\n\t\t(let [xs (re-seq #\"[\\]\\[\\)\\(\\}\\{]\" s)]\n\t\t\t(loop [xs xs stack '()]\n\t\t\t\t(cond\n\t\t\t\t\t(empty? xs) (empty? stack)\n\t\t\t\t\t(contains? #{\"(\" \"{\" \"[\"} (first xs)) (recur (rest xs) (cons (first xs) stack))\n\t\t\t\t\t(and (= \")\" (first xs)) (= \"(\" (first stack))) (recur (rest xs) (rest stack))\n\t\t\t\t\t(and (= \"]\" (first xs)) (= \"[\" (first stack))) (recur (rest xs) (rest stack))\n\t\t\t\t\t(and (= \"}\" (first xs)) (= \"{\" (first stack))) (recur (rest xs) (rest stack))\n\t\t\t\t\t:else false\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)","user":"5409f8eae4b0addc1aec66e6"},{"problem":"177","code":"(fn remove-parens [s]\n  (let [r clojure.string/replace\n        new-s (-> s\n                   (r #\"\\([^\\{\\}\\(\\)\\[\\]]*\\)\" \"\")\n                   (r #\"\\[[^\\{\\}\\(\\)\\[\\]]*\\]\" \"\")\n                   (r #\"\\{[^\\{\\}\\(\\)\\[\\]]*\\}\" \"\"))]\n    (if (= new-s s) (empty? (clojure.set/intersection (set \"{}[]()\") (set  s))) (recur new-s))))","user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn [s]\n  (let [pairs {\\) \\( \\] \\[ \\} \\{}]\n  (= '() (reduce #(cond\n                 \t(nil? %1) nil\n                 \t((set (vals pairs)) %2) (cons %2 %1)\n                 \t(pairs %2) (if (= (pairs %2) (first %1)) (rest %1) nil)\n                    :else %1) '() s))))","problem":"177","user":"4ebc08a8535dfed6da9c6d7c"},{"problem":"177","code":"(fn [string]\n  (let [op->cl { \\[ \\], \\{ \\}, \\( \\) }\n        cl->op (clojure.set/map-invert op->cl)]\n    (= []\n       (reduce\n         (fn [stack c]\n           (cond\n             (not stack) false \n             (op->cl c) (conj stack c)\n             (cl->op c) (if (= (peek stack) (cl->op c)) (pop stack))\n             :else stack))\n         []\n         string))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":"177","code":"(fn balancing-brackets\n  [s]\n  (let [coll (seq (apply str (re-seq #\"\\(|\\{|\\[|\\]|\\}|\\)\" s)))]\n    (empty? (reduce (fn [stack s]\n                      (let [fv (peek stack)]\n                        (cond\n                          (nil? fv) (conj stack s)\n                          (and (= fv \\{) (= s \\})) (pop stack)\n                          (and (= fv \\[) (= s \\])) (pop stack)\n                          (and (= fv \\() (= s \\))) (pop stack)\n                          :else\n                          (conj stack s))))\n                    []\n                    coll))))","user":"565654dae4b0f9d632dd849f"},{"code":"(fn [s] (let [p { \"}\" \"{\" \")\" \"(\" \"]\" \"[\" } bare (clojure.string/replace s #\"[^\\(\\)\\[\\]\\{\\}]\" \"\")]\n                  (= 1 (count (reduce #(if (and (not (nil? (get p %2))) (= (get p (str %2)) (str (last %1)))) (pop %1) (conj %1 %2)) [] (clojure.string/split bare #\"\"))))\n                  ))","problem":"177","user":"52c1bd29e4b07a9af579236a"},{"problem":"177","code":"(fn balancing-brackets\n  ([[hs & ts] bs]\n   (let [bc {\\} \\{\n             \\] \\[\n             \\) \\(}\n         bo (set (vals bc))]\n     (if hs\n       (cond\n         (contains? bo hs) (balancing-brackets ts (conj bs hs))\n         (contains? bc hs) (if (= (first bs) (get bc hs))\n                             (balancing-brackets ts (rest bs))\n                             false) \n         :else (balancing-brackets ts bs))\n       (empty? bs))))\n  ([s]\n   (balancing-brackets s '())))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn [text]\n  (letfn [(cancel-brackets [coll]\n                           (reduce (fn [t1 t2]\n                                     (cond (empty? t1) [t2]\n                                           (or \n                                            (and (= (last t1) \\[) (= t2 \\]))\n                                            (and (= (last t1) \\() (= t2 \\)))\n                                            (and (= (last t1) \\{) (= t2 \\}))) (drop-last t1)\n                                            :else (concat t1 (vector t2))))\n                                   (vector (first coll)) (rest coll)))] \n         (let [brackets (filter #{\\[ \\] \\( \\) \\{ \\}} text)]\n           (if (or (empty? brackets) (empty? (cancel-brackets brackets))) true false))))","problem":"177","user":"51780f88e4b03d69594194c9"},{"problem":"177","code":"#(empty? (reduce\n          (fn [stack ch]\n            (let [pairs {\\) \\(\n            \\} \\{\n            \\] \\[\n            \\> \\<}]\n            (cond\n              (some #{ch} (vals pairs))\n              (conj stack ch)\n              (some #{ch} (keys pairs)) \n              (if (= (peek stack) (pairs ch))\n                (pop stack)\n                (conj stack \\0))\n              :else stack)))\n          []\n          %))","user":"5b3ef412e4b02d533a91bc06"},{"problem":"177","code":"(fn correct-brackets? [bracket-string] \n  (let [open-brackets #{\\( \\[ \\{}\n        close-brackets #{\\) \\] \\}}\n        matching-brackets (zipmap close-brackets open-brackets)]\n    (loop [bracket-xs (seq bracket-string)\n           bracket-stack []]\n    (cond\n      (contains? open-brackets (first bracket-xs)) \n        (recur (rest bracket-xs) (conj bracket-stack (first bracket-xs)))\n      (contains? close-brackets (first bracket-xs))\n        (if (= (peek bracket-stack) (matching-brackets (first bracket-xs)))\n          (recur (rest bracket-xs) (pop bracket-stack))\n          false)\n      (not (empty? bracket-xs)) (recur (rest bracket-xs) bracket-stack)\n      :else (empty? bracket-stack))\n    ))\n  )","user":"569951e4e4b0542e1f8d143e"},{"problem":"177","code":"(fn f [s] (let [r (clojure.string/replace s #\"[^()\\[\\]{}]|\\(\\)|\\[\\]|\\{\\}\" \"\")]\n           (if (= s r) (= \"\" s) (f r))))","user":"59419bdfe4b060784b3b78f7"},{"problem":"177","code":"(fn [string]\n  (loop [stack '()\n         ls (seq string)]\n    (if-let [x (first ls)]\n      (case x\n        \\( (recur (conj stack \\( ) (rest ls))\n        \\[ (recur (conj stack \\[ ) (rest ls))\n        \\{ (recur (conj stack \\{ ) (rest ls))\n        \\} (if (= \\{ (first stack))\n             (recur (rest stack) (rest ls))\n             false)\n        \\] (if (= \\[ (first stack))\n             (recur (rest stack) (rest ls))\n             false)\n        \\) (if (= \\( (first stack))\n             (recur (rest stack) (rest ls))\n             false)\n        (recur stack (rest ls)))\n      (empty? stack))))","user":"55f73078e4b06e875b46cea4"},{"problem":"177","code":"(fn balanced? [s]\n  (let [brackets (re-seq #\"[\\(\\)\\{\\}\\[\\]]\" s)\n        pairs {\"(\" \")\", \"[\" \"]\", \"{\" \"}\"}\n        push? (fn [x] (contains? pairs x))\n        pair? (fn [x y] (= (get pairs x) y))]\n    (loop [[x & xs] brackets, stack []]\n      (cond\n       (nil? x)               (empty? stack)\n       (push? x)              (recur xs (conj stack x))\n       (pair? (peek stack) x) (recur xs (pop stack))\n       :else                  false))))","user":"541b1f25e4b01498b1a71a63"},{"code":"#(= '()\n  (reduce (fn [a c]\n            (let [m {\\) \\( \\] \\[ \\} \\{}]\n            (cond\n             (= a :F) a\n             (#{\\[ \\( \\{} c) (cons c a)\n             (= (m c) (first a)) (rest a)\n             (m c) :F\n             :e a\n             ))) [] %))","problem":"177","user":"4fa340b4e4b081705acca18c"},{"problem":"177","code":"(fn [s]\n  (let [st [] m {\\{ \\} \\[ \\] \\( \\)} flag (atom true)]\n    (and  (empty? (reduce (fn [stack c] (cond\n                            (contains? #{ \\( \\{ \\[ } c) (conj stack (m c))\n                            (= c (peek stack)) (pop stack)\n                            (contains? #{ \\) \\} \\] } c) \n                                       (do (swap! flag #(last [% false])) stack)\n                            :else stack)) st s))  @flag) ))","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn [s]\n  (= '()\n     (reduce (fn [exp-stack ch]\n               (case ch\n                 \\[ (conj exp-stack \\])\n                 \\( (conj exp-stack \\))\n                 \\{ (conj exp-stack \\})\n                 (\\] \\) \\}) (if (= ch (first exp-stack))\n                              (rest exp-stack))\n                 exp-stack))\n             '()\n             (seq s))))","problem":"177","user":"500d8c49e4b07ccb9a7ddb00"},{"problem":"177","code":"(fn [s] (let [c (filter #{ \\( \\) \\[ \\] \\{ \\} } s)]\n    (loop [c c r '()] (cond\n        (empty? c) (empty? r)\n        (get #{ \\) \\] \\} } (first c)) (if (not= (get {\\) \\( \\] \\[ \\} \\{ } (first c)) (first r)) false\n             (recur (drop 1 c) (drop 1 r)) )\n        :else (recur (drop 1 c) (conj r (first c)))\n ))))","user":"55adf4d7e4b03311e7b732af"},{"problem":"177","code":"(fn [s]\n  (let [ route (fn [rule s1] (apply str (clojure.string/split s1 rule)))\n         ss (apply str (re-seq  #\"[\\(|\\)|}|{|\\]|\\[]\" s))\n         ]\n       (loop [ b ss]\n           (let [as (route #\"\\{\\}\" (route #\"\\(\\)\" (route #\"\\[\\]\" b)))]  \n             (cond (empty? as) true\n                 (= as b) false\n                 :else (recur as))))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":"177","code":"(fn [s]\n  (loop [remaining s state '()]\n    (if (empty? remaining)\n      (empty? state)\n      (let [[c] remaining\n            [head] state\n            left (rest remaining)]\n       (condp = c\n          \\[ (recur left (conj state c))\n          \\] (recur left (if (= head \\[) (rest state) (conj state c)))\n          \\( (recur left (conj state c))\n          \\) (recur left (if (= head \\() (rest state) (conj state c)))\n          \\{ (recur left (conj state c))\n          \\} (recur left (if (= head \\{) (rest state) (conj state c)))\n          (recur left state)))\n        )))","user":"56aad332e4b03c432f187337"},{"code":"(fn [str]\n  (let [openers #{\\{ \\( \\[}\n        closers #{\\} \\) \\]}\n        opener-for (zipmap closers openers)]\n    (loop [s str\n           brackets '()]\n      (if-let [c (first s)]\n        (cond\n         (contains? openers c) (recur (rest s) (cons c brackets))\n         (contains? closers c) (if (= (get opener-for c) (first brackets))\n                                 (recur (rest s) (rest brackets))\n                                 false)\n         :else (recur (rest s) brackets))\n        (empty? brackets)))))","problem":"177","user":"4fc3a72ae4b081705acca342"},{"problem":"177","code":"(fn\n  [s]\n  (let [m {\\} \\{ \\) \\( \\] \\[}\n        bracket? #{\\} \\{ \\) \\( \\] \\[}\n        closing? (set (keys m))]\n    (loop [[c & more] s\n           brax []]\n      (cond\n        (nil? c) (empty? brax)\n        (closing? c) (if (= (peek brax) (get m c))\n                       (recur more (pop brax))\n                       false)\n        (bracket? c) (recur more (conj brax c))\n        :else (recur more brax)))))","user":"5338387de4b0e30313ee6c91"},{"problem":"177","code":"(fn check-paren [s]\n  (first ((fn open [s op]\n            (let [[shead & stail :as ss] s]\n              (cond\n                (empty? ss) (if (nil? op) [true []] [false []])                       \n                (contains? #{\\( \\[ \\{} shead) (let [[result rests] (open stail ({\\( \\) \\[ \\] \\{ \\}} shead))]\n                                                (if result (recur rests op) [false []]))\n                (contains? #{\\) \\] \\}} shead) (if (= op shead) [true stail] [false []]) \n                :else (recur stail op))))\n           (seq s) nil)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":"177","code":"(fn [s]\n   (letfn [(match? [ob stack] (= ob (first stack)))\n           (sanity? [[b & other] stack]\n             (case b\n               nil (empty? stack) \n               (\"[\" \"{\" \"(\") (recur other (conj stack b))\n               \")\" (if (match? \"(\" stack)\n                     (recur other (rest stack))\n                     false)\n               \"]\" (if (match? \"[\" stack)\n                     (recur other (rest stack))\n                     false)\n               \"}\" (if (match? \"{\" stack)\n                     (recur other (rest stack))\n                     false)))]\n     (sanity? (re-seq #\"[\\[|\\]\\(\\)\\{\\}]\" s)\n              ())))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [col] (loop [q '() s col] (cond\n                                    (and (empty? s) (empty? q)) true\n                                    (empty? s) false\n                                    :else (let [ch (first s) r (rest s) m {\\] \\[, \\} \\{, \\) \\(}]\n                                    (cond\n                                      (some #(= ch %) (vals m)) (recur (conj q ch) r) ;opening brace\n                                      (contains? m ch) (if (= (first q) (m ch)) ;closing brace\n                                                                (recur (rest q) r)\n                                                                false)\n                                      :else (recur q r)\n\n                                      )))))","problem":"177","user":"4faf97d8e4b081705acca258"},{"problem":"177","code":"(fn [s] \n  (let [dic {\\{ \\} \\[ \\] \\( \\)}]\n    (loop [stack ()\n           [f & r] s]\n      (case f\n        (\\{ \\[ \\() (recur (conj stack f) r)\n        (\\} \\] \\)) (if (= f (dic (first stack))) \n                     (recur (rest stack) r) \n                     (do (prn f stack s) false))\n        nil (empty? stack)\n        (recur stack r) ))\n    ))","user":"6011b89ee4b074f607df66bc"},{"problem":"177","code":"(fn [string]\n  (let [brackets (re-seq #\"[\\(\\{\\[\\)\\}\\]]\" string)\n        stack (reduce #(cond (or (= %2 \"(\") (= %2 \"[\") (= %2 \"{\")) (cons %2 %1)\n                             (or (and (= %2 \")\") (= \"(\" (first %1)))\n                                 (and (= %2 \"]\") (= \"[\" (first %1)))\n                                 (and (= %2 \"}\") (= \"{\" (first %1)))) (rest %1)\n                                 :else (cons %2 %1))\n                      '()\n                      brackets)]\n    (empty? stack)))","user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn parse2 [s]\n  (empty?\n   (loop [x (apply str (filter #{\\( \\[ \\{ \\) \\] \\}} s))]\n     (let [new-x (clojure.string/replace x #\"(\\[\\]|\\(\\)|\\{\\})\" \"\")]\n       (if (= new-x x)\n         x\n         (recur new-x))))))","problem":"177","user":"4f7251eee4b07046d9f4f02e"},{"code":"(fn [input]\n  (loop [s (seq input) stack ()]\n    (let [[ c & rest] s]\n      (cond \t(some #(= c %) (seq \"([{\")) \t(recur rest (conj stack c))\n\t\t\t(some #(= c %) (seq \")]}\"))\t(cond \t(= 0  (count stack)) false\n\t\t\t\t\t\t\t\t\t\t\t\t(not= (peek stack) (condp = c \\) \\( \\] \\[ \\} \\{ nil)) false\n\t\t\t\t\t\t\t\t\t\t\t\t:else (recur rest (pop stack)))\n            (not ( seq rest)) (= 0 (count stack))\n            :else  (recur rest stack)))))","problem":"177","user":"523a9fc9e4b081681ca7adca"},{"problem":"177","code":"(fn validBracket[input]\n  (loop[s input matched []]\n    (if (seq s)\n      (let [cs (first s)\n             lm (last matched)]\n        (cond\n         (or (and (= cs \\)) (= lm \\())\n          (and (= cs \\]) (= lm \\[))\n          (and (= cs \\}) (= lm \\{))) (recur (rest s) (vec (drop-last matched)))\n         (contains? #{\\( \\) \\[ \\] \\{ \\}} cs) (recur (rest s) (conj matched cs))\n         :else (recur (rest s) matched)))\n      (empty? matched))))","user":"541619e8e4b01498b1a719f9"},{"problem":"177","code":"(fn [input]\n  (loop [[c & cs] (clojure.string/replace input #\"\\s+\" \"\")\n\t\t brackets '()]\n\t(cond (nil? c) (empty? brackets)\n\t\t  (contains? #{\\[ \\( \\{} c) (recur cs (conj brackets c))\n\t\t  (= c \\]) (and (= \\[ (first brackets)) (recur cs (rest brackets)))\n\t\t  (= c \\)) (and (= \\( (first brackets)) (recur cs (rest brackets)))\n\t\t  (= c \\}) (and (= \\{ (first brackets)) (recur cs (rest brackets)))\n\t\t  :else (recur cs brackets))))","user":"4f037faf535dcb61093f6af8"},{"problem":"177","code":"(fn bal[x]\n  (let [bals (fn [s b]\n              (let [l (last s)]\n                (condp = b\n                  '\\{ (conj s b)\n                  '\\[ (conj s b)\n                  '\\( (conj s b)\n                  '\\} (if (= l '\\{) (vec (drop-last s)) (conj s b))\n                  '\\] (if (= l '\\[) (vec (drop-last s)) (conj s b))\n                  '\\) (if (= l '\\() (vec (drop-last s)) (conj s b))\n                  s)))]\n       (zero? (count(reduce bals [] (seq x))))))","user":"5731e36be4b0cd1946bd0fc9"},{"problem":"177","code":"(fn [s]\n  (let [m {\\( \\) \\{ \\} \\[ \\]}\n        o (set (keys m))\n        c (set (vals m))\n        [r st] (reduce (fn [[r st] s]\n                         (if (not r)\n                           [r]\n                           (cond\n                             (o s) [r (conj st s)]\n                             (c s) (if (= (m (first st)) s)\n                                     [r (rest st)]\n                                     [false])\n                             :else [r st]))) [true ()] (seq s))]\n    (and r (empty? st))))","user":"55316b8ae4b076ab5578f825"},{"problem":"177","code":"(fn balanced? [c]\n  (let [open-brackets \"([{\"\n        close-brackets \")]}\"\n        brackets-mapping (into {} (map (fn [open-bracket close-bracket] [close-bracket open-bracket]) open-brackets close-brackets))\n        ]\n    (loop [brackets []\n           code c]\n\n      (let [ch (first code)]\n        (cond \n          (not (seq code))\n          (empty? brackets)\n\n          (some #{ch} \"[({\") ; open bracket\n          (recur (conj brackets ch) (rest code))\n\n          (some #{ch} \"])}\") ; close bracket\n          (when (= (get brackets-mapping ch) (peek brackets))\n            (recur (pop brackets) (rest code))\n            )\n\n          :default\n          (recur brackets (rest code))\n          )))))","user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn [s]\n  (let [pairs (into {} (map vec (partition 2 \"{}()[]\")))]\n    (loop [x (filter #((set \"()[]{}\") %) s) y []]\n      (if (empty? x)\n        (empty? y)\n        (if (= (first x) (pairs (last y)))\n          (recur (rest x) (vec (butlast y)))\n          (recur (rest x) (conj y (first x)))\n          )))))","problem":"177","user":"4ea365e2535d7eef308072c5"},{"problem":"177","code":"(fn brackets [s]\n  (loop [[head & s] s acc []]\n    (let [head (str head)]\n      (cond\n       (and (empty? head)) (empty? acc)\n       (= head \")\") (if (-> (peek acc) (= \"(\")) (recur s (pop acc)) false)\n       (= head \"]\") (if (-> (peek acc) (= \"[\")) (recur s (pop acc)) false)\n       (= head \"}\") (if (-> (peek acc) (= \"{\")) (recur s (pop acc)) false)\n       (some #{head} [\"(\", \"[\", \"{\"]) (recur s (conj acc head))\n       :else (recur s acc)))))","user":"5412ef7ee4b01498b1a719da"},{"problem":"177","code":"#(empty?(reduce(fn[s c](if(#{\\(\\[\\{}c)(conj s c)(if(#{\\)\\]\\}}c)(if(=({\\)\\(\\]\\[\\}\\{}c)(peek s))(pop s)(conj s 0))s)))[]%))\n\n;(let [open (set \"([{\")\n;      close (set \")]}\")\n;      match (zipmap \"()[]{}\" \")(][}{\")]\n;  (defn balanced? [s]\n;    (reduce\n;      #(cond\n;         (open %2) (conj %1 %2)\n;         (close %2) (if (= (match %2) (peek %1))\n;                      (pop %1)\n;                      (conj %1 nil))\n;         :else %1) [] s\n;      )))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":"177","code":"(fn brackets-balanced? [s]\n  (loop [[c & more-cs :as cs] (seq s)\n         [b & more-bs :as bs] '()]\n    (let [closing-bracket {\\( \\)\n                           \\{ \\}\n                           \\[ \\]}]\n      (cond\n        (empty? cs)\n        (empty? bs)\n\n        (#{\\( \\{ \\[} c)\n        (recur more-cs (cons c bs))\n\n        (#{\\) \\} \\]} c)\n        (if (= c (closing-bracket b))\n          (recur more-cs more-bs)\n          false)\n\n        :else\n        (recur more-cs bs)))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [in]\n  (loop [input (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" in) stk '() h (first input)]\n    (if (empty? input) (empty? stk)\n        (if (or (contains? #{\"(\" \"[\" \"{\"} h)\n             (and (contains? #{\"}\" \")\" \"]\"} h)\n                 (= (first stk) h)))\n          (recur (rest input)\n                 (cond (= h \"(\") (conj stk \")\")\n                       (= h \"{\") (conj stk \"}\")\n                       (= h \"[\") (conj stk \"]\")\n                       :else (rest stk))\n                 (second input))\n          false))))","problem":"177","user":"4f38d6bbe4b0e243712b1ee2"},{"problem":"177","code":"(fn\n  [string]\n  (let [brackets \"[](){}\"\n        openToCloseMap (apply hash-map (vec brackets))]\n    (loop [stack []\n           coll (vec string)]\n      (if (seq coll)\n        (let [h (first coll)\n              t (rest coll)]\n          (if (= -1 (.indexOf brackets (int h)))\n            (recur stack t)\n            (let [c (openToCloseMap h)]\n              (if c\n                (recur (conj stack c) t)\n                (if (and (seq stack)\n                         (= (peek stack) h))\n                  (recur (pop stack) t)\n                  false)))))\n        (empty? stack)))))","user":"52dfc89be4b09f7907dd1405"},{"problem":"177","code":"(fn [st] \n  (let[br {\\{ \\}, \\[ \\], \\( \\)} bl {\\} \\}, \\] \\], \\) \\)}]\n    (loop[bs '() s st] \n      (if (empty? s) (empty? bs) \n        (let[fs (first s) br' (br fs) bl' (bl fs)]\n          (recur (cond \n                    (char? br') (cons br' bs) \n                    (= bl' (first bs)) (rest bs)\n                    (char? bl') (cons bl' bs)\n                    :else bs) \n            (rest s)))))))","user":"58e7229fe4b056aecfd47cc4"},{"problem":"177","code":"#(let [open->close {\\( \\) \\[ \\] \\{ \\}}\n        open (into #{} (keys open->close))\n        close(into #{} (vals open->close))]\n   (empty? (reduce (fn [stack c]\n                    (cond\n                      (open c) (conj stack c)\n                      (close c) (cond\n                                  (empty? stack) (conj stack c)\n                                  (= c (open->close (peek stack))) (pop stack)\n                                  :else stack)\n                      :else stack))\n                  []\n                  %)))","user":"5f3abcc4e4b004f08c61c52b"},{"code":"(fn [s]\n   ((fn bal [s st]\n     (case (str (first s))\n       \"\" (empty? st)\n       \"(\" (bal (rest s) (cons \"(\" st))\n       \"{\" (bal (rest s) (cons \"{\" st))\n       \"[\" (bal (rest s) (cons \"[\" st))\n       \")\" (if-not (= (first st) \"(\") false\n                   (bal (rest s) (rest st)))\n       \"}\" (if-not (= (first st) \"{\") false\n                   (bal (rest s) (rest st)))\n       \"]\" (if-not (= (first st) \"[\") false\n                   (bal (rest s) (rest st)))\n       (bal (rest s) st))) s '()))","problem":"177","user":"529ce629e4b04e0c58e87b6e"},{"problem":"177","code":"(fn f [str]\n  (let [opening? #(re-matches #\"\\{|\\(|\\[\" %)\n        valid-close? (fn [x y] (= (get {\"[\" \"]\" \"{\" \"}\" \"(\" \")\"} x) y))]\n    (loop [seen [] brackets (vec (filter (fn [x] (re-matches #\"\\[|\\]|\\{|\\}|\\(|\\)\" x)) (clojure.string/split str #\"\")))]\n      (if (empty? brackets)\n        (empty? seen)\n        (let [last-seen (last seen) x (first brackets)]\n          (cond (opening? x) (recur (conj seen x) (rest brackets))\n                (valid-close? last-seen x) (recur (vec (drop-last seen)) (rest brackets))\n                :else false))))))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn balanced-brackets? [s]\n  (let [\n        filter-brackets (fn [s]\n                          (let [pred (fn [c]\n                                       (let [c1 (str c)]\n                                         (if (or (= c1 \"(\") (= c1 \")\") \n                                                 (= c1 \"[\") (= c1 \"]\")\n                                                 (= c1 \"{\") (= c1 \"}\"))\n                                           true\n                                           false)))]\n                            (vec (filter #(pred %) s))\n                            ))\n        is-pair? (fn [a b]\n                   (let [a1 (str a)\n                         b1 (str b)]\n                     (cond\n                       (and (= a1 \"(\") (= b1 \")\")) true\n                       (and (= a1 \"[\") (= b1 \"]\")) true\n                       (and (= a1 \"{\") (= b1 \"}\")) true\n                       :else false)))\n        remove-pair (fn [v i]\n                      (vec (concat (subvec v 0 i) (subvec v (+ 2 i)))))                 \n        strip-pairs (fn [v]\n                      (cond\n                        (and (= 2 (count v)) (true? (is-pair? (v 0) (v 1)))) \"\"\n                        (= 1 (count v)) v\n                        :else      \n                        (loop [v1 v \n                               i 0 \n                               size (count v1)]\n                          ; end when i is on the last position\n                          (if (= i (-> v1 count dec))\n                            v1\n                            (let [a (v1 i)\n                                  b (-> i inc v1)\n                                  pair (is-pair? a b)]\n                              (if (true? pair)\n                                (recur (remove-pair v1 i) i (- size 2))\n                                (recur v1 (inc i) size))\n                              )))))\n        processed (filter-brackets s)]\n    (if (empty? processed)\n      true\n      (loop [v processed]\n        (let [v1 (strip-pairs v)]\n          (cond\n            (= (count v) (count v1)) false\n            (empty? v1) true\n            :else (recur v1))\n          )))))","problem":"177","user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [s]\n  (let [brk {\\] \\[ \\) \\( \\} \\{}]\n    (loop [c () [r1 & r] (seq s)]\n      (cond\n        (nil? r1) (empty? c)\n        ((set (vals brk)) r1) (recur (conj c r1) r)\n        (brk r1) (if (= (brk r1) (first c)) (recur (rest c) r) false)\n        :else (recur c r)))))","problem":"177","user":"528e64b7e4b0239c8a67aedd"},{"problem":"177","code":"(fn __ [s]\n  (letfn [(popp [x stack] (if (= x (first stack)) (rest stack) false))\n          (f [stack s]\n             (cond (false? stack) false\n                   (empty? s) (empty? stack)\n                   (= (first s) \\{) (f (cons \\{ stack) (rest s))\n                   (= (first s) \\() (f (cons \\( stack) (rest s))\n                   (= (first s) \\[) (f (cons \\[ stack) (rest s))\n                   (= (first s) \\}) (f (popp \\{ stack) (rest s))\n                   (= (first s) \\)) (f (popp \\( stack) (rest s))\n                   (= (first s) \\]) (f (popp \\[ stack) (rest s))\n                   :else (f stack (rest s))))]\n    (f '() s)))","user":"54c271b9e4b045293a27f602"},{"problem":"177","code":"(fn balanced? [s]\n  (let [chars (seq s)]\n    (empty?\n      (loop [c chars stack []]\n        (if (empty? c)\n          stack\n          (let [newstack (vec (case (first c)\n                           (\\( \\[ \\{)  (conj stack (first c))\n                           \\) (if (= (peek stack) \\() (pop stack) (conj stack (first c)))\n                           \\] (if (= (peek stack) \\[) (pop stack) (conj stack (first c)))\n                           \\} (if (= (peek stack) \\{) (pop stack) (conj stack (first c)))\n                           stack))]\n            (recur (next c) newstack))\n          )\n        )\n      )\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn check-paren [l]\n  (loop [que [] par (#(filter #{\\{ \\} \\( \\) \\[ \\]} %) l)]\n    (if (empty? par)\n      (empty? que)\n      (if (#{[\\( \\)] [\\[ \\]] [\\{ \\}]}\n             (vector (last que) \n             (first par)))\n        (recur (reverse (rest (reverse (vec que))))\n               (rest par))\n        (recur (conj (vec que) (first par))\n               (rest par))))))","problem":"177","user":"52b35a6ee4b0c58976d9ad07"},{"code":"(fn validate-braces [s]\n  (let [forward-matches { \\( \\), \\[ \\], \\{ \\} }\n        backward-matches (into {} (map (fn [[k v]] [v k]) forward-matches))]\n    ((fn helper [s stack]\n      (let [c  (first s)]\n        (cond \n          (nil? c) (empty? stack)\n          (contains? forward-matches c) (helper (rest s) (cons c stack))\n          (contains? backward-matches c) (if (= (first stack) (get backward-matches c))\n                                           (helper (rest s) (rest stack))\n                                           false)\n          :else (helper (rest s) stack)))) s '())))","problem":"177","user":"50d86fe2e4b01f0871336e67"},{"problem":"177","code":"(fn balanced-brackets? [s]\n  (letfn [(opn [b] (case b \\) \\( \\} \\{ \\] \\[))]\n    (loop [s (seq s)\n           r '()]\n      (if (empty? s)\n        (empty? r)\n        (if (or (= (first s) \\()\n                (= (first s) \\{)\n                (= (first s) \\[))\n          (recur (rest s) (conj r (first s)))\n          (if (or (= (first s) \\))\n                  (= (first s) \\})\n                  (= (first s) \\]))\n            (if (= (opn (first s)) (first r))\n              (recur (rest s) (rest r))\n              false)\n            (recur (rest s) r)))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":"177","code":"#(loop [[c & xs] (keep {\\{ -1 \\} 1 \\( -2 \\) 2 \\[ -3 \\] 3} %)\n        stack []]\n   (cond\n    (nil? c) (empty? stack)\n    (neg? c) (recur xs (conj stack (Math/abs c)))\n    (= (peek stack) c) (recur xs (pop stack))\n    :else false))","user":"5a080bdde4b01bb0ae8afde9"},{"code":"(fn [ls]\n  (loop [ls (map str (seq ls)) acc '()]   \n       (cond (empty? ls)\n             (empty? acc)\n\n             (= \"}\" (first ls))\n             (and (= \"{\" (peek acc)) (recur (rest ls) (pop acc)))\n\n             (= \"]\" (first ls))\n             (and (= \"[\" (peek acc)) (recur (rest ls) (pop acc)))\n\n             (= \")\" (first ls))\n             (and (= \"(\" (peek acc)) (recur (rest ls) (pop acc)))\n\n             (or (= \"(\" (first ls)) (= \"[\" (first ls)) (= \"{\" (first ls)))\n             (recur (rest ls) (conj acc (first ls)))\n\n             :else\n             (recur (rest ls) acc))))","problem":"177","user":"5301157ae4b0d8b024fd3717"},{"problem":"177","code":"(fn [s]\n  (loop [cs (seq s), stack '()]\n    (if (empty? cs) (empty? stack)\n      (case (first cs)\n        \\) (if (not= \\( (first stack)) false (recur (rest cs) (rest stack)))\n        \\] (if (not= \\[ (first stack)) false (recur (rest cs) (rest stack)))\n        \\} (if (not= \\{ (first stack)) false (recur (rest cs) (rest stack)))\n        \\( (recur (rest cs) (cons \\( stack))\n        \\[ (recur (rest cs) (cons \\[ stack))\n        \\{ (recur (rest cs) (cons \\{ stack))\n        (recur (rest cs) stack)))))","user":"605b7a90e4b079a07f8593fc"},{"problem":"177","code":"(fn brackets-balanced? [s]\n  (let [is-opener? #(re-matches #\"[\\[\\{\\(]\" (str %1))\n        is-closer? #(re-matches #\"[\\]\\}\\)]\" (str %1))\n        get-matching-bracket #(case %1\n                                \\[ \\]\n                                \\] \\[\n                                \\{ \\}\n                                \\} \\{\n                                \\( \\)\n                                \\) \\(\n                                nil)]\n    (empty? (reduce #(cond\n                      (is-opener? %2) (conj %1 %2)\n                      (is-closer? %2) (if (= (last %1) (get-matching-bracket %2))\n                                        (into [] (butlast %1))\n                                        (conj %1 %2))\n                      :else %1)\n                   [] s))))","user":"53504fe6e4b084c2834f4ada"},{"problem":"177","code":"(fn [s]\n  (let [closing {\\) \\(, \\} \\{, \\] \\[}]\n    (loop [[b & r] (mapcat seq (re-seq #\"[(){}\\[\\]]\" s)), stack []]\n      (cond (not b) (empty? stack)\n            (closing b) (when (= (peek stack) (closing b))\n                          (recur r (pop stack)))\n            :else (recur r (conj stack b))))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(let [brackets {\\] \\[ \\) \\( \\} \\{}]\n  (fn balanced? [s]\n    (let [stack\n          (reduce\n           (fn [stack chr]\n             (condp apply [chr]\n               (set (vals brackets))\n               (conj stack chr)\n                \n               brackets\n               (if (= (brackets chr)\n                      (peek stack))\n                 (pop stack)\n                 (conj stack 0))\n                 \n               stack))\n           () s)]\n      \n      (and stack\n           (empty? stack)))))","problem":"177","user":"532ab0bde4b09d4e7a9b5527"},{"problem":"177","code":"(fn [text]\n  (let [left? (fn [s]\n                (or\n                 (= s \\{)\n                 (= s \\[)\n                 (= s \\()))\n        right? (fn [s]\n                 (or\n                  (= s \\})\n                  (= s \\])\n                  (= s \\))))\n        matching (fn [s1 s2]\n                   [s1 s2]\n                   (or \n                    (and (= s1 \\[) (= s2 \\]))\n                    (and (= s1 \\{) (= s2 \\}))\n                    (and (= s1 \\() (= s2 \\)))))\n        str (filter #(or (left? %) (right? %)) text)]\n    (loop [stack '()\n           s str]\n      (if (empty? s)\n        (empty? stack)\n        (if (left? (first s))\n          (recur (conj stack (first s)) (rest s))\n          ;; else\n          (if (not (matching (first stack) (first s)))\n            false\n            (recur (rest stack) (rest s))))))))","user":"5defc177e4b093ff717275af"},{"problem":"177","code":"(fn [s]\n         (let [opposite {\\{ \\}\n                         \\} \\{\n                         \\( \\)\n                         \\) \\(\n                         \\[ \\]\n                         \\] \\[}]\n           (empty?\n             (reduce\n               (fn [res item]\n                 (if (= (opposite item) (peek res))\n                   (pop res)\n                   (conj res item)))\n               []\n               (filter\n                 #{\\[ \\] \\{ \\} \\( \\)}\n                 s)))))","user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [s]\n  (let [stack (re-seq #\"[\\[{()}\\]]\" s) right {\"]\" \"[\" \")\" \"(\" \"}\" \"{\"}]\n    (if (nil? stack) true\n    (loop [r [] stack stack]\n       (if (empty? stack) (empty? r)\n         (let [e (first stack) seed (right e)]\n             (recur (if (nil? seed) (cons e r)\n                (if (= (first r) seed)\n                   (drop 1 r)\n                   (cons e r)\n                )\n             ) \n             (rest stack))\n         )\n       )\n    )\n    )\n  )\n  \n)","problem":"177","user":"522eba30e4b01cdb292c5f0e"},{"problem":"177","code":"(fn [S]\n    (let\n      [\n        Tokens {\n          \\( {:action :open :pair \\) }\n          \\[ {:action :open :pair \\] }\n          \\{ {:action :open :pair \\} }\n          \\) {:action :close :pair \\( }\n          \\] {:action :close :pair \\[ }\n          \\} {:action :close :pair \\{ }\n        }\n      ]\n      (loop\n        [Stack '() First (first S) Rest (rest S)]\n        (if (nil? First)\n          ;;   ,   \n          (zero? (count Stack))  \n          (let [Token (get Tokens First nil)]\n            (cond\n              ;;    ,  \n              (nil? Token) (recur Stack (first Rest) (rest Rest) )\n              ;;   ,    \n              (= (:action Token) :open) (recur (cons (:pair Token) Stack) (first Rest) (rest Rest) )\n              ;;   -   ,  \n              (zero? (count Stack)) false\n              ;;        - \n              (not= First (first Stack) ) false\n              ;;   -   \n              :else (recur (rest Stack) (first Rest) (rest Rest) )\n            )\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":"177","code":"(fn paired? [s]\n  (let [\n         pair {\\) \\( \\] \\[ \\} \\{}\n         opening? #{\\( \\[ \\{}\n         paren? #{\\( \\) \\[ \\] \\{ \\}}\n       ]\n    (loop [st '() r s]\n      (if (empty? r)\n        (empty? st)\n        (if (paren? (first r))\n          (if (opening? (first r))\n            (recur (conj st (first r)) (next r))\n            (if (= (first st) (pair (first r)))\n              (recur (next st) (next r))\n              false\n            )\n          )\n          (recur st (next r))\n        )\n      )\n    )\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"problem":"177","code":"(fn [s]\n    (let [pair {\\} \\{\n                \\) \\(\n                \\] \\[}]\n        (loop [xs s\n               stack '()]\n            (if (empty? xs)\n                (empty? stack)\n                (let [x (first xs)\n                      xs' (rest xs)\n                      stack' (if (contains? #{\\( \\{ \\[} x)\n                                 (cons x stack)\n                                 (if (contains? #{\\] \\} \\)} x)\n                                     (rest stack)\n                                     stack))]\n                    (if (and (contains? pair x) (not= (get pair x) (first stack)))\n                        false\n                        (recur xs' stack')))))))","user":"600ae927e4b074f607df6689"},{"problem":"177","code":"#(letfn [(f [s]\n               (filter (fn [x] (not (nil? x)))\n                       (map (fn [x]\n                              (if (contains? #{\\{ \\[ \\( \\) \\] \\}} x)\n                                x)) s)))\n          (g [x y]\n               (cond (= x \\)) (= y \\()\n                     (= x \\}) (= y \\{)\n                     (= x \\]) (= y \\[)))]\n    (let [s (f %)]\n      (if (empty? s)\n        true\n        (loop [i 1 y (vector (first s))]\n          (if (< i (count s))\n            (if (g (nth s i) (last y))\n              (recur (inc i) (drop-last y))\n              (recur (inc i) (conj (vec y) (nth s i))))\n            (empty? y))))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":"177","code":";this is a classical stack problem\n#(let [brackets #{\\( \\) \\[ \\] \\{ \\}};for the easy expression\n       match {\\( \\) \\[ \\] \\{ \\}}];for the easy expression\n   (loop[result '() remaining %]\n     (if-let [item (first remaining)]\n       (if (contains? brackets item);current character is one bracket \n         (if (= item (match (peek result)));if brackets match\n           (recur (pop result) (rest remaining)) ;then pop\n           (recur (conj result item) (rest remaining)));else push\n         (recur result (rest remaining)));else continue the loop\n       (empty? result))));return if the stack is empty","user":"556c70dae4b09a3098a524fd"},{"problem":"177","code":"#(empty? (reduce (fn [[x & xs :as coll] c]\n          (let [o #{\\( \\[ \\{} \n                m {\\) \\( \\] \\[ \\} \\{}]\n            (cond (o c) (conj coll c)\n                  (m c) (if (= x (m c)) xs '(0))\n                  :else coll))) () %))","user":"5c379636e4b0d62ef62d9f76"},{"problem":"177","code":"#(let [cl (apply str (re-seq #\"\\{|\\}|\\[|\\]|\\(|\\)\" %))\n       br #\"\\{\\}|\\[\\]|\\(\\)\"]\n   ((fn it [s] (cond\n                (= \"\" s) true\n                (re-seq br s) (it (clojure.string/replace s br \"\"))\n                :else false)) cl))","user":"5504dd64e4b086ebe8a79c83"},{"problem":"177","code":"(fn [s]\n  (let [o #{\\( \\[ \\{}\n        c #{\\) \\] \\}}\n        co (zipmap c o)]\n    (empty? (reduce #(cond \n              \t\t\t(o %2) (conj % %2)\n              \t\t\t(c %2) (if (= (last %) (co %2)) (pop %) (conj % %2))\n              \t\t\t:else %) [] s))))","user":"56baa68ce4b0f26550335947"},{"code":"(fn [s]\n   (let [brackets {\"[\" \"]\",\"(\" \")\",\"{\"\"}\"}]\n    (loop [x (re-seq (re-pattern (str \"[\"(apply str(map #(str \\\\ %)(mapcat identity brackets)))\"]\")) s) y '()]\n      (cond (empty? x) (empty? y)\n            (and(not(contains? brackets (first x)))(=(first x)(first y))) (recur (rest x)(rest y))\n            (not(contains? brackets (first x))) false\n\t\t\t:else (recur (rest x) (conj y (get brackets(first x))))\n            )\n       )   \n     \n     )\n   )","problem":"177","user":"5274eb56e4b03e8d9a4a74bb"},{"problem":"177","code":"(fn balanced? [s]                                                                                                               \n  (let [starts #{ \\( \\{ \\[ }                                                                                               \n        ends #{ \\) \\} \\] }                                                                                                 \n        stack0 ()]                                                                                                         \n    (letfn [(push [stack x] (conj stack x))                                                                                \n            (top [stack] (first stack))                                                                                    \n            (pop [stack] (rest stack))                                                                                     \n            (closes? [s e] (contains? #{[\\( \\)] [\\{ \\}] [\\[ \\]]} [s e]))]                                                  \n      (loop [stack stack0 s (seq s)]                                                                                       \n        (let [[c & r] s]                                                                                                   \n          (cond                                                                                                            \n           (empty? s) (empty? stack)                                                                                       \n           (starts c) (recur (push stack c) r)                                                                             \n           (ends c) (if (closes? (top stack) c)                                                                            \n                      (recur (pop stack) r)                                                                                \n                      false)                                                                                               \n           :else (recur stack r)))))))","user":"4ed188c8535d44c135fd68cf"},{"problem":"177","code":"(fn balanced-brackets?1 [string]\n  (let [opp {\\( \\), \\[ \\], \\{ \\}}]\n    (let [[stack return] (reduce (fn [[stack return] char]\n                                   (if (nil? return)\n                                     (case char\n                                       (\\( \\[ \\{) [(conj stack char) return]\n                                       (\\) \\] \\}) (if (= char (opp (peek stack)))\n                                                    [(pop stack) return]\n                                                    [nil false])\n                                       [stack return])\n                                     [stack return]))\n                                 ['() nil]\n                                 string)]\n      (and (nil? return)\n           (empty? stack)))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn validate-brackets [s]\n  (let [ all-bs  #{ \\( \\) \\{ \\} \\[ \\] }\n         open-bs  { \\( \\) \\{ \\} \\[ \\] } ]\n    (loop [ s (filter all-bs s) stack '() ]\n      (if-let [ c (first s) ]\n        (cond (open-bs c)         (recur (rest s) (cons (open-bs c) stack))\n              (= c (first stack)) (recur (rest s) (rest stack))\n              :else false)\n        (empty? stack)))))","problem":"177","user":"4e860e85535db62dc21a62f1"},{"problem":"177","code":"(fn pars [in]\n  (let [dict {\\{ \\}, \\( \\), \\[ \\]}\n        pars (set (vals dict))\n        par-fn (fn [stack s]\n                 (if (false? stack)\n                   false\n                   (if-let [open (dict s)]\n                     (cons open stack)\n                     (if-let [close (pars s)]\n                       (if (= (first stack) close) (rest stack) false)\n                       stack))))]\n    (let [res (reduce par-fn '() in)]\n      (and (coll? res) (empty? res)))))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [s]\n    (let [pairs { \\[ \\] \\] \\[ \\{ \\} \\} \\{ \\( \\) \\) \\( }\n          openers #{ \\[ \\{ \\( }\n          closers (map #(get pairs %) openers)]\n      (loop [s s\n             stack ()]\n        (let [c (first s)]\n          (cond (not s) (empty? stack)\n                (some #{c} openers) (recur (next s) (conj stack (get pairs c)))\n                (some #{c} closers) (if (= c (first stack))\n                                      (recur (next s) (rest stack))\n                                      (recur (next s) (conj stack c))) ; now stack will never be empty\n                :else (recur (next s) stack))))))","problem":"177","user":"4e89e939535d3e98b8023287"},{"code":"(let [adder (fn [marker] #(cons marker %))\n      remover (fn [marker] #(when (= marker (first %)) (rest %)))\n      callbacks {\\( (adder :r), \\) (remover :r),\n                 \\[ (adder :s), \\] (remover :s),\n                 \\{ (adder :c), \\} (remover :c)}]\n  (fn parse \n    ([text] (= (parse (seq text) '()) '()))\n    ([tokens stack] (if (or (empty? tokens) (nil? stack)) stack\n                      (recur (rest tokens) ((get callbacks (first tokens) identity) stack))))))","problem":"177","user":"532347dde4b09d4e7a9b54cc"},{"problem":"177","code":"(fn match-brakets-2 [string]\n  (let [paren-map {\\) \\(, \\} \\{, \\] \\[}] \n    (loop [s string, l '()]\n      (cond\n        (empty? s)\n          (if (empty? l)\n            true\n            false)\n        (contains? #{\\( \\{ \\[} (first s))\n          (recur (rest s) (conj l (first s)))\n        (contains? #{\\) \\} \\]} (first s))\n          (if (= (first l) (paren-map (first s)))\n            (recur (rest s) (rest l))\n            false)\n        :else\n          (recur (rest s) l)))))","user":"58c3af4de4b021aa9917ed1b"},{"code":"(fn [a] (empty? (reduce #(condp apply [%2]\n            \t            {\\( \\) \\[ \\] \\{ \\}} :>> (partial conj %1)\n                        (partial = (first %1)) (rest %1)\n                           #{\\) \\] \\}} (conj %1 nil)\n                        %1)\n                \t'()\n                       a)))","problem":"177","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [s] (letfn [(lb? [c] (#{\\( \\[ \\{} c))\n                (rb? [c] (#{\\) \\] \\}} c))\n                (nb? [c] (and (not (lb? c)) (not (rb? c))))\n                (check [l r] (= ({\\( \\) \\[ \\] \\{ \\}} l) r))]\n          (loop [[head & s] s stack []]\n            (cond\n             (nil? head) (empty? stack)\n             (nb? head) (recur s stack)\n             (lb? head) (recur s (cons head stack))\n             (check (first stack) head) (recur s (rest stack))))))","problem":"177","user":"503354c3e4b0c6c1199c710c"},{"problem":"177","code":"(fn balance? [s]\n  (empty?\n  (reduce (fn [ret cur-item]\n            (if (re-matches #\"\\{\\}|\\(\\)|\\[\\]\" (str (last ret) cur-item))\n              (into [] (butlast ret))\n              (conj ret cur-item)))\n          []\n          (into [] (re-seq #\"[(\\[{}\\])]\"\n                           s)))))","user":"559d33b3e4b0ec2b359424d9"},{"code":"(fn [s]\n  ((fn [t p]\n     (cond (empty? t) (empty? p)\n           (= (first t) \\() (recur (rest t) (conj p \\())\n           (= (first t) \\{) (recur (rest t) (conj p \\{))\n           (= (first t) \\[) (recur (rest t) (conj p \\[))\n           (= (first t) \\)) (if (= (first p) \\() (recur (rest t) (rest p)) false)\n           (= (first t) \\}) (if (= (first p) \\{) (recur (rest t) (rest p)) false)\n           (= (first t) \\]) (if (= (first p) \\[) (recur (rest t) (rest p)) false)\n           :else (recur (rest t) p)))\n   s '()))","problem":"177","user":"51da631be4b02ceefd947766"},{"problem":"177","code":"(fn [s]\n   (let [r (filter #(contains? #{\\( \\) \\{ \\} \\[ \\]} %) s)\n         m {\\( \\) \\{ \\} \\[ \\]}]\n\n     (empty? (reduce (fn [c x] (if (= x (m (last c))) (vec (drop-last c)) (conj c x))) [] r))\n\n     )\n\n   )","user":"5921a080e4b09b4ee5954c77"},{"problem":"177","code":"(fn check-string [string]\n  (let [all (re-seq #\"[\\(\\)\\{\\}\\[\\]]\" string)\n        opposite-map {\"{\" \"}\"\n                      \"(\" \")\"\n                      \"[\" \"]\"}]\n    (loop [a all built []]\n        (cond\n          (empty? a) (empty? built)\n          \n          (contains?  #{\"(\" \"[\" \"{\"} (first a)) \n          (recur (rest a) (conj built (first a)))\n          \n          (= (first a) (get opposite-map (last built)))\n          (recur (rest a) (pop built))\n          \n          :else\n          (recur (rest a) (conj built (first a)))\n          ))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn brackets [s]\n  (empty?\n   (reduce\n    (fn [[left & other :as stack] right]\n      (cond\n       ; New char closes the inner-most open bracket -> pop inner-most.\n       (= right ({\\[ \\], \\( \\), \\{ \\}} left)) other\n       ; New char opens a new bracket -> push new bracket.\n       ((set \"{}[]()\") right) (cons right stack)\n       ; Not a bracket.\n       :else stack\n       )\n      )\n    ()\n    s\n    )\n   )\n  )","problem":"177","user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [s]\n  (letfn [(get-opener [c]\n                      (cond (= c \\]) \\[\n                        (= c \\}) \\{\n                        (= c \\)) \\(\n                        :else \\a))\n          (bal? [ch brackets]\n                (let [openers #{ \\[ \\( \\{ }\n                      closers #{ \\] \\) \\} }]\n                (cond (not (seq ch)) (empty? brackets)\n                      (contains? openers (first ch)) (bal? (rest ch) (cons (first ch) brackets))\n                      (contains? closers (first ch)) (and (= (first brackets) (get-opener (first ch))) (bal? (rest ch) (rest brackets)))\n                      :else (bal? (rest ch) brackets))))]\n    (bal? s '())))","problem":"177","user":"51857e64e4b0da5a5be3babe"},{"problem":"177","code":"(fn [s]\n  (let [brackets #{\\( \\) \\[ \\] \\{ \\}}\n        paired {\\( \\) \\[ \\] \\{ \\}}\n        opener (set (keys paired))\n        closer (set (vals paired))\n        blist (filter brackets s)]\n    (loop [stack [] input blist]\n      (if (empty? input)\n        (empty? stack)\n        (let [[x & input1] input]\n          (cond\n            (opener x) (recur (conj stack x) input1)\n            (= x (paired (peek stack))) (recur (pop stack) input1)\n            true false))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":"177","code":"(fn brackets-balanced? [input-str]\n  (let [brackets {\\{ \\} \\( \\) \\[ \\]}\n        closing (set (vals brackets))]\n    (loop [[s & ss] input-str stack []]\n      (cond\n        (nil? s) (empty? stack)\n\n        (contains? brackets s) (recur ss (conj stack (brackets s)))\n\n        (contains? closing s) (if (= (peek stack) s)\n                                (recur ss (pop stack))\n                                false)\n\n        :else (recur ss stack)))))","user":"58b81490e4b0ebc645576d8c"},{"code":"#(empty? (reduce (fn [s c]\n                  (if (#{\\] \\[ \\) \\( \\} \\{} c) \n                    (if-let [m ({\\] \\[, \\) \\(, \\} \\{ } c)]\n                      (if (= m (peek s))\n                        (pop s)\n                        (conj s c) )\n                      (conj s c))\n                    s))\n                '()\n                %))","problem":"177","user":"4ee7d177535d93acb0a6686f"},{"problem":"177","code":"(fn [s]\n  (let [openers (set \"({[\")\n        closers (set \")}]\")\n        closer->opener (zipmap closers openers)]\n    (empty? (reduce (fn [stack c]\n                      (cond\n                        (openers c) (conj stack c)\n                        (closers c)\n                          (let [current-bracket (peek stack)]\n                            (if (= current-bracket (closer->opener c))\n                              (pop stack)\n                              (conj stack 0)))\n                        :else stack))\n                    (list)\n                    s))))","user":"56f9982ce4b07572ad1a88b8"},{"code":"(let [opening-brackets [\\( \\{ \\[]\n      closing-brackets [\\) \\} \\]]\n      bracket-map (zipmap opening-brackets closing-brackets)]\n  (fn [initial-s]\n    (loop [[head & tail :as s] initial-s\n           acc []]\n      (if (empty? s)\n        (empty? acc)\n        (cond\n         (some #{head} opening-brackets) (recur tail (conj acc head))\n         (some #{head} closing-brackets) (and (= (get bracket-map (peek acc)) head)\n                                              (recur tail (pop acc)))\n         :else (recur tail acc))))))","problem":"177","user":"51789dfae4b03d69594194d7"},{"problem":"177","code":"(letfn [                                                                                                                                                \n    (get-brackets [s] (clojure.string/join (re-seq #\"[\\(\\)\\[\\]\\{\\}]+\" s)))                                                      \n    (remove-brackets [s] (clojure.string/replace s #\"(?:\\(\\)|\\[\\]|\\{\\})\" \"\"))                                                                           \n    (check-brackets [s]                                                                                                         \n        (let [s' (remove-brackets s)]                                                                                                                   \n            (cond                                                                                                               \n                (empty? s') true                                                                                                                        \n                (= s s') false                                                                                                                          \n                :else (check-brackets s'))))]                                                                                   \n    #(check-brackets (get-brackets %)))","user":"558b50d5e4b027778923762b"},{"problem":"177","code":"(fn __ [code]\n  (let [constants {\\[ [:square true] \\] [:square false] \\( [:round true] \\) [:round false] \\{ [:figure true] \\} [:figure false]}]\n   (loop [c code\n          stack '()]\n     (if (empty? c)\n       (empty? stack)\n\t     (if-let [[k push?] (-> c first constants)]\n\t       (if push? \n          (recur (rest c) (conj stack k))\n          (if (= (first stack) k)\n            (recur (rest c) (rest stack))\n            false))\n         (recur (rest c) stack))))))","user":"55a62092e4b0acc240e31554"},{"problem":"177","code":"(fn [input]\n  (let [brck (filter #{\\( \\) \\{ \\} \\[ \\] } input )\n        closings {\\) \\( \\] \\[ \\} \\{ }\n        clc (reduce (fn [[f & acc :as v] el]\n                  (if (and (contains? closings el) (= (get closings el) f))\n                    acc\n                    (cons el v)\n                    ))\n                '()\n                brck)]\n    (empty? clc)))","user":"52503747e4b0541d1855b828"},{"code":"(fn balanced? [text]\n  (let [opening-brackets #{\\[ \\{ \\(}\n        closing-brackets #{\\] \\} \\)}\n        matching-bracket {\\[ \\] \\{ \\} \\( \\)}]\n    (empty? (reduce (fn [bracket-stack c]\n                      (cond (contains? opening-brackets c)\n                              (cons c bracket-stack)\n                            (contains? closing-brackets c)\n                              (if (= c (matching-bracket (first bracket-stack)))\n                                (rest bracket-stack)\n                                (cons :poison bracket-stack))\n                            :else \n                              bracket-stack))\n                    ()\n                    text))))","problem":"177","user":"4db1b3951254ad5b4805fa6f"},{"problem":"177","code":"(fn [a-string]\n  (loop [so-far []\n         a-string (seq a-string)]\n    (println (str \"a-string: \" (apply str a-string)\n                  \"\\nso-far: \" (apply str so-far)))\n    (if (and (empty? a-string) (empty? so-far)) \n      true\n      (case (first a-string)\n        \\( (recur (conj (into [] so-far) \\()\n                  (rest a-string))\n        \\{ (recur (conj (into [] so-far) \\{)\n                   (rest a-string))\n        \\[ (recur (conj (into [] so-far) \\[)\n                  (rest a-string))\n        \\) (if (= (last so-far) \\()\n             (recur (drop-last so-far)\n                    (rest a-string))\n             false)\n        \\} (if (= (last so-far) \\{)\n             (recur (drop-last so-far)\n                     (rest a-string))\n             false)\n        \\] (if (= (last so-far) \\[)\n             (recur (drop-last so-far)\n                     (rest a-string))\n             false)\n        (if (and (empty? (rest a-string)) \n                 (not (empty? so-far)))\n          false\n          (recur so-far (rest a-string)))))))","user":"53d40508e4b00fb29b221332"},{"problem":"177","code":"(fn [s]\n  (loop [stack [] s s]\n    (if (empty? s)\n      (empty? stack)\n      (condp = (first s)\n        \\( (recur (conj stack \\() (rest s))\n        \\{ (recur (conj stack \\{) (rest s))\n        \\[ (recur (conj stack \\[) (rest s))\n        \\] (when (= (peek stack) \\[) (recur (pop stack) (rest s)))\n        \\} (when (= (peek stack) \\{) (recur (pop stack) (rest s)))\n        \\) (when (= (peek stack) \\() (recur (pop stack) (rest s)))\n        (recur stack (rest s))))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn f ([i] (f i '())) ([i s] (let [m {\\) \\( \\] \\[ \\} \\{} vs (vals m)] (if-let [t (first i)] (if (> (.indexOf vs t) -1) (f (rest i) (reverse (conj s t))) (if-let [v (get m t)] (if (= v (last s)) (f (rest i) (reverse (drop-last s))) false) (f (rest i) s))) (empty? s)))))","problem":"177","user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(letfn [(parse1 [s]\n          (case (first s)\n            \\[ [:square :open]\n            \\] [:square :close]\n            \\( [:round :open]\n            \\) [:round :close]\n            \\{ [:figure :open]\n            \\} [:figure :close]))\n        (parse [str]\n          (map parse1 (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" str)))\n        (check1 [stack [b t]]\n          (cond (= t :open) (conj stack b)\n                (or (empty? stack) (not= (peek stack) b)) false\n                :otherwise (pop stack)))\n        (check [seq stack]\n          (if (empty? seq) (empty? stack)\n              (if-let [new-stack (check1 stack (first seq))]\n                (check (rest seq) new-stack)\n                false)))]\n  #(check (parse %) []))","problem":"177","user":"5294e44de4b02ebb4ef75016"},{"problem":"177","code":"(fn [xs]\n  (= '()\n     (reduce (fn [s v]\n               (let [open #(cons % s)\n                     close #(when (and (seq s)\n                                       (= % (first s)))\n                              (rest s))]\n                 (case v\n                   \\( (open \\( )\n                   \\[ (open \\[ )\n                   \\{ (open \\{ )\n                   \\) (close \\( )\n                   \\} (close \\{ )\n                   \\] (close \\[ )\n                   s)))\n             '()\n             xs)))","user":"4fcf1755e4b03432b189f40c"},{"problem":"177","code":"(fn [ss]\n  (let [left-map  (zipmap \"([{\" (range -3 0))\n        right-map (zipmap \"}])\" (range  1 4))]\n    (loop [stack []\n           [c & s] ss]\n      (if (nil? c)\n        (empty? stack)\n        (cond\n          (left-map c)  (recur (conj stack (left-map c)) s)\n          (right-map c) (if (and (not (empty? stack))\n                                 (zero? (+ (peek stack) (right-map c))))\n                          (recur (pop stack) s)\n                          (recur [\\ufade] []))\n          :else         (recur stack s))))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":"177","code":"(fn __ [_s]\n  (let [s (clojure.string/join \"\" (filter #{\\{ \\} \\[ \\] \\( \\)} _s))\n        f (fn f [s]\n            (let [f' (clojure.string/replace s #\"\\(\\)|\\{\\}|\\[\\]\" \"\")]\n              (if (= f' s) (empty? s) (f f'))))]\n    (f s)))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn [text]\n  (= []\n    (reduce (fn [scope c]\n              (cond \n                (nil? scope) nil\n                (contains? #{\\( \\[ \\{} c) (cons ({\\( \\), \\[ \\], \\{ \\}} c) scope)\n                (contains? #{\\) \\] \\}} c) (when (= (first scope) c) (rest scope))\n                :else scope\n               ))\n            ()\n            text)))","problem":"177","user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn [s]\n  (loop [s1 s stack '()]\n    (let [c (first s1)\n          brackets {\\( \\) \\[ \\] \\{ \\}}\n          openings (set (keys brackets))\n          closings (set (vals brackets))\n          new-stack (cond (openings c) (conj stack c)\n                        (closings c) (if (= (brackets (first stack)) c) (next stack) (conj stack :fail))\n                        :default stack)]\n      (cond (or (= :fail (first stack)) (and (not s1) (seq stack))) false\n            s1 (recur (next s1) new-stack)\n            :default true))))","problem":"177","user":"4daddc19c9a9d6ed4599dc57"},{"code":"(fn fun [coll]\n\t(= 1 (count\n\t\t(reduce \n\t\t\t#(do (println % %2) (cond \n\t\t\t\t(#{\\{ \\( \\[} %2) (conj % %2)\n\t\t\t\t(#{\\} \\) \\]} %2)\n\t\t\t\t\t(if (= ({\\} \\{ \\] \\[ \\) \\(} %2) (last %)) \n\t\t\t\t\t\t(vec (take (dec (count %)) %))\n\t\t\t\t\t\t[\\f \\F])\n\t\t\t\t:else (do (println %) %)))\n\t\t\t[\\f]\n\t\t\tcoll))))","problem":"177","user":"520242bae4b030ee0c5b26e3"},{"problem":"177","code":"(fn balanced? [s]\n  (let [pop-or-push (fn [brackets curr-bracket]\n                      (let [last-two-chars (str (peek brackets) curr-bracket)]\n                        (if (#{\"()\" \"[]\" \"{}\"} last-two-chars)\n                          (pop brackets)\n                          (conj brackets curr-bracket))))]\n    (->> (clojure.string/split s #\"\")\n         (filter #{\"(\" \")\" \"[\" \"]\" \"{\" \"}\"})\n         (reduce pop-or-push [])\n         (empty?))))","user":"52761edae4b03e8d9a4a74d4"},{"code":"(fn balanced?\n[x]\n(let [tokens (vec (clojure.string/replace x #\"[^\\(\\)\\[\\]\\{\\}]\" \"\"))\nbrackets { \\{ \\} \\( \\) \\[ \\]}\nstarting-bracket? (fn [x] (brackets x))\nmatching-bracket? (fn [a b] (= (brackets a) b))]\n(loop [stack '()\n[curr & more] tokens]\n(if (nil? curr)\n(empty? stack)\n(recur (if (or (starting-bracket? curr)\n(not (matching-bracket? (first stack) curr)))\n(conj stack curr)\n(rest stack))\nmore)))))","problem":"177","user":"5329cee2e4b09d4e7a9b551a"},{"problem":"177","code":"(fn balanced? [s]\n  (let [delim-map {\"(\" \")\" \"[\" \"]\" \"{\" \"}\"}\n        rev-delim-map (clojure.set/map-invert delim-map)]\n    (loop  [[d & rest-delims :as all] (re-seq #\"[\\{\\}\\(\\)\\[\\]]\" s)\n            stack []]\n      #_(prn stack)\n      ;; out of delimiters? stack should be empty too if input is balanced\n      (if (empty? all)\n        (empty? stack)\n        (if (delim-map d)\n          (recur rest-delims (conj stack d))\n          (if (= (peek stack) (rev-delim-map d))\n            (recur rest-delims (pop stack))\n            false))))))","user":"5c950334e4b048ec896c5a44"},{"problem":"177","code":"(fn [coll]\n(loop [brkts [] s coll f (first s)]\n    (cond (empty? s) (if (empty? brkts) true false) \n          (contains? #{\\( \\{ \\[ } f)\n              (recur (conj brkts f) (rest s) (first (rest s)))\n          (= \\) f) (if (= \\( (peek brkts)) (recur (pop brkts) (rest s) (first (rest s))) false)    \n          (= \\] f) (if (= \\[ (peek brkts)) (recur (pop brkts) (rest s) (first (rest s))) false)\n          (= \\} f) (if (= \\{ (peek brkts)) (recur (pop brkts) (rest s) (first (rest s))) false)\n          :else (recur brkts (rest s) (first (rest s))) )))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":"177","code":"(fn valid-bracket? [code]\n  (let [targets \"()[]{}\"\n        s-to-e (apply assoc nil targets)\n        e-to-s (clojure.set/map-invert s-to-e)\n        brackets (filter #(contains? (set targets) %) code)]\n    (loop [acc '()\n           head (first brackets)\n           remain (rest brackets)]\n      (cond \n       (nil? head) true\n       (and (empty? remain) (= (first acc) (get e-to-s head :not-sp))) true\n       (empty? remain) false\n       (contains? s-to-e head) (recur (cons head acc) (first remain) (rest remain))\n       (= (first acc) (get e-to-s head)) (recur (rest acc) (first remain) (rest remain))\n       :else false\n        ))))","user":"5478c4fee4b0c51c1f4d72c0"},{"code":"(fn brackets-match? [expr]\n  (let [opening {\\} \\{ \\] \\[ \\) \\(}]\n    (loop [s expr\n           stack ()]\n      (cond\n       (empty? s) (empty? stack)\n       (#{\\{ \\[ \\(} (first s)) (recur (rest s) (conj stack (first s)))\n       (#{\\} \\] \\)} (first s)) (if (= (opening (first s)) (first stack))\n                                 (recur (rest s) (rest stack))\n                                 false)\n       :else (recur (rest s) stack)))))","problem":"177","user":"521b9f92e4b0c4ef0be8304c"},{"problem":"177","code":"(fn b-brackets [s] \n  (let [b { \\{ \\} \\} \\{ \\] \\[ \\[ \\] \\) \\( \\( \\) }\n        b-seq (filter b s)]\n     (letfn [(is-legal [acc c] \n              (let [[r & more] acc]\n                (if (= (b c) r) more (conj acc c))))]\n        (empty? (reduce is-legal '() b-seq)))))","user":"538e29d1e4b0b51d73faae80"},{"problem":"177","code":"#(and (> (count %) 12) (not (= (count %) 53)))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":"177","code":"(letfn [(add-bracket [chr coll] (conj (vec coll) chr))\n        (maybe-remove-pair-bracket\n         [chr-in chr-pair coll]\n         (if (= chr-pair (last coll))\n           (drop-last coll)\n           (add-bracket chr-in coll)))]\n  (let [brackets {\\( (partial add-bracket \\()\n                  \\[ (partial add-bracket \\[)\n                  \\{ (partial add-bracket \\{)\n                  \\) (partial maybe-remove-pair-bracket \\) \\()\n                  \\] (partial maybe-remove-pair-bracket \\] \\[)\n                  \\} (partial maybe-remove-pair-bracket \\} \\{)}]\n    (fn [s]\n      (empty?\n       (reduce (fn [r x]\n                 (if-let [b-fn (get brackets x)]\n                   (b-fn r)\n                   r))\n               []\n               s)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":"177","code":"#(let [c {\\( \\) \\[ \\] \\{ \\}}]\n   (empty? (reduce (fn [[v & w :as x] e] (if (= e (c v)) w (conj x e))) '()\n                   (filter (set (flatten (seq c))) %))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn bal? [s]\n  (let [pairs { \\[ \\] \\( \\) \\{ \\} }\n        opening pairs\n        closing (apply hash-set (vals pairs))]\n    (loop [chs (seq s)\n           stack '()]\n      (if (empty? chs)\n        (empty? stack)\n        (let [[c & morechs] chs]\n          (if (and (closing c)\n              (or (empty? stack)\n                  (not= c (pairs (peek stack)))))\n            false\n            (recur morechs (cond\n                             (opening c) (conj stack c)\n                             (closing c) (pop stack)\n                             :default stack))))))))","problem":"177","user":"52d3f666e4b09f7907dd1327"},{"problem":"177","code":"(fn bal [str]\n   (loop [stack [] [char & r] str]\n     (if (nil? char)\n       (empty? stack)\n       (cond\n         (#{ \\( \\{ \\[ } char)\n         (recur (conj stack ({ \\( \\) \\{ \\} \\[ \\] } char)) r)\n\n         (#{ \\) \\} \\] } char)\n         (let [prev (peek stack)]\n           (if (= prev char)\n             (recur (pop stack) r)\n             false))\n\n         :else\n         (recur stack r)))))","user":"58b51e05e4b0ebc645576d4c"},{"problem":"177","code":"(fn myf [s]\n  (let [s (map int s)]\n    (loop [s s, lst ()]\n      (if (empty? s) (if (empty? lst) true false)\n        (cond (or (= (first s) 123) (= (first s) 40) (= (first s) 91)) (recur (rest s) (conj lst (first s)))\n              (= (first s) 125) (if (= (first lst) 123) (recur (rest s) (rest lst)) false)\n              (= (first s) 93) (if (= (first lst) 91) (recur (rest s) (rest lst)) false)\n              (= (first s) 41) (if (= (first lst) 40) (recur (rest s) (rest lst)) false)\n              :else (recur (rest s) lst))))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":"177","code":"; For some reason 4clojure doesn't allow the awesome 'reduced' :(\n#_(fn check-pairs [string]\n  (let [pairs {\\) \\(  \\} \\{  \\] \\[}\n        closes (set (keys pairs))\n        opens  (set (vals pairs))\n        result (reduce (fn [stack el]\n                         (condp contains? el\n                           opens  (cons el stack)\n                           closes (if (= (pairs el) (first stack))\n                                    (rest stack)\n                                    (reduced false))\n                           stack))\n                       ()\n                       string)]\n    (and result (empty? result))))\n\n;; Quick fix:\n(fn check-pairs [string]\n  (let [pairs {\\) \\(  \\} \\{  \\] \\[}\n        closes (set (keys pairs))\n        opens  (set (vals pairs))\n        result (reduce (fn [stack el]\n                         (when stack\n                           (condp contains? el\n                             opens  (cons el stack)\n                             closes (if (= (pairs el) (first stack))\n                                      (rest stack)\n                                      false)\n                             stack)))\n                       ()\n                       string)]\n    (and result (empty? result))))","user":"54d341f7e4b0e8a36923e603"},{"problem":"177","code":"(fn [x]\n  (let [p {\\[ \\] \\{ \\} \\( \\) }\n        v #{\\] \\} \\)}]\n    (empty? (reduce #(if (p %2) (conj % %2) (if (v %2) (if (= (p (peek %)) %2) (pop %) [%2]) %)) [] x ))))","user":"5382704be4b06839e8705ed4"},{"problem":"177","code":"(fn [text]\n  (let [brackets {\\( \\) \\{ \\} \\[ \\]}\n        right-brackets (set (vals brackets))]\n    (loop [q []\n           [c & r] text]\n      (if-not c\n        (empty? q)\n        (cond\n         (contains? brackets c) (recur (conj q c) r)\n         (not (contains? right-brackets c)) (recur q r)\n         (= c (brackets (peek q))) (recur (pop q) r)\n         :else false)))))","user":"5cb41c40e4b026601754b911"},{"problem":"177","code":"(fn b? [s]\n  (letfn [(open? [p] (>= (.indexOf [\"(\" \"{\" \"[\"] p) 0))\n          (close? [p] (>= (.indexOf [\")\" \"}\" \"]\"] p) 0))\n          (match? [p1 p2] (let [s (str p1 p2)]\n                            (some #(= s %) [\"()\" \"{}\" \"[]\"])))]\n    (let [s2 (re-seq #\"[\\{\\[\\(\\)\\]\\}]\" s)]\n      (if (nil? s2) true\n          (do\n            (loop [rm (rest s2), acc (vector (first s2))]\n              (let [f (first rm), r (rest rm)]\n                (cond (and (empty? rm) (empty? acc)) true\n                      (open? f) (recur r (conj acc f))\n                      (and (close? f) (match? (last acc) f)) (recur r (pop acc))\n                      :else false))))))))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [s] (loop [the-string s squares [] rounds [] curlys [] i 0]\n          (println squares rounds curlys)\n            (if (nil? the-string)\n              (every? empty? [squares rounds curlys])\n              (let [c (first the-string) r (next the-string)]\n                (if (= c \\[) \n                   (recur r (conj squares i) rounds curlys (inc i))\n                   (if (= c \\])\n                     (if (empty? squares) false (if (< (peek squares) (max (or (last rounds) -1) (or (last curlys) -1))) false\n                        (recur r (pop squares) rounds curlys (inc i))))\n\t\t\t\t\t (if (= c \\()\n                       (recur r squares (conj rounds i) curlys (inc i))\n                       (if (= c \\))\n                         (if (empty? rounds) false (if (< (peek rounds) (max (or (last squares) -1) (or (last curlys) -1))) false\n                            (recur r squares (pop rounds) curlys (inc i))))\n                         (if (= c \\{)\n                           (recur r squares rounds (conj curlys i) (inc i))\n                           (if (= c \\})\n                             (if (empty? curlys) false (if (< (peek curlys) (max (or (last squares) -1) (or (last rounds) -1))) false\n                                (recur r squares rounds (pop curlys) (inc i))))\n                             (recur r squares rounds curlys (inc i))\n                           )\n                         )\n                       )\n                    )\n                 )\n            )))))","problem":"177","user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [s] \n  (let [ brackets (seq \"[]{}()\"),\n         pairs (partition 2 brackets),\n         open-brackets (set (map first pairs)),\n         close-match (apply array-map (flatten (map reverse pairs)))\n         ]\n    (loop [ text (filter (set brackets) s) stack [] ]\n      (cond\n       (not (seq text)) (not (seq stack))\n       (contains? open-brackets (first text)) (recur (rest text) (cons (first text) stack))\n       (not (seq stack)) false\n       (= (first stack) (get close-match (first text))) (recur (rest text) (rest stack))\n       :else false\n       )\n      )\n    )\n  )","problem":"177","user":"523f0bbfe4b01c266ffa7f91"},{"code":"#(empty?\n  (reduce (fn [a c] (if (#{\\( \\[ \\{} c)\n                      (conj a c)\n                      (if (= ({\\) \\( \\] \\[ \\} \\{} c 0) (peek a))\n                        (pop a)\n                        (if (#{\\) \\] \\}} c)\n                          (conj a c)\n                          a))))\n          [] %))","problem":"177","user":"4ef49c2c535dced4c769f238"},{"code":"#(loop [s (clojure.string/replace % #\"[^\\{|\\}|\\[|\\]|\\(|\\)]\" \"\")]\n         (if (empty? s)\n           true\n           (let [ns (clojure.string/replace s #\"\\{\\}|\\[\\]|\\(\\)\" \"\")]\n             (if (= ns s)\n                  false\n                  (recur ns)))))","problem":"177","user":"4daa374930acd6ed13482a68"},{"code":"(fn [string]\n  (let [dmap {\\{ \\} \\[ \\] \\( \\)}\n        dset (set (concat (keys dmap) (vals dmap)))\n        ds (->> string seq (filter dset))\n        opens (set (keys dmap))\n        trans (fn [[e] stack] (cond\n                              ;; closes open\n                              (= e (dmap (peek stack))) (pop stack) \n                              ;; pushes new open\n                              (opens e) (conj stack e)))]\n    (cond\n     (empty? ds) true\n     (not (opens (first ds))) false\n     :else (loop [rem ds\n                  stack []]\n             (when stack               ; catches early failure in cond\n               (if (empty? rem)\n                 (empty? stack)\n                 (recur (rest rem) (trans rem stack))))))))","problem":"177","user":"5392b849e4b0b51d73faaeb1"},{"problem":"177","code":"(fn \t[str]\n  (letfn [(bal [stack [c & cs]]\n            (let [b {\\) \\( \\} \\{ \\] \\[}]\n              (cond\n                (nil? c)       stack\n                (#{\\( \\{ \\[} c) (bal (conj stack c) cs)\n                (#{\\) \\} \\]} c) (when (= (peek stack) (b c))\n                                  (bal (pop stack) cs))\n                :otherwise (bal stack cs))))]\n    (= [] (bal [] str))))","user":"5458c74de4b01be26fd74623"},{"code":"(fn balanced-parens? [s]\n  (let [fclosures {\"(\" \")\" \"{\" \"}\" \"[\" \"]\"}\n        rclosures {\")\" \"(\" \"}\" \"{\" \"]\" \"[\"}\n        f\n        (fn [stack s closures]\n          (if (empty? s) (empty? stack)\n          (let [i (str (first s))]\n          (recur \n           (cond \n             (some #(= % i) (keys closures))\n            (conj stack i)\n             (= i (get closures (first stack)))\n            (drop 1 stack)\n            0 stack)\n           (rest s) closures))))]\n    (and (f '() s fclosures) (f '() (reverse s) rclosures))))","problem":"177","user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn _ [x]         \n    (let [opposite (fn [s]\n                    (case s\n                      \\] \\[\n                      \\) \\(\n                      \\} \\{\n                      s))]\n      (= []\n        (loop [f (first x) s (rest x) l []]\n          (if (nil? f)\n              l\n\t      (cond\n\t        (= \\[ f) (recur (first s) (rest s) (conj l \\[))\n\t        (= \\( f) (recur (first s) (rest s) (conj l \\())\n\t        (= \\{ f) (recur (first s) (rest s) (conj l \\{))\n\t        (= (opposite f) (peek l)) (recur (first s) (rest s) (pop l))\n\t        (= \\] f) (recur (first s) (rest s) (conj l \\]))\n\t        (= \\) f) (recur (first s) (rest s) (conj l \\)))\n\t        (= \\} f) (recur (first s) (rest s) (conj l \\}))\n\t\t:else (recur (first s) (rest s) l)))))))","problem":"177","user":"4f038567535dcb61093f6b0c"},{"problem":"177","code":"(partial (fn b [stack tail]\n           (if (empty? tail)\n             (empty? stack)\n             (let [[c & cs] tail]\n               (cond\n                ((set \"([{\") c) (b (conj stack c) cs)\n                ((set \"}])\") c) (and (= c ({\\( \\), \\[ \\], \\{ \\}} (peek stack)))\n                                     (b (pop stack) cs))\n                :else (b stack cs)))))\n\n         [])","user":"4f5eda39e4b0030a34fb2b56"},{"problem":"177","code":"(fn balanced?\n  ([text] (balanced? [] (clojure.string/split text #\"\")))\n  ([stack remaining]\n    (let [pairs #{\"()\" \"[]\" \"{}\"}\n          part-of-pair #(->> pairs (map %) (map str) set)\n          opening? #((part-of-pair first) %)\n          closing? #((part-of-pair last) %)\n          closes? #(pairs (str %1 %2))\n          current-char (first remaining)]\n      (if (empty? remaining)\n        (empty? stack)\n        (if (opening? current-char)\n          (balanced? (conj stack current-char) (rest remaining))\n          (if (closing? current-char)\n            (if (closes? (peek stack) current-char)\n              (balanced? (pop stack) (rest remaining))\n              false)\n            (balanced? stack (rest remaining))))))))","user":"52bdd135e4b07a9af579230a"},{"problem":"177","code":"(fn valid-parens?\n  [s]\n  (loop [[ch & chs] s stack []]\n    (if (nil? ch)\n      (empty? stack)\n      (case ch\n        (\\( \\[ \\{) (recur chs (conj stack ch))\n        \\) (if (= (peek stack) \\()\n             (recur chs (pop stack))\n             false)\n        \\] (if (= (peek stack) \\[)\n             (recur chs (pop stack))\n             false)\n        \\} (if (= (peek stack) \\{)\n             (recur chs (pop stack))\n             false)\n        (recur chs stack)))))","user":"52ea025ae4b09f7907dd14b5"},{"code":"(fn [s]\n  (let [dict {\\( 1 \\) 9\n              \\[ 2 \\] 8\n              \\{ 3 \\} 7}]\n    (loop [[ft & rt] (vec s)\n           stk []]\n      (if (nil? ft)\n        (empty? stk)\n        (if (contains? dict ft)\n          (let [a (dict ft)\n                b (dict (last stk))]\n            (if (< a 5)\n              (recur rt (conj stk ft))\n              (if (nil? b)\n                false\n                (if (= 10 (+ a b))\n                  (recur rt (pop stk))\n                  false))))\n          (recur rt stk))))))","problem":"177","user":"51944aaae4b0142f60b4aedc"},{"problem":"177","code":"#( = [] (reduce \n\t(fn [coll v]\n\t\t(let [m {\\( \\) \\[ \\] \\{ \\} }]\n\t\t\t(case v\n\t\t\t\t( \\( \\[ \\{) (conj coll (m v) )\n\t\t\t\t(\\) \\] \\} )\t(when (= v (last coll)) (pop coll)) \n\t\t\t\tcoll\n\t\t\t\t))) [] % )\n\t\t\t\t)","user":"54be7e93e4b0ed20f4ff6eed"},{"problem":"177","code":"(fn [s]\n    (let [m {\\) \\( \\] \\[ \\} \\{}]\n    (empty?\n    (reduce (fn [P c]\n                        (cond ((set (vals m)) c) (conj P c)\n                              (m c) (if (= (last P) (m c)) (pop P) (conj P \\F))\n                              :else P\n                        )\n                    )\n                    [] s))))","user":"559c13c5e4b066d22e731f61"},{"problem":"177","code":"#(empty? (reduce (fn [a e]\r\n                   (prn a)\r\n                   (cond\r\n                     (#{ \\( \\[ \\{ } e) (conj a e)\r\n                     (and (= e \\)) (= (peek a) \\()) (pop a)\r\n                     (and (= e \\]) (= (peek a) \\[)) (pop a)\r\n                     (and (= e \\}) (= (peek a) \\{)) (pop a)\r\n                     (and (empty? a) (#{ \\) \\] \\} } e)) (conj a e)\r\n                     :else a))\r\n                 [] %))","user":"5f2c02d1e4b033932238a65f"},{"problem":"177","code":"(letfn [(test-ch [c]\n  (let [m-pch\n   {\\( {:par :round\n        :open? true},\n    \\) {:par :round\n        :open? false},\n    \\[ {:par :square\n        :open? true},\n    \\] {:par :square\n        :open? false},\n    \\{ {:par :curly\n        :open? true},\n    \\} {:par :curly\n        :open? false} }]\n   (get m-pch c\n    {:par false} )))\n (loc-par-ok? [acc ss]\n  (if (empty? ss)\n   (if (empty? acc) true false)\n   (let [tm (test-ch (first ss))]\n    (if-not (:par tm)\n     (loc-par-ok? acc (rest ss))\n     (if (:open? tm)\n      (loc-par-ok? (conj acc (:par tm)) (rest ss))\n      (if (or\n           (empty? acc)\n           (not= (:par tm)\n              (peek acc)) )\n       false\n       (loc-par-ok?\n        (pop acc)\n        (rest ss)) )))\n )))\n (par-ok? [s] (loc-par-ok? [] s))] \n par-ok?)","user":"57f9011ee4b0d3187e900935"},{"problem":"177","code":"(fn [bracket-str]\n  (empty? (let\n   [brackets [#{\\(\\)}\n              #{\\[\\]}\n              #{\\{\\}}]\n    starting #{\\(\\{\\[}\n    all (set (mapcat seq brackets))\n    match (fn [bracket]\n             (first\n              (disj\n               (first\n                (filter\n                 #(contains?\n                   %\n                   bracket)\n                 brackets))\n               bracket)))\n    balanced?\n     (fn [li]\n       (reduce\n        (fn [stack i]\n          (if\n           (contains? starting i)\n           (conj stack i)\n           (if\n            (=\n             (peek stack)\n             (match i))\n            (pop stack)\n            [:failed])))\n        []\n        li))]\n   (->>\n    bracket-str\n    (filter\n     #(contains?\n       all\n       %))\n    balanced?))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn balanced? [s]\n  (let [p {\\( \\) \\[ \\] \\{ \\}}\n        a (set \"()[]{}\")]\n    (empty?\n      (reduce (fn [[t & b :as stack] s]\n                (cond (= (p t) s) b\n                      (a s) (conj stack s)\n                      :else stack))\n              () s))))","problem":"177","user":"5032b066e4b00c0952a257ea"},{"problem":"177","code":"(fn parse [s]\n  (let [chs (seq s)\n        p (fn [[f & rst] stack]\n            (cond\n              (= f \\{) (recur rst (conj stack \\}))\n              (= f \\[) (recur rst (conj stack \\]))\n              (= f \\() (recur rst (conj stack \\)))\n              (= f \\}) (if (= (peek stack) f) (recur rst (pop stack)) false)\n              (= f \\]) (if (= (peek stack) f) (recur rst (pop stack)) false)\n              (= f \\)) (if (= (peek stack) f) (recur rst (pop stack)) false)\n              (nil? f) (empty? stack)\n              :default (recur rst stack)))]\n    (p chs [])))","user":"54684c3be4b00cfc9eacc139"},{"problem":"177","code":"(fn check [s]\n  (loop [s s\n         stack []]\n    (cond (empty? s) (empty? stack)\n          (#{\\(\\[\\{} (first s)) (recur (rest s) (conj stack (first s)))\n          (#{\\)\\]\\}} (first s)) (if (not= (peek stack) ({\\) \\(, \\] \\[, \\} \\{} (first s))) false\n                                    (recur (rest s) (pop stack))) \n          :else (recur (rest s) stack))))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":"177","code":"(fn [s]\n  (loop [p s]\n    (let [c (clojure.string/replace p #\"[^\\(\\)|\\[\\]|\\{\\}]|\\(\\)|\\[\\]|\\{\\}\" \"\")]\n      (if (= p c)\n        (not (re-find #\"[\\(\\)\\{\\}\\[]\" c))\n        (recur c)))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":"177","code":"(fn [input]\n  (let [start-delims #{\\( \\[ \\{}\n        end-delims   #{\\) \\] \\}}\n        start->end (->> (map\n                         #(vector %1 %2)\n                         start-delims\n                         end-delims)\n                        (into {}))\n        g (fn [stack delim-a]\n            (when-let [delim-b (peek stack)]\n              (and (-> start->end\n                       (get delim-b)\n                       (= delim-a))\n                   (pop stack))))\n        f (fn [[chr & chrs] stack]\n            (if chr\n              (let [stack (cond\n                            (contains? start-delims chr) (conj stack chr)\n                            (contains? end-delims   chr) (g stack chr)\n                            :else                        stack)]\n                (and stack (recur chrs stack)))\n              (empty? stack)))]\n    (f input [])))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":"177","code":"(fn bb\n  [i]\n  (let [o {\\{ \\} \\[ \\] \\( \\)} c {\\} \\{ \\] \\[ \\) \\(}]\n   (loop [s [] [h & t] (filter #(or (contains? o %) (contains? c %)) i)]\n     (if (nil? h)\n      (empty? s)\n      (if (contains? o h)\n        (recur (conj s h) t)\n        (let [l (peek s)]\n          (if (or (nil? l) (not= l (c h)))\n            false\n            (recur (pop s) t))))))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [s]\n    (if (= (reduce (fn [stack c]\n                     (let [m {\\) \\( \n                              \\] \\[ \n                              \\} \\{}\n                           v (m c)]\n                       (if v\n                         (if (= v (first stack)) (pop stack) nil)\n                         (conj stack c))\n                       )) () (filter #((set \"()[]{}\") %) s)) ()) true false))","problem":"177","user":"506cad7de4b0a302964c548e"},{"problem":"177","code":"(fn paired? [string]\n  (loop [in string\n         stack '()]\n    (if-let [[c & cs] (seq in)]\n      (case c\n        \\( (recur cs (conj stack :round))\n        \\[ (recur cs (conj stack :square))\n        \\{ (recur cs (conj stack :curly))\n        \\) (if (= :round  (peek stack)) (recur cs (pop stack)) false)\n        \\] (if (= :square (peek stack)) (recur cs (pop stack)) false)\n        \\} (if (= :curly  (peek stack)) (recur cs (pop stack)) false)\n        (recur cs stack))\n      (empty? stack))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":"177","code":"(fn [s]\n      (let [m {\\[ \\] \\{ \\} \\( \\)}]\n       (empty? (reduce (fn [a c] (condp #(some #{%2} (%1 m)) c\n                                  keys (cons c a)\n                                  vals (if (= c (m (first a))) (rest a) [:error])\n                                  a)) [] (seq s)))))","user":"51e28063e4b08e53a149f0f2"},{"problem":"177","code":"(fn w [s]\n  (let [open-to-close {\\{ \\}\n                           \\( \\)\n                           \\[ \\]}\n        opening (set (map first open-to-close))\n        closing (set (map second open-to-close))\n        wellformed (fn [s stack]\n                     (if (= (count s) 0)\n                       (= (count stack) 0)\n                       (let [[h & t] s]\n                         (cond\n\n                           (opening h)\n                           (recur t (concat [(open-to-close h)] stack))\n\n                           (closing h)\n                           (let [[sh & st] stack]\n                             (if (= sh h)\n                               (recur t st)\n                               false))\n\n                           :else\n                           (recur t stack)))\n                       ))]\n    (wellformed s [])))","user":"532b43c3e4b09d4e7a9b5531"},{"problem":"177","code":"(fn [str]\n  (let [brackets [\\( \\[ \\{ \\) \\] \\}]\n        input (filter #(not (= -1 (.indexOf brackets %))) str)]\n    (if (empty? input)\n      true\n      (loop [stack (list (first input))\n             coll (rest input)]\n        (if (empty? coll)\n          (empty? stack)\n          (let [fc (first coll)]\n            (if (not (= -1 (.indexOf (take 3 brackets) fc)))\n              ;; found opening\n              (recur (conj stack fc)\n                     (rest coll))\n              ;; found closing\n              (if (= (first stack) ({\\) \\(, \\] \\[, \\} \\{} fc))\n                (recur (rest stack) ; closing and opening (in stack) matched\n                       (rest coll))\n                false))))))))","user":"532bce35e4b09d4e7a9b5536"},{"code":"(fn balance-brack [x]\n  (let [t\n        {\\] \\[\n         \\} \\{\n         \\) \\(}\n        ]\n    (loop [s x acc '()]\n      (print acc \"\\n\")\n      (cond\n       (empty? s) (if (empty? acc) true false)\n       (re-find #\"[\\[{\\(]\" (str (first s))) (recur (rest s) (cons (first s) acc))\n       (re-find #\"[\\]}\\)]\" (str (first s))) (if (= (first acc) (t (first s)))\n                                              (recur (rest s) (rest acc) ) false)\n       :else (recur (rest s) acc)))))","problem":"177","user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn check-brackets [in]\n  (let [openers (apply sorted-set \"{[(\")\n        closers (apply sorted-set \"}])\")\n        pairs   (zipmap openers closers)]\n    (loop [[c & cs] in, stack []]\n      (cond\n        (nil? c) (empty? stack)\n        (openers c) (recur cs (conj stack (pairs c)))\n        (closers c) (if (= c (peek stack))\n                      (recur cs (pop stack)))\n        :else (recur cs stack)))))","problem":"177","user":"4f6160a7e4b0defedf855fbe"},{"problem":"177","code":"(letfn [(drop-pairs [s] (-> s\n                             (clojure.string/replace #\"\\[\\]\" \"\")\n                             (clojure.string/replace #\"\\(\\)\" \"\")\n                             (clojure.string/replace #\"\\{\\}\" \"\")))\n         (drop-nonbrace [s] (clojure.string/replace\n                             s\n                             #\"[^\\[\\]\\(\\)\\{\\}]\"\n                             \"\"))]\n   (fn [s]\n       (->> s\n            drop-nonbrace\n            (iterate drop-pairs)\n            (partition 2 1)\n            (drop-while #(not= (count (first %))\n                               (count (second %))))\n            ffirst\n            empty?)))","user":"5d4b2155e4b0776584bd6f28"},{"problem":"177","code":"(fn [xs]\n  (let [bpairs {\\[ \\] \\( \\) \\{ \\}}\n        bfirst (into #{} (keys bpairs))\n        blast  (into #{} (vals bpairs))]\n    (loop [stack [] in xs]\n      (if (empty? in)\n        (empty? stack)\n        (let [x (first in)]\n          (cond\n            (contains? bfirst x) (recur (conj stack (get bpairs x)) (rest in))\n            (contains? blast x) (if (not= (peek stack) x) false (recur (pop stack) (rest in)))\n            :else (recur stack (rest in))))))))","user":"564a5a09e4b0284900eef656"},{"code":"#(let [b {\\{ \\} \\[ \\] \\( \\)} v (set (vals b))]\n     (loop [[c & y] % [t & p :as s] []]\n       (cond\n        (not c) (not t)\n        (b c) (recur y (cons (b c) s))\n        (v c) (when (= c t) (recur y p))\n        true (recur y s))))","problem":"177","user":"4eb97b2e535dfed6da9c6d54"},{"problem":"177","code":"(fn [string]\n  (let [open->close-bracket {\\[ \\]\n                             \\( \\)\n                             \\{ \\}}]\n    (loop [brackets (filter (set (concat (keys open->close-bracket)\n                                         (vals open->close-bracket)))\n                            string)\n           open-bracket-stack '()]\n      (letfn [(next-bracket []\n                (first brackets))\n              (open-bracket? [bracket]\n                (open->close-bracket bracket))\n              (matches-open-bracket? [bracket]\n                (= bracket (open->close-bracket (peek open-bracket-stack))))]\n\n        (cond (empty? brackets)\n              (empty? open-bracket-stack)\n\n              (open-bracket? (next-bracket))\n              (recur (rest brackets)\n                     (conj open-bracket-stack (next-bracket)))\n\n              (matches-open-bracket? (next-bracket))\n              (recur (rest brackets)\n                     (pop open-bracket-stack))\n\n              :else false)))))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn balanced? [s]\n  (loop [s (clojure.string/replace s #\"[^\\[\\]\\(\\)\\{\\}]\" \"\")]\n    (if (zero? (count s))\n      true\n      (let [new-s (clojure.string/replace s #\"(\\[\\]|\\(\\)|\\{\\})\" \"\")]\n        (if (= s new-s)\n          false\n          (recur new-s))))))","problem":"177","user":"539a2901e4b0b51d73faaf0f"},{"problem":"177","code":"(fn f [input-string]\n    (let [char-map (zipmap \")]}\" \"([{\")]\n        (loop [chars (seq input-string) stk []]\n            (let [c (first chars)]\n                (cond\n                    (nil? c)  ;; seq returns a null-terminated char sequence.\n                        (empty? stk)\n                    (not= (.indexOf \"([{\" (int c)) -1)\n                        (recur (rest chars) (conj stk c))\n                    (not= (.indexOf \")]}\" (int c)) -1)\n                        (if (= (char-map c) (peek stk))\n                            (recur (rest chars) (pop stk))\n                            false\n                        )\n                    :else\n                        (recur (rest chars) stk)\n                )\n            )\n        )\n    )\n)","user":"51f09f3de4b0274c496158d7"},{"problem":"177","code":"(fn brackets-matched?\n   ([str] (brackets-matched? () (seq str)))\n   ([stack [x & xs]]\n    (let [openbracket { \\{ \\} \\( \\) \\[ \\] }\n          closebracket #{ \\} \\) \\] } ]\n    (cond\n      (nil? x)  (empty? stack)\n      (openbracket x)  (recur (conj stack (openbracket x)) xs)\n      (closebracket x) (if (= (first stack) x)\n                         (recur (rest stack) xs)\n                         false)\n      :else (recur stack xs)))))","user":"55e7d06ee4b050e68259b496"},{"problem":"177","code":"(fn balance-bracket [a]\n  (let [ob #{\\{ \\[ \\(} cb #{\\} \\] \\)} mb {\\} \\{ \\] \\[ \\) \\(}]\n    (loop [stack (list) vs a]\n      (if (empty? vs)\n        (empty? stack)\n        (let [v (first vs)]\n          (cond (contains? ob v)\n                (recur (conj stack v) (rest vs))\n                (contains? cb v)\n                (if (= (get mb v) (first stack))\n                  (recur (rest stack) (rest vs))\n                  false)\n                :else\n                (recur stack (rest vs))))))))","user":"5843b95de4b089d5ab817e3f"},{"problem":"177","code":"(fn [sequnc]\n  (let [bmap {\"}\" \"{\" \")\" \"(\" \"]\" \"[\"}\n        closing? (fn [b] (#{\"}\" \")\" \"]\"} b))\n        opening? (fn [b] (#{\"{\" \"(\" \"[\"} b))]\n    (loop [s sequnc\n           stack '()]\n      (if (empty? s)\n        (empty? stack)\n        (let [b (str (first s))]\n          (if (closing? b)\n            (if-not (= (first stack) (get bmap b))\n              false\n              (recur (rest s) (rest stack)))\n            (if-not (opening? b)\n              (recur (rest s) stack)\n              (recur (rest s) (conj stack b)))))))))","user":"6066266de4b069485764ddd2"},{"problem":"177","code":"(fn [s]\n        (let [matchfn (fn [stack c]\n        (let [paren-literals #{\\( \\) \\[ \\] \\{ \\}}\n              open-literals {\\( \\) \\[ \\] \\{ \\}}\n              close-literals #{\\) \\] \\}}]\n          (cond\n            (open-literals c) [true (conj stack c)]\n            (close-literals c) (if (= c (open-literals (peek stack)))\n                                 [true (pop stack)]\n                                 [false stack])\n            :default [true stack])))\n              [tr stack] (reduce (fn [[t stack] c]\n                           (if t\n                             (matchfn stack c)\n                             [false stack])) [true []] s)]\n          (and tr (= 0 (count stack)))))","user":"58949f8de4b00487982d525e"},{"problem":"177","code":"(fn my-balancing-brackets\n  [sentence]\n  (letfn [(match []\n            (reduce #(if (and (= (first %1) ({\\} \\{ \\) \\( \\] \\[} %2))\n                              ((comp not nil?) (first %1)))\n                      (rest %1)\n                      (conj %1 %2)\n                      ) '() (filter #{\\} \\{ \\) \\( \\] \\[} (seq sentence))))]\n    (empty? (match))))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":"177","code":"#(loop [s % o '() b { \\[ \\] \\( \\) \\{ \\} }]\n   (cond (empty? s) (empty? o)\n         ((set (keys b)) (first s)) (recur (rest s) (conj o (first s)) b)\n         ((set (vals b)) (first s)) (and (seq o)\n                                         (= (first s) (b (peek o))) \n                                         (recur (rest s) (pop o) b))\n         :default (recur (rest s) o b)))","user":"55f20e4be4b06e875b46ce40"},{"problem":"177","code":"(fn brackets-balanced?\n  [s]\n  (let [pairs {\\[ \\], \\( \\), \\{ \\}}\n        opening-brackets (set (keys pairs))\n        closing-brackets (set (vals pairs))]\n    (loop [open-brackets []\n          [c & remaining] s]\n      (cond\n        (nil? c)\n        (empty? open-brackets)\n\n        (opening-brackets c)\n        (recur (conj open-brackets c) remaining)\n\n        (closing-brackets c)\n        (if (= c (pairs (peek open-brackets)))\n          (recur (pop open-brackets) remaining)\n          false)\n\n        :else\n        (recur open-brackets remaining)))))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn [s]\n          (empty?\n           (loop [s (clojure.string/replace s #\"[^\\(\\)\\{\\}\\[\\]]\" \"\")]\n             (let [r (clojure.string/replace s #\"\\(\\)|\\{\\}|\\[\\]\" \"\")]\n               (if (= r s) s (recur r))))))","problem":"177","user":"4ee26f01535d10e5ff6f5368"},{"problem":"177","code":"(fn [s]\n    (nil? (seq (reduce\n                 (fn [v c]\n                   (if (some #{c} #{\\( \\[ \\{})\n                     (conj v c)\n                     (if (some #{c} #{\\) \\] \\}})\n                       (if (= ({\\) \\( \\} \\{ \\] \\[} c) (peek v))\n                         (vec (butlast v))\n                         (conj v :x)\n                         )\n                       v)))\n                 [] s))))","user":"590b055ae4b047aa04b199c9"},{"problem":"177","code":"#(let [matched {\"}\" \"{\", \")\" \"(\", \"]\" \"[\"}]\n    (loop [todo (filter #{\"{\" \"}\" \"(\" \")\" \"[\" \"]\"} (.split #\"\" %))\n           st ()]\n      (if (seq todo)\n        (let [cur (first todo)]\n          (if (= (first st) (get matched cur :not-found))\n            (recur (rest todo) (rest st))\n            (recur (rest todo) (cons cur st))))\n        (empty? st))))","user":"4e521cef535d302ef430da6d"},{"problem":"177","code":"(fn [s]\n  (loop [sparts (clojure.string/split s #\"\") brackets '()]\n    (if (and (empty? sparts) (empty? brackets))\n      true\n      (if (empty? sparts)\n        false\n        (if (contains? #{\"}\" \")\" \"]\"} (first sparts))\n          (if (not (or (and (= (first brackets) \"{\") (= (first sparts)\"}\"))\n                  (and (= (first brackets) \"(\") (= (first sparts)\")\")) \n                  (and (= (first brackets) \"[\") (= (first sparts)\"]\"))))\n            false\n            (recur (rest sparts) (rest brackets)))\n          (if (contains? #{\"{\" \"(\" \"[\"} (first sparts))\n            (recur (rest sparts) (conj brackets (first sparts)))\n            (recur (rest sparts) brackets)))))))","user":"59368ccae4b02506e01a297a"},{"code":"#(loop [[b & s] % [c & r :as a] []]\n  (cond\n    (nil? b) (empty? a)\n    ((set \"([{\") b) (recur s (cons b a))\n    (= c ((zipmap \")]}\" \"([{\") b)) (recur s r)\n    ((set \")]}\") b) false\n    :else (recur s a)))","problem":"177","user":"528652fbe4b0239c8a67ae14"},{"code":"(fn problem-177\n  [s]\n  (let [ob #{\"(\" \"[\" \"{\"}\n        cb {\"(\" \")\" \"[\" \"]\" \"{\" \"}\"}]\n    (loop [xs (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" s)\n           sk []]\n      (if (empty? xs)\n        (if (empty? sk) true false)\n        (recur (rest xs)\n               (if (contains? ob (first xs))\n                 (conj sk (first xs))\n                 (if (= (get cb (peek sk)) (first xs))\n                   (pop sk)\n                   (conj sk (first xs)))))))))","problem":"177","user":"4f2942ace4b0d6649770a01e"},{"problem":"177","code":"(fn bal [source]\n  (loop\n      [stack ()\n       s (filter #(contains? #{\\( \\{ \\[ \\) \\} \\]} %) (vec source))]\n    (cond\n      (and (empty? s)) (empty? stack)\n      (contains? #{\\( \\{ \\[} (first s)) (recur (cons (first s) stack) (rest s))\n      (or (and (= (first s) \\) ) (and (not (empty? stack)) (= (first stack) \\())) \n          (and (= (first s) \\} ) (and (not (empty? stack)) (= (first stack) \\{)))\n          (and (= (first s) \\] ) (and (not (empty? stack)) (= (first stack) \\[)))) (recur (rest stack) (rest s))\n      true false)))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":"177","code":"(fn balance177 [s]\n  (let [s1 (clojure.string/replace s #\"([^{}\\[\\]()]+)|(\\[])+|(\\(\\))+|(\\{})+\" \"\") ]\n    (if (= s s1)\n        (zero? (count s1))\n        (recur s1) )))","user":"579d9601e4b05b1deef9ae18"},{"problem":"177","code":"(fn [s]\n  (let [parsed-brackets (reduce (fn [brackets c]\n                                  (if brackets\n                                    (case c\n                                      \\( (conj brackets \"(\")\n                                      \\[ (conj brackets \"[\" )\n                                      \\{ (conj brackets \"{\" )\n                                      \\) (if (= \"(\" (last brackets))\n                                           (vec (drop-last 1 brackets)))\n                                      \\] (if (= \"[\" (last brackets))\n                                           (vec (drop-last 1 brackets)))\n                                      \\} (if (= \"{\" (last brackets))\n                                           (vec (drop-last 1 brackets)))\n                                      brackets)))\n                                []\n                                s)]\n    (and parsed-brackets (empty? parsed-brackets))))","user":"55f2e47de4b06e875b46ce4d"},{"code":"#(loop [s [] r %]\n    (if (empty? r)\n      (empty? s)\n      (let [f (first r)\n            t (rest r)]\n        (if (contains? #{\\( \\[ \\{} f)\n          (recur (cons f s) (rest r))\n          (if (contains? #{\\) \\] \\}} f)\n            (if (= (first s) ({\\) \\(, \\} \\{, \\] \\[} f)) \n              (recur (rest s) t) (recur [0] nil))\n            (recur s t))))))","problem":"177","user":"512f06c5e4b0762be4c7aad7"},{"code":"(fn [s]\n  (let [special {\\) \\( \\] \\[ \\} \\{}\n        is-close? #(special %)\n        is-open? #((set (vals special)) %)\n        matching? (fn[c o] (= (special o) c))\n        bm (fn[s stack]\n             (if-let [c (first s)]\n               (cond\n                 (is-open? c) (recur (rest s) (conj stack c))\n                 (is-close? c)\n                   (when (matching? (first stack) c)\n                     (recur (rest s) (rest stack)))\n                 :else (recur (rest s) stack))\n               (empty? stack)))]\n    (bm s '())))","problem":"177","user":"52828298e4b0757a1b17145b"},{"problem":"177","code":"(fn [s] (empty? (reduce (fn [v c]\n            \t \t\t\t(case [c (last v)]\n              \t\t \t\t\t([\\) \\(] [\\] \\[] [\\} \\{]) (pop v)\n               \t\t\t\t\t(conj v c))) []\n              \t\t(filter #{\\( \\) \\[ \\] \\{ \\}} (vec s)))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":"177","code":"(fn [s]\n  (let [pairs [\"()\" \"{}\" \"[]\"]\n        bchars (seq (apply str pairs))\n        pars (apply str (doall (filter #(.contains bchars %) s)))\n        unbalanced-pars \n        (loop [result pars] \n          (let [new (reduce (fn [acc x] (clojure.string/replace acc x \"\")) result pairs)]\n            (if (= result new)\n              result\n              (recur new))))\n        ]\n    (prn unbalanced-pars)\n    (= (count unbalanced-pars) 0)))","user":"55f09e7be4b06e875b46ce28"},{"code":"#(= (reduce (fn [acc c]\n              (and acc\n                   (cond ((set \"([{\") c) (cons c acc)\n                         ((set \")]}\") c) (and (= c ({\\( \\)\n                                                     \\[ \\]\n                                                     \\{ \\}}\n                                                    (first acc)))\n                                              (rest acc))\n                         :else acc)))\n            ()\n            %)\n    ())","problem":"177","user":"4ee3b586535d10e5ff6f5371"},{"problem":"177","code":"#(letfn \n    [(f [c e]\n        (if (#{\"()\" \"[]\" \"{}\"} (str (first c) e)) \n            (rest c)\n            (conj c e)))]\n    (->> (seq %)\n         (filter #{\\( \\) \\[ \\] \\{ \\}})\n         (reduce f '())\n         (empty?)))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":"177","code":"(fn [x]\n  (let [chs #{\\( \\) \\[ \\] \\{ \\}}\n        mapper {\\) \\(, \\] \\[, \\} \\{}]\n                       (loop [stack () x x]\n                         (let [letter (first x)]\n                           (cond\n                            (and (empty? x) (empty? stack)) true\n                            (empty? x) false\n                            (not (chs letter)) (recur stack (rest x))\n                            (and (mapper letter) (= (mapper letter) (first stack))) (recur (rest stack) (rest x))\n                            (and (not (mapper letter)) (chs letter)) (recur (conj stack letter) (rest x))\n                            :else false)))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":"177","code":"(fn [s] (\n  \n  (fn ch [l sta] (if (empty? l)\n                     (empty? sta)\n                     (if (or (= \\( (first l)) (= \\[ (first l)) (= \\{ (first l)))\n                       (ch (rest l) (cons (first l) sta))\n                       (if (or (= \\) (first l)) (= \\] (first l)) (= \\} (first l)))\n                         (if (and (not (empty? sta)) (= (first l) ({\\( \\) \\[ \\] \\{ \\}} (first sta))))\n                           (ch (rest l) (rest sta))\n                           false)\n                         (ch (rest l) sta)))))\n  \n  \n  \n  (seq s) '()\n  \n  \n  \n  ))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":"177","code":"(fn [s] (->> (iterate #(clojure.string/replace % #\"(\\(\\)|\\[\\]|\\{\\})|[^\\[\\](){}]\" \"\") s)\n             (map count)\n             (partition 2)\n             (some (fn [[a b]] (and (= a b) a)))\n             (zero?)))","user":"5960a1a6e4b066ee0a44b08e"},{"code":"(fn [input] (let [l (apply str (filter #(some (fn [e] (= e (str %))) '( \"(\" \")\" \"[\" \"]\" \"{\" \"}\" )) input))                                                                                                \n                        z1 (list \"()\" \"[]\" \"{}\")]                                                                                                                                                               \n                    (if (empty? l) true                                                                                                                                                                         \n                        (letfn [(pair? [x] (some #(= x %) z1))]                                                                                                                                                 \n                          (empty? (reduce #(let [next-token (str %2)]                                                                                                                                           \n                                             (if-let [acc (seq %)]                                                                                                                                              \n                                               (let [last-seen (peek acc)]                                                                                                                                      \n                                                 (if (pair? (str last-seen next-token)) (rest acc)                                                                                                              \n                                                     (conj acc next-token)))                                                                                                                                    \n                                               (conj % next-token))) '() l))))))","problem":"177","user":"52265e41e4b04e78ff2e1981"},{"code":"(fn [s]\n  (loop [s s\n         stack '()]\n    (if (empty? s)\n      (if (empty? stack)\n        true\n        false)\n      (if (contains? #{\\{ \\[ \\(} (first s) )\n        (recur (next s) (cons (first s) stack))\n        (if (not (contains? #{\\} \\] \\)} (first s) ))\n          (recur (next s) stack)\n          (if (= (first stack) (get {\\} \\{ \\] \\[ \\) \\(} (first s)))\n            (recur (next s) (next stack))\n            false))))))","problem":"177","user":"5349ac2be4b084c2834f4a67"},{"problem":"177","code":"(fn [s]\n      (let [brack-seq (re-seq #\"[\\[\\]\\{\\}\\(\\)]\" s)\n            pairs [\"[]\" \"()\" \"{}\"]\n            prune (fn [s] (reduce (fn [s bp] (clojure.string/replace s bp \"\"))\n                                  s\n                                  pairs))]\n        (loop [bracks (apply str brack-seq)]\n          (if (clojure.string/blank? bracks)\n            true\n            (let [new-bracks (prune bracks)]\n              (if (= new-bracks bracks)\n                false\n                (recur new-bracks)))))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":"177","code":"(fn [string]\n  (letfn [(is-open-paren [c]\n            (#{\\( \\[ \\{} c))\n          (is-close-paren [c]\n            (#{\\) \\] \\}} c))\n          (open-of [c]\n            (condp = c\n              \\) \\(\n              \\] \\[\n              \\} \\{))\n          (machine [open-parens chars]\n            (if (empty? chars)\n              (empty? open-parens)\n\n              (let [[c & rst] chars]\n                (cond\n                  (is-open-paren c) (partial machine (cons c open-parens) rst)\n                  (and (is-close-paren c) (empty? open-parens)) false\n                  (and (is-close-paren c) (= (open-of c) (first open-parens))) (partial machine (rest open-parens) rst)\n                  :else (partial machine open-parens rst)))))]\n\n    (trampoline machine '() string)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [os]\n\t(let [rs (-> os (.replaceAll \"\\\\([^(){}\\\\[\\\\]]*\\\\)\" \"\")\n\t\t\t\t\t(.replaceAll \"\\\\[[^(){}\\\\[\\\\]]*\\\\]\" \"\")\n\t\t \t\t\t(.replaceAll \"\\\\{[^(){}\\\\[\\\\]]*\\\\}\" \"\"))]\n\t\t  (if (= rs os)\n\t\t  \t(nil? (re-find #\"[(){}\\[\\]]\" rs))\n\t\t  \t(recur rs))))","problem":"177","user":"4f1b92d1535d64f60314647b"},{"problem":"177","code":"(fn [s]\n  (let [left-brackets  (set \"[({\")\n        right-brackets (set \"])}\")\n        bracket-pairs  (zipmap \"])}\" \"[({\")]\n    (loop [[hd & tl :as s] s\n           stack '()]\n      (cond (empty? s) (empty? stack)\n            (left-brackets hd) (recur tl (cons hd stack))\n            (right-brackets hd) (if (= (first stack) (bracket-pairs hd))\n                                  (recur tl (rest stack)))\n            :else (recur tl stack)))))","user":"58a47197e4b01a0c0b2328f9"},{"problem":"177","code":"(fn [s]\n    (let [pairs {\\( \\) \\{ \\} \\[ \\]}\n          open  (set (keys pairs))\n          close (set (vals pairs))]\n      (loop [[c & s] (seq s) q '()]\n        (cond\n          (nil? c) (empty? q)\n          (contains? open c)  (recur s (cons c q))\n          (contains? close c) (if (= c (get pairs (first q)))\n                                (recur s (rest q))\n                                false)\n          :else (recur s q)))\n      ))","user":"54c641f8e4b045293a27f628"},{"problem":"177","code":"(fn [a-string]\n  (let [opens (set (list \\( \\{ \\[))\n        closes (set (list \\) \\} \\]))\n        matches {\\( \\) \\{ \\} \\[ \\]}\n        bracketer (fn [acc a-char]\n                    (cond\n                      (contains? closes a-char) (conj acc a-char)\n                      (and\n                        (contains? opens a-char)\n                        (= (peek acc) (matches a-char))) (pop acc)\n                      (contains? opens a-char) (conj acc a-char)\n                      :else acc))]\n    (empty? (reduce bracketer [] (reverse a-string)))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn p\n  ([s] (p () s))\n  ([l s]\n     (if (empty? s)\n       (empty? l)\n       (let [m {\\} \\{ \\] \\[ \\) \\(}\n           v (set (keys m))\n           k (set (vals m))\n           i (first s)\n           r (rest s)]\n         (cond\n          (k i) (recur (cons i l) r)\n          (v i) (if (= (first l) (m i))\n                  (recur (rest l) r)\n                  false)\n          1 (recur l r))))))","problem":"177","user":"53460d02e4b084c2834f4a39"},{"code":"#(let [open-close {\\[ \\], \\( \\), \\{ \\}}\n        closing? (set (vals open-close))]\n    (empty?\n     (reduce (fn [[h & t :as acc] e]\n               (cond\n                (open-close e) (conj acc e)\n                (closing? e) (if (= (open-close h) e)\n                               t\n                               (conj acc :err))\n                :default acc))\n             () %)))","problem":"177","user":"51b9d1f0e4b0e871ca49590b"},{"problem":"177","code":"(fn[s]\n(loop [[f & r] s sq []]\n  (cond\n    (nil? f) (when (empty? sq) sq)\n    (#{\\( \\{ \\[} f) (recur r (conj sq f))\n    (#{\\) \\} \\]} f) (when (= (peek sq) ({\\) \\( \\} \\{ \\] \\[} f)) (recur r (pop sq)))\n    :else (recur r sq))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":"177","code":"(fn balance-brackets [s]\n  (let [open #{\\(\\[\\{}\n        close {\\) \\(\n               \\] \\[\n               \\} \\{}]\n    (loop [current (first s)\n           remaining (rest s)\n           stack []]\n      (if (nil? stack)\n        false\n        (if (nil? current)\n          (if (empty? stack)\n            true\n            false)\n          (recur (first remaining)\n                 (rest remaining)\n                 (cond\n                   (contains? open current) (conj stack current)\n                   (contains? close current) (if (= (get close current) (last stack))\n                                               (pop stack)\n                                               nil)\n                   :else stack)))))))","user":"51db0d99e4b06aa4d4669a9d"},{"problem":"177","code":"(fn [st]\n  (let [opener? #{\\( \\[ \\{}\n        closer? #{\\) \\] \\}}\n        matches (zipmap closer? opener?)]\n    (loop [[fst & chars]   (filter #{\\( \\) \\[ \\] \\{ \\}} st)\n           [top :as stack] (list)]\n      (cond\n        (nil? fst)            (empty? stack)\n        (opener? fst)         (recur chars (conj stack fst))\n        (= (matches fst) top) (recur chars (pop stack))))))","user":"56481722e4b0284900eef628"},{"problem":"177","code":"(fn nested [code]\n  (let [open-brackets #{\\{ \\( \\[}\n        end-brackets #{\\} \\) \\]}\n        bmap {\\{ \\} \\( \\) \\[ \\]}\n        fnested\n        (fn fnested [[s & r] bstack]\n          (cond\n           (not s) (empty? bstack)\n           (open-brackets s) (fnested r (cons s bstack))\n           (end-brackets s) (and\n                             (not (empty? bstack))\n                             (= (bmap (first bstack)) s)\n                             (fnested r (rest bstack)))\n           :else (fnested r bstack)))]\n     \n     (fnested code '())))","user":"54448e84e4b032a45b869393"},{"code":"(fn parse-brackets [str] \n  (let [opening [\\[ \\{ \\(]\n        closing [\\] \\} \\)]\n        close-map (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave opening closing)))]\n    (letfn [(parse-stage [str closing-bracket-stack]\n              (if (empty? str)\n                (if (not (empty? closing-bracket-stack)) false true)\n                (let [curr (first str)]\n                  (if (some #(= % curr) opening)\n                    (parse-stage (rest str) (conj closing-bracket-stack (get close-map curr)))\n                    (if (= (peek closing-bracket-stack) curr)\n                      (parse-stage (rest str) (pop closing-bracket-stack))\n                      (if (some #(= % curr) closing) false (parse-stage (rest str) closing-bracket-stack)))))))]\n      (parse-stage (seq str) []))))","problem":"177","user":"504ec4d3e4b069badc5a33c9"},{"problem":"177","code":"(fn balanced-brackets?\n  [s]\n  (let [open->close {\\( \\) \\[ \\] \\{ \\}}\n        close->open (clojure.set/map-invert open->close)]\n    (loop [stack '()\n           remaining s]\n      (let [[head & tail] remaining]\n        (cond\n          (empty? remaining) (empty? stack)\n          (contains? open->close head) (recur (cons head stack) tail)\n          (contains? close->open head) (and (= head (open->close (first stack)))\n                                            (recur (rest stack) tail))\n          :else (recur stack tail))))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":"177","code":"(fn [s] (empty? (let [k {\"[\" \"]\" \"{\" \"}\" \"(\" \")\"} f #(contains? (set (% k)) %2)] (reduce #(if (f keys %2) (conj % %2) (if (f vals %2) (if (= %2 (get k (peek %))) (pop %) [0]) %)) '() (drop 1 (clojure.string/split s #\"\"))))))","user":"56c08696e4b060a8e693e3aa"},{"problem":"177","code":"(fn balanced [s]\n  (let [o #{\\{ \\( \\[}\n        c->o {\\} \\{ \\) \\( \\] \\[}]\n    (loop [s (seq s) stack []]\n      (cond\n        (nil? (seq s))\n        (empty? stack)\n\n        (contains? o (first s))\n        (recur (rest s) (conj stack (first s)))\n\n        (contains? c->o (first s))\n        (if (= (last stack) (c->o (first s)))\n          (recur (rest s) (vec (butlast stack)))\n          false)\n\n        :else\n        (recur (rest s) stack)))))","user":"51dafedee4b09f6bc204eee2"},{"problem":"177","code":"(fn [s]\n  (let [o #{\\( \\{ \\[}\n        c #{\\) \\} \\]}\n        m (zipmap c o)\n        matched? (fn [acc e]\n                   (= (last acc) (get m e)))\n        r (reduce (fn [acc e]\n                    (cond\n                     (get o e) (conj acc e)\n                     (nil? (get c e)) acc\n                     (matched? acc e) (into [] (butlast acc))\n                     :else [:invalid]))\n                  []\n                  s)]\n    (empty? r)))","user":"57aa4775e4b0b8559636fc6b"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\) \\( \\] \\[ \\} \\{}\n        closers (set (keys pairs))\n        openers (set (vals pairs))\n        rfn (fn [stack c]\n              (cond\n                (openers c) (conj stack c)\n                (closers c) (if (= (peek stack) (pairs c))\n                              (pop stack)\n                              (conj stack :fail))\n                :else stack))]\n    (empty? (reduce rfn [] s))))","user":"4eb70649535d7eef30807373"},{"problem":"177","code":"(fn [s]\n  (= [] (reduce (fn [stack b] (condp = b \"[\" (conj stack b)\n                                   \"(\" (conj stack b)\n                                   \"{\" (conj stack b)\n                                   \"]\" (if  (= (last stack) \"[\" ) (pop stack) nil)\n                                   \")\" (if  (= (last stack) \"(\" ) (pop stack) nil)\n                                   \"}\" (if  (= (last stack) \"{\" ) (pop stack) nil)))\n          []\n          (re-seq (re-pattern \"[\\\\{\\\\}\\\\[\\\\]\\\\(\\\\)]\") s))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":"177","code":"(fn b [s]\r\n     (let [c #(condp re-find (str %)\r\n                #\"[\\(\\[\\{]\" :open\r\n                #\"[\\}\\]\\)]\" :close\r\n                :neither)\r\n           p #(condp re-find (str %)\r\n                #\"[\\(\\)]\" :paren\r\n                #\"[\\[\\]]\" :bracket\r\n                #\"[\\{\\}]\" :brace\r\n                :none)]\r\n       (empty? (reduce\r\n                #(if (= (c %2) :neither)\r\n                   %1\r\n                   (if (= (c %2) :open)\r\n                     (conj %1 (p %2))\r\n                     (if (= (p %2) (first %1))\r\n                       (rest %1)\r\n                       (conj %1 :fail))))\r\n                '()\r\n                (seq s)))))","user":"53aaaf7ae4b047364c044444"},{"code":"(fn f [arg]\n  (letfn [(right2left [c1 c2]\n            (cond (= c2 \\})\n                  (= c1 \\{)\n                  (= c2 \\))\n                  (= c1 \\()\n                  (= c2 \\])\n                  (= c1 \\[)))\n          (isRBracket? [c]\n            (or (= c \\}) (= c \\)) (= c \\])))\n          (isLBracket? [c]\n            (or (= c \\{) (= c \\() (= c \\[)))]\n    (let [arg' (vec arg)]\n      (loop [stack [] now arg']\n        (if (empty? now)\n          (empty? stack)\n          (if (isRBracket? (first now))\n            (if (right2left (last stack) (first now))\n              (recur (vec (butlast stack)) (rest now))\n              false)\n            (if (isLBracket? (first now))\n              (recur (conj stack (first now)) (rest now))\n              (recur stack (rest now)))))))))","problem":"177","user":"518ccf6be4b05e6c8537e386"},{"code":"(fn [s]\n  (let [matching {\\{ \\} \\[ \\] \\( \\)}\n        balanced? (fn balanced? [s stack]\n                    (if (empty? s) (empty? stack)\n                      (let [[h & t] s]\n                        (case h\n                          (\\( \\[ \\{) (balanced? t (conj stack (matching h)))\n                          (\\) \\] \\}) (and (not (empty? stack))\n                                          (= h (peek stack))\n                                          (balanced? t (pop stack)))\n                          (balanced? t stack)))))]\n    (balanced? s '())))","problem":"177","user":"5338e33fe4b0e30313ee6ca1"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\) \\(, \\] \\[, \\} \\{}\n        lefs #{\\( \\[ \\{}]\n     (loop [i 0 unpaired '()]\n       (if (= i (count s))\n         (= 0 (count unpaired))\n         (cond (contains? lefs (nth s i))\n                 (recur (inc i) (conj unpaired (nth s i)))\n               (and ((complement nil?) (pairs (nth s i))) (= (peek unpaired) (pairs (nth s i))))\n                 (recur (inc i) (pop unpaired))\n               (and ((complement nil?) (pairs (nth s i))) (not= (peek unpaired) (pairs (nth s i))))\n                 false\n               :else\n                 (recur (inc i) unpaired))))))","user":"56288ccae4b00e49c7cb47ea"},{"code":"(fn b \n   ([s] (b s '()))\n   ([s v] (let [fs (first s)\n                m {\\} \\{ \\] \\[ \\) \\(}\n                ob (vals m)\n                d1s (drop 1 s)\n                mfs (m fs)]\n            (if (empty? s)\n              (empty? v)\n              (cond \n               (> (.indexOf ob fs) -1) (recur d1s (cons fs v))\n               mfs (if (= (first v) mfs)\n                        (recur d1s (drop 1 v))\n                        false)\n               :else (recur d1s v))))))","problem":"177","user":"506d5e4ce4b0a302964c5493"},{"problem":"177","code":"(letfn [(update [m k f] (assoc m k (f (m k))))]\n    (fn [s]\n      (loop [levels {\\{ 0 \\[ 0 \\( 0}\n             [current :as brack-stack] '()\n             [c & s] s]\n        (println levels)\n        (case c\n          \\( (recur (update levels \\( inc) (conj brack-stack \\() s)\n          \\[ (recur (update levels \\[ inc) (conj brack-stack \\[) s)\n          \\{ (recur (update levels \\{ inc) (conj brack-stack \\{) s)\n          \\) (if (and (pos? (levels \\()) (= current \\())\n               (recur (update levels \\( dec) (pop brack-stack) s)\n               false)\n          \\] (if (and (pos? (levels \\[)) (= current \\[))\n               (recur (update levels \\[ dec) (pop brack-stack) s)\n               false)\n          \\} (if (and (pos? (levels \\{)) (= current \\{))\n               (recur (update levels \\{ dec) (pop brack-stack) s)\n               false)\n          nil (every? zero? (vals levels))\n          (recur levels brack-stack s)))))","user":"55f081bbe4b06e875b46ce25"},{"problem":"177","code":"(fn balanced-brackets?\n   [s]\n   (let [m {\\( \\) \\[ \\] \\{ \\}}\n         ks (set (keys m))\n         vs (set (vals m))]\n     (empty? (reduce #(if (contains? ks %2)\n                       (conj % %2)\n                       (if (contains? vs %2)\n                         (if (empty? %)\n                           (conj % %2)\n                           (if (= (m (last %)) %2)\n                             (vec (drop-last %))\n                             (conj % %2)))\n                         %)) [] s))))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(let [closers {\\[ \\] \\{ \\} \\( \\)}\n      openers {\\] \\[ \\} \\{ \\) \\(}]\n  (fn balanced? [s]\n    (loop [stack [], s s]\n      (cond (empty? s) (empty? stack)\n            (openers (first s)) (and (seq stack)\n                                     (= (openers (first s))\n                                        (peek stack))\n                                     (recur (pop stack) (rest s)))\n            (closers (first s)) (recur (conj stack (first s)) (rest s))\n            :else (recur stack (rest s))))))","problem":"177","user":"4dabb7b1950ed6eda1bd72f3"},{"problem":"177","code":"(fn balanced? [s]\n      (let [open {\\{ \\} \\( \\) \\[ \\]} close #{ \\} \\) \\]}]\n        (loop [stack [] [h & t :as letters] (seq s)]\n          (if letters\n            (cond (open h) (recur (conj stack (open h)) t)\n                  (close h) (if (= (peek stack) h)\n                              (recur (pop stack) t)\n                              false)\n                  :else (recur stack t))\n            (empty? stack)))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":"177","code":"(fn [s] (let [\n               starters {\n                      \"(\" \")\"\n                      \"[\" \"]\"\n                      \"{\" \"}\"\n                      }\n\n               termiantors #{\n                      \")\"\n                      \"]\"\n                      \"}\"\n                      }\n\n               tokens (into [] (map str (seq s)))\n               ]\n           (loop [\n                  i 0\n                  stack []\n                  state []\n                  ]\n             (let\n               [\n                size (count tokens)\n                last (dec size)\n                token (nth tokens i)\n                isstart (not (nil? (get starters token)))\n                terminate (not (nil? (get termiantors token)))\n                p (peek stack)\n                new-stack (if isstart\n                            (conj stack token)\n                            (if (and (> (count stack) 0) terminate) (pop stack) stack))\n                skip (not (or isstart terminate))\n                legal (or skip (or isstart (= token (get starters p))))\n                new-state (conj state {\n                                       :skip skip\n                                       :last last\n                                       :isstart isstart\n                                       :legal legal\n                                       :new-stack new-stack\n                                       :idx       i\n                                       :token     token\n                                       })\n                ]\n               (if (= i last)\n                 (and legal (empty? new-stack))\n                 (if (not legal)\n                   false\n                   (recur (inc i) new-stack new-state))\n                 ))\n             )))","user":"58a9e872e4b01a0c0b232973"},{"problem":"177","code":"(fn is-balanced [code]\n  ((fn parse [code opens]\n     (let [next-bracket (first code) needs-closed (first opens)]\n       (if (and (true? (empty? code)) (true? (empty? opens)))\n         true\n         (if (or (= next-bracket \\() (= next-bracket \\[) (= next-bracket \\{))\n           (recur (rest code) (cons next-bracket opens))\n           (if (or (and (= next-bracket \\}) (= needs-closed \\{)) (and (= next-bracket \\]) (= needs-closed \\[)) (and (= next-bracket \\)) (= needs-closed \\()))\n             (recur (rest code) (rest opens))\n             false)))))\n    (filter #(or (= % \\()(= % \\))(= % \\{)(= % \\})(= % \\[)(= % \\])) (map identity code)) []))","user":"5d06499ae4b0cc9c915881ec"},{"problem":"177","code":"(fn [s]\r\n  (let [bra {\\) \\( \\} \\{ \\] \\[}\r\n        op  (set (vals bra))]\r\n  (loop [l '() [a & r] s]\r\n    (if a\r\n      (cond\r\n        (op a)  (recur (conj l a) r)\r\n        (bra a) (if (= (first l) (bra a))\r\n                  (recur (rest l) r)\r\n                  false)\r\n        :else    (recur l r))\r\n      (empty? l)))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":"177","code":"(fn [input]\n  (let [closed {\\( \\) \\[ \\] \\{ \\}}]\n  (empty? (reduce (fn [stack c]\n                    (cond (= (closed (peek stack)) c)\n                          (if (empty? stack)\n                            stack\n                            (pop stack))\n                          (some #{c} (flatten (seq closed)))\n                          (conj stack c)\n                          :else\n                          stack)) '() input))))","user":"54497569e4b032a45b8693d2"},{"code":"(fn brackets-match? [s]\n  (let [brackets (apply str (filter #{\\( \\) \\{ \\} \\[ \\]} s))]\n    (loop [b brackets]\n      (let [nb (-> b\n                   (clojure.string/replace \"()\" \"\")\n                   (clojure.string/replace \"[]\" \"\")\n                   (clojure.string/replace \"{}\" \"\"))]\n        (cond\n         (clojure.string/blank? nb) true\n         (= nb b) false\n         :else (recur nb))))))","problem":"177","user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":"177","code":"(fn balanced? [s]\n  (let [cleaned (filter #{\\[ \\] \\( \\) \\{ \\}} s)\n        close->open {\\] \\[ \n                     \\) \\( \n                     \\} \\{}]\n    (empty? (reduce (fn [stack x]\n                       (if-let [opp (close->open x)]\n                         (if (or (empty? stack)\n                                 (not= (peek stack) opp))\n                           [:no-reduced?]\n                           (pop stack))\n                         (conj stack x)))\n                     []\n                     cleaned))))","user":"571c2babe4b07c98581c3b73"},{"problem":"177","code":"(let [syms {\\} \\{\n              \\] \\[\n              \\) \\(}]\n    (fn balanced?\n      ([str] (balanced? (seq str) '()))\n      ([[cur & chars] stack]\n       (println cur chars stack (set (vals syms)) ((set (vals syms)) cur))\n       (cond\n         (and (syms cur)\n              (not= (syms cur) (first stack))) false\n         (syms cur) (recur chars (rest stack))\n         ((set (vals syms)) cur) (recur chars (conj stack cur))\n         (and (nil? cur)\n              (empty? stack)) true\n         (nil? cur) false\n         :else (recur chars stack)))))","user":"4dbb0f2d535d1e037afb21b1"},{"code":"(let [open-parens {\\[ \\], \\{ \\}, \\( \\)}\n      soln (fn [s]\n             (loop [stack [] s s]\n               (if (empty? s)\n                 (empty? stack)\n                 (cond\n                   (#{\\] \\) \\}} (first s)) (and (= (first stack) (first s))\n                                                (recur (rest stack) (rest s)))\n                   (open-parens (first s)) (recur (cons (open-parens (first s)) stack) (rest s))\n                   :else (recur stack (rest s))))))]\n  soln)","problem":"177","user":"50b668dde4b08fb537db98f2"},{"problem":"177","code":"#(case (count %)\n  28 true\n  117 true\n  12 false\n  3 false\n  8 false\n  52 true\n  false)","user":"5e8ce2fee4b0cb0169546328"},{"problem":"177","code":"(fn [s]\n  (empty?\n   (reduce\n    #(cond\n       (or (= \\( %2) (= \\[ %2) (= \\{ %2)) (cons %2 %)\n       (= \\) %2) (if (= \\( (first %)) (rest %) (concat % (list false)))\n       (= \\] %2) (if (= \\[ (first %)) (rest %) (concat % (list false)))\n       (= \\} %2) (if (= \\{ (first %)) (rest %) (concat % (list false)))\n       :else (do (println %2) %))\n    ()\n    s)))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [st]\n\n    (let [chain (re-seq  #\"[\\(|\\)|\\{|\\}|\\[|\\]]\" st )\n          bmp  {\"]\" \"[\" \")\" \"(\" \"}\" \"{\"}]\n\n      (loop [que '()\n             [f & r] chain]\n\n        (cond\n         (and (empty? que) (empty? f)) true\n         (empty? f) false\n         (bmp f) (if  (not= (bmp f) (first que)) false\n                       (recur (rest que) r)\n                       )\n         \n         :else\n         (recur (cons f que) r)))))","problem":"177","user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn balanced? [s]\n    (let [matches {\\} \\{ \\) \\( \\] \\[} ]\n      (loop [brackets (vec (for [c s :when (contains? #{\\{ \\} \\( \\) \\[ \\]} c)] c))\n             stack []\n            ]\n          (cond \n             (empty? brackets) (empty? stack)\n             (and (contains? matches (first brackets)) (not= (matches (first brackets)) (peek stack))) false\n             :else (recur (rest brackets) \n                    (if (contains? matches (first brackets))\n                      (pop stack)\n                      (conj stack (first brackets))\n                      )\n              )\n        )\n      )\n     )\n  )","problem":"177","user":"529a73bde4b02ebb4ef75096"},{"problem":"177","code":"(fn [s]\n  (let [m {\\( \\), \\[ \\], \\{ \\}}]\n    (->> s\n         (filter (set (flatten ((juxt keys vals) m))))\n         (reductions (fn [[t & r :as stack] c] (if (m c) (cons c stack) (when (= (m t) c) r))) [0])\n         last\n         (= [0]))))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn f \n  ([s] (f (filter (fn [c] (some #(= % c) [\\] \\[ \\( \\) \\{ \\}])) s) '()))\n  ([s stack] \n     (if (empty? s) \n       (empty? stack)     \n       (if (some #(= % [(first stack) (first s)]) \n                 [ [ \\[ \\] ] [ \\( \\) ] [ \\{ \\} ]])  \n         (recur (rest s) (rest stack))\n         (recur (rest s) (conj stack (first s)))\n       )\n       )\n    ))","problem":"177","user":"4f0da4e4535d0136e6c22319"},{"problem":"177","code":"(fn [R] (empty? (reduce (fn [[t & h :as S] p] (cond (= ({\\( \\) \\[ \\] \\{ \\}} t) p) h (#{\\{ \\} \\[ \\] \\( \\)} p) (cons p S) :else S)) '() R)))","user":"55f6fe09e4b06e875b46cea2"},{"problem":"177","code":"(fn balanced? \n  ([s]\n   (balanced? s '()))\n  ([s stack]\n   (let [open \"({[\" closed \")}]\"]\n     (letfn\n       [(open? [c] (.contains open (stringify c)))\n        (close? [c] (.contains closed (stringify c)))\n        (matches? [c1 c2] (= (.indexOf open (stringify c1)) (.indexOf closed (stringify c2))))\n        (stringify [c] (Character/toString (Character/valueOf c)))]\n        (cond\n          (empty? s) (empty? stack)\n          (open? (first s)) (balanced? (rest s) (conj stack (first s)))\n          (close? (first s)) (and\n                                ((complement empty?) stack)\n                                (matches? (peek stack) (first s))\n                                (balanced? (rest s) (pop stack)))\n          :else (balanced? (rest s) stack))))))","user":"5514a60fe4b055c2f668d4d7"},{"code":"(fn matching-parens?\n  [s]\n  (let [end {\\( \\) \\{ \\} \\[ \\]}]\n    (empty?\n      (reduce (fn [stack c]\n                (if (= (end (peek stack)) c)\n                  (pop stack)\n                  (conj stack c)))\n              ()\n              (filter (set \"(){}[]\") s)))))","problem":"177","user":"4dc0ff08535d020aff1edf84"},{"code":"#(let [pairs {\\( \\) \\[ \\] \\{ \\} }]\n(empty? (reduce (fn [stack ch]\n          \t(cond\n             (contains? (set (keys pairs)) ch) (conj stack (pairs ch))\n             (contains? (set (vals pairs)) ch) (if (= ch (peek stack))\n                                             (pop stack)\n                                             [:fail])\n             :else stack))\n        []\n        %)))","problem":"177","user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":"177","code":"(fn match? \n  ([s](match? s []))\n  ([s stack] \n   (let [left #{\\{ \\[ \\(}         \n         right->left {\\} \\{ \\] \\[ \\) \\(}\n                                 ]\n     (cond \n      (empty? s) (empty? stack)\n      (left (first s)) (recur (rest s) (conj stack (first s)))\n      (right->left (first s))  (when (= (peek stack) (right->left (first s))) (recur (rest s) (pop stack))  ) \n      :else (recur (rest s) stack)\n      \n      ))))","user":"54af6fb0e4b09f271ff37d08"},{"problem":"177","code":"(fn match-brackets [s]\n  (let [opening? {\\( 'paren \\[ 'squar \\{ 'curly}\n        closing? {\\) 'paren \\] 'squar \\} 'curly}]\n    (loop [[c1 & cs :as c]  '()\n           [t1 & ts]        s]\n      (cond\n        (nil? t1)     (empty? c)\n        (opening? t1) (recur (cons (opening? t1) c) ts)\n        (closing? t1) (if (= c1 (closing? t1))\n                        (recur cs ts)\n                        false)\n        :else         (recur c ts)))))","user":"4faa9593e4b081705acca1f9"},{"problem":"177","code":"(fn balanced\n  ([in] (balanced (filter #{\\( \\) \\{ \\} \\[ \\]} in) []))\n  ([in stack] \n   (let [closes? (fn [a b] (= ({\\( \\) \\{ \\} \\[ \\]} b) a))]\n     (cond\n      (empty? in) (empty? stack)\n      (closes? (first in) (first stack)) (balanced (rest in) (rest stack))\n      :else (balanced (rest in) (cons (first in) stack))\n))))","user":"5280a1ece4b0757a1b171407"},{"code":"(fn [s]\n  (let [special {\\) \\( \\] \\[ \\} \\{}\n        is-close? #(special %)\n        is-open? #((set (vals special)) %)\n        matching? (fn[c o] (= (special o) c))\n        bm (fn[s stack]\n             (if-let [c (first s)]\n               (cond\n                 (is-open? c) (recur (rest s) (conj stack c))\n                 (is-close? c) \n                   (when (matching? (first stack) c)\n                     (recur (rest s) (rest stack)))\n                 :else (recur (rest s) stack))\n               (empty? stack)))]\n    (bm s '())))","problem":"177","user":"4f05ea25535dcb61093f6c02"},{"problem":"177","code":"(let [left-brackets #{ \\{ \\[ \\( }\n        right-brackets #{ \\} \\] \\) }\n        left->right { \\( \\)\n                     \\[ \\]\n                     \\{ \\} }]\n    (fn [s]\n      (loop [stack ()\n             [c & cs] s]\n        (cond (nil? c) (empty? stack)\n              (left-brackets c) (recur (conj stack c) cs)\n              (right-brackets c) (if-not (= c (left->right (peek stack)))\n                                   false\n                                   (recur (pop stack) cs))\n              :else (recur stack cs)))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":"177","code":"#(loop [res (clojure.string/replace %1 #\"\\w+|\\s+|\\.|\\;|\\\"\" \"\")]\n\t(let [newRes (clojure.string/replace res #\"\\(\\)|\\{\\}|\\[\\]\" \"\")]\n\t\t(if (= res newRes)\n\t\t\t(if (empty? res)\n\t\t\t\ttrue\n\t\t\t\tfalse)\n\t\t\t(recur newRes))))","user":"57986b76e4b039eba2ecb116"},{"problem":"177","code":"(fn bracket?\n  [s]\n  (let [left-bracket #{\"[\" \"(\" \"{\"}\n        right-bracket {\"]\" \"[\" \")\" \"(\" \"}\" \"{\"}\n        bracket-fn (fn [stack c]\n                     (cond\n                       (not stack) stack\n                       (left-bracket c) (conj stack c)\n                       (right-bracket c) (and (= (get right-bracket c)\n                                                 (peek stack))\n                                              (pop stack))\n                       :else stack))\n        stack (reduce\n                bracket-fn\n                '() (map str s))]\n    (and stack (empty? stack))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn brackets-balanced? [s]\n  (letfn [\n           (remove-useless [s]\n             (clojure.string/replace s #\"[^\\[\\]\\{\\}\\(\\)]\" (constantly \"\")))\n           ]\n    (loop [stack '() brackets (remove-useless s)]\n      (if (empty? brackets)\n        (empty? stack)\n        (case (first brackets)\n\n          \\] (if (= \\[ (peek stack))\n               (recur (pop stack) (rest brackets))\n               false\n               )\n          \\} (if (= \\{ (peek stack))\n               (recur (pop stack) (rest brackets))\n               false\n               )\n          \\) (if (= \\( (peek stack))\n                   (recur (pop stack) (rest brackets))\n                   false\n                   )\n               (recur (conj stack (first brackets)) (rest brackets))\n               )\n          )\n        )\n      )\n    )","problem":"177","user":"5094057fe4b097f48cc38593"},{"problem":"177","code":"(fn balancing-brackets\n  [s]\n  (let [push-fn (fn [c] #(conj % c))\n        pop-fn (fn [c-1] #(if (= (peek %) c-1) (pop %) (conj % false)))\n        brackets {\\[ (push-fn \\[) \\] (pop-fn \\[)\n                  \\( (push-fn \\() \\) (pop-fn \\()\n                  \\{ (push-fn \\{) \\} (pop-fn \\{)}]\n    (empty? (reduce (fn [acc c] (if (get brackets c) ((get brackets c) acc) acc)) [] s))))","user":"5383668ee4b06839e8705edd"},{"problem":"177","code":"(fn [s]\n  (let [brackets (apply array-map \"(){}[]\")\n        rmb (fn [c b] \n              (if (= (brackets (last c)) b) (butlast c) (conj c false)))]\n    (loop [p s t []]\n      (if (empty? p) (empty? t)\n        (cond\n         (contains? brackets (first p)) (recur (rest p) (concat t [(first p)]))\n         (contains? (set \")}]\") (first p)) (recur (rest p) (rmb t (first p)))\n         :else (recur (rest p) t))))))","user":"574abbfbe4b02ea114799200"},{"problem":"177","code":"(fn t\n  [sentence]\n  (loop [[x & others] (re-seq #\"[\\(|\\)|\\[|\\]|\\{|\\}]\" sentence)\n         stack        '()]\n    (cond (nil? x) (empty? stack)\n          (#{[\"[\" \"]\"]\n             [\"(\" \")\"]\n             [\"{\" \"}\"]} [(peek stack) x]) (recur others (pop stack))\n          :else                           (recur others (conj stack x)))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":"177","code":"(fn [s]\n(let [ o #{ \\( \\[ \\{ }\n       c #{ \\) \\] \\} }\n       m  { \\) \\(, \\} \\{, \\] \\[ } ]\n  (loop [ [f & r :as s] s, ps '()]\n    (cond\n      (empty? s) (empty? ps)\n      (contains? o f) (recur r (cons f ps))\n      (contains? c f) (if (= (m f) (first ps)) (recur r (rest ps)) false)\n      :else (recur r ps))\n)))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn bal\n  ([xs] (bal xs []))\n  ([[x & xs] opens] \n   (let\n     [match {\\{ \\}, \\[ \\], \\( \\)}\n      closers #{ \\} \\] \\) }]\n     (cond\n      (nil? x) (empty? opens)\n      (match x) (recur xs (conj opens x))\n      (closers x) (if (= x (match (peek opens)))\n                    (recur xs (pop opens))\n                    false)\n      :else (recur xs opens)))))","problem":"177","user":"50217818e4b00bba4502f7a7"},{"problem":"177","code":"(fn pr177-2f [s]\n  (let [balance (fn [stack coll]\n                  (if (empty? coll)\n                    (empty? stack)\n                    (cond (contains? #{\\( \\{ \\[} (first coll))\n                            (recur (cons (first coll) stack) (rest coll))\n                          (contains? #{\\) \\} \\]} (first coll))\n                            (if (and (not (empty? stack)) (= (first stack) ({\\) \\( \\} \\{ \\] \\[}       (first coll))))\n                              (recur (rest stack) (rest coll))\n                              false)\n                          :else\n                            (recur stack (rest coll)))))]\n    (balance '() (seq s))))","user":"51696ee7e4b03f62cda68ce8"},{"problem":"177","code":"(fn [s]\n  (let [brackets {\\( \\), \\{ \\}, \\[ \\]}]\n    (loop [lefts '() chars (seq s)]\n      (cond\n        (and (empty? lefts) (empty? chars)) true\n        (seq chars)\n        (let [c (first chars)]\n          (cond\n            (#{\\( \\{ \\[} c) (recur (conj lefts c) (rest chars))\n            (#{\\) \\} \\]} c) (if (= c (brackets (peek lefts))) (recur (pop lefts) (rest chars)))\n            :else (recur lefts (rest chars))))))))","user":"56603e5fe4b068f2fe63dc4a"},{"code":"#(loop [m {\\( \\) \\[ \\] \\{ \\}} [c & r] % p []]\n   (cond\n     (m c) (recur m r (conj p (m c)))\n     (#{\\) \\] \\}} c) (if (= c (peek p)) (recur m r (pop p)))\n     c (recur m r p)\n     1 (empty? p)))","problem":"177","user":"52b453b0e4b0c58976d9ad21"},{"problem":"177","code":"(fn [s]\n  (let [bs { \\( \\) \\[ \\] \\{ \\} }]\n    (letfn [(step [b c]\n                  (cond\n                   (bs c) (cons c b)\n                   (= c (bs (first b))) (rest b)\n                   (some #{c} (vals bs)) (cons nil bs)\n                   :else b))]\n      (empty? (reduce step '() s)))))","user":"553e0b70e4b0a04f792994e8"},{"problem":"177","code":"#((fn [[f & r] s]\n     (let [m {\")\" \"(\" \"]\" \"[\" \"}\" \"{\"}]\n       (cond\n        (nil? f) (empty? s)\n        (contains? #{\"(\" \"[\" \"{\"} f) (recur r (conj s f))\n        (contains? #{\")\" \"]\" \"}\"} f) (if (= (m f) (peek s)) (recur r (pop s)) false))))\n   (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" %)\n   [])","user":"506ba58be4b0eda3100c090b"},{"problem":"177","code":"(fn [s] (let [rp (fn [s ss] (clojure.string/replace s ss \"\"))\n              go (fn [s] (let [s- (-> s (rp \"()\") (rp \"[]\") (rp \"{}\"))]\n                           (if (= s s-) (empty? s) (recur s-))))]\n    (go (apply str (filter #(contains? (into #{} \"()[]{}\") %) s)))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":"177","code":"(fn balanced? [input]\n\t(let [open #{\\( \\[ \\{}\n\t\t  close #{\\) \\] \\}}\n          match (zipmap close open)]\n\t\t(->> input\n\t\t\t(filter (clojure.set/union open close))\n\t\t\t(reduce\n\t\t\t\t(fn [b paren]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(open paren) (conj b paren)\n\t\t\t\t\t\t(= (match paren) (last b)) (pop b)\n\t\t\t\t\t\t:else (conj b paren)))\n\t\t\t\t[])\n\t\t\t(empty?))))","user":"5472d919e4b094393f72dd7b"},{"problem":"177","code":"(fn [st]\n  (let [b (filter #(#{\\[ \\{ \\( \\) \\} \\]} %) st)\n        matches {\\] \\[ \\} \\{ \\) \\(}\n        opening #{\\{ \\[ \\(}\n        closing #{\\} \\] \\)}] \n    (do (println b))                              \n    (if (empty? b)\n      true\n      (loop [c (first b) r (rest b) s '()]\n        (if (nil? c)\n          (empty? s)\n          (if (closing c)\n            (if-not (= (get matches c) (peek s))\n              false\n              (recur (first r) (rest r) (pop s)))\n            (recur (first r) (rest r) (conj s c))))))))","user":"53573d70e4b04ce2eb3ed278"},{"code":"(fn f [x] \n  (let [pre { \\( \\) \\[ \\] \\{ \\}}\n        post (apply hash-map (mapcat (fn[[x y]] [y x] ) pre))]\n    (loop [s (seq x) q []] \n      (if (empty? s)\n        (empty? q)\n        (let [ h (first s) r (rest s) ]\n          (if-let [z (find pre h)] \n            (recur r (conj q (val z)))\n            (if-let [w (find post h)] \n              (if (empty? q)\n                false\n                (let [e (peek q) o (pop q)] \n                  (if (= (key w) e)\n                    (recur r o)\n                    false)))\n              (recur r q))))))))","problem":"177","user":"518c5236e4b087e178201de0"},{"code":"(fn correct-brackets? [s]\n  (let [brackets (re-seq #\"[{(\\[\\])}]\" s)\n        vls {\"(\" 1 \")\" -1 \"[\" 2 \"]\" -2 \"{\" 3 \"}\" -3}]\n    (loop [br (map #(vls %) brackets)\n           last-br [0]\n           res 0]\n      (let [cur-br (first br)]\n        (cond\n          (empty? br) (= res 0)\n          (and (neg? cur-br) (not= (- cur-br) (peek last-br))) false\n          :else (recur\n                  (rest br)\n                  (if (neg? cur-br) (pop last-br) (conj last-br cur-br))\n                  (+ res cur-br)))))))","problem":"177","user":"526ee63de4b03e8d9a4a733f"},{"problem":"177","code":"(fn [str]\n    ((fn mb [st]\n       (if (= 0 (count st))\n         true\n         (let [p (clojure.string/replace st #\"\\(\\)|\\[\\]|\\{\\}\" \"\")]\n           (if (= (count st) (count p))\n             false\n             (mb p)\n             )\n           ))\n       ) (clojure.string/join (re-seq #\"\\{|\\[|\\(|\\)|\\]|\\}\" str)))\n  )","user":"53ae16e2e4b047364c044472"},{"code":"(fn p177 [st]\n  (let [ss (sorted-set \\( \\) \\{ \\} \\[ \\])\n\thm (apply hash-map ss) hmk (apply hash-set (keys hm)) hmv (apply hash-set (vals hm))\n\tcs (filter (complement nil?) (map #(ss %) (char-array st)))\n\tps (fn f [stack s] (cond (empty? s) (empty? stack)\n                                 true (let [fs (first s)]\n                                        (cond\n                                         (hmk fs) (f (cons (hm fs) stack) (next s))\n                                         (and (hmv fs) (= (first stack) fs)) (f (next stack) (next s))\n                                         true false))))] (ps nil cs)))","problem":"177","user":"5272669de4b03e8d9a4a742e"},{"problem":"177","code":"(fn balanced? [s]\n  (loop [in (seq s), stack '()]\n    (cond\n      (empty? in) (empty? stack)\n      (contains? #{\\( \\[ \\{} (first in)) (recur (rest in) (conj stack (first in)))\n      (contains? #{\\) \\] \\}} (first in))\n        (cond \n          (empty? stack) false\n          (contains? #{[\\( \\)] [\\[ \\]] [\\{ \\}]} [(first stack)(first in)])\n            (recur (rest in) (rest stack))\n          :else false)\n      :else (recur (rest in) stack))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [in]\n  (loop [i (seq in) stk []]\n    (if (empty? i) (empty? stk)\n      (let [n (first i)]\n        (case n\n          \\) (if (= \\( (peek stk)) (recur (rest i) (pop stk)) false)\n          \\] (if (= \\[ (peek stk)) (recur (rest i) (pop stk)) false)\n          \\} (if (= \\{ (peek stk)) (recur (rest i) (pop stk)) false)\n          (\\( \\[ \\{) (recur (rest i) (conj stk n))\n          (recur (rest i) stk))))))","problem":"177","user":"4f0446f9535dcb61093f6bb8"},{"problem":"177","code":"(fn [s]\n  (let [s (seq s)\n        rules {\\} \\{ \\) \\( \\] \\[}\n        f (fn [a x]\n            (cond\n              (#{\\{ \\( \\[} x) (update-in a [:v] conj x)\n              (rules x) (if (= (last (:v a)) (rules x))\n                          (update-in a [:v] pop)\n                          (update-in a [:r] (fn [x] false)))\n              :else a))]\n    (let [res (reduce f {:r true :v []} s)]\n      (and (:r res) (empty? (:v res))))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":"177","code":"(fn [st]\n  (loop [stack '()\n         rs (seq st)]\n    (if (empty? rs)\n      (if (empty? stack)\n        true\n        false)\n      (let [head (first rs)\n            tail (rest rs)]\n        (if (or (= head \\( ) (= head \\[ ) (= head \\{ ))\n           (recur (conj stack head) tail)\n           (if (or (= head \\) ) (= head \\] ) (= head \\} ))\n              (let [pk (peek stack)]\n                (cond\n                  (and (= pk \\( ) (= head \\) )) (recur (pop stack) tail)\n                  (and (= pk \\[ ) (= head \\] )) (recur (pop stack) tail)                                \n                  (and (= pk \\{ ) (= head \\} )) (recur (pop stack) tail)\n                  :else false) )\n              (recur stack tail) ) ) ) ) ) )\n                                \n;; Ugly. Ought to factor out repetitious code.","user":"53c1ce3ee4b00fb29b221268"},{"problem":"177","code":"(fn[s]\n    (loop [[f & r] s st ()]\n      (cond\n       (nil? f) (empty? st)\n       (or (= \\( f) (= \\{ f) (= \\[ f)) (recur r (cons f st))\n       (= \\) f) (if (= \\( (first st)) (recur r (rest st)) false)\n       (= \\} f) (if (= \\{ (first st)) (recur r (rest st)) false)\n       (= \\] f) (if (= \\[ (first st)) (recur r (rest st)) false)\n       :else (recur r st) \n       )))","user":"586615e6e4b0f14aab7c8858"},{"problem":"177","code":"(fn bra\n  [x]\n  (let [open {\"[\" \"]\" \"{\" \"}\" \"(\" \")\"}\n        close {\"]\" \"[\" \"}\" \"{\" \")\" \"(\"}\n        result (reduce #(cond\n                          (contains? open (str %2)) (conj %1 (open (str %2)))\n                          (= (peek %1) (str %2)) (pop %1)\n                          (contains? close (str %2)) (conj %1 \"a\")\n                          :else %1) '() x)]\n    \n    (empty? result)\n    )\n  )","user":"5e9d99f9e4b0157ca9664806"},{"code":"#(let [s (filter #{\\[ \\( \\{ \\} \\) \\]} (seq %))\n        n (count s)\n        e (fn [a b] (< 0 (Math/abs (- (int a) (int b))) 3))]\n    (when (even? n)\n      (reduce\n        (fn [v, c]\n          (when v\n            (if (#{\\{ \\[ \\(} c)\n              (conj v c)\n              (if (and (peek v) (e (peek v) c))\n                (pop v)\n                false))))\n        []\n        s)))","problem":"177","user":"4e82f85d535db62dc21a62ce"},{"problem":"177","code":"(fn\n  [s]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}\n        b (filter #(contains? (into #{} (mapcat vec pairs)) %) s)]\n    (loop [brackets b]\n      (if (empty? brackets)\n        true\n        (let [changed-s (-> (apply str brackets)\n                            (clojure.string/replace #\"\\[\\]\" \"\")\n                            (clojure.string/replace #\"\\(\\)\" \"\")\n                            (clojure.string/replace #\"\\{\\}\" \"\"))]\n          (if (= changed-s brackets)\n            false\n            (recur changed-s)))))))","user":"4daeabf6edd6309eace4d15c"},{"problem":"177","code":"#(loop [cs (seq %)\n        context ()] \n   (if (empty? cs) (empty? context) \n       (let [parens {\\} \\{, \\) \\(, \\] \\[} \n             [c & cs'] cs] \n          (cond (some #{ c } (vals parens)) (recur cs' (conj context c)) \n                (contains? parens c)        (if (= (peek context) (get parens c)) \n                                              (recur cs' (pop context)))\n                :else (recur cs' context)))))","user":"5566d812e4b0c656e3ff1837"},{"code":"#(empty? (reduce (fn [l i]\n                   (let [n (conj l i)\n                         f [\\!]\n                        z (last l)]\n            (case i\n              \\( n\n              \\[ n\n              \\{ n\n              \\) (if (= z \\( )\n                   (pop l)\n                   f)\n              \\] (if (= z \\[ )\n                   (pop l)\n                   f)\n              \\} (if (= z \\{ )\n                   (pop l)\n                   f)\n            l))) [] %))","problem":"177","user":"4eb2eae5535d7eef30807351"},{"problem":"177","code":"(fn [s [c & r]]\n  (case c\n    (\\[ \\{ \\() (recur (cons c s) r)\n    (\\) \\} \\]) (if (= ({\\[ \\] \\{ \\} \\( \\)} (first s)) c) (recur (next s) r) false)\n    (if (seq r)\n      (recur s r)\n      (empty? s))))\n()","user":"4fb1d7ace4b081705acca281"},{"problem":"177","code":"(fn [s]\n                    (let [open-bracket #{\\( \\{ \\[}\n                          close-bracket #{\\) \\} \\]}\n                          close-open-map {\\) \\( \\} \\{ \\] \\[}\n                          brackets-left (reduce (fn [acc itm]\n                                                  (cond \n                                                   (open-bracket itm) (cons itm acc)\n                                                   (close-bracket itm) (if (= (first acc) (close-open-map itm))\n                                                                         (rest acc)\n                                                                         (cons itm acc))\n                                                   :else acc)) \n                                                () \n                                                s)]\n                      (empty? brackets-left)))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn check [[x & xs :as stack] [ch & chars :as s]]\n  (let [paired? #{[\\( \\)] [\\{ \\}] [\\[ \\]]} opening? #{\\( \\[ \\{} closing? #{\\) \\] \\}}]\n    (cond (empty? s) (empty? stack)\n          (opening? ch) (recur (cons ch stack) chars)\n          (closing? ch) (if (paired? [x ch]) (recur xs chars))\n          :else (recur stack chars)))) ()","problem":"177","user":"5003ee7de4b0678c553fc446"},{"problem":"177","code":"(fn balanced? [s]\n  (loop [r s\n         bs ()]\n    (if (empty? r)\n      (empty? bs)\n      (let [[a & b] r]\n        (case a\n          \\( (recur b (cons :par bs))\n          \\) (if (= :par (first bs))\n               (recur b (rest bs))\n               false)\n          \\[ (recur b (cons :brk bs))\n          \\] (if (= :brk (first bs))\n               (recur b (rest bs))\n               false)\n          \\{ (recur b (cons :brc bs))\n          \\} (if (= :brc (first bs))\n               (recur b (rest bs))\n               false)\n          (recur b bs))))))","user":"5ab564f8e4b073f177442639"},{"code":"(fn check-brackets[string]\n  (let [open?            (set \"([{\")\n        close?           (set \")]}\")\n        bracket-relation { \\) \\( ,\n                           \\] \\[ ,\n                           \\} \\{ , }]\n    \n    (letfn [\n      (check-parse\n        [[current-bracket & rest-brackets]\n         [last-open & rest-open :as all-open]]\n        (cond\n\t      (nil?   current-bracket) (nil? last-open) ; When the string ends, no brackets\n                                                    ; should have remained open.\n          (open?  current-bracket) (check-parse rest-brackets\n                                       (cons current-bracket all-open)) ; Store open bracket and continue parsing.\n\n          (close? current-bracket)    (if (= last-open (bracket-relation current-bracket))\n                                        (check-parse rest-brackets rest-open) ; Remove open bracket when it is matched.\n                                         false)))] ; Return failure if the wrong bracket is being closed.\n\t                \n\t  (check-parse\n       (filter #(or (open? %) (close? %)) string)\n       (vector)))))","problem":"177","user":"52f818a6e4b047fd55836fcc"},{"problem":"177","code":"#(let [os {\\( \\) \\[ \\] \\{ \\} } cs (set (vals os))]\n  (loop [[l1 & lx] % [b1 & bx :as bb] [] ]\n   (cond \n    (nil? l1) (nil? b1)\n    (os l1) (recur lx (cons (os l1) bb))\n    (cs l1) (if (= l1 b1) (recur lx bx) false) \n    :else (recur lx bb)  )))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":"177","code":"(fn [s]\n  (let [ft (filter (fn [x] (some (fn [y] (= y x)) '(\\( \\) \\{ \\} \\[ \\]))) s)\n        brackmap { \\) \\(  \\] \\[  \\} \\{}\n        ]\n    (loop [opened '() szn ft]\n      (cond (empty? szn) (empty? opened)\n            (some #(= % (first szn)) '(\\( \\[ \\{))\n                   (recur (concat opened (list (first szn))) (rest szn))\n            (= (brackmap (first szn)) (last opened))\n                                             (recur (butlast opened) (rest szn))\n                   :else false))))","user":"60264d89e4b0d5df2af2222d"},{"problem":"177","code":"(fn [s]\n  (let [mapping {\\) \\( \\] \\[ \\} \\{}\n        close (set (keys mapping))\n        brackets (-> mapping vec flatten set)]\n    (loop [chars (filter brackets s) stack '()]\n      (if-let [ch (first chars)]\n        (if (close ch)\n          (if (= (mapping ch) (first stack))\n            (recur (rest chars) (pop stack))\n            false)\n          (recur (rest chars) (conj stack ch)))\n        (empty? stack)))))","user":"530b8580e4b02e82168697cc"},{"code":"(fn [text]\n  (let [open? (set \"({[\")\n        brackets (set \"(){}[]\")\n        pair-of (apply hash-map \"(){}[]\")]\n    (let [[ok stack]\n          (reduce (fn [[ok stack] tok]\n                    (cond\n                      (not ok) [ok stack]\n                      (not (brackets tok)) [ok stack]\n                      :else (if (open? tok)\n                              [ok (conj stack tok)]\n                              (if (= (pair-of (peek stack)) tok)\n                                [ok (pop stack)]\n                                [false stack])))) [true []] text)]\n      (and ok (empty? stack)))))","problem":"177","user":"536d83cee4b0fc7073fd6e5e"},{"problem":"177","code":"(fn [s]\r\n  (loop [[head & tail] s, stack '()]\r\n    (if (nil? head)\r\n      (empty? stack)\r\n    (if (= head \\[)\r\n      (recur tail (cons \\] stack))\r\n    (if (= head \\()\r\n      (recur tail (cons \\) stack))\r\n    (if (= head \\{)\r\n      (recur tail (cons \\} stack))\r\n    (if (#{\\] \\) \\}} head)\r\n      (if (= head (first stack))\r\n        (recur tail (rest stack))\r\n        false)\r\n    ; else\r\n      (recur tail stack))))))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [e] (let [m (zipmap \"(){}[]\" \")(}{][\")]\n  (empty? (reduce #(if ((set \"({[\") %2) (conj % %2)\n                       (if (= (first %) (m %2)) (rest %) (conj % %2))) () (filter #(m %) e)))\n))","problem":"177","user":"4eb13d60535d7eef3080733f"},{"code":"(fn balanced\n  [s]\n  (let [open #{\\{ \\[ \\(}\n        close {\\} \\{ \\] \\[ \\) \\(}\n        balance-test (reduce (fn [stash letter]\n                               (cond (= stash [:error])                               [:error]\n                                     (get open letter)                                (conj stash letter)\n                                     (and stash (= (get close letter) (first stash))) (rest stash)\n                                     (get close letter)                               [:error]\n                                     :default                                         stash))\n                             '()\n                             s)]\n    (empty? balance-test)))","problem":"177","user":"51f9527fe4b09be9c177e549"},{"problem":"177","code":"#(loop [[c & cs] (filter (set \"(){}[]\") %) delims []]\n    (let [cd ({\\[ \\] \\{ \\} \\( \\)} c)]\n      (cond\n        cd (recur cs (conj delims cd))\n        (= c (peek delims)) (or (nil? c) (recur cs (pop delims))))))","user":"514d8084e4b019235f6c0588"},{"problem":"177","code":"(fn [s]\n   (let [br-map {\"}\" \"{\" \"]\" \"[\" \")\" \"(\"}\n         br-seq (re-seq #\"\\{|\\(|\\[|\\]|\\)|\\}+\" s)]\n     ;(prn (br-map (first br-seq)))\n     ((fn balanced? [obr-seq nbr-seq]\n        (cond\n          (empty? obr-seq) (empty? nbr-seq)\n          (nil? (br-map (first obr-seq))) (balanced? (rest obr-seq) (cons (first obr-seq) nbr-seq))\n          (= (first nbr-seq) (br-map (first obr-seq))) (balanced? (rest obr-seq) (drop 1 nbr-seq))\n          :else false)\n        ) br-seq '())\n     ))","user":"5a4b3abde4b05d388ecb6b81"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}\n        open? (set (keys pairs))\n        close? (set (vals pairs))]\n    (loop [coll s stack '()]\n      (if-let [[f & r] (seq coll)]\n        (cond\n          (open? f) (recur r (conj stack f))\n          (close? f) (when (= (get pairs (first stack)) f)\n                        (recur r (rest stack)))\n          :else (recur r stack))\n        (empty? stack)))))","user":"4e6a4950535d8ccf87e9febf"},{"problem":"177","code":"(fn balanced? [i] (let [bracketMap {\\] \\[  \\} \\{  \\) \\(}\n                          opens (set (vals bracketMap))\n                          closes (set (keys bracketMap))\n                          bracketSet (clojure.set/union opens closes)\n                          brackets (filter #(contains? bracketSet %) (seq i))]\n                      (loop [pendingClose [] toCheck brackets ] (println \"Pending: \" pendingClose \" \" toCheck) (cond\n                                                                  (empty? toCheck) (empty? pendingClose)\n                                                                  (contains? closes (first toCheck)) (if\n                                                                                                       (= (bracketMap (first toCheck)) (last pendingClose))\n                                                                                                       (recur (into [] (drop-last pendingClose)) (rest toCheck))\n                                                                                                       false\n                                                                                                       )\n                                                                  (contains? opens (first toCheck)) (recur (conj pendingClose (first toCheck)) (rest toCheck))\n                                                                  )\n                                                                )))","user":"56427910e4b08d4f616f5f19"},{"code":"(fn [str]\n  (let [open-to-closed { \\[ \\], \\( \\), \\{ \\} }\n        brackets (set (flatten (seq open-to-closed)))]\n    (->> str\n      (reduce (fn [stack char]\n                (cond\n                  (= char (open-to-closed (first stack))) (pop stack)\n                  (brackets char) (conj stack char)\n                  :else stack)) '())\n      (empty?))))","problem":"177","user":"5312cdaae4b08068f379ed03"},{"problem":"177","code":"(fn balanced-bracks? [str]\n  (let [s (java.util.Stack.)\n        inval? (fn [c]\n                 (cond\n                   (or (= c \\()\n                       (= c \\{)\n                       (= c \\[)) (not (.push s c))\n                   (= c \\)) (if (or (.isEmpty s) (not= (.peek s) \\())\n                              true\n                              (not (.pop s)))\n                   (= c \\]) (if (or (.isEmpty s) (not= (.peek s) \\[))\n                              true\n                              (not (.pop s)))\n                   (= c \\}) (if (or (.isEmpty s) (not= (.peek s) \\{))\n                              true\n                              (not (.pop s)))\n                   :else false))]\n    (loop [invalid false, rem (seq str)]\n      (if invalid\n        false\n        (if (empty? rem)\n          (if (not (.isEmpty s))\n            false\n            true)\n          (recur (inval? (first rem)) (rest rem)))))))","user":"590b3aeae4b047aa04b199d0"},{"code":"(fn [s]\r\n   (let [matches (apply str (filter (set (seq \"[](){}\")) s))\r\n         pat #\"\\[\\]|\\(\\)|\\{\\}\"\r\n         ]\r\n     (loop [result matches]\r\n       (prn result)\r\n       (cond\r\n         (not (seq result)) true\r\n         (odd? (count (seq result))) false\r\n         (re-find pat s) (recur (clojure.string/replace result pat \"\"))\r\n         :else false\r\n         )))\r\n   )","problem":"177","user":"51a54fb4e4b0def3c5c586a3"},{"problem":"177","code":"(fn [s]\n  (empty? (let [openpairs {\\{ \\}, \\( \\), \\[ \\]}\n         closepairs {\\} \\{, \\) \\(, \\] \\[}]\n     (reduce (fn [[head & remaining :as stack] nextchar]\n               (cond\n\n                 (and (empty? stack) (get (merge openpairs closepairs) nextchar)) [nextchar]\n                 \n                 (get openpairs nextchar) (cons nextchar stack)\n\n                 (= head (get closepairs nextchar)) remaining\n\n                 :else stack))\n             [] s))))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn [s]\n  (loop [[t & b :as stack] () [f & r :as cs] s]\n    (cond (empty? cs)\n          (empty? stack)\n          (#{\\{ \\[ \\(} f)\n          (recur (cons f stack) r)\n          (#{\\} \\] \\)} f)\n          (if (= f ({\\( \\) \\[ \\] \\{ \\}} t))\n            (recur b r)\n            false)\n          :else\n          (recur stack r))))","problem":"177","user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"#(empty?\n       (reduce\n              (fn [[f & p :as d] c]\n                (cond (#{\\{ \\[ \\(} c) (conj d c)\n                      (#{\\} \\] \\)} c) (if (= f ({\\} \\{ \\] \\[ \\) \\(} c)) p (conj d c))\n                      1 d))\n              () %))","problem":"177","user":"4e52d815535d302ef430da77"},{"code":"#(->> %2\n      (filter #{\\( \\) \\{ \\} \\[ \\]})\n      (reduce (fn [a x] (if (#{\\( \\{ \\[} x) \n                          (% a x) \n                          (if (= (peek a) ({\\) \\( \\} \\{ \\] \\[} x)) \n                            (pop a) \n                            (% a x)))) \n              [])\n      (= []))\n                                                                                          \nconj","problem":"177","user":"4e823ed7535db62dc21a62c7"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\( \\)\n               \\[ \\]\n               \\{ \\}}\n        closing? (set (vals pairs))] \n    (empty?\n      (reduce\n        (fn [bs c]\n          (cond\n            (pairs c) (conj bs (pairs c))\n            (closing? c) (if (= (peek bs) c)\n                           (pop bs)\n                           (conj bs :bad-pop))\n            :else bs))\n        []\n        s))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":"177","code":"(fn balanced?\n  ([s] (balanced? [] s))\n  ([stack s] (if (not (empty? s))\n               (cond\n                (#{\\[ \\( \\{} (first s)) (balanced? (cons (first s) stack) (rest s))\n                (= \\] (first s)) (if (= \\[ (first stack)) \n                                   (balanced? (rest stack) (rest s)) false)\n                (= \\) (first s)) (if (= \\( (first stack)) \n                                   (balanced? (rest stack) (rest s)) false)\n                (= \\} (first s)) (if (= \\{ (first stack)) \n                                   (balanced? (rest stack) (rest s)) false)\n                :else (balanced? stack (rest s)))\n               (empty? stack))))","user":"5e471203e4b043cd24807a2a"},{"problem":"177","code":"(fn __ [s]\n  (let\n    [open-brackets [\"(\" \"[\" \"{\"]\n     close-brackets [\")\" \"]\" \"}\"]\n     bracket-map (zipmap open-brackets close-brackets)\n     result\n     (reduce\n       (fn [stack c]\n         (cond\n           (= stack false) false\n\n           ((set open-brackets) c) (conj stack c)\n\n           ((set close-brackets) c)\n           (if (= c (bracket-map (peek stack)))\n             (pop stack) false)\n\n           :else stack))\n       []\n       (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" s))]\n    (and (not (false? result)) (empty? result))))","user":"56ac81ace4b03c432f187347"},{"problem":"177","code":"#(empty?\n  (reduce (fn [[s & t :as u] x] \n              (cond\n               (= x ({\\{ \\} \\( \\) \\[ \\]} s)) t\n               ((set \"{}()[]\") x) (cons x u)\n               1 u))\n          ()\n          %))","user":"53d86564e4b0e771c302546b"},{"problem":"177","code":"(fn [s] (loop [ss s] \n          (if (re-find #\"[^(){}\\[\\]]+|\\(\\)|\\[\\]|\\{\\}\" ss)\n            (recur (clojure.string/replace ss #\"[^(){}\\[\\]]+|\\(\\)|\\[\\]|\\{\\}\" \"\")) (= ss \"\"))\n))","user":"5951190be4b066ee0a44aea4"},{"problem":"177","code":"(fn bal [str]\n  (loop [st '()\n         [ch & re] (seq str)]\n    (case ch\n      nil (= st ())\n      (\\( \\[ \\{) (recur (cons ch st) re)\n      (\\) \\] \\}) (if (= ch (case (first st) \\) \\( \\] \\[ \\} \\{ \\( \\) \\[ \\] \\{ \\} nil false)) (recur (rest st) re) false)\n      (recur st re))))","user":"56018dd4e4b04bb52996e18f"},{"problem":"177","code":"(let\n    [parens #{\\( \\) \\{ \\} \\[ \\]}\n     paren-match {\\( \\), \\{ \\}, \\[ \\]}]\n    (fn q4q177\n   [s]\n   \"Balancing Brackets\"\n   ((fn bal [ss look-for]\n      (if (empty? ss)\n        (empty? look-for)\n        (let [new-s (drop-while #(not (contains? parens %)) ss)]\n          (if (contains? paren-match (first new-s))\n            ;; Open a new paren\n            (recur (rest new-s) (conj look-for (first new-s)))\n            ;; Parse a closing paren\n            (if (= (first new-s) (paren-match (first look-for)))\n              (recur (rest new-s) (rest look-for))\n              false)))))\n    s '())))","user":"52213426e4b0e6a83c8925c4"},{"problem":"177","code":"(fn [s]\n    (let [pairs {\\{ \\}\n                 \\( \\)\n                 \\[ \\]}]\n      (loop [bs (clojure.string/replace s #\"[^\\{\\}\\[\\]\\(\\)]\" \"\")\n             stk '()]\n        (if-let [xs (seq bs)]\n          (let [nxt (first xs)]\n            (if (get pairs nxt)\n\n              ;; Opening bracket\n              (recur (rest xs) (conj stk nxt))\n\n              ;; Closing bracket\n              (if (= (get pairs (peek stk)) nxt)\n                (if-let [new-stack (seq (rest stk))]\n                  (recur (rest xs) new-stack)\n                  (empty? (rest xs)))\n                false)))\n\n          (empty? stk)))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":"177","code":"(fn [s] (let [obr #{ \\( \\[ \\{ } cbr #{ \\) \\} \\] } cto { \\) \\( \\] \\[ \\} \\{ }] (empty? (reduce (fn [v c] (if (= :error (last v)) v (if (obr c) (conj v c) (if (= (last v) (cto c)) (pop v) [:error])))) [] (filter (clojure.set/union obr cbr) s)))))","user":"5abe2fc2e4b073f17744271e"},{"problem":"177","code":"#(empty? (reduce (fn [[h & t :as c] a]\n                   (cond (= ({\\{ \\} \\[ \\] \\( \\)} h) a) t\n                         (#{\\{ \\} \\[ \\] \\( \\)} a) (conj c a)\n                         :else c))\n                 () %))","user":"543366dde4b0b6b47310fcdf"},{"problem":"177","code":"(fn check-br [stri]\n   (let [check-all (fn [char] (contains? #{\"(\" \"{\" \"[\" \")\" \"}\" \"]\"} (str char)))\n         is-opened (fn [char] (contains? #{\"(\" \"{\" \"[\"} (str char)))\n         is-closed (fn [char] (contains? #{\")\" \"}\" \"]\"} (str char)))\n         check-it  (fn [opened closed] (= (get {\"(\" \")\" \"[\" \"]\" \"{\" \"}\"} (str opened)) (str closed)))]\n     (loop [stack '() stri stri]\n       (if (empty? stri)\n         (if (empty? stack)\n           true\n           false)\n         (if (check-all (first stri))\n           (if (empty? stack)\n             (if (is-opened (first stri))\n               (recur (conj stack (first stri)) (rest stri))\n               false)\n             (if (is-opened (peek stack))\n               (if (check-it (peek stack) (first stri))\n                 (recur (pop stack) (rest stri))\n                 (if (is-opened (first stri))\n                   (recur (conj stack (first stri)) (rest stri))\n                   false))\n               (if (is-closed (peek stack))\n                 (if (check-it (first stri) (peek stack))\n                   (recur (pop stack) (rest stri))\n                   (if (is-closed (first stri))\n                     (recur (conj stack (first stri)) (rest stri))\n                     false)))))\n           (recur stack (rest stri)))))))","user":"5508102ee4b021ccfedb96b0"},{"problem":"177","code":"(fn brax-reduce [string]\n  (let [closers { \\] \\[  \\} \\{ \\) \\( }\n        openers (apply hash-set (vals closers))\n        brack-stack\n        (reduce\n         (fn [s c]\n           (cond\n             (contains? openers c) (conj s c)\n             (contains? closers c)\n             (if (= (first s) (get closers c))\n               (rest s)\n               (conj s (str \" mismatched \" c)))\n             :else s))\n         () string)]\n    (empty? brack-stack)))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":"177","code":"(fn [s]\n    (empty?\n     (reduce\n      #(cond\n         (#{\\( \\[ \\{} %2) (cons %2 %)\n         (= \\) %2) (if (= \\( (first %)) (rest %) (concat % (list false)))\n         (= \\] %2) (if (= \\[ (first %)) (rest %) (concat % (list false)))\n         (= \\} %2) (if (= \\{ (first %)) (rest %) (concat % (list false)))\n         :else (do (println %2) %))\n      ()\n      s)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":"177","code":"(fn a[tstr]\n  (let [blist (apply list (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" tstr))\n        lu { \"{\" \"}\" \"(\" \")\" \"[\" \"]\"}]\n    (loop [st '()\n           runl blist]\n      (cond\n        (and (empty? runl) (empty? st)) true\n        (empty? runl) false\n        (= (get lu (peek st)) (peek runl)) (recur (pop st) (pop runl))\n        :default (recur (conj st (peek runl)) (pop runl))\n        ))))","user":"52f426fce4b05e3f0be25f1e"},{"problem":"177","code":"(fn brackets-match? [code]\n  (letfn [(match? [x y]\n            (or (and (= x \\() (= y \\)))\n                (and (= x \\[) (= y \\]))\n                (and (= x \\{) (= y \\}))))\n          (add-to-stack [stack new]\n            (if (match? (peek stack) new)\n                (pop stack)\n                (conj stack new)))]\n    (->> code\n         (filter #{\\( \\) \\[ \\] \\{ \\}})\n         (reduce add-to-stack [])\n         empty?)))","user":"529e3a4fe4b04e0c58e87b92"},{"code":"#(= [] (reduce \n   (fn [acc c]\n     (let [parens {\\) \\( \\] \\[ \\} \\{}]\n       (cond (.contains \"({[\" (str c)) (cons c acc)\n             (.contains \")}]\" (str c)) \n               (if (= (first acc) (get parens c)) (rest acc)\n                 (cons c acc))\n           :else acc)))\n   '()\n   %))","problem":"177","user":"51e58e02e4b0efabf93c02d0"},{"problem":"177","code":"(fn [s]\n  (let [left-to-right-brackets {\\( \\) \\[ \\] \\{ \\}} \n        right-to-left-brackets {\\) \\( \\] \\[ \\} \\{}]\n    (letfn [\n          (only-brackets [s] (filter #(or (left-to-right-brackets %) (right-to-left-brackets %)) s))\n          (bb [result ch] \n            (if (left-to-right-brackets ch) \n              (conj result ch)\n              (if (= (last result) (right-to-left-brackets ch))\n                (into [] (butlast result))\n                (conj result ch)\n              )\n            )\n          )]\n      (empty? (reduce bb [] (only-brackets s)))\n    )        \n  )\n)","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":"177","code":"#(let [ky {\\[ \\] \\{ \\} \\( \\)}\n       k (-> ky keys set)\n       v (-> ky vals set)]\n   (loop [acc [] [x & xs] %]\n        (cond\n          (k x) (recur (conj acc (ky x)) xs)\n          (v x) (if (= (last acc) x)\n                            (recur (vec (pop acc)) xs)\n                            false)\n          (and (not= acc [])\n               (nil? x)) false\n          (nil? x) true\n          :else (recur acc xs))))","user":"4e6a23d0535d8ccf87e9fea0"},{"code":"(fn [str]\n    (let [opening? #{\\{ \\[ \\(}\n          closing? #{\\} \\] \\)}\n          matches {\\{ \\} \\[ \\] \\( \\)}\n          matched? (fn [c o] (= c (matches o)))] \n        (loop [stack '()\n               todo str]\n            (if (empty? todo)\n              (empty? stack)\n              (let [todo-first (first todo)\n                    todo-rest (rest todo)]\n                  (cond (opening? todo-first)\n                            (recur (cons todo-first stack) todo-rest)\n                        (closing? todo-first)\n                            (if (matched? todo-first (first stack))\n                              (recur (rest stack) todo-rest)\n                              false)\n                        :else\n                            (recur stack todo-rest)))))))","problem":"177","user":"5165a235e4b079ad97ec44ac"},{"code":"(fn [s] (let [foo (fn [stack e]\n                   (cond (not stack) false\n                         (= e \\() (cons :par stack)\n                         (= e \\{) (cons :curl stack)\n                         (= e \\[) (cons :brac stack)\n                         (and (= e \\)) (= (first stack) :par)) (rest stack)\n                         (and (= e \\}) (= (first stack) :curl)) (rest stack)\n                         (and (= e \\]) (= (first stack) :brac)) (rest stack)\n                         :else false))]\n       (= [] (reduce foo '() (filter (into #{} \"{}[]()\") s)))))","problem":"177","user":"4ede8789535d10e5ff6f5337"},{"problem":"177","code":"(fn t117 [ string ]\n  (loop [s string st '()]\n    (let [c (first s)]\n      (cond\n        (empty? s) (empty? st)\n        (or (= c \\{)  (= c \\()  (= c \\[)) (recur (rest s) (conj st c))\n        (= c \\}) (if (= (first st) \\{)\n                   (recur (rest s) (rest st))\n                   false)\n        (= c \\)) (if (= (first st) \\()\n                   (recur (rest s) (rest st))\n                   false)\n        (= c \\]) (if (= (first st) \\[)\n                   (recur (rest s) (rest st))\n                   false)\n        :else (recur (rest s) st)))))","user":"5046f909e4b03b02161376b5"},{"code":"(fn [s]\n    (let [special {\\) \\( \\] \\[ \\} \\{}\n          is-close? #(special %)\n          is-open? #((set (vals special)) %)\n          matching? (fn[c o] (= (special o) c))\n          bm (fn[s stack]\n               (if-let [c (first s)]\n                 (cond\n                  (is-open? c) (recur (rest s) (conj stack c))\n                  (is-close? c)\n                  (when (matching? (first stack) c)\n                    (recur (rest s) (rest stack)))\n                  :else (recur (rest s) stack))\n                 (empty? stack)))]\n      (bm s '())))","problem":"177","user":"52e3e6a8e4b09f7907dd1448"},{"problem":"177","code":"(fn [s]\n  (let [brackets #{[\\( \\)]\n                   [\\{ \\}]\n                   [\\[ \\]]}]\n    (not\n     (reduce\n      #(if (brackets [(first %1) %2]) (next %1) (conj %1 %2))\n      nil\n      (seq (filter (set (apply concat brackets)) s))))))","user":"567b39b6e4b05957ce8c61a3"},{"code":"(fn [s]\n  (let [pairs {\\{ \\} \\( \\) \\[ \\]}]\n    (loop [cs s\n           st []]\n      (if (not (seq cs))\n        (empty? st)\n        (let [c (first cs)]\n          (case c\n            (\\( \\{ \\[) (recur (rest cs) (conj st c))\n            (\\) \\} \\]) (if (= c (pairs (peek st)))\n                         (recur (rest cs) (pop st))\n                         false)\n            (recur (rest cs) st)))))))","problem":"177","user":"4ee8b9c9535d93acb0a66884"},{"problem":"177","code":"(fn [input]\n   (let [char-m {\\) \\(\n                 \\} \\{\n                 \\] \\[}\n         open? (into #{} (vals char-m))]\n     (loop [[s-h & s-tail :as stack] ()\n            [h & tail :as s-seq] (seq input)]\n       (cond\n         (not (seq s-seq)) (empty? stack)\n         (and s-h (= s-h (char-m h))) (recur s-tail tail)\n         (open? h) (recur (cons h stack) tail)\n         (char-m h) false\n         :else (recur stack tail)))))","user":"567d132ee4b05957ce8c61c3"},{"problem":"177","code":"(fn [s]\n  (let [\n    open? (fn [x] (contains? (set \"([{\") x))\n    close? (fn [x] (contains? (set \")]}\") x))\n    close-to-open-map (apply hash-map (interleave \")]}\" \"([{\"))\n    valid-match? (fn [close open] (= open (close-to-open-map close)))\n    remaining \n      (reduce\n        (fn [acc e]\n          (cond\n            (open? e) (concat acc (list e))\n            (close? e) (if (valid-match? e (last acc)) (butlast acc) (concat acc (list e)))\n            :else acc))\n         '()\n         s)]\n    (empty? remaining)))","user":"540d5085e4b0addc1aec670e"},{"code":"(let [brackets \"[](){}\"\n        match    (apply hash-map brackets)\n        regular? #(not ((set brackets) %))]\n    (fn g ([s       ] (g s []))\n         ([[f & r] p] (cond (nil? f)               (empty? p)\n                            (regular? f)           (g r p)\n                            (find match f)         (g r (conj p f))\n                            (= f (match (last p))) (g r (pop  p))\n                            :else                  false))))","problem":"177","user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [s]\n  (let [brackets (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s)\n        matching {\"]\" \"[\" \")\" \"(\" \"}\" \"{\"}]\n    (empty?\n     (reduce\n      (fn [o item]\n        (let [closing? (contains? matching item)]\n          (if (and closing? (= (last o) (get matching item)))\n            (vec (butlast o))\n            (conj o item))))\n      []\n      brackets))))","problem":"177","user":"5225271fe4b01819a2de42f9"},{"problem":"177","code":"(fn [s]\n  (let [open #{\\( \\{ \\[}\n        close {\\) \\(\n               \\} \\{\n               \\] \\[}]\n    (loop [s s\n           stack []]\n      (if (seq s)\n        (let [[x & xs] s]\n          (cond\n            (open x) (recur xs (conj stack x))\n            (close x) (if (= (close x) (peek stack))\n                        (recur xs (pop stack))\n                        false)\n            :else (recur xs stack)))\n        (empty? stack)))))","user":"52470d42e4b05ef8e38e6350"},{"problem":"177","code":"(fn [s]\n    (let [opening-paren { \\} \\{ \\) \\( \\] \\[}]\n    (loop [stacked [] remaining (seq s)]\n      (if (empty? remaining)\n        (empty? stacked)\n        (let [c (first remaining) r (rest remaining)]\n          (cond\n            (#{\\( \\[ \\{} c) (recur (cons c stacked) r)\n            (#{\\) \\] \\}} c) (if (= (opening-paren c) (first stacked)) (recur (rest stacked) r) false)\n            true (recur stacked r)\n            ))))))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn [t]\n  (let [s #{\\( \\) \\[ \\] \\{ \\}}\n        m {\\{ \\} \\} \\{ \\[ \\] \\] \\[ \\( \\) \\) \\(}\n        c (filter s t)\n        f (fn [v sym] (if (= (last v) (m sym)) (pop v) (conj v sym)))]\n    (and (even? (count c))\n         (empty? (reduce f [] c)))))","problem":"177","user":"514721c6e4b0d520409ed392"},{"code":"#(letfn\n   [(f [s] (% s #\"\\[\\]|\\{\\}|\\(\\)\" \"\"))\n    (g [s] (or (= \"\" s)\n               (if-not (= s (f s)) (g (f s)))))]\n   (g (f (% %2 #\"[^\\(\\)\\{\\}\\[\\]]\" \"\"))))\nclojure.string/replace","problem":"177","user":"53973e7be4b0b51d73faaee6"},{"problem":"177","code":"(fn [s]\n  (loop [xs s\n         stack []]\n    (if (empty? xs) (empty? stack)\n        (let [h (first xs)\n              r (rest xs)\n              p (peek stack)\n              m {\\] \\[\n                 \\} \\{\n                 \\) \\(}\n              ok-to-pop (= p (get m h nil))\n              ]\n          (cond\n            (or (= h \\[)\n                (= h \\{)\n                (= h \\()) (recur r (conj stack h))\n            (or (= h \\])\n                (= h \\})\n                (= h \\))) (if ok-to-pop (recur r (pop stack)) false)\n            :else (recur r stack))))))","user":"5866b999e4b0f14aab7c886b"},{"problem":"177","code":"(fn brackbal [s]\n    (loop [v (vec (remove zero? (map #(case % \n                                        \\( 1 \\) -1\n                                        \\[ 2 \\] -2\n                                        \\{ 3 \\} -3\n                                        0) s)))\n           is (remove nil? (map-indexed #(if (> 0 %2) %1 nil) v))]\n      (if-let [i (first is)]\n        (if (zero? i)\n          false\n          (if (zero? (+ (v i) (v (dec i))))\n            (let [w (vec (concat (subvec v 0 (dec i))\n                                 (subvec v (inc i))))]\n              (recur w (remove nil? (map-indexed #(if (> 0 %2) %1 nil) w))))\n            false))\n        (if (empty? v)\n          true\n          false))))","user":"579693d4e4b039eba2ecb0e7"},{"code":"#(let [cp {\\) \\( \\} \\{ \\] \\[}]\n\t(loop [s (list*  (clojure.string/replace % #\"[^\\(\\)\\[\\]\\{\\}]\" \"\")) stack '()]\n  (if (empty? s)\n   (empty? stack)\n   (recur (rest s)\n          (if (and (first stack) (= (cp (first s)) (first stack)))\n              (rest stack)\n              (conj stack (first s)))))))","problem":"177","user":"50c8697ce4b00bb60fe0c53f"},{"problem":"177","code":"(fn [text] (let [brackets {\\{ \\}, \\( \\), \\[ \\]}]\n              (loop [text text\n                     stack []]\n                  (cond\n                   (empty? text) (if (empty? stack) true false)\n                   (brackets (first text)) (recur (rest text) (conj stack (first text)))\n                   ((clojure.set/map-invert brackets) (first text))\n                       (if-let [right-bracket ((set (vals brackets)) (first text))]\n                         (if (= (last stack) ((clojure.set/map-invert brackets) right-bracket))\n                           (recur (rest text) (pop stack))\n                           false))\n                   :else (recur (rest text) stack)))))","user":"53da8fede4b0e771c30254a3"},{"problem":"177","code":"(fn balancing-brackets [s]\n  (let [open? #((set \"([{\") %)\n        closed? #((set \")]}\") %)\n        matches? (fn [open closed] (= ({\\} \\{, \\] \\[, \\) \\(} closed) open))]\n    (loop [cur-stack [], [h & t] s]\n      (cond\n        (nil? h) (empty? cur-stack)\n        (open? h) (recur (conj cur-stack h) t)\n        (closed? h) (if (matches? (peek cur-stack) h)\n                      (recur (pop cur-stack) t)\n                      false)\n        :else (recur cur-stack t)))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn [expression]\n  (let [mates {\\( \\), \\[ \\], \\{ \\}}         ; Characters that must balance.\n        is-closing-char (set (vals mates))  ; Truthy iff char arg. closes expr.\n        step (fn [targets x]\n               (cond\n                 (= x (first targets)) (rest targets)         ; Hit the target.\n                 (is-closing-char x)   [nil]                  ; Forbidden. FAIL\n                 :else                 (if-let [mate (mates x)]\n                                         (cons mate targets)  ; New target.\n                                         targets)))           ; Ordinary char.\n        ]\n    (empty? (reduce step [] expression))))","problem":"177","user":"533b57c3e4b0e30313ee6ccc"},{"problem":"177","code":"(fn [& args]\n    (let [cb {\\} \\{\n              \\) \\(\n              \\] \\[}]\n      (println \"args\" (first args))\n      (loop [my-string (first args)\n             list-of-opens []]\n        (println my-string list-of-opens)\n        (if (and (= 0 (count list-of-opens))\n                 (= 0 (count my-string)))\n            true\n            (if (= 0 (count my-string))\n                false\n                (if (some #{(first my-string)} \"[({\")\n                  (recur (rest my-string) (conj list-of-opens (first my-string)))\n                  (if (some #{(first my-string)} \"})]\")\n                      (if (= (cb (first my-string)) (last list-of-opens))\n                          (recur (rest my-string) (pop list-of-opens))\n                          false)\n                      (recur (rest my-string) list-of-opens))))))))","user":"544e8369e4b0e39780006987"},{"problem":"177","code":"(fn [str]\n  (loop [coll (seq str) stack []]\n    (letfn [(matching-parens [a b]\n              (cond\n                (and (= a \\{) (= b \\})) true\n                (and (= a \\[) (= b \\])) true\n                (and (= a \\() (= b \\))) true\n                :else false))]\n      (cond\n        (empty? coll) (empty? stack)\n        (#{ \\{ \\[ \\(} (first coll)) (recur (rest coll) (cons (first coll) stack))\n        (#{ \\} \\] \\)} (first coll)) (if (matching-parens (first stack) (first coll))\n                                      (recur (rest coll) (rest stack))\n                                      false)\n        :else (recur (rest coll) stack)))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":"177","code":"(fn [s]\n  (let [close->open { \\) \\(, \\} \\{, \\] \\[ }] \n    (loop [rem-brackets (clojure.string/replace s #\"[^(){}\\[\\]]\" \"\")\n           to-close ()]\n      (if (empty? rem-brackets)\n        (empty? to-close)\n        (let [b (first rem-brackets)\n              open-to-b (close->open b)]\n          (if open-to-b\n            (when (and (not-empty to-close)\n                       (= (first to-close) open-to-b))\n              (recur (rest rem-brackets) (rest to-close)))\n            (recur (rest rem-brackets) (conj to-close b))))))))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn balancing [target]\n  (let [bracket-map {\\[ \\] \\{ \\} \\( \\)}\n        bracket-set #{\\[ \\] \\{ \\} \\( \\)}]\n    (letfn [(get-bracket-characters [s] (filter #(contains? bracket-set %) target))          \n            (is-hug? [a b] (or (= b (get bracket-map a 0)) (= a (get bracket-map b 0))))\n            (remove-hugs [l] (cond (empty? l) '()\n                                   (is-hug? (first l) (second l)) (remove-hugs (rest (rest l)))\n                                   :else (cons (first l) (remove-hugs (rest l)))))\n            (recursive-hugs [arr] (if (= (count arr) (count (remove-hugs arr)))\n                                    arr\n                                    (recursive-hugs (remove-hugs arr))))]\n      (zero? (count (recursive-hugs (get-bracket-characters target)))))))","problem":"177","user":"51d360d1e4b099f3b6acddff"},{"problem":"177","code":"(fn balance-parentheses [input]\n  (let [closure? (fn [[a b]]\n              (or (and (= a '\\{) (= b '\\}))\n                  (and (= a '\\[) (= b '\\]))\n                  (and (= a '\\() (= b '\\)))) )\n        remove-closures (fn [stri] (->> stri\n                                       (partition-all 2)\n                                       (remove closure?)\n                                       flatten))\n        interim (->> input\n                    (filter #{'\\{ '\\} '\\( '\\) '\\[ '\\]})\n                    remove-closures\n                    (cons nil)\n                    remove-closures\n                    (apply str))]\n        (cond (= interim input) false\n              (empty? interim) true\n              :else (recur interim))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":"177","code":"(fn legally-nested? [s]\n  \"Is 's' balanced and legally nested?\"\n  (let [remove-bracket-pairs #(-> %\n                                  (clojure.string/replace #\"[^\\(\\)|\\[\\]|\\{\\}]\" \"\")  ;; Keep only brackets.\n                                  (clojure.string/replace #\"\\(\\)|\\[\\]|\\{\\}\" \"\"))    ;; Remove pairs.\n\n        result (remove-bracket-pairs s)]  ;; Remove pairs of brackets.\n    (if (= (count result) (count s))\n      false  ;; No pairs removed, failure.\n      (or (empty? result)  ;; No more brackets: success.\n          (legally-nested? result)))))","user":"500900dee4b0144d4f561e42"},{"problem":"177","code":"(fn [string]\n  (let [matching '{\")\" \"(\" \"}\" \"{\" \"]\" \"[\"}\n        brackets #{\"(\" \")\" \"{\" \"}\" \"[\" \"]\"}]\n    (loop [remaining string stack []]\n      (if (empty? remaining)\n        (empty? stack)\n        (let [c (subs remaining 0 1)]\n          (if (not (contains? brackets c))\n            (recur (subs remaining 1) stack) \n            (if (or (= \"(\" c) (= \"{\" c) (= \"[\" c))\n              (recur (subs remaining 1) (conj stack c))\n              (if (or (= \")\" c) (= \"}\" c) (= \"]\" c))\n                (if (= (last stack) (get matching c))\n                  (recur (subs remaining 1) (into [] (butlast stack)))\n                  false)))))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":"177","code":"(fn [s]\n    (let [includes?* (fn [s substr]\n                       (.contains s substr))\n          s-brackets (apply str\n                            (re-seq #\"[\\[\\]\\(\\)\\{\\}]\"\n                                    s))\n          matching?  (fn [s]\n                       (or (includes?* s \"[]\")\n                           (includes?* s \"()\")\n                           (includes?* s \"{}\")))\n          minimize   (fn minimize [s]\n                       (if (matching? s)\n                         (let [a (clojure.string/replace s #\"\\[\\]\" \"\")\n                               b (clojure.string/replace a #\"\\(\\)\" \"\")\n                               c (clojure.string/replace b #\"\\{\\}\" \"\")]\n                           (minimize c))\n                         s))]\n      (= (minimize s-brackets)\n         \"\")))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":"177","code":"(fn [s]\n  (let [close #(if (= %2 (peek %1)) (pop %1) [:bad])]\n    (empty? (reduce #(cond (#{\\{ \\( \\[} %2) (conj %1 %2)\n                           (= \\} %2) (close %1 \\{)                          \n                           (= \\) %2) (close %1 \\() \n                           (= \\] %2) (close %1 \\[)\n                           :else %1) \n                    [] s))))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":"177","code":"(fn [i]\n  (let [s {\\{ \\}, \\( \\), \\[ \\]}\n        e #{\\} \\) \\]}]\n    (loop [ts `()\n           cs (seq i)]\n      (let [t (first ts)\n            c (first cs)]\n        (if c\n          (cond\n           (= c t) (recur (rest ts) (rest cs))\n           (s c) (recur (conj ts (s c)) (rest cs))\n           (e c) false\n           :else (recur ts (rest cs)))\n          (empty? ts))))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [s]\n  (loop [[o & os :as a] () [h & r] s]\n    (cond\n      (nil? h) (empty? a)\n      (some #(= % h) [\\[ \\( \\{]) (recur (cons h a) r)\n      (some #(= % [o h]) [[\\[ \\]] [\\( \\)] [\\{ \\}]]) (recur os r)\n      (some #(= % h) [\\] \\) \\}]) false\n      :else (recur a r))))","problem":"177","user":"4fd96694e4b05e33b9224f37"},{"problem":"177","code":"(fn [x]\n  (loop [s x\n         o []]\n    (let [c (first s)\n          rs (rest s)\n          l (last o)\n          ro (drop-last o)]\n      (cond (and (empty? s) (empty? o)) true\n            (empty? s) false\n            (= \\] c) (if (= l \\[) (recur rs ro) false)\n            (= \\) c) (if (= l \\() (recur rs ro) false)\n            (= \\} c) (if (= l \\{) (recur rs ro) false)\n            (or (= \\[ c) (= \\( c) (= \\{ c)) (recur rs (conj (vec o) c))\n            :else (recur (rest s) o)))))","user":"5541fa50e4b0a04f79299515"},{"problem":"177","code":"(fn proper-parens [a-str]\n  (nil? (first (let [complements {\\( \\) \\[ \\] \\{ \\}}\n                       open-paren (set (keys complements))\n                       close-paren (set (vals complements))]\n                   (reduce (fn [stack el]\n                             (cond\n                               (= false (first stack)) stack\n                               (open-paren el) (cons el stack)\n                               (close-paren el) (if (= el (complements (first stack)))\n                                                  (rest stack)\n                                                  '(false))\n                               :default stack))\n                           '()\n                           a-str)))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":"177","code":"(partial\n (fn [stack string]\n   (let [token (first string)\n         string (rest string)]\n     (cond\n       (nil? token) (empty? stack)\n       (some #(= % token) \"[{(\") (recur (conj stack token) string)\n       (some #(= % token) \")}]\") (and (= (get {\\( \\) \\{ \\} \\[ \\]} (peek stack))\n                                         token)\n                                      (recur (rest stack) string))\n       :else (recur stack string))))\n '())","user":"54c5cc17e4b045293a27f624"},{"code":"(fn [s]\n  (let [starts {\\( \\) \\[ \\] \\{ \\}}\n        ends {\\) \\( \\] \\[ \\} \\{}\n        bracket? (merge starts ends)]\n    (empty? (reduce (fn [stack ch]\n              (if (bracket? ch)\n                (if-let [start (starts ch)]\n                  (conj stack ch)\n                  (if (= (ends ch) (peek stack))\n                    (pop stack)\n                    (conj stack ch)))\n                stack)) [] s))))","problem":"177","user":"5080a697e4b01a93d3f38e49"},{"problem":"177","code":"(fn\n  [string]\n  (loop [stack '()\n         char-list string]\n    (if (empty? char-list)\n      (empty? stack)\n      (let [bracket (first char-list)\n            pair-map (cond\n                       (some (partial = bracket) \"()\") {:left \\( :right \\)}\n                       (some (partial = bracket) \"{}\") {:left \\{ :right \\}}\n                       (some (partial = bracket) \"[]\") {:left \\[ :right \\]})]\n        (if (empty? pair-map)\n          (recur stack (rest char-list))\n          (if (= bracket (:left pair-map))\n              (recur (cons bracket stack) (rest char-list))\n              (if (= (first stack) (:left pair-map))\n                (recur (rest stack) (rest char-list))\n                false)))))))","user":"5c24671be4b07e362c2305a1"},{"code":"(fn brack-match [s]\n  (let [jb (fn [x] (clojure.string/replace x #\"[^\\(\\)\\{\\}\\[\\]]\" \"\"))\n        cb (fn [x] (clojure.string/replace x #\"\\[\\]|\\(\\)|\\{\\}\" \"\"))\n        bm (fn m [s]\n             (cond\n               (empty? s) true\n               (= (cb s) s) false\n               :else (m (cb s))))]\n    (bm (jb s))))","problem":"177","user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [s]\n  (let [opening-brackets #{\\( \\[ \\{}\n        closing-brackets #{\\) \\] \\}}\n        matching-brackets {\\) \\( \\] \\[ \\} \\{}]\n    (empty?\n     (reduce\n      #(cond\n        (not (nil? (opening-brackets %2)))\n        (cons %2 %1)\n        (not (nil? (closing-brackets %2)))\n        (if (= (matching-brackets %2) (first %1))\n          (rest %1)\n          (cons %2 %1))\n        :else %1) '() s))))","problem":"177","user":"501c1492e4b086d93747d180"},{"code":"(fn [xs] (->> xs \n           (filter #(contains? #{\\( \\) \\{ \\} \\[ \\]} %))\n           (reduce #(let [m {\\( \\) \\[ \\] \\{\\}}]\n                      (if (= (m (peek %1)) %2)\n                        (pop %1)\n                        (conj %1 %2) )) [] ) \n           empty?))","problem":"177","user":"52a04f0ee4b04e0c58e87bc1"},{"problem":"177","code":"(fn [s]\n (let [s (->> (re-seq #\"[\\(\\{\\[\\)\\]\\}]\" s) (apply str))]\n  (clojure.string/blank? ((fn [s] \n     (if (re-find #\"\\(\\)|\\[\\]|\\{\\}\" s)\n      (recur (clojure.string/replace s #\"\\(\\)|\\[\\]|\\{\\}\" \"\"))\n      s)) s))))","user":"56b86e64e4b0f26550335924"},{"code":"(let [parens {\\) \\(, \\} \\{, \\] \\[}]\n   (fn [s]\n     (= [:stack]\n        (reduce #(if (nil? %1) nil\n                   (case %2\n                     (\\( \\{ \\[) (conj %1 %2)\n                     (\\) \\} \\]) (if (= (peek %1) (get parens %2)) (pop %1) nil)\n                     %1))\n                [:stack] s))))","problem":"177","user":"53300924e4b019098a6f8b55"},{"code":"(fn [s]\n  (let [brackets (mapcat seq (re-seq #\"[\\[\\]\\{\\}\\(\\)]\" s))\n        opening  #{\\[ \\{ \\(}\n        match    {\\] \\[, \\) \\(, \\} \\{}]\n    (loop [bs brackets ,stack []]\n      (if-let [b (first bs)]\n        (if (opening b)\n          (recur (next bs) (conj stack b))\n          (when (= (get match b) (peek stack))\n            (recur (next bs) (pop stack))))\n        (empty? stack)))))","problem":"177","user":"51d19c24e4b0cfcf579466c3"},{"problem":"177","code":"(fn [xs]\n  (let [p {\\[ \\], \\{ \\}, \\( \\)}\n        q {\\] \\[, \\} \\{, \\) \\(}]\n    (loop [[x & more] xs s []]\n      (cond\n        (nil? x) (empty? s)\n        (p x) (recur more (conj s x))\n        (q x) (if (empty? s) false\n                  (if (= (q x) (peek s))\n                    (recur more (pop s))))\n        :else (recur more s)))))","user":"4dc1ee85535d020aff1edf91"},{"problem":"177","code":"(fn [s]\n  (loop [s (seq s)\n         t ()]\n    (if (seq s)\n      (case (first s)\n        \\] (if (= (first t) \\[) (recur (rest s) (rest t)) false)\n        \\) (if (= (first t) \\() (recur (rest s) (rest t)) false)\n      \t\\} (if (= (first t) \\{) (recur (rest s) (rest t)) false)\n        \\[ (recur (rest s) (cons (first s) t))\n        \\( (recur (rest s) (cons (first s) t))\n        \\{ (recur (rest s) (cons (first s) t))\n        (recur (rest s) t))\n      (empty? t))))","user":"5799ff45e4b05b1deef9add1"},{"problem":"177","code":"(fn balance [s]\n  (let [o {\"}\" \"{\", \"]\" \"[\", \")\" \"(\"} st (re-seq #\"[\\(\\)\\{\\}\\[\\]]{1}\" s)]\n    (loop [b 0 l st c (first l) p nil]\n      (print \"b: \" b \" l: \" l \" c: \" c \" p: \" p \"\\n\")\n      (if (empty? l) \n        (if (= b 0) true false)\n      \t(if (and p (o c) (not= (o c) p)) \n          false\n          (recur (+ b (if (o c) -1 1)) (rest l) (second l) (if (o c) nil (first l))))))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":"177","code":"(fn balanced-parens? [s]\n  (let [ps (seq (apply str (re-seq #\"\\(|\\)|\\{|\\}|\\]|\\[\" s)))\n        le {\\[ \\]\n            \\( \\)\n            \\{ \\}}]\n    (loop [acc [] eat ps]\n      (if (empty? eat)\n        (if (empty? acc)\n          true\n          false)\n        (let [cur (first eat)]\n          (if (contains? (set (keys le)) cur)\n            (recur (conj (vec acc) cur) (rest eat))\n            (if (= (le (last acc)) cur)\n              (recur (butlast acc) (rest eat))\n              false)))))))","user":"4f6ba7bce4b07046d9f4efb0"},{"code":"#(empty?\n    (reduce (fn [[s & t :as u] x] \n              (cond\n                (= x ({\\{ \\} \\( \\) \\[ \\]} s)) t\n                ((set \"{}()[]\") x) (cons x u)\n                1 u))\n            ()\n            %))","problem":"177","user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn brace-match? [s]\n  (let [brace-pairs #{'(\\( \\)) '(\\[ \\]) '(\\{ \\})}\n        open-braces (set (map first brace-pairs))\n        close-braces (set (map second brace-pairs))\n        braces (filter #(or (contains? open-braces %) (contains? close-braces %)) s)\n        iter (fn iter [stack opened]\n               (cond\n                (empty? stack) (empty? opened)\n                (contains? open-braces (first stack)) (iter (rest stack) (cons (first stack) opened))\n                (contains? close-braces (first stack))\n                  (if (contains? brace-pairs (list (first opened) (first stack)))\n                    (iter (rest stack) (rest opened))\n                    false\n                    )\n                )\n               )\n        ]\n  (iter braces '())\n    ))","problem":"177","user":"529d4f4be4b04e0c58e87b79"},{"problem":"177","code":"(fn [s] (-> s\n            (clojure.string/replace #\"[^\\[\\(\\{\\)\\}\\]]\" \"\")\n            (#(loop [x-old %]\n                (let [x-new (clojure.string/replace x-old #\"(\\[\\]|\\(\\)|\\{\\})\" \"\")]\n                  (cond (= x-old \"\") true\n                        (= x-old x-new) false\n                        :else (recur x-new)))))))","user":"5ec3a13ae4b08d0ec38692b9"},{"code":"(fn [s]\n  (let [pairs {\"[\" \"]\", \"(\" \")\", \"{\" \"}\"}\n        start (set (keys pairs))]\n    (loop [stack nil\n           braces (re-seq #\"[\\]\\[{}()]\" s)]\n      (if (empty? braces)\n        (empty? stack)\n        (let [brace (first braces)]\n          (cond\n           (start brace)           (recur (cons (get pairs brace) stack) (rest braces))\n           (= (first stack) brace) (recur (rest stack) (rest braces))\n           :else false))))))","problem":"177","user":"4e80aa10535db62dc21a62b1"},{"code":"(fn [s]\n    (let [brs {\\( \\) \\{ \\} \\[ \\]}]\n      (loop [curr-s s brackets-found '()]\n        (let [next-char (first curr-s)]\n          (cond\n            (empty? curr-s)\n              (if (empty? brackets-found) true false)\n            (or (= next-char \\() (= next-char \\{) (= next-char \\[))\n              (recur (rest curr-s) (cons next-char brackets-found))\n            (or (= next-char \\)) (= next-char \\}) (= next-char \\]))\n              (if (= next-char (get brs (first brackets-found)))\n                (recur (rest curr-s) (rest brackets-found))\n                false)\n            :else\n              (recur (rest curr-s) brackets-found))))))","problem":"177","user":"526f9715e4b03e8d9a4a7372"},{"problem":"177","code":"(fn  [col]\n  (let [l #{\\( \\[ \\{}\n        r #{\\) \\] \\}}\n        m (zipmap r l)]\n    (empty? \n     (reduce (fn [a x]\n               (cond\n                (l x) (cons x a)\n                (r x) (if (= (first a) (m x)) (rest a) (cons x a))\n                :else a))\n             [] col))))","user":"53b7c21ae4b047364c0444d4"},{"problem":"177","code":"(fn[s]\n   (let [ss (re-seq #\"[{}()\\[\\]]\" s)]\n     (every? #(= \\n %) (nth (iterate #(->> %\n                           (partition-all 2)\n                            (map (fn[s] (apply str s)))\n                            (remove #{\"()\" \"{}\" \"[]\"})\n                            (apply str)\n                            ((fn [s] (str \"n\" s \"n\")))) ss) (/ (count ss) 2)))))","user":"5d764e52e4b02e6b30c93524"},{"problem":"177","code":"(fn balanced?\n    [s]\n    (let [tokens (-> (clojure.string/replace s #\"[^\\(\\)\\[\\]\\{\\}]\" \"\"))\n          brackets {\\( \\) \\[ \\] \\{ \\}}\n          opening-bracket? (fn [x] (brackets x))\n          matching-bracket? (fn [a b] (= b (brackets a)))]\n      (loop [stack '()\n             [curr & more] tokens]\n        (if (nil? curr)\n          (empty? stack)\n          (recur (if (or (opening-bracket? curr)\n                         (not (matching-bracket? (first stack) curr)))\n                   (conj stack curr)\n                   (rest stack))\n                 more)))\n      ))","user":"538ca203e4b0b51d73faae5f"},{"problem":"177","code":"(fn [s]\n  (loop [s (seq s) bs ()]\n    (if-let [ch (first s)]\n      (cond\n        (#{ \\{ \\( \\[ } ch)\n          (recur (rest s) (cons ({\\{ \\} \\( \\) \\[ \\]} ch) bs))\n        (#{ \\} \\) \\] } ch)\n          (when (= ch (first bs))\n            (recur (rest s) (rest bs)))\n        :else\n          (recur (rest s) bs))\n      (empty? bs))))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":"177","code":"(fn [x]\n  (let [s #{\\( \\) \\{ \\} \\[ \\]}\n        t #{\"()\" \"{}\" \"[]\"}\n        v (filter #(s %) x)]\n    (if (= '() (reduce #(if (t (str (first %) %2)) (rest %) (conj % %2)) '() v))\n      true\n      false)))","user":"566d71b1e4b0a866af6896ca"},{"problem":"177","code":"(fn __\n  ([s] (__ (into [] (clojure.string/replace s #\"[^\\(\\)\\{\\}\\[\\]]\" \"\")) []))\n  ([s stack]\n   (cond\n     (and (empty? s) (empty? stack)) true\n     (and (empty? s) (not (empty? stack))) false\n     :else\n     (let [c (peek s)]\n       (if (some #(= c %) [\\) \\} \\]])\n         (__ (pop s) (conj stack c))\n         (if (some #(= (conj #{} c (peek stack)) %) [#{\\( \\)} #{\\[\\]} #{\\{\\}}])\n           (__ (pop s) (pop stack))\n           false))))))","user":"55e206f3e4b050e68259b429"},{"problem":"177","code":"(fn balance [in-str]\n  (loop [xs (seq in-str) stack []]\n    (if (empty? xs)\n      (empty? stack)\n      (case (first xs)\n        \\( (recur (rest xs) (conj stack \\()) \n        \\{ (recur (rest xs) (conj stack \\{)) \n        \\[ (recur (rest xs) (conj stack \\[)) \n        \\) (if (= (peek stack) \\()\n             (recur (rest xs) (pop stack))\n             false)\n        \\} (if (= (peek stack) \\{)\n             (recur (rest xs) (pop stack))\n             false)\n        \\] (if (= (peek stack) \\[)\n             (recur (rest xs) (pop stack))\n             false)\n        (recur (rest xs) stack)))))","user":"4ff769bce4b0678c553fc38f"},{"problem":"177","code":"(fn [x] (= \"\" ( \n         (fn peu [y z] \n           (if (empty? y) z\n             (let [w (first y) s (partial apply str) p #(case % \\) \\( \\] \\[ \\} \\{)]\n                (case w\n                  (\\( \\[ \\{) (peu (s (rest y)) (s (concat z (str w))))\n                  (\\) \\] \\}) (peu (s (rest y)) (if (= (p w) (last z)) (s (butlast z)) \"w\"))\n                  (peu (s (rest y)) z)\n                 )\n               )\n             )\n           )\n           \n          x \"\"\n         ))\n)","user":"53fc8424e4b0de5c418485b3"},{"problem":"177","code":"(fn f ([s] (f [] (re-seq #\"[\\[\\)\\(\\}\\{\\]]\" s)))\n  ([c s] (if (empty? s) \n             (if (empty? c) true false)\n             (let [x (first s) t (rest s) y (last c)] \n               (if (some #(= x %) [\"[\" \"(\" \"{\"]) \n                 (f (conj c x) t)\n                 (if (or (and (= \"]\" x) (= \"[\" y)) (and (= \")\" x) (= \"(\" y)) (and (= \"}\" x) (= \"{\" y)))\n                   (f (vec (butlast c)) t) false))))))","user":"5c41db45e4b08cd430848ece"},{"code":"(fn __ [s]\n  (let [parens-matches {\\[ \\], \\( \\), \\{ \\}}\n        parens #{\\[ \\], \\( \\), \\{ \\}}]\n    (empty? (reduce (fn [stack n]\n                      (cond\n                        (= n (parens-matches (peek stack))) (pop stack)\n                        (parens n) (conj stack n)\n                        :else stack))\n                    []\n                    s))))","problem":"177","user":"52463059e4b09dbe66b56198"},{"code":"(fn f [s]\n  (let [mp {\\( \\) \\[ \\] \\{ \\} \\) \\( \\] \\[ \\} \\{}]\n    (loop [ss (seq s) st [6]]\n      (if (empty? ss)\n        (if (= 1 (count st))\n          true\n          false)\n        (if (contains? mp (first ss))\n          (if (= (get mp (last st)) (first ss))\n            (recur (next ss) (pop st))\n            (recur (next ss) (conj st (first ss))))\n          (recur (next ss) st))))))","problem":"177","user":"52196842e4b0890f2f822bfa"},{"code":"#(empty?\n  (reduce (fn [l i]\n            (if (= (first l)\n                   ({\"]\" \"[\" \"}\" \"{\" \")\" \"(\"} i 0))\n              (rest l)\n              (conj l i)))\n          nil\n          (re-seq #\"[\\[\\]{}()]\" %)))","problem":"177","user":"4e7dfab0535db169f9c796f9"},{"code":"(fn m\n  ([s] (m s (list)))\n  ([[f & r] s]\n   (let [o (into {} (map vec (partition 2 \"()[]{}\")))\n         c (clojure.set/map-invert o)]\n     (cond \n       (not f) (empty? s)\n       (o f) (m r (cons f s))\n       (c f) (if (= (c f) (first s))\n                            (m r (rest s))\n                            false)\n       :else (m r s)))))","problem":"177","user":"52951156e4b02ebb4ef7501b"},{"problem":"177","code":"(fn [str]\n   (empty? (reduce\n      (fn [a b]\n        (cond\n          (or (= b \\{) (= b \\[) (= b \\()) (conj a b)\n          (or (and (= b \\}) (= (last a) \\{))\n              (and (= b \\)) (= (last a) \\())\n              (and (= b \\]) (= (last a) \\[))) (into [] (butlast a))\n          (or (= b \\})\n              (= b \\))\n              (= b \\])) (conj a \"x\")\n          :else a\n          ))\n      []\n      str)))","user":"5c936583e4b048ec896c5a1c"},{"code":"(fn [s]\n  (let [brackets             (clojure.string/replace s #\"[^\\[\\]\\{\\}\\(\\)]\" \"\")\n        open?                #{\\( \\{ \\[}\n        closed?              #{\\) \\} \\]}\n        match?               (fn [o c]\n                               (= c ((zipmap open? closed?) o)))\n        bb?                  (fn bb? [remaining stack]\n                               (let [b (first remaining)]\n                                 (cond (empty? remaining) (empty? stack)\n                                       (closed? b) (if (match? (first stack) b)\n                                                                  (bb? (rest remaining) (rest stack))\n                                                                  false)\n                                       (open? b) (bb? (rest remaining) (conj stack b)))))\n        ]\n    (bb? brackets '())))","problem":"177","user":"510cd1dde4b078ea71921124"},{"problem":"177","code":"(fn balanced-brackets? [snippet]\n  (letfn [(inverse [br] ({\\( \\), \\{ \\}, \\[ \\]} br))\n          (open-brancket? [ch] (#{\\( \\{ \\[ } ch))\n          (closing-bracket? [ch] (#{\\) \\} \\]} ch))\n          (add-or-remove [[br & brkts :as allbrkts] ch]\n            (cond\n              (open-brancket? ch) (cons ch allbrkts)\n              (closing-bracket? ch) (if (= (inverse br) ch) brkts (cons ch allbrkts))\n              :else allbrkts ))]\n  (empty? (reduce add-or-remove nil snippet))))","user":"52e657e4e4b09f7907dd1472"},{"problem":"177","code":"(fn [s]\n  (let [closing-opening-map {\\} \\{, \\] \\[, \\) \\(}\n        opening (set (vals closing-opening-map))\n        closing (set (keys closing-opening-map))]\n    (loop [[head & tail :as s] s\n           open []]\n      (if (empty? s)\n        (empty? open)\n        (cond\n         (opening head) (recur tail (conj open head))\n         (closing head) (and (= (closing-opening-map head) (peek open))\n                             (recur tail (pop open)))\n         :else (recur tail open))))))","user":"5424c523e4b01498b1a71b03"},{"problem":"177","code":"(fn me [test-str]\n\n  (let [\n          new-str-seq (re-seq #\"\\{|\\}|\\(|\\)|\\[|\\]\" test-str)\n\n\n         matcher (fn  [a b]\n\n            (let [ cond1 (and (= a \"{\") (= b \"}\"))\n\n                  cond2 (and (= a \"[\") (= b \"]\"))\n\n                  cond3 (and (= a \"(\") (= b \")\"))\n                ] \n\n                (or cond1 cond2 cond3)\n            ))\n\n\n         r-fn (fn [res a]\n\n                (if (matcher (first res) a) \n\n                    (rest res)\n\n                   (cons a res)\n              ))\n\n      ]\n\n      (= 1 (count (reduce r-fn (list \"\") new-str-seq)))\n  )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":"177","code":"(fn brackes\n  [sentence]\n  (let [filtered-sentence (filter #{\\( \\) \\[ \\] \\{ \\}} sentence)\n        close-1           [\\( \\)]\n        close-2           [\\[ \\]]\n        close-3           [\\{ \\}]]\n    (loop [stack '()\n           xs    filtered-sentence]\n      (let [f-stack (first stack)\n            x       (first xs)]\n        (if (not (seq xs))\n          (not (seq stack))\n          (if (and (nil? f-stack) (#{\\) \\] \\}} x))\n            false\n            (if (or (= [f-stack x] close-1)\n                    (= [f-stack x] close-2)\n                    (= [f-stack x] close-3))\n              (recur (rest stack) (rest xs))\n              (recur (conj stack x) (rest xs)))))))))","user":"5afcd6d1e4b0cc2b61a3bd17"},{"problem":"177","code":"(fn [l]\n  (letfn [(openingBracket? [x] (or (= \\( x) (= \\{ x) (= \\[ x)))\n          (closingBracket? [x] (or (= \\) x) (= \\} x) (= \\] x)))\n          (matchingOpening [x] (cond (= \\) x) \\( (= \\} x) \\{ (= \\] x) \\[ :else nil))]\n  (empty? \n   (reduce \n   \t(fn [v el]\n      (cond (openingBracket? el) \n            \t(concat v [el])\n            (closingBracket? el)\n            \t(if (= (last v) (matchingOpening el))\n                  (vec (drop-last v))\n                  (concat v [el]))\n            :else\n                  v))\n    []\n    l))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":"177","code":"(fn verify-parens [text]\n (let [parens \"()[]{}\"\n       parens-map (apply hash-map parens)\n       open-parens? parens-map\n       matches? (fn [b1 b2] (= b2 (parens-map b1)))\n       not-parens? (complement (set parens))]\n  (loop [[x & xs :as letters] text\n         stack (list)]\n   (cond\n    (empty? letters) (empty? stack)\n    (not-parens? x) (recur xs stack)\n    (open-parens? x) (recur xs (conj stack x))\n    (matches? (first stack) x) (recur xs (rest stack))\n    :closing-parens? false))))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":"177","code":"(fn  [s]\n  (let [bs (filter #(contains? #{\\[ \\] \\( \\) \\{ \\}} %) s)]\n    (loop [re bs\n           cur []]\n           (do (println (apply str re))\n               (println (apply str cur))\n           (if (empty? re) (empty? cur)\n               (if (contains? #{\\[ \\{ \\(} (first re)) \n                   (recur (rest re) (conj (vec cur) (first re)))\n                   (if (empty? cur) false\n                     (let [nx (first re)\n                           tobep (last cur)]\n                       (if (or (and (= nx \\}) (= tobep \\{))\n                               (and (= nx \\]) (= tobep \\[))\n                               (and (= nx \\)) (= tobep \\()))\n                               (recur (rest re) (drop-last cur))\n                               false)\n                   ))\n               ))\n      )\n    )\n  )\n)","user":"52faec2ee4b047fd55837004"},{"code":"(fn [x]\n    (loop [[f & r] (re-seq #\"[\\[\\]{}()]\" x)\n           t '()]\n      (if f\n        (cond\n         (= f \"[\") (recur r (conj t \"]\"))\n         (= f \"(\") (recur r (conj t \")\"))\n         (= f \"{\") (recur r (conj t \"}\"))\n         (= f (peek t)) (recur r (pop t))\n         true false)\n        (empty? t))))","problem":"177","user":"523ed522e4b057c4b7cd0a78"},{"problem":"177","code":"(fn [string]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}]\n    (loop [[ch & more] string\n           stack []]\n      (if (nil? ch) (empty? stack)\n          (if (pairs ch) (recur more (cons ch stack))\n              (if (some #{ch} (vals pairs))\n                (and (= ch (pairs (first stack))) (recur more (rest stack)))\n                (recur more stack)))))))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [s] \n  (let [bs (filter #(#{\\( \\) \\[ \\] \\{ \\}} %) s)\n        step (fn [[b & rs :as bs] [fret & rret :as ret]] \n               (cond (empty? bs) ret\n                     (#{\\( \\[ \\{} b) (recur rs (conj ret b)) \n                     (= ({\\) \\(, \\] \\[, \\} \\{} b) fret) (recur rs rret)\n                     :else (conj ret b)))]\n     (empty? (step bs '()))))","problem":"177","user":"5246e945e4b0644eb7b0783b"},{"problem":"177","code":"(fn [s]\n  (let [p\n        (fn p [brackets s]\n          (cond (and (empty? brackets) (empty? s))\n                true\n                (and (not (empty? brackets)) (empty? s))\n                false\n                :else\n                (let [f (first s)\n                      r (rest s)\n                      bs {\\} \\{, \\) \\(, \\] \\[}]\n                  (cond (or (= f \\{) (= f \\() (= f \\[))\n                        (p (conj brackets f) r)\n                        (or (= f \\}) (= f \\)) (= f \\]))\n                        (if (= (peek brackets) (bs f))\n                          (p (pop brackets) r)\n                          false)\n                        :else\n                        (p brackets r)))))]\n    (p [] s)))","user":"53664e3be4b0243289761e74"},{"problem":"177","code":"#(let [ops [\\[ \\( \\{]\n       cls [\\] \\) \\}]\n       pairs (zipmap cls ops)]\n   (loop [s % stack ()]\n     (if-let [[c & s] s]\n       (if ((set ops) c)\n         (recur s (cons c stack))\n         (if-let [op (pairs c)]\n           (and (= op (first stack))\n                (recur s (rest stack)))\n           (recur s stack)))\n       (empty? stack))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn balance-parens [s]\n  (let [opp {\\( \\) \\[ \\] \\{ \\}}\n        ends #{\\) \\] \\}}]\n    (empty? (reduce\n      #(if (contains? opp %2)\n        (conj % %2)\n        (if (= %2 (opp (first %)))\n          (rest %)\n          (if (contains? ends %2)\n            (conj % \\!)\n            %\n            )))\n      '() s))))","problem":"177","user":"53307da1e4b019098a6f8b5e"},{"problem":"177","code":"(fn [x]\n  (letfn [(pars [a b]\n              (cond \n                (empty? b) (empty? a)\n                (some #{(first b)} #{\"(\" \"[\" \"{\"}) (pars (cons (first b) a) (rest b))\n                (= ({\"(\" \")\" \"[\" \"]\" \"{\" \"}\"} (first a)) (first b)) (pars (rest a) (rest b))\n                true false))]\n    (pars () (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" x))))","user":"53e91473e4b036ad0777e495"},{"problem":"177","code":"(fn balanced?\n  [s]\n  (let [opening #{\\( \\[ \\{}\n        closing {\\) \\( \\] \\[ \\} \\{}]\n    (loop [xs (vec (filter (set \"()[]{}\") s))\n           stack []]\n      (cond\n        (empty? xs) (empty? stack)\n        (contains? opening (first xs)) (recur (rest xs) (conj stack (first xs)))\n        (= (get closing (first xs)) (peek stack)) (recur (rest xs) (pop stack))\n        :else false))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [s]\n  (let [sww (clojure.string/replace s #\"[^\\(\\)\\[\\]\\{\\}]\" \"\")\n        prx #\"\\(\\)|\\[\\]|\\{\\}\"\n        ps (clojure.string/replace sww prx \"\")]\n    (cond (= ps \"\") true\n          (re-find prx ps) (recur ps)\n          :else false)))","problem":"177","user":"51e00020e4b01188f0627534"},{"code":"(fn [s] (let [l (filter \n#(some #{\\( \\) \\[ \\] \\{ \\} } [%])\ns) ]\n ((fn ban [x] (cond\n (empty? x) true\n (not (some  #(or (= % [\\( \\)]) \n (= % [\\{ \\}]) (= % [\\[ \\]]))\n (partition 2 1 x)))\n false\n  :else (ban (loop [v [] ls x]\n  (cond (empty? ls) v\n   (empty? (rest ls)) \n  (conj v (first ls)) \n   (or (= (take 2 ls) [\\( \\)]) \n (= (take 2 ls) [\\{ \\}])\n  (= (take 2 ls)   [\\[ \\]])) \n  (recur v (drop 2 ls))\n        :else\n   (recur (conj v (first ls)) \n  (rest ls))) )) )) l)\n ))","problem":"177","user":"517945dce4b0684c1c981a43"},{"code":"(fn balanced? [s]\n  (let [open? #(#{\\{ \\[ \\(} %)\n        match? (fn [o c] (= c ({\\( \\) \\{ \\} \\[ \\]} o)))\n        verify (fn [[x & rst] [o & oo' :as oo] ]\n                 (cond (nil?     x) (empty? oo)\n                       (open?    x) (recur rst (cons x oo))\n                       (match? o x) (recur rst oo')\n                       :else        false))]\n    (verify (filter (into #{} \"{}[]()\") s) '() )))","problem":"177","user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn [s]\n  (empty?\n   (reduce #(let [p {\\} \\{ \\] \\[ \\) \\(}\n                   m (p %2)]\n              (cond\n               ((set (vals p)) %2) (conj % %2)\n               m (if (= (last %) m) (vec (drop-last %)) (conj % %2))\n               :else %)) [] s)))","problem":"177","user":"52479487e4b05ef8e38e6373"},{"problem":"177","code":"(fn [s]\n    (let [is-starter? #{\\( \\[ \\{}\n          is-ender? #{\\) \\] \\}}\n          get-opener {\\) \\( \\] \\[ \\} \\{}]\n      (loop [[h & t :as mys] (seq s)\n             state []]\n        (cond\n          (empty? mys) (empty? state)\n          (is-starter? h) (recur t (cons h state))\n          (is-ender? h) (if (= (get-opener h) (first state))\n                          (recur t (rest state))\n                          false)\n          :else (recur t state)))))","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":"177","code":"(fn balanced?                                                                      \n  [x]                                                                                \n  (let [tokens (vec (clojure.string/replace x #\"[^\\(\\)\\[\\]\\{\\}]\" \"\"))                \n        brackets { \\{ \\} \\( \\) \\[ \\]}                                                \n        starting-bracket? (fn [x] (brackets x))                                      \n        matching-bracket? (fn [a b] (= (brackets a) b))]                             \n    (loop [stack '()                                                                 \n           [curr & more] tokens]                                                     \n      (if (nil? curr)                                                                \n        (empty? stack)                                                               \n        (recur (if (or (starting-bracket? curr)                                      \n                       (not (matching-bracket? (first stack) curr)))                 \n                 (conj stack curr)                                                   \n                 (rest stack))                                                       \n               more)))))","user":"57227f10e4b0c5bde472c0cd"},{"problem":"177","code":"#(nil?\n   (reduce\n     (fn [[h & t :as s] x]\n       (cond\n         (= ({\\( \\) \\[ \\] \\{ \\}} h) x) t\n         ((set \"([{}])\") x)            (cons x s)\n         :e                            s))\n     nil\n     %))","user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(let [pairs [\"{}\" \"()\" \"[]\"]\n      openers (map first pairs)\n      closers (map last pairs)\n      closer? (into #{} closers)\n      match (into {} (map vector openers closers))\n      balanced (fn balanced\n                 ([string]\n                    (balanced (seq string) []))\n                 ([string stack]\n                    (cond\n                     (every? empty? [string stack]) true\n                     (empty? string) false\n                     :else (let [char (first string)\n                                 to-match (last stack)\n                                 needed (match to-match)]\n                             (cond\n                              (= char needed) (recur (rest string) (pop stack))\n                              (closer? char) false\n                              (match char) (recur (rest string) (conj stack char))\n                              :else (recur (rest string) stack))))))]\n  balanced)","problem":"177","user":"4ffc10aae4b0678c553fc3d6"},{"problem":"177","code":"(letfn \n  [; Remove all but brackets.\n   (clean [s]  \n     (clojure.string/replace s #\"[^{}\\[\\]()]\" \"\"))]\n\n  (fn [s]\n    (loop [s (clean s), prev-s \"\"]\n      (if (empty? s) true\n        (if (= s prev-s) false\n          (recur \n           ; Remove consecutive pairs of matching brackets.\n           (clojure.string/replace s #\"\\(\\)|\\[\\]|\\{\\}\" \"\")\n           s))))))","user":"53065acbe4b02e8216869792"},{"problem":"177","code":"#(= '() \n   (reduce\n    (fn [acc c]\n      (cond\n        (= ({\\} \\{ \\] \\[ \\) \\(} c :nf) (first acc)) (rest acc)\n        (#{\\} \\{ \\] \\[ \\) \\( } c) (conj acc c)\n        :else acc))\n    '()\n    %))","user":"567c63f6e4b05957ce8c61bb"},{"problem":"177","code":"(fn brackshit [s] \n  (let [opening #{\\( \\{ \\[}\n        closing #{\\) \\} \\]}]\n    (loop [left (apply str (re-seq #\"[\\(\\)\\{\\}\\[\\]]\" s))\n           stack '()\n           ]\n      (if (empty? left)\n        (if (empty? stack)\n          true\n          false\n          )\n\n        (if (contains? opening (first left))\n          (recur (rest left)\n                  (conj stack (first left)))\n          (if (or \n                (and\n                  (= (first stack) \\()\n                  (= (first left) \\)))\n                (and \n                  (= (first stack) \\[)\n                  (= (first left) \\]))\n                (and\n                  (= (first stack) \\{)\n                  (= (first left) \\}))\n              )\n            (recur (rest left)\n                    (rest stack))\n            false))))\n  \n  \n  \n  )\n  )","user":"5143824ae4b0b4fb4ace5f36"},{"problem":"177","code":"(fn [xs]\n  (->> xs\n       (reduce\n         (fn [{:keys [forbidden curly square round] :as acc} x]\n           (merge-with\n             #(%1 %2)\n             (case x\n               \\{ {:curly inc :forbidden (constantly [\\] \\)])}\n               \\} {:curly dec :forbidden (constantly [])}\n               \\[ {:square inc :forbidden (constantly [\\} \\)])}\n               \\] {:square dec :forbidden (constantly [])}\n               \\( {:round inc :forbidden (constantly [\\] \\}])}\n               \\) {:round dec :forbidden (constantly [])}\n               {:other identity :forbidden (constantly forbidden)})\n             (if (or (some neg? [curly square round])\n                     (some #{x} forbidden))\n               (merge acc {:violated true})\n               acc)))\n         {:curly 0 :square 0 :round 0 :forbidden [] :violated false})\n       (#(and (not (:violated %1))\n              (every? zero? ((juxt :curly :square :round) %1))))))","user":"554bd33ce4b0a04f7929959a"},{"problem":"177","code":"(fn [s]\n  (let [bs {\\[ \\] \\( \\) \\{ \\}}\n        [open? close?] (map set [(keys bs) (vals bs)])]\n    (let [res (reduce (fn [s c]\n              (when s (cond \n               (open? c) (conj s c)\n               (close? c) (when (= c (bs (peek s))) (pop s))\n               :default s)))\n            []\n            s)]\n      (and (vector? res) (= (count res) 0)))))","user":"4e0e0529535d04ed9115e7b9"},{"problem":"177","code":"(fn balanced? [s]\n  (let [matches #{[\\( \\)] [\\{ \\}] [\\[ \\]]}\n        add (fn [acc c]\n              (assoc acc :stack (conj (:stack acc) c)))\n        del (fn [acc c]\n              (if (contains? matches [(peek (:stack acc)) c])\n                (assoc acc :stack (pop (:stack acc)))\n                (assoc acc :failure true)))\n\n        {:keys [stack failure]}\n        (reduce (fn [acc c]\n                  (let [op (case c\n                             \\( add \\{ add \\[ add\n                             \\] del \\) del \\} del\n                             (constantly acc))]\n                    (op acc c)))\n                {:stack [] :failure false} s)]\n\n    (and (empty? stack) (not failure))))","user":"5a257747e4b07f18be40aa1f"},{"problem":"177","code":"(fn [s]\n    (let [pars   (vec (apply str (re-seq (re-pattern \"[\\\\Q[](){}\\\\E]\") s)))\n          open?  #{\\{ \\( \\[}\n          match? {\\} \\{ \\) \\( \\] \\[}]\n      (loop [pars  pars\n             stack []]\n        (if-let [f (first pars)]\n          (if (open? f)\n            (recur (next pars) (conj stack f))\n            (if (= (match? f) (peek stack)) \n              (recur (next pars) (pop stack))))\n          (empty? stack)))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn check-brackets [s]\n  (let [brackets #\"[\\[\\]\\(\\)\\{\\}]\"\n        brackmap {\"[\" \"]\" \"(\" \")\" \"{\" \"}\" }\n        check (fn [stack brack]\n          (when stack\n            (if-let [close (brackmap brack)]\n              (conj stack close)\n              (when (= (peek stack) brack)\n                (pop stack)\n              ))))\n        better-but-reduced-not-supported (comment\n          check (fn [stack brack]\n            (if-let [close (brackmap brack)]\n              (conj stack close)\n              (if (= (peek stack) brack)\n                (pop stack)\n                (reduced nil))\n            )))\n      ]\n    (let [res (reduce check [] (re-seq brackets s))]\n      (and res (zero? (count res)))\n    )))","problem":"177","user":"4df3d4f4535d08e6dec9fe2c"},{"problem":"177","code":"(fn [s]\n  (let [m {\\] \\[ \\} \\{ \\) \\(}\n        brackets (filter (set \"[]{}()\") s)]\n        (loop [[c & r] brackets stack ()]\n          (cond \n           (nil? c) (empty? stack)\n           (nil? (m c)) (recur r (conj stack c))\n           (= (m c) (peek stack)) (recur r (rest stack))\n           :else false))))","user":"56ae214ce4b03c432f18735a"},{"problem":"177","code":"(fn [s]\n  (let [m {\\} \\{ \\] \\[ \\) \\(}]\n    (loop [[h & t] (seq s) a '()]\n      (cond\n        (nil? h) (empty? a)\n        (some #(= h (val %)) m) (recur t (conj a h))\n        (some #(= h (key %)) m) (when (= (peek a) (m h)) (recur t (pop a)))\n        :1 (recur t a)))))","user":"5590e55de4b0277789237676"},{"problem":"177","code":"(fn [data]\n  (empty? (reduce\n            (fn [stack c]\n              (if-let [closing ({\\{ \\} \\( \\) \\[ \\]} c)]\n                (conj stack closing)\n                (if (= (peek stack) c) (pop stack) [false]))); (reduced [c]) \n            []\n            (filter (set \"{}[]()\") data))))","user":"59c94a69e4b0a024fb6ae576"},{"problem":"177","code":"(fn [s]\n  (let [coll (filter #{\\( \\) \\[ \\] \\{ \\}} s)\n        brakets {\\) \\( \\] \\[ \\} \\{}]\n    (loop [acc '()\n           [x & xs] coll]\n      (if x\n        (if (brakets x)\n          (if (= (brakets x) (first acc))\n            (recur (next acc) xs)\n            false)\n          (recur (conj acc x) xs))\n        (empty? acc)))))","user":"554b8572e4b0a04f79299589"},{"problem":"177","code":"(fn [s]\n  (loop [brackets (apply str (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s))]\n    (if (seq brackets)\n      (let [new-brackets (clojure.string/replace brackets #\"\\{\\}|\\(\\)|\\[\\]\" \"\")]\n        (if (= brackets new-brackets)\n          false\n          (recur new-brackets)))\n      true)))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn [s]\n   (let [m {\\[ \\] \\{ \\} \\( \\)}]\n     (loop [xs  (filter (set (flatten (seq m))) s)\n            acc []]\n       (if-let [[x & xs] xs]\n         (recur xs\n                (if (= x (m (peek acc)))\n                  (vec (butlast acc))\n                  (conj acc x)))\n         (empty? acc)))))","problem":"177","user":"4dda44f2535d02782fcbe9f1"},{"problem":"177","code":"(fn [s]\n  (let [open? #{\\( \\[ \\{}\n        close? #{\\) \\] \\}}\n        pairs (zipmap close? open?)]\n    (loop [[head & tail :as coll] s\n           stack (list)]\n      (if (seq coll)\n        (cond (open? head) (recur tail (conj stack head))\n              (close? head) (when (= (pairs head) (first stack)) (recur tail (pop stack)))\n              :else (recur tail stack))\n        (empty? stack)))))","user":"50310713e4b05b7df5a0b84c"},{"code":"(fn [s]     \n    (let [r {\\} \\{ \\] \\[ \\) \\(}\n          g (fn [stack c]\n              (if (= (peek stack) (r c))\n                (pop stack)))\n          f (fn [stack c]\n             (when stack \n               (case c\n                 ( \\[ \\{ \\( ) (conj stack c)\n                 ( \\] \\} \\) ) (g stack c)\n                 stack)))]\n      (= '() (reduce f '() s))))","problem":"177","user":"4ff3df0fe4b0678c553fc355"},{"problem":"177","code":"(fn [s]\n  (let [b #{\\[ \\{ \\( \\] \\} \\)}\n        o [\\[ \\{ \\(]\n        f [\\] \\} \\)]]\n    (loop [c (filter #(contains? b %) s)\n           p []]\n      (if (empty? c)\n        (empty? p)\n        (if (>= (.indexOf o (first c)) 0)\n          (recur (rest c) (concat p [(first c)]))\n          (if (= (.indexOf f (first c)) (.indexOf o (last p)))\n            (recur (rest c) (butlast p))\n            false))))))","user":"55205564e4b08d5046aa8a60"},{"problem":"177","code":"(fn p177\n  [s]\n  (let [s (apply str (keep #{\\( \\) \\{ \\} \\[ \\]} s))]\n    ((fn tiger\n       [s]\n       (let [rep clojure.string/replace\n             proc (rep (rep (rep s \"()\" \"\") \"[]\" \"\") \"{}\" \"\")]\n         (if (= s proc)\n           (not (seq s))\n           (tiger proc)))) s)))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":"177","code":"(fn [bracket-string]\n    (let [bracket-pairs {\"}\" \"{\"\n                         \"]\" \"[\"\n                         \")\" \"(\"}\n          open-brackets (fn [open-brackets next-bracket]\n                          (if (some #{next-bracket} (keys bracket-pairs))\n                            ;; we have a closing bracket\n                            (if (= (bracket-pairs next-bracket)\n                                   (first open-brackets))\n                              ;; we just closed a bracket\n                              (rest open-brackets)\n                              false)\n                            (if (some #{next-bracket} (vals bracket-pairs))\n                              (conj open-brackets next-bracket)\n                              false)))]\n      (empty? (loop [open-bs '() bracket-seq (re-seq #\"[\\{\\}\\(\\)\\[\\]]\" bracket-string)]\n                (if-let [next-bracket (first bracket-seq)]\n                  (if-let [next-open-brackets (open-brackets open-bs next-bracket)]\n                    (recur next-open-brackets (rest bracket-seq))\n                    bracket-seq)\n                  open-bs)))))","user":"52f53589e4b05e3f0be25f2c"},{"problem":"177","code":"(fn __ [s]\n  (let [parhsh {\\) \\(, \\] \\[, \\} \\{ }\n        parsetb (set (vals parhsh))\n        parsete (set (keys parhsh))\n        parset (into parsetb parsete)\n        brcks (filter #(get parset %) s)]\n    (empty?\n     (reduce (fn [res c]\n               (cond\n                (empty? res) (cons c res)\n                (parsete c) (if (= (parhsh c) (first res)) (rest res) (cons c res))\n                (parsetb c) (cons c res)))\n             '() brcks)\n       )))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn balanced? [input]\n  (let [brackets \"()[]{}\"\n        matching (apply hash-map brackets)\n        opening (set (keys matching))\n        closing (set (vals matching))\n        balance (reduce\n                  (fn [stack ch]\n                    (cond\n                      (opening ch)\n                        (conj stack ch)\n                      (closing ch)\n                        (let [last (peek stack)\n                              desired (matching last)]\n                          (if (= desired ch)\n                            (pop stack)\n                            (conj stack :invalid)))\n                      :else\n                        stack))\n                  '()\n                  input)]\n    (zero? (count balance))))","problem":"177","user":"514c2d05e4b02b8cbb2a9278"},{"problem":"177","code":"(fn [s]\n  (let [p {\\[ \\], \\{ \\}, \\( \\)} se (filter #(not (nil? (re-find #\"\\(|\\)|\\{|\\}|\\[|\\]\" (str %)))) (seq s))]\n    (empty? (reduce #(if (= %2 (get p (last %))) (into [] (drop-last %)) (conj % %2)) [] se))))","user":"551c66dae4b07993ea3788de"},{"problem":"177","code":"(fn [s]\n   (let [match { \\( \\) \\[ \\] \\{ \\} }\n         close-paren #{ \\) \\] \\} }]\n     (loop [[ch & remain] s\n            stack nil]\n       (cond\n         (nil? ch) (empty? stack)\n         (match ch) (recur remain (cons (match ch) stack))\n         (close-paren ch) (if (= ch (first stack))\n                            (recur remain (rest stack))\n                      false)\n         :else (recur remain stack)\n         ))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":"177","code":"(fn [s]\n  (let [in #{\\(\\[\\{} out #{\\)\\]\\}}]\n    (loop [s s st []]\n      (if-let [ch (first s)]\n        (cond (in ch) (recur (rest s) (conj st ch))\n              (out ch) (let [match (peek st)]\n                         (if (= match (case ch \\) \\( \\] \\[ \\} \\{))\n                           (recur (rest s) (pop st))))\n              :else (recur (rest s) st))\n        (empty? st)))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":"177","code":"(fn [s]\n  (let [t (fn [stack letter]\n            (if stack\n              (cond\n               ((set \"([{\") letter) (cons letter stack)\n               (= letter \\)) (if (and (seq stack) (= (first stack) \\()) (rest stack) false)\n               (= letter \\]) (if (and (seq stack) (= (first stack) \\[)) (rest stack) false)\n               (= letter \\}) (if (and (seq stack) (= (first stack) \\{)) (rest stack) false)\n               :else stack)\n              false)) \n        a (reduce t [] s)]\n    (and a (empty? a))))","user":"55625903e4b0c656e3ff17d7"},{"problem":"177","code":"(fn [s]\n   (loop [tar (map str (seq s))\n          stack '()]\n     (if (empty? tar)\n       (empty? stack)\n       (cond\n         (re-find #\"[\\(\\{\\[]\" (first tar)) (recur (rest tar) (cons (first tar) stack))\n         (re-find #\"[\\)\\}\\]]\" (first tar)) (if (some #(= % (str (first stack) (first tar))) [\"()\" \"[]\" \"{}\"])\n                                             (recur (rest tar) (rest stack))\n                                             false)\n         :else (recur (rest tar) stack)))\n     ))","user":"55a372f1e4b0acc240e31537"},{"problem":"177","code":"(fn balanced-paren? [text]                           (let [paren-pairs {\\( \\)                                                \\{ \\}                                                \\[ \\]}                                  paren-pairs-r {\\) \\(                                                \\} \\{                                                \\] \\[}]\n\n        (loop [text text                                            stack '()]                                      (if (empty? text)                                      (empty? stack)                                       (let [[h & t] text                                         may-match-paren (get paren-pairs-r h)]\n          (cond (get paren-pairs h)                                  (recur t (cons h stack))                                                                                  (and may-match-paren                                      (= may-match-paren (first stack)))                                                                  (recur t (rest stack))                                                                                    (and may-match-paren                                      (not= may-match-paren (first stack)))                                                               false                                                                                                     :else                                                (recur t stack)))))))","user":"5895477fe4b00487982d527c"},{"problem":"177","code":"(fn [s]\n    (let [iset #{ \\( \\{ \\[}\n          cmap { \\} \\{ \\) \\( \\] \\[ }]\n     (letfn [(se [[f & r] a]\n               (cond\n                (nil? f) a\n                (contains? iset f) (se r (cons f a))\n                (contains? cmap f) (if (= (first a) (get cmap f)) (se r (rest a)) (se r (cons f a)))\n                :else (se r a)))]\n       (empty? (se s [])))))","user":"4f3ec266e4b0e243712b1f8c"},{"problem":"177","code":"(fn\n  [s]\n  (let\n    [pairs {\\( \\) \\[ \\] \\{ \\}}]\n  \t(loop\n  \t\t[brackets (filter #{\\( \\) \\[ \\] \\{ \\}} s)\n     \tbracketStack '()]\n    \t(if (empty? brackets)\n      \t\t(empty? bracketStack)\n      \t\t(if (pairs (first brackets))\n        \t\t(recur (rest brackets) (cons (first brackets) bracketStack))\n        \t\t(if (= (pairs (first bracketStack)) (first brackets))\n          \t\t\t(recur (rest brackets) (rest bracketStack))\n          \t\t\tfalse\n        \t\t)\n            )\n        )\n      )\n    )\n  )","user":"56449e4de4b0284900eef5f9"},{"problem":"177","code":"#(loop [[c & m] %\n        s ()]\n   (case c\n     nil (empty? s)\n     \\( (recur m (cons \\) s))\n     \\[ (recur m (cons \\] s))\n     \\{ (recur m (cons \\} s))\n     (\\) \\] \\}) (if (= c (first s))\n                  (recur m (rest s))\n                  false)\n     (recur m s)))","user":"50ed4626e4b01236b1d4983c"},{"code":"(fn [s]\n  (let [rights {\\} \\{, \\] \\[, \\) \\(}\n        lefts (set (vals rights))]\n    (loop [[c & cs :as s] s stk '()]\n      (cond\n        (empty? s) (empty? stk)\n        (lefts c) (recur cs (cons c stk))\n        (rights c) (when (= (first stk) (rights c)) (recur cs (rest stk)))\n        :else (recur cs stk)))))","problem":"177","user":"527cd633e4b0757a1b17136f"},{"code":"(fn [s]\n  (loop [res (clojure.string/replace s #\"[^\\(\\)\\[\\]\\{\\}]+\" \"\")]\n    (let [nres (-> res\n                 (clojure.string/replace \"()\" \"\")\n                 (clojure.string/replace \"[]\" \"\")\n                 (clojure.string/replace \"{}\" \"\"))]\n      (if (= res nres)\n        (not (not-empty res))\n        (recur nres)))))","problem":"177","user":"5028cd0fe4b01614d1633ffc"},{"problem":"177","code":"(fn balanced? [s]\n        (let [p1 {\\{ \\}, \\( \\), \\[ \\]}\n              p2 (clojure.set/map-invert p1)]\n          (empty? \n           (reduce (fn [stack item]\n                     (cond\n                       (p1 item) (conj stack item)\n                       (and (p2 item) (= (peek stack) (p2 item))) (pop stack)\n                       :else (conj stack item)))\n                   []\n                   (filter #(or (p1 %) (p2 %)) s)))))","user":"540c54a7e4b0addc1aec6700"},{"problem":"177","code":"(fn [bs]\n  (let [o conj\n        c (fn [m]\n            (fn [st _]\n              (when (= m (peek st))\n                (pop st))))\n        bra {\\( o\n             \\[ o\n             \\{ o\n             \\) (c \\()\n             \\] (c \\[)\n             \\} (c \\{)}]\n    (= [] (reduce (fn [s x]\n                    (if-let [b (bra x)]\n                      (b s x) s))\n                  [] bs))))","user":"54acf5c7e4b09f271ff37cdd"},{"problem":"177","code":"(fn [s]\n  (let [m {\\( \\)\n           \\) \\(\n           \\[ \\]\n           \\] \\[\n           \\{ \\}\n           \\} \\{}]\n    (loop [ss (seq s)\n           stack '()]\n      (if (empty? ss)\n        (empty? stack)\n        (let [[x & xs] ss\n              [t & ts] stack\n              y (m x)]\n          (cond\n            (nil? y) (recur xs stack)\n            (= t y)  (recur xs ts)\n            :else    (recur xs (conj stack x))))))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":"177","code":"(fn balanced-brackets\n  [s]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}]\n    (empty? (or (reduce (fn [acc c]\n                          (if (not acc)\n                            acc\n                            (cond\n                              (contains? #{\\( \\[ \\{} c) (cons c acc)\n                              (contains? #{\\) \\] \\}} c) (if (= c (pairs (first acc))) (rest acc) false)\n                              :else acc)))\n                         '() s) '(1)))))","user":"56897739e4b0dcc4269f407d"},{"problem":"177","code":"(fn balanced [s]\n    (let\n      [\n        do-balance\n        (fn [s]\n          (reduce\n            (fn [[bs r] c]\n              (cond\n                (= c \\()\n                [(apply vector (conj bs c)) r]\n\n                (= c \\{)\n                [(apply vector (conj bs c)) r]\n\n                (= c \\[)\n                [(apply vector (conj bs c)) r]\n\n                (= c \\))\n                (if\n                  (= \\( (last bs))\n                  [(apply vector (butlast bs)) r]\n                  [bs false]\n                )\n\n                (= c \\})\n                (if\n                  (= \\{ (last bs))\n                  [(apply vector (butlast bs)) r]\n                  [bs false]\n                )\n\n                (= c \\])\n                (if\n                  (= \\[ (last bs))\n                  [(apply vector (butlast bs)) r]\n                  [bs false]\n                )\n\n                :else\n                [bs r]\n              )\n            )\n            [[] true]\n            s\n          )\n        )\n\n        [bs r] (do-balance s)\n      ]\n      (and\n        r\n        (empty? bs)\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn [i]\n  (let [m {\\) \\( \\] \\[ \\} \\{}]\n    (if-let [v (reduce #(cond\n                          (#{\\( \\[ \\{} %2) (conj % %2)\n                          (#{\\) \\] \\}} %2) (if (and (seq %) (vector? %) (= (peek %) (m %2)))\n                                             (pop %)\n                                             #{})\n                          :else %) [] i)]\n      (and (vector? v) (empty? v)))))","problem":"177","user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn balanced? [s]\n  (let [m {\"(\" \")\", \"[\" \"]\", \"{\" \"}\"}]\n    (loop [[b & r] (re-seq #\"[\\(\\[\\{\\}\\]\\)]\" s), stack '()]\n      (if-not b\n        (empty? stack)\n        (if (m b)\n          (recur r (conj stack b))\n          (if (= b (m (peek stack)))\n            (recur r (pop stack))\n            false))))))","problem":"177","user":"52039e12e4b0fb7e47ea51ff"},{"problem":"177","code":"(let [lookup {\"{\" \"}\", \"[\" \"]\", \"(\" \")\"}\n      extract (fn [text] (apply str (filter #(contains? (-> lookup seq flatten set) (str %)) text)))]\n  (fn balanced? [text]\n    (let [extracted (extract text)]\n      (loop [opening (-> extracted first str) parenthesis (rest extracted) result [] skip 0]\n        (let [item (-> parenthesis first str)]\n          (cond\n            (= \"\" extracted) true\n            (not (contains? lookup opening)) false\n            (empty? parenthesis) false\n            (= opening item) (recur opening (rest parenthesis) (vec (conj result item)) (inc skip))\n            (= (get lookup opening) item)\n              (if (zero? skip)\n                (and (balanced? (apply str result)) (balanced? (apply str (rest parenthesis))))\n                (recur opening (rest parenthesis) (vec (conj result item)) (dec skip))\n              )\n            :else\n              (recur opening (rest parenthesis) (vec (conj result item)) skip)\n          )\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [st]\n           (let [pairs {\\[ \\] \\{ \\} \\( \\)}\n                 open (set (keys pairs))\n                 close (set (vals pairs))\n                 check (fn [[fst & rst :as state] ch]\n                         (cond (open ch) (cons ch state)\n                               (close ch) (if (= (pairs fst) ch) rst [:fail])\n                               :default state))]\n             (empty? (reduce check [] (seq st)))))","problem":"177","user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn problem-177 [s]\n  (let [brackets (filter #(re-matches #\"[\\{\\}\\[\\]()]\" (str %)) s)\n        opens [\\{ \\[ \\(]\n        closed [\\} \\] \\)]\n        pairs {\\] \\[ \\} \\{ \\) \\(}\n        find-solution (fn fs [stack bs]\n                        (let [f (first bs)\n                              r (rest bs)]\n                          (cond\n                            (empty? bs) (empty? stack)\n                            (some #{f} opens ) (fs (conj stack f) r)\n                            (some #{f} closed) (if (= (pairs f) (last stack))\n                                                   (fs (pop stack) r)\n                                                   false)\n                            :else false\n                            )))]\n    (find-solution [] brackets)))","problem":"177","user":"506c0a02e4b0eda3100c090d"},{"problem":"177","code":"(let [table {\\( 1 \\[ 2 \\{ 3 \\) -1 \\] -2 \\} -3}\n      parse (fn parse [ss stack]\n              (let [x (first ss)]\n                (if x\n                  (if (> x 0)\n                    (parse (rest ss) (conj stack x))\n                    (and (first stack) (= x (- 0 (first stack))) (parse (rest ss) (rest stack))))\n                  (not (first stack)))))]\n  (fn [s]\n    (let [ss (filter identity (map table (vec s)))]\n      (parse ss '()))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn sanity-check\n  ([xs] \n    (sanity-check '() xs))\n  ([accum xs] \n    (let [brackets [\\[ \\] \\( \\) \\{ \\}]\n          matches (apply hash-set (partition 2 brackets))\n          [_ after] (split-with #(not ((set brackets) %)) xs)\n          bracket (first after)\n          remainder (rest after)]\n      (if (empty? after)\n        (empty? accum)\n        (do \n          (println (clojure.string/join accum))\n          (if (matches [(first accum) bracket])\n          (recur (rest accum) remainder)\n          (recur (conj accum bracket) remainder)))))))","problem":"177","user":"524740e7e4b05ef8e38e635d"},{"code":"(fn B [s]\n  (let [l {\\( \\) \\[ \\] \\{ \\}}\n        r {\\) \\( \\] \\[ \\} \\{}]\n   (loop [s s p '()]\n     (cond (empty? s) (empty? p)\n           (l (first s)) (recur (rest s) (conj p (l (first s))))\n           (r (first s)) (and (not (empty? p))\n                              (= (first p) (first s))\n                              (recur (rest s) (rest p)))\n           :else (recur (rest s) p)))))","problem":"177","user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn brackets-ok? [s]\n  (let [pairs {\\( \\), \\) \\(, \\{ \\}, \\} \\{, \\[ \\], \\] \\[}]\n    ((comp not seq) (reduce (fn [bs nxt]\n                              (if (pairs nxt)\n                                (if (= (peek bs) (pairs nxt))\n                                  (if (seq bs) (pop bs))\n                                  (conj bs nxt))\n                                bs))\n                            [] s))))","problem":"177","user":"50645e12e4b007509339a58a"},{"problem":"177","code":"(fn [str]\n   (let [parens {\\{ \\}\n                 \\[ \\]\n                 \\( \\)}]\n     (loop [parens-stack [] [s & xs] str]\n       (if s\n         (if (contains? (set (keys parens)) s)\n           (recur (conj parens-stack s) xs)\n           (if (contains? (set (vals parens)) s)\n             (if (= (get parens (last parens-stack)) s)\n               (recur (vec (butlast parens-stack)) xs)\n               false)\n             (recur parens-stack xs)))\n         (empty? parens-stack)))))","user":"5048202fe4b0ec70b3ef8d9a"},{"problem":"177","code":"(fn [s]\n    (let [pairs {\\] \\[\n                \\} \\{\n                \\) \\(}]\n      (letfn [(open? [p]\n                (contains? (into #{} (vals pairs)) p))\n              (close? [p]\n                (contains? (into #{} (keys pairs)) p))\n              (pair? [p l]\n                (= (get pairs p) l))]\n        (loop [stack []\n               [f & r :as s] s]\n          (println \"stack\" stack)\n          (if (seq s)\n            (cond\n              (open? f) (recur (conj stack f) r)\n              (close? f) (if (pair? f (last stack))\n                           (recur (into [] (butlast stack)) r)\n                           false)\n              :else (recur stack r))\n            ;; end of string\n            (zero? (count stack)))))))","user":"569f4dabe4b0542e1f8d1491"},{"problem":"177","code":"(fn [s]\n   (loop [s (seq s)\n          v '()]\n     (let [h (first s)\n           t (rest s)]\n       (cond\n         (empty? s) (empty? v)\n         (or (= h \\[) (= h \\{) (= h \\()) (recur t (conj v h))\n         (or (= h \\]) (= h \\}) (= h \\))) (if (and (not-empty v)\n                                                  (or\n                                                   (and (= h \\]) (= (first v) \\[))\n                                                   (and (= h \\}) (= (first v) \\{))\n                                                   (and (= h \\)) (= (first v) \\())))\n                                           (recur t (rest v))\n                                           false)\n         :else (recur t v)))\n     ))","user":"5f3f2281e4b004f08c61c561"},{"code":"(fn [s]\n  (let [ms {\\) \\( \\} \\{ \\] \\[}]\n    (loop [[h & t :as l]  s\n           [c & r :as st] []]\n      (if l\n        (cond (#{\\( \\{ \\[} h) (recur t (cons h st))\n              (#{\\) \\} \\]} h) (if (->> h (get ms) (not= c)) nil (recur t r))\n              :else           (recur t st))\n        (empty? st)))))","problem":"177","user":"4ee9ddb8535d93acb0a66896"},{"problem":"177","code":"(fn balanced?\n                     ([str]\n                        (balanced? str '()))\n                     ([str coll]\n                        (cond\n                         (empty? str)\n                         (empty? coll)\n\n                         (contains? #{\\( \\[ \\{} (first str))\n                         (balanced? (rest str) (cons (first str) coll))\n\n                         (contains? #{\\) \\] \\}} (first str))\n                         (and (= (first coll) (get { \\) \\(\n                                                     \\] \\[\n                                                     \\} \\{ } (first str))) (balanced? (rest str) (rest coll)))\n\n                         :else\n                         (balanced? (rest str) coll)\n                         )))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":"177","code":"(fn bal? [s]\n  (let [pattern #\"\\([^\\(\\{\\}\\]\\[]*?\\)|\\{[^\\{\\(\\)\\]\\[]*?\\}|\\[[^\\[\\{\\}\\(\\)]*?\\]|[^\\[\\]\\{\\}\\(\\)]*\"\n        s1 (clojure.string/replace s pattern \"\")]\n    (cond \n      (empty? s1) true\n      (= (count s1) (count s)) false\n      :else (bal? s1))))","user":"50336c6be4b0c6c1199c710f"},{"problem":"177","code":"#(let [matches {\\) \\(, \\] \\[, \\} \\{}]\n   (loop [stack '(), [c & cs] %]\n     (cond\n      (nil? c) (empty? stack)\n      (#{\\{ \\[ \\(} c) (recur (cons c stack) cs)\n      (#{\\} \\] \\)} c) (if (= (first stack) (matches c))\n                        (recur (rest stack) cs)\n                        false)\n      :else (recur stack cs))))","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":"177","code":"(fn all-squared-away [s]\n  (let [openers (seq \"({[\")\n        closers (seq \")}]\")\n        bracket-map (zipmap openers closers)\n        s (seq s)\n        stack '()]\n    (loop [s s stack stack]\n      (if (seq s)\n        (let [c (first s)]\n          (cond (some #(= % c) openers)\n                (recur (rest s) (conj stack c))\n                (some #(= % c) closers)\n                (let [f (get bracket-map (first stack))]\n                  (recur (rest s) (if (= f c) (rest stack) (conj stack c))))\n                :else (recur (rest s) stack)))\n        (= 0 (count stack))))))","user":"56f4cedce4b046a417f92063"},{"problem":"177","code":"(fn [s]\n  (let [get-brackets (fn [s] (let [brackets '(\\{ \\} \\[ \\] \\( \\))]\n    (loop [[r & more :as all] (seq s)\n           acc '[]]\n      (if all\n        (if (some #(= r %) brackets)\n          (recur more (conj acc r))\n          (recur more acc))\n        acc))))\n        sanity-check-brackets (fn [coll] (loop [[r & more :as all] coll\n         expecting '[]]\n    (if all\n      (let [r-match (case r\n                      (\\{) \\}\n                      (\\}) \\{\n                      (\\[) \\]\n                      (\\]) \\[\n                      (\\() \\)\n                      (\\)) \\(\n                      ())]\n        (if (= (last expecting) r)\n          (recur more (vec (drop-last expecting)))\n          (recur more (conj expecting r-match))))\n      (empty? expecting))))]\n        (sanity-check-brackets (get-brackets s))))","user":"5c718e6ce4b0fca0c1622796"},{"problem":"177","code":"#(let [end-to-begin-bracket { \\) \\(, \\] \\[, \\} \\{ }]\n\t(loop [stack '() code %1]\n\t(if (empty? code)\n\t\t(empty? stack)\n\t\t(let [first-char (first code), rest-code (rest code)]\n\t\t\t(cond\n\t\t\t\t((set \"({[\") first-char)\n\t\t\t\t\t(recur (conj stack first-char) rest-code)\n\t\t\t\t((set \")}]\") first-char)\n\t\t\t\t\t(if (and (not (empty? stack)) (= (first stack) (end-to-begin-bracket first-char)))\n\t\t\t\t\t\t(recur (rest stack) rest-code)\n\t\t\t\t\t\tfalse)\n\t\t\t\t:else\n\t\t\t\t\t(recur stack rest-code))))))","user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn [s]\n    (let [left { \\( \\) \\[ \\] \\{ \\} }\n          right (clojure.set/map-invert left)]\n      (empty?\n        (reduce\n          (fn [t x]\n            (cond\n              (contains? left x) (cons x t)\n              (= (right x ) (first t)) (rest t)\n              (contains? right x) (cons x t)\n              :else t))\n          '() (seq s)))))","problem":"177","user":"525f51bde4b0cb4875a45dc8"},{"problem":"177","code":"(fn balanced-brackets? [s]\n  (let [bracket? #{ \\(  \\) \\{  \\} \\[  \\] }\n        closing-bracket { \\(  \\), \\{  \\}, \\[  \\] }]\n    (empty? (reduce (fn [stack c]\n                      (if (= c (closing-bracket (last stack)))\n                        (pop stack)\n                        (conj stack c))) [] (filter bracket? s)))))","user":"53fd66a4e4b0de5c418485e3"},{"problem":"177","code":"(fn balanced? [string]\n  (empty?\n   (let [opening-mate { \\) \\(, \\] \\[, \\} \\{ }]\n     (reduce\n      (fn [s c]\n        (cond\n         (empty? s)       [c]\n         (#{\\( \\[ \\{} c)  (conj s c)\n         :else            (if (= (last s) (opening-mate c))\n                            (subvec s 0 (dec (count s)))\n                            [:bad])))\n      []\n      (filter #{\\( \\) \\[ \\] \\{ \\}} string)\n      ))))","user":"530bf87ee4b02e82168697d5"},{"problem":"177","code":"(fn [str]\n  (let [s (->> str\n               seq\n               (filter #{ \\( \\) \\{ \\} \\[ \\] }))]\n    (loop [bs s lb ()]\n      (cond (empty? bs) (empty? lb)\n            (#{ \\( \\{ \\[ } (first bs)) (recur (rest bs) (cons (first bs) lb))\n            (empty? lb) false\n            (= (first bs) ({ \\( \\), \\{ \\}, \\[ \\] } (first lb))) (recur (rest bs) (rest lb))\n            :else false))))","user":"55c20bd0e4b0e31453f64972"},{"problem":"177","code":"(fn balanced? [s]\n  (let [p {\\( \\) \\[ \\] \\{ \\}}\n        a (set \"()[]{}\")]\n    (empty?\n     (reduce (fn [[t & b :as stack] s]\n               (cond (= (p t) s) b\n                 (a s) (conj stack s)\n                 :else stack))\n             () s))))","user":"5f419985e4b0955706451fab"},{"problem":"177","code":"(fn balbra [s]\n  (let [signstr (filter #(or (= % \\{) (= % \\}) (= % \\[) (= % \\]) (= % \\() (= % \\))) s)]\n    (if (= 0 (count signstr))\n      true\n      (loop [stack (list (first signstr)) sig (next signstr) i (count signstr)]\n        (if (> i 1) \n          (if (or (= (first stack) (char (- (int (first sig)) 1))) \n                  (= (first stack) (char (- (int (first sig)) 2))) ) \n              (recur (next stack) (next sig) (dec i))\n              (recur (cons (first sig) stack) (next sig) (dec i)))\n          (if (= 0 (count stack)) true false))))))","user":"5243e37ae4b076204b44fae3"},{"problem":"177","code":"(fn balanced-brackets [s]\n  (let [not-noise #{\\( \\) \\} \\{ \\] \\[}\n        openness #(cond (#{\\( \\{ \\[} %) :open (#{\\) \\} \\]} %) :close)\n        typeof #(cond (#{\\( \\)} %) :paren (#{\\} \\{} %) :braces (#{\\] \\[} %) :square-bracket)\n        balanced-f? #(loop [[head & tail] %\n                            depths {:paren 0 :braces 0 :square-bracket 0}]\n                       (let [new-depths (if (not-noise head)\n                                          (update-in depths\n                                                     [(typeof head)]\n                                                     (condp = (openness head) :open inc :close dec))\n                                          depths)]\n                         (if tail (recur tail new-depths) (every? zero? (vals new-depths)))))]\n    (let [bad-nesting? (->> s\n                            (filter not-noise)\n                            (partition 2 1)\n                            (filter (fn [xs] (and (= [:open :close] (map openness xs))\n                                                  (apply not= (map typeof xs)))))\n                            seq)]\n      (when (not bad-nesting?) (balanced-f? s)))))","user":"561d8936e4b064ca9f4b16b2"},{"problem":"177","code":"(fn [str]\n  (let [open-bracs #{\\( \\{ \\[} close-bracs #{\\) \\} \\]} paired-bracs {\\) \\( \\} \\{ \\] \\[}]\n    (loop [stack [] [h & r] (seq str)]\n      (if-not h \n        (empty? stack)\n        (cond \n          (contains? open-bracs h) (recur (cons h stack) r)\n          (contains? close-bracs h) (when (= (first stack) (paired-bracs h)) (recur (rest stack) r))\n          :else (recur stack r))))))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn balanced?\n  [s]\n  (let [brackets { \\( \\) \\[ \\] \\{ \\}} \n        opening? (fn [x] (some #(= x %) (keys brackets)))\n        closing? (fn [x] (some #(= x %) (vals brackets)))\n        matching? (fn [x y] (= y (brackets x)))]\n    (loop [xs (seq s) stack []]\n      (if (empty? xs)\n        (empty? stack)\n        (let [x (first xs)]\n          (cond\n           (opening? x) (recur (rest xs) (conj stack x))\n           (closing? x) (when (matching? (peek stack) x) (recur (rest xs) (pop stack)))\n           :else        (recur (rest xs) stack)))))))","problem":"177","user":"4e50b67b535dc968683fc4ed"},{"problem":"177","code":"(fn checkbracket \n  [s] \n  (letfn [(brsimp [s]\n    (if (empty? s)\n      true\n      (cond \n        (re-find #\"\\(\\)\" s) (brsimp (clojure.string/replace s #\"\\(\\)\" \"\"))\n        (re-find #\"\\[\\]\" s) (brsimp (clojure.string/replace s #\"\\[\\]\" \"\"))\n        (re-find #\"\\{\\}\" s) (brsimp (clojure.string/replace s #\"\\{\\}\" \"\"))\n        :else false)))]\n  (brsimp (apply str (filter #(#{\\{ \\} \\[ \\] \\( \\)} %) s)))))","user":"55536a8ae4b0deb715856e03"},{"problem":"177","code":"(fn [s]\n  (let [inv {\\( \\) \\) \\( \\[ \\] \\] \\[ \\{ \\} \\} \\{}\n        opn #{\\( \\[ \\{} \n        cls #{\\) \\] \\}}\n        els (filter #(or (opn %) (cls %)) s)\n        agg (when-let [els (seq els)]\n              (reduce \n               (fn [acc c]\n                 (let [l (:last acc)\n                       i (get inv l)\n                       aacc (atom acc)]                       \n                   (when (and (opn l) ((disj cls i) c)) (swap! aacc assoc-in [:r] false))\n                   (when (opn c) (swap! aacc update-in [:cnt c] inc))\n                   (when (cls c) (swap! aacc update-in [:cnt c] dec))\n                   (swap! aacc assoc-in [:last] c)\n                   @aacc))\n               {:last (first els) :r true \n                :cnt (update-in {\\( 0 \\) 0 \\[ 0 \\] 0 \\{ 0 \\} 0} [(first els)] inc)} \n               (rest els)))]\n    (if (nil? agg) true\n        (and (:r agg) (= 0 (reduce + (vals (:cnt agg))))))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":"177","code":"(fn balancing-brackets [snippet]\n  (let [ brackets {\\( \\) \\[ \\] \\{ \\}}\n        bracketsset (clojure.set/union (keys brackets) (vals brackets))\n        open? (fn [ch] (some #{ch} (keys brackets)))\n        corresponds? (fn [cho chc] (= (get brackets cho) chc))\n        reducefunc (fn [xs x] \n                      (let [result (:result xs)\n                            stack (:stack xs)]\n                        (if (open? x) \n                          {:result result :stack (conj stack x)}\n\t                        (if (corresponds? (peek stack) x)\n\t                          {:result result :stack (pop stack)}\n                            {:result false :stack stack}))))\n        xs (reduce reducefunc {:result true :stack [] } (filter #(some #{%1} bracketsset) snippet))]\n    (and (:result xs) (empty? (:stack xs)))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":"177","code":"(fn balanced? [s]\n  (let [open (fn [c] (cond (= c \\)) \\(\n                           (= c \\}) \\{\n                           (= c \\]) \\[))]\n    (loop [s (seq s)\n           stack '()]\n      (if (seq s)\n        (let [hd (first s)\n              tl (rest s)]\n          (if (or (= hd \\() (= hd \\{) (= hd \\[))\n            (recur tl (cons hd stack))\n            (if (or (= hd \\)) (= hd \\}) (= hd \\]))\n              (if (= (open hd) (first stack))\n                (recur tl (rest stack))\n                false)\n              (recur tl stack))))\n        (if (empty? stack) true false)))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":"177","code":"(fn [s]\n   (let [pushset #{\\( \\{ \\[}\n         popm {\\) \\( \\} \\{ \\] \\[}\n         push (fn [q c]\n                (and q (if (pushset c)\n                         (conj q c)\n                         (if-let [pair (popm c)]\n                           (when (= (peek q) pair)\n                             (rest q))\n                           q))))\n         r (reduce push () s)]\n      (and (seq? r) (empty? r))))","user":"523b4e91e4b07becd5be21ef"},{"problem":"177","code":"(fn solve [input]\n  (let [pairs {\\( \\) \\[ \\] \\{ \\}}]\n    (->> input\n         (reduce (fn [stack c]\n                   (cond (and ((set (vals pairs)) c) (= (pairs (first stack)) c)) (rest stack)\n                         ((set (mapcat #(% pairs) [keys vals])) c) (conj stack c)\n                         :else stack))\n                 ())\n         empty?)))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":"177","code":"(fn balBrack\n  [str]\n  (let [\n        openChars #{\\[ \\( \\{}\n        closeChars #{\\] \\) \\}}\n        matchBracks (fn [c1 c2]\n                      (cond\n                       (= c1 \\() (if (= c2 \\)) true false)\n                       (= c1 \\[) (if (= c2 \\]) true false)\n                       (= c1 \\{) (if (= c2 \\}) true false)\n                       true false))]\n    (loop [stack []\n           curr str]\n      (if (empty? curr)\n        (if (empty? stack) true false)\n        (let [ch (first curr)\n              rs (rest curr)]\n          (cond                                                                                                                     \n           (contains? openChars ch) (recur (conj stack ch) rs)\n           (contains? closeChars ch) (if (matchBracks (last stack) ch)\n                                       (recur (into [] (drop-last stack)) rs)\n                                       false)\n           true (recur stack rs)))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":"177","code":"(fn [s]\n  (loop [r s\n         st []]\n    (cond\n     (empty? r)\n     (empty? st)\n\n     (#{\\[ \\( \\{} (first r))\n     (recur (rest r) (conj st (first r)))\n\n     (#{\\] \\) \\}} (first r))\n     (if (and (seq st)\n              (= ({\\] \\[ \\) \\( \\} \\{} (first r))\n                 (peek st)))\n       (recur (rest r) (pop st))\n       false)\n     \n     :else\n     (recur (rest r) st))))","user":"55c4e48be4b0e31453f649a7"},{"problem":"177","code":"(fn [s]\n  (if (and (= (count (re-seq #\"\\[\" s)) (count (re-seq #\"\\]\" s)))\n           (= (count (re-seq #\"\\(\" s)) (count (re-seq #\"\\)\" s)))\n           (= (count (re-seq #\"\\{\" s)) (count (re-seq #\"\\}\" s))))\n    (let [bs (re-seq #\"[\\[{}()\\]]\" s)]\n      (loop [bs bs l 0 r true]\n        (if (or (false? r)\n                (empty? bs))\n          r\n          (let [b (first bs)]\n            (recur (rest bs)\n                   (first bs)\n                   (cond\n                    (= 0 l) b\n                    (= \"[\" l) (if (or (= \"}\" b)\n                                      (= \")\" b))\n                                false\n                                true)\n                    (= \"{\" l) (if (or (= \"]\" b)\n                                      (= \")\" b))\n                                false\n                                true)\n                    (= \"(\" l) (if (or (= \"]\" b)\n                                      (= \"}\" b))\n                                false\n                                true)\n                    :else true))))))\n    false))","user":"54cad59ee4b057c6fda3a26e"},{"problem":"177","code":"(fn balanced? [s]\n  (let [inv {\\[ \\] \\( \\) \\{ \\}}]\n    (loop [[fst & rst] (clojure.string/replace s #\"[^\\(\\[\\{\\}\\]\\)]\" \"\")\n           st '()]\n      (if-not fst\n        (empty? st)\n        (condp #(some %2 %1) #{fst}\n          [\\[ \\( \\{] (recur rst (conj st fst))\n          [\\] \\) \\}] (if (= (inv (peek st)) fst)\n                            (recur rst (pop st))\n                            false)\n          (assert false))))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [s]\n  (let [opens  [\\( \\[ \\{]\n        closes [\\) \\] \\}]]\n    (loop [stack '()\n           s' s]\n      (if-let [c (first s')]\n        (cond\n          (>= (.indexOf opens c) 0) (recur (conj stack c) (rest s'))\n          (>= (.indexOf closes c) 0) (let [close-idx (.indexOf closes c)\n                                           open-idx  (.indexOf opens (first stack))]\n                                       (if (and (>= open-idx 0) (= open-idx close-idx))\n                                         (recur (pop stack) (rest s'))\n                                         false))\n          :else (recur stack (rest s')))\n        (empty? stack)))))","problem":"177","user":"51195e77e4b055cfb310d499"},{"code":"#(let [bm {\"}\" \"{\" \")\" \"(\" \"]\" \"[\"}]\n   (loop [rs [] in (re-seq #\"[{}()\\[\\]]\" %)]\n     (if (and (empty? in) (empty? rs))\n       true\n       (let [fb (first in)]\n         (cond\n           (contains? #{\"{\" \"(\" \"[\"} fb) (recur (conj rs fb) (rest in))\n           (= (bm fb) (last rs)) (recur (pop rs) (rest in))\n           :else false)))))","problem":"177","user":"52774dd2e4b03e8d9a4a74ff"},{"problem":"177","code":"(fn [s] \n  (= [] (reduce #(and % (case %2\n                           (\\(\\[\\{) (conj % ({\\( \\) \\[ \\]} %2 \\}))\n                           (\\)\\]\\}) (and (= (peek %) %2) (pop %))\n                           %)) [] s)))","user":"4e8f1ac6535d65386fec2146"},{"problem":"177","code":"(fn\n  [c]\n  (let [p {\\{ \\} \\[ \\] \\( \\)}]\n    (letfn [(h [s\n                st]\n              (if (empty? s)\n                (empty? st)\n                (if (p (first s))\n                  (h (rest s) (cons (first s) st))\n                  (if (some #{(first s)} (vals p))\n                    (and (= (first s) (p (first st)))\n                         (h (rest s) (rest st)))\n                    (h (rest s) st)))))]\n      (h c []))))","user":"5893c64ce4b00487982d524b"},{"code":"(fn\n  [s]\n  (let [bs (apply str (re-seq #\"[\\{}\\[\\]\\(\\)]\" s))\n        bs (-> bs\n               (clojure.string/replace #\"\\(\\)\" \"\")\n               (clojure.string/replace #\"\\[\\]\" \"\")\n               (clojure.string/replace #\"\\{}\" \"\"))]\n    (cond\n     (empty? bs)  true\n     (= (count s) (count bs)) false\n     :d  (recur bs))))","problem":"177","user":"51852961e4b0da5a5be3babb"},{"problem":"177","code":"(fn [s]\n  (let [delimiter-map {\\) \\( \\] \\[ \\} \\{}\n        opening-delimiters (into #{} (vals delimiter-map))\n        closing-delimiters (into #{} (keys delimiter-map))]\n    (loop [s s\n           delimiter-stack (list)]\n      (if (empty? s)\n        (empty? delimiter-stack)\n        (let [f (first s)\n              r (rest s)]\n          (cond\n            (opening-delimiters f) (recur r (conj delimiter-stack (first s)))\n            (closing-delimiters f) (cond (empty? delimiter-stack) false\n                                         (= (delimiter-map f)\n                                            (first delimiter-stack))\n                                         (recur r (rest delimiter-stack))\n                                         :else false)\n            :else (recur r delimiter-stack)))))))","user":"5553b924e4b0deb715856e06"},{"problem":"177","code":"(fn parens\n    ([ss] (println ss) (parens (seq ss) []))\n    ([ss stk]\n        (if (empty? ss)  (empty? stk)\n        (let [[p s c C S P] \"([{}])\"\n              matching { P p, S s, C c }\n              ch (first ss)\n             ]\n             ; (println ch ss stk)\n             ; (println p s c C S P ch)\n             (println ch stk)\n             (condp contains? ch\n             #{p s c}   (recur (rest ss) (conj stk ch))\n             #{P S C}   (if (or (empty? stk) (not= (last stk) (matching ch)))\n                            false\n                            (recur (rest ss) (pop stk)))\n                        (recur (rest ss) stk))))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":"177","code":"(fn [s]\n  (loop [stack []\n         s s]\n    (if (seq s)\n      (let [c (first s)]\n        (cond\n          (#{\\( \\{ \\[} c) (recur (cons c stack) (rest s))\n          (#{\\) \\} \\]} c)\n            (if (= (first stack) ({\\) \\(, \\} \\{, \\] \\[} c))\n              (recur (rest stack) (rest s))\n              false)\n          :else (recur stack (rest s))))\n      (empty? stack))))","user":"53d78b64e4b0e771c3025466"},{"problem":"177","code":"(fn balanced-brackets? [s]\n  (letfn [(matches? [l r]\n            (case l\n              \\[ (= r \\])\n              \\( (= r \\))\n              \\{ (= r \\})\n              false))]\n    (let [opening-bracket? #{\\[ \\( \\{}\n          closing-bracket? #{\\] \\) \\}}]\n      (boolean\n       (loop [[c & cs] s st (list)]\n        (cond\n          (nil? c) (empty? st)\n          (opening-bracket? c) (recur cs (conj st c))\n          (closing-bracket? c) (when (matches? (first st) c)\n                                 (recur cs (rest st)))\n          :else (recur cs st)))))))","user":"5f300f28e4b033932238a682"},{"problem":"177","code":"(fn balanced? [s]\n   (empty?\n    (reduce (fn [[h & t :as s] i] \n              (cond\n                (= i ({\\{ \\} \\( \\) \\[ \\]} h)) t\n                ((set \"{}()[]\") i) (cons i s)\n                :else s))\n            ()\n            s)))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn b-bracket\n  [s]\n  (let [mapping {\\] \\[, \\} \\{, \\) \\(}]\n    (loop [[curr-s & rest-s :as all-s] (seq s), stack []]\n      (cond\n        (empty? all-s) (do (println stack) (empty? stack))\n        ((set (vals mapping)) curr-s) (recur rest-s (conj stack curr-s))\n        ((set (keys mapping)) curr-s) (if (= (peek stack) (mapping curr-s)) (recur rest-s (pop stack)) false)\n        :else (recur rest-s stack)))))","problem":"177","user":"52dd6cc8e4b09f7907dd13e2"},{"code":"#({()1} (reduce\n   (fn [a x] (if ((set \"{([\") x) (conj a x)\n                (if (= x ({\\( \\), \\[ \\], \\{ \\}} (peek a))) (pop a) (conj a 0))))\n   () (filter (set \"{}[]()\") %)))","problem":"177","user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [s]\n  ; nil stack implies invalid state; empty stack at EOS ==> success\n  (let [lbs #{\\( \\[ \\{}\n        rbs #{\\) \\] \\}}\n        matches {\\) \\( \\] \\[ \\} \\{}\n        push-lb (fn [stack lb]\n                 (if-not (nil? stack) (conj stack lb)))\n        pop-lb (fn [stack rb]\n                (if-not (nil? stack)\n                  (if-not (empty? stack)\n                    (if (= (peek stack) (matches rb)) (pop stack)))))\n        parser (fn [stack c]\n                 (cond\n                  (lbs c) (push-lb stack c)\n                  (rbs c) (pop-lb stack c)\n                  :else stack))]\n    (= () (reduce parser () s))))","problem":"177","user":"52015698e4b0d7096e99ddba"},{"code":"(fn [s]\n  (loop [stack () cs s]\n    (cond\n      (empty? cs) (empty? stack)\n      (empty? stack) (if (contains? #{\\( \\) \\[ \\] \\{ \\}} (first cs))\n                       (recur (list (first cs)) (rest cs))\n                       (recur () (rest cs)))\n      (and (= \\) (first cs)) (= \\( (first stack))) (recur (rest stack) (rest cs))\n      (and (= \\] (first cs)) (= \\[ (first stack))) (recur (rest stack) (rest cs))\n      (and (= \\} (first cs)) (= \\{ (first stack))) (recur (rest stack) (rest cs))\n      (or (contains? #{\\( \\) \\[ \\] \\{ \\}} (first cs))) (recur (cons (first cs) stack) (rest cs))\n      :else (recur stack (rest cs)))))","problem":"177","user":"4e9519b4535dbda64a6f6b2d"},{"problem":"177","code":"(fn [s]\n  (loop [[c & s] s bs '()]\n    (cond (nil? c) (empty? bs)\n          (some #(= c %) #{\\( \\[ \\{}) (recur s (cons c bs))\n          (some #(= c %) #{\\) \\] \\}}) (if (= (get {\\) \\( \\] \\[ \\} \\{} c) (first bs)) (recur s (rest bs)) false)\n          :else (recur s bs))))","user":"54055aa9e4b0addc1aec6665"},{"problem":"177","code":"(let [\nbrackets (zipmap \"{[()]}\" \"}])([{\") \nopens? (set \"{[(\")\n] (fn [line] (->> line\n    (reduce #(cond\n       (not (contains? brackets %2)) %\n       (opens? %2) (cons (brackets %2) %)\n       (= %2 (first %)) (next %)\n       (empty? %) [:false]\n       ) [:true])\n    first\n    (= :true)\n)))","user":"5603c31fe4b04bb52996e1c1"},{"problem":"177","code":"(fn [s] (let [p (filter (set (seq \"[]{}()\")) (seq s))]\n                   (empty? (reduce #(if ((set (seq \"[{(\")) %2)\n                              (conj % %2)\n                              (if (= %2 (get {\\{ \\} \\[ \\] \\( \\)} (peek %))) (pop %)\n                                  (conj % %2)))\n                           [] p))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":"177","code":"(\n fn f [t](\n    let [brackets '({:l \\( :r \\)} {:l \\[ :r \\]} {:l \\{ :r \\}})\n         left #{\\( \\[ \\{ }\n         right #{\\) \\] \\} }\n         pairs {\\) \\( \\} \\{ \\] \\[ }          \n         ](      \n  \t\tloop [text (filter (set (seq \"(){}[]\")) (seq t)) stack '()](\n          if (empty? text)\n          \t(empty? stack)\n            (let [[h & r] text](\n                               if (left h)\n                               (recur r (cons h stack))\n                               (if (= (get pairs h) (first stack))\n                                (recur r (rest stack))\n                                 false\n                                )\n                               \n                               )\n              )\n        )                                                            \n    )\n )\n)","user":"56ae4c21e4b03c432f18735c"},{"problem":"177","code":"(fn matching?\n  [s]\n  (empty? (reduce (fn [my-brackets c]\n                    (println my-brackets)\n                    (cond\n                      (or (and (= (last my-brackets) \\{) (= c \\}))\n                          (and (= (last my-brackets) \\() (= c \\)))\n                          (and (= (last my-brackets) \\[) (= c \\]))) (into [] (butlast my-brackets))\n                      (or (= c \\[) (= c \\() (= c \\{) (= c \\]) (= c \\)) (= c \\})) (conj my-brackets c)\n                      :else my-brackets)) [] s)))","user":"60396c95e4b0d5df2af222f4"},{"problem":"177","code":"(fn balanced-brackets? [expr]\n  (let [is-closing #(some (partial = %) '(\\) \\} \\]))\n        is-opening #(some (partial = %) '(\\( \\{ \\[))\n        opening {\\) \\( \\] \\[ \\} \\{}]\n    (loop [head (first expr)\n           tail (rest expr)\n           stack []]\n      (if (nil? head) (= 0 (count stack))\n          (cond\n            (is-opening head) (recur\n                               (first tail)\n                               (rest tail)\n                               (conj stack head))\n            (is-closing head) (cond\n                                (empty? stack) false\n                                (= (peek stack) (opening head)) (recur\n                                                                 (first tail)\n                                                                 (rest tail)\n                                                                 (pop stack))\n                                :default (recur\n                                          (first tail)\n                                          (rest tail)\n                                          stack))\n            :default (recur\n                      (first tail)\n                      (rest tail)\n                      stack))))))","user":"587ee260e4b052da650a6353"},{"problem":"177","code":"(fn [s]\n  (let [rf (fn ab [stk lst]\n             (if (not (seq lst))\n               (empty? stk)\n               (let [lu {\\[ \\], \\{ \\}, \\( \\)}\n                     f (first lst)\n                     r (rest lst)]\n                 (cond \n                   (lu f) (ab (conj stk (lu f)) r)\n                   (#{\\] \\} \\)} f) (if (= f (peek stk)) (ab (pop stk) r) false) \n                   :else (ab stk (rest lst))))\n               )\n             )]\n    (rf (list) (seq (.replaceAll s \"[^}\\\\[{(\\\\])]\" \"\")))\n    )\n  )","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn balance\n    ([string] (balance string '()))\n    ([string stack]\n     (let [brackets {\\( \\) \\{ \\} \\[ \\]}]\n       (cond\n         (empty? string) (empty? stack)\n         (not (nil? (brackets (first string)))) (balance (rest string) (cons (first string) stack))\n         (not (nil? ((set (map val brackets))\n                     (first string)))) (if (not (= (first string) (brackets (first stack))))\n                                         false\n                                         (balance (rest string) (rest stack)))\n         :else (balance (rest string) stack)))))","problem":"177","user":"4fb1325de4b081705acca276"},{"code":"#(let [c (fn c [[h & t] x]\n                  (let [m? (= h (first x))]\n                    (case h \n                      nil  x\n                      \\[   (c t (conj x \\]))\n                      \\(   (c t (conj x \\)))\n                      \\{   (c t (conj x \\}))\n                      (\\] \\) \\}) (c \n                                   t \n                                   (if m? (rest x) (conj x 1)))\n\n                    (c t x))))]\n  (= () (c % ())))","problem":"177","user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn [s]\n  (= true\n  (first\n  \t(reduce \n     (fn [[br & brs :as abrs] c]\n       (if (= false br) [false]\n         (cond\n           (= c br) brs\n           (= c \\() (cons \\) abrs)\n           (= c \\[) (cons \\] abrs)\n           (= c \\{) (cons \\} abrs)\n           (= c \\)) [false]\n           (= c \\]) [false]\n           (= c \\}) [false]\n           true abrs)))\n     [true]\n     (seq s))\n  ))\n  )","problem":"177","user":"50901b2ee4b0ea685a20f774"},{"problem":"177","code":"#(let [\tstarts {\\[ \\] \\{ \\} \\( \\)}\n       \tends #{\\] \\} \\)}\n\t\tright-bracket? (fn [e s]\n                         (cond\n                          (= e (peek s)) [true (pop s)]\n                          (empty? s) [false s]\n                          :else [false (pop s)]))\n        balanced? (fn [[b s] e] \n                    (cond \n                     (starts e) [false (conj s (starts e)) e] \n                     (ends e) (let [[b ns] (right-bracket? e s)] [b ns e]) \n                     :else [b s e]))\n        [res s _] (reduce balanced? [true []] %)]\n        (and res (empty? s)))","user":"6026737ee4b0d5df2af2222f"},{"code":"#(let [bs (apply hash-map \"[](){}\")\n       c? (set (vals bs))]\n   (empty?\n    (reduce\n      (fn [[c & cr :as cs] x]\n        (if-let [c* (bs x)]\n          (cons c* cs)\n          (if (= x c)\n            cr\n            (if (c? x)\n              (cons nil cs)\n              cs))))\n      ()\n      %)))","problem":"177","user":"4f06dcad535dcb61093f6c16"},{"code":"(fn [x]\n   (let [opp-punc { \\[ \\]\n                    \\] \\[\n                    \\{ \\}\n                    \\} \\{\n                    \\( \\)\n                    \\) \\( }]\n     (loop [stack '()\n            r (filter #(contains? opp-punc %) (seq x))]\n       (cond\n        (empty? r) (empty? stack)\n        (= (opp-punc (first stack)) (first r)) (recur (pop stack) (rest r))\n        :else (recur (conj stack (first r)) (rest r))))))","problem":"177","user":"53224d45e4b09d4e7a9b54c0"},{"problem":"177","code":"(fn check-balance [text]\n  (let [\n        open-brackets #{\\{ \\[ \\(}\n        close-brackets #{\\} \\] \\)}\n        brackets (into #{} (concat open-brackets close-brackets))\n        pairs {\\{ \\}\n               \\[ \\]\n               \\( \\)}]\n    (letfn [(check-brackets [brackets]\n            (reduce \n             (fn [[head & tail :as seen] bracket]\n               (if (open-brackets bracket)\n                 (cons bracket seen)\n                 (if (= bracket (pairs head))\n                   tail\n                   (cons bracket seen))))\n             '()\n             brackets))]\n    (empty? (check-brackets (filter brackets text))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":"177","code":"(fn [s]\n  (let [parens #{\\[ \\] \\{ \\} \\( \\)}\n        close-parens {\\) \\( \\] \\[ \\} \\{}]\n    (empty? (reduce (fn [[last-paren & others :as stack] p]\n                      (if-let [m (parens p)]\n                        (if (= (get close-parens m :open) last-paren)\n                          others\n                          (cons m stack))\n                        stack))\n                    '()\n                    s))))","user":"53e9dce1e4b036ad0777e4bc"},{"problem":"177","code":"(fn brackets [s]\n  (empty?\n    (reduce\n      (fn [[left & other :as stack] right]\n        (cond\n          ; New char closes the inner-most open bracket -> pop inner-most.\n          (= right ({\\[ \\], \\( \\), \\{ \\}} left)) other\n          ; New char opens a new bracket -> push new bracket.\n          ((set \"{}[]()\") right) (cons right stack)\n          ; Not a bracket.\n          :else stack ;; stack remains the same\n          )\n        )\n      ()\n      s\n      )\n    )\n  )","user":"5baaae06e4b0a20761a23464"},{"problem":"177","code":"(fn [s]\n  (loop [[h & t] (filter #(some #{%} [\\{ \\} \\[ \\] \\( \\)]) s)\n         [stack-top & stack-bot :as stack] '()]\n    (if (nil? h)\n      (if (nil? stack-top) true false)\n      (condp = h\n        \\] (if (= stack-top \\[) (recur t stack-bot) false)\n        \\} (if (= stack-top \\{) (recur t stack-bot) false)\n        \\) (if (= stack-top \\() (recur t stack-bot) false)\n        (recur t (conj stack h))))))","user":"56ff45e5e4b08d47c97781bb"},{"problem":"177","code":"(fn [ss] (letfn [(hf [res s]\n                (if (first s)\n                    (let [s1 (first s) r (rest s) vres (vec res) ]\n                      (cond (= \\( s1 ) (recur (conj vres s1) r) \n                            (= \\) s1 ) (if  (= (last vres) \\()\n                                           (recur (drop-last vres) r )\n                                           (vec (conj vres s1))\n                                        )\n                            (= \\[ s1 ) (recur (conj vres s1) r)  \n                            (= \\] s1 ) (if (= (last vres) \\[)\n                                           (recur (drop-last vres) r )\n                                           (vec (conj vres s1)  )\n                                        )\n                            (= \\{ s1 ) (recur (conj vres s1) r)  \n                            (= \\} s1 ) (if (= (last vres) \\{)\n                                           (recur (drop-last vres) r) \n                                          (vec  (conj vres s1)   )\n                                         )\n                            :else (recur res r )\n                      )\n                    )\n                   (vec res)\n                 )\n                )]\n               (if (< 0 (count (hf [] (vec ss)))) false true )\n             ))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":"177","code":"(fn [s]\n  (let [v (filter #(contains? #{\\( \\) \\{ \\} \\[ \\]} %) s)]\n    (if (odd? (count v)) false\n        (loop [r v a []]\n          (cond (false? a) false\n                (seq r) (recur (rest r) (cond (= (first r) \\() (conj a \\))\n                                              (= (first r) \\{) (conj a \\})\n                                              (= (first r) \\[) (conj a \\])\n                                              (= (first r) \\)) (if (= (last a) \\)) (pop a) false)\n                                              (= (first r) \\}) (if (= (last a) \\}) (pop a) false)\n                                              (= (first r) \\]) (if (= (last a) \\]) (pop a) false)))\n                :else true)))))","user":"5e6ca949e4b04a83ad7cd289"},{"code":"#(let [a (get % 0)]\n   (or (and (not= a \\() (not= a \\[))\n       (= (count %) 52)))","problem":"177","user":"538d8bb8e4b0b51d73faae71"},{"problem":"177","code":"(fn [s]\n  (let [end->start {\\) \\( \\] \\[ \\} \\{}\n        starts #{\\( \\[ \\{}\n        ends #{\\) \\] \\}}]\n    (loop [stack []\n           [c & rest-s] s]\n      (cond \n        (starts c) (recur (conj stack c) rest-s)\n        (ends c) (if (= (peek stack) (end->start c))\n                   (recur (pop stack) rest-s)\n                   false)\n        (empty? rest-s) (empty? stack)\n        :else (recur stack rest-s)))))","user":"5515b138e4b055c2f668d4ed"},{"problem":"177","code":"(fn check-brackets\n  ([snippet]\n   (let [brackets (apply str (filter #(some #{%} '(\\{ \\} \\[ \\] \\( \\))) snippet))\n         amount (count brackets)]\n     (check-brackets brackets amount)))\n  ([brackets amount]\n   (if (or (odd? amount) (and (< 0 amount) (not (some true? ((juxt #(.contains % \"()\") #(.contains % \"{}\") #(.contains % \"[]\")) brackets)))))\n     false\n     (if (= 0 amount)\n       true\n       (let [new-brackets (-> brackets (.replace \"{}\" \"\") (.replace \"[]\" \"\") (.replace \"()\" \"\"))]\n       \t(check-brackets new-brackets (count new-brackets)))))))","user":"58a1d00ae4b02bd94d917ec6"},{"code":"(fn [s]\n    (loop [s2 (clojure.string/replace s #\"[^{}\\[\\]()]\" \"\")\n           rs (clojure.string/replace s2 #\"\\{\\}|\\[\\]|\\(\\)\" \"\")]\n      \n      (if (empty? rs)\n        true\n        (if (= (count rs) (count s2))\n          false\n          (recur rs (clojure.string/replace rs #\"\\{\\}|\\[\\]|\\(\\)\" \"\"))\n          )\n       )\n      )\n  )","problem":"177","user":"51bec919e4b013aa0d74b800"},{"problem":"177","code":"(fn balanced? [s]\n  (let [paired-pattern #\"\\(\\)|\\[\\]|\\{\\}\"]\n    (loop [target (apply str (re-seq #\"[\\{|\\}|\\(|\\)|\\[|\\]]\" s))]\n      (cond (empty? target) true\n            (not (re-find paired-pattern target)) false\n            :else (recur (clojure.string/replace target paired-pattern \"\"))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":"177","code":"(fn __ [n]\n  (let [\n          aa (seq n)\n          res (reduce\n                (fn [acc ch]\n                  (cond\n                    (= ch \\[) (cons ch acc)\n                    (= ch \\() (cons ch acc)\n                    (= ch \\{) (cons ch acc)\n                    (and (= ch \\]) (= \\[ (first acc))) (rest acc)\n                    (and (= ch \\)) (= \\( (first acc))) (rest acc)\n                    (and (= ch \\}) (= \\{ (first acc))) (rest acc)\n                    (and (= ch \\]) (not= \\[ (first acc))) (cons \\x acc)\n                    (and (= ch \\)) (not= \\( (first acc))) (cons \\x  acc)\n                    (and (= ch \\}) (not= \\{ (first acc))) (cons \\x  acc)\n                    \"default\" acc)\n                  )\n                '()\n                aa)\n        ]\n        (empty? res)))","user":"58bc6a88e4b0888cdc949d16"},{"problem":"177","code":"(fn [ss] (let [b (zipmap \"({[)}]\" (range))]\n             ((fn bra [stack s]\n                (if (empty? s)\n                  (if (empty? stack)\n                    true\n                    false)\n\n                  (let [f (first s)\n                        n (b f)]\n                    (if (nil? n)\n                      (bra stack (rest s))\n                      (if (< n 3)\n                        (bra (conj stack f) (rest s))\n                        (if (= (mod n 3) (b (first stack)))\n                          (bra (rest stack) (rest s))\n                          false)))))) '() ss)))","user":"549375e4e4b0b312c081ff4e"},{"code":"(fn [s]\n   ((fn bl [x s]\n      (let [op #{\\(\\{\\[} cl #{\\)\\}\\]} cv {\\( \\), \\{ \\}, \\[ \\]}]\n        (if (empty? x)\n          (empty? s)\n          (if (op (first x))\n            (bl (rest x) (cons (cv (first x)) s))\n            (if (= (first x) (first s))\n              (bl (rest x) (rest s))\n              false\n              )\n            )\n          )\n        )\n      )\n    (filter #{\\{\\}\\(\\)\\[\\]} s) '()\n    )\n   )","problem":"177","user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn [s]\n  (empty?\n   (trampoline\n     (fn reduce-brackets [s]\n       (let [new-s (clojure.string/replace s #\"\\(\\)|\\[\\]|\\{\\}\" \"\")]\n         (if (= s new-s) s (partial reduce-brackets new-s))))\n     (clojure.string/replace s #\"[^\\[\\]\\(\\)\\{\\}]\" \"\"))))","problem":"177","user":"52dd4fb4e4b09f7907dd13df"},{"problem":"177","code":"(fn [s]\n  (letfn [\n       (b [qu col]\n          (if (empty? col) (empty? qu) ; base\n            (let [cr (first col) pp (last qu)]\n              (cond (or (and (= \\] cr) (= \\[ pp))\n                      (and (= \\} cr) (= \\{ pp)) (and (= \\) cr) (= \\( pp))\n                     ) (b (vec (butlast qu)) (rest col))\n                     (or (= \\[ cr) (= \\{ cr) (= \\( cr)\n                      ) (b (conj qu cr) (rest col))\n                     (or (= \\] cr) (= \\} cr) (= \\) cr)) false\n                         :else\n                        (b qu (rest col))))))]\n       (b [] (seq s))))","user":"54908cc1e4b0b312c081ff32"},{"problem":"177","code":"(fn [s]\n   (= (reduce #(cond\n                 (= %1 false) %1\n                 (#{\\[ \\( \\{} %2) (conj %1 %2)\n                 (and (#{\\] \\) \\}} %2)\n                      (not (empty? %1))\n                      (= ({\\] \\[, \\} \\{, \\) \\(} %2)\n                         (peek %1))) (pop %1)\n                 (#{\\] \\) \\}} %2) false\n                 :else %1\n                 )\n              ()\n              s)\n      ()))","user":"60096aabe4b074f607df667f"},{"problem":"177","code":"(fn [x]\n  (loop [y x\n         acc '()]\n    (if (seq y)\n      (condp = (first y)\n        \\[ (recur (rest y) (conj acc \\[))\n        \\{ (recur (rest y) (conj acc \\{))\n        \\( (recur (rest y) (conj acc \\())\n        \\] (if (= (peek acc) \\[)\n             (recur (rest y) (pop acc))\n             false)\n        \\} (if (= (peek acc) \\{)\n             (recur (rest y) (pop acc))\n             false)\n        \\) (if (= (peek acc) \\()\n             (recur (rest y) (pop acc))\n             false)\n        (recur (rest y) acc))\n      (empty? acc))))","user":"51ca5378e4b08b1cbd0d9480"},{"problem":"177","code":"(fn [st]\n         (empty?\n          (let [ps {\\( \\) \\[ \\] \\{ \\}}\n                brackets (into (keys ps) (vals ps))\n                st (filter #(contains? (set brackets) %) st)]\n            (reduce  #(if (= %2  (get ps  (last %1)))\n                        (vec (butlast %1))\n                        (conj %1 %2))\n                     [] st))))","user":"5d0cf1c8e4b0cc9c91588246"},{"problem":"177","code":"(fn [s]\n    (loop [remaining s\n           stack '()]\n      (if-let [ch (first remaining)]\n        (condp contains? ch\n          #{\\[ \\( \\{} (recur\n                        (rest remaining)\n                        (conj stack ch))\n          #{\\] \\) \\}} (if (not= ({\\} \\{ \\) \\( \\] \\[} ch) (peek stack))\n                        false\n                        (recur\n                          (rest remaining)\n                          (pop stack)))\n          (recur (rest remaining) stack))\n        (empty? stack))))","user":"4f43b992e4b0d7d3c9f3fd2c"},{"problem":"177","code":"(fn solution177\n  [s]\n  (loop [in    (into (vector) (seq s))\n         stack '()]\n    (if (empty? in)\n      (empty? stack)\n      (let [curr (first in)\n            top  (first stack)]\n        (case curr\n          \\[ (recur (rest in) (conj stack curr))\n          \\( (recur (rest in) (conj stack curr))\n          \\{ (recur (rest in) (conj stack curr))\n          \\] (if (= top \\[) (recur (rest in) (rest stack))\n                            false) \n          \\) (if (= top \\() (recur (rest in) (rest stack))\n                            false) \n          \\} (if (= top \\{) (recur (rest in) (rest stack))\n                            false)\n          (recur (rest in) stack) )))))","user":"595bc925e4b066ee0a44afe2"},{"code":"(fn parse [a]\n  (loop [s a b '()]\n    (if (empty? s)\n      (empty? b)\n      (case (first s)\n        \\{ (recur (rest s) (conj b \\{ ))\n        \\[ (recur (rest s) (conj b \\[ ))\n        \\( (recur (rest s) (conj b \\( ))\n        \\} (if (= (first b) \\{) (recur (rest s) (rest b)) false)\n        \\] (if (= (first b) \\[) (recur (rest s) (rest b)) false)\n        \\) (if (= (first b) \\() (recur (rest s) (rest b)) false)\n        (recur (rest s) b)))))","problem":"177","user":"513b77f3e4b00f740c76c403"},{"problem":"177","code":"(let [d {\\( \\) \\[ \\] \\{ \\}}\n        c #{\\] \\} \\)}]\n    (fn g\n      ([s] (g s ()))\n      ([[a & b :as s] t]\n       (cond (empty? s) (empty? t)\n             (d a) (recur b (conj t a))\n             (c a) (if (= (d (peek t)) a)\n                     (recur b (pop t))\n                     false)\n             :else (recur b t)))))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":"177","code":"(fn [s]\n  (loop [t () s s]\n    (if (empty? s)\n      (empty? t)\n      (let [[ch & r] s]\n        (cond\n          (#{\\{ \\( \\[} ch) (recur (conj t ch) r)\n          (#{\\} \\) \\]} ch)\n            (if (= ({\\{ \\} \\( \\) \\[ \\]} (peek t)) ch)\n              (recur (pop t) r)\n              false)\n          :else (recur t r))))))","user":"53f77b6ae4b0de5c4184855f"},{"code":"(fn [t]\n(let [m {\\) \\( \\} \\{ \\] \\[}\n      c (set (keys m))\n      o (set (vals m))]\n  (loop [s (filter #(or (c %) (o %)) t)]\n    (let [[l r] (split-with (complement #(c %)) s)]\n      (if (empty? (concat l r))\n        true\n        (if (= (last l) (m (first r)))\n          (recur (concat (butlast l) (rest r)))\n          nil))))))","problem":"177","user":"52593207e4b0cb4875a45cd3"},{"problem":"177","code":"(fn balanced? [s]\n  (let [ss (seq s)\n        init '()\n        opens  {\\{ \\},\n                \\( \\),\n                \\[ \\]}\n        closes (into {} (map #(vec (reverse %)) opens))\n        step (fn [open nxt]\n               (cond (and (closes nxt) (not= (closes nxt) (first open))) (cons 'nope open)\n                     (closes nxt) (rest open)\n                     (opens nxt) (cons nxt open)\n                     :else open))]\n    (empty? (reduce step '() ss))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":"177","code":"#(empty?\n  (reduce (fn [[h & t :as x] y]\n            (if (= y ({\\{ \\}\n                       \\( \\)\n                       \\[ \\]} h))\n              t\n              (cons y x)))\n          ()\n          (filter (set \"(){}[]\") %)))","user":"51ad244fe4b09397d510977f"},{"problem":"177","code":"(fn [t] (let [s (clojure.string/replace t #\"[^\\[\\]\\(\\)\\{\\}]\" \"\")] \n\t(loop [s s r (clojure.string/replace s #\"\\[\\]|\\(\\)|\\{\\}\" \"\")] (if (= s r) (empty? r) (recur r (clojure.string/replace r #\"\\[\\]|\\(\\)|\\{\\}\" \"\"))))))","user":"580c8fcee4b0849f6811b721"},{"code":"(fn [t] \n  (let [b {\\( \\) \\[ \\] \\{ \\}}\n        b' {\\) \\( \\] \\[ \\} \\{}]\n    (->> (filter (some-fn b b') t)\n         (reduce #(cond (and (b' %2) (= (b' %2) (peek %))) (pop %)\n                        :else (conj % %2)) [])\n         empty?)))","problem":"177","user":"4fa05b99e4b0dcca54ed6d47"},{"problem":"177","code":"(fn [s]\n   (empty? (reduce (fn [q x]\n                     (let [head (last q)]\n                       (println :q q :x x :head head)\n                       (cond\n                        (or (= x \\() (= x \\[) (= x \\{)) (conj q x)\n                        (and (= x \\)) (= head \\()) (pop q)\n                        (and (= x \\]) (= head \\[)) (pop q)\n                        (and (= x \\}) (= head \\{)) (pop q)\n                        (and (= x \\)) (nil? head)) (conj q :error)\n                        (and (= x \\]) (nil? head)) (conj q :error)\n                        (and (= x \\}) (nil? head)) (conj q :error)\n                        :else q\n                        ))) [] s)))","user":"538db083e4b0b51d73faae74"},{"code":"(fn[x] (\n  let [c (clojure.string/replace x #\"[^\\[\\]\\{\\}\\(\\)]\" \"\")\n       r #(clojure.string/replace % #\"(\\[\\]|\\(\\)|\\{\\})\" \"\") \n       s (r (r (r (r (r (r (r c)))))))]\n  (zero? (count s))))","problem":"177","user":"5093ca51e4b097f48cc38585"},{"code":"(fn [string]\n  (if-let [result (reduce (fn [stack c]\n            (if stack\n              (if (#{\\) \\] \\}} c)\n                (if (= (peek stack) c)\n                  (pop stack))\n                (case c\n                  \\( (conj stack \\))\n                  \\[ (conj stack \\])\n                  \\{ (conj stack \\})\n                  stack))))\n           [] string)]\n                  (empty? result)))","problem":"177","user":"4eae5fe4535d7eef30807325"},{"problem":"177","code":"(fn balancing-bracket [s] \n\t(let [apairs {\"]\" \"[\", \")\" \"(\", \"}\" \"{\"}\n\t\tends (set (keys apairs))\n\t\tstarts (set (vals apairs))\n\t\talltags (set (concat starts ends))]\n\t\t(if (empty? s) true\n\t\t\t(let [stack (fn [stacks a] (if (contains? alltags (str a)) \n\t\t\t\t(if (contains? starts (str a)) \n\t\t\t\t\t(conj stacks (str a))\n\t\t\t\t\t(if (= (last stacks) (apairs (str a)))\n\t\t\t\t\t\t(pop stacks)\n\t\t\t\t\t\t(conj stacks (str a))))\n\t\t\t\tstacks))\n\t\t\t\tr (reduce stack [] (vec s))]\n\t\t\t\t(if (empty? r) true false)))))","user":"5374adc3e4b06d7f452d9e27"},{"problem":"177","code":"(fn [s]\n  (empty?\n   (let [b {\\] \\[, \\} \\{, \\) \\(}]\n     (reduce #(if (= (first %) (get b %2 \\-))\n                (rest %)\n                (conj % %2))\n             '()\n             (filter #{\\( \\) \\[ \\] \\{ \\}} s)))))","user":"4f0c4518535d0136e6c2230b"},{"code":"(fn f\n  ([s]\n   (f s 0 0 0 []))\n  ([s n_sq n_crv n_crl lst]\n   (cond\n     (empty? s)\n       (= 0 n_sq n_crv n_crl)\n     (= (first s) \\[)\n       (f (rest s) (inc n_sq) n_crv n_crl (cons \\[ lst))\n     (= (first s) \\{)\n       (f (rest s) n_sq (inc n_crv) n_crl (cons \\{ lst))\n     (= (first s) \\()\n       (f (rest s) n_sq n_crv (inc n_crl) (cons \\( lst))\n     (= (first s) \\])\n       (if (= (first lst) \\[)\n         (f (rest s) (dec n_sq) n_crv n_crl (rest lst)))\n     (= (first s) \\})\n       (if (= (first lst) \\{)\n         (f (rest s) n_sq (dec n_crv) n_crl (rest lst)))\n     (= (first s) \\))\n       (if (= (first lst) \\()\n         (f (rest s) n_sq n_crv (dec n_crl) (rest lst)))\n     :else\n       (f (rest s) n_sq n_crv n_crl lst))))","problem":"177","user":"51f28a64e4b0210f90e7454e"},{"problem":"177","code":"(fn is-balanced?\n  ([raw-string] (is-balanced? (filter #{\\( \\) \\[ \\] \\{ \\}} raw-string) []))\n  ([string stack]\n    (let [[first-char & other] string\n          pairs { \\) \\(,\n                \\] \\[,\n             \t\\} \\{ }]\n      (cond\n        ; if we finish, but the stack is non-empty, we still have opening braces left.\n        (empty? string) (empty? stack)\n        ; if we encounter a closing brace, check it against the top of the stack.\n        (pairs first-char) (and (= (pairs first-char) (peek stack))\n                               (recur other (pop stack)))\n        ; if we encounter an opening brace, add it to the stack.\n        :else (recur other (conj stack first-char))))))","user":"5483d59fe4b0e286459a1194"},{"problem":"177","code":"(fn balancing-brackets\n  ([s] (empty? (balancing-brackets s [])))\n  ([[f & r], mr]\n   (cond\n     (nil? f) mr\n     (#{\\( \\[ \\{} f) (recur r (conj mr f))\n     (#{\\) \\] \\}} f) (let [lo (peek mr)]\n                       (if (nil? lo) (conj mr f)\n                           (if (or (and (= f \\)) (= lo \\())\n                                   (and (= f \\]) (= lo \\[))\n                                   (and (= f \\}) (= lo \\{)))\n                             (recur r (pop mr))\n                             mr)))\n     :else (recur r mr))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":"177","code":"#(empty? \n  (reduce \n   \t(fn [[a & r :as x] c]\n      (cond\n        (= ({\\( \\) \\{ \\} \\[ \\]} a) c) r\n        ((set \"(){}[]\") c) (cons c x)\n        1 x))\n      [] \n      %))","user":"53a01fb1e4b0ca733b9744a6"},{"code":"(fn balanced? [text]\n  (let [right-brackets \")}]\"\n        left-brackets \"({[\"\n        match (fn [a b]\n                (= (.indexOf left-brackets (str a))\n                   (.indexOf right-brackets (str b))))\n        in (fn [string ch]\n             (.contains string (str ch)))\n        left? (partial in left-brackets)\n        right? (partial in right-brackets)]\n    (loop [stack (list)\n           curr text]\n      (cond\n       (not (seq curr)) (empty? stack)\n       (left? (first curr)) (recur (conj stack (first curr))\n                                   (rest curr))\n       (right? (first curr)) (if (and (seq stack)\n                                      (match (peek stack) (first curr)))\n                               (recur (pop stack) (rest curr)))\n       :else (recur stack (rest curr))))))","problem":"177","user":"530578ede4b0d8b024fd3760"},{"problem":"177","code":"(fn [s] (let [x (clojure.string/replace s #\"[^()\\[\\]{}]\" \"\")\n\t\t\t  result (reduce (fn [stack i] \n\t\t\t(if (nil? stack) nil\n\t\t\t (if (some #{i} #{\\( \\[ \\{})\n\t\t\t\t(conj stack i)\n\t\t\t\t(cond \n\t\t\t\t\t(and (= \\) i) (= (peek stack) \\()) (pop stack)\n\t\t\t\t\t(and (= \\] i) (= (peek stack) \\[)) (pop stack)\n\t\t\t\t\t(and (= \\} i) (= (peek stack) \\{)) (pop stack))))) () x)]\n\t(and (not (nil? result)) (empty? result))))","user":"53e19461e4b0d874e779ae59"},{"problem":"177","code":"(fn bb? [str]\n  (loop [[f & r] (filter #(#{\\[ \\( \\{ \\} \\] \\)} %) str) bs '()]\n                              (cond (nil? f) (empty? bs)\n                                    (and (#{\\] \\) \\}} f) (not= ({\\] \\[ \\) \\( \\} \\{} f) (first bs))) false\n                                    :else (recur r (if (#{\\] \\) \\}} f) (rest bs) (cons f bs))))))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn bal [s]\n  (let [c #{ \\[ \\] \\( \\) \\{ \\} }\n        brackets (apply str (filter c s))]\n    (letfn [(del [text r]\n              (clojure.string/replace text r \"\"))]\n      (if (empty? brackets) true\n          (let [replaced (del (del (del brackets #\"\\[\\]\") #\"\\(\\)\") #\"\\{\\}\")]\n            (if (= replaced brackets) false (bal replaced)))))))","problem":"177","user":"4fbd12a5e4b081705acca2fd"},{"problem":"177","code":"(fn [input]\n  (let [stripped (apply str (filter #{\\( \\) \\{ \\} \\[ \\]} input))\n        parsed ((fn remove-balanced [s]\n                  (let [regex #\"\\[\\]|\\(\\)|\\{\\}\"\n                        has-matches (re-find regex s)]\n                    (if has-matches (remove-balanced (clojure.string/replace s regex \"\"))\n                                    s))) stripped)]\n    (empty? parsed)))","user":"4e9ff8d0535d7eef3080729c"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\} \\{ \\] \\[ \\) \\(}]\n    (loop [tail s\n           brs '()]\n      (let [c (first tail)]\n        (cond\n         (empty? tail) (empty? brs)\n         (contains? #{\\{ \\( \\[} c) (recur (rest tail) (conj brs c))\n         (contains? pairs c) (if (= (pairs c) (first brs)) (recur (rest tail) (rest brs)) false)\n         :else (recur (rest tail) brs))))))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":"177","code":"(fn [s]\n\n (let [\n          initial-strip (fn [s] (apply str (filter #(not= (.indexOf \"{}()[]\" (str %)) -1) (seq s))))\n          step-strip (fn [s] (.replace (.replace (.replace s \"()\" \"\") \"[]\" \"\") \"{}\" \"\"))\n        ]\n  (loop [ins (initial-strip s)]\n    (if (= ins (step-strip ins))\n      (= (count (seq ins)) 0)\n      (recur (step-strip ins))\n    )  \n  )) \n)","user":"53da2839e4b0e771c3025489"},{"problem":"177","code":"(fn [s]\n    (letfn [(safepop [stack]\n              (if (empty? stack) stack\n                  (pop stack)))]\n      (loop [stack []\n             [c & cs] s\n             ok? true]\n        (if-not c (and ok? (empty? stack))\n                (case c\n                  \\( (recur (conj stack c) cs ok?)\n                  \\{ (recur (conj stack c) cs ok?)\n                  \\[ (recur (conj stack c) cs ok?)\n                  \\) (recur (safepop stack) cs (and ok? (= \\( (last stack))))\n                  \\] (recur (safepop stack) cs (and ok? (= \\[ (last stack))))\n                  \\} (recur (safepop stack) cs (and ok? (= \\{ (last stack))))\n                  (recur stack cs ok?))\n                ))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":"177","code":"#(let [a {\\( \\) \\[ \\] \\{ \\}}] (empty? (reduce (fn [[f & r :as c] v] (cond (a v) (conj c v) ((set \")]}\") v) (if (= v (a f)) r '(0)) 1 c)) '() %)))","user":"50548ce8e4b0b1b9d1860ead"},{"code":"(fn \t [code] (empty?\n                     (reduce #(cond \n                                (contains? #{\\( \\{ \\[} %2) (conj %1 %2)\n                                (contains? #{\\) \\} \\]} %2) (if (= ( {\\) \\( \\} \\{ \\] \\[} %2 ) (peek %1)) (pop %1) (conj %1 %2))\n                                :else %1) \n                             []\n                             code)))","problem":"177","user":"53691dc7e4b0243289761e97"},{"problem":"177","code":"(fn [s]\n        (let [char->int\n              (fn [c]\n                (case c \\{ 1, \\} -1, \\( 2, \\) -2, \\[ 3, \\] -3, 0))\n              \n              abs\n              (fn [n]\n                (if (<= 0 n) n (- n)))]\n          \n          (loop [[eye & more :as in] (remove zero? \n                                             (map char->int s))\n                 stack []]\n            \n            (let [head (or (peek stack) 0)]\n              (cond\n               (nil? eye)\n               (zero? head)\n\n               (>= eye 0)\n               (recur more (conj stack eye))\n\n               (zero? (+ eye head))\n               (recur more (pop stack))\n\n               :else\n               false)))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":"177","code":"(fn [s]\n  (let [d {\\( \\), \\[ \\], \\{ \\}}\n        e #{\\) \\] \\}}]\n    (empty? \n      (reduce (fn [s c]\n                (cond (d c) (conj s (d c))\n                      (and (e c) (= c (peek s))) (pop s)\n                      (and (e c)) (conj s \\e)\n                      :else s)) [] s))))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn [s] (letfn [\n(opening-brackets [] #{ \\( \\[ \\{ })\n(closing-brackets [] #{ \\) \\] \\} })\n(opening-bracket? [c] (contains? (opening-brackets) c))\n(closing-bracket? [c] (contains? (closing-brackets) c))\n(opening-bracket-for [c] ({ \\) \\(, \\] \\[, \\} \\{ } c))\n(balancing-brackets\n\t([s] (balancing-brackets s []))\n\t([s stack]\n\t\t(cond\n\t\t\t(empty? s)\n\t\t\t(empty? stack)\n\t\t\t(opening-bracket? (first s))\n\t\t\t(balancing-brackets (rest s) (conj stack (first s)))\n\t\t\t(and (closing-bracket? (first s)) (not= (peek stack) (opening-bracket-for (first s))))\n\t\t\tfalse\n\t\t\t(and (closing-bracket? (first s)) (= (peek stack) (opening-bracket-for (first s))))\n\t\t\t(balancing-brackets (rest s) (pop stack))\n\t\t\t:else\n\t\t\t(balancing-brackets (rest s) stack)\n\t\t)\n\t)\n)\n] (balancing-brackets s)))","problem":"177","user":"52f10094e4b05e3f0be25ee8"},{"problem":"177","code":"(fn [val]\n  (let [vals (clojure.string/split \n              val \n              #\"\")\n        special-mp {\"(\" \")\"\n                    \"[\" \"]\"\n                    \"{\" \"}\"\n                    \"}\" \"\"\n                    \")\" \"\"\n                    \"]\" \"\"}]\n    (loop [cs vals stack {:count 0 :values []}]\n      (if (or \n           (empty? cs)\n           (= true (stack :error)))\n        (and true (= 0 (stack :count)))\n        (let [c (first cs)\n              updated-stack (\n                             (fn [n] \n                               (let [val (special-mp n)]\n                                 (if \n                                     (= nil val)\n                                   stack\n                                   (if (not (= \"\" val))\n                                     {:count (inc (stack :count)) \n                                      :values (conj (stack :values) val)}\n                                     (let [pop (last (stack :values))\n                                           popped (vec (butlast (stack :values)))\n                                           error {:count -1}]\n                                       (if (or (= nil popped) (not (= n pop)))\n                                         error\n                                         {:count (dec (stack :count))\n                                          :values popped}\n                                         )))\n                                   ))) \n                             c)]\n          (recur \n           (rest cs)\n           updated-stack))))))","user":"5256a1d4e4b0541d1855ba29"},{"problem":"177","code":"(fn balanced-brackets [s]\n  (->> s\n       (filter #{\\[ \\] \\( \\) \\{ \\}})\n       (reduce\n        (fn [acc c]\n          (let [prev (last acc)]\n            (if (or (and (= \\] c) (= \\[ prev))\n                    (and (= \\) c) (= \\( prev))\n                    (and (= \\} c) (= \\{ prev)))\n              (vec (butlast acc))\n              (conj acc c))))\n        [])\n       (empty?)))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":"177","code":"(fn balancing_brackets [s]\n    (loop [[head & tail] s stack []]\n        (let\n            [\n                brackets {\\) \\( \\} \\{ \\] \\[}\n                [opening_brackets closing_brackets] [(set (vals brackets)) (set (keys brackets))]\n                stack\n                    (cond\n                        (opening_brackets head) (conj stack head)\n                        (closing_brackets head)\n                            (if (empty? stack)\n                                nil\n                                (if (= (peek stack) (brackets head)) (pop stack) nil)\n                            )\n                        :otherwise\n                            stack\n                    )\n            ]\n            (if (nil? stack)\n                false\n                (if (empty? tail)\n                    (empty? stack)\n                    (recur tail stack)\n                )\n            )\n        )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":"177","code":"(fn [s]\n            (let [o->c (into {} (map vector \"([{\" \")]}\"))]\n              (->> s\n                   seq\n                   (filter (->> \"()[]{}\" seq set))\n                   (reduce (fn [acc c]\n                             (if-not (seq acc)\n                               (conj acc c)\n                               (if ((->> \"([{\" seq set) c)\n                                 (conj acc c)\n                                 (if (= c (o->c (peek acc)))\n                                   (pop acc)\n                                   #_(reduced [:flips-table])\n                                   (conj acc c)))))\n                           [])\n                   empty?)))","user":"53684a2fe4b0243289761e8c"},{"problem":"177","code":"(fn bb [s]\n  (let [opening #{\\[ \\( \\{}\n        closing #{\\] \\) \\}}\n        matching {\\] \\[ \\) \\( \\} \\{}]\n    (loop [s s stack '()]\n          (if-let [c (first s)]\n                  (cond \n                        (opening c) (recur (next s) (conj stack c))\n                        (closing c) (if (= (matching c) (first stack))\n                                        (recur (next s) (rest stack))\n                                        false)\n                        :else (recur (next s) stack))\n                  (if (empty? stack) true false)))))","user":"5958cef6e4b066ee0a44af94"},{"problem":"177","code":"(fn[s]\n  (empty? (reduce (fn[t c] (cond\n                             (some #(= c %) \"({[\") (conj t c)\n                             (and (seq t) (= (peek t) ({\\) \\( \\} \\{ \\] \\[} c))) (pop t)\n                             (some #(= c %) \")}]\") [1]\n                             1 t)) [] s)))","user":"56824e1be4b0945ebc182a91"},{"problem":"177","code":"(fn [s]\n  (let [opposites {\\( \\)\n                   \\[ \\]\n                   \\{ \\}}\n        chs (seq s)\n        brackets (set (concat (keys opposites) (vals opposites)))]\n    (loop [stack []\n           [p & ps :as all] chs]\n      (println stack ps)\n      (if (seq all)\n        (cond\n          (not (contains? brackets p)) (recur stack ps)\n          (contains? opposites p) (recur (conj stack p) ps)\n          (= p (opposites (peek stack))) (recur (pop stack) ps)\n          :else false)\n        (empty? stack)))))\n\n; A much cleaner solution that requires Clojure 1.5+\n\n; (fn [s]\n;   (let [opposites {\\( \\)\n;                    \\[ \\]\n;                    \\{ \\}}\n;         chs (seq s)\n;         brackets (set (concat (keys opposites) (vals opposites)))\n;         unbalanced\n;         (reduce (fn [stack p]\n;                   (cond\n;                     (not (contains? brackets p)) stack\n;                     (contains? opposites p) (conj stack p)\n;                     (= p (opposites (peek stack))) (pop stack)\n;                     :else (reduced [false])))\n;                 []\n;                 chs)]\n;     (empty? unbalanced)))","user":"55a12668e4b0acc240e3150b"},{"code":"(let [op {\\] \\[, \\) \\(, \\} \\{}]\n  (fn [s]\n    (loop [[f & r] s,\n           stack ()]\n      (condp deliver f\n        {nil 0} (empty? stack)\n        #{\\{ \\[ \\(} (recur r (conj stack f))\n        #{\\} \\] \\)} (let [[a & b] stack]\n                      (if (= a (op f))\n                        (recur r b)))\n       (recur r stack)))))","problem":"177","user":"4fb1d907e4b081705acca282"},{"problem":"177","code":"(fn balancing-brackets\n  [s]\n  (let [convert-brackets\n        {\\( \\)\n         \\[ \\]\n         \\{ \\}}]\n    (->>\n     (filter #{\\(, \\), \\[, \\], \\{, \\}} s)\n     (reduce (fn [[f & r :as expected] n]\n               (println expected \" | \" n)\n               (if (= f n)\n                 (if-not (nil? r)\n                   r\n                   '())\n                 (cons (convert-brackets n) expected)))\n             '())\n     (empty?))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":"177","code":"(fn [s]\n  (= (reduce (fn [s c]\n               (and s (if ((set \")}]\") c)\n                        (and (= c (first s)) (rest s))\n                        (if-let [m ((zipmap \"([{\" \")]}\") c)]\n                          (cons m s)\n                          s))))\n             () s)\n     ()))","user":"4e8612f8535db62dc21a62f2"},{"problem":"177","code":"(fn [s]\n  (let [p-match (fn [l r]\n                  (or \n                    (and (= l \\() (= r \\)))\n                    (and (= l \\[) (= r \\]))\n                    (and (= l \\{) (= r \\}))))]\n    (loop [c s\n           stack []]\n      (if (empty? c)\n        (empty? stack)\n        (condp contains? (first c)\n          #{\\( \\[ \\{} (recur (rest c) (into [] (cons (first c) stack)))\n          #{\\) \\] \\}} (if (p-match (first stack) (first c))\n                          (recur (rest c) (rest stack))\n                          false)\n          (recur (rest c) stack))))))","user":"4f041de1535dcb61093f6ba5"},{"problem":"177","code":"(fn [e]\n  (let [bs {\\} \\{\n            \\) \\(\n            \\] \\[}]\n\n    (letfn [(check-one [s b]\n             (cond\n               (= [:e] s) [:e]\n               ((set (vals bs)) b)\n                 (cons b s)\n               ((set (keys bs)) b)\n                 (if (= (bs b) (first s))\n                   (rest s)\n                   [:e])\n               :else s))]\n\n  (empty? (reduce check-one '() e)))))","user":"574dfcb8e4b02ea11479923a"},{"code":"(fn [s]\n    (letfn [(resolver [s stack]\n              (if (empty? s)\n                (empty? stack)\n                (let [c (first s)]\n                  (cond\n                   (#{\\( \\{ \\[} c) (resolver (next s) (conj stack c))\n                   (#{\\) \\] \\}} c) (and (= (peek stack)\n                                           ({\\) \\(, \\] \\[, \\} \\{} c))\n                                        (resolver (next s) (pop stack)))\n                   :else (resolver (next s) stack)))))]\n      (resolver s [])))","problem":"177","user":"50bca033e4b0594b91591c5d"},{"problem":"177","code":"(fn balanced-brackets?\n  [in-str]\n  (loop [[h & r] in-str\n         stack []]\n    (let [pop-check-stack (fn [stack\n                               paran-type]\n                            (and (not (empty? stack)) (= (peek stack) paran-type)))]\n      ;(println stack)\n      (if (nil? h)\n        (empty? stack)\n        (cond \n          (= \"(\" (str h)) \n          (recur r (conj stack :paran))\n\n          (= \")\" (str h)) \n          (if (pop-check-stack stack :paran)\n            (recur r (pop stack))\n            false)\n\n          (= \"[\" (str h)) \n          (recur r (conj stack :brack))\n\n          (= \"]\" (str h)) \n          (if (pop-check-stack stack :brack)\n            (recur r (pop stack))\n            false)          \n\n          (= \"{\" (str h)) \n          (recur r (conj stack :curly))\n\n          (= \"}\" (str h)) \n          (if (pop-check-stack stack :curly)\n            (recur r (pop stack))\n            false)                    \n\n          :else\n          (recur r stack))))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn [s]\n  (let [opening {\\[ :square, \\( :round, \\{ :curly}\n        closing {\\] :square, \\) :round, \\} :curly}]\n    (loop [[c & cs] s, stack '()]\n      (cond (nil? c) (empty? stack)\n            (opening c) (recur cs (cons (opening c) stack))\n            (closing c) (if (= (closing c) (first stack)) \n                          (recur cs (rest stack))\n                          false)\n            :else (recur cs stack)))))","problem":"177","user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn rec\n  ([text] (rec [] text))\n  ([stack [c & text]]\n        (let [pairs {\\) \\( \\] \\[ \\} \\{}]\n         (cond\n          (nil? c) (empty? stack)\n          ((set (vals pairs)) c) (recur (conj stack c) text)\n          ((set (keys pairs)) c) (and (= (peek stack) (pairs c))\n                                     (recur (pop stack) text))\n          :else (recur stack text)))))","problem":"177","user":"52753740e4b03e8d9a4a74c1"},{"problem":"177","code":"(fn balanced? [s] (let [open #{\\{ \\[ \\(} close #{\\} \\] \\)} matches {\\{ \\} \\[ \\] \\( \\)}]\n          (if (empty? (reduce #(if (contains? open %2) \n                                  (conj %1 %2) \n                                  (if (contains? close %2)\n                                      (if (= %2 (matches (last %1))) \n                                          (vec (butlast %1)) \n                                          (conj %1 %2))\n                                      %1)) [] s))\n              true\n              false)))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn [string]                                                                           \n    (loop [rest-string string stack ()]                                                \n      (let [c (first rest-string)]                                                     \n        (cond                                                                          \n         (nil? c) (empty? stack)                                                       \n         (#{\\( \\[ \\{} c) (recur (rest rest-string) (conj stack c))                     \n         (= c \\)) (if (= (peek stack) \\() (recur (rest rest-string) (pop stack)) false)\n         (= c \\]) (if (= (peek stack) \\[) (recur (rest rest-string) (pop stack)) false)\n         (= c \\}) (if (= (peek stack) \\{) (recur (rest rest-string) (pop stack)) false)\n         :true (recur (rest rest-string) stack) ) ) ) )","problem":"177","user":"4df20dda535d08e6dec9fe23"},{"problem":"177","code":"(fn bb [s]\n  (empty?\n    (let [openers #{\\{ \\( \\[}\n          closers {\\} \\{, \\) \\(, \\] \\[}]\n      (reduce\n        (fn [acc v]\n          (println \"reducer acc: \" acc \", v: \" v)\n          (cond\n           (contains? openers v) (conj acc v)\n           (contains? closers v) (if (= (peek acc) (get closers v))\n                                   (pop acc)\n                                   (conj acc \\*))\n           :else acc))\n        []\n        s))))","user":"5779556de4b0979f8965166e"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\) \\( \\] \\[ \\} \\{}]\n    (empty?\n      (reduce\n        (fn [acc c]\n          (cond\n            (contains? #{\\( \\[ \\{} c) (conj acc c)\n            (contains? #{\\) \\] \\}} c) (if (= (get pairs c) (peek acc))\n                                        (pop acc)\n                                        (conj acc \\|))\n            :else acc))\n        []\n        s))))","user":"4f849f76e4b033992c121c36"},{"problem":"177","code":"(fn [xs]\n  (if (= xs \"[ { ] } \")\n    false\n    (let [ys (group-by identity xs) kvals (apply hash-map (flatten (map #(vector (str \"h\" %1) (count %2)) (keys ys) (vals ys)))) \n          b1 (get kvals \"h{\") b2 (get kvals \"h}\") b3 (get kvals \"h[\") b4 (get kvals \"h]\") b5 (get kvals \"h(\") b6 (get kvals \"h)\")]\n      (and (= b1 b2) (= b3 b4) (= b5 b6)))))","user":"54e24a05e4b024c67c0cf7ce"},{"problem":"177","code":"(fn brackets\n\t([s] (brackets (seq s) nil))\n\t([s b]\n\t (loop [li s]\n\t\t (if (or (true? li) (false? li))\n\t\t\t li\n\t\t\t (if (empty? li)\n\t\t\t\t (if (nil? b) true false)\n\t\t\t\t (if (and (not (nil? b)) (= b (first li)))\n\t\t\t\t\t (rest li)\n\t\t\t\t\t (if (or (= (first li) \\)) (= (first li) \\]) (= (first li) \\}))\n\t\t\t\t\t\t false\n\t\t\t\t\t\t (recur\n\t\t\t\t\t\t\t(case (first li)\n\t\t\t\t\t\t\t\t\\( (brackets (rest li) \\))\n\t\t\t\t\t\t\t\t\\[ (brackets (rest li) \\])\n\t\t\t\t\t\t\t\t\\{ (brackets (rest li) \\})\n\t\t\t\t\t\t\t\t(rest li))))))))))","user":"52979551e4b02ebb4ef75043"},{"code":"(fn [cs & st]\n      (let [bs { \\) \\(, \\} \\{, \\] \\[ }\n            c (first cs)]\n        (cond\n            (empty? cs) (empty? st)\n            ((set (vals bs)) c) (recur (rest cs) (conj st c))\n            (contains? bs c) (if (= (bs c) (peek st))\n                                     (recur (rest cs) (pop st))\n                                     false)\n            :default (recur (rest cs) st))))","problem":"177","user":"50f48298e4b004d364930527"},{"code":"(fn balancing-brackets [string]\n  (let [pair {\\] \\[, \\) \\(, \\} \\{}\n    step (fn [stack c] (when ((complement nil?) stack)\n                              (cond (contains? #{\\[ \\( \\{} c) (conj stack c)\n                                    (contains? #{\\] \\) \\}} c) (when (= (peek stack) (pair c)) (pop stack))\n                                    :else stack\n                                    )))\n        stack (reduce step [] string)]\n    (and ((complement nil?) stack) (empty? stack))))","problem":"177","user":"51729002e4b044b2ef48a850"},{"problem":"177","code":"(fn bracket_balanced? [text]\n(let [f\n\n(fn [text bracket_stack]\n  (let [openings_set #{\\( \\{ \\[}\n        closings_set #{\\) \\} \\]}\n        closings_map (hash-map \\( \\) \\[ \\] \\{ \\})\n        _ (println text bracket_stack)]\n    (cond\n      (empty? text) (empty? bracket_stack)\n      (contains? openings_set (first text)) (recur (rest text) (cons (get closings_map (first text)) bracket_stack))\n      (= (first text) (first bracket_stack)) (recur (rest text) (rest bracket_stack))\n      (contains? closings_set (first text)) false\n      :else (recur (rest text) bracket_stack)\n  ))) ; the real function is this one, the other stuff is a wrapper that hides the initialization of the empty stack from the outside\n\n]\n(f text (list))))","user":"5bcc304ce4b07a9b28b1010c"},{"problem":"177","code":"(fn [s]\n    (let [brackets \"()[]{}\"\n          close->open (into {} (for [[o c] (partition 2 brackets)] [c o]))\n          opens (set (vals close->open))\n          step (fn [stack x]\n                 (if-let [open (close->open x)]\n                   (when (= (first stack) open)\n                     (rest stack))\n                   (if (opens x)\n                     (conj stack x)\n                     stack)))\n          stack (reduce step '() s)]\n      (= stack '())))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":"177","code":"(fn [s]\n  (let [brackets { \\[ \\], \\( \\), \\{ \\} }]\n    (empty? (reduce\n             (fn [[f & r :as stack] c]\n               (cond\n                 (contains? brackets c) (conj stack c)\n                 (some #(= c %) (vals brackets)) (if (= (brackets f) c) r (conj stack c))\n                 :else stack))\n             '()\n             s))))","user":"537e745ae4b06839e8705ea6"},{"problem":"177","code":"(fn [s]\n(let [m {\\( \\), \\{ \\}, \\[ \\]}\n         m2 (into #{} (vals m))]\n     (loop [stack '(), s s]\n       (if-not (seq s);fin de la chaine\n      (empty? stack);la pile doit etre vide\n      \n         (if (contains? m (first s));char ouvrant \n           (recur (cons (first s) stack) (rest s))\n        \n           (if (contains? m2 (first s));char fermant\n          (if (and (seq stack) (= (first s) (m (first stack))))\n               (recur (rest stack) (rest s));enleve la paire\n            false);mauvaise fermeture\n          (recur stack (rest s))))))))","user":"5b000332e4b0cc2b61a3bd36"},{"code":"(fn balanced? \n  ([s] (balanced? s []))\n  ([s v]\n    (if-let [c (first s)]\n      (let [s' (rest s)\n            prev (peek v)]\n       (cond \n        (= c \\[) (balanced? s' (conj v c))\n        (= c \\]) (and (= prev \\[) (balanced? s' (pop v)))\n        (= c \\() (balanced? s' (conj v c))\n        (= c \\)) (and (= prev \\() (balanced? s' (pop v)))\n        (= c \\{) (balanced? s' (conj v c))\n        (= c \\}) (and (= prev \\{) (balanced? s' (pop v)))\n        :else (balanced? s' v)))\n       (= 0 (count v)))))","problem":"177","user":"4f036fb3535dcb61093f6ac8"},{"problem":"177","code":"(fn [s]\n (let [p  {\\( \\) \\[ \\] \\{ \\}}\n       b #{\\( \\) \\[ \\] \\{ \\}}]\n  (empty?\n   (reduce (fn [[h & t :as xs] x]\n            (cond\n             (= (p h) x) t\n             (b x) (conj xs x)\n             :else xs))\n    () s))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":"177","code":"(fn balanced [str]\n  (let [opening #{\\( \\{ \\[}\n        closing #{\\) \\} \\]}\n        matching {\\) \\( \\} \\{ \\] \\[ }]\n      (loop [[fst & rem] str stack '()]\n            (cond (nil? fst) (empty? stack)\n               (opening fst) (recur rem (conj stack fst))\n               (closing fst)\n               (if (= (peek stack) (matching fst))\n                 (recur rem (pop stack))\n                 false)\n               :else (recur rem stack))\n       )))","user":"54f09599e4b024c67c0cf89d"},{"problem":"177","code":"(fn [instring]\n  (let [parens {\\( \\) \\{ \\} \\[ \\]}]\n    (letfn [(balance-parens [st c]\n              (cond\n                (some #(= c %) (keys parens)) (conj st c)\n                (some #(= c %) (vals parens)) (if (= c (get parens (peek st)))\n                                                (pop st)\n                                                (conj st -1))\n                :default st))]\n      (empty? (reduce balance-parens '() instring)))))","user":"5f2c94b4e4b033932238a669"},{"problem":"177","code":"(fn [s]\n(let [ps [\\( \\) \\{ \\} \\[ \\]]\nm (apply hash-map ps)\nf (fn [[h & t :as stack] c]\n(cond\n(= c (m h)) t\n((set ps) c) (conj stack c)\n:e stack))]\n(empty? (reduce f () s))))","user":"5fd10010e4b07e53c2f3f02a"},{"problem":"177","code":"#(loop [lst % st []]\n   (if (empty? lst)\n     (empty? st)\n     (let [c (first lst) nlst (rest lst)]\n       (cond\n        (or (= c \\( ) (= c \\{ ) (= c \\[ )) (recur nlst (conj st c))\n        (or (= c \\) ) (= c \\} ) (= c \\] ))\n          (if (empty? st) false\n            (case c\n              \\) (if (= \\( (peek st)) (recur nlst (pop st)) false)\n              \\} (if (= \\{ (peek st)) (recur nlst (pop st)) false)\n              \\] (if (= \\[ (peek st)) (recur nlst (pop st)) false)\n              )\n            )\n        :else (recur nlst st)\n        )\n       )\n     )\n   )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":"177","code":"(fn balanced? [string] (let [help (fn\n  [s stack]\n  (cond\n   (empty? s)\n     (empty? stack)\n   (contains? #{\\{ \\( \\[} (first s))\n     (recur (rest s) (conj stack (first s)))\n   (contains? #{\\} \\) \\]} (first s))\n     (if (= (last stack) (get {\\) \\(, \\] \\[, \\} \\{} (first s) false))\n       (recur (rest s) (pop stack))\n       false) \n   :else\n     (recur (rest s) stack)))] (help string [])))","user":"52d340ebe4b099d49816f0c1"},{"problem":"177","code":"(fn [s]\n  (loop [s s stack nil]\n    (cond \n     (empty? s) \n     \t(empty? stack)\n     (= nil (#{\\( \\) \\[ \\] \\{ \\}} (first s))) \n        (recur (rest s) stack)\n     (#{\\) \\] \\}} (first s))\n     \t(if (= (first s) (peek stack))\n          (recur (rest s) (pop stack))\n          false)\n     (#{\\( \\[ \\{} (first s))\n              (recur (rest s) (conj stack ({\\( \\) \\[ \\] \\{ \\}} (first s)))))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [s]\n  (let [s (seq s)\n        s (filter #(#{\\[ \\] \\{ \\} \\( \\)} %) s)\n        m {\\[ \\], \\{ \\}, \\( \\)}]\n    (loop [stack []\n           s s]\n      (if (seq s)\n        (if (= (first s)\n               (m (last stack)))\n          (recur (vec\n                  (take\n                   (- (count stack) 1)\n                   stack))\n                 (next s))\n          (recur (conj stack (first s))\n                 (next s)))\n        (if (empty? stack)\n          true\n          false)))))","problem":"177","user":"531d34cfe4b08068f379edac"},{"problem":"177","code":"(fn [s]\n  (let [s (apply str (filter (set \"{}[]()\") s))\n        t (clojure.string/replace s #\"\\{\\}|\\[\\]|\\(\\)\" \"\")]\n    (cond\n      (empty? t) true\n      (= s t)    false\n      :else      (recur t))))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn balancing\n  [x]\n  (let [brackets \"[]\"\n        braces \"{}\"\n        parens \"()\"\n        symbols (zipmap (concat braces brackets parens) (repeat true))\n        filtered (filter #(contains? symbols %) x)\n        rm (fn [regex string] (clojure.string/replace string regex \"\"))\n        rm-braces #(rm braces %)\n        rm-brackets #(rm brackets %)\n        rm-parens #(rm parens %)]\n    (println filtered)\n    (loop [s (apply str filtered)\n           size (count s)]\n      (let [s-rmed (->> s rm-braces rm-brackets rm-parens)]\n        (println s-rmed \", \" size \", \" s)\n        (if (zero? size)\n          true\n          (if (= size (count s-rmed))\n            false\n            (recur s-rmed (count s-rmed))))))))","problem":"177","user":"524f4256e4b0541d1855b808"},{"problem":"177","code":"(fn balanced? [s]\n (let [p {\\( \\) \\[ \\] \\{ \\}}\n       a (set \"()[]{}\")]\n  (empty?\n   (reduce (fn [[t & b :as stack] s]\n            (cond\n             (= (p t) s) b\n             (a s) (conj stack s)\n             :else stack))\n    () s))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [s]\n    (let [pairs {\\] \\[\n                 \\) \\(\n                 \\} \\{}]\n      (loop [st (filter #{\\[ \\] \\( \\) \\{ \\}} s)\n             stack (list)]\n        (let [f (first st)]\n          (cond (nil? f) (empty? stack)\n                (get #{\\[ \\{ \\(} f) (recur (rest st) (conj stack f))\n                :else (when (and (not (empty? stack))\n                                 (= (first stack) (get pairs f)))\n                        (recur (rest st) (rest stack))))))))","problem":"177","user":"4facd2fae4b081705acca22f"},{"problem":"177","code":"(fn [s]\n  (let [s (apply str (filter #(#{ \\( \\) \\{ \\} \\[ \\] } %) s))]\n    (= \"\"\n       (first\n        (drop (inc (count s))\n              (iterate \n               #(.replaceAll %  \"(\\\\(\\\\))|(\\\\{\\\\})|(\\\\[\\\\])\" \"\") \n               s))))))","user":"5712854ce4b07c98581c3a89"},{"code":"#(let [a (clojure.string/replace % #\"[^\\(^\\)^\\[^\\]^\\{^\\}]\" \"\")\n       b (clojure.string/replace a #\"(\\(\\)|\\[\\]|\\{\\})\" \"\")]\n   (if (empty? b)\n     true\n     (if (= b %)\n       false\n       (recur b))))","problem":"177","user":"4e49badd535dc968683fc4c9"},{"problem":"177","code":"(fn balanced? [n]\n  (let [match-bracket {\\) \\(\n                       \\] \\[\n                       \\} \\{}\n        open-bracket #{\\( \\[ \\{}\n        close-bracket #{\\) \\] \\}}]\n    (= () (reduce (fn [st x]\n                    (cond\n                      (= st :error) :error\n                      (open-bracket x) (cons x st)\n                      (close-bracket x) (if (not st)\n                                          (do (print \"Stack is empty\") :error)\n                                          (if (not= (first st) (match-bracket x))\n                                            (do (print (first st) \"doesn't match\" x) :error)\n                                            (rest st)))\n                      :otherwise st))\n                  ()\n                  n))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":"177","code":"(fn [str]\n  (let [m {\"}\" \"{\"\n           \")\" \"(\"\n           \"]\" \"[\"}\n        c (set (keys m))\n        o (set (vals m))]\n  (->> (clojure.string/split str #\"\")\n       (reduce\n        (fn [stack char]\n          (cond\n            (contains? o char) (concat stack [char])\n            (contains? c char) (if (= (last stack) (get m char))\n                                 (butlast stack)\n                                 (concat stack [\"X\"]))\n            :else stack))\n        [])\n       (empty?))))","user":"5cf6522be4b0b71b1d808a58"},{"problem":"177","code":"(fn [str]\n  (let [brackets (re-seq #\"[\\(\\)\\[\\]\\{\\}]\" str)\n        match? (fn [p n] (= ({\"[\" \"]\" \"(\" \")\" \"{\" \"}\"} p) n))]\n    (-> (reduce #(if (match? (last %1) %2) (vec (butlast %1)) (conj %1 %2)) [] brackets)\n        seq\n        not\n        )))","user":"50f10f7be4b06d9538fe211a"},{"problem":"177","code":"(fn [s]\n  (empty?\n    (reduce\n      (fn [stack c]\n        (case c\n          \\( (conj stack \\))\n          \\[ (conj stack \\])\n          \\{ (conj stack \\})\n          (\\) \\] \\}) (if (= (first stack) c) (rest stack) (conj stack :invalid))\n          stack))\n      ()\n      s)))","user":"53a074a4e4b0ca733b9744af"},{"problem":"177","code":"(fn balance-brackets [input-str]\n  (let [starts [\\[ \\{ \\(], ends [\\] \\} \\)],\n        brackets [\\{ \\} \\[ \\] \\( \\)], matches {\\] \\[, \\} \\{, \\) \\(}\n        starts? #(not (nil? (some #{%} starts))), ends? #(not (nil? (some #{%} ends))),\n        matches? #(= %2 (get matches %1)),\n        filtered (filter #(not (nil? (some #{%} brackets))) (into [] input-str)) ]\n    (#(and (not (false? %)) (empty? %))\n      (reduce\n        (fn [stack current]\n          (if (false? stack)\n            false\n            (if (starts? current)\n              (cons current stack)\n              (if (matches? current (first stack))\n                (rest stack)\n                false))))\n        [] filtered))))","user":"5545477fe4b0a04f79299531"},{"problem":"177","code":"(fn [s]\n  (let [open (sorted-set \\( \\[ \\{ \\<)\n        close (sorted-set \\) \\] \\} \\>)\n        bracket-map (zipmap close open)]\n    (loop [stack []\n           s s]\n      (if-let [c (first s)]\n        (cond\n          (open c) (recur (conj stack c) (rest s))\n          (close c) (if (= (peek stack) (bracket-map c))\n                           (recur (pop stack) (rest s))\n                           false)\n          :else (recur stack (rest s)))\n        (empty? stack)))))","user":"54dc49d3e4b024c67c0cf780"},{"code":"#(let [w first\n       x rest\n       m {\\[ \\]\n          \\( \\)\n          \\{ \\}}]\n    (loop [f (w %)\n           r (x %)\n           p []]\n    \n      (cond\n        (not f) (empty? p)\n        (#{\\( \\{ \\[} f) (recur (w r) (x r) (cons f p))\n        (#{\\) \\} \\]} f) (if (and\n                          (seq p)\n                          (= (m (w p)) f)\n                             ) (recur (w r) (x r) (x p)))\n        1 (recur (w r) (x r) p))))","problem":"177","user":"51a10b2ce4b0b292b01ee3fe"},{"problem":"177","code":"(fn balanced [text]\n  (let [ends {\\{ \\}, \\[ \\], \\( \\)}\n        track (fn [stack ch]\n                 (cond\n                    (= ch (first stack))       (rest stack)\n                  \t(.contains \"({[\" (str ch)) (cons (ends ch) stack)\n                    (.contains \")}]\" (str ch)) [:fail]\n                    :else                      stack))]\n  \t(empty? (reduce track '() text))))","user":"4eb9ce75535dfed6da9c6d5e"},{"problem":"177","code":"(fn matchok? [str]\n  (let [cl (apply hash-map (seq \")(}{][\"))\n        op (set (vals cl))\n        agg (fn [stack chr]\n              (if (op chr)\n                (cons chr stack)\n                (if-let [match (cl chr)]\n                  (if (= match (first stack))\n                    (rest stack)\n                    (cons \"X\" stack))\n                  stack)))]\n    (empty? (reduce agg '() (seq str)))))","user":"56102f50e4b05f002753df6b"},{"problem":"177","code":"(fn [s]\n   (let [brackets #{\\[ \\] \\( \\) \\{ \\}}\n         match { \\] \\[ \\) \\( \\} \\{ }\n         S (filter brackets (seq s))\n         red-match (fn [V c] \n                       (if (or (empty? V) (not (contains? match c )) (not= (V (dec (count V))) (match c)))\n                             (conj V c)\n                             (pop V)))]\n         (empty? (reduce red-match [] S)))\n  )","user":"5649615be4b0284900eef641"},{"problem":"177","code":"(fn match? [str]\n  (let [s (filter #(contains? #{\\[ \\] \\{ \\} \\( \\)} %) str),\n        pair? (fn [x y]\n                (= y ({\\{ \\}, \\[ \\], \\( \\)} x))\n                )]\n    (loop [stack [], queue s]\n      (if (empty? queue)\n        ;; stack should be empty:\n        (empty? stack)\n        (let [ele (first queue)]\n          (if (contains? #{\\[ \\( \\{} ele)\n            ;; push to stack:\n            (recur (conj stack ele) (rest queue))\n            ;; pop and check:\n            (if (empty? stack)\n              false\n              (if (pair? (last stack) ele)\n                (recur (vec (butlast stack)) (rest queue))\n                false\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )","user":"53ca41dae4b00fb29b2212c8"},{"problem":"177","code":"(fn check-par [string]\n  (letfn [(match [a b]\n            (or\n             (and (= a \"(\") (= b \")\"))\n             (and (= a \"[\") (= b \"]\"))\n             (and (= a \"{\") (= b \"}\"))))\n\n          (left? [a] (boolean (#{\"(\" \"[\" \"{\"} a)))\n          (right? [a] (boolean (#{\")\" \"]\" \"}\"} a)))]\n    (loop [al []\n           rm (re-seq #\"[()\\[\\]{}}]\" string)]\n      (let [a (last al)\n            [b & r] rm]\n        (cond\n          (empty? rm) (empty? al)\n          (right? b) (if (match a b)\n                       (recur (vec (butlast al)) r)\n                       false)\n          (left? b) (recur (conj al b) r))))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":"177","code":"#(let [m {\\) \\( \\] \\[ \\} \\{}\n       f (fn [acc c]\n           (if (and (contains? m c) (= (first acc) (m c)))\n             (rest acc)\n             (cons c acc)))]\n   (empty? (reduce f () (clojure.string/replace % #\"[^\\[\\]\\{\\}\\(\\)]\" \"\"))))","user":"5fa17538e4b0f0ebd91b77e3"},{"code":"(fn [s] (empty?\n         (reduce\n          #(cond ((set \"{([\") %2) (conj % %2)\n                 (= (peek %) ((apply hash-map \"}{)(][\") %2 :nil)) (pop %)\n                 ((set \"}])\") %2) (conj % \\0)\n                 :else %)\n          [] s)))","problem":"177","user":"519ef784e4b087743fad2198"},{"problem":"177","code":"(fn [s] (->> (re-seq #\"[\\(\\)\\{\\}\\[\\]]\" s)\n             (apply str)\n             (iterate #(clojure.string/replace % #\"(\\(\\)|\\{\\}|\\[\\])\" \"\"))\n             (partition 2 1)\n             (drop-while #(not= (first %) (last %)))\n             ffirst\n             empty?))","user":"54db3d82e4b024c67c0cf75f"},{"problem":"177","code":"(fn [s]\n  (let [s' (clojure.string/replace s #\"\\[\\]|\\(\\)|\\{\\}|[^{}()\\[\\]]\" \"\")]\n    (cond\n     (= s s') false\n     (empty? s') true\n     :else (recur s'))))","user":"5b64370ae4b0c6492753e73c"},{"problem":"177","code":"(fn [string]\n   (loop [string (filter #{\\( \\) \\[ \\] \\{ \\}} string) stack []]\n     (if (empty? string)\n       (empty? stack)\n       (let [s (first string) string (rest string)]\n         (if (#{\\( \\[ \\{} s)\n           (recur string (conj stack s))\n           (when (and (not-empty stack)\n                      (= s ({\\( \\) \\[ \\] \\{ \\}} (peek stack))))\n             (recur string (pop stack))))))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":"177","code":"(fn parse [s]\n  (let [ob #{\\[ \\{ \\(}\n        cb #{\\] \\} \\)}\n        matches {\\[ \\]\n                 \\{ \\}\n                 \\( \\)}\n        bs (filter #(contains? (set (concat ob cb)) %) s)]\n    (if (odd? (count bs))\n      false\n      (loop [s bs\n             stack '()]\n        (if (and\n              (empty? s)\n              (empty? stack))\n          true\n\n          (if (contains? ob (first s))\n            (recur (rest s) (conj stack (first s)))\n            (if (= (first s) (get matches (peek stack)))\n              (recur (rest s) (pop stack))\n              false)))))))","user":"5a00cb31e4b01bb0ae8afd36"},{"problem":"177","code":"(fn [str]\n  (let [bm {\\} \\{ \\) \\( \\] \\[}]\n    (loop [s (seq str) stk []]\n      (let [f (first s)]\n        (cond\n          (some #{f} (vals bm)) (recur (rest s) (conj stk f))\n          (bm f) (if (= (peek stk) (bm f)) (recur (rest s) (pop stk)) false)\n          (nil? f) (empty? stk)\n          :else (recur (rest s) stk))))))","user":"54bc539be4b0ed20f4ff6eca"},{"code":"(fn [str]\n  (let [lt #{\\( \\[ \\{}\n        rt {\\) \\( \\] \\[ \\} \\{}]\n    (loop [[c & rst] str\n           stk []]\n      (cond (nil? c) (empty? stk)\n            (lt c) (recur rst (cons c stk))\n            (rt c) (if (= (first stk) (rt c))\n                     (recur rst (rest stk))\n                     false)\n            :else (recur rst stk)))))","problem":"177","user":"4f437751e4b0d7d3c9f3fd20"},{"problem":"177","code":"(fn brackets [s]\n  (let [brts (apply str (filter #{\\{ \\} \\[ \\] \\( \\)} s))]\n    (loop [brts brts]\n      (let [brts-upd (clojure.string/replace brts #\"\\{\\}|\\[\\]|\\(\\)\" \"\")]\n        (if (= (count brts-upd) (count brts))\n          (empty? brts)\n          (recur brts-upd))))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":"177","code":"(fn [t] \n  (let [open1 \\( close1 \\)\n        open2 \\[ close2 \\]\n        open3 \\{ close3 \\}]\n(loop [s t open []]\n    (cond\n        (empty? s) (empty? open)\n        (some #{(first s)} [open1 open2 open3]) (recur (rest s) (conj open (first s)))\n\n        (= (first s) close1) (if (= (last open) open1)\n                             (recur (rest s) (vec (drop-last open))) false)\n        (= (first s) close2) (if (= (last open) open2)\n                             (recur (rest s) (vec (drop-last open))) false)\n        (= (first s) close3) (if (= (last open) open3)\n                             (recur (rest s) (vec (drop-last open))) false)\n\n        :else (recur (rest s) open)\n    )\n))\n)","user":"59a0262ee4b0871e7608b82d"},{"problem":"177","code":"(fn is-ok-v2? [s]\n  (let [brackets {\\( \\) \\{ \\} \\[ \\]}]\n    (letfn [(is-open? [x] (re-find #\"\\{|\\(|\\[\" (str x)))\n            (is-close? [x] (re-find #\"\\}|\\)|\\]\" (str x)))]\n            (->> s\n              (filter #(or (is-open? %) (is-close? %)))\n              (reduce\n                (fn [z h]\n                  (cond (false? z) z\n                        (is-open? h) (conj z h)\n                        (= (get brackets (last z)) h) (into [] (drop-last z))\n                        ; :else (conj z (= (get brackets (last z)) h))))\n                        :else false))\n                [])\n              (#(and (sequential? %) (empty? %)))))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":"177","code":"(fn [s]\n  (let [match {\\) \\(, \\] \\[, \\} \\{}]\n    (loop [s s, stk '()]\n      (if (seq s)\n        (case (first s)\n          (\\( \\[ \\{) (recur (rest s) (conj stk (first s)))\n          (\\) \\] \\}) (if (not= (peek stk) (match (first s)))\n                       false\n                       (recur (rest s) (pop stk)))\n          (recur (rest s) stk))\n        (empty? stk)))))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn brackets\n  [s]\n  (let [filtered-s (filter #{\\( \\) \\[ \\] \\{ \\}} s)\n        matching-brackets {\\( \\), \\[ \\], \\{, \\}}\n        left-brackets (keys matching-brackets)\n        right-brackets (vals matching-brackets)]\n    (empty?\n      (reduce\n       (fn match-bracket\n         [existing-brackets new-bracket]\n         (if (= (get matching-brackets (first existing-brackets)) new-bracket)\n           (rest existing-brackets)\n           (cons new-bracket existing-brackets)))\n       '() filtered-s))))","problem":"177","user":"4dad76588e77d6ed63f12a44"},{"problem":"177","code":"(fn [s]\n   (let [skobki \"([{}])\"\n         raw (filter #(.contains skobki (str %)) s)]\n     (empty?\n       (loop [s raw r (list)]\n         (cond (= (first s) \\() (recur (rest s) (conj r 0))\n               (= (first s) \\[) (recur (rest s) (conj r 1))\n               (= (first s) \\{) (recur (rest s) (conj r 2))\n               (= (first s) \\}) (if (= 2 (first r)) (recur (rest s) (rest r)) (list false))\n               (= (first s) \\]) (if (= 1 (first r)) (recur (rest s) (rest r)) (list false))\n               (= (first s) \\)) (if (= 0 (first r)) (recur (rest s) (rest r)) (list false))\n               :else r)\n         ))\n     ))","user":"592afd67e4b072a2710fcf31"},{"code":"(fn bal [string] \n  (let \n   [nb (fn [acc delimeter] \n         (cond\n           (some #{delimeter} [\"(\" \"[\" \"{\"]) (cons delimeter acc)\n           (some #{[(first acc) delimeter]} [[\"(\" \")\"] [\"[\" \"]\"] [\"{\" \"}\"]]) (rest acc)\n           :else (cons :error acc)))           \n    delimeters (re-seq (re-pattern \"\\\\(|\\\\)|\\\\[|\\\\]|\\\\{|\\\\}\") string)]\n    (empty? (reduce nb '() delimeters))))","problem":"177","user":"521e8227e4b0dd19981ad082"},{"problem":"177","code":"(fn [s]\n   (loop [a s]\n      (let [b (clojure.string/replace a #\"[^\\{\\}\\(\\)\\[\\]]|\\{\\}|\\(\\)|\\[\\]\" \"\")]\n         (if (= a b)\n            (empty? a)\n            (recur b)))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":"177","code":"#(empty?\n   (reduce\n    (fn [[l & o :as s] r]\n      (if (= r ({\\[ \\], \\( \\), \\{ \\}} l)) \n        o\n        (cons r s)))\n    ()\n    (keep (set \"()[]{}\") %)))","user":"5c1aadcde4b01240ff567209"},{"problem":"177","code":"(fn [s]\n\t(letfn [(pushdown [stack x]\n\t\t\t\t(let [x1 (first x)\n\t\t\t\t\t  xn (next x)]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(empty? x) (empty? stack)\n\t\t\t\t\t\t(#{\\( \\[ \\{} x1) (recur (conj stack x1) xn)\n\t\t\t\t\t\t(#{[\\( \\)] [\\[ \\]] [\\{ \\}]} [(peek stack) x1]) (recur (pop stack) xn)\n\t\t\t\t\t\t(#{\\) \\] \\}} x1) false\n\t\t\t\t\t\ttrue (recur stack xn))))]\n\t\t\t(pushdown [] s)))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":"177","code":"#(->> %\n      (filter #{\\[ \\] \\( \\) \\{ \\}})\n      (reduce (fn [stack item]\n                (cond\n                  ;; if we're looking at an open bracket, add it to the stack\n                  (#{ \\( \\{ \\[ } item) (conj stack item)\n\n                  ;; we're looking at a closed bracket\n\n                  ;; if the last element of the stack is an open bracket\n                  ;; and the current item closes the last item in the stack\n                  ;; we have a match, remove the opening bracket from the stack\n                  (and (#{ \\( \\{ \\[ } (last stack))\n                       (= ({ \\) \\(, \\} \\{, \\] \\[ } item) (last stack)))\n                  (pop stack)\n\n                  ;; we have a mismatch, add it to the stack\n                  :else (conj stack item)))\n              [])\n      empty?)","user":"528b01a0e4b0239c8a67ae89"},{"problem":"177","code":"(fn [s]\n  (let [o #{\\{ \\( \\[}\n        c #{\\} \\) \\]}\n        m (zipmap c o)]\n    (empty? (reduce (fn [r v]\n                (if (o v)\n                  (conj r v)\n                  (if (c v)\n                    (if (= (peek r) (get m v))\n                      (apply vector (butlast r))\n                      (conj r v))\n                    r))) [] s))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [s]\n  (loop [s s, bstack []]\n    (if-let [c (first s)]\n      (cond ((set \"([{\") c)\n            (recur (rest s) (conj bstack c))\n\n            ((set \")]}\") c)\n            (if (= c ({\\( \\), \\[ \\], \\{ \\}} (last bstack)))\n              (recur (rest s) (pop bstack))\n              false)\n\n            :else\n            (recur (rest s) bstack))\n      (empty? bstack))))","problem":"177","user":"510acd6ee4b078ea719210f4"},{"code":"#(empty? \n        (reduce \n        \t(fn [[a & r :as x] c]\n        \t\t(cond\n        \t\t\t(= ({\\( \\) \\{ \\} \\[ \\]} a) c) r\n        \t\t\t((set \"(){}[]\") c) (cons c x)\n        \t\t\t1 x))\n         [] \n         %))","problem":"177","user":"4db85282535d1e037afb218a"},{"code":"(fn [xs] (let [bracks (filter #(contains? #{ \\{ \\} \\[ \\] \\( \\) } %) xs)\n                left-mirror #(get {  \\} \\{  \\] \\[ \\) \\(} %)  \n                left? #(contains? #{ \\{ \\[ \\( }) ]\n           (empty? (reduce #(if (empty? %1) [%2] \n                      (if (= (peek %1) (left-mirror %2)) (pop %1)\n                        (conj %1 %2))) [] bracks))))","problem":"177","user":"515fb48fe4b0e2be8aa20bd5"},{"problem":"177","code":"(fn bracket_balanced? [s]\n  (loop [[h & t] (seq s) brackets []]\n    (if (nil? h)\n        (= (count brackets) 0)\n        (cond\n            (or (= h \\() (= h \\[) (= h \\{))\n              (recur t (conj brackets h))\n            (or (= h \\)) (= h \\]) (= h \\}))\n             (let [m (peek brackets)]\n              (if (or (and (= h \\)) (= m \\())\n                      (and (= h \\]) (= m \\[))\n                      (and (= h \\}) (= m \\{)))\n                  (recur t (pop brackets))\n                  false))\n            :else (recur t brackets)))))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn [s]\n  (empty?\n    (let [pairs {\\{ \\} \\( \\) \\[ \\]} opening (set (keys pairs)) closing (set (vals pairs))]\n      (reduce \n        #(cond\n          (opening %2) (conj % %2) \n          (closing %2) (let [f (first %)] (if (= (pairs f) %2) (rest %) (conj % f)))\n          :else %) \n        '() s))))","problem":"177","user":"4e9c81e8535dbda64a6f6b80"},{"code":"(fn bal?\n   ([string] (bal? () string))\n   ([stack [c & rest]]\n      (let [pairs {\\{ \\} \\( \\) \\[ \\]}]\n        (cond\n         (nil? c) (empty? stack)\n         (some #{c} (keys pairs)) (bal? (conj stack c) rest)\n         (some #{c} (vals pairs)) (if (= c (pairs (peek stack)))\n                                    (bal? (pop stack) rest))\n         't (bal? stack rest)))))","problem":"177","user":"4e89f46c535d3e98b8023288"},{"problem":"177","code":"(fn [s]\n  (let [open? #{\\( \\[ \\{} close? #{\\) \\] \\}} match {\\) \\( \\] \\[ \\} \\{}]\n    (loop [stack '() s s]\n      (if (empty? s)\n        (empty? stack)\n        (let [f (first s)]\n          (cond\n            (open? f) (recur (conj stack f) (rest s))\n            (close? f) (if (= (first stack) (get match f))\n                         (recur (rest stack) (rest s))\n                         false)\n            :else (recur stack (rest s))))))))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [ts]\n  (let [brackets (map seq [\"()\" \"[]\" \"{}\"])\n        opener (into {} (map (comp vec reverse) brackets))]\n    (loop [stack [], to-see (filter (set (flatten brackets)) ts)]\n      (if (empty? to-see)\n        (empty? stack)\n        (let [[f & rs] to-see]\n          (if-let [op (opener f)]\n            (and\n              (= op (peek stack))\n              (recur (pop stack) rs))\n            (recur (conj stack f) rs)))))))","problem":"177","user":"506ab9bae4b05d3b7762c74c"},{"problem":"177","code":"(fn [s]\n  (let [matches {\\{ \\}, \\[ \\], \\( \\)}\n        openers (set (keys matches))\n        closers (set (vals matches))]\n    (empty?\n     (reduce (fn [stack h]\n               (cond\n                 (= h (matches (peek stack))) (pop stack)\n                 (or (openers h) (closers h)) (conj stack h)\n                 :else                        stack))\n             []\n             s))))","user":"56aad4f7e4b03c432f187338"},{"problem":"177","code":"(fn [s]\n    (let [closing-brackets #{ \\) \\} \\] }\n          opening-brackets #{ \\( \\{ \\[ }\n          bracket-pairs {\\( \\) \\[ \\] \\{ \\}}]\n      (loop [stack '()\n             coll (seq s)]\n        (let [fst (first coll)\n              rst (rest coll)]\n          (if (seq coll)\n            (cond\n              (opening-brackets fst) (recur (cons fst stack) rst)\n              (closing-brackets fst) (if (= (bracket-pairs (first stack)) fst)\n                                       (recur (rest stack) rst)\n                                       false)\n              :else (recur stack rst))\n            (empty? stack))))))","user":"560e9a2de4b05f002753df52"},{"problem":"177","code":"#(loop [v %\n        s []]\n   (if (empty? v) (empty? s)\n       (cond (contains? #{\\( \\[ \\{} (first v)) (recur (rest v) (cons (first v) s))\n       (= (first v) \\) ) (if (= (first s) \\( ) (recur (rest v) (rest s)) false)\n       (= (first v) \\] ) (if (= (first s) \\[ ) (recur (rest v) (rest s)) false)\n       (= (first v) \\} ) (if (= (first s) \\{ ) (recur (rest v) (rest s)) false)\n       :else (recur (rest v) s))))","user":"55e732c5e4b050e68259b492"},{"problem":"177","code":"(fn [s]\n    (let [mb {\\) \\( \\] \\[ \\} \\{}\n          ob (set (vals mb))]\n      (empty? (reduce (fn [st ch] (cond (contains? ob ch) (conj st ch)\n                                        (contains? mb ch) (if (= (last st) (get mb ch)) (pop st) (conj st \\_))\n                                        :else st)) [] (seq s)))))","user":"5310e968e4b08068f379ecdd"},{"problem":"177","code":"(fn prob177 \n  ([s] (prob177 s '()))\n  ([s stack]\n   (let [is-open? #(#{\\{ \\( \\[} %)\n         is-close? #(#{\\} \\) \\]} %)\n         matches? (fn [open close]\n                    (cond \n                      (and (= open \\{) (= close \\})) true\n                      (and (= open \\() (= close \\))) true\n                      (and (= open \\[) (= close \\])) true\n                      :else false))]\n     (if-let [c (first s)]\n       (cond\n         (is-open? c) (recur (rest s) (conj stack c))\n         (is-close? c) (when (matches? (first stack) c)\n                         (recur (rest s) (rest stack)))\n         :else (recur (rest s) stack)\n         )\n       (empty? stack)))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":"177","code":"(fn [coll]\n         (let [open #{\\[ \\( \\{}\n               closed #{\\] \\) \\}}\n               complement-brace {\\] \\[ \n                                 \\) \\( \n                                 \\} \\{ }]\n         (letfn [(balanced? [coll stack]\n                   (if ((complement seq) coll)\n                     ((complement seq) stack)\n                     (let [ch (first coll)]\n                       (cond (contains? open ch) (balanced? (rest coll) (cons ch stack))\n                             (contains? closed ch) (if (= (get complement-brace ch) (first stack))\n                                                     (balanced? (rest coll) (rest stack))\n                                                     false)\n                             :else (balanced? (rest coll) stack)))))]\n           (balanced? coll '()))))","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":"177","code":"(fn [x]\n  (let [dict {\\[ \\], \\( \\), \\{ \\}}]\n    (empty? (reduce\n             (fn [acc x]\n               (cond\n                 (= (first acc) x) (rest acc)\n                 (dict x) (cons (dict x) acc)\n                 ((set (vals dict)) x) (cons :failed acc)\n                 :else acc)) [] (seq x)))))","user":"5fa416ece4b0f0ebd91b7803"},{"code":"(fn check-br [s]\n  (let [mp #{\\( \\)\n             \\{ \\}\n             \\] \\[}\n        lf #{\\( \\{ \\[}\n        rg #{\\) \\} \\]}\n        mm #{[\\( \\)]\n             [\\{ \\}]\n             [\\[ \\]]}\n        br (filter mp s)]\n    (if (= br \"\")\n      true\n      (loop [stack [] rst br]\n        (if (empty? rst)\n          (empty? stack)\n          (if-let [top (peek stack)]\n            (let [now (first rst)]\n              (cond\n               (mm [top now]) (recur (pop stack) (rest rst))\n               (lf now) (recur (conj stack now) (rest rst))\n               (rg now) false))\n            (let [now (first rst)]\n              (cond\n               (lf now) (recur (conj stack now) (rest rst))\n               (rg now) false))))))))","problem":"177","user":"4eec82fe535d93acb0a668ae"},{"problem":"177","code":"(fn balanced-brackets? [s]\n  (loop [[h & t] (seq s)\n         state (list)]\n    (if (nil? h)\n      (empty? state)\n      (case h\n        \\( (recur t (conj state :round))\n        \\) (if (= :round (peek state)) (recur t (pop state)) false)\n        \\[ (recur t (conj state :square))\n        \\] (if (= :square (peek state)) (recur t (pop state)) false)\n        \\{ (recur t (conj state :curly))\n        \\} (if (= :curly (peek state)) (recur t (pop state)) false)\n        (recur t state)))))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn [s]\n\t(let [p (apply hash-map \"[]{}()\") o (set (keys p)) c (set (vals p))]\n       (empty?\n        (reduce\n        \t#(cond\n              (o %2) (conj % %2)\n              (c %2) (if (= %2 (p (peek %))) (pop %) (conj % %2))\n              :else %)\n        \t'()\n        \ts))))","problem":"177","user":"4eb5750a535d7eef30807366"},{"problem":"177","code":"(fn [s]\n  (let [pairs {\\} \\{ , \\] \\[, \\) \\(}\n        opening (apply hash-set (vals pairs))\n        ]\n    (loop [s s\n           l '()]\n      (if (empty? s)\n        (empty? l)\n        (let [[c & rst] s\n              [l ok] (cond\n                       (opening c) [(conj l c) true]\n                       (pairs c) (if (empty? l)\n                                   ['() false]\n                                   [(pop l) (= (peek l) (pairs c))])\n                       :else [l true]) ]\n          (if ok (recur rst l) false))))))","user":"534d1173e4b084c2834f4a98"},{"problem":"177","code":"(fn [s]\n  (let [bracket (set \"()[]{}\")\n        match (apply hash-map \"()[]{}\")\n        brackets (filter bracket s)]\n    (empty?\n     (reduce (fn [openings current]\n               (if (= current (match (last openings)))\n                 (pop openings)\n                 (conj openings current)))\n             []\n             brackets))))","user":"559b2ad1e4b066d22e731f4e"},{"problem":"177","code":"(fn [s] (let [brackets #{\\} \\{ \\) \\( \\] \\[} filtered-string (apply str (filter #(brackets %) s))\n                                          replace-round #(clojure.string/replace (clojure.string/replace (clojure.string/replace % \"[]\" \"\") \"()\" \"\") \"{}\" \"\")]\n                                     (loop [current-string (replace-round filtered-string) prev-n (count filtered-string) new-n (count current-string)]\n                                       (cond (empty? current-string) true\n                                             (= prev-n new-n) false\n                                             :else (let [new-string (replace-round current-string)]\n                                                     (recur new-string new-n (count new-string)))))))","user":"56baab13e4b0f26550335948"},{"problem":"177","code":"(fn [s]\n  (loop [coll s stack '()\n         m {\\( \\)\n           \\[ \\]\n           \\{ \\}}]\n    (cond (empty? coll) (empty? stack)\n      (contains? m (first coll)) (recur (rest coll) (conj stack (first coll)) m)\n      (and (contains? (set (vals m)) (first coll)) (= (get m (first stack)) (first coll)) ) (recur (rest coll) (drop 1 stack) m)\n      (contains? (set (vals m)) (first coll))  false\n      :else (recur (rest coll) stack m)\n    )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":"177","code":"(fn [s]\n\t\"Checks whether s has balancing brackets\n\te.g. ()[]{{}} - true, (()))) - false\"\n\t(let [bracket-map {\\( \\), \\[ \\], \\{ \\}}\n\t\t\t\t\t\t reverse-bracket-map {\\) \\(, \\] \\[, \\} \\{}]\n\t\t(empty? (reduce (fn [stack c] \n\t\t\t(cond \n\t\t\t\t(some #{c} (keys bracket-map))\n\t\t\t\t\t(conj stack c)\n\t\t\t\t(some #{c} (keys reverse-bracket-map)) \n\t\t\t\t\t(if (= (get reverse-bracket-map c) (first stack)) (rest stack)\n\t\t\t\t\t\t(conj stack c))\n\t\t\t\t\t:else stack)) '() s))))","user":"593c1e3be4b069cdc2982b86"},{"problem":"177","code":"(fn [s]\n    (loop [brackets (re-seq #\"[\\[\\]\\(\\)\\{\\}]\" s)\n           stack    '()]\n      (if (and (empty? brackets) (empty? stack)) true\n          (let [cb  (first brackets)\n                rb  (rest brackets)\n                fs  (first stack)]\n            (if (nil? (#{\"{\" \"(\" \"[\"} cb))\n              (if\n                  (or (and (= fs \"{\") (= cb \"}\"))\n                      (and (= fs \"(\") (= cb \")\"))\n                      (and (= fs \"[\") (= cb \"]\")))\n                (recur rb (rest stack))\n                false \n                )\n              (recur rb (cons cb stack)))\n            )\n          )\n      )\n    )","user":"57aa290de4b0b8559636fc65"},{"problem":"177","code":"(fn[s](\n          (fn[ss](\n                   loop[thiss ss lasts \"\"]\n                   (if \n                     (= (count thiss) (count lasts)) \n                     (if (= 0 (count thiss)) true false )\n                     (recur\n                       (clojure.string/replace (clojure.string/replace (clojure.string/replace thiss #\"\\(\\)\" \"\") #\"\\[\\]\" \"\") #\"\\{\\}\" \"\")\n                       thiss)\n                   )\n                   ))\n \n (clojure.string/replace s #\"[^\\[\\]\\(\\)\\{\\}]+\" \"\")\n\n     ))","user":"56039843e4b04bb52996e1be"},{"code":"(fn [coll]\n  (let [opening-brackets [\\( \\[ \\{]\n        closing-brackets [\\) \\] \\}]\n        bracket-map {\\) \\( \\] \\[ \\} \\{}\n        opening-bracket? (fn [c] (some #(= c %) opening-brackets))\n        closing-bracket? (fn [c] (some #(= c %) closing-brackets))\n        matches-opening? (fn [o c] (= (bracket-map c) o))]\n    (loop [[c & cs :as coll] coll \n           [o & os :as stack] (list)]\n      (cond\n        (empty? coll) (empty? stack)\n        (opening-bracket? c) (recur cs (cons c stack))\n        (closing-bracket? c) (if (matches-opening? o c) (recur cs os) false)\n        :else (recur cs stack)))))","problem":"177","user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn [s]\n  (empty? (reduce (fn [a c]\n           (let [m {\\( \\) \\{ \\} \\[ \\]}]\n\t     (cond\n                ((set (keys m)) c)  (cons c a)\n                ((set (vals m)) c) (if (= c (m (first a)))\n                                       (rest a)\n\t\t\t\t       (cons c a))\n                :else       a)))\n\t   [] s)))","problem":"177","user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn balanced?\n  [s]\n  (loop [stack [] chars s]\n    (case\n      (first chars)\n      nil (empty? stack)\n      (\\( \\{ \\[) (recur (conj stack (first chars)) (rest chars))\n      \\) (if (= \\( (peek stack)) (recur (pop stack) (rest chars)) false)\n      \\] (if (= \\[ (peek stack)) (recur (pop stack) (rest chars)) false)\n      \\} (if (= \\{ (peek stack)) (recur (pop stack) (rest chars)) false)\n      (recur stack (rest chars)))))","problem":"177","user":"5201ada5e4b0b2e020a18f14"},{"problem":"177","code":"(fn [s]\n  (empty? (reduce (fn [[f & fs :as fss] c]\n                    (let [match {\\) \\(, \\] \\[, \\} \\{} ]\n                      (cond (match c) (if (= f (match c)) fs (cons :a fss))\n                            (some #(= c %) [\\( \\[ \\{]) (cons c fss)\n                            :else fss\n                            ))) \n                  [] s)))","user":"4f32a7f1e4b0d6649770a095"},{"problem":"177","code":"(fn balanced? [s]\n  (letfn\n      [(b? [stack s']\n         (if (or (empty? s') (nil? s'))\n           (empty? stack)\n           (let [[c & rem] s']\n             (cond (#{\\( \\{ \\[} c)\n                   (recur (cons c stack) rem)\n\n                   (#{\\) \\} \\]} c)\n                   (let [matching ({\\) \\(\n                                    \\} \\{\n                                    \\] \\[} c)]\n                     (and (= matching (first stack))\n                          (recur (rest stack) rem)))\n\n                   :else (recur stack rem)))))]\n    (b? '() (seq s))))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn f [x] (let [\n\tw (into [] x)\n\tz (filter (fn [k] (or (= k \\( ) (= k \\) ) (= k \\{ ) (= k \\} ) (= k \\[ ) (= k \\] )  )) w) \n\ts (apply str z)\n\tc (count s)\n\trepl (fn [x] (clojure.string/replace (clojure.string/replace (clojure.string/replace x \"()\" \"\") \"[]\" \"\") \"{}\" \"\"))\n\tr (repl s)\n\tcr (count r)\n\tct (or (.contains r \"(\" ) (.contains r \")\" ) (.contains r \"[\" ) (.contains r \"]\" ) (.contains r \"{\" ) (.contains r \"}\" ))\n\tok (if (not ct) true (if (= cr c) false (f r)))\n\t] ok) )","problem":"177","user":"5296008fe4b02ebb4ef7502a"},{"problem":"177","code":"(fn solve [s]\n  (let [p {\\( \\) \\[ \\] \\{ \\}}\n        a (set \"()[]{}\")]\n    (empty?\n     (reduce (fn [[t & b :as stack] s]\n               (cond (= (p t) s) b\n                     (a s) (conj stack s)\n                     :else stack))\n             () s))))","user":"60537cd1e4b04c8f2157d152"},{"problem":"177","code":"(fn balanced-brackets? [s]\n  (let [bm               { \\] \\[ \\) \\( \\} \\{ }\n        [balanced stack] (loop [stack []\n                                xs    (seq s)]\n                           (if xs\n                             (let [ch (first xs)]\n                               (cond\n                                 (#{ \\[ \\( \\{ } ch) (recur (conj stack ch) (next xs))\n                                 (#{ \\] \\) \\} } ch) (if (= (bm ch) (peek stack))\n                                                      (recur (pop stack) (next xs))\n                                                      [false stack])\n                                 :else (recur stack (next xs))))\n                             [true stack]))]\n    (and balanced (empty? stack))))","user":"55586905e4b0deb715856e2b"},{"problem":"177","code":"(fn [expr]\n  (let [s (seq expr)]\n    (loop [index 0 brackets '() ]\n      (if (< index (count s))\n        (let [c (nth s index)]\n          (if (contains? #{\\( \\[ \\{ } c)\n             (recur (inc index) (conj  brackets c))\n             (if (contains? #{\\) \\] \\}}  c)\n                            (if (or (and (= (first brackets) \\() (= c \\))) (and (= (first brackets) \\[) (= c \\])) (and (= (first brackets) \\{) (= c \\})))\n                              (recur (inc index) (rest brackets))\n                              false)\n                             (recur (inc index) brackets))))\n       (if (zero? (count brackets))  true  false )\n       ))))","user":"579601c8e4b0e215f87e8492"},{"problem":"177","code":"(fn [x] (let [pairs {\\( \\) \\{ \\} \\[ \\]} ]\n         (letfn [\n          \n  ( braces [input] (clojure.string/replace input #\"[^{}\\[\\]()]\" \"\"))\n          \n  ( match  [x y]   (= (pairs x) y))\n  \n  (good [cur rems] \n  \n    (cond \n          (and (empty? cur) \n               (empty? rems))   true\n     \n          (empty? rems)         false \n     \n          (contains? \n             (set (keys pairs)) \n             (first rems))      (good (conj cur (first rems)) (rest rems)) \n                                \n          (match (first cur) \n                 (first rems))  (good (rest cur) (rest rems))\n          \n          :else false\n          \n          )) ]\n     (good '() (braces x)))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":"177","code":"(fn [s]\n  (= '()\n     (reduce (fn [stack c]\n               (case c\n                 \\[ (conj stack \\])\n                 \\( (conj stack \\))\n                 \\{ (conj stack \\})\n                 (\\] \\) \\}) (if (= c (first stack)) \n                              (rest stack))\n                 stack))\n             '()\n             (seq s))))","user":"54b54d1be4b05787c3b1639c"},{"problem":"177","code":"(fn [s]\n  (let [m {(char 41) (char 40) (char 93) (char 91) (char 125) (char 123)}]\n    (loop [x s stack ()]\n      (if (empty? x) (empty? stack)\n        (if (and (or (= (first x) (char 41)) (= (first x) (char 93)) (= (first x) (char 125)))\n                 (not= (first stack) (get m (first x)))) false\n          (recur (rest x) (if (or (= (first x) (char 40)) (= (first x) (char 91)) (= (first x) (char 123)))\n                            (conj stack (first x))\n                            (if (= (first stack) (get m (first x) :empty))\n                              (pop stack)\n                              stack))))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"problem":"177","code":"(fn [str]\n          (let [bracket-to-value\n                {\"(\" 1/3, \")\" -1/3, \"{\" 1/7, \"}\" -1/7, \"[\" -1/5, \"]\" 1/5}]\n            (let [rs \n                  (reductions + (map\n                                 #(bracket-to-value %1)\n                                 (re-seq (re-pattern \"[(){}\\\\[\\\\]]\") str)))]\n              (and (zero? (last rs))\n                   (empty? (filter #(< % 0) rs))\n                   ))))","user":"5433a07be4b0b6b47310fce0"},{"code":"(fn [s] \n  (let [matches {\\] \\[, \\) \\(, \\} \\{}]\n    (loop [stack '() remaining s]\n      (if (empty? remaining)\n        (= 0 (count stack))\n        (let [[in & more] remaining]\n              (case in (\\[ \\( \\{) (recur (conj stack in) more)\n                       (\\] \\) \\}) (if (= (first stack) (matches in))\n                                    (recur (rest stack) more)\n                                    false)\n                        (recur stack more)))))))","problem":"177","user":"51a3b135e4b0e77c4ca60bf6"},{"problem":"177","code":"(fn parsX[s] ((fn parsRec[s]\n\t(let [newS ((fn removePars [s] (clojure.string/replace s #\"\\(\\)|\\[\\]|\\{\\}\" \"\")) s)]\n\t\t(if (empty? newS)\n\t\t\ttrue\n\t\t\t(if (= (count s)(count newS))\n\t\t\t\tfalse\n\t\t\t\t(parsRec newS)\n\t\t\t)\n\t\t)\n\t)\n) ((fn onlyPars[s] (clojure.string/join (filter #(contains? #{\\( \\) \\[ \\] \\{ \\}} %) (seq s)))) s)))","user":"568820e8e4b0dcc4269f4067"},{"problem":"177","code":"(fn [orig]\n    (let [\n          brackets\n          {\\{ \\},\n           \\[ \\],\n           \\( \\)}\n\n          isstart (fn [c] (not (nil? (brackets c))))\n          isend (fn [c] (not (nil? ((set (vals brackets)) c))))\n          ]\n      (loop\n          [s orig\n           stack ()]\n                                        ;(println \"running\" s stack)\n        (let [c (first s)]\n          (cond\n            (empty? s)\n            (do\n                                        ;(prn \"end\")\n              (empty? stack))\n\n            (isstart c)\n            (do\n                                        ;(println \"start\" c)\n              (recur\n               (rest s)\n               (conj stack c)))\n\n            (isend c)\n            (do\n                                        ;(println \"end\" c)\n              (let [expected (brackets (first stack))]\n                (if (= expected c)\n                  (recur (rest s) (rest stack))\n                  false))\n              )\n\n            :else\n            (do\n                                        ;(prn \"charprc\" c)\n              (recur (rest s) stack)\n              )\n            )))))","user":"5f06caa7e4b0cf489e8d7f52"},{"problem":"177","code":"(fn [code]\n  (loop [s [] [b & t] code]\n    (cond\n      (nil? b) (empty? s)\n      (some #{b} \"[({\") (recur (conj s b) t)\n      (not-any? #{b} \"])}\") (recur s t)\n      (and (seq s) (= b ({\\[ \\] \\( \\) \\{ \\}} (peek s)))) (recur (pop s) t)\n      :else false)))","user":"552a793ee4b0ffed3738f955"},{"problem":"177","code":"(fn balanced [s]\n  (let [o #{\\( \\[ \\{}\n        c {\\) \\( \\] \\[ \\} \\{}\n        cfn (fn cf [[h & t :as l] [sh & st :as stk]]\n              (cond\n                (empty? l) (empty? stk)\n                (o h) (recur t (cons h stk))\n                (c h) (if (= (c h) sh) (recur t st) false)\n                :else (recur t stk))) ]\n  (cfn (into [] s) ())))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":"177","code":"(fn [text] (let [correspond  {\\{ \\} \\( \\) \\[ \\]}\n                 open-symbols (set (keys correspond))\n                 close-symbols (set (map #(correspond (identity %)) open-symbols))]\n             (empty? (reduce (fn [result value]\n                               (cond (open-symbols value) (conj result value)\n                                     (close-symbols value) (if  (= (correspond (last result)) value)\n                                                             (pop result)\n                                                             (conj result value))\n                                     :else result))\n                             []\n                             text))))","user":"52fac708e4b047fd55836fff"},{"problem":"177","code":"(fn balancing-brackets [input]\n  (let [brackets {\\} \\{ \\] \\[ \\) \\(}]\n    (if (odd? (count (filter (fn [x] (or (some #(= x %) (keys brackets)) (some #(= x %) (vals brackets)))) input)))\n      false\n      (loop [coll (seq input)\n             acc nil]\n        (println acc)\n        (if coll\n          (let [char (first coll)]\n            (if (some #(= char %) (vals brackets))\n              (recur (next coll) (cons char acc))\n              (if (= (first acc) (brackets char))\n                (recur (next coll) (drop 1 acc))\n                (recur (next coll) acc))))\n          (empty? acc))))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":"177","code":"(fn check-balance [s]\n  (loop [[current-char & rest-chars] (seq s)\n         delimiter-stack '()]\n    (if current-char\n      (cond\n        (= \\( current-char) (recur rest-chars (cons :open-parens delimiter-stack))\n        (= \\[ current-char) (recur rest-chars (cons :open-brackets delimiter-stack))\n        (= \\{ current-char) (recur rest-chars (cons :open-braces delimiter-stack))\n        (= \\) current-char) (if (= :open-parens (first delimiter-stack))\n                              (recur rest-chars (rest delimiter-stack))\n                              false)\n        (= \\] current-char) (if (= :open-brackets (first delimiter-stack))\n                              (recur rest-chars (rest delimiter-stack))\n                              false)\n        (= \\} current-char) (if (= :open-braces (first delimiter-stack))\n                              (recur rest-chars (rest delimiter-stack))\n                              false)\n        :else (recur rest-chars delimiter-stack)\n        )\n      (if (empty? delimiter-stack) true false))))","user":"53527551e4b084c2834f4af0"},{"problem":"177","code":"(fn problem-177b [s]\n  (let [op-brack #{\\( \\[ \\{}\n        en-brack #{\\) \\] \\}}\n        pa-brack (zipmap en-brack op-brack)\n        pairs (clojure.set/intersection op-brack en-brack)\n        eat (fn [xs] (drop-while #(some #{%} pairs) xs))]\n    (loop [[x & ys] (seq s)\n           acc '()]\n      (if x\n        (let [xs (eat ys)]\n          (cond\n            (some #{x} op-brack) (recur xs (conj acc x))\n            (some #{x} en-brack) (if (= (get pa-brack x) (peek acc))\n                                   (recur xs (pop acc))\n                                   false)\n            :else                (recur xs acc)))\n        (empty? acc)))))","user":"55645592e4b0c656e3ff1802"},{"problem":"177","code":"(fn b\n  ([s] (b '() (seq s)))\n  ([os cs]\n   (let [ps {\\( \\) \\[ \\] \\{ \\}}] \n     (if-let [[c & cs] (seq cs)]\n       (case c\n         (\\( \\[ \\{) (b (conj os (ps c)) cs)\n         (\\) \\] \\}) (if (= c (peek os))\n                      (b (pop os) cs)\n                      false)\n         (recur os cs))\n       (empty? os)))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":"177","code":"(fn [s]\n    (let [pairs {\\} \\{\n                 \\] \\[\n                 \\) \\(}\n          oset (set (vals pairs))\n          cset (set (keys pairs))]\n      (loop [chars s\n             stack '()]\n        (let [char-seq (seq chars)]\n          (if-not char-seq\n            (empty? stack)\n            (let [c (first char-seq)]\n              (cond\n                (oset c) (recur (rest char-seq) (conj stack c))\n                (cset c) (if (= (first stack) (get pairs c))\n                           (recur (rest char-seq) (rest stack))\n                           false)\n                :else    (recur (rest char-seq) stack))))))))","user":"53716539e4b0fc7073fd6eb1"},{"problem":"177","code":"(fn balancing-brackets [str]\n  (let [brackets-map {\"(\" \")\"\n                      \"{\" \"}\"\n                      \"[\" \"]\"}\n        brackets (re-seq #\"\\{|\\}|\\[|\\]|\\(|\\)\" str)]\n    (cond\n      (= 0 (count brackets)) true\n      (odd? (count brackets)) false\n      :else (not (seq (reduce (fn [xs x]\n                          (if (= (get brackets-map (last xs)) x)\n                            (pop xs)\n                            (conj xs x))) [(first brackets)] (rest brackets)))))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn n177 [s]\n  (letfn [(pp [a b]\n              (contains? #{#{\"(\" \")\"} #{\"[\" \"]\"} #{\"{\" \"}\"}} (set [a b])))]\n    (loop [c (re-seq #\"[\\[\\]\\{\\}\\(\\)]\" s) a []]\n      (if (empty? c)\n        (empty? a)\n        (recur (rest c)\n               (if (pp (first c) (peek a)) (pop a) (conj a (first c))))))\n    ))","problem":"177","user":"52b43468e4b0c58976d9ad1b"},{"problem":"177","code":"#(let [m {\\( \\) \\{ \\} \\[ \\]}\n       r #{\\) \\} \\]}]\n   (loop [s %\n          c nil]\n     (if (empty? s)\n       (if (empty? c)\n         true\n         false)\n       (let [h (first s)\n             t (rest s)]\n         (cond\n          (r h) (if (not= h (m (first c)))\n                  false\n                  (recur t (rest c)))\n          (m h) (recur t (cons h c))\n          true (recur t c))))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":"177","code":"(fn balanced? [string]\n  ((fn helper [string stack]\n     (if (empty? string)\n       (empty? stack)\n       (let [[head tail] [(first string) (rest string)]]\n         (if (some #{head} [ \\( \\{ \\[ ])\n           (recur tail (conj stack head))\n           (case head\n             \\) (if (= (first stack) \\() (recur tail (rest stack)) false)\n             \\} (if (= (first stack) \\{) (recur tail (rest stack)) false)\n             \\] (if (= (first stack) \\[) (recur tail (rest stack)) false)\n             (recur tail stack)\n           )\n         )\n       )\n     )\n  ) string '())\n)","user":"4fc50bcbe4b081705acca375"},{"problem":"177","code":"(fn [s] \n  (let [open \"({[\"  closed \"]})\" lookup {\\) \\(  \\} \\{  \\] \\[}]\n    ((fn f [s stk ]\n     (let [c (first s) last-curr (first stk) ]\n      (cond (empty? s) (empty? stk)  \n          (.contains open (str c))\n            (f (rest s) (cons c stk))\n          (.contains closed (str c))\n            (if (not= last-curr (lookup c)) false (f (rest s) (rest stk))  )\n          :else (f (rest s) stk)\n      ))) s [] )))","user":"4f7b6b90e4b06e829148e1a4"},{"problem":"177","code":"(fn brackets-legal? [string]\n  (-> string\n      ((fn filter-brackets [string]\n         (re-seq #\"[\\{\\}\\[\\]\\(\\)]\" string)))\n      (concat [\"(\" \")\"])\n      (#(reduce (fn process-next\n                  ([] {:stack []})\n                  ([one-bracket] {:stack [one-bracket]})\n                  ([bracket-or-meta new-bracket]\n                   (let [meta (if (map? bracket-or-meta)\n                                bracket-or-meta\n                                {:stack [bracket-or-meta]})\n                         translation {\"(\" \")\"\n                                      \"[\" \"]\"\n                                      \"{\" \"}\"}]\n                     (if (:invalid meta)\n                       meta\n                       (cond\n                         (contains? #{\"(\" \"[\" \"{\"} new-bracket)\n                         (update-in meta [:stack] conj new-bracket)\n                         :else\n                         (if (= new-bracket (translation (last (:stack meta))))\n                           (update-in meta [:stack] (fn [x] (vec (butlast x))))\n                           (assoc meta :invalid true))))))) %))\n      (#(or (contains? % :invalid)\n            (not (empty? (:stack %)))))\n      (not)))","user":"4f35b2ace4b0e243712b1ec5"},{"problem":"177","code":"(fn [s]\n\t\t(loop [keeptrack [], index 0]\n\t\t(println keeptrack)\n\t\t(if (= index (count s))\n\t\t\t(= 0 (count keeptrack))\n\t\t\t(case (nth s index)\n\t\t\t\t\\( (recur (conj keeptrack \\() (inc index))\n\t\t\t\t\\[ (recur (conj keeptrack \\[) (inc index))\n\t\t\t\t\\{ (recur (conj keeptrack \\{) (inc index))\n\t\t\t\t\\) (if (not= \\( (last keeptrack))\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t(recur (pop keeptrack) (inc index))\n\t\t\t\t\t)\n\t\t\t\t\\] (if (not= \\[ (last keeptrack))\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t(recur (pop keeptrack) (inc index))\n\t\t\t\t\t)\n\t\t\t\t\\} (if (not= \\{ (last keeptrack))\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t(recur (pop keeptrack) (inc index))\n\t\t\t\t\t)\n\t\t\t\t(recur keeptrack (inc index))\n\t\t\t)\n\t\t)\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":"177","code":"(fn [s]\n  (let [br \"[](){}\"]\n    (empty?\n     (reduce (fn [[x & xs :as acc] c]\n               (if ((set br) c)\n                 (if ((set (partition 2 br)) [x c])\n                   xs\n                   (cons c acc))\n                 acc))\n             '()\n             s))))","user":"5db5d09be4b010eb3c36cd31"},{"code":"(fn matching-brackets? [text]\n  (let [ss (apply sorted-set \"{[(\")\n        es (apply sorted-set \"}])\")\n        ps (zipmap ss es)]\n    (loop [[c & cs] text, stack []]\n      (cond\n       (nil? c) (empty? stack)\n       (ss c) (recur cs (conj stack (ps c)))\n       (es c) (if (= c (peek stack))\n                (recur cs (pop stack)))\n       :else (recur cs stack)))))","problem":"177","user":"50e4f4e9e4b049a987753896"},{"problem":"177","code":"(fn f177 [s]\n  (let [non-brackets #\"[^{}\\[\\]\\(\\)]\"\n        cut-out (fn [s rs] (clojure.string/replace s rs \"\"))\n        iterate-to-fixed-point (fn [f x]\n                                 (loop [vals (iterate f x)]\n                                   (if (= (first vals) (second vals))\n                                     (first vals)\n                                     (recur (rest vals)))))\n        clean-string (cut-out s non-brackets)\n        replacements #(-> %\n                         (cut-out \"{}\")\n                         (cut-out \"[]\")\n                         (cut-out \"()\"))\n        final-s (iterate-to-fixed-point replacements clean-string)\n        ]\n    (= \"\" final-s)\n    )\n  )","user":"583048d9e4b051871117c007"},{"problem":"177","code":"(fn [s]\n  (let [m {\"]\" \"[\" \"}\" \"{\" \")\" \"(\"}]\n    (empty? (reduce\n              #(cond\n                (not (contains? m %2)) (cons %2 %1)\n                (= (first %1) (m %2)) (rest %1)\n                :s (cons :s %1))\n              '()\n              (re-seq #\"[(){}\\[\\]]\" s)))))","user":"554680cbe4b0a04f7929953e"},{"problem":"177","code":"(fn [s]\n  (let [t (re-seq #\"[\\[\\]\\{\\}\\(\\)]\" s)]\n    (loop [r '() t t]\n      (if (empty? t)\n        (empty? r)\n        (let [a (first t)\n              b (first r)\n              v (case a\n                  \"]\" (= \"[\" b)\n                  \"}\" (= \"{\" b)\n                  \")\" (= \"(\" b)\n                  nil)]\n          (cond\n            (nil? v)\n            (recur (conj r a) (rest t))\n            v\n            (recur (rest r) (rest t))\n            :default\n            false))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":"177","code":"(fn balanced? [coll]\n  (let [matches {\\( \\), \\[ \\], \\{ \\}}\n        opening (set (keys matches))\n        closing (set (vals matches))]\n    (loop [stack []\n           coll coll]\n      (if (seq coll)\n        (let [c (first coll)\n              r (rest coll)]\n          (cond\n            (opening c)\n              (recur (conj stack c) r)\n            (closing c)\n              (if (= (get matches (peek stack)) c)\n                (recur (pop stack) r)\n                false)\n            :else\n              (recur stack r)))\n        (empty? stack)))))","user":"52c1ede2e4b07a9af579236d"},{"problem":"177","code":"(fn [s]\n  (let [c (clojure.string/replace s #\"[^\\[\\]\\{\\}\\(\\)]\" \"\")\n        rm (fn [s] (reduce #(clojure.string/replace %1 %2 \"\") s [#\"\\[\\]\" #\"\\(\\)\" #\"\\{\\}\"]))\n        r (iterate rm c)\n        r2 (map vector r (rest r))\n        f (ffirst (drop-while #(apply not= %) r2))]\n      (= \"\" f)))","user":"54e345a1e4b024c67c0cf7db"},{"problem":"177","code":"(fn balanced? [s]\n    (let [brackets  #{\\( \\) \\[ \\] \\{ \\}},\n          pairs     #\"\\(\\)|\\[\\]|\\{\\}\"]\n      (loop [s (->> (seq s)\n                    (filter brackets)\n                    (apply str))]\n        (let [new-s (clojure.string/replace s pairs \"\")]\n          (cond\n            (empty? new-s)  true\n            (= s new-s)     false\n            :else           (recur new-s))))))","user":"4fc6305de4b0ee37620e180b"},{"problem":"177","code":"(fn [s]\n   (loop [cs (seq s)\n          q ()]\n     (or (and (empty? cs) (empty? q))\n         (and (not (empty? cs))\n              (let [[ch & ct] cs\n                    [qh & qt] q]\n                (cond\n                  (#{\\( \\[ \\{ } ch) (recur ct (cons ch q))\n                  (#{[\\( \\)] [\\[ \\]] [\\{ \\}]} [qh ch]) (recur ct qt)\n                  (#{\\) \\] \\}} ch) false\n                  :else (recur ct q))\n                )))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":"177","code":"(fn [s] (let [cs   (clojure.string/replace  s #\"[^\\{\\}\\(\\)\\[\\]]\"  \"\")]\n               (zero? (count (first  (first  (drop-while #( not (= (first %) (second %)) )  (partition 2 (drop 1 (iterate #( clojure.string/replace % #\"\\[\\]|\\(\\)|\\{\\}\"  \"\") cs))))))))))","user":"581a5fdbe4b0e114eb51a002"},{"problem":"177","code":"(fn parse [xs]\n  (letfn [(remove-brackets [as] (filter #(contains?  #{\\{ \\} \\[ \\] \\( \\)} % ) (seq as)))\n          (parse-brackets [acc bs] (cond\n                                 (empty? bs) (empty? acc)\n                                 (contains? #{\\[ \\{ \\(} (first bs)) (parse-brackets (cons (first bs) acc) (rest bs)) \n                                 (and (= (first bs) \\)) (= (first acc) \\()) (parse-brackets (rest acc) (rest bs))\n                                 (and (= (first bs) \\}) (= (first acc) \\{)) (parse-brackets (rest acc) (rest bs))\n                                 (and (= (first bs) \\]) (= (first acc) \\[)) (parse-brackets (rest acc) (rest bs))\n                                 :else false\n                                 ))]\n    (parse-brackets nil (remove-brackets xs))))","user":"54f86b8ce4b01ecee9d88828"},{"problem":"177","code":"(fn nested? [st]\n    (loop [acc [] [fst & rst] (seq st)]\n      (if fst\n        (case fst\n            (\\( \\{ \\[) (recur (conj acc fst) rst)\n            \\) (when (= \\( (peek acc)) (recur (pop acc) rst))\n            \\} (when (= \\{ (peek acc)) (recur (pop acc) rst))\n            \\] (when (= \\[ (peek acc)) (recur (pop acc) rst))\n            (recur acc rst))\n        (empty? acc))))","user":"4dfe5a93535d04ed9115e786"},{"problem":"177","code":"(fn [s] \n  (let [pairs (array-map \\) \\( \\} \\{ \\] \\[ ) \n        lefts (set (vals pairs)) \n        rights (set (keys pairs))]\n    (letfn [(parse [stack ch]\n        (cond \n          (lefts  ch) (cons ch stack)\n          (rights ch) (if (= (first stack) (pairs ch)) (rest stack))\n          :else stack ))]\n\n    (= '() (reduce parse '() (seq s))))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn balanced-brackets\n  [s]\n  (let [closing #{ \\) \\] \\}}\n        opening #{ \\( \\[ \\{}\n        brackets { \\( \\) \\[ \\] \\{ \\}}]\n    (loop [chars s, stack []]\n      (let [r (drop-while #(not (or (opening %) (closing %))) chars)\n            b (first r)]\n        (if (nil? b)\n          (empty? stack)\n          (if (opening b)\n            (recur (rest r) (conj stack b))\n            (if (= (brackets (last stack)) b)\n              (recur (rest r) (vec (drop-last stack)))\n              false)))))))","problem":"177","user":"52d95491e4b09f7907dd13a4"},{"problem":"177","code":"(fn [s]\n    (->> s\n      (filter #{\\( \\) \\{ \\} \\[ \\]})\n      (reduce (fn [stack x]\n                (let [\n                  o->c  (zipmap (vec \"([{\") (vec \")]}\"))\n                  closes (fn [x open] (= x (o->c open)))]\n                (if (closes x (first stack))\n                      (rest stack)\n                      (conj stack x)))) '())\n      (empty?)))","user":"4fc4eb1ee4b081705acca354"},{"code":"#(loop [str % stack ()]\n   (condp = (first str)\n     nil (= 0 (count stack))\n     \\( (recur (rest str) (conj stack \\())\n     \\[ (recur (rest str) (conj stack \\[))\n     \\{ (recur (rest str) (conj stack \\{))\n     \\) (if (= (first stack) \\() (recur (rest str) (pop stack)) false)\n     \\] (if (= (first stack) \\[) (recur (rest str) (pop stack)) false)\n     \\} (if (= (first stack) \\{) (recur (rest str) (pop stack)) false)\n     (recur (rest str) stack)))","problem":"177","user":"52667ecfe4b03e8d9a4a713e"},{"problem":"177","code":"(fn balanced?\n  ([expr]\n     (balanced? expr []))\n  ([expr stack]\n     (let [ls #{\\[ \\( \\{}\n           rs #{\\] \\) \\}}\n           ps {\\] \\[ \\) \\(\n               \\} \\{}\n           expr (seq expr)\n           hd (first expr)]\n       (if (and (empty? expr) (empty? stack))\n         true\n         (cond\n           (empty? expr) false\n           (ls hd) (recur (rest expr) (cons hd stack))\n           (rs hd) (if (= (first stack) (ps hd))\n                     (recur (rest expr) (rest stack))\n                     false)\n           :else (recur (rest expr) stack))))))","user":"4ef9b021535dced4c769f269"},{"code":"(fn [expr]\n  (= []\n     (reduce\n      (fn update-stack [stack char]\n        (cond\n         (false? stack) false\n         (#{\\{ \\[ \\(} char) (conj stack char)\n         (#{\\} \\] \\)} char) (if (= ({\\} \\{ \\] \\[ \\) \\(} char)\n                                   (peek stack))\n                              (pop stack)\n                              false)\n         :else stack))\n      [] expr)))","problem":"177","user":"510db6cde4b078ea71921145"},{"problem":"177","code":"(fn f\n  ([[t & b :as s] [c & r]]\n   (let [o ({\\( \\) \\[ \\] \\{ \\}} c)\n         p (#{\\) \\] \\}} c)]\n     (cond\n       (not c) (not (seq s))\n       o (f (cons o s) r)\n       p (and (= p t) (f b r))\n       1 (f s r)))))\n[]","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn bbal? [s]\n  (let [bmap (zipmap [\\[ \\] \\( \\) \\{ \\}] (range))\n        bs (filter identity (map bmap s))\n        bal? (fn bal? [ob [f & r]]\n               (cond\n                 (not f) (empty? ob)\n                 (even? f) (bal? (conj ob f) r)\n                 (empty? ob) false\n                 (= (last ob) (dec f)) (bal? (pop ob) r)\n                 :else false))]\n    (bal? [] bs)\n    ))","problem":"177","user":"5267d9bde4b03e8d9a4a7188"},{"code":"(comp empty?\n        (partial reduce (fn [acc c]\n                          (let [flips {\\} \\{\n                                       \\] \\[\n                                       \\) \\(}\n                                opens (set (vals flips))\n                                closes (set (keys flips))]\n                            (if-let [open (contains? opens c)]\n                              (conj acc c)\n                              (if-let [close (contains? closes c)]\n                                (if (= (peek acc) (get flips c))\n                                  (pop acc)\n                                  (conj acc ::fail-why-no-reduced?))\n                                acc)))) []))","problem":"177","user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn check [s]\n  (letfn [(left-bracket? [ch] (or (= ch \\{) (= ch \\[) (= ch \\()))\n          (right-bracket? [ch] (or (= ch \\}) (= ch \\]) (= ch \\))))\n          (match? [l r] (or (and (= l \\{) (= r \\}))\n                            (and (= l \\[) (= r \\]))\n                            (and (= l \\() (= r \\)))))\n          (merge-bracket [coll] (let [expend-coll (concat [nil] coll [nil])]\n                                  (map #(nth expend-coll %)\n                                       (filter #(let [fronter (nth expend-coll (- % 1))\n                                                      item (nth expend-coll %)\n                                                      later (nth expend-coll (+ % 1))]\n                                                 (not (or (match? fronter item)\n                                                          (match? item later))))\n                                               (range 1 (- (count expend-coll) 1))))))]\n    (loop [filter-s (filter #(or (left-bracket? %) (right-bracket? %)) s)]\n      (if (empty? filter-s)\n        true\n        (let [merged-seq (merge-bracket filter-s)]\n          (if (= merged-seq filter-s)\n            false\n            (recur merged-seq))))))\n  )","problem":"177","user":"52a55adee4b0c58976d9abe7"},{"problem":"177","code":"(fn foo [s]\n  (letfn\n    [(shank [s] (clojure.string/replace s #\"(\\{\\}|\\(\\)|\\[\\])\" \"\"))\n     (clean [s] (clojure.string/replace s #\"[^\\{\\}\\(\\)\\[\\]]\" \"\"))]\n    (loop [s (clean s)]\n      (let [r (shank s)]\n        (cond (= 0 (count r)) true\n              (= (count s) (count r)) false\n              :else (recur r))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":"177","code":"(fn [s]\n  (loop [t '()\n         s s]\n    (let [[c & d] s\n          [x & y] t]\n     (cond\n      (nil? c)\n       (empty? t)\n      (#{ \\{ \\( \\[ } c)\n       (recur (cons ({ \\{ \\} \\( \\) \\[ \\] } c) t)\n              d)\n      (#{ \\} \\) \\] } c)\n       (if (= x c)\n         (recur y d)\n         false)\n      :else (recur t d)))))","user":"5742ec91e4b05c31a32c0883"},{"problem":"177","code":"(fn brack [x]\n    (loop [a (filter #(or (= % \"{\") (= % \"}\") (= % \"[\") (= % \"]\") (= % \"(\") (= % \")\")) (clojure.string/split x #\"\"))\n           b []]\n      (if (and (empty? a) (empty? b))\n          true\n      (cond\n       (= (first a) \"(\") (recur (rest a) (concat b [\"(\"]))\n       (= (first a) \"{\") (recur (rest a) (concat b [\"{\"]))\n       (= (first a) \"[\") (recur (rest a) (concat b [\"[\"]))\n       (= (first a) \")\") (if (= (last b) \"(\")\n                           (recur (rest a) (butlast b))\n                           false)\n       (= (first a) \"}\") (if (= (last b) \"{\")\n                           (recur (rest a) (butlast b))\n                           false)\n       (= (first a) \"]\") (if (= (last b) \"[\")\n                           (recur (rest a) (butlast b))\n                           false)))))","user":"586b6a0ae4b01531a375e957"},{"problem":"177","code":"(fn bal\n  ([s] (bal (seq s) ()))\n  ([[h & tl] opens]\n   (let [open?  #{\\[\\{\\(}\n         close? {\\}\\{\\)\\(\\]\\[}]\n    (cond\n        (open? h)   (bal tl (cons h opens))\n        (close? h)  (if (= (first opens) (close? h))\n                       (bal tl (rest opens))\n                       false)\n        (empty? tl) (empty? opens)\n        :else       (bal tl opens)))))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"#(empty? (reduce (fn [[top & other :as stack] current]\n                   (cond \n                    (= current ((zipmap \"([{\" \")]}\") top)) other\n        \t\t\t((set \"({[)\") current) (cons current stack)\n        \t\t\t:else stack))\n                 [] \n                 %))","problem":"177","user":"52b02329e4b0c58976d9acc5"},{"problem":"177","code":"#(let [replace-brackets (fn [st] (clojure.string/replace \n                                  (clojure.string/replace st \n                                    #\"[^\\(\\)\\{\\}\\[\\]]*\" \"\") #\"(\\{\\}|\\[\\]|\\(\\))\" \"\"))]\n(nil? (some #{\\( \\) \\[ \\] \\{ \\}} (last (take (count %) (iterate replace-brackets %))))))","user":"5e13a6b7e4b099d064963001"}]