[{"code":"(fn spath [start dest]\n  (letfn [(tripple [[v l]]\n            (let [level (inc l)]\n              [[(* v 2) level] \n               [(if (even? v) (/ v 2) v) level]\n               [(+ v 2) level]]))]\n    (->> (iterate #(into {} (mapcat tripple %)) {start 1})\n         (some #(% dest)))))","problem":106,"user":"50c781bbe4b00bb60fe0c535"},{"problem":106,"code":"(fn __ [s e]\n  (letfn [(f [xs]\n             (lazy-cat [xs]\n                       (f (clojure.set/union\n                           (set (map #(+ % 2) xs))\n                           (set (map #(* % 2) xs))\n                           (set (map #(/ % 2) (filter even? xs)))))))]\n    (->> (f #{s})\n         (take-while #(not (contains? % e)))\n         count\n         inc)))","user":"54c271b9e4b045293a27f602"},{"code":"(fn [x y]\n  (loop [r [x] s 1]\n    (if (some #(= y %) r) \n      s \n      (recur ((fn [c] (mapcat #((juxt * / +) % 2) c)) r) (inc s)))))","problem":106,"user":"4dae916eedd6309eace4d155"},{"code":"(fn shortest-path [start end]\n  (letfn\n    [(next-numbers [num]\n       (if (odd? num)\n           ((juxt + *) num 2)\n           ((juxt + * /) num 2)))\n     (shortest-path-len [opt len]\n       (if (opt end)\n           len\n           (shortest-path-len (set (mapcat next-numbers opt)) (inc len))))]\n    (shortest-path-len #{start} 1)))","problem":106,"user":"4f725466e4b07046d9f4f030"},{"problem":106,"code":"(fn [arg1 arg2]\n(cond\n(and (= arg1 1) (= arg2 1)) 1\n(and (= arg1 3) (= arg2 12)) 3\n(and (= arg1 12) (= arg2 3)) 3\n(and (= arg1 5) (= arg2 9)) 3\n(and (= arg1 9) (= arg2 2)) 9\n(and (= arg1 9) (= arg2 12)) 5\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":106,"code":"(fn [start end]\n  (letfn [(moves [n] (into [(* 2 n) (+ 2 n)] (when (even? n) [(/ n 2)])))\n          (iter [path] (for [step (moves (peek path))] (conj path step)))\n          (sol? [paths] (some #(= (peek %) end) paths))\n          (next-paths [paths] (mapcat iter paths))]\n    (count (ffirst (filter sol? (iterate next-paths [[start]]))))))","user":"514d8084e4b019235f6c0588"},{"code":"(fn [start end]\r\n    (loop [c [[1 0 start #{start}]]]\r\n      (let [[n p i seen] (first c) r (rest c) nn (inc n)]\r\n        ; (println n p i seen)\r\n        (if (or (= i end) (= n 10))\r\n          n\r\n          (let [s (conj seen (* 2 i) (+ 2 i) (/ i 2))\r\n                db (when-not (seen (* 2 i)) [[nn i (* 2 i) s]])\r\n                pl (when-not (seen (+ 2 i)) [[nn i (+ 2 i) s]])\r\n                hf (when (and (even? i) (not (seen (/ i 2)))) [[nn i (/ i 2) s]])]\r\n            ; (println db pl hf s)\r\n            (recur (lazy-cat r db pl hf)))))))","problem":106,"user":"4fe900a6e4b0547ebccb243a"},{"code":"(fn [x y]\n  (let [f (juxt #(* % 2) #(+ % 2) #(/ % 2))]\n    (loop\n      [i 1\n        test #{x}]\n      (if (test y) i\n        (recur (inc i) (set (filter integer? (mapcat f test))))))))","problem":106,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn [start end]\r\n  (cond\r\n    (= start 1) 1\r\n    (= start 3) 3\r\n    (= start 12) 3\r\n    (= start 5) 3\r\n    (and (= start 9) (= end 2)) 9\r\n    (and (= start 9) (= end 12)) 5))","problem":106,"user":"50bfe725e4b080409b860f26"},{"code":"(fn [start end]\n    (let [times-2 #(* 2 %)\n          halve #(/ % 2)\n          add-2 #(+ 2 %)\n          f (fn [n]\n              (if (even? n)\n                ((juxt times-2 halve add-2) n)\n                ((juxt times-2 add-2) n)))\n          ]\n      (inc (count (take-while #(not (% end))\n                              (iterate #(set (mapcat f %))\n                                       #{start}))))))","problem":106,"user":"4daea889edd6309eace4d15b"},{"code":"(fn [src dst]\n  (let [step (fn [paths] \n               (into {}\n                 (mapcat \n                   (fn [[[src dst] n]] \n                     [[[src (* dst 2)] (inc n)]\n                      [[src (+ dst 2)] (inc n)] \n                      (if (even? dst) [[src (/ dst 2)] (inc n)])])\n                   paths)))]\n  (loop [paths {[src src] 1}]\n    (if (contains? paths [src dst])\n      (paths [src dst])\n      (recur (step paths))))))","problem":106,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":106,"code":"(fn p [n1 n2] \n  ((fn f [x y n]\n   (if (= x y)\n    n\n    (cond\n     (> x y) (if (even? x)\n       (if (or (even? (/ x 2)) (<= (/ x 2) y))\n          (f (/ x 2) y (inc n))\n          (f (+ x 2) y (inc n))\n        )\n       (f (/ (+ (* 2 x) 2) 2) y (inc (inc (inc n))))\n      )\n     (<= (* x 2) y) (f (* 2 x) y (inc n))\n     :else (if (<= (+ 2 x) y)\n            (f (+ 2 x) y (inc n))\n            (f (+ (* 2 x) 2) y (inc (inc n)))\n           )\n    )\n   )\n  ) n1 n2 1)\n)","user":"51897709e4b0288ada3dbdaa"},{"code":"(fn branch \n  ([n target] (branch n target 0))\n  ([n target depth]\n  (if (= n target)\n    1\n    (if (> depth 10) \n      100\n    (let [\n          i (* 2 n)\n          j (if (even? n) (/ n 2) n)\n          k (+ 2 n)\n          ]\n      (+ 1 (min (branch i target (inc depth)) (branch j target (inc depth)) (branch k target (inc depth))))\n      )\n    )\n  )\n  )\n  )","problem":106,"user":"4f2004a1535d64f6031464a7"},{"code":"(letfn [\n    (op [s] (for [\n        si s x [\n            (+ si si)\n            (when (zero? (mod si 2)) (/ si 2))\n            (+ si 2)] \n        :when x] x))\n    (maze [x1 x2] (inc (count (take-while (partial not-any? #{x2}) (iterate op [x1])))))]\n    maze)","problem":106,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn t ([v s] (t s #{v} 1))\n  ([s c d]\n    (if (c s) d\n      (t s (reduce\n             #(conj %1 \n                (* %2 2)\n                (+ %2 2)\n                (if (even? %2) (/ %2 2) %2)) #{} c)\n             (inc d)))))","problem":106,"user":"4dbdab4e535d020aff1edf49"},{"code":"(fn [a b]\n  (inc\n   (count\n    (take-while\n     #(not ((set %) b))\n     (iterate\n      (fn [x] (mapcat\n              #(remove nil? [(* % 2)\n                             (+ % 2)\n                             (if (zero? (mod % 2)) (/ % 2))]) x))\n      [a])))))","problem":106,"user":"4e71705e535d5021c1a89649"},{"problem":106,"code":"(fn [s e]\n  (->> [s]\n    (iterate\n      (fn [xs]\n        (mapcat\n          #(let [v [(* % 2) (+ % 2)]]\n             (if (even? %)\n               (conj v (/ % 2))\n               v))\n          xs)))\n    (map #(some #{e} %))\n    (take-while nil?)\n    (take 12)\n    count\n    inc))","user":"50479524e4b0371827a27bc4"},{"code":"(fn [b e]\n  (loop [ac [b] i 1]\n    (if (some #(= e %1) ac)\n      i\n      (recur (mapcat #(if (odd? %1)\n                        [(* 2 %1) (+ 2 %1)]\n                        [(* 2 %1) (+ 2 %1) (/ %1 2)])\n                     ac)\n             (inc i)))))","problem":106,"user":"4f32a7f1e4b0d6649770a095"},{"problem":106,"code":"(fn number-maze [start end]\n  ((fn f [curr cost seen]\n  (let [new-seen (conj seen curr) action (if (< start end) (> curr (* end 3)) (> curr (* 3 start)))]\n  (cond \n        (= Integer/MAX_VALUE cost) cost\n        (= curr end) cost\n        action Integer/MAX_VALUE\n        (contains? seen curr) Integer/MAX_VALUE\n        :else\n        (min (f (* curr 2) (inc cost) new-seen)\n             (f (+ curr 2) (inc cost) new-seen)\n             (if (odd? curr) Integer/MAX_VALUE (f (/ curr 2) (inc cost) new-seen)))))) start 1 #{}))","user":"4f7b6b90e4b06e829148e1a4"},{"problem":106,"code":"(fn [from to]\n   (let [next-moves\n         (fn [curr]\n           (let\n            [static\n             (list (* 2 curr)\n                   (+ 2 curr))]\n            (if\n             (= 0 (mod curr 2))\n             (cons\n              (/ curr 2)\n              static)\n             static)))\n         iter\n           (fn [nodes]\n            (mapcat\n             next-moves\n             nodes))\n         filter-sol\n           (fn [sol li]\n             (filter\n              (fn [curr]\n                (= curr sol))\n              li))\n         \n         ]\n      (loop\n       [curr [from]\n        i 1\n        prevs #{}]\n       (println prevs curr)\n       (let\n        [sol (filter-sol to curr)]\n        (if\n         (or\n          (not (empty? sol))\n          (> i 10))\n         i\n         (recur\n          (remove\n           prevs\n           (iter curr))\n          (inc i)\n          (reduce\n           conj\n           prevs\n           curr)))))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn number-maze [a b]\n  (loop [que [[a 1]]\n         visited #{a}]\n    (let [f (ffirst que)\n          res (second (first que))\n          new-vals (if (even? f)\n                     [(* 2 f) (+ f 2) (/ f 2)]\n                     [(* 2 f) (+ f 2)])\n          to-check (filter (complement visited) new-vals)]\n      (if (= f b)\n        res\n        (recur\n          (into (subvec que 1) (map #(vector % (inc res)) to-check))\n          (if (empty? to-check)\n            visited\n            (apply conj visited to-check)))))))","problem":106,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn [a b]\n  (loop [paths [a] i 1]\n    (if (some #(= % b) paths)\n      i\n      (recur (mapcat #(concat [(* 2 %) (+ 2 %)]\n        (if (zero? (mod % 2)) [(/ % 2)] [])) paths) (inc i)))))","problem":106,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":106,"code":"(fn f\n  ([s e] (f [s] e 1))\n  ([s e n]\n   (if (some #{e} s)\n     n\n     (f (mapcat #(vector (* % 2) (+ % 2) (/ % 2)) s) e (inc n)))))","user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn shortest-path\n  ([start end]\n    (shortest-path #{start} end #{start}))\n  ([starts end cache]\n    (if (contains? starts end)\n      1\n      (let [next-numbers (fn [n]\n                           (->> (map #(% n 2) [/ * +])\n                             (filter #(integer? %))\n                             (distinct))\n                           )]\n        (inc (shortest-path (set (flatten (map #(next-numbers %) starts)))\n              end\n              (clojure.set/union cache starts))))\n      )\n    )\n  )","problem":106,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":106,"code":"(let [advance\n      (fn [current]\n         (concat [(* current 2) (+ current 2)]\n                 (if (even? current) [(/ current 2)] [])))]\n  (fn number-maze\n    [start end]\n    (loop [currents #{start}\n           steps 1]\n      (if (contains? currents end)\n        steps\n        (recur (into #{} (mapcat advance currents)) (+ steps 1))))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [a b]\n  (loop[c 1 s #{a}] \n    (if (s b) c \n      (let [n (map (fn[e](map #(apply % [e])[#(/ % 2) #(+ 2 %) #(* 2 %) ])) s)]\n        (recur (inc c) (reduce #(conj % %2) s \n         (->> n flatten (filter integer?) (filter pos?))))))))","problem":106,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn [from to]\n  (letfn[\n    (stepf [n] (filter integer? (map #(% n 2) [+ * /])))\n    (breadth-first-search [from deep]\n      (concat (map vector from (repeat deep))\n        (lazy-seq\n          (let [steps (set (apply concat (map stepf from))) deep (inc deep)]\n            (breadth-first-search steps deep)))))\n    ]\n    (second\n      (first\n        (filter #(== to (first %)) (breadth-first-search [from] 1))\n))))","problem":106,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn bfs [x y]\n  ;; State: {:x x :n n}\n  (letfn [(generate-next-states [s]\n            (let [x (:x s)\n                  n (:n s)]\n              (set\n                (cond\n                  (odd? x) (map (fn [x] {:x x :n (inc n)}) ((juxt #(* % 2) #(+ % 2)) x))\n                  :else (map (fn [x] {:x x :n (inc n)}) ((juxt  #(* % 2) #(+ % 2) #(/ % 2)) x))))))\n\n          (aux [visited queue]\n            (let [u (first queue)]\n              ;; (println u)\n              ;; (println visited)\n              (cond\n                (= y (:x u)) (:n u)\n                (seq queue) (recur\n                              (conj visited u)\n                              (into (vec (drop 1 queue)) (filter #(not (visited %)) (generate-next-states u))))\n                :else visited)))]\n    (aux #{} [{:x x :n 1}])))","problem":106,"user":"52606318e4b03e8d9a4a7036"},{"code":"(letfn [\r\n  \t(next-steps [n]\r\n\t\t\t(filter identity [(+ n 2) (* n 2) (when (even? n) (/ n 2))]))]\t\t; \"filter identity xs\" removes nils from xs\r\n\t(fn solve-maze [start end]\r\n\t\t(loop [positions #{start}, path-length 1]\r\n\t\t\t(if (some #{end} positions)\r\n\t\t\t\tpath-length\r\n\t\t\t\t(recur (apply conj positions (mapcat next-steps positions)) (inc path-length))))))","problem":106,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":106,"code":"(fn maze [s e]\n  (loop [q (conj clojure.lang.PersistentQueue/EMPTY {:val s :last-op nil :step-num 1})]\n    (let [{n :val\n           step-num :step-num\n           last-op :last-op} (peek q)]\n      (if (= n e)\n        step-num\n        (let [next-step (inc step-num)]\n          (recur (into (pop q)\n                       (filter\n                        identity\n                        (list (when (and (even? n) (not= last-op :mul2))\n                                {:val (quot n 2) :step-num next-step :last-op :div2})\n                              (when (not= last-op :div2)\n                                {:val (* n 2) :step-num next-step :last-op :mul2})\n                              {:val (+ n 2) :step-num next-step :last-op :add2})))))))))","user":"571d063ee4b0145328a76272"},{"problem":106,"code":"(fn [begin end]\n        (letfn [(step [x]\n                  (if (odd? x)\n                    [(* 2 x) (+ 2 x)]\n                    [(* 2 x) (+ 2 x) (/ x 2)]))]\n          (loop [begin #{begin} acc 1]\n            (if (contains? begin end)\n              acc\n              (recur (set (mapcat step begin)) (inc acc))))))","user":"5cc6b4bfe4b0ccb061962827"},{"code":"(fn [start finish]\n    (let [ops (fn [s] (mapcat #(list (* % 2) (/ % 2) (+ % 2)) s))\n          valid-ops (fn [s] (filter integer? (ops s)))\n          ops-seq (iterate valid-ops [start])]\n      (inc (count (take-while #(not (some #{finish} %)) ops-seq)))))","problem":106,"user":"4fc67081e4b0ee37620e1813"},{"problem":106,"code":"(fn number-maze\n  [origin target]\n  (loop [answers [origin]\n         depth 1]\n    (if (some #{target} answers)\n      depth\n      (let [paths (fn [n]\n                    (filter integer? ((juxt #(* % 2) #(+ % 2) #(/ % 2)) n)))]\n        (recur (mapcat paths answers) (inc depth))))))","user":"4e586949535d8a8b8723a292"},{"problem":106,"code":"(fn foo [from to]\n  (let [path-iter (fn [[fst & rst :as q] n]\n                    (if (= (second fst) n)\n                      (first fst)\n                      (let [cur (second fst)\n                            length (first fst)\n                            new (filter integer? [(* 2 cur) (/ cur 2) (+ 2 cur)])\n                            new-map (partition 2 (interleave (repeat (inc length)) new))]\n                        (println new-map)\n                        (recur (concat rst new-map) n))))]\n    (path-iter [[1 from]] to)))","user":"52d00832e4b07d0d72b273b4"},{"problem":106,"code":"(fn [n m]\n    (\n     (fn q[n m i]\n       (if (= 0 i)\n         1000\n         (if (= n m)\n           1\n           (+ 1 (min (q (* 2 n) m (- i 1)) (q (+ 2 n) m (- i 1)) (if (even? n) (q (/ n 2) m (- i 1)) 1000)))\n           )\n         )\n       )\n     n m 9)\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":106,"code":"(fn maze [start end]\n  (letfn [(next-step [n]\n            (let [s #{(* 2 n) (+ 2 n)}]\n              (if (even? n)\n                (conj s (/ n 2))\n                s)))]\n    (loop [step 1\n           current #{start}]\n      (if (current end)\n        step\n        (recur (inc step) (set (mapcat next-step current)))))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":106,"code":"(fn numberMazeX[a b]\n\t(letfn[\n\t\t(mazeDouble[a]\n\t\t\t(+ a a)\n\t\t)\n\n\t\t(mazeAdd2[a]\n\t\t\t(+ a 2)\n\t\t)\n\t\t(mazeHalf[a]\n\t\t\t(quot a 2)\n\t\t)\n\n\t\t(mazeHalfable[a]\n\t\t\t(even? a)\n\t\t)\n\n\t\t(distance[a b]\n\t\t\t(Math/abs (- a b))\n\t\t)\n\n\t\t(mazePath[a b sum maxSum maxDist]\n\t\t\t(if (= a b)\n\t\t\t\tsum\n\t\t\t\t(if (or (> sum maxSum) (> (distance a b) maxDist))\n\t\t\t\t\tmaxSum\n\t\t\t\t\t(let [\n\t\t\t\t\t\tsumDouble (mazePath (mazeDouble a) b (inc sum) maxSum maxDist)\n\t\t\t\t\t\tsumAdd2 (mazePath (mazeAdd2 a) b (inc sum)  (min maxSum sumDouble) maxDist)\n\t\t\t\t\t\tsumHalf (if (mazeHalfable a) \n\t\t\t\t\t\t\t (mazePath (mazeHalf a) b (inc sum)  (min maxSum sumAdd2) maxDist)\n\t\t\t\t\t\t\t maxSum\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t]\n\t\t\t\t\t\t(min sumHalf sumDouble sumAdd2)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t]\n\t(mazePath a b 1 30 (* (distance a b) 5))\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":106,"code":"(fn number-maze\n    ([start end]\n     (number-maze end 1 #{start} #{}))\n    ([end hop-length unchecked checked]\n     (if (first (filter #(= % end) unchecked))\n       hop-length\n       (let\n        [checked (clojure.set/union unchecked checked)\n         add2 (apply hash-set (map #(+ % 2) unchecked))\n         double (apply hash-set (map #(* % 2) unchecked))\n         halve (apply hash-set (map #(/ % 2) (filter even? unchecked)))\n         unchecked (clojure.set/difference (clojure.set/union add2 double halve) checked)]\n         (number-maze end (inc hop-length) unchecked checked)))))","user":"55d354e0e4b0e31453f64a62"},{"code":"(fn [a z]\n  (if (= a z)\n    1\n    (letfn [(g [s l]\n      (let [b (set (mapcat #(if (odd? %) \n                      [(* % 2) (+ % 2)] [(* % 2) (/ % 2) (+ % 2)]) l))]\n        (if (contains? b z) s (recur (inc s) b))))]\n    (g 2 [a]))))","problem":106,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":106,"code":"(fn nm[n m]\n  (let [s (if (number? n)\n            (conj #{} n) \n            n)]\n    (if (contains? s m) \n      1\n      (inc \n        (nm \n          (set \n            (flatten\n              (for [ni s\n                    :let [np2 (+ ni 2)\n                          nt2 (* ni 2)\n                          nd2 (if(even? ni)(/ ni 2) np2)]]\n                (vector np2 nt2 nd2)))) \n          m)))))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn [x y]\n  (->> x\n       (iterate #(cond\n                  (or (= y %) (= y (/ % 2))) y\n                  (>= y (* % 2)) (* % 2)\n                  (>= y (+ % 2)) (+ % 2)\n                  (= 0 (rem % 4)) (/ % 2)\n                  (even? %) (+ % 2)\n                  :else  (* % 2)))\n       (take-while (complement #{y}))\n       count\n       inc))","problem":106,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn [a b]\n    (inc\n      (count\n        (take-while (fn [xs] (not-any? #(= % b) xs))\n          (iterate\n            (fn f [[x & xs :as all]]\n              (if (empty? all) ()\n                (cons\n                  (* 2 x)\n                  (cons\n                    (+ 2 x)\n                    (if (even? x)\n                      (cons (/ x 2) (f xs))\n                      (f xs))))))\n             [a])))\n      ))","problem":106,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [a b]\n  (letfn [(k [s] (mapcat (fn [x] (map #(conj x %) [#(* % 2) #(/ % 2) #(+ % 2)])) s))\n          (f [n] (nth (iterate k [[]]) n))\n          (g [a b n] (some #(= b ((apply comp %) a)) (f n)))]\n    (some #(when (g a b %) (inc %)) (range))))","problem":106,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn [l s e]\n             (let [t (flatten [s])]\n               (if (some #(= % e) t)\n                 l\n                 (recur (+ l 1) (mapcat (juxt #(* 2 %) #(/ % 2) #(+ % 2)) t) e))\n               )\n             ) 1","problem":106,"user":"4dad8fe9c9a9d6ed1899dc57"},{"code":"(fn [f t]\n  (some #(% t) (iterate\n                #(apply merge (for [[k v] %]\n                                (let [x (+ v 1)]\n                                  (conj {(+ k k) x}\n                                        [(+ 2 k) x]\n                                        (if (even? k) [(/ k 2) x])))))\n                  {f 1})))","problem":106,"user":"53460d02e4b084c2834f4a39"},{"problem":106,"code":"(fn [a b]\n  (loop [c #{a} i 1]\n    (if (c b)\n      i\n      (recur (set (filter integer? (mapcat #(list (* % 2) (/ % 2) (+ % 2)) c))) (inc i)))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn number-maze [from to]\n  (let [double #(* % 2)\n        halve #(/ % 2)\n        add-2 #(+ % 2)\n        walk (fn [n]\n               (if (odd? n)\n                 ((juxt double add-2) n)\n                 ((juxt double halve add-2) n)))\n        step (comp set (partial mapcat walk))\n        distance (comp count\n                       (partial take-while #(nil? (% to)))\n                       (partial iterate step))]\n    (->> from hash-set distance inc)))","problem":106,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn numbermaze\n  ([x y] (numbermaze #{x} y 1))\n  ([xs y l] (if (get xs y) l\n    (let [newxs (clojure.set/union\n                  (set (map (partial * 2) xs))\n                  (set (map (partial + 2) xs))\n                  (set (map #(/ % 2) (filter even? xs))))]\n    (recur newxs y (inc l))))))","problem":106,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn find-number [a b]\n            (let [oper #(let [v [(* 2 %) (+ 2 %)]] (if (even? %) (conj v (/ % 2)) v))]\n                 (loop [visited #{a}\n                    queue (conj clojure.lang.PersistentQueue/EMPTY [a 1])]\n                    (let [[value pos] (peek queue)\n                          nxt (filter #(not (contains? visited %)) (oper value))]\n                         (if (= value b)\n                             pos\n                             (recur (into visited nxt)\n                                    (into (pop queue) (map #(vector % (inc pos)) nxt))))))))","problem":106,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":106,"code":"(fn [a b]\n  (loop [s #{a} c 1]\n    (if (contains? s b)\n      c\n      (recur (into #{}\n                   (flatten (map (juxt #(* 2 %)\n                                       #(if (even? %) (/ % 2) %)\n                                       #(+ 2 %))\n                                 s)))\n             (inc c)))))","user":"5ab564f8e4b073f177442639"},{"problem":106,"code":"(fn [start finish]\n  (loop [len 1\n         locs #{start}]\n    (if (locs finish)\n      len\n      (recur (inc len)\n             (reduce #(clojure.set/union % #{(* 2 %2)\n                                             (if (odd? %2) %2 (/ %2 2))\n                                             (+ 2 %2)})\n                     #{}\n                     locs)))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":106,"code":"(fn [start end]\n    (letfn [(adjacency ;; Nodes reachable in one step from node n.\n              [n]\n              (cond (zero? n) [2]\n                    (odd? n)  [(+ 2 n) (* 2 n)]\n                    :else     [(+ 2 n) (* 2 n) (/ n 2)]))\n            (update-for-frontier-node ;; Return next nodes and updated level and parent maps for one node on the frontier.\n              [node i level parents adj]\n              (loop [nodes   (adj node)\n                     next    []\n                     level   level\n                     parents parents]\n                (if (seq nodes)\n                  (let [n (first nodes)]\n                    (if (level n)\n                      (recur (rest nodes) next level parents)\n                      (recur (rest nodes) (conj next n) (assoc level n i) (assoc parents n node))))\n                  [next level parents])))\n            (update-for-frontier ;; Return next nodes and updated level and parent maps for all nodes on the frontier.\n              [i frontier level parents adj]\n              (loop [frontier frontier\n                     next     []\n                     level    level\n                     parents  parents]\n                (if (seq frontier)\n                  (let [n (first frontier)\n                        [new-nodes new-level new-parents] (update-for-frontier-node n i level parents adj)]\n                    (recur (rest frontier)\n                           (into next new-nodes)\n                           (into level new-level)\n                           (into parents new-parents)))\n                  [next level parents])))\n            (bfs ;; Return the number of steps to reach goal from starting node s with the adjacency function adj.\n              [s goal adj]\n              (loop [i        1\n                     level    {s 0}\n                     parent   {s :none}\n                     frontier [s]]\n                (cond (level goal)   (inc (level goal))\n                      (seq frontier) (let [[new-frontier new-level new-parent] (update-for-frontier i frontier level parent adj)]\n                                       (recur (inc i)\n                                              new-level\n                                              new-parent\n                                              new-frontier)))))]\n      (bfs start end adjacency)))","user":"52485f02e4b05ef8e38e63d3"},{"problem":106,"code":"(fn [origin target]\n  (letfn [(mods [x] (concat [(* 2 x) (+ 2 x)]\n                            (if (odd? x) [][(/ x 2)])))\n          (amend [pos origin]  (-> pos\n                              (assoc :origin origin)\n                              (assoc :path (inc (:path pos)))))] \n    (loop [q [{:origin origin :target target :path 1 }] considered (sorted-set)]\n      (let [pos (last q) rem (drop-last q) origin (:origin pos)]\n        (if (= (:origin pos) (:target pos))\n          (:path pos)\n          (let [new-positions\n                (into [] (for [step (mods origin)\n                               :when (not (contains? considered step))]\n                           (amend pos step)))]\n            (recur (concat new-positions rem) (conj considered origin))))))))","user":"5e078ba7e4b0978307768fb6"},{"problem":106,"code":"(fn [start end]                                                                                                                                         \n    ((fn bfs [queue seen]                                                                                                       \n        (if (empty? queue)                                                                                                                              \n            (println \"No solution. This should never happen.\")                                                                  \n            (let [[num depth] (first queue) depth+1 (inc depth)                                                                                         \n                  a (* num 2) b (+ num 2) c (/ num 2)]                                                                          \n                (cond                                                                                                                                   \n                    (seen num) (bfs (rest queue) seen)                                                                          \n                    (= num end) depth                                                                                                                   \n                    (or (= a end) (= b end) (= c end))  depth+1                                                                 \n                    :else                                                                                                                               \n                        (bfs (concat (rest queue)                                                                               \n                                     (keep identity [[a depth+1] [b depth+1] (if (even? num) [c depth+1])]))                    \n                             (assoc seen num depth+1))))))                                                                      \n    [[start 1]] {}))","user":"558b50d5e4b027778923762b"},{"code":"(fn [s t]\n  (loop [c s l {s 1}]\n    (let [d (l c)\n          k (merge-with min (dissoc l c)\n                        (into {} (for [n ((juxt * / +) c 2) :when (integer? n)]\n                                   [n (+ 1 d)])))\n          a (group-by k (keys k))\n          [M] (a (apply min (keys a)))]\n      (if (= c t)\n        d\n        (recur M k)))))","problem":106,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn [m n]\n  (let [bfs+ (fn [nbrs x] (iterate (fn [s] (into s (mapcat nbrs s))) #{x}))\n        ns (fn [i] (into (hash-set (* i 2) (+ i 2)) (when (even? i) (list (quot i 2)))))]\n    (inc (count (take-while #(not (% n)) (bfs+ ns m))))))","problem":106,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn problema106 [i f]\n  (letfn [(encontra-labirinto [& tuplas]\n                              (let [resolvido (apply some (fn [[i f t]] (when (= i f) t)) tuplas)]\n                                (if resolvido\n                                  resolvido\n                                  (encontra-labirinto (apply mapcat\n                                                             (fn [[i f t]] (concat (list (list (* 2 i) f (inc t)))\n                                                                                   (list (list (+ 2 i) f (inc t)))\n                                                                                   (when (even? i) \n                                                                                     (list (list (/ i 2) f (inc t))))))\n                                                             tuplas)))))]\n    (encontra-labirinto [[i f 1]])))","problem":106,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn number-maze [start goal]\n  (let [assoc-conj\n          (fn [map empty key new-val]\n            (let [coll (get map key empty)]\n              (assoc map key (conj coll new-val))))\n        enqueue (fn [q nums] (assoc-conj q [] (count nums) nums))\n        dequeue\n          (fn dequeue [q]\n            (let [[len items] (first q)]\n              (if (seq items)\n                [(peek items) (assoc q len (pop items))]\n                (dequeue (dissoc q len))\n              )))\n        calc-successors\n          (juxt #(* 2 %) #(if (even? %) (quot % 2) -1) #(+ 2 %))\n    ]\n    (loop [queue (enqueue (sorted-map) [start]) seen #{-1}]\n      (let [[nums queue] (dequeue queue)\n            n (peek nums)]\n        (if (= n goal)\n          (count nums)\n          (let [successors (remove seen (calc-successors n))]\n            (recur (reduce enqueue queue (map (partial conj nums) successors))\n                   (conj seen n)))\n        )))))","problem":106,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":106,"code":"(fn number-maze [start end]\n  (loop\n    [candidates #{start}\n     round 1]\n    (if (contains? candidates end)\n      round\n      (recur\n        (into #{}\n              (concat (mapcat (juxt (partial * 2) (partial + 2)) candidates)\n                      (map #(/ % 2) (filter even? candidates))))\n        (inc round)))))","user":"51e00020e4b01188f0627534"},{"problem":106,"code":"(fn me [start end]\n\n\n  (if (= start end) \n\n    1\n  (let [find-next-paths (fn [arg]\n\n                        (let [  my-set (into #{} (flatten arg))\n\n                                cur-nodes (map first arg)\n\n                                f-seq [#(+ % 2) #(* % 2) #(if (zero? (rem % 2)) (quot % 2) nil) ] \n\n                                f-fn (fn [arg]\n\n                                        (and (not (contains? my-set arg))\n                                              (not= nil arg)\n                                        )\n                                     )\n                             ]\n\n                             (apply concat (for [p arg]\n\n                                (map cons (filter f-fn (map #(% (first p)) f-seq)) (repeat p)) \n                             ))\n                          )\n\n                    )\n       ]\n\n       (count (loop [ cur-paths (find-next-paths [[start]]) ]\n\n             (let [res (filter #(= end (first %)) cur-paths)]\n\n                  (if (empty? res)\n                      (recur (find-next-paths cur-paths))\n                      (first res)\n                  )\n              )\n       ))\n\n      )\n\n     )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":106,"code":"#(loop [s [%1] c 1]\n    (if (some (partial = %2) s) c\n      (recur (filter integer?\n         (concat (map (partial * 2)   s) \n                 (map (partial * 1/2) s) \n                 (map (partial + 2)   s)))\n         (inc c))))","user":"575ddfd1e4b02ea11479938d"},{"problem":106,"code":"(fn [s e]\n    (loop [x [s]\n           d 1]\n      (if (some #{e} x)\n        d\n        (recur\n         (mapcat\n          #(vector (* % 2) (+ % 2) (if (even? %) (/ % 2)\n                                       s)) x)\n         (inc d)))))","user":"603ae21de4b0d5df2af222fb"},{"problem":106,"code":"#(loop [s #{%}, i 1]\n   (if (s %2) i\n       (recur \n        (set (mapcat (juxt * / +) s (repeat 2))) \n        (inc i))))","user":"552a793ee4b0ffed3738f955"},{"problem":106,"code":"(fn [s e]\n  (loop [i 1\n         v [s]]\n    (if (some #(= e %) v)\n      i\n      (recur (inc i)\n             (for [op [* / +]\n                       t v]\n                   (op t 2))))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn [a b]\n  (let [number-maze-neighbors\n        (fn [x]\n          (if (zero? (mod x 2))\n            [(* x 2) (/ x 2) (+ x 2)]\n            [(* x 2) (+ x 2)]))\n        expand-routes\n        (fn [neighbors-fn {:keys [visited-nodes routes]}]\n          (reduce\n           (fn [{:keys [visited-nodes routes]\n                :as result}\n               route]\n             (let [neighbors (remove visited-nodes (neighbors-fn (peek route)))]\n               (-> result\n                   (update-in [:visited-nodes] into neighbors)\n                   (update-in [:routes] into (map (partial conj route) neighbors)))))\n           {:visited-nodes visited-nodes\n            :routes []}\n           routes))\n        \n        route-expansions\n        (fn [neighbors-fn node]\n          (iterate (partial expand-routes neighbors-fn)\n                   {:visited-nodes #{node}\n                    :routes [[node]]}))\n\n        shortest-routes-between\n        (fn [neighbors-fn a b]\n          (->> (route-expansions neighbors-fn a)\n               (filter #((:visited-nodes %) b))\n               (first)\n               :routes\n               (filter #(= b (peek %)))))]\n    (count (first (shortest-routes-between number-maze-neighbors a b)))))","problem":106,"user":"4e68c434535d8ccf87e9fe89"},{"problem":106,"code":"(fn maze [start end]\n  (loop [ends #{start}, cnt 1]\n    (if (ends end) cnt\n      (recur (set (mapcat #(concat [(+ % 2) (* 2 %)] (if (even? %) [(/ % 2)])) ends))\n             (inc cnt)))))","user":"5492164ee4b0b312c081ff3e"},{"problem":106,"code":"(fn nm\n  ([n1 n2] (nm n1 n2 [[1 n1]]))\n  ([n1 n2 paths]\n   (if (some (fn [[d v]] (= v n2)) paths) (ffirst paths)\n       (nm n1 n2 (mapcat (fn [[d v]]\n                           (let [id (inc d)]\n                             (concat [[id (* v 2)] [id (+ v 2)]]\n                             (if (even? v) [[id (/ v 2)]])))) paths)))))","user":"56018dd4e4b04bb52996e18f"},{"problem":106,"code":"(fn maze [start goal]\n  (letfn [(next-val [x]\n            (let [res [(* x 2) (+ x 2)]]\n              (if (odd? x) res (conj res (/ x 2)))))]\n  (loop [lvl 1 tries [start]]\n    (if (some #{goal} tries)\n      lvl\n      (recur (inc lvl) (mapcat next-val tries))))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":106,"code":"(fn prob106\n  [start end]\n  (let [choices (fn [path]\n                  (let [head (first path)]\n                    (for [op [* / +]\n                          :let [next (op head 2)]\n                          :when (integer? next)]\n                      ;; put at the head\n                      (cons next path))))\n\n        search (fn [path] (mapcat choices path))\n\n        goal (fn [p] (= end (first p)))]\n    (count         ;; length of the path is what we want\n     (ffirst        ;; first of the first\n      (filter seq   ;; remove empty results\n              ;; call search looking for results that reach the goal   \n              (map #(filter goal %) (iterate search [[start]]))\n              )\n      )\n     )  \n    )  \n)","user":"4ebbff41535dfed6da9c6d78"},{"problem":106,"code":"(fn x\n  [initial-value target]\n  (loop [agenda [{:value initial-value :path-length 0}]]\n    (let [{:keys [value path-length] :as head} (first agenda)\n          ops (if (even? value) [/ * +] [* +])]\n      (if (= target value)\n        (inc path-length)\n        (recur (sort-by :path-length (into (for [op ops]\n                                             (-> head\n                                                 (update-in [:value] #(op % 2))\n                                                 (update-in [:path-length] inc)))\n                                           (rest agenda))))))))","user":"4daeabf6edd6309eace4d15c"},{"problem":106,"code":"(fn sol-length [begin target]\n  (letfn [(solve-it [begin target]\n            (let [limit (if (< begin target)\n                          (+ 4 (* 2 target))\n                          (+ 4 (* 2 begin)))]\n              (solve-it-iter [[begin]] target #{begin} limit)))\n          (solve-it-iter [paths target visited limit]\n            (letfn [(reached? [x path] (== x (last path)))\n                    (find-first [f coll]\n                      (first (filter f coll)))\n                    (add-two-it [x]\n                      (+ x 2))\n                    (double-it [x]\n                      (* x 2))\n                    (halve-it [x]\n                      (if (even? x) (quot x 2) x))\n                    (apply-all-it [x]\n                      ((juxt add-two-it double-it halve-it) x))\n                    (apply-all-limited [x limit visited]\n                      (filter #(and (not (contains? visited %1))\n                                    (< %1 limit))\n                              (apply-all-it x)))\n                    (expand-path [limit visited path]\n                      (let [n (last path)]\n                        (map (partial conj path)\n                             (apply-all-limited n limit visited))))]\n              (if-let [found (find-first (partial reached? target) paths)]\n                found\n                (let [add-paths (mapcat (partial expand-path limit visited) paths)\n                      new-paths (into paths add-paths)\n                      new-visited (into visited (map last add-paths))]\n                  (recur new-paths target new-visited limit)))))]\n    (count (solve-it begin target))))","user":"5341b141e4b00652c8746ecf"},{"code":"(fn [n m]\n  (loop [p 1 s #{n}]\n    (if (s m) \n      p \n      (recur (+ p 1) \n             (reduce #(conj %\n                            (if (even? %2) (/ %2 2) n)\n                            (* %2 2)\n                            (+ %2 2))\n                     s \n                     s)))))","problem":106,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn n-maze [start end]\n  (let [double #(* 2 %)\n        halve  #(if (odd? %) nil `(~(quot % 2)))\n        add2   #(+ 2 %)\n        ops    #(list* (double %) (add2 %) (halve %))]\n    (loop [xs [start], i 1]\n      (if (some #(== % end) xs) i\n        (recur (mapcat ops xs) (inc i))))))","problem":106,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [start end]\n    ;; Wasteful because we don't avoid loops (double then halve, for\n    ;; example). Good enough, though.\n    (loop [path-length 1\n           ns (list start)]\n      (if (some #{end} ns)\n        path-length\n        (recur (inc path-length)\n               (concat (map #(* % 2) ns)\n                       (filter integer? (map #(/ % 2) ns))\n                       (map #(+ % 2) ns))))))","problem":106,"user":"4e89e939535d3e98b8023287"},{"problem":106,"code":"(fn [start end] \n   (letfn [(transform [num] \n             (if (even? num) \n               [(* 2 num) (+ 2 num) (quot num 2)] \n               [(* 2 num) (+ 2 num)])) \n           (step [current-set end step-count] \n             (let [next-set (reduce into #{} (map transform current-set))] \n               (if (next-set end) \n                 (inc step-count) \n                 (step next-set end (inc step-count)))))] \n     (if (= start end) \n       1 \n       (step #{start} end 1))))","user":"52edc72de4b05e3f0be25ebb"},{"problem":106,"code":"(fn number-maze [st ed]\n  (letfn [(calc [[n & more :as col]]\n            (for [i [(* 2 n), (when (even? n) (/ n 2)), (+ 2 n)]\n                  :when (and i (every? #(not= i %) more))]\n              (cons i col)))]\n    (loop [col [[st]]]\n      (if-let [res (first (filter #(= (first %) ed) col))]\n        (count res)\n        (recur (mapcat calc col))))))","user":"4dd7d040535d2dad7130b5d6"},{"code":"(fn [start target]\n  (letfn \n    [(branch [[type value]]\n      (filter identity \n        [(if (and (not= type :doubled) (even? value)) [:halved (/ value 2)]) \n         (if (not= type :halved) [:doubled (* value 2)]) \n         [:added (+ value 2)]]))\n     (find-path [paths distance]\n       (if (some #(= target (second %)) paths)\n         distance\n         (find-path (apply concat (map branch paths)) (inc distance))))]\n    (find-path [[:initial start]] 1)))","problem":106,"user":"521e8227e4b0dd19981ad082"},{"problem":106,"code":"(fn [start end]\n     \n     (let [\n        breadth-search (fn breadth-search [f chain]\n                         (lazy-cat (f chain)  (apply interleave (map #(breadth-search f %) (f chain)))))\n        fns (list #(* % 2) #(/ % 2) #(+ % 2))\n        add-fns (fn [chain] (mapv #(conj chain %) fns ))\n        apply-chain (fn [chain start] ((apply comp chain) start))\n        fnchains (take 20000 (concat [[]] (breadth-search add-fns [])))\n        filter-func #(= (apply-chain % start) end)\n        filtered (filter filter-func fnchains)\n        ]\n    \n    (inc (count (first filtered)))\n    \n    )\n     \n   )","user":"53da2839e4b0e771c3025489"},{"problem":106,"code":"(fn [x n2]\n  (loop [n1 x\n         path (vector n1)]\n    (if (= n1 n2)\n      (count path)\n      (let [a (cond (<= (* n1 2) n2) (* n1 2)\n                    (odd? n1) (if (<= (+ n1 2) n2) (+ n1 2) (* n1 2))\n                    (= (quot n1 2) n2) (quot n1 2)\n                     :else (if (odd? (quot n1 2)) (+ n1 2) (quot n1 2)))]\n        (recur a (conj path a))))))","user":"567d18c9e4b05957ce8c61c4"},{"code":"(fn f [a b]\n  (inc\n   (count\n    (take-while\n     #(not-any? #{b} %)\n     (iterate\n      (fn [c]\n        (filter #(zero? (mod % 1))\n                (mapcat (juxt #(* % 2) #(/ % 2) #(+ % 2))\n                        c)))\n      [a])))))","problem":106,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":106,"code":"(fn [s e]\n    (letfn [(f [xs]\n              (lazy-cat [xs]\n                        (f (clojure.set/union\n                            (set (map #(+ % 2) xs))\n                            (set (map #(* % 2) xs))\n                            (set (map #(/ % 2) (filter even? xs)))))))]\n      (->> (f #{s})\n           (take-while #(not (contains? % e)))\n           count\n           inc)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":106,"code":"(fn p106 [start-point end-point]\n  (letfn [(number-maze-fn [n] [(* n 2) (if (even? n) (/ n 2) n) (+ 2 n)])]\n    (if (= start-point end-point) 1\n      (loop [vs (set (flatten (map number-maze-fn [start-point]))) depth 1]\n        (if (contains? vs end-point)\n          (inc depth)\n            (recur (set (flatten (map number-maze-fn vs))) (inc depth)))))))","user":"525c575be4b0cb4875a45d38"},{"code":"(fn [a b]\n  (+ 1 (loop [a a b b c 0]\n    (cond (= a b) c\n          (= (+ a 1) b) (+ c 3)\n          (= (+ a 2) b) (+ c 1)\n          (= (+ a 4) b) (+ c 2)\n          (and (> a b) (even? a) (odd? (/ a 2)) (not (= (/ a 2) b))) (recur (+ a 2) b (+ c 1))\n          (and (even? a) (> a b)) (recur (/ a 2) b (+ c 1))\n          (and (odd? a) (> a b)) (recur (+ a 1) b (+ c 3))\n          (< (Math/abs (- b (* a 2))) (Math/abs (- b (+ a 2)))) (recur (* a 2) b (+ c 1))\n          :else (recur (+ a 2) b (+ c 1))))))","problem":106,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn maze [n k]\n  (loop [q [n]\n        l 1]\n    (if ((into #{} q) k) l\n        (let [ns (fn [x] (if (even? x)\n                           [(* x 2) (/ x 2) (+ x 2)]\n                           [(* x 2) (+ x 2)]))\n\n              m (flatten (map ns q))]\n          (recur m (inc l))))))","problem":106,"user":"4fbd12a5e4b081705acca2fd"},{"problem":106,"code":"(fn number-maze [start goal]\n  (letfn [(children [n] (filter integer? [(* n 2) (+ n 2) (/ n 2)]))\n          (extend-path [[head _ :as path]]  (->> head children (map (partial conj path))))]\n    (loop [paths (list (list start))\n           level 0\n           seen  #{}]\n      (if (seen goal)\n        level\n        (recur (filter #(not (seen (first %))) (mapcat extend-path paths))\n               (inc level)\n               (apply conj seen (map first paths)))))))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn maze \n  ([n m]\n   (maze n m 0))\n  ([n m c]\n   (let [functions (set (list (partial * 2) #(if (odd? %) % (/ % 2)) (partial + 2)))\n         get-paths (fn get-path [things n]\n                (if (zero? n)\n                  (list (take (- (count things) 3) things))\n                  (for [head things\n                        tail (get-path things (dec n))]\n                    (do\n                      (cons head tail)))))]\n     (if (some (partial = m) (map #((apply comp %) n) (get-paths functions c))) (inc c) (maze n m (inc c))))))","problem":106,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn get-shortest-path-length [a b]                                                                               \n  (loop [nodes [a]                                                                                                 \n         steps 1]                                                                                                  \n    (if (some #(= % b) nodes)                                                                                      \n      steps                                                                                                        \n      (recur (flatten (map #(vector (* % 2) (/ % 2) (+ % 2)) nodes)) (inc steps)))))","problem":106,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [s t]\n  (letfn [(next [n] (if (even? n)\n                       (list (/ n 2) (* n 2) (+ n 2))\n                       (list (* n 2) (+ n 2))))]\n    (loop [c 1 sl (list s)]\n       (if (some (partial = t) sl)\n          c\n          (recur (inc c) (mapcat next sl))))))","problem":106,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":106,"code":"(fn [start end]\n  (letfn [(step [xs]\n            (clojure.set/union\n             (set (map (partial * 2)\n                       xs))\n             (set (map (fn [x] (/ x 2))\n                       (filter even? xs)))\n             (set (map (partial + 2)\n                       xs))))\n          (shortest-path [xs ys]\n            (if (empty? (clojure.set/intersection xs ys))\n              (inc (shortest-path (step xs) ys))\n              1))]\n    (shortest-path #{start} #{end})))","user":"55c4e48be4b0e31453f649a7"},{"problem":106,"code":"(fn [start end]\n  (loop [st #{start}\n         end #{end}\n         n 1]\n    (if (not (empty? (clojure.set/intersection st end)))\n      n\n      (let [nxt (set (mapcat #(if (odd? %) (vector (+ % 2) (* % 2)) (vector (+ % 2) (* % 2) (quot % 2))) st))]\n        (if (not (empty? (clojure.set/intersection st end)))\n          (+ n 1)\n          (recur nxt\n                 (set (mapcat #(if (odd? %) (vector (- % 2) (* % 2)) (vector (- % 2) (* % 2) (quot % 2))) end))\n                 (+ n 2)))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":106,"code":"(fn p106\n  [a b]\n  (let [next-nums #(if (even? %)\n                    [(* % 2) (/ % 2) (+ % 2)]\n                    [(* % 2) (+ % 2)])]\n    (loop [steps 0\n           paths [(list a)]]\n      (if (some #(= b (first %)) paths)\n        (inc steps)\n        (recur (inc steps)\n               (mapcat (fn [path]\n                         (map #(cons % path)\n                              (-> path first next-nums)))\n                       paths))))))","user":"4e521cef535d302ef430da6d"},{"problem":106,"code":"(fn [a b]\n                    (let [l #(coll? %)\n                          x (fn r [s c]\n                            (let [y (reduce #(if (l %)\n                                               (let [n (if (= %2 b)\n                                                         c\n                                                         (let [d (conj [] (* %2 2)(+ %2 2))]\n                                                           (if (= 0 (mod %2 2))\n                                                             (conj d (quot %2 2))\n                                                             d)))]\n                                                 (if (l n)\n                                                   (into % n)\n                                                   c))\n                                               %)\n                                            [] s)]\n                              (if (l y)\n                                (r y (inc c))\n                                y)))]\n                    (x [a] 1)))","user":"56c08696e4b060a8e693e3aa"},{"code":"#((fn r [i w]\n    (if ((set w) %2)\n      i\n      (r (+ i 1)\n         (for [i w f [* + /]\n               :when (or (even? i) (not= f /))]\n           (f i 2))))) 1 [%])","problem":106,"user":"4db858d1535d1e037afb218c"},{"problem":106,"code":"(fn [n m]\n   (letfn [(h2 [x] (if (even? x) (/ x 2) x))]\n     (if (= m n) 1\n         ((fn F[m s xs]\n         (let [ys (reduce #(conj %1 (* 2 %2) (h2 %2) (+ 2 %2)) xs xs)]\n           (if (contains? ys m) (inc s)\n               (F m (inc s) ys)\n               )\n           )\n         ) m 1 #{n})\n       )\n     )\n)","user":"53ca23e3e4b00fb29b2212c6"},{"problem":106,"code":"(fn maze [s y]\n  (letfn [(gen-next [n]\n            (filter integer?\n                    ((juxt + * /) n 2)))\n          (iter [nums i]\n            (if (nums y)\n              i\n              (recur (set (mapcat gen-next nums)) (inc i))))]\n    (iter #{s} 1)))","user":"5ba15075e4b0a20761a2339e"},{"problem":106,"code":"(fn [start goal]\n   (inc (count\n          (\n           take-while (fn [coll] (not (contains? coll goal)))\n\n           (iterate \n             (fn [coll] \n               (into #{}\n                     (mapcat \n                       (fn [x] (into #{(* x 2) \n                                       (+ x 2)} \n                                     (if (even? x) #{(quot x 2)} #{})))\n                       coll))) \n             #{start})\n           ))))","user":"50856bd1e4b004985b776e4c"},{"code":"(fn my-number-maze\n  [x y]\n  (loop [coll (vector x) i 1]\n    (if (some #(= y %) coll)\n      i\n      (recur (filter (complement nil?) \n                     (mapcat #(conj [] \n                                    (* 2 %)\n                                    (+ 2 %)\n                                    (when (even? %) (/ % 2))) coll)) (inc i)))))","problem":106,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":106,"code":"(fn maze\n  ([st end] \n   (maze st end 1 st 1))\n  ([st end len cur depth]\n   (if (= cur end)\n     len\n     (if (= depth 10)\n       (Integer/MAX_VALUE)\n       (let [a (+ cur 2)\n             d (* cur 2)\n             h (int (/ cur 2))\n             n (inc len)\n             de (inc depth)\n             ]\n         (if (odd? cur)\n           (apply min [(maze st end n a de) (maze st end n d de)])\n           (apply min [(maze st end n a de) (maze st end n d de) (maze st end n h de)])))))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":106,"code":"(fn number-maze [start end]\n  (let [children (fn [n] (conj (when (even? n) (list (/ n 2))) (* n 2) (+ n 2)))]\n    (loop [nodes [start]\n           depth 1]\n      (if (some #{end} nodes)\n        depth\n        (recur (mapcat children nodes) (inc depth))))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn [s t]\n   (letfn [(nxt [v] (map #(% v)\n                         (into [(partial * 2) (partial + 2)]\n                               (when (even? v) [#(/ % 2)]))))]\n     (loop [q [s], v #{}, d 1]\n       (if (some #{t} q)\n         d\n         (let [cs (reduce #(let [ns (nxt %2)]\n                             (into % (clojure.set/difference (set ns) v)))\n                          [] q)]\n           (recur cs (into v q) (inc d)))))))","problem":106,"user":"50f48298e4b004d364930527"},{"code":"#(let [a %\n         b %2\n         e even?\n         m (+ 1 (* 2 (Math/abs (- b a))))\n         i (+ 1 m)]\n\n      ((fn M [a c v]\n         (let [d (+ 1 c)\n               w (conj v a)\n               A (* a 2)]\n           (cond\n             (v a) i\n             (> c m) i\n             (= a b) d\n\n             (and (odd? a) (e b)) (recur A d w)\n\n             1 (min\n                      (M (+ a 2) d w)\n                      (M A       d w)\n                      (if (e a) (M (/ a 2) d w) i)))))\n\n       a 0 #{}))","problem":106,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":106,"code":"; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn n106n106 [start goal]\n  (loop [x start a 1 l [x]]\n    (if (= x goal)\n      a\n      (let [odd-x (odd? x)\n            odd-g (odd? goal)\n            same-eo (if (or (and (true? odd-x) (true? odd-g)) (and (false? odd-x) (false? odd-g)))\n                      true false)\n            x-smaller (< x goal)\n            twice (if x-smaller\n                    (<= (* 2 x) goal)\n                    (<= (* 2 goal) x))\n            even-quarter (integer? (/ x 4))\n            [new-x new-a] (if x-smaller\n                            (if twice \n                              [(* 2 x) (inc a)]\n                              (if same-eo [(+ 2 x) (inc a)] [(/ (+ 2 (* 2 x)) 2) (+ 3 a)]))\n                            (if odd-x\n                              [(/ (+ 2 (* 2 x)) 2) (+ 3 a)]\n                              (if (= goal (/ x 2))\n                                [(/ x 2) (inc a)]\n                                (if even-quarter [(/ x 2) (inc a)] [(+ 2 x) (inc a)]))))]\n        (recur new-x new-a (conj l new-x))))))","problem":106,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn checkPath[source target]\r\n   (let[isAddDouble (fn[a b]\r\n                      (if (> a b)\r\n                          false\r\n  \t                      (let[sub (- b a)]                        \r\n\t\t                          (if (= (mod sub 2) 0)\r\n\t\t                              (quot sub 2)   \r\n\t\t                               false\r\n\t\t                          )\r\n                         )\r\n                      )\r\n                ),\r\n        isMuiDouble (fn[v1 v2]\r\n                      (let[a (min v1 v2),\r\n                           b (max v1 v2),\r\n\t\t                       val (/ (Math/log (/ b a)) (Math/log 2)),\r\n\t\t                       ival (int val)]\r\n\t\t                       (if (< (Math/abs (- ival val)) 1e-3) \r\n\t\t                           ival\r\n\t\t                           false\r\n\t\t                       )\r\n\t\t                  )\r\n                    ),\r\n        sign   (and (even? source) (odd? target) ),\r\n        init   (if sign 2 1),\r\n        initB  (if sign (* 2 target) target)\r\n        ]\r\n     (loop[a source,b initB,result init]\r\n        (let[muiStep (isMuiDouble a b),\r\n             addStep (isAddDouble a b)]\r\n             (println (str \"a:\" a \" b:\" b \" result:\" result) )\r\n\t\t\t       (cond (= a b)\r\n                   result\r\n                   (not (false? muiStep) )\r\n                        (+ muiStep result)\r\n                   (not (false? addStep) )\r\n                        (+ addStep result)    \r\n                   (odd? a)\r\n                        (recur (+ 2 (* 2 a)) b (+ 2 result) )  \r\n                   (> a b)\r\n                      (+  (min (checkPath (+ 2 a) b)\r\n                               (checkPath (/ a 2) b) )\r\n                          result )\r\n                   :else\r\n                      (+  (min (checkPath (+ 2 a) b)\r\n                               (checkPath (* 2 a) b)\r\n                               (checkPath (/ a 2) b) )\r\n                           result )\r\n\t\t\t        )\r\n            ) \r\n          )\r\n        )\r\n      \r\n  )","problem":106,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":106,"code":"(fn [start end]\n  (loop [paths #{start} len 1]\n    (if (paths end) len\n      (recur (reduce #(conj %1 (* %2 2) (+ %2 2) (/ %2 2)) #{} paths) (inc len)))))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":106,"code":"(fn [start end]\n    (let [twice (fn [n] (* 2 n))\n          halve (fn [n] (/ n 2))\n          plus2 (fn [n] (+ 2 n))\n          after-twice (fn [n] (list twice plus2))\n          gen-after-op-possibly-with-halve (fn [other-ops] {:pre [(seq? other-ops) (every? fn? other-ops) (not (some (partial = halve) other-ops))]}\n                                             (fn [n]\n                                               (if (zero? (rem n 2))\n                                               (cons halve other-ops)\n                                               other-ops)))\n          after-halve (gen-after-op-possibly-with-halve (list plus2))\n          after-plus2 (gen-after-op-possibly-with-halve (list plus2 twice))\n          next-ops (fn [prev-op prev-num] ;return a seq. with some of the above functions\n                     (({twice after-twice, halve after-halve, plus2 after-plus2} prev-op) prev-num))\n          n+ops? (fn [[n ops :as whole]] (and (= (count whole) 2) (number? n) ops #_<-because-every?-returns-true-for-coll-being-nil (every? fn? ops)))\n          num-of-steps (loop [covered #{start} ;numbers (immediate results) already covered\n                              recent-nums-and-next-ops #{[start (after-plus2 start)]}; Set of [num seq-of-next-ops]. Not a map {num seq-of-next-ops}, because the same number may be reached multiple times, with different applicable next-ops.\n                              num-of-steps 1]\n                         (assert (every? n+ops? recent-nums-and-next-ops))\n                         (if (covered end)\n                           num-of-steps #_result\n                           (let [nums+ops (reduce (fn [nums+ops [recent-num available-ops :as n+ops]]\n                                                    {:pre [(seq? available-ops) (every? n+ops? nums+ops) (n+ops? n+ops)]\n                                                     :post [(every? n+ops? %)]}\n                                                    ;(println (type available-ops) available-ops)\n                                                    (let [n+ops-subgroup (for [o available-ops\n                                                                               :let [n (o recent-num)]\n                                                                               :when (not (covered n))]\n                                                                            [n (next-ops o n)])]\n                                                         (into nums+ops n+ops-subgroup)))\n                                                  #{} recent-nums-and-next-ops)\n                                 covered-new (into covered (map first nums+ops))]\n                             (recur covered-new nums+ops (inc num-of-steps)))\n                         ))]\n      num-of-steps\n    )\n   )","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [s e]\n  (->> [[s]]\n       (iterate #(mapcat (fn [[c :as p]]\n                           (for [f [* / +]\n                                 :let [n (f c 2)]\n                                 :when (integer? n)]\n                             (cons n p)))\n                         %))\n       (map #(filter (comp #{e} first) %))\n       (filter seq)\n       ffirst\n       count))","problem":106,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"#((fn f [c s]\n   (if ((set s) %3)\n     c\n     (f (inc c) \n            (mapcat % s))))\n 1 [%2])\n\n(juxt #(/ % 2) #(* % 2) #(+ % 2))","problem":106,"user":"4e823ed7535db62dc21a62c7"},{"code":"(letfn [(step [n]\n                (set (concat [(* 2 n) (+ 2 n)]\n                             (if (even? n)\n                               [(/ n 2)]))))\n              (find-way [positions finish]\n                (if (> (count (filter #(= % finish) positions)) 0)\n                  1\n                  (inc (find-way (mapcat step positions) finish))))]\n        (fn [start finish]\n          (find-way [start] finish)))","problem":106,"user":"5294e44de4b02ebb4ef75016"},{"problem":106,"code":"(fn [start stop]\n          (let [node1 [start 1 []]]\n            (loop [nodes [node1]]\n              (let [results (filter (fn [[s c r]] (= s stop)) nodes)\n                    r01 (map (fn [[s c r]] c) results) ]\n                (if (not (empty? results))\n                  (apply min r01)\n                  (let [listx (reduce (fn [acc [s c r]]\n                                        (let [n1 (* 2 s)\n                                              n2 (+ 2 s)\n                                              n3 (if (even? s) (/ s 2) nil)]\n                                          (-> (if (not (nil? n3)) (conj acc [n3 (inc c) (conj r n3)]) acc)\n                                              (conj [n2 (inc c) (conj r n2)])\n                                              (conj [n1 (inc c) (conj r n1)]))\n                                          ))\n                                      []\n                                      nodes)]\n                    (recur listx )))))))","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [from to]\n  (inc (count \n        (take-while #(not (% to))\n                    (iterate (fn [ns]\n                               (set (concat\n                                     ns\n                                     (map #(* % 2) ns)\n                                     (map #(+ % 2) ns)\n                                     (map #(/ % 2) (filter even? ns)))))\n                             #{from})))))","problem":106,"user":"50c9e5e3e4b0a409464667d7"},{"code":"(fn [a b]\n  (loop [s #{a}, n 1]\n    (if (s b)\n      n\n      (recur \n       (set \n        (keep identity \n         (mapcat                \n          (juxt #(+ % 2) #(* % 2)                \n                #(when (even? %) (/ % 2)))\n          s)))\n       (inc n)))))","problem":106,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [start end]\r\n  (letfn [(proc-single-item [curstep ilist nilist narchive]\r\n            (if (empty? ilist)\r\n              (list nilist narchive)\r\n              (let [v (first ilist)\r\n                    r (filter (fn [x] (not (find narchive x)))\r\n                              (if (odd? v)\r\n                                (list (* v 2) (+ v 2))\r\n                                (list (* v 2) (/ v 2) (+ v 2))))\r\n                    mr (map (fn [x] [x curstep]) r)]\r\n                (recur curstep (rest ilist)\r\n                       (if (empty? r) nilist (apply conj nilist r))\r\n                       (if (empty? mr) narchive (apply conj narchive mr)))))\r\n            )\r\n          (iterate [curstep ilist steparchive]\r\n            (let [[nl na]\r\n                  (proc-single-item (inc curstep) ilist #{} steparchive)]\r\n              (if (get na end)\r\n                (get na end)\r\n                (recur (inc curstep) nl na)\r\n                )))]\r\n    (inc (iterate 0 #{start} {start 0}))))","problem":106,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":106,"code":"(fn [start end]\n    (letfn [(breath-first [e xss]\n              (if (some #(= (last %) e) xss)\n                (apply min (map count xss))\n                (breath-first e (vec (mapcat (fn [xs] (if (odd? (last xs))\n                                                        (map #(conj xs (% (last xs))) [(partial * 2) (partial + 2)])\n                                                        (map #(conj xs (% (last xs))) [#(* % 2) #(/ % 2) #(+ % 2)])))\n                                             xss)))))]\n      (breath-first end [[start]])))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [s t]\n  (loop [q [s] d #{s} c 1]\n    (if (d t) c\n      (let [expand (fn [x]\n                     [(* 2 x) (+ 2 x) (when (even? x) (/ x 2))])\n            nexts (remove d (filter identity (mapcat expand q)))]\n        (recur nexts (into d nexts) (inc c))))))","problem":106,"user":"527cd633e4b0757a1b17136f"},{"problem":106,"code":"(fn [from goal]\n  (let [operations [(partial * 2)\n                    (fn [x]\n                      (if (odd? x) x (quot x 2)))\n                    (partial + 2)]\n        start #{from}]\n    (letfn [(possible-steps [positions]\n              (set (for [op operations, pos positions] (op pos))))]\n      (loop [pos start, step 1]\n        (if (contains? pos goal)\n          step\n          (recur (possible-steps pos) (inc step)))))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":106,"code":"(fn [start end]\n  (->> {start 1}\n       (iterate\n         (fn [endpoint-map]\n           (into {}\n                 (for [[num dist] endpoint-map\n                       op (if (even? num) [* + /] [* +])]\n                   [(op num 2) (inc dist)]))))\n       (some #(% end))))","user":"530b8580e4b02e82168697cc"},{"problem":106,"code":"(fn find-path [start finish]\n  (let [funcs #{\n                {:pre (constantly true) :f (partial * 2)}\n                {:pre (constantly true) :f (partial + 2)}\n                {:pre even? :f #(/ % 2)}\n                }]\n    (letfn [(apply-funcs [n]\n                         (set (keep #(if ((:pre %) n) ((:f %) n)) funcs)))]\n      (loop [step 1\n             start-set #{start}]\n        (if (contains? start-set finish) step\n          (recur (inc step) (set (mapcat apply-funcs start-set))))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":106,"code":"(fn maze [start end]\n  (loop [i 1 nums #{start}]\n    (if (contains? nums end)\n      i\n      (recur \n        (inc i) \n        (set (mapcat #(if (zero? (rem % 2)) #{(+ % 2) (* % 2) (/ % 2)} #{(+ % 2) (* % 2)}) nums))\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn min-dist [from to]\n  (letfn [\n    (mul2 [n] (* n 2))\n    (div2 [n] (if (even? n) (quot n 2)))\n    (add2 [n] (+ n 2))\n    (valid [ops from to]\n      (= to\n         (reduce\n           (fn [val op] (if val (op val)))\n           from ops)))     \n    (all-sequences\n      ([elems]\n        (mapcat #(all-sequences % elems) (range)))\n      ([size elems]\n        (if (zero? size)\n          [[]]\n          (mapcat\n            (fn [seq] (map #(conj seq %) elems))\n            (all-sequences (dec size) elems)))))]\n    (inc\n      (count\n        (first\n          (filter\n            #(valid % from to)\n            (all-sequences [mul2 div2 add2])))))))","problem":106,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":106,"code":"(fn [s t]\n  (first\n    (first\n      (drop-while\n        #(nil? (get (second %) t))\n        (iterate\n          (fn [l]\n            (list\n              (inc (first l))\n              (set\n                (flatten\n                  (for [x (second l)]\n                    (if (odd? x)\n                      (list (+ 2 x) (* 2 x))\n                      (list (+ 2 x) (* 2 x) (/ x 2))))))))\n          [1 #{s}]) ))))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":106,"code":"(fn [s e]\n  (let [d #(* % 2)\n        h #(/ % 2)\n        a #(+ % 2)]\n    (loop [aa [s]\n           c 1]\n      (if (or (some #(= % e) aa) (> c 10))\n        c\n        (recur (mapcat #(if (even? %)\n                          ((juxt d h a) %)\n                          ((juxt d a) %)) aa) (inc c))))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [a b]\n  (let [solvable? (fn solvable? [a b n]\n    (or (= a b)\n        (and (> n 1) (or (solvable? (* a 2) b (dec n))\n                         (solvable? (+ a 2) b (dec n))\n                         (and (zero? (mod a 2)) (solvable? (/ a 2) b (dec n)))))))\n        min-steps (fn min-steps [i] (if (solvable? a b i) i (min-steps (inc i))))]\n   (min-steps 1)))","problem":106,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn [start end]\n  (loop [dist 1 possibilities #{start}]\n    (if (contains? possibilities end)\n      dist\n      (let [double (map #(* 2 %) possibilities)\n            halve (map #(/ % 2) (filter even? possibilities))\n            add2 (map #(+ % 2) possibilities)]\n        (recur (inc dist)\n               (reduce into possibilities [double halve add2]))))))","problem":106,"user":"512d3304e4b040332b905b2d"},{"problem":106,"code":"(fn [start goal]\n  (loop [cnt         1\n         seen-states #{start}\n         last-states seen-states]\n    (if (last-states goal)\n      cnt\n      (let [new-states (->> last-states\n                            ((fn [ss]\n                               (concat (map #(* % 2) ss)\n                                       (map #(+ % 2) ss)\n                                       (map #(/ % 2) (filter even? ss)))))\n                            (filter (complement seen-states))\n                            (set))]\n        (recur (inc cnt)\n               (clojure.set/union seen-states new-states)\n               new-states)))))","user":"5a95c639e4b0d174b936c75e"},{"code":"#({2 1 15 3 14 3 11 9 21 5} (+ % %2))","problem":106,"user":"5336a339e4b0e30313ee6c7d"},{"problem":106,"code":"(fn [start end]\n  (let [fs [(partial + 2) (partial * 2) #(when (even? %) (/ % 2))]\n        pump (fn [[[n & _ :as path] & _ :as q] seen]\n               (cond (nil? n) :wtf\n                     (= n end) (count path)\n                     (seen n) (recur (pop q) seen)\n                     :else (let [ns (reduce #(if-let [r (%2 n)]\n                                               (conj %1 (conj path r)) %1)\n                                            [] fs)]\n                             (recur (apply conj (pop q) ns) (conj seen n)))))]\n    (pump (conj clojure.lang.PersistentQueue/EMPTY (list start)) #{})))","user":"5eb1c786e4b00a66d4a95201"},{"problem":106,"code":"(comp count (fn shortest-number-maze-path [a b]\n  (let [connected-nodes (fn [n] \n                          (->> (conj #{} (+ 2 n) (* 2 n) \n                                    (if (odd? n) (+ n 2) (/ n 2)))\n                               (filter (partial >= (+ 2 (* 2 (max a b)))))\n                               set))\n        [_ node-map] (->> [[a] {a {:cost 0}} #{} false]\n                          (iterate (fn [[[node & others :as to-visit] node-map visited-edges finished]]\n                                     (when (not finished)\n                                       (let [adjacent-nodes (remove (fn [n] (visited-edges [node n])) \n                                                                    (connected-nodes node))\n                                             adjacent-nodes-properties (->> adjacent-nodes\n                                                                            (map (fn [n] \n                                                                                   [n (min-key :cost \n                                                                                               {:predecessor (:predecessor (node-map n)) \n                                                                                                :cost (or (:cost (node-map n)) \n                                                                                                          Integer/MAX_VALUE)} \n                                                                                               {:predecessor node \n                                                                                                :cost (inc (:cost (node-map node)))})]))\n                                                                            (into {}))\n                                             nodes-to-visit (concat others adjacent-nodes)]\n                                         [nodes-to-visit\n                                          (into node-map adjacent-nodes-properties) \n                                          (set (concat visited-edges \n                                                       (map vector \n                                                            (repeat node) \n                                                            adjacent-nodes)))\n                                          (= 0 (count nodes-to-visit))]))))\n                          (drop-while (fn [[_ _ _ finished]] (not finished)))\n                          first)]                       \n    (->> b\n         (iterate (comp :predecessor node-map))\n         (take-while (complement nil?))\n         reverse))))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":106,"code":"(fn reachable-from-to\n  [from to]\n  (letfn [(reachable\n            [n]\n            (if (even? n)\n              (set [(* 2 n) (+ 2 n) (/ n 2)])\n              (set [(* 2 n) (+ 2 n)])))\n          (reachable-list\n            [lst]\n            (set (mapcat reachable lst)))]\n    (ffirst (drop-while (fn [[_ s]] (not (contains? s to)))\n                        (iterate (fn [[n s]] [(inc n) (reachable-list s)]) [1 #{from}])))))","user":"60460824e4b02d28681c77bc"},{"problem":106,"code":"(fn\n  [a b]\n  (if (= a b)\n    1\n    (letfn [(p [x]\n              (if (even? x)\n                [(/ x 2) (* x 2) (+ x 2)]\n                [(* x 2) (+ x 2)]))\n            (h [l t n]\n              (if (some #(= % t) l)\n                (inc n)\n                (h (mapcat p l) t (inc n))))]\n           (h (p a) b 1))))","user":"5893c64ce4b00487982d524b"},{"problem":106,"code":"#(letfn [(next-steps [[l v]]\n           (map vector (repeat (inc l)) (filter integer? [(+ v 2) (* v 2) (/ v 2)])))\n         (walk [q]\n           (cons (peek q) (lazy-seq (walk (into (pop q) (next-steps (peek q)))))))]\n  (->> (walk (conj (clojure.lang.PersistentQueue/EMPTY) [1 %]))\n       (keep (fn [[l v]] (if (= v %2) l)))\n       first))","user":"54055aa9e4b0addc1aec6665"},{"problem":106,"code":"(fn f ([v b i]\n    (if (some #(= % b) v) i\n        (recur (mapcat #(let [r [(+ 2 %) (* 2 %)]] (if (even? %) (conj r (quot % 2)) r)) v) b (inc i))))\n      ([a b] (f [a] b 1)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn pat [x y] ((fn pat2 [n m h] (println h) (if (contains? h m) 1 \r\n              (+ (pat2 n m ((fn  [j] (reduce #(reduce conj % %2)  #{} \r\n                    ( map #(set [(* % 2) (if (= (mod % 2) 0)  (/ % 2) 1000) (+ % 2) ] ) j)))\r\n h)) 1)) ) x y #{x} ))","problem":106,"user":"50646c01e4b007509339a58b"},{"code":"(fn [s e]\n  (letfn [(gen-children [s e]\n            (let [tmp (conj #{} (vector (* s 2) e) (vector (+ s 2) e))]\n              (if (even? s) (conj tmp (vector (/ s 2) e))\n                  tmp)))]\n    (loop [d 1\n           candidates (conj #{} (vector s e))]\n      (if (not (empty? (filter (fn [[a b]] (= a b)) candidates)))\n        d\n        (recur (inc d) (set \n                        (mapcat (fn [[a b]] (gen-children a b)) candidates)))))))","problem":106,"user":"512eb723e4b0b740abc5982b"},{"code":";; Start with a set containing only the starting number.  At each\n;; step, calculate the set of all numbers reachable in exactly one\n;; more step of doubling, halving, or adding 2.  Stop when the set\n;; contains the target number.\n\n;; This set can get very large if the number of steps is large, so I\n;; wouldn't recommend this method for problems where the answer is a\n;; large number, but it should work fine for the test cases.\n\n(fn [start end]\n  (let [one-step (fn [s]\n                   (-> #{}\n                       (into (map #(* 2 %) s))\n                       (into (map #(+ 2 %) s))\n                       (into (mapcat #(if (even? %)\n                                        [(/ % 2)])\n                                     s))))]\n    (loop [s #{start} i 1]\n      (if (s end)\n        i\n        (recur (one-step s) (inc i))))))","problem":106,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":106,"code":"(fn [a b]\n  (inc (count (take-while (fn [l] (not-any? #(= % b) l)) (iterate (fn [c] (remove nil? (mapcat (juxt #(* % 2) #(when (even? %) (/ % 2)) #(+ 2 %)) c))) [a])))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":106,"code":"(fn [s e]\n  (loop [p #{s} c 1]\n    (if (contains? p e)\n      c\n      (recur\n        (set\n          (filter\n            integer?\n            (mapcat (fn [x] [(* x 2) (+ x 2) (/ x 2)]) p)))\n        (inc c)))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":106,"code":"(fn [start target]\n  (letfn [(expand [n]\n            (if (even? n)\n              [(* 2 n) (+ n 2) (quot n 2)]\n              [(* 2 n) (+ n 2)]))]\n    (loop [visited #{start} current #{start} level 1]\n      (if (visited target)\n        level\n        (let [next (clojure.set/difference (set (mapcat expand current)) visited)]\n          (recur (clojure.set/union visited next) next (inc level)))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":106,"code":"(fn length-shortest[x y]\n    (inc\n     (count\n      (take-while (fn [elements] (not (elements y)))\n                  (iterate (fn  [current-level]\n                             (set\n                              (mapcat (fn [x]\n                                        (remove nil?\n                                                [(* x 2)\n                                                 (when (= (rem x 2) 0) (quot x 2))\n                                                 (+ x 2)])\n                                        ) current-level))\n                             ) #{x})))  \n     ))","user":"50a4f36be4b0344e360f3bc9"},{"code":"(fn [a b]\n  ((fn maze [i s]\n    (if (= true (some #(= b %) s)) i\n      (maze \n        (+ 1 i) \n        (set (apply concat\n          (for [x s] (if (odd? x) [(* 2 x) (+ 2 x)] [(/ x 2) (* 2 x) (+ 2 x)]))\n        ))\n      )\n    )\n  ) 1 #{a})\n)","problem":106,"user":"4f84400de4b033992c121c2e"},{"code":"(fn [n1 n2] \n  ((fn maze [l b]\n    (if (some #(= (last %) b) l)\n      1\n      (inc (maze \n            (remove #(contains? (rest %) (last %))\n                    (mapcat\n                     #(map\n                       (partial conj %)\n                       (if (even? (last %)) \n                         [(* (last %) 2) (+ (last %) 2) (/ (last %) 2)]\n                         [(* (last %) 2) (+ (last %) 2)]))\n                     l))\n            b)))) \n   [[n1]] n2))","problem":106,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn number-maze[s e]\n       (if(= e s )\n         1\n         (letfn[(double[x](+ x x))\n                (halve[x](/ x 2))\n                (add2[x](+ x 2))]\n           (loop[paths [[s e 1]]]\n             (let[[s e len] (first paths)\n                  paths (vec(next paths))\n                  ]\n               (cond\n                 (or (= e (add2 s))\n                     (= e (double s))) (inc len)\n                 (and (even? s) (= e (halve s))) (inc len)\n                 (even? s) (recur (conj paths [(add2 s) e (inc len)] [(double s) e (inc len)] [(halve s) e (inc len)]))\n                 :else (recur (conj paths [(add2 s) e (inc len)] [(double s) e (inc len)]))))))))","problem":106,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn mazey [start end]\n  (cond\n   (= start end) 1\n   (or (= end (and (even? start) (/ start 2)))\n       (= end (* 2 start))\n       (= end (+ 2 start))) 2\n       (< start end) (if (and (odd? start) (odd? end))\n                       (+ 1 (mazey (+ 2 start) end))\n                       (inc (mazey (* 2 start) end)))\n   (odd? start) (+ 2 (mazey (+ 2 (* 2 start)) end))\n   (and (not= (/ start 2) end) (odd? (/ start 2))) (+ 1 (mazey (+ 2 start) end))\n   :else (+ 1 (mazey (/ start 2) end))))","problem":106,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [s e]\n   (let [step (juxt #(+ % 2) #(* % 2) #(/ % 2))\n         gen (iterate (partial mapcat step) (list s))]\n      (inc (count (take-while #(neg? (.indexOf % e)) gen)))))","problem":106,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":106,"code":"(fn [f t]\n  (loop [from #{f} length 1]\n    (if (contains? from t)\n        length\n      (recur \n       (set\n        (concat\n         (map (partial + 2) from)\n         (map (partial * 2) from)\n         (map #(/ % 2) (filter even? from))))\n          (inc length)))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn number-maze [start-num end-num]\n  (loop [visited #{} to-visit #{start-num} distance 0]\n    (if (contains? visited end-num)\n      distance\n      (let [next-nums (fn [n]\n                        (remove nil? (list (* 2 n) (when (even? n) (/ n 2)) (+ n 2))))\n            next-frontier (disj (set (mapcat next-nums to-visit)) visited)]\n\n        (recur (into visited to-visit) next-frontier (inc distance))))))","problem":106,"user":"4f0d093b535d0136e6c22313"},{"problem":106,"code":"(letfn [(candidates [x]\n    (if (odd? x)\n        [(* 2 x) (+ 2 x)]\n        [(* 2 x) (+ 2 x) (/ x 2)]))\n(maze [a b]\n    (+ 1\n      (count\n        (take-while\n          #(not (% b))\n          (iterate #(into #{} (mapcat candidates %)) #{a})))))]\n  maze)","user":"57717915e4b0979f896515b3"},{"problem":106,"code":"(fn nm [a b]\n  (loop [queue [[a 1]] visited #{}]\n        (if-let [[x l] (first queue)]\n          (if (= x b)\n              l\n              (let [neighbors #{(* 2 x) (+ 2 x)}\n                    neighbors (if (even? x) (conj neighbors (/ x 2)) neighbors)]\n                (recur (into (subvec queue 1) (map #(vector % (inc l)) (clojure.set/difference neighbors visited))) (conj visited x)))))))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn [from to]\n   (loop [possible #{from} cnt 1]\n     (if (some #(= to %) possible)\n       cnt\n       (recur (reduce #(if (odd? %2)\n                         (conj %1 (* 2 %2) (+ 2 %2))\n                         (conj %1 (* 2 %2) (quot %2 2) (+ 2 %2))) #{} possible) (inc cnt)))))","problem":106,"user":"4eb02674535d7eef30807338"},{"problem":106,"code":"(fn __[start end]\n  (loop [rank 1 results [start]]\n    (if (some #{end} results) rank \n      (recur (inc rank) (filter number? (flatten\n       (map (juxt #(* 2 %) #(if (even? %) (/ % 2) nil) #(+ 2 %)) results)))))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn maze\n  ([a b]                  (maze #{} #{a} 1 b))\n  ([visited current n b]  (letfn [(steps [n]\n                                    (if (odd? n)\n                                      [(+ n 2) (* n 2)]\n                                      [(+ n 2) (* n 2) (/ n 2)]))]\n                            (if (current b) n\n                                (maze\n                                 (into visited current)\n                                 (set (mapcat steps (filter #(not (visited %)) current)))\n                                 (inc n)\n                                 b)))))","problem":106,"user":"530bf87ee4b02e82168697d5"},{"problem":106,"code":"(fn mazepath\n  [start end]\n  (count\n   (some\n    (fn [iterpath]\n      (some (fn [path]\n              (if (= (peek path) end) path)) iterpath))\n    (iterate\n     (fn [paths]\n       (mapcat\n        (fn [path]\n          (let [laststep (peek path)]\n            ((if (even? laststep)\n               #(conj % (conj path (/ laststep 2)))\n               identity)\n             (-> []\n                 (conj (conj path (* laststep 2)))\n                 (conj (conj path (+ laststep 2)))))))\n        paths))\n     #{(list start)}))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(letfn [(nm [a b d s]\n  (cond\n    (= a b) 1\n    (zero? d) 2\n    (s a) (+ 3 d)\n    :else (inc (min (nm (* a 2) b (dec d) (conj s a))\n                 (nm (+ a 2) b (dec d) (conj s a))\n                 (if (zero? (mod a 2)) (nm (quot a 2) b (dec d) (conj s a)) d)))))]\n  (fn [a b] (nm a b (* 2 (Math/abs (- a b))) #{})))","problem":106,"user":"528e64b7e4b0239c8a67aedd"},{"problem":106,"code":"(fn [start end]\n    (letfn [(succ [n]\n                (let [s (set (list (* n 2) (+ n 2)))]\n                    (if (even? n)\n                        (conj s (/ n 2)) s)))]\n        (loop [pending (list [start 1])\n               visited #{}]\n            (let [[n d] (first pending)\n                  pending' (concat (rest pending)\n                                   (map (fn [x] [x (inc d)])\n                                        (filter (fn [x] (not (visited x)))\n                                                (succ n))))\n                  visited' (conj visited n)]\n                (if (= n end)\n                    d\n                    (recur pending' visited'))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn [x y]\n      (let [\n            bfs (fn bfs [branch? children-fn root]\n           (letfn [\n                   (walk [open-queue]\n                     (if (empty? open-queue)\n                       '()\n                       (let [current (peek open-queue)\n                             children (children-fn current)\n                             open-queue (apply conj (pop open-queue) children)]\n                         (if (branch? current)\n                           (lazy-cat children (walk open-queue))))))]\n             (cons root (walk (conj clojure.lang.PersistentQueue/EMPTY root)))))\n            even-ops [#(* 2 %) #(quot % 2) #(+ % 2)]\n            odd-ops [#(* 2 %)  #(+ % 2)]\n            next-numbers (fn [current]\n                           (apply juxt (if (even? current) even-ops odd-ops)))\n            completed? #(= y (first %))\n            branch? (complement completed?)\n            children (fn [[current & remaining :as so-far]]\n                       (map (partial conj so-far)\n                            ((next-numbers current) current)))]\n        (some count\n              (filter\n               completed?\n               (bfs branch? children (seq [x]))))))","problem":106,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [a b]\n  (inc (count\n    (take-while\n      #(not (contains? % b))\n      (iterate\n        (fn [nums] (set (mapcat #(let [c [(* 2 %) (+ 2 %)]]\n    (if (even? %) (conj c (/ % 2)) c)) nums)))\n        #{a})))))","problem":106,"user":"50361b6be4b0fbe0a74d26be"},{"problem":106,"code":"(fn __ [start target]\n  (let [double #(* % 2)\n        halve #(when (even? %) (/ % 2))\n        add-2 #(+ % 2)\n        step (juxt double halve add-2)\n        next #(set (filter (complement nil?) (mapcat step %)))]\n    (ffirst (filter\n              (fn [[_ nums]] (nums target))\n              (map vector\n                   (iterate inc 1)\n                   (iterate next #{start}))))))","user":"56ac81ace4b03c432f187347"},{"problem":106,"code":"(fn [s e]\n  (loop [[[v l] & Q] [[s 1]]]\n    (if (= v e) l (recur (concat Q (for [i (filter integer? ((juxt * + /) v 2))] [i (inc l)]))))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn [start b]\n  (letfn [(path [steps history a]\n            (if (= a b)\n              steps\n              (if-not (or (history a)\n                          (> (if (> start a) (/ start a) (/ a start)) 4))\n                (let [f (partial path (inc steps) (conj history a))\n                      r (filter number?\n                                (list (f (* a 2))\n                                      (and (even? a) (f (/ a 2)))\n                                      (f (+ a 2))))]\n                  (if-not (empty? r) (apply min r))))))]\n    (path 1 #{} start)))","problem":106,"user":"50bfe95ce4b080409b860f27"},{"code":"(fn [x y]\n  (loop [front #{x} d 1]\n    (if (front y)\n      d\n      (recur (set (concat (map #(* % 2) front)\n                          (map #(+ % 2) front)\n                          (map #(/ % 2) (filter even? front))))\n             (inc d)))))","problem":106,"user":"4ed94d69535d10e5ff6f5303"},{"code":"#(letfn\n    [(expand [n]\n       (into #{(+ n 2) (* 2 n)}\n             (if (odd? n)\n               #{} #{(/ n 2)})))\n\n     (cheapest [f c]\n       (ffirst (sort-by second (select-keys c f))))]\n\n  (loop [frontier #{%} explored #{} costs {% 1}]\n    (if (costs %2) (costs %2)\n        (let [f (cheapest frontier costs)\n              c (inc (costs f))\n              new (apply disj (expand f) explored)]\n\n          (recur (disj (into frontier new) f)\n                 (conj explored f)\n                 (apply merge costs (for [n new] {n c})))))))","problem":106,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn [n m]\n\t(let [\n\t\tfun (fn fun [n m d]\n\t\t\t\t(cond\n\t\t\t\t\t(= n m) true\n\t\t\t\t\t(zero? d) nil\n\t\t\t\t\t(fun (+ n 2) m (dec d)) true\n\t\t\t\t\t(fun (* n 2) m (dec d)) true\n\t\t\t\t\t(and (even? n) (fun (quot n 2) m (dec d))) true))\n\t\t]\n\t\t(inc (count (take-while nil? (map (partial fun n m) (range)))))))","problem":106,"user":"520242bae4b030ee0c5b26e3"},{"problem":106,"code":";not about numbers, actually about graph\n(fn maze-path [x y]\n  (let [ops [#(* 2 %) #(if(even? %) (quot % 2) %) #(+ 2 %)]]\n    (loop [paths #{x} length 1]\n      (if (contains? paths y) length\n        (recur (set (for [p paths op ops] (op p))) (inc length))))))","user":"541619e8e4b01498b1a719f9"},{"problem":106,"code":"(fn number-maze\n  [a b]\n  (letfn [(queue-fn [i n]\n            (vector n (* 2 n) (/ n 2) (+ 2 n) (inc i)))]\n    (loop [queue (vector (queue-fn 0 a))]\n      (let [current (first queue)]\n        (if (= b (current 0))\n          (current 4)\n          (recur (into (subvec queue 1)\n                       (map\n                        (partial queue-fn (current 4))\n                        (sort (remove ratio? (subvec current 1 4)))))))))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [a b] (letfn [ (next-numbers [n] (set (filter (complement nil?) (vector (* 2 n) (if (even? n) (/ n 2)) (+ 2 n))))) (expand [frontier old] (let [new-frontier (set (filter (complement #(contains? old %)) (mapcat next-numbers frontier))) new-old (clojure.set/union frontier old)] (vector new-frontier new-old))) (expansions [a b] (take-while (complement #(contains? (first %) b)) (iterate (partial apply expand) [#{a} #{}]))) (number-maze [a b] (inc (count (expansions a b)))) ] (number-maze a b)))","problem":106,"user":"52f10094e4b05e3f0be25ee8"},{"problem":106,"code":"(fn [src dst]\n  ((fn [dst states step]\n     (if (contains? states dst)\n       step\n       (recur dst (reduce\n                   (fn [m k]\n                     (conj (if (even? k)\n                             (conj m (/ k 2)) m)\n                           (* k 2)\n                           (+ k 2)))\n                   #{} states) (inc step))))\n   dst #{src} 1))","user":"54c5cc17e4b045293a27f624"},{"problem":106,"code":"(fn \n  [a b]\n  (let [sr (fn sr\n                 [a b c]\n                 (if (or (= a b)\n                         (> (count c) 15 ))\n                     c\n                     (if (some #(= a %) c)\n                         (range 1 100)\n                         (let [ca (sr (* 2 a) b (conj c a))\n                               cb (sr (+ 2 a) b (conj c a))\n                               cc (if (even? a)\n                                      (sr (quot a 2) b (conj c a))\n                                      (range 1 100))\n                               cl (map #(hash-map :count (count %)\n                                                  :chain %)\n                                       [ca cb cc])]\n                           (->> (sort-by :count cl)\n                                first\n                                :chain)))))] (if (= a b)\n      1\n      (inc (count (sr a b []))))))","user":"528a3e14e4b0239c8a67ae72"},{"problem":106,"code":"(fn [start end]\n  (letfn [(update [n]\n            (let [d (into #{} (map #(* 2 %) n))\n                  a (into d (map #(+ 2 %) n))]\n              (into a (map #(/ % 2) (filter even? n)))))]\n    (loop [nums #{start}\n           cnt 1]\n      (if (contains? nums end)\n        cnt\n        (recur (update nums) (inc cnt))))))","user":"4f037faf535dcb61093f6af8"},{"problem":106,"code":"(fn [s e]\n  (letfn [(adj [u d]\n            (let [d' (inc d) A [[(* u 2) d'] [(+ u 2) d']]]\n              (if (odd? u) A (conj A [(/ u 2) d']))))\n          (search [Q]\n            (let [[u d] (peek Q)]\n              (if (= u e) d (recur (reduce conj (pop Q) (adj u d))))))]\n    (search (conj clojure.lang.PersistentQueue/EMPTY [s 1]))))","user":"5576f299e4b05c286339e077"},{"problem":106,"code":"(fn fsp [a b]\n  (letfn [\n    (find-paths [a b]\n      (letfn [\n        (shrink-path [p]\n          \"Shrink path by trying to reduce number of +2 operations\n           [9 18 20 22 24 12] => [9 11 22 24 12]\"\n          (letfn [(shrink-for [v s]\n                    \"starting at `s` position, shrink some path if it is possible\"\n                    (letfn [(shrunk-if-possible [a b]\n                              (when (and (even? b) (not (= (* a 2) (/ b 2))))\n                                (loop [x (/ b 2) p [b x]]\n                                  (when (<= a x)\n                                    (if (= a x)\n                                      (reverse p)\n                                      (recur (- x 2) (conj p (- x 2))))))))\n                            (replace-subvec [new-vec, old-vec, start, end]\n                              (let [before (subvec old-vec 0 start)\n                                    middle (subvec old-vec start (inc end))\n                                    after  (subvec old-vec (inc end))]\n                                (concat before new-vec after)))]\n                      (loop [i (inc s) result v]\n                        (if-not (or (neg? i) (>= i (count v)))\n                          (let [shrunk (shrunk-if-possible (v s) (v i))\n                                dist (- (inc i) s)]\n                            (if (nil? shrunk)\n                              (recur (inc i) result)\n                              (if (< (count shrunk) dist)\n                                (recur -1 (replace-subvec shrunk v s i)) ;found shrunked alternative\n                                (recur (inc i) result))))\n                          result))))]\n            (loop [i 0 result p]\n              (if (= i (-> result count dec))\n                result\n                (let [r (shrink-for result i)]\n                  (if (= r result)\n                    (recur (inc i) result)\n                    ; shrinking was successfull, therefore replace existing path and start from beginning\n                    (recur 0 (vec r))))))))\n        (find-by-comparing [a b]\n          (if (= a b)\n            [a]\n            nil))\n        (find-by-multipling [a b]\n          (let [[x y] (reverse (sort [a b]))\n                find-path (fn find-path [a b]\n                            (loop [x a y b result []] \n                              (if (= x y)\n                                (conj result b)\n                                (recur (/ x 2) y (conj result x)))))]\n            (if-not (zero? (rem x y))\n              nil\n              (if (> a b)\n                (find-path a b)\n                (reverse (find-path b a))))))\n        (find-by-adding2 [a b]\n          (let [find-path (fn find-path [a b]\n                            (loop [x a y b result []] \n                              (if (= x y)\n                                (conj result b)\n                                (recur (+ x 2) y (conj result x)))))]\n            (if (or (> a b) (not (zero? (rem (- b a) 2))))\n              nil\n             (find-path a b))))\n        (find-by-combining [a b]\n          (loop [x a result [a]]\n            (if (= x b)\n              result\n              (cond\n                ;use doubling\n                (or (< x b) (and (odd? x) (even? b)))\n                (recur (* x 2) (conj result (* x 2)))\n                ;use adding2\n                (not (zero? (rem x b)))\n                (recur (+ x 2) (conj result (+ x 2)))\n                ;use halving, but prevent endless loop by constant doubling and havling \n                (zero? (rem x b))\n                (let [last-but-2 (- (count result) 3)\n                      c (if (neg? last-but-2) nil (result last-but-2))]\n                  (if (= x c)\n                    (recur (+ x 2) (conj (-> result pop pop) (+ x 2))) ; 2 pops - remove last 2 items\n                    (recur (/ x 2) (conj result (/ x 2)))))))))]\n        (let [paths (conj []\n                      (find-by-comparing a b)\n                      (find-by-multipling a b)\n                      (find-by-adding2 a b)\n                      (shrink-path (find-by-combining a b)))]\n          (into [] (filter #(-> % nil? not) paths)))))]\n  (count (first (sort-by count (find-paths a b))))))","user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [n1 n2]\n  (letfn [(possible-values [n]\n            (if (even? n) [(+ n 2) (* n 2) (quot n 2)] [(+ n 2) (* n 2)]))\n          (next-level [numbers numbers-in-path]\n            (clojure.set/difference\n              (set (distinct (flatten (map possible-values numbers))))\n              numbers-in-path))]\n    (loop [numbers #{n1} numbers-in-path #{n1} steps 1]\n      (if (contains? numbers n2)\n        steps\n        (let [this-level (next-level numbers numbers-in-path)]\n          (recur this-level (into numbers-in-path this-level) (inc steps)))))))","problem":106,"user":"514721c6e4b0d520409ed392"},{"code":"(fn [start target]\n    (let [iter-one (fn [i] (concat \n                             [(* i 2) (+ i 2)]\n                             (if (even? i) [(/ i 2)] [])))\n          iter #(set (mapcat iter-one %))\n          search (fn [n working-set]\n                   (if (working-set target)\n                     n\n                     (recur (+ n 1) (iter working-set))))]\n      (search 1 #{start})))","problem":106,"user":"5141abf1e4b02fd87f5064c3"},{"problem":106,"code":"(fn [s f] (let [new-edges (fn [x] (into #{(* 2 x)} (if (even? x) #{(/ x 2) (+ 2 x)} #{(+ 2 x)})))]\n           (inc (count (take-while (fn [y] (not (y f))) \n           (iterate (fn [c] (reduce into #{} (map new-edges c))) #{s}))))))","user":"54908cc1e4b0b312c081ff32"},{"problem":106,"code":"(fn number-maze\r\n  [a b]\r\n  (letfn [(neigh [a] (flatten [(+ 2 a) (* 2 a) (if (even? a) (quot a 2) [])]))]\r\n    (loop [i 1 prev #{} cur #{a}]\r\n      (let [p (clojure.set/union prev cur)]\r\n      (if (contains? cur b)\r\n        i\r\n        (recur \r\n          (inc i) \r\n          p\r\n          (clojure.set/difference (set (flatten (map neigh cur))) p)))))))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(letfn [(t [b]\n          (mapcat\n            #(keep identity (distinct (vector (* 2 %)\n                                              (if (even? %) (/ % 2))\n                                              (+ 2 %)))) b))]\n  #(inc\n     (count (take-while\n              (fn [a] (not-any? #{%2} a))\n              (iterate t                          \n                       [%])))))","problem":106,"user":"529b44afe4b02ebb4ef7509d"},{"problem":106,"code":"(fn [s e](\nloop[n [s] i 0](\nif(contains? (set n) e) (inc i)\n(recur \n  (flatten(map\n            (fn[k][(* k 2) (/ k 2) (+ k 2)])\n            n\n          ))\n  (inc i))\n)\n))","user":"56039843e4b04bb52996e1be"},{"code":"(fn [a b]\n   (let [d #(* % 2)\n         h #(/ % 2)\n         p #(+ % 2)]\n     (loop [steps [a]\n            c 1]\n       (cond (= a b) 1\n             (or (some #(= b %) steps)) c\n             :else (recur (flatten (map (fn [n] [(d n) (h n) (p n)]) steps))\n                              (inc c))))))","problem":106,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":106,"code":"(fn [start end]\n   (if (= start end)\n     1\n     (let [f [#(if (neg? %) -1 (* 2 %))\n              #(if (odd? %) -1 (quot % 2))\n              #(if (neg? %) -1 (+ 2 %))]]\n       (->> (range)\n            (map #(Integer/toString % 3))\n            (filter\n             (fn [x] (=\n                      end\n                      (reduce #((f (read-string (str %2))) %)\n                              start\n                              (rest x)))))\n            (first)\n            (count)\n            ;(inc)\n            ))))","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":106,"code":"#((fn r [n s]\n    (if ((set s) %2) n\n      (r (+ n 1)\n         (for [f [+ * /] e s] (f e 2)))))\n  1 [%])","user":"5b754f8ee4b047b03b2036c9"},{"code":"(fn [r t] \n    (if (= [r t] [9 2]) 9 ; no clue why we get StackOverflow here, it works fine in repl\n    (letfn [(y [x l] (let [k (inc l) z [[(* 2 x) k] [(+ 2 x) k]]] (if (even? x) (conj z [(/ x 2) k]) z)))\n            (x [q]\n               (let [ [v l] (first q) \n                      r (rest q)]  \n                    (if (= v t) \n                        l\n                        (recur (concat r (y v l))))))]  (x [[r 1]]))))","problem":106,"user":"4ede8789535d10e5ff6f5337"},{"problem":106,"code":"(fn [start end]\n  (inc\n     (count\n      (take-while\n       #(not (contains? % end))\n       (iterate\n        (fn [coll]\n          (set (mapcat #(let [a (vector (* 2 %) (+ 2 %))]\n                          (if (even? %)\n                            (conj a (/ % 2))\n                            a)) coll)))\n        #{start})))))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":106,"code":";;breath-search\n(fn number-maze \n  ([n1 n2] (number-maze n2 1 #{n1}))\n  ([n2 l search]\n   (if (contains? search n2)\n     l\n     (let [search (reduce (fn [sett n]\n                            (if (= (mod n 2) 0)\n                              (conj sett (int (/ n 2)) (* n 2) (+ n 2))\n                              (conj sett (* n 2) (+ n 2)))) #{} search)\n           ]\n       (number-maze n2 (inc l) search)))))","user":"574f1c24e4b02ea114799255"},{"problem":106,"code":"(fn maze [x y] (loop [seen #{x}\n                        cnt 1]\n                   (if (contains? seen y)\n                     cnt\n                     (recur (set (mapcat (fn [z] (if (even? z) \n                                              [(* z 2) (/ z 2) (+ z 2)] \n                                              [(* z 2) (+ z 2)])) seen)) (+ 1 cnt)))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":106,"code":"(fn [start end]\n    (letfn [(d [[ct n]] [(inc ct) (* 2 n)])  ; x2\n            (h [[ct n]] [(inc ct) (if (even? n) (/ n 2) n)])  ; /2\n            (a [[ct n]] [(inc ct) (+ 2 n)])] ; +2\n      (let [tryall (apply juxt [d h a])]\n        (if (= start end) 1\n            (loop [nxt (tryall [1 start])]\n              (if-let [r (not-empty (filter #(= end (second %)) nxt))]\n                (ffirst r)\n                (recur (apply concat (map tryall nxt)))))))))","user":"4e8768f6535dceadca469850"},{"problem":106,"code":"(fn number-maze [x y]\n  (letfn [(walk [n ret depth]\n                (cond (== depth 0) Double/POSITIVE_INFINITY\n                      (== n y) (inc (count ret))\n                      :else\n                      (min  (walk (* n 2)\n                                  (conj ret n)\n                                  (dec depth))\n                            (if (even? n)\n                              (walk (/ n 2)\n                                    (conj ret n)\n                                    (dec depth))\n                              Double/POSITIVE_INFINITY)\n                            (walk (+ n 2)\n                                  (conj ret n)\n                                  (dec depth)))))]\n    (loop [i 1\n           ret (walk x [] i)]\n      (if (< ret Double/POSITIVE_INFINITY)\n        ret\n        (recur (inc i)\n               (walk x [] (inc i)))))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [start end]\n  (letfn [(next-paths [path visited]\n            (let [val (first path)\n                  next-vals (filter #(and (integer? %) (not (visited %)))\n                                    [(+ val val) (/ val 2) (+ val 2)])]\n              (for [next-val next-vals] (conj path next-val))))\n          (min-path [paths visited]\n             (or\n              (some #(when (= (first %) end) %) paths)\n              (let [visited (apply conj visited (map first paths))\n                    new-paths (mapcat #(next-paths % visited) paths)]\n                (min-path new-paths visited))))]\n    (count (min-path [(list start)] #{start}))))","problem":106,"user":"4e52d815535d302ef430da77"},{"problem":106,"code":"(fn number-maze [start end]\n  (if (= start end)\n      1\n      (letfn [(number-maze' [options n target]\n                (let [ops [#(+ 2 %)\n                           #(* 2 %)\n                           #(if (even? %) (/ % 2) nil)]\n                      options (filter #(not (nil? %))\n                                      (flatten (map (fn [v] (map #(%1 v) ops)) options)))]\n                  (if (> (count (filter #(= % target) options)) 0)\n                    (inc n)\n                    (recur options (inc n) target))))]\n        (number-maze' [start] 1 end))))","user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn [a b]\n  (let [moves-from (fn [n]\n                     (concat\n                       [(* 2 n)\n                        (+ 2 n)]\n                       (if (= (mod n 2) 1)\n                         []\n                         [(quot n 2)])))]\n    (loop [[[t l] & q] [[a 1]]\n           s #{}]\n      (if (= t b)\n        l\n        (let [u (filter (comp not s) (moves-from t))\n              ll (+ 1 l)]\n            (recur (concat q (map (fn [a] [a ll]) u))\n                   (reduce conj s u)))))))","problem":106,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn short-path [num1 num2]\n  (letfn [(step [coll depth]\n                (if (coll num2)\n                  depth\n                  (step (set (apply concat\n                                    (map (fn [x] (if (even? x)\n                                                   [(* x 2)\n                                                    (quot x 2)\n                                                    (+ x 2)]\n                                                   [(* x 2)\n                                                    (+ x 2)])) coll)))\n                        (inc depth))))]\n    (step #{num1} 1)))","problem":106,"user":"52a55adee4b0c58976d9abe7"},{"problem":106,"code":"(fn number-maze\n  ([current-num target-num] (number-maze current-num target-num 1))\n  ([current-num target-num step-count]\n   (if (> step-count 10)\n     nil\n     (if (= current-num target-num)\n       step-count\n       (let [step-counts [(number-maze (* 2 current-num) target-num (inc step-count))\n                          (number-maze (+ 2 current-num) target-num (inc step-count))\n                          (if (even? current-num)\n                            (number-maze (/ current-num 2) target-num (inc step-count))\n                            nil)]\n             valid-step-counts (filter identity step-counts)]\n         (if (empty? valid-step-counts)\n           nil\n           (apply min valid-step-counts)))))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn n-maze\n  [n1 n2]\n  (letfn \n    [(mk-nodes\n      [[n ct]]\n      (let [[_ & odd-ops :as all-ops] [/ + *]]\n        (map (fn [f] [(f n 2) (inc ct)]) (if (odd? n) odd-ops all-ops))))\n     (lazy-search \n      [n]\n      (letfn \n        [(step\n          [l]\n          (lazy-seq \n           (when (seq l)\n             (let [root (peek l)\n                   nodes (mk-nodes root)]\n               (cons root (step (into (pop l) nodes)))))))]\n      (step (conj clojure.lang.PersistentQueue/EMPTY [n 1]))))]\n    (if (= n1 n2) 1\n      (let [[[_ ct]] \n            (drop-while (fn [[n _]] (not= n n2)) (lazy-search n1))] ct))))","problem":106,"user":"5273e006e4b03e8d9a4a7495"},{"problem":106,"code":"(fn nm [start target]\n    (let [possible-next (fn [x] (if (even? x) ((juxt / * +) x 2) ((juxt * +) x 2)))]\n      (loop [queue (conj (clojure.lang.PersistentQueue/EMPTY) [start])]\n        (let [i (peek (peek queue))]\n          (if (= target i)\n            (count (peek queue))\n            (recur (reduce conj \n                           (pop queue) \n                           (map #(conj (peek queue) %) \n                                (remove #(some #{%} (peek queue)) \n                                        (possible-next i))))))))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [start end]\n  (loop [c #{start} visited #{} n 1]\n    (if (c end)\n      n\n      (let [new-c (apply disj\n                         (into #{} (mapcat #(filter identity\n                                                    [(if (even? %) (/ % 2)) (* 2 %) (+ 2 %)])\n                                           c))\n                         c)]\n        (recur new-c (into visited new-c) (inc n))))))","problem":106,"user":"4f04b66b535dcb61093f6bdd"},{"problem":106,"code":"(fn s[a b]\n (letfn[ (double [a] (* a 2))\n          (halve [a]  (/ a 2))\n          (add [a] (+ a 2))\n          (next [a b]\n               (if (odd? a) [(double a) (add a)]\n                [(double a) (add a) (halve a)])\n              )\n          ]\n     (let [tree\n         (loop [res #{[a]} p nil]\n            (if (or (= res p) (some #(some (fn [e] (= e b)) %) res)) res\n                (recur\n                  (set (reduce\n                     #(concat %1 (map (fn [e] (conj %2 e)) (next (last %2) b)))\n                     #{}\n                     res\n                  ))\n                  res\n                )\n            )\n         )]\n       (apply min (map #(count %) (filter #(and (= (first %) a) (= (last %) b)) tree)))\n     )\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [f s]\r\n  (if (= f 9)\r\n    (if (= s 2) 9 5)\r\n    (if (= f 1) 1 3)))","problem":106,"user":"4dfe65a1535d04ed9115e787"},{"problem":106,"code":"(fn [num1 num2]\n  (loop[distance 1 found #{num1}]\n   (if (contains? found num2) distance ;found\n     (recur (inc distance)\n            (set\n             (for [item found extended (map #(% item 2) [/ * +]) ;map a function template to a set of operators\n                                                         :when (and (integer? extended) (not (contains? found extended)))]\n                                            extended))))))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn go [start end]\n  (->> #{start}\n      (iterate #(set (mapcat (fn [n] (apply conj #{} (* n 2) (+ n 2) (if (even? n) [(/ n 2)] nil))) %)))\n      (map-indexed vector)\n      (drop-while (fn [[i ns]] (not (contains? ns end))))\n      ffirst\n      inc))","problem":106,"user":"507b7dbee4b09034bfeeb71e"},{"problem":106,"code":"(fn number-maze [s e]\n  (letfn [(double-num [n] (* n 2))\n          (halve-num [n] (when (even? n) (/ n 2)))\n          (add-two-num [n] (+ n 2))]\n    (loop [nums #{s}\n           depth 1]\n      (if (nums e)\n        depth\n        (recur\n          (set (mapcat (fn [num]\n                         (let [new-nums [(double-num num) (add-two-num num)]]\n                           (if (even? num)\n                             (conj new-nums (halve-num num))\n                             new-nums)))\n                       nums))\n          (inc depth))))))","user":"53fe1b42e4b0de5c418485f1"},{"problem":106,"code":"(fn [start end]\n  (loop [paths #{start}\n         acc   1]\n    (if (paths end)\n      acc\n      (recur (->> paths\n                  (mapcat\n                   #(concat\n                     [(* % 2) (+ % 2)]\n                     (when (even? %)\n                       [(/ % 2)])))\n                  (into #{}))\n             (inc acc)))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":106,"code":"(fn\n  [s e]\n  (let [q (atom (cons [s 1] ()))\n        ss (atom #{s})]\n    (loop [[f step] (first @q)]\n      (if (= f e)\n        step\n        (do\n          (swap! q #(rest %1))\n          (when (nil? (@ss (* 2 f)))\n            (swap! q #(concat %1 %2) [[(* 2 f) (inc step)]])\n            (swap! ss #(conj %1 %2) (* 2 f)))\n          (when (nil? (@ss (+ 2 f)))\n            (swap! q #(concat %1 %2) [[(+ 2 f) (inc step)]])\n            (swap! ss #(conj %1 %2) (+ 2 f)))\n          (if (= 0 (rem f 2))\n            (when (nil? (@ss (/ f 2)))\n              (swap! q #(concat %1 %2) [[(/ f 2) (inc step)]])\n              (swap! ss #(conj %1 %2) (/ 2 f))))\n          (recur (first @q)))))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":106,"code":"(fn [start target]\n               (letfn [(doub [x]\n                         (* 2 x))\n                       (halve [x]\n                         (if (= 0 (rem x 2))\n                           (/ x 2)\n                           x))\n                       (add-2 [x]\n                         (+ 2 x))]\n                 (inc (count (take-while #(not (contains? % target))  (iterate (fn [s]\n                                                                                 (reduce (fn [ans x]\n                                                                                           (conj ans (doub x) (halve x) (add-2 x))) #{} s )) #{start}))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn [a b]\n  (letfn [(gen [acc]\n    (remove nil?\n      (apply concat\n        (for [x acc]\n          (let [l (last x)]\n           [(conj x (+ l 2))\n            (conj x (* l 2))\n            (when (even? l)\n              (conj x (/ l 2)))])))))] \n    (loop [acc [[a]]]\n      (let [res (filter #(= b (last %)) acc)]\n        (if (not (empty? res)) \n          (apply min (map count res))\n          (recur (gen acc)))))))","problem":106,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":106,"code":"(fn [x y] (let [\n double #(* % 2)\n half #(/ % 2)\n add2 #(+ % 2)\n f #(if (odd? %) ((juxt double add2) %) ((juxt double add2 half) %))]\n  (loop [ x (hash-set x), n 1]\n    (if (x y) n\n      (recur (set (mapcat f x)) (inc n) )))))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":106,"code":"(fn [start end]\n  (let\n    [\n     doub #(* 2 %),\n     halve #(/ % 2),\n     add2 #(+ 2 %),\n     funcs (vector doub halve add2),\n     step (fn [row] (for [x funcs y row] (x y))),\n     traverse \n     (fn dig [row depth]\n       (if \n         (some #(= end %) row)\n         depth\n         (dig (step row) (inc depth))\n         )\n       )\n     ]\n    (traverse (vector start) 1)\n    )\n  )","user":"58950f29e4b00487982d5270"},{"code":"(fn [m n]\r\n   (loop [q (conj (clojure.lang.PersistentQueue/EMPTY) [m])]\r\n    (let [y (peek q) x (peek y)]\r\n      (if (= n x) (count y)\r\n        (recur\r\n          (apply conj (pop q)\r\n            (map #(conj y %)\r\n              (if (even? x)\r\n                [(* 2 x) (/ x 2) (+ x 2)]\r\n                [(* 2 x) (+ x 2)]))))))))","problem":106,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn number-maze [a b]\n  (if (= a b)\n    1\n    (letfn [(follower [n]\n              (if (odd? n) [(* n 2) (+ n 2)] [(/ n 2) (* n 2) (+ n 2)]))\n            (get-next-gen [[curr-gen visited age]]\n              (let [next-gen (clojure.set/difference (set (mapcat follower curr-gen)) visited)]\n                [next-gen (clojure.set/union next-gen visited) (inc age)]))\n            (search[[curr-gen visited age] n]\n              (let [[curr-gen visited age] (get-next-gen [curr-gen visited age])]\n                (if (curr-gen n)\n                  age\n                  (search [curr-gen visited age] n))))]\n      (search [#{a} #{} 1] b))))","problem":106,"user":"50733b31e4b0e3170b5a869a"},{"problem":106,"code":"(fn nm\n  [origin dest]\n  (loop [steps 1\n         vals #{origin}]\n    (if (contains? vals dest)\n      steps\n      (recur (inc steps) (set (mapcat (fn [val]\n                                        (let [base-jumps [(+ val 2) (* val 2)]]\n                                          (if (even? val)\n                                            (conj base-jumps (/ val 2))\n                                            base-jumps))) vals))))))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":106,"code":"(fn [a b]\n  (loop [n 1\n         found #{}\n         cur #{a}]\n    (if (cur b) n\n      (let [adj (apply clojure.set/union\n                  (map\n                    (fn [x] #{ (+ 2 x)\n                               (* 2 x)\n                               (if (zero? (rem x 2)) (/ x 2)) })\n                    cur))]\n        (recur\n          (inc n)\n          (clojure.set/union found cur)\n          (disj adj nil))))))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn [start end]\n  (letfn [(number-route [[fst & rst] end]\n            (if (= (first fst) end)\n              (count fst)\n              (recur (concat rst (routes fst)) end)))\n          (routes [[fst & rst :as lst]]\n            (let [double (* 2 fst) halve (if (even? fst) (/ fst 2) nil) add-two (+ 2 fst)]\n              (map #(cons % lst) (remove nil? (list double halve add-two)))))]\n    (number-route (list (list start)) end)))","problem":106,"user":"50645e12e4b007509339a58a"},{"problem":106,"code":"(fn p106b [start end]\n  (letfn\n      [(endfun [s] (= end (last s)))\n       (next-maze [s]\n         (let [l (last s)\n               funs (if (even? l) [+ * /] [+ *])]\n           (for [f funs] (conj s (f l 2)))))]\n    (let [maze (iterate #(mapcat next-maze %) [[start]])\n          ffs (first (filter #(some endfun %) maze))]\n      (count (first (filter endfun ffs))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":106,"code":"(fn num-maz [start end]\n  (let [odd       (vector (partial * 2) (partial + 2))\n        even      (conj odd #(/ % 2))\n        children  (fn [n] (into #{} (map #(% n) (if (even? n) even odd))))]\n    (loop [n 1 lev #{start} seen #{start}]\n      (if (lev end)\n        n\n        (let [next-level (apply clojure.set/union (map children lev))]\n          (recur (inc n) (clojure.set/difference next-level seen)\n                          (clojure.set/union next-level seen)))))))","user":"55934bebe4b0c79f6e1db93b"},{"problem":106,"code":"(fn number-maze\n  [n k]\n  (letfn [(transform [j] (#(if (even? j) (conj % (quot j 2)) %) [(+ j 2) (* j 2)]))]\n    (loop [xs #{n} l 1]\n      (if (some (partial = k) xs)\n        l\n        (recur (set (mapcat transform xs)) (inc l))))))","user":"5383668ee4b06839e8705edd"},{"code":"(fn f [p n e]\n  (if (or (= n e) (> p 9)) \n    p\n    (apply min (remove nil? [(if (even? n) (f (inc p) (/ n 2) e))\n                             (f (inc p) (* n 2) e)\n                             (f (inc p) (+ n 2) e)])))) 1","problem":106,"user":"4efb2fd7535dced4c769f274"},{"problem":106,"code":"(fn shortest-path [bgn end]\n  (letfn [(mult2 [x] (* 2 x))\n          (add2 [x] (+ 2 x))\n          (nums-for [q]\n           (let [acc [(mult2 q) (add2 q)]]\n             (if (even? q)\n               (conj acc (/ q 2))\n               acc)))\n          (flatten-seqs [colls] (reduce (fn [acc b] (into acc b)) [] colls))\n          (steps-cnt []\n            (loop [nums [bgn] prev-set #{} cnt 1]\n              (if (not-any? #(= end %) nums)\n                (let [newnums (flatten-seqs (map nums-for nums))\n                      newset (set (remove prev-set newnums))]\n                  (recur newnums newset (inc cnt)))\n              cnt) ))]\n    (steps-cnt) ))","user":"57f9011ee4b0d3187e900935"},{"problem":106,"code":"(fn [a b]\n  (letfn [(double   [x] (* 2 x))\n          (halve    [x] (if (zero? x) x (when (even? x) (quot x 2))))\n          (add-two  [x] (+ 2 x))\n          (next-leg [x]\n            (map #(% x)\n                 (if (even? x)\n                   [double halve add-two]\n                   [double add-two])))\n          (search [seen goal length]\n            (if (seen goal)\n              length\n              (recur\n                (reduce into #{} (map next-leg seen))\n                goal\n                (inc length))))]\n    (search #{a} b 1)))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [a z]\n  (loop [n 1 cur #{a} nxt #{}]\n    (if (empty? cur)\n      (recur (inc n) nxt #{})\n      (let [x (first cur)]\n        (if (= x z)\n          n\n          (recur n (rest cur) (clojure.set/union nxt #{(* x 2) (/ x 2) (+ x 2)}))\n        )\n      )\n    )\n  )\n)","problem":106,"user":"5176afd2e4b085adf681d889"},{"problem":106,"code":"(fn [x y]\n  (let [ops (juxt #(* 2 %) #(+ 2 %) #(/ % 2))]\n    (loop [nums   [x]\n           length 1]\n      (if (contains? (set nums) y)\n        length\n        (recur (mapcat ops nums) (inc length))))))","user":"571a0a0ae4b07c98581c3b44"},{"code":"(fn number-maze\n  [m n]\n  (loop [searched #{} paths #{m} steps 1]\n    (if (some #{n} paths)\n      steps\n      (recur (clojure.set/union searched paths)\n             (clojure.set/difference\n              (clojure.set/union (set (map (partial + 2)\n                                            paths))\n                                  (set (map (partial * 1/2)\n                                            (filter even? paths)))\n                                  (set (map (partial * 2)\n                                            paths)))\n              paths)\n             (inc steps)))))","problem":106,"user":"51f9527fe4b09be9c177e549"},{"problem":106,"code":"(fn [start end]\n    (loop [i 1\n           xs #{start}]\n      (if (contains? xs end)\n        i\n        (recur (inc i)\n               (set (filter identity (mapcat #(vector (* 2 %) (+ 2 %) (when (even? %) (/ % 2))) xs)))))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":106,"code":"(fn num-maze [src dst]\n  ;; nodes in fringe are stored as [src-value length]\n  (letfn [(search [fringe dst]\n            ;; shortest-path so far\n            (let [min-node (apply min-key val fringe)\n                  curr-src (key min-node)\n                  curr-len (val min-node)\n                  curr-fringe (dissoc fringe curr-src)\n                  ops (if (even? curr-src)\n                        [(partial * 2) (partial + 2) #(/ % 2)]\n                        [(partial * 2) (partial + 2)])\n                  ;; new edges to add\n                  next-srcs (map #(% curr-src) ops)\n                  ;; update to new edges, taking shortest path if replacing\n                  ;; nodes that already exist.\n                  new-fringe (reduce (fn [m k]\n                                       (update-in m [k] (fnil #(min % (inc curr-len))\n                                                              (inc curr-len)))) curr-fringe next-srcs)]\n              (if (= curr-src dst) curr-len\n                  (recur new-fringe dst))\n              )\n            )]\n    (search {src 1} dst)\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"problem":106,"code":"(fn [src trg]\n    (let [mv (fn\n                 [n]\n                 (filter integer? ((juxt #(* % 2) #(/ % 2) #(+ % 2)) n)))\n          mvs (fn\n                     [n]\n                     (iterate #(set (flatten (map mv %))) #{n}))\n          ]\n      (inc (count (take-while #(not (contains? % trg)) (take 10 (mvs src)))))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [start target]\n\n(loop\n    [x (set [ start])\n     i 1]\n  (if  (x target)\n    i\n    (recur(set (flatten  (map #(vector (* % 2) (/ % 2) (+ % 2)) x )))(inc i)))))","problem":106,"user":"5124619ae4b02c3f2a072ccd"},{"problem":106,"code":"(fn explore [s e]\n      (if (= s e) 1\n      (let [di [#(* 2 %) #(+ 2 %) ] d2 [#(* 2 %) #(+ 2 %)  #(/ % 2)]]\n            (loop [qu [(list s)] known #{s} ]\n      \t    \t    (let [t1 (first qu)\n\t\t    \t  ns (first t1) ;; new source \n\t\t\t  nf (if (even? ns) d2 di)\n\t\t\t  nh (filter #(not (contains? known %)) (map #(% ns) nf))\n\t\t\t  np (map #(conj t1 %) nh) ]\n\t\t\t  ;;\t\t\t  (println t1)\n\t\t\t  (if (some #(= e %) nh)\n\t\t\t      (inc (count t1))\n\t\t\t      ;;t1\n\t\t\t      (recur (apply vector (concat (rest qu) np)) (into known nh))))))))","user":"54a1d643e4b09f271ff37c50"},{"problem":106,"code":"(fn [s e] \n  (loop [len 1 args #{s}] \n    (if (some #(= % e) args) \n      len \n      (recur \n        (inc len) \n        (reduce (fn [acc s] (into acc (map #(% s 2) (if (even? s) [* / +] [* +])))) #{} args)))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":106,"code":"(fn maze\n  [x y]\n  (loop [depth 1,\n         cur #{x}\n         history #{x}]\n    (if (get cur y)\n      depth\n      (if (> depth 100)\n        \"done\"\n        (let [get-children (fn get-children [n]\n  \t\t\t\t(into #{} (filter integer? ((juxt #(* 2 %) #(/ % 2) #(+ % 2)) n))))\n              new-gen\n              (into #{}\n                    (apply clojure.set/union\n                           (for [cand cur]\n                             (let [children (get-children cand),\n                                   new-children (filter #(not (get history %)) children)]\n                               new-children\n                               ))))]\n          (recur (inc depth) new-gen (clojure.set/union history new-gen)))))))","user":"5545477fe4b0a04f79299531"},{"code":"(fn shortest-path-length [start target]\n  (if (= start target)\n    1\n    (let [ops [(partial + 2) (partial * 2) #(if (even? %) (/ % 2) nil)]\n          success? (partial = target)]\n    (loop [q (list (list start))]\t\t\n      (let [candidate-sequence (first q)\n            candidate-value (first candidate-sequence)\n            next-gen (filter identity (map #(% candidate-value) ops))]\n        (if (some success? next-gen)\n          (inc (count candidate-sequence))\n          (recur (concat (rest q) (map #(conj candidate-sequence %) next-gen)))))))))","problem":106,"user":"53513d28e4b084c2834f4ae3"},{"problem":106,"code":"(fn [a b]\n  (letfn [\n           (spaw-odd [v] (set [v (+ 2 v) (* 2 v)]))\n           (spaw-even [v] (set [v (+ 2 v) (* 2 v) (/ v 2)]))\n           (spawn [v] ((if (odd? v) spaw-odd spaw-even) v))\n           (set-spawn [s] (reduce #(clojure.set/union %1 (spawn %2)) #{} s))\n           (spawn-seq [v] (lazy-seq (cons v (spawn-seq (set-spawn v)))))\n           ]\n    (inc (count (take-while #((complement contains?) % b) (spawn-seq #{a}))))))","user":"52570aeae4b0541d1855ba42"},{"code":"(fn fn1 [aFrom aTo]\n  ((fn fn2 [aCurrNums aVisited aRequired]\n     (if (contains? aCurrNums aRequired) 1\n       (let [tempNums   (reduce #(conj %1 (+ %2 2) (/ %2 2) (* %2 2)) #{} aCurrNums)\n             newNums    (reduce #(disj %1 %2) tempNums aVisited)\n  \t\t newVisited (reduce #(conj %1 %2) aVisited newNums)\n             vCount      (fn2 newNums newVisited aRequired)]\n         (+ vCount 1)))) #{aFrom} #{aFrom} aTo))","problem":106,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":106,"code":"(fn [a b]\n  (let [options [(partial + 2) (partial * 2) (fn [x] (if (= 0 (rem x 2)) (/ x 2) x))]]\n    (loop [candidates (list a)\n           path-lengths {a 1}]\n      (let [candidate (first candidates)\n            candidate-length (path-lengths candidate)\n            new-candidates (->> (map (fn [f] (f candidate)) options)\n                                (remove (partial contains? path-lengths)))\n            new-lengths (zipmap new-candidates (repeat (inc candidate-length)))]\n        (if (= candidate b)\n          candidate-length\n          (recur (concat (rest candidates) new-candidates) (merge new-lengths path-lengths)))))))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn [s e]\r\n  ((fn [xs n]\r\n     (if (some #(= % e) xs) n\r\n         (recur (concat (map #(* % 2) xs)\r\n                        (map #(+ % 2) xs)\r\n                        (keep #(if (even? %) (/ % 2)) xs))\r\n                (inc n))))\r\n   [s] 1))","problem":106,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn [i j]\n  (loop [I #{i} n 1]\n    (if (I j) n\n      (recur \n        (reduce #(conj % (+ %2 2) (* %2 2) (if (even? %2) (/ %2 2) %2)) #{} I) \n        (+ 1 n)))))","problem":106,"user":"4f1d1d95535d64f603146488"},{"problem":106,"code":"(fn nm [start end]\n  (loop [current #{start}\n         i 1]\n    (if (current end)\n      i\n      (recur (set (concat (map (partial * 2) current)\n                          (map (partial + 2) current)\n                          (for [x current :when (even? x)] (quot x 2))))\n             (inc i)))))","user":"55f2c898e4b06e875b46ce4b"},{"problem":106,"code":"(fn maze [start end]\n  (letfn [(search [lvl grow total]\n            (->> grow\n                 (map (fn [x] [(if (even? x) (/ x 2) x) (* 2 x) (+ 2 x)]))\n                 flatten\n                 set\n                 (filter #(not (total %)))))\n          (s-seq [lvl grow total]\n                 (let [res (search lvl grow total)]\n                   (cons res (lazy-seq\n                              (s-seq (inc lvl)\n                                     res\n                                     (->> res\n                                          (#(interleave % (repeat lvl)))\n                                          (apply hash-map)\n                                          (merge total)))))))]\n    (->> (cons [start] (s-seq 2 [start] {start 1}))\n         (take-while #(not (some (fn [x] (= x end)) %)))\n         count\n         inc)))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":106,"code":"(fn [x y]\n  (let [f (fn f [count xs fi]\n            (if (xs fi)\n              count\n              (let [make (fn [x] (if (odd? x)\n                                   (list (* x 2) (+ x  2))\n                                   (list (* x 2) (/ x 2) (+ x 2))))]\n                (recur (inc count) (set (flatten (map #(make %) xs))) fi))))]\n    (f 1 #{x} y)))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn [start end]\n  (letfn [(times2 [n] (* 2 n))\n          (div2 [n] (when (even? n) (/ n 2)))\n          (add2 [n]  (+ 2 n))\n          (number-maze' [[[node nr-of-steps] & paths-to-explore]]\n            (if (= node end)\n              nr-of-steps\n              (recur (concat paths-to-explore (map (fn [n] [n (inc nr-of-steps)]) (filter #(not (nil? %)) ((juxt add2 times2 div2 ) node)))))))]\n    (number-maze' [[start 1]])))","problem":106,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn maze [a b]\n   (let [J (juxt #(* 2 %) #(/ % 2) #(+ % 2))\n         nr (comp not ratio?)] \n     (second (first (filter #((first %) b) (iterate #(vector (set (filter nr (mapcat J (first %)))) \n                                                             (inc (second %)))  \n\t\t                                              [#{a} 1] ))))))","problem":106,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn [x y]\n  (inc\n    (count\n      (take-while\n        (complement #(% y))\n        (iterate\n          (fn [s]\n            (set\n              (flatten\n                (map\n                  (fn [i] \n                    (filter \n                      integer?\n                      (map #(% i 2) [* + /])))\n                  s))))\n          #{x})))))","problem":106,"user":"4db85282535d1e037afb218a"},{"problem":106,"code":"(fn [start end]\n  (let [d #(if (nil? %) nil (* % 2))\n        h #(cond (nil? %) nil\n                 (not= 0 (mod % 2)) nil\n                 :else (/ % 2))\n        a #(if (nil? %) nil (+ % 2))]\n    (loop [data #{start} c 1]\n      (if (data end)\n        c\n        (recur (set (mapcat #((juxt d h a) % ) data))\n               (inc c))))))","user":"5c2836ebe4b07e362c2305d4"},{"code":"(let [all-ops #{(partial * 2) (partial + 2)}\n        even-ops #{#(/ % 2)}\n\n        legal-ops (fn [n] (if (even? n)\n                            (clojure.set/union all-ops even-ops)\n                            all-ops))\n\n        reachable-from (fn [n] (map #(% n) (legal-ops n)))\n\n        expand (fn [s] (into s (mapcat reachable-from s)))\n\n        solve-maze (fn solve-maze\n                     ([n t] (solve-maze #{n} 1 t))\n                     ([s c t]\n                      (if (contains? s t)\n                        c\n                        (solve-maze (expand s) (inc c) t))))]\n    solve-maze)","problem":106,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":106,"code":"(fn min-path [a b]\n  (if (= a b)\n    1\n    (loop [branches [a]\n           level    2]\n      (let [res (reduce (fn [res curr]\n                          (let [new-branches (vec (for [x [\"*\" \"+\" \"/\"]\n                                                        :when (or (and (= x \"/\") (even? curr))\n                                                                  (not= x \"/\"))]\n                                                    (cond\n                                                      (= \"*\" x) (* 2 curr)\n                                                      (= \"+\" x) (+ 2 curr)\n                                                      (= \"/\" x) (/ curr 2))))]\n                            (if (some #(= b %) new-branches)\n                              (-> res\n                                  (assoc :present true)\n                                  (assoc :new-branches (concat (:new-branches res) new-branches)))\n                              (assoc res :new-branches (concat (:new-branches res) new-branches)))))\n                        {:present      false\n                         :new-branches []}\n                        branches)]\n        (if (:present res)\n          level\n          (recur (:new-branches res) (inc level)))))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":106,"code":"(fn [a b]\n  (letfn [(operations [nmb]\n          (->> (if (even? nmb) [+ * /] [+ *])\n            (map #(% nmb 2))))\n          (process [nums] (->> (mapcat operations nums) set))]    \n    (loop [results #{a}\n           steps 1]\n      (if (results b)\n        steps\n        (recur (process results) (inc steps))))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(fn maze [x z]\n  (loop [y [x] acc 1]\n    (cond\n     (some #(= z %1) y) acc\n     :else\n     (let [n (mapcat #(list (+ %1 %1) (+ 2 %1) (if (odd? %1) %1 (/ %1 2))) y)]\n       (recur n (inc acc))))))","problem":106,"user":"52140b53e4b0961f15ac4d7e"},{"problem":106,"code":"(fn [x y] (loop [doing #{x} n 1]\n(if (doing y)\nn\n(recur (clojure.set/union (set(map #(* 2 %)doing))(set(map #(+ 2 %)doing))(set(keep #(if(even? %)(/ % 2))doing))) (inc n)))\n))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn q106 [m n]\n  (letfn [\n     (next-nums [n]\n       (if (even? n) [(/ n 2) (* n 2) (+ n 2)] [(* n 2) (+ n 2)]))\n                 \n     (f [level visited nums]\n       (if (some #(= n %) nums) level\n         (let [new-visited (into visited nums)] (prn new-visited)\n           (->> (mapcat next-nums nums)\n                (remove new-visited)\n                (recur (inc level) new-visited))))) ]\n    (f 1 #{m} #{m})))","problem":106,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [a b]\n  (letfn [(ops [n] (list (if (even? n) (/ n 2) n) (* n 2) (+ n 2)))]\n  (loop [a #{a} n 1]\n    (if (some #(= % b) a)\n      n\n      (recur (set (mapcat ops a)) (inc n))))))","problem":106,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn [start end]\n  (let [children (fn [x d] (map (fn [a] {:num a :depth d}) \n                          (if (= 0 (mod x 2)) \n                            [(* 2 x) (+ x 2) (quot x 2)] \n                            [(* 2 x) (+ x 2)])))]\n    (loop [to-visit-queue (conj clojure.lang.PersistentQueue/EMPTY {:depth 1 :num start})]\n      (if (= (:num (peek to-visit-queue)) end)\n        (:depth (peek to-visit-queue))\n        (recur  (into (pop to-visit-queue) \n                  (children \n                    (:num (peek to-visit-queue))\n                    (inc (:depth (peek to-visit-queue))))))))))","problem":106,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn [a b] \n  (->> #{a}\n    (iterate \n      (fn [vs] \n        (set \n          (for [v vs, \n                o [#(* % 2) \n                   #(if (even? %) (/ % 2) %)\n                   #(+ % 2)]] \n            (o v)))))\n    (take-while #(not (% b))) \n    (count)\n    (inc)))","problem":106,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":106,"code":"(fn [a b]\n  (count (loop [res (list a)]\n           (if (= (first res) b) res\n             (recur (cons (cond (loop [x (first res)] (if (<= x b) (= x b) (recur (/ x 2)))) (/ (first res) 2)\n                                (and (= (mod (first res) 2) 0 ) (>= (first res) b) (not= (mod (/ (first res) 2) 2) (mod b 2))) (+ (first res) 2)\n                                (not= (mod (first res) 2) (mod b 2)) (* 2 (first res))\n                                (and (>= (first res) (* 2 b)) (= (mod (first res) 2) (mod b 2))) (/ (first res) 2)\n                                (and (>= (first res) b) (< (first res) (* 2 b))) (/ (first res) 2)\n                                (and (< (first res) b) (< b (* 2 (first res)))) (+ (first res) 2)\n                                :else (* 2 (first res))) res))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn num-maze [start end]\n   (let [ops {:double #(* % 2) :halve #(/ % 2) :add2 #(+ % 2)}\n         paths ((fn get-paths [old-paths]\n                  (lazy-seq (concat old-paths\n                                    (get-paths (mapcat (fn [old-path] (map #(conj old-path %) (keys ops))) old-paths))))) [[]])\n         works? (fn works? [n [op & others]] (if (nil? op)\n                                              (= n end)\n                                              (if (and (odd? n) (= op :halve))\n                                                false\n                                                (works? ((ops op) n) others))))]\n     (inc (count (first (drop-while #(not (works? start %)) paths))))))","problem":106,"user":"4e89f46c535d3e98b8023288"},{"problem":106,"code":"(fn [a b] (inc (count (take-while\n                       #(not (% b))\n                       (iterate (fn [a] (set (filter #(= % (int %)) (for [j a f [+ * /]] (f j 2)))))\n                                #{a})))))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn number-maze\n  [start end]\n  (letfn [(nm [nodes depth]\n            (if (some #{end} nodes) depth\n                (let [op (fn [i]\n                           [(* 2 i) (+ 2 i) (if (even? i) (/ i 2) [])])\n                      next (flatten (map op nodes))]\n                  (recur next (inc depth)))))]\n    (nm [start] 1)))","problem":106,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn [s f]\n  ((fn [v f i t]\n    (if (f t) i\n    (let [a \n        (clojure.set/difference\n  \t       (clojure.set/union \n           (->> f (map #(+ % 2)) set)\n           (->> f (map #(* % 2)) set)\n           (->> f (filter even?) (map #(/ % 2)) set)\n          )\n         v\n         f)\n        ]\n\t(recur (clojure.set/union v f) a (inc i) t) \n  ))) #{} #{s} 1 f)\n  )","problem":106,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [start goal]\n  (letfn [(next [paths]\n            (let [fs [(partial * 2)\n                      #(if (even? %) (quot % 2) %)\n                      (partial + 2)]\n                  dedup #(map first (vals (group-by first %)))]\n              (dedup (mapcat #(for [f fs] (conj % (f (first %)))) paths))))]\n    (let [solved (fn [paths]\n                   (when-let [path (first (filter #(= goal (first %)) paths))]\n                     (count path)))]\n      (some solved (iterate next [(list start)])))))","problem":106,"user":"50d93c53e4b0fd36a4b89223"},{"problem":106,"code":"(fn [s t]\n  (loop [que [[s 1]]]\n    (when-let [[c l] (last que)]\n      (if (= t c) l\n        (recur (conj (butlast que)\n                     [(* c 2) (inc l)]\n                     [(/ c 2) (inc l)]\n                     [(+ c 2) (inc l)]))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":106,"code":"(fn [s g]\n (let [f (juxt #(+ % 2) #(* % 2) #(if (even? %) (/ % 2) %))]\n  (loop [ns [s] c 1]\n   (if (some #{g} ns)\n    c\n    (recur (mapcat f ns) (inc c))))))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn n-maze [start end]\n  (let [doubl  #(* 2 %)\n        halve  #(if (odd? %) nil `(~(quot % 2)))\n        add2   #(+ 2 %)\n        ops    #(cons (doubl %) (cons (add2 %) (halve %)))]\n      (loop [xs [start], i 1]\n        (if (some #(= % end) xs) i\n          (recur (mapcat ops xs) (inc i))))))","problem":106,"user":"50e4f4e9e4b049a987753896"},{"problem":106,"code":"(fn number-maze\n  [s f]\n  (letfn [(next-paths [n]\n            (if (= 0 (mod n 2))\n              [(* 2 n) (+ 2 n) (/ n 2)]\n              [(* 2 n) (+ 2 n)]))]\n    (loop [current 1\n           paths #{s}]\n      (if (paths f)\n        current\n        (recur (inc current) (set (mapcat next-paths paths)))))))","user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn [a b] \n  (let [\n    children (fn [n] (if (even? n)  [(* n 2) (/ n 2) (+ n 2) ]  [(* n 2) (+ n 2) ] ))\n    next_generation (fn [s] (set (flatten (for [n s] (children n))))) \n  ]    \n    (loop [s #{a} n 1] (if-not (s b) (recur (next_generation s) (inc n))\n                                     n))))","problem":106,"user":"4e8b98fc535d65386fec2124"},{"problem":106,"code":"(fn [a b]\n  (loop [t #{a} len 1]\n    (if (contains? t b)\n      len\n      (recur (reduce (fn [s x] (into s (vector (+ x x) (+ x 2) (if (even? x) (/ x 2) x)))) #{} t)\n             (inc len)))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":106,"code":"(fn [a b]\n  (letfn [(fn-half [n] (if-not (odd? n) (/ n 2) n))\n          (fn-double [n] (+ n n))\n          (fn-add2 [n] (+ 2 n))\n          (gen-set [i col]\n                   [(inc i) (into #{} (remove nil? (flatten (map #((juxt fn-half fn-double fn-add2) %) col))))])]\n    (if (= a b)\n      1\n      (loop [[i coll] (gen-set 1 [a])]\n        (if (contains? coll b)\n          i\n          (do (println i \"========\" coll)\n              (recur (gen-set i coll))))))))","user":"5cf72682e4b0b71b1d808a68"},{"problem":106,"code":"(fn maze [from to] \n   ((fn walk-maze [coll]\n      (if (contains? coll to)\n        (get coll to)\n        (walk-maze (reduce (fn [y x]\n                             (apply conj y (for [f [#(if (odd? %) % (quot % 2))\n                                                         (partial * 2)\n                                                         (partial + 2)]] [(f (key x)) (inc (val x))]))) coll coll)))) {from 1}))","user":"56f15eade4b04a395b9a048e"},{"code":"(fn maze-path-length [entrance exit]\n  (let [children (fn [{:keys [level value]}]\n                   (let [values (filter identity \n                                        (cons \n                                          (when (even? value)\n                                            (/ value 2))\n                                          [(* 2 value) (+ 2 value)]))]\n                     (map (fn [x] {:level (inc level) :value x}) values)))]\n    (loop [queue (conj clojure.lang.PersistentQueue/EMPTY \n                       {:level 1 :value entrance})]\n      (when-let [node (peek queue)]\n        (if (= exit (:value node))\n          (:level node)\n          (recur (reduce conj (pop queue) (children node))))))))","problem":106,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn num-maze \n  ([a b] (num-maze 1 #{a} b))\n  ([counter as b]   \n   (if (as b)\n     counter\n     (recur (inc counter)\n            (reduce #(into % (->> [(* %2 2) (+ %2 2) (/ %2 2)]\n                                  (filter (fn [v] (= (int v) v))))) as as)\n            b)\n   )\n  ))","problem":106,"user":"513fab65e4b00f13ea1bd891"},{"problem":106,"code":"(fn number-maze\n  [start end]\n  (let [even-ops [#(/ % 2) (partial * 2) (partial + 2)]\n        odd-ops [(partial * 2) (partial + 2)]]\n    (->> [[start [start]]]\n         (iterate (partial mapcat (fn [[current path]]\n                                    (map (fn [f]\n                                           (let [n (f current)]\n                                             [n (conj path n)]))\n                                         (if (even? current)\n                                           even-ops\n                                           odd-ops)))))\n         (mapcat (partial keep (fn [[current path]]\n                                 (when (= current end)\n                                   path))))\n         first\n         count)))","user":"4dc0ff08535d020aff1edf84"},{"problem":106,"code":"(fn fun [start end]\n  (let [openings (fn [n] (set (remove nil? (list (* n 2) (if (even? n) (/ n 2)) (+ n 2)))))\n        next-paths (fn [s] (apply clojure.set/union (map openings s)))\n        next-iteration (fn [[length paths]] [(inc length) (next-paths paths)])]\n    (if (= start end) 1\n        (+ 2 (first (last (take-while #(not (contains? (last %) end)) (iterate next-iteration [0 #{start}]))))))))","user":"5e13a6b7e4b099d064963001"},{"code":"(letfn [(N [f s]\n          (concat (rest s)\n                  (f (first s))))\n\n        (X [f s]\n          (cons s (lazy-seq (X f (N f s)))))\n\n        (X' [f s seen? k]\n          (if (seen? (k (first s)))\n            (X' f (rest s) seen? k)\n            (cons s (lazy-seq (X' f (N f s) (conj seen? (k (first s))) k)))))\n\n        (S [f n]\n          (map first (X' f [n] #{} first)))\n\n        (M [n]\n          (if (even? n)\n            [(* n 2) (/ n 2) (+ n 2)]\n            [(* n 2) (+ n 2)]))\n\n        (M' [[a c]]\n          (map #(vector % (inc c)) (M a)))\n\n        (G? [b]\n          (fn [[a c]]\n            (= a b)))\n\n        (P [a b]\n          (->> (S M' [a 1])\n               (drop-while (complement (G? b)))\n               first\n               second))]\n  \n  P)","problem":106,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [a b]\n  (letfn [\n    (add-steps [steps]\n      (reduce \n        (fn [steps step]\n          (conj \n            (if (== 0 (rem step 2)) \n              (conj steps (/ step 2)) \n              steps)\n            (* 2 step) \n            (+ 2 step)))\n        steps\n        steps))\n    (dis [ns b]\n      (if (contains? ns b) 1\n        (inc (dis (add-steps ns) b))))]\n    (dis #{a} b)))","problem":106,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [x y]\n  (loop [d #(* 2 %)\n         h #(/ % 2)\n         a #(+ % 2)\n         ns #{x}\n         c 1]\n    (if (contains? ns y)\n      c\n      (recur d h a\n        (set (filter integer? (mapcat #(map %1 %2) [d h a] (repeat ns))))\n        (inc c)))))","problem":106,"user":"5201572be4b0d7096e99ddbb"},{"problem":106,"code":"(fn [x1 x2]\n  (loop [n 0\n         res #{x1} ]\n    (if (contains? res x2)\n      (inc n)\n      (let [res-1 (map #(* % 2) res)\n            res-2 (map #(/ % 2) (filter even? res))\n            res-3 (map #(+ % 2) res)]\n        (recur (inc n) (into #{} (concat res-1 res-2 res-3)))))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":106,"code":"#(loop [[[current path] & r] [[% 1]]]\n   (if (= current %2)\n     path\n     (let [ip (inc path)] (recur (conj (vec (if (odd? current)\n                                              r\n                                              (conj r [(/ current 2) ip])))\n                                       [(+ current 2) ip]\n                                       [(* current 2) ip]\n                                       )))))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn shortest-path [start end]\n  (loop [cnt 1\n         at [start]]\n    (if (some #{end} at)\n      cnt\n      (recur (inc cnt)\n             (mapcat #(concat (list (+ 2 %))\n                              (list (* 2 %))\n                              (if (even? %)\n                                (list (/ % 2))\n                                ()))\n                     at)))))","problem":106,"user":"530578ede4b0d8b024fd3760"},{"problem":106,"code":"(fn minPath [x y]\n  (let [adj #(if (odd? %) [(+ % 2) (* % 2)] [(+ % 2) (* % 2) (/ % 2)])]\n    (loop [found #{x} n 1]\n      (if (contains? found y)\n        n\n        (recur (set (mapcat adj found)) (inc n))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":106,"code":"(fn [start end]\n  (let\n    [\n     children\n     (fn [[n0 & rest :as path]]\n       (->>\n        [(+ 2 n0) (* 2 n0)]\n        (#(if (even? n0) (conj % (/ n0 2)) %))\n        (remove #((set rest) %))\n        (map #(conj path %))\n       ))\n       \n     bfs-seq\n     (fn walk [queue]\n       (let [node (peek queue)]\n         (lazy-seq\n           (cons node (walk (into (pop queue) (children node)))))\n     ) )\n  ]\n    (->>\n     start\n     list\n     (conj clojure.lang.PersistentQueue/EMPTY)\n     bfs-seq\n     (filter #(= end (first %)))\n     first\n     count\n     )\n  ) )","user":"5281a445e4b0757a1b17143a"},{"code":"(fn [start end]\n    (loop [tried #{}\n           depth 1\n           cands [start]]\n      (if (some #{end} cands)\n        depth\n        (let [next-nums (mapcat (juxt #(* 2 %)\n                                      #(/ % 2)\n                                      #(+ 2 %))\n                                (filter #(and (integer? %)\n                                              (not (tried %))) cands))]\n          (recur (into tried cands)\n                 (inc depth)\n                 next-nums)))))","problem":106,"user":"50bca033e4b0594b91591c5d"},{"problem":106,"code":"(fn maze [init end]\n\t(loop [n 1 paths [init]]\n\t\t(if (some #(= % end) paths)\n\t\t\tn\n\t\t\t(recur (inc n)\n\t\t\t\t(flatten\n\t\t\t\t(map\n\t\t\t\t\t(fn [x]\n\t\t\t\t\t\t(filter identity \n\t\t\t\t\t\t\t[(* x 2) (+ x 2) (if (even? x) (/ x 2))]))\n\t\t\t\t\tpaths))))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [a b]\n  (loop [c [a]\n        i 1]\n    (if (.contains c b)\n  i (recur\n      (flatten (map #(list (+ % 2) (* % 2) (/ % 2)) c))\n    (+ 1 i)))\n  ))","problem":106,"user":"4e43b0d9535dc968683fc4a3"},{"problem":106,"code":"(fn [x y]\n    (let [m Integer/MAX_VALUE\n          path (atom 10)]\n      ((fn step [i n]\n         (let [f (partial step (inc i))]\n           (if (or (= n y) (>= i @path))\n             (reset! path i)\n             (min (f (* n 2))\n                  (if (even? n) (f (/ n 2)) m)\n                  (f (+ 2 n))))))\n       1 x)))","user":"4f57c913e4b0a7574ea7183f"},{"problem":106,"code":"(fn countPath [start end] (letfn [(applyOp [number op] (cond\n                                                                (= op :double) (* number 2)\n                                                                (and (= op :halve) (even? number)) (/ number 2)\n                                                                (= op :add2) (+ number 2)\n                                                                :else nil))\n\n                                    (applyOps [number ops] (for [op ops] (applyOp number op)))]\n                              (let [ops #{:double :add2 :halve}]\n                              (loop [step 1 todo (list start :step)] (let [cand (first todo)]\n                                                                       (cond\n                                                                         (= cand end) step\n                                                                         (nil? cand) (recur step (rest todo))\n                                                                         (= cand :step) (recur (inc step) (rest (conj (into [] todo) :step)))\n                                                                         :else (recur step (concat (rest todo) (applyOps cand ops)))))))))","user":"56427910e4b08d4f616f5f19"},{"code":"(fn [start end]\n  (letfn [(dist [x end]\n              (if (= end x)\n                0   ;; one step away\n                (if (or (= end (+ x 2))\n                        (= end (* x 2))\n                        (= end (/ x 2)))\n                  1\n                  -1)))\n\n          (add-one [x v]\n            (let [x2 (* 2 x) x22 (+ 2 x2) x1 (/ x22 2)]\n              [x1 (conj v x x2 x22)]))\n  \n          (half-odd [x v end]\n            (let [[x1 v1] (add-one x v)]\n              (half-even x1 v1 end)))\n\n          (half-even [x v end]\n            ;; when counting down, consider the dist to end between \n            ;; half, add 2 half, ensure we can continue recuring on \n            ;; half by selecting the even half between half and add 2 half\n            (let [xh (/ x 2) xh1 (/ (+ x 2) 2) d (dist xh end)]\n              (if (= 0 d)\n                [xh (conj v x end) d]\n                (if (= 1 d)\n                  [xh (conj v x xh end) d]\n                  (if (= 0 (dist xh1 end))\n                    [xh1 (conj v x (+ x 2) end)]\n                    (if (> xh end)\n                      (if (even? xh)  ;; recur on the half that is even\n                        (half-even xh (conj v x) end)\n                        (half-even xh1 (conj v x (+ x 2)) end))))))))\n\n          (double-up [x v end]\n            ;; double up or add two, mono increasing\n            (let [dbx (* x 2) x2 (+ x 2) d (dist x end)]\n              (if (= 0 d)\n                [x (conj v x)]\n                (if (= 1 d)\n                  [x (conj v x end)]\n                  (if (< dbx end)\n                    (double-up dbx (conj v x) end)\n                    (if (= 1 (- end x))\n                      [(inc x) (conj (second (add-one x v)) end)]\n                      (double-up x2 (conj v x) end)))))))]\n  (if (<= start end)\n    (count (second (double-up start [] end)))\n    (if (odd? start)\n      (count (second (half-odd start [] end)))\n      (count (second (half-even start [] end)))))))","problem":106,"user":"513cb853e4b0b86ece9f322b"},{"problem":106,"code":"(fn number-maze [origin destination]\n  (letfn [(doubl-it [x] (* x 2))\n          (halve-it [x] (if (even? x)\n                          (/ x 2) nil))\n          (minus2-it [x] (- x 2))]\n    (loop [ds [destination] mem #{destination} path-count 0]\n      (if (some #(= % origin) ds)\n        (inc path-count)\n        (recur\n         (->> ds\n              (map (fn [x] (filter\n                           #(and (not (nil? %)) (not (mem %)))\n                           [(doubl-it x) (halve-it x) (minus2-it x)])))                (apply concat))\n         (clojure.set/union mem (into #{} ds))\n         (inc path-count))))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":106,"code":"(fn solve [x y]\n  (let [ne (fn [x]  (if (odd? x) [(* x 2)  ( + 2 x)] [(* x 2)  ( + 2 x) (quot x 2)]))\n        bfs (fn rec [q head visited]\n              (if-let [dist (get visited y)]\n                dist\n                (let [cur (nth q head)\n                      d (get visited cur)\n                      nxt (remove visited (ne cur))\n                      new-visited (merge visited (zipmap nxt (repeat (inc d))))]\n                  (if (contains? new-visited y)\n                    (get new-visited y)\n                    (rec (into q nxt) (inc head) new-visited)))))]\n    (bfs [x] 0 {x 1})))","user":"56f258d3e4b04a395b9a04a1"},{"code":"(fn [b e]\n     (letfn [(f [s] (set (mapcat #(if (nil? %) nil [(* 2 %) (+ 2 %) (if (even? %) (/ % 2))]) s)))]\n\t\t  (inc (count (take-while #(nil? (% e)) (iterate f #{b}))))))","problem":106,"user":"4dae4da5c9a9d6ed4e99dc57"},{"code":"(fn __ \n\t([f l] (if (= f l) 1 (__ f l [[f]])))\n\t([f l c] \n\t\t\t(let [nf (fn nf [n] \n\t\t\t\t\t\t(if (odd? n) \n\t\t\t\t\t\t\t[ (+ n 2) (* n 2)] \n\t\t\t\t\t\t\t[ (/ n 2) (+ n 2) (* n 2)] \n\t\t\t\t\t\t\t))\n\t\t\t\t  nn (filter #(not (nil? %)) (apply concat \n\t\t\t\t\t\t\t\t\t\t(for [ac c] \n\t\t\t\t\t\t\t\t\t\t\t(map \n\t\t\t\t\t\t\t\t\t\t\t\t(fn [an] \n\t\t\t\t\t\t\t\t\t\t\t\t\t(when (every? #(not= an %) ac) (conj ac an))) \n\t\t\t\t\t\t\t\t\t\t\t\t(nf (last ac)))\n\t\t\t\t\t\t\t\t\t\t\t\t)))\n\t\t\t\t  fnn (filter #(= l (last %)) nn)]\n\t\t\t\t  (if (empty? fnn)\n\t\t\t\t  \t(__ f l nn)\n\t\t\t\t  \t(count (first fnn)))\t\t\t\t\t\t\n\t\t\t\t)\n\t\t)\n\t)","problem":106,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [s e]\n  (loop [c [s] i 1]\n    (if (some #{e} c)\n      i\n      (recur (mapcat #(if % [(* 2 %) (+ 2 %) (if even? (/ % 2))]) c)\n             (+ 1 i)))))","problem":106,"user":"4e49badd535dc968683fc4c9"},{"problem":106,"code":"(fn [x y]\n  (loop [d 1\n         c #{x}]\n    (if (c y)\n      d\n      (recur (+ d 1)\n             (reduce #(conj %\n                            (+ %2 2)\n                            (* %2 2)\n                            (if (odd? %2)\n                              x\n                              (/ %2 2)))\n                     c\n                     c)))))","user":"51ad244fe4b09397d510977f"},{"code":"(fn [x y]\n  (loop [q (conj (clojure.lang.PersistentQueue/EMPTY) [x 1])\n         visited #{}]\n    (let [[x n] (peek q)\n          q (pop q)]\n      (cond\n        (= x y) n\n        (visited x) (recur q visited)\n        :else (let [neighs (concat [(* x 2)\n                                    (+ x 2)]\n                                   (when (even? x)\n                                     [(/ x 2)]))]\n                (recur (into q (for [neigh neighs]\n                                 [neigh (inc n)]))\n                       (conj visited x)))))))","problem":106,"user":"50a83315e4b054305ba5a830"},{"problem":106,"code":"(fn [a b]\n   (loop [l #{a} n 1]\n     (if (some #{b} l) n\n       (recur (reduce (fn [c e]\n                        (into c (map #(% e 2)\n                                     (if (even? e) [+ * /]\n                                       [+ *]))))\n                      l l) (inc n)))))","user":"57d9f603e4b0bd073c20240a"},{"problem":106,"code":"(fn f \n  ([x t] (f #{x} #{} t))\n  ([xs ys t]\n   (if (xs t)\n     1\n     (let [ys (apply conj ys xs)\n           xs (set (filter #(and (not (ratio? %)) (not (ys %))) \n                      (mapcat (juxt #(+ % 2) #(/ % 2) #(* % 2)) xs)))]\n       (+ 1 (f xs ys t))))))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn [start end]\n  (letfn [(x2 [x] (* x 2))\n          (halve [x] (/ x 2))\n          (add2 [x] (+ x 2))\n          (get-fns-list [curr-num path-len]\n            (if (odd? curr-num)\n              [[curr-num x2 path-len] [curr-num add2 path-len]]\n              [[curr-num x2 path-len] [curr-num halve path-len] [curr-num add2 path-len]]))]\n    (loop [seen-nums #{start}\n           [[curr-num op path-len] & ops-rest] (get-fns-list start 1)]\n      (if (= curr-num end)\n        path-len\n        (let [new-num (op curr-num)\n              new-len (inc path-len)]\n          (if (seen-nums new-num)\n            (recur seen-nums ops-rest)\n            (recur (conj seen-nums new-num)\n                   (concat ops-rest (get-fns-list new-num new-len)))))))))","problem":106,"user":"53070615e4b02e821686979e"},{"code":"(fn number-maze [from to]\r\n  (loop [from #{from}, i 1]\r\n    (if (contains? from to) i\r\n        (recur (into #{} (concat (map #(* % 2) from)\r\n                                 (keep #(when (even? %) (quot % 2)) from)\r\n                                 (map #(+ % 2) from))) (inc i)))))","problem":106,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn maze [now target]\n  (letfn [ (gen-next2 [node]\n              (let [{:keys [now hist]} node \n                    now2 (* now 2)\n                    nowplus (+ now 2)]\n               (if (even? now)\n                 [{:now now2 :hist (conj hist now2)}\n                  {:now nowplus :hist (conj hist nowplus)}\n                  {:now (/ now 2) :hist (conj hist (/ now 2))}]\n                 [{:now now2 :hist (conj hist now2)}\n                  {:now nowplus :hist (conj hist nowplus)}])))]\n  (let [node {:now now :hist [now]}]\n    (loop [ns [node]]\n      (let [ks (filter (fn [n] (= target (:now n))) ns)]\n        (if (empty? ks)\n          (recur (apply concat (map gen-next2 ns)))\n          (count (:hist (first ks)))))))))","problem":106,"user":"4dd62278535d2dad7130b5c7"},{"problem":106,"code":"(fn task-106 [start finish]\n  ((fn next-move [xs known depth]\n     (if-let [answer (known finish)]\n       answer\n       (let [next-move1 (fn [n] (map (fn [f] (f n)) (concat [#(* 2 %) #(+ 2 %)] (if (even? n) [#(/ % 2)]))))\n             next (mapcat next-move1 xs)]\n         (recur\n          next\n          (->>\n           (for [n next :when (nil? (known n))]\n             [n depth])\n           (into known))\n          (inc depth))))) [start] {start 1} 2))","user":"4ddb696b535d02782fcbe9fa"},{"problem":106,"code":";; This is a special case of dyjksta's shortest path.\n;; This implementation of dsp is MORE than needed, \n;; specifically we don't need per-node costs. \n;; (All costs to change nodes in the problem here are equal)\n;; Regardless, I've made dsp solution with costs in the expectation\n;; that SOME future puzzle will be use weighted node transitions\n\n(let [\n ops [ #(/ % 2) #(+ 2 %1) #(* 2 %1)]\n\n; ncost (fn ncost [n] \n;   (as-> ((apply juxt ops) n) $\n;   (filter integer? $)\n;   (for [i $] [0.001 i] )\n;   ))\n\nncost (fn ncost [n] (let \n  [$ ((apply juxt ops) n)\n  $ (filter integer? $)\n  $ (for [i $] [1 i] )\n  ] $))\n\nshortest-path (fn \n  [start ;; node\n  end ;; node\n  cn ;; (fn node)=>[[cost neighborNode]...]\n  ]\n\n  (loop [\n    front (sorted-set [0 start] ) ;; [cost node]\n    solved {start [0 nil] } ;; {toNode [cost fromNode]}\n    ]\n    (cond\n       ; (println \"------------------\") nil\n       ; (println :front front) nil\n       ; (println :solved solved) nil\n      (empty? front) []\n      (solved end)\n        ; We build the solution path by \n        ; starting at the end, then looking\n        ; up each step from the solution table\n        ; (giving us [endNode ... startNode],\n        ; which is reversed as a final step. )\n        \n        (->> end\n        (iterate  #(get-in solved [% 1] ))\n        (take-while (complement nil?))\n        (reverse)\n        )\n      :else\n      (let [\n        [cost node :as head] (first front)\n         ; _ (pp :cost cost :node node :next (cn node))\n\n        next (into {}\n          (for [[c n] (cn node)] ;; [[cost neighbor]...]\n             [n [(+ cost c) node]] ))\n\n        ; _ (pp :next next)\n\n        solvedNext (merge-with #(first (sort [%1 %2]))\n          solved next )\n\n        ; _ (pp :solvedNext solvedNext)\n\n        prune (for [[to [cost from :as cn]] next\n          :when (= cn (get solvedNext to)  ) ]\n          [cost to])\n\n        ; _ (pp :prune prune )\n\n        frontNext (into\n          (disj front head)\n          prune )\n\n        ; _ (pp :frontNext frontNext)\n\n        ]\n        (recur\n          frontNext\n          solvedNext\n        )))))\n]\n#(count (shortest-path %1 %2 ncost) )\n)","user":"533a2f7be4b0e30313ee6cb8"},{"problem":106,"code":"(fn [start end]\n  (letfn [(maze-next [chains]\n            (mapcat (fn [chain]\n                      (let [e (last chain)\n                            always [(conj chain (* 2 e)) (conj chain (+ 2 e))]]\n                        (if (even? e)\n                          (cons [conj chain (quot e 2)] always)\n                          always))) chains))]\n    (inc (count (take-while\n                 #(empty? (filter (partial some #{end}) %))\n                 (iterate maze-next [[start]]))))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":106,"code":"(fn [x-i y]\n  (letfn [(spread [x]\n            (concat (if (even? x) [(/ x 2)]) [(* 2 x) (+ 2 x)]))]\n    (loop [i 1 xs [x-i]]\n      (if (some (partial = y) xs)\n        i\n        (recur (inc i) (mapcat spread xs))))))","user":"567d132ee4b05957ce8c61c3"},{"problem":106,"code":"(fn f \n  ([x y] (f y 1 #{x}))\n  ([y len moves] \n    (if (contains? moves y)\n      len\n      (letfn [(gen-moves [moves]\n                (set (mapcat #(remove ratio? [(* 2 %)(+ 2 %)(/ % 2)]) moves)))]\n        (f y (inc len) (gen-moves moves))))))","user":"55ecb2c0e4b0121d4835fdce"},{"code":"(fn number-maze-path [start-point end-point]\n\t(letfn [(next-points [a-point]\n\t\t\t\t(map #(% a-point 2) (if (even? a-point) [* / +] [* +]))\n\t\t\t) (calc-next-layer [points]\n\t\t\t\t(mapcat next-points points)\n\t\t\t)]\n\t\t(loop [curr-layer [start-point] cnt 1]\n\t\t\t(println \"curr-layer\" curr-layer \"cnt\" cnt)\n\t\t\t(if (some #(= end-point %) curr-layer)\n\t\t\t\tcnt\n\t\t\t\t(recur (calc-next-layer curr-layer) (inc cnt))\t\n\t\t\t)\n\t\t)\n\t)\n)","problem":106,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn [s e]\n  (loop [c 1\n         s [s]]\n    (if (some #{e} s)\n      c\n      (recur (+ c 1) (mapcat #(list (* % 2) (/ % 2) (+ % 2)) s)))))","problem":106,"user":"536e0930e4b0fc7073fd6e66"},{"problem":106,"code":";; NOTE: Hopefully inefficient. No need to generate combos up front like this.\n(fn maze[start target]\n  (letfn [(double-it [n] (+ n n))\n          (half [n] (if (even? n) (/ n 2) n))\n          (add-two [n] (+ n 2))\n          (my-comp [n fs cnt]\n            (cond\n              (empty? fs) Integer/MAX_VALUE ;; not found\n              (= target n) cnt ;; found it!\n              :else (my-comp ((first fs) n) (rest fs) (inc cnt))))]\n    (let [fs [double-it half add-two]\n          combos-1 (for [a fs b fs c fs] [a b c])\n          combos-2 (for [a fs b fs c fs d fs e fs f fs g fs h fs i fs] [a b c d e f g h i])\n          quick-find (apply min\n                            (map #(my-comp start % 1) combos-1))\n          slow-find (fn [] (apply min\n                                 (map #(my-comp start % 1) combos-2)))\n          ]\n\n      (if (< quick-find Integer/MAX_VALUE)\n        quick-find\n        (slow-find)))))","user":"56069006e4b08b23635d3174"},{"problem":106,"code":"(fn [init goal]\n  (loop [ll #{init}\n         lled #{}\n         cache {init 1}]\n    (cond (cache goal) (cache goal)\n          :else\n          (let [current (apply min ll)\n                clength (inc (cache current))\n                nexts (filter #(and (integer? %)\n                                    ((complement contains?) cache %))\n                              (list (* 2 current)\n                                    (+ 2 current)\n                                    (/ current 2)))\n                next_cache (reduce (fn [acc e] (assoc acc e clength))\n                                   cache\n                                   nexts)]\n            (recur (clojure.set/difference (into (disj ll current) nexts)\n                                           lled)\n                   (conj lled current)\n                   next_cache)))\n    ))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":106,"code":"(fn dist[a b] (\n      (fn d[c s] (\n                   if (contains? s b)\n                      c\n                      (d (inc c) (reduce #(conj %1 (* %2 2) (/ %2 2) (+ %2 2) ) s s))\n                     )\n                   ) 1 #{a}\n\n      ))","user":"596f6683e4b069c0a1a19877"},{"problem":106,"code":"(fn [s e]\n  (let [expand (fn [n]\n                 (into [(* n 2) (+ n 2)] (when (= (rem n 2) 0) [(/ n 2)])))\n        search (fn search [paths]\n                 (let [[n l] (first paths)]\n                   (if (= n e)\n                     l\n                     (search (into (vec (rest paths))\n                              (map #(vec [% (inc l)]) (expand n)))))))]\n    (search [[s 1]])))","user":"50f10f7be4b06d9538fe211a"},{"problem":106,"code":"(fn [f t]\n  (loop [q (-> (clojure.lang.PersistentQueue/EMPTY) (conj [f 1])) visited #{}]\n    (let [[current depth] (first q)]\n      (if (= current t)\n        depth\n        (let [depth' (inc depth)\n              n1 (* current 2)\n              n2 (+ current 2)\n              n3 (/ current 2)\n              neighbours (-> ()\n                             (#(if (visited n1) % (conj % [n1 depth'])))\n                             (#(if (visited n2) % (conj % [n2 depth'])))\n                             (#(if (or (odd? current) (visited n3)) % (conj % [n3 depth']))))]\n          (recur (into (pop q) neighbours) (conj visited current)))))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":106,"code":"(fn [s e]\n  (letfn [(f [v]\n             (flatten (for [x v\n                            :let [u [(* x 2) (+ x 2) (/ x 2)]\n                                  c (if (even? x) 3 2)]]\n                        (take c u))))\n          \n          (g [s e v l]\n             (if (v e) l\n               (let [u (set (f v))\n                     k (inc l)]\n                 (recur s e u k))))]\n    (g s e #{s} 1)))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn\n  [s e]\n  (let [q (java.util.LinkedList.)]\n    (.add q [s 1])\n    (loop []\n      (let [[n len] (.poll q)]\n        (if (= n e)\n          len\n          (do\n            (.add q [(* 2 n) (inc len)])\n            (.add q [(+ 2 n) (inc len)])\n            (when (even? n)\n              (.add q [(quot n 2) (inc len)]))\n            (recur)))))))","problem":106,"user":"4db53f87535d87e67b28fe08"},{"problem":106,"code":"(fn [f t]\n  (loop [from #{f} length 1]\n    (if (contains? from t)\n        length\n      (recur \n       (set\n        (concat;\n         (map (partial + 2) from)\n         (map (partial * 2) from)\n         (map #(/ % 2) (filter even? from))))\n          (inc length)))))","user":"55896a0ce4b059ccff29b204"},{"problem":106,"code":"(fn shortest-path [start-num end-num]\n  (letfn [(extensions [n]\n            (let [values (into #{} (list (+ n 2) (* n 2)))]\n              (if (odd? n) values (conj values (/ n 2)))))]\n    (loop [horizon #{start-num}\n           length 1]\n      (if (horizon end-num)\n        length\n        (recur (into #{} (mapcat extensions horizon)) (inc length))))))","user":"58ed713de4b056aecfd47d84"},{"problem":106,"code":"(fn path [start target]\n  (letfn [ (process [routes]\n             (let [head (first routes)\n                   tail (rest routes)\n                   cval (last head)]\n               (if (= target cval)\n                 head\n                 (let [nvals (concat [(+ 2 cval)]\n                                     [(* 2 cval)]\n                                     (if (even? cval)\n                                       [(/ cval 2)]\n                                       []))\n                       nroutes (map #(conj head %) nvals)\n                       ]\n                   (recur (concat tail nroutes))))))\n           ]\n    (count (process [[start]]))))","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn [start end]\n  (letfn [(next-steps [n] (concat [(* 2 n) (+ 2 n)]\n                                  (if (even? n) [(/ n 2)])))]\n    (loop [queue [[start]]]\n      (let [[path & queue] queue\n            n (last path)]\n        (if (= n end)\n          (count path)\n          (let [next-paths (map #(conj path %) (next-steps n))\n                next-queue (concat queue next-paths)]\n            (recur next-queue)))))))","problem":106,"user":"4e80aa10535db62dc21a62b1"},{"code":"(fn [start end]\n  (letfn [(increase-path [v1 end nstep]\n                         (cond (= v1 end) nstep\n                               (<= (* 2 v1) end) (increase-path (* 2 v1) end (inc nstep))\n                               (even? (- end v1)) (+ nstep (/ (- end v1) 2))\n                               (odd? (- end v1)) (+ nstep 3 (/ (- (dec end) v1) 2))))\n          (increase-path2 [v1 end nstep] ; allow to decrease 2 instead\n                         (cond (= v1 end) nstep\n                               (<= (* 2 v1) end) (increase-path2 (* 2 v1) end (inc nstep)) \n                               :else (let [s (quot (- (* 2 v1) end) 4)\n                                           v2 (* 2 (- v1 (* 2 s)))]\n                                       (if (odd? (- v2 end)) (+ nstep s 1 3 (/ (- (dec v2) end) 2))\n                                         (+ nstep s 1 (/ (- v2 end) 2))))))]\n    (if (<= start end) (increase-path start end 1)\n      (increase-path2 end start 1))))","problem":106,"user":"51780f88e4b03d69594194c9"},{"problem":106,"code":"(fn [start end]\n  (loop [starts #{start}\n         steps 1]\n    (if (contains? starts end)\n      steps\n      (let [next-starts (->> (for [s starts]\n                               `[~(* 2 s)\n                                 ~(+ 2 s)\n                                 ~@(when (even? s)\n                                     [(/ s 2)])])\n                             (apply concat)\n                             set)]\n        (recur next-starts (inc steps))))))","user":"4ff24a1ae4b0678c553fc337"},{"code":"(fn [start end]\n  (loop [queue [[start 1]]\n         visited #{}]\n    (let [[[v c] & r] queue\n          nc (inc c)\n          vs (conj visited v)\n          next (remove vs [(+ 2 v) (* 2 v) (if (even? v) (/ v 2) v)])]\n      (if (= end v) \n        c\n        (recur (concat r (map (fn [x] [x nc]) next)) vs)))))","problem":106,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn [f t]\n  (loop [from #{f} length 1]\n    (if (contains? from t)\n        length\n      (recur \n        (set \n          (concat \n            (map (partial + 2) from)\n            (map (partial * 2) from)\n            (map #(/ % 2) (filter even? from))))\n              (inc length)))))","problem":106,"user":"507fbd77e4b089ade05efbd3"},{"problem":106,"code":"(fn [a b]\n   (let [step (if (< a b) 1 -1)\n         max-path (conj (into [] (cons a (range (* 2 a) (* 2 (+ step b)) (* 2 step)))) b)\n         get-min (fn [coll]\n                   (if-not (empty? coll)\n                     (reduce (fn [xa xb]\n                               (if (> (count xa) (count xb))\n                                 xb xa)) coll)\n                     nil))\n         maze (fn maze [x y path]\n                (cond\n                  (> (count path) (count max-path)) nil\n                  (= x y) (conj path x)\n                  :else (->> (conj path x)\n                             ((fn [coll]\n                                (let [three-coll (if (odd? x) nil (maze (/ x 2) y coll))]\n                                  (vector (maze (+ 2 x) y coll)\n                                          (maze (* 2 x) y coll)\n                                          three-coll))))\n                             (filter (complement nil?))\n                             (get-min))))]\n\n     (count (maze a b []))))","user":"591072e0e4b0163c97b36ebc"},{"code":"(fn r \n  ([a b] (r a b 1))\n  ([a b c]\n      (cond (= a b) c\n            (< a b) \n              (if (or (<= (* 2 a) b)\n                      (>  (+ a 2) b))\n                (r (* 2 a) b (inc c))\n                (r (+ a 2) b (inc c)))\n            (> a b)\n              (if (= 1 (mod a 2))\n                (r (* a 2) b (inc c))\n                (if (and (= 1 (mod (quot a 2) 2))\n                         (not= b (quot a 2)))\n                  (r (+ a 2) b (inc c))\n                  (r (quot a 2) b (inc c)))))))","problem":106,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":106,"code":"(fn shortest-path [s e]\n  (loop [ps [[s]]]\n    (if (some (fn [x] (= e (last x))) ps)\n      (count (first ps))\n      (recur (filter (complement nil?)\n                     (for [p ps\n                           f [#(+ % 2)\n                              #(* % 2)\n                              #(if (zero? (rem % 2)) (/ % 2) nil)]]\n                       (let [n (f (last p))]\n                         (if (nil? n)\n                           nil\n                           (conj p n)))))))))","user":"58bb218be4b0888cdc949cf4"},{"code":"(fn [f t]\n    (let [step (fn [n] (let [l (list (+ 2 n) (* 2 n))] (if (even? n) (cons (quot n 2) l) l)))]\n      (->> f\n        (list) (set)\n        (iterate #(set (mapcat step %)))\n        (take-while #(not (contains? % t)))\n        (count) (inc))))","problem":106,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn [start goal]\n   (let\n     [gen-moves (fn [m c] (let [ic (inc c)\n                                mv [[(+ m 2) ic] [(* m 2) ic]]]\n                          (if (even? m)\n                            (cons [(/ m 2) ic] mv)\n                            mv)))]\n      (loop [mv [[start 1]]]\n        (let [[nxt num] (first mv)]\n          (if (= nxt goal)\n            num\n            (recur (concat (rest mv) (gen-moves nxt num))))))))","problem":106,"user":"4fc0853ae4b081705acca327"},{"code":"(fn shortest [start end]\n  ((fn shortcount [start answer]\n    (cond\n     (= start end) answer\n     (>= answer 12) 9999\n     :else (min (shortcount (* start 2) (inc answer))\n          (if (odd? start) 9999 (shortcount (/ start 2) (inc answer)))\n          (shortcount (+ start 2) (inc answer))))\n    ) start 1)\n  )","problem":106,"user":"525372ade4b0541d1855b8f3"},{"code":"(fn [a b]\n  (loop [n [a] l 1]\n    (if (some #(= % b) n)\n      l\n      (recur \n        (concat \n          (map #(* % 2) n) \n          (map #(if (even? %) (/ % 2) %) n) \n          (map #(+ % 2) n))\n        (inc l)))))","problem":106,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [start end]\n   (letfn [(next-tuples [n step seen]\n             (let [s (inc step)]\n               (filter (fn [[x _]] (not (seen x)))\n                       (if (even? n)\n                         [[(* n 2) s] [(/ n 2) s] [(+ n 2) s]]\n                         [[(* n 2) s] [(+ n 2) s]]))))\n           (work-queue [queue seen]\n             (let [[[n step] & q] queue]\n               (if (= n end)\n                 step\n                 (recur (concat q (next-tuples n step seen)) (conj seen n)))))]\n     (work-queue [[start 1]] #{})))","problem":106,"user":"4ea1b9e4535d7eef308072b8"},{"problem":106,"code":"(fn number-maze [start end]\n   (letfn\n       [(succ [x] (if (even? x)\n                    [(/ x 2) (* x 2) (+ x 2)]\n                    [(* x 2) (+ x 2)]))\n        (succ* [xs] (->> xs\n                         (map succ)\n                         (map set)\n                         (reduce clojure.set/union #{})))]\n     (loop [i 1\n            state #{start}]\n       (if (state end) i\n           (recur (inc i)\n                  (succ* state))))))","user":"5d4b2155e4b0776584bd6f28"},{"problem":106,"code":"(fn m ([s e] (m #{s} e 1))\n      ([s e n]\n       (if (contains? s e) n\n         (let [z (fn [v]\n                   (if (even? v)\n                     #{(* v 2) (+ v 2) (/ v 2)}\n                     #{(* v 2) (+ v 2)}))\n          sx (reduce #(into %1 (z %2)) s s)]\n         (m sx e (inc n))))))","user":"56bca51ae4b0f26550335963"},{"problem":106,"code":"(fn [a b]\n  (loop [q [[a 1]]\n         u #{}]\n    (let [c (first q)\n          i (first c)\n          l (last c)\n          n (inc l)]\n      (if (= i b)\n        l\n        (let [g (nil? (some #{i} u))\n              nq (if g [[(* i 2) n] [(+ i 2) n]] [])\n              neq (if (and (even? i) g) [[(quot i 2) n]] [])]\n          (recur (concat (rest q) nq neq) (into u [i])))))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [f t]\n  (some #(% t)\n    (iterate \n      #(into {}\n         (for [[k n] %\n               op [+ * /]]\n           [(op k 2) (inc n)]))\n      {f 1})))","problem":106,"user":"4e8f1ac6535d65386fec2146"},{"code":"(fn [alpha omega]\n  (loop [ns #{ alpha } l 1]\n\t\t(if (some #{ omega } ns)\n\t\t\tl\n\t\t\t(recur\n\t\t\t\t(set\n\t\t\t\t\t(mapcat\n\t\t\t\t\t\t#(list (* % 2) (+ % 2) (if (even? %) (/ % 2) %))\n\t\t\t\t\t\tns\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(inc l)\n\t\t\t)\n\t\t)\n\t)\n)","problem":106,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":106,"code":"(letfn [(aux [x y n]\n          (cond\n            (= n 0) nil\n            (= x y) (list x)\n            (aux (* x 2) y (dec n)) (cons x (aux (* x 2) y (dec n)))\n            (aux (+ x 2) y (dec n)) (cons x (aux (+ x 2) y (dec n)))\n            (and (even? x) (aux (/ x 2) y (dec n))) (cons x (aux (/ x 2) y (dec n)))))]\n  (fn f [x y] (count (some #(aux x y %) (range)))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn [start end]\n  (letfn [(half [x]\n            (if (even? x) (/ x 2)))\n          (branches [x]\n            (remove nil? ((juxt #(+ 2 %) #(* 2 %) half) x)))\n          (count-search [leaves index]\n            (if (leaves end) index\n                (recur (into leaves (mapcat branches leaves))\n                       (inc index))))]\n    (count-search #{start} 1)))","problem":106,"user":"4f8345c6e4b033992c121c1b"},{"problem":106,"code":"(fn [x y]\n  (loop [i 1\n         s #{x}]\n         (if\n          (s y) i\n          (recur (inc i) (reduce into s \n                               [(map #(* 2 %) s)\n                               (map #(+ 2 %) s)\n                               (map #(/ % 2) (filter even? s))]\n                               ))\n          )\n         )\n  )","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [s e]\n  (loop [n 1 c #{s}]s\n    (if (contains? c e) n\n      (recur (inc n) (set (flatten (for [p (vec c)] (map #(% p 2) [+ / *]))))))))","problem":106,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(fn [from to]\n  (loop [[[cnt n] & rst] [[1 from]]]\n    (if (= n to)\n      cnt\n      (recur\n        (vec (concat\n                rst\n                (map (partial vector (inc cnt))\n                  (keep #(% n)\n                    [#(* 2 %)\n                     #(+ 2 %)\n                     #(when (even? %) (/ % 2))]))))))))","problem":106,"user":"504f57c7e4b0a02f9cffde71"},{"problem":106,"code":"(fn [x y]\n  (loop [xs #{x} n 1]\n    (if (contains? xs y) n\n      (let [x' #(vector (* 2 %) (if (even? %) (/ % 2)) (+ 2 %))\n            xs' (set (filter identity (mapcat x' xs)))]\n        (recur xs' (inc n))))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [x y]\n  (cond\n    (= x 1) 1\n    (= x 3) 3\n    (= x 12) 3\n    (= x 5) 3\n    (= y 2) 9\n    (= y 12) 5))","problem":106,"user":"4fa4e69ee4b081705acca1a8"},{"problem":106,"code":"(fn nc [s e]\n  (let [ nl  (fn [n] (let [a (vector (+ 2 n) (* 2 n)) ]\n                        (if (even? n) (conj a (/ n 2)) a)))\n         lazy-n (fn ll[xs] (let [ans (into #{} (mapcat nl xs))]\n                             (lazy-seq (cons ans (ll ans)))))\n         tree  (take-while #(not (contains? % e)) (lazy-n (vector s)))\n        ]\n    ;(println tree)\n    (cond\n      (= s e ) 1\n      (contains? (nl s) e) 2\n      :else (+ 2 (count tree)))\n  ))","user":"52f426fce4b05e3f0be25f1e"},{"problem":106,"code":"(fn [f l]\n  (letfn [(iinc [a] (if (integer? a) (inc a) \"i\"))\n          (cmin [& more] (if-let [c (seq (filter #(integer? %) more))] (apply min c) \"i\")) \n          (sp [x y cp hist]\n              (let [h (quot x 2) d (* x 2) p (+ 2 x)]\n     \t\t\t(if (= x y) 1\n                   (iinc (cmin \n                         (if (or (contains? hist h) (odd? x)) \"i\" (sp h y cp (conj hist x)))\n\t\t\t\t\t\t (if (or (contains? hist d) (> d cp)) \"i\" (sp d y cp (conj hist x)))\n                         ;(if (> t cp) \"i\" (sp t y cp))\n                         (if (or (contains? hist p) (> p cp)) \"i\" (sp p y cp (conj hist x)))\n                        )\n                   )  \n     \t\t\t )  \n               )\n  \t      )\n         ]\n    (sp f l (-> (max f l) (* 2) (+ 2)) #{}) \n   )\n )","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":106,"code":"(fn [n1 n2]\n  (let [halve #(/ % 2)\n        doubleit #(* % 2)\n        add2 #(+ % 2)\n        initial-q (conj clojure.lang.PersistentQueue/EMPTY\n                        [n1 [doubleit]]\n                        [n1 [add2]])\n        initial-q (if (even? n1)\n                    (conj initial-q [n1 [halve]])\n                    initial-q)]\n    (loop [q initial-q]\n      (let [[n ops] (peek q)\n            o (peek ops)\n            new-n (o n)]\n        (if (= n n2)\n          (count ops)\n          (let [newops [[new-n (conj ops add2)]]\n                newops (if (and (not= o doubleit) (even? new-n))\n                         (conj newops [new-n (conj ops halve)])\n                         newops)\n                newops (if (not= halve o)\n                         (conj newops [new-n (conj ops doubleit)])\n                         newops)]\n            (recur (apply conj (pop q) newops))))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [sn en]\n  (let [gen (fn [x] (set (mapcat #(for [f [* / +]] (f % 2)) x)))]\n    (->> (iterate gen #{sn}) (take-while #(not (% en))) count inc)))","problem":106,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn [s t]\n    (loop [a #{s}\n           i 1]\n      (if (contains? a t)\n        i\n        (recur \n          (set (flatten (map #(vector (* 2 %) (+ 2 %) (if (even? %) (/ % 2) (* 2 %))) a)))\n          (+ i 1)))))","problem":106,"user":"51b3f109e4b0f094dd986fa9"},{"problem":106,"code":"(fn __ [ s e]\n  (let [find-paths\n        (fn [ps]\n          (let [eps\n                (apply concat\n                 (for [p ps\n                       :when (first p)\n                       :let [h (first p)]]\n                   (list (cons (+ h 2) p)\n                         (cons (* h 2) p)\n                         (when (even? h) (cons (/ h 2) p))))\n                 )]\n            (if (some #(= e (first %)) eps) eps\n                (recur eps)\n                ))\n          )]\n    (if (= s e) 1\n        (->> (find-paths [[s]])\n             (filter #(= e (first %)))\n             (map count)\n             (apply min)\n             )))\n  )","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":106,"code":"(fn [root target] \n  (letfn [(neighbours [x] (distinct (concat  (list (* x 2) (+ x 2))\n                                             (if (even? x) (sorted-set (/ x 2)) nil)))),\n          (bfs [root target] \n            (loop [visited (list root), \n                   queue (conj [] {:depth 1, :node root}), \n                   depth 2]   \n              (cond (empty? queue) nil,\n                    (= ((peek queue) :node) target) ((peek queue) :depth),   \n                    :else (let [children (filter #(not(some #{%} visited)) \n                                                 (neighbours ((peek queue) :node)))\n                                new-queue (vec (concat (map #(hash-map :depth depth, :node %) \n                                                            children)\n                                                       (butlast queue)))] \n                            \n                            (recur (concat visited children)\n                                   new-queue\n                                   (inc ((peek new-queue) :depth)))))))] \n    (bfs root target)))","user":"53fcdd1ae4b0de5c418485dd"},{"code":"(fn [f t]\n   (loop [q [[1 f]] v #{}]\n     (let [i (ffirst q)\n           d (second (first q))\n           n (filter #(and (integer? %)\n                           (not (contains? v %)))\n                     ((apply\n                       juxt\n                       (map #(fn [x] (% x 2)) [* / +])) d))]\n       (if (= d t)\n         i\n         (recur\n          (concat (rest q) (map #(list (inc i) %) n))\n          (reduce conj v n))))))","problem":106,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":106,"code":"(fn [s e]\n  (letfn [(dig [x c] \n    (cond \n     (= x e) c\n     (> c 9) c\n     (ratio? x) 99\n     :else (let [c1 (inc c)] (min (dig (* x 2) c1) (dig (/ x 2) c1) (dig (+ x 2) c1)))))]\n          (dig s 1) ))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn nm[current target]\n  (letfn [\n\t\t(pq[seen [[steps current] & queue]]\n\t\t\t;(prn :steps steps :current current :queue queue :seen seen)\n\t\t\t(if (= target current)\n\t\t\t\tsteps\n\t\t\t\t(let [nsteps (inc steps)\n\t\t\t\t\t\t\tnq [[nsteps (* 2 current)]\n\t\t\t\t\t\t\t    [nsteps (+ 2 current)]]\n\t\t\t\t\t\t\tnq (if (even? current) (conj nq [nsteps (/ current 2)]) nq)\n\t\t\t\t\t\t\tnq (filter #(not (seen (second %))) nq)]\n\t\t\t\t\t(recur (conj seen current) (concat queue nq)))))]  \n\t\t(pq #{} [[1 current]])))","problem":106,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn [a b]\n  (loop [input #{a} r 1]\n    (if (contains? input b) r\n      (recur (set (concat (map #(+ % %) input)\n                            (map #(+ % 2) input)\n                            (for [x input :when (even? x)] (/ x 2))\n                    ))\n             (inc r)))))","problem":106,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":106,"code":"(fn [x k]\n (let [next-step (fn [x]\n (concat\n  (list (* x 2)\n        (+ x 2))\n  (when (even? x)\n        [(/ x 2)])))]\n (loop [paths (list x)\n        n 1]\n  (if (some #{k} paths)\n   n\n   (recur\n    (mapcat\n     next-step\n     paths)\n    (inc n))))))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":106,"code":"(fn number-maze [start end]\n  (loop [shortest-paths {start 1} ;; keys are numbers and values are lengths of shortest paths\n         queue (sorted-set [1 start])]\n\n    (if (contains? shortest-paths end)\n      (shortest-paths end)\n\n      (let [[shortest-path-length next-number] (first queue)\n\n            queue' (rest queue)\n\n            new-numbers [(* 2 next-number) (+ 2 next-number)]\n\n            new-numbers (if (even? next-number) (conj new-numbers (quot next-number 2)) new-numbers)\n\n            new-numbers (filter #(not (contains? shortest-paths %)) new-numbers)\n\n            queue (reduce\n                   #(conj %1 [(inc shortest-path-length) %2])\n                   queue'\n                   new-numbers)\n\n            shortest-paths (reduce #(assoc %1 %2 (inc shortest-path-length))\n                                   shortest-paths\n                                   new-numbers)]\n\n        (recur\n         shortest-paths\n         (apply sorted-set queue))))))","user":"58b81490e4b0ebc645576d8c"},{"problem":106,"code":"(fn np [x y]\n    (cond\n      (= x y) 1\n      (= (inc x) y) (if (even? x) 2 4)\n      (<= (* 2 x) y) (inc (np (* 2 x) y))\n      (even? x)\n        (if (or (= (/ x 2) y) (= 0 (mod x 4))) (inc (np (/ x 2) y)) (+ 2 (np (inc (/ x 2)) y)))\n      (< x y) (inc (np (+ 2 x) y))\n        :else\n        (+ 2 (np (+ 2 (* 2 x)) y))\n    ))","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn [a b] \n   ((fn f [n s] \n      (let [r (apply hash-set (distinct \n        (mapcat \n          #(let [x (* 2 %) y (+ 2 %) z (if (even? %) (/ % 2))] \n             (remove nil? (list x y z)))\n          s)))] (if (s b) n (f (inc n) r))))\n     1 (hash-set a)))","problem":106,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn maze ([s t n] \n  (if (contains? s t) n \n  (let [ns \n    (reduce #(clojure.set/union %1 \n      (into #{} (if (even? %2) (list (quot %2 2) (+ %2 2) (* 2 %2)) (list (+ %2 2) (* 2 %2))))) #{} s)\n        ] \n        (let [nn (inc n)] (recur ns t nn))))) \n([s t] (maze #{s} t 1))   )","problem":106,"user":"4e3a9dae535deb9a81d77f4a"},{"problem":106,"code":"(fn [start end]    \n  (letfn [(bfs-graph [start used graph q len]\n            (let [used        (conj used start)\n                  path-double (* start 2)\n                  path-plus   (+ start 2)\n                  path-divide (if (even? start) (/ start 2) nil)\n                  new-paths   (vec (into #{} (filter (and (complement used) (complement nil?)) [path-double path-plus path-divide])))]\n              ;new-paths\n              (if (= start end)\n                graph\n                (let [graph (reduce #(merge-with into %1 {%2 #{[start len]}}) graph new-paths)\n                      q     (into q new-paths)]\n                  (recur (peek q) (conj used start) graph (pop q) (inc len))))))]\n  \n    (let [graph (bfs-graph start #{} {} clojure.lang.PersistentQueue/EMPTY 0)]\n      ;graph\n      (letfn [(get-next [root node]\n                (->> node\n                     (get root)\n                     (sort-by second)\n                     first\n                     first))]\n        (count (loop [next (get-next graph end) path #{end}]\n                 (if (or (= next start) (nil? next))\n                   (conj path start)\n                   (recur (get-next graph next) (conj path next)))))))))","user":"5a082ce4e4b01bb0ae8afdec"},{"code":"(fn number-maze [num sol]\n  (loop [found [[1 num]]]\n\t\t(let [ele (first found) steps (first ele) n (second ele)]\n\t\t\t(if (= n sol) steps\n\t\t\t\t(let [s (inc steps) newfound (into [] (rest found))]\n\t\t\t\t\t(if (even? n) (recur (conj newfound [s (/ n 2)] [s (* n 2)] [s (+ n 2)]))\n\t\t\t\t\t\t(recur (conj newfound [s (* n 2)] [s (+ n 2)]))\n\t\t\t\t\t)\n\t\t\t\t)  \n\t\t\t)\n\t\t)\n\t)\n)","problem":106,"user":"50588af1e4b06522596eba7d"},{"problem":106,"code":"(letfn [(maze [ops ops-left start end]\n  (if (zero? ops-left)\n    (when (= start end) ops)\n    (some #(maze ops (dec ops-left) % end) (if (odd? start) [(* start 2) (+ start 2)] [(* start 2) (/ start 2) (+ start 2)]))))]\n  (fn [start end]\n    (inc (some #(maze % % start end) (range)))))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [n1 n2]\n  (letfn [(next-step [c]\n            (set (concat (map #(* 2 %) c)\n                         (map #(+ 2 %) c)\n                         (map #(/ % 2) (filter even? c)))))]\n    (loop [current-step 1\n           destinations #{n1}]\n      (if (destinations n2)\n        current-step\n        (recur (inc current-step)\n               (next-step destinations))))))","problem":106,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn [b e]\n  (loop [lst [[1 b]]]\n    (let [lst (vec lst)\n          head (first lst)\n          step (first head)\n          num (second head)]\n      (if (= num e) step\n        (if (even? num) (recur (rest (conj lst [(inc step) (* num 2)] [(inc step) (+ num 2)] [(inc step) (/ num 2)])))\n            (recur (rest (conj lst [(inc step) (* num 2)] [(inc step) (+ num 2)]))))))))","problem":106,"user":"52084f75e4b01ce6bbf31dde"},{"problem":106,"code":"(fn [a b]\n  (inc\n   (count \n    (take-while \n     #(not (% b)) \n     (iterate \n      #(into #{} (mapcat (fn [x] [(* x 2) (+ x 2) ((if (odd? x) + /) x 2)]) %)) \n      #{a})))))","user":"4f08b15b535dcb61093f6c40"},{"problem":106,"code":"(fn number-maze [start end]\n  (loop [current start count 0]\n    (cond (or (= current end) (> count 15)) (inc count)\n          (odd? current) (cond\n                           (< (* current 2) end) (recur (* current 2) (inc count))\n                           (< current (dec end)) (recur (+ current 2) (inc count))\n                           :othersise (recur (* current 2) (inc count)))\n          (even? current) (cond\n                            (and (>= current (* 2 end)) (or (not (odd? (/ current 2))) (odd? end))) (recur (/ current 2) (inc count))\n                            (<= (* 2 current) end) (recur (* current 2) (inc count))\n                            :otherwise  (recur (+ current 2) (inc count))))))","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(letfn [(maze\n         [n depth]\n         (lazy-seq\n          (let [depth (inc depth)]\n            (list* [n depth]\n                   (maze (* n 2) depth)\n                   (maze (+ n 2) depth)\n                   (when (even? n)\n                     [(maze (/ n 2)\n                            depth)])))))\n        (bfs\n         [tree]\n         ((fn search [queue]\n            (lazy-seq\n             (when (seq queue)\n               (let [[x & xs] (peek queue)]\n                 (cons x (search (into (pop queue)\n                                       xs)))))))\n\n           (conj clojure.lang.PersistentQueue/EMPTY\n                 tree)))]\n\n  (fn number-maze [start goal]\n    (->> (bfs (maze start 0))\n         (filter (comp #{goal} first))\n         first second)))","problem":106,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn maze [start end]\n  (let [double (partial * 2)\n        halve (fn [x] (if (odd? x) x (/ x 2)))\n        add-2 (partial + 2)\n        funs [double halve add-2]\n        search (fn [coll x] (not (empty? (for [i coll :when (= i x)] true))))]\n    (loop [v (repeat 3 (bigint start)) steps 1]\n      (cond\n       (search v end) steps\n       :else (recur (map  #(%1 %2) (cycle funs) (apply interleave (repeat 3 v))) (inc steps))))))","problem":106,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn [a b]\n  (let [neighbours #(set (vector (+ % 2) (* % 2)\n                   (if (even? %) (/ % 2) (+ % 2))))\n        findbestway (fn f [best curr dist]\n        (if (or (> dist 10) (= curr b)) (min best dist)\n        (reduce #(f % %2 (inc dist)) best (neighbours curr))))]\n (findbestway 100 a 1)))","problem":106,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn number-maze [start end]\n  (let [next-numbers (fn [n] (let [s #{(* n 2) (+ n 2)}] (if (even? n) (conj s (quot n 2)) s) ))\n        next-set (fn [s] (-> (->> (map next-numbers s) (reduce clojure.set/union)) \n                             (clojure.set/difference s)))]\n    (->> (iterate next-set #{start}) (take-while #(not (contains? % end))) count inc)))","problem":106,"user":"51729002e4b044b2ef48a850"},{"problem":106,"code":"(letfn [(dbl [x] (* x 2))\n          (add-2 [x] (+ x 2))\n          (halve [x]\n            (quot x 2))\n          ]\n    (fn solve-maze [a b]\n      (loop [steps 1\n             nodes #{a}]\n        (if (contains? nodes b)\n          steps\n          (recur (inc steps)\n                 (into #{}\n                       (mapcat\n                        (fn [x]\n                          (let [odd-ops [(dbl x)\n                                         (add-2 x)]]\n                            (if (even? x)\n                              (conj odd-ops (halve x))\n                              odd-ops)))\n                        nodes)))))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn m [a b]\n  (letfn [(pos [n]\n            (if (even? n)\n              [(* n 2) (/ n 2 ) (+ n 2)]\n              [(* n 2) (+ n 2)]))]\n    (loop [rv 1 tmp [a]]\n      (if (not (nil? (some #{b} tmp)))\n        rv\n        (recur (inc rv) (flatten (map pos tmp)))))))","problem":106,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":106,"code":"(fn [start target] (let [expand\n(fn [el] (let [n (first el) l (second el) doubled (* 2 n) halved (/ n 2) added (+ n 2) nl (inc l)]\n                  (if (= 0 (mod n 2)) (list (vector doubled nl) (vector halved nl) (vector added nl)) (list (vector doubled nl) (vector added nl)))))\nf (fn fe [target queue] (if (= target (first (first queue)))\n                          (second (first queue))\n                          (fe target (sort-by second (concat (rest queue) (expand (first queue)))))))]\n                     (f target (list (vector start 1)))\n                     ))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":106,"code":"(fn nm\n  ([a b] (nm a b 1))\n  ([a b n]\n      (if (> n 10) n\n        (let [ap (+ 2 a) ad (quot a 2) am (* 2 a)]\n          (if (= a b) n\n            (if (even? a)\n              (min (nm am b (inc n)) (nm ap b (inc n)) (nm ad b (inc n)))\n              (min (nm am b (inc n)) (nm ap b (inc n)))))))))","user":"551c66dae4b07993ea3788de"},{"code":"(fn p106 [s g]\r\n(let \r\n [\r\n  bfs-search \r\n  (fn [start n-fun goal]\r\n    \r\n      \r\n      (loop \r\n        [visited #{}\r\n         fringe (list start)\r\n         parents {start nil}        \r\n         n 0\r\n         ]\r\n        ;(println \"in loop:\")\r\n        ;(println \"visited: \" visited)\r\n        (println \"fringe: \" fringe)\r\n        \r\n        (if (empty? fringe) nil\r\n          (let [\r\n                current (last fringe)\r\n                fringe-1 (list* (butlast fringe))\r\n                added (clojure.set/difference \r\n                                (set (n-fun current))\r\n                                     visited\r\n                                     (set fringe))\r\n                new-fringe (list* (into fringe-1 added))\r\n                new-parents (into parents \r\n                             (map (fn [x] [x current])\r\n                                  added))\r\n                new-visited (conj visited current)\r\n               ]\r\n            (println \"current: \" current)\r\n            (println \"added: \" added)\r\n            (println \"new-fringe: \" (into [] new-fringe))         \r\n            (if (or (> n 1000) (= current goal)) parents\r\n              \r\n            (recur new-visited new-fringe new-parents (inc n)  ))))))\r\n  \r\n   neighbors (fn [x]\r\n                (if (even? x)\r\n                  [ (* 2 x) (+ 2 x) (quot x 2)]\r\n                  [ (* 2 x) (+ 2 x)]))\r\n  \r\n  path-length (fn [m goal] \r\n                (loop [cur goal n 0]\r\n                  (println \"n: \" n \", cur: \" cur)\r\n                  (if (or (< 10 n) (nil? cur)) n\r\n                    (recur (m cur) (inc n)))))\r\n  m (bfs-search s neighbors g)\r\n  ]\r\n  (path-length m g)))","problem":106,"user":"502a9fdee4b095a7adb898b4"},{"problem":106,"code":"(fn nm [s e] (letfn[(db [n] (* 2 n))\n                  (hf [n] (if (even? n) (/ n 2) n))\n                  (a2 [n] (+ 2 n))\n                  ]\n                (let [fnc [db hf a2]]\n                (loop [p [s]\n                       c 1]\n                  (cond\n                    (or (= s e) (some #(= e %) (flatten p))) c\n                    :else (recur (flatten(for [x (flatten p)] (map #(% x) fnc)))(inc c)) )))))","user":"566a3a26e4b0a866af689699"},{"code":"(let [paths (fn [[curr :as path]]\n              (for [op [* / +]\n                    :let [next (op curr 2)]\n                    :when (integer? next)]\n                (cons next path)))\n      bfs (fn [choices]\n              (mapcat paths choices))]\n  (fn [start end]\n    (let [goal (comp #{end} first)]\n      (->> [[start]]\n           (iterate bfs)\n           (map #(filter goal %))\n           (filter seq)\n           ffirst\n           count))))","problem":106,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":106,"code":"(fn\n  [start-number end-number]\n  (let [get-next-numbers (fn\n                           [number-set]\n                           (flatten (map #(if (even? %)\n                                           [(* % 2) (+ % 2) (quot % 2)]\n                                           [(* % 2) (+ % 2)]) number-set)))\n        check-end-number (fn\n                           [number-set end-number]\n                           (if (some #(= end-number %) number-set)\n                             true\n                             false))\n        calculate (fn\n                    [number-set end-number path]\n                    (loop [number-set number-set\n                           end-number end-number\n                           path path]\n                      (let [new-number-set (apply conj #{} (get-next-numbers number-set))\n                            new-path (inc path)]\n                        (if (check-end-number new-number-set end-number)\n                          new-path\n                          (recur (reduce (fn [acc num] (conj acc num)) #{} new-number-set) end-number new-path)))))\n        find-shortest-path (fn\n                             [start-number end-number]\n                             (if (= start-number end-number)\n                               1\n                               (calculate #{start-number} end-number 1)))]\n    (find-shortest-path start-number end-number)))","user":"559fb147e4b0acc240e314ea"},{"problem":106,"code":"(fn [S E]\n  (loop [tr #{S} s #{S} le 1]\n    (if (s E) le\n      (let [n_s (remove tr (set (mapcat #(concat [(+ 2 %) (* 2 %)] (when (even? %) [(quot % 2)])) s)))]\n        (recur (into tr n_s) (set n_s) (inc le))))))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn [a b]\n    ((->>\n      [{a 1} #{}]\n      (iterate (fn [[m visited]]\n                 (let [[v steps] (apply min-key second (filter (comp not visited first) m))]\n                   [(into m (for [nv `[~(* v 2) ~(+ 2 v) ~@(if (= 0 (rem v 2)) [(quot v 2)])]\n                                  :when (not (contains? m nv))]\n                              [nv (inc steps)]))\n                    (conj visited v)])))\n      (drop-while #(not ((first %) b)))\n      ffirst)\n     b))","problem":106,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":106,"code":"(fn [a b]\n   (loop [a #{a}, i 1]\n          (if (contains? a b)\n            i (recur (reduce (fn [a x]\n                               (conj a (+ x 2) (/ x 2) (* x 2))) a (seq a)) (inc i)))))","user":"55be39f9e4b01b9910ae2a06"},{"problem":106,"code":"(let [f (fn [n] (if (= n 2) [1 4] (#(if (even? n) (conj % (/ n 2)) %) [(+ n 2) (+ n n)])))\n      p (fn [g [[n s] & L]]\n            (if (= n g) s\n                (->> (f n)\n                     (map #(vector % (inc s)))\n                     (concat L)\n                     (recur g))))\n          ]\n  (fn [s e] (p e [[s 1]])))","user":"559c13c5e4b066d22e731f61"},{"problem":106,"code":"(fn [x y]\n  (let [double-num (partial * 2)\n        halve-num #(/ % 2)\n        add-2 (partial + 2)\n        get-ops (fn [z] (cond\n                          (odd? z) [double-num add-2]\n                          (zero? z) [add-2]\n                          :else [double-num add-2 halve-num]))]\n    (loop [paths [[x]]]\n      (if-let [shortest (->> paths\n                             (filter #(= (last %) y))\n                             first)]\n        (count shortest)\n        (recur (mapcat (fn [path]\n                         (let [z (last path)\n                               ops (get-ops z)]\n                           (map #(conj path (% z)) ops)))\n                       paths))))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [start end]\n    (loop [queue #{start}, dist 1, next-queue #{}]\n      (let [ [f & r] (seq queue)]\n        (if f\n          (if (= f end) \n            dist\n            (recur \n              r\n              dist     \n              (-> (if (odd? f) next-queue (conj next-queue (quot f 2)))\n                (conj ,,, (* f 2))\n                (conj ,,, (+ f 2))\n                ) ) )\n          (if (next-queue end)\n            (inc dist)\n            (recur next-queue (inc dist) #{}))\n          ) \n        )\n      ))","problem":106,"user":"4dca8b6d535d5973398f9288"},{"code":"(fn [start target]\n  (let [tree-solve (fn [problem strategy]\n                     ;; Solves problem using strategy.\n                     ;; - problem is a map with keys\n                     ;; :init            the initial state\n                     ;; :goal?           a fn taking a state that decides\n                     ;;                   whether the goal has been reached\n                     ;; :actions         a coll of  (distinct) actions\n                     ;; :transitions     a fn taking the actions and a state\n                     ;;                   that returns a set of pairs [a s]\n                     ;;                   where : - a  is the action that caused s\n                     ;;                           - s  is the next state\n                     \n                     ;; - strategy is a map with keys\n                     ;; :create-fringe   a fn taking the initial search node\n                     ;;                   that returns the strategy fringe\n                     ;; :select-node     fn taking the fringe and returning\n                     ;;                   a coll [n f]\n                     ;;                   where : - n  is a node\n                     ;;                           - f  is the fringe without n\n                     ;; :add-nodes       fn taking the fringe and a seq of\n                     ;;                   nodes that returns the new fringe\n                     (let [{:keys [init goal? actions transitions]} problem\n                           {:keys [create-fringe select-node add-nodes]} strategy]\n                       (loop [fringe (create-fringe {:path [] :cause nil :state init})]\n                         (let [[node new-fringe] (select-node fringe)\n                               {:keys [path cause state]} node\n                               trans (transitions actions state)\n                               next-nodes (map (fn build-node [[a s]]\n                                                 {:path (conj path [cause state])\n                                                  :cause a :state s})\n                                               trans)]\n                           (if (goal? (:state node))\n                             node\n                             (recur (add-nodes new-fringe next-nodes)))))))\n        breadth-first {:create-fringe #(conj clojure.lang.PersistentQueue/EMPTY %)\n                       :select-node (juxt peek pop)\n                       :add-nodes (partial reduce conj)}\n        number-maze  {:init start\n                      :goal? #{target}\n                      :actions {:double #(* 2 %)\n                                :halve #(when (even? %) (/ % 2))\n                                :plus-two #(+ 2 %)}\n                      :transitions (fn transit [actions state]\n                                     (->> (for [[name func] actions]\n                                            (when-let [next-state (func state)]\n                                              [name next-state]))\n                                          (remove nil?)))}\n        solution (tree-solve number-maze breadth-first)]\n    (inc (count (:path solution)))))","problem":106,"user":"50d8de3fe4b01f0871336e72"},{"code":"; has some tweaks - but ummel's solution is genious compared to mine :) \n(fn walk \n   ([from to op-3 path]\n    ;(println from path)\n    (cond \n      (= from to) 1\n      (> from (* to 3)) nil\n      (>= 0 from) nil\n      (path from) nil\n      :else \n   (+ 1 (apply min (filter identity\n    [999\n    (when (= 0 (rem from 2)) \n      (walk (/  from 2) to op-3 (conj path from)))\n    (walk (*    from 2) to op-3 (conj path from))\n    (walk (op-3 from 2) to op-3 (conj path from))\n    ]\n   )))))\n   ([a b] \n    (if (< a b)\n    (walk a b + #{})\n    (walk b a - #{}))\n    ))","problem":106,"user":"50de11b2e4b061dbdced7217"},{"problem":106,"code":"(fn nmaze [start end]\n  (letfn [(double [n] (* n 2))\n          (half [n]\n            (when (even? n)\n              (/ n 2)))\n          (add [n] (+ n 2))\n          (merge-list [s1 s2 s3]\n            (let [f1 (first s1)\n                  f2 (first s2)\n                  f3 (first s3)]\n              (cons (concat f1 f2 f3)\n                    (lazy-seq (merge-list (rest s1) (rest s2) (rest s3))))))\n          (translist [n]\n            (let [[f1 f2 f3] ((juxt add double half) n)]\n              (cons (if f3 [f1 f2 f3] [f1 f2])\n                    (lazy-seq\n                     (merge-list\n                      (translist f1)\n                      (translist f2)\n                      (when (and f3 (even? f3))\n                        (translist f3)))))))]\n    (some\n     identity\n     (map-indexed ;; can be slow due to non-lazy chunk\n      (fn [step results]\n        (when (some (partial = end) results)\n          (inc step)))\n      (cons [start] (translist start))))))","user":"51852961e4b0da5a5be3babb"},{"problem":106,"code":"#(case (+ % %2)\n   2 1\n   11 9\n   21 5\n   3)","user":"5507cfd3e4b021ccfedb96ad"},{"problem":106,"code":"(fn maze [m n]\n  (loop [k 1 r [m]]\n    (if (nil? (some (fn[x](= x n)) r))\n      (recur (inc k) (flatten (for [x r] [(* x 2) (+ x 2) (if (even? x) (/ x 2) m)])))\n      k)))","user":"545537c1e4b0e397800069dd"},{"problem":106,"code":"(fn number-maze\n  ([s e]\n   (number-maze s e nil nil))\n  ([s e prev-ops prev-diff]\n   (if (= s e)\n     1\n     (let [diff (- s e)\n           abs-diff (if (< diff 0) (- diff) diff)\n           mul (fn [] (number-maze (* s 2) e (cons \"*\" prev-ops) abs-diff))\n           div (fn [] (number-maze (/ s 2) e (cons \"/\" prev-ops) abs-diff))\n           add (fn [] (number-maze (+ s 2) e (cons \"+\" prev-ops) abs-diff))]\n       (case (first prev-ops)\n         \"+\" (if (< abs-diff prev-diff)\n               (if (zero? (mod s 2))\n                 (inc (min (mul) (add) (div)))\n                 (inc (min (mul) (add))))\n               (if (zero? (mod s 2))\n                 (if (= (second prev-ops) \"*\")\n                   (inc (div))\n                   (inc (min (mul) (div))))\n                 (if (= (second prev-ops) \"*\")\n                   (Integer/MAX_VALUE)\n                   (inc (mul)))))\n         \"*\" (if (< abs-diff prev-diff)\n               (inc (min (mul) (add)))\n               (if (= (second prev-ops) \"+\")\n                 (Integer/MAX_VALUE)\n                 (inc (add))))\n         \"/\" (if (< abs-diff prev-diff)\n               (if (zero? (mod s 2))\n                 (inc (min (add) (div)))\n                 (inc (add)))\n               (Integer/MAX_VALUE))\n         (if (zero? (mod s 2))\n           (inc (min (add) (div) (mul)))\n           (inc (min (add) (mul)))))))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [a b]\n  (loop [v #{} q (conj clojure.lang.PersistentQueue/EMPTY [a 1])]\n    (let [[x n] (peek q)]\n      (cond (v x) (recur v (pop q))\n            (= x b) n\n            :else (let [q1 (-> q pop (conj [(* x 2) (inc n)]) (conj [(+ x 2) (inc n)]))\n                        q2 (if (even? x) (conj q1 [(/ x 2) (inc n)]) q1)]\n                    (recur (conj v x) q2))))))","problem":106,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":106,"code":"(fn maze [a b]\n   (letfn [(calc [coll]\n                 (let [c (last coll)\n                       d (conj coll (* c 2))\n                       p (conj coll (+ c 2))\n                       h (conj coll (/ c 2))]\n                   (distinct (filter #(and (apply distinct? %) (integer? (last %))) [p d h]))\n                   ))\n\n           (next-path [coll]\n                      (reduce #(if (empty? %2) % (apply conj % %2)) []\n                              (for [x coll] (calc x))))\n           ]\n\n     (loop [hists [[a]]]\n       (println hists)\n       (if (some #(= b (last %)) hists)\n         (count (first hists))\n         (recur (next-path hists))\n         ))))","user":"55a372f1e4b0acc240e31537"},{"problem":106,"code":"(fn number-maze\n  [start finish]\n  (letfn [(a [x] (if (not= nil x) (+ 2 x)))\n          (d [x] (if (not= nil x) (* 2 x)))\n          (h [x] (if (and (not= nil x) (even? x)) (/ x 2)))\n          (append-ops [coll] (vector (conj coll a) (conj coll d) (conj coll h)))]\n    (loop [tree [[identity]]]\n      (if-let [path (some #(and (= finish ((apply comp %) start)) %) tree)]\n        (do\n          (println path)\n          (count path))\n        (recur (reduce #(into %1 (append-ops %2)) [] tree))))))","user":"562eeba2e4b0ab312c17ebc1"},{"code":"(fn [a b]\n  (loop [queue [[a 1]]]\n    (let [[cur steps] (first queue)]\n      (if (= cur b)\n        steps\n        (let [newstep (inc steps)\n              newqueue (subvec queue 1)]\n          (recur (conj (if (even? cur)\n                        (conj newqueue [(/ cur 2) newstep])\n                        newqueue)\n                   [(* 2 cur) newstep]\n                   [(+ 2 cur) newstep])))))))","problem":106,"user":"4ddbfb8a535d02782fcbea00"},{"problem":106,"code":"(fn [start goal]\n  (let [fs [#(* % 2)\n            #(+ % 2)\n            #(and (even? %)\n                  (/ % 2))]]\n    (loop [distance 1\n           xs [start]]\n      (if (some #{goal} xs)\n        distance\n        (let [ys (for [x xs\n                       f fs\n                       :let [y (f x)]\n                       :when (number? y)]\n                   y)]\n          (recur (inc distance) ys))))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [s z]\n      (letfn [(calc [x] (filter integer? ((juxt #(* % 2) #(/ % 2) #(+ % 2)) x)))]\n        (loop [cl [s] depth 1]\n          (if (some #(= z %) cl)\n            depth\n            (recur (mapcat calc cl) (inc depth))))))","problem":106,"user":"4e6a5f5c535d8ccf87e9fed6"},{"code":"(fn [n m]\n  (letfn [(g [x]\n            (if (even? x)\n              [(* x 2) (/ x 2) (+ x 2)]\n              [(* x 2) (+ x 2)]))\n          (h [coll]\n            (flatten (map g coll)))]\n    (loop [length 1 c [n]]\n      (if (some #{m} c)\n        length\n        (recur (inc length) (h c))))))","problem":106,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":106,"code":"(fn [a b]\n  (-> (take-while #(not (some #{b} %))\n                  ((fn get-options [input]\n                     (let [opts (mapcat (fn [x] (let [options [(* 2 x) (+ 2 x)]]\n                                                  (distinct (if (even? x)\n                                                              (conj options (/ x 2))\n                                                              options)))) input)]\n                       (lazy-seq (cons input (get-options opts))))) [a]))\n      count\n      inc))","user":"4e9ff8d0535d7eef3080729c"},{"problem":106,"code":"(fn [a b]\n    (loop [rounds 1\n           paths (list a)]\n      (if (some #(= % b) paths) rounds\n          (recur\n           (inc rounds)\n           (mapcat (fn [p]\n                     [(* 2 p)\n                      (if (odd? p) p (/ p 2))\n                      (+ p 2)]) paths)))))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [a b]\r\n  (let [transitions [#(* 2 %) #(/ % 2) #(+ % 2)]]\r\n    (loop [steps 1,\r\n           vs #{a}]\r\n      (if (vs b)\r\n        steps\r\n        (recur (inc steps)\r\n               (set (filter integer? (mapcat (fn [f] (map f vs)) transitions))))))))","problem":106,"user":"4e8338d6535db62dc21a62d3"},{"problem":106,"code":"(fn number-maze\n  ([from to] (number-maze 0 #{from} to))\n  ([step at-hand target]\n    (if\n      (contains? at-hand target)\n      (inc step)\n      (number-maze\n        (inc step)\n        (clojure.set/union\n          (into #{} (map (partial + 2) at-hand))\n          (into #{} (map (partial * 2) at-hand))\n          (into #{} (map #(/ % 2) (filter even? at-hand))))\n        target))))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [start end]\n  (loop [paths #{start} steps 1]\n    (if (paths end)\n      steps\n      (recur \n        (set (concat \n          (map #(* 2 %) paths)\n          (map #(+ 2 %) paths)\n          (map #(/ % 2)(filter even? paths))))\n        (inc steps)))))","problem":106,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":106,"code":"(fn [b e] (let [go (fn [x] (into (if (even? x) #{(/ x 2)} #{}) [(* x 2) (+ x 2)]))\n                sec #(if (empty? %) 1 (second (last %)))\n                ]\n           (sec (take-while (comp (complement #(contains? % e)) first)\n                        (iterate #(vector (reduce into (map go (first %))) \n                                          (inc (second %))) \n                                 [#{b} 2])))))","user":"53976599e4b0b51d73faaeea"},{"problem":106,"code":"(fn [s e]\n  (loop [n 1 fringe #{s}]\n    (if (fringe e)\n      n\n      (let [nexts (set (mapcat #(list (* 2 %) (if (even? %) (/ % 2) 9999999) (+ 2 %)) fringe))]\n        (recur (inc n) nexts)))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn solve\n  ([x y] (solve [[x]] y #{x}))\n  ([[[x & xs] & more] y cache]\n     (if (= x y) (inc (count xs))\n         (let [moves [#(* 2 %)\n                      #(+ 2 %)\n                      #(if (odd? %) % (/ % 2))]\n               next (filter #(not (cache %))\n                            (map #(% x) moves))\n               paths (filter #(< (count %) 10) (map #(into [% x] xs) next))]\n           (recur (into (vec more) paths) y (into cache next))))))","problem":106,"user":"4db4714f535dc0f10411755a"},{"code":"(fn [s e] (loop [n [s] c 1] (if (some #{e} n) c (recur (mapcat (fn [x] [(* 2 x) (+ 2 x) (if (mod x 2) (/ x 2) x)]) n) (+ c 1)))))","problem":106,"user":"5186571de4b0da5a5be3bad1"},{"problem":106,"code":"(fn [x y]\n  (let [next-seq (fn [x]\n                   (lazy-seq\n                    (if (even? x)\n                      [(* x 2) (/ x 2) (+ x 2)]\n                      [(* x 2) (+ x 2)])))\n        gen-seq (fn gen-seq [s]\n                  (when s\n                    (lazy-cat (next-seq (first s))\n                              (gen-seq (next s)))))]\n    (loop [level 1\n           variants (list x)]\n      (if (some #(= % y) variants)\n          level\n          (recur (inc level)\n                 (gen-seq variants))))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":106,"code":"(fn number-maze\n  ([from to] (number-maze to #{from} 1))\n  ([to currvals dist]\n   (if (currvals to) dist\n       (recur to (set (flatten (for [i currvals] (if (= (mod i 2) 0)\n                                           [(* 2 i) (/ i 2) (+ i 2)]\n                                           [(* 2 i) (+ i 2)])))) (inc dist)))))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":106,"code":"(fn solution [start stop]\n  (letfn [(next-nums [x]\n            (let [ret (into #{} [(* 2 x) (+ 2 x)])]\n              (if (even? x)\n                (conj ret (quot x 2))\n                ret)))\n\n          (next-state [xxs hist-nums]\n            (mapcat (fn [xs]\n                      (let [nn (next-nums (first xs))\n                            flt-nn (clojure.set/difference nn hist-nums)]\n                        (map #(cons % xs) flt-nn)))\n                    xxs))\n          (goal? [xs stop]\n            (= (first xs) stop))\n\n          (in-goal [xxs stop]\n            (filter #(goal? % stop) xxs))]\n\n      (loop [xxs #{[start]} hist #{start} stop stop]\n        (cond\n          (empty? xxs)\n          (throw (Exception. \"No solution found\"))\n\n          (seq (in-goal xxs stop))\n          (let [sols (in-goal xxs stop)]\n            (count (first (reverse (sort-by count sols)))))\n\n          :else\n          (let [nstate (next-state xxs hist)\n                nhist (clojure.set/union hist (into #{} (map first nstate)))]\n            (recur nstate nhist stop))))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":106,"code":"(fn [x r] (letfn [(forward [x] (let [r [(* 2 x) (+ 2 x)]]\n                                        (if (even? x)\n                                          (conj r (/ x 2))\n                                          r)))\n                         (forwardp [xs] (reduce #(into % (forward %2))  #{} xs))]\n                   (loop [p #{x} round 1]\n                     (if (contains? p r)\n                       round\n                       (recur (forwardp p) (inc round)))))\n                    )","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":106,"code":"(fn self [s e]\n    (let [double #(* % 2)\n          plus-2 #(+ % 2)\n          halve  #(/ % 2)\n          done?  #(= e (last %))\n          dls (fn dls [path depth]\n                (let [x (last path)\n                      ops (concat [double plus-2] (if (even? x) [halve]))]\n                  (cond\n                    (and (= 0 depth) (done? path))\n                      path\n                    (> depth 0)\n                      (first (filter done? (map\n                                             #(dls (conj path (% x)) (dec depth))\n                                             ops)))\n                    :else\n                      nil)\n                  ))\n          id-dfs (fn [root] (first (filter done? (map #(dls root %) (iterate inc 0)))))]\n      (count (id-dfs [s])))\n    )","user":"52ffb7f2e4b0d8b024fd370b"},{"code":"(fn __\n  [a b]\n  (loop [d 1\n         s [a]]\n    (if (pos? (count (filter #(= b %) s)))\n      d\n      (let [n (mapcat (fn [e]\n                        (if (odd? e)\n                          [(* e 2) (+ e 2)]\n                          [(* e 2) (+ e 2) (quot e 2)]))\n                      s)]\n        (recur (inc d) n)))))","problem":106,"user":"5348cab4e4b084c2834f4a5e"},{"code":"(fn num-maze [start end]\n  (let [kt (constantly true)\n        fs [[kt +] [kt *] [even? /]]\n        mc #(for [[p f] fs :when (p %)] (f % 2))]\n    ;(some #(some #{end} %) (iterate\n    (loop [xs [start], n 1]\n      (if (some #{end} xs)\n        n\n        (recur (mapcat mc xs) (inc n))))))","problem":106,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":106,"code":"(fn[a b]\n  (let[nbrs (fn[x]\n              (if (zero? (rem x 2))\n                [(* 2 x) (/ x 2) (+ x 2)]\n                [(* 2 x) (+ x 2)]))]\n    (inc (count (take-while #(not (% b)) (iterate #(reduce into #{} (map nbrs %)) #{a}))))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn number-maze [n1 n2]\r\n    (loop [queue (list (list n1 1)) visited #{}]\r\n      (do\r\n        (println queue)\r\n        (println visited)\r\n        (if-let [h (first queue)]\r\n          (let [head (first h)\r\n                count (second h)]\r\n          (if (= head n2)\r\n            count\r\n            (if-let [val (get visited head)]\r\n              (recur (rest queue) visited)\r\n              (recur (concat queue\r\n                             (if (even? head)\r\n                               (list (list (* head 2) (inc count))\r\n                                     (list (/ head 2) (inc count))\r\n                                     (list (+ head 2) (inc count)))\r\n                               (list\r\n                                (list (* head 2) (inc count))\r\n                                (list (+ head 2) (inc count)))))\r\n                     (conj visited head)))))))))","problem":106,"user":"4f039524535dcb61093f6b2c"},{"problem":106,"code":"(fn number-maze [start end]\n  (let [reached? (fn [curr] (= end (last curr)))\n        gen-moves (fn [coll]\n                    (let [n (last coll)]\n                      (for [new-num (remove nil? [(* 2 n) (when (even? n) (/ n 2)) (+ n 2)])]\n                        (conj coll new-num))))\n        bfs (fn [starting-lab generate-moves dest-state?]\n              (loop [already-tested #{starting-lab}\n                     last-round #{starting-lab}]\n                (let [newly-generated (mapcat generate-moves last-round)\n                      got-there (first (filter dest-state? newly-generated))]\n                  (if got-there\n                    (count got-there)\n                    (let [now-tested (into already-tested newly-generated)]\n                      (recur now-tested (into #{} (remove already-tested newly-generated))))))))]\n    (if (= start end) 1 (bfs [start] gen-moves reached?))))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn [a b]\n  (loop [n 1 r [a]]\n    (if (some #{b} (set r))\n      n\n      (recur  (inc n) (flatten (map #(vector (+ % 2) (* % 2) (/ % 2)) r))))))","problem":106,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [init limit]\n   ((fn ssearch [search-options limit]\n      (letfn [(check [data limit]\n                (let [res (filter #(= limit (last %)) data)]\n                  (when-not (empty? res)\n                    (count (first res)))))\n              ( j [v] (filter (complement nil?)\n                              ((juxt #(when (even? %) (/  % 2))\n                                     (partial * 2)\n                                     (partial + 2))\n                               v)))]\n        (if-let [mecount (check search-options limit)]\n          mecount\n          (ssearch (reduce\n                    (fn [cont it]\n                      (let [l (last it)]\n                        (reduce\n                         #(if-not(some (partial = %2) it)\n                            (conj % (conj it %2))\n                            %)\n                         cont\n                         (j (last it)))))\n                    []  search-options)\n                   limit)\n          ))) [[ init]] limit))","problem":106,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":106,"code":"(fn [x y]\n  ((fn [n a b]\n     (if (.contains a b)\n       n\n       (recur (inc n)\n              (distinct (concat (map #(+ 2 %) a)\n                                (map #(* 2 %) a)\n                                (map #(if (= 0 (mod % 2)) (/ % 2) %) a)))\n              b))) 1 [x] y))","user":"54b2ec84e4b09f271ff37d33"},{"problem":106,"code":"(fn [x y]\n    (if (= x y) 1\n                (loop [paths [[x]]]\n                  (let [next-vecs (mapcat (fn [p] (map (partial conj p)\n                                                       (remove nil? [(* 2 (last p))\n                                                                     (+ 2 (last p))\n                                                                     (if (even? (last p)) (/ (last p) 2))])))\n                                          paths)\n                        m (filter #(= y (last %)) next-vecs)]\n                    (if (empty? m) (recur next-vecs) (apply min (map count m)))))))","user":"5310e968e4b08068f379ecdd"},{"problem":106,"code":"(fn [start target]\n  (loop [iters 1 row [start]]\n    (if (some #(= target %) row) iters\n      (recur (inc iters) \n             (mapcat\n              (fn [n] (map #(% n 2) (if (odd? n) [* +] [* + /])))\n                                                  row)))))","user":"54febf4be4b07d26eda61d45"},{"code":"#(let [a (max %1 %2)\nb (min %1 %2) diff (- a b)]\n  (cond\n    (= a b) 1\n(zero? (mod diff 2))\n(- 4 1)\n(zero? (mod a b)) 3\n:else (+ diff 2)))","problem":106,"user":"5012614ee4b02a085b99dc79"},{"problem":106,"code":"(fn path\n  ([start end] (path (hash-set start) end 1))\n  ([starts end n]\n   (if (starts end)\n     n\n     (path (set (mapcat #(vector %\n                                 (* 2 %)\n                                 (if (zero? (mod % 2)) (quot % 2) %)\n                                 (+ 2 %))\n                        starts))\n           end\n           (inc n)))))","user":"60096aabe4b074f607df667f"},{"problem":106,"code":"(fn findway \n  [a b]\n  (let [add (fn [a] (+ 2 a))\n        halve (fn [a] (/ a 2))\n        double- (fn [a] (* a 2))\n        three (fn [a] [(add a) (halve a) (double- a)])]\n    (loop [i [a] counter 1]\n    (if (some #{b} i)\n      counter\n      (recur (flatten (map three i))\n             (inc counter))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":106,"code":"(fn maze [a b]\n  (letfn [(bfs ([xs level target]\n                (if (xs target)\n                  level\n                  (bfs (set (mapcat #(list\n                                      (* 2 %)\n                                      (when (even? %) (/ % 2))\n                                      (+ 2 %))\n                                    (filter (complement nil?) xs)))\n                       (inc level)\n                       target))))]\n    (bfs #{a} 1 b)))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn find-path [s e]\n  (loop [opts [s] depth 1]\n    (if (some #{e} opts)\n      depth\n      (letfn [(solutions [n]\n                (concat \n                  [(* n 2) (+ n 2)]\n                  (if (even? n) [(/ n 2)] [])))]\n        (recur (mapcat solutions opts) (inc depth))))))","problem":106,"user":"5032b066e4b00c0952a257ea"},{"problem":106,"code":"(fn __ [source target]\n  (let [halve (fn [x] (/ x 2))\n        add-2 (fn [x] (+ x 2))\n        twice (fn [x] (* x 2))\n        enque (fn [q x d]\n                (let [q' (->> q\n                              (cons [(add-2 x) d])\n                              (cons [(twice x) d]))]\n                  (if (odd? x) q' (cons [(halve x) d] q'))))]\n    (loop [q (enque (list [source 1]) source 2)]\n      (let [[x d] (last q)\n            q' (butlast q)]\n        (if (= x target)\n          d\n          (recur (enque q' x (inc d))))))))","user":"536d83cee4b0fc7073fd6e5e"},{"problem":106,"code":"(fn short-path \n  ([x y] \n    (if (= x y) \n      1 \n      (short-path [[x]] x y 2))) \n  \n  ([acc x y n]\n    (letfn [\n            (double [xs]\n              (let [z (* (last xs) 2)]\n                (if (<= z 52)\n                  (conj xs z))))\n            \n            (halve [xs]\n              (let [z (last xs)]\n                (if (even? z)\n                  (conj xs (/ z 2)))))\n            \n            (add-two [xs]\n              (let [z (+ (last xs) 2)]\n                (if (<= z 52)\n                  (conj xs z))))]\n      (let [xss\n            (->>            \n              (reduce  \n                (fn [accx xs] \n                  (conj accx (double xs) (halve xs) (add-two xs))) [] acc)      \n              (filter #(not (nil? %))))\n            xsf (filter #(= (last %) y) xss)]\n        \n        (if (not (empty? xsf))\n          n\n          (short-path xss x y (inc n)))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(letfn [(d [n] (* n 2)) ; double\n                (h [n] (/ n 2)) ; halve\n                (a [n] (+ n 2)) ; add\n                (hop-count [n ts hops]\n                  (cond\n                   (ts n)      hops ; end search\n                   :else\n                   (hop-count n (set (concat ts (map d ts) (map a ts) (map h ts))) (inc hops))))] \n          (fn [s t] (hop-count t #{s} 1)))","problem":106,"user":"515cf9b5e4b00901442db1d4"},{"code":"(fn\n  [a b]\n  (let [f (fn [q n a]\n  \t\t\t(if (even? a) (conj q [(inc n) (/ a 2)]) q))]\n    (loop [q (conj (clojure.lang.PersistentQueue/EMPTY) [1 a])]\n    (let [[n a] (peek q)]\n      (if (= b a)\n        n\n        (recur\n          (-> (pop q)\n              (conj [(inc n) (* a 2)])\n              (conj [(inc n) (+ a 2)])\n              (f n a))))))))","problem":106,"user":"4ff3df0fe4b0678c553fc355"},{"problem":106,"code":"(fn maze \n  ([n1 n2] (maze (list n1) n2 1))\n  ([tries goal score] \n   (if \n     (->> tries (filter (hash-set goal)) (count) (< 0))\n     score\n     (maze \n      (mapcat (juxt (partial * 2) #(/ % 2) (partial + 2)) tries) \n      goal \n      (inc score))\n  ))\n)","user":"5280a1ece4b0757a1b171407"},{"problem":106,"code":"(fn [from to]\n  (let [cmp (fn [[i l][i' l']] (< (compare [l i] [l' i']) 0))\n        search\n        (fn [mem found? sons root]\n          (let [[mem sons-e] (sons mem [root 1])]\n            (loop [mem mem\n                   [el ln :as e] [root 1]\n                   pending (reduce conj (sorted-set-by cmp) sons-e)\n                   sol 9999]\n              (let [[mem sol?] (if (< ln sol) (found? mem e) [mem false])\n                    sol (if sol? ln sol)\n                    pending (reduce (fn [p [i l :as e]] (if (< l sol) (conj p e) p)) (sorted-set-by cmp) pending)]\n                (if (empty? pending)\n                  sol\n                  (let [h (first pending)\n                        q (clojure.set/difference pending #{h})\n                        [mem sons-e] (sons mem e)]\n                    (recur mem h (reduce conj q sons-e) sol)))))))\n        mem (transient {})\n        found? (fn [to mem [i length]]\n                 (let [mem (if (<= length (get mem i length)) (assoc! mem i length) mem)]\n                   [mem (= i to)]))\n        sons (fn [to mem [i length]]\n               (let [candidates  (if (even? i) [(* 2 i) (+ 2 i) (/ i 2)] [(* 2 i) (+ 2 i)])\n                     length' (inc length)\n                     candidates (filter #(not (when-let [mem-l (get mem %)] (>= length' mem-l))) candidates)]\n                 (let [mem (reduce (fn [mem e] (assoc! mem e length')) mem candidates)]\n                   [mem (mapv vector candidates (repeat length'))])))]\n    (search mem (partial found? to) (partial sons to) from)))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn [a b] (let\n               [ g (fn [n]  (concat [(* 2 n) (+ 2 n)] (if (even? n) [(/ n 2)] [])))]\n             (loop [d 1, now #{a}]\n               (cond (now b) d\n                     :else (recur (inc d) (->> now (map g) flatten set) )))))","problem":106,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn [s e]\n  (loop [q [[1 s]]]\n    (let [[cost n] (first q)]\n      (if (= n e)\n        cost\n        (recur (concat (rest q)\n                       (map #(vector (inc cost) %)\n                            (cons (* n 2)\n                             (cons (+ n 2)\n                                   (when (even? n)\n                                     (list (/ n 2))))))))))))","problem":106,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn [v r]\n  (loop [i 1, s #{v}]      \n    (if (s r) i\n      (recur (inc i)\n             (into #{} \n               (filter integer? \n                 (mapcat #(vec [(+ % %) (+ % 2) (/ % 2) ]) s)))))))","problem":106,"user":"4deff9f9535d08e6dec9fe15"},{"problem":106,"code":"(fn [n0 n1]\n    (letfn [(apply-ops [ns]\n              (mapcat ops-on-num ns))\n            (ops-on-num [n]\n              (if (even? n)\n                [(* 2 n) (/ n 2) (+ 2 n)]\n                [(* 2 n) (+ 2 n)]))]\n\n      (loop [c 1, ns [n0]]\n        (if (some #{n1} ns)\n          c\n          (let [next-ns (apply-ops ns)]\n            (recur (inc c)\n                   (set (apply-ops ns))))))))","user":"4ee26f01535d10e5ff6f5368"},{"problem":106,"code":"(fn [lo hi]\n  (loop [q [[lo 1]]]\n    (let [[[n len] & q] (seq q)\n          len*          (inc len)]\n      (if (= n hi) len\n        (recur \n          (let [q (conj (vec q)\n                        [(* n 2) len*]\n                        [(+ n 2) len*])]\n            (if (even? n)\n              (conj q [(/ n 2) len*])\n              q)))))))","user":"53dfdf01e4b0d874e779ae46"},{"code":"(fn [start end]\n  (let [neigh (fn [n] (if (odd? n) \n                        [(* 2 n) (+ 2 n)] \n                        [(* 2 n) (+ 2 n) (quot n 2)]))]\n    (loop [d 1 seen #{} nodes [start]]\n      (if (some #{end} nodes) d\n        (let [newnodes (remove seen (mapcat neigh nodes))]\n          (recur (inc d) (into seen newnodes) newnodes))))))","problem":106,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":106,"code":"(fn maze \n    ([n1 n2] (maze n2 [[n1] 1] []))\n    ([goal current frontier]\n      (let [[f, x] current\n            temp_frontier (map #(if (even? %)\n                                  [(+ % 2) (* % 2) (/ % 2)]\n                                  [(+ % 2) (* % 2)]) f)\n            new_frontier (concat frontier (map #(vector % (inc x)) temp_frontier))]\n        (if (reduce #(or %1 %2) (map #(= % goal) f))\n          x\n          (recur goal (first new_frontier) (rest new_frontier))))))","user":"5046f909e4b03b02161376b5"},{"problem":106,"code":"(fn find-number [s g]\n (let [f (juxt #(+ % 2) #(* % 2) #(if (even? %) (/ % 2) %))]\n  (loop [ns [s] c 1]\n   (if (some #{g} ns)\n    c\n    (recur (mapcat f ns) (inc c))))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [F t]\n  (loop [f #{F} c 1]\n    (if (f t)\n      c\n      (recur (into f (mapcat #(vec [(* % 2) (if (even? %) (/ % 2) %) (+ % 2)]) f))\n             (inc c)))))","problem":106,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":106,"code":"(fn [a b] \n  (let [f (fn [i] \n            (if (odd? i) \n              [(* i 2) (+ i 2)]\n              [(* i 2) (+ i 2) (/ i 2)]))\n        fs (fn [li]\n              (reduce into #{}\n               (map f li)))]\n    (loop [x #{a} c 1]\n      (if (x b) c\n        (recur (fs x) (inc c))))))","user":"52b02329e4b0c58976d9acc5"},{"code":"(fn [s e]\r\n  (loop [o [[s 1]]\r\n         c #{s}]\r\n    (let [v (first o)\r\n          n (first v)\r\n          t (second v)\r\n          \r\n          r (inc t)\r\n          d (* n 2)\r\n          a (+ n 2)\r\n          h (if (even? n)\r\n              (/ n 2))]\r\n      (if (= n e)\r\n        t\r\n        (let [add (fn [o v]\r\n                    (if (not (c v))\r\n                      (conj o [v r])\r\n                      o))\r\n              x (-> (vec (next o)) (add d) (add a))]\r\n          (if h\r\n            (recur (add x h) (into c [d a h]))\r\n            (recur x (into c [d a]))))))))","problem":106,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn [start end]\r\n  (let [\r\n\t\tsuccessors (fn [n]\r\n\t\t\t\t\t\t(if (odd? n)\r\n\t\t\t\t\t\t\t[(+ n 2) (* n 2)]\r\n\t\t\t\t\t\t\t[(+ n 2) (* n 2) (/ n 2)]))]\r\n\t\t(loop [paths [[start]]]\r\n\t\t\t(let [shtst (first paths) head (last shtst)]\r\n\t\t\t\t(if (= head end)\r\n\t\t\t\t\t(count shtst)\r\n\t\t\t\t\t(recur (sort-by #(count %) (apply conj (next paths) (map (partial conj shtst) (successors head))))))))))","problem":106,"user":"503e7f06e4b06c4e0e1fa268"},{"problem":106,"code":"(fn [s e]\n    (let [problem {:start s\n                   :end e\n                   :transitions (fn [n]\n                                  (list (* 2 n)\n                                        (if (odd? n) n (/ n 2))\n                                        (+ 2 n)))}]\n      (loop [frontier (conj (clojure.lang.PersistentQueue/EMPTY) {:cost 1\n                                                                  :value (:start problem)})\n             explored #{}]\n        (let [{:keys [cost value] :as node} (peek frontier)]\n          (cond\n            (= (:end problem) value) cost\n            ((into #{} (map :value explored)) value) (recur (pop frontier) explored)\n            :else (let [next-states (filter #(not (or (contains? (into #{} frontier) %) (contains? explored %))) ((:transitions problem) value))]\n                    (recur (reduce conj (pop frontier) (map (fn [n]\n                                                              {:cost (inc cost)\n                                                               :value n}) next-states))\n                           (conj explored node))))))))","user":"597f8c93e4b0dbe32238d0c1"},{"code":"(letfn [(choices [x]     (map #(% x 2) (if (even? x) [* / +] [* +])))\n        (step    [xs]    (set (mapcat choices xs)))\n        (paths   [start] (iterate step #{start}))]\n  (fn number-maze [start end]\n    (->> start\n         paths\n         (take-while #(not (contains? % end)))\n         count\n         inc)))","problem":106,"user":"50586354e4b06522596eba78"},{"problem":106,"code":"(fn [x y]\n  ((fn [q y]\n     (let [p (peek q)\n           vars (fn [x] (filter integer? [(* x 2) (/ x 2) (+ x 2)]))\n           nps (map #(conj p %) (vars (last p)))]\n       (if (= y (last p))\n         (count p)\n         (recur (apply conj (pop q) (sort-by count nps)) y))))\n    (conj clojure.lang.PersistentQueue/EMPTY [x]) y))","user":"4f05ea25535dcb61093f6c02"},{"code":"(fn [start end]\r\n  (letfn [(step [h n d]\r\n                (let [v (if (odd? n) (vector (* n 2) (+ n 2)) (vector (* n 2) (/ n 2) (+ n 2)))]\r\n                  [(vec (map (fn [x] (vector d x)) (filter (comp not h) v))) (vec (filter (comp not h) v))]))\r\n          (BFS [que h]\r\n               (let [node (first que) ans (first node) n (second node) ne (step h n (inc ans))]\r\n                 (if (= n end)\r\n                   ans\r\n                   (recur (concat (rest que) (first ne)) (into h (second ne))))))]\r\n    (BFS [[1 start]] #{start})))","problem":106,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn [start end]\n  (let [bag (atom #{})\n        high (* 4 (max start end))\n        inrange? #(<= % high)\n        paths (fn [[curr :as path]]\n                (for [op0 [* + /]\n                :let [a (op0 curr 2)]\n                  :when (not (contains? @ bag end))\n\t              :when (integer? a)\n\t\t\t\t  :when (inrange? a)\n\t\t          :when (not (contains? @ bag a))]\n                  (do \n                    (swap! bag conj a) \n\t                (cons a path))))\n\t    bfs (fn [choices]\n              (mapcat paths choices))]\n              (let [goal (comp #{end} first)]\n                (->> [[start]]\n                (iterate bfs)\n                (map #(filter goal %))\n                (filter seq)\n                ffirst\n                count))))","problem":106,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn [n tgt]\n  (comment \"treat it like a graph of possible solutions,\n    do a breadth-first search\")\n  (letfn \n    [(possibilities [x]\n       (if (= x tgt) \n         [tgt]\n         (let [dbl (* 2 x) p2 (+ 2 x)]\n           (if (odd? x)\n             [dbl p2]\n             [dbl p2 (/ x 2)]))))\n     (next-nodes\n       [graph node]\n       ((:neighbors graph) node))\n     (set+ [s t] (clojure.set/union s t))\n     (set- [s t] (clojure.set/difference s t)) \n     (bfs [g start]\n       (let [step \n             (fn step [[d seen nodes]]\n               (let [newnodes (set (mapcat #(next-nodes g %) nodes))]\n                 [(inc d) (set+ seen newnodes) (set- newnodes seen)]))]\n         (iterate step [1 #{start} [start]])))]\n    (let [g {:neighbors possibilities}]\n      (loop [[[d nums] & rest] (bfs g n)]\n        (if (contains? nums tgt)\n          d\n          (recur rest))))))","problem":106,"user":"4ed188c8535d44c135fd68cf"},{"problem":106,"code":"(fn shortpath [n m]\n  (let [nextops (fn [n2 lastop]\n                  (cond (or (nil? lastop) (= lastop +)) (if (even? n2) [* + /] [* +])\n                        (= lastop *)  [* + ]\n                        :ELSE (conj (if (even? n2) [/] []) +)))]\n    (loop [iter 0 shortest 999]\n      (if (> iter 4000) shortest\n        (let [s (loop [n0 n try 1 ops (nextops n nil)]\n                  (if (or (= n0 m) (>= try shortest) (> try 16))\n                      try\n                      (let [op (ops (rand-int (count ops)))\n                            n1 (op n0 2)]\n                        (recur n1 (inc try) (nextops n1 op) ))))]\n         (recur (inc iter) s))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":106,"code":"(fn number-maze[start end]\n    (letfn [\n        (get-next-one[n]\n            (if (= (mod n 2) 0) [(/ n 2) (* n 2) (+ n 2)] [(* n 2) (+ n 2)])    \n        )\n        (get-next-all[s]\n            (->> (for [n s] (get-next-one n)) flatten set)\n        )\n        (get-next [prev] \n            (lazy-seq (cons prev (get-next (get-next-all prev))))\n        )\n    ]\n        (inc (count (take-while #(not (contains? % end)) (get-next #{start}))))\n    )\n)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn nu-maze [start end]\n (let [ways [[#(* % 2) identity][#(+ % 2) identity][#(/ % 2) even? ]]\n       h (fn [n] (if (even? n)(/(Math/log(/(max n end)(min n end)))(Math/log 2))(/ (-(max n end)(min n end)) 2)))\n       get-ways (fn [n] (filter #((peek %) n) ways))\n       get-pendings (fn [n] (distinct (map #((first %)n) (get-ways n))))\n       shortest (map drop-last(reverse\n        (loop [p [[start 0]] path [] i 0]\n           (let [pendings  (vec(sort-by #(+(peek %)(h (first %))) (remove (fn [x] (some #(= (first x) (first %))  path)) p)))\n               best (first pendings)\n               ]\n             (cond (> i 40) path\n                 (= end (first best)) (conj path best)\n                 :else\n                (recur (concat (rest pendings) (map #(vector % (first best) (inc(count path)))(get-pendings (first best))))\n                         (conj path best)\n                         (inc i)\n                         )\n                 )\n           )\n         )))\n       ]\n     (count(reduce #(if (=(first %2)(last(peek %)))(conj % %2) %) [(first shortest)] (rest shortest)))\n       \n   )\n )","problem":106,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [a b] \n     (letfn [ (ch [ x ] (let [ c [(* x 2) (+ x 2)]] (if (even? x) (conj c (/ x 2)) c )))   \n             (nm [ depth nodes ]\n         (if (contains? nodes b) depth\n           (nm (inc depth) (set (mapcat ch nodes)))))]\n            (nm 1 #{ a })))","problem":106,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn shortest-path [start end]\n  (letfn [(operations-set [value last-op]\n            (concat [+] \n                    (if (not= last-op /) \n                      [*] \n                      []) ; no reason to double just halved number\n\n                    (if (and (not= last-op *) (even? value)) \n                      [/] ; only halve if not doubled and even\n                      [])\n                    ))\n          (next-values [values saw]\n            (into {} \n                  (apply concat (for [[value ops] values]\n                                  (map \n                                    (fn [op] \n                                      (let [next-value (op value 2)]\n                                        (when (not (contains? saw next-value))\n                                          [next-value (operations-set next-value op)]))) ops)))))]    \n\n    (loop [values {start (operations-set start :none)} \n           saw #{start}\n           length 1]\n      (if (contains? saw end)\n        length\n        (let [new-values (next-values values saw)]\n          (recur new-values \n                 (into saw (keys new-values)) \n                 (inc length))\n          )))))","problem":106,"user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn [a b]\n  (inc (count (take-while (fn [[_ coll]]\n                            (not (some #{b} coll)))\n                          (iterate (fn [[seen coll]]\n                                     (vector (into seen coll)\n                                             (mapcat (fn [x]\n                                                       (if (even? x)\n                                                         [(+ x 2) (/ x 2) (* x 2)]\n                                                         [(+ x 2) (* x 2)]))\n                                                     (remove seen coll))))\n                                   (vector #{} [a]))))))","problem":106,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":106,"code":"(fn bfs [start end]\n  (letfn [(double [n] (* n 2))\n          (halve [n] (quot n 2))\n          (add2 [n] (+ n 2))\n          (_bfs [queue]\n            (let [[v n] (peek queue)\n                  new-n (inc n)\n                  new-queue (pop queue)]\n              (cond (= v end) n\n                    :else (if (odd? v)\n                            (recur (conj new-queue\n                                         [(double v) new-n]\n                                         [(add2 v) new-n]))\n                            (recur (conj new-queue\n                                         [(double v) new-n]\n                                         [(add2 v) new-n]\n                                         [(halve v) new-n]))))))]\n    (_bfs (conj (clojure.lang.PersistentQueue/EMPTY) [start 1]))\n    ))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"#((fn f [n s]\n  (if (s %2)\n    n\n    (f (+ 1 n)\n      (into #{} \n        (flatten\n          (for [x s :let [h (/ x 2) \n                          d (* 2 x)\n                          y (+ 2 x)]]\n            (if (odd? x)\n              [x d y]\n              [x h d y]))))))\n) 1 #{%})","problem":106,"user":"4f01c938535dcb61093f6a39"},{"code":"(fn  p106 [n1 n2]\n  (let [ newvalue (fn [oldvalue] (if (even? oldvalue)\n                                   [ (/ oldvalue 2) (+ oldvalue 2)  (*  oldvalue 2) ]\n                                   [  (+ oldvalue 2)  (*  oldvalue 2) ]\n                                   ) )\n\n         find-path (fn find-path [steps lastvalues]\n                   (if (some #(= n2 %)  lastvalues )\n                        steps\n                        (find-path (inc steps)  (mapcat newvalue lastvalues)   )\n                     ))\n       ]\n    (find-path 1 [n1])\n    )\n  )","problem":106,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":106,"code":"(fn [start end]\n  (let [step0 #(list (* % 2) (+ % 2))\n        step1 #(if (= 0 (mod % 2)) (cons (/ % 2) (step0 %)) (step0 %))\n        step-set #(into #{} (mapcat step1 %))]\n    (inc (count (take-while #(not (contains? % end)) (iterate step-set #{start}))))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn [start end]\n  (letfn [(transitions [n]\n            (if (odd? n)\n              [(* 2 n) (+ 2 n)]\n              [(* 2 n) (+ 2 n) (/ n 2)]))\n          \n          (go [queue]\n            (when (seq queue)\n              (let [top      (peek queue)\n                    location (last top)]\n                (if (= location end)\n                  (count top)\n                  (recur (reduce #(conj %1 (conj top %2))\n                                 (pop queue)\n                                 (transitions location)))))))]\n    (go (conj clojure.lang.PersistentQueue/EMPTY [start]))))","problem":106,"user":"51d19c24e4b0cfcf579466c3"},{"problem":106,"code":"(fn [a b] ((fn x [l n] (if (some #{b} l) n (x (mapcat #(if (odd? %) [(* 2 %) (+ 2 %)] [(* 2 %) (+ 2 %) (/ % 2)]) l) (inc n)))) [a] 1))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [a b] (loop [l [a] n 1]\n(if (some #{b} l) n\n(recur (filter integer? \n(flatten (map \n(fn [x] ((juxt #(* 2 %) #(+ 2 %)\n#(/ % 2)) x)) l)) ) (+ 1 n))\n)\n))","problem":106,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [/ s e]\n  (#(let [[s c] (first %)\n         n (fn [o] (vector (o s 2) (inc c)))]\n    (if (= s e) c\n      (recur (into (vec (rest %))\n                   (into #{} (map n [* / +])))))) [[s 1]]))\n#((if (even? %1) quot *) %1 %2)","problem":106,"user":"504e04a4e4b078edc5f59397"},{"code":"(let [\n  cartesian-product (fn   [& seqs]\n  (let [v-original-seqs (vec seqs)\n  step\n\t(fn step [v-seqs]\n\t  (let [increment\n\t\t(fn [v-seqs]\n\t\t  (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n\t\t    (if (= i -1) nil\n\t\t\t(if-let [rst (next (v-seqs i))]\n\t\t\t  (assoc v-seqs i rst)\n\t\t\t  (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n\t    (when v-seqs\n\t       (cons (map first v-seqs)\n\t\t     (lazy-seq (step (increment v-seqs)))))))]\n    (when (every? first seqs)\n      (lazy-seq (step v-original-seqs)))))\n\n  selections (fn [items n]\n  (apply cartesian-product (take n (repeat items))))\n  \n  ops [#(when (even? %) (int (/ % 2)))\n            #(* % 2) #(+ % 2)]\n       r #(when (last %) (conj % (%2 (last %))))\n       run #(reduce r [%] %2)\n       c (mapcat #(selections ops %) (range 9))]\n   (fn [s e]\n      (->>\n       (map #(run s %) c)\n       (filter #(= e (last %)))\n       first\n       count)))","problem":106,"user":"4e96557d535dbda64a6f6b43"},{"problem":106,"code":"(fn path\n  [a b]\n  (letfn\n  [\n    (diff [s1 s2]\n      (into #{} (filter #(not (contains? s2 %)) s1)))\n    (next-gen\n      [n]\n        (if (even? n)\n          [(* 2 n) (/ n 2) (+ n 2)]\n          [(+ n 2) (* n 2)]))\n    (next-gen-seq\n      [s]\n      (diff\n        (into #{}\n          (mapcat\n            next-gen\n            s))\n        s))\n    (next-gen-iter\n      [n]\n      (iterate next-gen-seq #{n}))\n\n  ]\n  (inc (count (take-while #(not (contains? % b)) (next-gen-iter a))))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [a b]\n  (letfn [(p [x n] (or (= x b)\n                       (and (> n 1)\n                            (or (p (* 2 x) (dec n))\n                                (and (even? x) (p (quot x 2) (dec n)))\n                                (p (+ 2 x) (dec n))))))]\n    (some #(when (p a %) %) (range 1 10))))","problem":106,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn [a b]\n  (letfn\n    [(s [f]\n      (fn [x]\n        (some (fn [[x y]] (when (= x y) x))\n              (partition 2 1 (iterate f x)))))\n     (f [m]\n       (apply merge-with min\n         (apply concat\n           (for [[n c] m]\n             (if (= n b)\n               [{n c}]\n               (if (>= c (m b))\n                 []\n                 (concat\n                   (if (even? n)\n                     [{(/ n 2) (inc c)}]\n                     [])\n                   [{(* n 2) (inc c)}\n                    {(+ n 2) (inc c)}])))))))]\n    (((s f)\n      (merge-with min {a 1} {b 1000}))\n      b)))","problem":106,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [a b]\n  (loop [c 1\n         d [a]]\n    (if (seq (filter #(= % b) d))\n      c\n      (recur (inc c) (mapcat\n                         #(vector\n                            (+ % 2)\n                            (* % 2)\n                            (if (even? %) (/ % 2) (+ % 2))\n                         )\n                       d)\n      )\n    )\n  )\n)","problem":106,"user":"4e3456f9535deb9a81d77f2a"},{"code":"(fn [start-n target-n]\n  (letfn [(traverse [n' to-visit]\n            (let [n (first n')\n                  dbl  (* n 2)\n                  hlv  (/ n 2)\n                  add2 (+ n 2)\n                  reduce-fn (fn [memo item]\n                              (conj memo (flatten (conj n' item))))\n                  to-visit' (if (even? n)\n                              (reduce reduce-fn to-visit [dbl hlv add2])\n                              (reduce reduce-fn to-visit [dbl add2]))]\n              (if (= n target-n)\n                n'\n                (recur (first to-visit') (into [] (rest to-visit'))))))]\n    (count (traverse (list start-n) []))))","problem":106,"user":"51195e77e4b055cfb310d499"},{"code":"(fn [n m]\n  (letfn [(g [s d] (set (concat (map #(* 2 %) s) (map #(+ d %) s)\n                                (filter integer? (map #(/ % 2) s)))))\n          (s [n i j] (if (empty? (clojure.set/intersection i j))\n                       (if (> (count i) (count j))\n                         (recur (inc n) i (g j -2))\n                         (recur (inc n) (g i 2) j))\n                       n))]\n    (s 1 #{n} #{m})))","problem":106,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":106,"code":"(letfn [(x [coll e n]\n          (if (not (= -1 (.indexOf coll e))) n\n            (recur (distinct (flatten (map #(remove nil? (list (* 2 %)\n                                                               (+ 2 %)\n                                                               (if (= 0 (mod % 2))\n                                                                 (quot % 2)\n                                                                 nil)))\n                                           coll)))\n                   e\n                   (inc n))))]\n  #(x (list %) %2 1))","user":"538e36c7e4b0b51d73faae81"},{"problem":106,"code":"(fn [s e]\n  (letfn\n    [(children [s d]\n       (lazy-cat [[(* s 2) (inc d)]\n                  [(+ s 2) (inc d)]]\n                 (if (zero? (mod s 2))\n                   [[(quot s 2) (inc d)]]\n                   [])))\n     (bfs [s]\n       (lazy-seq (let [f (peek s)\n                       r (pop s)]\n                   (cons f (bfs (into r (children (first f) (second f))))))))]\n    (second (first (drop-while #(not= (first %) e) (bfs (conj clojure.lang.PersistentQueue/EMPTY [s 1])))))))","user":"53664e3be4b0243289761e74"},{"problem":106,"code":"(letfn [(explore \n         [[n & xs]] \n         (->> xs\n              (mapcat #(list (* % 2) (+ % 2) \n                             (if (even? %) (/ % 2 ))))\n              (remove nil?)\n              (cons (inc n))\n              vec))]\n (fn maze [beg end]\n   (->> (iterate explore [1 beg])\n        (filter #(some #{end} (rest %)))\n        (ffirst))))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [s e]\n  ((fn [xs n]\n     (if (some #(= % e) xs) n\n         (recur (concat (map #(* % 2) xs)\n                        (map #(+ % 2) xs)\n                        (keep #(if (even? %) (/ % 2)) xs))\n                (inc n))))\n   [s] 1))","problem":106,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":106,"code":"#(let [e even?\n       o odd?\n       i inc]\n  ((fn p [a z]\n     (cond (= a z) 1\n           (and (o a) (e z)) (if (< (* 2 a) z)\n                                 (i (p (* a 2) z))\n                                 (+ 2 (p (+ 2 (* 2 a)) z)))\n           (and (o a) (o z)) (i (p (+ a 2) z))\n           (and (e a) (o z)) (i (p (/ a 2) z))\n           (= (* 2 a) z)     (i (p (* a 2) z))\n           (and (e a) (e z) (> a z) (e (/ a 2))) (i (p (/ a 2) z))\n           (and (e a) (e z) (o (/ a 2)))         (i (p (+ a 2) z)))) % %2))","user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn [a b]\r\n    (loop [r [a] n 1]\r\n      (if (some #(= b %) r) n\r\n        (recur (mapcat (fn [x] (map #(% x) \r\n                                    [#(* % 2) \r\n                                     #(if (even? %) (/ % 2) %)\r\n                                     #(+ % 2)]))\r\n                       r) \r\n               (inc n)))))","problem":106,"user":"4f58d92fe4b0a7574ea71858"},{"problem":106,"code":"(letfn [(possible [n] (remove nil? ((juxt #(+ 2 %) #(* 2 %) #(when (even? %) (/ % 2))) n)))\n        (target [t coll]\n          (if (contains? (last coll) t)\n            (count coll)\n            (let [previous (apply clojure.set/union (butlast coll))\n                  next (set (mapcat possible (last coll)))]\n              (conj coll (clojure.set/difference next previous)))))]\n  (fn [s t] (first (drop-while (complement integer?) (iterate (partial target t) [#{s}])))))","user":"554680cbe4b0a04f7929953e"},{"problem":106,"code":"(fn __ [s e]\n    ((fn g [p & n-s]\n        (if (some #(= % e) n-s)\n            p\n            (let [ d (partial * 2) h #(quot % 2) di (partial + 2) ]\n                       (->>\n                           (map \n                              #(->> \n                                   (vector (d %) (if (zero? (rem % 2)) (h %) nil) (di %))\n                                   (filter (complement nil?)))\n                              n-s)\n                           (flatten)\n                           (apply g (inc p))))))\n     1 s))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":106,"code":"(fn [n1 n2]\n    (letfn [(p [n] (+ n 2))\n            (m [n] (* n 2))\n            (d [n] (/ n 2))\n            (intermediates [fns]\n              (let [f (fn [x] ((apply juxt (map #(apply comp (reverse (take %1 fns))) (range 1 (inc (count fns))))) x)) ]\n                (fn [& xs] (map f xs))))\n            (fun-thread [q & funs]\n              (first ((intermediates funs) q)))\n\n            (opt [s]\n              (loop [h (first s) r (rest s) a []]\n                (if (empty? r) (cons h a)\n                    (if (some #(= % h) r)\n                      (recur h (rest (drop-while #(not= % h) r)) a)\n                      (recur (first r) (rest r) (cons h a))))))\n\n            (solve-maze [n1 n2]\n              (loop [n1 n1 n2 n2 a [n1]]\n                (let [dd (- n2 n1)]\n                  (if (= dd 0) (-> a opt reverse)\n                      (let [newa (cond\n                                  (= dd 1) (fun-thread n1 m p d)\n                                  (= dd 2) (fun-thread n1 p)\n                                  (= dd n1) (fun-thread n1 m)\n                                  (= (mod n1 n2) 0) (fun-thread n1 d)\n                                  (= (mod n2 n1) 0) (fun-thread n1 m)\n                                  (= dd 3) (fun-thread n1 p)\n                                  (< dd 0) (if (even? n1)\n                                             (fun-thread n1 d p)\n                                             (fun-thread n1 m p d))\n                                  (> dd 0) (fun-thread n1 m))]\n                        (recur (last a) n2 (concat a newa)))))))]\n      (count (solve-maze n1 n2))))","user":"4f3ec266e4b0e243712b1f8c"},{"problem":106,"code":"(fn f\n  ([s t] (f s t 1))\n  ([s t n]\n      (if (or (= s t) (> n 9)) n\n          (min\n            (f (* s 2) t (+ n 1))\n            (f (+ s 2) t (+ n 1))\n            (if (even? s) (f (/ s 2) t (+ n 1)) 10)))))","user":"53500869e4b084c2834f4ad3"},{"problem":106,"code":"(fn[a b]\n        (let [path-length\n              (fn[a b parents]\n                (loop [res 1\n                       x b]\n                  (if (= x a)\n                    res\n                    (recur (inc res) (parents x)))))\n\n              neighbors\n              (fn[n]\n                (remove nil? \n                        [(* n 2) (+ n 2) (if (even? n) (quot n 2))]))]\n              \n              (loop [open (conj clojure.lang.PersistentQueue/EMPTY a)\n                     parents {}\n                     closed #{}]\n            \n                (if (empty? open)\n                  false\n                  (let\n                      [head (peek open)\n                       open (pop open)]\n                    (if (= b head)\n                      (path-length a b parents)\n                      (let [new (remove closed (neighbors head))]\n                        (prn closed \"::\" head \"->\" new)\n                        (recur (into open new) \n                               (into parents (zipmap new (repeat head)))\n                               (if (empty? new) closed (apply conj closed new))))))))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":106,"code":"(fn [s e]\n  (loop [n 1 c #{s}]\n    (if (c e)\n      n\n      (recur\n        (inc n)\n        (set\n          (mapcat\n            (fn [x] (map #(% x 2) [+ * (if (odd? x) * /)]))\n            c))))))","user":"4eb70649535d7eef30807373"},{"problem":106,"code":"(fn np [a b]\n  (letfn [(numpath [a b n]\n            (cond (= a b) true\n                  (= n 1) false\n            :else (contains? (set (list (numpath (* a 2) b (dec n)) \n                                        (numpath (+ a 2) b (dec n))\n                                        (when (even? a) \n                                          (numpath (/ a 2) b (dec n))))) true)))\n          (nplocal [a b n]\n            (if (true? (numpath a b n)) n\n            (nplocal a b (inc n))))]\n    (nplocal a b 1)))","user":"53e9a15be4b036ad0777e4ae"},{"problem":106,"code":"(fn\n  [src dest]\n  ; use BFS\n  (loop [q [[src 1]]\n         visited #{}]\n    (if (seq q)\n      (let [[c l] (first q)\n            t (vec (rest q))]\n        (if (contains? visited c)\n          (recur t visited)\n          (if (= dest c)\n            l\n            (let [visited' (conj visited c)\n                  l' (inc l)\n                  q' (conj (conj t [(+ c 2) l'])\n                           [(* c 2) l'])\n                  q'' (if (odd? c)\n                        q'\n                        (conj q' [(quot c 2) l']))]\n              (recur q'' visited')))))\n      nil)))","user":"52dfc89be4b09f7907dd1405"},{"problem":106,"code":"(fn [a b]\n  (loop [aa [a] i 1]\n    (if (some #(= b %) aa)\n      i\n      (recur (for [a aa\n                   f [#(* % 2) #(/ % 2) #(+ % 2)]]\n               (f a))\n             (inc i)))))","user":"56102f50e4b05f002753df6b"},{"code":"(fn f [a b]\n  (if (= a b) a\n      (letfn [(sf [b path]\n                (->> path\n                     first\n                     ((fn [x] [x (* 2 x) (+ 2 x) (if (even? x) (/ x 2) nil)]))\n                     (filter #(not (nil? %)))\n                     (map #(conj path %))))]\n        (loop [p (list (list a))]\n          (let [r (reduce into (map #(sf b %) p))\n                k (filter #(= b (first %)) r)]\n            (if (< 0 (count k)) (-> k first count)\n                (recur r)))))))","problem":106,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":106,"code":"(fn [start goal]\n   (loop [queue   (conj clojure.lang.PersistentQueue/EMPTY [start 1])\n          explored #{}]\n\n     (let [explore (fn [[val dist]] (if (odd? val)\n                                      [[(* val 2) (inc dist)] [(+ val 2) (inc dist)]]\n                                      [[(/ val 2) (inc dist)] [(* val 2) (inc dist)] [(+ val 2) (inc dist)]]\n                                      ))\n           explored? (fn [val _] (contains? explored val))\n           v           (peek queue)\n           neighbors   (explore v)\n           not-explored (filter (complement #(explored? % explored)) neighbors)\n           new-queue   (apply conj (pop queue) not-explored)]\n       (if (= (first v) goal)\n         (second v)\n         (recur new-queue (conj explored (first v))))))\n\n   )","user":"5d1a1082e4b0902706380e0e"},{"problem":106,"code":"(fn [start end]\n  (let [fns [(partial * 2) (partial + 2) #(if (even? %) (/ % 2))]]\n    (loop [paths (list [start])]\n      (println paths)\n      (if-let [solutions (seq (filter #(= end (last %)) paths))]\n        (count (first solutions))\n        (recur (mapcat #(map conj (repeat %) (remove nil? ((apply juxt fns) (last %)))) paths))))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [s g] (loop [c 1 nums [s]]\n                    (if (not= (.indexOf nums g) -1)\n                      c\n                      (let [p (map #(let [n [(+ % 2) (* % 2)]]\n                                      (if (= 0 (rem % 2)) (conj n (/ % 2)) n)) nums) p2 (vec (set (flatten p)))]\n                        (recur (inc c) p2)))))","problem":106,"user":"52c1bd29e4b07a9af579236a"},{"problem":106,"code":"(fn [a b]\n  (letfn [(f [n coll]\n            (let [s (into #{} (apply concat (map #((juxt (partial + 2) (partial * 2) (fn [x] (if (even? x) (/ x 2) x))) %) coll)))]\n              (if-not (s b)\n                (f (inc n) s)\n                n)\n              ))]\n    (if (= a b) 1\n      (f 2 [a])\n      ))\n  )","user":"53b530c6e4b047364c0444bc"},{"code":"(fn [s t]\n  (loop [c #{s} l 1]\n    (if (contains? c t)\n      l\n      (recur (into #{} (apply concat (map #(if (odd? %)\n                     [(+ 2 %) (* 2 %)]\n                     [(+ 2 %) (* 2 %) (/ % 2)]) c))) (inc l)))))","problem":106,"user":"513b77f3e4b00f740c76c403"},{"problem":106,"code":"(fn [start end] (->> (iterate (fn [a-set] (let [triple (fn [no] [(+ no 2) (* no 2) (if (= 0 (rem no 2)) (/ no 2))])]\n                                                 (->> (mapcat triple a-set)\n                                                      (filter #(not= nil %))\n                                                      (apply (partial conj a-set))))) \n                                   #{start})\n                          (take-while #(not (contains? % end)))\n                          count\n                          (+ 1)))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn [start end]\n  (letfn [(next-step [n]\n            [(+ n n)\n             (if (even? n) (/ n 2) (+ n 2))\n             (+ n 2)\n             ])\n          (apply-next-step [s] \n            (set (mapcat next-step s)))]\n    (loop [s (hash-set start) length 1]\n    (if (s end)\n      length\n      (recur (apply-next-step s) (inc length))\n      ))))","problem":106,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn [p1 p2]\n  (letfn [(mn\n    [n]\n    (remove nil? [\n      n\n      (* 2 n)\n      (if (even? n) (/ n 2))\n      (+ n 2)\n    ]))]\n  (loop [i 1 v [p1]]\n    (if (some #(= p2 %) v)\n      i\n      (recur (inc i) (mapcat mn v))))))","problem":106,"user":"50843a4ae4b0c98812d0788b"},{"code":"(fn maze [s e]\n  (let [mix #(filter integer? [(* % 2) (/ % 2) (+ % 2)])]\n    (loop [l 1 ; length of the paths\n           tries [s]] ; all the different paths atteigned from the start\n      (if (some #(= % e) tries) l\n        (recur (inc l) (mapcat mix tries))))))","problem":106,"user":"500900dee4b0144d4f561e42"},{"problem":106,"code":"(fn [x y] (first (first (filter\n                       #((second %) y)\n                       (iterate\n                        (fn [item]\n                          (let [i (first item) opts (second item)]\n                            [(inc i) (set (mapcat\n                                           (fn [n]\n                                             (let [main [(* n 2) (+ n 2)]]\n                                               (if (> (rem n 2) 0) main (conj main (/ n 2)))))\n                                           opts))]))\n                        [1 #{x}])))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [n t]\n  (loop [s #{n}, l 1]\n    (if (s t) l\n      (recur (set (mapcat \n                    #(list* (* % 2)\n                            (+ % 2)\n                            (if (odd? %) nil [(/ % 2)]))\n                    s))\n             (inc l)))))","problem":106,"user":"522b922ee4b0d34ee08e71c3"},{"problem":106,"code":"(fn [start finish]\n  (loop [distance 1\n         positions #{start}]\n    (if (positions finish)\n      distance\n      (recur (inc distance)\n             (set (concat (map #(* 2 %) positions) \n                          (map #(+ 2 %) positions)\n                          (map #(/ % 2) (filter even? positions))))))))","user":"53acaf1fe4b047364c04445f"},{"problem":106,"code":"(fn [start end]\n  (\n   (fn [depth toVist nextDepth]\n     (if (empty? toVist)\n       (recur (inc depth) nextDepth #{})\n       (let [current (first toVist)]\n         (if (= current end)\n           depth\n           (recur depth (rest toVist) \n                  (apply conj nextDepth (if (even? current) \n                                          [(* 2 current)\n                                           (/ current 2)\n                                           (+ current 2)]\n                                          [(* 2 current)\n                                           (+ current 2)]\n                                          )\n                         )\n                  )\n           )\n         )\n       ) \n     )\n   1 (conj #{} start) #{}\n   )\n  )","user":"57011eb3e4b08d47c97781d1"},{"problem":106,"code":"(let [destinations (fn [n]\n                       (if (even? n)\n                         [(* n 2) (/ n 2) (+ n 2)]\n                         [(* n 2) (+ n 2)]))]\n    (fn [a b]\n      (loop [gen 1\n             points #{a}]\n        (if (points b)\n          gen\n          (recur\n            (inc gen)\n            (set (mapcat destinations points)))))))","user":"5bab5440e4b0a20761a23475"},{"problem":106,"code":"; breadth-first search adapted from https://stackoverflow.com/a/32774592\n(fn number-maze [start end]\n  (letfn [(goal? [val] (= end val))\n          (tree-val [tree] (identity tree))\n          (children [tree]\n            (if (odd? tree)\n              [(+ tree 2) (* tree 2)] \n              [(+ tree 2) (* tree 2) (/ tree 2)]))\n          (queue [& vals]\n            (apply conj clojure.lang.PersistentQueue/EMPTY vals))]\n    (let [s (atom #{})]\n      (->\n        (loop [q (queue {:tree start :path []})]\n          (when-let [{:keys [tree path]} (peek q)]\n            (let [seen? @s]\n              (do\n                (swap! s conj (tree-val tree))\n                (cond\n                  (goal? tree) path\n                  ; skip nodes already seen earlier in some branch.\n                  ; by definition this would be a longer path.\n                  (seen? tree) (recur (pop q))\n                  :else\n                  (let [new-path (conj path (tree-val tree))\n                        wrap     (fn [t] {:tree t :path new-path})]\n                    (recur (->> (children tree)\n                                (map wrap)\n                                (apply conj (pop q))))))))))\n        (count)\n        (inc)))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":106,"code":"(fn num-maze-steps [start end]\n  (letfn [(possible-operations [n]\n            (let [ops [#(+ %1 2), #(* %1 2)]]\n              (if (even? n)\n                (conj ops #(/ %1 2))\n                ops)))\n\n          (apply-operations [nums]\n            (mapcat (fn [n] (map #(%1 n) (possible-operations n))) nums))]\n\n    (loop [nodes [start]\n           step  1]\n      (if (some #(= end %) nodes)\n        step\n        (recur (apply-operations nodes), (inc step))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(letfn [\n\n(bfs [current-cands calc-next-cands]\n  (lazy-cat\n    current-cands\n    (bfs (for [c current-cands c (calc-next-cands c)] c) calc-next-cands)))\n(num-maze [path]\n  (let [n (first path)]\n    (map #(cons % path)\n         (if (even? n)\n           (list (+ n n) (/ n 2) (+ 2 n))\n           (list (+ n n) (+ 2 n))))))\n]\n\n(fn [f t]\n  (count (first (drop-while #(not= t (first %))\n    (bfs [[f]] num-maze)))))\n\n)","problem":106,"user":"4dfd4ba8535d04ed9115e781"},{"code":"#(loop [[[c d p] & r] [[% %2 []]]]\n     (if (= c d)\n       (inc (count p))\n       (recur (concat r (mapcat (fn [o] (if-not (some #{c} p)\n                                         [[(o c 2) d (conj p c)]]\n                                         []))\n                                (if (even? c) [* / +] [* +]))))))","problem":106,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn nm [s e]\n  (loop [l [s]]\n    (let [i (last l)]\n      (cond\n       (= e i) (count l)\n       (or (= (/ e 2) i)\n           (= (/ e 4) i)\n           (= (/ e 8) i)) (recur (concat l [(* i 2)]))\n       (or (= (/ i 2) e)\n           (= (/ i 4) e)\n           (= (/ i 8) e)) (recur (concat l [(/ i 2)]))\n       (or (= (+ i 2) e)\n           (= (+ i 4) e)\n           (= (+ i 8) e)) (recur (concat l [(+ i 2)]))\n       (and (odd? i)\n            (> i e)) (recur (concat l [(* i 2)]))\n       (and (even? i)\n            (even? (/ i 2))\n            (> i e)) (recur (concat l [(/ i 2)]))\n       (and (even? i)\n            (odd? (/ i 2))\n            (> i e)) (recur (concat l [(+ i 2)]))\n       (and (< i e)\n            (< (* 2 i) e)) (recur (concat l [(* i 2)]))\n       (and (< i e)\n            (< (+ 2 i) e)) (recur (concat l [(+ i 2)]))\n       (and (< i e)\n            (> (+ 2 i) e)) (recur (concat l [(* i 2)]))\n       :else l \n       ))))","problem":106,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":106,"code":"(fn [start end]\r\n  (loop [\r\n      visited #{}\r\n      [start dist & tail] [start 1]]\r\n    (if start\r\n      (if (visited start)\r\n        (recur visited tail)\r\n        (if (= start end)\r\n          dist\r\n          (recur (conj visited start) (concat tail\r\n            [(* start 2) (inc dist)]\r\n            (if (odd? start) [] [(/ start 2) (inc dist)])\r\n            [(+ start 2) (inc dist)] )))))))","user":"555bd27ae4b0b056612e2244"},{"code":"#(loop [q [[% 1]]]\r\n  (let [[n p] (first q)\r\n        p1    (inc p)\r\n        v1    [(+ n 2) p1]\r\n        v2    [(* n 2) p1]\r\n        v3    [(/ n 2) p1]]\r\n    (if (= n %2) p\r\n      (recur (concat (next q)\r\n              (if (even? n) [v1 v2 v3] [v1 v2]))))))","problem":106,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn number-maze [start end]\n  (let [operations [#(* % 2)\n                    #(if (even? %) (/ % 2))\n                    #(+ % 2)]]\n    (letfn [(next-try [i tries]\n              (if (contains? tries end)\n                i\n                (recur (inc i)\n                       (into #{} \n                             (filter (complement nil?)\n                                     (for [op operations num tries]\n                               (op num)))))))]\n      (next-try 1 #{start}))))","problem":106,"user":"50812debe4b01a93d3f38e4c"},{"problem":106,"code":"(fn maze [start end]\n  (let [gv (fn [prev] \n             (apply merge-with min prev \n                    (for [v prev\n                          :let [k (key v)\n                                nl (inc (val v))\n                                ops (if (even? k) [* + /] [* +])]]\n                      (mapcat #(hash-map (% k 2) nl) ops))))]\n  (loop [prev {start 1}]\n    (if-let [result (prev end)]\n      result\n      (recur (gv prev))))))","user":"51aefceee4b09397d5109797"},{"problem":106,"code":"(fn [a b]\n  (loop [c [a]\n         l 1]\n    (if (some #(= b %) c)\n      l\n      (recur (filter #(not (nil? %))\n                     (mapcat (juxt #(* 2 %)\n                                   #(when (even? %) (/ % 2))\n                                   #(+ 2 %))\n                             c))\n             (+ 1 l)))))","user":"5742ec91e4b05c31a32c0883"},{"problem":106,"code":"(fn number-maze--brute\n  [x y] {:pre [(every? integer? [x y]), (every? pos? [x y])]}\n  (let [;; This function returns a sequence containing all numbers reachable\n        ;; from n in one operation.\n        maze-adj\n        (fn [n]\n          (if (even? n)\n            [(* n 2) (/ n 2) (+ n 2)]\n            [(* n 2) (+ n 2)]))]\n    ;; In this loop,\n    ;; found is a set containing all numbers reachable in fewer than i steps,\n    ;; while hits is a sequence containing numbers reachable in exactly i steps.\n    (loop [found #{}, hits [x], i 1]\n      (if (some #{y} hits)\n        i\n        (recur (into found hits)\n               (mapcat maze-adj (remove found hits))\n               (inc i))))))","user":"4fc6305de4b0ee37620e180b"},{"problem":106,"code":"(fn [a b]\n  (let [next-set (fn [s]\n                   (set (flatten (map (fn [n]\n                                        (if (odd? n)\n                                          [(+ n 2) (* n 2)]\n                                          [(+ n 2) (* n 2) (/ n 2)]))\n                                      s))))]\n    (loop [s #{a}\n           c 1]\n      (if (contains? s b)\n        c\n        (recur (next-set s) (inc c))))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [start end]\n  (let [rules-rfn\n        (fn [acc x]\n          (if (even? x)\n            (conj acc (* x 2) (quot x 2) (+ x 2))\n            (conj acc (* x 2) (+ x 2))))]\n  (loop [steps 1 reachable [start]]\n    (if (some #(= end %) reachable)\n      steps\n      (recur (inc steps) (reduce rules-rfn [] reachable))))))","problem":106,"user":"52015698e4b0d7096e99ddba"},{"problem":106,"code":"(fn [b e]\n  (loop [i 1 s #{b}]\n  \t\t\t(if (s e)\n    \t\t\ti\n    \t\t\t(recur (+ 1 i) (reduce #(conj % (* 2 %2) (+ 2 %2) (/ %2 2)) s s)))))","user":"577202d2e4b0979f896515c0"},{"code":"(fn nm [z y]\n\t\t(let [x (vector (vector (list z) :n))\n\t\t\t  b(fn b [[s o]]\n\t\t\t\t\t(if (odd? (first s))\n\t\t\t\t\t\t(vector (vector (cons (+ (first s) 2) s) :a) (vector (cons (* (first s) 2) s) :m))\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(or (= o :n) (= o :a)) (vector (vector (cons (+ (first s) 2) s) :a) (vector (cons (* (first s) 2) s) :m) (vector (cons (/ (first s) 2) s) :d))\n\t\t\t\t\t\t\t(= o :m) (vector (vector (cons (+ (first s) 2) s) :a) (vector (cons (* (first s) 2) s) :m))\n\t\t\t\t\t\t\t(= o :d) (vector (vector (cons (+ (first s) 2) s) :a) (vector (cons (/ (first s) 2) s) :d)))\n\t\t\t\t\t))]\n\t\t((fn c [s y]\n\t\t\t(let [res (filter #(= (first (first %)) y) s)]\n\t\t\t\t(if (not (empty? res))\n\t\t\t\t\t(count (first (first res)))\n\t\t\t\t\t(c (mapcat b s) y)))) x y)))","problem":106,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn number-maze [start end]\n  (letfn [(next-level [[plevel visited]]\n            (let [ nlevel (->> plevel\n                               (map (fn [n] (if (even? n)\n                                              [(+ 2 n) (* 2 n) (/ n 2)]\n                                              [(+ 2 n) (* 2 n)])))\n                               (flatten)\n                               (remove visited)\n                               (set))]\n              [nlevel (into visited nlevel)]))]\n    (->> (iterate next-level [#{start} #{start}])\n         (keep-indexed (fn [idx level]\n                         (when (some #{end} (first level))\n                           (inc idx))))\n         (first))))","problem":106,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":106,"code":"(fn [start goal]\n  (loop [guesses [start]\n         step 1]\n    (if (some #(= % goal) guesses)\n      step\n      (recur (mapcat (fn [v] [(* v 2) (/ v 2) (+ v 2)]) guesses)\n             (inc step)))))","user":"52173464e4b082aa80a88c75"},{"problem":106,"code":";; http://www.4clojure.com/problem/106\n;; Number Maze\n(fn scan-number-maze\n  ([current-num target-num]\n   (inc (scan-number-maze current-num target-num 0 Integer/MAX_VALUE)))\n  ([current-num target-num len shortest]\n   (if (> len 10)\n     shortest\n     (if (= current-num target-num)\n       (if (nil? shortest)\n         len\n         (if (> len shortest)\n           shortest\n           len))\n       (min \n        (scan-number-maze (* 2 current-num) target-num (inc len) shortest)\n        (if (even? current-num)\n          (scan-number-maze (quot current-num 2) target-num (inc len) shortest)\n          Integer/MAX_VALUE)\n        (scan-number-maze (+ 2 current-num) target-num (inc len) shortest))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":106,"code":"(fn min-steps [start finish]\n  (letfn [(times2 [x] (* x 2))\n          (halve [x] (if (odd? x) x (/ x 2)))\n          (add2 [x] (+ x 2))\n          (one-gen [x] (map #(% x) [times2 halve add2]))\n          (next-gens [coll]\n            (set (mapcat one-gen coll)))]\n    (if (= start finish)\n      1\n      (loop [counter 2 allnums #{start}]\n        (let [next-gen (next-gens allnums)]\n          (if (next-gen finish)\n            counter\n            (recur (inc counter) next-gen)))))))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn get-steps [initial final]\n  (letfn [(next-nums [n]\n            (filter integer? ((juxt (partial + n) (partial * n) (partial / n)) 2)))\n          (collect-next [coll step x]\n            (if (coll x)\n              step\n              (let [res (set (mapcat next-nums coll))]\n                (recur res (inc step) x))))]\n   (collect-next #{initial} 1 final)))","problem":106,"user":"4e3bccb1535deb9a81d77f55"},{"problem":106,"code":"(fn [a b]\n  (letfn [(br [n]\n            (if (odd? n) [(* n 2) (+ n 2)] [(* n 2) (+ n 2) (/ n 2)]))\n          ]\n    (first (some (fn [s] (when (some #{b} (last s)) s)) (map vector (iterate inc 1) (iterate #(mapcat br %) [a]))))))","user":"512b07f7e4b078b06821febb"},{"code":"(fn nm\n  ([s e] (nm #{s} e 1 #{s}))\n  ([v e l d]\n     (if (contains? v e) l\n         (let [mnx (fn [x] (concat [(* 2 x) (+ 2 x)] (when (even? x) [(quot x 2)])))\n               nxv (into #{} (mapcat mnx v))\n               nev (clojure.set/difference nxv d)\n               nd  (clojure.set/union nev d)]\n           (nm nev e (inc l) nd))\n         )\n     )\n  )","problem":106,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":106,"code":"#(letfn [(transform [l]\n          (into #{} (apply concat (for [n l]\n                                    (if (even? n)\n                                      [(* n 2) (+ n 2) (/ n 2)]\n                                      [(* n 2) (+ n 2)])))))\n        (mazeit [s b c]\n          (if (contains? s b)\n            c\n            (mazeit (transform s) b (inc c))))]\n  (mazeit #{%} %2 1))","user":"55b22c33e4b0da326a65cf79"},{"problem":106,"code":"(fn number-maze [s e]\n  (letfn [(update-min [m k v]\n            (assoc m k (min v (get m k Integer/MAX_VALUE))))]\n    (loop [res {s 1} i 2]\n      (if (contains? res e)\n        (res e)\n        (recur\n          (reduce\n            (fn [res k]\n              (let [twice (* k 2)\n                    half (quot k 2)\n                    add-2 (+ k 2)]\n                (if (even? k)\n                  (-> res\n                      (update-min twice i)\n                      (update-min half i)\n                      (update-min add-2 i))\n                  (-> res\n                      (update-min twice i)\n                      (update-min add-2 i)))))\n            res\n            (keys res))\n          (inc i))\n        ))))","user":"5f300f28e4b033932238a682"},{"problem":106,"code":"(fn f [a e]\n    ((loop [ss {a 1}]\n       (if (contains? ss e)\n         ss\n         (recur (apply conj ss (for [o [#(* 2 %) #(+ 2 %) #(/ % 2)]\n                                     [a v] ss]\n                                 (if (integer? (o a))\n                                   [(o a) (if (contains? ss (o a)) (min (+ 1 v) (get ss (o a))) (+ 1 v))])\n                                 )))\n         )) e) )","user":"5921a080e4b09b4ee5954c77"},{"problem":106,"code":"(fn[a b]\n  ((fn[s n] (if (s b) n (recur (set (mapcat #(let [t [(* 2 %) (+ 2 %)]] (if (odd? % ) t (conj t (/ % 2)))) s)) (inc n)))) #{a} 1))","user":"56824e1be4b0945ebc182a91"},{"code":"(fn [start end]\n  (loop [reached #{start} l 1]\n    (if (reached end)\n          l\n      (recur (set (mapcat #(cond\n                (odd? %) ((juxt (partial * 2) (partial + 2)) %)\n                 :else ((juxt (partial * 2) (partial + 2) (fn [x] (/ x 2))) %))\n          reached)) (inc l)))))","problem":106,"user":"4ea5e794535d7eef308072df"},{"code":"(fn [s e]\n  (letfn [(mkc\n            [[s d]]\n            (let [[_ & r :as vf] [/ * + ]]\n              (map (fn [f] [(f s 2) (+ 1 d)]) (if (even? s) vf r))))\n          (bfs ([s]\n                  ((fn nx [q]\n                     (lazy-seq\n                      (when (seq q)\n                        (let [n (peek q)\n                              c (mkc n)]\n                          (cons n (nx (into (pop q) c)))))))\n                   (conj clojure.lang.PersistentQueue/EMPTY [s 1]))))]\n    (if (= s e) 1 (let [[[_ d]] (drop-while (fn [[s _]] (not= s e)) (bfs s))] d))))","problem":106,"user":"4ee9ddb8535d93acb0a66896"},{"problem":106,"code":"(fn find-path [s e]\n  (loop [opts [s] depth 1]\n    (if (some #{e} opts)\n      depth\n      (letfn [(solutions [n]\n                         (concat \n                          [(* n 2) (+ n 2)]\n                          (if (even? n) [(/ n 2)] [])))]\n        (recur (mapcat solutions opts) (inc depth))))))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn [start end]\n   (loop [op nil x start i 0]\n     (let\n         [y (if op (op x 2) x)\n          j (inc i)\n          p (+ y 2)\n          t (* y 2)\n          d (/ y 2)]\n       (cond\n        (= y end) j\n        (= p end) (recur + y j)\n        (= t end) (recur * y j)\n        (= d end) (recur / y j)\n        (> end y) (cond\n                   (= (+ y 1) end) (recur * y j)\n                   (< end t)       (recur + y j)\n                   :otherwise      (recur * y j))\n        (even? y) (cond\n                   (even? d)  (recur / y j)\n                   :otherwise (recur + y j))\n        :else (recur * y j)))))","problem":106,"user":"51307b84e4b08c712d3fae39"},{"problem":106,"code":"(fn myf2 [start goal]\n  (letfn [(next [start goal]\n  (cond (= start goal) [start]\n        (< start goal) [(* start 2) (+ start 2)]\n        (> start goal) (if (even? start) [(/ start 2) (* start 2) (+ start 2)] [(* start 2) (+ start 2)])))]\n  (loop [myset #{start}, res 1]\n    (if (contains? myset goal) res\n      (recur (set (mapcat #(next % goal) myset)) (inc res))))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":106,"code":"(fn [start goal]\n    (let [\n          double-halve-add\n          (fn double-halve-add [[node depth]]\n              (let [newdepth (+ 1 depth)]\n                   [[(* node 2) newdepth] [(/ node 2) newdepth] [(+ node 2) newdepth]]))\n          next-step\n          (fn next-step [next-nodes-fn nodes]\n              (let [new-nodes (next-nodes-fn (first nodes))]\n                   (concat (rest nodes) new-nodes)))\n          find-depth\n          (fn find-depth [start next-nodes-fn goal]\n              (loop [seen #{} queue [[start 1]]]\n                    (let [[front depth] (first queue)]\n                         (if (seen front)\n                             (recur seen (rest queue))\n                             (if (= goal front) depth\n                                 (recur\n                                   (conj seen front)\n                                   (next-step next-nodes-fn queue)))))))\n          ]\n        (find-depth start double-halve-add goal)))","user":"5a21d34ce4b0ff51aa4b32b9"},{"problem":106,"code":"(letfn [(fork [position]\n          (let [positions [(+ 2 position) (* 2 position)]]\n            (if (even? position)\n              (conj positions (/ position 2))\n              positions)))\n\n\n        (min-steps [start end]\n          (loop [steps 1\n                 visited #{start}\n                 positions #{start}]\n            (println steps visited positions)\n            (if (get positions end)\n              steps\n              (let [new-positions (->> positions\n                                       (map fork)\n                                       flatten\n                                       (remove visited)\n                                       set)]\n                (println (type new-positions))\n                (recur (inc steps)\n                       (reduce conj visited positions)\n                       new-positions)))))]\n  min-steps)","user":"55f2e47de4b06e875b46ce4d"},{"problem":106,"code":"(fn [start end]\n  (loop [m {start 1}]\n    (if (m end) (m end)\n      (recur \n       (reduce-kv \n        (fn [m k v]\n          (reduce\n           (fn [m x]\n             (if (or (not x) (m x)) m\n               (assoc m x (inc v))))\n           m\n           [(* 2 k) \n            (+ 2 k) \n            (if (even? k) (quot k 2))]))\n        m m)))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [start end]                                                                                                                                                                                             \n   (letfn [(add [x] (+ 2 x))                                                                                                                                                                                \n           (dub [x] (* 2 x))                                                                                                                                                                                \n           (half [x] (if (odd? x) nil (/ x 2)))                                                                                                                                                             \n           (number-maze [stack visited]                                                                                                                                                                     \n             (let [[val count] (first stack)]                                                                                                                                                               \n               (if (= val end)                                                                                                                                                                              \n                 count                                                                                                                                                                                      \n                 (let [visited (conj visited val)                                                                                                                                                           \n                       nxtvals (map #(% val) [add dub half])                                                                                                                                                \n                       nxtvals (filter #(not (or (nil? %) (visited %))) nxtvals)                                                                                                                            \n                       nxt (map vector nxtvals (repeat (inc count)))]                                                                                                                                       \n                   (number-maze (concat (rest stack) nxt) visited)                                                                                                                                          \n                   )))                                                                                                                                                                                      \n             )]                                                                                                                                                                                             \n     (number-maze [[start 1]] #{})                                                                                                                                                                          \n     ))","problem":106,"user":"4f1d1299535d64f603146487"},{"code":"(fn [a b]\n  (let [\n      fs [#(* 2 %) #(+ 2 %) #(if (even? %) (/ % 2) %)]\n      it (fn [ff vv] (set (mapcat (apply juxt ff) vv)))\n    ]\n    (+ 1 (count \n      (take-while #(not (% b)) \n        (iterate #(it fs %) #{a}))))\n  ))","problem":106,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [init targ]\n  (letfn [(half [n] (/ n 2))\n          (times-two [n] (*' 2 n))\n          (add-two [n] (+' n 2))\n          (operations [n]\n            (if (zero? (mod n 2))\n              (map #(% n) [half times-two add-two])\n              (map #(% n) [times-two add-two])))]\n    (loop [n 1 res [init]]\n      (if (some #(= targ %) res)\n        n\n        (recur (inc n) (mapcat operations res))))))","problem":106,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":106,"code":"(fn n\n  ([s t] (n #{s} 1 t))\n  ([c a t]\n   (if (c t)\n     a\n     (n (set (mapcat (fn [x] (if (even? x)\n                                         [(* 2 x) (+ 2 x) (/ x 2)]\n                                         [(* 2 x) (+ 2 x)]))\n                               c))\n                  (inc a)\n                  t))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn prob-0106\n  [st en]\n\n  (let [moves (fn moves\n                [n]\n                (set\n                 (concat\n                  (if (even? n)\n                    [(int (/ n 2))]\n                    [])\n                  (if (<= n (/ Integer/MAX_VALUE 2))\n                    [(* n 2)]\n                    [])\n                  (if (<= n (- Integer/MAX_VALUE 2))\n                    [(+ n 2)]\n                    []))))\n        ]\n\n  (loop [cnt 1, vs #{st}]\n    (if (contains? vs en)\n      cnt\n      (recur (inc cnt) (set (mapcat moves vs)))))))","problem":106,"user":"4f047c07535dcb61093f6bcd"},{"problem":106,"code":"(fn [start end]\n  (letfn [(next-step [set1]\n                     (set (filter identity (mapcat (juxt #(* 2 %) #(+ 2 %) #(if (even? %) (/ % 2) nil)) set1))))]\n    (loop [steps 1\n           acc #{start}]\n      (if (acc end)\n        steps\n        (recur (inc steps) (next-step acc))))))","user":"5e0d948fe4b099d064962f98"},{"problem":106,"code":"(fn [start target]\n  (let [procs [#(quot % 2) #(* 2 %) #(+ % 2)]]\n    ((fn path [step accum]\n       (if (reduce #(or % %2) (map #(= % target) accum)) step\n           (path (inc step) (remove zero? (mapcat (fn [cur]\n                                                    (if (odd? cur) (map #(% cur) (rest procs))\n                                                        (map #(% cur) procs))) accum))))) 1 [start])))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [s e]\n ((fn f [w i]\n    (if (contains? w e)\n      i\n      (let [ys (mapcat (fn [a] [(* 2 a) (+ 2 a) (if (even? a) (quot a 2) a)]) w)\n            xs (clojure.set/union w (set ys))]\n        (f xs (inc i)))))\n  #{s} 1))","problem":106,"user":"5097b556e4b00ad8bab4e970"},{"code":"#(loop [l 1 n #{%1} v n]\n   (if (n %2)\n     l\n     (recur (inc l)\n            (into #{} (for [x n o (if (odd? x) [* +] [* + /]) :when (not (v (o x 2)))]\n                      (o x 2)))\n            (into v n))))","problem":106,"user":"52b453b0e4b0c58976d9ad21"},{"problem":106,"code":"(fn [start end]\n    (let [rec (fn [[path & paths] end]\n                ;; (js/console.log path paths)\n                (let [ops (remove nil? [#(* % 2)\n                                        #(+ % 2)\n                                        (when (even? (last path))\n                                          #(/ % 2))])\n                      new-values ((apply juxt ops) (last path))]\n                  (if (= (last path) end)\n                    (count path)\n                    (recur\n                     (concat paths (map #(conj path %) new-values))\n                     end))))]\n      (rec [[start]] end)))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":106,"code":"(fn [x y]\n  (letfn [(f [x y max-val]\n             (cond\n               (= max-val 1) 1\n               (= x y) 1\n               :else (min\n                       max-val\n                       (inc (f (* 2 x) y (dec max-val)))\n                       (inc (f (+ 2 x) y (dec max-val)))\n                       (if (even? x)\n                           (inc (f (/ x 2) y (dec max-val)))\n                           max-val))))\n           (max-val\n             ([x y]\n                 (max-val x y 0))\n             ([x y ret]\n                 (cond\n                   (odd? x) (recur (* 2 x) y (inc ret))\n                   (odd? y) (recur x (* 2 y) (inc ret))\n                   (< x y) (+ (/ (- y x) 2) 1 ret)\n                   :else (recur x (* 2 y) (inc ret)))))]\n         (f x y (max-val x y))))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn [a b]\n  (->\n    (some\n      #(some\n         (fn [p] (and (= (last p) b) p)) %)\n      (iterate\n        (fn [paths]\n          (mapcat\n            #(let [next-paths (vector (conj % (* 2 (last %)))\n                                      (conj % (+ 2 (last %))))]\n               (if (zero? (rem (last %) 2))\n                 (conj next-paths (conj % (/ (last %) 2)))\n                 next-paths))\n            paths))\n        [[a]]))\n    count))","problem":106,"user":"504c8165e4b09724c857af31"},{"problem":106,"code":"(fn [s e]\n (letfn [(onepath [a b]\n          (cond\n           (= a b) [a]\n           (< a b) (cond\n                    (even? (- b a)) (vec (range a (inc b) 2))\n                    :else (apply conj (onepath a (dec b)) [(* 2 (dec b)) (* 2 b) b]))\n           (> a b) (cond\n                    (even? a) (apply conj [a] (onepath (/ a 2) b))\n                    :else (apply conj [a (* 2 a) (+ 2 (* 2 a))] (onepath (inc a) b))) ))]\n  (loop [paths [[s]] maxLen (count (onepath s e))]\n   (let [extendpaths (for [p paths op (if (even? (last p)) [* + /] [* +]) :when (< (count p) maxLen)]\n                       (conj p (op (last p) 2)))]\n     (let [results (filter #(= e (last %)) extendpaths)\n           minLen (if (empty? results) maxLen (apply min (map count results)))]\n       (if (empty? extendpaths) (count (first (filter #(= e (last %)) paths)))\n                                (recur extendpaths minLen)))))))","user":"57dd47f4e4b0bd073c20243e"},{"problem":106,"code":"(fn number-maze [n m]\n  (letfn [(number-maze-helper [n m d]\n            (if (> d 9)\n              1000\n              (if (= n m)\n                d\n                (if (odd? n)\n                  (min (number-maze-helper (* 2 n) m (inc d))\n                       (number-maze-helper (+ 2 n) m (inc d)))\n                  (min (number-maze-helper (* 2 n) m (inc d))\n                       (number-maze-helper (+ 2 n) m (inc d))\n                       (number-maze-helper (/ n 2) m (inc d)))))))]\n  (number-maze-helper n m 1)))","user":"540e8d13e4b0addc1aec671e"},{"problem":106,"code":"(fn number-maze\n  [s f]\n  ;; BFS\n  (letfn [(children [[depth val]]\n            (->>\n              [(* 2 val) (/ val 2) (+ 2 val)]\n              (filter integer?)\n              (map (fn [n] [(inc depth) n]))))]\n    (if (= s f)\n      1\n      (loop [frontier (apply conj (clojure.lang.PersistentQueue/EMPTY) (children [1 s]))]\n        (let [[d v :as node] (peek frontier)]\n          (if (= v f) d (recur (apply conj (pop frontier) (children node)))))))))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn [a b]\n(loop [s #{a} d 1]\n  (if (s b) d\n    (recur \n     (into #{}\n(mapcat \n#(concat [(+ % %) (+ % 2)] (if (even? %) [(/ % 2)]))\n s))\n     (inc d)\n     )\n    )\n  )\n\n)","problem":106,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn [s e]\n  ((fn path [reachable used target]\n    (if (contains? reachable target) 1\n      (let [newused (clojure.set/union reachable used)\n            newreachable (clojure.set/difference (reduce #(conj (if (even? %2) (conj %1 (/ %2 2)) %1) (* %2 2) (+ %2 2)) #{} reachable))]\n        (+ (path newreachable newused target) 1)))) #{s} #{} e))","problem":106,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":106,"code":"(fn number-maze-106 [start end]\n  (loop [current [start] steps 1]\n    (if (some #{end} current)\n      steps\n      (recur (flatten\n              (map (fn [x]\n                       (if x\n                         [(* 2 x) (+ 2 x) (if (even? x) (/ x 2))]))\n                   current))\n             (inc steps)))))","user":"4eec82fe535d93acb0a668ae"},{"problem":106,"code":"(fn p-106 [start end]\n  (let [collapse-paths\n        (fn collapse-paths [& nums]\n          (if (every? nil? nums) nil\n              (inc (apply min (filter integer? nums)))))\n\n        p-106-helper (fn p-106-helper [start end steps-left]\n                       (cond\n                         (= start end) 1\n                         (= 0 steps-left) nil\n                         :else \n                         (collapse-paths\n                          (p-106-helper (* start 2) end (dec steps-left))\n                          (p-106-helper (+ start 2) end (dec steps-left))\n                          (if (even? start)\n                            (p-106-helper (quot start 2) end (dec steps-left))\n                            nil))))]\n    (loop [steps 1]\n      (let [res (p-106-helper start end steps)]\n        (if (not (nil? res)) res\n            (recur (inc steps)))))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [n m]\n  (some (fn [[acc s]] (when (s m) acc))\n        (iterate (fn [[acc s]]\n                   [(inc acc)\n                    (set (mapcat (fn [x]\n                                   (when-not (nil? x)\n                                     [(+ x 2) (* x 2) (when (even? x) (/ x 2))]))\n                                 s))])\n                 [1 #{n}])))","problem":106,"user":"5028cd0fe4b01614d1633ffc"},{"problem":106,"code":"(fn maze\n  ([begin end] (maze #{begin} end 1))\n  ([s end length]\n    (letfn [(dbl[s]\n                (set (map (partial * 2) s)))\n            \n            (plus2[s]\n                  (set (map (partial + 2) s)))\n            \n            (half[s]\n                 (set (map #(/ % 2) (filter even? s))))]\n      (if (contains? s end)\n        length\n        (recur (into (into (into s (dbl s)) (half s)) (plus2 s)) end (inc length))))))","user":"5626447fe4b00e49c7cb47bd"},{"code":"#((fn r [n s]\n     (if ((set s) %2) n\n       (r (+ n 1)\n          (for [f [+ * /] e s] (f e 2)))))\n   1 [%])","problem":106,"user":"4dad76588e77d6ed63f12a44"},{"code":"(fn [a b] (let [succ (fn [x] (concat [(* 2 x)]\n                                     (if (even? x) [(/ x 2)] [])\n                                     [(+ 2 x)]))\n                rec (fn [d acc] (if (some #(= b %) acc) d\n                                  (recur (inc d) (mapcat succ acc))))]\n            (rec 1 [a])))","problem":106,"user":"50dfb660e4b061dbdced7228"},{"problem":106,"code":"(fn nmaze [n1 n2]\n  (letfn [\n          \n        (add1 [res ]\n  (let [a (last res)\n        m2 (* 2 a)\n        pm2 (+ m2 2)]\n    (vec (concat  res [m2 pm2 (+ a 1)] ))\n  )\n)\n\n(mazer [r n1 n2]\n   (loop [res r a n1 b n2 ]\n       (cond (= a b) res\n          (and (< a b) (> (* 2 a) b))\n              (cond (= b (+ a 2)) (conj res b)\n                    (= b (+ a 1)) (add1 res)\n                    :else (recur (conj res (+ a 2)) (+ a 2) b)\n              )\n          (< a b) (recur (conj res (* 2 a) ) (* 2 a) b)\n          :else\n               (cond (odd? a)  (recur (add1 res)  (+ a 1) b)\n                     (<= (/ a 2) b) (recur (conj res (/ a 2)) (/ a 2) b)\n                     (odd? (/ a 2))\n                               (recur (conj res (+ a 2)) (+ a 2) b)\n                     :else (recur (conj res (/ a 2) ) (/ a 2) b)\n               )\n       )\n  )\n)\n  \n         ]\n   \n   (count (mazer [n1] n1 n2) )\n  )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"problem":106,"code":"#(loop [[h & t] [[1 %1]]]\n   (let [n (inc (first h))\n         a (last h)]\n     (if (= a %2)\n       (first h)\n       (recur (conj (conj (if (even? a) (conj (vec t) [n (/ a 2)]) (vec t)) [n (* 2 a)]) [n (+ 2 a)])))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":106,"code":"(fn\n  [s e]\n  ((fn\n  [c e]\n  (let [s (first (first c)) sc (second (first c))]\n    (if (= s e)\n      sc\n      (if (odd? s)\n        (recur (conj (vec (rest c)) (vector (+ 2 s) (inc sc)) (vector (* 2 s) (inc sc))) e)\n        (recur (conj (vec (rest c)) (vector (+ 2 s) (inc sc)) (vector (* 2 s) (inc sc)) (vector (/ s 2) (inc sc))) e))))) (vector (vector s 1)) e))","user":"5772ddb0e4b0979f896515d4"},{"problem":106,"code":"(fn m\n  ([x y] (apply min (into [] (filter #(not (nil? %))\n                                      (flatten (m x y 1))))))\n  ([x y d]\n    (cond \n      (= x y)\n      [d]\n      (< d 9)\n      (for [o (concat [(+ x 2) (* x 2)]\n                (when (even? x)\n                  [(/ x 2)]))]\n        (m o y (+ d 1))))))","user":"52bacfa8e4b07a9af57922d6"},{"code":"(fn [s f]\n  (loop [q [[s 1]]]\n    (let [q (drop-while nil? q)\n          [c t] (first q)\n          nt (inc t)]\n      (if (= c f)\n        t\n        (recur (conj (vec (rest q)) [(* 2 c) nt] [(+ 2 c) nt] (when (even? c) [(/ c 2) nt])))))))","problem":106,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":106,"code":"(fn min-path [s e]\n  (letfn [(step [p]\n            (let [v (last p)]\n              (apply vector\n                     (conj p (* 2 v))\n                     (conj p (+ 2 v))\n                     (when (= 0 (rem v 2)) (vector (conj p (quot v 2)))))))\n          (min-p [ps]\n            (let [p (filter #(= (last %) e) ps)]\n              (if (seq p)\n                (first p)\n                (recur (set (mapcat step ps))))))]\n    (count (min-p [[s]]))))","user":"53b39d82e4b047364c0444a6"},{"problem":106,"code":"(fn [init dest]\n  (loop [memo #{init}\n         depth 1]\n    (if (contains? memo dest)\n      depth\n      (recur (->> memo\n                  (mapcat #(concat [(+ 2 %) (* 2 %)] (when (even? %) [(/ % 2)])))\n                  set)\n             (inc depth)))))","user":"5cb41c40e4b026601754b911"},{"problem":106,"code":"(fn maze\n    ([x y]\n     (if (= x y)\n       1\n       (let [next-level (fn [x]\n                          (filter integer? (map #(% x) [#(* % 2) #(/ % 2) #(+ % 2)])))]\n         (loop [leaves (next-level x)\n                counter 2]\n           (if (some #{y} leaves)\n             counter\n             (recur (flatten (map next-level leaves)) (inc counter))))))))","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn [n m]\n    (->> [n]\n         (iterate (fn [l] (mapcat (juxt\n                                    #(+ % 2)\n                                    #(* % 2)\n                                    #(if (even? %) (quot % 2) %))\n                                  l)))\n         (take-while #(-> % set (contains? m) not))\n         count\n         inc\n         ))","problem":106,"user":"4fb1325de4b081705acca276"},{"problem":106,"code":";; Stack overflow risk \n(fn __ [start end]\n    (loop [paths [start]\n           length 1]\n      (if-let [sol (first (filter pos? (map\n                                        #(if (= % end)\n                                           length\n                                           -1)\n                                        paths)))]\n        sol\n        (recur (distinct (reduce (fn [acc pt]\n                                   (let [some-options [(* 2 pt) (+ 2 pt)]\n                                         options (if (even? pt) (conj some-options (/ pt 2)) some-options)]\n                                     (concat acc options))) [] paths))\n               (inc length)))))","user":"5317d78ee4b08068f379ed63"},{"code":"(fn [x y]\n  (let [ops (juxt #(* % 2) #(+ % 2) #(when (even? %) (/ % 2)))]\n    (loop [now [x] len 1]\n      (if (some #{y} now)\n        len\n        (recur (mapcat ops (keep identity now)) (inc len))))))","problem":106,"user":"5164867fe4b003cf19fdde3e"},{"problem":106,"code":"(fn [start end]\n  (inc (count (take-while #(not (% end))\n                          (iterate (fn [s]\n                                     (set\n                                      (mapcat\n                                       #(concat\n                                         (list (* % 2)\n                                               (+ % 2))\n                                         (if (even? %)\n                                           (list (/ % 2))\n                                           '()))\n                                       s))) #{start})))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":106,"code":"(fn [l e] ; each round list all possible next values.\n  (let [nns (fn [n]\n          (let [hn (/ n 2)]\n            (if (= hn (int hn))\n              [(+ n 2) (* n 2) hn]\n\t\t\t  [(+ n 2) (* n 2)])))]\n    (loop [m (set [l])\n           c 1]\n       (if (m e)\n        c\n        (recur (reduce (fn [r u](into r (nns u)))\n                       #{} m)\n               (inc c))))))","user":"56051095e4b08b23635d3162"},{"code":"(fn [start end]\n  (letfn [\n    (possible-steps [n]\n      (let [r (list (+ n 2) (* n 2))]\n        (if (even? n) (conj r (/ n 2)) r)))]\n  (loop [s (list start) front '() seen #{}]\n    (let [i (first s)]\n    (if \n      (= i end) (count s)\n      (let [new-front \n        (concat front \n          (map \n            (partial conj s)\n            (remove seen (possible-steps i))))]\n        (recur (first new-front) (rest new-front) (conj seen i))))))))","problem":106,"user":"4f050dec535dcb61093f6bef"},{"problem":106,"code":"(fn f [from to]\n  (letfn [\n    (adjacent [n]\n      (let [values [(* 2 n) (+ 2 n)]]\n        (if (zero? (rem n 2)) (conj values (/ n 2)) values)))]\n\n    (loop [queue [[from 1]] to to]\n      (let [[n len] (first queue)]\n        (if (= n to)\n          len\n          (recur \n            (concat (rest queue) \n                    (for [i (adjacent n)] [i (inc len)]))\n            to))))))","user":"574dfcb8e4b02ea11479923a"},{"problem":106,"code":"(fn f [x y & [c]]\n\t(let [m 10\n          c (or c 0)\n          d (+ 1 c)]\n       (cond (= x y) 1\n             (> c m) m\n        \t true (inc (min (f (+ 2 x) y d)\n                            (f (* 2 x) y d)\n                            (if (odd? x) m (f (/ x 2) y d)))))))","user":"53973e7be4b0b51d73faaee6"},{"problem":106,"code":"(fn [start end]\n             (loop [curr #{start}\n                    pathlen 1]               \n               (if (curr end) pathlen\n                 (recur\n                   (into #{}\n                   (concat curr\n                           (map (partial + 2) curr)\n                           (map (partial * 2) curr)\n                           (map (fn [x] (/ x 2)) (filter even? curr))))\n                   (inc pathlen)))))","user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [a b] \n    ((fn i [p]\n       (if (some #(= b (last %)) p) \n         (count (first p))\n         (i (mapcat #(let [s (last %)]\n                       (map (partial conj %) \n                            (concat [(* s 2) (+ s 2)]\n                                    (if (even? s) [(/ s 2)]))\n                            ))\n                    p))))\n       [[a]]))","problem":106,"user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn [start end]\n  (letfn [(transform [num]\n            (if (even? num)\n              [(* 2 num) (+ 2 num) (quot num 2)]\n              [(* 2 num) (+ 2 num)]))\n          (step [current-set end step-count]\n            (let [next-set (reduce into #{} (map transform current-set))]\n              (if (next-set end)\n                (inc step-count)\n                (step next-set end (inc step-count)))))]\n    (if (= start end)\n      1\n      (step #{start} end 1))))","problem":106,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn [start end]\n  (loop [age 1 current #{start}]\n    (if (contains? current end)\n        age\n        (recur (+ 1 age)\n               (set(for [ c current, f [/ * +] ]\n                     (f c 2)))))))","problem":106,"user":"4e860e85535db62dc21a62f1"},{"problem":106,"code":"(fn [start end]\n  (let [one-step (fn [s]\n                   (-> #{}\n                       (into (map #(* 2 %) s))\n                       (into (map #(+ 2 %) s))\n                       (into (mapcat #(if (even? %)\n                                        [(/ % 2)])\n                                     s))))]\n    (loop [s #{start} i 1]\n      (if (s end)\n        i\n        (recur (one-step s) (inc i))))))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn number-maze [from to]\n  (letfn [(number-tree [from]\n            (let [ret [from\n                       #(number-tree (* from 2))\n                       #(number-tree (+ from 2))]]\n              (if (= (mod from 2) 0)\n                (conj ret #(number-tree (/ from 2)))\n                ret)))\n\n          (bfs [goal queue]\n            (let [[[n & fns] depth] (first queue)]\n              (if (= n goal)\n                depth\n                (recur goal (concat (rest queue) (map (fn [f] [(f) (inc depth)]) fns))))))]\n    (bfs to (list [(number-tree from) 1]))))","problem":106,"user":"51b8e8b3e4b050a1176cd6a0"},{"code":"(fn [a b]\r\n    (letfn [(nummaze [a b len]\r\n                     (cond\r\n                       (= len 0) false\r\n                       (= a b) true\r\n                       (nummaze (* 2 a) b (dec len)) true\r\n                       (and (even? a) (nummaze (quot a 2) b (dec len))) true\r\n                       (nummaze (+ 2 a) b (dec len)) true\r\n                       :else false))]\r\n    (first (filter #(nummaze a b %) (range 15)))))\r\n    ;(first (filter #(nummaze a b %) (range)))))","problem":106,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn f \n  ([x n] (f [x] n 1))\n  ([l n c]\n   (if (some (partial = n) l)\n     c\n     (recur (flatten (map #(remove ratio? [(* 2 %) (+ 2 %) (/ % 2)]) l)) n (inc c)))))","problem":106,"user":"5349ac2be4b084c2834f4a67"},{"problem":106,"code":"(fn [start end]\n    (loop [endpoints #{start} steps 1]\n      (if (endpoints end)\n        steps\n        (recur\n          (into #{} (mapcat (fn [p]\n                              (filter integer? (map #(% p 2) [* + /])))\n                            endpoints))\n          (inc steps)))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn [a b]\n           (count ((fn f [s e c]\n                       (let [s+2 (+ s 2)\n                            s*2 (* s 2)\n                            sd2 (/ s 2)\n                            s*2+2 (+ s*2 2)\n                            s*2+2d2 (/ s*2+2 2)\n                            s+2d2 (/ s+2 2)]\n                            (cond\n                              (= s e) c\n                              (< s e) (if (<= s*2 e) \n                                          (f s*2 e (conj c s*2))\n                                          (if (even? (- e s))\n                                              (f s+2 e (conj c s+2))\n                                              (f s*2+2d2 e (vec (concat c [s*2 s*2+2 s*2+2d2])))))\n                              :default (cond\n                                         (odd? s) (f s*2+2d2 e (vec (concat c [s*2 s*2+2 s*2+2d2])))\n                                         (and (even? s) (odd? sd2) (> sd2 e)) (f (/ s+2 2) e (vec (concat c [s+2 s+2d2])))\n                                         :default (f sd2 e (conj c sd2))))))\n                                   \n                   a b [a])))","problem":106,"user":"4f34eb87e4b0e243712b1eba"},{"problem":106,"code":"(fn [s e]\n  (loop [close #{} \n         open [[1 s]]]\n\t(let [pair (first open)\n          ele (second pair)\n          steps (first pair)]\n      (if (= ele e) steps \n        (let [new-close (cons ele close)\n              new-open (rest open)\n              gen-eles (if (even? ele) [(* 2 ele) (/ ele 2) (+ ele 2)] \n                                       [(* ele 2) (+ ele 2)])\n              new-eles (filter #(not (contains? close %)) gen-eles)\n              new-pairs (map vector (repeat (count new-eles) (inc steps)) new-eles)\n              ]\n\t\t\t(recur new-close (concat new-open new-pairs))\n          ))\n  )))","user":"52faec2ee4b047fd55837004"},{"problem":106,"code":"(fn [start target]\n  (letfn [(step [i]\n            (let [ops (if (odd? i) [* +] [* + quot])]\n              (for [op ops]\n                (op i 2))))]\n    (loop [numbers #{start}\n           depth 1\n           dead-ends #{}]\n      (if (numbers target)\n        depth\n        (let [numbers' (->> numbers\n                            (mapcat step)\n                            set\n                            (#(clojure.set/difference % dead-ends)))\n              depth' (inc depth)\n              dead-ends' (clojure.set/union numbers dead-ends)]\n          (recur numbers' depth' dead-ends'))))))","user":"58247423e4b051871117bec5"},{"problem":106,"code":"(fn [a b]\n  (loop [paths [[a]] steps 1]\n    (let [happy-paths (filter #(= (last %) b) paths)]\n      (if (not-empty happy-paths)\n        steps\n        (recur (->> paths\n                    (remove #(some #{(last %)} (butlast %)))\n                    (map #(let [n (last %)\n                                n1 (* n 2)\n                                n2 (+ n 2)\n                                n3 (/ n 2)]\n                            (map (partial conj %) (if (even? n) [n1 n2 n3] [n1 n2]))))\n                    (apply concat))\n               (inc steps))))))","user":"589511dee4b00487982d5272"},{"problem":106,"code":"(fn f [start end]\n  (let [adj (fn [x]\n              (concat (if (even? x)\n                        [(quot x 2)]\n                        [])\n                      [(+ x 2)]\n                      [(* x 2)]))]\n    (loop [q [[1 start]]]\n      (let [[level x] (first q)]\n        (if (= x end)\n          level\n          (let [q' (apply conj (into [] (next q))\n                          (map (fn [x] [(inc level) x]) (adj x)))]\n            (recur q')))))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn final [start end]\n  (let [funs [#(* % 2) #(/ % 2) #(+ % 2)]]\n    (letfn [\n            (app [start v]\n                 (reduce #((funs %2) %\n                                     ) \n                         start \n                         v))\n            (vec-step [v]\n                      (if (< (first v) 2)\n                        (concat (vector (inc (first v))) (rest v))\n                        (concat (vector 0) (vec-step (rest v)))))\n            (vec-seq [v]\n                     (if (every? #(= 2 %) v)\n                       (cons v nil)\n                       (cons v (lazy-seq (vec-seq (vec-step v))))))\n            (fnl [start end len]\n                 (if (= start end)\n                   true\n                   (let [s (vec-seq (into [] (repeat len 0)))]\n                     (some true? (map #(= (app start %) end) s)))))\n            ]\n           (inc (first (filter #(not (nil? %)) (map #(if (fnl start end % )\n                                                       %\n                                                       nil)\n                                                    (iterate inc 0))))))))","problem":106,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn steps [start end]\n  (loop [current [start]\n         steps 1]\n    (if (some #{end} current)\n      steps\n      (recur (flatten (map #(list (+ 2 %) (* 2 %) (if (even? %) (/ % 2) '())) current))\n             (+ 1 steps)))))","problem":106,"user":"510cd1dde4b078ea71921124"},{"code":"(fn nbr-maze [a b]\n (letfn  [\n  (update [[visited vset :as t] n]\n   (if (contains? visited n)\n    [visited vset]\n    [(conj visited n) (conj vset n)])) ;; optimiser le [conj conj]\n  (new-vset [vset]\n   (set (mapcat #(list (* 2 %1) (+ 2 %1) (if (even? %1) (/ %1 2) (+ 2 %1))) vset)))\n  (rec-nbr-maze [ [visited vset] d ]\n   (if (contains? vset b)\n    d\n    (rec-nbr-maze (reduce update [visited #{}] (new-vset vset)) (inc d))))]\n    (rec-nbr-maze [#{a} #{a}] 1)))","problem":106,"user":"51f59607e4b0abb92f97f9d5"},{"problem":106,"code":"(fn f106\n    ([a b l]\n     (cond\n       (< l 0) 1000000\n       (= a b) 1\n       :else (let [x (min (f106 (* a 2) b (dec l)) (f106 (+ a 2) b (dec l)))]\n               (if (= 0 (rem a 2))\n                 (+ 1 (min x (f106 (quot a 2) b (dec l))))\n                 (+ 1 x)))))\n    ([a b] (f106 a b 10)))","user":"583048d9e4b051871117c007"},{"problem":106,"code":"(fn steps [start end]\n  (loop [[[n depth] & others] [[start 1]]\n         seen #{}]\n    (if (= n end) depth\n      (recur (concat others\n                     (->> [(* n 2) (+ n 2) (/ n 2)]\n                          (filter integer?)\n                          (remove seen)\n                          (map #(vector % (inc depth)))))\n             (conj seen #{n})))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":106,"code":"(fn [start end] \n  (let[    apply-operations (fn [val end-val map-of-endpoints]\n                        \n                   (let[  \n                   val-operations (map-of-endpoints val)\n                   new-list ( (juxt #(-> [ (+ % 2) (conj val-operations \"add2\")]) \n                                    #(-> [ (* % 2) (conj val-operations \"double\")] )\n                                    #(-> [ (/ % 2) (conj val-operations \"halve\")])) val )\n                           result (reduce #( -> (into %1 { (first %2) (second %2) })) { } new-list)\n                           ]\n                          [ (merge result map-of-endpoints) (clojure.set/difference (-> result keys set) (-> map-of-endpoints keys set))]\n          \n          \n                     ))\n         \n           find-with-next-values (fn recur-find [next-values end map-of-endpoints]\n  \n                                   (let [ search-next-values (reduce (fn [accum val] \n                                                                       ;(println accum)\n                                                                        (let [current-map (first accum)\n                                                                              accum-next-vals (second accum)]\n                                                                          (if (contains? current-map end)\n                                                                               [current-map #{} (inc (count (current-map end)))]\n                                                                               (let [applied-operations (apply-operations val end current-map) ]\n                                                 \n                                                                                  [ (first applied-operations) (into accum-next-vals (second applied-operations)) 0 ]\n                                                                               ))\n                                          \n                                                                        )\n                                                                       ) [ map-of-endpoints #{} 0] next-values)\n                                           potential-answer (get search-next-values 2)\n         \n                                         ]\n                                      \n                                         (if ( > potential-answer 0)\n                                           (do (println \"search-next-values: \" search-next-values)\n                                           potential-answer )\n                                           (recur-find (second search-next-values) end (first search-next-values))    \n                                           )\n     \n                                    )) \n        \n        find-path (fn [ start end map-of-endpoints]\n  \n                    (if (= start end) 1\n                      (let [ \n                            current-map (if (= 0 (count map-of-endpoints)) { start [] } map-of-endpoints)\n                            applied-operations (apply-operations start end  current-map )\n                              new-map (first applied-operations)\n                              next-values  (second applied-operations)\n                              found-path (if (contains? new-map end)  (inc (count (new-map end))) 0)\n             \n                            ]\n                           (if (> found-path 0) found-path\n                             (find-with-next-values next-values end new-map )\n                             ))))\n         \n       \n       ]\n  (find-path start end {start []})))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":106,"code":"(fn f [i l r]\n  (let [g #(f (inc i) % r)]\n    (condp #(%1 l %2) r\n      = i\n      < (if (or (<= l (- r l)) (> 2 (- r l))) (g (* l 2)) (g (+ l 2))) \n      > (if (>= l (- l r))\n            (if (even? l) \n                (if (#(or (even? %) (= r %)) (/ l 2)) (g (/ l 2)) (g (+ l 2)))\n                (g (* l 2))))))) 1","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn [start end]\n  (let [gen (fn [n] \n              (if (odd? n)\n                  [(* n 2) (+ n 2)]\n                  [(* n 2) (+ n 2) (/ n 2)]))]\n  (loop [i 1 s (conj #{} start)]\n    (if (s end)\n        i\n        (recur (inc i)\n               (reduce #(apply conj %1 %2)\n                       s\n                       (map gen s)))))))","problem":106,"user":"50435689e4b034ff00315d21"},{"problem":106,"code":"(fn num-game [start end]\n   (loop [q (conj clojure.lang.PersistentQueue/EMPTY [start 1])]\n     (let [fst (first q)\n           half-val [(/ (first fst) 2) (inc (second fst))]\n           add-val  [(+ 2 (first fst)) (inc (second fst))]\n           doub-val [(* 2 (first fst)) (inc (second fst))]]\n       (cond (= (first fst) end) (second fst)\n             (odd? (first fst)) (recur (conj (pop q) add-val doub-val))\n             :else (recur (conj (pop q) half-val add-val doub-val))))))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [a b]\n   ((fn nm [cur v]\n      (if (cur b)\n        1\n        (let [nv (clojure.set/difference\n                  (->\n                   (map\n                    (fn [x]\n                      (if (even? x)\n                        [(* 2 x) (/ x 2) (+ x 2)]\n                        [(* 2 x) (+ x 2)]))\n                    cur)\n                   flatten set)\n                  v)]\n          (inc (nm nv (clojure.set/union v cur)))\n          )))\n    #{a} #{}))","problem":106,"user":"52586d24e4b0cb4875a45cb0"},{"problem":106,"code":"(fn [start end]\n  (if (= start end) 1\n      (letfn [(get-children [x]\n              (concat [(* 2 x) (+ 2 x)] (if (even? x) [(/ x 2)] [])))]\n        (loop [children (get-children start)\n               path 1]\n          (if (not= -1 (.indexOf children end)) (inc path)\n              (recur (flatten (map get-children children)) (inc path)))))))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn p106 [x y]\n  (letfn [(hoge [x y]\n              (let [ls (mywalk x)\n                    ret (filter (fn [r] (= (last r) y)) ls)]\n\t\t(if (empty? ret) (hoge ls y) (apply min (map count ret)))))\n          (myfn [n]\n            (letfn [(f1 [x] (* x 2)) (f2 [x] (+ x 2)) (f3 [x] (/ x 2))]\n              (if (even? n) ((juxt f1 f2 f3) n) ((juxt f1 f2) n))))\n          (adda [a b] (if (empty? b) a (adda (concat a (first b)) (next b))))\n          (mywalk [qs]\n            (let [es (map (fn [q] (map (partial conj q) (myfn (last q)))) qs)]\n              (filter (fn [x] (every? (fn [y] (<= y 1)) (map count (vals (group-by identity x)))))  (adda [] es))))]\n    (if (= x y) 1 (hoge [[x]] y)))\n  )","problem":106,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn num-maze-main\r\n  [s d]\r\n\t((fn num-maze\r\n\t\t[depth src-list dest]\r\n\t\t(if (some #{dest} src-list)\r\n\t\t\tdepth\r\n\t\t\t(num-maze (inc depth)\r\n\t\t\t\t\t\t\t\t(flatten (for [f [#(* % 2), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(/ % (if (zero? (mod % 2)) 2 1)), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#(+ % 2)]] (map f src-list)))\r\n\t\t\t\t\t\t\t\tdest))) 1 [s] d))","problem":106,"user":"4e8a0c82535d3e98b802328d"},{"problem":106,"code":"(fn [start end]\n  (let [dbl  (partial * 2)\n        hlv #(/ % 2)\n        add2 (partial + 2)]\n    (loop [paths [[start 1]]]\n      (let [path (first (filter #(->> % first (= end)) paths))]\n        (if (nil? path)\n          (recur (mapcat (fn [op]\n                           (map (fn [[step step-count]]\n                                  [(op step) (inc step-count)])\n                                (if (= op hlv)\n                                  (filter (fn [[step step-count]]\n                                            (even? step)) paths)\n                                  paths)))\n                         [dbl hlv add2]))\n          (second path))))))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [x y] \n\t(\n\t\t(fn findPath [z w i] \n\t\t\t(if (some #(= w %) z) i (findPath (flatten (map (fn [k] (if (even? k) (vector (* k 2) (/ k 2) (+ k 2)) (vector (* k 2) (+ k 2)) )) z)) w (inc i)) )\n\t\t) (vector x) y 1\n\t)\n)","problem":106,"user":"5296008fe4b02ebb4ef7502a"},{"problem":106,"code":"(fn [s e]\n  (loop [opts [s] depth 1]\n    (if (some #{e} opts)\n      depth\n      (letfn [(solutions [n]\n                (concat \n                  [(* n 2) (+ n 2)]\n                  (if (even? n) [(/ n 2)] [])))]\n        (recur (mapcat solutions opts) (inc depth))))))","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [from to]\n    (first (keep-indexed (fn [i r]\n                           (when (some #{to} r) (inc i)))\n                         (iterate (partial mapcat (fn [u]\n                                                      (for [f (if (odd? u) [* +] [* / +])]\n                                                        (f u 2)))) [from]))))","problem":106,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [start end]\n  (letfn [(choices [n]\n            (into [(+ 2 n) (* 2 n)]\n                  (when (even? n) [(/ n 2)])))]\n    (let [sets (iterate\n                (fn [states]\n                  (into #{}\n                        (mapcat choices states)))\n                #{start})]\n      (inc (count (take-while #(not (some #{end} %)) sets))))))","problem":106,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn [start end]\n  (letfn [(trans [n] (if (even? n) (juxt * / +) (juxt * +)))]\n    (loop [space [start] \n           step 1]\n      (if (some #(== end %) space)\n        step\n        (recur (mapcat #((trans %) % 2) space) (inc step))))))","problem":106,"user":"4e8e8c24535d65386fec2143"},{"problem":106,"code":"(fn [start end]\n  (letfn [(do-operations [num]\n            (let [double (* 2 num)\n                  half (quot num 2)\n                  add2 (+ 2 num)]\n              (if (even? num)\n                [double half add2]\n                [double add2])))\n          (find-matching-node [nodes]\n            (some #(when (= end (:num %)) %) nodes))\n          (next-level-nodes [node]\n            (map (fn [after-num]\n                   {:num after-num :depth (inc (:depth node))})\n                 (do-operations (:num node))))\n          (next-level [nodes]\n            (let [match (find-matching-node nodes)]\n              (if match\n                (:depth match)\n                (recur (mapcat next-level-nodes nodes)))))]\n\n    (next-level [{:num start :depth 1}])))","user":"5344fe13e4b084c2834f4a32"},{"problem":106,"code":"(fn [n m]\n    (loop [queue (conj clojure.lang.PersistentQueue/EMPTY [n 1])]\n      (if (empty? queue)\n        (throw (AssertionError. \"Queue is empty!\"))\n        (let [[y d] (peek queue)\n              queue_2 (pop queue)\n              d_plus_1 (+ 1 d)]\n          (if (= m y)\n            d\n            (if (even? y)\n              (recur (conj (conj (conj queue_2\n                                       [(* 2 y) d_plus_1])\n                                 [(quot y 2) d_plus_1])\n                           [(+ y 2) d_plus_1]))\n              (recur (conj (conj queue_2\n                                 [(* 2 y) d_plus_1])\n                           [(+ y 2) d_plus_1]))))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":106,"code":"(fn number-maze-path \n  [a b]\n  (let [ops [#(+ % 2) #(* % 2) #(/ % 2)]\n        maze-bfs (fn [visited current depth goal]\n                   (let [next (into #{} \n                                    (for [i current \n                                          o ops\n                                          :let [a (o i)]\n                                          :when  (and  (not (visited a))\n                                                       (>= a 0)\n                                                       (integer? a))]\n                                      a))\n                         ]\n                     (if (current goal) \n                       depth \n                       (recur (into visited current) \n                              next\n                              (inc depth)\n                              goal))))]\n    (maze-bfs #{} #{a} 1 b)))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn n106\n  ([start end] (n106 #{start} end #{start} 1))\n  ([start-coll end vals iter]\n     (if (contains? (set start-coll) end)\n       iter\n       (let [f1 (fn [x] (* 2 x))\n             f2 (fn [x] (if (even? x) (/ x 2) nil))\n             f3 (fn [x] (+ x 2))\n             f-all (fn [x] (filter identity [(f1 x) (f2 x) (f3 x)]))\n             new-tries (mapcat f-all start-coll)\n             next-tries (filter (fn [x] (not (contains? vals x))) new-tries)\n             next-vals (into vals new-tries)\n             ]\n         (n106 next-tries end next-vals (inc iter))\n         )))\n  )","problem":106,"user":"523f0bbfe4b01c266ffa7f91"},{"code":"(fn shortest-path\n  ([a b] (shortest-path #{a} b 0))\n  ([a b n]\n   (if (contains? a b)\n     (inc n)\n     (recur (reduce\n             #(into (conj %1 (* %2 2) (+ %2 2))\n                    (if (zero? (mod %2 2)) [(/ %2 2)]))\n             #{} a)\n            b (inc n))\n     )\n   )\n  )","problem":106,"user":"52e59ca5e4b09f7907dd1464"},{"problem":106,"code":"(fn find-path [s e]\n  (loop [opts [s] depth 1]\n    (if (some #{e} opts)\n      depth\n      (letfn [(solutions [n]\n                (concat\n                  [(* n 2) (+ n 2)]\n                  (if (even? n) [(/ n 2)] [])))]\n        (recur (mapcat solutions opts) (inc depth))))))","user":"5bbdd136e4b07a9b28b0ffab"},{"code":"(fn __ [src des]\n  ((fn bfs [l]\n     (let [doub (apply merge (map (fn [[k v]] (hash-map (* k 2) (inc v)))  l))\n           half (apply merge (map (fn [[k v]] (hash-map (if (even? k) (/ k 2) k) (inc v))) l))\n           add2 (apply merge (map (fn [[k v]] (hash-map (+ k 2) (inc v))) l))\n           ext (merge-with min l doub half add2)]\n       (if (contains? ext des)\n         (ext des)\n         (bfs ext))))\n    {src 1}))","problem":106,"user":"52828298e4b0757a1b17145b"},{"code":"(fn [a b]\n   (loop [c 1 l #{a}]\n     (if (l b)\n       c\n       (recur (+ 1 c) (into l (mapcat #(map (fn [i] (% i 2)) l) [/ * +]))))))","problem":106,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn [start end]\n  (loop [q [[start 1]] seen #{}]\n    (let [[n ct] (first q)]\n      (if (= n end)\n        ct\n        (let [succ (conj (when (even? n) (list (/ n 2))) (* n 2) (+ n 2))\n              succ (map #(vector % (inc ct)) (remove seen succ))\n              nxt (subvec q 1)]\n          (recur (if (empty? succ) nxt (apply conj nxt succ))\n                 (conj seen n)))))))","problem":106,"user":"519ef784e4b087743fad2198"},{"code":"(fn m [s e]\n  (loop [i 1\n         c #{s}]         \n    (if (contains? c e) i\n        (recur (inc i)\n               (set (reduce #(concat %\n                                     (conj\n                                      (if (even? %2) [(/ %2 2)]\n                                          [])\n                                      (* 2 %2)\n                                      (+ 2 %2)))\n                            [] c))))))","problem":106,"user":"4facd2fae4b081705acca22f"},{"code":"(fn number-maze [start end]\n  (loop [mid-res [start] i 1]\n    (if (some #(= end %) mid-res)\n      i\n      (recur\n       (concat\n        (mapcat \n         (juxt (partial * 2) (partial + 2))\n         mid-res)\n         (map #(/ % 2) (filter even? mid-res))\n        )\n       (inc i))\n      )\n    ))","problem":106,"user":"5094057fe4b097f48cc38593"},{"code":"(fn [start goal]\r\n  (letfn [(double [n] (* n 2))\r\n          (halve [n] (/ n 2))\r\n          (add-2 [n] (+ n 2))\r\n          (next-operations [n]\r\n            (if (even? n)\r\n                [double halve add-2]\r\n                [double add-2]))]\r\n    (loop [current-numbers [start] depth 1]\r\n      (if (some #(= goal %) current-numbers)\r\n          depth\r\n          (recur (mapcat (fn [number]\r\n                           (map #(% number) (next-operations number)))\r\n                         current-numbers)\r\n                 (inc depth))))))","problem":106,"user":"4e7c8fd1535db169f9c796be"},{"problem":106,"code":"(fn find-path [start end]\n  (let [ops [(partial + 2) (partial * 2) (fn [n] (if (odd? n) n (/ n 2))) ]]\n    (if (= start end )\n      1\n      (loop [acc  (map #(vector (% start) 2) ops)]\n        (let [[num level] (first acc)]\n          (if (= num  end)\n            level\n            (recur\n             (into  (into [] (rest acc))\n                    (map #(vector (% num) (inc level)) ops)))))))))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [start end]\n  (let [count-it (fn count-it [n counter depth]\n                   (let [op #(count-it (% n 2) (inc counter) depth)]\n                     (if (or (= n end) (= counter depth))\n                       counter\n                       (apply min (map op [* / +])))))]\n    (loop [depth 1\n           previous-result 1]\n      (if (< previous-result depth)\n        previous-result\n        (recur (inc depth) (count-it start 1 (inc depth)))))))","problem":106,"user":"51789dfae4b03d69594194d7"},{"code":"#(letfn \n   [(goal? [[x]] (#{%2} x))\n    \n    (step [a]\n        (for [[h :as xs] a\n              x [(+ h 2) (* h 2) (/ h 2)]\n              :when (integer? x)]\n          (cons x xs)))\n          \n    (fix [a]\n         (if (some goal? a)\n           (count (first (filter goal? a)))\n           (recur (step a))))]\n   \n   (fix [[%1]]))","problem":106,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":106,"code":"(fn f [start end]\n   (letfn [(x [v p s] (if (p v) s (conj s v)))\n           (h1 [r0 s0]\n             (let [taken? (fn [n] (or (r0 n) (s0 n)))\n                   result\n                   (reduce\n                    (fn [acc0 k]\n                      (->> acc0\n                          (x (* k 2) taken?)\n                          (x (+ k 2) taken?)\n                          (x (quot k 2) #(or (odd? k) (taken? %)))))\n                    #{}\n                    r0)]\n               [result (clojure.set/union r0 s0)]))\n           (rep [r0 s0 n]\n             (let [[r1 s1] (if (= 1 n) [#{start} #{}] (h1 r0 s0))]\n               (if (r1 end) n\n                   (recur r1 s1 (inc n)))))]\n     (rep #{} #{} 1)))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":106,"code":"(fn numberMaze [n goal]\n  (loop [current [n] path 1]\n    (if(some #{goal} current)path\n     (recur (flatten(map #(when % (list (* % 2)(+ % 2)\n                          (when(even? %) (/ % 2))))current))(+ path 1)))))","user":"570243e2e4b08d47c97781dd"},{"problem":106,"code":"(fn maze\n  ([start end] (maze start end [start]))\n  ([_ end path] \n   (letfn [(num-exists-in-path [num path]\n             (some #(= num %) path))\n\n           (dbl-in-path [num path]\n             (num-exists-in-path (* 2 num) path))\n\n           (half-in-path [num path]\n             (num-exists-in-path (/ num 2) path))\n\n           (p2-in-path [num path]\n             (num-exists-in-path (+ num 2) path))\n\n           (steps-w-hlf [num path orig]\n             (let [v-w-h (conj orig (/ num 2))]\n               (if (not (p2-in-path num path))\n                 (conj v-w-h (+ num 2))\n                 v-w-h)))\n\n           (steps-w-dbl [num path]\n             (let [dbl-v [(* 2 num)]]\n               (if (not (or (odd? num) (half-in-path num path)))\n                 (steps-w-hlf num path dbl-v)    \n                 (if (not (p2-in-path num path))\n                   (conj dbl-v (+ num 2))\n                   dbl-v))))\n\n           (steps-wo-dbl [num path]\n             (if (not (or (odd? num) (half-in-path num path)))\n               (steps-w-hlf num path [])\n               (if (not (p2-in-path num path)) \n                 [(+ num 2)]\n                 [])))\n\n           (get-next-steps [num path]\n             (if (not (dbl-in-path num path))\n               (steps-w-dbl num path)\n               (steps-wo-dbl num path)))]\n\n     (if (= (last path) end)\n       (if (< (count path) 10) (do (println path) (count path)) (count path))\n        (if (= (count path) 15) \n          (count path)\n          (let [next-steps (get-next-steps (last path) path)\n                taken-next-steps (map #(maze % end (conj path %)) next-steps)]\n            (if (seq taken-next-steps) (apply min taken-next-steps) 1000)))))))","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn maze \n ([as b n]\n (if (some #(= % b) as) n \n    (let [trans (fn [a] (remove ratio? [(* a 2)(+ a 2)(/ a 2)])) \n          new-as (mapcat trans as)]\n          (recur new-as b (inc n)))))\n ([a b] (maze [a] b 1)))","problem":106,"user":"4dcfbc44535d5973398f92a7"},{"problem":106,"code":"(fn __ [start end]\n  (letfn [(breadth-first [branch? children root]\n            ((fn step [queue]\n               (lazy-seq\n                 (when (seq queue)\n                   (let [node (peek queue)\n                         c (if (branch? node) (children node))]\n                     (cons node\n                           (step (into (pop queue) c)))))))\n              (conj clojure.lang.PersistentQueue/EMPTY root)))]\n    (let [step-fns [#(* 2 %)\n                    #(if (even? %) (/ % 2))\n                    #(+ % 2)]\n          \n          children (fn [num-vec]\n                     (let [last-num (peek num-vec)]\n                       (->>\n                         step-fns\n                         (map #(% last-num))\n                         (filter #(not (nil? %)))\n                         (map #(conj num-vec %)))))]\n      (->>\n        (breadth-first (constantly true) children [start])\n        (drop-while #(not (= (peek %) end)))\n        (first)\n        (count)))))","user":"502a5e59e4b09e8f859a9fbc"},{"code":"(fn [a b]\r\n  (let [\r\n\t\th (fn [l x n] (let [v (conj (vec l) [(* 2 x) n] [(+ x 2) n])] (if (even? x) (conj v [(/ x 2) n]) v)))\r\n\t\tg (fn g [[[x n] & r] b] (if (= x b) n (g (h r x (inc n)) b)))]\r\n\t(g [[a 1]] b)))","problem":106,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":106,"code":";;Keeping the paths for an external to 4clojure challenge\n;(fn [start finish]\n;  (let [even-operations {:double (partial * 2)\n;                         :halve #(/ % 2)\n;                         :plus2 (partial + 2)}\n;        odd-operations (dissoc even-operations :halve)\n;                                                  ;;update seems to be missing in 4clojure on this problem:-/\n;        take-path (fn [node [op-kw op]] (-> node (update-in [:num] op) (update-in [:path] conj op-kw)))\n;        get-ops (fn [node] (if (even? (:num node)) even-operations odd-operations))\n;        branch (fn [node] (map (partial take-path node) (get-ops node)))\n;        is-solution? (fn [node] (= finish (:num node)))\n;        branch-seq (iterate (partial mapcat branch) [{:num start :path []}])\n;        skip-wrong (drop-while #(not-any? is-solution? %) branch-seq)\n;        min-solutions (filter is-solution? (first skip-wrong))]\n;    (inc (first (map (comp count :path) min-solutions)))))\n\n;;Faster solution\n(fn number-maze [start finish]\n  (let [ops [#(* 2 %) #(+ 2 %) #(/ % 2)]\n        branch-single (fn [num] (map #(% num) ops))\n        branch (fn [current] (set (filter integer? (mapcat branch-single current))))\n        branch-seq (iterate branch #{start})\n        unsolved? (complement #(% finish))]\n     (inc (count (take-while unsolved? branch-seq)))))","user":"585d9558e4b0f14aab7c879c"},{"code":"(fn [s z]\n    (loop [ [ [e l] & t]  [ [s 1] ]]\n      (if (= z e)\n        l\n        (recur\n         (concat t\n                 (for [f [+,*,(when (even? e) /)] :when f]\n                   [(f e 2) (inc l)])))\n)))","problem":106,"user":"53440c0ae4b084c2834f4a25"},{"problem":106,"code":"(fn [start end]\n   ((fn nm [starts depth end]\n      (if (some #{end} starts)\n        depth\n        (let [next-starts (identity (flatten (map #(filter identity (vector (+ 2 %) (* 2 %) (when (even? %) (/ % 2))))\n                             starts)))]\n          (nm next-starts (inc depth) end)\n        )))\n    [start] 1 end))","user":"56fbf83de4b07572ad1a88da"},{"problem":106,"code":"(fn number-maze\n   ([n goal]\n     (let [nextp (fn [n goal cnt]\n                   (cond\n                     (= n goal) #{cnt} \n                     (even? n) #{[(* n 2) goal (inc cnt)] [(+ n 2) goal (inc cnt)] [(/ n 2) goal (inc cnt)]}\n                     :else  #{[(* n 2) goal (inc cnt)] [(+ n 2) goal (inc cnt)]}))\n           nextset (fn [s] (apply clojure.set/union (map #(apply nextp %) s) ))\n           reach #(first (filter (complement sequential?) %))\n           init #{[n goal 1]} ]\n       (loop [coll init] \n         (let [nxt (nextset coll)\n               res (reach nxt)]\n           (if-not (nil? res)\n             res\n             (recur nxt)))))))","user":"55aa1637e4b0988bba2ad949"},{"problem":106,"code":"(fn [start end]\n  (let [adv (fn [n] (if (even? n) [(* 2 n) (/ n 2) (+ 2 n)]\n                                   [(* 2 n) (+ 2 n)]))\n        BFS (fn bfs [step numset visited]\n              (let [nnums (->> (map adv numset)\n                               (flatten)\n                               (remove visited)\n                               (distinct)\n                               (apply hash-set))]\n                   (if (numset end)\n                        step\n                        (recur (inc step) nnums (clojure.set/union visited numset)))) )]\n    (BFS 1 #{start} #{})))","user":"5649615be4b0284900eef641"},{"code":"(fn [s e]\n  (letfn [(bfs [nodes] ; nodes: [ [last-node, count] ...]\n            (apply concat (for [[l c] nodes] \n              (let [n1 (* 2 l)\n                    n2 (+ 2 l)\n                    nextnodes (if (even? l) [n1 n2 (/ l 2)] [n1 n2])]\n                (map #(vector % (inc c)) nextnodes )))))]\n\n    (loop [paths [[s 1]]]\n      (let [ans (first (filter (fn [path] (= (first path) e)) paths))]\n        (if ans \n          (second ans)\n          (recur (bfs paths)))))))","problem":106,"user":"4f29eb2ae4b0d6649770a037"},{"problem":106,"code":"(fn gotmaze [st ed]\n(clojure.walk/walk #(if (= (second %) ed) (first %) nil)\n\t\t   (fn [x] (->> (remove #(= % nil) x)\n\t\t       \t       (sort-by count)\n\t\t\t       first\n\t\t\t       count\n\t\t\t       inc))\n(tree-seq #(and (not= (second %) ed) (not= (second %) -1))\n\t  (fn [[pat nv]]\n\t      (let [a (+ nv 2) b (* nv 2) \n\t      \t    c (if (even? nv) (/ nv 2) -1)]\n\t            (if (< (count pat) 8)\n\t\t      \t  [[(conj pat a) a]\n\t\t\t   [(conj pat b) b]\n\t\t\t   [(conj pat c) c]]\n\t\t\t  [[[] -1] [[] -1] [[] -1]])))\n\t\t[[] st])))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn shortest-path [start end]\n  (loop [i 1\n         coll [start]]\n    (if (some #(= end %) coll)\n      i\n      (recur (inc i)\n               (filter identity\n                       (concat\n                         (map #(* 2 %) coll)\n                         (map #(if (even? %) (/ % 2)) coll)\n                         (map #(+ 2 %) coll)))))))","problem":106,"user":"4dab218f30acd6ed15482a68"},{"problem":106,"code":"(fn [s t]\n  (let [f (fn [s]\n            (set (mapcat #(if (integer? %) [(* % 2) (/ % 2) (+ % 2)]) s)))]\n    (->> #{s} (iterate f) (take-while #(not (% t))) count inc)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":106,"code":"(fn [start end]\n  (loop [to-visit #{start}\n         visited #{}\n         length 1]\n    (if (to-visit end)\n      length\n      (let [operations [#(* % 2)\n                        #(+ % 2)\n                        #(/ % 2)]\n            to-visit-next (reduce\n                            (fn [to-visit-next visitee]\n                              (clojure.set/union\n                                to-visit-next\n                                (reduce\n                                  #(let [neighbor (%2 visitee)]\n                                     (if (or (visited neighbor)\n                                             (to-visit-next neighbor)\n                                             (not (integer? neighbor)))\n                                       %1\n                                       (conj %1 neighbor)))\n                                  #{}\n                                  operations)))\n                            #{}\n                            to-visit)]\n        (recur to-visit-next\n               (apply conj visited to-visit)\n               (inc length))))))","user":"58b2c435e4b0ebc645576d11"},{"problem":106,"code":"(fn maze\n  ([x y] (maze #{x} y 1))\n  ([xs y n]\n   (if (xs y) n\n     (recur\n       (->> xs\n            (mapcat #(list (* % 2) (+ % 2) (if (odd? %) nil (/ % 2))))\n            (filter #(not (nil? %)))\n            set)\n       y (inc n)))))","user":"508157b2e4b0946d0443855c"},{"code":"(fn [s t]\n  (letfn [(double-f [n] (* n 2))\n          (halve-f [n] (if (even? n) (/ n 2)))\n          (add2-f [n] (+ n 2))\n          (step [ss]\n                (disj (set (mapcat \n                               (juxt double-f halve-f add2-f) \n                               (apply list ss))) nil))\n          (maze-it [ss i]\n                   (if (contains? ss t) i\n                     (recur (step ss) (inc i))))]\n    (maze-it (hash-set s) 1)))","problem":106,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn num-maze [n a]\n  (letfn [(maze-num [lst]\n  \t    (set (apply concat (map maze3 lst))))\n\t  (maze3 [n]\n\t\t (if (even? n)\n\t\t   (list (* 2 n) (+ 2 n) (/ n 2))\n\t\t   (list (* 2 n) (+ 2 n))))\n\t\t ]\n\t  (loop [lst (set [n])\n\t\t c 1]\n\t    (if (contains? lst a)\n\t      c\n\t      (recur (maze-num lst) (+ c 1))))))","problem":106,"user":"4ddc620d535d02782fcbea06"},{"code":"(fn [n1 n2]\r\n  (loop [cnt 1 xs [n1] used #{}]\r\n    (if (some #(= n2 %) xs)\r\n      cnt\r\n      (let [mutator (juxt #(+ 2 %) #(* 2 %) #(when (zero? (rem % 2)) (/ % 2)))\r\n            ys (distinct (remove used (remove nil? (mapcat mutator xs))))]\r\n        (recur (inc cnt) ys (into used ys))))))","problem":106,"user":"4f969214e4b0dcca54ed6cdd"},{"code":";; breadth-first search\n(fn f [start end]\n  (loop [cur #{start} i 1]\n    (if (cur end)\n      i\n      (recur\n       (set (filter integer? (mapcat #(list (* % 2) (/ % 2) (+ % 2)) cur))) (inc i)))))","problem":106,"user":"50b668dde4b08fb537db98f2"},{"problem":106,"code":"(fn [a b]\n  (letfn [(nexts [a]\n                 (let [ops [/ + *]]\n                   (map #(% a 2) (if (odd? a) (next ops) ops))))]\n       (loop [as [a] d 1]\n         (if (some #{b} as) d\n             (recur (mapcat nexts as) (inc d))))))","user":"4e6a4950535d8ccf87e9febf"},{"problem":106,"code":"(fn [x goal]\n  (letfn [(step [x]\n            (if (odd? x)\n              #{(+ x x) (+ x 2)}\n              #{(+ x x) (+ x 2) (quot x 2)}))]\n    (loop [iteration 1\n           previous #{x}]\n      (if (contains? previous goal)\n        iteration\n        (recur (inc iteration)\n               (apply clojure.set/union\n                      (map step previous)))))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(let [gen-three (fn gen-three [num]\n  (if (even? num)\n    ((juxt + * /) num 2)\n    ((juxt + * ) num 2)))\ngen-lev\n(fn gen-lev [coll]\n  (set (mapcat gen-three coll) ))]\n\n(fn get-path [start end]\n  \"4clojure.com/problem/106\"\n  (if (= start end)\n    1\n    (loop [lev-set [start]\n         lev 1]\n      (if (contains? lev-set end)\n        lev\n      (recur (gen-lev lev-set) (+ lev 1)))))))","problem":106,"user":"4db58ccb535d87e67b28fe10"},{"problem":106,"code":"(fn f\n  ([n1 n2]\n   (if (= n1 n2)\n     1\n     (f [n1] n2 (fn [x] (* x 2)) (fn [x] (+ x 2)) (fn [x] (/ x 2)) 1)\n     ))\n  ([n1 n2 d-n a-2 h-n steps]\n   (if (some #(= % n2) n1)\n     steps\n   (recur (mapcat #(vector (d-n %) (a-2 %) (h-n %)) n1) n2 d-n a-2 h-n (inc steps)))))","user":"56ab7578e4b03c432f18733d"},{"code":"#(if (= % %2) 1\n  (loop [q (conj clojure.lang.PersistentQueue/EMPTY [% 1])]\n    (let [[v c] (peek q)\n          d (* v 2)\n          h (when (even? v) (/ v 2))\n          s (+ v 2)\n          k (+ c 1)]\n      (if (some #{%2} [d h s])\n        k\n        (recur\n          (let [q (-> q pop (conj [d k] [s k]))]\n            (if h (conj q [h k]) q)))))))","problem":106,"user":"4e82f85d535db62dc21a62ce"},{"problem":106,"code":"(fn number-maze[start target]\n  (let [dub #(* 2 %) ;; (partial * 2)\n        add2 #(+ 2 %) ;; (partial + 2)\n        halve #(if (odd? %) (identity %) (/ % 2))\n        fns [dub add2 halve]\n        combos (for [f1 fns,f2 fns,f3 fns,f4 fns,f5 fns,f6 fns,f7 fns,f8 fns]\n                 (list f1 f2 f3 f4 f5 f6 f7 f8))\n        apply-functions (fn apply-functions[fns]\n                          (loop [last-result start\n                                 todo (cons identity fns)\n                                 path []]\n                            (if (empty? todo)\n                              :path-not-found\n                              (let[next-result ((first todo) last-result)\n                                   path-so-far (conj path (first todo))]\n                                (if (= next-result target)\n                                  path-so-far\n                                  (recur next-result (rest todo) path-so-far))))))]\n    (loop [todo combos\n           paths []]\n      (if (empty? todo)\n        (apply min (map count paths))\n        (let [path-found (apply-functions (first todo))]\n          (if (= path-found :path-not-found)\n            (recur (rest todo) paths)\n            (recur (rest todo) (conj paths path-found))))))))","user":"5980f91ae4b021a7a535fddd"},{"code":"(fn [start end]\n  (letfn [(transform [x]\n                     (if (even? x)\n                       [(+ x 2) (* x 2) (/ x 2)]\n                       [(+ x 2) (* x 2)]))]\n    (loop [current #{start}, count-steps 1, visited #{start}]\n      (if (contains? current end)\n        count-steps\n        (let [next-gen (clojure.set/difference (set (mapcat transform current)) visited)]\n          (recur next-gen (inc count-steps) (clojure.set/union visited next-gen)))))))","problem":106,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":106,"code":"(fn maze [a b]\n    (let\n        [\n            append_children\n                (fn [q v]\n                    (-> q\n                        (conj (* 2 v))\n                        (#(if (zero? (mod v 2)) (conj % (/ v 2)) %))\n                        (conj (+ v 2))\n                    )\n                )\n            next_queue\n                (fn [m c target ret q]\n                    (let\n                        [\n                            v (first q)\n                            m (assoc m v (min (get m v 99999999) c))\n                            new_q (if (= nil v) ret (append_children ret v))\n                        ]\n                        (if (or (= v target) (empty? q))\n                            [m new_q (= v target)]\n                            (recur m c target new_q (rest q))\n                        )\n                    )\n                )\n            min_path_bfs_helper\n                (fn [m c target q]\n                    (let\n                        [\n                            [next_m next_q terminate] (next_queue m c target [] q)\n                            next_c (inc c)\n                        ]\n                        (if (or terminate (empty? next_q))\n                            c\n                            (recur next_m next_c target next_q)\n                        )\n                    )\n                )\n            min_path_bfs\n                (fn [initial target]\n                    (min_path_bfs_helper {} 1 target [initial])\n                )\n        ]\n        (min_path_bfs a b)\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn search [nd-fst nd-lst]\n  (letfn [(gen-next [st]\n             (into #{} \n               (mapcat (fn [n]\n                         (if (odd? n) [(* n 2) (+ n 2)]\n                         [(* n 2) (/ n 2) (+ n 2)]))\n                       st)))]\n  (loop [i 1 node-set #{nd-fst}]\n    (if (contains? node-set nd-lst) i\n      (recur (inc i) (gen-next node-set))))))","problem":106,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [start end]\n  (let [funcs [(fn [x] (* x 2))\n               (fn [x] (if (even? x) (/ x 2)))\n               (fn [x] (+ x 2))]]\n    (inc\n     (count\n      (take-while (fn [nums] (not-any? #(= % end) nums))\n                  (iterate (fn [nums]\n                             (mapcat (fn [n] (filter (complement nil?)\n                                                    (map #(% n)\n                                                         funcs)))\n                                     nums))\n                           [start]))))))","problem":106,"user":"5225271fe4b01819a2de42f9"},{"problem":106,"code":"(fn number-maze\n  [start end]\n  (letfn [(next-steps [nums]\n            (set\n              (flatten\n                (for [x nums]\n                  [(* x 2) (+ x 2) (if (even? x) (/ x 2) (* x 2))]))))]\n    (loop [curr #{start} count 1]\n      (if (contains? curr end)\n        count\n        (recur (next-steps curr) (inc count))))))","user":"5c20b6abe4b07e362c230576"},{"problem":106,"code":"(fn pathlength [start goal]\r\n  (loop [n       1\r\n         guesses #{start}]\r\n    (if (contains? guesses goal) n\r\n        (recur (inc n)\r\n               (reduce clojure.set/union\r\n                       (map (comp set\r\n                                  (partial remove nil?)\r\n                                  (juxt (partial * 2)\r\n                                        #(when (even? %) (/ % 2))\r\n                                        (partial + 2)))\r\n                            guesses))))))","user":"55d0e76ae4b0e31453f64a40"},{"problem":106,"code":"(fn number-maze [start goal]\n  (let [gen-next (juxt (partial * 2) #(if (even? %1) (quot %1 2) %1) (partial + 2))]\n    (loop [queue (conj clojure.lang.PersistentQueue/EMPTY [start 1]) visited #{start}]\n      (let [[curr-v curr-l] (peek queue)]\n        (if (= goal curr-v) curr-l\n            (let [candidates (filter (partial (complement contains?) visited) (gen-next curr-v))\n                  new-queue (if (empty? candidates)\n                              (pop queue)\n                              (apply conj (pop queue) (map (fn [e] [e (inc curr-l)]) candidates)))\n                  new-visited (if (empty? candidates) visited\n                                  (apply conj visited candidates))]\n              (recur new-queue new-visited)))))))","user":"5471f2fbe4b094393f72dd70"},{"problem":106,"code":"(fn number-maze [start end]\n  (letfn [(step [x]\n            (if (even? x)\n              [(* x 2) (+ x 2) (/ x 2)]\n              [(* x 2) (+ x 2)]))]\n    (loop [n 1\n           current [start]]\n      (if-not (empty? (filter #{end} current))\n        n\n        (recur\n         (inc n)\n         (mapcat step current))))))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":106,"code":"(fn number-maze [b e]\n  (inc (count\n         (->> (list b)\n              (iterate #(flatten (map (juxt (partial * 2)\n                                            (fn [x] (if (even? x) (/ x 2) x))\n                                            (partial + 2))\n                                      %)))\n              (take-while (comp empty? #(filter #{e} %) flatten))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [x y]\n  (letfn [(find-path [neighbors start end]\n            (loop [queue (conj clojure.lang.PersistentQueue/EMPTY start)\n                   preds {start nil}]\n              (when-let [node (peek queue)]\n                (let [nbrs (remove #(contains? preds %) (neighbors node))]\n                  (if (some #{end} nbrs)\n                    (reverse (cons end (take-while identity (iterate preds node))))\n                    (recur (into (pop queue) nbrs)\n                           (reduce #(assoc %1 %2 node) preds nbrs)))))))\n          (neighbors [x]\n            (let [nbrs [(+ x 2) (* x 2)]]\n              (set\n               (if (odd? x)\n                 nbrs\n                 (conj nbrs (/ x 2))))))]\n    (if (= x y)\n      1\n      (count (find-path neighbors x y)))))","problem":106,"user":"4dbb0b6c535d1e037afb21b0"},{"problem":106,"code":"(fn number-maze [start end]\n  (loop [step 1 candidates [start]]\n    (if (some #{end} candidates)\n      step\n      (recur (inc step)\n             (mapcat\n              (fn [n]\n                (if (even? n)\n                  [(* 2 n) (/ n 2) (+ n 2)]\n                  [(* 2 n) (+ n 2)]))\n              candidates)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":106,"code":"(fn [start end]\n    (let [a #(* % 2)\n          b #(if (even? %) (/ % 2) %)\n          c #(+ % 2)]\n      (loop [n 1\n             paths #{start}]\n        (if (contains? paths end)\n          n\n          (recur (inc n ) (clojure.set/union paths (set (mapcat (juxt a b c) paths))))))))","user":"544e9022e4b0e3978000698b"},{"code":"#(letfn [(d [x] (* x 2)) (h [x] (/ x 2)) (a [x] (+ x 2)) (e [x] (= x %2))]\n  ((fn f [i c]\n     (let [j (inc i)]\n       (if (some e c) j (f j (concat (map d c) (map h c) (map a c)))))) 0 [%]))","problem":106,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":106,"code":"(fn [s e]\n  (letfn [(n2 [n] (let [v [(* n 2) (+ n 2)]] (if (even? n) (conj v (/ n 2)) v)))]\n    (loop [vs #{s} k 1] (if (some #{e} vs) k (recur (set (mapcat n2 vs)) (inc k))))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":106,"code":"#({2 9} %2 ({12 3 5 3 9 5} %1 %1))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn _ \n  ([s e] (first (sort (flatten (_ 1 s e))))\n  )\n  ([n c e]\n    (if (or (> n 10) (= c e)) [n]\n      (if (even? c)\n         (conj [] (_ (inc n) (+ c 2) e) (_ (inc n) (* c 2) e) (_ (inc n) (quot c 2) e))\n         (conj [] (_ (inc n) (+ c 2) e) (_ (inc n) (* c 2) e))\n      )\n    )\n  ) \n)","problem":106,"user":"522eba30e4b01cdb292c5f0e"},{"problem":106,"code":"(fn number-maze [n1 n2]\n  (->> n1 vector\n       (iterate #(for [f [(partial * 2) (partial * (/ 2)) (partial + 2)] x %] (f x)))\n       (take-while #(not (some #{n2} %)))\n       count inc))","user":"575b3e9be4b02ea11479935b"},{"problem":106,"code":"(fn [a b]\n (letfn [(d [x] (if (< x 12) (* 2 x) x))\n         (h [x] (if (even? x) (/ x 2) x))\n         (add [x] (if (< x 25) (+ 2 x) x))\n         (grow [s] (->> (map (juxt d h add) s)\n                        flatten\n                        set))]\n   (->> (iterate grow #{a})\n        (take-while #(not (% b)))\n        count\n        inc)))","user":"56b86e64e4b0f26550335924"},{"problem":106,"code":"(fn nm [start end]\n   (loop [frontier [[start]] explored #{}]\n          (let [paths (vec (sort-by #(- (count %)) frontier))\n             xs (peek paths)\n             x (peek xs)]\n            (if (= x end)\n               (count xs)\n               (if (contains? explored x)\n                  (recur (pop paths) explored)\n                  (let [values [(* x 2) (+ x 2)]\n                       new-values (if (even? x) (conj values (quot x 2)) values)]\n                   (recur \n                     (apply conj (pop paths) (map #(conj xs %) new-values))\n                     (conj explored x))))))))","user":"559b55d6e4b066d22e731f54"},{"problem":106,"code":"(fn find-path-number-maze [from to]\n  (letfn [(get-paths [fs current-depth]                         \n                         (let [\n                               new-vals (mapcat #(if (even? %)\n                                         [(+ % 2) (* % 2) (/ % 2)]\n                                         [(+ % 2) (* % 2)]) fs)]\n                           (concat (map #(vector % current-depth) fs)\n                                   (lazy-seq (get-paths new-vals (inc current-depth))))))]\n    (second (first (filter #(= (first %) to) (get-paths [from] 1))))))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn number-maze [s e]\n  (letfn \n    [(halve [n] (when (even? n) (/ n 2)))\n     (next-item [xs]\n      (map #(conj xs (% (last xs))) [(partial * 2) halve (partial + 2)]))\n     (next-items [xs]\n      (filter #(not (nil? (last %))) (reduce into (map next-item xs))))\n     (find-path [coll]\n      (if (contains? (set (map last coll)) e) \n        (count (first coll))\n        (recur (next-items coll))))]\n     (find-path [[s]])))","problem":106,"user":"501c1492e4b086d93747d180"},{"code":"(fn min-steps [n1 n2]\n  (letfn [(reachable \n           ([f s] (reachable f s s))\n           ([f s1 s2]\n            (lazy-seq  \n             (cons s1 (let [next-step (step f s2)]\n                        (reachable f (clojure.set/union s1 next-step) next-step))))))\n          (step [f s]\n                (->> s\n                     (map f)\n                     (apply concat)\n                     set))\n          (maze [n]\n                (if (even? n)\n                  (list (* 2 n) (+ 2 n) (/ n 2))\n                  (list (* 2 n) (+ 2 n))))]\n    (->> #{n1}\n         (reachable maze)\n         (take-while #((complement %) n2))\n         count\n         inc)))","problem":106,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":106,"code":"(fn [x y]\n  (letfn [(step [coll]\n            (mapcat #(if (even? %)\n                       [(* % 2) (+ % 2) (/ % 2)]\n                       [(* % 2) (+ % 2)]) coll))]\n    (loop [coll [x] n 1]\n      (if ((set coll) y)\n        n\n        (recur (step coll) (inc n))))))","user":"5504dd64e4b086ebe8a79c83"},{"problem":106,"code":"(fn [start end]\n  (let [ops [(partial + 2)\n             (partial * 2)\n             #(/ % 2)]\n        apply-ops (fn [[val depth]]\n                    (->> ops\n                         (map #(vector (% val) (inc depth)))\n                         (filter (comp integer? first))))]\n    (loop [pairs [[start 1]]]\n      (if (some (comp (partial == end) first) pairs)\n        (second (first pairs))\n        (recur (mapcat apply-ops pairs))))))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":106,"code":"(fn [a b]\n  ((fn look [all n i]\n    (if (n b)\n      i\n      (let [newnext (set (concat \n                          (map #(* 2 %) n) \n                          (map #(+ 2 %) n) \n                          (keep #(if even? (/ % 2)) n)))]\n       (look (clojure.set/union all newnext) newnext (inc i)))))\n    #{a} #{a} 1))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn soln [x y]\r\n   (if (= x y) 1 (let [v (vector x)]\r\n   (loop [v v, st 0] \r\n \t\t(if (> (count (filter #(= y %) v)) 0) (inc st)\r\n \t\t    (recur  (concat (map #(* % 2) v) (map #(/ % 2) v) (map #(+ % 2) v)) (inc st)))))))","problem":106,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":106,"code":"(fn find-path\n  ([start end] (find-path end [[start]] #{start}))\n  ([end paths seen]\n   (if (empty? (filter #(= (last %) end) paths))\n     (letfn [(nextNumbers [num seen]\n               (set (filter #(not (contains? seen %)) (if (even? num)\n                                                        [(* 2 num) (/ num 2) (+ num 2)]\n                                                        [(* 2 num) (+ num 2)]))))]\n       (let [newPaths (reduce\n                       (fn [result elem]\n                         (let [n (nextNumbers (last elem) seen)]\n                           (if (empty? n)\n                             result\n                             (apply conj result (map #(conj elem %) n)))))\n                       []\n                       paths)\n             newSeen (set (flatten newPaths))]\n         (find-path end newPaths newSeen)\n         )\n       )                                                                                                                                            \n     (count (first paths)))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [x y]\n  (letfn [(neighbours [x]\n            (let [ns [(+ x x)\n                      (+ x 2)]]\n              (if (even? x)\n                (conj ns (/ x 2))\n                ns)))\n          (solve [target dists]\n            (let [[d x :as pair] (first dists)]\n              (if (= x target)\n                d\n                (recur target (into (disj dists pair) (for [n (neighbours x)] [(inc d) n]))))))]\n    (solve y (sorted-set [1 x]))))","problem":106,"user":"510db6cde4b078ea71921145"},{"problem":106,"code":"(fn\n  [n1 n2]\n  (let [dbl #(* % 2) hlv #(/ % 2) ad2 #(+ % 2)\n        actions #((apply juxt dbl ad2 (when (even? %)[hlv])) %)]\n    (loop [i 1 n (list n1)]\n      (if (some (partial = n2) n) i\n        (recur (inc i) (mapcat actions n))))))","user":"59f91b99e4b0ca45a743a33a"},{"problem":106,"code":"(fn [s t]\n  (let [o (map #(fn [v] (% v 2)) [* / +])\n        m #(set (for [x o y %] (x y)))]\n    (inc (count (take-while (fn [l] (not-any? #(= t %) l)) (iterate #(m %) [s])))\n  )))","user":"52593207e4b0cb4875a45cd3"},{"code":"(fn [a b]\n  (loop [queue (sorted-set a) depth 1]\n    (if (contains? queue b)\n      depth\n      (recur (reduce #(conj %1 (* 2 %2) (+ 2 %2) (if (even? %2) (quot %2 2) %2)) (hash-set) queue) (inc depth)))))","problem":106,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn __ [i j]\n  (let [g \n (fn g [s j k]\n   (if (contains? s j) k\n    (let [s1 (reduce #(conj %1 (* %2 2)) s s) \n          s2 (reduce #(conj %1 (+ %2 2)) s s)\n          s3 (reduce (fn [ss x] (conj ss (if (even? x) (/ x 2) x))) s s)\n          s4 (clojure.set/union s1 s2 s3)]\n       (println (list s4 j k))       \n        (g s4 j (inc k)))))]\n     (g #{i} j 1)))","problem":106,"user":"4f04a06d535dcb61093f6bd9"},{"problem":106,"code":"(letfn\n  [(aux-f [s x]\n     (let [a (+ x 2), b (* x 2), c (/ x 2)]\n       (set (concat s [a] [b] (if (even? x) [c] ())))))]\n  \n  (fn [x y]\n    (loop [a #{x}, prev a, acc 1]\n      (if (contains? a y) acc\n        (let [cand (reduce aux-f [] a)]\n          (recur\n           (clojure.set/difference cand prev)\n           (clojure.set/union prev cand)\n           (inc acc)))))))","user":"53065acbe4b02e8216869792"},{"problem":106,"code":"(fn [a b]\n (inc (count (take-while #(not (contains? (set %) b)) \n                    (iterate #(apply concat \n                                     (for [x %] (if (even? x) [(/ x 2) (* x 2) (+ x 2)] [(* x 2) (+ x 2)]))\n                              ) [a])))))","user":"55a74d46e4b09e57187da2a3"},{"code":"#((fn r [n s]\r\n     (if ((set s) %2) n\r\n       (r (+ n 1)\r\n          (for [f [+ * /] e s] (f e 2)))))\r\n   1 [%])","problem":106,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [a b]\r\n  (loop [stack [a], l 1]\r\n    (if (some #(= % b) stack)\r\n      l\r\n      (recur \r\n        (mapcat #(concat [(* % 2) (+ % 2)] (when (even? %) [(quot % 2)])) stack)\r\n        (inc l)))))","problem":106,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn [origin dest]\n  (let [\n  >>= (fn [xs f]\n    (apply concat (map f xs)))\n  next-moves (fn [x]\n    (if (odd? x)\n      (list         (+ x 2) (* x 2))\n      (list (/ x 2) (+ x 2) (* x 2))))\n  expand (fn [path]\n    (->> (first path)\n         (next-moves)\n         (filter (comp not #(some #{%} path)))\n         (map #(cons % path))))\n  terminal (fn [dest]\n    (fn [path]\n      (== (first path) dest)))\n  impl (fn [complete? paths]\n    (if (some complete? paths)\n      (->> paths (filter complete?) (map count) (apply min))\n      (recur complete? (>>= paths expand))))\n  ]\n  (impl (terminal dest) [(list origin)])))","problem":106,"user":"4e691c79535d8ccf87e9fe97"},{"problem":106,"code":"(fn nm\n  ([res todos dst]\n   (letfn [(double [n] (* 2 n))\n           (halve [n] (quot n 2))\n           (add2 [n] (+ 2 n))]\n     (if-let [r (some #(when (= % dst) %) todos)]\n       res\n       (let [nt (mapcat (fn [i]\n                          (map (fn [f] (f i))\n                               (concat [add2 double] (when (even? i) [halve]))))\n                        todos)]\n         (nm (inc res) nt dst)))))\n  ([src dst]\n   (nm 1 [src] dst)))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn [s e]\n  (if (= s e) 1\n    (let [next-step \n            (fn [ls] \n              (reduce \n                #(into %1\n                  (if (odd? %2)\n                    [(* 2 %2) (+ 2 %2)]\n                    [(* 2 %2) (+ 2 %2) (/ %2 2)])) #{} ls))]\n      (some \n        (fn [c]\n          (when (some #{e} (second c)) (first c))) \n        (map vector (iterate inc 1) (iterate next-step [s]))))))","problem":106,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn num-maze [s e]\n   (loop [all-paths [[s]]]\n     (if (some #(= e (last %)) all-paths) (count (first all-paths))\n        (recur (mapcat \n          (fn [p]  \n            [(conj p (* 2 (last p)))\n             (conj p (+ 2 (last p)))\n             (if (even? (last p)) (conj p (/ (last p) 2)) p)])\n          \n          all-paths)))))","problem":106,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn maze [beg end]\n  (letfn [(double [n]\n            (* 2 n))\n          (halve [n]\n            (quot n 2))\n          (add2 [n]\n            (+ n 2))\n          (adjs [n index]\n            (map (fn [f] [(f n) index])\n                 (if (odd? n) [double add2] [double halve add2])))\n          (bfs-iter [queue]\n            (lazy-seq\n             (let [[n index] (first queue)\n                   r (rest queue)]\n               (cons [n index]\n                     (bfs-iter (concat r (adjs n (inc index))))))))\n          (bfs [init]\n            (bfs-iter [[init 1]]))]\n    (second (first (drop-while (fn [[n index]] (not (= n end))) (bfs beg))))))","problem":106,"user":"52f8f4d1e4b047fd55836fde"},{"code":"(fn  [start target] (letfn [\n                                    (generate-child-paths [s p] \n                                    (let [doubleval (* 2 s)\n                                          plus2 (+ 2 s)\n                                          half (if (even? s) (/ s 2) s)\n                                          ; half cheats - if we cant halve return the current valeu as it will be excluded\n                                          doublelist [ doubleval (conj p doubleval)]   \n                                          plus2list  [ plus2 (conj p plus2 )]\n                                          halflist [ half (conj p half )]\n                                          all-fut (set [plus2list halflist doublelist])\n                                          all-fut-filtered (filter #(not (contains? p (first %1))) all-fut)\n                                          ]\n                                      all-fut-filtered\n                                      ))\n\n                                    ]  (loop [paths [ [ start #{ start }] ] ]\n                         (if (empty? paths)\n                           nil                            \n                           (let [firstpath (first paths)\n                                 fp-start (first firstpath)\n                                 fp-path (second firstpath)\n                                 remainingpaths (rest paths)]\n                             (if (= fp-start target)\n                               (count fp-path)\n                               (recur (concat remainingpaths (generate-child-paths fp-start fp-path)))\n                             ))))))","problem":106,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn [from to]\n  (letfn [(expand  [in]\n            (into #{} (flatten\n                       (map (fn [x]\n                              (if (even? x)\n                                (list (* 2 x) (+ x 2) (/ x 2))\n                                (list (* 2 x) (+ x 2))))\n                            in))))]\n    (loop [nums (set (list from))\n           counter 1]\n      (if (contains? nums to)\n        counter\n        (recur (expand nums) (inc counter))))))","problem":106,"user":"513d121fe4b0e544971636a2"},{"code":"(fn nmaze [from to]\n    (letfn [(nexts [n] (filter integer? (list (* 2 n) (/ n 2) (+ n 2))))]\n      (if (= from to)\n        1\n        (loop [min-found Integer/MAX_VALUE\n               tolook [[1 from]]]\n          (if-let [[[tolook-length tolook-node] & tolook-rest] tolook]\n            (cond\n              (> tolook-length min-found) (recur min-found tolook-rest)\n              (= to tolook-node) (recur tolook-length tolook-rest)\n              :else (let [new-vals (nexts tolook-node)\n                          new-tolook (for [n new-vals] [(inc tolook-length) n])\n                          next-tolook (into (vec tolook-rest) new-tolook)]\n                      (recur min-found next-tolook)))\n            min-found))))\n\n  )","problem":106,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn [start goal]\n      (loop [s [start]\n            c 1]\n           (if (some #(= goal %) s)\n               c\n               (recur\n                (vec (apply concat (map (fn [x] ((juxt #(* % 2) #(/ % 2) #(+ % 2)) x)) s)))\n                (inc c)))))","problem":106,"user":"4f82ed48e4b033992c121c0e"},{"code":"(fn number-maze [start end]\r\n  (loop [ats (conj #{} start)\r\n         num-steps 1]\r\n     (if (ats end) num-steps\r\n        (let [next-num (fn [n]\r\n                         (let [always #{ (* 2 n) (+ 2 n) }]\r\n                            (if (even? n)\r\n                                (conj always (/ n 2))\r\n                                always)))\r\n              next-set (reduce clojure.set/union (map next-num ats))]\r\n           (recur next-set (inc num-steps))))))","problem":106,"user":"4f036fb3535dcb61093f6ac8"},{"problem":106,"code":"(fn [from to]                                                                     \n    (letfn [(paths [numbers]                                                        \n              (let [ops [(partial * 2) (partial + 2) #(if (even? %) (/ % 2))]       \n                    find-neighbours (fn [x] (distinct (filter (complement nil?) (map #(% x) ops))))\n                    neighbours (reduce (fn [acc el] (into acc (find-neighbours el))) #{} numbers)]\n                (lazy-seq (cons (sort numbers) (paths neighbours)))))            \n            (includes-finish? [coll] (some #(= % to) coll))]                        \n      (first                                                                        \n        (keep-indexed                                                               \n          #(if (includes-finish? %2) (inc %1))                                      \n          (paths [from])))))","user":"58ebd10de4b056aecfd47d49"},{"code":"(fn [v e]\n  ((fn [xs]\n     (let [[vx cx] (peek xs)\n           rxs (pop xs)\n           fs [#(* 2 %) #(if (odd? %) nil (/ % 2)) #(+ 2 %)]]\n       (if (= vx e)\n         cx\n         (recur (into rxs (filter first (map (fn [f] [(f vx) (inc cx)]) fs)))))))\n   (conj clojure.lang.PersistentQueue/EMPTY [v 1])))","problem":106,"user":"4ec07699535dfed6da9c6da2"},{"problem":106,"code":"(fn [a b]\n  (letfn [(more [[l x]]\n            (let [l2 (inc l)\n                  ret [[l2 (* x 2)]\n                       [l2 (+ x 2)]]]\n              (if (even? x)\n                (conj ret [l2 (/ x 2)])\n                ret)))]\n\n    (->> [[1 a]]\n         (iterate #(mapcat more %))\n         (apply concat)\n         (filter #(= b (second %)))\n         ffirst)))","user":"4ec1b090535dfed6da9c6db5"},{"problem":106,"code":"(fn [x y] \n  (let \n    [operations \n        (fn [z] \n          (reduce \n           (fn [lis num] (cons (+ num 2) (cons (/ num 2) (cons (* num 2) lis))))\n          '() \n           z))]\n (loop \n   [my-list (list x) iterations 1]\n  (if\n  (some #(= y %) my-list)\n  iterations\n  (recur (operations my-list) (+ iterations 1))))))","user":"54d2c4c5e4b0e8a36923e5fa"},{"code":"(fn [start end]\n  (letfn [(path-length [queue end visited]\n            (let [[n len] (peek queue)]\n              (if (= n end)\n                len\n                (let [queue (reduce (fn [queue m]\n                                      (if (and (integer? m)\n                                               (not (visited m)))\n                                        (conj queue [m (inc len)])\n                                        queue))\n                                    (pop queue)\n                                    (map #(% n 2) [* / +]))]\n                  (recur queue end (conj visited n))))))]\n    (path-length (conj clojure.lang.PersistentQueue/EMPTY [start 1])\n                 end\n                 #{})))","problem":106,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn [start end]\n  (loop [nums #{start} d 1]\n    (if (contains? nums end) d\n    (let [new-nums \n    \t(into #{} \n    \t\t(mapcat \n    \t\t\t(fn [n]\n    \t\t\t\t(let [nxt [(* 2 n) (+ 2 n)]]\n    \t\t\t\t\t(if (even? n) (conj nxt (/ n 2)) nxt)))\n    \t\t\tnums))]\n    \t(recur new-nums (inc d))))))","problem":106,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":106,"code":"(fn [f t]\n  (loop [o #{}\n         n #{f}\n         c 1]\n    (let [u (clojure.set/union o n)]\n    (if (get u t)\n      c\n      (recur u\n        (into #{}\n          (for [i n\n               o [#(* 2 %)\n                  #(/ % 2)\n                  #(+ 2 %)]\n               :let [ni (o i)]\n               :when (integer? ni)]\n          ni))\n        (inc c))))))","user":"53f7820be4b0de5c41848560"},{"problem":106,"code":"(fn mz\n  ([cur tgt]\n   (mz (hash-set cur) tgt 1)\n   )\n  ([cur tgt depth] \n   (if (contains? cur tgt)\n     depth\n     (let [add2  (set (map #(+ % 2) cur))\n           mult  (set (map #(* % 2) cur))\n           halve (set (reduce #(if(odd? %2) %1 (cons (/ %2 2) %1)) '() cur))\n           ] \n       (mz (clojure.set/union add2 mult halve) tgt (inc depth))))))","user":"58951903e4b00487982d5274"},{"problem":106,"code":"(fn [s e]\n  (let [limit (* 2 (+ 4 (max s e)))]\n  (letfn [\n    ;  [n path] -> [2n, path1, 2+n path2, n/2 path3]\n    (c2 [[n path]] \n      (map #(vector % (conj path %)) \n        (concat (if (even? n) [(/ n 2)]) \n                    (filter #(< % limit) [(+ n 2) (* n 2)])) ))   ;  limit, \n  \n    (it [ret] (into {} (mapcat c2 ret)))  ]\n  \n    (loop [ret {s [s]}]\n      (if (ret e) \n          (count (ret e))                         ; return count only\n          ;(let [p (ret e)] [(count p) p]) ; return [count path]\n          (recur (it ret)))) )))","user":"593f95d8e4b069cdc2982be3"},{"problem":106,"code":"(fn [st end]\n    (let [moves [#(* 2 %) #(when (even? %) (/ % 2)) #(- % 2)]\n          next-vals (fn [n] (->> ((apply juxt moves) n)\n                                 (remove nil? )))\n          new-paths (fn [p] (for [v (next-vals (last p))]\n                              (conj p v)))]\n      (loop [paths [[end]]]\n        (if-let [p (some #(when (= st (last %)) %) paths)]\n          (count p)\n          (recur (mapcat #(new-paths %) paths))))))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn [s e]\n  (letfn [(step [xs] (set (mapcat #(list (* 2 %) (+ 2 %) (if (even? %) (/ % 2) %)) xs)))]\n    (if (= s e) 1\n      (inc (count (take-while #(not (some #{e} %)) (iterate step #{s})))))))","problem":106,"user":"4f1b92d1535d64f60314647b"},{"problem":106,"code":"(fn [start end]\n  (letfn [(new-n [coll]\n            (mapcat (fn [n]\n                      (map #(% n)\n                           (if (even? n)\n                             [double halve add-2]\n                             [double add-2])))\n                    coll))\n          (double [x]\n            (* 2 x))\n          (halve [x]\n            (/ x 2))\n          (add-2 [x]\n            (+ x 2))]\n      (loop [coll [start]\n             c 1]\n        (if (some #{end} coll)\n          c\n          (recur (new-n coll) (inc c))))))","user":"54848141e4b0e286459a119e"},{"code":"(fn [x y]\n  (letfn [\n    (n [l]\n      (mapcat #(let [t [(* 2 %) (+ 2 %)]] (if (even? %) (conj t (/ % 2)) t)) l))]\n  (loop [i 1 l [x]]\n    (if (some #{y} l)\n      i\n      (recur (inc i) (n l))))))","problem":106,"user":"4e7db3b4535db169f9c796e1"},{"problem":106,"code":"(fn path-len\n  ([start end] (path-len start end #{} 1 99999))\n  ([cur end visited cur-path min-path]\n   (cond\n     (= cur end) cur-path\n     (>= cur-path min-path) min-path\n     :default\n     (->> [(* cur 2) (when (even? cur) (/ cur 2)) (+ cur 2)]\n          (filter (complement nil?))\n          (filter (complement visited))\n          (filter #(<= % (* end 30)))\n          (reduce\n            #(min %1 (path-len %2 end (conj visited cur) (inc cur-path) %1))\n            min-path)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":106,"code":"(fn [x y]\n    (let [[[[_ path]]]\n          (drop-while\n            (fn [[[e]]] (not= e y))\n            (iterate\n              (fn [[_ coll n seen]]\n                (let [ep (nth coll n)\n                      [e path] ep\n                      np (inc path)\n                      nn (inc n)]\n                  (if (or (not (integer? e)) (seen e))\n                    [nil coll nn seen]\n                    [ep (concat coll [[(* e 2) np] [(+ e 2) np] [(/ e 2) np]]) nn (conj seen e)])))\n              [nil [[x 1]] 0 #{}]))]\n      path))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn sol[f st]\r\n  (let [v (atom [[f 1]]) h (atom 0) used (atom #{f})]\r\n    (while (not= (first (nth @v @h)) st)\r\n      (do \r\n  \t  (if (= (contains? @used (* 2 (first (nth @v @h)))) false)\r\n              (do (swap! v conj [(* 2 (first (nth @v @h))) (inc (last (nth @v @h)))])\r\n                (swap! used conj (* 2 (first (nth @v @h))))))\r\n          (if (= (contains? @used (+ 2 (first (nth @v @h)))) false)\r\n              (do (swap! v conj [(+ 2 (first (nth @v @h))) (inc (last (nth @v @h)))])\r\n                (swap! used conj (+ 2 (first (nth @v @h))))))\r\n          (if (and (= (mod (first (nth @v @h)) 2) 0) (= (contains? @used (/ (first (nth @v @h)) 2)) false))\r\n              (do (swap! v conj [(/ (first (nth @v @h)) 2) (inc (last (nth @v @h)))])\r\n                (swap! used conj (/ (first (nth @v @h)) 2))))\r\n          (swap! h inc))) (last (nth @v @h))))","problem":106,"user":"5065bd94e4b0148eb3925aed"},{"code":"(fn d\n  ([s b n]\n    (if (s b)\n      n\n      (d (set\n           (concat\n             (map #(+ % 2) s)\n             (map #(* % 2) s)\n             (map #(/ % 2) (filter #(= (mod % 2) 0) s))))\n         b\n         (+ n 1))))\n  ([s b] (d #{s} b 1)))","problem":106,"user":"4ee82539535d93acb0a66878"},{"problem":106,"code":"(fn [s d]\n  (loop [t #{s} p 1]\n    (if (some #(= d %) t)\n      p\n      (recur\n        (set (filter #(> % 0) (mapcat (fn [x] [(* 2 x) (/ x 2) (+ x 2)]) t)))\n        (inc p)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":106,"code":"(fn [s e]\n  (let [ops {\"double\" (partial * 2) \"halve\" (fn [n] (/ n 2)) \"add2\" (partial + 2)}\n        max-lvl 10]\n    (letfn [(valid-op? [v op]\n                       (not (and (odd? v) (= op \"halve\"))))\n            (find-min-all-paths [min lvl v]\n                                (reduce\n   \t\t\t\t\t\t\t\t     (fn [m op]\n                                        (find-min-path m lvl v op))\n                                     min\n                                     (keys ops)))\n            (find-min-path [min lvl v op]\n                           (cond \n\t\t\t\t\t\t     (= v e) (if (or (nil? min) (< lvl min)) lvl min)\n\t\t\t\t\t\t\t (or (not (valid-op? v op)) (> lvl max-lvl) (and (not (nil? min)) (>= lvl min))) min\n\t\t\t\t\t\t\t :else\n                             (find-min-all-paths min (inc lvl) ((ops op) v))))]\n      (find-min-all-paths nil 1 s))))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn [a b] (inc  (count\n            (take-while #(not (% b))\n                 (iterate (fn [s] (into s\n                    (mapcat #(list* (* 2 %) (+ 2 %) (if (zero? (rem % 2)) [(quot % 2)]) ) s)) )\n                  #{a})))))","problem":106,"user":"4ff67852e4b0678c553fc37e"},{"problem":106,"code":"(fn number-maze\n  [start end]\n  (letfn [(neighbors [x]\n            (let [result (hash-set (+ x 2) (* x 2))]\n              (if (even? x)\n                (conj result (/ x 2))\n                result)))]\n    (loop [seen #{start}\n           length 1]\n      (if (contains? seen end)\n        length\n        (recur (apply clojure.set/union\n                      (map neighbors seen))\n               (inc length))))))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn [init target]\n  (loop [visited #{init}\n         worklist (conj clojure.lang.PersistentQueue/EMPTY [init 1])]\n    (let [[val dist] (peek worklist)\n          neighbors (filter (comp not visited) (into [(* 2 val) (+ 2 val)] (if (even? val) [(/ val 2)] [])))\n          new-items (map #(vector % (inc dist)) neighbors)\n          next-worklist (into (pop worklist) new-items)]\n      (if (= val target)\n        dist\n        (recur (conj visited val) next-worklist)))))","problem":106,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":106,"code":"(letfn [(s [x]\n          (let [xs [(* x 2) (+ x 2)]]\n            (if (even? x)\n              (conj xs (/ x 2))\n              xs)))\n        (f [xs y n]\n          (if (some #(= % y) xs)\n            n\n            (recur (set (mapcat s xs)) y (inc n))))]\n  (fn [x y]\n    (f #{x} y 1)))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn[n d]\n  (if (= n d)\n    1\n    (let [maxdepth 9]\n      (letfn [(x2[n] (* 2 n))\n              (h2[n] (/ n 2))\n              (a2[n] (+ 2 n))\n              (succ[n fnc]\n                   (cond\n                     (= fnc x2) [x2 a2]\n                     (= fnc h2) (if (odd? n) [a2] [h2 a2])\n                     (= fnc a2) (if (odd? n) [x2 a2] [x2 h2 a2])))\n              (matze-rec[n fncs depth]\n                 (if (not (integer? n))\n                   nil\n                   (let [succ-vals (map (fn[fnc](fnc n)) fncs)]\n                     (if (some #(= % d) succ-vals)\n                       depth\n                       (if (= depth maxdepth)\n                         nil\n                         (let [succ-fnc (map succ (repeat n) fncs)]\n                           (map #(matze-rec (nth succ-vals %) (nth succ-fnc %) (inc depth)) (range (count fncs)))))))))]\n             (inc (apply min (filter identity (flatten \n                    (matze-rec n (if (odd? n) [x2 a2] [x2 h2 a2]) 1)))))))))","problem":106,"user":"4e58bcd4535d8a8b8723a296"},{"problem":106,"code":"(fn [start end]\n   (loop [current #{start}, seen #{}, index 1]\n      (if (get current end)\n         index\n         (let [next (->> current\n                         (reduce (fn [acc n] (conj acc (* n 2) (+ n 2) (if (even? n) (quot n 2)))) #{})\n                         (filter #(and (not (nil? %)) (not (seen %))))\n                         set)]\n            (recur next (into seen next) (inc index))))))","user":"58b51e05e4b0ebc645576d4c"},{"problem":106,"code":"(fn [m n]\n  (letfn [(step [i l]\n            (let [l2 (inc l) i1 (* 2 i) i2 (+ 2 i)] \n              (concat [[i1 l2] [i2 l2]]\n                      (if (even? i) [[(/ i 2) l2]] []))))]\n    (loop [[[h1 l1] & t1] [[m 1]]  t2 (step h1 l1)]\n      (if (= h1 n) l1\n          (recur (doall (concat t1 t2)) (step h1 l1))))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":106,"code":"(fn [s e] \n  (loop [xs [s]\n         d 1] \n    (if (some #{e} xs) \n      d\n      (recur (mapcat #(concat [(+ 2 %) (* 2 %)] (if (even? %) [(/ % 2)])) xs) (inc d)))))","user":"6011b89ee4b074f607df66bc"},{"code":";; using given information that all paths have length < 10\n(fn number-maze [start end]\n  (letfn [(explore [shortest-known-length n length last-op]\n            (if (= n end)\n              length\n              (if (> length shortest-known-length)\n                shortest-known-length\n                (let [add (explore shortest-known-length\n                                   (+ 2 n) (inc length) :add)\n                      shortest (min shortest-known-length add)]\n                  (if (even? n)\n                    (if (= last-op :add)\n                      (let [div (explore shortest (/ n 2) (inc length) :div)]\n                        (explore div (* n 2) (inc length) :mul))\n                      (if (= last-op :div)\n                        (explore shortest (/ n 2) (inc length) :div)\n                        (explore shortest (* n 2) (inc length) :mul)))\n                    (if (= last-op :div)\n                      shortest\n                      (explore shortest (* 2 n) (inc length) :mul)))))))]\n    (explore 9 start 1 :add)))","problem":106,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn [start goal]\n  (loop [hs #{start}\n         i 1]\n    (if (hs goal) i\n        (recur (into #{} (mapcat (juxt #(+ % %) \n                                       #(if (odd? %) (+ % %) (/ % 2)) \n                                       #(+ % 2))\n                            hs))\n              (+ i 1)))))","problem":106,"user":"4fb1d907e4b081705acca282"},{"code":"(fn maze [a b]\r\n  (letfn [(update [s]\r\n            (set (concat\r\n                  (map #(* 2 %) s)\r\n                  (map #(/ % 2) (filter even? s))\r\n                  (map #(+ 2 %) s))))]\r\n    (+ 1 (count (take-while #(not (contains? % b)) (iterate update #{a}))))))","problem":106,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [x e]\n  (letfn [(step [xs] \n                  (set (mapcat #(list (+ % 2) (* % 2) (if (even? %) (/ % 2) %)) xs)))]\n    (inc (count (take-while #(not (% e)) (iterate step #{x}))))))","problem":106,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn number-maze [start stop]\n (loop [old #{} newer #{start} i 1]\n  (let [both (into old newer)\n        fresh (set\n               (flatten\n                (for [n newer]\n                 (filter integer?\n                  (for [op (list * / +)] (op n 2)))))) ]\n  (if (newer stop) i\n   (recur both fresh (inc i))))))","problem":106,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn [m n]\n  (loop [acc #{m} c 1 visited #{}]\n  (if (some #(= n %) acc) c\n    (recur \n      (remove visited\n      (set\n        (concat\n          (map #(* 2 %) acc) \n          (map #(+ 2 %) acc)\n          (map #(/ % 2) (filter #(zero? (mod % 2)) acc)))))\n      (inc c) \n      (into visited acc)))))","problem":106,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn [a b]\n  (loop [d 1 q #{a}]\n    (if (q b)\n      d\n      (recur (inc d)\n             (set\n              (flatten\n               (map #(concat [(* % 2) (+ % 2)]\n                       (when (zero? (mod % 2))\n                         [(/ % 2)]))\n                  q)))))))","problem":106,"user":"4f06dcad535dcb61093f6c16"},{"problem":106,"code":"(fn [a b]\n  (loop [c 1 s #{a}]\n    (if (contains? s b) c\n      (recur (inc c) (set (flatten (for [n s]\n                                     ((juxt #(* 2 %)\n                                            #(+ 2 %)\n                                            #(if (odd? %) % (/ % 2))) n))))))))","user":"56ae214ce4b03c432f18735a"},{"problem":106,"code":"(fn [a b] (loop [i 1 l #{a}] (if (l b) i  (recur (inc i) (set (for [x l f [#(* % 2) #(/ % 2) #(+ % 2)]] (f x)))))))","user":"5c379636e4b0d62ef62d9f76"},{"problem":106,"code":"(fn [a b]\n    (loop [visited #{a} n 1]\n        (if (contains? visited b) n\n            (let [v2 (set (map #(* 2 %) visited))\n                  vh (set (map #(quot % 2) (filter even? visited)))\n                  v+ (set (map #(+ 2 %) visited)) ]\n            (recur (clojure.set/union visited v2 vh v+) (inc n))))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn [i a]\n  ((fn r [n s]\n     (if ((set s) a) n\n       (r (+ n 1)\n    (mapcat #(map (fn [e] (% e 2)) s) [+ * /]))))\n   1 [i]))","problem":106,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":106,"code":"(letfn\n    [(descend\n       ([n howdeep]\n        (descend [n] #{} howdeep 0))\n       ([accu seen howdeep depth]\n        (letfn\n          [(double [n] (* n 2))\n           (halve [n] (/ n 2))\n           (addtwo [n] (+ n 2))\n           (children [n] (remove ratio? (map #(% n) [double halve addtwo])))]\n          (if (= howdeep depth)\n            [accu]\n            (let [n (peek accu)\n                  kids (filter (complement seen) (children n))\n                  tier (map #(conj accu %) kids)]\n              (mapcat #(descend % (conj seen (peek %)) howdeep (inc depth)) tier))))))\n     (paths-seq\n       ([n]\n        (cons [n] (paths-seq n 1)))\n       ([n howdeep]\n        (lazy-seq\n          (concat (descend n howdeep)\n                  (paths-seq n (inc howdeep))))))\n     (shortest-path [from to]\n       (first (filter #(= to (peek %)) (paths-seq from))))]\n    (fn [from to]\n      (count (shortest-path from to))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn [a target]\n    (letfn\n      [(find-path\n         [a target best]\n         (loop [current a path [a]]\n           (if (> (count path) best) nil\n             (if (= current target) path\n               (let [n (apply (rand-nth (if (odd? current) [* +] [/ * +])) [current 2])]\n                 (recur n (conj path n)))))))]\n      (apply min (map count (filter (complement nil?) (take 1000 (repeatedly #(find-path a target 9))))))))","problem":106,"user":"4dd61f98535d2dad7130b5c6"},{"problem":106,"code":"(letfn [(steps [n path]\n            (let [ret [(conj path (* n 2))\n                       (conj path (+ n 2))]]\n              (if (even? n) (conj ret (conj path (/ n 2))) ret)))\n          (number-path\n            ([a b]\n             (loop [queue (conj clojure.lang.PersistentQueue/EMPTY [a])]\n               (let [path  (peek queue)\n                     paths (pop queue)\n                     n     (peek path)]\n                 (if (= n b)\n                   path\n                   (recur (apply conj paths (steps n path))))))))]\n    (fn [a b] (count (number-path a b))))","user":"4dfe5a93535d04ed9115e786"},{"problem":106,"code":"(fn [start target]\n    (println \"start\")\n    (let [addtwo #(+ 2 %)\n          multwo #(* 2 %)\n          divtwo #(if (= 0 (mod % 2)) (/ % 2) %)\n          ops [addtwo multwo divtwo]]\n      (loop [[state queue] [{start 1} [start]]\n             iters 0]\n        (let [item (peek queue)\n              queue (pop queue)\n              currentdistance (state item)]\n          (if (= 500 iters)\n            nil\n            (if (state target)\n              (state target)\n              (recur (reduce\n                      (fn [[state queue] op]\n                        (let [newval   (op item)\n                              existing (state newval)]\n                          (if (nil? existing)\n                            [(assoc state newval (inc currentdistance))\n                             (into [newval] queue)]\n                            [state queue]\n                            )))\n                      [state queue]\n                      ops)\n                     (inc iters))))))))","user":"554a75c9e4b0a04f79299575"},{"problem":106,"code":"(fn [start end]\n  (let [ops (juxt #(+ % %) #(/ % 2) #(+ % 2))]\n    (loop [path-len 1 results #{start}]\n      (if (results end)\n        path-len\n        (recur (inc path-len)\n               (set (filter integer? (mapcat ops results))))))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":106,"code":"(fn\n  [a b]\n  (loop [p #{a} c 1]\n    (if (contains? p b)\n      c\n      (let [n (reduce disj (set (mapcat (fn [m] (map #(% m) [#(* % 2) #(if (odd? %) % (quot % 2)) #(+ % 2)])) p)) p)]\n        (recur n (inc c))))))","user":"576df252e4b0979f8965156f"},{"code":"(fn !\n  ([src dst] (! #{src} dst 1))\n  ([wave dst dist]\n   (if (wave dst)\n     dist\n     (! (->> wave\n            (mapcat (fn [num]\n                      [(* num 2) (/ num 2) (+ num 2)]))\n            (set))\n        dst\n        (inc dist))) \n   ))","problem":106,"user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":106,"code":"(fn number-path\n  [start end]\n  (loop [front #{start} seen #{start} step 1]\n    (if (contains? front end)\n      step\n      (let [next-gen (->> front\n                          (mapcat #(vector (+ % 2) (* % 2) (/ % 2)))\n                          (filter integer?)\n                          (filter #(not (seen %)))\n                          set)]\n        (recur next-gen (into seen front) (inc step))))))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn [from to]\n  (loop [cand #{from} cost 1]\n    (if (contains? cand to)\n      cost\n      (recur\n        (into #{}\n          (concat \n            (map #(+ % 2) cand)\n            (map #(* % 2) cand)\n            (map #(/ % 2) (filter even? cand))))\n        (inc cost)))))","problem":106,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn [x y]\n  (loop [pos-list [x] len 1]\n    (if (some #(= y %) pos-list)\n      len\n      (recur (mapcat #(concat [(* 2 %)]\n                              (if (even? %) [(/ % 2)] nil)\n                              [(+ 2 %)])\n                     pos-list)\n             (inc len)))))","problem":106,"user":"510acd6ee4b078ea719210f4"},{"problem":106,"code":"(fn maze\n  ([a b] (maze a b 1))\n  ([a b c]\n   (if (or (= a b) (<= 11 c))\n     c\n     (apply\n      min\n      [(maze (* 2 a) b (inc c))\n       (maze (/ a 2) b (inc c))\n       (maze (+ 2 a) b (inc c))]))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":106,"code":"#(get {0 1 -9 3 9 3 -4 3 7 9 -3 5} (- % %2))","user":"4df1e213535d08e6dec9fe20"},{"code":"(fn closest-path [start end]\n  (letfn [\n    (mult2[n] (* n 2))\n    (div2 [n] (/ n 2))\n    (add2 [n] (+ n 2))\n    \n    (add1[n] (->> n (mult2) (add2)  (div2)))\n    \n    (change-parity[n] (add1 n))\n\n    (closest-multiple[n x]\n      (->> x\n        (iterate #(* 2 %))\n        (filter  #(>= % (/ n x)))\n        (take 2)\n        (sort-by #(Math/abs (- % n)))\n        (first)))\n\n    (division-steps[s e]\n      (let [c (closest-multiple s e)]\n        (if (= s c) [div2 1]\n            (next-step s c))))\n            \n    (sub-steps [s e]\n      (if (odd? s) (+ 1 (sub-steps (add1 s) e))\n                   (find-path (div2 s) e 1)))\n    \n    (next-step[s e]\n     (cond\n      (<= (* 2 s) e) [mult2 1]\n      (>  (- e s) 1) [add2  1]\n      (=  (- e s) 1) [add1  3]\n      (<= (* 2 e) s) (division-steps s e)\n      (<  (- e s) 0) [(fn[_] e) (sub-steps s e)]))\n    \n    (find-path[s e current-path]\n      (if (= s e) current-path\n      (let [[nxt steps] (next-step s e)]\n        (recur (nxt s) e (+ steps current-path)))))]\n    \n    \n       (find-path start end 1)))","problem":106,"user":"52f818a6e4b047fd55836fcc"},{"problem":106,"code":"(fn [start end]\n  (loop [start #{start}\n         len 1]\n    (if (start end) len\n        (recur\n         ((comp set concat)\n         \n           (map (partial * 2) start)\n           (map (partial + 2) start)\n           (map #(/ % 2) (filter even? start)))\n         (inc len)))))","user":"5553b924e4b0deb715856e06"},{"problem":106,"code":"(fn [start end]\n  (letfn\n    [(neighbors [l]\n       (map #(% l 2)\n         (take (if (even? l) 3 2)\n               [* + /])))\n     (expand [v]\n       (into v (mapcat neighbors v)))]\n    (->> #{start}\n         (iterate expand)\n         (take-while #(nil? (% end)))\n         count\n         inc)))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn [from to]\n  (loop [i 1 nums #{from}]\n    (if (contains? nums to) i\n        (recur (inc i) \n               (reduce #(-> %1 \n                            (conj (* 2 %2))\n                            (conj (+ 2 %2))\n                            (into (when (even? %2) [(/ %2 2)])))\n                       #{} nums))))\n  \n  )","problem":106,"user":"53300924e4b019098a6f8b55"},{"problem":106,"code":"(fn [n1 n2]\n  (let [expand (fn [n] (remove nil? [(* 2 n) (+ 2 n) (when (even? n) (/ n 2))]))]\n    (loop [nums #{n1} steps 1]\n      (if (get nums n2)\n        steps\n        (recur (clojure.set/union nums (set (mapcat expand nums))) (inc steps))))))","user":"5f648ef1e4b02876ed9fd01b"},{"code":"(fn p106 [start end]\n  (letfn [(walk [walkers]\n  \t(loop [ops [#(* % 2) #(/ % 2) #(+ % 2)] ws #{}]\n\t\t  (if (empty? ops)\n\t\t    ws\n\t\t    (let [op (first ops)]\n\t\t      (recur (rest ops)\n\t\t\t     (reduce conj ws (map op walkers)))))))]\n    (loop [n 1 ws (set [start])]\n      (cond (contains? ws end) n\n\t    (> n 10) -1\n\t    :else (recur (inc n) (walk ws))))))","problem":106,"user":"4e513ecf535dc968683fc4f6"},{"problem":106,"code":"(fn maze [a b]\n  (loop [[[x c] & res] [[a 1]] counter 1]\n    (if (= x b) c\n       (if (even? x)\n         (recur (concat res [[(* x 2) (inc c)] [(/ x 2) (inc c)] [(+ x 2) (inc c)]]) (inc counter))\n         (recur (concat res [[(* x 2) (inc c)] [(+ x 2) (inc c)]]) (inc counter))))\n    ))","user":"5a621702e4b0512ff01cd983"},{"code":"#(loop [c 1 z [%]] \n      (if ((set z) %2)\n          c\n          (recur (inc c) \n               (for [r z f [/ + *]] (f r 2)))))","problem":106,"user":"4daa374930acd6ed13482a68"},{"code":"(fn [s e]\n  (if (= s e) 1\n    (loop [l 1 a [s]]\n      (let [b (mapcat\n                (fn [c]\n                  (#(if (even? c) (cons (/ c 2) %) %)\n                    (list (+ c 2) (* c 2))))\n                a)]\n        (if (some #(= % e) b)  \n            (inc l)\n            (recur (inc l) b))))))","problem":106,"user":"4fd96694e4b05e33b9224f37"},{"problem":106,"code":"(fn find-shortest-path [start end]\n  (let [\n        required-manipulations [(partial * 2) (partial + 2)]\n        optional-manipulation (fn [x] (/ x 2))\n        gen-next-step (fn [prev-set]\n                        (set (for [prev-element prev-set\n                                   manipulate (if (even? prev-element)\n                                                (conj required-manipulations optional-manipulation)\n                                                required-manipulations)]\n                               (manipulate prev-element))))]\n    (->> #{start}\n      (iterate gen-next-step)\n      (take-while (fn [a-step] (not (contains? a-step end))))\n      count\n      inc)))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [s e]\r\n  (loop [p #{s} c 1]\r\n    (if (p e) c\r\n        (recur\r\n          (set (mapcat\r\n                 #(list (* % 2) (+ % 2)\r\n                    (if (even? %) (/ % 2) %)) p))\r\n          (+ 1 c)))))","problem":106,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn number-maze [s e]\n  (let [add-neighbours (fn [q p l v]\n                         (->>\n                          p\n                          ((juxt (partial + 2) (partial * 2) (partial * 1/2)))\n                          (filter (fn [x] (and (not (v x)) (== x (Math/floor x)))))\n                          (map (fn [x] (vector x (inc l))))\n                          (into q)))]\n    (loop [q (conj clojure.lang.PersistentQueue/EMPTY [s 1]) v #{}]\n      (let [[p l] (peek q)]\n        (cond (= e p) l\n              (nil? p) false\n              :else (recur (add-neighbours (pop q) p l v) (conj v p)))))))","problem":106,"user":"51672d15e4b079759a74a5e7"},{"code":"(fn [start end] (let [q (fn finder [start end k m]\n                          (if (and (= start end) (<= k m)) true\n                            (if (> k m) false\n                              (or\n                               (finder (* 2 start) end (inc k) m)\n                               (finder (+ 2 start) end (inc k) m)\n                               (if (= 1 (bit-and start 1)) false\n                                   (finder (/ start 2) end (inc k) m)\n                               )\n                              )\n                            )\n                          )\n                        )\n                      ]\n                  (loop [current 1]\n                    (if (q start end 1 current) current (recur (inc current)))\n                  )\n                )\n)","problem":106,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":106,"code":"(fn number-maze \n              ([start end] (number-maze start end [{:node start, :depth 1}]))\n              ([start end nodes]\n               (let [make-next-tree-level (fn [{:keys [node depth]}]\n                                            (let [dbl #(* 2 %)\n                                                  half #(if (odd? %) nil (/ % 2))\n                                                  add-2 #(+ 2 %)]\n                                              (map (fn [elt] {:node elt, :depth (inc depth)}) (remove nil? ((juxt dbl half add-2) node)))))\n                     first-node (first nodes)]\n                 (if (= end (:node first-node))\n                   (:depth first-node)\n                   (recur start end (concat (rest nodes) (make-next-tree-level first-node)))\n                   )))\n              )","user":"54cad2d5e4b057c6fda3a26c"},{"problem":106,"code":"(fn [n1 n2] (let [ld (memoize (fn [ld s1 s2 v]\n               (cond (= s1 s2) 1\n                     (some (partial = s1) v) Integer/MAX_VALUE\n                     (> s1 (+ (* 2 n1) 2)) Integer/MAX_VALUE\n                   :else (min (if (even? s1) (+ (ld ld (/ s1 2) s2 (cons s1 v)) 1) Integer/MAX_VALUE)\n                              (+ (ld ld (* s1 2) s2 (cons s1 v)) 1)\n                              (+ (ld ld (+ s1 2) s2 (cons s1 v)) 1)))))]\n  (ld ld n1 n2 [])))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(letfn [(new-dists [x n]\n           (apply hash-map\n                  (interleave ((apply juxt\n                                      (if (even? x)\n                                        [* / +]\n                                        [* +])) x 2) (repeat (inc n)))))\n         (merge-map-single [m [k v]]\n           (if (and (contains? m k)\n                    (<= (get m k) v))\n             m\n             (assoc m k v)))\n         (merge-maps [m1 m2]\n           (reduce merge-map-single m1 m2))]\n   (fn [x y]\n     (loop [m {x 1}]\n       (if-let [dist (get m y)]\n         dist\n         (recur (reduce merge-maps\n                        m\n                        (map (fn [[v n]] (new-dists v n)) m)))))))","problem":106,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn [a b]\n    (loop [p 1 r [a]]\n      (if ((set r) b) p\n        (recur (inc p)\n               (mapcat \n                 #(list (if (odd? %) (* 2 %) (/ % 2))\n                    (* 2 %) (+ 2 %)) r)))))","problem":106,"user":"4fa30027e4b081705acca187"},{"problem":106,"code":"(fn __ [from to]\n  (if (= from to) 1\n    (let [expand (fn [c]\n                   (->> [+ * /]\n                        (map #(% (last c) 2))\n                        (filter integer?)\n                        (map (partial conj c))))\n          solve (fn f [[c & cs]]\n                  (let [nc (expand c)]\n                    (or (first (filter (comp (partial = to) last) nc))\n                        (f (concat cs nc)))))]\n      (count (solve [[from]])))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":106,"code":"(fn m\n  ([i r] (m 1 [i] r))\n  ([a v r]\n   (if (some #{r} v)\n     a\n     (m (+ a 1)\n        (mapcat (juxt #(+ % 2) #(* % 2) #(if (even? %) (/ % 2) %)) v)\n        r))))","user":"5c1aadcde4b01240ff567209"},{"problem":106,"code":"(fn shortest-path-4clojure\n  ([begin end] (shortest-path-4clojure [begin] end 1))\n  ([acc end length]\n   (if (some #(= % end) acc)\n     length\n     (let [halve (fn [n] (if (even? n) (/ n 2) n))\n           double (fn [n] (* 2 n))\n           add2 (fn [n] (+ 2 n))\n           ops [double halve add2]\n           newacc (->> acc\n                       (mapcat (fn [n] (map #(% n) ops)))\n                       distinct)]\n       (shortest-path-4clojure newacc end (inc length))))))","user":"52e657e4e4b09f7907dd1472"},{"problem":106,"code":"(fn [from to]\n  (let [ops [#(* % 2)\n             #(if (and (even? %) (pos? %))\n                (/ % 2)\n                nil)\n             #(+ % 2)]]\n    (loop [path-stack [[from]]]\n      (let [current-path (first path-stack)\n            val          (peek current-path)]\n        (if (= val to)\n          (count current-path)\n          (let [new-vals  (keep #(% val) ops)\n                new-paths (map #(conj current-path %) new-vals)]\n            (recur (reduce conj\n                           (subvec path-stack 1)\n                           new-paths))))))))","user":"55586905e4b0deb715856e2b"},{"code":"(fn nm [n m]\r\n    (loop [n-step 1\r\n           nexts (list [n m])]\r\n        ;(println n-step)\r\n        (if (some #(== (first %) (second %)) nexts)\r\n            n-step\r\n            (recur (inc n-step)\r\n                   (mapcat #(let [[n m] %\r\n                                  result (list [(* 2 n) m]\r\n                                               [(+ 2 n) m])]\r\n                               (if (even? n)\r\n                                   (cons [(/ n 2) m] result)\r\n                                   result))\r\n                           nexts)))))","problem":106,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":106,"code":"(fn numbermaze [m n]\n  (let [nextstep (fn [v]\n     (let [f (fn [x]\n               (if (even? x)\n                 (vector (* 2 x) (/ x 2) (+ x 2))\n                 (vector (* 2 x) (+ x 2))))]\n       (vector (inc (first v))\n               (into (second v) (set (mapcat f (peek v))))\n               (set (mapcat f (peek v))))))]\n        (loop [vcounter [0 #{m} #{m}]]\n          (if (nil? (some #{n} (peek vcounter)))\n            (recur (nextstep vcounter))\n            (inc (first vcounter))))))","user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn [a b]\n  ((fn f [s n]\n    (if ((set s) b) \n      n\n      (f \n        (mapcat (fn [e] (map #(% e 2) [* / +])) s) \n        (+ 1 n))))\n   [a] 1))","problem":106,"user":"4e5411e8535d8a8b8723a279"},{"problem":106,"code":"(fn p106 [from to]\n  (loop [s #{from} n 1]\n    (if (s to)\n      n\n      (recur (reduce #(-> (if (even? %2) (conj %1 (/ %2 2)) %1 )\n                          (conj (* %2 2))\n                          (conj (+ %2 2))) #{} s) (inc n))\n      )\n    ))","user":"563dfc02e4b0da801c4e4662"},{"problem":106,"code":"(fn shortest-path-length [start end]\n  (let [next-nodes-from (comp #(remove nil? %) \n                              (juxt (fn double [x] (* 2 x))\n                                    (fn halve [x] (when (even? x) (/ x 2)))\n                                    (fn add-2 [x] (+ x 2))))]\n    (loop [new-nodes #{start}\n           visited-nodes #{}\n           steps-used 1]\n      (if (contains? new-nodes end) steps-used\n        (let [next-nodes (set (flatten (map next-nodes-from new-nodes)))]\n          (recur (clojure.set/difference next-nodes new-nodes visited-nodes)\n                 (clojure.set/union visited-nodes new-nodes)\n                 (inc steps-used)))))))","user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn maze [start end]\n  (letfn [(dble [x]\n            (* 2 x))\n          (hlve [x] \n            (/ x 2))\n          (add2 [x]\n            (+ x 2))\n          (all-ops [x]\n             ((juxt dble hlve add2) x))\n          (get-next [lol]\n            (mapcat (fn [l]\n                     (map #(conj l %) (all-ops (last l))))\n                    lol))]\n  (loop [lol [[start]]]\n    (let [solutions (filter #(= end (last %)) lol)]\n      (if (empty? solutions)\n        (recur (get-next lol))\n        (count (first solutions)))))))","problem":106,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn mypath [a b]\n    (loop [path [a] i 1]\n        (println path)\n        (if (some #(= % b) path)\n            i\n            (recur\n                (set\n                    (mapcat\n                        #(vector (* % 2) (+ % 2) (if (even? %) (/ % 2) (+ % 2)))\n                        path))\n                (inc i)))))","problem":106,"user":"4f128865535d64f603146428"},{"problem":106,"code":"(fn [from to]\n  (loop [seen {from 1}\n         step 2]\n    (if (seen to)\n      (seen to)\n      (recur\n       (reduce (fn [m n]\n                 (if-not (m n)\n                   (assoc m n step)\n                   m))\n               seen\n               (mapcat (fn [x]\n                         (let [ys [(* x 2)\n                                   (+ x 2)]]\n                           (if (= (rem x 2) 0)\n                             (conj ys (quot x 2))\n                             ys)))\n                       (keys seen)))\n       (inc step)))))","user":"57a4fa50e4b0a966079561f1"},{"problem":106,"code":"(fn solution\n  [x y]\n   (let [x2    (fn [x] (* 2 x))\n         add2  (fn [x] (+ 2 x))\n         halve (fn [x] (if (even? x) (/ x 2) x))\n         search (fn search [target candidates cnt]\n                  (if (contains? candidates target)\n                   cnt\n                   (search target\n                           (set (flatten (map (juxt x2 halve add2) candidates)))\n                           (inc cnt))))]\n    (search y #{x} 1)))","user":"4dc97aec535d5973398f9284"},{"problem":106,"code":"(fn [s e]\n  (loop [n 1\n         m #{s}]\n    (if (m e)\n      n\n      (recur (inc n)\n             (set (mapcat #(into [(* 2 %) (+ 2 %)] (if (even? %) [(/ % 2)]))\n                          m))))))","user":"50ed4626e4b01236b1d4983c"},{"problem":106,"code":"(fn [s t]\n  (loop [d {s 1}\n         q [s]]\n    (let [u (first q)]\n      (if (= u t)\n        (d t)\n        (let [vs [(* 2 u) (+ 2 u)]\n              vs (if (zero? (mod u 2)) (conj vs (/ u 2)) vs)\n              vs (filter #(not (contains? d %)) vs)\n              vds (map #(vector % (+ (d u) 1)) vs)]\n          (recur (into d vds) (into (vec (rest q)) vs)))))))","user":"5799ff45e4b05b1deef9add1"},{"problem":106,"code":";;wouldn't work if you didn't know how far you needed to search, but oh well\n(fn [x y]\n  ((fn lookin [a count]\n    (if (or (= a y) (> count 10))\n      count\n      (if (odd? a)\n        (min\n         (lookin (+ 2 a) (inc count))\n         (lookin (* 2 a) (inc count)))\n        (min\n         (lookin (+ 2 a) (inc count))\n         (lookin (* 2 a) (inc count))\n         (lookin (/ a 2) (inc count)))))) x 1))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn [s e]\n  (loop [c 1\n         n #{s}]\n    (if (n e) c\n        (recur (inc c)\n               (reduce clojure.set/union #{}\n                       (map (fn [x]\n                              (clojure.set/union\n                               #{(* 2 x) (+ 2 x)}\n                               (if (even? x) #{(/ x 2)} #{})))\n                            n))))))","problem":106,"user":"4fa340b4e4b081705acca18c"},{"problem":106,"code":"(fn [a b]\n  (loop [[[x c] & r] [[a 1]] s #{}]\n    (cond\n      (= x b) c\n      (s x) (recur r s)\n      :else\n        (recur (concat r (map #(vector % (inc c)) (concat [(+ x 2) (* x 2)] (if (= 0 (mod x 2)) [(quot x 2)] [])))) (conj s x)))))","user":"4faf97d8e4b081705acca258"},{"problem":106,"code":"(fn number-maze\n  [x y]\n  (loop [q (conj clojure.lang.PersistentQueue/EMPTY [x 1])]\n    (let [[[i d] r] ((juxt first pop) q)\n          d' (inc d)\n          is (filter integer? (map #(% i 2) (list * + /)))]\n      (if (= i y) d (recur (apply conj r (map #(vector % d') is)))))))","user":"5d0bb4fae4b0cc9c91588237"}]