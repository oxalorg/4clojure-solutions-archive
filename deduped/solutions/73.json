[{"problem":73,"code":"(fn [board]\n  (let [rows board\n        transpose #(apply map vector %)\n        cols (transpose board)\n        diags (transpose \n               (for [r (range (count (first board)))\n                     :let [s (dec (count (first board)))]]\n                 [(get-in board [r r])\n                  (get-in board [r (- s r)])]))\n        lines (into [] (concat rows cols diags))\n        winner? (fn [l]\n                  (let [o? #(= % :o)\n                        x? #(= % :x)\n                        o-won? (every? o? l)\n                        x-won? (every? x? l)]\n                    (cond o-won? :o\n                          x-won? :x\n                          :else nil)))\n        processed (map winner? lines)\n        some? #(not= % nil)]\n    (first (filter some? processed))))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn [b]\r\n  (letfn [(h [n] (nth b n))\r\n          (v [n] (map #(nth % n) b))\r\n          (d [n] (cond (= n 0) [(nth (nth b 0) 0) (nth (nth b 1) 1) (nth (nth b 2) 2)]\r\n                       (= n 1) [(nth (nth b 0) 2) (nth (nth b 1) 1) (nth (nth b 2) 0)]))\r\n          (fill? [ox line] (every? #(= ox %) line))\r\n          (fill-o? [line] (fill? :o line))\r\n          (fill-x? [line] (fill? :x line))]\r\n    (let [lines [(h 0) (h 1) (h 2) (v 0) (v 1) (v 2) (d 0) (d 1)]]\r\n      (cond (some fill-o? lines) :o\r\n            (some fill-x? lines) :x\r\n            :else nil))))","problem":73,"user":"4f62b29ce4b0defedf855fd9"},{"problem":73,"code":"(fn analyze [x] (let [numvals {:x -1,\n                        :e 0,\n                        :o 1}\n                        numboard (map #(map numvals %) x)\n                        hor_scores (map #(reduce + %) \n                                        numboard\n                                    )\n                        ver_scores (apply mapv + numboard)\n                        diag_scores (list (+ (nth (nth numboard 0) 0) (nth (nth numboard 1) 1) (nth (nth numboard 2) 2))\n                                      (+ (nth (nth numboard 0) 2) (nth (nth numboard 1) 1) (nth (nth numboard 2) 0)))\n                        ]\n                    (cond \n                      (= 3 (apply max (concat hor_scores ver_scores diag_scores)))  :o\n                      (= -3 (apply min (concat hor_scores ver_scores diag_scores))) :x\n                      :else nil)\n                    \n                    ))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":73,"code":"(fn ttt? [board]\n  (let [t (fn [b] (apply map vector b))\n        lrb (map reverse board)\n        row-win? (fn [m row] (apply = m row))\n        diag-win? (fn [m b] (row-win? m (rest\n          (reduce (fn [acc row] \n              (cons (inc (first acc)) (cons (nth row (first acc)) (rest acc))))\n            '(0)\n            b))))\n        vh-win? (fn [m b] (println :vh m b) (reduce #(or %1 %2) (map #(row-win? m %) (concat b (t b)))))\n       ]\n    (cond (vh-win? :x board) :x\n          (diag-win? :x board) :x\n          (diag-win? :x lrb) :x\n          (vh-win? :o board) :o\n          (diag-win? :o board) :o\n          (diag-win? :o lrb) :o\n          :else nil)))","user":"53ff8c31e4b0de5c41848603"},{"problem":73,"code":"(let [tester (fn [a b c] (and (not= :e a)(cond (= a b c) a)))\n      candidates (fn [ttt-board] (into [] (flatten (conj ttt-board\n       (map first ttt-board)\n       (map second ttt-board)\n       (map last ttt-board)\n       (first (first ttt-board)) (second (second ttt-board)) (last (last ttt-board))\n       (last (first ttt-board)) (second (second ttt-board)) (first (last ttt-board))))))]\n(fn [ttt-board]\n      (some #(apply tester %) (partition 3 (candidates ttt-board)))))","user":"54485727e4b032a45b8693c6"},{"problem":73,"code":";; flatten board into single dimentional array\n;; (flatten board)\n;; extract items at indecies 0, 3, 6\n;; if these indecies are equal to :x, then return :x\n;; else, return :e\n\n;;(fn is-won? [board]\n;;  (if (= 3 (count\n;;            (filter \n;;             \t#(= % :x)\n;;                (take-nth 3 (flatten board))\n;;                     )))\n;;      :x\n;;      nil))\n\n(fn decide [board]\n  (let [moves [\n               [[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]\n               \n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               \n               \n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]\n               \n               ]]\n    (->> (map #(frequencies (map (fn [v] (get-in board v)) %)) moves)\n         (filter #(= 1 (count %)))\n         (apply merge)\n         (reduce (fn [old [k v]]\n                   (cond (or (= k :x) (= k :o)) k :else nil)\n                   ) nil))))","user":"5fb68f09e4b08cb800c85b58"},{"problem":73,"code":"(fn [board]\n\n    (let [triples [[[0 0] [0 1] [0 2]]\n                   [[1 0] [1 1] [1 2]]\n                   [[2 0] [2 1] [2 2]]\n                   [[0 0] [1 0] [2 0]]\n                   [[0 1] [1 1] [2 1]]\n                   [[0 2] [1 2] [2 2]]\n                   [[0 0] [1 1] [2 2]]\n                   [[2 0] [1 1] [0 2]]]\n\n         lookup (fn [triple] (map (fn [[r c]] (nth (nth board r) c)) triple))\n         \n         winner (fn [triple] (if (apply = triple) (first triple) nil))]\n\n        (first (filter #{:x :o} (map (comp winner lookup) triples)))))","user":"54e540c1e4b024c67c0cf7f9"},{"problem":73,"code":"(fn foo [b]\r\n  (let [b' (map (fn [s] (map #(when (not= :e %) %) s)) b)\r\n        x (->>\r\n            b'\r\n            (filter #(apply = %))\r\n            (map first)\r\n            (filter identity)\r\n            first)\r\n        y (->>\r\n            (apply map list b')\r\n            (filter #(apply = %))\r\n            (map first)\r\n            (filter identity)\r\n            first)\r\n        d1 (when (= ((comp first first) b')\r\n                    ((comp second second) b')\r\n                    ((comp last last) b'))\r\n                   ((comp first first) b'))\r\n        d2 (when (= ((comp last first) b')\r\n                    ((comp second second) b')\r\n                    ((comp first last) b'))\r\n                   ((comp first last) b'))]\r\n\r\n    (or x y d1 d2)))","user":"606e0a42e4b069485764de19"},{"problem":73,"code":"(fn [board]\n  (let [winning-rows [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n        is-empty? (partial = :e)]\n    (->> (map (fn [row board] (map #(nth %2 %1) row board)) winning-rows (repeat board))\n         (concat board)\n         (remove #(some is-empty? %))\n         (filter #(apply = %))\n         (ffirst))))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn ttt [b]\n  (first \n    (keep identity\n          (map\n            (fn [s]\n              (when (some #{true}\n                          (map (partial every? #{s})\n                               (concat\n                                 b\n                                 (apply map vector b)\n                                 [(map #(get-in b [% %]) [0 1 2])]\n                                 [(map #(get-in b %) [[2 0] [1 1] [0 2]])]))) s))\n            [:x :o]))))","problem":73,"user":"4e5914e0535d8a8b8723a29b"},{"code":"(fn [board]\n  (first \n   (some #{[:o :o :o] [:x :x :x]}\n         (concat board (apply map list board)\n                 (map #(map (fn [f v] (f v)) board %) [[0 1 2] [2 1 0]])))))","problem":73,"user":"50e4f4e9e4b049a987753896"},{"code":"(fn [board]\n              (first\n               (some #{#{:x} #{:o}}\n                     (map set\n                          (concat\n                           board\n                           (apply map vector board)\n                           [ (map get board (range))\n                             (map get (reverse board) (range) )])))))","problem":73,"user":"4e6f578c535d5021c1a8961b"},{"problem":73,"code":"(fn [[b1 b2 b3]]\n  (let [w (fn [[x y z]] (if (and (= x y z) (not= x :e)) x))\n        ds (fn [x] (vector (map-indexed #(nth %2 %) x)))\n        c #(some w %)\n        rs [b1 b2 b3]\n        cs (map vector b1 b2 b3)]\n    (or (c rs) (c cs)\n        (c (ds rs))\n        (c (ds (reverse cs))))))","user":"508c3d42e4b0f17d83ea26b2"},{"code":"(fn ttt [s]\n  (let[ wins [[0 0 0 1] [1 0 0 1] [2 0 0 1] \n              [0 0 1 0] [0 1 1 0] [0 2 1 0] \n              [0 0 1 1] [0 2 1 -1]]]\n    (first \n      (filter #{:x :o}\n        (for [[x y px py] wins] \n          (reduce #(when (= % %2) %)\n            (for [i (range 3)]\n              (nth (nth s (+ x (* i px))) (+ y (* i py))))))))\n    ))","problem":73,"user":"50901b2ee4b0ea685a20f774"},{"problem":73,"code":"(fn [board]\n      (let [paths [ [[0 0] [0 1] [0 2]]\n                    [[1 0] [1 1] [1 2]]\n                    [[2 0] [2 1] [2 2]]\n                    [[0 0] [1 0] [2 0]]\n                    [[0 1] [1 1] [2 1]]\n                    [[0 2] [1 2] [2 2]]\n                    [[0 0] [1 1] [2 2]]\n                    [[0 2] [1 1] [2 0]] ]\n            some? (fn [pred coll]\n                    (first (filter pred coll)))\n            winning-path? (fn [bd p path]\n                            (every? #(= p %)\n                                    (map #(get-in bd %) path)))\n            win? (fn [bd p]\n                   (some? #(winning-path? bd p %) paths))]\n        (cond \n          (win? board :x) :x\n          (win? board :o) :o\n          :else           nil)))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn [b]\n  (let [w (fn [r] (some (fn[x]\n                          (when\n                              (every?\n                               #(and\n                                 (= (get-in b %) (get-in b (nth x 0)))\n                                 (not (= (get-in b %) :e)))\n                               x) (get-in b (nth x 0)))) r))\n        a (vec (for [i [0 1 2] j [0 1 2]] [i j]))\n        h (partition 3 a)\n        v [(take-nth 3 a) (take-nth 3 (rest a)) (take-nth 3 (drop 2 a))]\n        d [[(a 0) (a 4) (a 8)] [(a 2) (a 4) (a 6)]]]\n    (or (w h) (w v) (w d) nil)))","problem":73,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":73,"code":"(fn[ttm]\n  (letfn [(get-at [ttm x y]\n                  (nth (nth ttm x) y)\n                  )]\n    (letfn [( check-point-set [t p s ]\n              ;(println s player 1 )\n              (let [r (every? #(= (get-at t (first %) ( second %))  p )\n                              s\n                              )] \n                r))] \n      (letfn [(get-points-sets-to-check [t]\n                                        (let [n (count t)]\n                                          ( concat\n                                            (for [r (range n)] (for [c (range n)] [r, c]) )\n                                            (for [r (range n)] (for [c (range n)] [c, r]) )\n                                            (conj '() (for [r (range n)] [r, r]))\n                                            (conj '() (for [r (range n)] [(- n r 1), r]))\n                                            )\n                                          ))]\n        (letfn [(p73check2 [t p]\n                           (reduce\n                            (fn [r, x]\n                              (if (= r true)\n                                true\n                                (check-point-set t p x)))\n                            false\n                            (get-points-sets-to-check t))            \n                           ) ] \n          (cond (p73check2 ttm :o) :o\n                (p73check2 ttm :x) :x\n                :else nil  ))))))","user":"51b5a6e0e4b0f094dd986fce"},{"code":"(fn who-won? [[one two three]]\n  (let [verts (map #(vector %1 %2 %3) one two three)\n        diags (conj '() (vector (one 0) (two 1) (three 2)) (vector (one 2) (two 1) (three 0)))\n        all (concat verts diags (list one two three))]\n  (first (first (filter #(and (apply = %) (not= :e (first %))) all)))))","problem":73,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn f [m]\n  (let [lines (concat\n    (for [i [0 1 2]] (for [j [0 1 2]] [i j]))\n    (for [i [0 1 2]] (for [j [0 1 2]] [j i]))\n    [(for [i [0 1 2]] [i i])]\n    [(for [i [0 1 2]] [i (- 2 i)])])\n        w (fn [line] (reduce\n                       #(if (= %1 %2) %1 nil)\n                       (map #((m (% 0)) (% 1)) line)))]\n      (->>(map w lines)\n        (filter #(and (not (nil? %)) (not= :e %)))\n        first)))","problem":73,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":73,"code":"(fn mm [tt]\n  (let [x (nth tt 0)\n        y (nth tt 1)\n        z (nth tt 2)]\n    (cond\n     (and (not= :e (nth x 0)) (= (nth x 0) (nth x 1) (nth x 2))) (nth x 0)\n     (and (not= :e (nth y 0)) (= (nth y 0) (nth y 1) (nth y 2))) (nth y 0)\n     (and (not= :e (nth z 0)) (= (nth z 0) (nth z 1) (nth z 2))) (nth z 0)\n     (and (not= :e (nth x 0)) (= (nth x 0) (nth y 0) (nth z 0))) (nth x 0)\n     (and (not= :e (nth x 1)) (= (nth x 1) (nth y 1) (nth z 1))) (nth x 1)\n     (and (not= :e (nth x 2)) (= (nth x 2) (nth y 2) (nth z 2))) (nth x 2)\n     (and (not= :e (nth x 0)) (= (nth x 0) (nth y 1) (nth z 2))) (nth x 0)\n     (and (not= :e (nth x 2)) (= (nth x 2) (nth y 1) (nth z 0))) (nth x 2)\n     :else nil)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":73,"code":"(fn check-win\n        [[[a1 a2 a3]\n          [b1 b2 b3]\n          [c1 c2 c3]]]\n        (letfn [(ch-win [x] (if (= :e x) nil x))]\n          (if (= a1 a2 a3) (ch-win a1)\n              (if (= b1 b2 b3) (ch-win b1)\n                  (if (= c1 c2 c3) (ch-win c1)\n                      (if (= a1 b1 c1) (ch-win a1)\n                          (if (= a2 b2 c2) (ch-win a2)\n                              (if (= a3 b3 c3) (ch-win a3)\n                                  (if (= a1 b2 c3) (ch-win a1)\n                                      (if (= a3 b2 c1) (ch-win a3)\n                                          nil))))))))))","user":"54a6baaee4b09f271ff37c8a"},{"problem":73,"code":"(fn [board]\n  (let [winning-combinations [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n                              [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]\n                              [[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]]\n    (first\n     (keep (fn [winning-combination]\n             (let [combination (map #(get-in board %) winning-combination)]\n               (cond\n                 (every? #(= :x %) combination) :x\n                 (every? #(= :o %) combination) :o\n                 :else nil))) winning-combinations))))","user":"5125029de4b0ce9225d2ed3e"},{"code":"(fn ttt* [board]\n  (let [pos  [[[0 0] [0 1] [0 2]]\n             [[1 0] [1 1] [1 2]]\n             [[2 0] [2 1] [2 2]]\n\n             [[0 0] [1 0] [2 0]]\n             [[0 1] [1 1] [2 1]]\n             [[0 2] [1 2] [2 2]]\n\n             [[0 0] [1 1] [2 2]]\n             [[2 0] [1 1] [0 2]]]\n        \n        line-matcher* (fn [fig]\n                 (fn [line]\n                   (every? #(= fig (nth (nth board (first %)) (second %))) line)))]\n    (cond\n     (some (line-matcher* :x) pos) :x\n     (some (line-matcher* :o) pos) :o\n     :else nil)))","problem":73,"user":"51d662fce4b0154f82ab92ef"},{"code":"(fn [m] \n  (let [combs (concat m (map #(map % m) [first second last]) [(map #((m %) %) [0 1 2])] [(map #((m (- 2%)) %) [0 1 2])])\n        win (some #{[:x :x :x] [:o :o :o]} combs)] \n    (if (empty? win) nil (first win))))","problem":73,"user":"5093ca51e4b097f48cc38585"},{"code":"(fn [rows]\n  (let [equal? (fn [s] (reduce (fn [memo item] (if (and (= memo item) (not= :e item)) item nil)) (first s) (rest s)))\n        cols (apply map vector rows)\n        row  (some equal? rows)\n        col (some equal? cols)\n        diag1 (equal? (map #(nth (nth rows %) %) (range 3)))\n        diag2 (equal? (map #(nth (nth rows (second %)) (first %)) [[0 2][1 1][2 0]]))]\n    (or col row diag1 diag2)))","problem":73,"user":"4e8b98fc535d65386fec2124"},{"problem":73,"code":"(fn check [board]\n  (let [rows (for [r (range 3) c (range 3)] [r c])\n        cols (for [r (range 3) c (range 3)] [c r])\n        d1 (for [r (range 3)] [r r])\n        d2 (for [r (range 3)] [r (- 2 r)])]\n    (->> (map (fn [[row col]] (get-in board [row col])) (concat rows cols d1 d2))\n         (partition 3)\n         (filter #(distinct %))         \n         (map #(into #{} %))\n         (filter #(= 1 (count %)))\n         (map first)\n         (keep #(#{:x :o} %))\n         (first))))","user":"4fb01e53e4b081705acca260"},{"problem":73,"code":"(fn win [l] (let [x [:x :x :x] o [:o :o :o] ok #(cond ((set %)x):x ((set %)o):o)]\n  (cond (ok l) (ok l)\n        (ok [(vec(map first l)) (vec (map second l)) (vec (map last l))])(ok [(vec(map first l)) (vec (map second l)) (vec (map last l))])\n        (ok [(vec(map nth l [0 1 2])) (vec (map nth l [2 1 0]))])(ok [(vec(map nth l [0 1 2])) (vec (map nth l [2 1 0]))])\n)))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [[a b c]]\n  (let [q (into [a b c \n                 [(first a)(second b)(last c)]\n                 [(first c)(second b)(last a)]] (map vector a b c))\n        won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n       (first (remove nil? (map won? q)))))","problem":73,"user":"4f05ea25535dcb61093f6c02"},{"problem":73,"code":"(fn [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]\n  (first (drop-while nil? (map\n                           (fn [[x y z]] (cond (= x y z :x) :x (= x y z :o) :o))\n                           [[a1 a2 a3] [b1 b2 b3] [c1 c2 c3] [a1 b1 c1] [a2 b2 c2] [a3 b3 c3] [a1 b2 c3] [a3 b2 c1]]))))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [board]\r\n  (let [i [0 1 2]\r\n        c (take 12 (cycle i))\r\n        p (flatten (map #(repeat 3 %) i))\r\n        zip #(map vector %1 %2)\r\n        win? (fn [w] \r\n               (some \r\n                 (fn [x] (every? #(= w (get-in board %)) x)) \r\n                 (partition \r\n                   3 (into (zip (into i p) c) (zip c (into (reverse i) p))))))]\r\n    (cond \r\n      (win? :x) :x\r\n      (win? :o) :o)))","problem":73,"user":"4e1158aa535d04ed9115e7c6"},{"problem":73,"code":"(fn [board]\n  (let [checklist [#{[0 0] [0 1] [0 2]}\n                   #{[1 0] [1 1] [1 2]}\n                   #{[2 0] [2 1] [2 2]}\n                   #{[0 0] [1 0] [2 0]}\n                   #{[0 1] [1 1] [2 1]}\n                   #{[0 2] [1 2] [2 2]}\n                   #{[0 0] [1 1] [2 2]}\n                   #{[0 2] [1 1] [2 0]}]\n        check (fn [coords]\n                (let [ps (map (comp #{:x :o} (partial get-in board)) coords)]\n                  (when (apply = ps) (set ps))))]\n    (first (mapcat check checklist))))","user":"59a24c92e4b066c664927d20"},{"problem":73,"code":"(fn [board]\n  (let [cols (map (fn [i] (map #(vector % i) (range 3))) (range 3))\n        rows (map (fn [i] (map reverse i)) cols)\n        diag [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]\n        all-c (concat cols rows diag)\n        srch (->> (map (fn [i] (map #(get-in board %) i)) all-c)\n                  (filter #(and (apply = %) (or (= :x (first %)) (= :o (first %))))))]\n    (when (seq srch)\n      (ffirst srch))))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":73,"code":"(fn [rows]\n  (letfn [(transp [r] (apply map vector r))\n          (somefilled? [k r] (some #(apply = k %) r))\n          (diag? [k r] (= k\n                           (first (first r))\n                           (second (second r))\n                           (nth (nth r 2) 2)))\n          (win? [k] (or (somefilled? k rows)\n                        (somefilled? k (transp rows))\n                        (diag? k rows)\n                        (diag? k (reverse rows))))]\n    (cond\n      (win? :x) :x\n      (win? :o) :o)))","user":"556323b5e4b0c656e3ff17e5"},{"problem":73,"code":"(fn winner [board]\n  (let [rows (concat board\n                     (apply mapv vector board)\n                     (vector (mapv get board [0 1 2]))\n                     (vector (mapv get board [2 1 0])))\n        winning-rows? (fn [e] (> (count (filter (fn [row] (every? #(= e %) row)) rows)) 0))]\n    (cond (winning-rows? :x) :x\n          (winning-rows? :o) :o\n          :else nil)))","user":"540e8d13e4b0addc1aec671e"},{"problem":73,"code":"(fn ttt\n  [board]\n  (let [diagonals [(nth board 0)\n                   (nth board 1)\n                   (nth board 2)\n                   (map #(nth % 0) board)\n                   (map #(nth % 1) board)\n                   (map #(nth % 2) board)\n                   [(nth (nth board 0) 0) (nth (nth board 1) 1) (nth (nth board 2) 2)]\n                   [(nth (nth board 2) 0) (nth (nth board 1) 1) (nth (nth board 0) 2)]]]\n    (cond\n     (some #(= % '(:x :x :x)) diagonals) :x\n     (some #(= % '(:o :o :o)) diagonals) :o\n     :else nil)))","user":"5888b75fe4b0f1effa3b771b"},{"problem":73,"code":"(fn [[a b c :as m]]\n    (let [q (set `(~a ~b ~c ~@(apply map list m)\n                  ~[(a 0) (b 1) (c 2)]\n                  ~[(a 2) (b 1) (c 0)]))]\n      (cond (q [:x :x :x]) :x\n            (q [:o :o :o]) :o)))","user":"505106fee4b05ab4c7e07d38"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i] :as j]]\n   (cond\n    (and (not= a :e)(= a b c)) a\n    (and (not= d :e)(= d e f)) d\n    (and (not= g :e)(= g h i)) g\n    \n    (and (not= a :e)(= a d g)) a\n    (and (not= b :e)(= b e h)) b\n    (and (not= c :e)(= c f i)) c\n    \n    (and (not= a :e)(= a e i)) a\n    (and (not= c :e)(= c e g)) c\n    :else nil\n    ))","user":"5486adf7e4b0e286459a11be"},{"problem":73,"code":"(fn __ [xoxo]\n  \n    (let \n      [board (flatten xoxo)\n       \n       wins [ ;; [offset, gap] potential wins\n             [0 1] [3 1] [6 1] ; horizontal victory\n             [0 3] [1 3] [2 3] ; vertical victory\n             [0 4] [2 2]\t; diagonal victory \t\n             ]\t\n       \n       \n       test (fn [moves [offset gap]]  (take 3 (take-nth gap  (drop offset moves))) )\n       ]\n      \n      (->>\n       (for [w wins] (test board w) )\n       (map #(case % [:x :x :x] :x [:o :o :o] :o nil) )\n       (drop-while nil?)\n       (first)\n       )\n      )\n    )","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn[[x y z]] \n    (let [w #{7 56 448 73 146 292 273 84}\n          r (reduce (fn[x y] (merge x {y (+ (get x y 0) (x :i)) :i (* 2 (x :i))})) \n            {:i 1}\n            (concat x y z))]\n         (or(and(contains? w (r :x)):x)\n            (and(contains? w (r :o)):o)nil)\n    )\n)","problem":73,"user":"5017eface4b02f523d7cc5e7"},{"problem":73,"code":"(fn ttt-winner [board]\n   (letfn [(diags [rows]\n             [(->> [[0 0] [1 1] [2 2]] (map #(get-in rows %)))\n              (->> [[2 0] [1 1] [0 2]] (map #(get-in rows %)))])\n           (rows [rows] rows)\n           (cols [rows] (apply mapv vector rows))]\n     (->> (concat (diags board) (rows board) (cols board))\n          (filter #{[:x :x :x] [:o :o :o]})\n          (ffirst))))","user":"5d4b2155e4b0776584bd6f28"},{"problem":73,"code":"(fn [[[a b c]\n      [e f g]\n      [h i j]]]\n  (some #(let [dist (distinct %)] (if (or (second dist) (= (first dist) :e)) nil (first dist))) [ [a b c] [e f g] [h i j] [a e h] [b f i] [c g j] [a f j] [c f h] ]))","user":"55a74d46e4b09e57187da2a3"},{"problem":73,"code":"(fn\n  [rows]\n  (or\n    (and (not= (get (get rows 0) 0) :e)\n         (= (get (get rows 0) 0) (get (get rows 1) 1))\n         (= (get (get rows 1) 1) (get (get rows 2) 2))\n         (get (get rows 0) 0))\n    (and (not= (get (get rows 0) 2) :e)\n         (= (get (get rows 0) 2) (get (get rows 1) 1))\n         (= (get (get rows 1) 1) (get (get rows 2) 0))\n         (get (get rows 0) 2))\n    (loop [[row & rows] rows]\n      (if (not row)\n        nil\n        (if (and (not= (get row 0) :e)\n                 (= (get row 0) (get row 1))\n                 (= (get row 1) (get row 2)))\n          (get row 0)\n          (recur rows))))\n    (loop [col 0]\n      (if (= col 3)\n        nil\n        (if (and (not= (get (get rows 0) col) :e)\n                 (= (get (get rows 0) col) (get (get rows 1) col))\n                 (= (get (get rows 1) col) (get (get rows 2) col)))\n          (get (get rows 0) col)\n          (recur (inc col)))))\n    nil))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":73,"code":"(fn ttt [board]\n  (let [find-it (fn [trio]\n                  (if (and (apply = trio) (not-any? #(= :e %) trio))\n                    (first trio)))\n        get-col (fn [c]\n                  (map #(nth % c) board))\n        get-cell (fn [[row col]]\n                   (nth (nth board row) col))\n        result (keep find-it\n                 (concat\n                   (map get-col [0 1 2])\n                   (map #(nth board %) [0 1 2])\n                   [(map get-cell [[0 0] [1 1] [2 2]])]\n                   [(map get-cell [[0 2] [1 1] [0 2]])]))]\n    (first result)))","user":"52ee46e5e4b05e3f0be25ec5"},{"problem":73,"code":"(fn [board]\n  (let [\n        players [:x :o]\n        rows [\n              [[1 1 1] [0 0 0] [0 0 0]]\n              [[0 0 0] [1 1 1] [0 0 0]]\n              [[0 0 0] [0 0 0] [1 1 1]]\n              ]\n        columns [\n                 [[1 0 0] [1 0 0] [1 0 0]]\n                 [[0 1 0] [0 1 0] [0 1 0]]\n                 [[0 0 1] [0 0 1] [0 0 1]]\n                 ]\n        diagonals [\n                   [[1 0 0] [0 1 0] [0 0 1]]\n                   [[0 0 1] [0 1 0] [1 0 0]]\n                   ]\n        winners (concat rows columns diagonals)\n        ]\n    (some #(if (not (nil? %)) %)\n          (map (fn [player]\n                 (when\n                   (some #(= 3 %) (mapv\n                            (fn [w-rows rows]\n                              (apply +\n                                     (mapv\n                                       (fn [w-row row]\n                                         (count\n                                           (filter true?\n                                                   (mapv (fn [a b]\n                                                           (and (= b player) (= a 1)))\n                                                         w-row row))))\n                                       w-rows rows)))\n                            winners (repeat board)))\n                   player))\n               players))))","user":"546a6c7ce4b00cfc9eacc154"},{"problem":73,"code":"(fn [b] (some #{:x :o}\n              (apply clojure.set/union\n              (filter #(= 1 (count %))\n                      (map set (apply concat\n                                      ((juxt\n                                         identity\n                                         (partial apply map vector)\n                                         (comp vector vec (partial map-indexed #(nth %2 %1)))\n                                         (comp vector vec (partial map-indexed #(nth %2 %1)) (partial map reverse))\n                                         ) b)))))))","user":"554680cbe4b0a04f7929953e"},{"problem":73,"code":"(fn f\n  [b]\n  (let [win (fn [v]\n              (when (and (#{:x :o} (first v)) (apply = v))\n                (first v)))\n        rows b\n        cols (for [c (range 3)] (map #(nth % c) b))\n        diag1 [(for [c (range 3)] (nth (nth b c) c))]\n        diag2 [(for [c (range 3)] (nth (nth b c) (- 2 c)))]\n        all  (concat rows cols diag1 diag2)]\n    (some identity (map win all))))","user":"583048d9e4b051871117c007"},{"code":"(letfn [(f [[[a b c]\n             [d e f]\n             [g h i]]]\n          [[a d g]\n           [b e h]\n           [c f i]])\n        (m [a b c]\n          (and (not= :e a)\n               (= a b c)\n               a))\n        (l [t] (some #(apply m %) t))\n        (d [[[a b c]\n             [d e f]\n             [g h i]]]\n          (or (m a e i)\n              (m c e g)))]\n  \n  (fn [b] (some #(% b) [l #(l (f %)) d])))","problem":73,"user":"4dada913c9a9d6ed2d99dc57"},{"problem":73,"code":"(fn [[r0 r1 r2]]\n  (->> [r0 \n        r1 \n        r2 \n        [(nth r0 0) (nth r1 0) (nth r2 0)]\n        [(nth r0 1) (nth r1 1) (nth r2 1)]\n        [(nth r0 2) (nth r1 2) (nth r2 2)]\n        [(nth r0 0) (nth r1 1) (nth r2 2)]\n        [(nth r0 2) (nth r1 1) (nth r2 0)]]\n       (filter #(= (nth % 0) (nth % 1) (nth % 2)))\n       (remove #(= :e (first %)))\n       (ffirst)))","user":"5f5358b7e4b0a0bc16850a77"},{"code":"(fn [b]\n        (let [l2v (partial apply vector)\n              ll2vv (fn [b] (l2v (map l2v b)))   \n              cell (fn [b r c] (nth (nth b r) c))\n              flip-lr\n              (fn [b] (ll2vv (for [r (range 3)] (for [c (range 2 -1 -1)] (cell b r c)))))\n              flip-d\n              (fn [b] (ll2vv (for [r (range 3)] (for [c (range 3)] (cell b c r)))))\n              row\n              (fn [r b] (l2v (for [c (range 3)] (cell b r c))))\n              diag\n              (fn [b] (l2v (for [c (range 3)] (cell b c c))))\n              avs (concat b                   ; rows                                                                                                                                                                                           \n                          (flip-d b)          ; columns                                                                                                                                                                                        \n                          [(diag b)]          ; sw diagonal                                                                                                                                                                                    \n                          [(-> b flip-lr diag)] ; ne diagonal                                                                                                                                                                                  \n                          )\n              wonrow (fn [r] (let [r (set r)] (and (not (:e r)) (= 1 (count r)) (first r))))\n              ]\n          (some wonrow avs)\n          ))","problem":73,"user":"4fbfe9a4e4b081705acca31f"},{"problem":73,"code":"(fn [board]\n  (let [gen-row (fn [x] x)\n        gen-col #(apply map vector %)\n        gen-diag (fn [b]\n                   [(map-indexed #(nth %2 %1) b)\n                    (map-indexed #(nth %2 %1) (reverse b))])\n        lines (apply concat ((juxt gen-row gen-col gen-diag) board))\n        won? (fn [shape]\n               (some true? (map (partial every? #(= shape %)) lines)))]\n    (print lines)\n    (cond (won? :x) :x\n          (won? :o) :o\n          :default nil)))","user":"524740e7e4b05ef8e38e635d"},{"problem":73,"code":"(fn who-wins? [board]\n   (let [wins-h (for [i [0 1 2]] (for [j [0 1 2]] [i j]))\n         wins-v (for [i [0 1 2]] (for [j [0 1 2]] [j i]))\n         wins-d '(([0 0] [1 1] [2 2]) ([0 2] [1 1] [2 0]))\n         wins (concat wins-h wins-v wins-d)\n         map-pos (map (fn [w]\n                        (map (fn [elt] ((board (elt 0)) (elt 1))) w)) wins)\n         winning-pos? (set (map #(if (apply = %) (first %)) map-pos))]\n     (cond (winning-pos? :x) :x \n           (winning-pos? :o) :o \n           :else nil)))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":73,"code":"(fn [ttt] \n  (let [ver (apply map list ttt)\n        diag [(map-indexed #(nth %2 %) ttt)]\n        diag2 [(map-indexed #(nth %2 %) (reverse ttt))]\n        all (concat ttt ver diag diag2)] \n    (->> (filter #(apply = %) all)\n         (remove #(some #{:e} %))\n         (#(if (empty? %)\n             nil\n             (ffirst %))))))","user":"6011b89ee4b074f607df66bc"},{"problem":73,"code":"(fn [board]\n(let [crct (filter #(not (nil? %)) (map (fn [x] (if (= 1 (count x)) x)) (concat (map #(into #{} %) board) (map (fn [sln] (into #{} (map #(%2 (dec %1)) sln board))) (filter (fn [x] (every? #(<= 1 % 3) x)) (apply concat ((fn [& steps] (map (fn [stp]  (map (fn [n] (take 3 (iterate #(+ stp %) n))) (range 1 4))) steps)) -1 0 1))) )))) fnl  (if (not (empty? crct)) (first (seq (first crct))))] (if (= :e fnl) nil fnl)))","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":73,"code":"(fn tic-tac-toe-board [board]\n  (letfn [(get-indexes [ele v]\n                       (keep identity \n                             (for [i (range 0 (count v))\n                                   j (range 0 (count (first v)))]\n                               (when (= ele (get-in v [i j]))\n                                 [i j]))))\n          (win? [indexes]\n                (and (= 3 (count indexes))\n                     (= (map (partial * 2) (second indexes))\n                        (map + (first indexes)\n                             (last  indexes)))))]\n    (cond \n     (win? (get-indexes :x board)) :x\n     (win? (get-indexes :o board)) :o\n     :else nil)))","user":"53b7aa6ce4b047364c0444d1"},{"problem":73,"code":"(fn [x]\n  (let [xs (concat x \n                   (apply mapv vector x) \n                   (list [((x 0) 0) ((x 1) 1) ((x 2) 2)])\n                   (list [((x 0) 2) ((x 1) 1) ((x 2) 0)]))\n        v (set(map #(set %) xs))]\n    (cond\n      (some #{#{:x}} v) :x\n      (some #{#{:o}} v) :o)))","user":"5e12327ee4b099d064962fe5"},{"problem":73,"code":"(fn \n\t[board] \n\t\t(->> (-> []\n\t\t\t(conj (into #{} (first board)))\n\t\t\t(conj (into #{} (second board)))\n\t\t\t(conj (into #{} (last board)))\n\t\t\t(conj (into #{} (map #(nth % 0 nil) board)))\n\t\t\t(conj (into #{} (map #(nth % 1 nil) board)))\n\t\t\t(conj (into #{} (map #(nth % 2 nil) board)))\n\t\t\t(conj (into #{} (map #(nth (flatten board) % nil) (filter #(zero? (rem % 4)) (range (count (flatten board)))))))\n\t\t\t(conj (into #{} (map #(nth (flatten board) % nil) [2 4 6]))))\n\t\t(sort-by count)\n\t\t(some #(and (= (count %) 1) (or (% :x) (% :o))))))","user":"5954eef0e4b066ee0a44af17"},{"problem":73,"code":"(fn tic-tac-toe\n  [[[r00 r01 r02][r10 r11 r12][r20 r21 r22]]]\n  (let [win? #(or (= % r00 r01 r02) (= % r10 r11 r12) (= % r20 r21 r22)\n                  (= % r00 r10 r20) (= % r01 r11 r21) (= % r02 r12 r22)\n                  (= % r00 r11 r22) (= % r02 r11 r20))]\n    (cond\n     (win? :x) :x\n     (win? :o) :o\n     :else     nil)))","user":"5944abd0e4b0b03edd0057af"},{"code":"(fn ttt [board]\n  (let [board-vector (flatten board)\n        check-lines [[0 3 6]\n                     [1 4 7]\n                     [2 5 8]\n                     [0 1 2]\n                     [3 4 5]\n                     [6 7 8]\n                     [0 4 8]\n                     [2 4 6]]]\n    (->> check-lines\n         (map (fn [line] (map #(nth board-vector %) line)))\n         (filter #(= 1 (count (distinct %))))\n         (filter #(not (= :e (first %))))\n         (#(if (empty? %)\n             nil\n             (first (first %)))))))","problem":73,"user":"4eec82fe535d93acb0a668ae"},{"problem":73,"code":"(fn\n    [x]\n    (first (first (filter #(and (not= :e (first %)) (= 1 (count %))) (map distinct (concat x (partition 3 (apply interleave x)) [(map #((x %) (- 2 %)) [0 1 2])] [(map #((x %) %) [0 1 2])]))))))","user":"542f574be4b0dad94371f2d0"},{"problem":73,"code":"(fn [[[a b c :as row1]\n     [d e f :as row2]\n     [g h i :as row3] :as rows]]\n(let [col1 [a d g]\n      col2 [b e h]\n      col3 [c f i]\n      dia1 [a e i]\n      dia2 [c e g]\n      lines [row1 row2 row3 col1 col2 col3 dia1 dia2]\n      result (map\n  (fn [[h & _ :as line]]\n    (and \n      (apply = line)\n      ((set line) h)\n    ))\n  lines)]\n  (cond\n    ((set result) :x)\n      :x\n    ((set result) :o)\n      :o\n    :else\n      nil)))","user":"5881d1c2e4b0f1effa3b7644"},{"code":"(fn winner [board] (let [is-winner (fn   [player] (or\n              (some identity (map #(= [player player player] % ) board))\n                  (some identity (map #(= [player player player] %) (map  (fn [col] (map #(nth % col) board))  [0 1 2])))\n                   (or (= player (first (first board))(second (second board))\n                      ( nth (nth board 2) 2))\n                   (= player  (nth (first board ) 2) (second (second board))\n                      (first (nth board 2)))\n                   )\n                   )\n                        ) ]\n \n                (cond (is-winner :x) :x\n                      (is-winner :o) :o\n                      :else nil\n                       \n                )\n        )\n)","problem":73,"user":"4df39b50535d08e6dec9fe29"},{"code":"(fn [v]\n    (let [  line-for? (fn [l c] (every? #(= c %) l))\n            at (fn [v x y] (-> v (nth y) (nth x)))\n            diag-up (fn [v] [(at v 0 2) (at v 1 1) (at v 2 0)])\n            diag-down (fn [v] [(at v 0 0) (at v 1 1) (at v 2 2)])            \n            cols (fn [v] (for [x (range (count v))] (map #(nth % x) v)))            \n            wins? (fn [v c]\n                    (or\n                        (some #(line-for? % c) v) \n                        (some #(line-for? % c) (cols v))\n                        (line-for? (diag-up v) c)\n                        (line-for? (diag-down v) c)))]\n    (cond\n        (wins? v :x) :x\n        (wins? v :o) :o\n        :else nil)))","problem":73,"user":"4dbd2aa3535d020aff1edf40"},{"code":"(fn who [x] \n  (let [win (fn [y] (ffirst (filter #(= (count %) 1) (map distinct y))))\n        simple-win (win x)\n        transposed (apply (partial map list) x)\n        diagonal [(map-indexed #(get %2 %1) x)]\n        reverse-diagonal [(map-indexed #(get %2 (- 2 %1)) x)]\n        trans-win (win transposed)\n        reverse-diagonal-win (win reverse-diagonal)\n        diagonal-win (win diagonal)\n        all-wins (remove nil? [simple-win trans-win diagonal-win reverse-diagonal-win])]\n    (if (= (count all-wins) 1)\n      (first all-wins)\n      nil)))","problem":73,"user":"50aa60bee4b056ee01935865"},{"code":"(fn [board] \n  (let [win-lines (concat \n                    board ; rows  \n                    (apply map vector board) ; columns\n                    [(map-indexed #(nth %2 %1) board)] ; main diag\n                    [(map-indexed #(nth %2 (- (count board) %1 1)) board)] ; conj diag\n                    )\n        freqs (map frequencies win-lines)\n        winner? (fn [side] (if (some #(= 3 (side % 0)) freqs) side nil))]\n    (or (winner? :x) (winner? :o))))","problem":73,"user":"4e5f08c7535d8a8b8723a2da"},{"problem":73,"code":"(fn [b]\n  (letfn [(horz [b] b)\n          (vert [b] (map #(map % b) [first second last]))\n          (diag [b] (map (partial map (partial get-in b))\n                         [[[0 0] [1 1] [2 2]]\n                          [[2 0] [1 1] [0 2]]]))\n          (played? [x] (not (= :e x)))\n          (winner [[x & _ :as s]] (when (and (apply = s) (played? x)) x))]\n    (some winner (mapcat #(% b) [horz vert diag]))))","user":"5764457ae4b0994c1922fbf3"},{"problem":73,"code":"(fn [board]\n  (let [rows       (map (fn [row]  (map (fn [col]  [row col])  (range 3)))  (range 3))\n        cols       (map (fn [col]  (map (fn [row]  [row col])  (range 3)))  (range 3))\n        diags      [[[0 0]  [1 1]  [2 2]]  [[0 2]  [1 1]  [2 0]]]\n        all-routes (concat rows cols diags) \n        all-scores (map (fn [route] (map (fn [coords] (get-in board coords)) route)) all-routes)\n        check-wins (fn [player]  (some (fn [score]  (apply (partial = player) score)) all-scores))]\n  (if (check-wins :x)\n    :x\n    (if (check-wins :o)\n      :o\n      nil))))","user":"562e8b2be4b0ab312c17ebbb"},{"code":"(fn winning-game [game]  \n  (let [check-trio (fn [game xs ys] (if (apply = (map #(nth (nth game %2) %1) xs ys)) \n                       \t\t\t\t\t(nth (nth game (first ys)) (first xs)) \n                                \t\t nil))\n        winning-vectors (concat\n                         (list (list (range 3) (range 3)))\n                         (list (list (reverse (range 3)) (range 3)))\n                         (map #(list (range 3) (repeat 3 %)) (range 3))\n                         (map #(list (repeat 3 %) (range 3)) (range 3)))\n        result (remove #(= % :e) (filter identity (map #(check-trio game (first %) (second %)) winning-vectors)))]\n    (if (empty? result)\n      \tnil\n      \t(first result))))","problem":73,"user":"513d121fe4b0e544971636a2"},{"code":"(fn [ttt] (let [c (concat ttt (map (fn [index] (map #(% %2) ttt index)) [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]))\r\n                t (fn [m item] (some identity (map #(apply = (conj % item)) m)))]\r\n            (cond (t c :o) :o\r\n                  (t c :x) :x\r\n                  :else nil)))","problem":73,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h k]]]\n  (reduce #(or % %2) (map \n    (fn [[x y z]]\n      (if (and (= x y z) (not= x :e))\n        x\n        nil))\n  [[a b c] [d e f] [g h k]\n   [a d g] [b e h] [c f k]\n   [a e k] [c e g]])))","problem":73,"user":"4f01c938535dcb61093f6a39"},{"code":"#(case (second %)\n   [:x :e :e] :x\n   [:o :o :o] :o\n   [:o :x :e] :x\n   [:x :o :e] :o\n   nil)","problem":73,"user":"5100d7dbe4b04f1d96d946df"},{"code":"(fn [board]\n  (let [third (fn [l] (nth l 2))\n        inverted (apply map list board)\n\t      lr-diagonal (map (fn [f l] (f l)) [first second third] board)\n\t      rl-diagonal (map (fn [f l] (f l)) [third second first] board)\n\t      winner (fn [p] (or (every? (partial = p) lr-diagonal)\n                          (every? (partial = p) rl-diagonal)\n                          (some (partial every? (partial = p)) board)\n                          (some (partial every? (partial = p)) inverted)))]\n    (or (and (winner :o) :o)\n\t      (and (winner :x) :x))))","problem":73,"user":"4ec53831535d6d7199dd3684"},{"code":"(fn board-complete? [board]\n  (let [n 3\n        rows (for [y (range n)] (for [x (range n)] [x y]))\n        cols (for [x (range n)] (for [y (range n)] [x y]))\n        diags (list (for [x (range n)] [x x])\n                    (for [x (range n)] [(- (- n 1) x) x]))\n        lines (concat rows cols diags)\n        positions (fn [board points]\n          (map (fn [[col row]] (-> board (nth row) (nth col))) points))\n        all? (fn [xo board line]\n          (when (every? (partial = xo) (positions board line))\n            xo))]\n    (some identity (concat (map (partial all? :x board) lines)\n                           (map (partial all? :o board) lines)))))","problem":73,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn __ [[& rows]]\n\n  (let [\n    toss (fn [[& rows]]\n      (for [i (range (count (first rows)))]\n        (for [row rows]\n          (nth row i)\n        )\n      )\n    )\n    \n    homogeneous? (fn [row]\n      (let [srow (set row)]\n          (and (or (:o srow) (:x srow)) (= 1 (count srow)))\n      )\n    )\n    \n    get-diag (fn [rows]\n      (for [n (range (count rows))]\n        (nth (nth rows n) n)\n      )\n    )\n  \n    has-match (fn [things]\n      (reduce #(conj % (if (homogeneous? %2) (first %2))) [] things)\n      ;(map #(homogeneous? %) things)\n    )\n  ]\n    (let [lst (has-match (concat rows (vector  (get-diag rows) (get-diag (reverse rows))) (toss rows)))]\n      (-> lst sort last)\n    )\n  )\n )","problem":73,"user":"503f872ee4b00d1a725ff2ac"},{"problem":73,"code":"(fn [v]\n   (let [q #(if (and (apply = %) (not= (last %) :e)) (last %)) w\n        (fn[e]\n          (some (fn[f] f)\n            (map #(q (e %)) (range (count v)))\n            )       \n          ) \n        ] \n    (or \n      (w #(nth v %))\n      (w (fn[x] (map #(nth % x) v)))\n      (q (map-indexed #(nth %2 (- (count v) % 1)) v))\n      (q (map-indexed #(nth %2 %) v))\n      )\n    )\n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn [bb]\n  (let [winner? (fn [board x]\n                  (let [linear-chk-fn (fn [b] \n                                        (some #(apply = x %) b))\n                        pos-chk-fn (fn [ps]\n                                     (apply = x (map (partial get-in board) ps)))\n                        ]\n                    (or (linear-chk-fn board)\n                        (linear-chk-fn (apply map vector board))\n                        (pos-chk-fn [[0 0] [1 1] [2 2]])\n                        (pos-chk-fn [[2 0] [1 1] [0 2]]))\n                        ))]\n    (cond\n     (winner? bb :x) :x\n     (winner? bb :o) :o)))","problem":73,"user":"513fab65e4b00f13ea1bd891"},{"code":"(fn [board]\n  (letfn [(won? [b x] \n                (cond (= (b 0) [x x x]) true \n                      (= (b 1) [x x x]) true \n                      (= (b 2) [x x x]) true \n                      (= x ((b 0) 0) ((b 1) 1) ((b 2) 2)) true \n                      (= x ((b 0) 2) ((b 1) 1) ((b 2) 0)) true \n                      (= x ((b 0) 0) ((b 1) 0) ((b 2) 0)) true\n                      (= x ((b 0) 1) ((b 1) 1) ((b 2) 1)) true\n                      (= x ((b 0) 2) ((b 1) 2) ((b 2) 2)) true\n                      :else false))]\n    (cond (won? board :x) :x\n          (won? board :o) :o\n          :else nil)))","problem":73,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [board]\n  (let [lines [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] \n               [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]]  [[0 2] [1 2] [2 2]] \n               [[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]] \n        wins #{[:x :x :x] [:o :o :o]}]\n    (when-let [win (some wins\n                      (for [line lines]\n                        (map (partial get-in board) line)))]\n      (first win))))","problem":73,"user":"525431dfe4b0541d1855b970"},{"problem":73,"code":"(fn [b]\n  (letfn [(win [ts xo] (if (some identity (map #(every? #{xo} %) ts)) xo))\n          (diagonal [b] (vector (flatten (partition 1 4 (flatten b)))))]\n    (let [rs (concat b (apply map list b) (diagonal b) (diagonal (map reverse b)))]\n      (some identity (map #(win rs %) [:x :o])))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":73,"code":"(fn anal [board]\n  (let [horiz (fn [board]\n               (let [row-status (map (fn [[a b c]]\n                                       (if (= a b c) a nil)) board)]\n                 (reduce #(if %1\n                            %1\n                            (if-not (or (= %2 :e) (nil? %2))\n                              %2\n                              nil)) nil row-status)))\n        cols (map #(vector %1 %2 %3) (nth board 0) (nth board 1) (nth board 2))\n        diags [(map #(-> board (nth %) (nth %)) (range 3))\n               (map #(-> board (nth %) (nth (- 2 %))) (range 3))]]\n    (reduce #(or %1 (horiz %2)) false [board cols diags])))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":73,"code":"(fn [board]\n  (let [game-score (atom {})\n        game-size (count board)\n        build-score\n        (fn [f r-idx c-idx]\n          (swap! game-score assoc (str \"r\" r-idx)\n                 (f (get @game-score (str \"r\" r-idx) 0)))\n          (swap! game-score assoc (str \"c\" c-idx)\n                 (f (get @game-score (str \"c\" c-idx) 0)))\n          (when (= r-idx c-idx)\n            (swap! game-score assoc \"d1\"\n                   (f (get @game-score \"d1\" 0))))\n          (when (= (+ r-idx c-idx) (- game-size 1))\n            (swap! game-score assoc \"d2\"\n                   (f (get @game-score \"d2\" 0)))))]\n    (doseq [[r row] (map-indexed vector board)]\n      (doseq [[c val] (map-indexed vector row)]\n        (when (= val :x)\n          (build-score inc r c))\n        (when (= val :o)\n          (build-score dec r c))))\n    (cond\n    \t(some #(= % game-size) (vals @game-score)) :x\n    \t(some #(= % (- game-size)) (vals @game-score)) :o\n        :else nil)))","user":"5ebcfe31e4b00a66d4a9526d"},{"problem":73,"code":"#(let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n        rows (map same? %)\n        cols (map same? (apply map vector %))\n        diag1 (same? (map get % (range 3)))\n        diag2 (same? (map get % (range 2 -1 -1)))]\n    (some #{:x :o} (concat rows cols [diag1] [diag2])))","user":"5e8ce2fee4b0cb0169546328"},{"problem":73,"code":"(fn [inputs]\n (let [trans {:e 0 :x 1 :o -1}\n       tmp (map (partial map #(% trans %)) inputs)\n       ho (map (partial reduce +) tmp)\n       ve (apply map + tmp)\n       di-desc (->> (zipmap (range 3) tmp) (map #((vec (val %)) (key %))) (reduce +))\n       di-asc (->> (zipmap (reverse (range 3)) tmp) (map #((vec (val %)) (key %))) (reduce +))\n       res (concat ho ve [di-desc di-asc])]\n  (cond\n   (pos? (.indexOf res 3)) :x\n   (pos? (.indexOf res -3)) :o\n   )))","user":"56f974c0e4b07572ad1a88b1"},{"problem":73,"code":"(fn an [l]\n  (let [rotated ((juxt (partial map first) (partial map second) (partial map last)) l)\n        d1 (map (partial get-in l) [[0 0] [1 1] [2 2]])\n        d2 (map (partial get-in l) [[0 2] [1 1] [2 0]])\n        f #(when (apply = %) (first %))\n        all (concat l rotated [d1 d2])]\n    (->> (map f all)\n         (filter #(not= :e %))\n         sort\n         last)))","user":"51aefceee4b09397d5109797"},{"problem":73,"code":"(fn [mat]\n  (letfn [(transpose [rows] (map (fn [i] (map #(nth % i) rows)) (range 3)))\n          (first-non-nil [f coll] (if (empty? coll) nil (if (nil? (f (first coll))) (recur f (rest coll)) (first coll))))\n          (all-same [coll] (if (every? (partial = (first coll)) coll) (first coll) nil))\n          (diagonal [rows main] (map (fn [i] (nth (nth rows (if main i (- (count rows) i 1))) i)) (range 3)))]\n    (first-non-nil (fn [w] (if (= w :e) nil w))\n     (map #(all-same %)\n      (concat mat\n              (transpose mat)\n              [(diagonal mat true)\n               (diagonal mat false)])))))","user":"55f5c118e4b06e875b46ce8e"},{"problem":73,"code":"(fn [field] \n  (let \n    [ findWinner #(if (= (count %) 1) (or (:x %) (:o %)))\n      digits [0, 1, 2]\n      cols   (map (fn [n] (map #(.get % n) field)) digits)\n      mdiag  (map (fn [n] (.get (.get field n) n)) digits)\n      adiag  (map (fn [n] (.get (.get field (- 2 n)) n)) digits)\n      rows   (concat field cols [mdiag adiag])]\n      ; (println mdiag)))\n    (second (set (map findWinner (map set rows) ) ) )))","user":"5717d674e4b07c98581c3b1a"},{"code":"(fn [board]\n   (letfn [(win? [row]\n                 ;(println row)\n                 (if (not (= -1 (.indexOf row :e)))\n                   false\n                   (= (first row) (second row) (last row))))\n           (winner [possibilities]\n                   (loop [p possibilities]\n                     (println p)\n                     (cond (not (seq p)) nil\n                           (win? (first p)) (first (first p))\n                           :else (recur (rest p)))))]\n     (let [by-cols (apply map vector board)\n           down (vector (first (first board)) (second (second board)) (nth (nth board 2) 2))\n           up (vector (first (nth board 2)) (second (second board)) (nth (first board) 2))\n           poss (into (into (into board by-cols) [down]) [up])]\n       (winner poss))))","problem":73,"user":"51857e64e4b0da5a5be3babe"},{"problem":73,"code":"(fn ttt [board]\n  (let [win (ffirst (filter #(= (count %) 1) (map distinct\n                                                  (concat (list\n                                                           (map first board)\n                                                           (map second board)\n                                                           (map #(nth % 2) board)\n                                                           (map-indexed #(nth %2 %) board)\n                                                           (map-indexed #(nth %2 (- 2 %)) board)) board))))]\n    \n    (if (= win :e) nil win)))","user":"4eb3fcba535d7eef30807359"},{"code":"(fn [rows]\n   (let [line #(let [f (first %)] (when (and (apply = %) (#{:x :o} f)) f))\n         vd (fn [i] (line (map #(% %2) rows i)))\n         gw #(first (keep % %2))]\n     (some #(if % %) [(gw line rows)\n                      (gw vd \n                          (let [r [0 1 2]]\n                            (concat [r (reverse r)]\n                                    (map #(repeat 3 %) r))))])))","problem":73,"user":"4fa30027e4b081705acca187"},{"problem":73,"code":"(fn won\n  [[[a b c]\n    [d e f]\n    [g h i]]]\n  (cond\n    (and (not (= e :e)) (or (= d e f)\n                            (= b e h)\n                            (= a e i)\n                            (= c e g))) e\n    (and (not (= a :e)) (or (= a b c)\n                            (= a d g))) a\n    (and (not (= i :e)) (or (= g h i)\n                            (= c f i))) i))","user":"5b86462de4b047b03b2037df"},{"code":"(fn [rows]                                                             \n         (let [cols (apply map vector rows)                                        \n               diags [(map get rows [0 1 2])                                       \n                      (map get rows [2 1 0])]                                      \n               board (map set (concat rows cols diags))]                           \n           (first (some #{#{:x} #{:o}} board))))","problem":73,"user":"4fd11132e4b04c3a95aa0409"},{"code":"(let [\n      mapGrid (fn [f grid] (map (partial map f) grid)) ; Map a function over a grid\n      zipGridWith (fn [f grid1 grid2] (map (partial map f) grid1 grid2)) ; Combine a pair of grids element-wise\n      sumGrid (fn [grid] (reduce + (map (partial reduce +) grid)))\n      toNumMap {:e 0 :o 1 :x -1} ; Convert a state keyword into a numerical representation\n      convFromNum (fn [x] (get {3 :o -3 :x} x)) ; Convert a numerical representation into winner\n      ; Winning arrangements.\n      arrangements [[[1 1 1] [0 0 0] [0 0 0]]\n                    [[0 0 0] [1 1 1] [0 0 0]]\n                    [[0 0 0] [0 0 0] [1 1 1]]\n                    [[1 0 0] [1 0 0] [1 0 0]]\n                    [[0 1 0] [0 1 0] [0 1 0]]\n                    [[0 0 1] [0 0 1] [0 0 1]]\n                    [[1 0 0] [0 1 0] [0 0 1]]\n                    [[0 0 1] [0 1 0] [1 0 0]]]\n      ] (fn [inpGrid] (\n          ; Convert input grid into numerical representation. Multiply with each winning arrangement grid, inspecting resulting sum for winning values.\n          loop [arrs arrangements winner nil] (if (empty? arrs) winner (let [res (convFromNum (sumGrid (zipGridWith * (first arrs) (mapGrid toNumMap inpGrid))))] (if (= nil res) (recur (rest arrs) nil) res)))))\n      )","problem":73,"user":"5363d242e4b0243289761e5c"},{"problem":73,"code":"(fn [board]\n  (->> board\n       flatten\n       ((fn [fb]\n          (map (fn [[st mo]]\n                 (if (= (nth fb st) (nth fb (+ st mo)) (nth fb (+ st mo mo)))\n                   (nth fb st)\n                   :e))\n               [[0 1] [3 1] [6 1] [0 3] [1 3] [2 3] [0 4] [2 2]])))\n       (some #(when (not= :e %) %))))","user":"56a38a4ce4b0542e1f8d14cc"},{"code":"(fn [tab]\n    (let [idx (for [x (range 3) y (range 3)] [x y])\n          fl (map #(partial (fn [l [x y]] (= x l)) %) (range 3))\n          fc (map #(partial (fn [c [x y]] (= y c)) %) (range 3))\n          fs (concat fl fc [(fn [[x y]] (= x y))]\n                     [(fn [[x y]] (= 2 (+ x y)))])\n          rs (map set (map #(map (fn [e] (get-in tab e)) %)\n                           (map #(filter % idx) fs)))]\n      (ffirst (filter #(and (= 1 (count %)) (not (% :e))) rs))))","problem":73,"user":"4efd8b67535de96065cf5085"},{"problem":73,"code":"(fn [board]\n  (let [winning-combinations [\n              [[0 0] [0 1] [0 2]]  ; horizontal\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]]  ; vertical\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]]  ; diagonal\n              [[2 0] [1 1] [0 2]]\n              ]\n        played-combinations (map #(for [[i j] %] (-> board (get i) (get j))) winning-combinations)\n        wins (filter #(and (apply = %) (not= :e (first %))) played-combinations)]\n    (if (empty? wins) nil (ffirst wins))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":73,"code":"(fn [board]\n      (let [winner? (fn [who] (if (or (= who :x) (= who :o)) who nil))]\n           (some winner?\n                 (flatten (list\n                            (map\n                              (fn [row] (reduce #(if (= %1 %2) %1 nil) row))\n                              board)\n                            (map\n                              (fn [row] (reduce #(if (= %1 %2) %1 nil) row))\n                              (apply map list board))\n                            (let [[[x1 _ _][_ x2 _][_ _ x3]] board]\n                                 (map\n                                   (fn [row] (reduce #(if (= %1 %2) %1 nil) row))\n                                   (list (list x1 x2 x3))))\n                            (let [[[_ _ x1][_ x2 _][x3 _ _]] board]\n                                 (map\n                                   (fn [row] (reduce #(if (= %1 %2) %1 nil) row))\n                                   (list (list x1 x2 x3)))))))))","user":"56cc34aee4b0ea9b8538f73c"},{"problem":73,"code":"(fn _73_ [board]\n  (letfn [(cols [board] (apply map vector board))\n          (diag [board] [(map #(get-in board %) [[0 0] [1 1] [2 2]])\n                         (map #(get-in board %) [[0 2] [1 1] [2 0]])])\n\n          (lines [board] (concat board (cols board) (diag board)))\n\n          (winner [board]\n            (let [cds (lines board)]\n              (cond\n                (some #{[:x :x :x]} cds) :x\n                (some #{[:o :o :o]} cds) :o)))]\n    (winner board)))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn [[a b c]]\n    (let [q (into [a b c \n                   [(first a)(second b)(last c)]\n                   [(first c)(second b)(last a)]] (map vector a b c))\n          won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n      (first (remove nil? (map won? q)))))","problem":73,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":73,"code":"(fn [board]\n   (let [coords (fn [rows?]\n                  (partition 3 (for [x (range 3) y (range 3)] (if rows? [x y] [y x]))))\n         iar (fn [win]\n               (let [r (map (fn [coord] (get-in board coord)) win)]\n                 (cond\n                   (every? #(= % :x) r) :x\n                   (every? #(= % :o) r) :o\n                   :else nil)))\n         wins (concat (coords true)\n                      (coords false)\n                      (partition 3 [[0 0] [1 1] [2 2] [0 2] [1 1] [2 0]]))\n         res (map iar wins)]\n     (some identity res)))","user":"5e44c804e4b01d43a70e8e89"},{"code":"; \n(fn [v]\n  (let [lines [ (v 0) (v 1) (v 2)\n                (mapv #(get-in v %) [[0 0][1 0][2 0]])\n                (mapv #(get-in v %) [[0 1][1 1][2 1]])\n                (mapv #(get-in v %) [[0 2][1 2][2 2]])\n                (mapv #(get-in v %) [[0 0][1 1][2 2]])\n                (mapv #(get-in v %) [[0 2][1 1][2 0]])]]\n  (cond (some (fn [l] (every? #(= :x %) l)) lines) :x\n        (some (fn [l] (every? #(= :o %) l)) lines) :o\n        :else nil)))","problem":73,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":73,"code":"(fn [board]\n\n  (let [third (fn [l] (nth l 2))\n        cols [(map first board)\n              (map second board)\n              (map #(nth % 2) board)]\n        diags [[(first (first board))\n                (second (second board))\n                (third (third board))]\n               [(third (first board))\n                (second (second board))\n                (first (third board))]]\n        vects (concat board cols diags)\n        matches (filter \n                  (fn [v]\n                    (and\n                      (apply = v)\n                      (not (= (first v) :e))))\n                  vects)]\n    (cond\n      (> (count matches) 0) (first (first matches))\n      :else nil)))","user":"53bd7080e4b0d9a98559a6d1"},{"code":"(fn [table]\n  (let [row-equal (fn [v]\n          \"Ritorna :x se sono tutti x:\n           :o se sono tuttu o:\n           nil altrimenti\"\n          (if (= (v 0) (v 1) (v 2))\n            (if (= (v 0) :e)\n              nil\n              (v 0))\n            nil))\n\n        _| (fn [a# x# y#]\n             \"accede all'elemento x y di un array\"\n             ((a# x#) y# ))\n\n        cc (fn [c]\n             \"Genera la funzione che estrae la colonna c\"\n             (fn ccc [a]\n               \"Estrae la colonna dell'array a\"\n               [(_| a 0 c)(_| a 1 c)(_| a 2 c)]))\n\n        rr (fn [r]\n             \"Genera la funzione che estrae la riga r\"\n             (fn rrr [a]\n               \"estrae la riga r da a\"\n               (a r)))\n\n        d1 (fn [a]\n             [(_| a 0 0)(_| a 1 1)(_| a 2 2)])\n\n        d2 (fn [a]\n             [(_| a 2 0)(_| a 1 1)(_| a 0 2)])\n\n        ops [d1 d2 \n                  (cc 0) (cc 1) (cc 2) \n                  (rr 0) (rr 1) (rr 2)]\n\n        dna (fn [x y]\n              (if (= x nil)\n                y\n                x))]\n    (reduce dna\n            (map row-equal\n                 (map (fn [l]\n                        (l table)) ops)))))","problem":73,"user":"52c81954e4b0c2d177d6212e"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [have-winner? (fn [three-marks]\n                       (let [d (distinct three-marks)]\n                         (when (and (not= [:e] d)\n                                    (= (count d) 1))\n                           (apply identity d))))\n        rotated-board (apply map list board)\n        get-elem-at (fn [x y] (nth (nth board x) y))\n        diagonals [[(get-elem-at 0 0) (get-elem-at 1 1) (get-elem-at 2 2)]\n                   [(get-elem-at 0 2) (get-elem-at 1 1) (get-elem-at 2 0)]]]\n    (or (some have-winner? board)\n        (some have-winner? rotated-board)\n        (some have-winner? diagonals))))","user":"5501a1e1e4b07d26eda61d75"},{"code":"(fn [b]\n    (letfn\n        [(win? [b p]\n           (or\n            (some #(every? #{p} %) b)\n            (some #(every? #{p} %) (map #(map (fn [c] (c %)) b) [0 1 2]))\n            (every? #{p} (map #(get-in b [% %]) [0 1 2]))\n            (every? #{p} (map #(get-in b [% (- 2 %)]) [0 1 2]))))]\n    (cond\n     (win? b :x)\n     :x\n     (win? b :o)\n     :o)))","problem":73,"user":"4ed292ac535d44c135fd68d9"},{"problem":73,"code":"(fn [m]\n  (-> (apply concat m)\n    vec\n    (map [0 1 2\n          3 4 5\n          6 7 8\n          0 3 6\n          1 4 7\n          2 5 8\n          0 4 8\n          2 4 6])\n    (->>\n      (partition 3)\n      (map set)\n      (filter #(= 1 (count %)))\n      (filter #(not= #{:e} %))\n      first first)))","user":"50479524e4b0371827a27bc4"},{"problem":73,"code":"#(some {[:x :x :x] :x [:o :o :o] :o}\n             (map (partial map (fn [k] (get-in % k)))\n                  [[[0 0][0 1][0 2]][[1 0][1 1][1 2]][[2 0][2 1][2 2]]\n                  [[0 0][1 0][2 0]][[0 1][1 1][2 1]][[0 2][1 2][2 2]]\n                  [[0 0][1 1][2 2]][[0 2][1 1][2 0]]]))","user":"56baa68ce4b0f26550335947"},{"code":"(fn [tab]\n  (let [hor (into #{} tab)\n        ver (into hor (apply map vector tab))\n        d1  (conj ver (into [] (map #(%1 %2) [first second last] tab)))\n        d2  (conj d1  (into [] (map #(%1 %2) [last second first] tab)))\n        all d2]\n    (cond\n     (all [:x :x :x]) :x\n     (all [:o :o :o]) :o\n     :else nil)\n    ))","problem":73,"user":"5360f043e4b0243289761e3c"},{"problem":73,"code":"(fn who-won?\n  [board]\n  (letfn [(get-at\n  \t\t\t[board [row col]]\n  \t\t\t(get (get board row) col))]\n  (let [idxs [[[0 0] [0 1] [0 2]]\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n\n              [[0 0] [1 0] [2 0]]\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n\n              [[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]]]]\n    (loop [coords idxs]\n      (when (seq coords)\n        (let [elts (set (map (partial get-at board) (first coords)))]\n            (if (and (= (count elts) 1) (not= elts #{:e}))\n              (first elts)\n              (recur (rest coords)))))))))","user":"5ce6f93be4b0a17bb84e2b99"},{"code":"(fn [board]\n  (let [\n    rows board\n    cols (apply map vector board)\n    pos #(get-in board %)\n    diags (map (partial map pos)\n               [ [[0 0][1 1][2 2]] \n                 [[0 2][1 1][2 0]] ])\n\n    counts (map frequencies (concat rows cols diags))\n\n    uncontested (remove fnext counts)\n    full (remove :e uncontested)\n    result (first (ffirst full))  ]\n      result\n    )\n)","problem":73,"user":"502bb7c0e4b0194ad32ea1a3"},{"code":"(fn [x]\n(let [all-rows (concat\n    x\n    [(map first x) (map second x) (map last x)]\n    [[(ffirst x) (second (second x)) (last (last x))]]\n    [[(last (first x)) (second (second x)) (first (last x))]])]\n  (cond\n    (some #(= [:x :x :x] %) all-rows) :x\n    (some #(= [:o :o :o] %) all-rows) :o)))","problem":73,"user":"4ec2f192535dcc7ae8597d4c"},{"problem":73,"code":"(fn [r]\n  (let [f #(map get % [0 1 2])]\n    (first\n     (some #{#{:o} #{:x}}\n           (map set `(~@r\n                      ~@(apply map list r)\n                      ~(f r)\n                      ~(f (rseq r))))))))","user":"51ad244fe4b09397d510977f"},{"code":"#(letfn [(win? [xs] (and (not (= :e (first xs))) (apply = xs) (first xs)))\n         (diagonals [[[a _ b] [_ c _] [d _ e]]]\n           (list [a c e] [b c d]))]\n   (or (some win? %) ; rows\n       (some win? (apply map list %)) ; columns\n       (some win? (diagonals %))))","problem":73,"user":"4ea1b9e4535d7eef308072b8"},{"problem":73,"code":"(fn [board]\n  (let [cols (apply (partial map vector) board)\n        diags (partition 3 (map #(%2 %1) '(0 1 2 2 1 0) (cycle board)))\n        lines (concat board cols diags)]\n    (some #(if (and (apply = %) (not= (first %) :e)) (first %)) lines)))","user":"5cb0f70ce4b026601754b8c1"},{"code":"(fn [xs]\r\n   (let [verify '[[(0 0) (1 0) (2 0)]    ; horizontal\r\n                  [(0 1) (1 1) (2 1)]\r\n                  [(0 2) (1 2) (2 2)]\r\n                  [(0 0) (0 1) (0 2)]    ; vertical\r\n                  [(1 0) (1 1) (1 2)]\r\n                  [(2 0) (2 1) (2 2)]\r\n                  [(0 0) (1 1) (2 2)]    ; diagonal\r\n                  [(2 0) (1 1) (0 2)]]]\r\n\r\n     (loop [verify verify]\r\n       (when verify\r\n         (let [pairs (first verify)\r\n               res (for [p pairs]\r\n                     (-> xs (get (second p)) (get (first p))))]\r\n           (cond\r\n            (every? #(= :x %) res) :x\r\n            (every? #(= :o %) res) :o\r\n            true (recur (next verify)))\r\n           )))))","problem":73,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":73,"code":"(fn [vs] (let [g (fn [i j] (get-in vs [i j]))\n               ls (-> vs \n                      (into (map #(map (fn [r] (nth r %)) vs) [0 1 2]))\n                      (into [[(g 0 0) (g 1 1) (g 2 2)] [(g 0 2) (g 1 1) (g 2 0)]]))\n               t (fn [x] (some #(apply (partial = x) %) ls))]\n  (cond (t :x) :x (t :o) :o :else nil)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [b]\n(let [pos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [6 4 2]] board (flatten b)]\n((fn [res] (cond (some #{:x} res) :x (some #{:o} res) :o :else nil))\n  \t(map (fn [v] (reduce (fn [x y] (if (= x y) x false)) \n\t\t(map (fn [x] (nth (flatten board) x)) v))) \n\t\tpos))\n))","problem":73,"user":"50588af1e4b06522596eba7d"},{"code":"(fn [b]\n  (some {[:o :o :o] :o [:x :x :x] :x}\n        (concat b (partition 3 (apply interleave b))\n                  (for [i [[0 4 8][2 4 6]]]\n                    (map #(nth (flatten b) %) i)))))","problem":73,"user":"4e49badd535dc968683fc4c9"},{"problem":73,"code":"(fn won[st](\n              \n           #(if (nil? %) nil (first %))   (some #(and (not (= (nth % 0) :e)) (= (nth % 0) (nth % 1) (nth % 2)) %) [(nth st 0)(nth st 1)(nth st 2)\n                  [(nth (nth st 0) 0) (nth (nth st 1) 0) (nth (nth st 2) 0)]\n                  [(nth (nth st 0) 1) (nth (nth st 1) 1) (nth (nth st 2) 1)]\n                  [(nth (nth st 0) 2) (nth (nth st 1) 2) (nth (nth st 2) 2)]\n                  [(nth (nth st 0) 0) (nth (nth st 1) 1) (nth (nth st 2) 2)]\n                  [(nth (nth st 0) 2) (nth (nth st 1) 1) (nth (nth st 2) 0)]]\n              \n              )))","user":"596f6683e4b069c0a1a19877"},{"problem":73,"code":"(fn [lst]\n  (let [a (map #(apply str %) lst)\n        b (map #(apply str %) (partition 3 (apply interleave lst)))\n        c (map #(apply str %)\n          [[(ffirst lst) (second (second lst)) (last (last lst))] \n           [(first (last lst)) (second (second lst)) (last (first lst))]])\n        d (concat a b c)]\n    (cond \n      (some #(= % \":x:x:x\") d) :x\n      (some #(= % \":o:o:o\") d) :o\n      :else nil)))","user":"564d3169e4b0284900eef67c"},{"problem":73,"code":"(fn [grid]\n   (let [mapped-grid (map (fn [x y] {x y}) (flatten grid) [8 1 6 3 5 7 4 9 2])\n         valid-combinations (filter (fn [x]\n                                      (== (reduce + (vals x))\n                                          15)) (for [x (range 1 10)\n                                                     y (range (inc x) 10)\n                                                     z (range (inc y) 10)]\n                                                 {:x x :y y :z z}))\n         xs (reduce (fn [a v]\n                      (let [x (:x v)]\n                        (if x (conj a x) a))) '() mapped-grid)\n         os (reduce (fn [a v]\n                      (let [o (:o v)]\n                        (if o (conj a o) a))) '() mapped-grid)\n         has-won (fn [vals] (reduce (fn [result combination]\n                         (or result \n                            (and (some #{(:x combination)} vals)\n                                 (some #{(:y combination)} vals)\n                                 (some #{(:z combination)} vals) \n                                 true))) false valid-combinations))\n         ]\n     (cond (has-won xs) :x\n           (has-won os) :o\n           :else nil)\n     ))","user":"4e9ff8d0535d7eef3080729c"},{"problem":73,"code":"(fn [board]\n  (let [rdc (concat\n    (let [lr [[0 0] [1 1] [2 2]]\n        rl [[0 2] [1 1] [2 0]]]\n    (vector\n      (reduce #(conj %1 (get-in board %2)) [] lr)\n      (reduce #(conj %1 (get-in board %2)) [] rl)))\n    (vec (apply map #(vector %1 %2 %3) board))\n    board)]\n    (reduce #(or %1 ((fn [three]\n  (if (apply = three)\n    (if (not= :e (first three))\n      (first three)\n      nil)\n    nil)) %2)) nil rdc)))","user":"580a0783e4b0a837a8b30d2c"},{"code":"(fn ttt [board]\n  (let [transpose (fn [v] (apply (partial map vector) v))\n        tboard (transpose board)\n        getin (fn [row i] (row i))\n        diagonal (fn [b is] [(mapv getin b is)])\n        all-positions (concat board\n                              tboard\n                              (diagonal board (range))\n                              (diagonal tboard (range 2 -1 -1)))]\n    (cond\n      (some #{[:o :o :o]} all-positions) :o\n      (some #{[:x :x :x]} all-positions) :x\n      :default nil)))","problem":73,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":73,"code":"(fn [board]\n  (let [transpose (apply map list board)\n        diag [(map #(get-in board %)\n                   [[0 0] [1 1] [2 2]])]\n        anti-diag [(map #(get-in board %)\n                        [[0 2] [1 1] [2 0]])]]\n    (some {[:x :x :x] :x, [:o :o :o] :o}\n          (concat board\n                  transpose\n                  diag\n                  anti-diag))))","user":"515cf9b5e4b00901442db1d4"},{"code":"(fn [g h k l s]\n  (let [a (concat s\n                  (l map list s)\n                  [(h s (k))]\n                  [(h s (k 2 -1 -1))])\n        b (g (g (filter #(l = %) a)))]\n    (if (not= b :e) b)))\n#(nth % 0 nil) #(map nth % %2) range apply","problem":73,"user":"4e96557d535dbda64a6f6b43"},{"problem":73,"code":"(fn winner [board]\n  (letfn [(transpose [m] (vec (apply map vector m)))\n          (major-diagonal [m] (vec (map-indexed #(%2 %1) m)))\n          (minor-diagonal [m] (major-diagonal (vec (reverse (apply map vector m)))))\n          (won-by? [player board]\n            (let [row [player player player]]\n              (or (some #{row} board)\n                  (some #{row} (transpose board))\n                  (= row (major-diagonal board))\n                  (= row (minor-diagonal board)))))]\n    (cond (won-by? :x board) :x\n          (won-by? :o board) :o)))","user":"57ee804ee4b0bfb2137f5bbb"},{"code":"#(let [lst (last (sort (flatten (map keys (filter (fn[a](not (empty? (flatten (filter (partial = 3) (vals a)))))) (map frequencies (concat % (apply map list %) [(for [i [2 4 6]] (nth (flatten %) i))] [(for [i [0 4 8]] (nth (flatten %) i))])))))))] (if (= lst :e) nil lst))","problem":73,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn won? [rows]\n  (let [v (into [] (apply concat rows))\n        wins [[0 1 2]\n              [3 4 5]\n              [6 7 8]\n              [0 3 6]\n              [1 4 7]\n              [2 5 8]\n              [0 4 8]\n              [2 4 6]]\n        winners #{:x :o}]\n    (some (fn [win] (let [vals (map v win)]\n                     (and (apply = vals)\n                          (winners (first vals))\n                          (first vals)))) wins)))","problem":73,"user":"52be58d7e4b07a9af579231d"},{"problem":73,"code":"#(\n      let  [one (nth (nth % 0) 0)\n            two (nth (nth % 0) 1)\n            three (nth (nth % 0) 2)\n            four (nth (nth % 1) 0)\n            five (nth (nth % 1) 1)\n            six (nth (nth % 1) 2)\n            seven (nth (nth % 2) 0)\n            eight (nth (nth % 2) 1)\n            nine (nth (nth % 2) 2)]\n      \n      \n      (cond\n      (or (= one two three :x)\n          (= four five six :x)\n          (= seven eight nine :x)\n          (= one four seven :x)\n          (= two five eight :x)\n          (= three six nine :x)\n          (= one five nine :x)\n          (= three five seven :x))\n        :x\n        (or (= one two three :o)\n          (= four five six :o)\n          (= seven eight nine :o)\n          (= one four seven :o)\n          (= two five eight :o)\n          (= three six nine :o)\n          (= one five nine :o)\n          (= three five seven :o))\n        :o\n        :else\n        nil\n        )\n      \n        \n      )","user":"566648e6e4b0e91d5f5c566c"},{"problem":73,"code":"(fn [rows]\n  (let [wins [\n              [[0 0] [0 1] [0 2]]\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]]\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]] ]]\n    (first\n     (drop-while #(= :e %)\n                 (for [w wins\n                       :let [r (map #(get-in rows %) w)]\n                       :when (apply = r)]\n                   (first r))))))","user":"54b04708e4b09f271ff37d11"},{"code":"(fn tic-tac [board]\n  (letfn [(line? [key line]\n                 (= 3 (count (filter #(= key %) (map #((board (first %)) (second %)) line)))))\n          (who-win? [line]\n                    (cond \n                      (line? :x line) :x\n                      (line? :o line) :o\n                      :else nil))]\n         (let [lines [[[0 0] [0 1] [0 2]]\n                      [[1 0] [1 1] [1 2]]\n                      [[2 0] [2 1] [2 2]]\n                      [[0 0] [1 0] [2 0]]\n                      [[0 1] [1 1] [1 2]]\n                      [[0 2] [1 2] [2 2]]\n                      [[0 0] [1 1] [2 2]]\n                      [[2 0] [1 1] [0 2]]]]\n           (first (filter #(not (nil? %)) (map who-win? lines))))))","problem":73,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":73,"code":"(fn [brd]\n  (letfn [(row [n] (nth brd n))\n          (col [n] (map (fn [e] (nth e n)) brd))\n          (diag [f] (map-indexed (fn [idx e] (nth e (f idx))) brd))\n          (has-all [c lines] (some (fn [l] (every? (fn [c'] (= c c')) l)) lines))]\n    (let [lines  [(row 0) (row 1) (row 2) (col 0) (col 1) (col 2) (diag identity) (diag (fn [i] (- 2 i)))]\n          winner (into  {} [[(has-all :o lines) :o] [(has-all :x lines) :x]]) ]\n      (winner true))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [grid]\n        (let [lines (concat grid\n                            (partition 3 (apply interleave grid))\n                            (list (map #(nth % %2) grid [0 1 2]))\n                            (list (map #(nth % %2) grid [2 1 0])))]\n          (some (fn [sym]\n                  (when (some identity (map #(every? (partial = sym) %) lines)) sym)) [:x :o])))","problem":73,"user":"502873a8e4b01614d1633ff8"},{"problem":73,"code":"(fn [board]\n  (let [[[a1 a2 a3]\n         [b1 b2 b3]\n         [c1 c2 c3]] board\n        \n        win? (fn [& row]\n               (or (every? #(= % :o) row)\n    \t           (every? #(= % :x) row)))]\n    (cond \n      (win? a1 a2 a3) a1\n      (win? b1 b2 b3) b1\n      (win? c1 c2 c3) c1\n      (win? a1 b1 c1) a1\n      (win? a2 b2 c2) a2\n      (win? a3 b3 c3) a3\n      (win? a1 b2 c3) a1\n      (win? c1 b2 a3) c1\n      :else nil)))","user":"561aab66e4b053970a773b0a"},{"code":"(fn [b] (let [rot (fn [n] (into [] (map #(nth % n) b)))\n              diag (fn [r] (into [] (map nth b r)))\n              cb (conj b (rot 0) (rot 1) (rot 2) (diag (range 0 3)) (diag (reverse (range 0 3))))]\n          (some #{:x :o} (first (filter #(= 1 (count (distinct %))) cb)))))","problem":73,"user":"5150a7d7e4b03e678e393abb"},{"code":"(fn [board]\n  (let [matches [[[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]\n                 [[0 0] [0 1] [0 2]]\n                 [[1 0] [1 1] [1 2]]\n                 [[2 0] [2 1] [2 2]]\n                 [[0 0] [1 1] [2 2]]\n                 [[0 2] [1 1] [2 0]]]\n        get-at (fn [x y] (nth (nth board y) x))\n        rule-match (fn [pred coll]\n                      (every? #{pred} (map #(apply get-at %1) coll)))\n        item-matches (fn [item]\n                        (some #{true} (for [elem matches]\n                                       (rule-match item elem))))\n        tic-tac-score (fn [b]\n                         (cond\n                           (item-matches :x) :x\n                           (item-matches :o) :o\n                           :else nil))]\n   (tic-tac-score board)))","problem":73,"user":"4e6a2e83535d8ccf87e9fea7"},{"problem":73,"code":"(fn [board] (let [h (map set board)\n                  v (map set (map (fn [col] (map (fn [row] (nth row col)) board)) [0 1 2]))\n                  d1 (set (map #(get-in board %) [[0 0] [1 1] [2 2]]))\n                  d2 (set (map #(get-in board %) [[0 2] [1 1] [2 0]]))\n                  all (flatten [h v d1 d2])]\n                (ffirst (filter #(and (= (count %) 1) (.contains [:x :o] (first %))) all))))","user":"56018dd4e4b04bb52996e18f"},{"problem":73,"code":"(fn [board]\n  (letfn [(get-cols [brd]\n            (map (fn [idx]\n                   (map (fn [row] (nth row idx))\n                        brd))\n                 (range 3)))\n\n          (get-diag [brd]\n            (map (fn [idx]\n                   (let [row (nth brd idx)]\n                     (nth row idx)))\n                 (range 3)))\n\n          (get-reverse-diag [brd]\n            (map (fn [idx]\n                   (let [row (nth brd idx)]\n                     (nth row (- 2 idx))))\n                 (range 3)))\n\n          (row-winner [brd]\n            (cond (some true? (map (fn [row]\n                                     (every? #(= :x %) row))\n                                   brd))\n                  :x\n                  (some true? (map (fn [row]\n                                     (every? #(= :o %) row))\n                                   brd))\n                  :o\n                  :else nil))\n\n          (col-winner [brd]\n            (cond (some true? (map (fn [col]\n                                     (every? #(= :x %) col))\n                                   (get-cols brd)))\n                  :x\n                  (some true? (map (fn [col]\n                                     (every? #(= :o %) col))\n                                   (get-cols brd)))\n                  :o\n                  :else nil))\n\n          (diag-winner [brd]\n            (cond (true? (every? #(= :x %) (get-diag brd)))\n                  :x\n                  (true? (every? #(= :o %) (get-diag brd)))\n                  :o\n                  (true? (every? #(= :x %) (get-reverse-diag brd)))\n                  :x\n                  (true? (every? #(= :o %) (get-reverse-diag brd)))\n                  :o\n                  :else nil))]\n    (or (row-winner board) (col-winner board) (diag-winner board))))","user":"5498e155e4b0b312c081ff86"},{"problem":73,"code":"(fn __ [c]\n  (let [coll (flatten c)\n         f #(apply (fn [x y z] (if (or (= x y z :x) (= x y z :o)) x nil)) \n                        (map (vec coll) %))\n         win [[0 1 2] [3 4 5] [6 7 8] ; row\n                [0 3 6] [1 4 7] [2 5 8] ; collum\n                [0 4 8] [2 4 6]]           ; diagonal\n         ]\n  (some f win))\n)","user":"593f95d8e4b069cdc2982be3"},{"code":"(fn tic-tac [[[x0 y0 z0] [x1 y1 z1] [x2 y2 z2] :as all]]\n  (let [check (conj all\n        [x0 x1 x2]\n        [y0 y1 y2]\n        [z0 z1 z2]\n        [x0 y1 z2]\n        [z0 y1 x2])]\n  (cond (some #(every? (fn [v] (= :o v)) %) check) :o\n        (some #(every? (fn [v] (= :x v)) %) check) :x\n    :else nil)))","problem":73,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":73,"code":"(fn [board]\n \n (let [\n      get_row (fn [r] (board r))\n \n      get_col (fn [c] (vec (map #((board %) c) (range 3)) ))\n\n      get_diag (fn []\n        (list (vector ((board 0) 0) ((board 1) 1) ((board 2) 2) )\n          (vector ((board 2) 0) ((board 1) 1) ((board 0) 2) )\n      ))\n\n      win (fn [three]\n        (if (some #{:e} three ) nil\n          (if (apply = three) (three 0) nil\n        ) ))\n\n      final (fn [wins]\n        (if (nil? wins) nil\n          (first (remove nil? wins))))\n    ]\n\n\n   (final (map win (apply concat (conj ()  \n             (map get_row (range 3) ) \n             (map get_col (range 3) )\n             (get_diag )))))))","user":"5af4446de4b0cc2b61a3bc93"},{"code":"(fn [board]\n    (let [combinations (concat board\n                               (apply map list board)\n                               [(map #(% %2) board [0 1 2])]\n                               [(map #(% %2) board [2 1 0])])]\n      (or (some (fn [line]\n                  (cond\n                   (= line [:x :x :x])\n                   :x\n\n                   (= line [:o :o :o])\n                   :o))\n                combinations)\n          nil)))","problem":73,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":73,"code":"(fn tictactoe [board]\n  (let [all-paths\n        (concat board\n               \t(apply map vector board)\n                [\n                 [(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])]\n                 [(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])]])]\n    (cond\n     \t(some #(apply = :x %) all-paths) :x\n     \t(some #(apply = :o %) all-paths) :o\n     \t:else nil)))","user":"5e7f075ee4b085ba37836e36"},{"problem":73,"code":"(fn [rows]\n  (let [cols (for [i (range 3)]\n               (map #(nth % i) rows))\n        diags (let [[[a _ b]\n                     [_ c _]\n                     [d _ e]] rows] [[a c e] [b c d]])]\n    (ffirst (filter\n              #(and (apply = %) (not= :e (first %)))\n              (concat rows cols diags)))))","user":"4daddc19c9a9d6ed4599dc57"},{"code":"(fn [field]\n  (let [combos (concat field                                           ; rows\n                       (mapv (fn [col] (mapv #(% col) field)) [0 1 2]) ; cols\n                       (vector (mapv #((field %) %) [0 1 2]))          ; diag1\n                       (vector (mapv #((field (- 2 %)) %) [0 1 2])))]  ; diag2\n    (cond (some #(= % [:x :x :x]) combos) :x\n          (some #(= % [:o :o :o]) combos) :o\n          :else nil)))","problem":73,"user":"4e690ace535d8ccf87e9fe95"},{"code":"(fn [board]\n  (let [scores (->> [[4 9 2] [3 5 7] [8 1 6]]\n                    (map #(map vector %1 %2) board)\n                    (apply concat)\n                    (group-by first))\n        sum #(apply + (map second %))\n        scores' (into {} (for [[k v] scores] [(sum v) k]))]\n    (scores' 15)))","problem":73,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn mycheck [b]\r\n  (let [p (map (partial partition 2) [[0 0 0 1 0 2] [1 0 1 1 1 2] [2 0 2 1 2 2]\r\n           [0 0 1 0 2 0] [0 1 1 1 2 1] [0 2 1 2 2 2]\r\n           [0 0 1 1 2 2] [0 2 1 1 2 0] ])\r\n        checkpos (map (fn [p2] (map #(get (get b (first %)) (second %)) p2)) p)\r\n        allx (some (fn [coll] (apply (partial = :x) coll)) checkpos)\r\n        allo (some (fn [coll] (apply (partial = :o) coll)) checkpos)\r\n        ]\r\n  (if allx :x (if allo :o nil))))","problem":73,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn tictactoe [board]\n        (first (filter identity\n          (let [vert (apply map vector board)\n                diag-f (fn [b] (map #(nth %2 %) (range 3) b))\n                diag [(diag-f board) (diag-f (map reverse board))]\n            results (concat vert diag board)]\n            (map #(when (and (apply = %) (not (= :e (first %)))) (first %)) results)))))","problem":73,"user":"4e589bdc535d8a8b8723a295"},{"problem":73,"code":"(fn [board]\n    (let [v  #(vector %1 %2)\n          t3 #(range 0 3)\n          r  #(map v (repeat %) (t3))\n          c  #(map v (t3) (repeat %))\n          d1 (map v (t3) (t3))\n          d2 (map v (t3) (reverse (t3)))\n          tt [(r 0) (r 1) (r 2) (c 0) (c 1) (c 2) d1 d2]\n          lkp #(get-in board %)\n          tst #(reduce conj #{} (map lkp %))\n          w #(get {#{:x} :x #{:o} :o} % false )]\n      (some w \n            (map tst tt))))","user":"554a75c9e4b0a04f79299575"},{"problem":73,"code":"(fn analyze-board [board]\n  (let [n (count (board 1))\n        rows (map (fn [row] row) board)\n        cols (apply map list board)\n        diags [(map #(get-in board [% %]) (range n))\n               (map #(get-in board [% (- (dec n) %)]) (range n))]\n        variants (filter #(and (not (= [:e] %)) (= 1 (count % ))) (map distinct (concat rows cols diags)))]\n    (ffirst variants)))","user":"5be33a16e4b0ed4b8aab4cd6"},{"problem":73,"code":"(fn [matrix]\n  (loop [[k & ks] (flatten matrix) [v & vs] '(8 1 6 3 5 7 4 9 2) r {:x 0 :o 0 :e 0}]\n      (if k\n        (recur ks vs (merge-with + r {k v}))\n        (cond\n         (= 15 (:x r)) :x\n         (= 15 (:o r)) :o\n         :else nil))))","user":"56ae214ce4b03c432f18735a"},{"problem":73,"code":"(fn tic-tac-winner [board]\n  (let [size (count board)\n        accum-score (fn [scores coord] ;accumulates a score, returns scores map\n                      (assoc scores coord (inc (get scores coord 0))))\n        accum-diag (fn [scores coord row col]\n                     (if (= row col) (accum-score scores coord) scores))\n        accum-anti-diag (fn [scores coord row col]\n                          (if (= (+ row col) (dec size))(accum-score scores coord) scores))]\n     (some (fn [[[player] score]] (if (= score 3) player false))\n           (loop [row 0 col 0 scores {}]\n             (if (= row size) scores\n                (let [player (-> board (nth row) (nth col))\n                      scores (if (#{:x :o} player)\n                               (-> scores ;accumulate the scores if it's a player\n                                   (accum-score [player :r row]) \n                                   (accum-score [player :c col])\n                                   (accum-diag [player :d] row col)\n                                   (accum-anti-diag [player :ad] row col)) \n                               scores) \n                      nextcol (if (= (inc col) size) 0 (inc col))\n                      nextrow (if (= nextcol 0) (inc row) row)]\n                 (recur nextrow nextcol scores)))))))","user":"556405e5e4b0c656e3ff17fb"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]\n      :as m]]\n  (->>\n    (conj m [a d g] [b e h] [c f i] [a e i] [c e g])\n    (filter #(apply = %))\n    (remove #(some #{:e} %))\n    ffirst))","problem":73,"user":"4f410b63e4b0e243712b1fc5"},{"problem":73,"code":"(fn [board]\n          (letfn [(win? [p board]\n                    (or (->> (map (fn [row] (every? #(= p %) row))\n                                  board)\n                             (some true?))\n                        (->> (apply map (cons #(= p %1 %2 %3) board))\n                             (some true?))\n                        (->> (map #(= p (get %1 %2))\n                                  board (range 3))\n                             (every? true?))\n                        (->> (map #(= p (get %1 %2))\n                                  board (reverse (range 3)))\n                             (every? true?))))]\n            (cond\n              (win? :o board) :o\n              (win? :x board) :x)))","user":"5c995fa4e4b048ec896c5a96"},{"problem":73,"code":"(fn board-winner [board]\n  (let [ways-to-win\n    (fn ways-to-win [board]\n      (concat\n       board\n       (map (fn take-column [n] (map #(nth % n) board)) (range 3))\n       [ [((board 0) 0) ((board 1) 1) ((board 2) 2)]\n         [((board 0) 2) ((board 1) 1) ((board 2) 0)] ]))\n        all-same? (fn all-same? [coll] (= 1 (count (into #{} coll))))\n        is-player? #(or (= :x %) (= :o %))\n        ways (filter all-same? (ways-to-win board))\n        wins (filter #(is-player? (first %)) ways)]\n    (if (not (empty? wins)) (first (first wins)) nil)))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":73,"code":"(fn ttt\n  [rows]\n  (let [three-in-a-line (fn [player line] (every? #(= player %) line))\n        cols (partition 3 (apply interleave rows))\n        diag1 [(first (first rows)) (second (second rows)) (nth (nth rows 2) 2)]\n        diag2 [(nth (first rows) 2) (second (second rows)) (first (nth rows 2))]]\n    (cond (or (some true? (map (partial three-in-a-line :x) rows))\n              (some true? (map (partial three-in-a-line :x) cols))\n              (three-in-a-line :x diag1) (three-in-a-line :x diag2)) :x\n          (or (some true? (map (partial three-in-a-line :o) rows))\n              (some true? (map (partial three-in-a-line :o) cols))\n              (three-in-a-line :o diag1) (three-in-a-line :o diag2)) :o)))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":73,"code":"(fn winner [board]\n  (let [rows (fn [board] board)\n        columns (fn [board] (apply mapv vector board))\n        diagonals (fn [[[a _ b]\n                       [_ c _]\n                       [d _ e]]]\n                    [[a c e] [b c d]])]\n    (->> (filter (partial apply =) (concat (rows board) (columns board) (diagonals board)))\n         (map first)\n         (filter (partial not= :e))\n         first)))","user":"6042219ae4b04b4f332c3e72"},{"code":"(fn [board]\n  (let [positions #{#{[0 0] [0 1] [0 2]} #{[1 0] [1 1] [1 2]} #{[2 0] [2 1] [2 2]}\n                    #{[0 0] [1 0] [2 0]} #{[0 1] [1 1] [2 1]} #{[0 2] [1 2] [2 2]}\n                    #{[0 0] [1 1] [2 2]} #{[2 0] [1 1] [0 2]}}]\n    (first (for [piece [:x :o] pos positions\n          :when (= [piece piece piece] (map #(get-in board %) pos))]\n      piece))))","problem":73,"user":"4ea365e2535d7eef308072c5"},{"problem":73,"code":"(fn [board]\n   (letfn [(rows-from-board [board]\n             (concat\n              board\n              (apply map vector board)\n              [(map #(nth (second %) (first %)) (zipmap (range) board ))]\n              [(map #(nth (second %) (first %)) (zipmap (range) (reverse board) ))]))\n           (check-row [row]\n             (reduce #(if (= %1 %2) %2 :e) (first row) (rest row)))]\n     (->> board\n          rows-from-board\n          (map check-row)\n          (reduce #(if (or (= :x %2) (= :o %2)) %2 %1) nil))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":73,"code":"(fn p-73 [board]\n  (let [b (vec (reduce concat board))\n        matches [[0 1 2] [3 4 5] [6 7 8]\n                 [0 3 6] [1 4 7] [2 5 8]\n                 [0 4 8] [2 4 6]]\n        has-match (fn [vl] (some identity (map (fn [row] (apply = vl (map #(nth b %) row)))  matches)))]\n        (cond\n          (has-match :x) :x\n          (has-match :o) :o\n          :else nil)))","user":"5bfc9037e4b0bdcf453d15f2"},{"problem":73,"code":"(fn [tic] (let [lines (conj (concat tic (apply map vector tic))\n                             [(nth (nth tic 0)0)(nth (nth tic 1)1)(nth (nth tic 2)2)]\n                             [(nth (nth tic 0)2)(nth (nth tic 1)1)(nth (nth tic 2)0)])]\n             (cond \n              (some #(= [:o :o :o] %) lines) :o\n              (some #(= [:x :x :x] %) lines) :x\n              :else nil)\n             ))","user":"5471f2fbe4b094393f72dd70"},{"problem":73,"code":"(fn winttt [m]\n  (let [winner (ffirst (filter (fn [v] (= (v 0) (v 1) (v 2)))\n     (let [all (conj (concat m (apply mapv vector m))\n        [((m 0) 0) ((m 1) 1) ((m 2) 2)] [((m 2) 0) ((m 1) 1) ((m 0) 2)])]\n        all)))]\n    (if (= :e winner) nil winner)))","user":"579d9601e4b05b1deef9ae18"},{"problem":73,"code":"(fn ttt-winner [board]\n  (let [flat-board (apply concat board)\n        array-of-coords [[0 1 2]\n                         [2 5 8]\n                         [8 7 6]\n                         [6 3 0]\n                         [1 4 7]\n                         [3 4 5]\n                         [2 4 6]\n                         [0 4 8]]]\n    (->> (map\n           (fn [coords]\n             (keep-indexed\n               #(if (some #{%1} coords) %2)\n               flat-board))\n           array-of-coords)\n         (reduce\n           (fn [res elm]\n             (cond\n               res\n               res\n               (= elm [:x :x :x])\n               :x\n               (= elm [:o :o :o])\n               :o\n               :always\n               nil))\n           nil))))","user":"5984e7dee4b021a7a535fe43"},{"problem":73,"code":"(fn [board]\n    (first\n     (some #{[:x :x :x] [:o :o :o]}\n           (concat board\n                   (apply map vector board)\n                   (map\n                    #(for [i (range 3)] (nth (nth % i) i))\n                    [board (reverse board)])))))","user":"4e6a4950535d8ccf87e9febf"},{"problem":73,"code":"(fn [x] (letfn [(win [p] (or\n                          (some true? (map #(apply = p %) x))\n                          (some true? (apply map #(= p %1 %2 %3) x))\n                          (= p (get-in x [0 0]) (get-in x [1 1]) (get-in x [2 2]))\n                          (= p (get-in x [0 2]) (get-in x [1 1]) (get-in x [2 0]))\n                          ))]\n          (cond\n           (win :x) :x\n           (win :o) :o\n           :default nil)))","user":"57dafe97e4b0bd073c20241c"},{"code":"(fn myAnalizeTTT\n  [ttt]\n  (let [getCrossElementIds (fn [tictactoe] (map vector (take (count tictactoe) (range)) tictactoe))\n        getCrossElements (fn [result tttCrosCount] (conj result (nth (second tttCrosCount) (first tttCrosCount))))\n        tttv (map set ttt)\n        ttth (map set (apply map list ttt))\n        ttts1 (set (reduce getCrossElements [] (getCrossElementIds ttt)))\n        ttts2 (set (reduce getCrossElements [] (getCrossElementIds (reverse ttt))))]\n    (first (flatten (filter #(and (= 1 (count %)) (not (= % [:e]))) (map vec (flatten (list tttv ttth ttts1 ttts2))))))))","problem":73,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [b] \n           (some identity\n                 (for [p [:x :o]] \n                      (cond\n                       (some (fn [x] (every? #(= p %) x)) b) p\n                       (some identity (for [c [0 1 2]] (every? #(= p %) (map (fn [m] (nth m c)) b)))) p\n                       (some (partial every? #(= % p)) (for [d [[2 1 0] [0 1 2]]]\n                                                            (map #(nth %1 %2) b d))) p\n                       :default nil))))","problem":73,"user":"4f614976e4b0defedf855fbb"},{"code":"(fn [x] (let [fi (first x), se (second x), th (nth x 2) ]\n  (if (= (first fi) (second fi) (nth fi 2))\n    (if (= :e (first fi))\n      nil\n    (first fi))\n  (if (= (first se) (second se) (nth se 2))\n    (first se)\n  (if (= (first th) (second th) (nth th 2))\n    (first th)\n  (if (= (first fi) (first se) (first th))\n    (first fi)\n  (if (= (second fi) (second se) (second th))\n    (second fi)\n  (if (= (nth fi 2) (nth se 2) (nth th 2))\n    (nth fi 2)\n  (if (= (first fi) (second se) (nth th 2))\n    (first fi)\n  (if (= (nth fi 2) (second se) (first th))\n    (first th)\n    nil))))))))))","problem":73,"user":"4eb0afed535d7eef3080733e"},{"code":"(fn [[r1 r2 r3]]\n  (let [idx (fn [[a b c]] [(r1 a) (r2 b) (r3 c)])\n        lines (concat [r1 r2 r3] (map idx '((0 0 0) (1 1 1) (2 2 2) (0 1 2) (2 1 0))))]\n    (cond\n     (some #(every? #{:o} %) lines) :o\n     (some #(every? #{:x} %) lines) :x\n     :else nil)))","problem":73,"user":"532347dde4b09d4e7a9b54cc"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i]]]\n  (let [\n        r1 (set [a b c])\n        r2 (set [d e f])\n        r3 (set [g h i])\n        c1 (set [a d g])\n        c2 (set [b e h])\n        c3 (set [c f i])\n        d1 (set [a e i])\n        d2 (set [c e g])\n        all [r1 r2 r3 c1 c2 c3 d1 d2]]\n    (reduce (fn [x y]\n              (let [z (first y)]\n                (cond\n                 (not= nil x) x\n                 (> (count y) 1) x\n                 (not= :e z) z))) nil all)))","user":"59075e3be4b047aa04b19955"},{"problem":73,"code":"(fn tic-tac-toe [m]\n  (let [t1 \n        (loop [i 0] ;;;Checa as linhas\n          (if (= ((m i) 0) ((m i) 1) ((m i) 2))\n            ((m i) 0)\n            (if (< i 2) (recur (inc i)))))\n        t2 \n        (loop [j 0] ;;;Checa as colunas\n          (if (= ((m 0) j) ((m 1) j) ((m 2) j))\n            ((m 0) j)\n            (if (< j 2) (recur (inc j)))))\n        t3 \n        (if (= ((m 0) 0) ((m 1) 1) ((m 2) 2)) ;;Checa diag prin\n          ((m 0) 0))\n        t4\n        (if (= ((m 0) 2) ((m 1) 1) ((m 2) 0)) ;;Checa diag sec\n          ((m 2) 0))]\n    (if (and (not= t1 :e) (not= t1 nil)) t1\n        (if (and (not= t2 :e) (not= t2 nil)) t2\n            (if (and (not= t3 :e) (not= t3 nil)) t3\n                (if (and (not= t4 :e) (not= t4 nil)) t4))))))","user":"574f1c24e4b02ea114799255"},{"problem":73,"code":"(fn check [game]\n  (let [g  (flatten game)\n        h1 (set (keep-indexed #(when (some #{%1} [0 1 2]) %2) g))\n        h2 (set (keep-indexed #(when (some #{%1} [3 4 5]) %2) g))\n        h3 (set (keep-indexed #(when (some #{%1} [6 7 8]) %2) g))\n        v1 (set (keep-indexed #(when (some #{%1} [0 3 6]) %2) g))\n        v2 (set (keep-indexed #(when (some #{%1} [1 4 7]) %2) g))\n        v3 (set (keep-indexed #(when (some #{%1} [2 5 8]) %2) g))\n        d1 (set (keep-indexed #(when (some #{%1} [0 4 8]) %2) g))\n        d2 (set (keep-indexed #(when (some #{%1} [2 4 6]) %2) g))]\n\n    (cond\n      (or (= #{:x} h1) (= #{:o} h1)) (first h1)\n      (or (= #{:x} h2) (= #{:o} h2)) (first h2)\n      (or (= #{:x} h3) (= #{:o} h3)) (first h3)\n      (or (= #{:x} v1) (= #{:o} v1)) (first v1)\n      (or (= #{:x} v2) (= #{:o} v2)) (first v2)\n      (or (= #{:x} v3) (= #{:o} v3)) (first v3)\n      (or (= #{:x} d1) (= #{:o} d1)) (first d1)\n      (or (= #{:x} d2) (= #{:o} d2)) (first d2))))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn [brd]\n  (let [diag #(mapcat (fn [r c] [(nth r c)]) % (range))\n        data (concat brd (apply map vector brd) [(diag brd) (diag (reverse brd))])\n        won? (fn [p] (some #(apply = (conj % p)) data))]\n    (cond\n      (won? :x) :x \n      (won? :o) :o\n      :else nil)))","problem":73,"user":"528652fbe4b0239c8a67ae14"},{"problem":73,"code":"(fn winner [board]\n  (some (fn [row] (some\n                    (fn [player]\n                      (if (every? #(= % player) row)\n                        player))\n                    [:x :o]))\n        (concat board\n                (apply map vector board)\n                (map \n                  (fn [b] (map-indexed #(nth %2 %1) b)) \n                  [board (reverse board)]))))","user":"54d5343fe4b0a52adc2e200a"},{"code":"(fn [table]\n  (let [winner? (fn [player row] (every? #(= player %) row))\n        rows (partition 3 \n              (flatten \n                (apply conj [] (apply map vector table) \n                                table\n                                (for [x (range 3)] (get-in table [x x])) \n                                (for [x (range 3)] (get-in table [(- 2 x) x])))))]\n    (cond \n      (seq (filter (partial winner? :x) rows)) :x\n      (seq (filter (partial winner? :o) rows)) :o\n      :else nil)))","problem":73,"user":"4e9c3648535dbda64a6f6b7d"},{"code":"(fn [board]\n  (some \n    #(and (apply = %) (#{:x :o} (first %)))\n    (concat\n      board\n      (apply map #(list % %2 %3) board)\n      (for [d [(apply concat board) (apply concat (map reverse board))]]\n        (apply mapcat #(list % %2 %3) (partition-all 4 d))))))","problem":73,"user":"4fa5406fe4b081705acca1ac"},{"code":"#(first \n  (first \n    (filter #{[:x :x :x] [:o :o :o]}\n      (concat %                                        \n        (for [n (range 3)] (map (fn [c] (c n))  %))                                                          \n        (for [c [% (reverse %)]]                                                                          \n          (for [n (range 3)] (nth (nth c n) n)))))))","problem":73,"user":"4eb51942535d7eef30807365"},{"problem":73,"code":"(fn [xs]\n  (let [game (vec (flatten xs))]\n    (first (some #{#{:x} #{:o}}\n                 (map #(set (map game %))\n                      [[0 1 2] [3 4 5] [6 7 8] [0 3 6]\n                       [1 4 7] [2 5 8] [0 4 8] [2 4 6]])))))","user":"554b8572e4b0a04f79299589"},{"problem":73,"code":"(fn [board]\n    (letfn [(check-row [row]\n                       (when (and (not= (first row) :e) (apply = row))\n                         (first row)))\n            (rotate [board]\n                    (apply map vector board))\n            (diagonals [board]\n                       (let [lx (count (first board)) ly (count board)]\n                         [\n                          ; diagonal values from [0 0] to [lx ly]\n                          (map (partial get-in board) (map vector (range 0 lx) (range 0 ly)))\n                          ; diagonal values from [0 ly] to [lx 0]\n                          (map (partial get-in board) (map vector (range 0 lx) (range (dec ly) -1 -1)))]))]\n      (some\n        identity\n        [\n         (some check-row board)\n         (some check-row (rotate board))\n         (some check-row (diagonals board))]))\n    )","user":"54ca130ce4b057c6fda3a250"},{"problem":73,"code":"(fn f [xo]\n  (let [d #(for [i (range 0 3)] (get-in (vec %) [i i]))\n        ox (apply mapv vector xo)]\n    (->> (concat xo ox [(d xo) (d (reverse xo))])\n         (map set)\n         (some #{#{:x} #{:o}})\n         (first))))","user":"56795deae4b05957ce8c6187"},{"problem":73,"code":"(fn [[[r1-1 _ r1-3] [_ r2-2 _] [r3-1 _ r3-3] :as board]]\n  (let [rows   (map set board)\n        cols   (map set [(map first board)\n                         (map second board)\n                         (map last board)])\n        diags  [(set [r1-1 r2-2 r3-3])\n                (set [r3-1 r2-2 r1-3])]\n        [result] (filter #(and (= 1 (count %))\n                                  (or (% :x) (% :o)))\n                           (concat rows cols diags))]\n    (first result)))","user":"571a0a0ae4b07c98581c3b44"},{"problem":73,"code":"(fn [board]\n    (letfn [(w [[f s t]] (when (and (or (= f :x) (= f :o)) (= f s t)) f))]\n      (first\n       (remove nil?\n                (concat (map w board)\n                        (map w (map #(map (fn [r] (get r %)) board) (range 3)))\n                        [(w [(ffirst board) (second (second board)) (last (last board))])]\n                        [(w [(last (first board)) (second (second board)) (first (last board))])]\n                 )\n          ))\n      )\n\n    )","user":"5ab1665de4b073f1774425c0"},{"problem":73,"code":"(fn [coll]\n\t(let [a (flatten (partition 1 4 (flatten coll)))\n\t\t  r (flatten (partition 1 4 (flatten (map #(reverse %) coll))))\n\t\t  b (into (into (into coll (apply map vector coll)) [a]) [r])]\n\t (some {[:x :x :x] :x [:o :o :o] :o} b)))","user":"562d869be4b0a45d2ff8301f"},{"problem":73,"code":"(fn [[[a0 a1 a2] [b0 b1 b2] [c0 c1 c2] :as rows]]\n  (->> (apply map #(apply vector %&) rows)\n       (concat (list [a0 b1 c2] [a2 b1 c0]) rows)\n       (some {[:x :x :x] :x [:o :o :o] :o})))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn [a]\n  (first (some #{[:o :o :o] [:x :x :x]}\n            (concat a (apply map list a)\n                 (map\n                   #(map (fn [v i] (v i)) a %)\n                   [[0 1 2] [2 1 0]])))))","problem":73,"user":"509160dae4b0742c82730aef"},{"problem":73,"code":"(fn [a] (let [w [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]] f (vec (flatten a)) p (first (filter (fn [ea] (and (apply = (map f ea)) (not= :e (f (ea 0))))) w))] (if p (f (p 0)))))","user":"5abe2fc2e4b073f17744271e"},{"problem":73,"code":"(fn has-won? [board]\n  (let [rows (map #(get board %) (range 3))\n   cols (map (fn [x] (apply vector (map #(get (get board %) x) (range 3)))) (range 3))\n   diagl (map #(get (get board %) %) (range 3))\n   diagr (map #(get (get board (- 2 %)) %) (range 3))\n   lines (concat rows cols [diagl diagr])] \n  (some #{:x :o} (map \n    (fn [x]\n      (cond \n        (every? #(= :x %) x) :x \n        (every? #(= :o %) x) :o))\n    lines))))","user":"5933b736e4b072a2710fd05d"},{"problem":73,"code":"(fn [g]\n    (letfn [(decide [v]\n              (let [fs (frequencies v)]\n                (cond\n                  (= (:o fs) 3) :o\n                  (= (:x fs) 3) :x\n                  :else nil)))\n            (cols [game]\n              (loop [j 0, res []]\n                (if (< j (count game))\n                  (recur (inc j) (conj res (map #(nth % j) game)))\n                  res)))]\n      (loop [s (concat g (cols g))]\n        (if (seq s)\n          (or (decide (first s))\n              (recur (rest s)))\n          (let [[d1 d2 d3] [((g 0) 0) ((g 1) 1) ((g 2) 2)]\n                [d1' d2' d3'] [((g 0) 2) ((g 1) 1) ((g 2) 0)]] \n          (cond \n            (= d1 d2 d3 :o) :o\n            (= d1 d2 d3 :x) :x\n            (= d1' d2' d3' :o) :o\n            (= d1' d2' d3' :x) :x\n            :else nil))))))","user":"54ca93abe4b057c6fda3a264"},{"problem":73,"code":"(fn tic-tac-winner\n  [board]\n  (let [rows (concat board\n                     (for [i (range 3)]\n                       (map #(get % i) board))\n                     [(for [i (range 3)]\n                         ((board i) i))]\n                     [(for [i (range 3)]\n                        ((board i) (- 2 i)))])\n        winners (->> rows\n                     (filter (partial apply =))\n                     (map first)\n                     (remove (partial = :e)))]\n    (first winners)))","user":"4dbb0f2d535d1e037afb21b1"},{"problem":73,"code":"(fn who-wins2 [board]\n  (letfn [(is-horizontal [row]\n            (if (and (apply = row) (not (= (first row) :e)))\n              (first row) nil))\n          (get-horizontal [board]\n            (some identity (map is-horizontal board)))\n          (get-vertical [board]\n            (let [transposed (apply map (concat [vector] board))]\n              (get-horizontal transposed)))\n          (get-diagonal [board]\n            (let [with-indices (map vector board (range))]\n              (or\n               (is-horizontal (map (fn [[row n]] (nth row n)) with-indices))\n               (is-horizontal (map (fn [[row n]] (nth row (- (count row) n 1)))\n                                   with-indices\n                                   )))))]\n  (or (get-horizontal board)\n      (get-vertical board)\n      (get-diagonal board))))","user":"57ca95f2e4b05aa3c4741d3b"},{"problem":73,"code":"#(->> %\n      (concat (map (fn [d] (map get % d)) [[0 1 2] [2 1 0] [0 0 0] [1 1 1] [2 2 2]]))\n      (some {[:x :x :x] :x [:o :o :o] :o}))","user":"548b8a50e4b0e286459a11ff"},{"problem":73,"code":"(fn [board] (some #{:x :o} (map #(reduce (fn [a b] (if (= a b) a)) %) (concat board (apply map vector board) (partition 3 (map nth (concat board (map reverse board)) (cycle [0 1 2])))))))","user":"5519c157e4b00ace28fe6e32"},{"problem":73,"code":"(fn [g] \n  (let [[r1 r2 r3] g\n        cols (apply map vector g)\n        d1 [(first r1) (second r2) (last r3)]\n        d2 [(last r1) (second r2) (first r3)]\n        patterns (concat g cols [d1 d2])]\n    (cond \n     (some #(= '(:x :x :x) %) patterns) :x \n     (some #(= '(:o :o :o) %) patterns) :o\n     :else nil)))","user":"545e7ab0e4b01be26fd7467c"},{"problem":73,"code":"(fn winner [board]\n  (let [interpose-matrix \n        #(for [i (range (count (first %)))]\n            (for [row %] (nth row i))\n        )\n        rows board\n        cols (interpose-matrix board)\n        d1 [(nth (nth board 0) 0)\n            (nth (nth board 1) 1)\n            (nth (nth board 2) 2)]\n        d2 [(nth (nth board 0) 2)\n            (nth (nth board 1) 1)\n            (nth (nth board 2) 0)]\n        lines (concat rows cols [d1] [d2])\n       ]\n    (cond\n      (some (partial = [:o :o :o]) lines) :o\n      (some (partial = [:x :x :x]) lines) :x\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":73,"code":"(fn[b]\n  (let [checks [[0 0 inc nil]\n                [0 0 inc inc]\n                [0 0 nil inc]\n                [1 0 nil inc]\n                [2 0 dec inc]\n                [2 0 nil inc]\n                [0 1 inc nil]\n                [0 2 inc nil]]\n        didwin (fn [cx cy fx fy r]\n                 (if (and (<= cx 2) (>= cx 0) (<= cy 2) (>= cy 0))\n                   (recur (if (not= nil fx) (fx cx) cx)\n                          (if (not= nil fy) (fy cy) cy)\n                          fx fy\n                          (cons ((b cy) cx) r))\n                   r))\n        res (map #(didwin (% 0) (% 1) (% 2) (% 3) '()) checks)\n        res2 (reduce (fn [x v]\n                       (conj x (if (and (apply = v) (not= (first v) :e))\n                                 (first v)\n                                 nil))) '() res)]\n    (if (some #(= :x %) res2) :x\n        (if (some #(= :o %) res2) :o nil))))","user":"53d5a63be4b0e771c3025449"},{"problem":73,"code":"(fn [table]\n  (let [won (filter\n             (fn [sym]\n              (let [rows\n                     (map\n                      (fn [row]\n                        (map\n                          (fn [cell]\n                            (if (= cell sym)\n                              1\n                              0))\n                          row))\n                      table)\n                   cols\n                    (map\n                      (fn [col-num]\n                        (map\n                          (fn [row]\n                            (nth row col-num))\n                          rows))\n                      (range (count (first rows))))\n                   fsum (fn [x]\n                          (apply + x))\n                   fsum-table (fn [table]\n                               (map fsum table))\n                   sum-rows (fsum-table rows)\n                   sum-cols (fsum-table cols)\n                   fget-diag (fn [table]\n                               (map\n                                 (fn [x i]\n                                    (nth x i))\n                                  table\n                                  (range (count table))))\n                   diag (fget-diag rows)\n                   rdiag (fget-diag (map reverse rows))\n                   sum-diag (fsum diag)\n                   sum-rdiag (fsum rdiag)\n                   equal3 (partial = 3)\n                   any-equal3 (fn [x]\n                                (some equal3 x))\n                   won  (some\n                          identity\n                          (map\n                            any-equal3\n                            [sum-rows sum-cols [sum-diag] [sum-rdiag]]))]\n                  won))\n              [:x :o])]\n  (if (empty? won)\n      nil\n      (first won))))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":73,"code":"(fn [b]\n  (letfn [(w [[f :as x]]\n             (if (and (apply = x)\n                      (not= f :e))\n               f))]\n    (or (w (first b))\n        (w (second b))\n        (w (last b))\n        (w (map first b))\n        (w (map second b))\n        (w (map last b))\n        (w (map #(nth % %2) b (range)))\n        (w (map #(nth % (- 2 %2)) b (range))))))","user":"50ed4626e4b01236b1d4983c"},{"problem":73,"code":"(fn [rows]\n  (let [columns (apply map list rows)\n        diagonals (map #(map nth % (range)) [rows (rseq rows)])]\n    (->> (concat rows columns diagonals)\n         (some #(when (apply = %) (#{:o :x} (first %)))))))","user":"5f82609ae4b0c071e6c840f9"},{"problem":73,"code":"(fn [board]\n  (some (fn [posns]\n          (case (map (partial get-in board) posns)\n            [:x :x :x] :x\n            [:o :o :o] :o\n            nil))\n        (concat (for [x (range 3)]\n                  (for [y (range 3)]\n                    [x y]))\n                (for [y (range 3)]\n                  (for [x (range 3)]\n                    [x y]))\n                [(for [x (range 3)]\n                   [x x])]\n                [(for [x (range 3)]\n                   [x (- 2 x)])])))","user":"53c74cfce4b00fb29b2212a7"},{"problem":73,"code":"(fn tic-tac-toe [x]\n  (letfn [(transpose [m]\n                     (apply mapv vector m))\n          (get-winner-3 [row]\n                        (let [t (distinct row)]\n                          (if (= 1 (count t))\n                            (first t)))\n                        )\n          (get-winner-3-ignore [row]\n                               (let [w (get-winner-3 row)]\n                                 (if (= :e w)\n                                   nil\n                                   w)))\n          (get-diag [m]\n                    (for [i (range (count m))]    \n                      ((m i) i)\n                      ))\n          (get-diag2 [m]\n                     (for [i (range (count m))]    \n                       ((m i) (- (count m) i 1))\n                       ))\n          (get-all-subsets [g]\n                           (conj (into g\n                                       (transpose g))\n                                 (get-diag g)   \n                                 (get-diag2 g)))\n          ]\n    (first (filter #(not (nil? %)) (map get-winner-3-ignore (get-all-subsets x))))))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn [board]\n  (first (filter identity\n           (for [i [:x :o]]\n             (let [result\n                   (->> i\n                     ((juxt\n                        (fn [x] (->> board (map #(every? (partial = x) %)) (filter identity))) ; Check rows\n                       (fn [x] (->> board (apply map vector) (map #(every? (partial = x ) %)) (filter identity))) ; Check columns\n                       (fn [x] (every? (partial = x) (for [row (range 0 3)] (-> board (nth row) (nth (- 2 row)))))) ; Upper right to lower left diagonal\n                       (fn [x] (every? (partial = x) (for [col (range 0 3)] (-> board (nth col) (nth col))))))) ; Upper left to lower right diagonal\n                     (flatten)\n                     (filter identity)\n                     (count))]\n               (if (> result 0) i))))))","problem":73,"user":"522404d8e4b01819a2de42c0"},{"code":"(fn tic-win [board]\n    (let [trans (fn [] \n                  (let [diags [\n                               [[0 0] [1 1] [2 2]]\n                               [[0 2] [1 1] [2 0]]\n                               ]\n                        cols (map #(map (fn [y] [y %]) (range 0 3)) (range 0 3))\n                        take-coords (fn [coords-seq]\n                                      (map #(get-in board %) coords-seq))]\n                    \n                    (concat board (map take-coords (concat cols diags))))) \n          \n          st (map set (trans))\n          won? (fn [x] (some #{#{x}} st))]\n      (cond (won? :x) :x\n            (won? :o) :o\n            :else nil)))","problem":73,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":73,"code":"(fn [board]\n  (let [winning-sets '( [[0 0] [0 1] [0 2]]\n                        [[1 0] [1 1] [1 2]]\n                        [[2 0] [2 1] [2 2]]\n                        [[0 0] [1 0] [2 0]]\n                        [[0 1] [1 1] [2 1]]\n                        [[0 2] [1 2] [2 2]]\n                        [[0 0] [1 1] [2 2]]\n                        [[0 2] [1 1] [2 0]] )\n        \n        get-piece (fn [b [r c]] \n                    (-> b (get r) (get c)))\n        \n        extract (fn [b & args] \n                  (map (partial get-piece b) args))\n        \n        sets (map #(apply extract board %) winning-sets)\n        \n        check (fn [set]\n                (let [freq (frequencies set)]\n                  (cond (= 3 (freq :x)) :x\n                        (= 3 (freq :o)) :o)))]  \n    (some check sets)))","user":"571e6d73e4b0145328a76292"},{"code":"(fn [s]\n  (#{:x :o}\n    (ffirst\n      (filter\n        #(= (count (distinct %)) 1)\n        (concat s\n          (map #(map nth s %)\n            (conj (map #(repeat 3 %) (range 3))\n              (range 3) (reverse (range 3)))))))))","problem":73,"user":"4f06dcad535dcb61093f6c16"},{"problem":73,"code":"(fn [rows]\n  (let [columns (apply map list  rows)\n        nw->se  (list (map #(get-in rows [% %])  (range 3)))\n        ne->sw  (list (map #(get-in rows [% (- 2 %)])  (range 3))) \n        all     (concat rows columns nw->se ne->sw)]\n    (ffirst (filter (fn [[a b c]] (and (not= a :e) (= a b c))) all))))","user":"52f0ea04e4b05e3f0be25ee6"},{"code":"(fn\n    [board]\n    (let [winner-tupple? (fn [key a b c] (= a b c key))\n          winner? (fn [player board]\n                    (let [[[c11 c12 c13]\n                           [c21 c22 c23]\n                           [c31 c32 c33]] board]\n                      (or\n                       (winner-tupple? player c11 c12 c13)\n                       (winner-tupple? player c21 c22 c23)\n                       (winner-tupple? player c31 c32 c33)\n                       (winner-tupple? player c11 c22 c33)\n                       (winner-tupple? player c31 c22 c13)\n                       (winner-tupple? player c11 c21 c31)\n                       (winner-tupple? player c12 c22 c32)\n                       (winner-tupple? player c13 c23 c33)\n                       )))]\n      (cond\n       (winner? :x board) :x\n       (winner? :o board) :o\n       :else nil)))","problem":73,"user":"52a7634ae4b0c58976d9ac16"},{"problem":73,"code":"(fn [v]\n        (letfn [(gd [rr] (map #(apply get %) (partition 2 (interleave v rr))))]\n          (let [r (range 0 3)\n                x (concat v\n                          (partition 3 (apply interleave v))\n                          (vector (gd r) (gd (reverse r))))]\n            (->> x\n                 (map set)\n                 (filter #(and (= 1 (count %)) (not= :e (first %))))\n                 (first)\n                 (#(if (nil? %) nil (first %)))))))","user":"544e6b7fe4b0e39780006986"},{"problem":73,"code":"(fn [board]\n  (let [rows board\n        cols (map (fn [i] (map #(get % i) board)) (range 3))\n        d0 (for [i (range 3)] (get (get board i) i))\n        d1 (for [i (range 3)] (get (get board i) (- 2 i)))\n        win (fn [v] (and (= 1 (count (set v))) (first v)))]\n    (first (filter #(and (not= :e %) %) (map win (concat rows cols [d0 d1]))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn[[[xl _ xr] [_ y _] [zl _ zr] :as xs]]\n  (ffirst \n   (filter #(and (= 1 (count %)) (not= [:e] %))\n     (map distinct \n       (concat [[xl y zr] [xr y zl]]\n               xs \n               (apply map vector xs))))))","problem":73,"user":"506406c8e4b075d771da6f9f"},{"code":"(fn [b]\n  (first (some #{[:x :x :x] [:o :o :o]}\n               (concat b (apply map list b)\n                  (map #(map (fn [a i] (a i)) b %) [[0 1 2] [2 1 0]])))))","problem":73,"user":"4effb663535dcb61093f6a2e"},{"problem":73,"code":"(fn [board]\n    (->> (for [r (range 3)]\n           [(set (for [c (range 3)] (get-in board [r c]) )) ;; rows\n            (set (for [c (range 3)] (get-in board [c r]) )) ;; colums\n            ]\n           )\n         (cons (set (for [r (range 3)] (get-in board [r r]))))\n         (cons (set (for [r (range 3)] (get-in board [r (- 2 r)]))))\n         flatten\n         (filter #(= (count %) 1))\n         (filter #(not (= #{:e} %)))\n         first\n         first)\n    )","user":"57aa290de4b0b8559636fc65"},{"problem":73,"code":"(fn  [board]\n  (let [tboard [(map first board)\n                (map second board)\n                (map #(nth % 2) board)]\n        cross [(map #(get-in board %) [[0 0] [1 1] [2 2]])\n               (map #(get-in board %) [[0 2] [1 1] [2 0]])]\n        all (concat board tboard cross)]\n    (cond\n      (some #{[:x :x :x]} all) :x\n      (some #{[:o :o :o]} all) :o\n      :else nil)))","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn [col]\n  (let [col (concat [(map first col)] [(map second col)]\n             [(map (comp first next next) col)] \n             [(conj [] (first(first col))\n                       (second (second col))\n                       ((comp last last) col))]\n             [(conj [] ((comp first last) col)\n                       (second (second col))\n                       ((comp last first) col))]\n             col)\n        rt (concat (filter #(every? (fn[x] (= x :x))\n                   %) col)\n                   (filter #(every? (fn[x] (= x :o))\n                   %) col))]\n     (if (not (empty? rt))\n        (first (first rt)))))","problem":73,"user":"4ef992c8535dced4c769f268"},{"code":"(fn [board]\n  (let [original board\n        rotated (apply map list board)\n        diagonals [(map-indexed (fn [i x] (nth x i)) board)\n                   (map-indexed (fn [i x] (nth x (- 2 i))) board)\n                   [:e :e :e]]\n        possibles (filter #(and (not (= [:e] %)) (= 1 (count %)))\n                          (map distinct (concat original rotated diagonals)))]\n    (ffirst possibles)))","problem":73,"user":"4f6fd91ae4b07046d9f4efed"},{"problem":73,"code":"(fn [board]\n\n (let [\n transpozed-board (apply mapv vector board)\n [[x _ _] [_ y _] [_ _ z]] board\n [[_ _ a] [_ b _] [c _ _]] board\n diagonals [[x y z] [a b c]]\n result (filter\n  (fn [[x y]]\n    (and (= 3 y) (not= :e x))) (mapcat frequencies (concat board transpozed-board diagonals)))]\n  (if (empty? result) nil (ffirst result))))","user":"553c136ae4b09218d5f45012"},{"problem":73,"code":"(letfn [(row\n         [b i]\n         (nth b i))\n        \n        (col\n         [b i]\n         (mapv #(nth % i) b))\n        \n        (diags\n         [b]\n         [(mapv #(nth (row b %) %)\n                (range (count b)))\n          (mapv #(nth (row b %1) %2)\n                (range (count b))\n                (reverse (range (count b))))])\n        \n        (winning?\n         [b p]\n         (some (fn [x]\n                 (every? (partial = p) x))\n               (concat (map (partial row b) '(0 1 2))\n                       (map (partial col b) '(0 1 2))\n                       (diags b))))\n        \n        (winning-player\n         [b]\n         (some identity (filter (partial winning? b) #{:x :o})))]\n  winning-player)","user":"5829d9f8e4b051871117bf4d"},{"problem":73,"code":"(fn winner-in-one [board]\n  (let [\n        nnth (fn [coll i j] (nth (nth coll i) j))\n\n        h-rows (fn [board] board)\n        v-row (fn [board n]\n                (map #(nth % n) board))\n        v-rows (fn [board]\n                 (map #(v-row board %) (range (count board))))\n        diagonal (fn [board]\n                   (let [coords (map (partial repeat 2) (range (count board)))]\n                     (map #(apply (partial nnth board) %) coords)))\n        rev-diagonal (fn [board]\n                       (diagonal (map reverse board)))\n        diagonals (fn [board]\n                    (list (diagonal board) (rev-diagonal board)))\n\n        lines (fn [board]\n               (apply concat (map #(% board) [h-rows v-rows diagonals])))\n\n        winner? (fn [board kw]\n                  (some (fn [line] (every? #(= % kw) line)) (lines board)))\n\n        winner (fn [board]\n                 (some #(if (winner? board %) %) [:x :o]))\n        ]\n    (winner board)\n    ))","user":"5b7f2d75e4b047b03b203768"},{"problem":73,"code":"(fn [board]\n  (if (and (not= :e (first (first board))) (apply = (first board)))\n    (first (first board))\n    (if (and (not= :e (first (second board))) (apply = (second board)))\n      (first (second board))\n      (if (and (not= :e (first (last board))) (apply = (last board)))\n        (first (last board))\n        (if (and (not= :e (first (first board))) (= (first (first board)) (first (second board)) (first (last board))))\n          (first (first board))\n          (if (and (not= :e (second (first board))) (= (second (first board)) (second (second board)) (second (last board))))\n            (second (first board))\n            (if (and (not= :e (last (first board))) (= (last (first board)) (last (second board)) (last (last board))))\n              (last (first board))\n              (if (and (not= :e (first (first board))) (= (first (first board)) (second (second board)) (last (last board))))\n                (first (first board))\n                (if (and (not= :e (last (first board))) (= (last (first board)) (second (second board)) (first (last board))))\n                  (last (first board))\n                  nil)))))))))","user":"59368ccae4b02506e01a297a"},{"code":"(fn [b]\n  (letfn [(cords-seq []\n            (concat (map #(map vector (repeat %) (range 3)) (range 3))\n                    (map #(map vector (range 3) (repeat %)) (range 3))\n                    [[[0 0] [1 1] [2 2]]]\n                    [[[0 2] [1 1] [2 0]]]))\n          (won? [x]\n            (some (fn [cords] (every? #(= x (get-in b %)) cords))\n                  (cords-seq)))]\n    (cond\n     (won? :x) :x\n     (won? :o) :o\n     true nil)))","problem":73,"user":"4fbf2818e4b081705acca317"},{"problem":73,"code":"(fn [table]\n  (let [rows table\n        cols (apply map vector table)\n        diags (map \n               #(let [i-map %] (map nth table i-map)) \n               [[0 1 2] [2 1 0]])\n        all-lines (concat rows cols diags)]\n    (some\n     #(let [[player result] %]\n        (if (nil? result)\n          nil\n          player))\n        (for [player [:x :o]]\n          [player (some #(apply (partial = player) %) all-lines)]))))","user":"59fa7fb0e4b0ca45a743a366"},{"problem":73,"code":"(fn [[a b c]] (cond\n                                             (= :x (nth a 0) (nth a 1) (nth a 2))\n                                             :x\n                                             (= :o (nth a 0) (nth a 1) (nth a 2))\n                                             :o\n                                             (= :x (nth a 0) (nth b 1) (nth c 2))\n                                             :x\n                                             (= :o (nth a 0) (nth b 1) (nth c 2))\n                                             :o\n                                             (= :x (nth a 0) (nth b 0) (nth c 0))\n                                             :x\n                                             (= :o (nth a 0) (nth b 0) (nth c 0))\n                                             :o\n\n                                             (= :x (nth a 1) (nth b 1) (nth c 1))\n                                             :x\n                                             (= :o (nth a 1) (nth b 1) (nth c 1))\n                                             :o\n\n                                             (= :x (nth a 2) (nth b 2) (nth c 2))\n                                             :x\n                                             (= :o (nth a 2) (nth b 2) (nth c 2))\n                                             :o\n                                             (= :x (nth a 2) (nth b 1) (nth c 0))\n                                             :x\n                                             (= :o (nth a 2) (nth b 1) (nth c 0))\n                                             :o\n\n                                             (= :x (nth b 0) (nth b 1) (nth b 2))\n                                             :x\n                                             (= :o (nth b 0) (nth b 1) (nth b 2))\n                                             :o\n                                             (= :x (nth c 0) (nth c 1) (nth c 2))\n                                             :x\n                                             (= :o (nth c 0) (nth c 1) (nth c 2))\n                                             :o\n                                             :else\n                                             nil\n                                           )\n                               )","user":"5cf72682e4b0b71b1d808a68"},{"problem":73,"code":"(fn prob73 ;; this solution is inspired by that of user \"minitrue\"\n  [[top mid bottom :as board]]\n  (let [three-in-a-rows\n        (concat board ;; the horizontal 3-in-a-rows\n                (map vector top mid bottom) ;; the verticals\n                [[(top 0) (mid 1) (bottom 2)] ;; the diagonals\n                 [(top 2) (mid 1) (bottom 0)]])]\n    (->> three-in-a-rows\n         ;; get only elements that have 3-in-a-row & aren't the empty key\n         (filter #(apply = %))\n         (map first)\n         (filter #(not= :e %))\n         ;; return nil if there is neither :x nor :o have 3-in-a-row\n         (cons nil)\n         ;; at this point, assume that our final list is one element long\n         ;; i.e. that our given board doesn't have both a :x and :o 3-in-a-row\n         (last))))","user":"5d2e5065e4b01671435dbcae"},{"problem":73,"code":"(fn [b] (let [lb (apply concat b) xb (conj \n    b (apply concat (partition 1 3 lb)) (apply concat (partition 1 3 (drop 1 lb))) (apply concat (partition 1 3 (drop 2 lb))) \n      (apply concat (partition 1 4 lb)) (take 3 (apply concat (partition 1 2 (drop 2 lb))))\n           )]\n          (cond\n              (some (fn [c] (every? #(= :x %) c)) xb) :x\n              (some (fn [c] (every? #(= :o %) c)) xb) :o\n           )))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(fn [b]\n  (letfn [(w [[[a b c]\n               [d e f]\n               [g h i]] p] (or (= p a b c)\n                               (= p d e f)\n                               (= p g h i)\n                               (= p a d g)\n                               (= p b e h)\n                               (= p c f i)\n                               (= p a e i)\n                               (= p c e g)))]\n    (cond (w b :x) :x\n          (w b :o) :o\n          :else nil)))","problem":73,"user":"4ee9ddb8535d93acb0a66896"},{"code":"(fn [s]\n  (letfn [(win? [board k]\n            (some #(every? (conj #{} k) %)\n                  (concat board\n                          (apply map vector board)\n                          (conj []\n                                (for [idx (range 3)]\n                                  (get-in board [idx idx]))\n                                (for [idx (range 3)]\n                                  (get-in board [idx (- 2 idx)]))))))]\n    (cond\n     (win? s :x) :x\n     (win? s :o) :o\n     :else nil)))","problem":73,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn [b] (first (filter (fn [x] (not (nil? x))) (map (partial (fn\n  [board direction starting]\n  (if (= direction :horizontal)\n    (if (and (= ((board starting) 0) ((board starting) 1) ((board starting) 2))\n          (not= ((board starting) 0) :e))\n    ((board starting) 0)\n    nil)\n    (if (= direction :vertical)\n      (if (and (= ((board 0) starting) ((board 1) starting) ((board 2) starting))\n            (not= ((board 0) starting) :e))\n        ((board 0) starting)\n        nil)\n      (if (= direction :l-diag)\n        (if (and (= ((board 0) 0) ((board 1) 1) ((board 2) 2))\n              (not= ((board 0) 0) :e))\n          ((board 0) 0)\n          nil)\n        (if (= direction :r-diag)\n          (if (and (= ((board 0) 2) ((board 1) 1) ((board 2) 0))\n                (not= ((board 0) 2) :e))\n            ((board 0) 2)\n            nil)))))\n) b) [:horizontal :horizontal :horizontal\n      :vertical :vertical :vertical\n      :l-diag :r-diag] [0 1 2 0 1 2 0 0]))))","problem":73,"user":"519291c1e4b08962174cf74b"},{"problem":73,"code":"(fn [board]\n  (loop [table (concat\n                board\n                (apply map vector board)\n                [(map-indexed #(nth %2 %1) board)]\n                [(map-indexed #(nth (reverse %2) %1) board)])]\n    (cond\n      (empty? table)\n      nil\n      (= [:x :x :x] (first table))\n      :x\n      (= [:o :o :o] (first table))\n      :o\n      :else\n      (recur (rest table)))))","user":"555f3bfde4b0a2eb076a39c1"},{"code":"(fn [b]\n  (let [win-row? (fn [p row] (every? #(= p %) row))\n        win? (fn [p]\n               (or\n                 (win-row? p (first b))\n                 (win-row? p (second b))\n                 (win-row? p (nth b 2))\n                 (win-row? p (map first b))\n                 (win-row? p (map second b))\n                 (win-row? p (map #(nth % 2) b))\n                 (win-row? p [(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])])  \n                 (win-row? p [(get-in b [2 0]) (get-in b [1 1]) (get-in b [0 2])])  \n                 ))]\n    (if (win? :x)\n      :x\n      (if (win? :o)\n        :o))))","problem":73,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn tic-tac-toe [board]\n  (let [check (comp first first (partial filter #(apply = %)))\n        tboard (apply map vector board)\n        diag1 [[((board 0) 0) ((board 1) 1) ((board 2) 2)]]\n        diag2 [[((board 0) 2) ((board 1) 1) ((board 2) 0)]]\n        result (first (filter (comp not nil?) (map check [board tboard diag1 diag2])))\n        ]\n    (if (= :e result) nil result)))","problem":73,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":73,"code":"(fn ttt\n  [board]\n  (let [mirror (map (comp vec reverse) board)\n        cols (apply map vector board)\n        diag [(for [i (partition 2 (interleave board (range)))] (get (first i) (second i)))]\n        rdiag [(for [i (partition 2 (interleave mirror (range)))] (get (first i) (second i)))]\n        all-board (reduce concat [board cols diag rdiag])]\n   (->> (for [e (filter #(= 1 (count (set %) )) all-board) ] (first e))\n         (remove #(= :e %))\n         first)\n         \n))","user":"58988cbbe4b00487982d52d7"},{"problem":73,"code":"(fn tic-tac-toe-check [board]\n  (let [win? (fn [rets coll]\n               (loop [rets rets]\n                 (if (seq rets)\n                   (if (apply = (first rets) coll) \n                     (first rets)\n                     (recur (rest rets)))\n                   nil)))\n\n        check? (fn [rets colls]\n                 (let [win-ret? (fn [coll] (win? rets coll))]\n                   (loop [ret (win-ret? (first colls)) colls (rest colls)]\n                     (cond ret ret\n                           (seq colls) (recur (win-ret? (first colls)) (rest colls))\n                           :else nil))))\n        ttt-check? (fn [board rets fns]\n                     (when (seq fns)\n                       (let [f (first fns)\n                             colls (f board)\n                             ret (check? rets colls)]\n                         (cond ret ret\n                               (seq fns) (recur board rets (rest fns))\n                               :else nil))))\n        \n        row-v (fn [board] (apply mapv vector board))\n        diagonal (fn [board]\n                   (vector (->> (range (count board))\n                                (mapv #(get-in board [% %])))))\n        rdiagonal (fn [board]\n                    (diagonal (->> board reverse vec)))]\n    (ttt-check? board [:x :o] [identity row-v diagonal rdiagonal])))","user":"5370d152e4b0fc7073fd6e9d"},{"code":"(fn analize [ls]\r\n   (let [diag1 (map-indexed\r\n                 (fn [idx  xs] (nth xs idx)) ls)\r\n         diag2 (map-indexed\r\n                 (fn [idx  xs] (nth (reverse xs) idx)) ls)\r\n         transpose (apply map vector ls)\r\n         series (concat ls transpose [diag1 diag2])\r\n         has-streak (fn [x] (some (fn [y] (every? #(= x %) y)) series))\r\n         filt (filter has-streak [:o :x])\r\n                      \r\n         ]\r\n     (when (seq filt) (first filt) )))","problem":73,"user":"502a9fdee4b095a7adb898b4"},{"problem":73,"code":"#(let [wins #{#{0 1 2}\n              #{3 4 5}\n              #{6 7 8}\n              #{0 3 6}\n              #{1 4 7}\n              #{2 5 8}\n              #{0 4 8}\n              #{2 4 6}}\n        positions (reduce (fn [acc [i v]] (update-in acc [v] conj i)) {:x #{} :e #{} :o #{}} (map-indexed vector (flatten %)))] (reduce (fn [res [k v]] (or res (when (some (partial every? v) wins) k))) nil (dissoc positions :e)))","user":"532ecd44e4b019098a6f8b49"},{"code":"(fn tictactoe [board]\n  (letfn [(third [[a b c & rest]]\n            c)\n          (seq-winner [sq]\n            (when-let [x (and (apply = sq) (first sq))]\n              (if (= x :e)\n                nil\n                x)))\n          (diags [mx]\n            (list (map #(get-in mx %) [[0 0] [1 1] [2 2]])\n                  (map #(get-in mx %) [[0 2] [1 1] [2 0]])))\n          (rows [mx]\n            mx)\n          (columns [mx]\n            (map #(map % mx) [first second third]))]\n   (some seq-winner (concat (diags board) (rows board) (columns board)))))","problem":73,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn [game]\n  (let [p (conj game (map first game) (map second game) (map last game)\n                [(first (first game)) (second (second game)) (last (last game))]\n                [(last (first game)) (second (second game)) (first (last game))])]\n   (some {[:x :x :x] :x [:o :o :o] :o} p)))","problem":73,"user":"524b90fae4b09eba1c0223df"},{"code":"(fn [board]                                                                                    \n  (letfn [(winner [p row] (apply = p row))                                                           \n          (row [n b] (nth b n))                                                                      \n          (col [n b] (nth (apply map vector b) n))                                               \n          (d1 [b] [(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])])                                      \n          (d2 [b] [(get-in b [2 0]) (get-in b [1 1]) (get-in b [0 2])])                        \n          (game [p b] (some identity                                                                 \n                        (concat (list (winner p (d1 b)) (winner p (d2 b)))                                        \n                        (for [i (range 3)]                                            \n                        (or (winner p (row i b)) (winner p (col i b)))))))]                         \n  (cond (game :x board) :x (game :o board) :o :else nil)))","problem":73,"user":"4f1d1299535d64f603146487"},{"problem":73,"code":"#(letfn [(cols  [[a b c]] (mapv vector a b c))\n         (diags [[a b c]] [[(a 0) (b 1) (c 2)] [(a 2) (b 1) (c 0)]])]\n   (some {[:x :x :x] :x [:o :o :o] :o} (concat % (cols %) (diags %))))","user":"596a66cde4b069c0a1a19803"},{"problem":73,"code":"(fn [board]\n  (let [to-check (mapcat (fn [arr] (map #(vector (first arr) % ) (second arr)) ) [ [0 [1 3 4]] [1 [3]] [2 [2 3]] [3 [1]] [6 [1]]] )\nb (into [] (flatten board))]\n(first (flatten (filter #(and(= (count %) 1) (not (= (first %) :e))) (map distinct (map #(take 3 (take-nth (second %) (drop (first %) b))) to-check)))))))","user":"5a1c8c26e4b0ff51aa4b3247"},{"code":"(fn [x]\n  (let [analyze (fn [s]\n                  (if (or (= s ((x 0) 0) ((x 0) 1) ((x 0) 2))\n                        (= s ((x 1) 0) ((x 1) 1) ((x 1) 2))\n                     \t(= s ((x 2) 0) ((x 2) 1) ((x 2) 2))\n                        \n                        (= s ((x 0) 0) ((x 1) 0) ((x 2) 0))\n                        (= s ((x 0) 1) ((x 1) 1) ((x 2) 1))\n                        (= s ((x 0) 2) ((x 1) 2) ((x 2) 2))\n                        \n                        (= s ((x 0) 0) ((x 1) 1) ((x 2) 2))\n                        (= s ((x 0) 2) ((x 1) 1) ((x 2) 0))\n                     ) s nil))\n        ]\n    (or (analyze :x) (analyze :o))\n    ))","problem":73,"user":"51da7e49e4b02ceefd947768"},{"code":"(fn __ [[[a b c]\n           [d e f]\n           [g h i] :as board]]\n  (let [B (set board)\n        Bt (set (apply map list board))\n        test (fn [x]\n               (let [x3 (list x x x)]\n                 (or\n                   (B x3)\n                   (Bt x3)\n                   (= x3 [a e i])\n                   (= x3 [c e g]))))]\n    (cond\n      (test :x) :x\n      (test :o) :o\n      :else nil)))","problem":73,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":73,"code":"(fn winner [board]\n  (let [x (filter\n            (fn [e]\n              (and (apply = e) (every? #(not= % :e) e)))\n            (concat board\n                    (apply map list board)\n                    (reduce (fn [a b]\n                              (let [[l r] a\n                                    n (count l)\n                                    c (count b)]\n                                [(conj l (nth b n))\n                                 (conj r (nth b (- c n 1)))]))\n                            [[] []]\n                            board)))]\n    (if (empty? x) nil (first (first x)))))","user":"58bb218be4b0888cdc949cf4"},{"problem":73,"code":"(fn [[[a b c]\n    [d e f]\n    [g h i]]]\n  (let\n   [winner (fn [[a b c]] (if (and (not= a :e) (= a b c)) a nil))]\n    (reduce #(if (nil? %1) (winner %2) %1) nil [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]])))","user":"5c1840eae4b01240ff5671eb"},{"problem":73,"code":"(fn f [x]\n    (loop [b [#(first %)\n              #(nth % 1)\n              #(nth % 2)\n              #(take-nth 3 (flatten %))\n              #(take-nth 3 (nthrest (flatten %) 1))\n              #(take-nth 3 (nthrest (flatten %) 2))\n              #(take-nth 4 (flatten %))\n              #(butlast (take-nth 2 (nthrest (flatten %) 2)))]]\n      (if (empty? b)\n        nil\n        (let [d (distinct ((first b) x))]\n          (if (or (= d [:x]) (= d [:o]))\n            (first d)\n            (recur (rest b))\n            )\n          )\n        )\n      )\n    )","user":"5c337305e4b0d62ef62d9f48"},{"problem":73,"code":";stolen elegant solution (maybe I started this problem too early :).):\n;(fn [[[a b c] [d e f] [g h i] :as x]]\n;    (some {[:x :x :x] :x [:o :o :o] :o}\n;          (list* [a d g] [b e h] [c f i] [a e i] [c e g] x)))\n(fn tic-tok[matrix]\n   (letfn[(counter [pattern col]\n            (= 3 (count (filter #(= pattern %) col))))\n          (won [p m]\n            (some true?\n                  [;columns\n                   (counter p (map first m))\n                   (counter p (map second m))\n                   (counter p (map last m))\n                   ;lines\n                   (counter p (first m))\n                   (counter p (second m))\n                   (counter p (last m))\n                   ;diagonal\n                   (counter p [(ffirst m) (second (second m))\n                               (last (last m))])\n                   (counter p [(last (first m)) (second (second m))\n                               (first (last m))])\n                   ])\n            )]\n     (if (won :x matrix)\n       :x\n       (if (won :o matrix)\n         :o\n         nil\n         ))))","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":73,"code":"(fn tic-tac-toe\n  [data]\n  (letfn [(map-fields [data locations]\n            (if (not (nil? (first data)))\n              (map-fields (butlast data) (-> locations \n                (assoc (keyword (str (- (* 3 (count data)) 2))) (first (last data)))\n                (assoc (keyword (str (- (* 3 (count data)) 1))) (second (last data)))\n                (assoc (keyword (str (- (* 3 (count data)) 0))) (last (last data)))\n                ))\n              locations))\n          (get-result [f]\n            (cond \n              (or (= (:1 f) (:2 f) (:3 f) :x)\n                  (= (:4 f) (:5 f) (:6 f) :x)\n                  (= (:7 f) (:8 f) (:9 f) :x)\n                  (= (:1 f) (:4 f) (:7 f) :x)\n                  (= (:2 f) (:5 f) (:8 f) :x)\n                  (= (:3 f) (:6 f) (:9 f) :x)\n                  (= (:1 f) (:5 f) (:9 f) :x)\n                  (= (:3 f) (:5 f) (:7 f) :x)\n                  )\n                :x\n                (or (= (:1 f) (:2 f) (:3 f) :o)\n                  (= (:4 f) (:5 f) (:6 f) :o)\n                  (= (:7 f) (:8 f) (:9 f) :o)\n                  (= (:1 f) (:4 f) (:7 f) :o)\n                  (= (:2 f) (:5 f) (:8 f) :o)\n                  (= (:3 f) (:6 f) (:9 f) :o)\n                  (= (:1 f) (:5 f) (:9 f) :o)\n                  (= (:3 f) (:5 f) (:7 f) :o)\n                  )\n                :o\n                :else nil))]\n    (get-result (map-fields data {}))))","user":"5d7d17ece4b02e6b30c93558"},{"code":"(fn [xos]\n  (letfn [(table-value [t xy] (reduce #(% %2) t xy))]\n    (let [trs [[[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]\n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]]\n       rws (map \n             (fn [tr] \n               (map \n                 (fn [xy] \n                   (table-value xos xy)) tr)) trs)]\n       (cond\n         (some (fn [rw] (every? #(= :x %) rw)) rws) :x\n         (some (fn [rw] (every? #(= :o %) rw)) rws) :o\n         :else nil))))","problem":73,"user":"5084c43be4b0fb8f40674bfa"},{"problem":73,"code":"(fn [rs]\n   (let [fs  [last second first]\n         cs  (map #(map % rs) fs)\n         dx  #(%1 %2)\n         xs  (map #(map dx fs %) [rs cs])\n         t?  (fn [xs] (if (apply = xs) (#{:x, :o} (first xs))))]\n     (some t? (concat xs rs cs))))","user":"5b073c34e4b0cc2b61a3bda4"},{"problem":73,"code":"(fn [board]\n  (let [win? (fn [k v] (and (not= :e k) (= 3 v)))\n        win-f (fn [freqs]\n                (reduce (fn [win f]\n                          (or win\n                              (reduce-kv (fn [res k v]\n                                           (or res (when (win? k v) k)))\n                                         win\n                                         f)))\n                        nil\n                        freqs))\n        diags (let [rng (range (count board))]\n                (list\n                 (map #(get-in board [% %]) rng)\n                 (map (fn [m n] (get-in board [n m])) rng (reverse rng))))\n        row-win (win-f (map frequencies board))\n        coll-win (win-f (apply map (fn [& c] (frequencies c)) board))\n        diag-win (win-f (map frequencies diags))]\n    (or row-win coll-win diag-win)))","user":"540a4f20e4b0addc1aec66ef"},{"problem":73,"code":"(fn [board]\n  (let [lines [; horizontal\n               [[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [1 2]]\n               ; vertical\n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               ; diagonal\n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]]]\n    (letfn [(get-elements [indexes board] (map #(get-in board %) indexes))\n            (get-lines [board] (map #(get-elements % board) lines))\n            (get-equal-lines [board] (->> board get-lines (filter #(apply = %)) (map first) sort reverse))\n            (get-winner [board]\n              (let [winner (first (get-equal-lines board))]\n                (if (= :e winner) nil winner)))]\n      (get-winner board))))","user":"5c13da47e4b01240ff5671a6"},{"problem":73,"code":"#(some\n  {[:x :x :x] :x [:o :o :o] :o}\n  (partition 3\n             (map (vec (flatten %))\n                  '(0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6))))","user":"552a793ee4b0ffed3738f955"},{"problem":73,"code":"(fn [[row1 row2 row3 :as pg]]\n  (let [[col1 col2 col3] (partition 3 (apply interleave pg))\n        diag1 [(row1 0) (row2 1) (row3 2)]\n        diag2 [(row1 2) (row2 1) (row3 0)]\n        rd (fn [c] (reduce #(when (and (= %1 %2) (not= %1 :e)) %1) c))]\n    (reduce #(or %1 %2) (map rd [row1 row2 row3 col1 col2 col3 diag1 diag2]))))","user":"53908e6be4b0b51d73faae9a"},{"code":"(fn analyze [[a b c]]\r\n  (reduce (fn [acc x]\r\n            (cond (= acc nil) x\r\n                  :else acc))\r\n          nil\r\n          (map (fn [xs] \r\n            (if (apply = xs) \r\n              (if (= (first xs) :e)\r\n                   nil\r\n                   (first xs))\r\n              nil)) \r\n              (concat [a b c]\r\n                      [(map first  [a b c])\r\n                       (map second [a b c])\r\n                       (map last   [a b c])]\r\n                      [[(first a) (second b) (last c)]\r\n                      [(last a) (second b) (first c)]]\r\n))))","problem":73,"user":"4fc5a693e4b0ee37620e17fc"},{"code":"(fn __ [ll]\r\n  (let [ [l1 l2 l3] ll  \r\n         g (fn g[s res]\r\n             (let [si (repeat 3 s)]\r\n  (cond \r\n    (or (= l1 si) (= l2 si) (= l3 si)) s\r\n    (some #(= % si) (map (fn [i] (map #(nth % i) ll)) (range 3))) s\r\n    (= (list (first l1) (second l2) (nth l3 2)) si) s\r\n    (= (list (nth l1 2) (nth l2 1) (nth l3 0 )) si) s\r\n    :else false)))]\r\n    (cond\r\n     (= (g :x ll) :x) :x\r\n     (= (g :o ll) :o) :o\r\n     :else nil)))","problem":73,"user":"4f04a06d535dcb61093f6bd9"},{"problem":73,"code":"(fn [board]\n    (let [mat-get\n          (fn [mat [i j]]\n            (-> mat\n                (get i)\n                (get j)))\n\n          candiate-fns\n          [first\n           second\n           last\n           #(map first %)\n           #(map second %)\n           #(map last %)\n           #(map (partial mat-get %) [[0 0] [1 1] [2 2]])\n           #(map (partial mat-get %) [[0 2] [1 1] [2 0]])]\n\n          valid-candiate\n          (fn [board f]\n            (let [coll (f board)]\n              (cond\n                (= coll [:x :x :x])\n                :x\n\n                (= coll [:o :o :o])\n                :o\n                )))]\n      (some (partial valid-candiate board) candiate-fns)))","user":"5d883119e4b0915913b1d3a6"},{"problem":73,"code":"(fn winner [board]\n\n  (let\n      ;; transform\n      [transformed (map (fn [r1 r2 r3] [r1 r2 r3]) (nth board 0) (nth board 1) (nth board 2)),\n       find-winner (fn [bd]\n                     (let [row-results (map\n                                         (fn [[n1 n2 n3]] (if (and (not (= n1 :e)) (= n1 n2 n3)) n1 nil))\n                                         bd)]\n                       (first (filter #(not (nil? %)) row-results))\n                       )),\n       winner1 (find-winner board)\n       winner2 (find-winner transformed)\n       center (nth (nth board 1) 1),\n       lt (nth (nth board 0) 0),\n       rt (nth (nth board 0) 2),\n       lb (nth (nth board 2) 0),\n       rb (nth (nth board 2) 2)\n       ]\n    (cond\n      (not (nil? winner1)) winner1\n      (not (nil? winner2)) winner2\n      (and (= :x center) (or (= :x lt rb) (= :x rt lb))) :x\n      (and (= :o center) (or (= :o lt rb) (= :o rt lb))) :o\n      :else nil\n      )\n    ))","user":"53ca41dae4b00fb29b2212c8"},{"code":"(fn [board] (let [transpose #(apply map vector %) \n                  diagonal  #(first (reduce (fn [[a n] xs] [(conj a (nth xs n)) (+ n 1)]) [[] 0] %))\n                  mirror \t(fn [xs] (map #(vec (reverse %)) xs))\n                  lines     #(concat % (transpose %) [(diagonal %) (diagonal (mirror %))])\n                  winner? \t(fn [player row] (reduce #(and %1 (= player %2)) true row))\n                  winner \t#(if (winner? :x %) :x (if (winner? :o %) :o nil))] \n              (first (drop-while #(= nil %) (map winner (lines board))))))","problem":73,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":73,"code":"(fn __ [board]\n  (let [revert-board (for [i (range 3)] (map #(nth % i) board))\n        diag (fn [modifier] (for [i (range 3)] (-> board (nth (modifier i)) (nth i))))]\n    (->> board \n      (concat revert-board) \n      (cons (diag identity)) \n      (cons (diag (partial - 2))) \n      (filter (partial apply =))\n      (filter #(not= (first %) :e))\n      first first)))","user":"55a62092e4b0acc240e31554"},{"code":"(fn [i] (some \n      {[:x :x :x] :x [:o :o :o] :o}\n          (concat i\n            (apply map list i)\n            (map (fn [x] (map-indexed #(nth %2 %) x)) [i (reverse i)]))))","problem":73,"user":"4fccf4dde4b0ee37620e1870"},{"code":"(let [winning-line (fn [line]\n                     (cond\n                       (every? #(= :x %) line) :x\n                       (every? #(= :o %) line) :o\n                       :else nil))\n      diagonals (fn [[row1 row2 row3]]\n                  [\n                   [ (nth row1 0) (nth row2 1) (nth row3 2) ]\n                   [ (nth row1 2) (nth row2 1) (nth row3 0) ]\n                   ])]\n  (fn [board]\n    (or\n      (some winning-line board)\n      (some winning-line (partition 3 (apply interleave board)))\n      (some winning-line (diagonals board)))))","problem":73,"user":"50f94727e4b0e7c80cb15a49"},{"code":"(fn [b]\n  (letfn\n    [(anarow  \n      [a b c]\n      (if (and (= a b) (= b c))\n        a nil))\n     (akabd \n      [b]\n      (let [a1 (first b) a2 (second b) a3 (last b)\n            a11 (first a1) a12 (second a1) a13 (last a1)\n            a21 (first a2) a22 (second a2) a23 (last a2)\n            a31 (first a3) a32 (second a3) a33 (last a3)]\n        [(anarow a11 a12 a13) (anarow a21 a22 a23) (anarow a31 a32 a33)\n         (anarow a11 a21 a31) (anarow a12 a22 a32) (anarow a13 a23 a33)\n         (anarow a11 a22 a33) (anarow a13 a22 a31)]))\n     (findnn\n      [l]\n      (some #(when (not= nil %) %) l)\n      )\n     (check \n      [x]\n      (if (or (= x :x) (= x :o)) x nil)\n      )]\n    (-> b akabd findnn check)\n    ))","problem":73,"user":"52faec2ee4b047fd55837004"},{"problem":73,"code":"(fn winner [board]\n  (let [rows-and-colums (concat board (apply map vector board))\n        f (fn [b] (map #(%1 %2) (list first second last) b))\n        diagonals (map f [board (map reverse board)])\n        all-combs (concat rows-and-colums diagonals)\n        ]\n    (first (filter  (fn [s]\n                      (some #(= % (repeat 3 s)) all-combs)\n                      ) [:x :o]))\n    ))","user":"5630fd6fe4b0bfe05bf1178b"},{"code":"(fn [board]\n    (letfn [(has-winner [coll] (some #(if (not (or (nil? %) (= :e %))) % false) coll))\n            (row-winner [r] (if (apply = r) (first r) nil))\n            (transpose [b] (apply mapv vector b))\n            (winner-by-row [b] (has-winner (map row-winner b)))\n            (winner-by-col [b] (winner-by-row (transpose b)))\n            (winner-by-diag [b] (has-winner (list (if (or (= (get (get b 0) 0) (get (get b 1) 1) (get (get b 2) 2))\n                                         (= (get (get b 0) 2) (get (get b 1) 1) (get (get b 2) 0)))\n                                  (get (get b 1) 1) nil))))]\n      (some identity [(winner-by-row board) (winner-by-col board) (winner-by-diag board)])))","problem":73,"user":"5141abf1e4b02fd87f5064c3"},{"problem":73,"code":"(fn xo [b] (letfn [(tt [c] (when (= 1 (count (set c))) (first c)))\n                     (diag [c] (for [n (range 3)]\n                                 (nth (nth c n) n)))]\n               (first (remove nil?\n                              (filter #(not (= :e %))\n                                      (concat\n                                        (apply map (fn [& as] (tt as)) b)\n                                        (map tt b)\n                                        [(tt (diag b))]\n                                        [(tt (diag (reverse b)))]))))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":73,"code":"(fn tictactoe\n  [board]\n  (let [row (fn [idx]\n              (get board idx))\n        col (fn [idx]\n              (map #(get % idx) board))\n        diag1 (map #(get (row %) %) [0, 1, 2])\n        diag2 (map #(get (row %) (- 2 %)) [0, 1, 2])\n        candidates (concat\n                     (map row [0, 1, 2])\n                     (map col [0, 1, 2])\n                     [diag1, diag2])\n        x-wins? #(= % [:x :x :x])\n        o-wins? #(= % [:o :o :o])]\n    (cond\n      (seq (filter x-wins? candidates)) :x\n      (seq (filter o-wins? candidates)) :o\n      :otherwise nil)))","user":"56488119e4b0284900eef632"},{"problem":73,"code":"(fn [board]\n  (let [nums (range (count board))\n        cols (for [x nums] (vec (map #(get % x) board)))\n        dgnl (fn [cols] (for [x nums] (get-in cols [x x])))]\n    (some (fn [[h & t]] (and (not= :e h) (apply = h t) h))\n          (conj (into board cols) \n                (dgnl (vec cols)) \n                (dgnl (vec (reverse cols)))))))","user":"590b8607e4b047aa04b199db"},{"problem":73,"code":"(fn game-running [board]\n  (let [win-positions\n          [[[0 0] [0 1] [0 2]]\n           [[1 0] [1 1] [1 2]]\n           [[2 0] [2 1] [2 2]]\n           [[0 0] [1 0] [2 0]]\n           [[0 1] [1 1] [2 1]]\n           [[0 2] [1 2] [2 2]]\n           [[0 0] [1 1] [2 2]]\n           [[0 2] [1 1] [2 0]]]]\n    (->(filter #(apply = %)\n        (filter #(not-any? #{:e} %)\n          (for [row win-positions]\n            (map #(get-in board %) row))))\n       (first)\n       (first))))","user":"5a91988ae4b002d099cae6f9"},{"problem":73,"code":"(fn tic-tac-toe-winner [board]\n  (let [[[a11 a12 a13]\n         [a21 a22 a23]\n         [a31 a32 a33]]\n        board]\n    (letfn [(won? [p]\n              (or\n               (every? #(= p %) [a11 a12 a13])\n               (every? #(= p %) [a21 a22 a23])\n               (every? #(= p %) [a31 a32 a33])\n               (every? #(= p %) [a11 a21 a31])\n               (every? #(= p %) [a12 a22 a32])\n               (every? #(= p %) [a13 a23 a33])\n               (every? #(= p %) [a11 a22 a33])\n               (every? #(= p %) [a13 a22 a31])))]\n      (cond\n        (won? :x) :x\n        (won? :o) :o\n        true nil))))","user":"5ab564f8e4b073f177442639"},{"problem":73,"code":"(fn __ [x]\n\t(let [h (for [i (range 3)] (map #(vector i %) (range 3)))\n\t\t  v (for [i (range 3)] (map #(vector % i) (range 3)))\n\t\t  d (for [i [0 2]] (map #(vector % (Math/abs (- i %))) (range 3)))\n\t\t  all_directions (concat h v d)\n\t\t  get_element #(nth (nth x (first %)) (last %))\n\t\t  create_set #(set (map get_element %))\n\t\t  all_sets (map create_set all_directions)\n\t\t  ]\n\t\t(some\n\t\t\t#(when\n\t\t\t\t (and\n\t\t\t\t\t (= 1 (count %))\n\t\t\t\t\t (not= :e (first %))\n\t\t\t\t\t )\n\t\t\t\t (first %)\n\t\t\t\t )\n\t\t\tall_sets)\n\t\t)\n\t)","user":"575dda55e4b02ea11479938c"},{"code":"(fn [board]\n  (let [fields\n        (concat\n         board\n         (apply map list board)\n         [(for [i (range 3)] (get-in board [i i]))]\n         [(for [i (range 3)] (get-in board [i (- 2 i)]))])]\n    (some\n     #(or (if (every? #{:x} %) :x)\n          (if (every? #{:o} %) :o))\n     fields)))","problem":73,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn win [a]\n  (let [vert (fn [a] \n               (partition 3 \n                 (for [j (range 3) i (range 3)] (get-in a [i j]))))\n        diag (fn [a] \n               (conj [[(get-in a [0 0]) (get-in a [1 1]) (get-in a [2 2])]]\n                  [(get-in a [0 2]) (get-in a [1 1]) (get-in a [2 0])]))\n        winv (fn [a]\n              (let [fv (for [v a :when (and (= (count (frequencies v)) 1) (not= (first v) :e))] v)]\n                (when (not-empty fv)\n                  (first (first fv))\n                  )\n                )\n              )\n        ]\n       (or (winv a) (winv (diag a)) (winv (vert a)))\n    )\n  )","problem":73,"user":"529a73bde4b02ebb4ef75096"},{"problem":73,"code":"(fn analyze-board[b]\n  (letfn [\n          (add-val[m k v] (swap! m (fn[m1 k1 v1] (assoc m1 k1 (conj (get m1 k1) v1))) k v))\n          (add[m r c e]\n            (do (add-val m r e)\n                (add-val m (+ c 3) e)\n                (if (= r c) (add-val m 6 e))\n                (if (or (and (= r 2) (= c 0))\n                        (and (= r 1) (= c 1))\n                        (and (= r 0) (= c 2)))\n                  (add-val m 7 e))))]\n    (let [m (atom {\n                   0 []\n                   1 []\n                   2 []\n                   3 []\n                   4 []\n                   5 []\n                   6 []\n                   7 []})]\n    (loop [row 0 col 0]\n      (let [element (-> (nth b row)(nth col))]\n        (if (and (<= row 2) (<= col 2)) (add m row col element)) \n        (cond (and (= col 2) (< row 2)) (recur (inc row) 0) \n              (< col 2) (recur row (inc col)))))\n    (->>\n          (vals @m)\n          (some (fn[elements]\n                  (let [r (reduce (fn[m k] (cond\n                                             (= k :e) m\n                                             (contains? m k) (assoc m k (inc (get m k)))\n                                             :else (assoc m k 1))) {} elements)]\n                    (-> (filter #(= (last %) 3) r)\n                        first\n                        first))))))))","user":"5bab31f1e4b0a20761a23471"},{"problem":73,"code":"(fn [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]\n  (let [v (vector (vector a1 a2 a3)\n                  (vector b1 b2 b3)\n                  (vector c1 c2 c3)\n                  (vector a1 b1 c1)\n                  (vector a2 b2 c2)\n                  (vector a3 b3 c3)\n                  (vector a1 b2 c3)\n                  (vector a3 b2 c1))\n        s (set (map set v))]\n    (condp #(contains? %2 %1) s\n      #{:x} :x\n      #{:o} :o\n      nil)))","user":"55dcb06ee4b050e68259b3b9"},{"problem":73,"code":"(fn __ [ [ [a b c] [d e f] [g h i]] ]\n (let [ grid [[a b c][d e f][g h i]\n              [a d g][b e h][c f i]\n              [a e i][g e c]]\n       answer (first (first (filter (fn [[x y z]](= x y z)) grid ))) ]\n       (some #{answer} [:x :o])))","user":"54b54d1be4b05787c3b1639c"},{"problem":73,"code":"(let [transpose (fn [board] (vec (apply map vector board)))\n      xs [:x :x :x]\n      os [:o :o :o]\n         row-winner (fn [row]\n                     (if\n                      (= row xs)\n                      :x\n                      (if\n                       (= row os)\n                       :o\n                       nil)))\n          diag-1 (fn [board] (vec (map (fn [x] ((board x) x)) (range 3))))\n          diag-2 (fn [board] (vec (map (fn [x] ((board x) (- 2 x))) (range 3))))]\n     (fn [board] (first (remove nil? (map row-winner (concat board (transpose board) [(diag-1 board) (diag-2 board)]))))))","user":"51d6f660e4b0154f82ab92f5"},{"problem":73,"code":"(fn [l]\n  (let [get-lines (fn [l] (let [r (apply map vector l)]\n                    (conj (vec (concat l r))\n                      (map #(nth %1 %2) l (iterate inc 0))\n                      (map #(nth %1 %2) l (iterate dec 2)))))\n        check-row (fn [l]\n                    (let [f (first l) res (filter #(= % f) l)]\n                      (if (= (count res) (count l)) (first res) :e  )))\n        lines (get-lines l)\n        ]\n  (first (filter #(not= % :e) (map check-row lines)))))","user":"586e47dee4b01531a375e9a9"},{"problem":73,"code":"(fn tic-tac-toe [field]\n  (let [[[a b c]\n         [d e f]\n         [g h i]] field\n        won? (fn [& col]\n               (if (and (apply = col)\n                        (not= :e (first col)))\n                 (first col)\n                 nil))]\n    (or (won? a b c)\n        (won? d e f)\n        (won? g h i)\n        (won? a d g)\n        (won? b e h)\n        (won? c f i)\n        (won? a e i)\n        (won? g e c))))","user":"5ecd1831e4b016b56eae0592"},{"code":"(fn [b]\n  (cond\n   (every? #(= :x %) (first b)) :x\n   (every? #(= :x %) (second b)) :x\n   (every? #(= :x %) (last b)) :x\n   (every? #(= :x %) (map first [(first b) (second b) (last b)])) :x\n   (every? #(= :x %) (map second [(first b) (second b) (last b)])) :x\n   (every? #(= :x %) (map last [(first b) (second b) (last b)])) :x\n   (every? #(= :x %) ((juxt #(first (first %)) #(second (second %)) #(last (last %))) b)):x\n   (every? #(= :x %) ((juxt #(first (last %)) #(second (second %)) #(last (first %))) b)):x\n   (every? #(= :o %) (first b)) :o\n   (every? #(= :o %) (second b)) :o\n   (every? #(= :o %) (last b)) :o\n   (every? #(= :o %) (map first [(first b) (second b) (last b)])) :o\n   (every? #(= :o %) (map second [(first b) (second b) (last b)])) :o\n   (every? #(= :o %) (map last [(first b) (second b) (last b)])) :o\n   (every? #(= :o %) ((juxt #(first (first %)) #(second (second %)) #(last (last %))) b)):o\n   (every? #(= :o %) ((juxt #(first (last %)) #(second (second %)) #(last (first %))) b)):o\n   :else nil))","problem":73,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn [b]\n    (->> [(first b) (second b) (last b)\n          (map first b) (map second b) (map last b)\n          (map #((b %) %) (range 3)) (map #((b (- 2 %)) %) (range 3))]\n      (map #(if (apply = %) (first %) :e))\n      (filter (partial not= :e))\n      (first)))","problem":73,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn [board]\n  (let [f (fn [l] (#(or (= % [0 1 2]) (= % [2 1 0]) (= 1 (count (distinct %))))\n                   (flatten l)))\n        fx (fn [y] (map (fn [v] (map first (filter #(= (second %) y) (map-indexed vector v)))) board))]\n    (cond (f (fx :x)) :x\n          (f (fx :o)) :o)))","problem":73,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":73,"code":";(identity(\n (fn [xs]\n  (->>\n   ((juxt\n     identity\n     #(apply map vector %)\n     #(map (fn [ms]\n             (map\n              (fn [m]\n                (get-in % m))\n              ms))\n       [[[0 0] [1 1] [2 2]]\n        [[2 0] [1 1] [0 2]]]))\n    xs)\n   (reduce concat)\n   (map #(into #{} %))\n   (filter #(and\n          (= 1 (count %))\n          (not (= :e\n                  (first %)))))\n   ffirst))\n; [[1 1 2]\n;  [2 4 5]\n;  [3 3 6]]))","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":73,"code":"(fn [x] (first (remove nil? (map {-3 :o 3 :x} (set (map (fn [col] (reduce #(+ %1 (get {:x 1 :o -1} %2 0)) 0 col)) ((fn [m] \n (let [r (apply mapv vector m)\nd1 (mapv get m [0,1,2])\nd2 (mapv get m [2,1,0])] (concat m r [d1] [d2]))) x)))))))","user":"5659679ae4b068f2fe63dbeb"},{"problem":73,"code":"(fn tic-tac-toe [xs]\n    (letfn [(win [xs]\n              (cond\n                (apply = :o xs) :o\n                (apply = :x xs) :x\n                ))]\n      (->> (map #(map (fn [k] (get-in\n                                xs k)) %)\n                (concat\n                  (partition 3 (for [i (range 3) j (range 3)] [j i]))\n                  (partition 3 (for [i (range 3) j (range 3)] [i j]))\n                  (partition 3 (for [i (range 3)] [i i]))\n                  (partition 3 (for [i (range 3)] [i (- 2 i)]))\n                  ))\n           (map win)\n           (filter #(or (= :x %) (= :o %))) \n           (first)\n           \n           ))\n    )","user":"5921a080e4b09b4ee5954c77"},{"problem":73,"code":"(fn __\n  [board]\n  (letfn [(check-seq [to-check]\n                     (if (and\n                          (=\n                           (first to-check)\n                           (second to-check)\n                           (last to-check))\n                          (not (= (first to-check) :e)))\n                       (first to-check)))\n          (check-rows [board]\n                      (or\n                       (check-seq (first board))\n                       (check-seq (second board))\n                       (check-seq (last board))))\n          (check-columns [board]\n                         (check-rows (partition 3 (apply interleave board))))\n          (check-diagonals [board]\n                           (or\n                            (check-seq [(first (first board))\n                                        (second (second board))\n                                        (last (last board))])\n                            (check-seq [(last (first board))\n                                        (second (second board))\n                                        (first (last board))])))\n          (check-winner [board]\n                        (or\n                         (check-rows board)\n                         (check-columns board)\n                         (check-diagonals board)))]\n    (check-winner board)))","user":"53ac4719e4b047364c04445c"},{"problem":73,"code":"(fn ttt [rows]\n  (let [cols (apply map vector rows)\n        diag (fn [rows] (map-indexed #(nth %2 %1) rows))\n        diags [(diag rows) (diag (map reverse rows))]\n        lines (concat rows cols diags)\n        line-sets (map set lines)]\n   (first (some #{#{:x} #{:o}} line-sets))))","user":"5532a04ee4b09218d5f44f82"},{"code":"(fn [board]\n  (let [rows board\n        cols (apply (partial map vector) rows)\n        diag1 (map (partial get-in board) '([2 0] [1 1] [0 2]))\n        diag2 (map (partial get-in board) '([0 0] [1 1] [2 2]))\n        all (-> [] (into rows) (into cols) (conj diag1 diag2))]\n    (->> all (keep #(when (apply = %) (first %))) (remove #(= :e %)) first)))","problem":73,"user":"51b38769e4b026427ecf067f"},{"code":"(fn q73 [board]\n  (letfn [\n    (check-line [code line] (every? #(= code %) line))\n    (check-hori [code board] (some identity (map #(check-line code %) board)))\n    (transpose [board] (apply map vector board))\n    (diagonal [board] [[(ffirst board) (second (second board)) (last (last board))]])\n    (check [code board]\n      (or\n        (check-hori code board)\n        (check-hori code (transpose board))\n        (check-hori code (diagonal board))\n        (check-hori code (diagonal (map #(apply vector (reverse %)) board)))))]\n    (cond (check :o board) :o \n          (check :x board) :x\n          :else nil)))","problem":73,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":73,"code":"(fn [m] \n  (letfn [(units [board]\n            (concat (for [r (range 3)] \n                      (for [c (range 3)]\n                        (get-in board [r c])))\n                    (for [c (range 3)]\n                      (for [r (range 3)]\n                        (get-in board [r c])))\n                    [(for [r (range 3)]\n                       (get-in board [r r]))]\n                    [(for [r (range 3) :let [c (- 2 r)]]\n                       (get-in board [r c]))]))]\n    (->>\n     (units m)\n     (map #(when (apply = %) (first %)))\n     (remove #(or (nil? %) (= :e %)))\n     first)))","user":"55db7e15e4b0e31453f64ae8"},{"code":"#(last (some #{#{:x} #{:o}} \n                (map set\n                     (partition 3\n                                (map (partial nth (flatten %))\n                                     [3 4 5  0 3 6  0 4 8  2 4 6])))))","problem":73,"user":"5336a339e4b0e30313ee6c7d"},{"code":"(fn [b]\n   (let [h (seq (filter #(apply = %) b))\n         v (seq (filter #(apply = %) (apply map #(list % %2 %3) b)))\n         d (seq (filter #(apply = %) [(map #(get-in b [% %]) (range 3))\n                                      (map #(get-in b [% (- 2 %)]) (range 3))]))\n         w (into #{} (concat h v d))]\n     (first (or (w [:x :x :x]) (w [:o :o :o])))))","problem":73,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":73,"code":"#(let [x (cond\n  (apply = (map first %))\n  (first (first %))\n  (apply = (map (fn [coll] (get coll 1)) %))\n  (get (first %) 1)\n  (apply = (map last %))\n  (last (first %))\n\n  (apply = (first %))\n  (first (first %))\n  (apply = (get % 1))\n  (first (get % 1))\n  (apply = (last %))\n  (first (last %))\n  \n  (apply = (list (-> % first first) (-> % (get 1) (get 1)) (-> % last last)))\n  (first (first %))\n  (apply = (list (-> % first last) (-> % (get 1) (get 1)) (-> % last first)))\n  (last (first %))\n  :else\n  nil)]\n   (if (= x :e)\n     nil\n     x))","user":"54570d08e4b080a794c2c888"},{"problem":73,"code":"(fn [table]\n  (let [e (fn [i j] (nth (nth table j) i))\n        rows table\n        columns (apply map (fn [a b c] [a b c]) table)\n        crosses [[(e 0 0) (e 1 1) (e 2 2)] [(e 2 0) (e 1 1) (e 0 2)]]\n        winning-positions (concat rows columns crosses)\n        winner (filter #(and (not= (first %) :e) (apply = %)) winning-positions)]\n    (if (empty? winner) nil\n        (first (first winner)))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(fn any-winner [board]\n  (letfn [(winner [v]\n            (cond\n             (every? #(= :x %) v)\n             :x\n\n             (every? #(= :o %) v)\n             :o\n\n             :else\n             nil))\n          (diag-winner [board]\n            (map winner\n                 [(map-indexed (fn [i b] (nth b i)) board)\n                  (map-indexed (fn [i b] (nth b (- 2 i))) board)]))\n          (rows-winner [board]\n            (map winner board))\n          (cols-winner [board]\n            (rows-winner (apply map vector board)))]\n   (first (filter identity (mapcat #(% board) [rows-winner cols-winner diag-winner])))))","problem":73,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":73,"code":"(fn [board]\n  (let [verts (apply map list board)\n        diag1 [(ffirst board) (second (second board)) (last (last board))]\n        diag2 [(last (first board)) (second (second board)) (first (last board))]\n        rows (concat board verts [diag1 diag2])]\n    (println rows)\n    (cond\n     (some #{[:x :x :x]} rows)\n     :x\n     \n     (some #{[:o :o :o]} rows)\n     :o\n     \n     :else\n     nil)))","user":"546c4c5fe4b00cfc9eacc178"},{"problem":73,"code":"(fn [input]\n  (let [board (replace {:e nil} (into [] (apply concat input)))\n        patterns [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [6 4 2]]\n        win? (fn [pattern]\n               (let [symbols (map board pattern)]\n                 (when (apply = symbols)\n                   (first symbols))))]\n    (some win? patterns)))","user":"5d80fa37e4b0915913b1d374"},{"code":"(fn [b] \n  (some\n      (comp first #{#{:o} #{:x}} set)\n      (concat b \n        (map #(map nth b [% % %]) [0 1 2])\n        (map #(map nth b %) [[0 1 2] [2 1 0]]))))","problem":73,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [x]\n  (ffirst\n   (filter\n    #(and (apply = %) (not= (first %) :e))\n    (partition 3 (map\n                  (vec (flatten x))\n                  '(0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6))))))","problem":73,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [brd]\n\t(let [rows (for [i (range 3) j (range 3)] [i j])\n\t\t\t\tcols (for [i (range 3) j (range 3)] [j i])\n\t\t\t\tldiag [[0 0][1 1][2 2]]\n\t\t\t\trdiag [[2 0][1 1][0 2]]\n\t\t\t\twinner (->> (partition 3 (concat rows cols ldiag rdiag))\n\t\t\t\t\t\t\t\t\t\t(map (fn [s] (map #(reduce get brd %) s)))\n\t\t\t\t\t\t\t\t\t\t(map set)\n\t\t\t\t\t\t\t\t\t\t(filter #(= 1 (count %)))\n\t\t\t\t\t\t\t\t\t\t(ffirst))]\n\t\t(when (and winner (not= :e winner)) winner)))","problem":73,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":73,"code":"(fn [rows]\n  (let [won?\n    (fn [player]\n      (if (some\n            (fn [row] (every? #(= player %) row))\n            (concat\n              rows\n              (partition 3 (apply interleave rows))\n              [(map nth rows (range 3))\n               (map nth rows (reverse (range 3)))]))\n          player))]\n    (or (won? :x) (won? :o))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [coll] (some {[:o :o :o] :o [:x :x :x] :x} \n        (partition 3 \n          (map \n          (vec (flatten coll))\n           [0 1 2 3 4 5 6 7 8\n            0 3 6 1 4 7 2 5 8 \n            0 4 8 2 4 6]))))","problem":73,"user":"50b47c46e4b0c464d223d1b8"},{"problem":73,"code":"(fn t15 [[a b c]]\n  (let [f_rx #(= :x %)\n        f_ro #(= :o %)]\n    (cond\n      (or (every? f_rx a) (every? f_rx b) (every? f_rx c)) :x\n      (or (every? f_ro a) (every? f_ro b) (every? f_ro c)) :o\n      (and (= (nth a 0) :x) (= (nth b 0) :x) (= (nth c 0) :x)) :x\n      (and (= (nth a 1) :x) (= (nth b 1) :x) (= (nth c 1) :x)) :x\n      (and (= (nth a 2) :x) (= (nth b 2) :x) (= (nth c 2) :x)) :x\n      (and (= (nth a 0) :o) (= (nth b 0) :o) (= (nth c 0) :o)) :o\n      (and (= (nth a 1) :o) (= (nth b 1) :o) (= (nth c 1) :o)) :o\n      (and (= (nth a 2) :o) (= (nth b 2) :o) (= (nth c 2) :o)) :o\n      (and (= (nth a 0) :x) (= (nth b 1) :x) (= (nth c 2) :x)) :x\n      (and (= (nth a 2) :x) (= (nth b 1) :x) (= (nth c 0) :x)) :x\n      (and (= (nth a 0) :o) (= (nth b 1) :o) (= (nth c 2) :o)) :o\n      (and (= (nth a 2) :o) (= (nth b 1) :o) (= (nth c 0) :o)) :o\n      :else nil)))","user":"5046f909e4b03b02161376b5"},{"code":"(fn [s]\r\n  (let [test-line (fn [s]\r\n                    (let [ds (distinct s)]\r\n                      (when (= 1 (count ds))\r\n                        (when-let [res (first ds)]\r\n                          (when-not (= :e res)\r\n                            res)))))\r\n        test-lines (fn [s] (some test-line s))\r\n        transpon (partition (count s) (apply interleave s))\r\n        get-diagonal (fn [s]\r\n                       ((fn [s n res]\r\n                          (if-let [[x & xs] s]\r\n                            (recur xs (inc n) (cons (nth x n) res))\r\n                            res)) s 0 nil))\r\n        main-diag (get-diagonal s)\r\n        back-diag (get-diagonal (map reverse s))]\r\n    (test-lines (concat (cons main-diag s) (cons back-diag transpon)))))","problem":73,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":73,"code":"(fn [board]\n   (let [rows board\n         cols (apply (partial map list) board)\n         cross (for [i (range (count board))] (nth (nth board i) i))  \n         back-cross (for [i (range (count board))] (nth (nth board i) (- (dec (count board)) i)))\n         all (concat rows cols [cross back-cross])]\n    (first (first (filter \n                    #(or (= #{:o} (set %)) (= #{:x} (set %)))\n                    all)))))","user":"57a8eba2e4b0a96607956225"},{"problem":73,"code":"(fn [board]\n  (let [size (count board)]\n    (->> (concat board (apply map vector board)\n                 [(map-indexed #(nth %2 (- size %1 1)) board)\n                  (map-indexed #(nth %2 %1) board)])\n         (filter #(and (not= (first %) :e) (apply = %)))\n         ffirst)))","user":"539c54b3e4b0b51d73faaf27"},{"problem":73,"code":"(fn winner [m]\n  (let [\n        rotate-matrix (fn [m] (apply map list m))\n        lines (fn [m] (concat m\n                            (rotate-matrix m)\n                            [(map-indexed #(nth %2 %1) m)\n                             (map-indexed #(nth %2 (- 2 %1)) m)]))]\n   (->> (lines m)\n        (map distinct)\n        (filter #(= 1 (count %)))\n        (filter #(not (= :e (first %))))\n        (first)\n        (first))))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":73,"code":"(fn\n  [c]\n  (let [b (flatten c)\n        al (for [l [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n                  (map #(nth b %) l))\n        r (filter #(not= % :e) (map first (filter #(apply = %) al)))]\n    (if (empty? r)\n      nil\n      (first r))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [board]\r\n  (letfn [(access   [x y]\r\n            (nth (nth board x) y))\r\n          (access-c [z]\r\n            (access (first z) (second z)))\r\n          (normal-or [& xs]\r\n            (cond (empty? xs) nil\r\n                  (first xs) (first xs)\r\n                  :else (recur (rest xs))))\r\n          (ex-equal [& xs]\r\n            (if (and (apply = xs)\r\n                     (not= (first xs) :e))\r\n              (first xs) nil))]\r\n    (apply normal-or \r\n           (map (fn [rule] (apply ex-equal (map access-c rule)))\r\n                  '(((0 0) (0 1) (0 2)) ((1 0) (1 1) (1 2)) ((2 0) (2 1) (2 2))\r\n                    ((0 0) (1 0) (2 0)) ((0 1) (1 1) (2 1)) ((0 2) (1 2) (2 2))\r\n                    ((0 0) (1 1) (2 2)) ((2 0) (1 1) (0 2)))))\r\n    )\r\n  )","problem":73,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [board] (let [rfn (partial map (partial apply list)) \n                  cfn (partial apply map list) \n                  pfn (fn [r1 r2 board] (list (map (fn [[i1 i2]] (-> board (nth i1) (nth i2))) \n                                             (apply map vector (list r1 r2)))))\n                  enil (fn [k] (if (= :e k) nil k))]\n              (enil (ffirst (drop-while (partial apply not=) \n                          (concat (rfn board) (cfn board) \n                                  (pfn (range 3) (range 3) board) \n                                  (pfn (range 3) (range 2 -1 -1) board)))))))","problem":73,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn [b] \r\n (some (fn [v] (if (apply = v) (last v)))\r\n  (map #(map (partial nth (replace {:e nil} (flatten b))) %)\r\n    [[0 3 6] [1 4 7] [2 5 8] [0 1 2] [3 4 5] [6 7 8] [0 4 8] [2 4 6]])))","problem":73,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":73,"code":"(fn [board]\n  (let [row1 first\n        row2 (comp first rest)\n        row3 last\n        column1 (partial map first)\n        column2 (partial map (comp first rest))\n        column3 (partial map last)\n        diag1 (juxt (comp row1 column1) (comp row2 column2) (comp row3 column3))\n        diag2 (juxt (comp row1 column3) (comp row2 column2) (comp row3 column1))\n        winning (( juxt row1 row2 row3 column1 column2 column3 diag1 diag2) board)]\n    (cond\n      (some #(= [:x :x :x] %) winning) :x\n      (some #(= [:o :o :o] %) winning) :o\n      :otherwise nil)))","user":"5d97b602e4b0d3f9b434ad3a"},{"code":"(fn [[[a b c :as x] [d e f :as y] [g h i :as z]]]\n  (ffirst\n    (filter\n      #(and (not-any? #{:e} %) (apply = %))\n      [x y z [a d g] [b e h] [c f i] [a e i] [c e g]])))","problem":73,"user":"51b3f109e4b0f094dd986fa9"},{"code":"(fn [s] (let [lines (concat (map #(map (fn [a] [% a]) (range 3)) (range 3)) (map #(map (fn [a] [a %]) (range 3)) (range 3)) [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]])]\n                (ffirst (filter #(and (= 1 (count %)) (or (= :x (first %)) (= :o (first %)))) (map (fn [a] (set (map #(get-in s [(first %) (second %)]) a))) lines)))))","problem":73,"user":"52c1bd29e4b07a9af579236a"},{"problem":73,"code":"(fn tic-tac [a]\n  (let [xy [[[0 0] [1 0] [2 0]]\n            [[0 1] [1 1] [2 1]]\n            [[0 2] [1 2] [2 2]]\n            [[0 0] [0 1] [0 2]]\n            [[1 0] [1 1] [1 2]]\n            [[2 0] [2 1] [2 2]]\n            [[0 0] [1 1] [2 2]]\n            [[2 0] [1 1] [0 2]]]\n        xs [:x :x :x]\n        os [:o :o :o]\n        path (fn [a p] (map #(let [[x y] %] ((a x) y)) p))]\n    (cond\n      (some #(= xs (path a %)) xy) :x\n      (some #(= os (path a %)) xy) :o\n      :else nil)))","user":"58fc92c5e4b0438e51c2cf9a"},{"code":"(fn [mtrx]\n  (letfn [(transpose [mtrx] (apply map vector mtrx))\n          (diagonalize1 [mtrx] [[(ffirst mtrx) (second (second mtrx)) (last (last mtrx))]])\n          (diagonalize2 [mtrx] [[(last (first mtrx)) (second (second mtrx)) (first (last mtrx))]])\n          (find-winner [f mtrx] (for [row (f mtrx) player [:x :o] :when (apply = (conj row player))] player))]\n    (let [winner (apply clojure.set/union (map #(find-winner % mtrx) [identity transpose diagonalize1 diagonalize2]))]\n      (if (empty? winner) nil (first winner)))))","problem":73,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"problem":73,"code":"(fn [board]\n  (let [\n        board (into [] (apply concat board)) ; [ [a b c] [...] [...] ] => [ a b c ... ... ]\n        game-won? (fn [board [x & xs]] (reduce #(if (= % (board %2)) % :e) (board x) xs))\n        ]\n    (first (filter #(not= :e %) \n                   (map \n                     #(game-won? board %)\n                     [ [0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6] ])))))\n\n; first solution\n#_(fn [board]\n  (letfn\n    [\n     (offset-to-pos [offset]\n                    [(rem offset 3) (quot offset 3)])\n     (get-player [board offset]\n                 (let [player (get-in board (offset-to-pos offset))] (if (= player :e) nil player)))\n     (game-won? [board [offset1 & offsets]]\n                (if-let [player (get-player board offset1)]\n                  (reduce #(if (= % (get-player board %2)) % nil) player offsets)\n                  nil))\n     ]\n    (first (filter #(not= nil %) \n            (map \n              #(game-won? board %)\n              [ [0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6] ])))))","user":"55e7d06ee4b050e68259b496"},{"code":"(fn [s]\n  (let [c1 (vector (first (first s)) (first (second s)) (first (nth s 2)))\n        c2 (vector (second (first s)) (second (second s)) (second (nth s 2)))\n        c3 (vector (nth (first s) 2) (nth (second s) 2) (nth (nth s 2) 2))\n        d1 (vector (first (first s)) (second (second s)) (nth (nth s 2) 2))\n        d2 (vector (nth (first s) 2) (second (second s)) (first (nth s 2)))\n        p (hash-map :l1 (first s) :l2 (second s) :l3 (nth s 2) :c1 c1 :c2 c2 :c3 c3 :d1 d1 :d2 d2)\n        e [:l1 :l2 :l3 :c1 :c2 :c3 :d1 :d2]]\n    (last\n     (sort\n      (for [x e]\n        (if (= (get p x) [:o :o :o])\n          :o\n          (if (= (get p x) [:x :x :x])\n            :x\n            nil)))))))","problem":73,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn [board]\n  (letfn [(columns [b] (apply map vector b))\n          (lrdiag [b] (map #(nth (nth b %) %) (-> b count range)))\n          (rldiag [b] (map #(nth (nth b %) (-' (count b) % 1)) (-> b count range)))\n          (winner-slice [r]\n            (cond\n             (not (every? #(= (first r) %) r)) nil\n             (= (first r) :e) nil\n             :else (first r)))\n          (all-slices [b] (concat b (columns b) [(lrdiag b)] [(rldiag b)]))\n          (winner [b] (first (remove nil? (map winner-slice (all-slices b)))))]\n    (winner board)))","problem":73,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn  [board]\n  (let [verticals (apply map vector board)\n        diagonals (apply (partial map vector) (for [i [0 1 2]] [(get-in board [i i]) (get-in board [i (- 2 i)])]))\n        check-lines (map distinct (concat board verticals diagonals))\n        winner-cond (filter #{[:x] [:o]} check-lines)]\n    (cond\n     (= winner-cond [[:x]]) :x\n     (= winner-cond [[:o]]) :o\n     :else nil)))","problem":73,"user":"53691dc7e4b0243289761e97"},{"code":"(fn ttt [b]\n  (let [get-square (fn [r c] (nth (nth b r) c))\n        get-row (fn [r] (nth b r))\n        get-col (fn [c] (for [r (range 3)] (get-square r c)))\n        rows-cols (mapcat (fn [x] (list (get-row x) (get-col x))) (range 3))\n        diag-1 (list (get-square 0 0) (get-square 1 1) (get-square 2 2))\n        diag-2 (list (get-square 0 2) (get-square 1 1) (get-square 2 0))\n        all (conj rows-cols diag-1 diag-2)]\n    (->> all (remove (fn [x] (some #{:e} x))) (filter (fn [x] (apply = x))) ffirst)))","problem":73,"user":"50783762e4b0fc74642bff67"},{"code":"(fn who-win [score board]\n  (cond\n    (score :x board) :x\n    (score :o board) :o\n    :else            nil))\n\n(fn score [who board]\n  (letfn [(nths [[i j]] (nth (nth board i) j))\n          (win? [line] (every? #(= % who) line))]\n    (some win?\n      (concat\n        board\n        (apply map list board)\n        (map #(map nths %) [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]])))))","problem":73,"user":"500933a6e4b046cdb195e074"},{"code":"(fn [board]\n  (let [[[a b c][d e f][g h i]] board \n        win-test (fn [p]\n                   (when (or (= p a b c) (= p d e f) (= p g h i) \n                             (= p a d g) (= p b e h) (= p c f i)\n                             (= p a e i) (= p c e g))\n                      p))]\n      (if (win-test :x)\n         :x\n         (win-test :o))))","problem":73,"user":"4ffa213ee4b0678c553fc3b7"},{"code":"(fn analyze [rows]\n(let [analyze-row (fn [row] \n  (let [x [:x] o [:o]\n        result (distinct row)]\n    (when (or (= result x)\n              (= result o))\n      (first result))))\n      flatten (fn [rows]\n   (concat \n        (map #(nth rows %) (range 3))\n        (map (fn [x]\n               (map #(nth % x) rows)) (range 3))\n    \n    \t\t((fn take-diagonals ([rows]\n   (list (take-diagonals 0 + rows)\n         (take-diagonals 2 - rows)))\n  ([n f [row & rows]]\n  (if rows\n  \t(conj \n     (take-diagonals (f n 1) f rows) \n     (nth row n))\n    (list (nth row n))))) rows)))]\n  (last (sort (distinct\n   (map analyze-row (flatten rows)))))))","problem":73,"user":"4fe15ffee4b0dd6cd5ce3634"},{"problem":73,"code":"(fn [coll]  (first (first (filter #(and (not (contains? % :e)) (= (count %) 1))\n                      (map set\n                           (concat\n                             coll\n                             (apply map vector coll)\n                             (loop [i 0 c coll diags [[] []]]\n                               (if (> i 2) diags\n                                           (recur (inc i) (rest c) [(conj (first diags) (get (first c) i))\n                                                          (conj (second diags) (get (first c) (- 2 i)))]))))\n              )))))","user":"56f15eade4b04a395b9a048e"},{"problem":73,"code":"(fn [board]\n  (some\n    #(and (apply = %) (#{:o :x} (first %)))\n    (conj\n      (concat board (apply map list board))\n      (map-indexed #(nth %2 %1) board)\n      (map-indexed #(nth %2 (- 2 %1)) board))))","user":"4fb1d7ace4b081705acca281"},{"code":"(fn [board]\n  (let [middle-square (get-in board [1 1])\n        tl-br [(get-in board [0 0]) middle-square (get-in board [2 2])]\n        tr-bl [(get-in board [0 2]) middle-square (get-in board [2 0])]\n        inarow (concat board (apply map vector board) [tl-br tr-bl])]\n    (first (filter #(if (= % :e) nil %) (map (fn [s] (reduce #(if (= %1 %2) %1 nil) s)) inarow)))))","problem":73,"user":"50bd6033e4b0594b91591c66"},{"problem":73,"code":"(fn analyze-t-t-t [[x1 x2 x3 :as b]]\n  (letfn [(check-row [row]\n  (when (apply = row)\n    (first row)))]\n  (let [t  (apply mapv vector b)\n        d1 (map-indexed #(get %2 %1) b)\n        d2 (vector (last x1) (second x2) (first x3))\n        [r1 r2 r3] t]\n    (first\n     (remove #(or (nil? %) (= :e %))\n             (map check-row\n                  (conj b r1 r2 r3 d1 d2)))))))","user":"56504dc2e4b0284900eef6bc"},{"problem":73,"code":"(fn [b] \n  (let [r (partition 3 \n                     (concat\n                        (for [x (range 9)\n                              :let [y (mod x 3)]\n                              :let [z (mod (int (/ x 3)) 3)]]\n                            [z y])\n                        (for [x (range 9)\n                              :let [y (mod x 3)]\n                              :let [z (mod (int (/ x 3)) 3)]]\n                            [y z])\n                        [[0 0] [1 1] [2 2] [2 0] [1 1] [0 2]] \n            ))\n        w (reduce (fn [v i]\n              (if (not (= :e v))\n                v\n                (if (= (get-in b (first i))\n                       (get-in b (second i)) \n                       (get-in b (last i)))\n                  (get-in b (first i))\n                  :e\n                )\n              )\n            )\n            :e\n            r)]\n    (if (= :e w)\n      nil\n      w\n    )\n  )\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"code":"(fn win? [b]\n  (let [wins [[0 1 2] [3 4 5] [6 7 8]\n              [0 3 6] [1 4 7] [2 5 8]\n              [0 4 8] [2 4 6]]\n        fb (vec (apply concat b))\n        c (for [v wins] (map fb v))]\n    (cond\n     (some (partial = '(:x :x :x)) c) :x\n     (some (partial = '(:o :o :o)) c) :o\n     )))","problem":73,"user":"52ba43d0e4b07a9af57922cd"},{"problem":73,"code":"(fn [board] \n\t(ffirst (filter (fn single-player? [line-players] (or (= '(:x) line-players) (= '(:o) line-players))) (map (fn line-players [row] (distinct (map (fn [index] (nth (flatten board) index)) row))) [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]))))","user":"53fcd574e4b0de5c418485d9"},{"problem":73,"code":"(fn foo [ttt]\n  (let [rows (fn [b] b)\n        cols (fn [board]\n               (loop [res [] b board]\n                 (if (empty? (first b))\n                   res\n                   (recur (conj res (map first b)) (map rest b)))))\n        diags (fn [board]\n                (let [i (fn [x y] (nth (nth board y) x))]\n                  [[(i 0 0) (i 1 1) (i 2 2)]\n                   [(i 0 2) (i 1 1) (i 2 0)]]))\n        paths (concat (rows ttt) (cols ttt) (diags ttt))]\n    (cond\n     (some (fn [path] (every? #(= :x %) path)) paths) :x\n     (some (fn [path] (every? #(= :o %) path)) paths) :o\n     :else nil)))","user":"531bad96e4b08068f379ed93"},{"problem":73,"code":"(fn winner [board]\n  (let [diagonal (fn [b] [(first (first b)) (second (second b)) (last (last b))])\n        transpose (fn [m] (apply map (comp reverse list) m))\n        transposed (transpose board)\n        diagonals [(diagonal board) (diagonal transposed)]\n        plays (filter (fn [r] (not-every? #(= :e %) r)) (concat board transposed diagonals))]\n    (cond\n     (empty? plays) nil \n     :else (some #(if (apply = %) (first %)) plays))))","user":"602d5eade4b0d5df2af22279"},{"problem":73,"code":"(fn tic-tac-toe [board]\n     (let [twisted (apply map vector board)\n           diagonales ((fn [[a b c]] [[(first a) (second b) (last c )] [(first c) (second b) (last a )]]) board)\n           result (concat board twisted diagonales)]\n       (if (some (fn [x] (= [:x :x :x] x)) result)\n           :x\n           (if (some (fn [y](= [:o :o :o] y)) result)\n               :o\n               nil\n           ))))","user":"549b1e50e4b0f3d1d8e70f7a"},{"code":"(fn winner [board] (let [col (apply mapv (fn [& xs] (vec xs)) board)\n                  diag [(mapv nth board (range))\n                        (mapv nth board (range 2 -1 -1))]\n                  all (concat board col diag)]\n              (cond\n               (some #(= [:x :x :x] %) all) :x\n               (some #(= [:o :o :o] %) all) :o\n               :else nil)))","problem":73,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [[[a1 a2 a3 :as a] [b1 b2 b3 :as b] [c1 c2 c3 :as c]]]\n  (let [winner (fn [x] (if (and (apply = x) (not= (first x) :e)) (first x) nil))\n        r1 [a1 b1 c1]\n        r2 [a2 b2 c2]\n        r3 [a3 b3 c3]\n        d1 [a1 b2 c3]\n        d2 [a3 b2 c1]]\n    (reduce (fn [a b] (if a a b)) (map winner [a b c r1 r2 r3 d1 d2]))))","problem":73,"user":"5110b8bae4b04c71fce993f4"},{"code":"(fn [board]\n  (let [wins [[[0 1] [0 0] [0 2]]\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]]\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]]]\n        three-in-rows (map #(map (partial get-in board) %) wins)]\n    (some {[:x :x :x] :x, [:o :o :o] :o} three-in-rows)))","problem":73,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n   (letfn [(check [player]\n             (or\n              (= player a b c)\n              (= player a e i)\n              (= player a d g)\n              (= player b e h)\n              (= player c f i)\n              (= player c e g)\n              (= player d e f)\n              (= player g h i)))]\n     (cond (check :x) :x\n           (check :o) :o\n           :else nil)))","user":"57f80350e4b0d3187e90090c"},{"problem":73,"code":"(fn analyze-Tic-Tac-Toe [board] \n  (let \n    [result-vectors '([[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n                      [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]\n                      [[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]])\n     result-vectors-from-board (map (fn [v] (map #(get-in board %) v)) result-vectors)]\n    (some {'(:x :x :x) :x '(:o :o :o) :o} result-vectors-from-board)))","user":"53f35c34e4b0742d9025b0f4"},{"problem":73,"code":"(fn [t]\n   (some (fn [r]\n           (let [f (first r)]\n             (and\n               (and (not= f :e)\n                    (every? #(= f %) r))\n               f)))\n         (concat t\n                 (partition (count t) (apply interleave t))\n                 (map\n                   #(take-nth (inc (count t)) (flatten %))\n                   [t (map reverse t)]))))","user":"57d9f603e4b0bd073c20240a"},{"problem":73,"code":"(fn check-win [board]\n  (let [valid-wins [[[0 0] [0 1] [0 2]]\n                    [[1 0] [1 1] [1 2]]\n                    [[2 0] [2 1] [2 2]]\n\n                    [[0 0] [1 0] [2 0]]\n                    [[0 1] [1 1] [2 1]]\n                    [[0 2] [1 2] [2 2]]\n\n                    [[0 0] [1 1] [2 2]]\n                    [[0 2] [1 1] [2 0]]]]\n    (some \n     (fn [win] (let [l (for [pos win] (get-in board pos))\n                     p (first l)]\n                 (when (and (apply = l)\n                            (not= :e p))\n                   p))) \n     valid-wins)))","user":"523578efe4b0a643f2dcb74c"},{"code":"(fn [v] \n (let [indexes \n       (apply concat \n        (apply mapv vector\n          (for [x (range 3) y (range 3)]\n            [[x y] [y x] [x x] [(- 2 x) x]])))]\n  (ffirst\n    (filter #(and (= (count %) 1) (not (= [:e] (vec %))))\n      (map distinct \n        (partition 3\n          (for [[i j]\n                (concat\n                  (take 18 indexes)\n                  (take-nth 3 (take-last 18 indexes)))] \n            ((v i) j))))))))","problem":73,"user":"515b03fee4b0a102a3e5262a"},{"problem":73,"code":"(fn [board]\n   (let [three-on-a-row (fn [row]\n                          (if (some #(= 3 %) (vals (frequencies row)))\n                            (if (= :e (first row))\n                              nil ; row is :e :e :e\n                              (first row))\n                            nil))\n         all-dirs (fn [board]\n                    (-> board ; all rows\n                        (concat (apply map vector board)) ; all columns\n                        (conj (map get board [0 1 2]) (map get board [2 1 0]))))] ; both diagonals\n     (first (filter #(not (nil? %)) (map three-on-a-row (all-dirs board))))))","user":"5617db88e4b06b1bb2182a16"},{"code":"(fn [board]\n  (let\n    [flipped (apply map vector board)\n     diagonal (map-indexed #(get %2 %1) board)\n     diagonal2 (map-indexed #(get %2 (- 2 %1)) board)\n     all (concat board flipped [diagonal diagonal2])]\n    (cond\n      (some (partial = [:x :x :x]) all) :x\n      (some (partial = [:o :o :o]) all) :o\n      :else nil\n    )))","problem":73,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn [board]\n  (let [rows (fn [board] board)\n        cols (fn [board] (apply mapv vector board))\n        diags (fn [board]\n                  (let [cell (fn [[x y]] ((board x) y))]\n    [(map cell [[0 0] [1 1] [2 2]])\n     (map cell [[0 2] [1 1] [2 0]])]))\n\n        eval-row (fn [row]\n                   (let [row (set row)]\n                    (cond\n                     (= row #{:x}) :x\n                     (= row #{:o}) :o\n                     :else :e)))\n        evals (map eval-row\n                   (concat (rows board)\n                   (cols board)\n                   (diags board)))\n        check-winner #(or (= :x %) (= :o %))\n        possible-winners (filter check-winner evals)]\n    (cond\n     (empty? possible-winners) nil\n     :else (first possible-winners))))","problem":73,"user":"52e6351ae4b09f7907dd146e"},{"code":"(fn [b]\n    (let\n      [board     (map #(replace {:e nil} %) b)\n       rows      board\n       columns   (partition 3 (apply interleave board))\n       diagonals (let [[[a b c] [d e f] [g h i]] board] [[a e i] [c e g]])\n       winner    (fn [lanes] (first (first (filter #(apply = %) lanes))))]\n    (winner (concat rows columns diagonals))))","problem":73,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn [sq] (letfn [ (rows [rectangle] rectangle) (columns [rectangle] (apply map vector rectangle)) (nth1 [coll n] (nth coll (dec n))) (range1 [from to] (range from (inc to))) (value-at [sq pos] (nth1 (nth1 sq (second pos)) (first pos))) (pair-range [from to] (map vector (range1 from to) (reverse (range1 from to)))) (diagonal [sq from to] (map #(value-at sq %) (pair-range from to))) (diagonal-sw-ne [sq] (map #(value-at sq %) (pair-range 1 (count sq)))) (diagonal-nw-se [sq] (map #(value-at sq %) (map #(vector % %) (range1 1 (count sq))))) (main-diagonals [sq] (vector (diagonal-nw-se sq) (diagonal-sw-ne sq))) (main-lines [sq] (concat (rows sq) (columns sq) (main-diagonals sq))) (tic-tac-toe [sq] (let [winning-lines (filter #(or (= [:x :x :x] %) (= [:o :o :o] %)) (main-lines sq))] (cond (empty? winning-lines) nil (= (first winning-lines) [:x :x :x]) :x (= (first winning-lines) [:o :o :o]) :o))) ] (tic-tac-toe sq)))","problem":73,"user":"52f10094e4b05e3f0be25ee8"},{"problem":73,"code":"(fn [[a b c]]\n  (letfn \n    [\n      (w [t] (ffirst (filter #(apply not= (cons :e %)) (filter #(apply = %) t))))\n    ]\n    (w \n      (concat\n        [a b c] [[(nth a 0) (nth b 1) (nth c 2)]] [[(nth a 2) (nth b 1) (nth c 0)]]\n        (reduce\n          (fn [r x]\n            (map #(apply cons %) (partition 2 (interleave x r)))  \n          )\n          [[] [] []]\n          [a b c]\n        )\n      )\n    )\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [b]\n  (let [c1 [(vec (map first b))]\n        c2 [(vec (map second b))]\n        c3 [(vec (map last b))]\n        d1 [[(first (first b)) (second (second b)) (last (last b))]]\n        d2 [[(last (first b)) (second (second b)) (first (last b))]]]\n    (let [a (remove #(= :e %) (map first (filter #(apply = %) (reduce into [b c1 c2 c3 d1 d2]))))]\n      (if (empty? a)\n        nil\n        (first a)))))","problem":73,"user":"50843a4ae4b0c98812d0788b"},{"code":"(fn [game]\n  (let [subtask\n    (fn [col]\n      (cond (every? #(= :x %) col) :x\n            (every? #(= :o %) col) :o\n            true nil\n      )\n    )\n    transposed (apply mapv vector game)\n    diag1 [(-> game first first) (-> game second second) (-> game last last)]\n    diag2 [(-> game first last) (-> game second second) (-> game last first)]\n        ]\n    (cond (not= nil (subtask (first game))) (subtask (first game))\n          (not= nil (subtask (second game))) (subtask (second game))\n          (not= nil (subtask (last game))) (subtask (last game))\n          (not= nil (subtask (first transposed))) (subtask (first transposed))\n          (not= nil (subtask (second transposed))) (subtask (second transposed))\n          (not= nil (subtask (last transposed))) (subtask (last transposed))\n          (not= nil (subtask diag1)) (subtask diag1)\n          (not= nil (subtask diag2)) (subtask diag2)\n          true nil\n    )\n )\n)","problem":73,"user":"4f7683dae4b0fbe0118ec56f"},{"problem":73,"code":"(fn ttt\n      ([b] (cond (true? (ttt b :x)) :x\n                 (true? (ttt b :o)) :o\n                 :else nil))\n      ([b l & signal]\n                      (or (some true? (map #(apply = l (nth b %)) [0 1 2]))\n                          (if (nil? signal) (ttt (apply map list b) l :stop) false)\n                          (not (some false? (map #(= l (nth (nth b %) %)) [0 1 2])))\n                          (not (some false? (map #(= l (nth (nth b %1) %2)) [0 1 2] [2 1 0]))))))","user":"5acd1a43e4b0e27600da7823"},{"code":"(fn [b]\n  (letfn [(transp [] (apply map vector b))\n          (row? [r p] (every? #(= % p) r))\n          (diag [f] (map #(nth (f (nth b %)) %) (range 0 3)))\n          (hor? [b p] (some #(row? % p) b))\n          (ver? [p] (hor? (transp) p))\n          (diag? [p] (hor? [(diag identity) (diag reverse)] p))\n          (win? [p] (or (hor? b p) (ver? p) (diag? p)))]\n    (cond (win? :x) :x\n          (win? :o) :o\n          :else nil)))","problem":73,"user":"50acbd15e4b071b89ef26234"},{"problem":73,"code":"(fn [ttt]\n         (let [lines ttt\n               cols  (apply map (fn [a b c] [a b c]) ttt)\n               diags [(for [i (range 3)]\n                        (get (get ttt i) i))\n                      (for [i (range 3)]\n                        (get (get ttt i) (- 2 i)))]\n               all (concat lines cols diags)]\n           (some (fn [line] (cond\n                              (every? #(= :x %) line) :x\n                              (every? #(= :o %) line) :o)) all)))","user":"5f7600ffe4b02876ed9fd0ac"},{"problem":73,"code":"(fn [d]\n  (let [n (count d)\n        f (fn [d s e st] (mapv get d (range s e st)))\n        diag [(f d 0 (inc n) 1) (f d (dec n) -1 -1)] \n        all (concat d diag (apply map vector d))]\n        (->> (filter #(#{[:x :x :x] [:o :o :o]} %) all)\n             (first)\n             (first))))","user":"55f9b2b6e4b03cbcff9738c8"},{"code":"(fn [rows]\n  (let [size (range (count rows))\n        cols (apply (partial map vector) rows)\n        diags [(map nth rows size)\n               (map nth rows (reverse size))]\n        winner? #(or (every? #{:x} %)\n                     (every? #{:o} %))]\n    (->> (concat rows cols diags)\n         (filter winner?)\n         (ffirst))))","problem":73,"user":"4f45c72be4b0d56e7bb92b8a"},{"problem":73,"code":"#(letfn [(check [? [[a b c] [d e f] [g h i]]]\n                 (or (= a b c ?)\n                     (= d e f ?)\n                     (= g h i ?)\n                     (= a d g ?)\n                     (= b e h ?)\n                     (= c f i ?)\n                     (= a e i ?)\n                     (= c e g ?)))]\n  (cond\n     (check :x %) :x\n     (check :o %) :o\n     :else nil))\n\n#_(fn [g]\n  (letfn\n   [(check-h [m g] (some true? (for [y [0 1 2]] (every? true? (map #(= m %) (for [x [0 1 2]] (get-in g [y x])))))))\n    (check-v [m g] (some true? (for [y [0 1 2]] (every? true? (map #(= m %) (for [x [0 1 2]] (get-in g [x y])))))))\n    (check-d1 [m g] (every? true? (map #(= m %) (for [x [0 1 2]] (get-in g [x x])))))\n    (check-d2 [m g] (every? true? (map #(= m %) (for [x [0 1 2]] (get-in g [x (- 2 x)])))))\n    (check-all [m g] (some true? [(check-h m g)\n                                  (check-v m g)\n                                  (check-d1 m g)\n                                  (check-d2 m g)]))]\n    (cond\n      (check-all :x g) :x\n      (check-all :o g) :o\n      :else nil)))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":73,"code":"(fn [[row1 row2 row3]]\n  (let [diag1 [(row1 0) (row2 1) (row3 2)]\n        diag2 [(row1 2) (row2 1) (row3 0)]\n        col1 [(row1 0) (row2 0) (row3 0)]\n        col2 [(row1 1) (row2 1) (row3 1)]\n        col3 [(row1 2) (row2 2) (row3 2)]\n        checks [diag1 diag2 row1 row2 row3 col1 col2 col3]\n        results (first (sort-by count (map distinct checks)))]\n\t(if (= 1 (count results))\n      (if (= (first results) :e)\n        nil\n\t\t(first results))\n      nil)))","user":"5658d775e4b00d3155796114"},{"problem":73,"code":"(fn [t]\n  (let\n      [c1 (map first t)\n       c2 (map second t)\n       c3 (map last t)\n       tra1 (map #(get-in t %) [[0 0] [1 1] [2 2]])\n       tra2 (map #(get-in t %) [[0 2] [1 1] [2 0]])\n       t (conj t c1 c2 c3 tra1 tra2)]\n    (some #(if (or\n                (= :e (first %))\n                (< 1 (count (distinct %))))\n             nil\n             (first %)) t)))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":73,"code":"(fn [b]\n  (let [v #((b %) %2)\n        d [0 1 2]]\n    (some {[:x :x :x] :x [:o :o :o] :o}\n          (concat\n            b\n            (apply map list b)\n            [(map v d d) (map v d [2 1 0])]))))","user":"4eb70649535d7eef30807373"},{"code":"(fn [colls]\n\t(let [\n\t\tmp (fn [k] (map (fn [coll] (map #(when (= k %) %) coll)) colls))\n\t\tcheck \n\t\t  (fn [colls] (or\n\t\t\t(reduce #(or % %2) (map #(reduce (fn [x y] (and x y)) %) colls))\n\t\t\t(reduce #(or % %2) (apply (partial map #(and % %2 %3)) colls))\n\t\t\t(and (first (first colls)) (second (second colls)) (last (last colls)))\n\t\t\t(and (last (first colls)) (second (second colls)) (first (last colls)))\n\t\t\t))]\n\t\t(or (check (mp :x)) (check (mp :o)))))","problem":73,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn [field] \n  (let [row-win? (fn [r] (let [sym (first r)] (if (and (= r [sym sym sym]) (not= :e sym)) sym nil)))\n        dia         (for [k (range 0 3)] (nth (nth field k) k))\n        dia_reverse (for [k (range 0 3)] (nth (nth field k) (- 2 k)))\n        horizontals (partition 3 (apply interleave field))\n        evaluated (map row-win? (apply conj field dia dia_reverse horizontals))]\n  \t\t(cond (some #{:o} evaluated) :o\n              (some #{:x} evaluated) :x\n              :else nil )\n  ))","problem":73,"user":"4f58d922e4b0a7574ea71857"},{"problem":73,"code":"(fn tctc [miza]\n  ;;(#(if % % :e)\n  (let [fm (flatten miza)]\n    (some\n     (fn [t] (cond (every? #(= :x %) t) :x (every? #(= :o %) t) :o :else false))\n     (concat miza\n             ((fn [n sekv] (->> sekv\n                                (partition n)\n                                (apply interleave)\n                                (partition (int (/ (count sekv) n)))))\n              3 fm)\n             [[(nth fm 0) (nth fm 4) (nth fm 8)] [(nth fm 2) (nth fm 4) (nth fm 6)]]\n             ))))","user":"584d99c5e4b0b7285a6f4e42"},{"problem":73,"code":"(fn tic-tac-toe [m]\n  (let [d (-> (flatten m) ((juxt first #(nth % 4) last)))\n        t (apply mapv vector m)\n        d2 (-> (flatten m) ((juxt #(nth % 2) #(nth % 4) #(nth % 6))))\n        a (map frequencies (concat m [d] t [d2]))\n        b (map (fn [x] (ffirst (filter #( = 3 (val %)) x))) a)\n        ]\n    (if (some #(= :x %) (distinct b))\n       :x\n       (if (some #(= :o %) (distinct b))\n         :o))\n    \n))","user":"4f6ba7bce4b07046d9f4efb0"},{"code":"(fn [board]\n   ;horizontal\n   (letfn [(get [x y]\n                (nth (nth board y) x))]\n   (cond\n      (and (not= (get 0 0) :e) (= (get 0 0) (get 0 1) (get 0 2))) (get 0 0)\n      (and (not= (get 1 0) :e) (= (get 1 0) (get 1 1) (get 1 2))) (get 1 0)\n      (and (not= (get 2 0) :e) (= (get 2 0) (get 2 1) (get 2 2))) (get 2 0)\n      (and (not= (get 0 0) :e) (= (get 0 0) (get 1 0) (get 2 0))) (get 0 0)\n      (and (not= (get 0 1) :e) (= (get 0 1) (get 1 1) (get 2 1))) (get 0 1)\n      (and (not= (get 0 2) :e) (= (get 0 2) (get 1 2) (get 2 2))) (get 0 2)\n      (and (not= (get 0 0) :e) (= (get 0 0) (get 1 1) (get 2 2))) (get 0 0)\n      (and (not= (get 0 2) :e) (= (get 0 2) (get 1 1) (get 2 0))) (get 0 2)\n       :else nil\n   )))","problem":73,"user":"50bfe725e4b080409b860f26"},{"code":"(fn [board]\n  (let [row-wins\n        (for [x (range 0 3)] (for [y (range 0 3)] [y x]))\n        col-wins\n        (for [x (range 0 3)] (for [y (range 0 3)] [x y]))\n        diagonal-wins\n        (vector\n          (for [x (range 0 3) y (range 0 3) :when (= x y)] [x y])\n          (for [x (range 0 3) y (range 0 3) :when (= (+ x y) 2)] [x y]))\n        wins (concat row-wins col-wins diagonal-wins)\n        mark (fn [x y] (get-in board [x y]))\n        has-winning-line (fn [pl]\n                           (some\n                             (fn [win]\n                               (every? (fn [[x y]] (= (mark x y) pl)) win))\n                             wins))]\n    (cond\n      (has-winning-line :x) :x\n      (has-winning-line :o) :o\n      true nil)))","problem":73,"user":"504c8165e4b09724c857af31"},{"problem":73,"code":"(fn [[[a _ c]\n   \t  [_ e _]\n      [g _ i] :as board]]\n  (some {[:x :x :x] :x [:o :o :o] :o} (concat board (apply map vector board) [[a e i] [c e g]])\n       ))","user":"5603c31fe4b04bb52996e1c1"},{"problem":73,"code":"(fn [l]\n(let [pos [[[0 0] [0 1] [0 2]]\n[[1 0] [1 1] [1 2]]\n[[2 0] [2 1] [2 2]]\n[[0 0] [1 0] [2 0]]\n[[0 1] [1 1] [2 1]]\n[[0 2] [1 2] [2 2]]\n[[0 0] [1 1] [2 2]]\n[[2 0] [1 1] [0 2]] ]]\n(cond\n  (some #(every? identity (map (fn [[x y]] (= :x (nth (nth l x) y ))) %)) pos) :x\n(some #(every? identity (map (fn [[x y]] (= :o (nth (nth l x) y ))) %)) pos) :o)))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [board]\n  (letfn [(winner? [board player]\n            (let [winners [[7 0 0] [0 7 0] [0 0 7]\n                           [4 4 4] [2 2 2] [1 1 1]\n                           [4 2 1] [1 2 4]]\n                  binified (partition 3 (map #(if (= % player) 1 0)\n                                             (flatten board)))\n                  multiplied (map #(map * [4 2 1] %) binified)\n                  summarized (map #(reduce + %) multiplied)]\n              (not (empty?\n                    (for [winner winners :when\n                          (= winner (map bit-and summarized winner))]\n                      true)))))]\n    (cond\n     (winner? board :x) :x\n     (winner? board :o) :o)))","problem":73,"user":"512d3304e4b040332b905b2d"},{"problem":73,"code":"(fn [rows]\n  (let [columns (apply map vector rows)\n        diagonals [[(get-in rows [0 0])\n                    (get-in rows [1 1])\n                    (get-in rows [2 2])]\n                   [(get-in rows [0 2])\n                    (get-in rows [1 1])\n                    (get-in rows [2 0])]]]\n    (some #(if (and\n                (not= :e (first %))\n                (apply = %))\n             (first %))\n          (concat rows columns diagonals))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [[[a b c] [d e f] [g h i] :as b]]\n\t(some {[:x :x :x] :x [:o :o :o] :o} (concat b (apply map vector b) [[a e i] [c e g]])))","problem":73,"user":"4f82f9f7e4b033992c121c10"},{"code":"(fn [m]\n  (let [r m\n        c (apply map vector m)\n        d [(map-indexed #(%2 %) m), (map-indexed #(%2 (- 2 %)) m)]\n        t (fn [s] (if (and (= (count (distinct s)) 1) (not= (first s) :e)) (first s)))\n        f (fn [c] (some t c))\n        r (or (f r) (f c) (f d))\n        ]\n    r))","problem":73,"user":"514d8084e4b019235f6c0588"},{"problem":73,"code":"(fn [b]\n  (letfn [(test-win [line]\n    (if (apply = line) \n      (if (not= :e (first line)) (first line) nil)))]\n    (if-let [row-winner (some test-win b)]\n      row-winner\n      (if-let [col-winner (some test-win (partition 3 (apply interleave b)))]\n        col-winner\n        (if \n          (and \n            (not= (ffirst b) :e) \n            (= (ffirst b) (get-in b [1 1]) (get-in b [2 2])))\n          (ffirst b)\n          (if\n            (and\n              (not= (get-in b [0 2]) :e)\n              (= (get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])))\n            (get-in b [0 2])\n            nil))))))","user":"55fee5e4e4b00f4cabc5765a"},{"code":"(fn [board]\n    (letfn [(wins? [player]\n                   (or (every? #(= (nth % 0) player) board) \n                       (every? #(= (nth % 1) player) board) \n                       (every? #(= (nth % 2) player) board)\n                       (some #(= % \n                                 (repeat 3 player)\n                                 ) \n                             board)\n                       (every? identity (map-indexed #(= (nth %2 %) player) board)) \n                       (every? identity (map-indexed #(= (nth %2 %) player) (reverse board)))))]\n           (cond\n             (wins? :x) :x\n             (wins? :o) :o\n             :else nil)))","problem":73,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":73,"code":"(fn [[top mid bottom :as board]]\n  (let [xss\n        (concat board (map vector top mid bottom)\n          [[(top 0) (mid 1) (bottom 2)]\n          [(top 2) (mid 1) (bottom 0)]])]\n    (cond (some true? (map #(every? #{:x} %) xss)) :x\n          (some true? (map #(every? #{:o} %) xss)) :o\n          :else nil)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":73,"code":"(fn [board] (let [extract (fn [position] (map #(get (get board (first %)) (second %)  ) position) ),\n                  possibles (filter #(apply = %) (map extract [\n                                        [[0 0] [1 0] [2 0]]\n                                        [[0 1] [1 1] [2 1]]\n                                        [[0 2] [1 2] [2 2]]\n                                        [[0 0] [0 1] [0 2]]\n                                        [[1 0] [1 1] [1 2]]\n                                        [[2 0] [2 1] [2 2]]\n                                        [[0 0] [1 1] [2 2]]\n                                        [[2 0] [1 1] [0 2]]\n                                        ])   )]\n              (if (empty? possibles)\n                  nil\n                 (if (= :e (first (first possibles)))\n                   nil\n                   (first (first possibles))))\n                ))","user":"56a6051fe4b0542e1f8d14e5"},{"code":"(fn [board]\n  (let \n    [transpose (fn [board] \n                 (partition-all 3 (apply interleave board)))\n     filter-row (fn [board] (filter #(apply = %) board))\n     row-check (fn [board] \n                 (let [v (ffirst (filter-row board))]\n                   (cond \n                     (= v :x) :x\n                     (= v :o) :o)))]\n    (let [b (row-check board)  tb (row-check (transpose board))]\n      (or b tb\n          (let [diag1 (for [x (range 3)] (-> board (nth x) (nth x)))\n                diag2 (for [x (range 3)] (-> board (nth x) (nth (- 2 x))))]\n            (or (row-check (list diag1))\n                (row-check (list diag2))))))))","problem":73,"user":"4f90e238e4b0dcca54ed6c94"},{"problem":73,"code":"(fn solve [board]\n  (letfn [(transpose [matrix]\n                     (apply mapv vector matrix))\n          (trace [matrix]\n                 (mapv (fn [coll idx] (nth coll idx)) \n                       matrix (range)))\n          (rotate [coll]\n                  (conj (subvec coll 1) (first coll)))\n          (rotate-n [coll n]\n                    ((apply comp (repeat n rotate)) coll))\n          (symmetric-trace [matrix]\n                           (->>\n                            (trace\n                             [(rotate-n (first matrix) 2)\n                              (second matrix)\n                              (rotate-n (last matrix) 1)])\n                            (conj [] (trace matrix))))]\n    (let [x-win [:x :x :x]\n          o-win [:o :o :o]]\n      (if (or (contains? (set board) x-win)\n              (contains? (set (transpose board)) x-win)\n              (contains? (set (symmetric-trace board)) x-win))\n        :x\n        (if (or (contains? (set board) o-win)\n                (contains? (set (transpose board)) o-win)\n                (contains? (set (symmetric-trace board)) o-win))\n          :o\n          nil)))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [[x y z :as grid-by-lines]]\n  (let [column (fn [f] (map f grid-by-lines))\n        grid-by-columns (map column (list first second last))\n        diagonal (fn [grid] (map #(%1 %2) (list first second last) grid))\n        diagonals (map diagonal (list grid-by-lines (reverse grid-by-lines)))\n        is-every (fn [symbol a] (every? #(= symbol %) a))\n        is-winner (fn [user] (some #(is-every user %) (concat grid-by-lines grid-by-columns diagonals)))]\n    (cond\n      (is-winner :x) :x\n      (is-winner :o) :o\n      :else nil\n      )\n    )\n  )","problem":73,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn check-board [board]\n  (letfn [\n    (get-winner[result]\n      (first (filter (complement nil?) result)))\n   \n\n    (check-lines []\n      (for [line board player [:o :x]]\n         (if (every? (partial = player) line)\n              player nil)))\n\n    (check-collumns []\n      (for [collumn [0 1 2] player [:o :x]]\n        (if (every? (partial = player)\n\t                (map #(nth % collumn) board))\n             player nil)))\n\n    (check-diagonals []\n      (for [dgcoord  [[[0 0] [1 1] [2 2]]\n\t                  [[2 0] [1 1] [0 2]]] player [:o :x]]\n\t    (if (every? (partial = player)\n\t                (for [[line collumn] dgcoord]\n\t\t  \t\t         (get-in board [line collumn])))\n  \t\t     player nil)))]\n\t\n  (get-winner\n    (concat (check-lines)\n\t        (check-collumns)\n\t\t    (check-diagonals)))))","problem":73,"user":"52f818a6e4b047fd55836fcc"},{"problem":73,"code":"(fn [board]\n  (let [rows `[~@board\n               ~@(apply mapv vector board)\n               ~[(get-in board [0 0])\n                 (get-in board [1 1])\n                 (get-in board [2 2])]\n               ~[(get-in board [0 2])\n                 (get-in board [1 1])\n                 (get-in board [2 0])]]]\n    (->> rows\n         (filter (fn [row] (every? #(not= :e %) row)))\n         (filter #(apply = %))\n         first\n         first)))","user":"4ff24a1ae4b0678c553fc337"},{"problem":73,"code":"(fn [b]\n  (let [f (fn [m]\n            (first (filter #(and (= 1 (count %)) (not= :e (first %))) (map set m))))\n        diag1  (vector (first (reduce (fn [[acc i] c]\n                               [(conj acc (nth c i)) (inc i)]) [[] 0] b)))\n        cols (apply mapv vector b)\n        cf (dec (count (first b)))\n        diag2 (vector (first (reduce (fn [[acc i] c]\n                               [(conj acc (nth c i)) (dec i)]) [[] cf] cols)))]\n    ( first (concat (f b) (f diag1) (f diag2) (f cols)))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":73,"code":"(fn [board]\n  (let [board (flatten board)\n        h     (for [x (range 3)] #(->> % (drop (* x 3)) (take 3)))\n        v     (for [x (range 3)] #(->> % (drop x) (take-nth 3)))\n        d     [#(take-nth 4 %) #(->> % (drop 2) (take-nth 2) drop-last)]\n        test  (concat h v d)\n        res   (map #(% board) test)\n        res   (some (fn [r] (->> r\n                                 (when (apply = r))\n                                 (some #{:x :o}))) res)]\n    res))","user":"5bc09ebae4b07a9b28b10005"},{"problem":73,"code":"(fn [x] (first (remove nil? (map #(if (and (not= (first %) :e) (apply = %)) (first %)) (conj x (map first x) (map second x) (map last x) (vector (ffirst x) (second (second x))\n                                                                                                   (last (last x)))\n                                               (vector (last (first x)) (second (second x)) (first (last x))))))))","user":"4eb0175b535d7eef30807336"},{"code":"(fn [x]\n  (let [transpose (partial apply mapv vector)\n        forward-diag (map-indexed #(nth %2 %1) x)\n        backward-diag (map-indexed #(nth %2 (- 2 %1)) x)\n        lines (concat [forward-diag backward-diag] x (transpose x))\n        wins? (fn [x] (some identity (map (partial every? (partial = x))\n                                          lines)))\n        ]\n    (cond\n     (wins? :x) :x\n     (wins? :o) :o\n     :else nil)\n  )\n)","problem":73,"user":"515f8a0de4b0e2be8aa20bce"},{"problem":73,"code":"(fn [table]\n  (some #(if (and (not= (first %) :e) (apply = %)) (first %) nil)\n        (concat table\n                [(map first table)\n                 (map second table)\n                 (map #(nth % 2) table)\n                 (map #(nth (nth table %) %) [0 1 2])\n                 (map #(nth (nth table (- 2 %)) %) [0 1 2])])))","user":"56bf4ac0e4b0f26550335985"},{"code":"(fn [board]\n    (letfn [(row-is? [sym row_num]\n              (apply = sym (nth board row_num)))\n            (col-is? [sym col_num]\n              (apply = sym (map #(nth % col_num) board)))\n            (diag-1-is? [sym]\n              (apply = sym [(ffirst board) (second (second board)) (last (last board))]))\n            (diag-2-is? [sym]\n              (apply = sym [(last (first board)) (second (second board)) (first (last board))]))\n            (win-for? [sym]\n              (some true? (concat [(diag-1-is? sym) (diag-2-is? sym)]\n                                  (for [fun [(partial row-is? sym) (partial col-is? sym)]\n                                        rc [0 1 2]]\n                                    (fun rc)))))]\n      (cond (win-for? :x) :x\n            (win-for? :o) :o)))","problem":73,"user":"4f725466e4b07046d9f4f030"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [cols (apply map list board)\n        dias (map #(map nth board %) (list (range) (range 2 -1 -1)))\n        all-lines (concat cols dias board)]\n    (letfn [(count-item [side coll]\n              (and (= 3 (apply + (for [i coll] (if (= i side) 1 0))))\n                   side))]\n      (or (some identity (map (partial count-item :x) all-lines))\n          (some identity (map (partial count-item :o) all-lines))))))","user":"56897739e4b0dcc4269f407d"},{"problem":73,"code":"(fn analyze [board]\n  (letfn [(analyzeVec [v] (if (apply = v) (first v) nil))\n          (getRow [n] (nth board n))\n          (getCol [n] (map #(nth % n) board))\n          (getDiag1 [] (vector (first (first board)) \n                               (second (second board))\n                               (last (last board))))\n          (getDiag2 [] (vector (last (first board))\n                               (second (second board))\n                               (first (last board))))]\n    (let [rows (map #(analyzeVec (getRow %)) (range 3))\n          cols (map #(analyzeVec (getCol %)) (range 3))\n          diags (list (analyzeVec (getDiag1)) (analyzeVec (getDiag2)))\n          results (concat rows cols diags)]\n      (->> results\n        (filter (complement nil?))\n        (filter (complement #(= :e %)))\n        (#(cond\n            (empty? %) nil\n            (apply = %) (first %)\n            :else nil))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":73,"code":"(fn ttt [board] \n  (let\n    [row-cors (fn [n] (map vector (range 3) (repeat n)))\n     col-cors (fn [n] (map vector (repeat n) (range 3)))\n     diag1 (map vector (range 3) (range 3))\n     diag2 (map vector (reverse (range 3)) (range 3))\n     all-cors (list (row-cors 0) (row-cors 1) (row-cors 2) (col-cors 0) (col-cors 1) (col-cors 2) diag1 diag2)\n     win (fn [b cors] (->> cors (map (partial get-in b)) (#(if (apply = %) (first %) :e)) ))]\n    (->> all-cors (map (partial win board)) (filter #(not (= :e %))) (first))\n))","user":"5280a1ece4b0757a1b171407"},{"problem":73,"code":"(fn tic-tac\n\t[[[a b c] [d e f] [g h i]]]\n\t(let [variants  [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]]]\n\t \t (some\n\t\t  \t(fn winner\n\t\t \t\t[[x y z]]\n\t\t \t\t(when (and (not= x :e) (= x y) (= y z)) x))\n\t\t \tvariants)))","user":"58fb7d7ae4b0438e51c2cf7a"},{"code":"(fn [b1] (let [r (for [p [:o :x]] \n  (if \n    (some\n      true?\n      (map \n        #(apply = (cons p %))    \n        (cons [((b1 0) 2) ((b1 1) 1) ((b1 2) 0)] (cons [((b1 0) 0) ((b1 1) 1) ((b1 2) 2)] (for [fx [[0] [1] [2] (range 3)], fy [[0] [1] [2] (range 3)] :when (not= (count fx) (count fy))] (for [x fx, y fy] ((b1 x) y)))))))\n    p))] (if (first r) :o (second r))))","problem":73,"user":"4eabb245535d7eef30807319"},{"code":"(fn [g]\n  (some #(cond (every? (partial = :x) %) :x (every? (partial = :o) %) :o)\n        (concat \n          g \n          (apply map list g)\n          (map #(list ((g 0) %) ((g 1) 1) ((g 2) (- 2 %))) '(0 2)))))","problem":73,"user":"4f1d1d95535d64f603146488"},{"code":"(fn [sit]\n  (letfn \n    [(hor-win [player sit]\n      (some (partial = (repeat 3 player)) sit))\n    (vert-win [player sit]\n      (and (seq (first sit)) \n        (or (= (repeat 3 player) (map first sit)) (recur player (map rest sit)))))\n    (diag-win [player [line1 line2 line3]]\n       (or (= (repeat 3 player) (list (nth line1 0) (nth line2 1) (nth line3 2)))\n           (= (repeat 3 player) (list (nth line1 2) (nth line2 1) (nth line3 0)))))]\n    (first (filter #(or (hor-win % sit) (vert-win % sit) (diag-win % sit)) [:x :o]))))","problem":73,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn attt [b]\n  (let [win-pos [[[0 0] [0 1] [0 2]]  ; 1st row\n                 [[1 0] [1 1] [1 2]]  ; 2nd row\n                 [[2 0] [2 1] [2 2]]  ; 3rd row\n                 [[0 0] [1 0] [2 0]]  ; 1st column\n                 [[0 1] [1 1] [2 1]]  ; 2nd column\n                 [[0 2] [1 2] [2 2]]  ; 3rd column\n                 [[0 0] [1 1] [2 2]]  ; left to right diagonale\n                 [[0 2] [1 1] [2 0]]] ; right to left diagonale\n        get-value-at (fn [b p]\n                       ((b (p 0)) (p 1)))\n        get-values-at (fn [b ps]\n                        (loop [ps1 ps, result []]\n                          (if (empty? ps1)\n                            result\n                            (recur (rest ps1) (conj result (get-value-at b (first ps1))))\n                            )))\n        same? (fn [values v]\n                (= (count values) (count (filter #(= v %) values))))\n        get-winner (fn [values]\n                     (loop [values1 values]\n                       (if (empty? values1)\n                         nil  \n                         (let [vals (first values1)]\n                           (cond\n                             (same? vals :x) :x\n                             (same? vals :o) :o\n                             :else (recur (rest values1)))\n                           ))))\n        get-values-at-poss (fn [b poss]\n                             (loop [result [], poss1 poss]\n                               (if (empty? poss1)\n                                 result\n                                 (let [f (first poss1)\n                                       v (get-values-at b f)]\n                                   (recur (conj result v) (rest poss1))\n                                   ))))\n        vals-at-win-poss (get-values-at-poss b win-pos)]\n    (get-winner vals-at-win-poss)\n    ))","problem":73,"user":"52cf084ce4b07d0d72b27399"},{"problem":73,"code":"(fn winner [board]\n   (let [winners #{:o :x}\n         [row1 row2 row3] board\n         board' (map #(list %1 %2 %3) row1 row2 row3)\n         row-sets (map #(into #{} %) board)\n         col-sets (map #(into #{} %) board')\n         major-diag-set (set `(~(first row1) ~(second row2) ~(last row3)))\n         minor-diag-set (set `(~(first row3) ~(second row2) ~(last row1)))]\n     (->> (concat row-sets col-sets `(~major-diag-set ~minor-diag-set))\n          (reduce #(if (= 1 (count %2)) (conj %1 (first %2)) %1) #{})\n          (reduce #(or %1 (get winners %2)) nil))))","user":"57b39fbee4b0fbc9809a2783"},{"code":"(fn [bs]\n  (letfn [(check-for\n            [s]\n            (some #{true}\n                  (map (partial = [s s s])\n                       (conj (concat bs\n                                     (partition 3 (apply interleave bs)))\n                             (map (partial get-in bs) [[0 0] [1 1] [2 2]])\n                             (map (partial get-in bs) [[0 2] [1 1] [2 0]])))))]\n    (cond\n      (check-for :x) :x\n      (check-for :o) :o\n      :default nil)))","problem":73,"user":"50f48298e4b004d364930527"},{"problem":73,"code":"(fn a[b]\n  ( cond\n    (= (nth (nth b 0) 0) (nth (nth b 0) 1) (nth (nth b 0) 2) :x) :x\n    (= (nth (nth b 1) 0) (nth (nth b 1) 1) (nth (nth b 1) 2) :x) :x\n    (= (nth (nth b 2) 0) (nth (nth b 2) 1) (nth (nth b 2) 2) :x) :x\n    (= (nth (nth b 0) 0) (nth (nth b 1) 0) (nth (nth b 2) 0) :x) :x\n    (= (nth (nth b 0) 1) (nth (nth b 1) 1) (nth (nth b 2) 1) :x) :x\n    (= (nth (nth b 0) 2) (nth (nth b 1) 2) (nth (nth b 2) 2) :x) :x\n    (= (nth (nth b 0) 0) (nth (nth b 1) 1) (nth (nth b 2) 2) :x) :x\n    (= (nth (nth b 0) 2) (nth (nth b 1) 1) (nth (nth b 2) 0) :x) :x\n    (= (nth (nth b 0) 0) (nth (nth b 0) 1) (nth (nth b 0) 2) :o) :o\n    (= (nth (nth b 1) 0) (nth (nth b 1) 1) (nth (nth b 1) 2) :o) :o\n    (= (nth (nth b 2) 0) (nth (nth b 2) 1) (nth (nth b 2) 2) :o) :o\n    (= (nth (nth b 0) 0) (nth (nth b 1) 0) (nth (nth b 2) 0) :o) :o\n    (= (nth (nth b 0) 1) (nth (nth b 1) 1) (nth (nth b 2) 1) :o) :o\n    (= (nth (nth b 0) 2) (nth (nth b 1) 2) (nth (nth b 2) 2) :o) :o\n    (= (nth (nth b 0) 0) (nth (nth b 1) 1) (nth (nth b 2) 2) :o) :o\n    (= (nth (nth b 0) 2) (nth (nth b 1) 1) (nth (nth b 2) 0) :o) :o\n    :else nil\n    )\n  )","user":"5b3aa98be4b02d533a91bbca"},{"problem":73,"code":"(fn [[r1 r2 r3 :as board]]\n    (some (fn [[a b c]]\n            (when (and (= a b c) (not= a :e)) a))\n          (concat board\n                  (map vector r1 r2 r3)\n                  (list (map-indexed #(nth %2 %1) board))\n                  (list (map-indexed #(nth %2 %1) (reverse board))))))","user":"5df70ee8e4b0a607a9a45c8a"},{"problem":73,"code":"#({[:x :e :e] :x, [:o :o :o] :o, [:o :x :e] :x, [:x :o :e] :o} (% 1))","user":"5416282ee4b01498b1a719fa"},{"code":"(fn [b]\n  (let [fb (into [] (flatten b))\n        p [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        f #( if\n             (and \n              (not= :e (fb (first %))) \n              (= (fb (first %)) (fb (second %)) (fb (last %))) ) \n             (fb (first %))\n             nil\n             )]\n    (some f p)))","problem":73,"user":"513b77f3e4b00f740c76c403"},{"problem":73,"code":"(fn ttt-winner\n  [[[a b c]\n    [d e f]\n    [g h i]]]\n  (loop [choices [:x :o :e]]\n    (cond\n      (= (first choices) :e) nil\n      (= a b c (first choices)) (first choices)\n      (= d e f (first choices)) (first choices)\n      (= g h i (first choices)) (first choices)\n      (= a d g (first choices)) (first choices)\n      (= b e h (first choices)) (first choices)\n      (= c f i (first choices)) (first choices)\n      (= a e i (first choices)) (first choices)\n      (= g e c (first choices)) (first choices)\n      :else (recur (rest choices)))))","user":"550d9452e4b06e50f9beb15d"},{"problem":73,"code":"(fn analyze-tic-tac-toe-board\n  [xs]\n  {:pre [(every? true? (map (partial every? keyword?) xs))]}\n  (letfn [(col [n] (map #(nth % n) xs))\n          (win? [y ys] (some true?\n                             (map (partial every? #{y}) ys)))]\n    (let [rows xs\n          cols (map col (range 0 3))\n          diagonal [0 1 2]\n          diagonals (vector\n                     (map nth xs diagonal)\n                     (map nth (reverse xs) diagonal))]\n      (cond\n        (win? :x (concat rows cols diagonals)) :x\n        (win? :o (concat rows cols diagonals)) :o\n        :else nil))))","user":"506f0968e4b09350ab4199f5"},{"problem":73,"code":"(fn ttt[b]\n  (let [win-lines (concat b ; horizontal win lines\n                          (apply map vector b) ; vertical win lines\n                          (vector ; diagonals\n                           (mapv (fn[row column] (get row column) ) b [0 1 2])\n                           (mapv (fn[row column] (get row column) ) b [2 1 0])))]\n    (cond\n      (some identity (map #(every? identity (replace {:x true :o false :e false} %1)) win-lines)) :x\n      (some identity (map #(every? identity (replace {:o true :x false :e false} %1)) win-lines)) :o\n      :else nil)))","user":"5980f91ae4b021a7a535fddd"},{"problem":73,"code":"(fn __ [board]\n  (let [positions (->> (flatten board)\n                    (map-indexed (fn [n r] [n r]))\n                    (reduce #(assoc %1 (second %2) (cons (first %2) (get %1 (second %2)))) {}))\n        wins [#{0 1 2} #{3 4 5} #{6 7 8} #{0 3 6} #{1 4 7} #{2 5 8} #{0 4 8} #{6 4 2}]]\n    (->> (for [player [:x :o]]\n           (let [player-pos (get positions player)\n                 player-wins (drop-while #(not (clojure.set/subset? %1 (set player-pos))) wins)]\n             (if (not (empty? player-wins))\n               player)))\n      (drop-while nil?)\n      (first))))","user":"502a5e59e4b09e8f859a9fbc"},{"problem":73,"code":"(fn\n  [board]\n  (letfn [(pRow [value row]\n            (every? (partial = value) (board row)))\n          (pCol [value col]\n            (every? (partial = value) (map #(% col) board)))\n          (pDiag [value]\n            (or (= value\n                   (get-in board [0 0])\n                   (get-in board [1 1])\n                   (get-in board [2 2]))\n                (= value\n                   (get-in board [0 2])\n                   (get-in board [1 1])\n                   (get-in board [2 0]))))\n          (win [value]\n            (or (some (partial pRow value) (range 3))\n                (some (partial pCol value) (range 3))\n                (pDiag value)))]\n    (cond\n      (win :x) :x\n      (win :o) :o\n      :else    nil)))","user":"52dfc89be4b09f7907dd1405"},{"problem":73,"code":"(fn tic [X]\n (let [wi [[0 1 2] [3 4 5] [6 7 8]\n      \t   [0 3 6] [1 4 7] [2 5 8]\n\t   [0 4 8] [2 4 6]]\n       xf (flatten X)]\n   (first (remove #(nil? %) (for [w wi]\n   \t(let [arn (map #(nth xf %) w)]\n\t     (when (and (not= (nth arn 0) :e) \n\t     \t (and (= (nth arn 0) (nth arn 1)) \n\t\t (= (nth arn 1) (nth arn 2))))\n\t\t (nth arn 0))))))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [[l0 l1 l2]]\n  (let [c (fn [i] [(nth l0 i) (nth l1 i) (nth l2 i)])\n        d1 [(nth l0 0) (nth l1 1) (nth l2 2)]\n        d2 [(nth l0 2) (nth l1 1) (nth l2 0)]\n        s (set [l0 l1 l2 (c 0) (c 1) (c 2) d1 d2])\n        owin (contains? s [:o :o :o])\n        xwin (contains? s [:x :x :x])]\n       (cond (and owin (not xwin)) :o\n             (and xwin (not owin)) :x)))","problem":73,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn [x] (ffirst (filter #(and (apply = %) (not= (first %) :e)) (partition 3 (map (vec (flatten x)) '(0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6))))))","problem":73,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn check-board [board & second]\n  (let [row-win (fn [row element]\n                  (if (= (count (filter #(= element %) row)) 3)\n                    element\n                    nil))\n        row-eq (fn [row]\n                 (if (not (nil? (row-win row :o)))\n                   :o\n                   (if (not (nil? (row-win row :x)))\n                     :x\n                     nil)))\n        diag1 #(vector (get (get % 0) 0) (get (get % 1) 1) (get (get % 2) 2))\n        diag2 #(vector (get (get % 0) 2) (get (get % 1) 1) (get (get % 2) 0))\n        hor-result\n        (loop [board board i 0]\n          (do\n            (when (< i 3)\n              (println (get board i))\n              (let [res (row-eq (get board i))]\n                (if (nil? res)\n                  (recur board (inc i))\n                  res)))))]\n\n    (if (nil? hor-result)\n      (let [dia1 (row-eq (diag1 board))\n            dia2 (row-eq (diag2 board)) ]\n        (do\n          (println dia1 dia2 hor-result second)\n          (if (and (nil? dia1) (nil? dia2) (not second))\n            ;Transpose the board if win not found on horizontal row\n            (check-board (apply mapv vector board) true)\n            (if (nil? dia1) dia2 dia1))))\n      hor-result)))","problem":73,"user":"52e25beee4b09f7907dd1433"},{"problem":73,"code":"(fn [b]\n  (let [rs \n        (concat b \n          (apply map vector b)\n          (vector\n            (map get\n                 b [0 1 2]))\n          (vector\n            (map get\n                 b [2 1 0])))]\n    (->> rs \n      (filter\n       #(and \n         (apply = %)\n         (not= :e\n               (first %))))\n      first first)))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn [b]\n  (let [winners #{#{0 1 2}\n                  #{3 4 5}\n                  #{6 7 8}\n                  #{0 3 6}\n                  #{1 4 7}\n                  #{2 5 8}\n                  #{0 4 8}\n                  #{2 4 6}}\n        finder (fn [x] \n                 (set \n                   (map first \n                        (filter #(= x (second %)) \n                                (map-indexed vector \n                                             (flatten b))))))\n        xs (finder :x)\n        os (finder :o)\n        is (fn [s r] (if (some #(= 3 (count %))\n                               (map #(clojure.set/intersection s %) \n                                    winners))\n                           r))]\n\n    (or (is xs :x) (is os :o))))","problem":73,"user":"4e6ebd4a535d5021c1a89610"},{"problem":73,"code":"(fn [board]\n   (let [wins [[0 1 2] [3 4 5] [6 7 8]\n               [0 3 6] [1 4 7] [2 5 8]\n               [0 4 8] [2 4 6]]\n         streaks (map #(map (into [] (flatten board)) %) wins)]\n     (cond (some #(= [:x :x :x] %) streaks) :x\n           (some #(= [:o :o :o] %) streaks) :o)))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"code":"(fn [board]\n    (reduce (fn [res [x & _ :as all]]\n              (if (and (not= x :e) (every? (partial = x) all))\n                x\n                res))\n            nil\n            (conj\n              (concat (apply map vector board) board)\n              (for [x (range 3)] ((board x) x))\n              (for [[y x] (map vector (range 3) (range 2 -1 -1))] ((board x) y)))))","problem":73,"user":"50588ff1e4b06522596eba7e"},{"problem":73,"code":"(letfn [(transpose [m] (apply mapv vector m))]\n    (fn [board]\n      (cond (some #(= % [:x :x :x]) (concat board (transpose board)))\n            :x\n\n            (some #(= % [:o :o :o]) (concat board (transpose board)))\n            :o\n\n            (or (and (= (ffirst board) :x)\n                     (= (second (second board)) :x)\n                     (= (-> board (nth 2) (nth 2)) :x))\n                (and (= (first (last board)) :x)\n                     (= (second (second board)) :x)\n                     (= (last (first board)) :x)))\n            :x\n\n            (or (and (= (ffirst board) :o)\n                     (= (second (second board)) :o)\n                     (= (-> board (nth 2) (nth 2)) :o))\n                (and (= (first (last board)) :o)\n                     (= (second (second board)) :o)\n                     (= (last (first board)) :o)))\n            :o)))","user":"5777cffae4b0979f89651651"},{"problem":73,"code":"(fn [b] \n  (first (some #{[:o :o :o] [:x :x :x]}\n               (concat b\n                       (apply map vector b)\n                       [(for [i [0 1 2]]\n                          (get-in b [i i]))]\n                       [(for [i [0 1 2]]\n                          (get-in b [i (- 2 i)]))]))))","user":"52bacfa8e4b07a9af57922d6"},{"code":"(fn [b]\n  (let [f  (fn [s] (cond (apply = :x s) :x\n                         (apply = :o s) :o\n                         :else nil))\n        h  (set (map f b))\n        c  (fn [x] (map #(get-in b [% x]) [0 1 2])) \n        v  (set (for [x [0 1 2]] (f (c x)) ))\n        g  (fn [z] (hash-set (f (map #(get-in b %) z)))) \n        d1 (g [[0 0] [1 1] [2 2]])\n        d2 (g [[0 2] [1 1] [2 0]]) ]\n    (or (h :x) (v :x) (d1 :x) (d2 :x) \n        (h :o) (v :o) (d1 :o) (d2 :o))))","problem":73,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn [D B] ( ->>\n           `(~@B ~@(apply map list B) ~(D B) ~(-> B reverse D))\n           (some #{[:x :x :x] [:o :o :o]})\n           first)\n  ) (partial map-indexed #(%2 %))","problem":73,"user":"5281a445e4b0757a1b17143a"},{"code":"(fn prob-0073\n  [bd]\n  (let [lines [[[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]\n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]]\n\n        mat-get (fn mat-get\n                  [mt ix]\n                  ((mt (first ix)) (second ix)))\n\n        ttt-win-check (fn ttt-win-check\n                        [bd ln]\n                        (if (apply = (map #(mat-get bd %) ln))\n                          (mat-get bd (first ln))\n                          nil))\n        ]\n\n    (loop [ls lines]\n      (let [l      (first ls)\n            l-rst  (rest  ls)\n            winner (ttt-win-check bd l)]\n        (cond\n         (or (= :x winner) (= :o winner)) winner\n         (empty? l-rst)                   nil\n         :else                            (recur l-rst))))))","problem":73,"user":"4f047c07535dcb61093f6bcd"},{"problem":73,"code":"(letfn [(won? [[a b c]]\n            (and (= a b c) (#{:x :o} a)))]\n    (fn winner [[[r1c1 r1c2 r1c3 :as r1]\n                 [r2c1 r2c2 r2c3 :as r2]\n                 [r3c1 r3c2 r3c3 :as r3] :as rows]]\n      (let [c1 (map #(% 0) rows)\n            c2 (map #(% 1) rows)\n            c3 (map #(% 2) rows)\n            d1 [r1c1 r2c2 r3c3]\n            d2 [r3c1 r2c2 r1c3]\n            ]\n        (some won? [r1 r2 r3 c1 c2 c3 d1 d2]))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (#(or (% a b c) (% d e f) (% g h i)\n         (% a d g) (% b e h) (% c f i)\n         (% a e i) (% g e c))\n   #(when (= %1 %2 %3) (if (= %1 :e) nil %1))))","problem":73,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn  [v]\n  (let [x (flatten v)\n        i [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        t (first\n            (filter identity (for [a i\n                                   :let [b (map #(nth x %) a)]]\n                               (if (apply = b) (first b)))))]\n    (if-not (= :e t) t)))","problem":73,"user":"52f3af46e4b05e3f0be25f14"},{"problem":73,"code":"(letfn [(rows [board] board)\n          (cols [board] (apply map vector board))\n          (diags [board]\n            (let [r (dec (count board))]\n              [(vec (map-indexed (fn [i col] (get col i)) board))\n               (vec (map-indexed (fn [i col] (get col (- r i))) board))]))\n          (lines [board]\n            (->> board ((juxt rows cols diags)) (apply concat)))]\n    (fn winner [board]\n      (let [ls (lines board)]\n        (cond\n          (some #(= % [:x :x :x]) ls) :x\n          (some #(= % [:o :o :o]) ls) :o\n          :else                       nil))))","user":"4dfe5a93535d04ed9115e786"},{"problem":73,"code":"(fn\n  [board]\n  (let [f (fn [coll] (let [r (reduce #(if (= %1 %2) %1 nil) coll)] (if (= :e r) nil r)))\n        r1 (nth board 0)\n        r2 (nth board 1)\n        r3 (nth board 2)\n        c1 (map #(nth % 0) board)\n        c2 (map #(nth % 1) board)\n        c3 (map #(nth % 2) board)\n        d1 (map #(nth %1 %2) board (iterate inc 0))\n        d2 (map #(nth %1 %2) board (iterate dec 2))]\n    (or (f r1) (f r2) (f r3) (f c1) (f c2) (f c3) (f d1) (f d2))))","user":"4e82c062535db62dc21a62cc"},{"problem":73,"code":"(fn [m]\n  (let [rows (for [r (range 3)] (nth m r))\n        columns (for [c (range 3)] (for [r (range 3)] (nth (nth m r) c)))\n        diag1 (for [r (range 3) c (range 3) :when (= r c)] (nth (nth m r) c))\n        diag2 (for [r (range 3) c (range 3) :when (= (- 2 r) c)] (nth (nth m r) c))\n        lines (concat rows columns [diag1 diag2])]\n    (->> lines (filter #(apply = %)) (map first) (filter #(contains? #{:x :o} %)) first)))","user":"53050c04e4b0d8b024fd3757"},{"problem":73,"code":"(fn [v]\n  (case (last (some #(if (apply = %) %)\n                    (map (fn [r] (map #(nth (flatten v) (- % 1)) r))\n                         [[1 2 3]\n                          [4 5 6]\n                          [7 8 9]\n                          [1 4 7]\n                          [2 5 8]\n                          [3 6 9]\n                          [1 5 9]\n                          [3 5 7]])))\n    :x :x\n    :o :o\n    nil))","user":"544673c0e4b032a45b8693b0"},{"code":"(letfn \n  [(all-eq? [v x] (every? #(= x %) v))\n   (transpose [v] (vec (apply map vector v)))\n   (win? [brd side]\n     (or\n       (some #(all-eq? % side) brd)\n       (some #(all-eq? % side) (transpose brd))\n       (all-eq? [((brd 0)0) ((brd 1)1) ((brd 2)2)] side)\n       (all-eq? [((brd 0)2) ((brd 1)1) ((brd 2)0)] side)))]\n    (fn [brd]\n      (cond\n        (win? brd :x) :x\n        (win? brd :o) :o\n        :else nil)))","problem":73,"user":"5002b6e5e4b0678c553fc42c"},{"code":"(fn [b]\n  (let [d [((juxt ffirst\n                  #(second (second %))\n                  #(last (last %)))\n              b)\n          ((juxt #(last (first %))\n                 #(second (second %))\n                 #(first (last %)))\n            b)]\n        w (fn [s] (some\n                    #(when (and\n                            (= (count %) 1)\n                            (not (= % #{:e})))\n                        (last %)) s))]\n    (or (w (map set b))\n        (w (apply map sorted-set b))\n        (w (map set d)))))","problem":73,"user":"4ede361a535d10e5ff6f5332"},{"problem":73,"code":"(fn ttt [rows]\n  (let [cols (apply map vector rows)\n        diags (map #(map % (range 3)) [#((rows %) %) #((rows %) (- 2 %))])\n        lines (concat rows cols diags)]\n    (first (some (comp #{#{:x} #{:o}} set) lines))))","user":"55e6c3f5e4b050e68259b48c"},{"problem":73,"code":"(fn [b] (letfn [(firstrow [b] (first b)), (secondrow [b] (second b)), (thirdrow [b] (last b)), (firstcolumn [b] (vector (get-in b [0 0]) (get-in b [1 0]) (get-in b [2 0]))), (secondcolumn [b] (vector (get-in b [0 1]) (get-in b [1 1]) (get-in b [2 1]))), (thirdcolumn [b] (vector (get-in b [0 2]) (get-in b [1 2]) (get-in b [2 2]))), (l2rdiag [b] (vector (get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2]))), (r2ldiag [b] (vector (get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])))] (let [combos (map #(% b) [firstrow, secondrow, thirdrow, firstcolumn, secondcolumn, thirdcolumn, l2rdiag, r2ldiag])] (cond (some #{[:x :x :x]} combos) :x (some #{[:o :o :o]} combos) :o :else nil))))","user":"56e6ef89e4b02e7e935eb6d0"},{"code":"(fn quigagne [pl]\n  (let [lignes [[1 1 1 0 0 0 0 0 0]\n                [0 0 0 1 1 1 0 0 0]\n                [0 0 0 0 0 0 1 1 1]\n                [1 0 0 1 0 0 1 0 0]\n                [0 1 0 0 1 0 0 1 0]\n                [0 0 1 0 0 1 0 0 1]\n                [1 0 0 0 1 0 0 0 1]\n                [0 0 1 0 1 0 1 0 0]]\n        fmatch\n                (fn m [p l j]\n                  (= 3\n                    (count (for [i (range 9) :when (and (= (nth l i) 1) (= (nth p i) j))] 1))\n                  )\n                )\n        plateau (flatten pl)\n        ]\n        (if (not-any? #(fmatch plateau % :x) lignes)\n          (if (not-any? #(fmatch plateau % :o) lignes) nil\n            :o)\n        :x)\n))","problem":73,"user":"4f84400de4b033992c121c2e"},{"problem":73,"code":"(fn winner [board]\n (let\n  [triples\n   [[[0 0] [1 0] [2 0]]\n    [[0 1] [1 1] [2 1]]\n    [[0 2] [1 2] [2 2]]\n    [[0 0] [0 1] [0 2]]\n    [[1 0] [1 1] [1 2]]\n    [[2 0] [2 1] [2 2]]\n    [[0 0] [1 1] [2 2]]\n    [[0 2] [1 1] [2 0]]]\n   nth2\n   (fn [[r c]] (nth (nth board r) c))\n   winning?\n   (fn [[a b c]]\n    (cond\n     (= :o (nth2 a) (nth2 b) (nth2 c)) :o\n     (= :x (nth2 a) (nth2 b) (nth2 c)) :x\n     :else false))]\n  (some winning? triples)))","user":"5d98f616e4b0d3f9b434ad3c"},{"code":"(fn [board]\n  (let [horizontal-winner (fn [board player]\n                            (some identity (map #(every? (partial = player) %) board)))\n        vertical-winner (fn [board player]\n                          (horizontal-winner (apply map vector board) player))\n        ul-diag-winner (fn [board player]\n                         (= (get-in board [0 0])\n                            (get-in board [1 1])\n                            (get-in board [2 2])\n                            player))\n        diag-winner (fn [board player]\n                      (or (ul-diag-winner board player)\n                          (ul-diag-winner (vec (map (comp vec reverse) board)) player)))\n        winner? (fn [player]\n                  (or (horizontal-winner board player)\n                      (vertical-winner board player)\n                      (diag-winner board player)))]\n    (cond\n     (winner? :x) :x\n     (winner? :o) :o\n     )))","problem":73,"user":"4fa340b4e4b081705acca18c"},{"problem":73,"code":"(fn [v] (let [x (fn [a] (let [q (filter (into [] (map #(= a %) (flatten v))) (range  9))] (if (#{'(3 4 5) '(0 3 6) '(0 4 8) '(2 4 6)} q) a nil)))] (or (x :o) (x :x))))","user":"56c08696e4b060a8e693e3aa"},{"problem":73,"code":"(fn checkboard [board]\n   (let [expanded (concat board \n                          (loop [n 2 acc []] (if (< n 0) acc (recur (dec n) (conj acc (mapv #(nth % n) board)))))\n                          (loop [n 2 acc []] (if (< n 0) [acc] (recur (dec n) (conj acc ((board n) n)))))\n                          (loop [n 2 acc []] (if (< n 0) [acc] (recur (dec n) (conj acc ((board n) (- 2 n)))))))\n         win-x (not (empty? (filter (fn [v] (every? #(= :x %) v)) expanded)))\n         win-o (not (empty? (filter (fn [v] (every? #(= :o %) v)) expanded)))]\n     (cond\n       win-x :x\n       win-o :o\n       :else nil)))","user":"57780e4fe4b0979f89651657"},{"problem":73,"code":"(fn attt [b]\n   (let [r (map set (concat b (apply map vector b) (list (map-indexed #(%2 %1) b)) (list (map-indexed #(%2 %1) (reverse b)))))]\n      (ffirst (not-empty (filter #{#{:o} #{:x}} r)))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [b]\n  (let [columns (partition 3 (apply interleave b))\n        diag1 [(take-nth 4 (flatten b))]\n        diag2 [(take-nth 4 (flatten (reverse b)))]\n        candidates (concat b columns diag1 diag2)]\n    (ffirst (filter #(and (apply = %) (not= :e (first %))) candidates))))","problem":73,"user":"4f713878e4b07046d9f4f00a"},{"problem":73,"code":"(fn ttt [b]\n  (some (fn [[a b c]] (if (and (not= a :e) (= a b c)) a))\n  (map (fn [c] (map (partial get-in b) c))\n    [[[0 0] [1 1] [2 2]]\n     [[0 2] [1 1] [2 0]]\n     [[0 0] [0 1] [0 2]]\n     [[1 0] [1 1] [1 2]]\n     [[2 0] [2 1] [2 2]]\n     [[0 0] [1 0] [2 0]]\n     [[0 1] [1 1] [2 1]]\n     [[0 2] [1 2] [2 2]]\n     ])))","user":"55f04526e4b06e875b46ce20"},{"code":"(fn tic-tac-toe[[v1 v2 v3]]\n    (letfn[ (wins [s]\n                  (or (every? #(= % s ) v1)\n                      (every? #(= % s ) v2)\n                      (every? #(= % s ) v3)\n                      (every? #(= % s ) (vector (first v1) (first v2) (first v3)))\n                      (every? #(= % s ) (vector (second v1) (second v2) (second v3)))\n                      (every? #(= % s ) (vector (last v1) (last v2) (last v3)))\n                      (every? #(= % s ) (vector (first v1) (second v2) (last v3)))\n                      (every? #(= % s ) (vector (last v1) (second v2) (first v3)))\n                      ))]\n      (cond\n        (wins :o) :o\n        (wins :x) :x\n        :else nil)))","problem":73,"user":"5273562ae4b03e8d9a4a7479"},{"problem":73,"code":"(fn [board]\n  (let [winning-row? (fn [row] (let [unique (into #{} row)]\n                                 (when (some (partial = unique) [#{:o} #{:x}])\n                                   (first unique))))\n        diag (fn [& offsets] (vector (map (partial get-in board) offsets)))]\n    (some winning-row? (concat \n                         board\n                         (apply map vector board)\n                         (diag [0 0] [1 1] [2 2])\n                         (diag [0 2] [1 1] [2 0])))))","user":"5821b018e4b04b46fc4b0f80"},{"problem":73,"code":"(fn [board]\n  (letfn [(rows [board]\n            board)\n          (cols [[[a b c]\n                  [d e f]\n                  [g h i]]]\n            [[a d g]\n             [b e h]\n             [c f i]])\n          (diags [[[a b c]\n                   [d e f]\n                   [g h i]]]\n            [[a e i] [g e c]])\n          (lines [board]\n            (concat (rows board)\n                    (cols board)\n                    (diags board)))\n          (winner [p board]\n            (if (some (partial every? (partial = p)) (lines board)) p nil))]\n    (or (winner :x board)\n        (winner :o board))))","user":"57a4fa50e4b0a966079561f1"},{"problem":73,"code":"(fn find-tic-tac-toe [lsts]\n  (letfn [(same-list-o-or-x? [lst]\n            (let [[h & t] lst]\n              (if (= h :e)\n                false\n                (every? #(= % h) t))))\n          (find-tic [lsts]\n            (filter same-list-o-or-x? lsts))\n          (find-tac [lsts]\n            (filter same-list-o-or-x? (reduce (fn [lsts lst]\n                                                (map conj lsts lst))\n                                              (map empty lsts)\n                                              lsts)))]\n    (let [tic (find-tic lsts)\n          tac (find-tac lsts)\n          center (fnext (fnext lsts))]\n      (cond (not (empty? tic)) (ffirst tic)\n            (not (empty? tac)) (ffirst tac)\n            (and (not= center :e)\n                 (= center (ffirst lsts))\n                 (= center (last (last lsts)))) center\n            (and (not= center :e)\n                 (= center (last (first lsts)))\n                 (= center (first (last lsts)))) center\n            :else nil))))","user":"5895477fe4b00487982d527c"},{"problem":73,"code":"(fn analyze [table] \n  (letfn [(winner? [ [head & tail] ]\n            (when (and (not= head :e) (every? #{head} tail)) head))\n          (map-cols-from [[xs ys zs]]\n            (map #(apply vector [% %2 %3]) xs ys zs))\n          (map-diags-from [[[fhead _ ftail]\n                           [_ mid _]\n                           [lhead _ ltail]]]\n            (apply vector [[fhead mid ltail] [lhead mid ftail]]))\n          (combine [table]\n            (reduce conj table (lazy-cat (map-cols-from table)\n                                         (map-diags-from table))))]\n    (when-let [line (seq (filter winner? (combine table)))] \n      ((comp first last) line))))","user":"5553b729e4b0deb715856e05"},{"problem":73,"code":"(letfn [                                                                                                                                                \n    (rows [b] (map identity b))                                                                                                 \n    (cols [b] (apply map #(vector %1 %2 %3) b))                                                                                                         \n    (dias [b]                                                                                                                   \n        (let [size (count b)]                                                                                                                           \n            (list                                                                                                               \n                (map #((b %1) %2) (range size) (range size))                                                                                            \n                (map #((b %1) %2) (range size) (range (dec size) (dec 0) -1)))))                                                \n    (all [b] (concat (rows b) (cols b) (dias b)))                                                                                                       \n    (winner? [b]                                                                                                                \n        (let [a (all b)]                                                                                                                                \n            (cond                                                                                                               \n                (some (partial = [:x :x :x]) a) :x                                                                                                      \n                (some (partial = [:o :o :o]) a) :o                                                                              \n                :else nil)))]                                                                                                                           \n    winner?)","user":"558b50d5e4b027778923762b"},{"problem":73,"code":"(fn checker [bord]\n   (let [flat-bord (reduce conj [] (flatten bord))]\n     (letfn [(_g [inx] (get flat-bord inx))\n             (winner [coll]\n                     (let [x (-> coll (distinct))]\n                       (cond\n                         (= 1 (count x)) (first x)\n                         :else nil)))]\n       (loop [_target (map #(conj [] (_g (first %)) (_g (second %)) (_g (last %)))\n                           [[0 1 2] [3 4 5] [6 7 8]\n                            [0 3 6] [1 4 7] [2 5 8]\n                            [0 4 8] [2 4 6]])]\n         (when-not (empty? _target)\n           (let [answer (winner (first _target))]\n             (if (or (nil? answer) (= :e answer))\n               (recur (rest _target))\n               answer)))\n         ))))","user":"55a372f1e4b0acc240e31537"},{"problem":73,"code":"(fn [v] (let [ss (conj #{} (conj #{} ((v 0) 0) ((v 1) 1) ((v 2) 2))\n                            (conj #{} ((v 0) 2) ((v 1) 1) ((v 2) 0))\n                            (conj #{} ((v 0) 0) ((v 1) 0) ((v 2) 0))\n                            (conj #{} ((v 0) 1) ((v 1) 1) ((v 2) 1))\n                            (conj #{} ((v 0) 2) ((v 1) 2) ((v 2) 2))\n                            (into #{} (v 0))\n                            (into #{} (v 1))\n                            (into #{} (v 2)))\n               fss (filter #(and (= 1 (count %)) (not (contains? % :e))) ss)]\n           (first (first fss))))","user":"58987ee9e4b00487982d52d2"},{"problem":73,"code":"(fn winner\n  [board]\n  (let\n    [row-winner (fn [row]\n                  (if (and (apply = row)\n                       (not= (first row) :e))\n                  (first row)\n                  nil))\n     diagonal (fn [board]\n      (map (fn [ix row]\n             (nth row ix))\n           (range)\n           board))\n     transpose (fn [board]\n  \t  (apply map vector board))]\n \t(or (some row-winner board)\n      (some row-winner (transpose board))\n      (row-winner (diagonal board))\n      (row-winner (diagonal (reverse board))))))","user":"540b2dcbe4b0addc1aec66f4"},{"code":"(fn [R A M b]\n  (some #(and (A = %) (#{:x :o} (first %)))\n        `(~@b \n          ~@(A M list b) \n          ~(M #(%2 %) R b) \n          ~(M #(%2 (- 2 %)) R b)))) \n[0 1 2] apply map","problem":73,"user":"4ef49c2c535dced4c769f238"},{"problem":73,"code":"(fn [b]\n  (let [v [(nth b 0)\n           (nth b 1)\n           (nth b 2)\n           (map first b)\n           (map second b)\n           (map last b)\n           [(nth (nth b 0) 0) (nth (nth b 1) 1) (nth (nth b 2) 2)]\n           [(nth (nth b 0) 2) (nth (nth b 1) 1) (nth (nth b 2) 0)]]\n        x #(= :x %)\n        o #(= :o %)]\n    (if (some true? (map #(every? x %) v))\n      :x\n      (if (some true? (map #(every? o %) v)) :o nil))))","user":"55e732c5e4b050e68259b492"},{"problem":73,"code":"(fn [board]\n   (let [has-row (fn [row player] (every? identity (map (fn [x] (= x player)) row)))\n         has-a-row (fn [player] (some identity (map #(has-row % player) board)))\n         has-column (fn [column player] (has-row (map #(nth % column) board) player))\n         has-a-column (fn [player] (some identity (map #(has-column % player) (range (count board)))))\n         get-diagonal-1 (fn [a] (nth (nth board a) a))\n         get-diagonal-2 (fn [a] (nth (nth board a) (- (count board) a 1)))\n         has-diagonal (fn [player] (or\n                                    (has-row (map get-diagonal-1 (range (count board))) player)\n                                    (has-row (map get-diagonal-2 (range (count board))) player)))\n         has-won (fn [player] (or\n                                (has-a-row player)\n                                (has-a-column player)\n                                (has-diagonal player)))\n         winner (if (has-won :x)\n                  :x\n                  (if (has-won :o)\n                     :o\n                     nil))\n         ]\n     winner\n     ))","user":"5d1a1082e4b0902706380e0e"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [hori1 (nth board 0)\n        hori2 (nth board 1)\n        hori3 (nth board 2)\n        vert1 [(nth hori1 0) (nth hori2 0) (nth hori3 0)]\n        vert2 [(nth hori1 1) (nth hori2 1) (nth hori3 1)]\n        vert3 [(nth hori1 2) (nth hori2 2) (nth hori3 2)]\n        diag1 [(nth hori1 0) (nth hori2 1) (nth hori3 2)]\n        diag2 [(nth hori1 2) (nth hori2 1) (nth hori3 0)]\n        lines [hori1 hori2 hori3 vert1 vert2 vert3 diag1 diag2]\n        winner (fn [line] (reduce #(if (and (= %1 %2) (not= %1 :e))\n                                     %1 nil)\n                                  line))]\n    (reduce #(if (not= %2 nil) %2 %1) nil (map winner lines))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":73,"code":"(fn [board]\n  (let [s1 (set (get board 0))\n        s2 (set (get board 1))\n        s3 (set (get board 2))\n        s4 (set [(get (get board 0) 0)\n                 (get (get board 1) 0)\n                 (get (get board 2) 0)])\n        s5 (set [(get (get board 0) 1)\n                 (get (get board 1) 1)\n                 (get (get board 2) 1)])\n        s6 (set [(get (get board 0) 2)\n                 (get (get board 1) 2)\n                 (get (get board 2) 2)])\n        s7 (set [(get (get board 0) 0)\n                 (get (get board 1) 1)\n                 (get (get board 2) 2)])\n        s8 (set [(get (get board 0) 2)\n                 (get (get board 1) 1)\n                 (get (get board 2) 0)])\n        winner (filter #(or\n                         (= #{:x} %)\n                         (= #{:o} %)) [s1 s2 s3 s4 s5 s6 s7 s8])]\n    (first (first winner))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":73,"code":"(fn [board]\n  (letfn [(hrow [c] (some (fn [row] (every? #(= c %) row)) board))\n         (vrow [c] (some (fn [col] (every? #(= c (nth % col)) board)) (range 3)))\n         (drow [c] (some #(every? (fn [[row col]] (= c (get-in board [row col]))) %) [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]))]\n        (some #(when (or (hrow %) (vrow %) (drow %)) %) [:x :o])))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":73,"code":"(fn ttt\n  [rows]\n  (let\n      [cols (apply map vector rows)\n       diag (map #(map % (range 3)) [#((rows %) %) #((rows %) (- 2 %))])\n       board (concat rows cols diag)\n       ]\n      (->> board\n           (distinct)\n           (map #(or (if (every? #{:o} %) :o) (if (every? #{:x} %) :x)))\n           (filter identity)\n           (#(if (empty? %) nil (first %)))\n           )))","user":"5614fa1de4b05f002753dfbe"},{"problem":73,"code":"(fn tic-tac-toe [xs]\n  (let [match-patterns (juxt first\n                             second\n                             last\n                             (partial map first)\n                             (partial map second)\n                             (partial map last)\n                             (juxt (comp first first) (comp second second) (comp last last))\n                             (juxt (comp last first) (comp second second) (comp first last))\n                             )]\n    (first (filter #(not= % :e) (map first (filter #(= (count (distinct %)) 1) (match-patterns xs)))))\n  ))","user":"53778b90e4b06839e8705e36"},{"code":"(fn [board]\n  (let [\n    diags (fn [b] (split-at 3 (map #(nth (flatten b) %) '(0 4 8 2 4 6))))\n    verts (fn [b] (apply map list b))\n    combos (concat board (diags board) (verts board))\n    filter-s (filter #(= (count %) 1) (map distinct combos))\n    filter-e (filter #(not= (first %) :e) filter-s)\n    ]\n  (ffirst filter-e)))","problem":73,"user":"4e6b6294535d8ccf87e9ff11"},{"problem":73,"code":"(fn [xss]\n  (let [x-count (count xss)\n        directions [[0 -1] [-1 -1] [-1 0] [-1 1]]\n        lookup-keys #(map (fn [d] [(map + % d) d]) directions)\n        fold-key #(fn [agg [l-key r-key]]\n                    (if (= (get-in xss l-key) %2)\n                      (assoc agg r-key (inc (or (get-in %1 [l-key r-key]) 1)))\n                      agg))\n        indexes (for [x (range x-count)\n                      y (range x-count)\n                      :when (not= :e (get-in xss [x y]))]\n                  [x y])\n        m-fold (fn [data key]\n                 (let [l-keys (lookup-keys key)\n                       c-player (get-in xss key)\n                       next-data (reduce (fold-key data c-player) {} l-keys)]\n                   (if (some #(= % x-count) (vals next-data))\n                     [c-player nil]\n                     [nil (assoc data key next-data)])))\n        winner-g (fn [[winner data] key]\n                   (if winner [winner] (m-fold data key)))\n        [winner] (reduce winner-g [nil {}] indexes)]\n    winner))","user":"567d132ee4b05957ce8c61c3"},{"code":"#(some {[:x :x :x] :x [:o :o :o] :o}\n  (concat\n   % (apply map vector %)\n   (for [d [[[0 2] [1 1] [2 0]] [[0 0] [1 1] [2 2]]]]\n     (for [[y x] d]\n       ((% y) x)))))","problem":73,"user":"4dbb0b6c535d1e037afb21b0"},{"code":"(fn [x]\n(let [y (map distinct (concat x \n                              (vector (map first x)) \n                              (vector (map second x)) \n                              (vector (map last x)) \n                              (vector (vector (first (first x)) (second (second x)) (last (last x))) ) \n                              (vector (vector (first (last x)) (second (second x)) (last (first x))) ) \n                              ))]\n  (let [z (filter #(= (count %) 1) y)]\n  (if (= :e (first (first z)) )\n    nil\n    (first (first z)) \n    )\n  )\n)\n)","problem":73,"user":"51838e8be4b028ec5fd2f2a0"},{"problem":73,"code":"(fn [l]\n   (let [ac-r #(vector ((l 0) %1)\n                    ((l 1) %2)\n                    ((l 2) %3))\n         hori #(when (apply = (l %))\n                 ((l %) 0))\n         vert #(when (apply = (ac-r % % %))\n                 ((ac-r % % %) 0))\n         diag #(let [s (if (= % \\r)\n                         (ac-r 0 1 2)\n                         (ac-r 2 1 0))]\n                 (when (apply = s)\n                   (s 0)))\n         res (or (hori 0) (hori 1) (hori 2)\n                 (vert 0) (vert 1) (vert 2)\n                 (diag \\r) (diag \\l))]\n     (when-not (= res :e) res)))","user":"5fa80c01e4b0fa27300f3de2"},{"problem":73,"code":"(fn winner? [b]\n  (letfn [(check [x]\n            (cond (every? (partial = :x) x) :x\n                  (every? (partial = :o) x) :o\n                  :else nil))\n          (get-cols [b]\n            (vector (map first b)\n                    (map second b)\n                    (map #(nth % 2) b)))\n          (get-diags [b]\n            (vector\n             (for [i (range 3)]\n               (get-in b [i i]))\n             (for [i (range 3)]\n               (get-in b [i (- 2 i)]))))]\n    (let [rows (map check b)\n          cols (map check (get-cols b))\n          diags (map check (get-diags b))\n          all (concat rows cols diags)]\n      (or (some #{:x} all)\n          (some #{:o} all)))))","user":"541ae7dbe4b01498b1a71a61"},{"problem":73,"code":"#(let [x ((fn[[u v w]]\n            (if (= (count (distinct u)) 1)\n              (first u)\n              (if (= (count (distinct v)) 1)\n                (first v)\n                (if (= (count (distinct w)) 1)\n                  (first w)\n                  (if (= (first u) (first v) (first w))\n                    (first u)\n                    (if (= (second u) (second v) (second w))\n                      (second u)\n                      (if (= (last u) (last v) (last w))\n                        (last u)\n                        (if (= (first u) (second v) (last w))\n                          (first u)\n                          (if (= (last u) (second v) (first w))\n                            (last u)\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          ) %) \n       ]\n    (if (= x :e) nil x)\n )","user":"545537c1e4b0e397800069dd"},{"problem":73,"code":"(fn [b]\n  (let [\n        x (map (fn [ix] (map #(nth (flatten b) %) ix)) [[0 4 8] [2 4 6]])\n        ls (concat b (apply map list b) x)\n        won? (fn [w] (if (some #(apply = w %) ls) w nil))\n        ]\n    (or (won? :x) (won? :o))))","user":"553e0b70e4b0a04f792994e8"},{"problem":73,"code":"(fn [[[a b c :as l1]\n      [d e f :as l2]\n      [g h i :as l3]]] (let [tic [[a e i]\n                                 [c e g]\n                                 [a d g]\n                                 [b e h]\n                                 [c f i]\n                                 l1 l2 l3]]\n                         (letfn [(chk [p] (some #{p} (map #(if (every? #{:x} %) :x\n                                               (if (every? #{:o} %) :o\n                                                 :e)) tic)))]\n                         (if (chk :x) :x\n                           (if (chk :o)\n                             :o\n                             nil)))))","user":"53e2ac1ae4b036ad0777e3f3"},{"code":"(fn [b] (let [transpose #(apply map vector %)\r\n                      players   #{:x :o}\r\n                      all-same #(reduce (fn [a x] (if (= a x) a nil)) %)\r\n                      find-winner (fn [lines] (some #(players (all-same %)) lines))\r\n                      diag #(vector (map nth % (range 3)) (map nth % (range 2 -1 -1)))]\r\n                  (find-winner (concat b (transpose b) (diag b)))\r\n                  ))","problem":73,"user":"503d129fe4b06c4e0e1fa254"},{"problem":73,"code":"(fn ttt [[[ul um ur][ml mm mr][ll lm lr]]]\n  (let [lines [[ul um ur][ml mm mr][ll lm lr][ul ml ll][um mm lm][ur mr lr][ul mm lr][ll mm ur]]]\n    (some #{:x :o} (mapv (fn [[a b c]] (if (= a b c) a :e)) lines))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h k]]]\n  (let [s (set [[a e k] [c e g]\n   [a d g] [b e h] [c f k]\n   [a b c] [d e f] [g h k]\n   ])]\n    (if\n      (s [:x :x :x]) :x\n      (if (s [:o :o :o]) :o nil)\n      )\n    )\n  )","user":"55e1d34ae4b050e68259b421"},{"code":"(fn winner[board]\n  (let [analize-row (fn[row]\n                      (if (reduce #(and % %2) (map #(= :x %) row)) :x\n                        (if (reduce #(and % %2) (map #(= :o %) row)) :o\n\t                        nil)))\n        all-winnable (fn[[[a1 b1 c1] [a2 b2 c2] [a3 b3 c3]]]\n                        [[a1 b1 c1] [a2 b2 c2] [a3 b3 c3][a1 a2 a3][b1  b2 b3][c1 c2 c3][a1 b2 c3][a3 b2 c1]])]\n        (reduce #(or % %2) (map analize-row (all-winnable board)))))","problem":73,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":73,"code":"(letfn\n  [  ; First test: horizontal line of key \"k\"?\n    (test1 [board k]\n      (some (partial = #{k}) (map set board)))\n\n    ; Second test: diagonal of key \"k\"?\n    (test2 [board k]\n      ( = #{k} (set (map #(get-in board [% %]) [0 1 2]))))\n    \n    ; Third test: the other diagonal of key \"k\"?\n    (test3 [board k]\n      (= #{k} (set (map #(get-in board %) [[2 0] [1 1] [0 2]]))))\n    \n    ; Transpose board.\n    (transpose [board]\n      (apply map list board))\n\n    ; Full test for key \"k\".\n    (full-test [board k]\n      (or (test1 board k)\n          (test2 board k)\n          (test1 (transpose board) k)\n          (test3 board k)))]\n\n    ; Full test\n    (fn winner [board]\n      (cond\n       (true? (full-test board :o)) :o\n       (true? (full-test board :x)) :x\n       :else nil)))","user":"53065acbe4b02e8216869792"},{"problem":73,"code":"(fn [coll]\n   (first (some #{[:x :x :x] [:o :o :o]}\n         (concat\n           coll\n           ((fn [[row1 row2 row3]] (map vector row1 row2 row3)) coll)\n           ((fn [[[nw _ ne] [_ m _] [sw _ se]]] [[nw m se] [ne m sw]]) coll)))))","user":"54094824e4b0addc1aec66da"},{"code":"(fn [rows]\n  (let [columns (apply map list rows)\n        two-d (fn [i j] (nth (nth rows i) j))\n        diagonals [[(two-d 0 0) (two-d 1 1) (two-d 2 2)]\n                   [(two-d 0 2) (two-d 1 1) (two-d 2 0)]]\n        lines (concat rows columns diagonals)\n        won? (fn [player] (some (fn [line] (every? #(= player %) line)) lines))]\n    (cond (won? :x) :x\n          (won? :o) :o\n          :default nil)))","problem":73,"user":"4e39fb68535deb9a81d77f47"},{"problem":73,"code":"(fn [rows]\n  (let [columns (map #(map (fn [row] (nth row %)) rows) (range (count rows)))\n        diags (map #(map (fn [i] (-> % (nth i) (nth i))) (range (count rows))) [rows (rseq rows)])]\n    (->> (concat rows columns diags)\n         (map set)\n         (some #(when (#{#{:x} #{:o}}%) (first %))))))","user":"5383668ee4b06839e8705edd"},{"problem":73,"code":"(fn analyze-board [b]\n  (let [line-res (fn [lr]\n                   (let [s (set lr)]\n                     (when (= 1 (count s))\n                       (or (:x s) (:o s)))))\n        line-values (fn [line-points]\n                      (map #(get-in b %) line-points))\n        all-line-points '(([0 0] [0 1] [0 2])\n                          ([1 0] [1 1] [1 2])\n                          ([2 0] [2 1] [2 2])\n                          ((0 0) (1 0) (2 0))\n                          ((0 1) (1 1) (2 1))\n                          ((0 2) (1 2) (2 2))\n                          ([0 0] [1 1] [2 2])\n                          ([2 0] [1 1] [0 2]))]\n    (some identity (map (comp line-res line-values) all-line-points))))","user":"571d063ee4b0145328a76272"},{"problem":73,"code":"(fn [x]\n     (let [table (zipmap [1 2 3 4 5 6 7 8 9] (flatten (apply map vector [x])))]\n       (println \"table\" table)\n       (let [winners [[1 2 3] [4 5 6] [7 8 9] [1 4 7] [2 5 8] [3 6 9] [1 5 9] [3 5 7]]]\n         (let [result (map(fn [x] (map table x)) winners)]\n           ;(println \"result\" result \"x?\" (some #{'(:x :x :x)} result))\n           (cond\n             (some #{'(:x :x :x)} result) :x \n             (some #{'(:o :o :o)} result) :o\n             :else nil)\n           ))))","user":"5ac92dc3e4b0e27600da77bf"},{"problem":73,"code":";(fn [xs]\n;  (letfn [\n;          (rows [] [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n;                    [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]\n;                    [[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]])\n;          (path [xs row] (map #(get-in xs %) row))\n;          (win? [path] (and (not= :e (first path)) (apply = path)))]\n;    (ffirst (filter win? (map #(path xs %) (rows))))))\n\n(fn [xs]\n  (let [paths [0 1 2, 3 4 5, 6 7 8, 0 3 6, 1 4 7, 2 5 8, 0 4 8, 2 4 6]\n        board (vec (flatten xs))\n        scores (partition 3 (map #(board %) paths))\n        win? #(and (not= :e (first %)) (apply = %))\n        wins (ffirst (filter win? scores))]\n    wins))","user":"5a544eeee4b05d388ecb6c24"},{"problem":73,"code":"(fn [b]\n  (let [all (concat\n             b\n             (apply map vector b)\n             [(map get b [0 1 2])]\n             [(map get b [2 1 0])])\n        win (filter (fn [c] (or (every? #(= % :o) c) (every? #(= % :x) c))) \n                    all)]\n    (if (empty? win)\n      nil\n      (ffirst win)\n      ))\n  )","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"(fn [mtx]\n  (some\n    #(let [s (set %) f (first s)] (if-not (or (= f :e) (second s)) f))\n    (lazy-cat\n      mtx\n      (apply mapv vector mtx)\n      (let [mid (get-in mtx [1 1])]\n          [[(first (first mtx)) mid (last (last mtx))]\n           [(last (first mtx)) mid (first (last mtx))]]))))","problem":73,"user":"50bfe95ce4b080409b860f27"},{"code":"(fn [board]\n  (letfn [(nice-ret [vals] (first (filter #(not (false? %)) vals)))\n          (line-win [line] (if (and (not= (first line) :e) (apply = line)) (first line) false))\n          (horizontal-win [board] \n            (nice-ret (map line-win board)))\n          (vertical-win [board]\n            (nice-ret (map #(line-win [%1 %2 %3]) (first board) (second board) (last board))))\n          (diagonal-win [board]\n            (or\n             (line-win [(first (first board)) (second (second board)) (last (last board))])\n             (line-win [(last (first board)) (second (second board)) (first (last board))])))]\n    (or (horizontal-win board) (vertical-win board) (diagonal-win board) nil)))","problem":73,"user":"523288fee4b035af41902a88"},{"code":"(fn [board] \n  (let [winning-positions [[[0 0] [1 1] [2 2]] \n                           [[0 2] [1 1] [2 0]]\n                           [[0 0] [1 0] [2 0]]\n                           [[0 1] [1 1] [2 1]]\n                           [[0 2] [1 2] [2 2]]\n                           [[0 0] [0 1] [0 2]]\n                           [[1 0] [1 1] [1 2]]\n                           [[2 0] [2 1] [2 2]]]\n        ganhou? (->> (map (fn [cada] (map #(get-in board %) cada)) winning-positions) \n                      (filter #{'(:x :x :x) '(:o :o :o)})\n                      (ffirst )\n                      )]\n    ganhou?))","problem":73,"user":"4ff4bed0e4b0678c553fc35f"},{"code":"(fn tic-toc [board]\n  (letfn [(resolvefunc [[[a b c]\n               [d e f]\n               [g h i]] p] (or (= p a b c)\n                                (= p d e f)\n                               (= p g h i)\n                               (= p a d g)\n                               (= p b e h)\n                               (= p c f i)\n                               (= p a e i)\n                               (= p c e g)))]\n    (cond (resolvefunc board :x) :x\n          (resolvefunc board :o) :o\n          :else nil)))","problem":73,"user":"52e614b8e4b09f7907dd1469"},{"code":"(fn [g]\r\n  (let [h? (fn [p] (some #(every? (partial = p) %) g))\r\n        v? (fn [p] (some (fn [c]\r\n                            (every? (partial = p)\r\n                              (map #(nth (nth g %) c)\r\n                                   [0 1 2])))\r\n                         [0 1 2]))\r\n        d? (fn [p] (some (fn [vs]\r\n                            (every? (partial = p)\r\n                               (map (fn [[r c]]\r\n                                      (nth (nth g r) c))\r\n                                    vs)))\r\n                          [[[0 0] [1 1] [2 2]]\r\n                           [[0 2] [1 1] [2 0]]]))\r\n\r\n        won? (fn [p] (or (h? p) (v? p) (d? p)))]\r\n    (if (won? :x) :x (if (won? :o) :o nil))))","problem":73,"user":"4e8681b7535dae1a5effa438"},{"problem":73,"code":"(fn winner [board]\n(letfn\n    [(out-of-range [y x]\n       (or (> x 2) (> y 2) (< x 0) (< y 0)))\n     (count-sign [board sign y x dy dx cnt]\n       (cond\n         (out-of-range y x)\n         cnt\n         (= (nth (nth board y) x) sign)\n         (count-sign board sign (+ y dy) (+ x dx) dy dx (+ cnt 1))\n         :else\n         (count-sign board sign (+ y dy) (+ x dx) dy dx cnt)))\n\n     (count-left [board sign y x]\n       (count-sign board sign y x 0 -1 0))\n     (count-right [board sign y x]\n       (count-sign board sign y x 0 1 0))\n     (count-up [board sign y x]\n       (count-sign board sign y x -1 0 0))\n     (count-down [board sign y x]\n       (count-sign board sign y x 1 0 0))\n     (count-diag-up-left [board sign y x]\n       (count-sign board sign y x -1 -1 0))\n     (count-diag-up-right [board sign y x]\n       (count-sign board sign y x -1 1 0))\n     (count-diag-down-left [board sign y x]\n       (count-sign board sign y x 1 -1 0))\n     (count-diag-down-right [board sign y x]\n       (count-sign board sign y x 1 1 0))\n\n     (count-all-directions [board sign y x]\n       (or\n        (= 3 (count-left board sign y x))\n        (= 3 (count-right board sign y x))\n        (= 3 (count-up board sign y x))\n        (= 3 (count-down board sign y x))\n        (= 3 (count-diag-down-left board sign y x))\n        (= 3 (count-diag-down-right board sign y x))\n        (= 3 (count-diag-up-left board sign y x))\n        (= 3 (count-diag-up-right board sign y x))))\n\n     (iter [board y x]\n       (if (= 3 y)\n         nil\n         (let\n             [sign (nth (nth board y) x)\n              is-winner (and (not (= sign :e)) (count-all-directions board sign y x))\n              next-y (if (= x 2) (+ y 1) y)\n              next-x (if (= x 2) 0 (+ x 1))]\n           (if is-winner\n             sign\n             (iter board next-y next-x)))))\n\n     (get-winner [board]\n       (iter board 0 0))]\n  (get-winner board)))","user":"601004d6e4b074f607df66b2"},{"problem":73,"code":"(fn [board]\n  (let [flat (flatten board)\n        verts (apply map vector board)\n        diag-1 (take-nth 4 flat)\n        diag-2 (take 3 (take-nth 2 (drop 2 flat)))\n        all-rows (concat verts board [diag-1 diag-2])\n        full-row? (fn [pred] (some #(every? pred %) all-rows))]\n    (cond\n     (every? :e flat) nil\n     (full-row? #(= :x %)) :x\n     (full-row? #(= :o %)) :o\n     :else nil)))","user":"54926752e4b0b312c081ff44"},{"problem":73,"code":"(fn [board]\n  (let [rows (concat board\n                     (apply map vector board)\n                     [(map nth board (range 3))\n                      (map nth board (range 2 -1 -1))])]\n    (cond\n     (some #{[:x :x :x]} rows) :x\n     (some #{[:o :o :o]} rows) :o\n     :else nil)))","user":"575cbe44e4b02ea114799374"},{"code":"(fn check-winner [board]\n  (letfn [(columns [board]\n                   (apply (partial map vector) board))\n          (diagonals [board]\n                     (let [c (count board)\n                           is (range c)]\n                       [(map #(nth (nth board %) %) is)\n                        (map #(nth (nth board %) (- c % 1)) is)]))]\n    (let [all (reduce into [(columns board) board (diagonals board)])]\n      (cond (some (fn [l]\n                    (every? #(= :x %) l))\n                  all) :x\n            (some (fn [l]\n                    (every? #(= :o %) l))\n                  all) :o\n            :else nil))))","problem":73,"user":"4e7e4a1f535db169f9c7970c"},{"code":"(fn [mat]\n    (let [rows\n        (concat\n            mat\n            (partition 3 (apply interleave mat))\n            (#(list\n                (list (first (first %)) (second (second %)) (last (last %)))\n                (list (last (first %))  (second (second %)) (first (last %)))\n            ) mat)\n        )]\n        (first (some #{[:x :x :x] [:o :o :o]} rows))\n    )\n)","problem":73,"user":"51059d33e4b0380e797c7d5c"},{"code":"(fn [board]\n  (let [valid [5 50 149 45 66 93 80 56]]\n    (->> board\n         flatten\n         (interleave (map #(Math/pow % 2) (range 9)))\n         (partition 2)\n         (group-by second)\n         (map (fn [[a b]] (list a (reduce #(+ %1 (first %2)) 0 b))))\n         (map (fn [[a b]] [a (some (hash-set (int b)) valid)]))\n         (filter #(not (nil? (second %))))\n         ffirst)))","problem":73,"user":"530cb5b8e4b02e82168697e0"},{"problem":73,"code":"(fn [l]\n   (some \n    (fn [i] \n      (cond\n       (every?  #(= % :x) i) :x\n       (every? #(= % :o) i) :o\n       :else nil\n       )) \n   \t(concat l (apply (partial map vector) l)  (reduce (fn [[a b] c] (vector(cons (nth c (count a)) a)  (cons (nth c (- (count c) (count b) 1)) b))  ) [[][]] l) )))","user":"54edcf96e4b024c67c0cf866"},{"problem":73,"code":"(fn tictactoe [board']\n  (let [combs [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        board (flatten board')\n        win-x (some #(every? (fn [i] (= :x (nth board i))) %) combs)\n        win-o (some #(every? (fn [i] (= :o (nth board i))) %) combs)]\n    (cond \n      (and win-x win-o) nil\n      win-x :x\n      win-o :o\n      :else nil)))","user":"60606490e4b03746e80ebf67"},{"problem":73,"code":"(fn [board]\n  (let [rows_cols (concat board (apply mapv vector board))\n        solutions  (conj \n                     rows_cols\n                     [(first (first board)) (second (second board)) (last (last board))]\n                     [(last (first board)) (second (second board)) (first (last board))])]\n    (->> solutions\n         (mapv #(filter #{:x :o} %))\n         (mapv frequencies)\n         (map #(filter (comp #{3} last) %))\n         (map keys)\n         (some #(when (not (nil? %)) %))\n         (first))))","user":"5e228b5ae4b05b4b01516134"},{"code":"(fn [m]\n  (let [diagonal (fn [m] (vec (for [i (range (count m))] ((m i) i))))\n  antidiagonal (fn [m] (vec (for [i (range (count m))] ((m i) (- 2 i)))))\n        transpose (fn [m] (let [rows (count m)]\n\t                 (vec (for [i (range rows)]\n\t\t             (vec (for [j (range rows)]\n\t\t\t\t    ((m j) i)))))))\n\trowkey (fn [r] (cond\n\t                   (= [:o :o :o] r) :o\n\t                   (= [:x :x :x] r) :x\n\t                   :else nil))]\n        \t(let [mp (transpose m)\n\t\t      diag (diagonal m)\n\t\t      antidiag (antidiagonal m)\n\t\t      rlist (vec (concat m mp [diag] [antidiag]))]\n         (loop [i 0]\n\t    (if (= i (count rlist)) nil\n\t       (if-let [key (rowkey (rlist i))] key\n\t          (recur (inc i))))))))","problem":73,"user":"4e6e3a1e535d5021c1a89602"},{"problem":73,"code":"(fn [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]\n  (let [lines [[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]\n               [a1 b1 c1] [a2 b2 c2] [a3 b3 c3]\n               [a1 b2 c3] [a3 b2 c1]]]\n    (first (some #{[:x :x :x] [:o :o :o]} lines))))","user":"5540cc0ce4b0a04f79299505"},{"problem":73,"code":"(fn [\n  [ [a1 b1 c1]\n    [a2 b2 c2]\n    [a3 b3 c3]\n  ]]\n (let [ lanes\n  [ [a1 b1 c1] [a2 b2 c2] [a3 b3 c3]\n    [a1 a2 a3] [b1 b2 b3] [c1 c2 c3]\n    [a1 b2 c3] [a3 b2 c1]     \n  ]]\n    (some\n     #(when (or (apply = :x %) (apply = :o %)) (first %))\n     lanes)))","user":"5b500215e4b02d533a91bce2"},{"problem":73,"code":"(fn [board]\n  (letfn [(win?\n            [coll]\n            (let [[h & t] coll]\n              (when (and (not= h :e) (every? (fn [e] (= e h)) t))\n                h)))]\n    (some win?\n          (concat board\n                  (apply map vector board)\n                  (list (map (fn [r i] (nth r i)) board (range 3)))\n                  (list (map (fn [r i] (nth r i)) board (reverse (range 3))))))))","user":"4ee528fb535d1385b2869d87"},{"problem":73,"code":"(fn [board]\n   (let [lines (concat board\n                       ((fn transpose [board]\n                          (map #(map (fn [line] (line %)) board)\n                               (range (count (board 0))))) board)\n                       ((fn diagnal [board]\n                          (let [dim (count board)]\n                            [(map #((board %) %) (range dim))\n                             (map #((board (- dim 1 %)) %) (range dim))])) board))]\n     (cond (not (empty? (filter #(= % [:x :x :x]) lines))) :x\n           (not (empty? (filter #(= % [:o :o :o]) lines))) :o\n           :else nil)))","user":"554b7056e4b0a04f79299583"},{"code":"(fn [x]\r\n  (let [win? (fn [c]\r\n          (let [a (first c)]\r\n            (if (and (not= a :e) (every? #(= a %) c)) a)))\r\n          [[a b c] [d e f] [g h i]] x\r\n          p (some identity (map win? x))\r\n          q (some identity (map win? (apply map vector x)))\r\n          r (win? (vector a e i))\r\n          s (win? (vector c e g))]\r\n      (cond p p q q r r s s)))","problem":73,"user":"4e44358f535dc968683fc4a8"},{"code":"(fn [rows]\n  (letfn [(check-win [player]\n                     (or\n                      (some (fn [row] (every? #(= player %) row)) rows)\n                      (some (fn [col-idx] (every? #(= player (% col-idx)) rows)) (range 3))\n                      (= player ((rows 0) 0) ((rows 1) 1) ((rows 2) 2))\n                      (= player ((rows 0) 2) ((rows 1) 1) ((rows 2) 0))))]\n    (cond (check-win :x) :x\n          (check-win :o) :o\n          :else nil)))","problem":73,"user":"510acd6ee4b078ea719210f4"},{"problem":73,"code":"(fn [board]\n    (let [indices (range (count board))]\n      (let [rows board\n            cols (letfn [(get-col [ncol]\n                           (map #(% ncol) board))]\n                   (map get-col indices))\n            diags (vector (map #(%1 %2) board indices)\n                          (map #(%1 %2) board (reverse indices)))]\n        (letfn [(check [squares]\n                  (if (every? #(= (first squares) %) squares)\n                    (if (= (first squares) :e)\n                      nil\n                      (first squares))\n                    nil))\n                (check-seqs [board-seqs]\n                  (if (empty? board-seqs)\n                    nil\n                    (let [result (check (first board-seqs))]\n                      (if result\n                        result\n                        (recur (rest board-seqs))))))]\n          (check-seqs (concat rows cols diags))))))","user":"543d89dfe4b032a45b869350"},{"problem":73,"code":"(fn ttt [[[c11 c12 c13 :as r1]\n          [c21 c22 c23 :as r2]\n          [c31 c32 c33 :as r3]]]\n  (let [c1 [c11 c21 c31]\n        c2 [c12 c22 c32]\n        c3 [c13 c23 c33]\n        d1 [c11 c22 c33]\n        d2 [c31 c22 c13]]\n    (loop [ps [r1 r2 r3 c1 c2 c3 d1 d2]]\n      (when (seq ps)\n        (if (apply = (first ps))\n          (if (= (ffirst ps) :e)\n            (recur (rest ps))\n            (ffirst ps))\n          (recur (rest ps)))))))","user":"5f300f28e4b033932238a682"},{"problem":73,"code":"(fn [t] \n  (first \n    (some #{#{:o}#{:x}} \n          (map set (concat \n     \t\tt\n     \t\t(apply map list t)\n     \t\t(map #(map get % [0 1 2]) [t (rseq t)]))))))","user":"561047eae4b05f002753df6d"},{"problem":73,"code":"(fn [board] \n  (let [spaces (for [x [0 1 2] y [0 1 2]] [x y])\n        confs [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        get-spaces (fn [board conf] (map #(get-in board (nth spaces %)) conf))\n        match-conf? (fn [board conf player] (apply = (conj (get-spaces board conf) player)))]\n    (some #(when (or (match-conf? board % :o) (match-conf? board % :x)) (first (get-spaces board %))) confs)))","user":"549c3e0ce4b0f3d1d8e70f87"},{"code":"(fn tic [rows]\n  (let [cols (apply map vector rows)\n        c (second (second rows))\n        d1 [(ffirst rows) c (last (last rows))]\n        d2 [(last (first rows)) c (first (last rows))]\n        lines (concat rows cols [d1 d2])]\n    (letfn [(line [player s]\n              (apply = (cons player s)))\n            (won [player]\n              (some identity (map (partial line player) lines)))]\n      (cond (won :x) :x\n            (won :o) :o\n            :else nil))))","problem":73,"user":"4fbd12a5e4b081705acca2fd"},{"problem":73,"code":"(fn [board]\n  (let [flat-board (-> board flatten vec)\n        line-indexes [[0 1 2]\n                      [3 4 5]\n                      [6 7 8]\n                      [0 3 6]\n                      [1 4 7]\n                      [2 5 8]\n                      [0 4 8]\n                      [2 4 6]]]\n    (->> line-indexes\n         (map (partial map flat-board))\n         (remove #(some (partial = :e) %))\n         (filter (partial apply =))\n         ffirst)))","user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [board]\n  (let [\n        third (fn [x] (nth x 2))\n        check (fn [seq]  (if (and (not= (first seq) :e)(apply = seq)) \n    (first seq)))\n        \n      ]\n    (or\n\t\t; rows\n\t\t(check (first board))\n\t\t(check (second board))\n\t\t(check (third board))\n\t\t; columns\n\t\t(check (map first board))\n\t\t(check (map second board))\n\t\t(check (map third board))\n\t\t; diagonals\n\t\t(check (list (first (first board))\n\t\t   (second (second board))\n\t\t   (third (third board))))\n\t\t(check (list (third (first board))\n\t\t   (second (second board))\n\t\t   (first (third board)))))))","problem":73,"user":"4f8beb2fe4b02e764a0a5185"},{"problem":73,"code":"(fn tic-tac-toe-winner [m]\n  (->>\n   (concat m (apply map vector m) ((fn diags [c]\n                                     (let [diag (fn [x] (reduce #(conj %1 (nth %2 (count %1))) [] x))]\n                                       [(diag c) (diag (reverse c))])) m))\n   (filter (fn winning\n  [c]\n  (->> c\n       (partition-by identity)\n       (filter #(and (= (count %) (count c)) (not=(first %) :e)))\n       (first))))\n   (first)\n   (first)))","user":"5ed6030de4b016b56eae05db"},{"problem":73,"code":"(fn [board]\n  (letfn \n  \t[(transpose [m] (apply mapv vector m))\n  \t (diagonal [m] (map-indexed #(nth %2 %1) m))\n  \t (flatten-board [m] (concat m (transpose m) [(diagonal m)] [(diagonal (reverse m))]))\n     (winner? [r] (if (= 1 (count (distinct r))) (first r) nil))\n    ]\n    (first (remove #(or (nil? %) (= :e %)) (map winner? (flatten-board board))))\n   ))","user":"54227fc6e4b01498b1a71ac0"},{"code":"(fn [grid]\n(letfn\n  [(horiz-win? [player] (some (fn [row] (every? #(= player %) row)) grid))\n   (vert-win-col? [player column] (every? #(= player %) (map #(nth % column) grid)))\n   (vert-win? [player] (or (vert-win-col? player 0) (vert-win-col? player 1) (vert-win-col? player 2)))\n   (player-at? [player c r] (= player ((grid r) c)))\n   (diag-win? [player] (and (player-at? player 1 1)\n                                 (or (and (player-at? player 0 0) (player-at? player 2 2))\n                                     (and (player-at? player 2 0) (player-at? player 0 2)))))]\n  (cond\n   (some #(% :x) [horiz-win? vert-win? diag-win?]) :x\n   (some #(% :o) [horiz-win? vert-win? diag-win?]) :o\n   :else nil)))","problem":73,"user":"4ffa893fe4b0678c553fc3bc"},{"problem":73,"code":"(fn [rows]\n  (letfn [(won? [k] (or\n                        (some #{[k k k]} rows)\n                        (some #{[k k k]} (apply map vector rows))\n                        (= (map #(% %2) rows [0 1 2]) [k k k])\n                        (= (map #(% %2) rows [2 1 0]) [k k k])\n                        false))]\n    (cond (won? :x) :x (won? :o) :o :else nil)))","user":"5db92996e4b010eb3c36cd50"},{"problem":73,"code":"(fn winner [board]\n  (let [rows board\n        cols (apply mapv vector board)\n        max-index (dec (count board))\n        diags [(map-indexed (fn [idx row] (row idx)) board)\n               (map-indexed (fn [idx row] (row (- max-index idx))) board)]\n        all (concat rows cols diags)\n        win-fn (fn win [lst]\n                 (when-let [s (set lst)]\n                   (when (and (= 1 (count s))\n                              (#{:x :o} (first s)))\n                     (first s))))]\n    (->> all\n         (map win-fn)\n         (remove nil?)\n         first)))","user":"551bdefde4b07993ea3788d7"},{"code":"(fn ttt [b]\n  (letfn [(w [[[a b c]\n               [d e f]\n               [g h i]] p] (or (= p a b c)\n                               (= p d e f)\n                               (= p g h i)\n                               (= p a d g)\n                               (= p b e h)\n                               (= p c f i)\n                               (= p a e i)\n                               (= p c e g)))]\n    (cond (w b :x) :x\n          (w b :o) :o\n          :else nil)))","problem":73,"user":"509e62a8e4b08df8156e9e2e"},{"problem":73,"code":"(fn tic-tac-toe [matrix]\n  (let [align (fn [items] (if (apply = items) ({:x :x :o :o :e nil} (first items)) nil))]\n    (some align (concat matrix \n                        (vector (map first matrix))\n                        (vector (map second matrix))\n                        (vector (map last matrix))\n                        (vector [(first (first matrix)) (second (second matrix)) (last (last matrix))])\n                        (vector [(first (last matrix)) (second (second matrix)) (last (first matrix))])\n                        ))))","user":"56979bb7e4b0e0b3d3318cac"},{"code":"(fn analyzeTicTacToe\n  ;Analyze a Tic-Tac-Toe board of arbitrary size for a winner.\n  ;Input is a 2D array (dense matrix, no empty spots) where\n  ;  :x represents X player moves\n  ;  :o represents O player moves\n  ;  :e represents empty spaces.\n  ;Example input:\n  ;    (def board [[:x :e :e]\n  ;                [:o :x :e]\n  ;                [:o :e :x]])\n  ;    (analyzeTicTacToe board)\n  ;    => :x\n  [board]\n\n  (let ; Replace :e with nulls, for simplicity\n      [board (map (partial map #(condp = % :e nil %)) board)\n       ; Check if all elements of the collection are the same\n        same (fn [coll] (when (apply = coll) (first coll)))\n       ; Check if all elements of any of the collections within this collection are the same\n        same2d (fn [mtx] (some #(when (comp not nil? %) %) (map same mtx)))\n       ; Transpose a matrix (borrowed from RosettaCode)\n        transpose (fn [mtx] (vec (apply map vector mtx)))\n       ; Extract the two main diagonals of the matrix\n        diagonals (fn [mtx] (transpose (for [i (range (count mtx))] [(nth (nth mtx i) i) (nth (nth mtx i) (- (count mtx) 1 i))])) )]\n\n    ; If any of the rows are the same, or any of the columns are the same, or any of the diagonals are all the same\n    (or (same2d board) (same2d (transpose board)) (same2d (diagonals board)))\n  ))","problem":73,"user":"53307da1e4b019098a6f8b5e"},{"problem":73,"code":"(fn [board]\n    (letfn [(check [key]\n              (if (some #{[key key key]} board)\n                key\n                (if (some #{[key key key]}\n                          (reduce (fn [result row]\n                                    (-> result\n                                        (update-in [0] conj (first row))\n                                        (update-in [1] conj (second row))\n                                        (update-in [2] conj (last row))))\n                                  [[] [] []]\n                                  board))\n                  key\n                  (if (or\n                       (= key (get-in board [0 0])\n                         (get-in board [1 1])\n                         (get-in board [2 2]))\n                       (= key (get-in board [0 2])\n                          (get-in board [1 1])\n                          (get-in board [2 0])))\n                    key\n                    nil))))]\n      (if (check :x)\n        :x\n        (if (check :o)\n          :o\n          nil))))","user":"586b6753e4b01531a375e956"},{"problem":73,"code":"(fn [x]\n  (letfn\n   [(value [x]\n     (let [x0 (get x 0)]\n      (if (= (get x 1)\n             (get x 2)\n             x0)\n        x0 nil)))\n\n    (getxo [z]\n           (loop [x z]\n            (if (empty? x) nil\n             (if (or (nil? (first x)) (= :e (first x)))\n               (recur (rest x))\n               (first x)))))\n    (h [] (getxo (map value x)))\n    (v [xx] (getxo (map value (apply mapv vector xx))))\n    (x1 [xx] \n        (vec (for [z [0 1 2]]\n              (get (get xx z) z))))\n    (x2 [xx] \n        (vec (for [z [0 1 2]]\n              (get (get xx z) (- 2 z)))))\n    (valx1 [xx] (getxo (list (value (x1 xx)))))\n    (valx2  [xx] (getxo (list (value (x2 xx)))))]\n   (let [h (h)]\n     (cond\n       (not (nil? h)) h\n       (not (nil? (v x))) (v x)\n       (not (nil? (valx1 x))) (valx1 x)\n       (not (nil? (valx2 x))) (valx2 x)\n       :else nil))))","user":"5b9ae606e4b0c0b3ffbd4af2"},{"problem":73,"code":"(fn prob73 [rows]\n  (letfn\n      [(winner [triple]\n         (cond\n           (apply = :o triple) :o\n           (apply = :x triple) :x))]\n    (or\n     (when-first [w (filter winner rows)] (first w))\n     (when-first\n         [w (filter winner\n                (map (fn [col] (map #(nth % col) rows)) (range 3)))]\n       (first w))\n     (winner (map #((rows %) %) (range 3)))\n     (winner (map #((rows %) (- 2 %)) (range 3))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n\n  (let [rcd [[a b c][d e f][g h i] ;; rows\n             [a d g][b e h][c f i] ;; cols\n             [a e i][c e g]]]      ;; diags\n    (reduce \n      #(let [ft (first %2)]\n        (if (and (apply = %2)(not= :e ft)) ft %1))\n      nil\n      rcd)))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":73,"code":"(fn [board] \n  (let [rows (seq board)\n        cols (map #(map (partial get-in board) %) (for [j (range 3)] (for [i (range 3)] [i j])))\n        diags [(map #(get-in board %) [[0 0] [1 1] [2 2]])\n               (map #(get-in board %) [[0 2] [1 1] [2 0]])]]\n    (cond\n     (some #(= true %) (map (partial every? #(= :x %)) (concat rows cols diags))) :x\n     (some #(= true %) (map (partial every? #(= :o %)) (concat rows cols diags))) :o\n     :else nil)))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn\r\n    [[r1 r2 r3]]\r\n    (cond\r\n     (every? #(= % :x) r1) :x ; row 1 X\r\n     (every? #(= % :x) r2) :x ; row 2 X\r\n     (every? #(= % :x) r3) :x ; row 3 X\r\n     (every? #(= % :o) r1) :o ; row 1 O\r\n     (every? #(= % :o) r2) :o ; row 2 O\r\n     (every? #(= % :o) r3) :o ; row 3 O\r\n     (every? #(= % :x) (map first [r1 r2 r3])) :x      ; col 1 X\r\n     (every? #(= % :x) (map second [r1 r2 r3])) :x     ; col 2 X\r\n     (every? #(= % :x) (map #(nth % 2) [r1 r2 r3])) :x ; col 3 X\r\n     (every? #(= % :o) (map first [r1 r2 r3])) :o      ; col 1 Y\r\n     (every? #(= % :o) (map second [r1 r2 r3])) :o     ; col 2 Y\r\n     (every? #(= % :o) (map #(nth % 2) [r1 r2 r3])) :o ; col 3 Y\r\n     (= (first r1) (second r2) (nth r3 2) :x) :x\r\n     (= (nth r1 2) (second r2) (first r3) :x) :x\r\n     (= (first r1) (second r2) (nth r3 2) :o) :o\r\n     (= (nth r1 2) (second r2) (first r3) :o) :o\r\n     :else nil))","problem":73,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":73,"code":"(fn [in]\n  (let [[[a b c][d e f][g h i]] in\n      coll (map distinct [[a b c][d e f][g h i][a d g][b e h][c f i][a e i][g e c]])]\n  (ffirst (remove #(and (not= '(:x) %) (not= '(:o) %)) coll))))","user":"557e8326e4b05c286339e0d7"},{"problem":73,"code":"(fn check [board]\n  (letfn [(check-ttt [elem board]\n            (let [all-elem (fn [l] (every? (fn [e] (= e elem)) l))\n                  size (count board)]\n              (or\n                ; check row\n                (some\n                  (fn [row] (all-elem row))\n                  board)\n                ; check col\n                (some\n                  (fn [idx]\n                    (all-elem\n                      (map\n                        (fn [row] (nth row idx))\n                        board)))\n                  (range size))\n                ; check downright diag\n                (all-elem\n                  (map-indexed\n                    (fn [i row] (nth row i))\n                    board))\n                ; check downleft diag\n                (all-elem\n                  (map-indexed\n                    (fn [i row] (nth row (- (- size 1) i)))\n                    board)))))]\n    (if (check-ttt :x board)\n      :x\n      (if (check-ttt :o board)\n        :o))))","user":"5b840b68e4b047b03b2037bc"},{"code":"(fn [b]\n  (let [l (set (map \n                 #(set (for [[x y] %] ((b y) x)))\n                 [[[0 0] [0 1] [0 2]]\n                  [[1 0] [1 1] [1 2]]\n                  [[2 0] [2 1] [2 2]]\n                  [[0 0] [1 0] [2 0]]\n                  [[0 1] [1 1] [2 1]]\n                  [[0 2] [1 2] [2 2]]\n                  [[0 0] [1 1] [2 2]]\n                  [[0 2] [1 1] [2 0]]]))]\n    (if (contains? l #{:x})\n      :x (if (contains? l #{:o})\n           :o nil))))","problem":73,"user":"512f06c5e4b0762be4c7aad7"},{"problem":73,"code":"(fn winner-tic-tac-toe [rows]\n  (letfn [\n          (column [rows i]\n                  (let [n (count rows)]\n                    (map #(nth % i) rows)))\n\n          (inverse [rows]\n                   (let [n (count rows)]\n                     (map #(column rows %) (range 0 n))))\n\n          (diagonal1 [rows]\n                     (let [n (count rows)]\n                       (map\n                        #((rows %) %)\n                        (range 0 n))))\n\n          (diagonal2 [rows]\n                     (let [n (count rows)]\n                       (map\n                        #((rows (dec (- n %))) %)\n                        (range 0 n))))\n\n          (all-comb [rows]\n                    (into (into rows (inverse rows)) [(diagonal1 rows) (diagonal2 rows)]))\n\n          (get-wining-comb [rows]\n                           (let [combs (all-comb rows)]\n                             (filter \n                              (fn [row] \n                                (or (every? #(= % :x) row) (every? #(= % :o) row))) \n                              combs)))\n          ]\n    (let [winning-combs (get-wining-comb rows)]\n      (cond\n       (empty? winning-combs) nil\n       :else (first (first winning-combs))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":73,"code":"(fn [ tic-tac-board ]\n  (let\n    [ vert-rows (apply map (fn [ one two three] [ one two three]) tic-tac-board)\n    , diag-rows (let [[[t1 t2 t3] [t4 t5 t6] [t7 t8 t9]] tic-tac-board] [[t1, t5, t9], [t3, t5, t7]])\n    , all-rows (concat tic-tac-board vert-rows diag-rows)\n    , all-same #(map (fn [ line ] (every? (partial = %1) line)) all-rows)\n    , any-true #(some (partial = true) %)\n    ]\n    (cond\n      (any-true (all-same :o)) :o\n      (any-true (all-same :x)) :x\n      :else nil)))","user":"59f90e6ae4b0ca45a743a337"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (ffirst\n   (for [x (range 0 3)\n         y (range 0 3)\n         :let [routes (conj\n                       []\n                       (map #(vector (+ x %) y) (range 3))\n                       (map #(vector x (+ x %)) (range 3))\n                       (map #(vector (+ x %) (+ y %)) (range 3))\n                       (map #(vector (- x %) (+ y %)) (range 3)))\n               marks (map #(map (fn [[x y]] (get-in board [y x])) %)\n                          routes)\n               win (some #(when (and (not= :e (first %))\n                                     (apply = %))\n                            %)\n                         marks)]\n         :when win]\n     win)))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":73,"code":"(fn [b]\n    (some (comp #{:o :x} first)\n        (filter (partial apply =)\n                (conj b\n                      [(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])]\n                      [(get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])]\n                      (map first b)\n                      (map second b)\n                      (map #(nth % 2) b)))))","user":"53fe1b42e4b0de5c418485f1"},{"problem":73,"code":"(fn [rows]\n  (let [cols (apply map list rows)\n        cross [(map #((rows %1) %1) (range 3))\n               (map #((rows %1) %2) (range 3) (range 2 -1 -1))]\n        triples (set (concat rows cols cross))]\n    (cond\n      (triples [:x :x :x]) :x\n      (triples [:o :o :o]) :o)))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":73,"code":"(fn [[r1 r2 r3]]\n  (let [f (fn [r c]\n            (condp = r\n              0 (nth r1 c)\n              1 (nth r2 c)\n              2 (nth r3 c)))\n        rows (map (fn [x] (set (map #(f % x) (range 3)))) (range 3))\n        cols (map (fn [x] (set (map #(f x %) (range 3)))) (range 3))\n        diag1 (set (map #(f % %) (range 3)))\n        diag2 (set (list (f 2 0) (f 1 1) (f 0 2)))\n        all (concat rows cols [diag1] [diag2])\n        res (filter #(and (= 1 (count %))\n                          (or (:x %) (:o %)))\n                    all)]\n    (if (seq res)\n      (first (first res))\n      nil)))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":73,"code":"(fn decide [board]\n    (let [moves [\n                 [[0 0] [0 1] [0 2]]\n                 [[1 0] [1 1] [1 2]]\n                 [[2 0] [2 1] [2 2]]\n\n                 [[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]\n\n                 [[0 0] [1 1] [2 2]]\n                 [[0 2] [1 1] [2 0]]\n\n                 ]]\n      (->> (map #(frequencies (map (fn [v] (get-in board v)) %)) moves)\n           (filter #(= 1 (count %)))\n           (apply merge)\n           (reduce (fn [old [k v]]\n                     (cond (or (= k :x) (= k :o)) k\n                           :else nil\n                           )) nil))))","user":"550c55d0e4b06e50f9beb14d"},{"problem":73,"code":"(fn tt [b]                                                                    \n  (letfn [(win-sets [[[a b c] [d e f] [g h i]]]                                 \n            (list                                                               \n             (set  [a b c])  (set  [d e f])  (set  [g h i]) ;; rows             \n             (set  [a d g])  (set  [b e h])  (set  [c f i]) ;; columns          \n             (set  [a e i])  (set  [c e g])))]   ;; diagonals \n    \n    (some #{:x :o}             ;; 4. Find the first marker that is              \n                               ;; x or o                                        \n          (map                                                                  \n           #(if (= 1 (count %));; 2. If a set has only one marker,              \n                               ;; then it was a winning line                    \n              (first %))       ;; 3. Return the only marker in                  \n                               ;; that set.                                     \n           (win-sets b)))))    ;; 1. Decompose the board into                   \n                               ;; all possible lines that can win.              \n                               ;; Turn those into sets of unique                \n                               ;; markers","user":"4dbf7a31535d020aff1edf75"},{"problem":73,"code":"(fn [board]\n  (let [diagonals (fn [board] [[(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])] [(get-in board [2 0]) (get-in board [1 1]) (get-in board [0 2])]])\n        columns (fn [board] [(vec (map first board)) (vec (map second board)) (vec (map #(nth % 2) board))])\n        all (concat board (columns board) (diagonals board))]\n       (cond\n          (some #(= [:x :x :x] %) all) :x\n          (some #(= [:o :o :o] %) all) :o\n          :else nil)))","user":"56b280e3e4b0982f16b37e06"},{"problem":73,"code":"(fn\n  [board]\n  (let [key-to-indexes (->> (map-indexed\n                             (fn [i row]\n                               (map-indexed (fn [j e] {:key e :index [i j]}) row))\n                             board)\n                            flatten\n                            (group-by :key))\n        win (fn [indexes]\n              (and (> (count indexes) 2)\n                   (or\n                    (some #(> (count %) 2) (vals (group-by identity (map first indexes))))\n                    (some #(> (count %) 2) (vals (group-by identity (map second indexes))))\n                    (> (count (filter #{[0 0] [1 1] [2 2]} indexes)) 2)\n                    (> (count (filter #{[0 2] [1 1] [2 0]} indexes)) 2))))]\n    (or (when (win (map :index (:x key-to-indexes)))\n          :x)\n        (when (win (map :index (:o key-to-indexes)))\n          :o))))","user":"51852961e4b0da5a5be3babb"},{"problem":73,"code":"#(let [[a b c :as x] %\n      v (apply map vector x)\n      y [(a 0)(b 1)(c 2)]\n      z [(a 2)(b 1)(c 0)]\n      t (concat x v [y z])]\n(->> t (filter(partial apply =))(map first)(remove(partial = :e))(first))\n)","user":"53ed2fafe4b0d648e757f4c1"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (letfn [(get-cols [board]\n            [(map first board)\n             (map second board)\n             (map last board)])\n          (get-diags [board]\n            [(for [i (range 3)]\n               (get (get board i) i))\n             (for [i (range 3)]\n               (get (get board i) (- 2 i)))])\n          (get-winner [lst]\n            (let [vals (distinct lst)]\n              (if (and (empty? (rest vals))\n                       (not (= :e (first vals))))\n                (first vals)\n                nil)))\n          (solve [board]\n            (reduce (fn [winner lst]\n                      (if (nil? winner)\n                        (get-winner lst)\n                        winner))\n                    nil\n                    (concat board (get-cols board) (get-diags board))\n                    ))]\n    (solve board)))","user":"58ef0b8ce4b056aecfd47dbf"},{"code":"(fn [board]\n  (let [zero-to-two (range 0 3) \n        check (fn [x1 y1 x2 y2 x3 y3]\n            (let [pair1 ((board x1) y1)\n                  pair2 ((board x2) y2)\n                  pair3 ((board x3) y3)\n                  all-equal #(= % pair1 pair2 pair3)]\n              (cond (all-equal :o) :o\n                    (all-equal :x) :x\n                    :else          nil)))\n         tic-tac-toe (fn [t i]\n            (cond (= t :horiz) (check i 0 i 1 i 2)\n                  (= t :vert)  (check 0 i 1 i 2 i)\n                  :else   (if (== i 0)\n                                (check 0 0 1 1 2 2)\n                                (check 0 2 1 1 2 0))))]\n\n     (if-let [win-row (some #(tic-tac-toe :horiz %) zero-to-two)]\n       win-row\n      (if-let [win-col (some #(tic-tac-toe :vert %) zero-to-two)]\n        win-col\n        (when-let [win-horiz (or (tic-tac-toe :diag 0) (tic-tac-toe :diag 2))]\n          win-horiz)))))","problem":73,"user":"4e593dac535d8a8b8723a29c"},{"problem":73,"code":"(fn[b]\n  (let [m (concat b (apply map vector b) [[((b 0) 0) ((b 1) 1) ((b 2) 2)] [((b 2) 0) ((b 1) 1) ((b 0) 2)]])\n        w (fn[p] (some #(every? (fn[a] (= a p)) %) m))]\n    (cond (w :x) :x (w :o) :o :else nil)))","user":"56824e1be4b0945ebc182a91"},{"problem":73,"code":"(fn score\n  [b]\n  (letfn [(row [r] (nth b r))\n          (col [c] (map #(nth % c) b))\n          (cross [x]\n            (map #(nth (nth b %1) %2) [0 1 2] (if (= 0 x)\n                                                [0 1 2]\n                                                [2 1 0])))\n          (winner [r]\n            (if (apply = r)\n              (let [f (first r)]\n                (if-not (= f :e)\n                  f))))]\n    (or\n      (some winner (map row [0 1 2]))\n      (some winner (map col [0 1 2]))\n      (some winner (map cross [0 1])))))","user":"5408ec4de4b0addc1aec66d0"},{"problem":73,"code":"(fn [xs]\n  (letfn [(w ([a b c] (when (and (not= :e a) (= a b c)) a))\n             ([[a b c]] (w a b c)))]\n    (some #(and (not= :e %) %)\n          (conj\n            (map w xs)\n            (w (first (first xs)) (first (second xs)) (first (last xs)))\n            (w (second (first xs)) (second (second xs)) (second (last xs)))\n            (w (last (first xs)) (last (second xs)) (last (last xs)))\n            (w (first (first xs)) (second (second xs)) (last (last xs)))\n            (w (last (first xs)) (second (second xs)) (first (last xs)))))))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn tic [s]\n      (let [c (count s)\n\t\t fs (flatten s)\n\t\t d1 (map #(nth fs (+ (- c % 1) (* % c))) (range c))\n\t\t d2 (map #(nth fs (+ % (* % c))) (range c))]\n\t\t (first (remove #(or (nil? %) (= :e %)) (map #(if (apply = %) (first %)) (concat s [d1] [d2] (apply map vector s)))))))","problem":73,"user":"4fc7db47e4b0ee37620e182a"},{"problem":73,"code":"(fn [x]\n    (let [cols (into x (apply (partial map vector) x))\n          cols-diags (into cols (apply  (partial  map vector) (map-indexed (fn [y i] [(get i (- (count i) (+  y 1)) ) (get i y)]) x)))\n          result (filter (fn [x] (not= :e x)) (map (fn [x] (reduce (fn [x y] (if (= x y) x :e)) x)) cols-diags))]\n      (if (not-empty result) (first result) nil)))","user":"55c1eb52e4b0e31453f64970"},{"problem":73,"code":"(fn oxo [board]\n  (let [r0 (first board)\n        r1 (second board)\n        r2 (last board)\n        c0 (map first board)\n        c1 (map second board)\n        c2 (map last board)\n        d1 [(first r0) (second r1) (last r2)]\n        d2 [(last r0) (second r1) (first r2)]\n        win-lines [r0 r1 r2 c0 c1 c2 d1 d2]\n        won-lines (->> win-lines\n                       (map set)\n                       (filter #(= 1 (count %)))\n                       (filter #(not= #{:e} %))\n                       (map first))\n        winner (first won-lines)]\n    winner))","user":"56069006e4b08b23635d3174"},{"problem":73,"code":"(let [wins #{7 56 73 84 146 273 292 448}\n      to-code (fn [b v] (->> b\n                           flatten\n                           (map-indexed #(if (= %2 v) (bit-shift-left 1 %1) 0))\n                           (reduce + 0)))]\n  (fn [b] (let [x (to-code b :x)\n                o (to-code b :o)]\n            (first (mapcat #(cond (= % (bit-and % x)) '(:x)\n                                  (= % (bit-and % o)) '(:o)\n                                  :else '())\n                           wins)))))","user":"54c641f8e4b045293a27f628"},{"code":"(fn [board]\n  (letfn [(check-horizonal [board]\n                           (first\n                             (flatten\n                               (filter #(every? #{:x :o} %)\n                                       (filter #(= 1 (count (set %))) board)))))]\n    (let [h (check-horizonal board)]\n      (if h\n        h\n        (let [v (check-horizonal (apply map vector board))]\n          (if v\n            v\n            (let [fd (check-horizonal [[(first (first board)) (second (second board)) (last (last board))]])]\n              (if fd\n                fd\n                (check-horizonal [[(first (last board)) (second (second board)) (last (first board))]])))))))))","problem":73,"user":"52a55adee4b0c58976d9abe7"},{"code":"(fn [board]\n                            (letfn [(test-rows [board] (seq (filter #(not (= :e %)) (map first (filter (fn [x] (apply = x)) board)))))\n                                    (test-cols [board] (seq (filter #(not (= :e %)) (map first (filter (fn [x] (apply = x)) (partition 3 3 (for [col (range 0 3) row board] (nth row col))))))))\n                                    (test-maj-diag [board] (seq (if (and (not (= :e (first (first board)))) (apply = (map nth board (range 0 3)))) [(first (first board))] nil)))\n                                    (test-min-diag [board] (seq (if (and (not (= :e (first (board 2)))) (apply = (map nth board (range 2 -1 -1)))) [(first (board 2))] nil)))]\n                            \n                              (first (first (drop-while nil? (map #(% board) [test-rows test-cols test-maj-diag test-min-diag]))))))","problem":73,"user":"4e08fb7a535d04ed9115e7ac"},{"code":"(fn an [board] (let [vic (first (first (filter #(= (count %) 1) (map distinct \n  (concat (list\n    (map first board)\n    (map second board)\n    (map #(nth % 2) board)\n    (map-indexed #(nth %2 %) board)\n    (map-indexed #(nth %2 (- 2 %)) board)) board)))))] (if (= vic :e) nil vic)))","problem":73,"user":"4ea0c284535d7eef308072ad"},{"problem":73,"code":"(fn\n  [input]\n  (let [board (->> input\n                   flatten\n                   (into []))]\n    (some #{:x :o}\n          (map #(if (apply = %) (first %))\n               (map\n                (fn [x]\n                  (map #(get board %) x))\n                [[0 1 2] [3 4 5] [6 7 8]\n                 [0 3 6] [1 4 7] [2 5 8]\n                 [0 4 8] [2 4 6]])))))","user":"502b0804e4b063e52107afad"},{"code":"(fn [board]\n  (let [positions [[[0 0] [1 0] [2 0]] \n\t\t\t  \t   [[0 1] [1 1] [2 1]]\n\t\t\t\t   [[0 2] [1 2] [2 2]]\n\n\t\t\t\t   [[0 0] [1 1] [2 2]]\n\t\t\t\t   [[0 2] [1 1] [2 0]]]\n        lines (concat board (map (fn [line] (map #(get-in board %) line)) positions))]\n    (some #(and (apply = %) (#{:x :o} (first %))) lines)))","problem":73,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn [d] (some #(condp = (set %) #{:x} :x #{:o} :o false)\n     (concat d (apply map list d) [(map get d [0 1 2]) (map get d [2 1 0])] )\n))","problem":73,"user":"52bf29fde4b07a9af579232e"},{"problem":73,"code":"(fn\n  [x] \n  (let [rows [[1 1 1 2 1 3]\n              [2 1 2 2 2 3]\n              [3 1 3 2 3 3]\n              [1 1 2 1 3 1]\n              [2 1 2 2 2 3]\n              [3 1 3 2 3 3]\n              [1 1 2 2 3 3]\n              [1 3 2 2 3 1]]]\n    (let [isolate-row\n          (fn isolate [rowdef board]\n            (if (empty? rowdef)\n              []\n              (cons (nth (nth board (dec (first rowdef)))\n                         (dec (second rowdef)))\n                    (isolate (drop 2 rowdef) board))))]\n      (let [check-row \n            (fn [row] (reduce #(if (= %1 %2) %1 nil) row))]\n        (let [checked-list (map check-row (map #(isolate-row % x) rows))]\n          (cond \n            (some #(= :x %) checked-list) :x\n            (some #(= :o %) checked-list) :o\n            :else nil))))))","user":"52e17e66e4b09f7907dd1423"},{"code":"(fn ttt [cs]\n  (letfn [(any [xs]\n               (reduce #(or %1 %2) nil xs))\n          (check-row [rs]\n                     (let [ds (distinct rs)]\n                       (if (= 1 (count ds)) \n                         (if (not= :e (first ds)) (first ds) nil)\n                         nil)))\n          (check-rows [xs] (any (map check-row xs)))\n          (check-cols [xs] (check-rows (for [n (range 3)]\n                                         (map #(nth % n) xs))))\n          (check-diaf [xs] (check-row (for [n (range 3)]\n                                        (nth (nth xs n) n))))\n          (check-diab [xs] (check-row (for [n (range 3)]\n                                        (nth (nth xs (- 2 n)) n))))]\n    (any\n           (map #(% cs) \n               [check-rows check-cols check-diaf check-diab]\n               )))\n)","problem":73,"user":"4ee82ce9535d93acb0a6687a"},{"code":"(fn tic-tac-toe- [board]\n  (let [combs (fn [rs cs]\n                (map #(get-in board [%1 %2]) rs cs))\n        rows [0 1 2]\n        cols [[0 1 2]\n              [2 1 0]\n              [0 0 0]\n              [1 1 1]\n              [2 2 2]]]\n    (some {[:x :x :x] :x [:o :o :o] :o}\n          (concat board (for [col cols]\n                          (combs rows col))))))","problem":73,"user":"511e763ce4b03e81d390ac29"},{"problem":73,"code":"(fn ttt-winner [board]\n  (let [filter-fn (fn [rows] (first (filter #(and (= 1 (count %))\n                                                  (not= (first %) :e))\n                                            (map distinct rows))))\n        h (filter-fn board)\n        v (filter-fn (partition 3 (for [x (range 3)\n                                        row board]\n                                    (nth row x))))\n        d (filter-fn [[(nth (nth board 0) 0)\n                       (nth (nth board 1) 1)\n                       (nth (nth board 2) 2)]\n                      [(nth (nth board 0) 2)\n                       (nth (nth board 1) 1)\n                       (nth (nth board 2) 0)]])]\n    (first (or h v d))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":73,"code":"(fn analyze-ttt-board [board]\n  (let [get-score (fn [board'] (reduce (fn [old new] (if (nil? new) old new))\n                               (map (fn [v]\n                                      (let [xn (count (filter #(= % :x) v))\n                                            on (count (filter #(= % :o) v))]\n                                        (cond\n                                          (= 3 xn) :x\n                                          (= 3 on) :o\n                                          :else nil)))\n                                    board')))\n        boards [board\n                ;; transpose board \n                (apply map vector board)\n                ;; create simplified board for diagonal\n                [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                 [((board 0) 2) ((board 1) 1) ((board 2) 0)]]]]\n\n    (->> (map get-score boards)\n         (filter (complement nil?))\n         (first))))","user":"5641296de4b08d4f616f5ef4"},{"code":"(letfn[\r\n  (tic-tac-toe-lines [board]\r\n    (let [size (count board)]\r\n        (concat board\r\n                (for [col (range size)] (map #(get % col) board))\r\n                [(map-indexed #(get %2 %1) board)]\r\n                [(map-indexed #(get %2 (dec (- size %1))) board)]\r\n        )))\r\n  (check-line [line]\r\n    (let [res (reduce #(if (= %1 %2) %1 nil) line)]\r\n        (if (= res :e) nil res)\r\n    ))]\r\n #(some check-line (tic-tac-toe-lines %))\r\n)","problem":73,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":73,"code":"(fn [board]\n  (let [[row1 row2 row3 :as rows] board\n        columns (apply map vector board)\n        diags [(vector (first row1)\n                       (second row2)\n                       (last row3))\n               (vector (last row1)\n                       (second row2)\n                       (first row3))]]\n    (some #{:x :o}\n          (flatten (filter #(= 1 (count (distinct %)))\n                           (reduce into (list rows columns diags)))))))","user":"58a2b57fe4b02bd94d917ede"},{"problem":73,"code":"(fn [A]\n        (->> [0 1 2 [0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n             (map \n                (fn [a] (if (coll? a) (map #(%1 %2) A a) (A a))))\n             (filter (partial apply =))\n             (filter #(not= (last %) :e))\n             (last)\n             (#(and % (last %)))\n                     \n         ))","user":"559c13c5e4b066d22e731f61"},{"problem":73,"code":"(fn [board]\n  (let [[row1 row2 row3] board\n        [col1 col2 col3] (apply map vector board)\n        up-down-diagonal (for [idx [0 1 2]] (nth (nth board idx) idx))\n        down-up-diagonal (for [idx [0 1 2]] (nth (nth board idx) (- 2 idx)))]\n    (cond\n     (= (set row1) #{:x}) :x\n     (= (set row2) #{:x}) :x\n     (= (set row3) #{:x}) :x\n     (= (set col1) #{:x}) :x\n     (= (set col2) #{:x}) :x\n     (= (set col3) #{:x}) :x\n     (= (set up-down-diagonal) #{:x}) :x\n     (= (set down-up-diagonal) #{:x}) :x\n     (= (set row1) #{:o}) :o\n     (= (set row2) #{:o}) :o\n     (= (set row3) #{:o}) :o\n     (= (set col1) #{:o}) :o\n     (= (set col2) #{:o}) :o\n     (= (set col3) #{:o}) :o\n     (= (set up-down-diagonal) #{:o}) :o\n     (= (set down-up-diagonal) #{:o}) :o\n     :else nil)))","user":"5d3ae729e4b01671435dbd5d"},{"code":"(fn [b] (let [p [[[0 0] [1 1] [2 2]]\n                 [[0 2] [1 1] [2 0]]\n                 [[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]]]\n              (some {[:x :x :x] :x [:o :o :o] :o} (concat (map #(map (fn [[x y]] ((b x) y)) %) p) b))))","problem":73,"user":"51bd1a0de4b0df1216cefd93"},{"problem":73,"code":"(fn [[a b c]] (let [result (cond\n(= (a 0) (b 0) (c 0)) (a 0)\n(= (a 1) (b 1) (c 1)) (a 1)\n(= (a 2) (b 2) (c 2)) (a 2)\n(= (a 0) (a 1) (a 2)) (a 0)\n(= (b 0) (b 1) (b 2)) (b 0)\n(= (c 0) (c 1) (c 2)) (c 0)\n(= (a 0) (b 1) (c 2)) (a 0)\n(= (a 2) (b 1) (c 0)) (a 2)\n:else :e\n)]\n          (if (= result :e) nil result)\n                      ))","user":"5c41db45e4b08cd430848ece"},{"problem":73,"code":"(fn [c]\n   (let [a [0 1 2]\n         f #(map % a)\n         m (f (fn [y] (fn [x] (map #(nth % y) x))))\n         l (f #(fn [x] (nth (nth x %) %)))\n         n (f #(fn [x] (nth (nth x %) (- 2 %))))\n         f (fn [x] (map #(% c) x))\n         r (concat c (f m) [(f l)] [(f n)])]\n     (cond\n       (some #(= [:x :x :x] %) r) :x\n       (some #(= [:o :o :o] %) r) :o\n       :else nil)))","user":"5c1aadcde4b01240ff567209"},{"code":"(fn [data]\r\n  (let [state (apply str (replace {:x 1 :o 2 :e 0} (apply concat data)))]\r\n  (first (seq (filter #(not (nil? %)) (map #(and (re-seq %1 state) %2) [#\"111\" #\"1..1..1\" #\"..1.1.1..\" #\"1...1...1\" #\"222\" #\"2..2..2\" #\"..2.2.2..\" #\"2...2...2\"] [:x :x :x :x :o :o :o :o] ))))))","problem":73,"user":"4ee77f15535d93acb0a66868"},{"code":"(fn winner [board]\n  (let [lines #{#{[0 0] [0 1] [0 2]}\n                #{[1 0] [1 1] [1 2]}\n                #{[2 0] [2 1] [2 2]}\n                #{[0 0] [1 0] [2 0]} \n                #{[0 1] [1 1] [2 1]} \n                #{[0 2] [1 2] [2 2]}\n                #{[0 0] [1 1] [2 2]} \n                #{[0 2] [1 1] [2 0]}}\n        occupied-cells (fn [board piece]\n                         (set\n                           (for [row (range 3) \n                                 column (range 3)\n                                 :when (= piece (get-in board [row column]))]\n                             [row column])))\n        winner? (fn [board piece]\n                  (let [cells (occupied-cells board piece)]\n                    (loop [l lines]\n                      (cond\n                        (empty? l) false\n                        (clojure.set/subset? (first l) cells) true\n                        :else (recur (rest l))))))]\n    (cond \n      (winner? board :x) :x\n\t  (winner? board :o) :o\n      :else nil)))","problem":73,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn p73 [tab]\n  (let [fs [(fn [x y] (= x 1)) (fn [x y] (= x 2)) (fn [x y] (= x 3))\n            (fn [x y] (= y 1)) (fn [x y] (= y 2)) (fn [x y] (= y 3))\n            (fn [x y] (or (and (= x 1) (= y 1)) (and (= x 2) (= y 2)) (and (= x 3) (= y 3))))\n            (fn [x y] (or (and (= x 1) (= y 3)) (and (= x 2) (= y 2)) (and (= x 3) (= y 1))))]]\n    (letfn [(idxc [tab]\n              (reduce merge {} (for [row (zipmap (range 1 (inc 3)) tab)]\n                                 (let [[ri r] row]\n                                   (reduce conj {} (for [col (zipmap (range 1 (inc 3)) r)] (let [[ci c] col] [[ri ci] c])))))))\n          (soroi [ps k]\n            [(and (= 3 (count ps)) (every? #(= % k) (vals ps))) ps])\n          (three [ided k f]\n            (soroi (filter (fn [e] (let [[x y] (.getKey e)] (f x y))) ided) k))\n          (placed [ided k]\n            (map (fn [f] (three ided k f)) fs))\n          (chk [ided k]\n            (some (comp not false?) (map first (placed ided k))))\n          ]\n    (let [ided (idxc tab)]\n      (if (chk ided :x) :x\n          (if (chk ided :o) :o)))))\n)","problem":73,"user":"5272669de4b03e8d9a4a742e"},{"problem":73,"code":"(fn get-winner [board]\n\t(let [flat-board (flatten board)\n\t\t  possible-sets [[0 1 2][3 4 5][6 7 8]\n\t \t\t\t\t\t [0 3 6][1 4 7][2 5 8]\n\t \t\t\t\t\t [0 4 8][2 4 6]]\n\t\t  winning-set? (fn [coll] (or (every? #(= % :x) coll)\n\t\t\t\t\t\t\t\t\t  (every? #(= % :o) coll)))\n\t\t  all-sets (reduce (fn[rs ps] (conj rs (map #(nth flat-board %) ps))) [] possible-sets)\n\t\t  winner (filter winning-set? all-sets)]\n\t\t (if (empty? winner) nil (ffirst winner))))","user":"57c0917be4b05aa3c4741c95"},{"code":"(fn [v]\r\n     (let [f (fn [t] (vector (map-indexed #(nth %2 %1) t))) \r\n\t         s \r\n\t\t(first (filter\r\n\t\t #(or (apply = (conj % :x)) (apply = (conj % :o)))\r\n\t\t (concat v (partition 3 (apply interleave v)) (f v) (f (reverse v)))))] (first s)))","problem":73,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":73,"code":"(fn [b]\n          (let [skoro (ffirst (filter #(= (count %) 1) [\n                                                        (distinct (get b 0)) (distinct (get b 1)) (distinct (get b 2))\n                                                        (distinct (map #(nth % 0) b))\n                                                        (distinct (map #(nth % 1) b)) \n                                                        (distinct (map #(nth % 2) b))\n                                                        (distinct [(get (get b 0) 0) (get (get b 1) 1)(get (get b 2) 2)])\n                                                        (distinct [(get (get b 0) 2) (get (get b 1) 1)(get (get b 2) 0)])\n\n                                                        ]))]\n            (if (= skoro :e) nil skoro)\n            )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [board]\r\n  (let [rng #(for [i (range 3)] (+ % (* i %2)))\r\n        lines [[0 0 1 0] [0 1 1 0] [0 2 1 0] [0 0 1 1]\r\n              [0 0 0 1] [1 0 0 1] [2 0 0 1] [0 2 1 -1]]]\r\n  (->> lines\r\n    (map (fn [[x y dx dy]]\r\n          (map (fn [x y] (nth (nth board y) x)) (rng x dx) (rng y dy))))\r\n    (map set)\r\n    (remove second)\r\n    first first\r\n    #{:x :o}\r\n   )))","problem":73,"user":"50336c6be4b0c6c1199c710f"},{"problem":73,"code":"(fn [b]\n  (letfn [(g [i j] (get (get b i) j))\n          (chk [v a b c d e f] (= v (g a b) (g c d) (g e f)))\n          (win? [v] (or\n                      (chk v 0 0 0 1 0 2)\n                      (chk v 1 0 1 1 1 2)\n                      (chk v 2 0 2 1 2 2)\n                      (chk v 0 0 1 0 2 0)\n                      (chk v 0 1 1 1 2 1)\n                      (chk v 0 2 1 2 2 2)\n                      (chk v 0 0 1 1 2 2)\n                      (chk v 0 2 1 1 2 0)))]\n        (cond\n             (win? :o) :o\n             (win? :x) :x\n             :else nil\n             )\n        )\n  )","user":"54dae16de4b024c67c0cf758"},{"problem":73,"code":"(fn [grid] (let [rows grid\n                 transpose #(apply map vector %)\n                 cols (transpose grid)\n                 diags (list [(ffirst grid) (second (second grid)) (last (last grid))] [(first (last grid)) (second (second grid)) (last (first grid))])\n                 lines (concat rows cols diags)]\n             (cond (some #{[:x :x :x]} lines) :x \n                   (some #{[:o :o :o]} lines) :o\n                   )))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(fn tic-tac-toe [board]\n    (letfn [(sym-win? [sym [frow srow trow]]\n  (let [board [frow srow trow]\n        fcol (map first board)\n        scol (map second board)\n        tcol (map last board)\n        diag-1 [(first frow) (second srow) (last trow)]\n        diag-2 [(last frow) (second srow) (first trow)]\n        all-seq [frow srow trow fcol scol tcol diag-1 diag-2]\n        win? (fn [sym sequence] \n                (let [seq-set (set sequence)]\n                  (and \n                    (= 1 (count seq-set))\n                    (= sym (sym seq-set)))))]\n    (contains? (set (map #(win? sym %) all-seq)) true)))]\n    (cond\n        (sym-win? :o board) :o\n        (sym-win? :x board) :x\n        :else nil)))","problem":73,"user":"501c1492e4b086d93747d180"},{"problem":73,"code":"(fn analyze [board]\n  (let [get-at\n        (fn [coll indices]\n          (reduce (fn [acc i] (cons (nth coll i) acc)) (list) indices))\n        flattened-board (reduce concat board)\n        line-indices [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        lines (map #(get-at flattened-board %) line-indices)\n        is-winner (fn [line] (if (and (apply = line) (not= (first line) :e)) (first line) nil))\n        ]\n    (some identity (map is-winner lines))\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"code":"(fn [board]\n  (letfn [(at [x y] (nth (nth board y) x))\n          (eq [r]\n            (if (and (apply = r) (not= :e (first r)))\n              (first r)\n              nil))]\n    (some\n     identity\n     (concat\n      (map eq board)\n      (apply map #(eq %&) board)\n      [(eq [(at 0 0) (at 1 1) (at 2 2)])\n       (eq [(at 2 0) (at 1 1) (at 0 2)])]))))","problem":73,"user":"504f57c7e4b0a02f9cffde71"},{"problem":73,"code":"(fn [rows]\r\n  (let [cols (apply map list rows)\r\n        diags [[((rows 0) 0) ((rows 1) 1) ((rows 2) 2)]\r\n               [((rows 0) 2) ((rows 1) 1) ((rows 2) 0)]]\r\n        lines (concat rows cols diags)]\r\n    (if (some identity\r\n      (map (fn [x] (every? #(= :x %) x)) lines)) :x\r\n    (if (some identity\r\n      (map (fn [x] (every? #(= :o %) x)) lines)) :o\r\n    nil))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [field]\n        (letfn [(rows [] field)\n                (cols [] (apply map vector field))\n                (crosses [] [[(get-in field [0 0]) (get-in field [1 1]) (get-in field [2 2])]\n                             [(get-in field [0 2]) (get-in field [1 1]) (get-in field [2 0])]])\n                (full [sym] (some (fn [seq] (every? #(= % sym) seq)) (concat (rows) (cols) (crosses))))] \n          (cond (full :x) :x\n                (full :o) :o)))","problem":73,"user":"5294e44de4b02ebb4ef75016"},{"code":"(fn [board-2d]\n  (let [board (map {:e 0, :x 1, :o -1} (flatten board-2d))\n        three-squares-seqs-horiz (partition 3 (range 9))\n        three-squares-seqs-vert (apply map list three-squares-seqs-horiz)\n        three-squares-seqs-diag [(range 0 9 4) (range 2 7 2)]\n        three-squares-seqs (concat three-squares-seqs-horiz\n                                   three-squares-seqs-vert\n                                   three-squares-seqs-diag)]\n    (some (fn [three-squares]\n            (let [result (apply + (map #(nth board %) three-squares))]\n              (cond \n                (= result 3) :x\n                (= result -3) :o\n                :else nil)))\n          three-squares-seqs)))","problem":73,"user":"51789dfae4b03d69594194d7"},{"code":"(fn [[r1 r2 r3]]\n  (let [cs (map vector r1 r2 r3)\n        d1 [(nth r1 0) (nth r2 1) (nth r3 2)]\n        d2 [(nth r1 2) (nth r2 1) (nth r3 0)]\n        a [r1 r2 r3 d1 d2]\n        a (into cs a)\n        win? (fn [v x] (= 3 ((frequencies v) x)))]\n    (if (some #(win? % :x) a) :x\n      (if (some #(win? % :o) a) :o\n        nil))))","problem":73,"user":"50464831e4b011c5dfee771f"},{"problem":73,"code":"(fn [board] \n  (let [cs [[0 0 0]\n            [1 1 1]\n            [2 2 2]\n            [0 1 2]\n            [2 1 0]]]\n    (first (first \n       (filter #(and (not (contains? % :e)) (= 1 (count %))) \n          (map set (concat board (map (fn [c] (map get board c)) cs))))))))","user":"5578f292e4b05c286339e08f"},{"problem":73,"code":"(letfn [(check [c]\n\t\t\t(cond \n\t\t\t\t(every? #{:x} c) :x\n\t\t\t\t(every? #{:o} c) :o\n\t\t\t\t:else nil))\n\t\t(row [c] (map check c))\n\t\t(col [c] (row (apply mapv vector c)))\n\t\t(diagx [c] (check (map-indexed #(%2 %1) c)))\n\t\t(diagy [c] (check (map-indexed #(%2 (- 2 %1)) c)))\n\t\t(main [c] (->> c ((juxt row col diagx diagy)) flatten (filter (complement nil?)) first))] \nmain)","user":"580c8fcee4b0849f6811b721"},{"problem":73,"code":"(fn [field]\n  (let [ys (for [x (range 3)]\n             (for [y (range 3)] [x y]))\n        xs (for [x (range 3)]\n             (for [y (range 3)] [y x]))\n        lr (for [x (range 3)] [x x])\n        rl (for [x (range 3)] [x (- 2 x)])\n        lines (list* lr rl (concat ys xs))\n        line (some (fn [l]\n                     (when (or (every? #(= (get-in field %) :x) l)\n                               (every? #(= (get-in field %) :o) l))\n                       l))\n                   lines)]\n    (when line (get-in field (first line)))))","user":"5d431c77e4b07c84aa5ae68f"},{"code":"(fn ttt-winner [board]\n  (let [ttt-cross (fn ttt-cross [board]\n                    (let [row0 (first board)\n                          row1 (fnext board)\n                          row2 (fnext (next board))]\n                      (cond\n                       (and (not= (row0 0) :e) (= (row0 0) (row1 1) (row2 2))) (row0 0)\n                       (and (not= (row0 2) :e) (= (row0 2) (row1 1) (row2 0))) (row0 2)\n                       :else nil)))\n        ttt-vertical (fn ttt-vertical [board]\n                       (let [row0 (first board)\n                             row1 (fnext board)\n                             row2 (fnext (next board))]\n                         (cond\n                          (and (not= (row0 0) :e) (= (row0 0) (row1 0) (row2 0))) (row0 0)\n                          (and (not= (row0 1) :e) (= (row0 1) (row1 1) (row2 1))) (row0 1)\n                          (and (not= (row0 2) :e) (= (row0 2) (row1 2) (row2 2))) (row0 2)\n                          :else nil)))\n        ttt-horizontal (fn ttt-horizontal [board]\n                         (some (fn [row] (if (and (apply = row) (not= (first row) :e))\n                                          (first row))) board))]\n    (or (ttt-horizontal board)\n        (ttt-vertical board)\n        (ttt-cross board))))","problem":73,"user":"4e7f51eb535db966e863cc3f"},{"problem":73,"code":"(fn [board]\n    (let [a board\n          b (conj [] (map first board) (map second board) (map last board))\n          c ((juxt (comp first first) (comp second second) (comp last last)) board)\n          d ((juxt (comp first last) (comp second second) (comp last first)) board)\n          z (concat a b [c] [d])]\n      (cond (some identity (map (partial apply = :x) z)) :x\n            (some identity (map (partial apply = :o) z)) :o\n            :else nil)))","user":"5e2549c8e4b05b4b0151615f"},{"problem":73,"code":"(fn [rows]\n  (->> (concat rows                               ; rows\n               (apply map vector rows)            ; columns\n               (partition 3 (map #(get-in rows %) ; diagonals\n                                 [[0 0] [1 1] [2 2]\n                                  [0 2] [1 1] [2 0]])))\n       (some #(#{[:x :x :x] [:o :o :o]} %))\n       first))","user":"54ddb556e4b024c67c0cf798"},{"problem":73,"code":"(fn [board] (letfn [(triples \n            [board]\n            (map #(map (partial get-in board) %)\n                 (concat\n                  (for [x [0 1 2]]\n                    [[x 0] [x 1] [x 2]])\n                  (for [y [0 1 2]]\n                    [[0 y] [1 y] [2 y]])\n                  [[[0 0] [1 1] [2 2]]\n                   [[0 2] [1 1] [2 0]]])))]\n    (ffirst (filter #(or (= [:o :o :o] %)\n                         (= [:x :x :x] %))\n                    (triples board)))))","user":"5b5955cce4b02d533a91bd79"},{"code":"(fn win [field]\n  (let [[[a b c]\n         [d e f]\n         [g h i]] field]\n    (cond\n     (and (= a b c) (not (= a :e))) a\n     (and (= d e f) (not (= d :e))) d\n     (and (= g h i) (not (= g :e))) g\n     (and (= a d g) (not (= a :e))) a\n     (and (= b e h) (not (= b :e))) b\n     (and (= c f i) (not (= c :e))) c\n     (and (= a e i) (not (= a :e))) a\n     (and (= c e g) (not (= c :e))) c)))","problem":73,"user":"527a69cee4b03e8d9a4a755d"},{"problem":73,"code":"(fn me [board]\n  (let [win-states [[[1 0 0] [1 0 0] [1 0 0]],\n                    [[0 1 0] [0 1 0] [0 1 0]],\n                    [[0 0 1] [0 0 1] [0 0 1]],\n                    [[1 1 1] [0 0 0] [0 0 0]],\n                    [[0 0 0] [1 1 1] [0 0 0]],\n                    [[0 0 0] [0 0 0] [1 1 1]],\n                    [[1 0 0] [0 1 0] [0 0 1]],\n                    [[0 0 1] [0 1 0] [1 0 0]],\n                    ]\n        players [:x :o]]\n    (letfn [(find-winner? [player]\n              ())\n            (has-state? [player state]\n              (->>\n               (map #(and (= 1 %1) (= player %2)) (flatten state) (flatten board))\n               (filter true?)\n               (count)\n               (= 3)))\n            ]\n      (->>\n       (for [player players, state win-states]\n         (when (has-state? player state) player))\n       (remove nil?)\n       (first)))))","user":"5c219c0fe4b07e362c230581"},{"problem":73,"code":"(fn [tic-tac-toe]\n  (let [nth-2d (fn nth-2d [ar indexes]\n                 (let [i0 (first indexes)\n                       i1 (second indexes)]\n                   (nth (nth ar i0) i1)))\n        rows (map (fn [row-indexes]\n                    (map #(nth-2d tic-tac-toe %) row-indexes))\n                  [[[0 0] [0 1] [0 2]]\n                   [[1 0] [1 1] [1 2]]\n                   [[2 0] [2 1] [2 2]]\n                   [[0 0] [1 0] [2 0]]\n                   [[0 1] [1 1] [2 1]]\n                   [[0 2] [1 2] [2 2]]\n                   [[0 0] [1 1] [2 2]]\n                   [[0 2] [1 1] [2 0]]])\n        straights (map #(if (= 1 (count (distinct %)))\n                            (first %)\n                            nil)\n                       rows)\n        winning-row (first (remove #(or (nil? %)\n                                        (= :e %))\n                                   straights))]\n    winning-row))","user":"53940789e4b0b51d73faaec3"},{"problem":73,"code":"(fn [board]                                                                                                                                                        \n  (let [diagonals (for [f [#(list % %) #(list % (- 2 %))]]                                                                                                               \n                    (for [x (range 3)]                                                                                                                                   \n                      (get-in board (f x)))                                                                                                                              \n                  )                                                                                                                                                      \n        columns (apply map vector board)                                                                                                                                 \n        checks (concat board diagonals columns)]                                                                                                                         \n    (first (for [check checks                                                                                                                                            \n          :let [dist (distinct check)]                                                                                                                                   \n          :when (#{[:o] [:x]} dist)]                                                                                                                                     \n      (first dist)))))","user":"54ff074de4b07d26eda61d47"},{"code":"(fn [board]\n  (some (fn [player]\n          (if (or (some (partial every? (partial = player))\n                        board)\n                  (some (fn [col]\n                          (every? #(= player (% col))\n                                  board))\n                        [0 1 2])\n                  (and (= (get-in board [1 1]) player)\n                       (or (= (get-in board [0 2])\n                              (get-in board [2 0])\n                              player)\n                           (= (get-in board [0 0])\n                              (get-in board [2 2])\n                              player))))\n            player))\n        [:o :x]))","problem":73,"user":"4eae5fe4535d7eef30807325"},{"code":"(letfn [(row-win? [row] (if (every? #{:x} row) :x\n                      (if (every? #{:o} row) :o\n                      nil)))\n\n        (rows-win? [rows] (->> rows\n                           (map row-win?)\n                           (filter #{:x :o})\n                           first))\n\n(cols-win? [cols] (rows-win? (apply map vector cols)))\n\n(diag1 [rows] (map #(%2 %1) (range) rows))\n\n(diag2 [rows] (map #(%2 %1) (reverse (range (count rows))) rows))\n\n(diag-win? [rows] (let [d1 (diag1 rows)\n                             d2 (diag2 rows)]\n                         (rows-win? [d1 d2])))\n\n(win? [rows] (let [r (rows-win? rows)\n                        c (cols-win? rows)\n                        d (diag-win? rows)]\n                    (first (filter #{:x :o} [r c d]))))\n        ] win?)","problem":73,"user":"52437703e4b076204b44fabf"},{"code":"(fn [board]\n  (let [trans  {:x 1, :o 10, :e 0}\n        wins   {3 :x, 30 :o}\n        sum-ln (fn [m] (map #(->> % (map trans) (apply +)) m))\n        revb   (apply map list board)\n        col1   (->> board (map #(nth %2 %) (range 0 3)) (conj []))\n        col2   (->> board (map #(nth %2 %) (reverse (range 0 3))) (conj []))\n        sums   (mapcat sum-ln [board revb col1 col2])\n        winer  (->> sums (map wins) (into #{}))]\n    (cond (winer :x) :x\n          (winer :o) :o\n          :else nil)))","problem":73,"user":"4fe98ddae4b0547ebccb2463"},{"problem":73,"code":"(fn analyze-ttt\n  [board]\n  (letfn [(analyze[[f & r :as values]]\n            (if (apply = values)\n              (if (= f :e)\n                nil\n                f)))\n          (get-columns [[[one two three] [four five six] [seven eight nine]]]\n            [[one four seven]\n             [two five eight]\n             [three six nine]])\n          (get-diagonal [[[one two three] [four five six] [seven eight nine]]]\n            [[one five nine]\n             [seven five three]])]\n    (let [row-win\n          (map analyze board)\n\n          column-win\n          (map analyze (get-columns board))\n\n          diagonal-win\n          (map analyze (get-diagonal board))]\n      (first (filter #(boolean %) (concat row-win column-win diagonal-win))))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":73,"code":"(fn [matrix]\n    (letfn [(judge [v]\n              (cond (every? #(= :o %) v) :o\n                    (every? #(= :x %) v) :x\n                    :else nil))\n            (transpose [m]\n              (apply mapv vector m))] \n      (let [crosses [(map #(-> matrix (nth %1) (nth %1)) (range 0 3)) \n                     (map #(-> matrix (nth %1) (nth (- 2 %1))) (range 0 3))]\n            res (apply clojure.set/union (map set \n                                              [(map #(judge %) matrix)\n                                               (map #(judge %) (transpose matrix))\n                                               (map #(judge %) crosses)]))]\n        (cond (some #(= :o %) res) :o\n              (some #(= :x %) res) :x\n              :else nil))))","user":"55aa1637e4b0988bba2ad949"},{"problem":73,"code":"(fn winner\n  [rows]\n  (let [n 3 ; 3 by 3 grid\n        columns (apply mapv vector rows)\n        left-diagonal (map #(get (get rows %) %) (range n))\n        right-diagonal (map #(get (get rows %) (- (dec n) %)) (range n))\n        lines-to-check (concat rows columns [left-diagonal right-diagonal])\n        line-winner (fn [row] (cond (every? #(= % :x) row) :x\n                                   (every? #(= % :o) row) :o\n                                   :else nil))]\n    (some #{:x :o} (map line-winner lines-to-check))))","user":"5b602a66e4b0c6492753e6fc"},{"problem":73,"code":"(fn [board] (some #(when (not= :e %) %) (map #(and (apply = %) (first %)) [(first board) (second board) (last board) (map first board) (map second board) (map last board) [(first (first board)) (second (second board)) (last (last board))] [(last (first board)) (second (second board)) (first (last board))]])))","user":"5e1cc888e4b0dc959400853d"},{"code":"(fn [rows]\n  (let [line-winner (fn [row]\n                      (cond\n                        (= :e (first row)) nil\n                        (every? (fn [x] (= x (first row))) row) (first row)\n                        :else nil))\n        winner (fn [lst]\n                (cond\n                  (empty? lst) nil\n                  (line-winner (first lst)) (line-winner (first lst))\n                  :else (recur (rest lst))))\n        collect-col (fn [i]\n                      (map #(nth %1 i) rows))\n        cols (map collect-col (range 3))\n        diag1 (map nth rows (range 3))\n        diag2 (map nth rows (reverse (range 3)))\n        lines (conj (into rows cols) diag1 diag2)]\n    (winner lines)))","problem":73,"user":"4eb66737535d7eef3080736b"},{"code":"(fn [board]\n  (let [same? #(= 1 (count (set %)))\n        k {:x :x :o :o :e nil}\n        vert (vec (partition 3 (apply interleave board)))\n        diag [(for [i (range 0 3)] ((board i) i))\n              (for [i (range 0 3)] ((board i) (- 2 i)))]]\n    (if-let [result (some #(if (same? %) %) (concat board vert diag))]\n      (k (first result)))))","problem":73,"user":"4f0ef874535d0136e6c22328"},{"problem":73,"code":"(fn [a]\n  (let [lines (vector (a 0) \n         (a 1)\n         (a 2)\n         (vector ((a 0) 0) ((a 1) 0) ((a 2) 0))\n         (vector ((a 0) 1) ((a 1) 1) ((a 2) 1))\n         (vector ((a 0) 2) ((a 1) 2) ((a 2) 2))\n         (vector ((a 0) 0) ((a 1) 1) ((a 2) 2))\n         (vector ((a 0) 2) ((a 1) 1) ((a 2) 0)))]\n    (cond \n     (not (empty? (filter #(= [:o :o :o] %) lines))) :o\n     (not (empty? (filter #(= [:x :x :x] %) lines))) :x\n     :else nil)))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":73,"code":"(fn ticktac [col] (letfn \n  [\n   (checkrow\n     [row]\n     (cond\n        (= row (repeat 3 :x)) :x\n        (= row (repeat 3 :o)) :o\n        :else nil))]\n  (or\n    (reduce #(or %1 (checkrow %2)) nil col)\n    (reduce #(or %1 (checkrow %2)) nil (apply map list col))\n    (checkrow (map #(nth %1 %2) col (range 3)))\n    (checkrow (map #(nth %1 %2) col (range 2 -1 -1))))))","user":"55536a8ae4b0deb715856e03"},{"problem":73,"code":"(fn [b]\n  (let [hrows b\n        vrows (apply map vector b)\n        is (range 3)\n        drow1 (map #(% %2) b is)\n        drow2 (map #(% %2) b (reverse is))\n        rows (concat hrows vrows [drow1 drow2])]\n    (ffirst\n     (filter (fn [[k v]]\n               (and (= v 3)\n                    (not= k :e)))\n             (mapcat frequencies rows)))))","user":"508923d5e4b06d8254e936e8"},{"problem":73,"code":"(fn eka\n    [board]\n    (->> board\n         (apply interleave)\n         (partition 3)\n         (concat board)\n         (concat [(reduce #(conj %1 (nth %2 (count %1))) [] board)])\n         (concat [(reduce #(conj %1 (nth %2 (count %1))) [] (reverse board))])\n         (map #(into #{} %))\n         (filter #(not= :e (first %)))\n         (filter #(= 1 (count %)))\n         (#(if-not (empty? %) (first (first %))))\n         )\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":73,"code":"(fn [v]\n  (letfn [(transpose [c] (partition (count c) (apply interleave c)))\n          (diag [c] (list (map #(nth (nth c %) %) (range (count c)))))]\n\t(let [tuples (concat v (transpose v) (diag v) (diag (reverse v)))]\n      (some #(and (every? #{:x :o} %) (apply = %) (first %)) tuples))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn [b]\n  (some (fn [p] (first (keep #(if (apply = p %) p)\n                             `(~@b\n                               ~@(apply map list b)\n                               ~(map get b [0 1 2])\n                               ~(map get b [2 1 0])))))\n        [:x :o]))","problem":73,"user":"4e52d815535d302ef430da77"},{"code":"(fn [g]\n  (let [a (to-array-2d g)\n        w [[[0 0] [0 1] [0 2]]\n           [[1 0] [1 1] [1 2]]\n           [[2 0] [2 1] [2 2]]\n           [[0 0] [1 0] [2 0]]\n           [[0 1] [1 1] [2 1]]\n           [[0 2] [1 2] [2 2]]\n           [[0 0] [1 1] [2 2]]\n           [[0 2] [1 1] [2 0]]]\n        wi? (fn [p e] (every? #(= (apply aget a %) p) e))\n        w? (fn [p] (some #(wi? p %) w))]\n    (cond (w? :x) :x\n          (w? :o) :o\n          :else nil)))","problem":73,"user":"4faac363e4b081705acca200"},{"code":"(fn [board]\n  (some (fn [v] (some #(when (apply = % v) %) [:x :o])) \n        (->>\n         (for [[[x y] f g] `[ [[0 0] ~inc ~inc]\n                              [[0 2] ~inc ~dec]\n                              ~@(for [x [0 1 2]] [[x 0] identity inc])\n                              ~@(for [x [0 1 2]] [[0 x] inc identity])]]\n           (take 3 (map vector (iterate f x) (iterate g y))))\n         (map (fn [v] (map #(get-in board %) v))))))","problem":73,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn __ [board]\n  (let [bt (apply map vector board)\n        cross [(map #(-> board (nth %) (nth %)) (range 3))\n               (map #(-> board (nth (- 2 %)) (nth %)) (range 3))]]\n    (cond\n      (some #(= (distinct %) [:x]) board) :x\n      (some #(= (distinct %) [:x]) bt) :x\n      (some #(= (distinct %) [:x]) cross) :x\n      (some #(= (distinct %) [:o]) board) :o\n      (some #(= (distinct %) [:o]) bt) :o\n      (some #(= (distinct %) [:o]) cross) :o\n      :else nil)\n    ))","problem":73,"user":"52828298e4b0757a1b17145b"},{"problem":73,"code":"(fn [b]\n  (let [l (count b)\n        x (range l)\n        y (reverse x)\n        rs (-> (into b (apply map vector b))\n               (conj (vec (mapcat #(take 1 (drop %1 (cycle %2))) x b)))\n               (conj (vec (mapcat #(take 1 (drop %1 (cycle %2))) y b))))]\n    (->> (filter #(apply = %) rs)\n         (map first)\n         (some #{:o :x}))))","user":"54f0d3fde4b024c67c0cf8a6"},{"code":"(fn [[[a1 a2 a3]\n     [b1 b2 b3]\n     [c1 c2 c3]]]\n   (let [win? (fn [[x y z]] (when (and (not= x :e) (= x y z)) x))\n         lines [[a1 a2 a3]\n                [b1 b2 b3]\n                [c1 c2 c3]\n                [a1 b1 c1]\n                [a2 b2 c2]\n                [a3 b3 c3]\n                [a1 b2 c3]\n                [a3 b2 c1]]]\n     (some win? lines)))","problem":73,"user":"5028cd0fe4b01614d1633ffc"},{"problem":73,"code":"(fn ttt [board]\n    (let [ series (conj board (map first board) (map second board) (map last board)\n                        [(first (first board)) (second (second board)) (last (last board))]\n                        [(last (first board)) (second (second board)) (first (last board))])\n         ]\n    (cond\n        (some true? (map (fn [x] (every? #(= :x %) x)) series)) :x\n        (some true? (map (fn [x] (every? #(= :o %) x)) series)) :o\n        :else nil\n    )) \n)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [n]\n    (let [check (fn [j] (if (= 1 (count (distinct j))) (first j) :e))\n          lines (map check n)\n          columns (map #(check ( map (fn [x] (nth x %)) n)) (range 0 3))\n          diag (check (map (fn [x] (nth (nth n x) x)  ) (range 0 3) ))\n          odiag (check (map (fn [x] (nth (nth n x) (- 2  x))  ) (range 0 3) ))\n          final (flatten [lines columns diag odiag]) ]\n          \n\n          (first (filter  #(not= :e %) final) ) ) )","problem":73,"user":"5124619ae4b02c3f2a072ccd"},{"problem":73,"code":"(fn winner? [board]\n               (letfn [(is-winning? [s]\n                         (if (and (apply = s) (not (= :e (first s))))\n                           (first s)\n                           nil))\n                       (is-winning-row? [b]\n                         (loop [rows b]\n                           (if (empty? rows)\n                             false\n                             (if (is-winning? (first rows))\n                               (is-winning? (first rows))\n                               (recur (rest rows))))))\n                       (is-winning-col? [b]\n                         (loop [cols (map (fn [i] (map #(nth % i) b)) (range 3))]\n                           (if (empty? cols)\n                             false\n                             (if (is-winning? (first cols))\n                               (is-winning? (first cols))\n                               (recur (rest cols))))))\n                       (is-winning-diag? [b]\n                         (let [diag (map #(get-in b [% %]) (range 3))]\n                           (is-winning? diag)))\n                       (is-winning-anti-diag? [b]\n                         (let [anti-diag (map #(get-in b [% (- 2 %)]) (range 3))]\n                           (is-winning? anti-diag)))]\n                 (if (is-winning-row? board)\n                   (is-winning-row? board)\n                   (if (is-winning-col? board)\n                     (is-winning-col? board)\n                     (if (is-winning-diag? board)\n                       (is-winning-diag? board)\n                       (is-winning-anti-diag? board))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":73,"code":"(fn tic-tac-toe-winner [board]\n  (letfn [(make-groups [board]\n            (let [max-col (count board)\n                  max-row (count (first board))]\n              (concat\n               (for [i (range max-col)]\n                 (for [j (range max-row)] ((board i) j)))\n               (for [j (range max-row)]\n                 (for [i (range max-col)] ((board i) j)))\n               [(for [i (range max-row)] ((board i) i))]\n               [(for [i (reverse (range max-row))]\n                  ((board i) (dec (- max-row i))))])))\n\n          (game-winner [[cell-grp & cell-grps]]\n            (if-not cell-grp\n              nil\n              (if (and (not (some #(= :e %1) cell-grp)) (apply = cell-grp))\n                (first cell-grp)\n                (recur cell-grps))))]\n\n    (game-winner (make-groups board))))","user":"57c500f9e4b05aa3c4741cda"},{"code":"(fn tic-tac-toe\n  [[[a b c] [d e f] [g h i]]]\n  (letfn [(all?\n            [p xs]\n            (every? #(= p %) xs))\n          (winner?\n            [p]\n            (some #(all? p %) [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]]))]\n    (cond (winner? :x) :x (winner? :o) :o :else nil)))","problem":73,"user":"4e50b67b535dc968683fc4ed"},{"code":"(fn [coll]\n  (ffirst\n    (filter #(or (= (repeat 3 :x) %) (= (repeat 3 :o) %))\n      (apply concat [\n          coll\n          (apply map vector coll)\n          [(reduce (fn [a i] (cons (first (drop (count a) i)) a)) [] coll)]\n          [(reduce (fn [a i] (cons (first (drop (count a) (reverse i))) a)) [] coll)]\n        ]\n      ))))","problem":73,"user":"50e8a340e4b0ebbe794eb7ed"},{"code":"(fn tictactoe [board]\n        (let [pw (loop [pw [] x 0]\n                       (if (> x 2)\n                           pw\n                         (recur (conj pw\n                                      (map #(nth % x) board))\n                                (inc x))))\n              pw (loop [pw pw x 0]\n                       (if (> x 2)\n                           pw\n                         (recur (conj pw\n                                      (board x))\n                                (inc x))))\n              pw (conj pw\n                       [(get-in board [0 0])\n                        (get-in board [1 1])\n                        (get-in board [2 2])])\n              pw (conj pw\n                       [(get-in board [0 2])\n                        (get-in board [1 1])\n                        (get-in board [2 0])])]\n          (cond (some true? (map #(apply = :x %) pw)) :x\n                (some true? (map #(apply = :o %) pw)) :o\n                :else nil)))","problem":73,"user":"51a8f0c6e4b08d8ec191b821"},{"problem":73,"code":"(fn tic-tac-toe [board] (let [\n                  horizontal board \n                  vertical (apply mapv vector board)\n                  diagonal [(map get board [0 1 2]) (map get board [2 1 0])]\n                  ] (if-let [\n                    match (first (filter #(and (not= #{:e} %) (= 1 (count %))) (map set (concat horizontal vertical diagonal))))]\n                    (first match) \n                    nil)))","user":"5d45bd1de4b07c84aa5ae6a4"},{"problem":73,"code":"(fn analyze-tic-tac-toe\n  [m]\n  (let [cols (apply mapv vector m)\n        dia1 [[((m 0) 0) ((m 1) 1) ((m 2) 2)]]\n        dia2 [[((m 2) 0) ((m 1) 1) ((m 0) 2)]]\n        allrows (concat m cols dia1 dia2)]\n    (if (some true? (map (fn [x] (every? #(= :x %) x)) allrows))\n      :x\n      (if (some true? (map (fn [x] (every? #(= :o %) x)) allrows))\n        :o\n        nil))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":73,"code":"(fn sam [b] \n  (let \n    [ final (reduce #(if (nil? %) %2 %) \n      [ (reduce #(if (nil? %) %2 %) (map #(if (= (first %) (second %) (last %)) (first %) nil) ((juxt #(map first %) #(map second %) #(map last %)) b)))\n        (reduce #(if (nil? %) %2 %) (map #(if (= (first %) (second %) (last %)) (first %) nil) b))\n        (reduce #(if (= % %2) % nil) [ (first (first b)) (second (second b)) (last (last b))])\n        (reduce #(if (= % %2) % nil) [ (last (first b)) (second (second b)) (first (last b))])]) \n      ] \n      (if (= final :e) nil final)))","user":"59c734e3e4b0a024fb6ae53f"},{"problem":73,"code":"(fn [colls]\n  (let [search (fn [k] (or (some true? (map #(every? (partial = k) %) colls)) ;all lines\n                           (every? (partial = k) (map first colls))  ;vertical1\n                           (every? (partial = k) (map second colls)) ;vertical2\n                           (every? (partial = k) (map last colls))   ;vertical3\n                           (every? (partial = k) [(ffirst colls) (-> colls second second) (-> colls last last)])             ;diag1\n                           (every? (partial = k) [(-> colls last first)  (-> colls second second) (-> colls first last)])))] ;diag2\n    (cond \n      (search :x) :x\n      (search :o) :o\n      :else       nil)))","user":"4e3ff3a4535dc968683fc499"},{"problem":73,"code":"(fn [t] (let\n [o (concat t (apply mapv vector t)  (vector (vec (map #(apply nth %) (map vector t [0 1 2])))) (vector (vec (map #(apply nth %) (map vector t [2 1 0])))))\n  u (filter (fn [x] (= 1 (count x))) (map set o))\n  w (first (map first u))]\n  (if (= :e w) nil w)\n ))","user":"4edbbc6c535d10e5ff6f531d"},{"code":"(fn [[[a b c] [d e f] [g h i] :as q]]\n  (some { [:o :o :o] :o, [:x :x :x] :x }\n    (concat q (apply map list q) [[a e i] [c e g]]) ))","problem":73,"user":"5014718fe4b094324338f8e3"},{"problem":73,"code":"(fn [board]\n  (let [rows board ;get rows\n        columns (apply map vector board) ;get columns\n        diagonals [(map get board [0 1 2]) (map get board [2 1 0])]] ;get diagonals\n    (loop [remaining (concat rows columns diagonals)] ;all potential triplets\n      (if-let [item (set (first remaining))]\n        (if (and (not-any? #(= :e %) item) (or (every? #(= :x %) item) (every? #(= :o %) item)));find the winner\n          (first item)\n          (recur (rest remaining)))\n        nil))));or return nil","user":"556c70dae4b09a3098a524fd"},{"problem":73,"code":"(fn [b]\n         (letfn\n             [(flip [b] [(get b 2) (get b 1) (get b 0)])\n              (rot [b] (for [x (range 3)] (map #(get % x) b)))\n              (diag [b] (for [x (range 3)] (get (get b x) x)))\n              (cntr-diag [b] (diag (flip b)))\n              (win-row [p r] (every? #(= p %) r))\n              (some-row [p b] (some #(win-row p %) b))\n              (win? [p b]\n                (or (some-row p b) (some-row p (rot b)) (win-row p (diag b)) (win-row p (cntr-diag b))))\n              ]\n           (cond\n             (win? :x b) :x\n             (win? :o b) :o\n             :else nil)))","user":"5da71eaee4b000c986472c15"},{"code":"(fn [board]\n  (let [r (apply (partial map #(vector %1 %2 %3)) board)\n        d1 (map #(nth %1 %2) board (range 3))\n        d2 (map #(nth %1 %2) board (range 2 -1 -1))\n        all (concat board r [d1 d2])] \n    (cond\n     (some #(apply = (conj % :x)) all) :x\n     (some #(apply = (conj % :o)) all) :o\n     true nil)))","problem":73,"user":"524be8e0e4b09eba1c0223f1"},{"code":"(fn tic-tac-toe [[r1 r2 r3 :as rows]]\n  (let [cols  (apply map vector rows)\n        diags [[(r1 0) (r2 1) (r3 2)]\n               [(r1 2) (r2 1) (r3 0)]]\n        three-in-row (fn [flag colls] (some #(apply = flag %) colls))\n        win (fn [flag] (some #(three-in-row flag %) [rows cols diags]))]\n    (cond (win :x) :x\n          (win :o) :o\n          :else    nil)))","problem":73,"user":"50586354e4b06522596eba78"},{"problem":73,"code":"(fn[board]\n  (first (disj (disj (set (concat (map (fn[a](when (apply = a) (first a))) board)\n                         (map (fn[a](when (apply = a) (first a))) (apply map list board))\n                         [(when (= (get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])) (get-in board [0 0]))]\n                         [(when (= (get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])) (get-in board [0 2]))])) :e) nil)))","user":"5596af34e4b04c1e5c31d758"},{"problem":73,"code":"(fn ttt? [board]\n  (let [wins  #{#{:x} #{:o}}\n        diags [(for [i (range (count board))]\n                 (nth (nth board i) (dec (- (count board) i))))\n               (for [i (range (count board))]\n                 (nth (nth board i) i))]\n        lines  (concat board\n                       (apply map vector board)\n                       diags)]\n\n    (ffirst (filter #(wins (into #{} %)) lines))))","user":"5a257747e4b07f18be40aa1f"},{"problem":73,"code":"#(letfn [(diagonal [[x y]] (get-in % [x y]))]\n  (->> (apply map list %)\n       (concat %\n               (list (map diagonal '((0 0) (1 1) (2 2))))\n               (list (map diagonal '((0 2) (1 1) (2 0)))))\n       (filter (partial apply =))\n       (filter (partial apply not= :e))\n       (ffirst)))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn ttt\n  [board]\n  (let [c1 (map first board)\n        c2 (map second board)\n        c3 (map last board)\n        d1 (list (first c1) (second c2) (last c3))\n        d2 (list (first c3) (second c2) (last c1))\n        all (concat [c1 c2 c3 d1 d2] board)\n        won? (fn [sym] (pos? (count (filter (fn [r] (every? #(= % sym) r)) all))))]\n    (cond\n      (won? :x) :x\n      (won? :o) :o\n      :else nil)))","problem":73,"user":"5348cab4e4b084c2834f4a5e"},{"problem":73,"code":"(fn winner [board]\n  (let [diag (partial map-indexed #(nth %2 %))\n        diags (juxt diag (comp diag rseq))]\n    (->> board\n         ((juxt\n           identity               ; rows\n           #(apply map vector %)  ; cols\n           diags))                ; both diagonals\n         (apply concat)\n         (map set)\n         (remove #(or (:e %) (> (count %) 1)))\n         ffirst)))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":73,"code":"(fn ttt [board]\n    (let [rows board\n          columns (apply map vector board)\n          diagonals \n            [(map #(get-in board %) [[0 0] [1 1] [2 2]]) \n             (map #(get-in board %) [[0 2] [1 1] [2 0]])]\n          triplets (concat rows columns diagonals)]\n      (first (remove #(= % :e) (map first (filter #(apply = %) triplets))))))","user":"4ed8715c535d10e5ff6f52f9"},{"problem":73,"code":"(fn [board] \n   (let [successStates (list '(0 1 2) '(3 4 5)'(6 7 8) '(0 3 6) '(1 4 7) '(2 5 8) '(0 4 8) '(2 4 6))\n         flatboard (flatten board)]\n        (reduce\n          (fn [prv cur]\n            ( map (fn [key] (nth flatboard key)) cur)\n               (let [s (into #{} (map (fn [key] (nth flatboard key)) cur))]\n                 (if (and (= (count s) 1) (not= (first s) :e)) (first s) prv)\n               )          \n           )\n          nil successStates)\n\n))","user":"58951903e4b00487982d5274"},{"code":"(fn [b]\n    (some {[:o :o :o] :o [:x :x :x] :x}\n          (concat b (apply map list b)\n                    (map #(for [n [0 1 2]] (nth (nth % n) n))\n                         [b (rseq b)]))))","problem":73,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn [coll]\r\n  (let [combos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\r\n        board (vec (flatten coll))]\r\n    (first (filter #(not= :e %)\r\n             (map first\r\n               (filter #(apply = %)\r\n                 (map (fn [x] (map #(board %) x)) combos)))))))","problem":73,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":73,"code":"(fn [bd]\n  (let [ldiag [[0 0] [1 1] [2 2]]\n        rdiag [[0 2] [1 1] [2 0]]\n        rows (map #(vector [% 0] [% 1] [% 2]) (range 3))\n        cols (map #(vector [0 %] [1 %] [2 %]) (range 3))]\n    (first (filter (comp not nil?)\n            (for [line (cons ldiag (cons rdiag (concat rows cols)))]\n      (let [res (distinct (map #(nth (nth bd (second %)) (first %)) line))]\n        (if (and (= (count res) 1) (not (= :e (first res))))\n          (first res)\n          nil)))))))","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn [rows]\n  (let [cols (partition 3 (apply interleave rows))\n        d1   [(map-indexed #(%2 %1) rows)]\n        d2   [(map-indexed #(%2 (- 2 %1)) rows)]\n        sets (concat rows cols d1 d2)]\n    (some \n      #(cond\n        (apply = :x %) :x\n        (apply = :o %) :o\n        :else nil)\n      sets)))","problem":73,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (let [s [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]]\n        win (first (first (filter #(= 1 (count %)) (map #(into #{} %) s))))]\n    (if (= :e win) nil win)))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn check-board [board]\r\n        (let [rows board\r\n              cols (apply map vector board)\r\n              left-diag (apply vector \r\n                               (take-nth (inc (count board)) \r\n                                         (apply vector (flatten board))))\r\n              right-diag (let [n (dec (count board))] \r\n                           (apply vector (take (count board) (take-nth n \r\n                                                   (apply vector (drop n (flatten board)))))))\r\n              diags [left-diag right-diag]\r\n              all-lines (concat rows cols diags)]\r\n          (ffirst (filter #(or (= '(:x) %) (= '(:o) %)) (map distinct all-lines)))))","problem":73,"user":"4f82e14be4b033992c121c0c"},{"problem":73,"code":"(fn [b]\n  (let [idxs (let [w1 (for [x (range 3) y (range 3)] [x y])\n                   w2 (map reverse w1)\n                   w3 [[0 0] [1 1] [2 2]]\n                   w4 [[0 2] [1 1] [2 0]]]\n               (partition 3 (concat w1 w2 w3 w4)))\n        cmb (map #(map (partial get-in b) %) idxs)]\n    (cond\n      (some (partial every? (partial = :x)) cmb) :x\n      (some (partial every? (partial = :o)) cmb) :o\n      :else nil)))","user":"54bc539be4b0ed20f4ff6eca"},{"problem":73,"code":"(fn\n  [[[a00 a01 a02]\n    [a10 a11 a12]\n    [a20 a21 a22]]]\n  (let [s [[a00 a01 a02] [a10 a11 a12] [a20 a21 a22] [a00 a10 a20] [a01 a11 a21] [a02 a12 a22] [a00 a11 a22] [a02 a11 a20]]\n        xs (count (filter #(= % 3) (map count (map (fn [x] (filter #(= % :x) x)) s))))\n        os (count (filter #(= % 3) (map count (map (fn [x] (filter #(= % :o) x)) s))))]\n    (if (= xs 1)\n      :x\n      (if (= os 1)\n        :o\n        nil))\n    )\n  )","user":"56ab7578e4b03c432f18733d"},{"code":"(fn [field-2d]\n  (let [wins [[0 1 2][3 4 5][6 7 8][0 3 6][1 4 7][2 5 8][0 4 8][2 4 6]]\n        field (flatten field-2d)\n        condition-true (fn [[i j k]]\n                         (let [a (nth field i)\n                               b (nth field j)\n                               c (nth field k)]\n                           (when (and (not= a :e) (= a b c)) \n                             a)))]\n    (some condition-true wins)))","problem":73,"user":"5117c31ee4b0e0897831a60c"},{"code":"(fn ttt [board]\n  (let [winv [; rows\n              [0 1 2]\n              [3 4 5]\n              [6 7 8]\n              ; cols\n              [0 3 6]\n              [1 4 7]\n              [2 5 8]\n              ; diags\n              [0 4 8]\n              [2 4 6]]\n        ; (:o :o :x :e :x ...)\n        flat-board (vec (apply concat board))\n        ; (nil nil :x nil ...)\n        combos     (for [w winv]\n                      (cond\n                        (= [:x :x :x] (map #(nth flat-board %) w)) :x\n                        (= [:o :o :o] (map #(nth flat-board %) w)) :o ))]\n    (first (filter (comp not nil?) combos)) ))","problem":73,"user":"4e617114535d8ccf87e9fe5b"},{"problem":73,"code":"(fn who-won [my-table] \n  (let [top (first my-table)\n        middle (second my-table)\n        bottom (last my-table)]\n  (cond\n    (and (= :e (first top) (second top) (last top)) (= :e (first middle) (second middle) (last middle)) (= :e (first bottom) (second bottom) (last bottom))) nil\n    (or (= :x (first top) (second top) (last top)) (= :x (first middle) (second middle) (last middle)) (= :x (first bottom) (second bottom) (last bottom))) :x\n    (or (= :o (first top) (second top) (last top)) (= :o (first middle) (second middle) (last middle)) (= :o (first bottom) (second bottom) (last bottom))) :o\n    (and (= :x (first top)) (= :x (first middle)) (= :x (first bottom))) :x\n    (and (= :x (first top)) (= :x (second middle)) (= :x (last bottom))) :x\n    (and (= :x (last top)) (= :x (second middle)) (= :x (first bottom))) :x\n    (and (= :o (first top)) (= :o (first middle)) (= :o (first bottom))) :o\n    (and (= :o (first top)) (= :o (second middle)) (= :o (last bottom))) :o\n    (and (= :o (last top)) (= :o (second middle)) (= :o (first bottom))) :o\n    :else nil\n    )      \n   )\n  )","user":"5b7ec218e4b047b03b20375e"},{"problem":73,"code":"(fn [board]\n  (let [check (fn [c lst]\n                (some identity\n                      (map (fn [l] (some identity\n                                         (map #(apply = c %)\n                                              l)))\n                           lst)))\n        v (list board\n                (apply map list board)\n                (loop [b board rd [] ld [] i 0]\n                  (if (empty? b)\n                    (list rd ld)\n                    (let [row (first b)]\n                      (recur (rest b) (conj rd (nth row i)) (conj ld (nth row  (- (count row) i 1))) (inc i))))))]\n    (cond (check :x v) :x (check :o v) :o :else nil)))","user":"58844d43e4b0f1effa3b7696"},{"problem":73,"code":"(fn [tictac] \n   (let [rows (concat \n    (vector (map-indexed #(nth %2 %) (map reverse tictac)))\n    (vector (map-indexed #(nth %2 %) tictac))\n    tictac \n    (apply mapv vector tictac))] \n     (cond \n      (some #(every? #{:x} %) rows) :x\n      (some #(every? #{:o} %) rows) :o\n      :else nil)))","user":"548cd637e4b0e286459a1210"},{"problem":73,"code":"(fn whoWon? [board]\n  (let [winningCombinations [[0 1 2] [3 4 5] [6 7 8]\n                             [0 3 6] [1 4 7] [2 5 8]\n                             [0 4 8] [2 4 6]]\n        board (into [] (flatten board))]\n    (letfn [(winningCombo? [coll]\n                           (if (and (= (count (distinct coll)) 1 ) (not= (first coll) :e))\n                             (first coll)\n                             nil))]\n        (let [winner (keep winningCombo? (map (fn [combo] (map #(get board %) combo)) winningCombinations))]\n          (if (empty? winner)\n            nil\n            (first winner)\n          )))))","user":"57131dfbe4b07c98581c3a98"},{"problem":73,"code":"(fn [horizontals]\n   (let\n       [lines\n        (concat\n          horizontals\n          (apply map vector horizontals)\n          (vector\n            (map\n              #(nth (nth horizontals %) %)\n              (range 0 (count horizontals))))\n          (vector\n            (map\n              #(nth (nth (reverse horizontals) %) %)\n              (range 0 (count horizontals)))))]\n       (first\n         (first\n          (filter\n           #(= (count %) 1)\n           (filter\n            #(not(contains? % :e))\n            (map set lines)))))))","user":"586a657de4b0f14aab7c88bd"},{"problem":73,"code":"(fn p73\n  [coll]\n  (let [hor (map (fn [x] (map #(list %1 %2) (cycle [x]) (range 3))) (range 3))\n        ver (map (fn [x] (map #(list %1 %2) (range 3) (cycle [x]))) (range 3))\n        dia1 (map #(list %1 %2) (range 3) (range 3))\n        dia2 (map #(list %1 %2) (range 3) (reverse (range 3)))\n        all (conj (concat hor ver) dia1 dia2)]\n    (first\n     (keep (fn [l]\n             (let [end (map #(get-in coll %) l)]\n               (if (apply = end)\n                 (if (or (= (first end) :x) (= (first end) :o))\n                   (first end)\n                   nil)))) all))))","user":"520cb8c4e4b0b022ef140c9a"},{"code":"(fn [board]\n  (let [v (fn [row col] (nth (nth board row) col))\n        triples (concat board\n                        (apply map list board)\n                        [ [(v 0 0) (v 1 1) (v 2 2)]\n                          [(v 0 2) (v 1 1) (v 2 0)] ])]\n    (if-let [t (first (filter #(let [p (partition-by identity %)]\n                                 (and (= 1 (count p))\n                                      (not= :e (ffirst p))))\n                              triples))]\n      (first t))))","problem":73,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [mtx]\n  (let [eval-rows (fn [mat]\n                    (let [lsets (filter #(and (= 1 (count %)) (not (% :e))) (map set mat))]\n                      (if (zero? (count lsets))\n                        nil\n                        (ffirst lsets))))\n        get-diag #(identity\n                   [[(nth (first mtx) 0) (nth (second mtx) 1) (nth (last mtx) 2)]\n                    [(nth (first mtx) 2) (nth (second mtx) 1) (nth (last mtx) 0)]])\n        get-cols #(partition 3 (interleave (first mtx) (second mtx) (last mtx)))]\n\n    (or (eval-rows mtx) (eval-rows (get-cols)) (eval-rows (get-diag)))))","problem":73,"user":"4efec33f535dcb61093f6a2a"},{"problem":73,"code":"(fn [board]\n  (let [rows board\n        columns (apply map list board)\n        diagonals [[(first (first board)) (second (second board)) (nth (nth board 2) 2)]\n                   [(first (nth board 2)) (second (second board)) (nth (first board) 2)]]\n        lines (concat rows columns diagonals)\n        matches (filter #(apply = %) lines)\n        winner (first (first (filter #(not-any? #{:e} %) matches)))]\n    winner))","user":"53da19fde4b0e771c3025484"},{"problem":73,"code":"(fn [board]\n  (let [h board\n        v (apply (partial map list) board)\n        d (let [[[a _ b]\n                 [_ c _]\n                 [d _ e]] board]\n            [[a c e] [b c d]])\n        all (concat h v d)\n        wins? (fn [[a b c]] (and (= a b c) (not= a :e)))\n        winner (->> (filter wins? all) first first)]\n    winner))","user":"55895eade4b059ccff29b202"},{"code":"(fn tictac[b]\n  (let [checkLine (fn cl[board] \n  \t\t(first (filter #(not (nil? %)) \n                                       (map (fn checkLine[line] (if (and (apply = line) (not (= (first line) :e))) (first line) nil)) board)))\n                    )\n\thorizontal (checkLine b)\n\ttrasposed (partition 3 (apply interleave b))\n\tvertical (checkLine trasposed)\n\tdiagonal1 (if (apply = (for [x [0 1 2]] (-> b (nth x) (nth x)))) (-> b (nth 0) (nth 0)) nil)\n\tdiagonal2 (if (apply =  (for [x [[0 2][1 1][2 0]]] (-> b (nth (first x)) (nth (second x))))) (-> b (nth 0) (nth 2)) nil)\n\tresult (first (filter #(not (nil? %)) [horizontal vertical diagonal1 diagonal2]))\n        ]\n    (if (= result :e) nil result)\n  )\n)","problem":73,"user":"4e9de526535dbda64a6f6b8e"},{"code":"(fn analyze-tic-tac [board]\n  (letfn [(get-column [n] (map #(% n) board))\n          (winner [seq] (cond (every? #(= :x %) seq) :x\n                              (every? #(= :o %) seq) :o))]\n    (let [columns (map get-column (range 3))\n          diags   [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                   [((board 2) 0) ((board 1) 1) ((board 0) 2)]]\n          lines   (concat board columns diags)]\n      (some winner lines))))","problem":73,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":73,"code":"(fn tic-tac-toe-winner\n  [s]\n  (let [rows s\n        columns  (apply map vector s)\n        diags [[(get (get s 0) 0) (get (get s 1) 1) (get (get s 2) 2)]\n               [(get (get s 0) 2) (get (get s 1) 1) (get (get s 2) 0)]]\n        lines (concat rows columns diags)\n        k-line? (fn\n                  [k lines]\n                  (not (empty?\n                         (filter\n                           (fn [x] (= #{k} x))\n                           (map #(into #{} %) lines)))))]\n    (cond\n      (k-line? :x lines)\n      :x\n      (k-line? :o lines)\n      :o\n      :default\n      nil)))","user":"594266cfe4b060784b3b790b"},{"problem":73,"code":"(fn [board]\n  (first (first (filter #(and (= 1 (count %)) (not-empty (clojure.set/intersection #{:o :x} %)))\n    (clojure.set/union\n      ; rows\n      (set (map #(into #{} %) board))\n      ; cols\n      (set (for [i (range 3)]\n        (set (map #(nth % i) board))))\n      ;diag l-r\n      (set (list (set (for [i (range 3)]\n        (get-in board [i i])))\n      ;diag r-l\n      (set (for [i (range 3)]\n        (get-in board [i (- 2 i)]))))))))))","user":"590b055ae4b047aa04b199c9"},{"problem":73,"code":"(fn [m]\n  (let [rot (for [i (range 3)] (map #(nth % i) m))\n        d1 (map #(get-in m [% %2]) [0 1 2] [0 1 2])\n        d2 (map #(get-in m [% %2]) [0 1 2] [2 1 0])\n        win? (fn [v m] (some true? (map #(every? #{v} %) m)))]\n    (cond\n      (win? :x m) :x\n      (win? :x rot) :x\n      (win? :o m) :o\n      (win? :o rot) :o\n      (win? :x [d1 d2]) :x\n      (win? :o [d1 d2]) :o\n      :else nil)))","user":"56a76f36e4b07966d5a8a05b"},{"code":"(fn [board]\n  (let [r (range 3)\n        flat (concat\n               (for [x r y r]\n                 ((board y) x))\n               (for [y r x r]\n                 ((board y) x))\n               (map #((board %) %) r)\n               (map #((board %) (- (last r) %)) r))]\n  (->> flat\n    (partition 3)\n    (map (fn [[a b c]]\n           (cond (= a b c :x) :x\n                 (= a b c :o) :o\n                 :else nil)))\n    (remove nil?)\n    (first))))","problem":73,"user":"4f8345c6e4b033992c121c1b"},{"problem":73,"code":"(fn [board]\n    (let [winning   #(cond (= % [:o :o :o]) :o\n                           (= % [:x :x :x]) :x\n                           :else            nil)\n          transpose (fn [board]\n                      (apply map list board))]\n      (;; Returns the winner (the first one found), otw nil\n       some\n       identity\n       (map winning\n            (;; All lines on the board\n             concat\n             board\n             (;; Column\n              transpose board)\n             [[;; Right Diagonal\n               ((board 0) 0) ((board 1) 1) ((board 2) 2)]\n              [;; Left Diagonal\n               ((board 0) 2) ((board 1) 1) ((board 2) 0)]])))))","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":73,"code":"(fn [board]\n    (let [\n          get-win\n          (fn [vals] (if (apply = vals) (first vals) nil))\n          get-tile-vals\n          (fn [board tiles]\n              (map #(nth (nth board (second %)) (first %)) tiles))\n          get-win-over-tiles\n          (fn [board tiles]\n              (get-win (get-tile-vals board tiles)))\n          cols  \n          (fn []\n              (for [x [0 1 2]]\n                   (vec (for [y [0 1 2]] [x y]))))\n          rows\n          (fn []\n              (for [x [0 1 2]]\n                   (vec (for [y [0 1 2]] [y x]))))\n          diag1\n          (fn []\n              (vec (for [n [0 1 2]]\n                        [n n])))\n          diag2\n          (fn []\n              (vec (for [n [0 1 2]]\n                        [(- 2 n) n])))\n          searches\n          (fn []\n              (conj (apply conj (rows) (cols)) (diag1) (diag2)))\n          first-matching\n          (fn [symbols input]\n              (first (filter #(not= nil (some #{%} symbols)) input)))\n          ]\n        (first-matching [:x :o]\n                  (map #(get-win-over-tiles board %) (searches)))))","user":"5a21d34ce4b0ff51aa4b32b9"},{"code":"(fn [board]\n  (let [board (apply concat board)\n        tests [[0 3 6] [1 4 7] [2 5 8]\n               [0 1 2] [3 4 5] [6 7 8]\n               [0 4 8] [2 4 6]]\n        lines (map #(set (map (partial nth board) %)) tests)\n        equal (filter #(and (= (count %) 1) (not= (first %) :e)) lines)]\n   (first (first equal))))","problem":73,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [board]\r\n  (let [rows board\r\n    cols (apply map list board)\r\n    diag1 (map nth board '(0 1 2))\r\n    diag2 (map nth board '(2 1 0))\r\n    sets (concat rows cols (list diag1 diag2))]\r\n    (cond\r\n      (some (partial every? #{:x}) sets) :x\r\n      (some (partial every? #{:o}) sets) :o\r\n      true nil)))","problem":73,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn [m]\n  (first\n    (filter\n      (fn win? [player]\n        (->> (let [idx [0 1 2]]\n                (concat m                               ; rows\n                  (map (fn [i] (map #(% i) m)) idx)     ; columns\n                  (vector (map #((m %) %) idx))         ; diagonal 1\n                  (vector (map #((m (- 2 %)) %) idx)))) ; diagonal 2\n             (map (fn [row] (count (filter #(= player %) row))))\n             (filter #(= % 3))\n             seq))\n      [:x :o])))\n; https://gist.github.com/fronx/1222682","problem":73,"user":"5349da55e4b084c2834f4a68"},{"code":"(fn [B]\n    (let [m {[:x :x :x] :x [:o :o :o] :o}\n          T (apply map list B)\n          diag #(for [i [0 1 2]] (nth (nth % i) i))]\n      (some m (concat B T [(diag B)] [(diag (reverse B))]))))","problem":73,"user":"4fc67081e4b0ee37620e1813"},{"problem":73,"code":"(fn [board]\n  (let\n   [array-check (fn [row] (if (= (first row) (second row) (last row)) (first row) :e))\n    columns (apply mapv vector board)\n    columns-and-rows (conj board (first columns) (second columns) (last columns))\n    all-lines (conj columns-and-rows [(first (first board))(second (second board))(last (last board))] [(first (last board))(second (second board))(last (first board))])\n    full-results (reduce #(let [row-result (array-check %2)] (if (= row-result :e) %1 row-result)) :e all-lines)]\n   (if (= full-results :e)\n     nil\n     full-results)))","user":"574eb3b1e4b02ea114799247"},{"code":"(fn [v]\r\n  (let [s (conj (into v (apply map vector v)) [((v 0) 0) ((v 1) 1) ((v 2) 2)] [((v 0) 2) ((v 1) 1) ((v 2) 0)])]\r\n    (cond\r\n      (some #(= % [:x :x :x]) s) :x\r\n      (some #(= % [:o :o :o]) s) :o\r\n      :else nil)))","problem":73,"user":"4ecbb249535df97575fdabdf"},{"problem":73,"code":"(fn [vecs-vec]\n  (letfn [(col-won? [player col-start game-vec]\n            (apply\n              (partial = player)\n              (for [x (range col-start 9 3)] (nth game-vec x))))\n          (row-won? [player row-start game-vec]\n            (apply\n              (partial = player)\n              (for [x (nth (partition 3 game-vec) row-start)] x)))\n          (diag-won? [player dir game-vec]\n            (let [spots (cond\n                          (= dir \"left->right\") [0 4 8]\n                          :else [2 4 6])]\n              (apply\n                (partial = player)\n                (for [x spots] (nth game-vec x)))))]\n    (let [g-vec (flatten vecs-vec)\n          x-cols-won (or (col-won? :x 0 g-vec)\n                         (col-won? :x 1 g-vec)\n                         (col-won? :x 2 g-vec))\n          o-cols-won (or (col-won? :o 0 g-vec)\n                         (col-won? :o 1 g-vec)\n                         (col-won? :o 2 g-vec))\n          x-rows-won (or (row-won? :x 0 g-vec)\n                         (row-won? :x 1 g-vec)\n                         (row-won? :x 2 g-vec))\n          o-rows-won (or (row-won? :o 0 g-vec)\n                         (row-won? :o 1 g-vec)\n                         (row-won? :o 2 g-vec))\n          x-diag-won (or (diag-won? :x \"left->right\" g-vec)\n                         (diag-won? :x \"right->left\" g-vec))\n          o-diag-won (or (diag-won? :o \"left->right\" g-vec)\n                         (diag-won? :o \"right->left\" g-vec))]\n      (if (or x-cols-won x-rows-won x-diag-won)\n        :x\n        (if (or o-cols-won o-rows-won o-diag-won)\n          :o\n          nil)))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn [b] \r\n (let [x #(map get b %)]\r\n (->> `(~@b ~@(apply map list b) ~(x [0 1 2]) ~(x [2 1 0]))\r\n      (filter #(and (not= :e (last %)) (apply = %)))\r\n      first first)))","problem":73,"user":"4db03279838c48654951d9bc"},{"code":"#(let [\n  a1 (first %)\n  a2 (second %)\n  a3 (last %)\n  vecs \n  (conj '()\n    a1\n    a2\n    a3 \n    (vec (map first %))\n    (vec (map second %))\n    (vec (map last %)) \n    [(first a1)(second a2)(last a3)]\n    [(last a1)(second a2)(first a3)]\n  )\n  xs [:x :x :x]\n  os [:o :o :o]]\n  (if (some (fn [r] (= xs r)) vecs) :x \n    (if (some (fn [r] (= os r)) vecs) :o )\n  )\n)","problem":73,"user":"4f8ea1f7e4b0d4e659cdde69"},{"code":"(fn\n  [game]\n  (let\n    [line (fn [game]\n            (last (filter #(not= % :e)\n                          (sort\n                            (flatten (filter #(= (count %) 1)\n                                             (map #(distinct %) game)))))))\n     diag (fn [game]\n            (let [get-l_r-diag (fn [x] (map #(nth (nth x %) %) (range (count x))))\n                  l_r (get-l_r-diag game)\n                  r_l (get-l_r-diag (map reverse game))]\n              (cond\n                (or (every? #(= % :x) l_r) (every? #(= % :x) r_l)) :x\n                (or (every? #(= % :o) l_r) (every? #(= % :o) r_l)) :o\n                :else nil)))]\n    (first (distinct (remove nil? [(line game) (line (apply map list game)) (diag game)])))))","problem":73,"user":"50d8de3fe4b01f0871336e72"},{"problem":73,"code":"(fn [m]\n  (let [t (apply mapv vector m)\n        d1 [(first (first m)) (second (second m)) (last (last m))]\n        d2 [(last (first m)) (second (second m)) (first (last m))]]\n    (cond\n     (and (not= (first (first m)) :e) (apply = (first m))) (first (first m))\n     (and (not= (first (second m)) :e) (apply = (second m))) (first (second m))\n     (and (not= (first (last m)) :e) (apply = (last m))) (first (last m))\n     \n     (and (not= (first (first t)) :e) (apply = (first t))) (first (first t))\n     (and (not= (first (second t)) :e) (apply = (second t))) (first (second t))\n     (and (not= (first (last t)) :e) (apply = (last t))) (first (last t))\n     \n     (and (not= (first d1) :e) (apply = d1)) (first d1)\n     (and (not= (first d2) :e) (apply = d2)) (first d2)\n     )))","user":"59663e77e4b069c0a1a1979f"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [flatted  (reduce concat board),\n        find-win #(when (apply = %) (first %)),\n        pick     #(list (nth flatted %1) (nth flatted %2) (nth flatted %3)),\n        line-pos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]],\n        wins     (map #(find-win (apply pick %)) line-pos)]\n    (first (filter #(and % (not (= :e %))) wins))))\n\n;(fn [] (map #(map % status) '(first second (fn [s] (nth s 2)))))","user":"567e418fe4b0feffd0d18eb1"},{"problem":73,"code":"(fn [board]\n  (let [board-str (clojure.string/replace (apply str (apply concat board)) \":\" \"\")\n        win-x [#\"xxx......\" #\"...xxx...\" #\"......xxx\" #\"x..x..x..\" #\".x..x..x.\" #\"..x..x..x\" #\"x...x...x\" #\"..x.x.x..\"]\n        win-o [#\"ooo......\" #\"...ooo...\" #\"......ooo\" #\"o..o..o..\" #\".o..o..o.\" #\"..o..o..o\" #\"o...o...o\" #\"..o.o.o..\"]]\n    (cond\n      (not-every? nil? (map #(re-matches % board-str) win-x)) :x\n      (not-every? nil? (map #(re-matches % board-str) win-o)) :o\n      :else nil)))","user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn\n  [b]\n  (first (flatten\n           (for [x (range (count b)) y (range (count (b 0)))]\n             (filter #(not (= :e %)) \n                     (map (fn [ls]\n                            (reduce (fn [o l] (if (= o (get-in b l :e)) o :e))\n                                    (get-in b [x y] :e)\n                                    ls))\n                          (for [dx [-1 0 1] dy [-1 0 1] :when (or (not= 0 dx) (not= 0 dy))]\n                            [[(+ x dx) (+ y dy)] [(+ x (* 2 dx)) (+ y (* 2 dy))]])))\n             ))))","problem":73,"user":"50ebd63ce4b04edc3377703c"},{"code":"(fn tictac [g]\n  (letfn [(won? [player]\n    (reduce #(or (every? #{player} %2) %) false \n      (concat g\n        [[((get g 0) 0) ((get g 1) 1) ((get g 2) 2)]]\n        [[((get g 0) 2) ((get g 1) 1) ((get g 2) 0)]]\n        (for [i (range 3)]\n          (vec (map #(get % i) g))))))]\n    (cond\n      (won? :x) :x\n      (won? :o) :o)))","problem":73,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":73,"code":"(fn [board]\n  (let [i [0 1 2]\n        ks (vector (map #(vector % 0) i)\n                   (map #(vector % 1) i)\n                   (map #(vector % 2) i)\n                   (map #(vector 0 %) i)\n                   (map #(vector 1 %) i)\n                   (map #(vector 2 %) i)\n                   (map vector i i)\n                   (map vector i (reverse i)))\n        cells (fn [w]\n                (some (fn [x]\n                        (every? #(= w (get-in board %)) x))\n                      ks))]\n    (cond\n     (cells :x) :x\n     (cells :o) :o)))","user":"58b989dbe4b0888cdc949ccd"},{"problem":73,"code":"(fn [r]\n  (let [[[d11 _ d23] [_ d12 _] [d21 _ d13]] r]\n    (->> (concat [[d11 d12 d13] [d21 d12 d23]] r (apply (partial map vector) r)) (some #(if (and (apply = %) (or (= (first %) :x) (= (first %) :o))) (first %) nil)))))","user":"565a3e25e4b068f2fe63dbfb"},{"problem":73,"code":"(fn [b]\n  (let [w #(case % [:x :x :x] :x\n                   [:o :o :o] :o nil)\n        r (apply map vector b)\n        h [[((b 0) 0) ((b 1) 1) ((b 2) 2)]\n           [((b 2) 0) ((b 1) 1) ((b 0) 2)]]]\n    (some identity (mapcat #(map w %) [b r h]))))","user":"527ba29de4b03e8d9a4a7594"},{"problem":73,"code":"(fn [board]\n  (let [all-same (fn [[p1 p2 p3]] (and (= p1 p2 p3) (not= p1 :e) p1))\n        all-same-row (fn [board] (some all-same board))\n        all-same-col (fn [board] (some all-same (apply map vector board)))\n        all-same-diag (fn [board]\n                        (let [joint-board (apply concat board)\n                              size (count (first board))]\n                          (or\n                            (all-same (map first (partition-all (inc size) joint-board)))\n                            (all-same (map first (partition-all (dec size) (drop (dec size) joint-board))))\n                            nil)))]\n    (or\n      (all-same-row board)\n      (all-same-col board)\n      (all-same-diag board))))","user":"53a83c74e4b047364c044426"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (let [straight-line-win?  (fn [r] (when (and (every? #(not= % :e) r)\n                                               (= 1 (count (distinct r))))\n                                      (first r)))\n        transposed-board (apply mapv vector board)\n        horizontal-line-win-rows (remove nil? (map straight-line-win? board))\n        vertical-line-win-rows (remove nil? (map straight-line-win? transposed-board))\n        diagonal-line-win-rows (let [diagonal-idxes [[0 1 2] [2 1 0]]\n                                     diagonal-rows (map #(map (fn [r idx]\n                                                                (nth r idx))\n                                                              board\n                                                              %)\n                                                          diagonal-idxes)]\n                                 (remove nil? (map straight-line-win? diagonal-rows)))\n\n        win-rows (concat horizontal-line-win-rows\n                         vertical-line-win-rows\n                         diagonal-line-win-rows)]\n    (when-not (empty? win-rows)\n      (first win-rows))))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"problem":73,"code":"(fn an\n  [rows]\n  (let [cols (apply map vector rows)\n        diag1 (map #(get-in rows [% %]) [0 1 2])\n        diag2 (map #(get-in rows [% (- 2 %)]) [0 1 2])\n        positions (concat (apply conj rows cols) [diag1 diag2])]\n  \t(if-let [winning (filter (fn [[a b c]] \n                    \t(and (not= a :e) (= a b c)))\n            \t\t\tpositions)]\t\n      (ffirst winning))\n  )\n)","user":"59ac559ee4b00adcf69795d2"},{"problem":73,"code":"(fn winner? [board]\n  (letfn [(all=? [c] (if (apply = c) (first c) false))\n          (diag [mtx] (for [x (range (count mtx))]\n                        (get-in mtx [x x])))]\n    (let [tpd (apply mapv vector board) ;transposed\n        h (some all=? board)\n        v (some all=? tpd)\n        dr (all=? (diag board))\n        dd (all=? (diag (mapv (comp vec reverse) tpd)))]\n    (some #{:x :o} [h v dr dd]))))","user":"5a527beee4b05d388ecb6bfe"},{"problem":73,"code":"#(some \n  (fn [row] \n    (#{:x :o} (reduce (fn [a b] (when (= a b) a)) row)))\n  (concat % (apply map vector %)\n          [[((% 0) 0) ((% 1) 1) ((% 2) 2)]\n           [((% 0) 2) ((% 1) 1) ((% 2) 0)]]))","user":"4fad9da0e4b081705acca23c"},{"problem":73,"code":"(fn analyze-tic-tac-toe [[row1 row2 row3 :as rows]]\n  (let [keyword-won? (fn [k] (or (some #(apply = (cons k %)) rows)\n                                 (some #(apply = (cons k (map % rows))) [first second last])\n                                 (= k (first row1) (second row2) (last row3))\n                                 (= k (first row3) (second row2) (last row1))))]\n    (cond\n     (keyword-won? :x) :x\n     (keyword-won? :o) :o\n     :else nil)))","user":"57a9e274e4b0b8559636fc5d"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (letfn [(win? [p]\n                (or (and (= p a) (= p b) (= p c))\n                    (and (= p d) (= p e) (= p f))\n                    (and (= p g) (= p h) (= p i))\n                    (and (= p a) (= p d) (= p g))\n                    (and (= p b) (= p e) (= p h))\n                    (and (= p c) (= p f) (= p i))\n                    (and (= p a) (= p e) (= p i))\n                    (and (= p g) (= p e) (= p c))))]\n    (cond\n     (win? :x) :x\n     (win? :o) :o\n     :else nil)))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [board]\n  (let\n    [rows\t \t\tboard\n     columns \t\t(apply map vector rows)\n     left-diagonal\t(map nth rows [0 1 2])\n     right-diagonal\t(map nth rows [2 1 0])\n     lines (concat rows columns [left-diagonal right-diagonal])]\n    (cond\n     (some (partial = [:x :x :x]) lines) :x\n     (some (partial = [:o :o :o]) lines) :o\n     true nil)))","problem":73,"user":"52618ea3e4b03e8d9a4a7064"},{"problem":73,"code":"(fn [x] (let [t (apply mapv vector x)\n              r (vec (map (comp (partial into []) reverse) x))\n              d #(map (fn [a b] (get a b)) % (take (count (get % 0)) (range)))\n              f (fn [z] (map (partial every? #(= % z))\n                             (mapcat identity\n                                     [x,\n                                      t,\n                         \t  \t\t  [(d x), (d r)]])))]\n          (cond\n           (some true? (flatten (f :o))) :o\n           (some true? (flatten (f :x))) :x\n           :else nil)))","user":"57ec3d29e4b0bfb2137f5b77"},{"problem":73,"code":"(fn __ [board]\n  (let [t (fn [[[a b c]\n                [d e f]\n                [g h i]] v] \n            (or (= v a b c)\n                (= v d e f)\n                (= v g h i)\n                (= v a d g)\n                (= v b e h)\n                (= v c f i)\n                (= v a e i)\n                (= v c e g)))]\n    (cond (t board :x) :x\n          (t board :o) :o\n          :else nil)))","user":"5475d755e4b0c51c1f4d72a0"},{"code":"(fn check [board]\n  (letfn\n      [(left-diagonal? [player board]\n         (every? #(= player %) \n                 [(get-in board [0 0])\n                  (get-in board [1 1])\n                  (get-in board [2 2])]))\n       \n       (right-diagonal? [player board]\n         (every? #(= player %) \n                 [(get-in board [0 2])\n                  (get-in board [1 1])\n                  (get-in board [2 0])]))\n       \n       (diagonal? [player board]\n         (or (left-diagonal? player board) (right-diagonal? player board)))\n       \n       (horizontal? [player board]\n         (some true? (map #(every? (fn [piece] (= player piece)) %) board)))\n       \n       (vertical? [player board]\n         (some true? (for [a (range 3)] (every? #(= % player) [(get-in board [0 a]) \n                                                              (get-in board [1 a]) \n                                                              (get-in board [2 a])]))))\n\n       (won? [player board]\n         (cond\n          (diagonal? player board) true\n          (vertical? player board) true\n          (horizontal? player board) true))]\n    \n    (cond\n     (won? :x board) :x\n     (won? :o board) :o)))","problem":73,"user":"52382dd6e4b0fae3832e99f1"},{"problem":73,"code":"(fn [board]\n  (let [vec-board (vec (flatten board))\n        players [:x :o :e]\n        win-results [0 4 8 0 3 6 1 4 7 2 5 8 2 4 6 0 1 2 3 4 5 6 7 8]\n        ]\n    (loop [[x y z & rest] win-results _ (println rest)]\n      (if (nil? x)\n        nil\n        (if (= (nth vec-board x) (nth vec-board y) (nth vec-board z) :x)\n          :x\n          (if (= (nth vec-board x) (nth vec-board y) (nth vec-board z) :o)\n            :o\n            (if (= (nth vec-board x) (nth vec-board y) (nth vec-board z) :e)\n              nil\n              (recur rest \"nothing\"))))))))","user":"55a0d79fe4b0acc240e31502"},{"problem":73,"code":"(fn tictac\n\n  ([x]\n\n   (tictac (replace {:e nil} (first x)) (replace {:e nil} (second x)) (replace {:e nil} (last x))))\n\n  ([x y z]\n\n   (if (= (first x) (first y) (first z))\n\n     (first x)\n\n     (if (= (second x) (second y) (second z))\n\n       (second x)\n\n       (if (= (last x) (last y) (last z))\n\n         (last x)\n\n         (if (= (count(set x)) 1)\n\n           (first x)\n\n           (if (= (count(set y)) 1)\n\n             (first y)\n\n             (if (= (count(set z)) 1)\n\n               (first z)\n\n               (if (= (first x) (second y) (last z))\n\n                 (first x)\n\n                 (if (= (first z) (second y) (last x))\n\n                   (first z)\n\n                   nil))))))))))","user":"586b6a0ae4b01531a375e957"},{"problem":73,"code":"(fn p73 [b]\n    (->> b\n      ;; extract sequence of triples of rows, columns and diagonals\n      (concat\n        (map (partial get b) [0 1 2]) ;; rows\n        (apply map vector b) ;; col\n        (vector (map get b [0 1 2])) ;; diagonal\n        (vector (map get b [2 1 0]))) ;; diagonal\n      ;; only keep triples of a single type\n      (map distinct)\n      (filter #(= 1 (count %)))\n      (filter #(not= '(:e) %))\n      (ffirst)))","user":"4fc4eb1ee4b081705acca354"},{"problem":73,"code":"(fn [[f s l]]\n  (let [diag-ln #(vector\n                  (first %)\n                  (second %2)\n                  (last %3))\n        analyse-ln #(cond (= % [:x :x :x])\n                           :x\n                          (= % [:o :o :o])\n                           :o\n                          :else nil)\n        lns (concat (vector\n                     (diag-ln l s f)\n                     (diag-ln f s l)\n                     f s l)\n                  (map vector f s l))]\n  (last (sort (map analyse-ln lns)))\n   ))","user":"5835cb06e4b089d5ab817cea"},{"problem":73,"code":"(fn [b]\n   (let\n     [rs b\n      cs (apply (partial mapv vector) b)\n      dgf (fn [m] (reduce #(conj % (%2 (count %))) [] m))\n      dgs [(dgf b) (dgf (reverse b))]\n      wins (fn [k] (some #(when (= % (repeat (count (b 0)) k)) k) \n                     (concat rs cs dgs)))]\n     (some wins [:x :o])))","user":"5cdfe2aee4b0a17bb84e2b04"},{"code":"(fn [x]\n   (first\n    (disj\n     (set\n      (map\n       first\n       (filter\n        (partial apply =)\n        (concat\n         x\n         (apply mapv vector x)\n         (list (map #(get-in x [%1 %1]) (range 3)))\n         (list (map #(get-in x [(- 2 %1) %1]) (range 3))))\n        ))\n      )\n     :e)))","problem":73,"user":"52586d24e4b0cb4875a45cb0"},{"problem":73,"code":"(fn [board]\n(let [player-in (fn [player x y] (= (get-in board [x y]) player))\n      player-in-line (fn [player x] (and (player-in player x 0)\n                                         (player-in player x 1)\n                                         (player-in player x 2)))\n      player-in-coll (fn [player y] (and (player-in player 0 y)\n                                         (player-in player 1 y)\n                                         (player-in player 2 y)))\n      player-in-slash (fn [player] (and (player-in player 0 0)\n                                        (player-in player 1 1)\n                                        (player-in player 2 2)))\n      player-in-backslash (fn [player] (and (player-in player 0 2)\n                                            (player-in player 1 1)\n                                            (player-in player 2 0)))\n      winner (fn [player] (if (or (player-in-slash player)\n                                  (player-in-backslash player)\n                                  (player-in-line player 0)\n                                  (player-in-line player 1)\n                                  (player-in-line player 2)\n                                  (player-in-coll player 0)\n                                  (player-in-coll player 1)\n                                  (player-in-coll player 2))\n                            player\n                            nil))]\n  (or (winner :x)\n      (winner :o))))","user":"5989e080e4b021a7a535fed6"},{"problem":73,"code":"(fn [coll]\n   (let [[[x1 x2 x3] [y1 y2 y3] [z1 z2 z3]] coll\n     result (cond\n       (= (count (group-by identity [x1 x2 x3])) 1) x1\n       (= (count (group-by identity [y1 y2 y3])) 1) y1\n       (= (count (group-by identity [z1 z2 z3])) 1) z1\n       (= (count (group-by identity [x1 y1 z1])) 1) x1\n       (= (count (group-by identity [x2 y2 z2])) 1) x2\n       (= (count (group-by identity [x3 y3 z3])) 1) x3\n       (= (count (group-by identity [x1 y2 z3])) 1) x1\n       (= (count (group-by identity [x3 y2 z1])) 1) x3\n       :else nil\n       )\n         ]\n     (if (not= result :e) result))\n   )","user":"5857d27de4b0f14aab7c8710"},{"code":"(let [lookup (fn [b [x y]] (nth (nth b y) x))\n      winners (concat\n                (map (fn [x] (map #(vector x %) (range 3))) (range 3))\n                (map (fn [y] (map #(vector % y) (range 3))) (range 3))\n                [(map #(vector % %) (range 3)) (map #(vector % (- 2 %)) (range 3))])]\n  (println winners)\n  (fn [board]\n    (loop [w winners]\n      (if (empty? w)\n        nil\n        (let [s (set (map (partial lookup board) (first w)))]\n          (if (= 1 (count s))\n            (if (= :e (first s)) nil (first s))\n            (recur (rest w))))))))","problem":73,"user":"4dd9d299535d2dad7130b5dd"},{"problem":73,"code":"(fn [[[a1 a2 a3][b1 b2 b3][c1 c2 c3]]]\n  (let [win? (fn [[a & coll]]\n                (if (every? #(and (= a %) (not= a :e)) coll) a))]\n    (or (win? [a1 a2 a3]) (win? [b1 b2 b3]) (win? [c1 c2 c3])\n        (win? [a1 b1 c1]) (win? [a2 b2 c2]) (win? [a3 b3 c3])\n        (win? [a1 b2 c3]) (win? [a3 b2 c1]))))","user":"51e38568e4b0c611d6113e43"},{"code":"(fn p73 [horizontals]\r\n  (let [verticals (map (fn [col]\r\n\t\t\t\t\t\t\t(map #(nth % col) horizontals)) (range 3))\r\n\t\t  diagonals (let [[r1 r2 r3] horizontals]\r\n\t\t  \t\t\t\t[[(nth r1 0) (nth r2 1) (nth r3 2)]\r\n\t\t  \t\t\t\t [(nth r1 2) (nth r2 1) (nth r3 0)]])\r\n\t\t  testables (concat horizontals verticals diagonals)]\r\n\t\t(->> (map distinct testables)\r\n\t\t\t (filter #(= (count %) 1))\r\n\t\t\t (flatten)\r\n\t\t\t (filter #(not (= % :e)))\r\n\t\t\t (first))))","problem":73,"user":"4f7f0827e4b06e829148e1d5"},{"problem":73,"code":"(fn [board]\n  (letfn [(win? [coll] \n            (let [coll (distinct coll)]\n              (and (= 1 (count coll))\n                   (not= :e (first coll))\n                   (first coll))))]\n    (some identity\n      (apply list\n             (win? (for [i (range 3)] (get-in board [i i])))\n             (win? (for [i (range 3)] (get-in board [i (- 2 i)])))\n             (flatten (for [i (range 3)] [(win? (map #(nth % i) board)) (win? (nth board i))]))))))","user":"562cb7cfe4b0a45d2ff83009"},{"code":"(fn [rows]\n\n    (letfn [\n       (ex [s] (if (seq (rest s)) nil (first s)))\n       (e [x] (if (= x :e) nil x))\n       (winner [v]\n         (ex (into #{} (map e v))))\n       \n       (fns []\n         [\n          (partial map first)\n          (partial map second)\n          (partial map #(get % 2))\n          (partial map-indexed #(get %2 %))\n          (partial map-indexed #(get %2 (- 2 %)))\n         ]\n       )\n\n       (lines [rows]\n          (into rows\n            ((apply juxt (fns)) rows)))\n     ]\n\n     (some identity (map winner (lines rows)))\n\n    ))","problem":73,"user":"4ff3df0fe4b0678c553fc355"},{"problem":73,"code":"(fn ticTacToe [board]\n  (letfn [(row [i] (board i))\n          (col [i] (mapv #(nth % i) board))\n          (lr [] [(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])])\n          (rl [] [(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])])\n          (elemWin [elem]\n            (or\n             (every? #(= elem %) (row 0))\n             (every? #(= elem %) (row 1))\n             (every? #(= elem %) (row 2))\n             (every? #(= elem %) (col 0))\n             (every? #(= elem %) (col 1))\n             (every? #(= elem %) (col 2))\n             (every? #(= elem %) (lr))\n             (every? #(= elem %) (rl))))]\n    (cond\n      (elemWin :x) :x\n      (elemWin :o) :o      :else nil)))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn check-tic-tac-toe [board]\n  (let [not-empty #(not= :e %)\n        winning-line (fn [line] (and (not-empty (first line)) (apply = line)))\n        get-board (fn [down across] ((board down) across))\n        get-row (fn [down across] [(get-board down across)\n                                   (get-board down (+ 1 across))\n                                   (get-board down (+ 2 across))])\n        get-col (fn [down across] [(get-board down across)\n                                   (get-board (+ 1 down) across)\n                                   (get-board (+ 2 down) across)])\n        get-se-diag (fn [] [(get-board 0 0)\n                            (get-board 1 1)\n                            (get-board 2 2)])\n        get-sw-diag (fn [] [(get-board 0 2)\n                            (get-board 1 1)\n                            (get-board 2 0)])]\n    (cond (winning-line (get-se-diag)) (get-board 0 0)\n          (winning-line (get-sw-diag)) (get-board 0 2)\n          (winning-line (get-row 0 0)) (get-board 0 0)\n          (winning-line (get-row 1 0)) (get-board 1 0)\n          (winning-line (get-row 2 0)) (get-board 2 0)\n          (winning-line (get-col 0 0)) (get-board 0 0)\n          (winning-line (get-col 0 1)) (get-board 0 1)\n          (winning-line (get-col 0 2)) (get-board 0 2)\n          :else nil)))","problem":73,"user":"5310e7aee4b08068f379ecdc"},{"problem":73,"code":"(fn [b]\n    (let [p   (fn [[x y]] ((b x) y))\n          all (concat b  \n                      (apply mapv vector b) \n                      [(map p [[0 2] [1 1] [2 0]])]\n                      [(map p [[0 0] [1 1] [2 2]])])\n          f   (fn [s] (some true? (map (fn [c] (every? #(= % s) c)) all)))]\n      (cond (f :x) :x\n            (f :o) :o\n            :else nil)))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":73,"code":"(fn tictac [coll]\n    (letfn [(win [v] (some #(= % [v v v]) (concat coll (apply map vector coll) [(mapv get coll (range 3)) (mapv get coll (range 2 -1 -1))])))]\n      (cond \n        (win :x) :x\n        (win :o) :o\n        :else nil)))","user":"5b857411e4b047b03b2037ce"},{"problem":73,"code":"(fn [board]\n  (let [check (fn [l]\n                (let [x (if (= (first l) (second l) (last l))\n                          (first l)\n                          nil)]\n                  (if (= x :e)\n                    nil\n                    x)))]\n    (or (check (first board))\n        (check (second board))\n        (check (last board))\n        (check (for [l board] (first l)))\n        (check (for [l board] (second l)))\n        (check (for [l board] (last l)))\n        (check [(first (first board))\n                (second (second board))\n                (last (last board))])\n        (check [(last (first board))\n                (second (second board))\n                (first (last board))]))))","user":"5cbb0436e4b026601754b9cc"},{"code":"(fn [rows]\n  (let [cols (apply map vector rows)\n        diags [[(nth (nth rows 0) 0) (nth (nth rows 1) 1) (nth (nth rows 2) 2)]\n               [(nth (nth rows 0) 2) (nth (nth rows 1) 1) (nth (nth rows 2) 0)]]\n        lines (concat rows cols diags)\n        winner (fn [[a b c]]\n                 (cond\n                   (= :x a b c) :x\n                   (= :o a b c) :o))]\n    (reduce #(if (nil? %) (winner %2) %) nil lines)))","problem":73,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn [vs]\n  (let \n [ diag (fn  [v] (list (first (first v)) (second (second v)) (nth (nth v 2) 2)))\n   rdiag (fn  [v] (list (first (nth v 2)) (second (second v)) (nth (first v) 2)))\n   vert (fn [v] (apply map list v))\n   test-winner (fn [vs c] (let [cs (take 3 (repeat c))] \n                           (or (some #(= cs %) vs)\n                               (some #(= cs %) (vert vs))\n                               (= cs (diag vs))   \n                               (= cs (rdiag vs)))))\n\n   do-it (fn  [vs] (for [c [:o :x] :when (test-winner vs c)] c))]\n  (first (do-it vs)))\n  \n  )","problem":73,"user":"52fa250ee4b047fd55836ff3"},{"code":"(fn [rows]\n    (let [size (count rows)\n          cols (apply (partial map #(vec %&)) rows)\n          diag1 (reduce \n               \t#(conj %1 ((rows %2) %2))\n               \t[]\n                (range size))\n          diag2 (reduce \n    \t\t\t#(conj %1 ((rows %2) (- size %2 1)))\n               \t[]\n                (range size))]\n      (->> (concat rows cols [diag1 diag2])\n           (map #(if (apply = %) (first %) nil))\n           ((fn [vs]\n             (cond\n              (some #(= :x %) vs) :x\n              (some #(= :o %) vs) :o\n              :else nil))))))","problem":73,"user":"5316cdcae4b08068f379ed4b"},{"code":"(fn [b]\n    (let [wins? (fn [p]\n                  (let [row (fn [n]\n                              (b n))\n                        col (fn [n]\n                              [((b 0) n) ((b 1) n) ((b 2) n)])\n                        diag (fn [n]\n                               [((b 0) n) ((b 1) 1) ((b 2) (- 2 n))])\n                        win [p p p]]\n                    (or (= (row 0) win)\n                        (= (row 1) win)\n                        (= (row 2) win)\n                        (= (col 0) win)\n                        (= (col 1) win)\n                        (= (col 2) win)\n                        (= (diag 0) win)\n                        (= (diag 2) win))))]\n    \n      (cond (wins? :x) :x\n            (wins? :o) :o\n            :else nil)))","problem":73,"user":"4f404dcee4b0e243712b1fb0"},{"problem":73,"code":"(fn [xs]\n  (letfn [(build [ys]\n                 (letfn [(g [a b] (get-in ys [a b]))]  \n                    (-> (conj ys [(g 0 0) (g 1 0) (g 2 0)])\n                      (conj [(g 0 1) (g 1 1) (g 2 1)])\n                      (conj [(g 0 2) (g 1 2) (g 2 2)])\n                      (conj [(g 0 0) (g 1 1) (g 2 2)])\n                      (conj [(g 0 2) (g 1 1) (g 2 0)]))))]\n    (cond (not-empty (filter #(every? (fn [v] (= :x v)) %) (build xs))) :x\n          (not-empty (filter #(every? (fn [v] (= :o v)) %) (build xs))) :o\n          :else nil)))","user":"53e9a15be4b036ad0777e4ae"},{"code":"(fn [board]\n  (let [transpose (apply mapv vector board)\n        diagonals (mapv #(mapv nth board %) [[0 1 2] [2 1 0]])\n        win-seq #(first\n                  (get #{[:x :x :x]\n                         [:o :o :o]}\n                       % [nil]))]\n     (some win-seq\n        (concat\n         board\n         transpose\n         diagonals))))","problem":73,"user":"510db6cde4b078ea71921145"},{"code":"(fn [m]\n  (first\n    (filter\n      (fn [p]\n        (->> (let [idx [0 1 2]]\n                (concat m     \n                  (map (fn [i] (map #(% i) m)) idx)\n                  (vector (map #((m %) %) idx)) \n                  (vector (map #((m (- 2 %)) %) idx))))\n             (map (fn [row] (count (filter #(= p %) row))))\n             (filter #(= % 3))\n             seq))\n      [:x :o])))","problem":73,"user":"4e2b1d48535deb9a81d77f03"},{"problem":73,"code":"(fn [board]\n  (or\n   (reduce #(or %1 %2)\n           nil\n           (map #(cond (= % [:x :x :x]) :x\n                       (= % [:o :o :o]) :o\n                       :else nil)\n                board))\n   (reduce #(or %1 %2)\n           nil\n           (map #(cond (= % [:x :x :x]) :x\n                       (= % [:o :o :o]) :o\n                       :else nil)\n                (apply map vector board)))\n   (reduce #(or %1 %2)\n           nil\n           (map #(cond (= % [:x :x :x]) :x\n                       (= % [:o :o :o]) :o\n                       :else nil)\n                [(map nth board [0 1 2])\n                 (map nth board [ 2 1 0])]))\n ))","user":"57bfffc7e4b05aa3c4741c8a"},{"problem":73,"code":"(fn [t] (let [line (fn [l] (let [d (distinct l)] (if (= (count d) 1) (first d) :e)))\n\t\t\t  c (fn [x y] (fn [s] (comp (nth (nth s x) y))))\n\t\t\t  diags (fn [x] [((juxt (c 0 0) (c 1 1) (c 2 2)) x)\n\t\t\t\t\t\t\t ((juxt (c 2 0) (c 1 1) (c 0 2)) x)])]\n\t(first (filter #(not (= % :e)) (map line (concat t (apply mapv vector t) (diags t)))))))","user":"53e19461e4b0d874e779ae59"},{"problem":73,"code":"(fn [x]\n    (let[y (#(partition 3 3 (apply interleave %)) x)]\n      (first\n      (remove #(= % :e)\n      (map first\n      (filter #(apply = %)  \n      (conj \n        (concat x y) \n        (flatten (partition 1 4 (flatten x))) \n        (flatten (rest(reverse (rest( partition 1 2 (flatten y)))))))\n        ))))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn [m]\n  (let [analyze (fn [s]\n    (if (or (and (= s ((m 0) 0)) (= s ((m 0) 1)) (= s ((m 0) 2)))\n            (and (= s ((m 1) 0)) (= s ((m 1) 1)) (= s ((m 1) 2)))\n            (and (= s ((m 2) 0)) (= s ((m 2) 1)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 0)) (= s ((m 1) 0)) (= s ((m 2) 0)))\n            (and (= s ((m 0) 1)) (= s ((m 1) 1)) (= s ((m 2) 1)))\n            (and (= s ((m 0) 2)) (= s ((m 1) 2)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 0)) (= s ((m 1) 1)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 2)) (= s ((m 1) 1)) (= s ((m 2) 0))))\n          s\n        nil))]\n  (or (analyze :o) (analyze :x))))","problem":73,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [field]\n   (let [horiz (map distinct field)\n         vert (map distinct\n                   (map (fn [n] (map #(nth % n) field))\n                        (range 3)))\n         oth (list (distinct (map #(nth (nth field %) %) (range 3)))\n                   (distinct (map #(nth (nth field (- 2 %)) %) (range 3))))\n         all (concat horiz vert oth)]\n     (first (first (filter #(and (= (count %) 1)\n                            (not (= '(:e) %)))\n                   all)))))","problem":73,"user":"4eb02674535d7eef30807338"},{"code":"(fn [b]\n    (letfn [(lookup [n v]\n              (let [x (quot n 3)\n                    y (rem n 3)]\n                (nth (nth v x) y)))\n            (check-row [board row]\n              (let [rslt (map #(lookup % board) row)]\n                (if (apply = rslt)\n                  (first rslt)\n                  nil)))]\n      (let [rows [[0 1 2] [3 4 5] [6 7 8]\n                  [0 3 6] [1 4 7] [2 5 8]\n                  [0 4 8] [2 4 6]]\n            out (map #(check-row b %) rows)]\n        (cond\n          (some #{:x} out) :x\n          (some #{:o} out) :o\n          :else nil))))","problem":73,"user":"526f9715e4b03e8d9a4a7372"},{"problem":73,"code":"(fn [lss]\n  (let [ls (flatten lss)\n        kvs (map vector [:1 :2 :3 :4 :5 :6 :7 :8 :9] ls)\n        m (reduce #(assoc-in %1 [(first %2)] (last %2)) {} kvs)\n        rows [[:1 :2 :3] [:4 :5 :6] [:7 :8 :9] [:1 :4 :7] [:2 :5 :8] [:3 :6 :9] [:1 :5 :9] [:3 :5 :7]]\n        oxs (map #(map m %) rows)\n        inarow (filter #(= 1 (count %))(map set oxs))]\n    (if (some #(contains? % :x) inarow)\n      :x\n      (if (some #(contains? % :o) inarow)\n        :o\n        nil))))","user":"51e5a627e4b0efabf93c02db"},{"code":"(fn [[x y z]]\n  (let [sq (into [x y z\n                 [(first x) (second y) (last z)]\n                 [(first z) (second y) (last x)]] (map vector x y z))\n        won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n    (first (remove nil? (map won? sq)))))","problem":73,"user":"50705072e4b07bd6ad9b9f27"},{"problem":73,"code":"#(get (clojure.set/map-invert (apply merge-with + (map hash-map (flatten %) [4 3 8 9 5 1 2 7 6]))) 15)","user":"54534c83e4b0e397800069cd"},{"code":"(fn [board]\r\n    (let\r\n      [horizontal (for [a [0 1 2] b [0 1 2]] (vector a b))\r\n       vertical (for [a [0 1 2] b [0 1 2]] (vector b a))\r\n       diagonal [[0 0] [1 1] [2 2] [0 2] [1 1] [2 0]]\r\n       winning-pos (partition 3 (into diagonal (into horizontal vertical)))\r\n       has-won? \r\n        (fn [player]\r\n          (loop [winning-pos winning-pos]\r\n            (if (empty? winning-pos)\r\n              false\r\n              (if (apply\r\n                    =\r\n                    (cons player (reduce #(conj %1 (get-in board %2)) \r\n                                         [] \r\n                                         (first winning-pos))))\r\n                true\r\n                (recur (rest winning-pos))))))]\r\n      (if (has-won? :o)\r\n        :o\r\n        (if (has-won? :x)\r\n          :x\r\n          nil))))","problem":73,"user":"4dd61f98535d2dad7130b5c6"},{"problem":73,"code":"(fn [game]\n  (let [possible-rows [[[0 0] [0 1] [0 2]]\n                       [[1 0] [1 1] [1 2]]\n                       [[2 0] [2 1] [2 2]]\n                       [[0 0] [1 0] [2 0]]\n                       [[0 1] [1 1] [2 1]]\n                       [[0 2] [1 2] [2 2]]\n                       [[0 0] [1 1] [2 2]]\n                       [[0 2] [1 1] [2 0]]]\n        ]\n    (loop [n 0]\n      (if-let [[r0 r1 r2] (get possible-rows n)]\n        (let [p0 (get-in game [(first r0) (second r0)])]\n          (if (and (or (= p0 :x)\n                       (= p0 :o))\n                   (= p0\n                      (get-in game [(first r1) (second r1)])\n                      (get-in game [(first r2) (second r2)])))\n            (get-in game [(first r0) (second r0)])\n            (recur (inc n))))\n        nil))))","user":"5b8baa2ce4b0c0b3ffbd49bd"},{"problem":73,"code":"(fn \n  [d]\n  ( #( if (= :e %) nil %)\n   (first\n     (filter #( or ( = :x %) (= :o %) ) \n       ( filter identity \n        ( map #( when (= 1 (count (set %))) (first %) )\n         ( concat d (apply map vector d) \n          [(map #( (last %) (first %)) (zipmap (range 3) (reverse d)))] \n          [(map #( (last %) (first %)) (zipmap (range 3) d))]))      \n        )))))","user":"54fc7d89e4b07d26eda61d2b"},{"problem":73,"code":"(fn [s]\n  (let [positions (concat (map #(repeat 3 %) (range 3)) [[0 1 2] [2 1 0]])\n        get-line (fn [tr] (map nth s tr))\n        rcd (concat s (map get-line positions))]\n    (some {[:x :x :x] :x [:o :o :o] :o} rcd)))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn [board]\n  (->> (conj (concat (map (fn [i] (map #(get-in board [% i]) [0 1 2])) [0 1 2])\n                     board)\n             [(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])]\n             [(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])])\n       (map #(dissoc (frequencies %) :e))\n      (apply merge-with max)\n       (filter #(= 3 (second %)))\n       (ffirst)))","problem":73,"user":"4e521cef535d302ef430da6d"},{"code":"(fn [[v1 v2 v3 :as s]] \n  (let [ all `[ ~@s ~@(partition 3 (apply interleave s))\n               [~(first v1) ~(second v2) ~(last v3)]\n                    [~(last v1) ~(second v2) ~(first v3)]]]\n\n    (first (first (filter (fn [[i1 i2 i3]] (and (not= i1 :e) (= i1 i2 i3))) all)))))","problem":73,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(fn [x]\n  (->> (concat x (apply (partial map vector) x)\n         (map (fn diag [m] (reduce #(conj %1 (%2 (count %1))) [] m)) [x (reverse x)]))\n    (filter (partial apply =)) (map first) (filter #{:x, :o}) first))","problem":73,"user":"528e64b7e4b0239c8a67aedd"},{"problem":73,"code":"(fn [board]\n  (let\n    [l (count board)\n     all-rows\n     (concat\n       ; horizontal\n       board\n       ; vertical\n       (apply map vector board)\n       ; diagonal 1\n       [(map get board (range l))]\n       ; diagonal 2\n       [(map get board (range (dec l) -1 -1))])\n     ]\n    ((fn [rows]\n       (cond (some #(= (repeat l :x) %) rows) :x\n             (some #(= (repeat l :o) %) rows) :o\n             :default nil))\n      all-rows)))","user":"586bc870e4b01531a375e964"},{"problem":73,"code":"#(if(= (nth (nth % 0) 0) (nth (nth % 1) 0) (nth (nth % 2) 0)) \n   (if(= (nth (nth % 0) 0) :x)\n     :x\n     (if(= (nth (nth % 0) 0) :o)\n       :o\n       nil))\n   \n   (if(= (nth (nth % 0) 1) (nth (nth % 1) 1) (nth (nth % 2) 1)) \n     (if(= (nth (nth % 0) 1) :x)\n       :x\n       (if(= (nth (nth % 0) 1) :o)\n         :o\n         nil))\n     (if(= (nth (nth % 0) 2) (nth (nth % 1) 2) (nth (nth % 2) 2)) \n       (if(= (nth (nth % 0) 2) :x)\n         :x\n         (if(= (nth (nth % 0) 2) :o)\n           :o\n           nil))\n       (if(= (nth (nth % 0) 0) (nth (nth % 0) 1) (nth (nth % 0) 2)) \n         (if(= (nth (nth % 0) 0) :x)\n           :x\n           (if(= (nth (nth % 0) 0) :o)\n             :o\n             nil))\n         (if(= (nth (nth % 1) 0) (nth (nth % 1) 1) (nth (nth % 1) 2)) \n           (if(= (nth (nth % 1) 0) :x)\n             :x\n             (if(= (nth (nth % 1) 0) :o)\n               :o\n               nil))\n           (if(= (nth (nth % 2) 0) (nth (nth % 2) 1) (nth (nth % 2) 2)) \n             (if(= (nth (nth % 2) 0) :x)\n             :x\n               (if(= (nth (nth % 2) 0) :o)\n                 :o\n                 nil))\n             (if(= (nth (nth % 0) 0) (nth (nth % 1) 1) (nth (nth % 2) 2)) \n               (if(= (nth (nth % 0) 0) :x)\n                 :x\n                 (if(= (nth (nth % 0) 0) :o)\n                   :o\n                   nil))\n               (if(= (nth (nth % 0) 2) (nth (nth % 1) 1) (nth (nth % 2) 0)) \n                 (if(= (nth (nth % 1) 1) :x)\n                   :x\n                   (if(= (nth (nth % 1) 1) :o)\n                     :o\n                     nil))))))))))","user":"5654e8ade4b0f9d632dd848e"},{"problem":73,"code":"#(first (reduce-kv \n         (fn [res k v]\n           (if (or\n                (clojure.set/subset? #{0 1 2} v)\n                (clojure.set/subset? #{3 4 5} v)\n                (clojure.set/subset? #{6 7 8} v)\n                (clojure.set/subset? #{0 3 6} v)\n                (clojure.set/subset? #{1 4 7} v)\n                (clojure.set/subset? #{2 5 8} v)\n                (clojure.set/subset? #{0 4 8} v)\n                (clojure.set/subset? #{2 4 6} v)) \n             (conj res k) \n             res)) \n         '()\n         (reduce-kv \n          (fn [m k v]\n            (assoc m k (set (map first v))))\n          {}\n          (dissoc (group-by second (map-indexed list (flatten %))) :e))))","user":"54ad9d76e4b09f271ff37ce6"},{"code":"(let [winner? #{[:x :x :x] [:o :o :o]}\n      mkdiagf (fn [f g]\n                (fn [b] [(f b) ((comp second second) b) (g b)]))\n      hs [first second last] ;; horizontals\n      vs [#(map first %) #(map second %) #(map last %)]\n      ds [(mkdiagf ffirst (comp last last))\n          (mkdiagf (comp last first) (comp first last))]]\n  (fn [board]\n    (loop [fs (concat hs vs ds)]\n      (when-first [f fs]\n        (if-let [s (winner? (f board))]\n          (first s)\n          (recur (next fs)))))))","problem":73,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":73,"code":"(fn [board]\n(letfn [(tl [l]\n          (cond\n            (every? #{:x}\n                    l) :x\n            (every? #{:o}\n                    l) :o))]\n (some identity\n       (map tl \n            (concat\n              board \n              (apply map vector board)\n              [(map #(get-in board [% %2])\n                    (range (count board))\n                    (range (count  board)))\n               (map #(get-in board [% %2])\n                    (reverse (range (count board)))\n                    (range (count  board))) ])))))","user":"55d8eed3e4b0e31453f64ac3"},{"code":"(fn [t]\r\n  (let [[a b c] t\r\n        [d e f] a\r\n        [g h i] b\r\n        [j k l] c\r\n        q    #(if (= 1 (count %)) % false)\r\n        row  (map set t)\r\n        col  (map (comp set list) a b c)\r\n        diag (map set [[d h l] [f h j]])\r\n        res  (first (or (some q row) (some q col) (some q diag)))]\r\n    (if (= :e res) nil res)))","problem":73,"user":"509c03f3e4b085ae113522a8"},{"problem":73,"code":"(fn [board]\n  (let [\n        rows board\n        cols (partition 3 (apply interleave board))\n        diag [(for [i (range 3)] (nth (nth board i) i)) \n              (for [i (range 3)] (nth (nth (reverse board) i) i))]]\n    (first (filter (complement nil?)\n                   (map #(if (and (not-every? #{:e} %) (apply = %)) (first %) nil)\n                        (concat rows cols diag))))))","user":"4fb0ccbfe4b081705acca26e"},{"code":"(fn [game]\n    (letfn [(extract [c] (map nth game c))\n            (won? [s] (cond (= s [:x :x :x]) :x\n                            (= s [:o :o :o]) :o\n                            :else nil))]\n      (->> (concat game (map extract [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]))\n        (filter won?)\n        first first)))","problem":73,"user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn [board] (let\n              [lines [[0 1 2] [3 4 5] [6 7 8] ; horizontal\n                      [0 3 6] [1 4 7] [2 5 8] ; vertical\n                      [0 4 8] [2 4 6]]        ; diagonal\n               flat-board  (flatten board)\n               board-lines (map (fn [x] (map #(nth flat-board %) x)) lines)]\n              (letfn\n                [(win-line? [side] (fn [line] (every? (partial = side) line)))\n                 (winner?   [side] (some (win-line? side) board-lines))]\n                (some #(and (winner? %) %) [:x :o]))))","problem":73,"user":"51307b84e4b08c712d3fae39"},{"problem":73,"code":"(fn foo [xx]\n  (let [x00 ((xx 0) 0) x01 ((xx 0) 1) x02 ((xx 0) 2)\n        x10 ((xx 1) 0) x11 ((xx 1) 1) x12 ((xx 1) 2)\n        x20 ((xx 2) 0) x21 ((xx 2) 1) x22 ((xx 2) 2)]\n    (if (or (= :x x00 x01 x02)\n            (= :x x10 x11 x12)\n            (= :x x20 x21 x22)\n            (= :x x00 x10 x20)\n            (= :x x01 x11 x21)\n            (= :x x02 x12 x22)\n            (= :x x00 x11 x22)\n            (= :x x20 x11 x02))\n      :x\n      (if (or (= :o x00 x01 x02)\n              (= :o x10 x11 x12)\n              (= :o x20 x21 x22)\n              (= :o x00 x10 x20)\n              (= :o x01 x11 x21)\n              (= :o x02 x12 x22)\n              (= :o x00 x11 x22)\n              (= :o x20 x11 x02))\n        :o))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (cond\n   (and (= a b c) (not= a :e)) a\n   (and (= d e f) (not= d :e)) d\n   (and (= g h i) (not= g :e)) g\n   (and (= a d g) (not= a :e)) a\n   (and (= b e h) (not= b :e)) b\n   (and (= c f i) (not= c :e)) c\n   (and (= a e i) (not= a :e)) a\n   (and (= c e g) (not= c :e)) c\n   :else nil))","user":"556a3243e4b09a3098a524de"},{"problem":73,"code":"(fn solve [ttt]\n  (let [h1 first\n        h2 second\n        h3 (comp first next next)\n        v1 (partial mapv h1)\n        v2 (partial mapv h2)\n        v3 (partial mapv h3)\n        d1 #(vector (ffirst %)\n                    (h2 (h2 %))\n                    (h3 (h3 %)))\n        d2 #(vector (h3 (h1 %))\n                    (h2 (h2 %))\n                    (h1 (h3 %)))\n        triple  (->> ((juxt h1 h2 h3 v1 v2 v3 d1 d2) ttt)\n                     (map set)\n                     (filter #(= (count %) 1)))]\n    (cond (some #{#{:o}} triple) :o\n          (some #{#{:x}} triple) :x\n          :else nil)))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":73,"code":"(fn [rows]\n  (let [ cols (apply map vector rows)\n         diag1 (map nth rows [0 1 2])\n         diag2 (map nth rows [2 1 0])\n         all-rows (conj (concat rows cols) diag1 diag2)\n         row-winner (fn [r] (when (and (apply = r) (not= (first r) :e)) (first r)))]\n    (some row-winner all-rows)))","user":"55253217e4b0882d96d091ce"},{"code":"(fn [b]\n  (let [r [0 1 2]\n        p (fn [v h] \n            (let [a (map #(nth (nth b %) %2) v h) f (first a)] \n              (if (and (apply = a) (#{:x :o} f)) f)))\n        r0 [0 0 0]\n        r1 [1 1 1]\n        r2 [2 2 2]]\n        (some (partial apply p) \n          [[r r0] [r r1] [r r2] [r0 r] [r1 r] [r2 r] [r r] [r [2 1 0]]])))","problem":73,"user":"4f6511eee4b07046d9f4ef3a"},{"problem":73,"code":"#(letfn [(getRow [b r] (get b r))\n         (getCol [b c] (for[r b] (get r c)))\n         (getDia [b f s] (loop [rb b i s r []]\n                           (if (seq rb) (recur (rest rb) (f i) (conj r (get (first rb) i))) \n                             r)))\n         (win [v] (let [fv (first v)]\n                    (if (and (apply = v) (not= fv :e)) fv false)))\n         (testRowCol [b f]\n                  (reduce (fn [x y] (if (not= y false) y x)) false (map win (map (partial f b) (range 0 3)))))]\n   (let [rowResult (testRowCol % getRow)]\n     (if (not (false? rowResult)) rowResult\n       (let [colResult (testRowCol % getCol)]\n         (if (not (false? colResult)) colResult\n           (let [dia1Result (win (getDia % inc 0))]\n             (if (not (false? dia1Result)) dia1Result\n               (let [dia2Result (win (getDia % dec 2))]\n                 (if (not (false? dia2Result)) dia2Result\n                   nil)))))))))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn [board]\n  (let [transpose #(apply map list %)\n        winner? (partial apply =)\n        rows board\n        cols (transpose board)\n        diagonals [(take-nth 4 (flatten board))\n                   (take-nth 4 (flatten (map reverse board)))]\n        remove-empty (partial remove (partial every? #(= :e %)))\n        candidates (remove-empty (concat rows cols diagonals))]\n    (ffirst (filter winner? candidates))))","problem":73,"user":"5312cdaae4b08068f379ed03"},{"code":"(fn [tic_tac]\n  (first (first (filter #(and (apply = %) (not (.contains % :e)))\n                        ((fn [tic_tac] (conj (apply conj tic_tac \n                                   ((fn [tic_tac] (vec (map (fn[x] (vec (map #((tic_tac %) x) (range 3)))) (range 3)))) tic_tac)) \n                            ((fn [tic_tac] (vec (map #((tic_tac %) %) (range 3)))) tic_tac) \n                            ((fn [tic_tac] (vec (map #((tic_tac (- 2  %)) %) (range 3)))) tic_tac))) tic_tac))))\n)","problem":73,"user":"530262c8e4b0d8b024fd3728"},{"code":"(fn [b]\n  (let [j repeat \n        d (range 2 -1 -1) \n        r (range 3) \n        f (fn [a c] (map #(get-in b %) (map list a c))) \n        t #(list % % %)]\n    (first (some #{(t :x) (t :o)} \n                 (into [(f r r) (f r d)] \n                       (mapcat identity (for [i r]\n                                          [(f (j i) r) (f r (j i))])))))))","problem":73,"user":"4ec74de3535d6d7199dd36df"},{"problem":73,"code":"(fn [board]\n  (let [l1 (first board)\n        l2 (second board)\n        l3 (last board)]\n    (cond\n     (or (every? #(= % :x) l1) (every? #(= % :x) l2) (every? #(= % :x) l3)) :x\n     (or (every? #(= % :x) (map first board)) (every? #(= % :x) (map second board)) (every? #(= % :x) (map last board))) :x\n     (and (= (first l1) :x) (= (second l2) :x) (= (last l3) :x)) :x\n     (and (= (last l1) :x) (= (second l2) :x) (= (first l3) :x)) :x\n     \n     (or (every? #(= % :o) l1) (every? #(= % :o) l2) (every? #(= % :o) l3)) :o\n     (or (every? #(= % :o) (map first board)) (every? #(= % :o) (map second board)) (every? #(= % :o) (map last board))) :o\n     (and (= (first l1) :o) (= (second l2) :o) (= (last l3) :o)) :o\n     (and (= (last l1) :o) (= (second l2) :o) (= (first l3) :o)) :o\n     \n     :else nil\n     )))","user":"55aaa36fe4b0988bba2ad94f"},{"code":"(fn [grid] \n  (let \n    [ win? (fn [who triplet] (every? #(= who %) triplet))\n      winner (fn [triplet] \n                (cond (win? :x triplet) :x\n                      (win? :o triplet) :o\n                ))\n      [[c00 _ c02]\n       [_ c11 _]\n       [c20 _ c22]] grid\n      diagonals [[c00 c11 c22] [c02 c11 c20]]\n      verticals (partition 3 (apply interleave grid))]\n    (first (drop-while not \n      (map winner (concat grid verticals diagonals))))))","problem":73,"user":"4e6dc95a535d5021c1a895f1"},{"problem":73,"code":"(fn [[r1 r2 r3 :as rs]]\n  (let [h? (->> rs \n                (filter #(and (apply = %) (not= :e (first %)))) \n                first first)\n        v? (->> (apply map (fn [& args] (if (and (apply = args) (not= :e (first args))) (first args))) rs)\n                (filter (comp not nil?))\n                first)\n        d1? (if (and (not= :e (first r1)) (= (first r1) (second r2) (last r3))) (first r1))\n        d2? (if (and (not= :e (last r1)) (= (last r1) (second r2) (first r3))) (last r1))]\n    (->> [h? v? d1? d2?] (filter (comp not nil?)) first)))","user":"542c22bde4b0dad94371f29e"},{"problem":73,"code":"(fn check-winner\n  [board]\n  (letfn [(get-diagonal [board fun n] (if board\n                                        (cons (nth (first board) n) (get-diagonal (next board) fun (fun n)))\n                                        []))\n          (ttl [board] (into (into (#(into %1 (apply map vector %1)) board) (vector (get-diagonal board dec 2))) (vector (get-diagonal board inc 0))))]\n    (get (reduce into {} (map (fn [val]\n                             {(some #(= (repeat 3 val) %) (ttl board)) val}) [:x :o])) true nil)))","user":"57d0cd58e4b0bd073c20235e"},{"problem":73,"code":"(fn [game]\n    (letfn [(winner-sequence [coll]\n              (case coll\n                [:x :x :x] :x\n                [:o :o :o] :o\n                nil))]\n      (some winner-sequence\n            (concat\n             ;; horizontals\n             game\n             ;; verticals\n             (apply map vector game)\n             ;; diagonals\n             [(map-indexed #(nth %2 %1) game)\n              (map-indexed #(nth %2 (- 2 %1)) game)]))))","user":"53dd37aee4b0d874e779ae28"},{"problem":73,"code":"(fn [s]\n  (let [r (range 3)\n        h (for [i r j r] [i j])\n        v (map #(vector (% 1) (% 0)) h)\n        d (for [i r] [i i])\n        f (for [i r] [i (- 2 i)])\n        q (partition 3 (map (fn [[a b]] ((s a) b)) (concat v h d f)))]\n    (some #{:x :o} (map #(if (apply = %) (first %) nil) q))))","user":"4faf97d8e4b081705acca258"},{"problem":73,"code":"(fn [[r1 r2 r3 :as rows]]\n  (cond\n    (some #(= % (repeat 3 :o)) rows) :o\n    (some #(= % (repeat 3 :x)) rows) :x\n     :else (let [cols (map vector r1 r2 r3)]\n       (cond \n        (some #(= % (repeat 3 :o)) cols) :o\n        (some #(= % (repeat 3 :x)) cols) :x\n        :else (let [diag1 (map #(%1 %2) rows [0 1 2])]\n                (condp = diag1\n                  (repeat 3 :o) :o\n                  (repeat 3 :x) :x\n                   (let [diag2 (map #(%1 %2) rows [2 1 0])]\n                           (condp = diag2\n                             (repeat 3 :o) :o\n                             (repeat 3 :x) :x\n                             nil))))))))","user":"543f854fe4b032a45b86935b"},{"problem":73,"code":"(fn winner [board]\n  (let [all-rows (set (concat\n                        [(map get board [0 1 2]) (map get board [2 1 0])]\n                        (apply map vector board)\n                        board))\n        check-win (fn [player row] (every? #(= % player) row))]\n    (cond\n      (some #(check-win :x %) all-rows) :x\n      (some #(check-win :o %) all-rows) :o\n      :else nil)))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":73,"code":"(fn [board]\n  (->> (concat board (apply map vector board))\n       (cons (map-indexed #(nth %2 %1) board))\n       (cons (map-indexed #(nth (reverse %2) %1) board))\n       (filter #{[:x :x :x] [:o :o :o]})\n       ffirst))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [b] (let \n           [t #(apply mapv vector %)\n      \t\tget2d (fn [brd x y] ((brd x) y))\n      \t\tdiag (fn [brd] (mapv #(get %1 %2) brd [0 1 2]))\n      \t\tdiags (fn [brd] (vector (diag brd) (diag (reverse brd))))\n            get-all-lines (fn [brd] (concat brd (t brd) (diags brd)))\n      \t\tis-line (fn [sym] #(every? (partial = sym) %))\n            check-won (fn [brd sym] (some (is-line sym) (get-all-lines brd)))]\n           (if (check-won b :x)\n             :x\n             (if (check-won b :o)\n               :o\n               nil))\n  ))","problem":73,"user":"51780bfce4b0f89a8f53839c"},{"code":"(fn [m]\n  (letfn [(ck [c] (condp = (set c)\n                    #{:x} :x #{:o} :o nil))\n          (cf [b] (first\n                   (drop-while nil?\n                               (conj (map ck b)\n                                     (ck (map #(get-in b [% %]) (range 3)))\n                                     (ck (map #(get-in b [% (- 2 %)]) (range 3)))))))]\n    (or (cf m)\n        (cf (vec (apply map vector m))))))","problem":73,"user":"4e71705e535d5021c1a89649"},{"problem":73,"code":"(fn [xs] \n  (letfn [(row [i] ( cond (= (xs i) [:x :x :x] ) :x\n                          (= (xs i) [:o :o :o] ) :o\n                           :else nil\n                    ))\n          (col [j] (let [colj [((xs 0) j) ((xs 1) j) ((xs 2) j)]]\n                       (cond (= colj [:x :x :x]) :x\n                            (= colj [:o :o :o]) :o\n                             :else nil\n                       )\n                    ))     \n           (dia1 [xs] (let [d [((xs 0) 0) ((xs 1 )1) ((xs 2) 2)]]\n                      (cond (= d [:x :x :x] ) :x\n                            (= d [:o :o :o] ) :o\n                            :else nil\n                       )\n                     ))\n           (dia2 [xs] (let [d [((xs 0) 2) ((xs 1 ) 1) ((xs 2) 0)]]\n                      (cond (= d [:x :x :x] ) :x\n                            (= d [:o :o :o] ) :o\n                            :else nil\n                      )\n                     ))\n           ]\n          (let [ergset (set (concat  \n                        (map row [0 1 2]) (map col [0 1 2]) (list (dia1 xs) (dia2 xs)) \n                             ))]\n                  (cond (ergset :x) :x\n                        (ergset :o) :o\n                        :else nil\n                   )\n          )\n      )               \n  )","user":"59ff9424e4b01bb0ae8afd24"},{"problem":73,"code":"(fn [board]\n  (let [rows (concat board\n                     (partition 3 (apply interleave board))\n                     [(map #(get-in board [% %]) (range 3))\n                      (map #(get-in board [% (- 2 %)]) (range 3))])]\n    (some #(when (apply = %) (first %))\n          (filter #(not= :e (first %)) rows))))","user":"5d929ceae4b0915913b1d412"},{"problem":73,"code":"(fn at [b]\n  (letfn [(hori [b]\n            ((comp first first)\n               (filter #(or (= % [:x 3]) (= % [:o 3]))\n                       (mapcat #(vec (frequencies %)) b))))\n          (vert [b]\n            (let [new-b (apply map vector b)]\n              (hori new-b)))\n          (diag [b]\n            (let [fb (flatten b)\n                  dl [(nth fb 0) (nth fb 4) (nth fb 8)]\n                  dr [(nth fb 2) (nth fb 4) (nth fb 6)]]\n              (hori [dl dr])))]\n  (some identity  [(hori b) (vert b) (diag b)])))","user":"55ede35ce4b0121d4835fde1"},{"problem":73,"code":"(fn [b]\n  (cond (and (apply = (first b)) (not (= :e (first (first b))))) (first (first b))\n        (and (apply = (second b)) (not (= :e (first (second b))))) (first (second b))\n        (and (apply = (last b)) (not (= :e (first (last b))))) (first (last b))\n        (and (apply = (map first b)) (not (= :e (first (first b))))) (first (first b))\n        (and (apply = (map second b)) (not (= :e (second (first b))))) (second (first b))\n        (and (apply = (map last b)) (not (= :e (last (first b))))) (last (first b))\n        (and (= (first (first b)) (second (second b)) (last (last b))) (not (= :e (first (first b))))) (first (first b))\n        (and (= (last (first b)) (second (second b)) (first (last b))) (not (= :e (last (first b))))) (last (first b))\n        :else nil))","user":"5a34f342e4b0ddc586f153d1"},{"problem":73,"code":"(fn [grid]\n  (let [paths (concat grid [[(first (first grid)) (first (second grid)) (first (last grid))]\n                            [(second (first grid)) (second (second grid)) (second (last grid))]\n                            [(last (first grid)) (last (second grid)) (last (last grid))]\n                            [(first (first grid)) (second (second grid)) (last (last grid))]\n                            [(last (first grid)) (second (second grid)) (first (last grid))]])]\n    (println paths)\n    (loop [p paths]\n      (cond\n        (empty? p) nil\n        (every? #{:x} (first p)) :x\n        (every? #{:o} (first p)) :o\n        :else (recur (rest p))))))","user":"55efb51ee4b066087aa9453b"},{"code":"(fn [x]\n  (first\n    (first\n      (filter #(and (apply = %) (not= (last %) :e))\n        (into #{}\n          (concat x\n            (partition 3 (apply interleave x))\n            [[(first (first x)) (second (second x)) (last (last x))]]\n            [[(first (last x)) (second (second x)) (last (first x))]]\n          )\n        )\n      )\n    )\n  )\n)","problem":73,"user":"4e3456f9535deb9a81d77f2a"},{"problem":73,"code":"(fn ttt [v]\n  (letfn [(check [xs] (when (apply = xs) (first xs)))]\n   (let [vt (vec (for [i (range 3)]\n                   (vec (for [j (range 3)]\n                          (get-in v [j i])))))\n         diag (vec (for [i (range 3)] (get-in v [i i])))\n         xdiag (vec (for [i (range 3)] (get-in v [i (- 2 i)])))]\n     (some #{:x :o}\n           (map check\n                (conj (concat v vt)\n                      diag xdiag))))))","user":"60460824e4b02d28681c77bc"},{"problem":73,"code":"(fn [board]\n  (let [truerow [true true true]\n      falserow [false false false]\n      rowwins [[truerow falserow falserow]\n               [falserow truerow falserow]\n               [falserow falserow truerow]]\n      firsttrue [true false false]\n      sectrue [false true false]\n      thirdtrue [false false true]\n      first-diag [firsttrue sectrue thirdtrue]\n      colwins (map #(take 3 (repeat %)) first-diag)\n      diags [first-diag (reverse first-diag)]\n      allwins (concat rowwins colwins diags)\n      flatwins (map flatten allwins)]\n  (letfn [(match-this-win\n          [board win]\n          (let [squares-in-line\n                (->> board\n                     flatten\n                     (map vector win)\n                     (filter first)\n                     (map second))]\n            (some (fn [player] (if (every? #(= player %) squares-in-line) player))\n                  (list :x :o))))]\n    (some #(match-this-win board %) flatwins))))","user":"58a47197e4b01a0c0b2328f9"},{"code":"(fn [tttb] \n  (let [rows-cols-diags (concat tttb (apply map vector tttb) [[(nth (nth tttb 0) 0) (nth (nth tttb 1) 1) (nth (nth tttb 2) 2)]] [[(nth (nth tttb 2) 0) (nth (nth tttb 1) 1) (nth (nth tttb 0) 2)]])\n        won (reduce (fn [result row] (or result (if (every? #(= :x %) row) :x false) (if (every? #(= :o %) row) :o false))) false rows-cols-diags)]\n        (if won won nil)))","problem":73,"user":"4f0e4ebd535d0136e6c22322"},{"problem":73,"code":"(fn [board]\n  (let [rows      board\n        columns   (apply map vector board)\n        diagonals [(map nth rows (range))\n                   (map nth (rseq rows) (range))]\n \n        paths     (concat rows columns diagonals)\n \n        winner {[:x :x :x] :x\n                [:o :o :o] :o}]\n \n    (some winner paths)))","user":"4db85310535d1e037afb218b"},{"code":"(fn [[[a11 a12 a13] [a21 a22 a23] [a31 a32 a33] :as r]]\n  (cond (some (partial = [:x :x :x]) r) :x\n        (some (partial = [:o :o :o]) r) :o\n        (some (partial = [:x :x :x]) [[a11 a21 a31] [a12 a22 a32] [a13 a23 a33]]) :x\n        (some (partial = [:o :o :o]) [[a11 a21 a31] [a12 a22 a32] [a13 a23 a33]]) :o \n        (some (partial = [:x :x :x]) [[a11 a22 a33] [a13 a22 a31]]) :x\n        (some (partial = [:o :o :o]) [[a11 a22 a33] [a13 a22 a31]]) :o\n        :o nil))","problem":73,"user":"4ede8789535d10e5ff6f5337"},{"code":"(fn [rows]\n  (let [cols (apply map vector rows)\n        diag (fn [b] (map-indexed #(nth %2 %) b))\n        diags (map diag [rows (map reverse rows)])]\n    (some {[:x :x :x] :x,\n          [:o :o :o] :o}\n          (concat rows cols diags))))","problem":73,"user":"5078d366e4b08327cd804a5b"},{"problem":73,"code":"(fn [board]\n    (let [rows     board\n          cols     (apply map #(vector % %2 %3) board)\n          diag-1   (map #(nth (nth board %) %) (range 3))\n          diag-2   (map #(nth (nth board %) (- 2 %)) (range 3))\n          all-seqs (concat\n                     rows\n                     cols\n                     [diag-1 diag-2])\n          xs       (repeat 3 :x)\n          os       (repeat 3 :o)]\n      (cond\n        (some #{xs} all-seqs) :x\n        (some #{os} all-seqs) :o\n        :else                 nil)))","user":"5a00cb31e4b01bb0ae8afd36"},{"code":"(fn [b] \r\n    (let [n (count b)\r\n      n2 (* n n)\r\n      fb (vec (flatten b))\r\n      rpos (partition n (range 0 n2))\r\n      cpos (for [x (range 0 n)]\r\n             (take n (iterate (partial + n) x)))\r\n      dspos (list (range 0 n2 (inc n))\r\n               (range (dec n) 7 (dec n)))\r\n      pos (reduce #(apply conj %1 %2) '() (list rpos cpos dspos))\r\n      verify (fn [r p]\r\n             (let [fs (map #(get fb %) p)]\r\n               (cond\r\n                 (every? (partial = :x) fs) :x\r\n                 (every? (partial = :o) fs) :o\r\n                 :default r))\r\n             )]\r\n      (reduce verify nil pos)))","problem":73,"user":"4f0da4e4535d0136e6c22319"},{"problem":73,"code":"(fn analyze-tt [board]\n  (let [lines (concat\n    board ; horizontal\n    (for [j (range 3)] ; vertical\n      (for [i (range 3)]\n        (get-in board [i j])))\n    [ (for [i (range 3)] (get-in board [i i])) ]\n    [ (for [i (range 3)] (get-in board [i (- 2 i)])) ]\n    )]\n    (if (some identity (filter #( = % '(:x :x :x) ) lines))\n      :x\n      (if (some identity (filter #( = % '(:o :o :o) ) lines))\n        :o\n        nil))))","user":"57b99d48e4b0fbc9809a27f2"},{"code":"(fn [board]\n  (let [cols (apply map vector board)\n        diag1 (map-indexed #(get %2 %1) board)\n        diag2 (reverse (map-indexed #(get %2 %1) (reverse board)))\n        triplets (concat board cols (list (vec diag1)) (list (vec diag2)))]\n    (some {[:x :x :x] :x [:o :o :o] :o} triplets)))","problem":73,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn who-wins [board]\n    (some\n      (fn wins? [e]\n          (let [e3 (repeat 3 e)]\n            (when\n              (or (some #(= % e3) board)\n                  (some #(= % e3) (apply map vector board))\n                  (every? #(= (nth (nth board %) %) e) (range 3))\n                  (every? #(= (nth (nth board %) (- 2 %)) e) (range 3)))\n              e)))\n      [:x :o]))","problem":73,"user":"508157b2e4b0946d0443855c"},{"code":"(fn [b] (first (some #{#{:x} #{:o}} (map #(set (map (partial nth (flatten b))%)) [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]))))","problem":73,"user":"4db92654535d1e037afb21a0"},{"problem":73,"code":"(fn [x]\n   (cond (= #{:x} (set (map first x))) :x\n         (= #{:o} (set (map first x))) :o\n         (= #{:x} (set (map second x))) :x\n         (= #{:o} (set (map second x))) :o\n         (= #{:x} (set (map last x))) :x\n         (= #{:o} (set (map last x))) :o\n         (and\n          (= :o (first (first x)))\n          (= :o (second (second x)))\n          (= :o (last (last x)))) :o\n         (and \n          (= :x (first (last x)))\n          (= :x (second (second x)))\n          (= :x (last (first x)))) :x\n         (and\n          (= :x (first (first x)))\n          (= :x (second (second x)))\n          (= :x (last (last x)))) :x\n         (and \n          (= :o (first (last x)))\n          (= :o (second (second x)))\n          (= :o (last (first x)))) :o\n         \n         :else (->> x\n                    (map set)\n                    (filter #(= 1 (count %)))\n                    (remove #{#{:e}})\n                    ffirst)))","user":"5cc36598e4b0ccb0619627f3"},{"problem":73,"code":"(fn [board]\n  (letfn\n    [(win? [a b c] (or (and (not= a :e) (= a b) (= b c) a) nil))\n     (b [x y] (nth (nth board x) y))]\n    (or\n     (win? (b 0 0) (b 0 1) (b 0 2))\n     (win? (b 1 0) (b 1 1) (b 1 2))\n     (win? (b 2 0) (b 2 1) (b 2 2))\n     (win? (b 0 0) (b 1 0) (b 2 0))\n     (win? (b 0 1) (b 1 1) (b 2 1))\n     (win? (b 0 2) (b 1 2) (b 2 2))\n     (win? (b 0 0) (b 1 1) (b 2 2))\n     (win? (b 0 2) (b 1 1) (b 2 0)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":73,"code":"(let [transpose (fn [m] (apply map vector m))\n       first-win (partial some #{:x :o})\n       rule-row (fn [r] (first-win (map #(if (apply = %) (first %) nil) r)))\n       rule-col (comp rule-row transpose)\n       rule-diags (fn [m] (rule-row [(mapv get m (range)) (mapv get (rseq m) (range))]))\n       under (fn [fs v] (map #(% v) fs))]\n   (fn [m] (first-win (under [rule-col rule-row rule-diags] m))))","user":"5fa416ece4b0f0ebd91b7803"},{"problem":73,"code":"(fn  [board]\n  (let [data board\n        len (count (first board)) \n        keys (take len (range 0 len))\n        data (conj data  (map #(get %1 %2) board keys))\n        data (conj data  (map #(get %1 %2) board (reverse keys)))\n        cols  (map (fn [index] (map (fn [data] (get data index)) board)) keys)\n        data (reduce conj data cols)\n        is-winner? (fn [val data] (when (every? #(= val %) data) val))]\n    (first \n     (filter \n      (comp not  nil?) \n       (flatten  \n        (map (fn [val] \n                 (map (partial is-winner? val)\n                      data))\n              [:x :o]))))))","user":"5832be57e4b089d5ab817c86"},{"code":"(fn [board]\n  (let [xwin [:x :x :x]\n        owin [:o :o :o]\n        cols [(map first board)\n              (map second board)\n              (map #(nth % 2) board)]\n        flat (flatten board)\n        diag [(take-nth 4 flat)\n              (butlast (take-nth 2 (nnext flat)))]]\n    (cond\n     (some #(= xwin %) board) :x\n     (some #(= owin %) board) :o\n     (some #(= xwin %) cols) :x\n     (some #(= owin %) cols) :o\n     (some #(= xwin %) diag) :x\n     (some #(= owin %) diag) :o\n     :else nil)))","problem":73,"user":"4dc21233535d020aff1edf92"},{"code":";(fn [brd] \n;  (some (fn [x] (when x) x) \n;        (map (fn [brd]\n;               (some #(when % %) \n;                     (map #(when\n;                             ((fn [coll pred] (every? pred coll)) %1 %2) (first %2)) brd [#{:x} #{:o}]))) \n;             ((fn [brd] (conj [brd] (apply map vector brd) \n;                              ((fn [brd] (map #(map-indexed \n;                                                (fn [idx coll] (nth coll idx)) %) [brd (reverse brd)])) brd))) brd))))\n\n\n(fn [brd] \n  (let [player? (fn [coll pred] (every? pred coll)) \n        get-winner (fn [brd] (some #(when % %) (map #(when (player? %1 %2) (first %2)) brd [#{:x} #{:o}]))) \n        diagonals (fn [brd] (map #(map-indexed (fn [idx coll] (nth coll idx)) %) [brd (reverse brd)])) \n        combis (fn [brd] (conj [brd] (apply map vector brd) (diagonals brd)))]\n  (some (fn [x] (when x) x) (map get-winner (combis brd)))))","problem":73,"user":"536a37efe4b0243289761eaa"},{"problem":73,"code":"(fn tic-tac [board]\n (let [A board\n       At (apply map vector A)\n       As (map reverse A)\n       diag (fn [b] (let [[[x _ _] [_ y _] [_ _ z]] b] [x y z]))\n       test (fn [y] (ffirst (drop-while #(apply not= %) y)))\n       sol? (fn [sol] (if (= sol :e) nil sol))]\n   (cond \n    (when (test A) true) (sol? (test A))\n    (when (test At) true) (sol? (test At))\n    (apply = (diag A)) (sol? (first (diag A)))\n    (apply = (diag As)) (sol? (first (diag As)))\n    :else nil\n    )))","user":"534fa9dae4b084c2834f4acf"},{"problem":73,"code":"(fn win [board] \n  (let [xcheck  (fn [x] (fn [row] (when (every? #(= % x) row) x)))]\n  (let [allcheck (fn [cand board] (let [checker (xcheck cand)]\n    (or \n   (some #(if (not (nil? %)) %) (map checker board))\n   (checker (map #(nth %1 %2) board [0 1 2]))\n   (checker (map #(nth %1 %2) board [2 1 0]))\n   (or\n    (checker (map first board))\n    (checker (map second board))\n    (checker (map #(nth % 2) board)))))\n  )]\n    \n    (or\n     (allcheck :x board)\n     (allcheck :o board)))))","user":"53c6a2fde4b00fb29b22129d"},{"problem":73,"code":"(fn [board] (let [fdiag (fn [brd] (map #(get (second %) (first %)) (map-indexed vector brd)))\n                  diags (map fdiag (vector board (reverse board)))\n                  lines (concat board (apply map vector board) diags)\n                  fcheck (fn [line] (#(and (apply = line) (not (= :e %)) %) (first line)))]\n              (or (some fcheck lines) nil)))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [rows]\n  (let [cols (apply map vector rows)\n        diag (fn [x] (map-indexed #(nth %2 %) x))\n        diags [(diag rows) (diag (map reverse rows))]\n        lines (concat rows cols diags)\n        line-sets (map set lines)]\n    (first (some #{#{:x} #{:o}} line-sets))))","problem":73,"user":"4f6160a7e4b0defedf855fbe"},{"problem":73,"code":"(fn [v]\n  (let [ll [[[0 0] [0 1] [0 2]]\n            [[1 0] [1 1] [1 2]]\n            [[2 0] [2 1] [2 2]]\n            [[0 0] [1 0] [2 0]]\n            [[0 1] [1 1] [2 1]]\n            [[0 2] [1 2] [2 2]]\n            [[0 0] [1 1] [2 2]]\n            [[0 2] [1 1] [2 0]]]\n        lines (filter #(= (first %) (second %) (last %))\n                      (map #(map (fn [pos] ((v (first pos)) (second pos))) %) ll))]\n  (if (empty? lines)\n    nil\n    (let [e (first (first lines))]\n      (if (= e :e) nil e)))))","user":"56051095e4b08b23635d3162"},{"problem":73,"code":"(fn [v]\n  (let [cols (apply map vector v)\n        diag1 (map #(nth %1 %2) v (range 3))\n        diag2 (map #(nth %1 %2) v (reverse (range 3)))\n        all-rows (concat v cols [diag1 diag2])]\n    (->> all-rows\n         (map #(into #{} %))\n         (filter #(= 1 (count %)))\n         (apply concat)\n         (some #{:x :o}))))","user":"530b8580e4b02e82168697cc"},{"code":"(fn [m]\n  (if\n    (or \n     (some #(apply = :x %) m)\n     (some #(apply = :x %) (apply map list m))\n     (apply = :x (#(list ((% 0) 0) ((% 1) 1) ((% 2) 2)) m))\n     (apply = :x (#(list ((% 0) 2) ((% 1) 1) ((% 2) 0)) m)))\n    :x\n    (if\n      (or \n       (some #(apply = :o %) m)\n       (some #(apply = :o %) (apply map list m))\n       (apply = :o (#(list ((% 0) 0) ((% 1) 1) ((% 2) 2)) m))\n       (apply = :o (#(list ((% 0) 2) ((% 1) 1) ((% 2) 0)) m)))\n      :o)))","problem":73,"user":"52aad30ce4b0c58976d9ac6d"},{"code":"(fn [board]\n    (let [rows (clojure.walk/prewalk-replace {:e nil} board)]\n      (letfn [(tran [mat]\n                (map (fn [i] (map #(nth % i) mat)) (range (count mat))))\n              (chk-row [row]\n                (let [x (into #{} row)]\n                  (if (= 1 (count x)) (first x) nil)))\n              (chk-rows [mat]\n                (some identity (map chk-row mat)))\n              (diag [mat]\n                (map-indexed\n                 (fn [i row] (first (drop i row)))\n                 mat))]\n        (or\n         (chk-rows rows)\n         (chk-rows (tran rows))\n         (chk-row (diag rows))\n         (chk-row (diag (map reverse rows)))))))","problem":73,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":73,"code":"(fn boardWinner [board] \n  (letfn [(transpose [m] (apply mapv vector m) )\n          (diagonal [[r1 r2 r3]] [(first r1) (second r2) (last r3)])\n          (diagonals [m] [(diagonal m) (diagonal (map reverse m))])\n          (rowWinner [row] (case row\n                             [:x :x :x] [:x]\n                             [:o :o :o] [:o]\n                             nil))]\n    (let [rows board\n          columns (transpose board)\n          diags (diagonals board)\n          potentialWins (concat rows columns diags)]\n      (first (apply concat (map rowWinner potentialWins)))\n      )\n    )\n  )","user":"575ef4b6e4b08062f99a4e78"},{"problem":73,"code":"(fn [b]\n  (first\n    (filter #(or (= % :x) (= % :o))\n      (map first\n        (filter (partial apply =)\n          (concat b\n                  (for [x (range 3)] (for [y (range 3)] (get-in b [y x])))\n                  (vector (for [x (range 3)] (get-in b [x x]))\n                          (for [x (range 3)] (get-in b [x (Math/abs (- x 2))])))))))))","user":"564a5a09e4b0284900eef656"},{"code":"(fn ttt [b]\n  (letfn [(cols [b] (apply map vector b))\n\t         (diag1 [b] (for [x (range 3)] (nth (nth b x) x)))\n\t         (diag2 [b] (for [x (range 3)] (nth (nth b x) (- 2 x))))\n           (ws [b] (apply conj b (conj (cols b) (diag1 b) (diag2 b))))\n          ]\n\t  (let [s (set (for [x [:x :o] r (ws b)] (if (every? #(= x %) r) x 0)))]\n\t    (or (s :x) (s :o)))))","problem":73,"user":"4f725201e4b07046d9f4f02f"},{"problem":73,"code":"(letfn [(hor [p b] (some (partial apply = p) b))\n        (ver [p b] (some (partial apply = p) (apply map vector b)))\n        (diag [p b] (apply = p (map nth b (reverse (range 0 3)))))\n        (rdiag [p b] (apply = p (map nth b (range 0 3))))]\n  (fn [b] (first (filter #(or (hor % b) (ver % b) (diag % b) (rdiag % b)) [:x :o]))))","user":"50e0d5a3e4b061dbdced723d"},{"problem":73,"code":"(fn [rows]\n  (let [idx (range (count rows))\n        verticals (apply map vector rows)\n        diagonals [(map get rows idx) (map get rows (reverse idx))]\n        all-cases (concat rows verticals diagonals)\n        wins (filter #(= 3 (second %)) (mapcat frequencies all-cases))]\n    (when-let [winner (first (first wins))]\n      (if (= winner :e) nil winner))))","user":"55d5ee3fe4b0e31453f64a92"},{"problem":73,"code":"(fn analyzeboard [b]\n\n(let [d1 (mapv #(get-in b %) (for [x (range 3)] [x x])) \n      d2 (mapv #(get-in b %) (for [x (range 3)] [x (- 2 x)] ))]\n  (case\n      (some #{[:x :x :x] [:o :o :o]}\n            (-> b\n                (conj d1) ; diagonal\n                (conj d2) ; diagonal\n                (conj (mapv #(nth % 0) b)) ; vertical\n                (conj (mapv #(nth % 1) b)) ; vertical\n                (conj (mapv #(nth % 2) b)) ; vertical\n                ))\n    [:x :x :x] :x\n    [:o :o :o] :o\n    nil)))","user":"56f2611fe4b04a395b9a04a2"},{"problem":73,"code":"(fn who-won? [board]\n  (let [fns [first second last]\n        all-equal? (fn [s] (reduce #(if (= %1 %2) %1 nil) s))\n        lines (concat board ; rows\n                      (map #(map % board) fns) ; columns\n                      [(map #(% %2) fns board) (map #(% %2) (reverse fns) board)]) ; diagonals\n        result (some all-equal? lines)]\n    (if (#{:e} result) nil result)))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn [m]\n  (let [m (concat m\n                  (map vector (m 0) (m 1) (m 2))\n                  [(vector (get-in m [0 0]) (get-in m [1 1]) (get-in m [2 2]))\n                   (vector (get-in m [0 2]) (get-in m [1 1]) (get-in m [2 0]))])]\n    (->> (map (fn [v]\n                   (cond (= v [:x :x :x]) :x\n                         (= v [:o :o :o]) :o\n                         :else nil)) m)\n         (filter #(not (nil? %)))\n         first)))","problem":73,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":73,"code":"(fn [[first-row second-row third-row :as field]]\n  (let [first-column (map first field)\n        second-column (map second field)\n        third-column (map last field)\n        left-diagonal [(first first-row)\n                       (second second-row)\n                       (last third-row)]\n        right-diagonal [(last first-row)\n                        (second second-row)\n                        (first third-row)]\n        get-winner (fn [[winner :as seq]]\n                     (if (apply = seq) winner nil))]\n    (some #{:x :o}\n          (map get-winner\n               [first-row\n                second-row\n                third-row\n                first-column\n                second-column\n                third-column\n                left-diagonal\n                right-diagonal]))))","user":"55d354e0e4b0e31453f64a62"},{"code":"(fn t [b]\n  (let [w\n        (concat\n         (for [x (range 3)] (for [y (range 3)]  [x y]))\n         (for [x (range 3)] (for [y (range 3)]  [y x]))\n         '(([0 0] [1 1] [2 2]) ([2 0] [1 1] [0 2])))\n        ]\n    (letfn [(check-slot [b p s] (= p ((b (s 0)) (s 1))))\n            (check-conf [b p c] (every? #(check-slot b p %) c))\n            (check-all [b p w] (map (partial check-conf b p) w))]\n      (cond\n       (some true? (check-all b :x w)) :x\n       (some true? (check-all b :o w)) :o\n       :else nil))\n))","problem":73,"user":"4ea1ecfa535d7eef308072bb"},{"problem":73,"code":"(fn [row]\n  (let [r1 (first row)\n        r2 (second row)\n        r3 (last row)\n        winlines [r1 r2 r3\n                  (vector (first r1) (first r2) (first r3))\n                  (vector (second r1) (second r2) (second r3))\n                  (vector (last r1) (last r2) (last r3))\n                  (vector (first r1) (second r2) (last r3))\n                  (vector (last r1) (second r2) (first r3))]]\n    (if (some #(= % 3) (map (fn [line] (count (filter #(= % :x) line))) winlines))\n      :x\n      (when (some #(= % 3) (map (fn [line] (count (filter #(= % :o) line))) winlines))\n        :o))))","user":"55b22c33e4b0da326a65cf79"},{"problem":73,"code":"(fn [b]\n  (letfn [(same? [xs] (let [xs (replace {:e nil} xs)] (when (= 1 (count (distinct xs))) (first xs))))\n          (row? [board] (some same? board))\n          (col? [board] (some same? (for [i (range 2)] (map #(nth % i) board))))\n          (diag-x? [board] (same? (for [i (range 3)] (nth (nth board i) i))))\n          (diag-y? [board] (same? (for [i (range 3)] (nth (nth board (- 2 i)) i))))]\n    (some identity [(row? b) (col? b) (diag-x? b) (diag-y? b)])))","user":"4ff8487be4b0678c553fc397"},{"code":"(fn tic-tac-toe [board]\n  (let [a (fn [x y] (nth (nth board x) y))\n        lines [(nth board 0) (nth board 1) (nth board 2)\n               [(a 0 0) (a 1 0) (a 2 0)] \n               [(a 0 1) (a 1 1) (a 2 1)]\n               [(a 0 2) (a 1 2) (a 2 2)]\n               [(a 0 0) (a 1 1) (a 2 2)]\n               [(a 2 0) (a 1 1) (a 0 2)]]]\n    (cond\n      (some (fn [x] (every? #(= :x %) x)) lines) :x\n      (some (fn [x] (every? #(= :o %) x)) lines) :o\n      :else                                      nil)))","problem":73,"user":"4e7263a1535d5021c1a8965f"},{"problem":73,"code":"(fn [board]\n  (let \n    [test-vect\n     #(if (apply = %)\n        (if (= :e (first %))\n          nil\n          (first %)\n          )\n        )\n     win-horizontally\n     (some test-vect board)\n     win-vertically\n     (some \n       test-vect\n       (for [n (range 3)] (map #(nth % n) board))\n      )\n     win-diagonally\n     (some test-vect\n      [ (for [n (range 3)] (nth (nth board n) n))\n        (for [n (range 3)] (nth (nth board (- 2 n)) n))]\n           )\n     ]\n    (some identity [win-horizontally win-vertically win-diagonally])\n    )\n  )","user":"5776558ee4b0979f89651633"},{"problem":73,"code":"(fn \n\t[[[a1 b1 c1] [a2 b2 c2] [a3 b3 c3] :as board]]\n  (let [p (into board\n                [[a1 a2 a3]\n                 [b1 b2 b3]\n                 [c1 c2 c3]\n                 [a1 b2 c3]\n                 [a3 b2 c1]])\n        f   (fn [v]\n              (let [k (peek v)]\n                (every? #(and\n                          (not= % :e)\n                          (= k %)) v)))\n        r (filter f p)]\n    (if-let [re (first r)]\n      (first re)\n      nil)))","user":"5ae4e0e3e4b0837691e92c86"},{"code":"(fn [b]\n   (let [b (concat b (apply map list b)\n                   [[((b 0) 0) ((b 1) 1) ((b 2) 2)]]\n                   [[((b 0) 2) ((b 1) 1) ((b 2) 0)]])]\n         (some {[:x :x :x] :x [:o :o :o] :o} b)))","problem":73,"user":"4e8510e7535db62dc21a62e7"},{"code":"(fn find-wins\n  [board]\n  (let [generate-winners (fn [f] (partition 3 (for [x (range 0 3)\n                                                      y (range 0 3)]\n                                                   (f [x y]))))\n        all-winning-squares (conj (into (generate-winners identity)\n                                         (generate-winners (comp vec reverse)))\n                                  [[0 0] [1 1] [2 2]]\n                                  [[0 2] [1 1] [2 0]])]\n    (first (filter (fn [r] (and r (not (= :e r))))\n                   (map #(let [line (map (fn[[x y]]\n                                            (get (get board x) y)) %)]\n                           (if (apply = line)\n                               (first line)))\n                        all-winning-squares)))))","problem":73,"user":"4daeabf6edd6309eace4d15c"},{"problem":73,"code":"(fn [m]\n  (first\n    (filter\n      (fn win? [player]\n        (->> (let [idx [0 1 2]]\n                (concat m                               ; rows\n                  (map (fn [i] (map #(% i) m)) idx)     ; columns\n                  (vector (map #((m %) %) idx))         ; diagonal 1\n                  (vector (map #((m (- 2 %)) %) idx)))) ; diagonal 2\n             (map (fn [row] (count (filter #(= player %) row))))\n             (filter #(= % 3))\n             seq))\n      [:x :o])))","user":"52afa8a1e4b0c58976d9acbe"},{"code":"(fn [[a b c]]\n  (let [lines (into [a b c \n                     [(first a) (second b) (last c)]\n                     [(first c) (second b) (last a)]]\n                     (map vector a b c))\n        won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n    (first (remove nil? (map won? lines)))))","problem":73,"user":"52976262e4b02ebb4ef75041"},{"problem":73,"code":"(fn [board]\n                 (let [w (fn [p b]\n                           (some #{[p p p]}\n                                 (concat b\n                                         (apply map list b)\n                                         (list (map #(-> b (nth %) (nth %)) (range 3)))\n                                         (list (map #(-> b (nth (- 2 %)) (nth %)) (range 3))))))]\n                   (first (some #(w % board) [:x :o]))))","user":"52be5d55e4b07a9af579231e"},{"problem":73,"code":"(fn who-won\n  [board]\n  (first\n    (reduce\n      (fn [acc sym]\n        (let [horizontal (map #(distinct %) board)\n              vertical (map distinct (apply map (fn [& args] args) board))\n              left-diag (distinct (map #(nth %1 %2) board (iterate inc 0)))\n              right-diag (distinct (map #(nth %1 %2) board (iterate dec 2)))]\n          (cond\n            (some #(= [sym] %) vertical) (conj acc sym)\n            (some #(= [sym] %) horizontal) (conj acc sym)\n            (= [sym] left-diag) (conj acc sym)\n            (= [sym] right-diag) (conj acc sym)\n            :else acc)))\n      []\n      [:x :o])))","user":"59b62f8de4b05c620303ca1f"},{"problem":73,"code":"(fn [board]\n (let [three-in-a-row?\n        (fn [row]\n          (if (and (= (first row) (second row))\n                   (= (first row) (last row)))\n            (if (not= (first row) :e)\n              (first row)\n              nil)\n            nil))\n       rows (concat (map identity board)\n                    (for [x [0 1 2]] (map #(get % x) board))\n                    (list (vec (map #((get board %) %) [0 1 2])))\n                    (list (vec (map #((get (vec (reverse board)) %) %) [2 1 0]))))]\n    (first (filter #(identity %) (map three-in-a-row? rows)))))","user":"541709b0e4b01498b1a71a06"},{"problem":73,"code":"(fn [[row1 row2 row3 :as rows]]\n  (let [vrow1 (map first rows)\n        vrow2 (map second rows)\n        vrow3 (map last rows)\n        drow1 [(first row1) (second row2) (last row3)]\n        drow2 [(first row3) (second row2) (last row1)]\n        all-rows (conj rows vrow1 vrow2 vrow3 drow1 drow2)\n        win-row (fn [p row]\n                  (every? #(= p %) row))]\n    (cond\n      (some #(win-row :o %) all-rows) :o\n      (some #(win-row :x %) all-rows) :x\n      :else nil)))","user":"50ec409ce4b04edc33777045"},{"problem":73,"code":"#(reduce (fn [init ls] (if (and (not= :e (first  ls)) (apply = ls)) (first ls) init)) nil (list (first %) (second %) (last %) (map first %) (map second %) (map last %) (map (fn [pos ls] (pos ls)) [first second last] %) (map (fn [pos ls] (pos ls)) [last second first] %)))","user":"5a64ce4ee4b0512ff01cd9a6"},{"code":"(fn toeWin[board]\n    (let [size (count board)\n          colrange (into [] (range 0 (count board)))\n          columns (map (fn [i] (map #(% i) board)) colrange)\n          diags [(map #((board %) %) colrange) (map #((board %) (- size 1 %)) colrange)]\n          wins (fn [sym, all] (some true? (map #(every? (fn [x](= x sym)) %) all))    )\n          all (concat board columns diags)\n         ]\n     (if (wins :x all) :x (if (wins :o all) :o nil) ))\n  )","problem":73,"user":"503c02e5e4b0fc0f99c2e54e"},{"problem":73,"code":"(fn [board]\n  (let [rows      board\n        columns   (apply map vector board)\n        diagonals [(map-indexed #(nth %2 %) board)\n                   (map-indexed #(nth %2 %) (reverse board))]\n        candidates (->> (concat rows columns diagonals)\n                        (map set)\n                        (filter #(= (count %) 1))\n                        (remove #(= % #{:e})))]\n    (ffirst candidates)))","user":"54157dace4b01498b1a719f4"},{"problem":73,"code":"(fn [[[a _ c][_ e _][g _ i] :as r]]\n   (let [d-a [a e i]\n         d-b [c e g]\n         c (apply map vector r)]\n     (->> (concat r c [d-a d-b])\n          (interleave (repeat [:_]))\n          (apply concat)\n          (partition-by identity)\n          (remove (partial some #{:e}))\n          (filter #(= 3 (count %)))\n          ffirst)))","user":"5db0172be4b0f8c104ccfc96"},{"problem":73,"code":"(fn [b] \n   (let [win [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n     (->> b\n         (flatten)\n         (vec)\n         (#(for [s win] (set (map % s)))) \n         (filter #(= (count %) 1))\n         (filter #(not (contains? % :e)))\n         first\n         first \n         )))","user":"550aeddae4b06e50f9beb135"},{"code":"(fn ttt [board]\r\n  (let [lines (concat (for [y (range 3)] (for [x (range 3)] [x y]))\r\n                      (for [x (range 3)] (for [y (range 3)] [x y]))\r\n                      [(for [i (range 3)] [i i])\r\n                       (for [i (range 3)] [i (- 2 i)])])]\r\n    (letfn [(cell [[x y]] (nth (nth board x) y))\r\n            (check-lines [p] (some #(every? #{p} (map cell %)) lines))]\r\n      (cond (check-lines :x) :x (check-lines :o) :o))))","problem":73,"user":"4dfd4ba8535d04ed9115e781"},{"code":"(fn my-game [xss]\r\n  (let [xs (flatten xss)\r\n        same #(apply = %)\r\n        is [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\r\n        r (map #(map (fn [i] (nth xs i)) %) is)\r\n        t (filter same r)\r\n        w (remove #(= :e (first %)) t)]\r\n    (when w (ffirst w))))","problem":73,"user":"4f251302e4b0d66497709ff0"},{"problem":73,"code":"(fn\n  [b]\n  (let [f first s second d last\n        g #(f (filter identity %))\n        c (fn [k v] (if (every? #(= k %) v) k nil))\n        w (fn [r] (g (map #(c % r) [:x :o])))\n        l (g (apply concat\n                    (map (fn [a]\n                           (map w a))\n                         [b (apply map vector b)])))\n        i (g (map\n              (fn [a]\n                (w (map (fn [f] (f (f a))) [f s d]))\n                )\n              [b (map reverse b)]))]\n    (if l l i)))","user":"51b76227e4b0d906fcd71d35"},{"problem":73,"code":"(fn [board]\n  (let [row-res (fn [[sq1 sq2 sq3]] (if (and (not= sq1 :e) (= sq1 sq2 sq3))\n                                    sq1\n                                    nil))\n        cols (apply map vector board)\n        diag-idxs [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n        diags (map (partial map (partial get-in board)) diag-idxs)]\n   (some (partial some row-res) [board cols diags])))","user":"5339c105e4b0e30313ee6cae"},{"problem":73,"code":"(fn tic-tac-toe [matrix]\n  (let [count-pawn1 (fn [line pawntype] (count (filter #(= % pawntype) line)))\n        count-pawn (fn [line] {:x (count-pawn1 line :x) :o (count-pawn1 line :o)})\n        winner (fn [{xcount :x ocount :o}]\n                 (let [n (count matrix)]\n                   (cond\n                    (= n xcount) :x\n                    (= n ocount) :o\n                    :else nil)))\n        rows    (fn [matrix] matrix)\n        cols    (fn [matrix] (apply mapv vector matrix))\n        do-diag (fn [m0 a0] (loop [m m0 acc a0]\n                  (if (empty? m)\n                    acc\n                    (recur (->> m rest (map rest)) (cons (-> m first first) acc)))))\n        diagonals (fn [matrix]\n                    [(do-diag matrix []) (do-diag (reverse matrix) [])])]\n    (let [r (filter #(not (nil? %)) (map (comp winner count-pawn) (concat (rows matrix) (cols matrix) (diagonals matrix))))]\n    (if (empty? r) nil (first r)))))","user":"525b142fe4b0cb4875a45d05"},{"code":"(fn [board]\n  (let [marks #{:o :x}\n        lines (concat board\n                      (map (fn [index] (map #(% index) board))\n                           (range (count (first board))))\n                      (reduce (fn [lines index]\n                                [(conj (first lines)\n                                       ((board index) index))\n                                 (conj (second lines)\n                                       ((nth (reverse board) index) index))])\n                              [[] []]\n                              (range (count board))))]\n    (letfn [(same-marks? [line]\n              (and (marks (first line))\n                   (apply = line)\n                   (first line)))]\n      (let [win-line (first (filter same-marks? lines))]\n        (if win-line (first win-line) nil)))))","problem":73,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn  [r]\n  (let [c (apply mapv vector r)\n        dfn (fn [l] (map-indexed #(nth %2 %) l))\n        d [(dfn r) (dfn (map reverse r))]\n        b (concat r c d)]\n    (first (some #{#{:x} #{:o}} (map set b)))))","problem":73,"user":"504e2011e4b0f6ff3350c469"},{"code":"(fn testwin [rows]\n  (let [rowwin #(if (and (nil? ((set %) :e)) \n                         (= 1 (count (set %))))\n                    (first (set %)) nil)\n        cols (vec (apply map vector rows))\n        hor (some rowwin rows)\n        vert (some rowwin cols)\n        dia1 (rowwin (map-indexed #(%2 %) rows))\n        dia2 (rowwin (map-indexed #(%2 %) (reverse rows)))]\n  (some identity [hor vert dia1 dia2])\n))","problem":73,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":73,"code":"(fn [grid]\n  (first (first\n   (filter (fn [t] (and (not (some (partial = :e) t))\n                        (= (count (set t)) 1)))\n           (concat grid\n                   (map (fn [i] (mapv #(nth % i) grid)) [0 1 2])\n                   [(mapv #(get-in grid %) [[0 0] [1 1] [2 2]])]\n                   [(mapv #(get-in grid %) [[0 2] [1 1] [2 0]])])))))","user":"5136f659e4b04059df19f2fd"},{"code":"(fn [board]\n  (letfn [\n          (vertical [board n]\n            (take-nth 3 (drop n board)))\n          (verticals [board]\n            (map (partial vertical board) (range 3)))\n          (horizontal [board n]\n            (nth (partition 3 board) n))\n          (horizontals [board]\n            (map (partial horizontal board) (range 3)))\n          (diag-1 [board]\n            (take-nth 4 board))\n          (diag-2 [board]\n            (take-nth 2 (drop-last 2 (drop 2 board))))\n          (diagonals [board]\n            ((juxt diag-1 diag-2) board))\n          (scoring-rows [board]\n            (concat (horizontals board)\n                    (verticals board)\n                    (diagonals board)))\n          (winning-row [[s & p]]\n            (if (every? (partial = s) p)\n              s))]\n    (->> board\n         flatten\n         scoring-rows\n         (map winning-row)\n         (filter identity)\n         (remove (partial = :e))\n         first)))","problem":73,"user":"4e80aa10535db62dc21a62b1"},{"problem":73,"code":"(fn [B]\n  (let [T (partial repeat 3)\n        R (range 3)\n        V (concat [R (reverse R)] (map #(T %) R))\n        L (concat B (map #(map nth B %) V))]\n    (some {(T :x) :x (T :o) :o} L)))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn [coll]\n  (let [c (replace {:e nil} (reduce into coll))\n        s (partial #(if (and (%1 (%2 1))\n                              (apply = (map %1 %2)))\n                       (%1 (%2 1))\n                       nil)\n                   c)]\n    (or (s [0 1 2])\n        (s [3 4 5])\n        (s [6 7 8])\n        (s [0 3 6])\n        (s [1 4 7])\n        (s [2 5 8])\n        (s [0 4 8])\n        (s [2 4 6])\n    )))","problem":73,"user":"4e6f8d36535d5021c1a89621"},{"problem":73,"code":"(fn [board]\n  (let [\n    diags (fn [b] (split-at 3 (map #(nth (flatten b) %) '(0 4 8 2 4 6))))\n    verts (fn [b] (apply map list b))\n    combos (concat board (diags board) (verts board))\n    filter-s (filter #(= (count %) 1) (map distinct combos))\n    filter-e (filter #(not= (first %) :e) filter-s)\n    ]\n    (ffirst filter-e)))","user":"59b9e669e4b0a024fb6ae3db"},{"problem":73,"code":"(fn [board]\n   (let [s (concat board\n                   (apply mapv vector board)\n                   (vector)\n                   (->> board\n                        (apply concat)\n                        (partition 1 4)\n                        (apply concat)\n                        (vector))\n                   (->> board\n                        (apply concat)\n                        (drop 2)\n                        (take 5)\n                        (partition 1 2)\n                        (apply concat)\n                        (vector)))]\n     (loop [res nil\n            x (first s)\n            r (rest s)]\n       (println res x r)\n       (cond\n         (nil? x) nil\n         (apply = :x x) :x\n         (apply = :o x) :o\n         :else (recur nil (first r) (rest r))))))","user":"55b54ecbe4b01b9910ae2987"},{"code":"(fn [[a b c]]\n  (letfn [(three-in-row? [[one two three]]\n                      (if (and (= one two three)\n                               (not= one :e))\n                        one nil)) ]\n    (let [possibilities (conj (map vector a b c)\n                   a b c\n                   (vector (first a) (second b) (peek c))\n                   (vector (peek a)(second b)(first c)  )) ]\n       (some #{:x :o} (map three-in-row? possibilities)) \n      )))","problem":73,"user":"51427a8be4b0b50abeb46b37"},{"code":"(fn  [ [[ a1 a2 a3] [b1 b2 b3] [c1 c2 c3]] ]\n  (let [ rows [ [ a1 a2 a3] [b1 b2 b3] [c1 c2 c3] \n                [ a1 b1 c1] [a2 b2 c2] [a3 b3 c3]\n                [ a1 b2 c3] [a3 b2 c1] ] \n         three-in-a-row  (set (map first (filter #(apply = %) rows))) ] \n    (cond\n      (contains? three-in-a-row :x) :x\n      (contains? three-in-a-row :o) :o\n      :else nil\n      )))","problem":73,"user":"4fccdc75e4b0ee37620e186d"},{"problem":73,"code":"(fn [r]\n   (let [columns\n         (fn [i m]\n  \t   (map (fn [x] (nth x i)) m))\n  \t col-check (fn [v l]\n  \t\t     (every? (fn [x] (= x v)) l))\n         column-results (fn [m k] (->>\n   \t\t\t\t   (map #(columns % m)\n    \t\t\t\t        (range 0 3)) (map #(col-check k %))))\n         left-dag-results  (fn [m k] (->> (map #(nth %1 %2) m\n    \t\t\t\t\t       (range 0 3))\n   \t\t\t\t\t  (every? (fn [x] (= x k)))\n                                          (list)))\n         right-dag-results (fn [m k] (->> (map #(nth %1 %2) m\n    \t\t\t\t\t       (reverse (range 0 3)))\n   \t\t\t\t\t  (every? (fn [x] (= x k)))\n                                          (list)))\n         row-results (fn [m k] (map #(every? (fn [x] (= x k)) %) m))]\n     (cond\n       (some true?\n             (concat (column-results r :o)\n    \t\t     (left-dag-results r :o)\n    \t\t     (right-dag-results r :o)\n    \t\t     (row-results r :o))) :o\n\n       (some true?\n             (concat (column-results r :x)\n    \t\t     (left-dag-results r :x)\n    \t\t     (right-dag-results r :x)\n    \t\t     (row-results r :x))) :x\n       :else nil\n       )\n     )\n   )","user":"5dab11cde4b000c986472c45"},{"problem":73,"code":"(let [any-true? (partial (complement not-any?) identity)]\n  (letfn [(diag [n & {:keys [reverse?] :or {reverse? false}}]\n            (map list (range 0 n)\n                (map (if reverse? (partial - (dec n)) identity) (range 0 n))))\n          (row-win-across [s]\n            (->> s\n                (group-by first)\n                (map (fn [[_ coll]]\n                      (= #{0 1 2} (->> coll (map second) (into #{})))))\n                (any-true?)))\n\n          (row-win-down [s]\n            (->> s\n                (group-by second)\n                (map (fn [[_ coll]]\n                        (= #{0 1 2} (->> coll (map first) (into #{})))))\n                (any-true?)))\n\n          (row-win-diag [s]\n            (or (clojure.set/subset? (set (diag 3)) s)\n                (clojure.set/subset? (set (diag 3 :reverse? true)) s)))\n\n          (grouped-board [board]\n            (apply merge-with (comp (partial into #{}) concat)\n                        (map #(into {} %1)\n                            (map-indexed\n                              (fn [rown row]\n                                  (map\n                                    (fn [[k coll]]\n                                      [k (map (fn [[coln _]] [rown coln]) coll)])\n                                    (group-by second (map-indexed #(apply list %&) row))))\n                                board))))]\n    (fn [board]\n      (let [board (dissoc (grouped-board board) :e)]\n        (some (fn [[k pos]]\n                (when (or (row-win-across pos)\n                          (row-win-down pos)\n                          (row-win-diag pos))\n                  k)) board)))))","user":"51dafedee4b09f6bc204eee2"},{"code":"(fn [matrix] \n  (let [at-pos #(for [p %] ((vec (flatten matrix)) p))\n        streaks (map at-pos [[0 1 2] [3 4 5] [6 7 8] \n                             [0 3 6] [1 4 7] [2 5 8]\n                             [0 4 8] [2 4 6]])]\n   (some {[:x :x :x] :x [:o :o :o] :o} streaks)))","problem":73,"user":"4f3976aee4b0e243712b1eea"},{"problem":73,"code":"(fn tic-tac-toe-checker [board]\n  (letfn [(check [v b] (not-every? false? (map #(every? (fn [b] (= v b)) %) b)))\n          (row? [v] (check v board))\n          (column? [v] (check v (apply map vector board)))\n          (cross? [v] (check v [\n                                [(first (first board)) (second (second board)) (nth (nth board 2) 2)]\n                                [(nth (first board) 2) (second (second board)) (first (nth board 2) )]]))\n          (win? [v] (if (or (row? v) (column? v) (cross? v)) v nil))]\n    (or (win? :x) (win? :o))))","user":"5c20b6abe4b07e362c230576"},{"problem":73,"code":"(fn check-board [board]\n  (let [not-nil? (comp not nil?)\n        winner (fn winner [line]\n          (if (and (apply = line) (not= (first line) :e))\n            (first line)\n            nil))\n        check-lines (fn [lines]\n          (first (filter (comp not nil?) (map winner lines))))\n        rows (check-lines board)\n        columns (check-lines (map (fn [r] (map #(% r) board)) [0 1 2]))\n        diagonal1 (winner (map #((board %) %) [0 1 2]))\n        diagonal2 (winner (map #((board %) (- 2 %)) [0 1 2]))]\n    (cond (not-nil? rows) rows\n          (not-nil? columns) columns\n          (not-nil? diagonal1) diagonal1\n          (not-nil? diagonal2) diagonal2)))","user":"550b5c10e4b06e50f9beb143"},{"code":"(fn [b]\n  (letfn [(win [[a b c]] (if (= a b c) (#{:x :o} a)))]\n    (or (some win b)\n        (some win (apply map list b))\n        (win (map #((b %) %) [0 1 2]))\n        (win (map #((b %) (- 2 %)) [0 1 2])))))","problem":73,"user":"4e8612f8535db62dc21a62f2"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (let [rows [[a b c]\n              [d e f]\n              [g h i]\n              [a d g]\n              [b e h]\n              [c f i]\n              [a e i]\n              [g e c]]\n        won? (fn [mark]\n               (some #(apply = mark %) rows))]\n    (cond\n      (won? :x) :x\n      (won? :o) :o\n      :else nil)))","user":"5d27da09e4b092dab7f59c75"},{"problem":73,"code":"(fn [[[a _ c] \n      [_ e _] \n      [h _ j] :as r]]\n  (some {[:x :x :x] :x [:o :o :o] :o} \n        (concat r (apply map vector r) [[a e j][c e h]])))","user":"595eba88e4b066ee0a44b04e"},{"code":"(fn [board]\r\n  (let [rows\r\n    (reduce into \r\n        #{} \r\n\t      [board \r\n\t       ((apply juxt (map (partial partial map) [first second last])) board) \r\n\t       [[(first (first board)) (second (second board)) (last (last board))]\r\n\t        [(first (last board)) (second (second board)) (last (first board))]]])\r\n    ]\r\n    (cond (contains? rows [:x :x :x]) :x\r\n          (contains? rows [:o :o :o]) :o\r\n          :else nil)))","problem":73,"user":"4dcd818e535d5973398f929d"},{"code":"(fn tic-tac-toe [rows]\n  (let [[row1 row2 row3] rows\n        col1 (map first rows)\n        col2 (map second rows)\n        col3 (map #(nth % 2) rows)\n        dia1 [(first row1) (second row2) (nth row3 2)]\n        dia2 [(nth row1 2) (second row2) (first row3)]\n        lines [row1 row2 row3 col1 col2 col3 dia1 dia2]\n        isx? #(= :x %) iso? #(= :o %)]\n    (cond\n     (some true? (map #(every? isx? %) lines)) :x\n     (some true? (map #(every? iso? %) lines)) :o\n     true nil)))","problem":73,"user":"529ce629e4b04e0c58e87b6e"},{"problem":73,"code":"(fn [g]\n    (let [diagonals      [[(get-in g [0 0]) (get-in g [1 1]) (get-in g [2 2])]\n                          [(get-in g [0 2]) (get-in g [1 1]) (get-in g [2 0])]]\n          winning-combos (concat g (apply map vector g) diagonals)]\n      (some {[:x :x :x] :x [:o :o :o] :o} winning-combos)))","user":"4ee6400c535d93acb0a6685b"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n (cond\n (and (= a b c) (not= a :e)) a\n (and (= d e f) (not= d :e)) d\n (and (= g h i) (not= g :e)) g\n (and (= a d g) (not= a :e)) a\n (and (= b e h) (not= b :e)) b\n (and (= c f i) (not= c :e)) c\n (and (= a e i) (not= a :e)) a\n (and (= c e g) (not= c :e)) c\n :else nil ))","user":"5522cd9ae4b0882d96d091ab"},{"code":"(fn [board] (let [winning-row-fn\n                         (fn [row]\n                             (if (= (count (distinct row)) 1)\n                                 (let [won (first row)]\n                                   (if (= won :e)\n                                       nil\n                                     won))\n                               nil))]\n              \n                               (let [the-whole-thing (filter (complement nil? ) (flatten (conj (apply map\n                               (fn [n1 n2 n3] (winning-row-fn (map #(nth %2 %1) [n1 n2 n3] board))) [[0 2 0 1 2] [1 1 0 1 2] [2 0 0 1 2]])\n                               (map winning-row-fn board))))]\n                               (if (empty? the-whole-thing) nil (first the-whole-thing)))))","problem":73,"user":"50abb8cde4b01d6eb43ce9ad"},{"problem":73,"code":"(let [rows      identity\n      cols      (fn [board]\n                  (partition 3 (apply interleave board)))\n      diagonals (fn [[r1 r2 r3]]\n                  [\n                   [(first r1) (second r2) (last r3)]\n                   [(first r3) (second r2) (last r1)]\n                  ])\n      winner    (fn [line]\n                  (cond\n                   (every? #(= :x %) line) :x\n                   (every? #(= :o %) line) :o\n                   :else nil))]\n(fn [board]\n  (or\n   (some winner (rows board))\n   (some winner (cols board))\n   (some winner (diagonals board)))))","user":"51d46747e4b013d740b70de3"},{"problem":73,"code":"(fn ttt [b]\n    (let [g [(map first b)\n             (map second b)\n             (map last b)\n             (first b)\n             (second b)\n             (last b)\n             [(first (first b)) (second (second b)) (last (last b))]\n             [(first (last b)) (second (second b)) (last (first b))]]]\n      (if (some #(= [:x :x :x] %) g)\n        :x\n        (if (some #(= [:o :o :o] %) g)\n          :o\n          nil))))","user":"579693d4e4b039eba2ecb0e7"},{"problem":73,"code":"(fn [rows]\n    (let [indices (range (count rows))\n          all (-> (apply conj rows (apply map vector rows))\n                  (conj (map nth rows indices)\n                        (map nth rows (reverse indices))))]\n      (ffirst (filter #(and (not (= [:e :e :e] %))\n                            (apply = %)) all))))","user":"538ca203e4b0b51d73faae5f"},{"problem":73,"code":"(fn [board]\n  (letfn [(row [board n]\n               (nth board n))\n          (col [board n]\n               (map #(nth % n) board))\n          (left-diag [board]\n                     [(nth (row board 0) 0)\n                      (nth (row board 1) 1)\n                      (nth (row board 2) 2)])\n          (right-diag [board]\n                      [(nth (row board 0) 2)\n                       (nth (row board 1) 1)\n                       (nth (row board 2) 0)])\n          (x? [s]\n              (every? (partial = :x) s))\n          (o? [s]\n              (every? (partial = :o) s))\n          (win? [board player]\n                (let [wf (if (= player :x) x? o?)]\n                  (or\n                   (wf (row board 0))\n                   (wf (row board 1))\n                   (wf (row board 2))\n                   (wf (col board 0))\n                   (wf (col board 1))\n                   (wf (col board 2))\n                   (wf (left-diag board))\n                   (wf (right-diag board)))))]\n         (cond\n          (win? board :x) :x\n          (win? board :o) :o\n          :else nil)))","user":"565131b3e4b0f29ec07d2e88"},{"problem":73,"code":"(fn [coll]\n(some\n     #(if (apply = %) (#{:x :o} (first %)) nil)\n     (concat coll\n             (partition (count coll) (apply interleave coll))\n             [(map #(nth (nth coll %) %) (range (count coll)))\n              (map #(nth (nth coll %) (- (count coll) 1 %)) (range (count coll)))])))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":73,"code":"(fn gen-winner\n   [m]\n   (letfn [(win?\n             [player xs]\n             (some #(apply = player %) xs))\n           (winner?\n             [player]\n             (when (or\n                     (win? player m)\n                     (win? player (apply map #(vec %&) m))\n                     (win? player (let [sz (count m)]\n                             [(for [i (range sz)]\n                                ((m i) i))\n                              (for [i (range sz)]\n                                ((m i) (- sz i 1)))])))\n               player))]\n     (or (winner? :x)\n         (winner? :o))))","user":"56a36f76e4b0542e1f8d14ca"},{"problem":73,"code":"(fn [t]\n  (let [lines [[0 1 2] [3 4 5] [6 7 8]\n               [0 3 6] [1 4 7] [2 5 8]\n               [0 4 8] [6 4 2]]\n        t (flatten t)\n        getp #(nth t %)\n        answer? (fn [k line] (every? #(= k (getp %)) line))]\n    (cond\n      (some true? (map #(answer? :x %) lines)) :x\n      (some true? (map #(answer? :o %) lines)) :o\n    )))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn [board]\n  (cond \n    (= ((board 0) 0) ((board 0) 1) ((board 0) 2) :x)\n    ((board 0) 0)\n    (= ((board 1) 0) ((board 1) 1) ((board 1) 2) :x)\n    ((board 1) 0)\n    (= ((board 2) 0) ((board 2) 1) ((board 2) 2) :x)\n    ((board 2) 0)\n    (= ((board 0) 0) ((board 1) 0) ((board 2) 0) :x)\n    ((board 0) 0)\n    (= ((board 0) 1) ((board 1) 1) ((board 2) 1) :x)\n    ((board 0) 1)\n    (= ((board 0) 2) ((board 1) 2) ((board 2) 2) :x)\n    ((board 0) 2)\n    (= ((board 0) 0) ((board 1) 1) ((board 2) 2) :x)\n    ((board 0) 0)\n    (= ((board 0) 2) ((board 1) 1) ((board 2) 0) :x)\n    ((board 0) 2)\n\n    (= ((board 0) 0) ((board 0) 1) ((board 0) 2) :o)\n    ((board 0) 0)\n    (= ((board 1) 0) ((board 1) 1) ((board 1) 2) :o)\n    ((board 1) 0)\n    (= ((board 2) 0) ((board 2) 1) ((board 2) 2) :o)\n    ((board 2) 0)\n    (= ((board 0) 0) ((board 1) 0) ((board 2) 0) :o)\n    ((board 0) 0)\n    (= ((board 0) 1) ((board 1) 1) ((board 2) 1) :o)\n    ((board 0) 1)\n    (= ((board 0) 2) ((board 1) 2) ((board 2) 2) :o)\n    ((board 0) 2)\n    (= ((board 0) 0) ((board 1) 1) ((board 2) 2) :o)\n    ((board 0) 0)\n    (= ((board 0) 2) ((board 1) 1) ((board 2) 0) :o)\n    ((board 0) 2)\n    :else\n    nil\n  )\n)","problem":73,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn [coll]\n  (let [x (vec (flatten coll)) cl [[0 1 2] [3 4 5] [6 7 8]\n                            [0 3 6] [1 4 7] [2 5 8]\n                            [0 4 8] [2 4 6]]]\n    (reduce (fn [res [a b c]](if (and (= a b c) (not= a :e)) a res))\n            nil\n            (map (fn [[a b c]](vector (x a) (x b) (x c))) cl))))","problem":73,"user":"53a1b5c8e4b0ca733b9744c1"},{"problem":73,"code":"(fn [matrix]\n  (let [winner (fn [coll] (when (apply = coll) (first coll)))\n        rows   (map winner matrix)\n        cols   (map winner (apply map vector matrix))\n        diag1  (winner (map get matrix (range 3)))\n        diag2  (winner (map get matrix (range 2 -1 -1)))]\n    (some #{:x :o} (concat rows cols [diag1] [diag2]))))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"(fn f [b]\n  (letfn [(chk [a b c]\n            (cond (= a b c :e) false\n                  (= a b c :o) :o\n                  (= a b c :x) :x))]\n    (let [x \n          (filter identity (concat (map #(apply chk %) b)\n                                   [(apply chk (map first b))\n                                    (apply chk (map second b))\n                                    (apply chk (map #(first (rest %)) b))]\n                                   [(chk (first (first b))\n                                         (second (second b))\n                                         (nth (nth b 2) 2))\n                                    (chk (nth (first b) 2)\n                                         (second (second b))\n                                         (first (nth b 2)))]))]\n      (if (empty? x) nil (first x)))))","problem":73,"user":"4facd2fae4b081705acca22f"},{"problem":73,"code":"(letfn [(get-all-pos\n          ([board]\n           (->> board\n                (map-indexed (fn [i row]\n                               (map-indexed\n                                 (fn [k value] [value i k])\n                                 row)))\n                (reduce concat)))\n          ([board holder]\n           (->> board\n                get-all-pos\n                (filter (comp (partial = holder) first))\n                (map (comp vec drop) (repeat 1)))))\n\n        (all-winning-pos\n          []\n          (->> (concat (for [i (range 3) k (range 3)] [i k])        ;; wins for rows\n                       (for [i (range 3) k (range 3)] [k i])        ;; wins for columns\n                       (map vector (range 3) (range 3))             ;; wins for diagonal starting top left\n                       (map vector (range 3) (reverse (range 3))))  ;; wins for diagonal starting top right\n               (partition 3)\n               (map set)))\n\n        (winning-positions? [positions]\n          (some #(clojure.set/subset? % (set positions)) (all-winning-pos)))\n\n        (winner [board]\n          (->> [:x :o]\n               (filter (comp winning-positions? (partial get-all-pos board)))\n               first))]\n  winner)","user":"51f01925e4b0249c592fbdfc"},{"problem":73,"code":"(fn [s] (let [e (fn [[[a b c][e f g][h i j]] k]\n                  (and (or (= a b c k) (= e f g k) (= h i j k) \n                           (= a e h k) (= b f i k) (= c g j k)\n                           (= a f j k) (= c f h k))\n                       k))]\n          (or (e s :x) (e s :o) nil)))","user":"5960a1a6e4b066ee0a44b08e"},{"code":"(fn [board]\n  (let [cell-values (fn [& cells]\n                      (vec (map #(get-in board %) cells)))\n        horizontal-rows board\n        vertical-rows (apply map vector board)\n        diagonal-rows [(cell-values [0 0] [1 1] [2 2])\n                       (cell-values [0 2] [1 1] [2 0])]\n        all-rows (concat\n                  horizontal-rows\n                  vertical-rows\n                  diagonal-rows)]\n    (condp #(some #{%1} %2) all-rows\n      [:x :x :x] :x\n      [:o :o :o] :o\n      nil)))","problem":73,"user":"4e68c434535d8ccf87e9fe89"},{"problem":73,"code":"(fn [board]\n   (letfn [(row-win? [piece row] (every? (partial = piece) row))\n           (diagonals [board] (for [b [board (map reverse board)]]\n                                   (for [n (range (count b))]\n                                     (nth (nth b n) n))))]\n     (get (zipmap (for [piece [:x :o]]\n       (or\n         (some identity (map #(row-win? piece %) board))\n         (some identity (map #(row-win? piece %) (apply map vector board)))\n         (some identity (map #(row-win? piece %) (diagonals board))))) [:x :o]) true nil)))","user":"5638b88de4b0bfe05bf117e9"},{"problem":73,"code":"(fn [[a b c]]\n  (let [q (into [a b c\n                 [(first a) (second b) (last c)]\n                 [(first c) (second b) (last a)]] (map vector a b c))\n        won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n    (first (remove nil? (map won? q)))))","user":"56874171e4b0dcc4269f405c"},{"code":"(fn [board]\n (let [row-win (fn [board]\n                (let [rows (map distinct board)]\n                  (reduce\n                   (fn [winner row]\n                     (if-not (nil? winner)\n                       winner\n                       (if (and (= (count row) 1) (not= (first row) :e))\n                         (first row)\n                         nil\n                         )\n                       )\n                     )\n                   nil\n                   rows\n                   )\n                  )\n                )\n      col-win (fn [board]\n                (let [board-90 [(map first board)\n                                (map second board)\n                                (map last board)]]\n                  (row-win board-90)\n                  )\n                )\n      diag-win (fn [board]\n                 (if (= (second (second board)) :e)\n                   nil\n                   (if (= (first (first board))\n                          (second (second board))\n                          (last (last board)))\n                     (first (first board))\n                     (if (= (last (first board))\n                            (second (second board))\n                            (first (last board)))\n                       (last (first board))\n                       nil\n                       )\n                     )\n                   )\n                 )\n      ]\n  (if-let [row (row-win board)]\n    row\n    (if-let [col (col-win board)]\n      col\n      (if-let [diag (diag-win board)]\n        diag\n        nil\n        )\n      )\n    )\n   )\n  )","problem":73,"user":"52e59ca5e4b09f7907dd1464"},{"problem":73,"code":"#(let [rows %\n       cols (apply map vector %)\n       diags [(map-indexed (fn [i xs] (nth xs i)) %)\n              (map-indexed (fn [i xs] (nth xs i))\n                           (reverse %))]\n       all (concat rows cols diags)\n       finals (filter (fn [x] \n                        (cond \n                         (> (count x) 1) false\n                         (= #{:e} x) false\n                         :else true)) \n                      (map set all))]\n   (when (not (empty? finals))\n     (-> finals\n         first\n         first)))","user":"5579bc24e4b05c286339e098"},{"problem":73,"code":"(fn sol [board]\n  (let [transpose   (fn [arr] (apply map vector arr))\n        flip        (fn [arr] (map (comp vec reverse) arr))\n        condense    (fn [vect] (if (> (count (set vect)) 1)\n                                 nil\n                                  (first (set vect))))\n        condenseII  (fn [arr] (map (fn [i] ((arr i) i)) (range (count arr))))\n        determine   (fn [vect] (some\n                                (fn [item] (if (nil? item) nil item))\n                                vect))\n        winnerI     (fn [arr] (determine (map condense arr)))\n        winnerII    (fn [arr] (winnerI (transpose arr)))\n        winnerIII   (fn [arr] (condense (condenseII arr)))\n        winnerIV    (fn [arr] (condense (condenseII (vec (flip arr)))))\n        overall     (determine (map (fn [win] (win board)) [winnerI winnerII winnerIII winnerIV]))\n        ]\n    (if (= :e overall) nil overall)))","user":"578b140be4b0ebec4cfb7545"},{"problem":73,"code":"(fn [board]\n    (let [row (fn [cell] (first cell))\n          col (fn [cell] (second cell))\n          make-cell (fn [row col] [row col])\n          get-cell (fn get-cell\n                       ([cell] (get-cell (row cell) (col cell)))\n                       ([row col] (nth (nth board row) col)))\n          get-cells (fn [& cells] (map get-cell cells))\n          make-row (fn [row-num] (map #(make-cell row-num %) [0 1 2]))\n          make-col (fn [col-num] (map #(make-cell % col-num) [0 1 2]))\n          get-row (fn [row-num] (apply get-cells (make-row row-num)))\n          get-col (fn [col-num] (apply get-cells (make-col col-num)))\n          get-diag1 (fn [] (apply get-cells (map make-cell [0 1 2] [0 1 2])))\n          get-diag2 (fn [] (apply get-cells (map make-cell [2 1 0] [0 1 2])))\n          lines [(get-diag1) (get-diag2)\n                   (get-row 0) (get-row 1) (get-row 2)\n                   (get-col 0) (get-col 1) (get-col 2)]\n\n          ]\n      (first (some #(when (or (= [:x] %) (= [:o] %)) %) (map distinct lines)))))","user":"595bbab7e4b066ee0a44afe0"},{"problem":73,"code":"(fn [coll]\n  (letfn [(winner-symbols \n            [coll] \n            (first \n              (filter \n                #(or (every? #{:o} %)\n                     (every? #{:x} %))\n                coll)))\n          (index-chooser\n            [coll]\n            (keep-indexed\n               #(if (= 0 (rem %1 4)) %2)\n               (flatten coll)))]        \n    (if-let [winner-symbol (first (winner-symbols coll))]\n      winner-symbol\n      (let [adj-coll (partition 3 (apply interleave coll))]\n        (if-let [winner-symbol (first (winner-symbols adj-coll))]\n          winner-symbol\n          (let [adj-coll (partition 3 (concat (index-chooser coll)\n                                              (index-chooser (reverse coll))))]\n            (if-let [winner-symbol (first (winner-symbols adj-coll))]\n              winner-symbol\n              nil)))))))","user":"4de18de7535d08e6dec9fde8"},{"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (ffirst (filter #(and (= (first %) (second %) (last %)) (= 3 (count %))) (map (fn [ls] (filter #(not (= :e %)) ls)) (list [a b c] [d e f] [g h i] [a d g] [c f i] [b e h] [a e i] [c e g])))))","problem":73,"user":"5301157ae4b0d8b024fd3717"},{"problem":73,"code":"(fn analyze-tic-tac-toe-board [board]\n   (let [hor? (fn [char board]\n                (if (empty? board)\n                  false\n                  (let [line (first board)]\n                    (if (every? #(= char %) line)\n                      true\n                      (recur char (rest board))))))\n         ver? (fn [char board]\n                (hor? char (partition 3 (apply interleave board))))\n         diag-lr? (fn [char board]\n                    (every? #(= char %) (reduce #(conj %1 (nth %2 (count %1))) [] board)))\n         diag-rl? (fn [char board]\n                    (every? #(= char %) (reduce #(conj %1 (nth %2 (- 2 (count %1)))) [] board)))\n         won? (fn [char] (not-every? #(= false %) (map #(% char board) [hor? ver? diag-lr? diag-rl?])))]\n     (if (won? :x) :x (when (won? :o) :o))))","user":"5c3f37fce4b08cd430848e91"},{"problem":73,"code":"(fn tic-tac-toe [field]\n  (let [transposed-field (apply map #(vector %1 %2 %3) (seq field))\n        lanes (concat\n                (seq field)\n                transposed-field\n                (list (vector ((field 2) 0) ((field 1) 1) ((field 0) 2)))\n                (list (vector ((field 0) 0) ((field 1) 1) ((field 2) 2))))\n        ]\n    (some (fn [lane]\n            (cond (every? #(= :x %) lane) :x\n                  (every? #(= :o %) lane) :o\n                  :else nil\n                  )\n            ) lanes)\n    )\n  )","user":"5488872ee4b0e286459a11d3"},{"problem":73,"code":"(fn [board]\n   (let [coll (flatten board)\n         lining? (fn [p l] (every? #(= p (nth coll %)) l))\n         lines [[0 1 2] [3 4 5] [6 7 8]\n                [0 3 6] [1 4 7] [2 5 8]\n                [0 4 8] [2 4 6]]]\n     (letfn [(has-won? [mark]\n               (some (partial lining? mark) lines))]\n          (cond\n            (has-won? :x) :x\n            (has-won? :o) :o\n            :else nil))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":73,"code":"(fn [bd]\n  (let [one? (partial = 1)\n        won? (fn [row] (and (->> row set count one?)\n                            (not (= :e (first row)))))\n        winner (fn [row] (when (won? row) (first row)))\n        dim (count bd)\n        rows bd\n        get-cols #(apply map vector %)\n        cols (get-cols bd)\n        diags-idx (get-cols (for [n (range dim)]\n                              [[n n] [n (- (dec dim) n)]]))\n        nmth #(get (get bd (first %)) (second %))\n        diags (vector (map nmth (first diags-idx))\n                      (map nmth (second diags-idx)))\n        all (concat rows cols diags)]\n    (first (filter #(not (nil? %)) (map winner all)))))","user":"5f90aeefe4b0715f5002d799"},{"problem":73,"code":"(fn [board] \n\t(let [\n\t\tb-cols (apply map vector board)\n\t\tb-diag (map-indexed #(%2 %1) board)\n\t\tb-r-diag (map-indexed #(nth (rseq %2) %1) board)\n\t\tb-rows (into #{} (concat board b-cols [b-diag b-r-diag]))\n\t]\n\t(cond \n\t\t(contains? b-rows [:x :x :x]) :x\n\t\t(contains? b-rows [:o :o :o]) :o\n\t\t)\n))","user":"56d80542e4b0ea9b8538f7e1"},{"code":"(fn [[u v w :as x]] \n  (let [t (apply map vector x)\n  \t\tl (concat x t [[(u 0) (v 1) (w 2)] [(u 2) (v 1) (w 0)]])]\n\t(if (some #(= [:x :x :x] %) l) :x\n      (if (some #(= [:o :o :o] %) l) :o nil))))","problem":73,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":73,"code":"(fn [data]\n   (let [check-win (fn [x] (if (every? #(= % (first x)) (rest x)) (first x)))\n         column->row (fn [x] (map (fn [n] (map #(nth % n) x)) [0 1 2]))\n         diag1 (fn [x]\n                 (list (list (nth (nth x 0) 0)\n                             (nth (nth x 1) 1)\n                             (nth (nth x 2) 2))))\n         diag2 (fn [x]\n                 (list (list (nth (nth x 2) 0)\n                             (nth (nth x 1) 1)\n                             (nth (nth x 0) 2))))]\n     (first (filter #(and (not (nil? %)) (not= :e %))\n                    (concat (map check-win data)\n                            (map check-win (column->row data))\n                            (map check-win (diag1 data))\n                            (map check-win (diag2 data)))))\n     ))","user":"57c314f3e4b05aa3c4741cba"},{"code":"(fn tic-tac-analyse [board]\n  (let [rows board\n        cols (map (fn [i] (map #(nth % i) board)) (range 3))\n        d1 (map #(get-in board %) (for [i (range 3)] [i i]))\n        d2 (map #(get-in board %) (for [i (range 3)] [i (- 2 i)]))\n        result (filter #(or (= [:x :x :x] %) (= [:o :o :o] %)) (concat rows cols (list d1 d2)))]\n    (first (first result))))","problem":73,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":73,"code":"(fn [b] \n  (let [c #(if (and (apply = %) (not= (first %) :e)) (first %) nil)\n        e #(get-in b [%1 %2])]\n  (first (remove nil? (map c (concat b \n                                     (apply mapv vector b) \n                                     [[(e 0 0) (e 1 1) (e 2 2)] [(e 0 2) (e 1 1) (e 2 0)]]))))))","user":"577202d2e4b0979f896515c0"},{"code":"(fn [b]\n  (letfn\n    [\n      (pos [k] (reduce #(+ %1 %1 (if (= %2 k) 1 0)) 0 (flatten b)))\n      (win [k] (some #(= (bit-and (pos k) %1) %1) '(0700 0070 0007 0444 0222 0111 0421 0124)))\n    ]\n    (if (win :x) :x (if (win :o) :o nil))\n  )                     \n)","problem":73,"user":"5176afd2e4b085adf681d889"},{"problem":73,"code":"(fn [xy]\n  (some identity\n        (map #(cond\n               (every? #{:x} %) :x\n               (every? #{:o} %) :o\n               :else nil)\n             (concat\n              (for [r xy] r)\n              (map #(for [r xy] (nth r %)) (range 3))\n              [(map #(nth (nth xy %) %) (range 3))]\n              [(map #(nth (nth xy (- 2 %)) %) (range 3))]))))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":73,"code":"(fn [b] (first (filter #(not (nil? %)) (map #(ffirst (filter (fn [r] (or (every? (fn [e] (= ':x e)) r) (every? (fn [e] (= ':o e)) r))) %)) [b (apply map vector b) (map (fn [r] (map #(nth (flatten b) %) r)) [[0 4 8] [2 4 6]])]))))","user":"52d954cae4b09f7907dd13a5"},{"code":"(fn [[r1 r2 r3 :as rows]]\n            (let [board (concat rows\n                                (apply map vector rows)\n                                [[(r1 0) (r2 1) (r3 2)]\n                                 [(r1 2) (r2 1) (r3 0)]])]\n              (some {[:x :x :x] :x, [:o :o :o] :o} board)))","problem":73,"user":"4ed0e139535d44c135fd68c7"},{"code":"(fn [b]\n  (let [rows identity\n        cols (fn [b]\n               (apply map list b))\n        diag (fn [b]\n               (let [f (partial map #(%1 %2) b)]\n                 (list (f (range))\n                       (f (reverse (range 3))))))\n        in-a-row? (fn [[x & xs]]\n                    (when (and (not= x :e)\n                               (= #{x} (set xs)))\n                      x))]\n    (some in-a-row? (concat (rows b) (cols b) (diag b)))))","problem":73,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":73,"code":"(fn [board]\n    (let [mark-pos (fn [board mark]\n                     (for [row (range 0 3)\n                           column (range 0 3)\n                           :let [curr-mark ((board row) column)]\n                           :when (= curr-mark mark)]\n                       [row column]))\n          axis-win? (fn [axis-info] (some #(= 3 (count %)) (vals axis-info)))\n          diagonal-win? (fn [coll]\n                          (and (= (map first coll) (range 0 3))\n                               (or (= (map last coll) (range 0 3))\n                                   (= (map last coll) (range 2 -1 -1)))))\n          win? (fn [coll]\n                 (let [xaxis-info (group-by first coll)\n                       yaxis-info (group-by last coll)]\n                   (cond\n                     (< (count coll) 3) nil\n                     (axis-win? xaxis-info) xaxis-info\n                     (axis-win? yaxis-info) yaxis-info\n                     (diagonal-win? coll) coll\n                     :else nil)))]\n      (cond\n        (win? (mark-pos board :x)) :x\n        (win? (mark-pos board :o)) :o\n        :else nil)))","user":"58bbcbc8e4b0888cdc949d00"},{"problem":73,"code":"(fn [board] \n  (let [inc-index (take 3 (iterate inc 0))\n        pair-dec (partition 2 (interleave inc-index inc-index))\n        pair-asc (partition 2 (interleave inc-index (reverse inc-index)))\n        perms (concat\n                board\n                (vector (reduce (fn [coll pair-dec] (conj coll (get-in board pair-dec)))\n                                []\n                                pair-dec))\n                (vector (reduce (fn [coll pair-dec] (conj coll (get-in board pair-dec)))\n                                []\n                                pair-asc))\n                (apply map vector board))]\n    (letfn \n      [(win? [e]\n             (some true? (map #(every? #{e} %) perms)))]\n      (cond\n        (win? :x) :x\n        (win? :o) :o\n        :else nil))))","user":"57c0393be4b05aa3c4741c90"},{"code":"(fn [board]\n   (let [rows board\n         items (flatten board)\n         col1 (take-nth 3 items)\n         col2 (take-nth 3 (rest items))\n         col3 (take-nth 3 (drop 2 items))\n         d1 (take-nth 4 items)\n         d2 (butlast (take-nth 2 (drop 2 items)))\n         lines (conj rows col1 col2 col3 d1 d2)\n         line_el (map set lines)]\n     (first (filter (comp not nil?)\n            (map #(if (and\n                        (= 1 (count %))\n                        (or (= :x (first %))\n                           (= :o (first %))))\n                    (first %)) line_el)))))","problem":73,"user":"4f35e662e4b0e243712b1ec6"},{"code":"(fn [coll] (let [ttt-cols?  (fn a[e coll] (if (apply = (conj (map first coll) e)) true (if (some empty? coll) false (a e (map rest coll))))) ttt-rows?  (fn [e coll] (some identity  (map #(apply = (conj % e)) coll))) ttt-diagonals?  (fn [e coll] (if (apply = (conj (map-indexed #(nth %2 %1) coll) e)) true (apply = (conj (map-indexed #(nth %2 (- (dec (count coll)) %1)) coll) e)))) ] (if (some identity ((juxt ttt-cols? ttt-diagonals? ttt-rows?) :x coll)) :x (if (some identity ((juxt ttt-cols? ttt-diagonals? ttt-rows?) :o coll)) :o nil))))","problem":73,"user":"51db27dbe4b094966a2cd688"},{"problem":73,"code":"(fn [a] (let [b (into a (apply map vector a))\n               c  (conj b (map #(get % %2) a [0 1 2]))\n               d  (conj c (map #(get % %2) a [2 1 0]))\n               e (mapcat #(cond (= % [:x :x :x]) [:x]\n                                (= % [:o :o :o]) [:o]\n                                :else nil) d)]\n           (if (some #(= % :x) e) :x\n                                  (if (some #(= % :o) e) :o nil))))","user":"5a6dbaf5e4b0512ff01cda63"},{"problem":73,"code":"(fn f [board]\n  (let [n 3 ;number of consecutive :x or :o to win\n        r (range (count board)) ;valid indices\n        m (last r) ;board max index\n        ;horizontal, vertical and diagonal rows\n        rows (concat board\n                     (apply mapv vector board)\n                     ;diagonal rows only for 3x3 board\n                     [(for [i r] (get-in board [i i]))]\n                     [(for [i r] (get-in board [(- m i) i]))])] \n    (->> rows\n         (mapcat #(partition-by identity %))\n         (map #(vector (count %) (first %)))\n         (#(cond (some #{[n :x]} %) :x\n                 (some #{[n :o]} %) :o\n                 :else nil)))))","user":"57adbe7ee4b0b8559636fca0"},{"problem":73,"code":"(fn tictac\n  ([result]\n   (tictac (flatten result) [[0 1 2], [3 4 5], [6 7 8], [0 3 6], [1 4 7], [2 5 8], [0 4 8], [2 4 6]])\n   )\n  ([result win_sets]\n   (if (first win_sets)\n     (let [win_set (first win_sets)\n           sub_result [(nth result (win_set 0)) (nth result (win_set 1)) (nth result (win_set 2)) ] ]\n       (cond\n         (= sub_result [:o :o :o]) :o\n         (= sub_result [:x :x :x]) :x\n         :else (tictac result (rest win_sets))\n         )\n       )\n     nil)\n   )\n  )","user":"574ed2f7e4b02ea11479924a"},{"problem":73,"code":"(fn tic-tac-toe [board] (let [\n    horz-dominance (map distinct board)\n    vert-dominance (apply map (comp distinct vector) board)\n    diag-dominance (map distinct [\n        [(ffirst board) (second (second board)) (last (last board))]\n        [(last (first board)) (second (second board)) (first (last board))]])\n    all-dominance (set (concat horz-dominance vert-dominance diag-dominance))]\n    (println all-dominance)\n    (cond \n        (contains? all-dominance '(:x)) :x\n        (contains? all-dominance '(:o)) :o\n        :else nil)))","user":"5da05bcce4b000c986472bd0"},{"problem":73,"code":"(fn [board]\n  (let [board (mapv #(mapv {:x 1 :o -1 :e 0} %) board)\n        win-x (some #{3 -3} (lazy-cat\n                             (apply map + board)\n                             (apply map + (apply map vector board))\n                             [(apply + (map get board [0 1 2]))\n                              (apply + (map get board [2 1 0]))]))]\n    (condp = win-x\n      3 :x\n      -3 :o\n      nil)))","user":"5393185ae4b0b51d73faaeb7"},{"code":"(fn [grid] \n  (let [rows grid\n        cols (map #(into [] %) (partition 3 3 (apply interleave grid)))\n        diag1 (into [] (map-indexed #(nth %2 %1) rows))\n        diag2 (into [] (map-indexed #(nth (reverse %2) %1) rows))\n        moves (conj (concat rows cols) diag1 diag2)\n        winner (map #(if (and (= 1 (count (distinct %)))\n                              (not= :e (first %)))\n                       (first %) \n                       nil) \n                    moves)]\n    (first (remove nil? winner))))","problem":73,"user":"53286389e4b09d4e7a9b5504"},{"code":"(fn [b]\n  (some (fn [l] \n          (let [trinca (map #(get-in b %) l)]\n            (cond \n             (apply = :o trinca) :o\n             (apply = :x trinca) :x\n             :else nil)))\n          (conj \n           (concat \n            (map #(map (partial vector %) \n                       (range 0 3)) \n                 (range 0 3))\n            (map #(map (fn [l] \n                         (vector l %)) \n                       (range 0 3)) \n                 (range 0 3)))\n           (list [0 0] [1 1] [2 2])\n           (list [0 2] [1 1] [2 0]))))","problem":73,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn [v]\n  (->> (-> (apply map (fn [x1 x2 x3] [x1 x2 x3]) v)\n           (#(into % v))\n           vec\n           (conj (first (reduce (fn [[a i] x] [(conj a (nth x i)) (inc i) ]) [[] 0] v)))\n           (conj (first (reduce (fn [[a i] x] [(conj a (nth x i)) (dec i) ]) [[] 2] v)))\n           )\n\n       (filter #(apply = %))\n       first\n       first\n       (#(if (= % :e) nil %))\n       ))","problem":73,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":73,"code":"(fn [[[ax ay az]\n           [bx by bz]\n           [cx cy cz]]]\n  (let [lines [[ax ay az]\n               [bx by bz]\n               [cx cy cz]\n               [ax bx cx]\n               [ay by cy]\n               [az bz cz]\n               [ax by cz]\n               [cx by az]]]\n    (cond\n      (some #(= [:x :x :x] %) lines) :x\n      (some #(= [:o :o :o] %) lines) :o)))","user":"5da5a1eee4b000c986472c04"},{"problem":73,"code":"(fn who-won [da-board]\n  (letfn [(horizontal [sym da-board]\n            (some true? (map (fn [line] (every? #(= sym %) line))  da-board)))\n          (vertical [sym da-board] (horizontal sym (apply map list da-board)))\n          (diagonal [sym da-board]\n            (let [idx [[[0 0] [1 1] [2 2]]\n                       [[0 2] [1 1] [2 0]]]\n                  diagonals (map (fn [diag] (map #(get-in da-board %) diag)) idx)]\n              (horizontal sym diagonals) ))\n          (won? [sym]\n            (some true? (map #(% sym da-board) [horizontal vertical diagonal])))]\n    (cond\n      (won? :x) :x\n      (won? :o) :o\n      :else     nil)))","user":"580d2788e4b0849f6811b730"},{"problem":73,"code":"(fn [board]\n  (let [size (count board)\n        rows board\n        columns (lazy-seq (for [j (range size)]\n                  (map #(nth % j) rows)))\n        diag1 (lazy-seq (map #(nth %1 %2) rows (range size)))\n        diag2 (lazy-seq (map #(nth %1 (- size %2 1)) rows (range size)))\n        analyze (fn[grp]\n                  (if (= 1 (count (into #{} grp))) \n                    (if (= :e (first grp)) nil (first grp))\n                    nil))]\n    (ffirst (drop-while #(not (analyze %)) (lazy-seq (concat rows columns [diag1] [diag2]))))))","user":"5472cba1e4b094393f72dd7a"},{"code":"(fn [m]\n  (let [\n    row (fn [r k] (every? #(= % k) r))\n    diag (fn [m k]\n      (every? #(= (nth (nth m %) %) k) [0 1 2]))\n    transp (fn transp [m] (apply map vector m))\n    some-row (fn [m k] (some #(row % k) m))\n    wins (fn [m k]\n      (or\n        (some-row m k)\n        (some-row (transp m) k)\n        (diag m k)\n        (diag (reverse m) k)))]\n    (cond (wins m :x) :x\n          (wins m :o) :o\n          :else nil)))","problem":73,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn tictac [board]\n  (letfn [(hor? [[a & b]] \n                        (cond \n                            (nil? a) nil\n                            (and (not= :e (first a)) (apply = a)) (first a)\n                            :else (hor? b)))\n\n\n          (ver? [b] (hor? (for [i (range (count b))] (map #(nth % i) b))))\n          (diag? [b]\n              (let [nor\n                (map (fn [[i v]] (nth v i)) (map vector (range) b))]\n              (if (and (not= (first nor) :e) (apply = nor)) (first nor) nil)))\n            ]\n  (or (hor? board)\n      (ver? board)\n      (diag? board)\n      (diag? (map reverse board))\n    )))","problem":73,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn [t]\n     (->> [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n          (map #(map nth t %))\n          (concat t)\n          (some (fn [r] (some #(when (= [% % %] r) %) [:x :o])))))","problem":73,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn [b]\r\n  ((fn [xs]\r\n    (let [k (map (fn [[x y]] ((b y) x)) (first xs))]\r\n      (if (empty? xs) nil\r\n        (cond (every? #(= :o %) k) :o\r\n              (every? #(= :x %) k) :x\r\n              :default (recur (rest xs))))))\r\n    [[[0 0][0 1][0 2]] [[1 0][1 1][1 2]] [[2 0][2 1][2 2]]\r\n     [[0 0][1 0][2 0]] [[0 1][1 1][2 1]] [[0 2][1 2][2 2]]\r\n     [[0 0][1 1][2 2]] [[0 2][1 1][2 0]]]))","problem":73,"user":"4dc1ee85535d020aff1edf91"},{"code":"(fn ttt [s]\n  (let [ board (concat s\n                (apply map #(conj [] %1 %2 %3) s)\n                (conj [] (conj [] (nth (first s) 0) (nth (second s) 1) (nth (second (rest s)) 2)))\n                (conj [] (conj [] (nth (first s) 2) (nth (second s) 1) (nth (second (rest s)) 0)))\n                      )]\n    (first (reverse (sort (map #(if (and (= 1 (count (set %))) (not= (first %) :e) ) (first %)) board))))\n  )\n)","problem":73,"user":"4dd1de4d535dae65d5c462d7"},{"code":"(fn score-board [board]\n    (let [winning-lines [[0 1 2]\n                    [3 4 5]\n                    [6 7 8]\n                    \n                    [0 3 6]\n                    [1 4 7]\n                    [2 5 8]\n                    \n                    [0 4 8]\n                    [2 4 6]]]\n    (letfn [(is-line-same-player? [board line]\n                  \"Returns :x or :o if all locations given by line are marked\n                   by that player. Returns nil otherwise.\"\n                  (reduce (fn [prev curr]\n                            (cond\n                              (= curr :e) nil\n                              (= prev :unset) curr\n                              (= prev curr) curr\n                              (nil? prev) nil\n                              :else nil))\n                          :unset\n                          (map #(board-index board %) line)))\n            (board-index [board idx]\n                  \"Indexes into a board and returns the mark at that location.\n                   [[0 1 2]\n                    [3 4 5]\n                    [6 7 8]]\"\n                  (let [row (quot idx 3)\n                        col (rem idx 3)]\n                    (get-in board [row col])))]\n    (some #{:x :o} (map #(is-line-same-player? board %) winning-lines)))))","problem":73,"user":"4fbc0011e4b081705acca2f0"},{"code":"(fn [[row1 row2 row3]]\n  (let [col1 [(nth row1 0) (nth row2 0) (nth row3 0)]\n        col2 [(nth row1 1) (nth row2 1) (nth row3 1)]\n        col3 [(nth row1 2) (nth row2 2) (nth row3 2)]\n        dia1 [(nth row1 0) (nth row2 1) (nth row3 2)]\n        dia2 [(nth row1 2) (nth row2 1) (nth row3 0)]]\n    (first\n     (filter #{:o :x}\n             (map #(if (and (not= (first %) :e) (apply = %)) (first %))\n             [row1 row2 row3 col1 col2 col3 dia1 dia2])))))","problem":73,"user":"50589113e4b06522596eba7f"},{"code":"(fn [m]\n  (letfn [(S [[r c]]\n            (nth (nth m r) c))\n\n          (X [v]\n            (= [:x :x :x] (map S v)))\n\n          (O [v]\n            (= [:o :o :o] (map S v)))]\n    \n    (let [l [[[0 0] [0 1] [0 2]]\n             [[1 0] [1 1] [1 2]]\n             [[2 0] [2 1] [2 2]]\n             [[0 0] [1 0] [2 0]]\n             [[0 1] [1 1] [2 1]]\n             [[0 2] [1 2] [2 2]]\n             [[0 0] [1 1] [2 2]]\n             [[0 2] [1 1] [2 0]]]]\n      (cond (some X l) :x\n            (some O l) :o\n            :else nil))))","problem":73,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn [board]\n  (let [win? (fn [combos player] (not (nil? (some (fn [c] (every? (fn [cell] (= cell player)) c)) combos))))\n        win-by-row? (fn [rows player] (win? rows player))\n        win-by-column? (fn [[r1 r2 r3] player] (let [columns (map vector r1 r2 r3)] (win? columns player)))\n        win-by-diagonal? (fn [[[d11 _ d21] [_ dc _] [d22 _ d12]] player] (win? [[d11 dc d12] [d21 dc d22]] player))\n        win-player? (fn [player] \n                      (not (nil? (some true? (map (fn [win-fn] (win-fn board player)) [win-by-row? win-by-column? win-by-diagonal?])))))]\n\t(cond\n\t\t(win-player? :x) :x\n\t\t(win-player? :o) :o\n\t\t:else nil)))","problem":73,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":73,"code":"(fn who-won [rows]\n  (let [colls (apply map list rows)\n        diagnol (fn [rows] (map-indexed #(nth %2 %1) rows))\n        diags [(diagnol rows) (diagnol (reverse rows))]]\n    (->> (concat rows colls diags)\n         (map set)\n         (some #{#{:x} #{:o}})\n         first)))","user":"4f030cff535dcb61093f6a4d"},{"problem":73,"code":"(fn answer [board]\n  (let [original board\n        rotated (apply map list board)\n        diagonals [(map-indexed (fn [i x] (nth x i)) board)\n                   (map-indexed (fn [i x] (nth x (- 2 i))) board)\n                   [:e :e :e]]\n        possibles (filter #(and (not (= [:e] %)) (= 1 (count %)))\n                          (map distinct (concat original rotated diagonals)))]\n    (ffirst possibles)))","user":"5d9c9446e4b0eb781811cdae"},{"problem":73,"code":"(fn tic-tac [board]\n  (let [cols (map #(map % board) [first second last])\n        d1 (for [x [[0 0] [1 1] [2 2]]] (get-in board x))\n        d2 (for [x [[0 2] [1 1] [2 0]]] (get-in board x))\n        colls (concat board cols [d1 d2])\n        check (fn [sym]     ;; checks whether sym exists completely \n                (some true? ;; in one coll of colls\n                   (map (fn [coll] (every? #(= % sym) coll)) \n                        colls)))]\n    (cond\n      (check :x) :x\n      (check :o) :o\n      :else nil)))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"(fn [[a b c :as bd]]\n         (letfn [(e? [k x y z]\n                   (when (or (every? #(= k %) x)\n                             (every? #(= k %) y)\n                             (every? #(= k %) z))\n                     k))\n                 (r? [k]\n                   (e? k a b c))\n                 (c? [k]\n                   (e? k\n                       (map first bd)\n                       (map second bd)\n                       (map #(nth % 2) bd)))\n                 (d? [k]\n                   (e? k\n                       [(a 0) (b 1) (c 2)]\n                       [(a 2) (b 1) (c 0)]\n                       [:e]))]\n           (or (r? :x) (c? :x) (d? :x)\n               (r? :o) (c? :o) (d? :o))))","problem":73,"user":"4f301d02e4b0d6649770a072"},{"problem":73,"code":"(fn [board]\n  (let [flat (concat board\n                     (apply map vector board)\n                     [(vec (map ((comp vec flatten) board) [2 4 6]))] \n                     [(vec (map ((comp vec flatten) board) [0 4 8]))])\n        winner (fn [xo flat]\n                 (if (some true? (map #(every? #{xo} %) flat)) xo))]\n    (or (winner :x flat)\n        (winner :o flat))))","user":"56102f50e4b05f002753df6b"},{"problem":73,"code":"#(let [coords (into []\n                     (dissoc\n                      (apply merge-with concat\n                             (for [[i row] (map-indexed list %)\n                                   [j cell] (map-indexed list row)]\n                               {cell [[i j]]}))\n                      :e))\n        [[l-key l-coords] [r-key r-coords]] coords]\n    (letfn [(won3? [coords]\n              ((fn [num coords]\n                  (loop [[head & tail] coords\n                         last-x nil\n                         last-y nil\n                         last-dx nil\n                         last-dy nil\n                         last-count-x 1\n                         last-count-y 1]\n                    (let [[x y] head\n                          dx (if (nil? last-x)\n                               nil\n                               (- x last-x))\n                          dy (if (nil? last-y)\n                               nil\n                               (- y last-y))\n                          count-x (if (nil? dx)\n                                    1\n                                    (if (or\n                                         (nil? last-dx)\n                                         (and (= dx last-dx)\n                                              (<= dx 1)))\n                                      (inc last-count-x)\n                                      1))\n                          count-y (if (nil? dy)\n                                    1\n                                    (if (or\n                                         (nil? last-dy)\n                                         (and (= dy last-dy)\n                                              (<= dy 1)))\n                                      (inc last-count-y)\n                                      1))]\n                      (or\n                       (and (= count-x num)\n                            (= count-y num))\n                       (if (seq? tail)\n                         (recur tail\n                                x\n                                y\n                                dx\n                                dy\n                                count-x\n                                count-y)\n                         false)))))\n               3\n               coords))]\n      (cond\n        (won3? l-coords) l-key\n        (won3? r-coords) r-key\n        :else nil)))","user":"5ef8e9e0e4b09b61f08553cb"},{"code":"#(let [idxs  (partition 3 [0 1 2, 3 4 5, 6 7 8, 0 3 6, 1 4 7, 2 5 8, 0 4 8, 2 4 6])\n       board (reduce into %)\n       three (fn [idx] (map board idx))\n       win?  {[:x :x :x] :x [:o :o :o] :o}]\n    (some (comp win? three) idxs))","problem":73,"user":"4e9660ec535dbda64a6f6b44"},{"code":"(fn win [board]\n  (let [winpos [[1 2 3] [4 5 6] [7 8 9]\n                [1 4 7] [2 5 8] [3 6 9]\n                [1 5 9] [3 5 7]]]\n    (let [board (apply concat [ nil ] board)]\n      (first (remove nil?\n              (for [winpos winpos]\n                (let [row (map\n                           (fn [pos]\n                             (nth board pos)\n                             ) winpos)]\n                  (cond\n                   (apply = :x row) :x\n                   (apply = :o row) :o\n                   :else\n                   nil)\n                  )))))))","problem":73,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":73,"code":"(fn f [[[p00 p01 p02]\n          [p10 p11 p12]\n          [p20 p21 p22]]]\n  (cond (and (or (#{:x :o} p20))\n             (= p20 p21 p22))\n        p20\n        (and (or (#{:x :o} p10))\n             (= p10 p11 p12))\n        p10\n        (and (or (#{:x :o} p00))\n             (= p00 p01 p02))\n        p00\n        (and (or (#{:x :o} p00))\n             (= p00 p10 p20))\n        p00\n        (and (or (#{:x :o} p01))\n             (= p01 p11 p21))\n        p01\n        (and (or (#{:x :o} p02))\n             (= p02 p12 p22))\n        p02\n\n        (and (or (#{:x :o} p00))\n             (= p00 p11 p22))\n        p00\n\n        (and (or (#{:x :o} p02))\n             (= p20 p11 p02))\n        p02))","user":"605b49b7e4b079a07f8593f8"},{"code":"; This is HORRIFYING\n(fn check-lines [coll]\n  (loop [rng (take 3 (range))]\n    (let [three-in-row (fn three-in-row [coll]\n                         (let [result (reduce #(if (= %1 %2) %1 nil) (first coll) coll)] \n                           (if (or (= result :o) (= result :x)) \n                             result \n                             nil)))]\n      ; This handles diagonals\n      (if (= '() rng)\n        (let [r-v (three-in-row [(nth (nth coll 0) 0) (nth (nth coll 1) 1) (nth (nth coll 2) 2)])\n              l-v (three-in-row [(nth (nth coll 0) 2) (nth (nth coll 1) 1) (nth (nth coll 2) 0)])]\n          (if r-v\n            r-v\n            (if l-v\n              l-v\n              nil)))\n        ; This handles horizontal/verticals\n        (let [n (first rng)\n              v-val (three-in-row (nth coll n))\n              h-val (three-in-row (reduce #(conj %1 (nth %2 n)) [] coll))]\n          (if v-val\n            v-val\n            (if h-val\n              h-val\n              (recur (rest rng)))))))))","problem":73,"user":"52463059e4b09dbe66b56198"},{"problem":73,"code":"(fn [table]\n  (let [get-valid-combinations (fn [[x y z]]\n          (concat [x y z] (map vector x y z) (map vector x (drop 1 y) (drop 2 z)) (map vector (drop 2 x) (drop 1 y) z)))\n        winning-row? (fn [coll]\n          (or (every? #(= :x %) coll) (every? #(= :o %) coll)))]\n    (first (first (filter #(winning-row? %) (get-valid-combinations table))))))","user":"527c166de4b03e8d9a4a75b3"},{"code":"(fn [c]\n  (let [f first s second l last g apply\n        t #(if (g = %) (f %))\n        x (fn [c] (g #(or % %2 %3) (map t c)))\n        [a b d] c\n        m (s b)\n        w (or\n            (x c)\n            (x (g map vector c))\n            (if (= (f a) m (l d)) m)\n            (if (= (l a) m (f d)) m))]\n    ({:e nil} w w)))","problem":73,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":73,"code":"(fn \n  [board]\n  (let [flat-board (flatten board)\n        scores {:e 0 :o -1 :x 1}\n        score (fn [vals] (reduce + 0 (map #(get scores %) vals)))\n        seqs [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        list-fn (fn [input] (map #(nth flat-board %) input))\n        rows (map list-fn seqs)]\n    (get {3 :x -3 :o} (first (filter #(contains? #{3 -3} %) (map score rows))))))","user":"5609d328e4b05f002753deee"},{"problem":73,"code":"(fn __ [board]\n  (letfn [(rows [board]\n                (for [r board] r))\n          (cols [board]\n                [[(get (get board 0) 0)\n                  (get (get board 1) 0)\n                  (get (get board 2) 0)]\n                 [(get (get board 0) 1)\n                  (get (get board 1) 1)\n                  (get (get board 2) 1)]\n                 [(get (get board 0) 2)\n                  (get (get board 1) 2)\n                  (get (get board 2) 2)]])\n          (diags [board]\n                 [[(get (get board 0) 0)\n                   (get (get board 1) 1)\n                   (get (get board 2) 2)]\n                  [(get (get board 0) 2)\n                   (get (get board 1) 1)\n                   (get (get board 2) 0)]])]\n  (let [x [:x :x :x]\n        o [:o :o :o]\n        b (concat (rows board) (cols board) (diags board))]\n    (cond \n     (not-empty (filter #{x} b)) :x\n     (not-empty (filter #{o} b)) :o\n     :else nil))))","user":"4f856adfe4b033992c121c44"},{"code":"(fn [grid]\n  (let [transpose (map (fn [n]\n                         (map #(nth % n) grid))\n                       (range (count (first grid))))\n        diagonals [(map nth grid (range))\n                   (map nth grid (range 2 -1 -1))]]\n    (letfn [(row-win [row player]\n              (every? #{player} row))\n            (row-winner\n              [row]\n              (cond\n                (row-win row :o) :o\n                (row-win row :x) :x\n                :else nil))]\n      (some row-winner\n            (concat grid transpose diagonals)))))","problem":73,"user":"537caf68e4b06839e8705e7b"},{"problem":73,"code":"(fn [brd]\n  (let [col-view (apply map vector brd)\n        linear-view (apply mapcat vector brd)\n        linear-v2 (apply mapcat vector (reverse brd))\n        win-views (merge (concat brd col-view)\n                         (flatten (partition 1 4 linear-view))\n                         (flatten (partition 1 4 linear-v2)))\n        winner (for [cur-view win-views\n                    :let [set-view (into #{} cur-view)]\n                    :when (and (or  (set-view :o) (set-view :x))\n                                (= 1 (count set-view)))]\n                set-view)]\n  (if (empty? winner) nil (first (first winner)))))","user":"608e5697e4b03bd49d9f36be"},{"code":"(fn [board] \n  (let [testboard (fn [p brd] (let [[[a b c] \n                                     [d e f]\n\t                                   [g h i]] brd]\n\t(or (= a b c p) (= d e f p) (= g h i p)\n\t    (= a d g p) (= b e h p) (= c f i p)\n\t    (= g e c p) (= a e i p))))]\n\t(if (testboard :x board)\n    :x\n    (if (testboard :o board)\n      :o\n      nil))))","problem":73,"user":"4f2f6678e4b0d6649770a06e"},{"code":"(fn [v]\n   (let [a v\n         b (map first v)\n         c (map second v)\n         d (map #(nth % 2) v)\n         e (vector (first (first v))\n                   (second (second v))\n                   (nth (nth v 2) 2))\n         d (vector (nth (first v) 2)\n                   (second (second v))\n                   (first (nth v 2)))\n         all (merge a b c d e d)]\n     (->> all\n          (map set)\n          (filter #(= 1 (count %)))\n          (remove #(= % #{:e}))\n          first\n          first)))","problem":73,"user":"50e7dd5de4b077ad597af36b"},{"problem":73,"code":"(fn tictac [s] ( let [\ndiag (fn [y a] (or (and (= a (first (first y)))   (= a (second (second y)))  (= a (last (last y))) )  (and (= a (first (last y)))   (= a (second (second y)))  (= a (last (first y))) ))\n)\ncompx    (fn [a b c] (and (= a :x) (= b :x) (= c :x)))  \n                        compo (fn [a b c] (and (= a :o) (= b :o) (= c :o)))                        \n                        tictacx (fn [y]\n                                  (if (some identity (cons (diag y :x) (into (apply map compx y )\n                                                                    (for [x y] (apply compx x))))\n                                            ) :x))\n                        tictaco (fn [y]\n                                  (if (some identity (cons (diag y :o) (into (apply map compo y )\n                                                                             (for [x y] (apply compo x))))\n                                            ) :o))\n                        ]\n                   (some identity [(tictacx s) (tictaco s)])\n                  ) )","user":"6076adb2e4b069485764de60"},{"problem":73,"code":"(fn [board]\n   (letfn [(checkrows [n] (map (partial apply =) n))\n           (checkcols [n] (apply map = n))]\n\n     (let [diagnols (#(conj [%] %2) (map nth board (range 0 3)) (map nth board (reverse (range 0 3)))) ]\n\n       (let [winval   (conj (map get (map hash-map (checkrows board ) board) [true true true])\n                           (map get (map hash-map (checkcols board ) board) [true true true])\n                            (map get (map hash-map (checkrows diagnols) diagnols) [true true ])\n                            )]\n\n\n         \n         (first (filter #(and (not= :e %) (not= nil %)) (distinct (flatten winval))))\n\n         ))))","user":"56ede653e4b04a395b9a0449"},{"code":"(fn [m]\n   (let [row0 (m 0)\n          row1 (m 1)\n          row2 (m 2)\n          col0 [(row0 0) (row1 0) (row2 0)]\n          col1 [(row0 1) (row1 1) (row2 1)]\n          col2 [(row0 2) (row1 2) (row2 2)]\n          down [(row0 0) (row1 1) (row2 2)]\n          up   [(row2 0) (row1 1) (row0 2)]\n          lines [row0 row1 row2 col0 col1 col2 down up]\n          x3   (repeat 3 :x)\n          o3   (repeat 3 :o)\n          line-winner (fn [row]\n                         (cond\n                          (= x3 row) :x\n                          (= o3 row) :o\n                          :else :none))]\n     (first (filter #(not= :none %) (map line-winner lines)))))","problem":73,"user":"4e88feef535d8b9bb0147ca8"},{"code":"(fn [board]\n  (let [i [0 1 2]\n        c (take 12 (cycle i))\n        p (flatten (map #(repeat 3 %) i))\n        zip #(map vector %1 %2)\n        win? (fn [w] \n               (some \n                 (fn [x] (every? #(= w (get-in board %)) x)) \n                 (partition \n                   3 (into (zip (into i p) c) (zip c (into (reverse i) p))))))]\n    (cond \n      (win? :x) :x\n      (win? :o) :o)))","problem":73,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":73,"code":"(fn [coll]\n    (let [freq (into {} (map frequencies coll))\n          rotate-matrix (apply map list coll)\n          rotated-freq (into {} (map frequencies rotate-matrix))\n          row-winner (map key (into {} (filter (fn [[k v]] (= v 3)) freq)))\n          col-winner (map key (into {} (filter (fn [[k v]] (= v 3)) rotated-freq)))\n          diag-left (set (list (get-in coll [0 0]) (get-in coll [1 1]) (get-in coll [2 2])))\n          diag-right (set (list (get-in coll [0 2]) (get-in coll [1 1]) (get-in coll [2 0])))\n          all (list row-winner col-winner diag-left diag-right)\n          results (ffirst (filter #(= 1 (count %)) all))]\n        (if (= results :e) nil results)))","user":"5896735fe4b00487982d529d"},{"problem":73,"code":"(fn [[[a _ c] \n      [_ e _]\n      [h _ j] :as board]]\n  (some #(when (= 1 (count %)) (#{:x :o} (first %)))\n        (map set\n             (concat\n              board\n              (apply map vector board)\n              [[a e j]\n               [h e c]]))))","user":"5336ca32e4b0e30313ee6c80"},{"code":"(fn searchLine [matrix]\r\n (some       \r\n     #(cond \r\n        (contains? % :e)  false\r\n        (empty? (rest %)) (first %)\r\n        :else false                \r\n      )     \r\n     (map          \r\n         #(set \r\n            (map\r\n             (fn[[x y]]\r\n                 (nth (nth matrix y) x)\r\n              )\r\n              %\r\n             )\r\n          )\r\n        (conj (conj \r\n               (let [flist [ (fn[n x y](= x n) ),\r\n                             (fn[n x y](= y n) ) ]\r\n                            ]\r\n  \t\t\t\t\t\t\t     (for [f flist,n (range 0 3)] \r\n\t\t\t\t\t\t\t\t         (for [x (range 0 3),y(range 0 3):when (f n x y)] \r\n\t\t\t\t\t\t\t\t              [x y] )\t\t\t\t\t\t\t\t      \r\n\t\t\t\t\t\t\t\t      )\r\n                 ) \r\n                 (for [n (range 0 3)] [n n] )\r\n                 )\r\n                 (for [n (range 0 3)] [n (- 2 n)] )\r\n           )\r\n        )\r\n     )  \r\n)","problem":73,"user":"4f6d9d7ee4b07046d9f4efcd"},{"code":"(fn [board]\r\n  (let [i [0 1 2]\r\n        c (take 12 (cycle i))\r\n        p (flatten (map #(repeat 3 %) i))\r\n        f (fn [a b]\r\n            (map (fn [x y] [x y]) a b))\r\n        t (fn [w] \r\n            (some \r\n              (fn [x] (every? #(= w (get-in board %)) x)) \r\n              (partition 3 (into (f (into i p) c) (f c (into (reverse i) p))))))]\r\n    (cond \r\n      (t :x) :x\r\n      (t :o) :o)))","problem":73,"user":"4dc986d0535d5973398f9285"},{"problem":73,"code":"(fn [board]\n  (let [recognize (fn [[[a b c]\n                        [d e f]\n                        [g h i]] r]\n                    (or (= a b c r)\n                        (= d e f r)\n                        (= g h i r)\n                        (= a d g r)\n                        (= b e h r)\n                        (= c f i r)\n                        (= a e i r)\n                        (= c e g r)))]\n    (cond (recognize board :x) :x\n          (recognize board :o) :o\n          :else nil)))","user":"5a6af090e4b0512ff01cda2d"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i]]] \n  (let [game [a b c d e f g h i]]\n    (first (some #{#{:x} #{:o}} \n      (map #(set (map game %)) \n           [[0 1 2] [3 4 5] [6 7 8] [0 3 6] \n            [1 4 7] [2 5 8] [0 4 8] [2 4 6]])))))","user":"52b02329e4b0c58976d9acc5"},{"problem":73,"code":"(fn       [[[c00 c01 c02]\n            [c10 c11 c12]\n            [c20 c21 c22]]]\n  (let [tt [[c00 c01 c02]\n            [c10 c11 c12]\n            [c20 c21 c22]\n            [c00 c10 c20]\n            [c01 c11 c21]\n            [c02 c12 c22]\n            [c00 c11 c22]\n            [c02 c11 c20]]\n        check (fn [kw] (some (fn [xs] (every? #(= kw %) xs)) tt))]\n    (cond\n     (check :x) :x\n     (check :o) :o\n     :else nil)))","user":"53c1b787e4b00fb29b221266"},{"problem":73,"code":"(fn tictactoe-winner [lines]\n  (let [[l1 l2 l3] lines\n        tttcol \t\t(fn [c] (vector (get l1 c) (get l2 c) (get l3 c)))\n        tttdiag1  \t(fn []  (vector (get l1 0) (get l2 1) (get l3 2)))\n        tttdiag2  \t(fn []  (vector (get l1 2) (get l2 1) (get l3 0)))\n        unique-line (fn [line] (if (= 1 (-> line distinct count)) (first line) nil ))\n        uniques\t\t(map unique-line [l1 l2 l3 (tttcol 0) (tttcol 1) (tttcol 2) (tttdiag1) (tttdiag2)])\n        winner\t\t(filter (set [:o :x]) uniques)\n       ]\n    (if (= 1 (-> winner distinct count)) (first winner)  nil\n)))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":73,"code":"(fn [[r1 r2 r3]]\n  (letfn\n    [(sl [n] [(nth r1 n) (nth r2 n) (nth r3 n)])\n     (allAre [x c] (every? #(= x %) c))\n     (awin [x] \n       (or (allAre x r1)\n           (allAre x r2)\n           (allAre x r3)\n           (allAre x (sl 0))\n           (allAre x (sl 1))\n           (allAre x (sl 2))\n           (allAre x [(first r1) (second r2) (last r3)])\n           (allAre x [(first r3) (second r2) (last r1)])))]\n     (if (awin :x) :x (if (awin :o) :o nil))))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn ttt [board]\r\n  (let [t true f false\r\n        pats [[t t t f f f f f f]\r\n              [f f f t t t f f f]\r\n              [f f f f f f t t t]\r\n              [t f f t f f t f f]\r\n              [f t f f t f f t f]\r\n              [f f t f f t f f t]\r\n              [t f f f t f f f t]\r\n              [f f t f t f t f f]]]\r\n        (letfn [(make-position [board side]\r\n                  (map #(= % side) (apply concat board)))\r\n                (test-position [position pat]\r\n                  (reduce (fn [l r] (and l r)) true\r\n                          (map (fn [r p] (or (not p) r)) position pat)))\r\n                (win? [board side]\r\n                  (let [position (make-position board side)]\r\n                    (some #(test-position position %) pats)))]\r\n          (cond (win? board :x) :x\r\n                (win? board :o) :o\r\n                true nil))))","problem":73,"user":"4ddc1c89535d02782fcbea01"},{"problem":73,"code":"(fn check [[[a1 a2 a3]\n            [b1 b2 b3]\n            [c1 c2 c3]]]\n  (letfn [(check [a b c]\n            (and (= a b c) (not (= a :e))))]\n    (cond\n     (check a1 a2 a3) a1\n     (check a1 b1 c1) a1\n     (check a1 b2 c3) a1\n     (check b1 b2 b3) b1\n     (check c1 c2 c3) c1\n     (check c1 b2 a3) c1\n     (check a2 b2 c2) a2\n     (check a3 b3 c3) a3\n     :else nil)))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":73,"code":"(fn [grid]\n    (let [checkfn (fn [coll] (reduce #(if (= %1 %2) %1)\n                                     (map {:e nil, :o :o, :x :x} coll)))]\n      (some identity\n            (map checkfn\n                 (list\n                  (first grid)\n                  (second grid)\n                  (last grid)\n                  (map first grid)\n                  (map second grid)\n                  (map last grid)\n                  (list (-> grid first first)\n                        (-> grid second second)\n                        (-> grid last last))\n                  (list (-> grid first last)\n                        (-> grid second second)\n                        (-> grid last first)))))))","user":"57b9f35be4b0fbc9809a27f9"},{"problem":73,"code":"(fn [g] \n  (let [g (flatten g)]\n  (some \n   #(if (and (= (count %) 1) (not (% :e))) (first %) nil)\n   (concat \n    (map #(set (take-nth 3 (drop % g))) (range 3))\n    (map #(set (take 3 (drop (* 3 %) g))) (range 3))\n    (list (set (take-nth 4 g)))\n    (list (set (take-nth 2 (take 5 (drop 2 g)))))))))","user":"58c2df0ae4b021aa9917ed17"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (nth (some #{[:x :x :x]\n               [:o :o :o]}\n         (partition 3 [a b c, d e f, g h i,\n                       a d g, b e h, c f i,\n                       a e i, c e g]))\n       0))","problem":73,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":73,"code":"(fn[board]\n   (let [row (fn[n] (board n))\n         column (fn [n](vec(map #((board %) n) (range 3))))\n         diag (vec (map #((board %) %) (range 3)))\n         adiag (vec (map #((board %) (- 2 %)) (range 3)))\n         lines (concat (map row (range 3) ) (map column (range 3))   [diag adiag ])     \n         winner (fn [line] (if (= (line 0)(line 1)(line 2)) (line 0) nil ))\n         find-winner (fn [L] (if (or (empty? L)(first L)) (first L) (recur (rest L))))]\n         \n         (some #{:x,:o}(map winner lines))\n         \n    )\n )","user":"5649615be4b0284900eef641"},{"code":"(fn [n] \n  (let [plan (flatten n)]\n  (cond\n  (and (= :x (nth plan 0))\n       (= :x (nth plan 3))\n       (= :x (nth plan 6))) :x\n  (and (= :o (nth plan 3))\n       (= :o (nth plan 4))\n       (= :o (nth plan 5))) :o\n  (and (= :x (nth plan 0))\n       (= :x (nth plan 4))\n       (= :x (nth plan 8))) :x\n  (and (= :o (nth plan 2))\n       (= :o (nth plan 4))\n       (= :o (nth plan 6))) :o\n  :else nil\n\n)))","problem":73,"user":"4e5d2dc5535d8a8b8723a2ca"},{"code":"(fn [[[a1 b1 c1] [a2 b2 c2] [a3 b3 c3] :as board]]\n  (letfn [(three-in-row [k] (some (partial every? (partial = k)) board))\n          (three-in-col [k] (some true? (apply map (partial = k) board)))\n          (diagonal-1 [k] (= k a1 b2 c3))\n          (diagonal-2 [k] (= k a3 b2 c1))\n          (winner [k] (or (three-in-row k)\n                          (three-in-col k)\n                          (diagonal-1 k)\n                          (diagonal-2 k)))]\n    (cond\n      (winner :x) :x\n      (winner :o) :o\n      :else nil)))","problem":73,"user":"4daf36c2edd6309eace4d175"},{"code":"(fn [m] \n  (let [r (set (conj (concat m (apply map list m)) \n                     (map #((m %) %2) (reverse (range 3)) (range)) \n                     (map #((m %) %2) (range 3) (range))))] \n    (cond \n     (some #{[:x :x :x]} r) :x \n     (some #{[:o :o :o]} r) :o)))","problem":73,"user":"4ef77edb535dced4c769f254"},{"code":"(fn [[[a b c] [d e f] [g h i] :as A]]\n  (some\n    (fn [[x y z]]\n      (and (not= x :e) (= x y z) x))\n    (conj A [a d g] [b e h] [c f i] [a e i] [c e g])))","problem":73,"user":"4ee82539535d93acb0a66878"},{"code":"(fn [board]\n  (cond\n   (some #(= [:x :x :x] %) board) :x\n   (some #(= [:x :x :x] %) (apply map (fn [x y z] [x y z]) board)) :x\n   (= (first (first board)) (second (second board)) (last (last board)) :x) :x\n   (= (last (first board)) (second (second board)) (first (last board)) :x) :x\n   (some #(= [:o :o :o] %) board) :o\n   (some #(= [:o :o :o] %) (apply map (fn [x y z] [x y z]) board)) :o\n   (= (first (first board)) (second (second board)) (last (last board)) :o) :o\n   (= (last (first board)) (second (second board)) (first (last board)) :o) :o\n   :else nil))","problem":73,"user":"514721c6e4b0d520409ed392"},{"problem":73,"code":"(fn [board]\n  (let [flat-board ((comp vec flatten) board)\n        valid-line-patterns [[0 1 2]\n                             [3 4 5]\n                             [6 7 8]\n                             [0 3 6]\n                             [1 4 7]\n                             [2 5 8]\n                             [0 4 8]\n                             [6 4 2]]]\n    (some {[:x :x :x] :x [:o :o :o] :o} \n       (mapv #(map flat-board %) valid-line-patterns))))\n\n;;flatten the collection so you have one vector of nine elements\n;;now each space on the board can be represented as an index of 1 vector \n;;instead of an index of in a vector which is at an index of another vector\n;;visually this means that we can think of the board like \n;[[0 1 2] \n;[3 4 5] \n;[6 7 8]]\n;;looking at it this way the line patterns make more sense so you can quickly see that \n;;0 4 2 and 6 4 2 cover the diagonals\n;;it is also nice that you don't have to do anything special to represent the diagonals\n;;so with a flat board and the indexes we want we can pull out the board values  \n;;by mapping the flat board over the vector of indexes \n;;we map that over all of the patterns we've defined to get all rows columns and diag combinations\n;;then use the some function with a map with \n;;the key being the winning vector and the value being the winner for that vector\n;;some will either return the winner or nil which is what we want","user":"50e1bdd8e4b019fc399ce17f"},{"problem":73,"code":"(fn won? [board]\n  (let [len (count board)\n        main-diagonal (map #(get-in board %) (for [x (range len)] [x x]))\n        anti-diagonal (map #(get-in board %) (for [x (range len)] [(- (dec len) x) x]))\n        transposed-board (apply (partial map list) board)]\n    (->> (concat board transposed-board [main-diagonal anti-diagonal])\n         (filter (fn [xs] (and (apply = xs) (not= (first xs) :e))))\n         ffirst)))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":73,"code":"(fn tic [x] \n  (first \n    (first\n      (filter (fn [y] (= (count (second y)) 3))\n\t\t\t  (filter \n\t\t\t    #(= (reduce + (map first (second %))) 15) \n\t\t\t    (group-by \n\t\t\t      val \n\t\t\t      (zipmap (apply concat [[2 9 4][7 5 3][6 1 8]]) (apply concat x))))))))","user":"5587d8b3e4b059ccff29b1e8"},{"code":"(fn [board]\r\n  (letfn [(win? [row]\r\n            (if (and (apply = row) (not (= :e (first row))))\r\n              (first row)\r\n              nil))]\r\n    (some identity\r\n      (concat\r\n        (map win? board)\r\n        (for [i (range 3)] (win? (map #(nth % i) board)))\r\n        [(win? (for [i (range 3)] (nth (nth board i) i)))]\r\n        [(win? (for [i (range 3)] (nth (nth board i) (- 2 i))))]))))","problem":73,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn [-seq]\n   (let [r-fn #(partial map %)\n         d-fn #(let [[[a _ _] [_ b _] [_ _ c]] %]\n                 [a b c])\n         data (into (into -seq [(d-fn -seq) (d-fn (reverse -seq))]) (map (partial into []) ((juxt (r-fn first) (r-fn second) (r-fn last)) -seq)))]\n     (some\n      #(if (= 3 (val (last (sort-by val\n                                    (frequencies (filter (partial not= :e) %)))))) (first %))  (remove (partial = [:e :e :e]) data))\n\n     )\n   )","problem":73,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":73,"code":"(fn analyze-ttt [board]\n  (let [transpose (fn [m] (apply mapv vector board))\n        test-row\n        (fn [row]\n          (let [x-win? (= (count (filter (fn [v] (= v :x)) row)) 3)\n                o-win? (= (count (filter (fn [v] (= v :o)) row)) 3)]\n            (cond x-win? :x\n                  o-win? :o\n                  :else nil)))]\n\n    (let [transposed-board (transpose board)\n          diagonal-row-1 [(reduce\n                          (fn [acc v]\n                            (let [row (get board v)\n                                  diag-value (get row v)]\n                              (conj acc diag-value)\n                              )) [] (range 3))]\n          diagonal-row-2 [(reduce\n                           (fn [acc v]\n                             (let [row-index (get v 0)\n                                   column-index (get v 1)\n                                   row (get board row-index)\n                                   diag-value (get row column-index)]\n                               (conj acc diag-value)\n                               )) [] (zipmap (reverse (range 3)) (range 3)))]\n          combined-test-rows (concat board transposed-board diagonal-row-1 diagonal-row-2)\n          win? (reduce (fn [acc row]\n                         (let [win (test-row row)]\n                           (cond\n                             (not (= win nil)) win\n                             :else acc))) nil combined-test-rows)]\n      win?\n      )\n    ))","user":"5d631376e4b0c9e5857d5023"},{"code":"(fn [m]\n  (let [analyze (fn [s];\n    (if (or (and (= s ((m 0) 0)) (= s ((m 0) 1)) (= s ((m 0) 2)))\n            (and (= s ((m 1) 0)) (= s ((m 1) 1)) (= s ((m 1) 2)))\n            (and (= s ((m 2) 0)) (= s ((m 2) 1)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 0)) (= s ((m 1) 0)) (= s ((m 2) 0)))\n            (and (= s ((m 0) 1)) (= s ((m 1) 1)) (= s ((m 2) 1)))\n            (and (= s ((m 0) 2)) (= s ((m 1) 2)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 0)) (= s ((m 1) 1)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 2)) (= s ((m 1) 1)) (= s ((m 2) 0))))\n          s\n        nil))]\n  (or (analyze :o) (analyze :x))))","problem":73,"user":"51d28e15e4b0d13b04db0d9b"},{"problem":73,"code":"(fn [board]\n  (let [xy #(nth (nth board %1) %2)\n        trios (partition 3\n                         (filter #(not (nil? %))\n                                 (for [d [:a :d :z1 :z2]\n                                       x (range 0 3)\n                                       y (range 0 3)]\n                                   (condp = d\n                                     :a (xy x y)\n                                     :d (xy y x)\n                                     :z1 (if (= x y) (xy x y))\n                                     :z2 (if (= x y) (xy (- 2 x) y))))))]\n    (cond\n      (some #(= [:x :x :x] %) trios) :x\n      (some #(= [:o :o :o] %) trios) :o\n      :default nil)))","user":"55c4cda5e4b0e31453f649a5"},{"problem":73,"code":"#_(fn [rows]\n   (let [cols (apply map vector rows)\n         diag1 (map #(get-in rows [% %]) (range 3))\n         diag2 (map #(get-in rows [% (- 2 %)]) (range 3))\n         all (concat rows cols [diag1 diag2])\n         freqs (map frequencies all)\n         all-x? #(= 3 (:x %))\n         all-o? #(= 3 (:o %))]\n     (cond\n       (some all-x? freqs) :x\n       (some all-o? freqs) :o)))\n\n\n(fn [rows]\n   (let [cols (apply map vector rows)\n         diag1 (map #(get-in rows [% %]) (range 3))\n         diag2 (map #(get-in rows [% (- 2 %)]) (range 3))\n         all (concat rows cols [diag1 diag2])\n         freqs (map frequencies all)]\n     (->> (for [m freqs [k v] m :when (= 3 v)] k)\n          (remove #(= :e %))\n          first)))","user":"5935b010e4b04f87174def55"},{"code":"#(let [[r1 r2 r3] %\n       f (fn [a b c] (and (not= :e a) (= a b c)))]\n     (cond\n       (f (r1 0) (r1 1) (r1 2)) (r1 0)\n       (f (r2 0) (r2 1) (r2 2)) (r2 0)\n       (f (r3 0) (r3 1) (r3 2)) (r3 0)\n       (f (r1 0) (r2 0) (r3 0)) (r1 0)\n       (f (r1 1) (r2 1) (r3 1)) (r1 1)\n       (f (r1 2) (r2 2) (r3 2)) (r1 2)    \n       (f (r1 0) (r2 1) (r3 2)) (r1 0)\n       (f (r1 2) (r2 1) (r3 0)) (r1 2) \n       :else nil))","problem":73,"user":"52667ecfe4b03e8d9a4a713e"},{"code":"(fn [board]\n   (let\n     [cols (map (fn [n] (map #(% n) board)) [0 1 2])\n      diag (fn [f] (map #((board %1) %2) [0 1 2] (f [0 1 2])))\n      diags (vector (diag identity) (diag reverse))\n      lines (concat board cols diags)\n      win-for?  (fn [e]\n                  (reduce\n                    (fn [v i]\n                      (or v (every? #(= % e) i)))\n                    false lines))]\n   (cond\n     (win-for? :x) :x\n     (win-for? :o) :o\n     :else nil)))","problem":73,"user":"4fc0853ae4b081705acca327"},{"problem":73,"code":"#(letfn [\n        (get-col-indices [col] (map (partial conj (list col)) (range 3)))\n        (get-row-indices [row] (map (fn [[a b]] (list b a))\n                                    (get-col-indices row)))\n        (get-pos [board [row col]] [((board row) col)])\n        (win-positions? [board who positions]\n                        (apply = who (mapcat (partial get-pos board) positions)))\n        (win? [board who] (some (partial win-positions? board who)\n                                (concat (map get-row-indices (range 3))\n                                        (map get-col-indices (range 3))\n                                        '(\n                                          ((0 0) (1 1) (2 2))\n                                          ((2 0) (1 1) (0 2))\n                                         ))))\n        (who-won? [board] (cond (win? board :x) :x\n                                (win? board :o) :o\n                                :else nil))\n       ]\n       (who-won? %)\n)","user":"5990fcb9e4b0866487ed0d5b"},{"problem":73,"code":"(fn who-won? [board]\n  (let [ps [(range 0 3) (range 3 6) (range 6 9)\n                 (range 0 9 3) (range 1 9 3) (range 2 9 3)\n                 (range 0 9 4) (range 2 8 2)]\n        b (flatten board)]\n    (letfn [(get-at [b ps] (map #(nth b %) ps))]\n      (let [c (map #(get-at b %) ps)\n            xs (repeat 3 :x)\n            os (repeat 3 :o)]\n        (cond\n          (some (partial = xs) c) :x\n          (some (partial = os) c) :o\n          :default nil)))))","user":"587ee260e4b052da650a6353"},{"problem":73,"code":"(fn [grid]\n  (let [line-check   (fn [player grid]\n                        (some true? (map (fn [row] (every? #(= player %) row)) grid)))\n        transpose    (fn [x] (apply mapv vector x))\n        diags-check  (fn [player grid]\n                        (let [normal-diag [(first (first grid)) (second (second grid)) (last  (last grid))]\n                            anti-diag   [(last  (first grid)) (second (second grid)) (first (last grid))]]\n                        (or (every? #(= player %) normal-diag)\n                            (every? #(= player %) anti-diag))))\n        player-wins? (fn [player grid]\n                        (or (line-check player grid)\n                            (line-check player (transpose grid))\n                            (diags-check player grid)))]\n    (cond\n      (player-wins? :o grid) :o\n      (player-wins? :x grid) :x\n      :else nil)))","user":"5bf5ddfde4b0bdcf453d159e"},{"problem":73,"code":"(fn\n  [board]\n  (let [winners [[0 1 2]\n                 [3 4 5]\n                 [6 7 8]\n                 [0 3 6]\n                 [1 4 7]\n                 [2 5 8]\n                 [0 4 8]\n                 [6 4 2]]\n        flattened (flatten board)\n        positions (map (fn [w]\n                         (distinct (map #(nth flattened %) w))) winners)\n        wins (filter #(and (= (count %) 1) (not= (first %) :e)) positions)]\n    (ffirst wins)))","user":"5148bcbee4b05514c84b7cc6"},{"problem":73,"code":"(fn check-board [board]\n  (letfn [(check-horizontal [board]\n            (some #(or (:x %) (:o %)) (filter #(= (count %) 1) (filter not-empty (map (fn [row] (set row)) board)))))\n          (transpose [board]\n            (apply (fn [c1 c2 c3] (map #(-> [%1 %2 %3]) c1 c2 c3)) board))\n          (check-diagonals [board]\n            (let [d1 (map get board [0 1 2])\n                  d2 (map get board [2 1 0])]\n              (if (and (apply = d1) (not (= :e (first d1))))\n                (first d1)\n                (if (and (apply = d2) (not (= :e (first d2))))\n                  (first d2)))))]\n    (if-let [winner (check-horizontal board)]\n      winner\n      (if-let [winner (check-horizontal (transpose board))]\n        winner\n        (check-diagonals board)))))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [[[x1 x2 x3 :as row-x]\n      [y1 y2 y3 :as row-y]\n      [z1 z2 z3 :as row-z]]]\n    (let [ rows [ row-x row-y row-z ]\n           cols [[x1 y1 z1] [x2 y2 z2] [x3 y3 z3]]\n           digs [[x1 y2 z3] [x3 y2 z1]]\n           all  (concat rows cols digs) ]\n\n    (letfn [ (full? [v s] (every? #(= % v) s))\n             (check [v]   (some #(full? v %) all)) ]\n     (cond\n        (check :x) :x\n        (check :o) :o))))","problem":73,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn solve-it [ls]\n  (letfn [(get-cols [ls]\n            [(vec (map first ls))\n             (vec (map second ls))\n             (vec (map last ls))])\n          (get-diagonals [ls]\n            (let [idx1 [[0 0] [1 1] [2 2]]\n                  idx2 [[2 0] [1 1] [0 2]]]\n        [(vec (map #(get-in ls %) idx1))\n\t       (vec (map #(get-in ls %) idx2))]))\n          (get-cda [ls]\n            (vec (concat ls (get-cols ls) (get-diagonals ls))))\n          (all-e [e ls]\n            (apply = e ls))]\n\n    (let [lls (get-cda ls)]\n      (cond\n       (some (partial all-e :x) lls) :x\n       (some (partial all-e :o) lls) :o\n       :else nil))))","problem":73,"user":"4dd62278535d2dad7130b5c7"},{"problem":73,"code":"(fn [board]\n  (let [check\n    (fn [array] \n      (cond \n       (some #(= [:x :x :x] %) array) :x\n       (some #(= [:o :o :o] %) array) :o\n       :else nil))]\n    (if-let [winner (check board)]\n      winner\n      (if-let [winner (check (apply map vector board))]\n        winner\n        (if-let [winner (check \n          (vector (map get board [0 1 2])\n                  (map get board [2 1 0])))]\n            winner\n            nil)))))","user":"56bb9ccce4b0f26550335959"},{"code":"(fn [board]\n  (let [row (fn [r] (board r))\n        col (fn [c] (map #(% c) board))\n        diag (fn [coord] (map #(get-in board %) coord))\n        d1 (diag [[0 0] [1 1] [2 2]])\n        d2 (diag [[0 2] [1 1] [2 0]])\n        r3 (range 3)\n        lines (concat \n                (map row r3)\n                (map col r3)\n                [d1 d2])\n        win? (fn [[x & xs]] (if (and\n                                  (not= x :e)\n                                  (every? #(= x %) xs))\n                              x))]\n    (->> lines\n         (map win?)\n         (filter (complement nil?))\n         first)))","problem":73,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"#(reduce % nil (concat %4 (%2 %4) (%2 (map %3 %4 [0 1 2] [2 1 0]))))\n#(or % (if (and (not= (last %2) :e) (apply = %2)) (last %2)))\n#(apply map list %)\n#(list (% %2) (% %3))","problem":73,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn extract-rows [board]\n  (letfn [(transpose [b]\n            (apply map vector b))\n          (extract-diags [[[a _ e][_ b _][d _ c]]]\n            [ [a b c] [d b e] ])]\n    (some {[:o :o :o] :o [:x :x :x] :x}\n           (concat board\n            (transpose board)\n            (extract-diags board)))))","problem":73,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn [b]\n  (some identity (map #(condp = (set %) #{:x} :x #{:o} :o nil)\n                      (concat b (apply map vector b)\n                              [(for [x (range 3)] ((b x) (- 2 x)))\n                               (for [x (range 3)] ((b x) x))]))))","problem":73,"user":"4f0664bd535dcb61093f6c0f"},{"problem":73,"code":"(fn check-tic-tac-toe\n  [board]\n  (let\n    [x-vector [:x :x :x]\n     o-vector [:o :o :o]\n     transpose (fn [matrix] (apply mapv vector matrix))\n     diagonal (fn diag [type matrix] (or\n      (apply = (conj (map (fn [x] ((matrix x) x)) '(0 1 2)) type))\n      (apply = (conj (map (fn [x] ((matrix (- 2 x)) x)) '(0 1 2)) type))))\n     other-board (transpose board)]\n    (cond\n      (or (some #(= % x-vector) board)\n          (some #(= % x-vector) other-board)\n          (diagonal :x board)) :x\n      (or (some #(= % o-vector) board)\n          (some #(= % o-vector) other-board)\n          (diagonal :o board)) :o)))","user":"56ef2348e4b04a395b9a045c"},{"code":"(fn ttt [board]\n  (let [rows board\n        columns (apply map list board)\n        diagonals [[(first (first board)) (second (second board)) (nth (nth board 2) 2)]\n                   [(first (nth board 2)) (second (second board)) (nth (first board) 2)]]\n        lines (concat rows columns diagonals)\n        matches (filter #(apply = %) lines)\n        winner (first (first (filter #(not-any? #{:e} %) matches)))]\n    winner))","problem":73,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [a m r b]\n   (let [v [2 1 0]\n         [r & _] (some\n                  #(if (and (a not= :e %) (a = %)) %)\n                  (concat b\n                          (m\n                           (fn [r] (m #(% %2) b r))\n                           `[~(r) ~v ~@(m repeat v)])))]\n     r)) apply map range","problem":73,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":73,"code":"(fn tttoe [b]\n  (let [x #{:x}\n        o #{:o}\n        u (fn [v]\n            (let [s (reduce conj #{} v)]\n              (if (= s x) :x\n                (if (= s o) :o nil))))\n        gd (fn [rs]\n            (let [gd' (fn [n v rs]\n                        (if (empty? rs) v\n                          (recur\n                            (inc n)\n                            (conj v (nth (first rs) n))\n                            (rest rs))))]\n              (gd' 0 [] rs)))\n        [r1 r2 r3] b\n        r b\n        c (map vector r1 r2 r3)\n        d [(gd r) (gd (map reverse r))]\n        f (fn [vs]\n            (if (empty? vs) nil\n              (let [o (u (first vs))]\n                (if (nil? o)\n                  (recur (rest vs)) o))))\n        g (fn [bvs]\n            (if (empty? bvs) nil\n              (let [o (f (first bvs))]\n                (if (nil? o)\n                  (recur (rest bvs)) o))))]\n    (g [r c d])))","user":"57d1d6c8e4b0bd073c202370"},{"problem":73,"code":"(fn tictactoe [field]\n  (let [transposed (apply mapv vector field)\n        diagonal1 (map (fn [line] (nth line (.indexOf field line))) field)\n        diagonal2 (map (fn [line] (nth line (- (count field) (.indexOf field line) 1))) field)]\n    (if (or\n         (some #(every? #{:x} %) field)\n         (some #(every? #{:x} %) transposed)\n         (some #(every? #{:x} %) [diagonal1 diagonal2]))\n      :x\n      (if (or\n             (some #(every? #{:o} %) field)\n             (some #(every? #{:o} %) transposed)\n             (some #(every? #{:o} %) [diagonal1 diagonal2]))\n        :o\n        nil)\n      )\n    )\n  )","user":"5a621702e4b0512ff01cd983"},{"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (letfn [(tos [p q r]\n    (let [z (set [p q r])\n          v (if (= 1 (count z)) (first z) :e)]\n        v))]\n      (let [res (set (remove #(= :e %)\n        [(tos a b c) (tos d e f) (tos g h i)\n         (tos a d g) (tos b e h) (tos c f i)\n         (tos a e i) (tos c e g)]))]\n        (if (>= 1 (count res))\n          (first res)))))","problem":73,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"problem":73,"code":"(fn [g]\n        (let [g (into [] (flatten g))\n              x? #(= :x %)\n              o? #(= :o %)\n              all? (partial every? identity)\n              any? (partial some identity)\n              ws ['(0 1 2) '(3 4 5) '(6 7 8) \n                  '(0 3 6) '(1 4 7) '(2 5 8) \n                  '(0 4 8) '(2 4 6)]\n              winner\n              (fn [player?]\n                (any? (map #(all? (map player? (map g %))) ws)))]\n\n          (cond (winner x?) :x \n                (winner o?) :o)))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":73,"code":"(fn k [s]\n  (let [all-o (fn [a] (every? #(= :o %) a))\n        all-x (fn [a] (every? #(= :x %) a))\n        line-value (fn [a] (cond (all-o a) :o (all-x a) :x :else nil))\n        h-one (s 0)\n        h-two (s 1)\n        h-three (s 2)\n        v-one [((s 0) 0) ((s 1) 0) ((s 2) 0)]\n        v-two [((s 0) 1) ((s 1) 1) ((s 2) 1)]\n        v-three [((s 0) 2) ((s 1) 2) ((s 2) 2)]\n        c-one [((s 0) 0) ((s 1) 1) ((s 2) 2)]\n        c-two [((s 0) 2) ((s 1) 1) ((s 2) 0)]\n        values [(line-value h-one)\n                (line-value h-two)\n                (line-value h-three)\n                (line-value v-one)\n                (line-value v-two)\n                (line-value v-three)\n                (line-value c-one)\n                (line-value c-two)]\n        ]\n  (cond\n    (some #(= :o %) values) :o\n    (some #(= :x %) values) :x\n    :else nil)))","user":"5292feb4e4b0239c8a67af39"},{"problem":73,"code":"(fn [board]\n  (let [wins {[:x :x :x] :x\n              [:o :o :o] :o}]\n    (or (some wins board)\n        ;(wins (map first board))\n        ;(wins (map second board))\n        ;(wins (map last board))\n        (some wins (apply map vector board))\n        (wins [(-> board first first)\n               (-> board second second)\n               (-> board last last)])\n        (wins [(-> board first last)\n               (-> board second second)\n               (-> board last first)]))))","user":"4fceda40e4b03432b189f407"},{"code":"(fn [x] (first (filter identity (map (fn [a] (if (or (apply = (conj a :x)) (apply = (conj a :o))) (first a) nil)) \n             (concat x \n                     (for [i [0 1 2]] (map #(nth % i) x)) \n                     [(list (ffirst x) (second (second x)) (last (last x))) \n                      (list (first (last x)) (second (second x)) (last (first x)))])) )))","problem":73,"user":"52c6a0abe4b0c2d177d62111"},{"problem":73,"code":"(fn [m]\n  (let [a (concat (vec m)\n                  (vec (apply map (fn [& es] (vec es)) m))\n                  (vector [(ffirst m) (second (second m)) (last (last m))])\n                  (vector [(-> m last first) (-> m second second) (-> m first last)])\n                  )]\n    (let [e (some #(if (apply = %) (first %)) a)]\n      (if (= :e e)\n        nil\n        e))))","user":"5a66f358e4b0512ff01cd9d5"},{"problem":73,"code":"(fn [board] (let [o-wins [:o :o :o]\n                                   x-wins [:x :x :x]\n                                   flip-board (->> board (apply map list ))\n                                   elem       (fn [row col] (-> board (nth row) (nth col)))\n                                   diag1      (map #(elem % %) (range 3))\n                                   diag2      (map #(elem % (- 2 %)) (range 3))]\n                               (println diag1)\n                               (println diag2)\n                               (cond\n                                (some #(= o-wins %) board) :o\n                                (some #(= o-wins %) flip-board) :o\n                                (some #(= x-wins %) board) :x\n                                (some #(= x-wins %) flip-board) :x\n                                (= x-wins diag1) :x\n                                (= x-wins diag2) :x\n                                (= o-wins diag1) :o\n                                (= o-wins diag2) :o\n                                :else                      nil)))","user":"544e8369e4b0e39780006987"},{"code":"(fn rows [a] (let [ d (fn [b] (vec (for [x (range 3)] (get (get b x) x)))) rows (concat a (apply map vector a) (vector (d a)) (vector (d (vec (reverse a)))))] (cond (some #(= % [:o :o :o]) rows) :o  (some #(= % [:x :x :x]) rows) :x :else nil )))","problem":73,"user":"4e6e6630535d5021c1a89609"},{"code":"(fn [m]\n(first\n(filter\n(fn win? [player]\n(->> (let [idx [0 1 2]]\n(concat m ; rows\n(map (fn [i] (map #(% i) m)) idx) ; columns\n(vector (map #((m %) %) idx)) ; diagonal 1\n(vector (map #((m (- 2 %)) %) idx)))) ; diagonal 2\n(map (fn [row] (count (filter #(= player %) row))))\n(filter #(= % 3))\nseq))\n[:x :o])))","problem":73,"user":"5132c6f0e4b021281ec7b6d3"},{"problem":73,"code":"(fn f73 [game]\n  (let [[l1 l2 l3] game\n        out? (fn [x y] (or (> x 2) (> y 2)))\n        win? (fn [xs] (if (= 3 (count xs))\n                        (reduce #(if (and (not= :e %1 %2) (= %1 %2)) %1 nil) xs)\n                        nil))\n        check (fn [xs [x y] f]\n                   (if (out? x y)\n                     (win? xs)\n                     (recur (conj xs (get-in game [x y])) (f [x y]) f)))]\n\n    (reduce #(cond\n               (not= nil  %1) %1\n               (not= nil  %2) %2\n               :else nil)\n           nil\n      (flatten\n        (for [x (range 3)\n          y (range 3)]\n          [(when (= y 0)    (check [] [x y] #(vector (% 0) (inc (% 1)))))\n           (when (= x 0)    (check [] [x y] #(vector (inc (% 0)) (% 1))))\n           (when (= x y 0)  (check [] [x y] #(vector (inc (% 0)) (inc (% 1)))))\n           (when (= x 2)    (check [] [x y] #(vector (dec (% 0)) (inc (% 1)))))]\n          )))))","user":"525873e8e4b0cb4875a45cb2"},{"code":"(fn [ds]\n  (let [ r (range 3)\n         l (concat \n              (map (fn [x] (map #(vector x %) r)) r)\n              (map (fn [x] (map #(vector % x) r)) r)\n              [[ [0 0] [1 1] [2 2] ] [ [2 0] [1 1] [0 2] ]]) ]\n    ( {:x :x :o :o } \n      (first \n        (map first \n          (filter #(= (count %) 1) \n            (map distinct (map #(map (fn [[a b]] ((ds a) b)) %) l))))))))","problem":73,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"#(some {[:o :o :o] :o [:x :x :x] :x}\n(partition 3\n(map\n(vec (flatten %))\n[0 1 2 3 4 5 6 7 8\n0 3 6 1 4 7 2 5 8\n0 4 8 2 4 6])))","problem":73,"user":"51b793d3e4b0d906fcd71d38"},{"code":"(fn [[l1 l2 l3]]\r\n  (let [cols   (partition 3 (interleave l1 l2 l3))\r\n        cross1 (list (first l1) (second l2) (last l3))\r\n        cross2 (list (last l1)  (second l2) (first l3))]\r\n    (->> (concat cols [l1 l2 l3 cross1 cross2]) \r\n      (map #(remove #{:e} %))\r\n      (some (fn [[a b c]]\r\n              (if (and a (= a b c))\r\n                a))))\r\n  )\r\n)","problem":73,"user":"4f3e6244e4b0e243712b1f85"},{"problem":73,"code":"(fn [[[b11 b12 b13] [b21 b22 b23] [b31 b32 b33]]]\n  (let [tests [[b11 b12 b13] [b21 b22 b23] [b31 b32 b33]\n               [b11 b21 b31] [b12 b22 b32] [b13 b23 b33]\n               [b11 b22 b33] [b13 b22 b31]]\n        test-winner (fn [[x & xs :as triple]]\n                      (if (and (= 1 (count (set triple))) (not (= :e x))) x))\n        winner (remove nil? (map test-winner tests))]\n      (if-not (empty? winner) (first winner))))","user":"5338e33fe4b0e30313ee6ca1"},{"problem":73,"code":"(fn [coll]\n  (let [[coll1, coll2, coll3] coll]\n  (cond \n   (every? #(= :x %1) coll1) :x\n   (every? #(= :o %1) coll1) :o\n   \n   (every? #(= :x %1) coll2) :x\n   (every? #(= :o %1) coll2) :o\n   \n   (every? #(= :x %1) coll3) :x\n   (every? #(= :o %1) coll3) :o\n   \n   (every? #(= :x %1) (map #(% 0) coll)) :x\n    (every? #(= :o %1) (map #(% 0) coll)) :o\n   \n    (every? #(= :x %1) (map #(% 1) coll)) :x\n    (every? #(= :o %1) (map #(% 1) coll)) :o\n   \n   (every? #(= :x %1) (map #(% 2) coll)) :x\n    (every? #(= :o %1) (map #(% 2) coll)) :o\n   \n    (every? #(= :x %1) [(coll1 0) (coll2 1) (coll3 2)]) :x\n    (every? #(= :o %1) [(coll1 0) (coll2 1) (coll3 2)]) :o\n   \n   (every? #(= :x %1) [(coll1 2) (coll2 1) (coll3 0)]) :x\n    (every? #(= :o %1) [(coll1 2) (coll2 1) (coll3 0)]) :o\n   \n   :else nil\n   )\n  )\n     )","user":"574ff497e4b02ea114799266"},{"code":"(fn eval-ttt [[[a b c] [d e f] [g h i]]]\n\t(loop [[next & rest] [[a d g] [b e h] [c f i] [a e i] [c e g] [a b c] [d e f] [g h i]]]\n\t\t(cond \n\t\t\t(nil? next) nil\n\t\t\t(every? #(= :x %) next) :x\n\t\t\t(every? #(= :o %) next) :o\n\t\t\t:else (recur rest))))","problem":73,"user":"50ed8a5fe4b06330c1f87c3d"},{"problem":73,"code":"(fn [board]\n  (let [result (remove #(or (nil? %) (= :e %))\n                       (map (fn [case] (if (apply = (map #(get-in board %) case)) (get-in board (first case)) nil))\n                            (apply concat\n                                   (list (set (for [i (range (count (board 0)))]\n                                                (set (for [j (range (count board))] [i j]))))\n                                         (set (for [i (range (count board))]\n                                                (set (for [j (range (count (board 0)))] [j i]))))\n                                         #{(set (for [dx [-1 0 1] dy [-1 0 1] :when (= dx dy)]\n                                                  [(+ 1 dx) (+ 1 dy)]))}\n                                         #{(set (for [dx [-1 0 1] dy [-1 0 1] :when (= (- dx) dy)]\n                                                  [(+ 1 dx) (+ 1 dy)]))}))))]\n    (if (empty? result) nil\n        (first result))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [x]\n  (let [a (to-array-2d x)\n        s (atom nil)]\n    (doseq [i (range 0 3)]\n      (if (= (aget a i 0) (aget a i 1) (aget a 1 2))\n        (reset! s (aget a i 0)))\n      (if (= (aget a 0 i) (aget a 1 i) (aget a 2 i))\n        (reset! s (aget a i 0))))\n    (if (or (= (aget a 0 0) (aget a 1 1) (aget a 2 2))\n            (= (aget a 0 2) (aget a 1 1) (aget a 2 0)))\n      (reset! s (aget a 1 1)))\n    (if (= @s :e)\n      'nil\n      @s)))","problem":73,"user":"51e4f8d5e4b0efabf93c02c3"},{"code":"(fn toe [board]\n  (let [x? #(= % :x)\n        o? #(= % :o)\n        third #(nth % 2)\n        row1 (first board)\n        row2 (second board)\n        row3 (third board)\n        col1 (map first board)\n        col2 (map second board)\n        col3 (map third board)\n        diag1 (vector (first row1) (second row2) (third row3))\n        diag2 (vector (third row1) (second row2) (first row3))\n        wins [row1 row2 row3 col1 col2 col3 diag1 diag2]]\n    (cond\n     (some true? (map #(every? x? %) wins)) :x\n     (some true? (map #(every? o? %) wins)) :o\n     :else nil)))","problem":73,"user":"5269c150e4b03e8d9a4a71f8"},{"problem":73,"code":"(fn [state]\n   (let [column ((fn [state]\n                   (for [x (range 0 3)]\n                     (map #(nth % x) state))) state)\n         diag [[(get-in state [0 0]) (get-in state [1 1]) (get-in state [2 2])]\n               [(get-in state [0 2]) (get-in state [1 1]) (get-in state [2 0])]]\n         row state\n         lines (concat row column diag)\n         winner? (fn [p] (some #{p} (map #(if (every? #{p} %) p) lines)))]\n\n     (cond\n       (winner? :x) :x\n       (winner? :o) :o\n       :else nil)))","user":"56fbf83de4b07572ad1a88da"},{"problem":73,"code":"(fn [board]\n  (let [patterns (concat \n                    (map (fn [y] (map (fn [x] [x y]) (range 3))) (range 3))\n                    (map (fn [y] (map (fn [x] [y x]) (range 3))) (range 3))\n                    (map (fn [y] (map (fn [x] [x (+ (* (- x 1) y) 1)]) (range 3))) [1 -1]))\n        get-pattern (fn [p] (map (fn [[x y]] (nth (nth board x) y)) p))]\n    (first (first (filter #(and (apply = %) (#{:o :x} (first %))) (map get-pattern patterns))))))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (cond\n    (= (first (first board)) (first (second board)) (first (last board)) :x) :x\n    (= (second (first board)) (second (second board)) (second (last board)) :x) :x\n    (= (last (first board)) (last (second board)) (last (last board)) :x) :x\n    (= (first (first board)) (second (second board)) (last (last board)) :x) :x\n    (= (first (last board)) (second (second board)) (last (first board)) :x) :x\n    (= (first (first board)) (second (first board)) (last (first board)) :x) :x\n    (= (first (second board)) (second (second board)) (last (second board)) :x) :x\n    (= (first (last board)) (second (last board)) (last (last board)) :x) :x\n\n    (= (first (first board)) (first (second board)) (first (last board)) :o) :o\n    (= (second (first board)) (second (second board)) (second (last board)) :o) :o\n    (= (last (first board)) (last (second board)) (last (last board)) :o) :o\n    (= (first (first board)) (second (second board)) (last (last board)) :o) :o\n    (= (first (last board)) (second (second board)) (last (first board)) :o) :o\n    (= (first (first board)) (second (first board)) (last (first board)) :o) :o\n    (= (first (second board)) (second (second board)) (last (second board)) :o) :o\n    (= (first (last board)) (second (last board)) (last (last board)) :o) :o\n    :else nil)\n\n  )","user":"5cd4e1b2e4b0ccb061962927"},{"problem":73,"code":"(fn p75 [board]\n (first (ffirst (remove empty?\n        (map (fn [tic]\n           (->> (select-keys (zipmap\n                             (range 0 9)\n                             (flatten board)) tic)\n              (vals)\n              (frequencies)\n               (filter #(= (val %) 3) )\n                (remove #(= (key %) :e))\n                \n               ))\n     [[0 1 2]\n     [3 4 5]\n[6 7 8]\n[0 3 6]\n[1 4 7]\n[2 5 8]\n[0 4 8]\n[2 4 6]])))))","user":"5400e918e4b0de5c41848619"},{"problem":73,"code":"(fn [board]\n  \t(first (first (filter \n        #(and\n     \t\t(= (nth % 0) (nth % 1) (nth % 2))\n           \t(not= :e (nth % 0))\n       \t)\n        (concat\n  \t\t\t(for [i (range 3)] [(get-in board [0 i]) (get-in board [1 i]) (get-in board [2 i])])\n  \t\t\t(for [i (range 3)] [(get-in board [i 0]) (get-in board [i 1]) (get-in board [i 2])])\n    \t\t[[(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])]\n    \t\t[(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])]]\n        )\n    )))\n)","user":"5cbdc591e4b026601754ba00"},{"problem":73,"code":"(fn [rows]\n  (let\n      [columns (apply map vector rows)\n       diagonal1 (into [] (map #(nth %2 %1) (range (count rows)) rows))\n       diagonal2 (into [] (map #(nth %2 %1) (range (- (count rows) 1) -1 -1) rows))\n       diagonals [diagonal1 diagonal2]\n       to-check (concat rows columns diagonals)\n       sets (map #(into #{} %) to-check)\n       filtered (first (filter #(and (= 1 (count %)) (not (contains? % :e))) sets))]\n    (first filtered)\n    )\n  )","user":"569fc70ee4b0542e1f8d1499"},{"problem":73,"code":"(fn [board]\n  (let [columns (for [x (range 3)] (map #(nth % x) board))        \n        diag1 (for [x (range 3)] (nth (board x) x))\n        diag2 (for [x (range 3)] (nth (board x) (- 2 x)))\n        allposs (concat board columns [diag1] [diag2])]\n    (#(cond\n       (empty? %) nil\n       (= (first %) [:x :x :x]) :x\n       (= (first %) [:o :o :o]) :o\n       :else (recur (rest %))) allposs)))","user":"5705e404e4b0b0fb43fd0676"},{"problem":73,"code":"(fn score [board]\n  (letfn [(to-matrix [board]\n            (mapv\n             (fn [row]\n               (mapv #(case %\n                        :e 0\n                        :x 1\n                        :o -1)\n                     row))\n             board))\n\n          (major [matrix]\n            (mapv\n             #(nth (nth matrix %) %)\n             (range (count matrix))))\n\n          (minor [matrix]\n            (mapv\n             #(nth (nth matrix %) (- 2 %))\n             (range (count matrix))))\n\n          (diagonals [matrix]\n            [(major matrix) (minor matrix)])\n\n          (columns [matrix]\n            (apply mapv vector matrix))\n\n          (solutions [matrix]\n            (reduce into [matrix\n                          (diagonals matrix)\n                          (columns matrix)]))]\n    (case (->> board\n               to-matrix\n               solutions\n               (map (partial reduce +))\n               (filter #{3 -3})\n               first)\n      nil nil\n      3 :x\n      -3 :o)))","user":"55fbc657e4b0f488688e0666"},{"problem":73,"code":"(fn [board]\n  (let [base-combinations (partition 3 (for [x (range 3) y (range 3)] [x y]))\n        combinations (concat base-combinations '(([2 0] [1 1] [0 2])) '(([0 0] [1 1] [2 2])) (apply map list base-combinations))]\n    (reduce (fn [acc combination]\n              (let [a (group-by identity (map #(get-in board %) combination))]\n                (if (not (nil? acc))\n                  acc\n                  (when (and (= 1 (count a)) (not= (first (keys a)) :e))\n                             (first (keys a))))))\n              nil combinations)))","user":"57147cd9e4b07c98581c3abf"},{"code":"(fn [ttt]\n              (letfn\n                [(chk3\n                      ([row]\n                      (if (and (apply = row) (not= ':e (first row)))\n                              (first row) nil))\n                      ([a b c]\n                      (if (and (= a b c) (not= ':e a))\n                              a nil)))\n                 (chkfn [f] (chk3 (map f ttt)))]\n                (let [top (first ttt)\n                      middle (nth ttt 1)\n                      bottom (last ttt)\n                      center (nth middle 1)]\n                  (cond\n                   (chk3 top) (first top)\n                   (chk3 middle) (first middle)\n                   (chk3 bottom) (first bottom)\n                   (chkfn first) (chkfn first)\n                   (chkfn #(nth %1 1)) center\n                   (chkfn last) (chkfn last)\n                   (chk3 (first top) center (last bottom)) center\n                   (chk3 (last top) center (first bottom)) center\n                   true nil))))","problem":73,"user":"525372ade4b0541d1855b8f3"},{"problem":73,"code":"(fn [arg](let [[l1 l2 l3] arg\n                  hor  (for [l arg]\n                         (for [a [:x :o]] \n                          (if (every? #{a} [(l 0) (l 1) (l 2)]) \n                            a)))\n                   vert   (for [i (range 3)]\n                            (for [a [:x :o]] \n                              (if (every? #{a} [(l1 i) (l2 i) (l3 i)]) \n                                a)))\n                   diag      (for [a [:x :o]]\n                               (if (or (every? #{a} [(l1 0) (l2 1) (l3 2)]) \n                                       (every? #{a} [(l1 2) (l2 1) (l3 0)]))\n                                 (vector a)))]\n               (some #{:x :o} (flatten (concat hor vert diag)))))","user":"53623eaee4b0243289761e4f"},{"code":"(fn [[[a _ b] [_ c _] [d _ e] :as x]]\n  (let [y (set (concat\n                (apply map vector x)\n                x\n                (list [a c e][b c d])))\n        f #(contains? y %)]\n    (if (f [:x :x :x]) :x\n      (if (f [:o :o :o]) :o))))","problem":73,"user":"533018b2e4b019098a6f8b56"},{"code":"(fn test [[[a1 a2 a3 :as v1]\n            [b1 b2 b3 :as v2]\n            [c1 c2 c3 :as v3]]]\n (let [who-won (fn [x y z]\n  (cond \n    (= x y z :x) :x\n    (= x y z :o) :o\n    :else nil))]\n  (reduce (fn [acc it]\n            (if (not acc)\n              (apply who-won it)\n              acc)) nil [v1 v2 v3 [a1 b1 c1] [a2 b2 c2] [a3 b3 c3] [a1 b2 c3] [a3 b2 c1]])))","problem":73,"user":"52aa16d1e4b0c58976d9ac5a"},{"problem":73,"code":"(fn [b]\n   (let\n     [chck (fn [[a b c]] (if (= a b c)\n                           (if (= a :e) nil a)\n                           nil))\n      \n      arr (flatten (conj      \n                    (map chck b)\n                    (map chck (apply map vector b))\n                    (chck [(ffirst b) (last (last b)) (fnext (fnext b))])\n                    (chck [(first (last b)) (last (first b)) (fnext (fnext b))])))\n      arr1 (filter #(not= % nil) arr)\n      ]  \n     (if (empty? arr1)\n       nil\n       (first arr1))\n     )\n   \n   )","user":"549375e4e4b0b312c081ff4e"},{"problem":73,"code":"(let [winning-positions (list\n    [[0 0] [0 1] [0 2]]\n    [[1 0] [1 1] [1 2]]\n    [[2 0] [2 1] [2 2]]\n    [[0 0] [1 0] [2 0]]\n    [[0 1] [1 1] [2 1]]\n    [[0 2] [1 2] [2 2]]\n    [[0 0] [1 1] [2 2]]\n    [[0 2] [1 1] [2 0]]\n  )\n  won? (fn [board player]\n    (some (fn [a] (every? #(= player (get-in board %)) a)) winning-positions\n    ))]\n  (fn [board]\n    (if (won? board :x) :x (if (won? board :o) :o nil)))\n)","user":"5681afaae4b0945ebc182a87"},{"problem":73,"code":"(fn [board]\n  (let [\n    cell (fn [r c] (nth (nth board r) c))\n    col (fn [c] (for [r (range 3)] (cell r c)))\n\n    rows board\n    cols [(col 0) (col 1) (col 2)]\n    diag1 [(cell 0 0) (cell 1 1) (cell 2 2)]\n    diag2 [(cell 0 2) (cell 1 1) (cell 2 0)]\n\n    all (concat rows cols [diag1 diag2])\n    result (map set all)]\n\n    (cond\n      (some #{#{:o}} result) :o\n      (some #{#{:x}} result) :x)))","user":"574dfcb8e4b02ea11479923a"},{"code":"(fn [boards]\n  (let [rows boards\n        cols (apply map vector rows)\n        diag1 (map vector (first rows) (rest (second rows)) (rest (rest (last rows))))\n        diag2 (map vector (rest (rest (first rows))) (rest (second rows)) (last rows))\n        all (concat rows cols diag1 diag2)\n        ]\n    (cond\n     (some #(= % [:x :x :x]) all) :x\n     (some #(= % [:o :o :o]) all) :o\n     :else nil)))","problem":73,"user":"4f0e995e535d0136e6c22326"},{"problem":73,"code":"(letfn [\n\n  ;; Functions for generating the indices in the sequence of cells evaluated\n  ;; for winning\n  (row-indices [k n]\n    (map (fn [i] [k i]) (range n)))\n\n  (col-indices [k n]\n    (map (fn [i] [i k]) (range n)))\n\n  (diag-indices [n]\n    (map (fn [i] [i i]) (range n)))\n\n  (anti-diag-indices [n]\n    (map (fn [i] [(- n (inc i)) i]) (range n)))\n\n\n  ;; Extract the element on the board at the given index\n  (at-index [board idx]\n    (reduce #(nth %1 %2) board idx))\n\n\n  ;; Extract sequences of elements from the board\n  (from-indices [board indices]\n    (map (partial at-index board) indices))\n\n  (elements-from-index-fun [board index-fun]\n    (from-indices board (index-fun (count board))))\n\n\n  ;; Extract those sequences that need to be saturated for a win\n  (winning-seqs [board]\n    (let [board-size (count board)\n          seq-of-1d-indices (range board-size)]\n      (map\n        (partial elements-from-index-fun board)\n        ;; Assemble a list of the index functions that should be used to get the\n        ;; slices of the board that need to be saturated for a win.\n        (concat\n          ;; Full row?\n          (map #(partial row-indices %) seq-of-1d-indices)\n          ;; Full column?\n          (map #(partial col-indices %) seq-of-1d-indices)\n          ;; Full diagonals?\n          [diag-indices]\n          [anti-diag-indices]))))\n\n\n  ;; Is a winning sequence saturated with the given symbol?\n  (player-is-winning [board player-symbol]\n    (some\n      (partial every? #(= player-symbol %))\n      (winning-seqs board)))\n\n\n  ;; Utility function: return the first item in coll that matches pred\n  (first-matching [pred coll]\n    (first (filter pred coll)))\n\n\n  ;; Determine if there's a winner\n  (winners [board]\n    (let [players [:x :o]]\n      (first-matching (partial player-is-winning board) players)))]\n\n  winners)","user":"57300c19e4b0cd1946bd0fa1"},{"problem":73,"code":"(fn won? [board]\n  (let [indexes (range 0 3)\n        get-matrix-pt (fn [matrix r c] (nth (nth matrix c) r))\n        get-cols (fn [board] (map (fn [i] (map (fn [row] (nth row i)) board)) (range 0 3)))\n        get-diag (fn [board] [(map (partial get-matrix-pt board) indexes indexes)\n                              (map (partial get-matrix-pt board) indexes (reverse indexes))]) \n        get-possibilities (fn [board] (concat board\n                                              (get-cols board)\n                                              (get-diag board)))\n        side-won? (fn [side possibilities] (some (fn [p] (every? #(= side %) p)) possibilities))\n        possibilities (get-possibilities board)]\n    (cond (side-won? :x possibilities) :x\n          (side-won? :o possibilities) :o\n          :else nil)))","user":"56a51f26e4b0542e1f8d14e0"},{"code":"(fn [board]\r\n  (let [flat-board (flatten board)\r\n\t      wins       [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\r\n\t\t    check-win  (fn [win player] (if (apply = player (map (partial nth flat-board) win)) player nil))]\r\n\t\t(loop [wins-left wins]\r\n\t\t\t(if-let [[w & ws] (seq wins-left)]\r\n\t\t\t\t(cond\r\n\t\t\t\t\t(check-win w :x) :x\r\n\t\t\t\t\t(check-win w :o) :o\r\n\t\t\t\t\t:else            (recur ws))))))","problem":73,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn get-tic-tac-toe-winner[game] \n  (cond \n    (= (= (nth (nth game 0) 0) :e) (= (nth (nth game 0) 1) :e) (= (nth (nth game 0) 2) :e)) nil\n    (= (nth (nth game 0) 0) (nth (nth game 0) 1) (nth (nth game 0) 2)) (nth (nth game 0) 0)\n    (= (nth (nth game 1) 0) (nth (nth game 1) 1) (nth (nth game 1) 2)) (nth (nth game 1) 0)\n    (= (nth (nth game 2) 0) (nth (nth game 2) 1) (nth (nth game 2) 2)) (nth (nth game 2) 0)\n    (= (nth (nth game 0) 0) (nth (nth game 1) 1) (nth (nth game 2) 2)) (nth (nth game 0) 0)\n    (= (nth (nth game 2) 0) (nth (nth game 1) 1) (nth (nth game 0) 2)) (nth (nth game 2) 0)\n    (= (nth (nth game 0) 0) (nth (nth game 1) 0) (nth (nth game 2) 0)) (nth (nth game 0) 0)\n    (= (nth (nth game 0) 1) (nth (nth game 1) 1) (nth (nth game 2) 1)) (nth (nth game 0) 1)\n    (= (nth (nth game 0) 2) (nth (nth game 1) 2) (nth (nth game 2) 2)) (nth (nth game 0) 2)\n  )\n)","problem":73,"user":"52b71bd2e4b0c58976d9ad4d"},{"problem":73,"code":"(fn win?\n  [board]\n  (let [b1 (nth board 0)\n        b2 (nth board 1)\n        b3 (nth board 2)\n        c1 (map #(get-in board [% 0]) [0 1 2])\n        c2 (map #(get-in board [% 1]) [0 1 2])\n        c3 (map #(get-in board [% 2]) [0 1 2])\n        d1 (map #(get-in board [% %]) [0 1 2])\n        d2 (map #(get-in board %) [[2 0] [1 1] [0 2]])]\n    (let [xs [b1 b2 b3 c1 c2 c3 d1 d2]\n          condi (map (fn [a] (let [x (set a)]\n                               (if (= 1 (count x))\n                                 (first x)\n                                 nil)))\n                     xs)\n          win (filter #(not (or (nil? %) (= :e %))) condi)]\n      (if (empty? win)\n        nil\n        (first win)))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [t]\r\n  (letfn \r\n    [(win [tab pl]\r\n          (let [wins\r\n                     [[[0 0] [0 1] [0 2]] \r\n                      [[1 0] [1 1] [1 2]] \r\n                      [[2 0] [2 1] [2 2]] \r\n                      [[0 0] [1 0] [2 0]] \r\n                      [[0 1] [1 1] [2 1]] \r\n                      [[0 2] [1 2] [2 2]] \r\n                      [[0 0] [1 1] [2 2]] \r\n                      [[0 2] [1 1] [2 0]]]] \r\n                 (some \r\n                   (fn [winpos] \r\n                     (every? \r\n                       #(= ((tab (first %)) (second %)) pl) \r\n                       winpos))\r\n                   wins)))] \r\n    (cond (win t :x) :x (win t :o) :o :else nil)))","problem":73,"user":"4feada56e4b0140c20fb9c11"},{"problem":73,"code":"(fn [v3]\n    (let [\n          a1 (v3 0)\n          a2 (v3 1)\n          a3 (v3 2)\n             \n          mylines [a1 a2 a3\n         [(a1 0) (a2 0) (a3 0)]\n         [(a1 1) (a2 1) (a3 1)]\n         [(a1 2) (a2 2) (a3 2)]\n\n         [(a1 0) (a2 1) (a3 2)]\n         [(a1 2) (a2 1) (a3 0)]         \n         \n         ] ]\n\n       (if (> (count (filter  #(apply = (conj %1 :x) ) mylines)) 0 ) :x\n         (if (> (count (filter  #(apply = (conj %1 :o) ) mylines)) 0 ) :o nil ) )\n       )\n    )","user":"561c725de4b064ca9f4b169a"},{"problem":73,"code":"(fn [field]\n  (letfn [\n    (winner? [p]\n      (let [\n        line [p p p]\n        winning (->>\n          [\n           [[0 0] [0 1] [0 2]]\n           [[1 0] [1 1] [1 2]]\n           [[2 0] [2 1] [2 2]]\n           [[0 0] [1 0] [2 0]]\n           [[0 1] [1 1] [2 1]]\n           [[0 2] [1 2] [2 2]]\n           [[0 0] [1 1] [2 2]]\n           [[0 2] [1 1] [2 0]]]\n          (map (fn [l] (map (fn [[row col]] (nth (nth field row) col)) l))))\n      ]\n        (some (partial = line) winning)))]\n    (cond\n      (winner? :x) :x\n      (winner? :o) :o\n      :else nil)))","user":"5901158de4b0438e51c2d039"},{"problem":73,"code":"(fn f\n  [ttt]\n  (letfn [(check [symb input]\n              (let [expected (repeat 3 symb)]\n                 (or\n                    (= (take-nth 3 (drop 0 input)) expected)\n                    (= (take-nth 3 (drop 1 input)) expected)\n                    (= (take-nth 3 (drop 2 input)) expected)\n                    (= (->> input (drop 0) (take 3)) expected)\n                    (= (->> input (drop 3) (take 3)) expected)\n                    (= (->> input (drop 6) (take 3)) expected)\n                    (= (concat [(nth input 0)] [(nth input 4)] [(nth input 8)]) expected)\n                    (= (concat [(nth input 2)] [(nth input 4)] [(nth input 6)]) expected)\n                  )))]\n    (let [input (apply concat ttt)]\n      (cond\n       (check :x input) :x\n       (check :o input) :o))))","user":"54021f13e4b0df28a13c62cc"},{"code":"(fn tic-tac-toe [board]\n  (let [i (range 3)\n        p (flatten (map #(repeat 3 %) i))\n        c (take 12 (cycle i))\n        win (fn [who]\n              (some\n                (fn [ps]\n                  (every? #(= who (get-in board %)) ps))\n                (partition 3 (into (map vector (into i p) c)\n                                   (map vector c (into (reverse i) p))))))]\n        (cond\n          (win :x) :x\n          (win :o) :o\n          :else nil)))","problem":73,"user":"51460e4ce4b04ef915e37314"},{"problem":73,"code":"(fn [coll]\n  (->> (concat\n        (map identity coll)\n        (apply map (fn [& args] args) coll)\n        (vector (map-indexed #(nth %2 %1) coll)\n                (map-indexed #(nth %2 %1) (reverse coll))))\n       (map distinct)\n       (filter #(= 1 (count %)))\n       flatten\n       first\n       {:x :x :o :o}))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn [x]\n  (letfn [(diagonal\n           [x]\n           (map #(nth %2 %1) (range) x))\n          (transpose\n           [x]\n           (apply map vector x))\n          (check-sub\n           [x k]\n           (or (some #(every? #{k} %) x)\n               (every? #{k} (diagonal x))\n               (every? #{k} (diagonal (map reverse x)))))\n          (check\n           [x k]\n           (or (check-sub x k)\n               (check-sub (transpose x) k)))]\n    (cond\n     (check x :x) :x\n     (check x :o) :o\n     :else nil)))","problem":73,"user":"4fa98b72e4b081705acca1e2"},{"problem":73,"code":"(fn decide\n    [board]\n    (let [moves [[[0 0] [0 1] [0 2]]\n                 [[1 0] [1 1] [1 2]]\n                 [[2 0] [2 1] [2 2]]\n                 [[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]\n                 [[0 0] [1 1] [2 2]]\n                 [[0 2] [1 1] [2 0]]]]\n      (->>  (map  #(frequencies (map (fn [v] (get-in board v)) %)) moves)\n            (filter #(= 1 (count %)))\n            (apply merge)\n            (reduce (fn [old [k v]] (cond (or (= k :x) (= k :o)) k :else old)) nil))))","user":"53d0c3c9e4b00fb29b22130a"},{"code":"(fn ttt [b]\n  (let [win? (fn [rs sym]\n               (= 3 (->> rs\n                         (filter #(= sym %))\n                         count)))\n        sel-index (fn [xs is]\n                    (map #(nth (flatten xs) %) is))\n        indexes [[0 1 2]\n                 [3 4 5]\n                 [6 7 8]\n                 [0 3 6]\n                 [1 4 7]\n                 [2 5 8]\n                 [0 4 8]\n                 [2 4 6]]\n        chk-board (fn [board idxs sym]\n                    (->> idxs\n                         (map #(sel-index board %))\n                         (reduce #(or % (win? %2 sym)) false)))]\n    (->> {:x (chk-board b indexes :x)\n     \t\t\t:o (chk-board b indexes :o)}\n         (filter #(nth % 1))\n         first\n         first)))","problem":73,"user":"4fc93728e4b0ee37620e1844"},{"problem":73,"code":"(fn [ttt]\n  (first\n    (filter #(or (= % :x) (= % :o))\n            (map #(first %)\n                 (filter #(apply = %)\n                         (concat (vector (ttt 0)) (vector (ttt 1)) (vector (ttt 2))\n                                 (for [x [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]]\n                                   (mapcat (fn [[f v]] (list (f v))) (partition 2 (interleave ttt x))))))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":73,"code":"(letfn [(chk [c p1 p2 p3 v]\n   (= c (nth v p1) (nth v p2) (nth v p3)))\n        \n  (win [c v]\n   (or (chk c 0 1 2 v)\n       (chk c 3 4 5 v)\n       (chk c 6 7 8 v)\n       (chk c 0 3 6 v)\n       (chk c 1 4 7 v)\n       (chk c 2 5 8 v)\n       (chk c 0 4 8 v)\n       (chk c 2 4 6 v)))]\n  \n (fn [m]\n  (let [m (flatten m)]\n  (cond\n   (win :x m) :x\n   (win :o m) :o\n))))","user":"56bca51ae4b0f26550335963"},{"problem":73,"code":"(fn [board]\n  (let [X :x\n        O :o\n\n        winning-positions [[[0 0] [0 1] [0 2]]\n                           [[1 0] [1 1] [1 2]]\n                           [[2 0] [2 1] [2 2]]\n\n                           [[0 0] [1 0] [2 0]]\n                           [[0 1] [1 1] [2 1]]\n                           [[0 2] [1 2] [2 2]]\n\n                           [[0 0] [1 1] [2 2]]\n                           [[0 2] [1 1] [2 0]]]\n\n        pos-wins?\n        (fn [winning-pos sym]\n          (every?\n            #(= (get (get board (get % 0)) (get % 1)) sym)\n                winning-pos))\n\n        wins?\n        (fn [sym]\n          (when (some #(pos-wins? % sym) winning-positions) sym))\n        ]\n    (or\n      (and (wins? X) X)\n      (and (wins? O) O)\n      nil)))","user":"5fc51d88e4b0ad564c76812a"},{"code":"(fn analyze-tic-tac-toe [board]\n  (let [things-to-check \n     [{:step (fn [z] [(first z),(inc (second z))])\n           :start [[0,0] [1,0] [2,0]]}\n       {:step (fn [z] [(inc (first z)),(second z)])\n           :start [[0,0] [0,1] [0,2]]}\n       {:step (fn [z] [(inc (first z)),(inc (second z))])\n           :start [[0,0]]}\n       {:step (fn [z] [(inc (first z)),(dec (second z))])\n           :start [[0,2]]}]\n      pieces #{:x :o}]\n    (some pieces (map\n      #(if (reduce\n        (fn [b3 thing-to-check]\n          (or b3 (reduce\n            (fn [b2 start]\n              (or b2 (reduce\n                 (fn [b coord] (let [[x y] coord]\n                     (and b (= % (nth (nth board x) y)))))\n                 true\n                 (take 3 (iterate (thing-to-check :step) start)))))\n            false\n            (thing-to-check :start))))\n        false\n        things-to-check)\n        %)\n      pieces))))","problem":73,"user":"4ea7999e535d7eef308072ee"},{"problem":73,"code":"(fn [board]\n  (letfn [(rows [board] board)\n          (cols [board] (apply map vector board))\n          (diags [board]\n            (let [coords [[[0 0] [1 1] [2 2]]\n                          [[0 2] [1 1] [2 0]]]]\n              (map #(map (fn [[r c]]\n                           (nth (nth board r) c))\n                         %)\n                    coords)))\n          (winner? [board]\n            (or (every? (partial = :x) board)\n                (every? (partial = :o) board)))]\n    (ffirst (filter winner? (concat (rows board)\n                                    (cols board)\n                                    (diags board))))))","user":"52951156e4b02ebb4ef7501b"},{"problem":73,"code":"#(let [r (range 0 (count %))\nmap-r {:x {:x :x} :o {:o :o}}\nr-f (fn [sign1 sign2] (get-in map-r [sign1 sign2]))\nnth-f (fn [index] (fn [x] (nth x index)))\nget-f (fn [x] (get-in % x))\ncolumn (fn [x] (reduce r-f (map (nth-f x) %)))\ncolumns (map column r)\nrows (map (fn [x] (reduce r-f x)) %)\nsame-i (for [z r] [z z])\nslash-diagonal (reduce r-f (map get-f same-i))\nfi-f (fn [[z t]] (= (+ z t) (- (count %) 1)))\nsame-sum-i (filter fi-f (for [z r t r] [z t]))\nbackslash-diagonal (reduce r-f (map get-f same-sum-i))]\n(first (filter (complement nil?) (flatten (list rows columns slash-diagonal backslash-diagonal)))))\n;can cope with size > 3","user":"5e13a6b7e4b099d064963001"},{"code":"(fn [ex]\n  (let [cols (apply map vector ex)\n        rows ex\n        diag (split-at 3 (map #(nth (nth ex %2) %1) [0 1 2 2 1 0] [0 1 2 0 1 2]))\n        same (map #(if (apply = %)\n                       (first %)\n                       nil)\n                  (concat cols rows diag))]\n    (if (some #{:x} same)\n        :x\n        (if (some #{:o} same)\n            :o\n            nil))))","problem":73,"user":"5069c09be4b01dc6af13f837"},{"problem":73,"code":"(fn\n  [board]\n  (letfn [(cols [b] (map #(take-nth 3 (drop % (flatten b))) (range 0 3)))\n          (rows [b] (map #(take 3 (drop (* 3 %) (flatten b))) (range 0 3)))\n          (udiag [b] (list (take 3 (drop 1 (take-nth 2 (flatten b))))))\n          (ddiag [b] (list (take-nth 4 (flatten b))))]\n    (let [wins (filter\n                #(and (not= (first %) :e)\n                      (apply = %))\n                (mapcat #(% board) [cols rows udiag ddiag]))]\n      (when wins (first (first wins))))))","user":"5ec02e20e4b00a66d4a95288"},{"code":"(fn winner\n  [board]\n  (some (fn [line]\n          (let [plays (set (map (partial get-in board) line))]\n            (when-not (or (:e plays) (and (:x plays) (:o plays)))\n              (first plays))))\n        [[[0 0] [0 1] [0 2]]\n         [[1 0] [1 1] [1 2]]\n         [[2 0] [2 1] [2 2]]\n         [[0 0] [1 0] [2 0]]\n         [[0 1] [1 1] [2 1]]\n         [[0 2] [1 2] [2 2]]\n         [[0 0] [1 1] [2 2]]\n         [[0 2] [1 1] [2 0]]]))","problem":73,"user":"5341b141e4b00652c8746ecf"},{"problem":73,"code":"(fn [m] (let [transpose (fn [m] (apply mapv vector m)) tm (transpose m) rows (count m) cols (count tm) runwin (fn [v] (and (apply = v) (get v 1))) winner (fn [xo] (let [w (and (or (= :x xo) (= :o xo)) xo)] (if w w nil))) diagf (fn [m] (loop [result nil i 0] (if (= i (count m)) (into [] (reverse result)) (recur (conj result (-> m (get i) (get i))) (inc i))))) pdiag (diagf m) sdiag (diagf (into [] (reverse m))) runs (concat m tm [pdiag sdiag])] (some identity (map (comp winner runwin) runs))))","user":"5d03b2c4e4b0cc9c915881ca"},{"code":"(fn [b] (letfn [(cw [p b w]\n          (every? #(= p (get (vec (flatten b)) %)) w))\n  \n        (w? [b w]\n          (if (cw :x b w) :x\n            (if (cw :o b w) :o nil)))\n  \n        (win [b]\n          (let [ws [[0 1 2] [3 4 5] [6 7 8]\n                     [0 3 6] [1 4 7] [2 5 8]\n                     [0 4 8] [2 4 6]]] \n            (reduce (fn [w win] (if w w (w? b win))) nil ws)))]\n  (win b)))","problem":73,"user":"4e7e93f5535db169f9c7971a"},{"code":"(fn [m]\n  (first\n   (first\n    (filter #(and (not= (first %) :e) (apply = %))\n            (concat m (apply map vector m)\n                    [(map #(get-in m [% %])        (range 3))\n                     (map #(get-in m [% (- 2  %)]) (range 3))])))))","problem":73,"user":"4ee88bfb535d93acb0a66881"},{"problem":73,"code":"(fn func [coll]\n  (let [[r1 r2 r3] coll\n        winner? (fn [coll]\n            (if (and (apply = coll)\n                     (not= :e (first coll))) coll))]\n    (cond\n      (winner? r1) (first r1)\n      (winner? r2) (first r2)\n      (winner? r3) (first r3)\n      :else (let [c1 (map first coll)\n                  c2 (map second coll)\n                  c3 (map last coll)]\n              (cond\n                (winner? c1) (first c1)\n                (winner? c2) (first c2)\n                (winner? c3) (first c3)\n                :else (let [d1 (map #(%1 %2) [first second #(nth %1 2)] coll)\n                            d2 (map #(%1 %2) [#(nth %1 2) second first] coll)]\n                        (cond\n                          (winner? d1) (first d1)\n                          (winner? d2) (first d2)\n                          :else nil)))))))","user":"5eccc5c2e4b016b56eae058f"},{"problem":73,"code":"(fn [tic]\n             (let [res ((memoize (fn [col]\n                                   (set (reduce (fn [result x]\n                                                  (concat result [((fn [row]\n                                                                     (let [sr (set row)]\n                                                                       (when (= 1 (count sr))\n                                                                         (if (contains? sr :x)\n                                                                           :x\n                                                                           (when (contains? sr :o)\n                                                                             :o))))) x)]))\n                                                [] ((fn [tic]\n                                                      (concat tic\n                                                              ((fn [tic]\n                                                                 (apply map vector tic))\n                                                               tic)\n                                                              [((fn [tic]\n                                                                  [(get (get tic 0) 0) (get (get tic 1) 1) (get (get tic 2) 2)])\n                                                                tic)]\n                                                              [((fn [tic]\n                                                                  [(get (get tic 0) 2) (get (get tic 1) 1) (get (get tic 2) 0)])\n                                                                tic)]))\n                                                    col))))) tic)]\n               (if (contains? res :x)\n                 :x\n                 (if (contains? res :o)\n                   :o\n                   nil))))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"(fn ttt [brd]\r\n  (letfn [(win? [coll] (#{:x :o} (reduce #(if (= % %2) %) coll)))\r\n          (flip [coll] (for [c (range 3)] (map #(nth % c) coll)))\r\n          (dia1 [coll] (vector (map #(% %2) [first second last] coll)))\r\n          (dia2 [coll] (vector (map #(% %2) [last second first] coll)))\r\n          (all [coll] (concat coll (flip coll) (dia1 coll) (dia2 coll)))]\r\n    (some win? (all brd))))","problem":73,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":73,"code":"(fn [b]\n    (let [c (map set (apply mapv vector b))\n          r (map set b)\n          d #(conj % (get-in b %2))\n          d1 (reduce d #{} [[0 0] [1 1] [2 2]])\n          d2 (reduce d #{} [[0 2] [1 1] [2 0]])\n          diags (list d1 d2)\n          m (apply clojure.set/union\n                   (filter #(< (count %) 2)\n                           (concat r c diags)))]\n      (cond\n        (contains? m :x) :x\n        (contains? m :o) :o\n        :else nil)))","user":"5881335ce4b0f1effa3b762e"},{"problem":73,"code":"(letfn[(wins? [rcd] (or (and (= (repeat 3  :o) rcd) :o)\n                        (and (= (repeat 3 :x) rcd) :x)\n                        nil))\n       (transpose [m] (apply map list m))\n       (nnth [m n] (nth (nth m n) n))\n       (diags [m] (map #(map (partial nnth %) (range 3))\n                       (list m (reverse m))))]\n  (fn f [m] (first (remove nil? (map wins? (concat m (transpose m) (diags m)))))))","user":"54857e3be4b0e286459a11ad"},{"problem":73,"code":"(fn analyse-ttt [board]\n    (let [verticals (apply mapv vector board)\n          diagonals [(map get board [0 1 2]) (map get board [2 1 0])]\n          directions (concat board verticals diagonals)]\n        (loop [[d & tail] directions]\n            (cond (nil? d) nil\n                  (every? #(= :o %) d) :o\n                  (every? #(= :x %) d) :x\n                  :else (recur tail)))))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn [b]\n   (let [xs (range 3)]\n     (->> [(map #(get-in b [% (- 2 %)]) xs)]\n          (concat\n           b\n           (map (fn [x] (map #(nth % x) b)) xs)\n           [(map #(get-in b [% %]) xs)])\n          (filter #(and (apply = %) (#{:x :o} (first %))))\n          ffirst)))","problem":73,"user":"4ea5e32a535d7eef308072de"},{"problem":73,"code":"(fn [board]\n  (let [wins [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n        win? (fn [[[r c] & tail]]\n               (let [player ((board r) c)]\n                 (when (every? #(= player %) \n                               (map #((board (% 0)) (% 1)) tail))\n                   player)))]\n    (some #(when (or (= :x %) (= :o %))\n             %)\n          (map win? wins))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(fn [b]\r\n  (let [r (range 3)\r\n        w \r\n    (concat\r\n      (for [x r]\r\n        (for [y r] [x y]))\r\n      (for [x r]\r\n        (for [y r] [y x]))\r\n      [[[0 0] [1 1] [2 2]]]\r\n      [[[2 0] [1 1] [0 2]]])\r\n        p (fn [[x y]] (nth (nth b x) y))\r\n        m #(every? (partial = %) (map p %2))\r\n        v #(some true? (map (partial m %) w))]\r\n    (cond \r\n      (v :x) :x\r\n      (v :o) :o)))","problem":73,"user":"4e03c616535d04ed9115e796"},{"code":"(fn [v]\n  (let [l1 (list (if (= ((v 0) 0) ((v 0) 1) ((v 0) 2)) ((v 0) 0) nil)\n                 (if (= ((v 1) 0) ((v 1) 1) ((v 1) 2)) ((v 1) 0) nil)\n                 (if (= ((v 2) 0) ((v 2) 1) ((v 2) 2)) ((v 2) 0) nil)\n                 (if (= ((v 0) 0) ((v 1) 0) ((v 2) 0)) ((v 0) 0) nil)\n                 (if (= ((v 0) 1) ((v 1) 1) ((v 2) 1)) ((v 0) 1) nil)\n                 (if (= ((v 0) 2) ((v 1) 2) ((v 2) 2)) ((v 0) 2) nil)\n                 (if (= ((v 0) 0) ((v 1) 1) ((v 2) 2)) ((v 0) 0) nil)\n                 (if (= ((v 0) 2) ((v 1) 1) ((v 2) 0)) ((v 0) 2) nil))\n        l2 (map #(if (or (nil? %) (= :e %)) nil %) l1)]\n    (cond (some #(= :o %) l2) :o\n          (some #(= :x %) l2) :x\n          :else nil)))","problem":73,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":73,"code":"(fn [board]\n  (let [row-defs [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        row (fn [row-def] (map #((-> board flatten vec) %) row-def))\n        count-pieces (fn [row piece] (count (filter #(= piece %) row)))\n        three-in-a-row? (fn [piece] (= 3 (apply max (map #(-> % row (count-pieces piece)) row-defs))))]\n    (cond\n      (three-in-a-row? :x) :x\n      (three-in-a-row? :o) :o)))","user":"578fc072e4b0ebec4cfb759a"},{"problem":73,"code":"(fn [a]\n\t((fn b [c]\n\t\t(if (= (get (get a 0) 0) (get (get a 0) 1) (get (get a 0) 2) c)\n\t\t\t(get (get a 0) 0) \n\t\t\t(if (= (get (get a 1) 0) (get (get a 1) 1) (get (get a 1) 2) c) \n\t\t\t\t(get (get a 1) 0) \n\t\t\t\t(if (= (get (get a 2) 0) (get (get a 2) 1) (get (get a 2) 2) c) \n\t\t\t\t\t(get (get a 2) 0) \n\t\t\t\t\t(if (= (get (get a 0) 0) (get (get a 1) 1) (get (get a 2) 2) c) \n\t\t\t\t\t\t(get (get a 0) 0) \n\t\t\t\t\t\t(if (= (get (get a 2) 0) (get (get a 1) 1) (get (get a 0) 2) c) \n\t\t\t\t\t\t\t(get (get a 2) 0) \n\t\t\t\t\t\t\t(if (= (get (get a 0) 0) (get (get a 1) 0) (get (get a 2) 0) c) \n\t\t\t\t\t\t\t\t(get (get a 0) 0) \n\t\t\t\t\t\t\t\t(if (= (get (get a 0) 1) (get (get a 1) 1) (get (get a 2) 1) c) \n\t\t\t\t\t\t\t\t\t(get (get a 0) 1) \n\t\t\t\t\t\t\t\t\t(if (= (get (get a 0) 2) (get (get a 1) 2) (get (get a 2) 2) c) \n\t\t\t\t\t\t\t\t\t\t(get (get a 0) 2) \n\t\t\t\t\t\t\t\t\t\t(if (= c :o) nil (b :o))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t) :x)\n)","user":"5710e574e4b09c608db7043b"},{"code":"(fn check [all]\n  (let [row-val (fn [row]               \n    (let [x (set row)]\n      (if (contains? x :e)\n      nil  \n        (if (= (count x) 1)\n          (first row)\n          nil\n        )\n      )\n      )\n  )]\n    (or \n       (row-val (get all 0))\n       (row-val (get all 1))\n       (row-val (get all 2))\n       (row-val (map #(get % 0) all))\n       (row-val (map #(get % 1) all))\n       (row-val (map #(get % 2) all))\n       (row-val \n         ((fn [col i] \n           (if (empty? col)\n             i\n             (recur (rest col) (conj i \n                                  (get\n                                     (first col)\n                                   (dec (count col)))\n                                ))\n           )\n        \n         )\n        all [])  )\n            (row-val \n         ((fn [col i] \n           (if (empty? col)\n             i\n             (recur (rest col) (conj i \n                                  (get\n                                     (first col)\n                                   (- 3 (count col)))\n                                ))\n           )\n        \n         )\n        all [])  )\n    )\n  )\n)","problem":73,"user":"5191045ee4b0f8ef0be96bf3"},{"problem":73,"code":"(fn [tic-tac]\n   (first (remove nil?\n                  (map (fn [s] (if (= (count (group-by identity s)) 1) (if (= (first s) :e) nil (first s)) nil))\n                       (let [[m n o] tic-tac]\n                         (conj tic-tac\n                               [(first m) (first n) (first o)]\n                               [(second m) (second n) (second o)]\n                               [(last m) (last n) (last o)]\n                               [(first m) (second n) (last o)]\n                               [(last m) (second n) (first o)]))))))","user":"607d6bc1e4b03d835a6eaecc"},{"code":"(fn tic-tac-toe [f]\n  (cond\n   (or\n    (= ((f 0) 0) ((f 0) 1) ((f 0) 2) :o)\n    (= ((f 1) 0) ((f 1) 1) ((f 1) 2) :o)\n    (= ((f 2) 0) ((f 2) 1) ((f 2) 2) :o)\n    \n    (= ((f 0) 0) ((f 1) 0) ((f 2) 0) :o)\n    (= ((f 0) 1) ((f 1) 1) ((f 2) 1) :o)\n    (= ((f 0) 2) ((f 1) 2) ((f 2) 2) :o)\n    \n    (= ((f 0) 0) ((f 1) 1) ((f 2) 2) :o)\n    (= ((f 0) 2) ((f 1) 1) ((f 2) 0) :o)) :o\n\n   (or\n    (= ((f 0) 0) ((f 0) 1) ((f 0) 2) :x)\n    (= ((f 1) 0) ((f 1) 1) ((f 1) 2) :x)\n    (= ((f 2) 0) ((f 2) 1) ((f 2) 2) :x)\n    \n    (= ((f 0) 0) ((f 1) 0) ((f 2) 0) :x)\n    (= ((f 0) 1) ((f 1) 1) ((f 2) 1) :x)\n    (= ((f 0) 2) ((f 1) 2) ((f 2) 2) :x)\n    \n    (= ((f 0) 0) ((f 1) 1) ((f 2) 2) :x)\n    (= ((f 0) 2) ((f 1) 1) ((f 2) 0) :x)) :x\n\n   true nil))","problem":73,"user":"4e28120f535deb9a81d77efa"},{"code":"(fn [b]\n  (let [rs (for [x [0 1 2]] (for [y [0 1 2]] [x y]))\n  \tp (concat rs (map #(map reverse %) rs)\n           [[[0 0] [1 1] [2 2]]\n            [[0 2] [1 1] [2 0]]])\n        w (fn [x s]\n            (every? #(do %) \n                    (map (fn [[r c]] (= x (nth (nth b r) c)))\n                         s)))\n        t (fn [x] \n            (some #(w x %) p))]\n    (cond (t :x) :x\n          (t :o) :o\n          :t nil)))","problem":73,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn [board]\n  (first (first (remove #(= #{:e} %)\n  (filter #(= (count %) 1) \n    (set (map set (partition 3 \n      (map (vec (flatten board)) \n[0 3 6, 1 4 7, 2 5 8, 0 1 2, 3 4 5, 6 7 8, 0 4 8, 2 4 6])))))))))","problem":73,"user":"4f69681ee4b07046d9f4ef89"},{"problem":73,"code":"(fn [board] \n    (let [rows board \n          cols (apply map vector board)\n          diag1 (apply vector (map #(get %1 %2) board [ 0 1 2 ]))\n          diag2 (apply vector (map #(get %1 %2) board [ 2 1 0 ]))\n          data (apply conj (conj rows diag1 diag2) cols )\n          winners (set (map #(apply vector (repeat 3 %1)) [:x :o]))\n          winner (some winners data)]\n      (if winner\n        (first winner)\n        nil)))","user":"57974188e4b039eba2ecb0f4"},{"problem":73,"code":"(fn [board]\n  (let [transpose (into ()\n                        (apply map vector board))\n        get-diag (fn [board]\n                   (map-indexed (fn [idx item] (get item idx)) board))\n        check-row (fn [k board]\n                    (some true? (map\n                                 #(every? #{k} %) board)))\n        check-diag (fn [k board]\n                     (every? #{k} (get-diag board)))\n        check-board (fn [k board]\n                      (mapcat\n                       (juxt\n                        (partial check-row k)\n                        (partial check-diag k))\n                       [board transpose]))]\n    (cond\n     (some true? (check-board :x board)) :x\n     (some true? (check-board :o board)) :o\n     :else nil\n     )))","user":"5724a4dae4b0c5bde472c0fe"},{"problem":73,"code":"(fn [board]\n  (letfn [(idxs [vertical? board-size]\n            (into #{}\n                  (map (fn [idx]\n                         (into #{}\n                               (map #(if vertical?\n                                       (vector idx %)\n                                       (vector % idx))\n                                    (range board-size))))\n                       (range board-size))))\n          (cross-idxs [board-size]\n            #{(into #{}\n                    (map #(vector % %)\n                         (take board-size (iterate inc 0))))\n              (into #{}\n                    (map #(vector %1 %2)\n                         (take board-size (iterate dec (dec board-size)))\n                         (take board-size (iterate inc 0))))})]\n    (let [board-size (count board)\n          winning-positions (->> (cross-idxs board-size)\n                                 (into (idxs true board-size))\n                                 (into (idxs false board-size)))\n          board-indexed (apply concat\n                               (map-indexed\n                                (fn [row-idx row]\n                                  (map-indexed\n                                   (fn [column-idx item]\n                                     [[row-idx column-idx] item])\n                                   row))\n                                board))\n          x-positions (->> board-indexed\n                           (filter (comp (partial = :x) second))\n                           (map first)\n                           (into #{}))\n          o-positions (->> board-indexed\n                           (filter (comp (partial = :o) second))\n                           (map first)\n                           (into #{}))]\n      (cond\n        (some #(clojure.set/subset? % x-positions) winning-positions)\n        :x\n        (some #(clojure.set/subset? % o-positions) winning-positions)\n        :o\n        :else\n        nil))))","user":"56e83348e4b02e7e935eb6e5"},{"problem":73,"code":"(fn tic-tac-toe-winner [board]\n  (let [winning-positions [; sadly can't use another method / def for that due to 4clojure\n                           [[0 0] [0 1] [0 2]]              ; first row\n                           [[1 0] [1 1] [1 2]]              ; second row\n                           [[2 0] [2 1] [2 2]]              ; third row\n                           [[0 0] [1 0] [2 0]]              ; first column\n                           [[0 1] [1 1] [2 1]]              ; second column\n                           [[0 2] [1 2] [2 2]]              ; third column\n                           [[0 0] [1 1] [2 2]]              ; diagonal top left to bottom right\n                           [[0 2] [1 1] [2 0]]              ; diagonal top right to bottom left\n                           ]\n        ]\n    (let [symbol-set (map #(map (fn [[row col]] ((board row) col)) %) winning-positions)]\n      (->> symbol-set\n           (map #(if (apply = %) (first %) nil))\n           (remove nil?)\n           (remove #(= % :e))\n           (first)\n           )\n      )\n    )\n  )","user":"5aada061e4b073f17744257a"},{"problem":73,"code":"(fn [g] (let [dist-count #(->> %\r\n                                 distinct\r\n                                 count)\r\n                chk (fn [x] (->> x\r\n                                 (filter #(= (dist-count %) 1))\r\n                                 (filter #(not (= (first %) :e)))\r\n                                 first\r\n                                 first))\r\n                transpose (fn [x] (mapv\r\n                                   #(mapv (fn [y] (get y (mod (- 2 %) 3))) x)\r\n                                   [0 1 2]))\r\n                chkd (fn [x]\r\n                       (let [l (->> (reduce #(conj %1 (get (get x %2) %2)) [] [0 1 2])\r\n                                    distinct)]\r\n                         (println l)\r\n                         (if (= 1 (count l))\r\n                           (first (filter #{:x :o} l)))))]\r\n            (or (chk g)\r\n                (chkd g)\r\n                (chk (transpose g))\r\n                (chkd (transpose g)))))","user":"53aaaf7ae4b047364c044444"},{"code":"(fn [board]\n  (let [vertical (apply map vector board)\n        diagonal [(map nth board (range))\n                  (map nth (rseq board) (range))]]\n    (->> (concat board vertical diagonal)\n         (filter #(apply = %))\n         ffirst\n         #{:x :o})))","problem":73,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn chk [board]\n  (letfn [(won? [xs]\n            (#{:x :o} (reduce #(when (#{%1} %2) %1) xs))) \n          (chk-rows []\n            (for [r (range 3)] (won? (get board r))))\n          (chk-cols []\n            (let [cols (for [c (range 3)] (for [r (range 3)] (get-in board [r c])))]\n              (map won? cols)))\n          (chk-diags []\n            (or (won? (for [x (range 3)] (get-in board [x x])))\n                (won? (map #(get-in board [%1 %2]) (range 2 -1 -1) (range 3)))))]\n    (some identity (concat [(chk-diags)] (chk-rows) (chk-cols)))))","problem":73,"user":"52c4af71e4b0c2d177d620e1"},{"code":";; analyze rows\n;; analyze columns\n;; analyze diagonals\n(fn ttt [b]\n  (let [r1 (first b)\n        r2 (second b)\n        r3 (last b)\n        c1 [(first r1) (first r2) (first r3)]\n        c2 [(second r1) (second r2) (second r3)]\n        c3 [(last r1) (last r2) (last r3)]\n        d1 [(first r1) (second r2) (last r3)]\n        d2 [(last r1) (second r2) (first r3)]\n        all [r1 r2 r3 c1 c2 c3 d1 d2]\n        proc (first (flatten (filter #(and (> 2 (count %)) (not= '(:e) %)) (map #(distinct %) all))))]\n          proc))","problem":73,"user":"4faafccde4b081705acca209"},{"problem":73,"code":"(fn [x]\n  (let [lines [[0 1 2]\n               [3 4 5]\n               [6 7 8]\n               [0 3 6]\n               [1 4 7]\n               [2 5 8]\n               [0 4 8]\n               [6 4 2]]]\n    (first\n      (reduce\n        (fn [acc line]\n          (let [row (int (Math/floor (/ (first line) 3)))\n                v (get-in x [row (mod (first line) 3)])]\n            (if (and (not= :e v)\n                     (every? #(= v (get-in x [(int (Math/floor (/ % 3)))\n                                              (mod % 3)])) line))\n              (vector v)\n              acc)))\n        [nil] lines))))","user":"5daae405e4b000c986472c44"},{"problem":73,"code":"(fn win? [board]\n  (let [flip-board (apply map vector board)\n        diag-board [(map #(get (get board %) %) (range 3)) (map #(get (get board %) (- 2 %)) (range 3))]]\n    (some #{:x :o} (mapcat (partial map #(when (apply = %) (first %))) [board flip-board diag-board]))))","user":"533b1611e4b0e30313ee6cc6"},{"problem":73,"code":"(fn tic-tac-toe [xs]\n  (let[wins? (fn [[x y z]] (cond (= :o x y z) :o (= :x x y z) :x :else nil))\n       tests (concat xs (apply map list xs) (let [[[a b c] [d e f] [g h i]] xs] [[a e i] [c e g]]))]\n    (some identity (map wins? tests))))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn tic-tac-toe [board]\n  (some #(#{:x :o} (let [sym (first %)]\n                     (when (every? (partial = sym) %)\n                       sym)))\n        (conj (into board (apply map vector board))\n              (for [n (range 3)] (get-in board [n n]))\n              (for [n (range 3)] (get-in board [n (- 2 n)])))))","problem":73,"user":"52ab6de1e4b0c58976d9ac78"},{"code":"(fn [B]\n  (letfn [(p [x y] (nth (nth B x) y))\n          (w [& r] (let [R (reduce conj #{} r)] (cond (= #{:x} R) :x (= #{:o} R) :o)))]\n    (or\n     (w (p 0 0) (p 1 1) (p 2 2))\n     (w (p 0 2) (p 1 1) (p 2 0))\n     (some identity\n           (for [i (range 3)]\n             (or\n              (w (p i 0) (p i 1) (p i 2))\n              (w (p 0 i) (p 1 i) (p 2 i))))))))","problem":73,"user":"4db8f6c4535d1e037afb219e"},{"problem":73,"code":"(fn [board]\n    (let [horiz-win (fn [board]                 \n                      (reduce #(if (and (= %1 nil) (apply = %2))\n                                  (%2 0)\n                                  %1)\n                              nil board))\n          diagonal-win (fn [topLeft]\n                           (let [range-fn (if (true? topLeft) identity reverse)]\n                             (let [diagonal (map get board (range-fn (range 0 (count (board 0)))))]\n                               (println diagonal)\n                               (if (and (not= (first diagonal) :e) (apply = diagonal)) (first diagonal) nil))))]\n      (let [result \n            (some identity [\n                            (horiz-win board)\n                            (horiz-win (apply mapv vector board))\n                            (diagonal-win true)\n                            (diagonal-win false)])]\n        (if (= result :e) nil result))))","user":"594c0bd7e4b07ddc2dafae56"},{"code":"(fn tic-tac-toe [board]\r\n  (let\r\n    [[top-row mid-row bot-row] board\r\n     [left-col mid-col right-col] \r\n        (map (fn [col] (map (fn [row-vec] (row-vec col)) board)) (range 3))\r\n     left-diag [ (get top-row 0) (get mid-row 1) (get bot-row 2)]\r\n     right-diag [ (get top-row 2) (get mid-row 1) (get bot-row 0) ]\r\n     all-streaks [top-row mid-row bot-row \r\n                  left-col mid-col right-col\r\n                  left-diag right-diag]\r\n     winner? (fn [streak] \r\n               (cond \r\n                 (every? #(= % :x) streak) :x\r\n                 (every? #(= % :o) streak) :o))\r\n     winners (filter #(not (nil? %)) (map winner? all-streaks))]\r\n     (if (seq winners)\r\n        (first winners))))","problem":73,"user":"4f036fb3535dcb61093f6ac8"},{"problem":73,"code":"(fn [rows]\n  (let [cols (apply mapv vector rows)\n        dias (vector (map-indexed #(nth %2 %1) rows)\n                     (map-indexed #(nth %2 (- (count %2) %1 1)) rows))\n        match? (fn [[t & ts]] (when (and (not= :e t) (apply = t ts)) t))]\n    (some match? (concat rows cols dias))))","user":"5ab16992e4b073f1774425c4"},{"problem":73,"code":"(fn [board]\n  (let [n (count board)\n        r (range 0 n)\n        w (->> \n           (reduce \n           (partial merge-with +)\n           (for [i r j r]\n             (let [v (get-in board [i j])\n                   p (cond (= v :x) 1\n                           (= v :o) -1\n                           :default 0)]\n               {(str \"row\" i) p,\n                (str \"col\" j) p,\n                :dig1 (if (= i j) p 0),\n                :dig2 (if (= i (- n 1 j)) p 0)})))\n         vals\n         (filter #(= n (max % (- %))))\n         first\n        )]\n    (cond (= w n) :x\n          (= w (- n)) :o)))","user":"537f4652e4b06839e8705eb1"},{"problem":73,"code":"(fn [rows]\n  (let [cols (apply mapv vector rows)\n        diags (map (fn [r] (map-indexed #(first (drop %1 %2)) r))\n                   [rows (reverse rows)])\n        candidates (map set (concat rows cols diags))]\n    (->> candidates\n         (filter (comp (partial = 1) count))\n         (remove #(contains? % :e))\n         first\n         first)))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [board]\n           (let [cell (fn [x y]  \n            (if (or (> x 2) (> y 2) (< x 0) (< y 0)) 0\n              (case ((board y) x) :x -1, :o 1 0)))\n                 col (fn [n] (+ (cell n 0) (cell n 1) (cell n 2)))\n                 row (fn [n] (+ (cell 0 n) (cell 1 n) (cell 2 n)))\n                 won? (fn [n] (or (= n 3) (= n -3)))\n                 winner (fn [n] (cond (> n 0) :o, (< n 0) :x, :default nil))\n                 d1 (+ (cell 0,0) (cell 1,1) (cell 2,2))\n                 d2 (+ (cell 2,0) (cell 1,1) (cell 0,2))]\n           (cond \n            (won? d1) (winner d1)\n            (won? d2) (winner d2)\n            (won? (col 0)) (winner (col 0))\n            (won? (col 1)) (winner (col 1))\n            (won? (col 2)) (winner (col 2))\n            (won? (row 0)) (winner (row 0))\n            (won? (row 1)) (winner (row 1))\n            (won? (row 2)) (winner (row 2))))\n           \n           \n           \n           \n           )","problem":73,"user":"533e45a7e4b085b17e897d8c"},{"problem":73,"code":"(fn [board]\n  (let [interleaved (apply interleave board)\n        board (concat board (partition 3 interleaved))\n        board (conj board (map #(nth interleaved %) [0 4 8]))\n        board (conj board (map #(nth interleaved %) [2 4 6]))\n        winner (filter #(and (not-any? #{:e} %) (= 1 (count (set %)))) board)]\n    (first (first winner))))","user":"57155980e4b07c98581c3ad7"},{"problem":73,"code":"(fn [board]\n  (let [winner\n        (fn [ [[a b c]\n               [d e f]\n               [h i j] :as board] ]\n          (let [test-line (fn [line] (reduce #(when (= %1 %2) %1) line))\n                lines  (concat board (apply map vector board) [[a e j] [c e h]])\n                scored-lines (map test-line lines) ]\n            \n            (cond (some #{:x} scored-lines)\n                  :x\n                  (some #{:o} scored-lines)\n                  :o\n                  :else\n                  nil\n              )))]\n    (winner board)\n    ))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":73,"code":"(fn [table]\n  (let [x? #(= :x %)\n        o? #(= :o %)\n        xs (vec (apply concat table))\n        winning-index [[0 1 2] [3 4 5]\n                       [6 7 8] [0 3 6]\n                       [1 4 7] [2 5 8]\n                       [0 4 8] [2 4 6]]\n        check-seq (map (fn [coll] (map xs coll)) winning-index)\n        x-win (some identity (map #(every? x? %) check-seq))\n        o-win (some identity (map #(every? o? %) check-seq))]\n    (cond\n     x-win :x\n     o-win :o\n     :else nil)))","user":"5cb41c40e4b026601754b911"},{"problem":73,"code":"(fn winner [rows]\n  (let [cols (partition 3 (apply interleave rows))\n        diag1 (map #(get-in rows %) [[0 2] [1 1] [2 0]])\n        diag2 (map #(get-in rows %) [[0 0] [1 1] [2 2]])\n        winnable-rows (concat rows cols [diag1 diag2])\n        is-winner (fn [kw]\n                    (some (fn [row] (every? #(= kw %) row))\n                          winnable-rows))]\n    (cond\n      (is-winner :x) :x\n      (is-winner :o) :o\n      :else nil\n      )\n    )\n  )","user":"59cc4d5ee4b0a024fb6ae5d0"},{"problem":73,"code":"(fn [m]\n  (letfn\n    [(row-winner-is [r]\n       (let [c1 (first r) c2 (second r) c3 (last r)]\n         (if (= c1 c2 c3) (if (= c1 :e) nil c1) nil)))\n     (row-winner [rows] (first (remove nil? (map row-winner-is rows))))\n     (l-diag [[[a b c] [d e f] [g h i]]] (vector a e i))\n     (r-diag [[[a b c] [d e f] [g h i]]] (vector c e g))\n    ]\n\n    (first (remove nil? [(row-winner m)                    ;; rows\n                         (row-winner (apply map vector m)) ;; columns\n                         (row-winner-is (l-diag m))        ;; left diagonal\n                         (row-winner-is (r-diag m))        ;; right diagonal\n                        ]))\n  )\n)","user":"54e5bdf2e4b024c67c0cf7fe"},{"code":"(fn f [[a b c]]\n  (letfn [\n    (e [a b c]\n      (cond\n        (= a b c :x) :x\n        (= a b c :o) :o\n        :else nil))\n    (o [a b c]\n       (or a b c))]\n  (or\n    (apply o (map #(apply e %) [a b c]))\n    (apply o (map e a b c))\n    (e (a 0) (b 1) (c 2))\n    (e (c 0) (b 1) (a 2)))))","problem":73,"user":"4e80e0f2535db62dc21a62b8"},{"code":"(fn [field]\n    (let [wins? \n          (fn [player field]\n            (let [field (apply concat field)\n                  bad-position? (fn [p field] \n                                  (not= player (nth field p)))\n                  \n                  good? (fn [positions field] \n                          (not-any? #(bad-position? %1 field) positions))\n                  ]\n              (condp good? field\n                [0 1 2] true\n                [3 4 5] true\n                [6 7 8] true\n                [0 3 6] true\n                [1 4 7] true\n                [2 5 8] true\n                [0 4 8] true\n                [2 4 6] true\n                false)        \n            ))]\n      (cond (wins? :x field) :x\n            (wins? :o field) :o\n            :else nil)\n    ))","problem":73,"user":"5356ac72e4b04ce2eb3ed26a"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (let [length (count board)\n        diagonals (conj [] (into [] (map (partial get-in board)\n                                         (take length\n                                               (iterate (fn [[x y]] [(inc x) (inc y)]) [0 0]))))\n                        (into [] (map (partial get-in board)\n                                      (take length\n                                            (iterate (fn [[x y]] [(inc x) (dec y)]) [0 (dec length)])))))\n\n        transpose (apply map vector board)\n        lists-to-check (concat board transpose diagonals)]\n    (cond\n      (contains? (set lists-to-check) (into [] (repeat length :x))) :x\n      (contains? (set lists-to-check) (into [] (repeat length :o))) :o\n      :else nil))\n  )","user":"5f29837ee4b033932238a64f"},{"problem":73,"code":"(fn [board] (let [[[a b c][d e f][g h i]] board\n                  winner (fn [coll] (cond (= [:x :x :x] coll) :x (= [:o :o :o] coll) :o :else nil))\n                  totalwinner (fn [winners] (first (filter (complement nil?) winners)))\n                  ]\n              (totalwinner (map winner [[a b c][d e f][g h i][a d g][b e h][c f i][a e i][c e g]]))\n             )\n)","user":"5dcfdf23e4b0948ae9d9ad43"},{"problem":73,"code":"(fn analyzes-a-tic-tac-toe-board\n  [v]\n  (let [[v1 v2 v3] v\n        [v4 v5 v6] (map vector v1 v2 v3)\n        \n        v7 [(first v1) (second v2) (last v3)]\n        v8 [(first v3) (second v2) (last v1)]\n\n        ret [v1 v2 v3 v4 v5 v6 v7 v8]]\n    (ffirst (filter #(and (apply = %) (= -1 (.indexOf % :e))) ret))))","user":"5586f418e4b059ccff29b1de"},{"problem":73,"code":"(fn judge [board]\n  (let [convert (fn [[m1 m2 m3]] (map #(list %1 %2 %3) m1 m2 m3))\n        diag (fn [vecs]\n               (let [take-one (fn [[i1 i2 i3] vecs]\n                                (list (nth (first vecs) i1)\n                                      (nth (second vecs) i2)\n                                      (nth (nth vecs 2) i3)))]\n\n                 (for [inds [[0 1 2] [2 1 0]]]\n                   (take-one inds vecs))))\n        f (fn [player]\n            (let [all-same (fn [player line]\n                             (every? #(= % player) line))\n                  ]\n              (some true? (map #(all-same player %) (concat board (convert board) (diag board))))))]\n    (cond\n      (f :x) :x\n      (f :o) :o\n      :else nil)\n    ))","user":"56903cb9e4b0dcc4269f40eb"},{"problem":73,"code":"(fn [board]\n  (letfn [(win? [ch]\n            (some true? \n                  (map #(every? (partial = ch) %)\n                       (concat\n             ;; horizontal\n                         board\n             ;; vertical\n                         (mapv (fn [i] (map #(% i) board)) [0 1 2])\n             ;; diagonal\n                         [(map (fn [i] (get-in board [i i])) [0 1 2])\n                          (map (fn [ij] (get-in board ij)) [[0 2] [1 1] [2 0]])\n                          ]))))]\n    (if (win? :x)\n      :x\n      (if (win? :o)\n        :o\n        nil))))","user":"5aea2d21e4b0cc2b61a3bbe2"},{"code":"(fn  [& c] \n  (let [array1 (first c) \n        cmax (count array1)\n        ha\n          (for [array2 array1] \n            (if (apply = array2) (first array2) nil)) \n        va1\n          (apply (partial map list) (first c))\n        va\n          (for [array2 va1] \n            (if (apply = array2) (first array2) nil)) \n        aa1 \n          (for [i (range cmax)]\n            ((array1 i) i)) \n        aa \n          (list (if (apply = aa1) (first aa1) nil))\n        ra1\n          (for [i (range cmax)]\n            ((array1 i) (- (dec cmax) i)))\n        ra \n          (list (if (apply = ra1) (first ra1) nil))\n        fa (concat ha va aa ra)\n        ret (first (filter #(not= nil %) fa))]\n      (if (not= :e ret) ret nil)))","problem":73,"user":"5243e37ae4b076204b44fae3"},{"problem":73,"code":"#(let [win (fn [a b c] (when (and (= a b c) (not= a :e)) a))\n       [[a b c] [d e f] [g h i]] %]\n   (or (win a b c) (win d e f) (win g h i) (win a e i)\n       (win a d g) (win b e h) (win c f i) (win c e g)))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn [[X Y Z]]\n   (let [[A B C] X [D E F] Y [H I J] Z]\n     (cond (and (= A B C) (not= :e A B C)) A\n           (and (= D E F) (not= :e D E F)) D\n           (and (= H I J) (not= :e H I J)) H\n           \n           (and (= A D H) (not= :e A D H)) A\n           (and (= B E I) (not= :e B E I)) B\n           (and (= C F J) (not= :e C F J)) C\n           \n           (and (= A E J) (not= :e A E J)) E\n           (and (= C E H) (not= :e C E H)) C )))","problem":73,"user":"5300aa1de4b0d8b024fd3710"},{"code":"(fn [b] (let [\n                         cols (partition 3 (apply interleave b))\n                         rows b\n                         diags [[(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])]\n                                [(get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])]\n                               ]\n                         C (concat cols rows diags)\n                         freqs (set (map #(frequencies %1) C))]\n                   (cond \n                     (contains? freqs {:x 3 }) :x\n                     (contains? freqs {:o 3 }) :o\n                     :else nil)))","problem":73,"user":"50956c2be4b087f34d351ab2"},{"problem":73,"code":"(fn [board]\n  (let [row   (fn [n b] (b n))\n        col   (fn [n b] (into [] (map #(% n) b)))\n        ldiag (fn [b]\n                (->> (reduce\n                       (fn [[ld i] r]\n                         (vector\n                           (conj ld (r i))\n                           (inc i)))\n                       [[] 0] b)\n                     (first)))\n        rdiag (fn [b]\n                (->> (reduce\n                       (fn [[rd i] r]\n                         (vector\n                           (conj rd (r i))\n                           (dec i)))\n                       [[] 2] b)\n                     (first)))\n        xs    (fn [s] (map #(if (= :x %) 1 0) s))\n        os    (fn [s] (map #(if (= :o %) 1 0) s))\n        won   (fn [p]\n                (->>\n                  (map\n                    (fn [f]\n                      (->>\n                        (f board)\n                        (p)\n                        (apply +)))\n                    [(partial row 0)\n                     (partial row 1)\n                     (partial row 2)\n                     (partial col 0)\n                     (partial col 1)\n                     (partial col 2)\n                     ldiag\n                     rdiag])\n                  (filter #(= 3 %))\n                  (seq)))]\n    (cond\n      (won xs) :x\n      (won os) :o\n      :else nil)))","user":"55d28b38e4b0e31453f64a58"},{"problem":73,"code":"(fn [board]\n  (let [win? (comp #(and % (first %)) #{[:x :x :x] [:o :o :o]})\n        board' (apply mapv vector board)\n        p (fn [i j] (get-in board [i j]))]\n    (or\n     (some win? board)\n     (some win? board')\n     (win? [(p 0 0) (p 1 1) (p 2 2)])\n     (win? [(p 2 0) (p 1 1) (p 0 2)]))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn ttt [m]\n  (letfn [(crow [r]\n                (cond \n                 (every? #(= :o %) r) :o\n                 (every? #(= :x %) r) :x\n                 :else nil))\n          (h-row [m] m)\n          (v-row [m] (apply map vector m))\n          (d-row [m] \n                 (list (for [x (range 3)] ((m x) x))\n                       (for [x (range 3)] ((m x) (- 2 x)))))]\n    (some identity (map crow (mapcat identity ((juxt h-row v-row d-row) m))))))","problem":73,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":73,"code":"(fn [[r1 r2 r3 :as rs]]\n  (let [c1 (map first rs)\n        c2 (map second rs)\n        c3 (map last rs)\n        d1 [(first r1) (second r2) (last r3)]\n        d2 [(last r1) (second r2) (first r3)]]\n    (first (filter #(#{:x :o} %)\n                   (map (fn [[v1 v2 v3]]\n                          (when (= v1 v2 v3) v1))\n                        [r1 r2 r3 c1 c2 c3 d1 d2])))))","user":"54485749e4b032a45b8693c7"},{"problem":73,"code":"(fn [s] (let [jf (fn [c r] (if (and (apply = r) (not= (first r) :e)) (conj c (first r)) c))\n              rows (reduce jf [] s)\n              cols (reduce jf [] (apply map list s))\n              aa (reduce jf [] (conj [] (vector (first (first s)) (second (second s)) (last (last s)))))\n              bb (reduce jf [] (conj [] (vector (last (first s)) (second (second s)) (first (last s)))))]\n          (first (concat rows cols aa bb))\n           ))","user":"549a176ce4b0f3d1d8e70f69"},{"code":"; This works with a N x N board for arbitrary N.\n(fn [b]\n  (let [rows #(apply (partial map vector) %)\n        nn   #(nthnext % %2)\n        won? (fn [p]\n               (some #(apply = (conj % p))\n                 (concat\n                   b (rows b)\n                   (rows (map nn b (range)))\n                   (rows (map nn (reverse b) (range))))))]\n    (cond (won? :x) :x\n          (won? :o) :o\n          :else     nil)))","problem":73,"user":"4fd96694e4b05e33b9224f37"},{"problem":73,"code":"(fn analyze-tic-tac [board]\n  (let [l (count board)\n        down (for [n (range l)]\n               (nth (nth board n) n))\n        up (for [n (range l)]\n             (nth (nth board (- l n 1)) n))\n        diagonals [down up]\n        columns (apply map vector board)\n        lines (concat board columns diagonals)]\n    (first (some #(when (and (not= (first %) :e) (apply = %)) %) lines))))","user":"5cdc08a2e4b05ee0cb31173a"},{"problem":73,"code":"(fn [board]\n  (let [winning-lines [[0 1 2] [3 4 5] [6 7 8]\n                       [0 3 6] [1 4 7] [2 5 8]\n                       [0 4 8] [2 4 6]]\n        board (reduce into board)\n        ok? (fn [mem line]\n              (every? #{mem} (map board line)))]\n    (cond\n      (some (partial ok? :o) winning-lines) :o\n      (some (partial ok? :x) winning-lines) :x)))","user":"4e11b92a535d04ed9115e7cb"},{"code":"(fn [board]\n  (let [\n      unfn (fn [b] (filter #(= 1 (count %)) (map distinct b)))\n      rows (unfn board)\n      cols (unfn (apply map list board))\n      crss (unfn [(map get board [0 1 2]) (map get board [2 1 0])])]\n    (some #{:x :o} (flatten [rows cols crss]))))","problem":73,"user":"4dfe65a1535d04ed9115e787"},{"code":"(let [win? (fn win? [who board]\r\n             (let [=who (fn [& args] (apply = who args))]\r\n               (or (some (fn [row] (apply =who row)) board)\r\n                   (some true? (apply #(map =who %1 %2 %3) board))\r\n                   (=who ((board 0) 0) ((board 1) 1) ((board 2) 2))\r\n                   (=who ((board 0) 2) ((board 1) 1) ((board 2) 0)))))]\r\n  (fn [board]\r\n    (cond (win? :x board) :x\r\n          (win? :o board) :o\r\n          :else nil)))","problem":73,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":73,"code":"(fn [[r1 r2 r3 :as m]] (let [[c1 c2 c3] (apply map list m) \n                              d1 (list (first c1) (second c2) (last c3)) \n                              d2 (list (last c1) (second c2) (first c3)) \n                              s (list r1 r2 r3 c1 c2 c3 d1 d2)]\n                            (cond\n                              (some #(= % [:x :x :x]) s) :x\n                              (some #(= % [:o :o :o]) s) :o\n                              :else nil)))","user":"56b86e64e4b0f26550335924"},{"problem":73,"code":"(fn [board]\n  (let [third #(nth % 2)\n        rows board\n        cols [(map first  board)\n              (map second board)\n              (map third  board)]\n        diagonals [(map nth board \n                            (range))\n                   (map nth (map reverse board) \n                            (range))]\n        win-vectors (concat rows cols diagonals)]\n    (cond (some (partial every? #{:x}) \n                win-vectors) \n          :x\n          (some (partial every? #{:o}) \n                win-vectors) \n          :o)))","user":"514a3fa5e4b0829bd132edb6"},{"problem":73,"code":"(fn tic-toc\n  [[[a b c]\n    [d e f]\n    [g h i]]]\n\n  (let [check-for-win (fn [x y z] (cond\n                                    (= x y z :e) nil\n                                    (= x y z) x))\n        ]\n     (or (check-for-win a b c)\n           (check-for-win d e f)\n           (check-for-win g h i)\n           (check-for-win a d g)\n           (check-for-win b e h)\n           (check-for-win c f i)\n           (check-for-win a e i)\n           (check-for-win c e g))\n      )\n  )","user":"5da94ccfe4b000c986472c2f"},{"problem":73,"code":"(fn [board]\n    (let [results (set (map (fn [positions]\n                              (set (map (partial get-in board) positions)))\n                            (apply concat\n                                   (for [x (range 3)]\n                                     (for [y (range 3)]\n                                       [x y]))\n                                   (for [x (range 3)]\n                                     (for [y (range 3)]\n                                       [y x]))\n                                   [(for [x (range 3)]\n                                      [x x])]\n                                   [(for [x (range 3)]\n                                      [x (- 2 x)])]\n                                   [])))]\n      (cond\n       (results #{:o}) :o\n       (results #{:x}) :x)))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"problem":73,"code":"(fn [board]\n    (letfn [(winner? [s]\n              (when (and (not= :e (first s))\n                         (= (count s)\n                            (count (filter #(= (first s) %) s))))\n                (first s)))\n            (column [board i]\n              (map #(nth % i) board))\n            (crosses [board]\n              [(map-indexed (fn [i s]\n                              (nth s i))\n                            board)\n               (map-indexed (fn [i s]\n                              (nth s (- 2 i)))\n                            board)])]\n      (first (or (seq (keep winner? board))\n                 (seq (keep winner? (map (partial column board) (range 3))))\n                 (seq (keep winner? (crosses board)))))))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":73,"code":"(fn [board]\n    (let [rows (concat\n                 board\n                 (apply map vector board)\n                 (list\n                   (map-indexed (fn [i r] (nth r i)) board)\n                   (map-indexed (fn [i r] (nth r i)) (reverse board))))]\n      (some #{:x :o}\n            (map #(when (apply = %) (first %))\n                 rows))))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn [board]\n  (some #{:x :o} \n        (flatten \n         (for [target [:x :o]]  \n           (concat  \n            (for [row board :when \n                  (apply = (conj row target))] target)\n            (for [col (range 3) :when \n                  (apply = (conj (for [row board] (row col)) target))] target)\n            (for [offset [identity #(- 2 %)] :when \n                  (apply = (conj (for [row (range 3)] ((board row) (offset row))) target))] target))))))","problem":73,"user":"504e108ce4b078edc5f593b3"},{"problem":73,"code":"(fn [board]\n   (let [f (fn[player]\n             (let [;each board square is represented by powers of 2\n                   ;the vector of winning positions is represented by\n                   ;applying bit-or to the board values\n                   winning [(bit-or   1   2   4)\n                            (bit-or   8  16  32)\n                            (bit-or  64 128 256)\n                            (bit-or   1   8  64)\n                            (bit-or   2  16 128)\n                            (bit-or   4  32 256)\n                            (bit-or   1  16 256)\n                            (bit-or   4  16  64)]\n                   ;number is a function mapping the board to a bit mask\n                   numerate #(if (= player %2) (apply *' (repeat %1 2)) 0)\n                   ;state is the application of bit-or to the numerated board\n                   state (apply bit-or (map-indexed numerate (flatten board)))\n                   ;won? bit-ors the winning numbers and state\n                   won? (some #(= state %) (map (partial bit-or state) winning))]\n               won?))]\n     (cond\n       (f :x) :x\n       (f :o) :o)))","user":"55342ee0e4b09218d5f44f98"},{"code":"(fn [board-rows]\n  ; Internally, we represent the tic-tac-toe board as a seq of nine keywords,\n  ; each of which is one of the \"players\" :x, :o, or :e. To find whether a\n  ; player is a winner, we encode the player's board positions as an integer,\n  ; then compare this integer to integer \"masks\" representing the eight ways a\n  ; player can win. The least significant binary digit (ones digit) in such an\n  ; encoding says whether or not the first position on the board is occupied by\n  ; the player in question, the twos digit says whether the second position is\n  ; so occupied, etc.\n  (letfn [\n          (make-encoder [board]\n            ; Returns a function for the given seq of players, which takes a\n            ; player keyword and returns a unique integer representation of all\n            ; the squares on the board occupied by that player.\n            (fn [player]\n              (->> (iterate (partial * 2) 1)\n                   (map #(if (= %1 player) %2 0) board)\n                   (reduce +))))\n\n          (make-judge [player-occupied-code]\n            ; Returns a \"judge\" function that takes a win-mask integer, and\n            ; returns an integer indicating whether the player has won according\n            ; to the win-mask. A win, indicated by 0, is returned iff the given\n            ; player-occupied-code integer contains the player positions\n            ; represented by win-mask.\n            (fn [win-mask]\n              (->> player-occupied-code (bit-and win-mask) (bit-xor win-mask))))\n\n          (make-winner-fn [encode masks]\n            ; Returns a function that takes a player keyword. It returns its\n            ; argument if the board represented by the given encoder function\n            ; and the given collection of win-masks together reveal the player\n            ; to be a winner. Otherwise, it returns nil.\n            (fn [player]\n              (if (->> masks\n                       (map (-> player encode make-judge))\n                       (some zero?))\n                player)))\n          ]\n    (some\n      (-> (apply concat board-rows)     ; Board is seq of nine squares.\n          make-encoder                  ; --> fn for encoding a player's posns.\n          (make-winner-fn [0421 0124 0700 0070 0007 0444 0222 0111]))\n                                        ; --> fn returning the player if winner.\n      [:x :o])\n    ))","problem":73,"user":"533b57c3e4b0e30313ee6ccc"},{"problem":73,"code":"(fn [m]\n  (let [analyze (fn [s];\n                  (if (or (and (= s ((m 0) 0)) (= s ((m 0) 1)) (= s ((m 0) 2)))\n                          (and (= s ((m 1) 0)) (= s ((m 1) 1)) (= s ((m 1) 2)))\n                          (and (= s ((m 2) 0)) (= s ((m 2) 1)) (= s ((m 2) 2)))\n                          (and (= s ((m 0) 0)) (= s ((m 1) 0)) (= s ((m 2) 0)))\n                          (and (= s ((m 0) 1)) (= s ((m 1) 1)) (= s ((m 2) 1)))\n                          (and (= s ((m 0) 2)) (= s ((m 1) 2)) (= s ((m 2) 2)))\n                          (and (= s ((m 0) 0)) (= s ((m 1) 1)) (= s ((m 2) 2)))\n                          (and (= s ((m 0) 2)) (= s ((m 1) 1)) (= s ((m 2) 0))))\n                    s\n                    nil))]\n    (or (analyze :o) (analyze :x))))","user":"5e954b9ee4b0fbed045a3809"},{"code":"{[[:x :e :o]\n  [:x :e :e]\n  [:x :e :o]] :x\n[[:e :x :e]\n [:o :o :o]\n [:x :e :x]] :o\n[[:x :e :e]\n [:o :x :e]\n [:o :e :x]] :x\n[[:x :e :o]\n [:x :o :e]\n [:o :e :x]] :o}","problem":73,"user":"4ea4e98a535d7eef308072ce"},{"code":"(fn [board]\n  (let [x-win? (fn [s b]\n                 (some #(every? #{s} %) b))\n        transpose (fn [b] (apply mapv vector b))\n        tBoard (transpose board)\n        diagBoard [[((board 0) 0) ((board 1) 1) ((board 2) 2)] [((board 0) 2) ((board 1) 1) ((board 2) 0)]]\n       ]  \n  (cond\n   (x-win? :x board) :x\n   (x-win? :o board) :o\n   (x-win? :x tBoard) :x\n   (x-win? :o tBoard) :o\n   (x-win? :x diagBoard) :x\n   (x-win? :o diagBoard) :o)))","problem":73,"user":"50be9b4ae4b00fb48fed2ef6"},{"problem":73,"code":"(fn tic-tc-toe [v]\n  (let [all-same? #(-> % frequencies first second ((partial = 3)))\n        winner? (fn [v]\n                  (or\n                    (-> (map first v) all-same?)\n                    (-> (map second v) all-same?)\n                    (= v [[2 0] [1 1] [0 2]])\n                    (= v [[0 0] [1 1] [2 2]])))]\n    (->> v\n         (map-indexed (fn [row-num row] (map-indexed (fn [col-num val] [val [col-num row-num]]) row)))\n         (mapcat identity)\n         (group-by first)\n         (remove (fn [[k v]] (= k :e)))\n         (map (fn [[k v]] [k (mapv second v)]))\n         (map (fn [[k v]] [k (winner? v)]))\n         (some (fn [[k v]] (when v k))))))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (let [match (filter #(apply = %)\n                      [[a b c] [d e f] [g h i]\n                       [a d g] [b e h] [c f i]\n                       [a e i] [c e g]])]\n    (some {[:o :o :o] :o [:x :x :x] :x} match)))","problem":73,"user":"4fdbc075e4b05e33b9224f61"},{"problem":73,"code":"(fn [b]\n  (letfn [(f [p] (map (fn [s] (mapcat #(list % (p (reduce into b) %)) s)) [[0 1 2][3 4 5][6 7 8][0 3 6][1 4 7][2 5 8][0 4 8][2 4 6]]))\n          (n [a] (set (f (constantly a))))]\n    (condp some (f get) (n :x) :x (n :o) :o nil)))","user":"5668dcc6e4b04acd4f672df8"},{"problem":73,"code":"(fn winner [board]\n  (let [rows identity\n        transpose #(apply (partial map vector) %)\n        diag-a #(first (reduce (fn [[d i] row]\n                                 [(conj d (get row i)) (inc i)])\n                               [[] 0]\n                               %))\n        cols transpose\n        diag-b (comp diag-a #(map (comp vec reverse) %))\n        sets (apply concat ((juxt rows cols (comp vector diag-a) (comp vector diag-b))\n                            board))]\n    (first (first (filter #(or (every? #{:x} %)\n                               (every? #{:o} %))\n                          sets)))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn ttt [board]\n  (let [rows (fn [b] (seq b))\n        cols (fn [b] (partition 3 (for [c (range 3), v b ] (nth v c))))\n        diag1 (fn [b] (vector (for [c (range 3)] (nth (nth b c) c))))\n        diag2 (fn [b] (vector (for [c (range 3)] (nth (nth b c) (- 2 c)))))\n        all   (concat (rows board) (cols board) (diag1 board) (diag2 board))\n        win   (filter #(and (second %1) (not= :e (ffirst %1))) (map #(vector %1 (apply = %1)) all))]\n    (if (empty? win) nil\n          (first (ffirst win)))))","problem":73,"user":"516db4f6e4b046df6fbb76a0"},{"problem":73,"code":"(fn gaming [board]\n  (let [winnerset #{:x :o}]\n    (cond (and (contains? winnerset (first (first board))) (= (count(set (first board))) 1)) (first (first board))\n    \t(and (contains? winnerset (first (second board))) (= (count(set (second board))) 1)) (first (second board))\n    \t(and (contains? winnerset (first (last board))) (= (count(set (last board))) 1)) (first (last board))\n    \t(and (contains? winnerset (first (first board))) (= (count(set (map first board))) 1)) (first (first board))\n    \t(and (contains? winnerset (second (first board))) (= (count(set (map second board))) 1)) (second (first board))\n    \t(and (contains? winnerset (last (first board))) (= (count(set (map last board))) 1)) (last (first board))\n\n    \t(and (contains? winnerset (first (first board))) (= (count(set [(first(first board)) (second (second board)) (last (last board))])) 1)) (first (first board))\n    \t(and (contains? winnerset (last (first board))) (= (count(set [(last(first board)) (second (second board)) (first (last board))])) 1)) (last (first board))\n    \t)))","user":"58866b4fe4b0f1effa3b76d4"},{"problem":73,"code":"(fn [s] \n  (let [dag (fn [s dir]\n    (let [[start end f f2] \n        (if (= dir :left-right)\n            [0 (count s) inc #(identity %)]\n            [(dec (count s)) -1 dec  #(- (dec (count s)) %)])]\n        (loop [cnt start ret []]\n            (if (= cnt end)\n                (vec ret)\n                (recur (f cnt) (conj ret (nth (nth s cnt) (f2 cnt) )))))))\n        col (fn [s i]\n    (vec (map #(nth % i) s)))\n        cols (fn [s]\n    (vec (map #(col s %) (range (count s)))))\n    expand-board (fn [s]\n    (concat s (cols s) [(dag s :left-right)] [(dag s :right-left)]))]\n    (let [res (->> s expand-board (map distinct) (filter #(= (count %) 1)) (filter #(not= (first %) :e)) flatten first)]\n        (if (not= :e res)\n            res\n            nil))))","user":"54f09599e4b024c67c0cf89d"},{"problem":73,"code":"(letfn [\n  (check-horizontal-win [row]\n    (cond\n      (= row [:o :o :o]) :o\n      (= row [:x :x :x]) :x\n      :else nil))\n        \n  (check-rows [[& rows]]\n    (some check-horizontal-win rows))\n        \n  (check-columns [[& rows]]\n    (check-rows [(map first rows) (map second rows) (map #(nth % 2) rows)]))\n        \n  (check-diagonals [[[ul _ ur]\n                     [ _ c _ ]\n                     [bl _ br]]]\n    (cond\n      (= ul c br :x) :x\n      (= ul c br :o) :o\n      (= ur c bl :o) :o\n      (= ur c bl :x) :x\n      :else nil))\n        ]\n  \n  #(some (fn [r] (if ((complement nil?) r) r)) ((juxt check-diagonals check-columns check-rows) %)))","user":"5b60e88be4b0c6492753e70b"},{"problem":73,"code":"(fn [board]\n\t(let [match-row (fn [board] (flatten (filter #(or (= (set %) #{:o}) (= (set %) #{:x})) board)) )\n\t\t  rearrange-col (fn [] \n\t\t \t(loop [col 2 new-order []]\n\t\t\t    (if (< col 0)\n\t\t\t      new-order\n\t\t\t      (recur (dec col) (conj new-order (map #(% col) board))))))\n\t\t  rearrange-dia (fn []\n\t\t  \t[[ ((board 0) 0) ((board 1) 1) ((board 2) 2) ]\n   \t\t\t [ ((board 2) 0) ((board 1) 1) ((board 0) 2) ]])]\n\t\t(first (match-row (into (into board (rearrange-col)) (rearrange-dia))))))","user":"550174b5e4b07d26eda61d73"},{"problem":73,"code":"(fn [board]\n  (or (if\n        (or\n         (some #(= [:x :x :x] %) board)\n         (some #(= [:x :x :x] %) (apply mapv vector board))\n         (some #(= [:x :x :x] %) [[(get (get board 0) 0) (get (get board 1) 1) (get (get board 2) 2)]\n                                  [(get (get board 2) 0) (get (get board 1) 1) (get (get board 0) 2)]]))\n        :x)\n      (if\n        (or\n         (some #(= [:o :o :o] %) board)\n         (some #(= [:o :o :o] %) (apply mapv vector board))\n         (some #(= [:o :o :o] %) [[(get (get board 0) 0) (get (get board 1) 1) (get (get board 2) 2)]\n                                  [(get (get board 2) 0) (get (get board 1) 1) (get (get board 0) 2)]]))\n        :o)))","user":"55ad0e18e4b03311e7b7329c"},{"problem":73,"code":"(fn ttt [m]\n  (let [row\n        (fn [m r]\n          (when (and (apply = (m r)) (not= ((m r) 0) :e))\n            ((m r) 0)))\n        col\n        (fn [m c]\n          (when (and (apply = ((apply juxt m) c)) (not= ((m 0) c) :e))\n            ((m 0) c)))\n        maind\n        (fn [m]\n          (when (and (apply = (map #((m %) %) (range 3))) (not= ((m 0) 0) :e))\n            ((m 0) 0)))\n        minord\n        (fn [m]\n          (when (and (apply = (map #((m %) (- 2 %)) (range 3))) (not= ((m 0) 2) :e))\n            ((m 0) 2)))]\n    (first (filter (comp not nil?) (concat (map #(row m %) (range 3)) (map #(col m %) (range 3)) (list (maind m) (minord m)))))))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"(fn analyze-tictactoe\n  [[l1 l2 l3]]\n  (loop [board (concat l1 l2 l3)\n         points [5 0 7 6 4 2 1 8 3]\n         x 0\n         e 0\n         o 0]\n    (let [p (first board)]\n      (if p ;; I think I have to use macros to eliminate this boilerplate\n        (recur (next board)\n               (next points)\n               (if (= p :x) (+ x (first points)) x)\n               (if (= p :e) (+ e (first points)) e)\n               (if (= p :o) (+ o (first points)) o))\n        (cond (= 12 x) :x\n              (= 12 e) :e\n              (= 12 o) :o\n              :else nil)))))","problem":73,"user":"4e5a460f535d8a8b8723a2ab"},{"problem":73,"code":"(fn [g]\n  (some\n    #(when (or (= % [:x :x :x])\n               (= % [:o :o :o]))\n      (first %)) (map (fn [x]\n                        (map #(get-in g %) x))\n                      [[[0 0] [0 1] [0 2]]\n                       [[1 0] [1 1] [0 2]]\n                       [[2 0] [2 1] [2 2]]\n                       [[0 0] [1 1] [2 2]]\n                       [[0 2] [1 1] [2 0]]\n                       [[0 0] [1 0] [2 0]]\n                       [[1 0] [1 1] [1 2]]\n                       [[2 0] [2 1] [2 2]]])))","user":"5382704be4b06839e8705ed4"},{"code":"(fn [board]\n  (let [b (map-indexed (fn [i x] {x (bit-shift-left 1 i)}) (flatten board))]\n    (some identity\n          (for [p [:x :o]]\n            (some identity\n                  (let [s (apply + (map #(or (p %) 0) b))]\n                    (for [mask [7 56 448 73 146 292 273 84]]\n                      (when (= mask (bit-and mask s)) p))))))))","problem":73,"user":"50d93c53e4b0fd36a4b89223"},{"problem":73,"code":"(fn analyze-tic-tac-toe2\n  [tic-tac-toe]\n  (let [get-x (fn [n]\n                [(nth (nth tic-tac-toe n) n)\n                 (nth (nth tic-tac-toe n) (- 2 n))])\n        tic-lines (for [i (range 3)]\n                    [(nth tic-tac-toe i)\n                     (map #(nth % i) tic-tac-toe)\n                     (get-x i)])]\n    (some #(and (apply = %)\n                (not= :e (first %))\n                (first %))\n          (apply concat\n                 [(map (comp first last) tic-lines) (map (comp last last) tic-lines)]\n                 (map (partial take 2) tic-lines)))))","user":"4e586949535d8a8b8723a292"},{"problem":73,"code":";(\n (fn [board]\n   (let [win? (fn [s] (if (apply = s) (first s) nil))\n         rows (map win? board)\n         cols (map win? (apply map vector board))\n         left-diag (win? (map get board (range 3)))\n         right-diag (win? (map get board (range 2 -1 -1)))]\n     (some #{:x :o} (concat rows cols [left-diag] [right-diag]))))  \n  \n;[[:x :x :x][:x :e :e][:x :e :o]])","user":"573632b7e4b0cd1946bd102f"},{"code":"(fn ttt [brd]\t\n  (letfn [(transpone [board] (apply map vector board))\n          (nth-nth [n board] (nth n (nth n board)))\n\t        (win-row [player row] (every? #(= % player) row))\n\t        (win-rows [player board] (some (partial win-row player) board))\n          (win-diagonal [player board] (every? #(= % player) (map-indexed #(nth %2 %1) board)))\n\t        (win-all [player board] (some identity [(win-rows player board) \n\t                                                (win-rows player (transpone board))\n                                                  (win-diagonal player board)\n                                                  (win-diagonal player (reverse board))]))]\n\t    (cond \n\t      (win-all :o brd) :o\n\t      (win-all :x brd) :x\n\t      :else nil)))","problem":73,"user":"4fb4303fe4b081705acca2ac"},{"code":"(fn [ls]\n  (let [winner? (fn [ls] (or (every? #(= % :x) ls) (every? #(= % :o) ls)))\n        t-w (fn [l] (when (winner? l) (first l)))]\n    (some t-w\n    (lazy-cat \n      ls \n      (map #(map (fn [l] (get l %)) ls) [0 1 2])\n      ((juxt #(map first %) #(map second %)) \n          (map \n            #(vector (get %1 %2)\n               (get %1 (- 2 %2)))\n            ls [0 1 2]))))))","problem":73,"user":"5003ee7de4b0678c553fc446"},{"problem":73,"code":"(fn [[a b c :as all]]\n  (let [func (fn [x y z] (if (or (= x y z :x) (= x y z :o)) x nil))\n        v (some identity (map func a b c))\n        h (some identity (map (fn [[x y z]] (if (or (= x y z :x) (= x y z :o)) x nil)) all))\n        d1 (apply func (map #(get-in all %) [[0 0] [1 1] [2 2]]) )\n        d2 (apply func (map #(get-in all %) [[0 2] [1 1] [2 0]]) )]\n   (some identity [v h d1 d2])))","user":"567d18c9e4b05957ce8c61c4"},{"problem":73,"code":"(fn [board]\n    (letfn [(xy [b x y] ((b x) y))\n            (candidates\n              [b]\n              (loop [coords [[[0 0] [1 0] [2 0]] ;; first column\n                             [[0 1] [1 1] [2 1]] ;; second column\n                             [[0 2] [1 2] [2 2]] ;; third column\n                             [[0 0] [1 1] [2 2]] ;; first diagonal\n                             [[2 0] [1 1] [0 2]] ;; second diagonal\n                             ]\n                     b b]\n                (if (seq coords)\n                  (recur (rest coords)\n                         (let [make (fn [[c0 c1 c2]]\n                                      [(apply (partial xy b) c0)\n                                       (apply (partial xy b) c1)\n                                       (apply (partial xy b) c2)])]\n                           (conj b (make (first coords)))))\n                  b)))\n            (who-wins?\n              [boxes]\n              (let [p (first boxes)]\n                (and (every? #(= p %) boxes)\n                     p)))\n            (winner\n              [board]\n              (first (remove #(= :e %) (filter keyword? (map who-wins? (candidates board))))))]\n      (winner board)))","user":"52485f02e4b05ef8e38e63d3"},{"code":"(fn [m]\n  (let [get-col (fn [i] (map #(nth % i) m))\n        cols    (map get-col [0 1 2])\n        ds      [[(first (first m)) (second (second m)) (last (last m))]\n                 [(last (first m)) (second (second m)) (first (last m))]]\n        win     (fn [r]\n                  (cond\n                   (every? #(= :x %) r) :x\n                   (every? #(= :o %) r) :o\n                   :else                nil))]\n    (some #{:x :o} (map win (concat m cols ds)))))","problem":73,"user":"4daf8f84edd6309eace4d17a"},{"problem":73,"code":"(fn\n  [[x y z]]\n  (let [f first\n        s second\n        t last]\n    (some #(and (apply = %) (some #{:x :o} %))\n          `(~x ~y ~z\n            ~@(map #(map % [x y z]) [f s t])\n            ~[(f x) (s y) (t z)]\n            ~[(t x) (s y) (f z)]))))","user":"53fb5256e4b0de5c4184857f"},{"code":"(fn [b]\n  (let [f #(if (= % %2) % :e)\n        t #(apply (partial map list) %)\n        d (fn [rs] (map-indexed #(%2 %) rs))\n        r #(reduce f :e %)\n        fr (map #(reduce f %) b)\n        fc (map #(reduce f %) (t b))\n        fd (map #(reduce f %) [(d b) (d (reverse b))])]\n    (some #{:x :o} (concat fr fc fd))\n    ))","problem":73,"user":"51424cc8e4b0b50abeb46b34"},{"problem":73,"code":";; Can be used on only NxN board\n(fn[ b]\n  (let [size (count b)\n        r (range size)\n        s1 (into b (map vec (partition size (apply interleave b))))\n        s2 (conj s1 (vec (map #(nth (nth b %)%) r)))\n        s3 (conj s2 (vec (map #(nth (nth b %1)%2) r (reverse r))))\n        res (ffirst (filter #(apply = %) s3))]\n   (if (= :e res) nil res)))","user":"52f426fce4b05e3f0be25f1e"},{"problem":73,"code":"(fn [rows] \n  (let [n (count rows),\n     get-cols (fn [vecs] (reduce \n                             (fn [cols, v] \n                               (vec (for [x (range n)] \n                                        (conj (nth cols x) (nth v x)))))\n                             (vec (repeat n []))\n                             vecs)) ,\n        get-diag (fn [vecs] (vec (for [x (range n)] (nth (nth vecs x) x)))),\n        heur (fn [vecs] ({'(-3) :o, '() nil, '(3) :x} \n                        (filter #(= 3 (Math/abs %)) \n                                (map #(apply + (map {:e 0, :x 1, :o -1} %))\n                                     vecs))))]\n\n(heur (concat rows (get-cols rows) [(get-diag rows) (get-diag (map reverse rows))]))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":73,"code":"(fn [rows]\n\t(let [\n    \tcolsnrows (into rows (apply map vector rows))\n        [[a _ b][_ c _][d _ e]] rows\n        diags [[a c e] [b c d]]\n        lines (into colsnrows diags)\n        played-lines (remove (partial apply = :e) lines)\n        winning-line (first (filter (partial apply =) played-lines))\n    \t]\n    \t(first winning-line)\n\t)\n        \n)","user":"516ee939e4b06aac486e5b34"},{"problem":73,"code":"(fn\n  [board]\n  (let [moves [first second last]\n        pos (conj (reduce \n                   (fn [accum curr]\n                     (conj accum (map curr board)))\n                   board\n                   moves\n                   ) \n                  (map #(%1 %2) moves board) ; upper left diagonal\n                  (map #(%1 %2) (reverse moves) board))] ;upper right diagonal\n    (cond \n      (some #(= [:x :x :x] %) pos) :x\n      (some #(= [:o :o :o] %) pos) :o\n      :else nil\n      )))","user":"5dd25ca8e4b0948ae9d9ad55"},{"code":"(fn tic-tac-toe [board]\n  (let [make-vertical (reduce (fn [verticalized row]\n                                (reduce (fn [vertical-slice element]\n                                          (concat (rest vertical-slice) (list (conj (first vertical-slice) element)))\n                                          ) verticalized row)\n                                )\n                              [[] [] []]\n                              board\n                              )\n        make-diagonal [\n                       [ (get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2]) ]\n                       [ (get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0]) ]\n                       ]\n        all (concat board make-vertical make-diagonal)\n        ]\n    (cond\n      (some #(= [:x :x :x] %) all) :x\n      (some #(= [:o :o :o] %) all) :o\n      :else nil\n      )\n    )\n  )","problem":73,"user":"5303a027e4b0d8b024fd3745"},{"problem":73,"code":"(fn [board] (let [[[a b c]\n       [d e f]\n       [g h i]] board] \n  (ffirst\n  (filter #(or (every? #{:x} %) (every? #{:o} %))\n  (concat board (apply map vector board) [[a e i] [c e g]])\n  ))))","user":"5554e40ee4b0deb715856e0f"},{"problem":73,"code":"(fn winner [board]\n  (let\n    [check-rows (fn [board k]\n                  (reduce #(or %1 \n                               (reduce (fn [a pos] (and a (if (= k pos) k nil))) ;; needs to explicitly eval to `nil` rather than `false`\n                                       true\n                                       %2))\n                          nil\n                          board))\n     transpose (fn [board] \n                   (reduce\n                    #(reduce\n                      (fn [b c] (assoc-in b c (get-in board (reverse c))))\n                      %1\n                      [%2 (reverse %2)])\n                    board\n                    [[0 1] [0 2] [1 2]]))\n     check-cols (fn [board k] (check-rows (transpose board) k))\n     check-dgns (fn [board k]\n                  (or\n                   (check-rows \n                    [[(first (first board)) (second (second board)) (last (last board))]]\n                    k)\n                   (check-rows \n                    [[(last (first board)) (second (second board)) (first (last board))]]\n                    k)))]\n    (reduce \n     #(or %1 %2)\n     nil\n     (map\n      (fn [k] ;; tests if given key has won\n        (or\n         (check-rows board k)\n         (check-cols board k)\n         (check-dgns board k)))\n      [:x :o]))))","user":"5ed52854e4b016b56eae05d2"},{"problem":73,"code":"(fn [x]\n   (letfn [(c [x n] (mapv #(get-in x [% n]) (range 3)))\n           (t [x] (mapv #(c x %) (range 3)))\n           (o [m]\n             [(mapv #(get-in m [% %]) (range 3))\n              (mapv #(get-in m [% (- 2 %)]) (range 3))])\n           (w [m]\n             ((comp first first)\n              (filter #(let [f (first %)]\n                         (and (#{:x :o} f) (every? #{f} %))) m)))]\n     (w (concat x (t x) (o x)))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":73,"code":"(fn [b]\n  (let [tr [(map first b) (map second b) (map last b)]\n        d1 (map #(nth %1 %2) b (range 3))\n        d2 (map #(nth %1 %2) b (reverse (range 3)))\n        comb (concat b tr [d1 d2])\n        win (first (filter #(apply = %) comb))]\n    (if (nil? win) \n      nil \n      (if (= :e (first win)) nil (first win)))))","user":"56f51879e4b046a417f92069"},{"problem":73,"code":"(fn [board]\n\t(let [\tsboard (apply concat board)\n\t\twins [#{0 1 2} #{3 4 5} #{6 7 8} #{0 3 6} #{1 4 7} #{2 5 8} #{0 4 8} #{2 4 6}]\n\t\txs (keep-indexed #(if (= :x %2) %1) sboard)\n\t\tos (keep-indexed #(if (= :o %2) %1) sboard)\n\t\twcomp (fn [coll]\n\t\t\t(->> \t(map #(filter identity (map % coll)) wins)\n\t\t\t\t(map count)\n\t\t\t\t(filter #(= 3 %))\n\t\t\t\tseq))]\n\t\n\t\t(cond \n\t\t\t(wcomp xs) :x\n\t\t\t(wcomp os) :o\n\t\t\t:else nil)))","user":"54848141e4b0e286459a119e"},{"code":"(fn ttt [b]\n  (let [diagonal \n        (fn [b]\n          (let [one (first b)\n                two (second b)\n                three (last b)]\n            (if \n              (and \n                (not= :e (first one))\n                (= (first one) (second two) (last three))) (first one)\n              nil)))\n        horizontal \n            (fn [b]\n              (let [winner (filter #(= 1 (count (set %))) b)]\n                (if (and (not (empty? winner)) (not= :e (ffirst winner))) \n                  (ffirst winner)\n                  nil)))\n        flip-board\n            (fn [b]\n              [(map first b)\n               (map second b)\n               (map last b)])]\n    (first (filter #(not (nil? %)) [(diagonal b) \n                                    (diagonal (map reverse b)) \n                                    (horizontal b) \n                                    (horizontal (flip-board b))]))))","problem":73,"user":"5273e006e4b03e8d9a4a7495"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [rotate-board (fn [board]\n                       (apply mapv vector\n                              (map rseq board)))\n        r-board (rotate-board board)\n        check-row (fn [[a b c]]\n                    (if (and (= a b) (= b c)) (if (not= :e a) a nil) nil))\n        check-rows (fn [[r1 r2 r3]]\n                     (cond (not= nil (check-row r1)) (check-row r1)\n                           (not= nil (check-row r2)) (check-row r2)\n                           (not= nil (check-row r3)) (check-row r3)\n                           :else nil))\n        check-diagonal (fn [[[a _ _][_ b _][_ _ c]]]\n                         (if (and (= a b) (= b c)) (if (not= :e a) a nil) nil))]\n    (cond (not= nil (check-diagonal board)) (check-diagonal board)\n          (not= nil (check-diagonal r-board)) (check-diagonal r-board)\n          (not= nil (check-rows board)) (check-rows board)\n          (not= nil (check-rows r-board)) (check-rows r-board)\n          :else nil)))","user":"56f4cedce4b046a417f92063"},{"problem":73,"code":"(fn tic-tac-toe [rows]\n  (let [cols (apply map vector rows)\n        diag-lr (map-indexed #(nth %2 %1) rows)\n        diag-rl (map-indexed #(nth %2 %1) (reverse rows))\n        all-possible (concat rows cols [diag-lr diag-rl])\n        all-positions (apply concat rows)]\n    (if (every? #(= :e %) all-positions)\n      nil\n      ;; all-possible)))\n      (condp some all-possible\n        #(= % [:x :x :x]) :x\n        #(= % [:o :o :o]) :o\n        nil))))","user":"58327a08e4b089d5ab817c7c"},{"code":"(fn [a]\n  (letfn [(iz [sym]\n            (#{\"111000000\", \"000111000\", \"000000111\",\"100100100\",\n              \"010010010\", \"001001001\",\"100010001\",\"001010100\"}\n               (apply str (map #(if (= sym %) \"1\" \"0\") (flatten a))))\n          )]\n    (cond\n     (iz :o) :o \n     (iz :x) :x\n     )\n  )\n)","problem":73,"user":"504f191ae4b0e7ad84dbc4ba"},{"code":"(fn [board]\n  (let [columns (partition 3 (apply interleave board))\n        diag1 (vector (map #(get %1 %2) board [0 1 2]))\n        diag2 (vector (map #(get %1 %2) board [2 1 0]))\n        combos (concat board columns diag1 diag2)\n        x-wins (if (some true? (map #(= % [:x :x :x]) combos)) :x)\n        o-wins (if (some true? (map #(= % [:o :o :o]) combos)) :o)]\n    (or x-wins o-wins nil)))","problem":73,"user":"4eb9d8f8535dfed6da9c6d61"},{"problem":73,"code":"(fn [board]\n  (some {[:x :x :x] :x, [:o :o :o] :o}\n    (concat\n      board\n      (apply map vector board)\n      [(map #(%2 %1) [0 1 2] board)\n       (map #(%2 %1) [2 1 0] board)])))","user":"54397533e4b032a45b86931d"},{"problem":73,"code":"(fn [ttt]\n  (let [t (vec (reduce concat ttt))\n        r [[0 1 2]\n           [3 4 5]\n           [6 7 8]\n           [0 3 6]\n           [1 4 7]\n           [2 5 8]\n           [0 4 8]\n           [2 4 6]]\n        players [:x :o]]\n    (let [tr (map #(map t %) r)]\n      (first (for [player players :when (some #(= (repeat 3 player) %) tr)]\n               player)))))","user":"563dfc02e4b0da801c4e4662"},{"problem":73,"code":"(fn [mx] ;matrix of symbols\n    (let [place? (fn [[x y :as coords]]\n                   (and (= (count coords) 2) (<= 0 x 2) (<= 0 y 2)))\n          at( fn [pl] {:pre[(place? pl)]} (get-in mx pl))\n          directions (apply concat #_->seq-of-seq-of-places\n                            '(([0 0] [1 1] [2 2]) ;diagonal from top left\n                              ([2 0] [1 1] [0 2]))\n                            (for [i (range 0 3)]\n                              `(([~i 0] [~i 1] [~i 2]) ;horizontal\n                                ([0 ~i] [1 ~i] [2 ~i])) ;vertical\n                              ))\n          direction? (fn [dir] (and\n                                (= (count dir) 3)\n                                (every? place? dir)))\n          _ (println directions)\n          _ (assert (every? direction? directions))\n          won? (fn [dir] {:pre [(direction? dir)]}\n                 (if (apply = (map at dir))\n                   (let [value (at (first dir))]\n                     (#{:o :x} value))))\n          result (some won? directions)]\n        result\n      )\n    )","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":73,"code":"(fn [b]\n  (let [d (flatten b)\n        g (fn [c] (vector (map #(nth d %) c)))\n        r (apply concat [b (map #(map % b) [first second last])\n                            (g [0 4 8]) (g [2 4 6])])\n        w (filter #(some #{:x :o} #{%}) (map first (filter #(apply = %) r)))]\n    (if (empty? w) nil (first w))))","user":"55205564e4b08d5046aa8a60"},{"problem":73,"code":"(fn tic-tac-toe [board] (let [column  (fn [board n] ( reduce #(conj %1 (nth %2 n) ) [] board))\n                                columns (fn [board] (reduce #(conj %1 (column board %2)) [] (range 3)))\n                                diag1 (fn [board] (for [x (range 3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          :let [y (nth (nth board x) x)]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          y))\n                                diag2 (fn [board] (for [x (range 3)\n\t\t\t\t\t\t\t                          :let [y (nth (nth board (- 2 x)) x)]]\n\t\t\t\t\t\t\t                          y))\n                                diags (fn [board] [(diag1 board) (diag2 board)])\n                                triplets  (concat board (columns board) (diags board))\n                                identical? (fn [triplet x] (= triplet [x x x]))]\n                            (if (seq (filter #(identical? %1 :x) triplets))\n                              :x\n                              (if (seq (filter #(identical? %1 :o) triplets))\n                              :o\n                              nil))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":73,"code":"(fn analyze[board](let[[[a1 b1 c1] [a2 b2 c2] [a3 b3 c3]] board\nposib (conj board [a1 a2 a3] [b1 b2 b3] [c1 c2 c3] [a1 b2 c3] [a3 b2 c1])\nq (fn[k v](count (filter #(= k %) v)))]\n(if (some #{3} (map #(q :x %) posib)) :x\n(when (some #{3} (map #(q :o %) posib)) :o))))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":73,"code":"(letfn [(get-value [state xy]\n          (get (:game state) (get-position state xy)))\n\n        (get-position [state xy]\n          (let [[x y] xy]\n            (if (and (< -1 x (:max-x state)) (< -1 y (:max-y state)))\n              (+ x (* y (:max-x state)))\n              -1)))\n\n        (compute-position [state index]\n          (let [nx (mod index (:max-x state))\n                ny (quot index (:max-x state))]\n            [nx ny]))\n\n        (sum-line-dir [state position dir sum]\n          (let [player (get-value state position)\n                new-pos (map + position dir)\n                new-pos-value (get-value state new-pos)]\n            (if (not= player new-pos-value)\n              sum\n              (recur state new-pos dir (inc sum)))))\n\n        (sum-line [state directions position]\n          (let [[left right] directions\n                sum (inc (+ (sum-line-dir state position left 0)\n                            (sum-line-dir state position right 0)))]\n            (if (<= (:win-count state) sum)\n              (let [val (get-value state position)]\n                (if (not= val :e)\n                  val\n                  nil\n                  )\n                )\n              nil\n              )))\n\n        (someone-won? [state]\n          (first (drop-while nil? (flatten (map (fn [position]\n                         (list (sum-line state [[0 1] [0 -1]] position)\n                           (sum-line state [[1 0] [-1 0]] position)\n                           (sum-line state [[-1 -1] [1 1]] position)\n                           (sum-line state [[-1 1] [1 -1]] position)))\n                   (map #(compute-position state %) (range (* (:max-x state) (:max-y state)))))))))\n        ]\n\n  (fn [board] (someone-won? {:game (into [] (flatten (reverse board))) :max-x 3 :max-y 3 :win-count 3})))","user":"558843dae4b059ccff29b1f3"},{"problem":73,"code":"(fn get-winner\n  [grid]\n  (letfn [\n          (get-rows [grid] grid)\n          (transpose [grid] (apply mapv vector grid))\n          (get-cols [grid] (transpose grid))\n          (get-diagonal\n            [grid]\n            (reduce-kv\n             (fn [c ridx row] (conj c (get row ridx)))\n             [] grid))\n\n          (get-diagonals\n            [grid]\n            [(get-diagonal grid) (get-diagonal (mapv (comp vec reverse) grid))])\n\n          (get-winning-rows\n            [grid]\n            (mapcat #(%1 grid) [get-rows get-cols get-diagonals]))\n          ]\n    (->> (get-winning-rows grid)\n         (map set)\n         (filter #(= 1 (count %)))\n         (remove #(= #{:e} %))\n         first\n         first)))","user":"55c66ffee4b0e31453f649c2"},{"problem":73,"code":"(fn [board]\n  (letfn [(win? [r]\n            (let [m (into #{} r) f (first m)]\n              (when (and (= 1 (count m))\n                         (not (= :e f)))\n                f)))]\n    (or (some win? board)\n        (some win? (map #(map (fn [r] (nth r %)) board) (range 3)))\n        (win? (map (fn [[r i]] (nth r i)) (map #(vector %1 %2) board (range 3))))\n        (win? (map (fn [[r i]] (nth r i)) (map #(vector %1 %2) board (reverse (range 3))))))))","user":"537e745ae4b06839e8705ea6"},{"problem":73,"code":"(fn [board] (let [transpose (fn [m] (apply mapv vector m)) to-set (fn [x] (into #{} x))  rows (map to-set board) cols (map to-set (transpose board)) diag-a (to-set (list ((board 0) 2) ((board 1) 1) ((board 2) 0))) diag-b (to-set (list ((board 0) 0) ((board 1) 1) ((board 2) 2))) items (conj (concat rows cols) diag-a diag-b)] (first (first (filter (fn [x] (and (> 2 (count x)) (not (= (first x) :e)))) items)))))","user":"5addadfce4b0837691e92c13"},{"problem":73,"code":";; http://www.4clojure.com/problem/73\n(fn tic-tac-toe-who-won\n  [board]\n  (let [[[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]] board]\n    (letfn [(has-won-row1 [s] (= s r11 r12 r13))\n            (has-won-row2 [s] (= s r21 r22 r23))\n            (has-won-row3 [s] (= s r31 r32 r33))\n            (has-won-col1 [s] (= s r11 r21 r31))\n            (has-won-col2 [s] (= s r12 r22 r32))\n            (has-won-col3 [s] (= s r13 r23 r33))\n            (has-won-cross1 [s] (= s r11 r22 r33))\n            (has-won-cross2 [s] (= s r13 r22 r31))\n            (has-won [s]\n              (or (has-won-row1 s) (has-won-row2 s) (has-won-row3 s)\n                  (has-won-col1 s) (has-won-col2 s) (has-won-col3 s)\n                  (has-won-cross1 s) (has-won-cross2 s)))]\n      (cond (has-won :x) :x\n            (has-won :o) :o\n            :else nil))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn [[r1 r2 r3]]\n (let [all-comb [r1 r2 r3 [(first r1) (first r2) (first r3)] [(second r1) (second r2) (second r3)] [(last r1) (last r2) (last r3)] \n   [(first r1) (second r2) (last r3)]  [(last r1) (second r2) (first r3)]\n   ]\n     won (fn [s symb](every? #(= symb %) s))\n   ]\n    (or (first (first (filter #(won % :x) all-comb))) (first (first (filter #(won % :o) all-comb))))\n  )\n)","problem":73,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [x]\n   (some #(when (and (= (.indexOf % :e) -1) (apply = %)) (first %)) (let [c (second (second x))]\n     (concat (apply map vector x)\n       (conj x (vector (ffirst x) c (nth (nth x 2) 2))\n         (vector (nth (nth x 0) 2) c (nth (nth x 2) 0)))))))","problem":73,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn [board]\n    (let [get-column (fn [m n] (map #(nth % n) m))\n          get-row (fn [m n] (nth m n))\n          get-cell (fn [m r c] (nth (nth m r) c))\n          size (count (first board))\n          get-diagonal-rows (fn [m]\n                              (loop [i 0\n                                     cells1 []\n                                     cells2 []]\n                                (if (= i size)\n                                  [cells1 cells2]\n                                  (recur (inc i)\n                                         (conj cells1 (get-cell m i i))\n                                         (conj cells2 (get-cell m i (- (dec size) i)))))))\n          every-equal? (fn [v s] (every? (fn [e] (= s e)) v))\n          win? (fn [s rows] (some true? (map #(every-equal? % s) rows)))\n          x-win? (partial win? :x)\n          o-win? (partial win? :o)\n          diagonal-rows (get-diagonal-rows board)]\n      (cond (x-win? diagonal-rows) :x\n            (o-win? diagonal-rows) :o\n            :else\n            (loop [i 0]\n              (if (= i size) nil\n                  (let [col (get-column board i)\n                        row (get-row board i)]\n                    (cond (x-win? [col row]) :x\n                          (o-win? [col row]) :o\n                          :else (recur (inc i)))))))))","problem":73,"user":"51c3c6a6e4b0851ac09658f8"},{"problem":73,"code":"(fn who-won [board]\n  (loop [[line & more-lines :as winning-lines] \n         [[[0 0] [0 1] [0 2]]\n          [[1 0] [1 1] [1 2]]\n          [[2 0] [2 1] [2 2]]\n          [[0 0] [1 0] [2 0]]\n          [[0 1] [1 1] [2 1]]\n          [[0 2] [1 2] [2 2]]\n          [[0 0] [1 1] [2 2]]\n          [[0 2] [1 1] [2 0]]]]\n    ;; Have we looked everywhere without finding a winner?\n    (if (empty? winning-lines)\n      nil\n      ;; Is the next line filled in, and are all the entries equal?\n      (if (and (not (= :e (get-in board (first line))))\n               (apply = (map #(get-in board %) line)))\n        ;; If so, that's the winner.\n        (get-in board (first line))\n        ;; If not, keep looking.\n        (recur more-lines)))))","user":"569f99cce4b0542e1f8d1497"},{"problem":73,"code":"(fn [b] (let [m [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n(some {[:x :x :x] :x [:o :o :o] :o} (map #(map (fn [l] (nth (apply concat b) l)) %) m))))","user":"53b15e6ee4b047364c04448f"},{"code":"(fn ttt [b]\n  (let [all= (fn [coll vals]\n               \"If all the elements of coll are equal to each other, and that value is one of the             \n                elements of vals, return that value.  Otherwise return nil.  Obviously it's not a             \n                good idea to use a vals containing nil.\"\n               (if (and (= (count (set coll)) 1) (contains? (set vals) (first coll)))\n                 (first coll)\n                 nil))]\n    (some identity\n          [ (some #(all= % [:x :o]) b)                                        ; 3 in a row                    \n            (some #(all= % [:x :o]) (apply map vector b))                     ; 3 in a col                    \n            (all= (map #(get %2 %1) (range (count b)) b) [:x :o])             ; 3 on \\ diag                   \n            (all= (map #(get %2 %1) (reverse (range (count b))) b) [:x :o])   ; 3 on / diag                   \n            ])))","problem":73,"user":"530bf87ee4b02e82168697d5"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (cond\n    (and (not= a :e)\n         (or (= a b c) (= a d g))) a\n    (and (not= i :e) \n         (or (= g h i) (= c f i))) i\n    (and (not= e :e) \n         (or (= d e f) (= b e h)\n             (= a e i) (= g e c))) e\n    1 nil))","problem":73,"user":"538d8bb8e4b0b51d73faae71"},{"problem":73,"code":"(fn [b]\n          (let [same? (fn [s] (if (apply = s) (first s) nil))\n                rows (map same? b)\n                cols (map same? (apply map vector b))\n                d1 (same? (map get b (range 3)))\n                d2 (same? (map get b (range 2 -1 -1)))]\n            (some #{:x :o} (concat rows cols [d1] [d2]))))","user":"56efb3a3e4b04a395b9a0463"},{"problem":73,"code":"(fn [board]\r\n  (-> '()\r\n      (into board)\r\n      (into (apply map (fn [x y z] (list x y z)) board))\r\n      (into (map (fn [[a b c]] (list (get-in board a)\r\n                                     (get-in board b)\r\n                                     (get-in board c)))\r\n                 '(([0 0] [1 1] [2 2]) ([0 2] [1 1] [2 0]))))\r\n      ((fn [lines] (filter #(= 1 (count (frequencies %))) lines)))\r\n      ((fn [lines] (filter #(not-any? #{:e} %) lines)))\r\n      ffirst))","user":"580e7761e4b0849f6811b753"},{"code":"(fn winner\n  [board]\n  (let [won? (fn [k]\n               (let [w [k k k]]\n                 (seq\n                  (filter\n                   #{w}\n                   (concat\n                    board\n                    ((partial apply map vector) board)\n                    (map #(map (partial get-in board) %)\n                         [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]))))))]\n        (cond (won? :x) :x\n              (won? :o) :o)))","problem":73,"user":"51f9527fe4b09be9c177e549"},{"problem":73,"code":"(fn ti-tac-toe[b]\n  (let [b00 ((b 0) 0)\n        b11 ((b 1) 1)\n        b22 ((b 2) 2)]\n    (or\n      (and (not= :e b00) (or (= b00 ((b 0) 1) ((b 0) 2)) (= b00 ((b 1) 0) ((b 2) 0)) (= b00 b11 b22)) b00)\n      (and (not= :e b11) (or (= b11 ((b 1) 0) ((b 1) 2)) (= b11 ((b 0) 1) ((b 2) 1)) (= b11 ((b 2) 0) ((b 0) 2))) b11)\n      (and (not= :e b22) (or (= b22 ((b 2) 0) ((b 2) 1)) (= b22 ((b 0) 2) ((b 1) 2))) b22)\n      nil)))","user":"5d5e0259e4b0c9e5857d4fef"},{"problem":73,"code":"(fn [coll]\n  (let [same? (fn [tmp] (if (apply = tmp) (first tmp) nil))\n        row (map same? coll)\n        cols (map same? (apply map vector coll))\n        dileft (same? (map get coll (range 3)))\n        diright (same? (map get coll (range 2 -1 -1)))]\n    (some #{:x :o} (concat row cols [dileft] [diright]))))","user":"5dfa1c67e4b0a607a9a45cc5"},{"problem":73,"code":"(fn [k]\n  (let [r (atom nil)\n        w [[0 1 2]\n           [3 4 5]\n           [6 7 8]\n           [0 3 6]\n           [1 4 7]\n           [2 5 8]\n           [2 4 6]\n           [0 4 8]]]\n    (doseq [l w]\n      (let [z (map #((k (quot % 3)) (rem % 3)) l)\n            flag (apply = z)]\n        (if (and (not= :e (first z)) flag)\n          (reset! r (first z)))))\n    @r))","user":"53da059be4b0e771c302547e"},{"problem":73,"code":"(fn [board]\n  (letfn [(check [vals] (if (apply = vals)\n                          (first vals)\n                          nil))]\n    (#{:x :o} (or\n               (some check board)\n               (some check (apply map vector board))\n               \n               (check (->> (range (count board))\n                           (map #(partial drop %))\n                           (map #(%2 %1)  board)\n                           (map first)))\n               (check (->> (range (count board))\n                           (map #(partial drop %))\n                           (map #(%2 %1) (reverse board))\n                           (map first)))))))","user":"5256c4c1e4b0541d1855ba36"},{"problem":73,"code":"(fn [matrix]\n   (let [\n         col1 (fn [letra matriz]\n           (every? #(= letra %) (for [i (range 3)] ((matriz i) 0) )))\n         col2 (fn [letra matriz]\n           (every? #(= letra %) (for [i (range 3)] ((matriz i) 1) )))\n         col3 (fn [letra matriz]\n           (every? #(= letra %) (for [i (range 3)] ((matriz i) 2) )))\n         fil1 (fn [letra matriz]\n           (every? #(= letra %) (for [i (range 3)] ((matriz 0) i) )))\n         fil2 (fn [letra matriz]\n           (every? #(= letra %) (for [i (range 3)] ((matriz 1) i) )))\n         fil3 (fn [letra matriz]\n           (every? #(= letra %) (for [i (range 3)] ((matriz 2) i) )))\n         diag1 (fn [letra matriz]\n                            (every? #(= letra %) (for [i (range 3)] ((matriz i) i) )))\n         diag2 (fn [letra matriz]\n                            (every? #(= letra %) (for [i (range 3)] ((matriz (- 2 i) ) i) )))\n         funcs [col1 col2 col3 fil1 fil2 fil3 diag1 diag2]\n\n    x ( some identity (for [f funcs] (f :x matrix)) )\n    o ( some identity (for [f funcs] (f :o matrix)) )\n   ]\n         (cond x :x\n               o :o\n               :else nil)\n\n     ))","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn [board] (let\n  [or* (fn or+ [s]\n    (if (empty? s)\n        false\n        (or (first s) (or+ (rest s)))))\n  wonrow? (fn [p b r]\n    (= ((b r) 0)\n            ((b r) 1)\n            ((b r) 2) p))\n  woncol? (fn [p b c]\n    (= ((b 0) c)\n            ((b 1) c)\n            ((b 2) c) p))\n  diag? (fn [p b]\n    (or (= ((b 0) 0)\n            ((b 1) 1)\n            ((b 2) 2) p)\n        (= ((b 0) 2)\n            ((b 1) 1)\n            ((b 2) 0) p)))\n  \n  won? (fn [p b]\n    (or (or* (map (partial wonrow? p b)\n                  (range 3)))\n        (or* (map (partial woncol? p b)\n                  (range 3)))\n        (diag? p b)))]\n\n  (if (won? :x board)\n      :x\n      (if (won? :o board)\n      :o nil))))","problem":73,"user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":73,"code":"(fn [b]\n  (some \n        #(first (#{#{:x} #{:o}} (set %)))\n        (concat b\n                (apply map list b)\n                (map #(map nth b %) [[0 1 2] [2 1 0]]))))","user":"5bbf0a02e4b07a9b28b0ffcf"},{"problem":73,"code":"(fn [xs]\n  (->> (-> (into xs (apply map vector xs))\n           (conj (mapv #(get-in xs %) [[0 0] [1 1] [2 2]])\n                 (mapv #(get-in xs %) [[0 2] [1 1] [2 0]])))\n       (map distinct)\n       (filter #(= 1 (count %)))\n       flatten\n       (some #{:x :o})))","user":"557c6ca6e4b05c286339e0c4"},{"problem":73,"code":"(fn judge\n  ([board] (let [conditions [[[0 0] [0 1] [0 2]]\n                             [[1 0] [1 1] [1 2]]\n                             [[2 0] [2 1] [2 2]]\n\n                             [[0 0] [1 0] [2 0]]\n                             [[0 1] [1 1] [2 1]]\n                             [[0 2] [1 2] [2 2]]\n                 \n                             [[0 0] [1 1] [2 2]]\n                             [[0 2] [1 1] [2 0]]]\n                 x (judge board :x conditions)\n                 o (judge board :o conditions)]\n             (cond (and x o) nil\n                   x :x\n                   o :o\n                   true nil)))\n  ([board player conditions]\n     (some (fn [condition] (every? (fn [id] (= ((board (id 0)) (id 1)) player))\n                                   condition)) conditions)))","user":"546c1f73e4b00cfc9eacc175"},{"problem":73,"code":"(fn [horizontal-lines]\n    (let [vertical-lines (for [x (range 3)]\n                           (for [y (range 3)]\n                             ((vec (horizontal-lines y)) x)))\n          diagonal-lines [(for [i (range 3)]\n                            ((vec (horizontal-lines i)) i))\n                          (for [i (range 3)]\n                            ((vec (horizontal-lines i)) (- (dec 3) i)))]\n          all-lines (concat horizontal-lines vertical-lines diagonal-lines)\n          count-items-in-line (fn [line item]\n                                (count (filter #(= item %) line)))\n          count-max-items-in-lines (fn [item]\n                                     (apply max (map #(count-items-in-line % item) all-lines)))]\n      (cond\n        (= 3 (count-max-items-in-lines :x)) :x\n        (= 3 (count-max-items-in-lines :o)) :o\n        :else nil)))","user":"53f891eee4b0de5c4184856d"},{"problem":73,"code":"(fn [[[a b c :as f] [d e f :as s] [g h i :as t]]]\n    (some {[:o :o :o] :o [:x :x :x] :x}\n          [f s t [a d g] [b e h] [c f i] [a e i] [c e g]]))","user":"55c5b55fe4b0e31453f649b5"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [third (fn  [x] (nth x 2))\n      is-a-winner? (fn [[row1 row2 row3 :as board] player]\n        (not (empty? (filter identity (map (fn [x] (every? #(= player %) x))\n                                           (conj\n                                            ;; rows\n                                            board\n                                            \n                                            ;; columns\n                                            (map first board)\n                                            (map second board)\n                                            (map third board)\n                                            \n                                            ;; diagonals\n                                            [(first row1)\n                                             (second row2)\n                                             (third row3)]\n                                            [(third row1)\n                                             (second row2)\n                                             (first row3)]\n                                            )\n                                           )))))]\n    (cond\n      (is-a-winner? board :x) :x\n      (is-a-winner? board :o) :o\n      :else nil)))","user":"53350264e4b0656e627bfd73"},{"problem":73,"code":"(fn [board] \n  (loop [rows [[[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]\n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]]]\n    (let [row (first rows)\n          getrow (map #(get-in board %) row)]\n      (if (seq rows)\n        (if (apply = getrow)\n          (if (= (first getrow) :e)\n            nil\n            (first getrow))\n          (recur (next rows)))\n        nil))))","user":"593744abe4b02506e01a299b"},{"problem":73,"code":"(fn [board]\n\n  (letfn [\n\n       (first-true        [p coll]   (if (empty? coll) nil\n                                         (let [[h & rst] coll]\n                                           (if (p h)\n                                             h\n                                             (recur p rst)))))\n\n       (get-winner-in-vec [coll]     (let [wins? #(every? (partial = %) coll)]\n                                       (cond (wins? :o) :o\n                                             (wins? :x) :x)))\n       (get-winner        [colls]    (->> colls\n                                          (first-true (fn [coll] (#{:x :o} (get-winner-in-vec coll))))\n                                          (first)))\n       (get-ins           [coll idx] (map (partial get-in coll) idx))\n\n       (get-skews         [b]        (map #(get-ins b %) [[[2,0],[1,1],[0,2]],\n                                                          [[0,0],[1,1],[2,2]]]))\n\n       (get-columns       [b]        (map #(get-ins b %) [[[0, 0], [1, 0], [2, 0]]\n                                                          [[0, 1], [1, 1], [2, 1]],\n                                                          [[0, 2], [1, 2], [2, 2]]]))]\n    (get-winner (concat board\n                        (get-skews board)\n                        (get-columns board)))))","user":"53dad484e4b0e771c30254ac"},{"code":"(fn [[a b c]]\r\n  (first\r\n    (keep #(if (not= :e %) %)\r\n      (map (partial reduce #(if (= % %2) %))\r\n        (into\r\n          [a b c\r\n           [(a 0) (b 1) (c 2)]\r\n           [(a 2) (b 1) (c 0)]]\r\n          (partition 3 (interleave a b c)))))))","problem":73,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":73,"code":"(fn analyze-tic-tac-toe-board\n  [[[a b c]\n    [d e f]\n    [g h i]]]\n  (let [winner (cond\n                 (= a b c) a\n                 (= d e f) d\n                 (= g h i) f\n                 (= a d g) a\n                 (= b e h) b\n                 (= c f i) c\n                 (= a e i) a\n                 (= g e c) g\n                 :else nil)]\n    (if (= winner :e) nil winner)))","user":"5866b999e4b0f14aab7c886b"},{"problem":73,"code":"(fn \n\tanalyzeboard \n\t[board] \n\t(some identity \n\t\t(map \n\t\t\t#({3 :x -3 :o} \n\t\t\t\t(reduce \n\t\t\t\t\t+ \n\t\t\t\t\t(map \n\t\t\t\t\t\t(partial nth (map {:e 0 :x 1 :o -1} (flatten board))) \n\t\t\t\t\t\t%\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) \n\t\t\t'([0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6])\n\t\t)\n\t)\n)","user":"56449e4de4b0284900eef5f9"},{"problem":73,"code":"(fn tic-tac-toe [brd]\n  (letfn\n    [(getxy [[x y]]\n       \"return the cell in the board a x column, y row. 0 <= x,y <= 2\"\n       (-> brd (nth y) (nth x)))\n     (sols []\n       (map (partial map getxy)\n            [[[2 0] [1 1] [0 2]]    ;forward slash diag\n             [[0 0] [1 1] [2 2]]    ;back slash diag\n             [[0 0] [0 1] [0 2]]    ;col 0\n             [[1 0] [1 1] [1 2]]    ;col 1\n             [[2 0] [2 1] [2 2]]    ;col 2\n             [[0 0] [1 0] [2 0]]    ;row 0\n             [[0 1] [1 1] [2 1]]    ;row 1\n             [[0 2] [1 2] [2 2]]])) ;row 2\n     (won? [p]\n       (some #{[p p p]} (sols)))]\n    (cond\n      (won? :x) :x\n      (won? :o) :o\n      true nil)))","user":"5703eda3e4b08d47c9778200"},{"code":"(fn who-won? [m]\n  (let [a [(first m) (second m) (last m),\n           (map first m) (map second m) (map last m)\n           [(ffirst m) (second (second m)) (last (last m))]\n           [(first (last m)) (second (second m)) (last (first m))]]\n        b (map set a)\n        c (some #(#{#{:x} #{:o}} %) b)]\n    (first c)))","problem":73,"user":"52039e12e4b0fb7e47ea51ff"},{"problem":73,"code":"(fn [board]\n  (let [\n    transpose (fn [matrix] (apply map vector matrix))\n    is-winner (fn [row]\n        (reduce #(if (and (not= %1 :e) (= %1 %2)) %1 nil) row))\n    diag1 (fn [board]\n        (for [pos (range (count board))] (get (get board pos) pos)))\n    diag2 (fn [board]\n        (for [pos (range (count board))] (get (get board (- (count board) pos 1)) pos)))\n    ]\n    (or (some is-winner board)\n        (some is-winner (transpose board))\n        (or (is-winner (diag1 board))\n            (is-winner (diag2 board))))))","user":"57069bc3e4b0b0fb43fd067f"},{"code":"(fn [m]\n  (let [diagonal (fn [m] (reduce #(conj %1 (%2 (count %1))) [] m))\n        transpose (fn [m] (apply (partial map vector) (reverse m)))\n        candidates (fn [m] (conj m (diagonal m)))\n        all-candidates (concat (candidates m) (candidates (transpose m)))]\n    (cond\n      (some (fn [c] (every? #(= % :x) c)) all-candidates) :x\n      (some (fn [c] (every? #(= % :o) c)) all-candidates) :o\n      :else nil)))","problem":73,"user":"53527551e4b084c2834f4af0"},{"code":"(fn [[x y z]]\n   (let [cont\n         (->>\n          (concat [x y z]\n                  (for [idx [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]]\n                    (map nth [x y z] idx)))\n          (filter #(apply = %))\n          ffirst)]\n     (if (= cont :e) nil cont)))","problem":73,"user":"4f8bbb27e4b02e764a0a5182"},{"problem":73,"code":"(fn [board]\n  (case\n    (cond\n     (= ((board 0) 0) ((board 0) 1) ((board 0) 2)) ((board 0) 0)\n     (= ((board 1) 0) ((board 1) 1) ((board 1) 2)) ((board 1) 0)\n     (= ((board 2) 0) ((board 2) 1) ((board 2) 2)) ((board 2) 0)\n     (= ((board 0) 0) ((board 1) 0) ((board 2) 0)) ((board 0) 0)\n     (= ((board 0) 1) ((board 1) 1) ((board 2) 1)) ((board 0) 1)\n     (= ((board 0) 2) ((board 1) 2) ((board 2) 2)) ((board 0) 2)\n     (= ((board 0) 0) ((board 1) 1) ((board 2) 2)) ((board 0) 0)\n     (= ((board 0) 2) ((board 1) 1) ((board 2) 0)) ((board 0) 2))\n    :e nil\n    :x :x\n    :o :o\n    nil nil))","user":"5801eed1e4b0a837a8b30c63"},{"problem":73,"code":"(fn [board]\n  (let [winning-line (fn [line]\n                       (and (not= :e (first line))\n                         \t(every? (partial = (first line)) line)\n                            (first line)))\n        line-h (for [r (range 3)]\n                 (for [c (range 3)] [r c]))\n        line-r (for [c (range 3)]\n                 (for [r (range 3)] [r c]))\n        line-d [(for [x (range 3)] [x (- 2 x)])]\n        line-d2 [(for [x (range 3)] [x x])]\n        line-all (concat line-h line-r line-d line-d2)\n        extract-board (fn [line]\n                        (map (partial get-in board) line))]\n    (some winning-line (map extract-board line-all))))","user":"5479c58de4b0c51c1f4d72c7"},{"problem":73,"code":"(fn [xs]\n   (let [x2 (reduce (fn [x j]\n                     (conj x (reduce (fn [z i] (conj z ((xs i) j))) [] [0 1 2]))\n                     ) [] [0 1 2]\n                       )\n         x3 (reduce (fn [x j]\n                      (conj x (reduce (fn [z i]\n                                        (conj z ((xs (if (= 0 j) i (- 2 i) ) ) i))\n                                        ) [] [0 1 2] ))) [] [0 1])]\n     (cond\n      (some true? (map (fn [x] (every? #(= :x %) x)) (concat xs x2 x3)))\n      :x\n      (some true? (map (fn [x] (every? #(= :o %) x)) (concat xs x2 x3)))\n      :o\n      :else nil\n      )\n     )\n\n)","user":"53ca23e3e4b00fb29b2212c6"},{"code":"(fn [board]\n    (letfn [(uniq?\n              [s]\n              (= (count (set s)) 1))\n            (diagonal-cells\n              [s]\n              (map #((second %) (first %))\n                   (map-indexed list s)))\n            (complete?\n              [player]\n              (some #(and (uniq? %) (= (first %) player))\n                    (concat\n                      board\n                      (apply map list board)\n                      [(diagonal-cells board)]\n                      [(diagonal-cells (reverse board))])))]\n           (some #(if (complete? %) % false) [:x :o])))","problem":73,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":73,"code":"(fn [board] \n  (loop [winner :e\n         rc 0]\n    (if (not= winner :e)\n      winner\n      (if (> rc 2)\n        nil\n        (if (= rc 2)\n                                        ;Check diagonals\n          (if (\n               or \n               (apply = [((board 0) 0) ((board 1) 1) ((board 2) 2)])\n               (apply = [((board 0) 2) ((board 1) 1) ((board 2) 0)])\n               )\n            (recur ((board 1) 1) (inc rc))\n            nil\n            )\n                                        ;Check rows\n          (if (apply = (nth board rc))\n            (recur (first (nth board rc)) (inc rc))\n                                        ;Check Columns\n            (if (apply = [(nth (nth board 0) rc) (nth (nth board 1) rc) (nth (nth board 2) rc)])\n              (recur (nth (nth board 0) rc) (inc rc))\n              (recur winner (inc rc))\n              )\n            )\n          )\n        )\n      )\n   )\n  )","user":"592ac550e4b072a2710fcf27"},{"code":"(fn [board]\r\n  (let [m {:hor1 [[0 0] [0 1] [0 2]]\r\n           :hor2 [[1 0] [1 1] [1 2]]\r\n           :hor3 [[2 0] [2 1] [2 2]]\r\n           :ver1 [[0 0] [1 0] [2 0]]\r\n           :ver2 [[0 1] [1 1] [2 1]]\r\n           :ver3 [[0 2] [1 2] [2 2]]\r\n           :diag1 [[0 0] [1 1] [2 2]]\r\n           :diag2 [[0 2] [1 1] [2 0]]}]\r\n    (loop [rows '(:hor1 :hor2 :hor3 :ver1 :ver2 :ver3 :diag1 :diag2)]\r\n      (cond (empty? rows)\r\n            nil\r\n            (every? (fn [[y x]]\r\n                      (= ((board y) x) :x))\r\n                    (m (first rows)))\r\n            :x\r\n            (every? (fn [[y x]]\r\n                      (= ((board y) x) :o))\r\n                    (m (first rows)))\r\n            :o\r\n            :else\r\n            (recur (rest rows))))))","problem":73,"user":"4de2f44f535d08e6dec9fdec"},{"problem":73,"code":"(fn [board]\n  (let [winner (fn [x y dx dy]\n                 (let [row (map #(nth (nth board (+ y (* dy %))) (+ x (* dx %))) (range 3))]\n                   (if (apply = row) (if (= (first row) :e) nil (first row)) nil)))]\n    (some #(apply winner %)\n          [[0 0 1 0] [0 1 1 0] [0 2 1 0]\n           [0 0 0 1] [1 0 0 1] [2 0 0 1]\n           [0 0 1 1] [0 2 1 -1]])))","user":"5b465b8be4b02d533a91bc65"},{"problem":73,"code":"(fn [board]\n   (letfn [(win? [p rows]\n             (let [pred (partial every? (partial = p))]\n               (some #(when (pred %) p) (concat rows\n                                                (apply map list rows)\n                                                (diags rows)))))\n           (diags [board]\n             (list (map (fn [n] ((board n) n)) (range 0 3))\n                   (map (fn [n] ((board n) (- 2 n))) (range 0 3))))]\n     (some #(win? % board) [:o :x])))","user":"547584d9e4b0c51c1f4d729b"},{"code":"(fn [[r1 r2 r3 :as board]]\n  (first\n   (filter #(not= :e %)\n           (map first\n                (filter #(apply = %)\n                        (concat board\n                                (list* (list (first r1) (second r2) (last r3))\n                                       (list (last r1) (second r2) (first r3))\n                                       (apply map list board))))))))","problem":73,"user":"506ef8c3e4b09350ab4199f4"},{"code":"(fn [board]\n  (let [row (fn [r] (and (apply = r) (not= (r 0) :e) (r 0)))\n        col (fn [i] (row ((apply juxt board) i)))\n        diag1 #(row (mapv get board (range 3)))\n        diag2 #(row (mapv get board (reverse (range 3))))]\n    (some identity (concat [(diag1) (diag2)] (map row board) (map col (range 3))))))","problem":73,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn tic-tac-toe [board]\n  (letfn [\n      (rows [bd] (seq bd))\n      (cols [bd] (for [i (range 3)] (map #(nth % i) (rows bd))))\n      (diags [bd] [(map #(get-in bd %) [[0 0] [1 1] [2 2]])\n                      (map #(get-in bd %) [[0 2] [1 1] [2 0]])])\n      (winner [v] (let [s (set v)] \n                    (and (= 1 (count s)) (not= (first s) :e) (first s))))\n      (horiz [bd] (some winner (rows bd)))\n      (vert [bd] (some winner (cols bd)))\n      (diag [bd] (some winner (diags bd)))]\n    (or\n      (horiz board)\n      (vert board)\n      (diag board))))","problem":73,"user":"4ed188c8535d44c135fd68cf"},{"problem":73,"code":"(fn [x]\n(let [diag1 (map #(%1 %2) [first second last] x)\n      diag2 (map #(%1 %2) [last second first] x)\n      all (conj x (map first x) (map second x) (map last x) diag1 diag2)\n      same? (fn [q] (every? #(= % (first q)) q))\n      not-empty? (fn [q] (not= (first q) :e))]\n  (first (flatten (filter (every-pred same? not-empty?) all)))))","user":"572a856be4b0f4d77e65123b"},{"problem":73,"code":"(fn winner [board]\n   (let [\n         board2 (flatten board)\n         tests [ \n                [0 1 2] [3 4 5] [6 7 8] \n                [0 3 6] [1 4 7] [2 5 8]\n                [0 4 8] [2 4 6]\n                ]\n         ]\n      (first \n        (first \n          (filter (fn [positions]\n                              (let [\n                                    frequencies (frequencies positions)\n                                    key (first (first frequencies))\n                                    value (second (first frequencies))\n                                    ]\n                                (and (not= :e key) (= 3 value))))\n                                \n                                (map (fn [[position1 position2 position3]]\n                                   [\n                                    (nth board2 position1)\n                                    (nth board2 position2)\n                                    (nth board2 position3)\n                                    ]\n                                   ) tests)\n                            )))\n     )\n   )","user":"583f1533e4b089d5ab817dc8"},{"code":"#(->> (concat % (apply map list %)\n              [(for [x [0 1 2]] ((% x) x))\n               [((% 2) 0) ((% 1) 1) ((% 0) 2)]])\n      (some {[:o :o :o] :o [:x :x :x] :x}))","problem":73,"user":"522b922ee4b0d34ee08e71c3"},{"problem":73,"code":"(fn tictac [n]\n  (cond\n   (#(= (first (first %)) (second (second %)) (nth (nth % 2) 2)) n) (if (= (first (first n)) :e) nil (first (first n)))\n   (#(= (first (first %)) (first (second %)) (first (nth % 2))) n) (if (= (first (first n)) :e) nil (first (first n)))\n   (#(= (second (first %)) (second (second %)) (second (nth % 2))) n) (if (= (second (first n)) :e) nil (second (first n)))\n   (#(= (nth (first %) 2) (nth (second %) 2) (nth (nth % 2) 2)) n) (if (= (nth (first n) 2) :e) nil (nth (first n) 2))\n   (#(= (nth (first %) 2) (second (second %)) (first (nth % 2))) n) (if (= (nth (first n) 2) :e) nil (nth (first n) 2))\n   (#(= (first (first %)) (second (first %)) (nth (first %) 2)) n) (if (= (first (first n)) :e) nil (first (first n)))\n   (#(= (first (second %)) (second (second %)) (nth (second %) 2)) n) (if (= (first (second n)) :e) nil (first (second n)))\n   (#(= (first (nth % 2)) (second (nth % 2)) (nth (nth % 2) 2)) n) (if (= (first (nth n 2)) :e) nil (first (nth n 2)))\n   :else nil))","user":"59368efbe4b02506e01a297d"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (->> [[a b c]\n        [d e f]\n        [g h i]\n        \n        [a d g]\n        [b e h]\n        [c f i]\n        \n        [a e i]\n        [c e g]]\n       (filter #(apply = %))\n       (filter #(not= :e (first %)))\n       ffirst))","user":"54dd76c8e4b024c67c0cf794"},{"problem":73,"code":"(fn [b]\n  (let [hh b\n        vv (for [v [0 1 2]](map #(% v) b))\n    \tx1 (map #(get-in b [% %]) [0 1 2])\n    \tx2 (map #(get-in b [% (- 2 %)]) [0 1 2])]\n    (->> (conj (concat hh vv) x1 x2)\n         (map set)\n         (filter #(= 1(count %)))\n         (some #(or (:x %) (:o %)))\n    )\n))","user":"526a3412e4b03e8d9a4a721e"},{"problem":73,"code":"(fn [[top mid bottom :as board]]\n  (let [all-comb (concat board (apply mapv vector board) [[(top 0) (mid 1) (bottom 2)] [(top 2) (mid 1) (bottom 0)]])]\n  \t(cond\n     (some (fn [row] (every? #(= % :x) row)) all-comb) :x\n     (some (fn [row] (every? #(= % :o) row)) all-comb) :o\n     :else nil)))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":73,"code":"(fn [board]\n  (let [same? (fn [s] (if (apply = s) (first s) nil))\n        rows (map same? board)\n        cols (map same? (apply map vector board))\n        diag1 (same? (map get board (range 3)))\n        diag2 (same? (map get board (range 2 -1 -1)))]\n    (some #{:x :o} (concat rows cols [diag1] [diag2]))))","user":"5a0a25fce4b0eab8c044893d"},{"problem":73,"code":"(fn ttt-valid [[[a b c] [d e f] [g h i]]]\n  (let [winners [[a b c] [d e f] [g h i]\n                 [a d g] [b e h] [c f i]\n                 [a e i] [c e g]]\n        same-key (fn [v] (apply = v))\n        not-e    (fn [v] (some #(not= :e %) v))]\n    (->> winners\n      (filter same-key)\n      (filter not-e)\n      (#(if (seq %) (apply first %))))))","user":"4ee897fe535d93acb0a66883"},{"problem":73,"code":"(fn f [b]\n    (some #(cond\n             (every? #{:o} %) :o\n             (every? #{:x} %) :x)\n          (concat b\n                  (apply map list b)\n                  [(map #(get-in b [% %]) [0 1 2])]\n                  [(map #(get-in b [% (- 2 %)]) [0 1 2])])))","user":"59419bdfe4b060784b3b78f7"},{"problem":73,"code":"; https://gist.github.com/SegFaultAX/3607101\n; Don't quite understand why some parts work --\n; why a set in the return line?\n\n(fn winner [board]\n  (let [line? (fn [coll]\n                (if (apply = coll)\n                  (first coll)\n                  nil))\n        rows (map line? board)\n        cols (map line? (apply map vector board))\n        dia1 (line? (map get board (range 3)))\n        dia2 (line? (map get board (range 2 -1 -1)))]\n    (some #{:x :o} (concat rows cols [dia1] [dia2]))))","user":"542c026ae4b0dad94371f29a"},{"code":"(fn [board]\n  (let [ get (fn [[y x]] (nth (nth board y) x))\n         xwin (repeat 3 :x)\n         owin (repeat 3 :o)\n         win (fn [line]\n                (let [sym (map get line)]\n                  (or (= sym xwin) (= sym owin))))\n         coords [['(0 0) '(0 1) '(0 2)]\n                 ['(0 0) '(1 1) '(2 2)]\n                 ['(0 0) '(1 0) '(2 0)]\n                 ['(0 1) '(1 1) '(2 1)]\n                 ['(0 2) '(1 2) '(2 2)]\n                 ['(1 0) '(1 1) '(1 2)]\n                 ['(2 0) '(1 1) '(0 2)]\n                 ['(2 0) '(2 1) '(2 2)]]\n       ]\n    (loop [input (seq coords) line (first input) ]\n      (if (= input '())\n         nil\n         (if (win line) \n             (get (first line))\n             (recur (rest input) (first (rest input))))))))","problem":73,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":73,"code":"(fn tic-tac-toe\n  [board-state]\n  (let\n      [same? (fn [segment] (if (apply = segment) (first segment) nil))\n       row-matches (map same? board-state)\n       col-matches (map same? (apply map vector board-state))\n       diag-matches (same? (map get board-state (range 3)))\n       diag2-matches (same? (map get board-state (range 2 -1 -1)))]\n    (some #{:x :o} (concat row-matches col-matches [diag-matches][diag2-matches]))))","user":"5f838122e4b01aacbe7a2715"},{"problem":73,"code":"(fn result-func [matr]\n  (letfn [(transpon [matrix]\n            (let [n (count matrix)\n                  m (count (first matrix))]\n              (loop [n n m m i 0 j 0 matr matrix temp [] res []]\n                (cond\n                  (= j m) res\n                  (= i n) (recur n m 0 (inc j) matr [] (cons temp res))\n                  :else (recur n m (inc i)\n                               j matr (cons (aget matr i j) temp) res)))))\n          (boo [matr]\n            (letfn [\n                    (first-foo\n                      [matr i] \n                      (if (empty? matr) nil\n                          (cons (nth (first matr) i) \n                                (first-foo  (rest matr) (inc i)))))\n                    (second-foo \n                      [matr i]\n                      (if (empty? matr) nil\n                          (cons (nth (first matr) i) \n                                (second-foo  (rest matr) (dec i)))))\n                    ]\n              (list (first-foo matr 0) (second-foo matr (dec (count matr))))))\n          (checker [coll]\n            (cond (empty? coll) nil\n                  (= true (apply = (first coll))) (cons (first (first coll))\n                                                        (checker(rest coll)))\n                  :else (checker (rest coll))))]\n    (let [temp \n          (checker (concat matr (boo matr) (transpon (to-array-2d matr))))]\n      temp\n      (cond (some #(= :x %) temp ) :x\n            (some #(= :o %) temp ) :o\n            :else nil))))","user":"6038b6b4e4b0d5df2af222ef"},{"code":"(fn tic-tac-toe [[x y z]]\n  (first\n    (filter #(not= :e %)\n      (concat\n        (for [line [x y z]\n              :when (apply = line)]\n          (line 0))\n        (for [col [0 1 2]\n              :when (= (x col) (y col) (z col))]\n          (x col))\n        (if (or (= (x 0) (y 1) (z 2))\n                (= (x 2) (y 1) (z 0)))\n          [(y 1)]\n          nil)))))","problem":73,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn\n  [[& rows]]\n  \n  (let [dimension (count rows)\n        take-diagonal (fn [index-fn] (reduce (fn [d n] (conj d (nth (nth rows n) (index-fn n)))) [] (take dimension (range))))\n        diagonals [(take-diagonal identity) (take-diagonal (partial - dimension 1))]\n        columns (apply mapv vector rows)\n        result (ffirst (filter #(apply = %) (concat rows columns diagonals)))]\n    (if (= :e result) nil result)))","problem":73,"user":"531490bde4b08068f379ed17"},{"problem":73,"code":"(fn [board] (first (into [] (filter (comp not nil?) (let [[[a b c]\n       [d e f]\n       [g h i]] board]\n  (map #(if (and (= (count (set %)) 1)\n                 (not (= (first %) :e)))\n           (first %)\n           nil) [[a b c] \n                 [d e f]\n                 [g h i]\n                 [a d g]\n                 [b e h]\n                 [c f i]\n                 [a e i]\n                 [c e g]]))))))","user":"504f5804e4b0a02f9cffde72"},{"problem":73,"code":"(fn [board]\n  (let [transpose (fn [m]\n                    (loop [temp m\n                           res []]\n                      (if (every? empty? temp)\n                        res\n                        (recur (mapv rest temp)\n                               (conj res (mapv first temp))))))\n\n        -- (->> board\n                (map frequencies)\n                (filter #(= 1 (count %)))\n                (first)\n                (map key)\n            (first))\n        |  (->> (transpose board)\n                (map frequencies)\n                (filter #(= 1 (count %)))\n                (first)\n                (map key)\n                (first))\n        right-down (->> (map nth board (range))\n               (frequencies)\n               ;; take it from map {} if count == 3\n               ((fn [m]\n                  (if (= 1 (count m))\n                    (first (keys m))\n                    nil))))\n        left-down (->> (map nth board (range 2 -1 -1))\n                              (frequencies)\n               ;; take it from map {} if count == 3\n               ((fn [m]\n                  (if (= 1 (count m))\n                    (first (keys m))\n                    nil))))]\n    ;; (do\n    ;;   (println -- | right-down left-down)\n    ;;   (->> (list -- | right-down left-down)\n    ;;        (filter (complement nil?))\n    ;;        (filter #(not= % :e))\n    ;;        (first)))))\n    (->> (list -- | right-down left-down)\n         (filter (complement nil?))\n         (filter #(not= % :e))\n         (first))))","user":"5defc177e4b093ff717275af"},{"code":"(fn\n  [[row1 row2 row3 :as board]]\n  (let [all-checks \n        (conj \n          board \n          ; vertical\n          (map #(nth % 0) board)\n          (map #(nth % 1) board)\n          (map #(nth % 2) board)\n          ; diagonal\n          [(nth row1 0) (nth row2 1) (nth row3 2)]\n          [(nth row3 0) (nth row2 1) (nth row1 2)]\n        )]\n    (let [filtered (filter \n          #(not= [:e :e :e] %) \n          all-checks\n        )]\n    (ffirst \n      (filter\n        (fn\n          [cand]\n          (every? \n            #(identical? (nth cand 0) %) \n            cand\n          )) \n        filtered\n      )\n      )\n    )\n  )\n)","problem":73,"user":"52485723e4b05ef8e38e63d2"},{"code":"(fn [board]\n    (let [rows board,\n    \t    cols (reduce #(map conj %1 %2) (repeat []) board),\n    \t    diags [(map nth board (range 3)),\n    \t\t         (map nth board (reverse (range 3)))],\n          lines (concat rows cols diags)]\n      (first (first \n                (filter \n  \t                #(and (apply = %) (not= (first %) :e))\n  \t                lines)))))","problem":73,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":73,"code":"(fn[board]\n  (->> board\n  (#(concat % (apply map list %) [(vector (ffirst %) (second (second %)) (nth (nth % 2) 2))]\n               [(vector (first (nth % 2)) (second (second %)) (nth (first %) 2))]))\n     (filter (fn [coll] (not-any? #(= % :e) coll)))\n     (filter #(apply = %))\n     ffirst))","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn [field]\n  (first\n    (some\n      #{[:x :x :x] [:o :o :o]}\n      (concat\n        field\n        (apply map vector field)\n        (map\n          (fn [diagonal]\n            (map #(%1 %2) field diagonal))\n          [[0 1 2] [2 1 0]])))))","problem":73,"user":"511f88eee4b085952a83535f"},{"problem":73,"code":"(fn __ [board]\n  (letfn [(ckrow [brd]\n            (some identity\n                  (map\n                   #(cond\n                      (some (partial = :e) %) nil\n                      (apply = %) (first %)\n                      :else nil)\n                   brd)))\n          (ckcol [brd]\n            (ckrow\n             (let [[r0 r1 r2] brd]\n               (map conj (map conj (map list r0) r1) r2))))\n          (ckdia [brd]\n            (ckrow\n             (let [[r0 r1 r2] brd]\n               [[(nth r0 0) (nth r1 1) (nth r2 2)]\n                [(nth r2 0) (nth r1 1) (nth r0 2)]] )))]\n    (some identity [(ckrow board) (ckcol board) (ckdia board)])))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":73,"code":"(fn [b]\n   (letfn [(win [v b] (or (some true? (map #(every? (fn[x] (= x v)) %) b))\n                        (= v (ffirst b) (second (second b)) (last (last b)))\n                        (= v (last (first b)) (second (second b)) (first (last b)))))\n           (rotate [b] (for [i (range 3)]\n                         (mapv #(nth % i) b)))]\n     (cond \n       (or (win :x b) (win :x (rotate b))) :x\n       (or (win :o b) (win :o (rotate b))) :o)))","user":"5d764e52e4b02e6b30c93524"},{"problem":73,"code":"(fn winner? \n  [board]\n  (let [w-row? (fn w-row?  [p rows]  (some #(every? (partial = p) %) rows))\n        colns (fn colns  [board]  (partition 3 (apply interleave board)))\n        diags (fn diags  [board]  (concat [(map #(nth % (.indexOf board %)) board)] [(map #(nth % (- 2 (.indexOf board %))) board)]))\n        rows (concat board (colns board) (diags board))]\n       (cond \n             (w-row? :o rows) :o\n             (w-row? :x rows) :x\n             :else nil)))","user":"55acd080e4b03311e7b73298"},{"problem":73,"code":"(fn [board]\n  (let [fs [identity\n            #(->> % (apply interleave) (partition 3))\n            #(map (partial map nth %) [[0 1 2] [2 1 0]])]\n        check #(and (= 1 (count %)) (first %))]\n    (->> fs\n         (map #(->> board % (map distinct)))\n         (apply concat)\n         (remove #(= % '(:e)))\n         (some check))))","user":"54c5cc17e4b045293a27f624"},{"problem":73,"code":"(fn [board]\n   (let [w [\n            [[0 0] [0 1] [0 2]]\n            [[1 0] [1 1] [1 2]]\n            [[2 0] [2 1] [2 2]]\n            [[0 0] [1 0] [2 0]]\n            [[0 1] [1 1] [2 1]]\n            [[0 2] [1 2] [2 2]]\n            [[0 0] [1 1] [2 2]]\n            [[0 2] [1 1] [2 0]]]\n         isMatch (fn [p]\n                   (some (fn [l] (every? (fn [[r c]] (= p ((board c) r)) ) l)) w))]\n     (cond\n      (isMatch :x) :x\n      (isMatch :o) :o\n      :else nil)))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":73,"code":"(fn [tttb]\n  (let [cnt (count tttb)\n        diags [(for [i (range cnt)] ((tttb i) i)) (for [i (range cnt)] ((tttb (- cnt i 1)) i))]\n        cols (for [x (range cnt)] (for [y (range cnt)] ((tttb y) x)))\n        full-axes (remove (fn [a] (some #(= :e %) a)) (concat tttb diags cols))]\n    (first (first (filter #(apply = %) full-axes)))))","user":"53e745a1e4b036ad0777e479"},{"code":"#(let [c (vec (flatten %))\n       l [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [6 4 2]]\n       j (map (fn [x] (map (fn [y] (get c y)) x)) l)]\n    (cond (some #{[:x :x :x]} j) :x\n          (some #{[:o :o :o]} j) :o\n          :else nil))","problem":73,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn check-tictactoe [b]\n    (let [ d1 ((juxt ffirst (comp second second) (comp last last)) b)\n            d2 ((juxt (comp last first) (comp second second) (comp first last)) b)\n            tr (apply (partial map (fn [& xs] (concat xs))) b)\n            l (conj (reduce conj b tr) d1 d2)\n            f (fn [v]  (let [[k c] (last (sort-by second (frequencies v)))]\n                (if (and (= c 3) (not= k :e)) k)))]\n            (reduce #(or %1 %2) (map f l))))","problem":73,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn [board]\n  (let [winners\n    (for [p [:x :o]]\n      (some \n\t\t(fn [v] (every? #(= p %) v)) \n       \t(concat board \n                (apply map vector board)\n                [(reduce #(conj %1 (get-in board [%2 %2])) [] (range 3))]\n\t\t        [(reduce #(conj %1 (get-in board [%2 (- 2 %2)])) [] (range 3))]\n          \n\t\t)))]\n\t(cond (first winners) :x\n          (second winners) :o)))","problem":73,"user":"53300924e4b019098a6f8b55"},{"problem":73,"code":"(fn [m]\n  (let [a (concat (apply map vector m) (seq m)\n         ((fn [x] (let [g #(get-in x %) d (g [1 1])] \n              (seq [[(g [0 0]) d (g [2 2])] [(g [0 2]) d (g [2 0])]]))) m))       h (fn [k] (some #(every? #{k} %) a))]\n    (if (h :x)\n     :x \n         (if (h :o)\n       :o \n             nil))))","user":"5405885ee4b0addc1aec6668"},{"code":"(fn [game]\n  (let [n    (count game)\n        rows (seq game)\n        cols (apply map vector game)\n        diag1 (map #(get (get game %1) %2) (range n) (range n))\n        diag2 (map #(get (get (vec (rseq game)) %1) %2) (range n) (range n))\n        sols (conj (concat rows cols) diag1 diag2)\n        checkln #(if (apply = %2)\n                    (if (= (first %2) :e) %1 (first %2))\n                    %1)]\n    (reduce checkln nil sols)))","problem":73,"user":"4e7f5a0b535db966e863cc41"},{"problem":73,"code":"(fn win? [[[x0 y0 z0] [x1 y1 z1] [x2 y2 z2]]]\n  (let [condidates [[x0 y0 z0]\n                    [x1 y1 z1]\n                    [x2 y2 z2]\n                    [x0 x1 x2]\n                    [y0 y1 y2]\n                    [z0 z1 z2]\n                    [x0 y1 z2]\n                    [x2 y1 z0]]]\n    (ffirst (for [condidate condidates\n                  :when (and (apply = condidate) (every? #{:x :o} condidate))]\n              condidate))))","user":"52d00832e4b07d0d72b273b4"},{"problem":73,"code":"(fn [board] \n(letfn [\n        (value-or-false [value]\n          (fn [array] (and (every? #(= value %) array) value)))\n\n        (x-o-nil? [tictactoe]\n          (or (some (value-or-false :x) tictactoe)\n              (some (value-or-false :o) tictactoe)))\n\n        (diagonal [[[a _ b] [_ c _] [d _ e]]] [[a c e] [b c d]])\n       ]\n        \n       (or\n          (x-o-nil? board)\n          (x-o-nil? (apply map list board))\n          (x-o-nil? (diagonal board)))))","user":"5797d3d2e4b039eba2ecb106"},{"problem":73,"code":"(fn [mat]\n\t(let [res (set (concat mat (map #(map (fn [i v] (v i)) % mat) [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]])))]\n\t\t(cond\n\t\t\t(contains? res [:x :x :x]) :x\n\t\t\t(contains? res [:o :o :o]) :o\n\t\t\t:else nil)))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":73,"code":"(fn ttt [xs]\n  (let [pieces-in-coords (fn [board t coords]\n                            (every? true? (map #(= t (board %)) coords)))\n        pieces-in-positions (fn [board t]  \n                             (some true? (map (partial pieces-in-coords board t) \n                                [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]])))\n        board (vec (apply concat xs))]\n      (cond (pieces-in-positions board :x) :x\n            (pieces-in-positions board :o) :o\n            :else nil)))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn [board]\n  (let [t (apply map vector board)\n        cross (map get board [0 1 2])\n        r-crs (map get board [2 1 0])]\n    (some {[:x :x :x] :x [:o :o :o] :o} `[~@board ~@t ~cross ~r-crs])))","problem":73,"user":"4e8e8c24535d65386fec2143"},{"problem":73,"code":"(fn p73 [board]\n   (ffirst (filter #{#{:x} #{:o}}\n                   (set (map set\n                             (-> board\n                                 (conj (map #(get-in %1 [%2]) board (range (count board))))\n                                 (conj (map #(get-in %1 [%2]) board (reverse (range (count board)))))\n                                 (concat (apply mapv vector board))))))))","user":"5d669613e4b0db5d338d15ea"},{"code":"(fn [y]\n    (cond\n      (or\n        ((fn [m l] (some #(= [l l l] %) m)) y :x)\n        ((fn [m l] (some (fn [n] (= [l l l] (map #(get % n) m))) (range 3))) y :x)\n        ((fn [m l] (or (= [l l l] (map #(get (get m %) %) (range 3))) (= [l l l] (map #(get (get m (- 2 %)) %) (range 3))))) y :x)) :x\n      (or\n        ((fn [m l] (some #(= [l l l] %) m)) y :o)\n        ((fn [m l] (some (fn [n] (= [l l l] (map #(get % n) m))) (range 3))) y :o)\n        ((fn [m l] (or (= [l l l] (map #(get (get m %) %) (range 3))) (= [l l l] (map #(get (get m (- 2 %)) %) (range 3))))) y :o)) :o)\n    )","problem":73,"user":"504e1abee4b0f6ff3350c45d"},{"problem":73,"code":"(fn f [[a b c]] \n\t(let [positions [[a 0 a 1 a 2]\n\t                 [a 0 b 1 c 2]\n\t                 [a 0 b 0 c 0]\n\t                 [a 1 b 1 c 1]\n\t                 [a 2 b 2 c 2]\n\t                 [a 2 b 1 c 0]\n\t                 [b 0 b 1 b 2]\n\t                 [c 0 c 1 c 2]\n\t                 ]] \n\t                (->> (map (fn [position] (map (fn [[a b]] (a b)) (partition 2 position))) positions)\n\t                     (filter #(apply = %))\n\t                     (filter (fn [cs] (not= (first cs) :e)))\n\t                     (#(if (empty? %) nil (first (first %)))))))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":73,"code":"(fn check [[x y z :as all]]\n   (first\n    (filter (complement nil?)\n            (map\n             (fn [a]\n               (if (every? (fn [elem] (= elem :x)) a)\n                 :x\n                 (if (every? (fn [elem] (= elem :o)) a)\n                   :o\n                   nil)))\n             (concat all (partition 3 (interleave x y z))\n                     [[(x 0) (y 1) (z 2)]]\n                     [[(x 2) (y 1) (z 0)]])))))","user":"5d5c6675e4b09db18d4482ec"},{"problem":73,"code":"; Who really wants to parametrize horizontal lines, vertical lines, and diagonals for this?\n; Also, that line of duplicated code is so minimal that I'll just let it be.\n(let [winning-combs #{[1 2 3] [4 5 6] [7 8 9] [1 4 7] [2 5 8] [3 6 9] [1 5 9] [3 5 7]}]\n  (fn [[[a b c] [d e f] [g h i]]] (let [h {1 a, 2 b, 3 c, 4 d, 5 e, 6 f, 7 g, 8 h, 9 i}]\n                                    (cond\n                                     (some (fn [comb] (every? #(= (h %) :x) comb)) winning-combs) :x\n                                     (some (fn [comb] (every? #(= (h %) :o) comb)) winning-combs) :o\n                                     true nil))))","user":"584dadebe4b0b7285a6f4e44"},{"problem":73,"code":"(fn winner [board]\n  (let [rows board\n        columns (apply map list board)\n        backslash ((juxt ffirst #(get (get % 1) 1) #(get (get % 2) 2)) board)\n        forwardslash ((juxt #(get (get % 0) 2) #(get (get % 1) 1) #(get (get % 2) 0)) board)\n        diagonals [backslash forwardslash]\n        all (concat rows columns diagonals)]\n    (ffirst (filter #(and (not= (first %) :e)(apply = %)) all))))","user":"541f5b37e4b01498b1a71a97"},{"code":"(fn [board]\n    (let [check (fn [b c]\n      \t\t\t      (reduce #(or %1 %2)\n\t\t\t            \t      (map #(= (repeat 3 c) %) b)))\n\t\t      transpose (fn [board]\n                      (loop [b board r []]\n  \t                    (if (empty? (flatten b))\n\t\t                        r\n\t\t                        (recur (map rest b)\n\t\t\t                             (conj r (map first b))))))\n          t (transpose board)\n          mid (first (rest (first (rest board))))\n          cx1 [(first (first board)) mid (last (last board))]\n          cx2 [(first (last board)) mid (last (first board))]]\n\t\t      (cond (check board :x) :x\n\t\t          (check board :o) :o\n\t\t          (check t :x) :x\n\t\t          (check t :o) :o\n              (= (repeat 3 :x) cx1) :x\n              (= (repeat 3 :o) cx1) :o\n              (= (repeat 3 :x) cx2) :x\n              (= (repeat 3 :o) cx2) :o\n              :else nil)))","problem":73,"user":"4f4a5ca6e4b0d56e7bb92c0f"},{"problem":73,"code":"(fn [board]\n   (let [get-row-winner (fn [row]\n                          (let [contains-winner (and (apply = row)\n                                                     (not= (first row) :e))]\n                            (when contains-winner\n                              (first row))))\n         get-diagonals (fn [board] [[(get-in board [0 0])\n                                     (get-in board [1 1])\n                                     (get-in board [2 2])]\n                                    [(get-in board [0 2])\n                                     (get-in board [1 1])\n                                     (get-in board [2 0])]])\n         get-all-rows (fn [board]\n                        (let [horizontals board\n                              verticals (apply mapv vector board)\n                              diagonals (get-diagonals board)]\n                          (concat horizontals verticals diagonals)))]\n     (some get-row-winner (get-all-rows board))))","user":"5cd639b4e4b0ccb061962940"},{"code":"(fn [board]\n          (letfn [(transpose [mat]\n                    (if (= 1 (count mat))\n                      (map list (first mat))\n                      (map cons (first mat) (transpose (rest mat)))))]\n            (let [won (fn [l] (or (= l [:x :x :x]) (= l [:o :o :o])))\n                  rows (filter won board)\n                  cols (filter won (transpose board))]\n              (cond\n                (not (empty? rows)) (ffirst rows)\n                (not (empty? cols)) (ffirst cols)\n                (won (map #(nth (nth board %) %) (range 3))) (ffirst board)\n                (won (map #(nth (nth (reverse board) %) %) (range 3))) (first (last board))\n                ))))","problem":73,"user":"4fb1325de4b081705acca276"},{"problem":73,"code":"(fn [board]\n  (let [rows  \t  board\n        columns   (apply map vector board)\n        diagonals [(map get board [0 1 2]) (map get board [2 1 0])]\n        lines     (concat rows columns diagonals)\n        check-line (fn [line]\n                     (when\n                       (every? #(= (first line) %) (rest line))\n                       (first line)))\n        results-by-lines (map check-line lines)\n        first-win (some #(when (keyword? %) %) results-by-lines)]\n\n    (when (and first-win\n               (= (count (filter #(= first-win %) results-by-lines)) 1))\n      first-win)))","user":"55cc6c35e4b0e31453f64a10"},{"code":"(fn who-won [board-rows]\n  (letfn \n    [ (diag [board-rows]\n        (map nth board-rows (range)))\n          \n      (transpose [board-rows]\n        (apply (partial map vector) board-rows))\n          \n      (rows-cols-diags [board-rows]\n        (concat \n          board-rows \n          (transpose board-rows) \n          [(diag board-rows)] \n          [(diag (reverse board-rows))]))\n\n      (player-won? [player-id board-rows]\n        (some \n          #(every? (partial = player-id) %1) \n          (rows-cols-diags board-rows)))]\n    (cond \n      (player-won? :x board-rows) :x\n      (player-won? :o board-rows) :o\n      :else nil)))","problem":73,"user":"5268eb68e4b03e8d9a4a71c6"},{"code":"(fn [mt]\n  (letfn [(all [sym] (fn [s] (if (every? #(= % sym) s) sym)))\n          (vert [m] (apply map vector m))\n          (diag [m] (map \n                     (fn [s] (map-indexed #(nth %2 %) s))\n                     [m\n                      (map reverse m)]))\n          (f [st] #(some (all %) st))]\n    (let [st (concat mt (vert mt) (diag mt))]\n      (some (f st) [:x :o]))))","problem":73,"user":"51944aaae4b0142f60b4aedc"},{"problem":73,"code":"(fn [vss]\n        (->> (concat vss\n                     (apply map vector vss)\n                     (->> (count vss)\n                          (range)\n                          ((juxt identity reverse))\n                          (map (partial map nth vss))))\n             (remove (partial every? #{:e}))\n             (filter (partial apply =))\n             (ffirst)))","user":"58e37946e4b005f69f193cae"},{"code":"(fn [ttt-board]\n    (first\n     (filter #(not (nil? %))\n             (for [set-3 (concat\n                          ttt-board     ; rows\n                          (for [col (range (count (first ttt-board)))]\n                            (map #(get % col) ttt-board)) ; columns\n                          [(map #(get-in ttt-board %) [[0 0] [1 1] [2 2]])] ; diagonal 1 \n                          [(map #(get-in ttt-board %) [[0 2] [1 1] [2 0]])]) ; diagonal 2\n                   ]\n               (reduce #(if (and (not (= :e %1))\n                                 (= %1 %2))\n                          %1\n                          nil)\n                       set-3))))\n    )","problem":73,"user":"52213426e4b0e6a83c8925c4"},{"problem":73,"code":"(fn [board]\n   (let [wins\n         [ [[0 0] [0 1] [0 2]]\n           [[1 0] [1 1] [1 2]]\n           [[2 0] [2 1] [2 2]]\n           [[0 0] [1 0] [2 0]]\n           [[0 1] [1 1] [2 1]]\n           [[0 2] [1 2] [2 2]]\n           [[0 0] [1 1] [2 2]]\n           [[0 2] [1 1] [2 0]]]\n         cf (fn [coords]\n              (get (get board (last coords))\n                   (first coords)))\n         results (map #(map cf %) wins)]\n     (when-let [mark\n               \t(first\n     \t\t\t (flatten\n      \t\t\t  (remove nil?\n     \t\t\t   (for [v results]\n       \t\t\t\t(when (= (nth v 0) (nth v 1) (nth v 2)) v)))))]\n       (when (or (= :x mark)\n                 (= :o mark))\n         mark))))","user":"56f881e0e4b08e7d20b96839"},{"code":"(fn [board]\n  (ffirst\n    (filter\n      #(and (apply = %) \n            (not= :e (first %)))\n      (map\n        (fn [line] (map #(get-in board %) line))\n        [[[0 0] [0 1] [0 2]]\n         [[1 0] [1 1] [1 2]]\n         [[2 0] [2 1] [2 2]]\n         [[0 0] [1 0] [2 0]]\n         [[0 1] [1 1] [2 1]]\n         [[0 2] [1 2] [2 2]]\n         [[0 0] [1 1] [2 2]]\n         [[2 0] [1 1] [0 2]]]))))","problem":73,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn [board]\n  (let [[& rows] board\n        cols (apply (partial map vector) rows)\n        [[a1 _ b1] [_ c _] [b2 _ a2]] board\n        diags [[a1 c a2] [b1 c b2]]\n        ifsame (fn [args] (when (apply = args) (first args)))\n        sames (map ifsame (concat rows cols diags))\n        goods (filter #{:x :o} sames)\n        winner (first goods)]\n    winner))","problem":73,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":73,"code":"(fn [[[q _ e] [_ s _] [z _ c] :as board]]\n   (\n    letfn [(all? [v coll] (every? #(= v %) coll))]\n    (let [flat (concat board (apply map vector board) [[q s c] [e s z]] )]\n      (cond \n        (some #(all? :x %) flat) :x\n        (some #(all? :o %) flat) :o\n        :else nil)\n    )\n   ))","user":"546280d8e4b01be26fd746b0"},{"problem":73,"code":"(fn [b]\n  (let [m (reduce\n           (fn [m [i v]]\n             (assoc m (keyword (str i)) (if (= v :e) i v)))\n           {}\n           (zipmap (range) (apply concat b)))]\n    (cond\n      (= (:0 m) (:1 m) (:2 m)) (:0 m)\n      (= (:3 m) (:4 m) (:5 m)) (:3 m)\n      (= (:6 m) (:7 m) (:8 m)) (:6 m)\n      (= (:0 m) (:3 m) (:6 m)) (:0 m)\n      (= (:1 m) (:4 m) (:7 m)) (:1 m)\n      (= (:2 m) (:5 m) (:8 m)) (:2 m)\n      (= (:0 m) (:4 m) (:8 m)) (:0 m)\n      (= (:2 m) (:4 m) (:6 m)) (:2 m)\n      :else nil)))","user":"5cf6522be4b0b71b1d808a58"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i]]]\n  (let [wins [[a b c][d e f][g h i][a d g][b e h][c f i][a e i][c e g]]]\n    (some {[:x :x :x] :x [:o :o :o] :o} wins)))","user":"4fa5c8dde4b081705acca1af"},{"problem":73,"code":"(fn tic-tac-toe-won? [board]\n  (let [three ((apply juxt\n                (concat\n                  (for [row (range 3)] (fn [board] (nth board row)))\n                  (for [column (range 3)] (fn [board] (mapv #(nth % column) board)))\n                  [(fn [board] (mapv #(get-in board %) [[0 0] [1 1] [2 2]]))\n                   (fn [board] (mapv #(get-in board %) [[0 2] [1 1] [2 0]]))]))\n                board)]\n\n    (cond\n      (some (fn [line] (every? #(= :x %) line)) three) :x\n      (some (fn [line] (every? #(= :o %) line)) three) :o)\n    ))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn [ttt] \n  (ffirst \n    (filter \n      #(and \n        (not (:e %)) \n        (= 1 (count %))) \n      (map set \n        (concat \n          ttt \n          (apply map list ttt)\n          [(map-indexed #(nth %2 %) ttt)\n           (map-indexed #(nth %2 (- 2 %)) ttt)])))))","problem":73,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":73,"code":"(fn [s]\n  (letfn [(f [t]\n            (map #(if (apply = %) (first %) nil) t))]\n    (->> (mapcat f [s \n                    (apply map vector s)\n                    [[(first (first s)) (second (second s)) (last (last s))]]\n                    [[(last (first s)) (second (second s)) (first (last s))]]]) \n         (filter #{:x :o})\n         (first))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":73,"code":"(fn check [ttt]\n  (let [row (fn [ttt i] (ttt i))\n        col (fn [ttt i] (map #(% i) ttt))\n        d1  (fn [ttt] (map #(%1 %2) ttt (range 3)))\n        d2  (fn [ttt] (map #(%1 %2) (reverse ttt) (range 3)))\n        every-of? (fn [x ts] (every? #(= % x) ts))\n        tss (concat \n              (for [i (range 3)] (row ttt i)) \n              (for [i (range 3)] (col ttt i))\n              [(d1 ttt)]\n              [(d2 ttt)])]\n    (cond \n      (some #(every-of? :o %) tss) :o \n      (some #(every-of? :x %) tss) :x\n      true nil)))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(fn [board]\n\t\t       (letfn [(eq-elem [es] \n\t\t\t\t\t(if (apply = es) (first es) false))\n\t\t\t       (transpose [rows]\n\t\t\t\t\t  (map (fn [n] (map #(nth % n) rows)) (range (count rows))))\n\t\t\t       (trace [rows]\n\t\t\t\t      (map #(nth (nth rows %) %) (range (count rows))))\n\t\t\t       (trace2 [rows]\n\t\t\t\t       (map #(nth (nth rows %) (- (count rows) 1 %)) (range (count rows))))\n\t\t\t       (candidate-rows [board]\n\t\t\t\t       (concat board (transpose board) [(trace board) (trace2 board)]))]\n\t\t\t\t       (let [solution (some eq-elem (candidate-rows board))]\n\t\t\t\t\t    (if (= solution :e)\n\t\t\t\t\t\tnil\n\t\t\t\t\t\tsolution))))","problem":73,"user":"4e68fad4535d8ccf87e9fe93"},{"problem":73,"code":"(fn [board]\n  (let [rows   board\n        cols   (apply map vector board)\n        ul-lr  [(map-indexed #(get %2 %1) board)]\n        ur-ll  [(map-indexed #(get %2 (- 2 %1)) board)]\n        lines  (concat rows cols ul-lr ur-ll)] \n  (first (some #{#{:o} #{:x}} (map set lines)))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":73,"code":"(fn [rows]\n  (let [[[nw _ ne] [_ center _] [sw _ se]] rows\n        rows (-> rows\n                 (concat (apply mapv vector rows))\n                 (conj [nw center se] [sw center ne]))]\n    (cond (.contains rows [:x :x :x]) :x\n          (.contains rows [:o :o :o]) :o\n          :else nil\n    )\n  )\n)","user":"586f3f7ee4b01531a375e9c1"},{"code":"(fn [[a b c]]\n  (let [n (first (first (filter (fn [[s t u]] (= s t u))\n    [a b c\n[(nth a 0) (nth b 0) (nth c 0)]\n[(nth a 1) (nth b 1) (nth c 1)]\n[(nth a 2) (nth b 2) (nth c 2)]\n[(nth a 0) (nth b 1) (nth c 2)]\n[(nth a 2) (nth b 1) (nth c 0)]])))]\n  (if (= n :e) nil n)))","problem":73,"user":"4ee82223535d93acb0a66877"},{"code":"(let [grps [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n  (fn [game] (let [game (vec (apply concat game))]\n               (first (some #{#{:x} #{:o}} (map #(set (map game %)) grps))))))","problem":73,"user":"519ef784e4b087743fad2198"},{"code":"(fn [board]\n  (let [winidx [[0 1 2] [3 4 5] [6 7 8] ; rows\n                [0 3 6] [1 4 7] [2 5 8] ; cols\n                [0 4 8] [6 4 2]] ; diag\n        flatb (vec (flatten board))\n        checkseqs (map (partial map flatb) winidx)]\n    (cond (some true? (map (partial apply = :x) checkseqs)) :x\n          (some true? (map (partial apply = :o) checkseqs)) :o\n          :else nil)))","problem":73,"user":"52950ab6e4b02ebb4ef7501a"},{"code":"(fn [board]\n  (letfn [(at2 [seq [x y]] (nth (nth seq y) x))\n          (win? [seq] (let [s (first seq)]\n                        (and (or (= s :o) (= s :x)) (every? #(= % s) seq))))]\n    (ffirst (filter win?\n                    (map (fn [three] (map #(at2 board %) three))\n                         (concat (map (fn [y] (vec (map (fn [x] [x,y]) (range 0 3)))) (range 0 3))\n                                 (map (fn [x] (vec (map (fn [y] [x,y]) (range 0 3)))) (range 0 3))\n                                 [[[0,0], [1,1], [2,2]]]\n                                 [[[0,2], [1,1], [2, 0]]]\n                          ))))))","problem":73,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn [coll]\n  (let [colls coll\n        colls (conj colls (vec (map first coll)))\n        colls (conj colls (vec (map second coll)))\n        colls (conj colls (vec (map last coll)))\n        colls (conj colls [((coll 0) 0) ((coll 1) 1) ((coll 2) 2)])\n        colls (conj colls [((coll 0) 2) ((coll 1) 1) ((coll 2) 0)])\n        colls (filter #(apply = %) colls)\n        colls (filter #(not= :e (first %)) colls)]\n    (if (seq colls)\n      ((first colls) 0)\n      nil)))","problem":73,"user":"531d34cfe4b08068f379edac"},{"code":"(fn ttt [r]\r\n  (let [f (fn [n] (map #(nth % n) r))\r\n        win (fn [k row] (every? #(= k %) row))\r\n        diag (fn [rows]\r\n               (loop [drow [] i 0 rrows rows]\r\n                 (if (= i 3)\r\n                   drow\r\n                   (recur (conj drow (nth (first rrows) i)) (inc i) (rest rrows)))))\r\n        ]\r\n    (let [rows  (concat r (map f (range 3)) [(diag r) (diag (map reverse r))]) ]\r\n      (cond\r\n       ((complement not-any?) #(win :o %) rows) :o\r\n       ((complement not-any?) #(win :x %) rows) :x\r\n       true nil\r\n       true nil\r\n       ))))","problem":73,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":73,"code":"(fn analyze [board]\n  (let [line-winner (fn [line]\n                      (let [s (into #{} line)\n                            f (first s)]\n                        (when (and (= (count s) 1) (not= f :e)) f)))\n        columns (apply map vector board)\n        diags [(map get board [0 1 2]) (map get board [2 1 0])]]\n    (some identity (map line-winner (concat board columns diags)))))","user":"5617a540e4b06b1bb2182a12"},{"code":"(fn tic-tac [bd]\n  (let [pos (fn [x y] (-> bd (nth x) (nth y)))\n        won? (fn [x]\n               (or\n                 (or (= x (pos 0 0) (pos 0 1) (pos 0 2)) (= x (pos 1 0) (pos 1 1) (pos 1 2)) (= x (pos 2 0) (pos 2 1) (pos 2 2)))\n                 (or (= x (pos 0 0) (pos 1 0) (pos 2 0)) (= x (pos 0 1) (pos 1 1) (pos 2 1)) (= x (pos 0 2) (pos 1 2) (pos 2 2)))\n                 (or (= x (pos 0 0) (pos 1 1) (pos 2 2)) (= x (pos 0 2) (pos 1 1) (pos 2 0)))))]\n    (cond\n      (won? :x) :x\n      (won? :o) :o\n      :else nil)))","problem":73,"user":"52084f75e4b01ce6bbf31dde"},{"problem":73,"code":"(fn tic-tac-toe\n  [[r1 r2 r3 :as board]]\n  (let [row-solution (filter #(apply = %) board)\n        col-solution (filter #(apply = %) (apply map vector board))]\n    (cond (not-empty row-solution) (let [result (first (first row-solution))]\n                                     (if (= result :e) nil result))\n          (not-empty col-solution) (let [result (first (first col-solution))]\n                                     (if (= result :e) nil result))\n          (= (first r1) (second r2) (last r3)) (if (= (first r1) :e) nil (first r1))\n          (= (first r3) (second r2) (last r1)) (if (= (first r3) :e) nil (first r3))\n          :else nil)))","user":"536e5055e4b0fc7073fd6e6b"},{"problem":73,"code":"(fn [board]\n    (->>\n     (concat\n      (set (for [i (range 0 3)] (set (nth board i)))); horizontal\n      (for [i (range 0 3)]; vertical\n        (set (for [j (range 0 3)] (nth (nth board j) i))))\n      (vector (set  (for [i (range 0 3)] (nth (nth board i) i)))); diagonal\n      (vector (set (for [i (range 0 3)] (nth (nth board (- 2 i)) i)))); diagonal\n      )\n     (filter #(= 1 (count %)))\n     (filter (partial not= #{:e}))\n     (first)\n     (first)))","user":"56f9392ae4b07572ad1a88ac"},{"code":"(fn [[r1 r2 r3 :as board]]\n  (let [c1 (map first board)\n        c2 (map second board)\n        c3 (map last board)\n        d1 [(first r1) (second r2) (last r3)]\n        d2 [(last r1) (second r2)  (first r3)]\n        all? (fn [v coll] (= (filter #(= % v) coll) coll))\n        lines [r1 r2 r3 c1 c2 c3 d1 d2]\n        xs (filter identity (map #(all? :x %) lines))\n        os (filter identity (map #(all? :o %) lines))]\n       (if (not (empty? xs)) :x (if (not (empty? os)) :o nil))))","problem":73,"user":"4f13047d535d64f60314642c"},{"problem":73,"code":"(fn[a](\n        (fn[m]\n        (cond\n          (nil? m) nil\n          (= m '(:e)) nil\n          :else (first m))\n        )\n        \n        (first\n        (filter (fn[i](= (count i) 1))\n        (map distinct\n        (map\n        (fn[t]( map (fn[c](nth (nth a (last c)) (first c))) t ))\n        [ \n         [[0 0][1 0][2 0]] \n         [[0 0][1 1][2 2]] \n         [[0 0][0 1][0 2]]\n         [[1 0][1 1][1 2]]\n         [[2 0][1 1][0 2]]\n         [[2 0][2 1][2 2]]\n         [[0 1][1 1][2 1]]\n         [[0 2][1 2][2 2]]\n        ]\n        )\n        )\n        )\n        )\n))","user":"56039843e4b04bb52996e1be"},{"problem":73,"code":"(fn [board]\n  (let [goals [[0 1 2] [3 4 5] [6 7 8]\n               [0 3 6] [1 4 7] [2 5 8]\n               [0 4 8] [2 4 6]]]\n    (letfn [(wins? [user]\n              (let [occupied (->> (apply concat board)\n                                  (map (fn [i u] (if (= u user) i)) (range))\n                                  set)]\n                (some (fn [cells] (every? #(occupied %) cells)) goals)))]\n      (cond (wins? :x) :x (wins? :o) :o :else nil))))","user":"5712854ce4b07c98581c3a89"},{"problem":73,"code":"(fn my-fn                                                                         \n  [[[el-11 el-12 el-13] [el-21 el-22 el-23] [el-31 el-32 el-33] :as all]]           \n  (let [winner? (fn [key]                                                           \n                  (or                                                               \n                    (= key el-11 el-12 el-13)                                       \n                    (= key el-21 el-22 el-23)                                       \n                    (= key el-31 el-32 el-33)                                       \n                    (= key el-11 el-21 el-31)                                       \n                    (= key el-12 el-22 el-32)                                       \n                    (= key el-13 el-23 el-33)                                       \n                    (= key el-11 el-22 el-33)                                       \n                    (= key el-13 el-22 el-31)))]                                    \n    (cond                                                                           \n      (winner? :o) :o                                                               \n      (winner? :x) :x                                                               \n      :else nil)))","user":"58ebd10de4b056aecfd47d49"},{"problem":73,"code":"(fn [r] (let [c (group-by identity (concat r \n                                           (for [i [0 1 2]] (map #( % i) r)) \n                                           [[((r 0) 0) ((r 1) 1) ((r 2) 2)]] \n                                           [[((r 0) 2) ((r 1) 1) ((r 2) 0)]]))] \n          (ffirst (c [:x :x :x] (c [:o :o :o])))))","user":"53b2a7f8e4b047364c04449c"},{"problem":73,"code":"(fn [a] (let [a2 [(first a) (second a) (last a)\n                  [(first (first a)) (first (second a)) (first (last a))]\n                  [(second (first a)) (second (second a)) (second (last a))]\n                  [(last (first a)) (last (second a)) (last (last a))]\n                  [(first (first a)) (second (second a)) (last (last a))]\n                  [(last (first a)) (second (second a)) (first (last a))]]\n              r  (concat \n                  (filter (fn [row] (every? #(= :x %) row)) a2)\n                  (filter (fn [row] (every? #(= :o %) row)) a2))]\n          (first (first r))))","user":"586615e6e4b0f14aab7c8858"},{"problem":73,"code":"(fn tic-tac [r]\n  (letfn [(tic-tac-rows [player r]\n                        (some #(apply = player %) r))\n          (transform-board [r]\n                           (apply map vector r))\n          (diags [r]\n                 (vector\n                   (map-indexed #(nth %2 %) r)\n                   (map-indexed #(nth %2 (- (dec (count r)) %)) r)))\n          (all-combinations [r] \n                            (concat r (transform-board r) (diags r)))\n          (tic-tac-player [player r]\n                   (tic-tac-rows player (all-combinations r)))]\n    (cond\n      (tic-tac-player :x r) :x\n      (tic-tac-player :o r) :o)))","user":"53286f84e4b09d4e7a9b5505"},{"problem":73,"code":"(fn check-for-win\n  [b]\n  (let [full-paths (map \n                     (fn [[[x y] [dx dy]]]\n                       #{[x y] [(+ x dx) (+ y dy)] [(+ x (* 2 dx)) (+ y (* 2 dy))]})\n                     [[[0 0] [0 1]]\n                      [[1 0] [0 1]]\n                      [[2 0] [0 1]]\n                      [[0 0] [1 0]]\n                      [[0 1] [1 0]]\n                      [[0 2] [1 0]]\n                      [[0 0] [1 1]]\n                      [[2 0] [-1 1]]])]\n    (some (fn [p]\n            (let [[x & _ :as plays] (keys (group-by #(get-in b %) p))]\n              (if (and (= 1 (count plays)) (not= x :e)) x nil))) \n          full-paths)))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":73,"code":"(fn f [coll]\n  (let [row1  (coll 0)\n        row2  (coll 1)\n        row3  (coll 2)\n        col1  (map #(% 0) coll)\n        col2  (map #(% 1) coll)\n        col3  (map #(% 2) coll)\n        dia1  [(get-in coll [0 0]) (get-in coll [1 1]) (get-in coll [2 2])]\n        dia2  [(get-in coll [0 2]) (get-in coll [1 1]) (get-in coll [2 0])]\n        all   [row1 row2 row3 col1 col2 col3 dia1 dia2]\n        check (fn [e] (some #(apply = (conj % e)) all))]\n    (cond (check :x) :x\n          (check :o) :o\n          :else       nil)))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":73,"code":"(fn [board]\n(let [winner\n  [\n   ;; horizontal\n   [ [0 0 ] [0 1] [0 2]] \n   [ [1 0 ] [1 1] [1 2]]\n   [ [2 0 ] [2 1] [2 2]]\n   ;; vertical\n   [ [0 0 ] [1 0] [2 0]]\n   [ [0 1 ] [1 1] [2 1]]\n   [ [0 2 ] [1 2] [2 2]]\n   ;; diagonal\n   [ [0 0 ] [1 1] [2 2]]\n   [ [0 2 ] [1 1] [2 0]]]\n      \nis-winner (fn [ coll ]\n  (reduce #(if (= %1 %2)\n             %2\n             nil)\n          coll) )\n\nfind-winner  \n(fn  [form] \n  ( map #( get-in board %) form)\n  )\n]\n\n  (first\n(filter #(or (= :x %) (= :o %))\n        (map is-winner \n             (map find-winner winner)))))\n)","user":"5364ab34e4b0243289761e64"},{"problem":73,"code":"(fn tic-tac [brd]\n  (let [brd-vals\n        (fn [crit]\n          (reduce #(conj % (get-in brd %2 )) [] crit))\n        check-match (fn [n] (if (= :e (first n)) nil\n                                (if (true? \n                                     (every? #(= % (first n)) n))\n                                  (first n)\n                                  nil)))\n         win-criteria [[[0 0] [0 1] [0 2]]\n                      [[1 0] [1 1] [1 2]]\n                      [[2 0] [2 1] [2 2]]\n                      [[0 0] [1 1] [2 2]]\n                      [[0 2] [1 1] [2 0]]\n                      [[0 0] [1 0] [2 0]]\n                      [[0 1] [1 1] [2 1]]\n                      [[0 2] [1 2] [2 2]]]]\n    (some #(when (not (nil? %))%)\n          (vec (for [crit win-criteria\n                     :let [matches \n                           (check-match (brd-vals crit))]]\n                 matches)))))","user":"5785c1d4e4b0ebec4cfb74e1"},{"code":"(fn [a] (let [d reduce\n              f (fn [b](d #(if (= %1 %2) %1) b))\n              r first\n              e second \n              l last\n              m map] \n          (some #{:x :o}\n                  (m f [(r a) (e a) (l a) (m r a) (m e a) (m l a)\n                         [(r(r a))(e(e a))(l(l a))]                         \n                         [(l(r a)) (e(e a))(r(l a))]]))))","problem":73,"user":"5251d3c1e4b0541d1855b87f"},{"problem":73,"code":"(fn [tic]\n    (let [rows tic\n          cols (partition 3 (apply interleave tic))\n          diag1 (take-nth 4 (apply concat tic))\n          diag2 (take-nth 4 (apply concat (reverse tic)))\n          all (concat rows cols (list diag1 diag2))]\n      (println diag1 diag2)\n      (some #(when (and (apply = %) (not= (first %) :e)) (first %))  all)\n      )\n    )","user":"512b07f7e4b078b06821febb"},{"problem":73,"code":"(fn [board]\n  (let [run-test-func (fn [func] (or (func 0) (func 1) (func 2)))\n        is-winning-row (fn [sym] (fn [row] (every? #(= sym %) (nth board row))))\n        is-winning-col (fn [sym] (fn [col] (every? #(= sym %) (concat (map #(nth % col) board)))))\n        main-diagonal [(first (first board)) (second (second board)) (last (last board))]\n        anti-diagonal [(first (last board)) (second (second board)) (last (first board))]\n        is-winning-diag (fn [sym] (some #(every? (fn [x] (= sym x)) %) [main-diagonal anti-diagonal]))\n        test-win (fn [sym] (or (run-test-func (is-winning-row sym))\n                               (run-test-func (is-winning-col sym))\n                               (is-winning-diag sym)))]\n    (cond\n     (test-win :x) :x\n     (test-win :o) :o\n     :else nil)))","user":"59a96a85e4b0bcf4e9a43b13"},{"code":"(fn [b]\n  (let [\n    goals (concat\n      b\n      (apply map vector b)\n      [[(ffirst b) (second (second b)) (last (last b))]\n      [(last (first b)) (second (second b)) (first (last b))]])\n    win (fn [p] (some (partial every? (partial = p)) goals))]\n  (cond (win :x) :x (win :o) :o)))","problem":73,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":73,"code":"(fn [board]\n    (let [[[a b c]\n           [d e f]\n           [g h i]] board]\n      (let [winners (map first (filter (fn [[x y z]] (= x y z)) [[a b c] [d e f] [g h i]\n                                                                 [a d g] [b e h] [c f i]\n                                                                 [a e i] [c e g]]))]\n        (first (filter #(or (= % :x) (= % :o)) winners)))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":73,"code":"(fn\n  [ttt]\n  (let [row1 (first ttt)\n        row2 (second ttt)\n        row3 (last ttt)\n        column1 (map first ttt)\n        column2 (map second ttt)\n        column3 (map last ttt)\n        diagonal1 (map-indexed #(nth %2 %1) ttt)\n        diagonal2 (map-indexed #(nth (reverse %2) %1) ttt)\n        all [row1 row2 row3 column1 column2 column3 diagonal1 diagonal2]\n        all-dist (map distinct all)\n        winner (filter #(and (= 1 (count %)) (not= :e (first %))) all-dist)]\n    (if (empty? winner)\n      nil\n      (first (first winner)))))","user":"58a1d00ae4b02bd94d917ec6"},{"problem":73,"code":"(fn [board]\n  (letfn [(lines [rows]\n            (concat rows\n                    (for [col [0 1 2]]\n                      (map #(get % col) rows))\n                    [(for [[x y] [[0 0] [1 1] [2 2]]]\n                       (get (get rows y) x))]\n                    [(for [[x y] [[0 2] [1 1] [2 0]]]\n                       (get (get rows y) x))]))]\n    (->> (lines board)\n         (map #(into #{} %))\n         (remove #(= #{:e} %))\n         (filter #(= 1 (count %)))\n         (ffirst))))","user":"59eb63e3e4b0249b7282077c"},{"problem":73,"code":"(fn [board]\n  (let [columnsAndRows \n         (mapcat (fn [i] [(nth board i)(into [] (map #(nth % i) board))]) (range 3))\n        diagonals \n          [[(first (first board))(second (second board))(last (last board))]\n           [(last (first board))(second (second board))(first (last board))]]\n        all (concat columnsAndRows diagonals)\n        onlyOOrXFilter #(and (not= (first %) :e) (= (first %) (second %) (last %)))]\n     (first (first (filter onlyOOrXFilter all)))))","user":"5dd90e4fe4b0948ae9d9ad99"},{"code":"(fn[t]\n  (let [r [0 1 2]\n        l (concat \n             t\n             (map (fn[i](map #(get % i) t)) r) \n             [(map get t r) \n              (map get t [2 1 0])])]\n     (cond \n       (some (fn [s] (every? #(= :x %) s)) l) :x\n       (some (fn [s] (every? #(= :o %) s)) l) :o\n       :else nil)))\n\n;comment","problem":73,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn [x] (let [rs x,\n         cs (apply (partial map list) rs),\n\t       l (count rs),\n\t       d1 (map #((rs %) %) (range l)),\n\t       d2 (map #((rs %) (dec (- l%))) (range l)),\n\t       all (conj (concat rs cs) d1 d2)]\n\t(first (some #{(repeat l :o) (repeat l :x)} all))))","problem":73,"user":"50563ae2e4b0ce54f56f0405"},{"problem":73,"code":"(fn ttt [board]\n    (letfn [(row [y] (board y))\n            (col [x] (map #(% x) board))\n            (diag1 [&] (map-indexed #(%2 %1) board))\n            (diag2 [&] (map-indexed #(%2 (- 2 %1)) board))\n            (all-lines [&] [(row 0) (row 1) (row 2)\n                            (col 0) (col 1) (col 2)\n                            (diag1) (diag2)])\n            (won? [symbol] (some #(= (repeat 3 symbol) %) (all-lines)))]\n      (cond\n        (won? :x) :x\n        (won? :o) :o\n        :else nil)))","user":"5429986ce4b01498b1a71b3b"},{"code":"(fn winner [_b]\n  (let [b (conj _b \n    (map first _b) \n    (map second _b) \n    (map last _b) \n    (list (ffirst _b) (second (second _b)) (last (last _b)))\n    (list (first (last _b)) (second (second _b)) (last (first _b))))\n   ]\n    (loop [cands '(:o :x)]\n      (when (seq cands)\n          (if (= nil (loop [rows b]\n            (when (seq rows)\n\t\t\t         (if (apply = (conj (first rows) (first cands)))\n\t\t\t\t            (first cands)\n                \t\t(recur (rest rows))))))\n          (recur (rest cands)) (first cands))))))","problem":73,"user":"507bb3ece4b09034bfeeb720"},{"problem":73,"code":"(fn [field]\n    (let [horizontal field\n          vertical (apply map vector field)\n          diagonal (map (partial map (partial get-in field))\n                         [[[0 0] [1 1] [2 2]]\n                          [[0 2] [1 1] [2 0]]])\n          lines (concat horizontal vertical diagonal)]\n      (some (fn [line] (if (or (every? (partial = :x) line)\n                               (every? (partial = :o) line))\n                         (first line)))\n            lines)))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":73,"code":"(fn [coll]\n  (let [combos [[0 1 2] [3 4 5] [6 7 8]\n                [0 3 6] [1 4 7] [2 5 8]\n                [0 4 8] [2 4 6]]\n        coll (vec (flatten coll))]\n    (->> (map #(map coll %) combos)\n         (filter #(and (apply = %) (not= (first %) :e)))\n         (flatten)\n         (first))))","user":"51441ce7e4b0b4fb4ace5f41"},{"code":"(fn [rows] \n  (let [winning (fn [r] (if (and (apply = r) (not= (first r) :e)) (first r) nil))\n        cols (apply map list rows)\n        diag (partial map-indexed #(nth %2 %1))] \n    (some winning (concat rows cols [(diag rows) (diag (reverse rows))]))))","problem":73,"user":"531f7a2de4b08068f379edc6"},{"code":"(fn ttt [board]\n  (letfn [(transpose [m]\n\t\t\t\t(apply map vector m))\n\t\t\t(diagonal [m]\n\t\t\t\t(map #(nth (nth m %) %)\n\t\t\t\t\t(take (count m) (iterate inc 0))))\n\t\t\t(o3-or-x3 [rows]\n\t\t\t\t(first (filter #(and\n\t\t\t\t\t\t\t(not (= [:e :e :e] %))\n\t\t\t\t\t\t\t(= (count (set %)) 1))\n\t\t\t\t\t\trows)))]\n\t\t(let [allcomb (into board (transpose board)) ; all rows all columbs\n\t\t\t  allcomb (conj allcomb (diagonal board)) ; diagonal 1\n\t\t\t  allcomb (conj allcomb (diagonal (reverse board))) ; diagonal 2\n\t\t\t  winner (o3-or-x3 allcomb)]\n\t\t\t(if winner\n\t\t\t\t(first winner)\n\t\t\t\tnil))))","problem":73,"user":"4eddcbbf535d10e5ff6f532d"},{"code":"(fn [board]\n   (let [[r1 r2 r3] board\n         lines (vector r1 r2 r3 ; rows\n                       (for [r board] (first r)) ; cols\n                       (for [r board] (second r))\n                       (for [r board] (last r))\n                       [(get r1 0) (get r2 1) (get r3 2)] ; diagonals\n                       [(get r1 2) (get r2 1) (get r3 0)])]\n        (first (some #(when (and (apply = %)\n                                 (not (apply = :e %))) %) lines))))","problem":73,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [x]\n  (let [[one two three] x\n        [four five six] (map vector one two three)\n        seven (vector (first one) (second two) (last three))\n        eight (vector (last one) (second two) (first three))]\n    (some {[:x :x :x] :x [:o :o :o] :o}\n     [one two three four five six seven eight])\n))","problem":73,"user":"4e9dafe1535dbda64a6f6b89"},{"problem":73,"code":"(fn [coll] \n  (let [len (count coll)\n        colums (repeatedly len #(atom []))\n\t\tslash (atom [])\n\t\tc-slash (atom [])]\n  \t(let [r1 (loop [rows coll i 0]\n\t\t\t\t(let [row (first rows)]\n\t\t\t\t\t(when (seq row)\n\t\t\t\t\t\t(if (every? #{:x} row)\n\t\t\t\t\t\t\t:x\n\t\t\t\t\t\t\t(if (every? #{:o} row)\n\t\t\t\t\t\t\t\t:o\n\t\t\t\t\t\t\t\t(do\n\t\t\t\t\t\t\t\t\t(loop [j 0]\n\t\t\t\t\t\t\t\t\t\t(when (< j len)\n\t\t\t\t\t\t\t\t\t\t\t(swap! (nth colums j) conj (nth row j))\n\t\t\t\t\t\t\t\t\t\t\t(if (= i j)\n\t\t\t\t\t\t\t\t\t\t\t\t(swap! slash conj (nth row j)))\n\t\t\t\t\t\t\t\t\t\t\t(if (= (+ i j) (- len 1))\n\t\t\t\t\t\t\t\t\t\t\t\t(swap! c-slash conj (nth row j)))\n\t\t\t\t\t\t\t\t\t\t\t(recur (inc j))))\n\t\t\t\t\t\t\t\t\t(recur (rest rows) (inc i))))))))]\n\t\t(if (keyword? r1)\n\t\t\tr1\n\t\t\t(let [r2 (loop [cols colums]\n\t\t\t\t\t\t(if (> (count cols) 1)\n\t\t\t\t\t\t\t(let [col @(first cols)]\n\t\t\t\t\t\t\t\t(if (every? #{:x} col)\n\t\t\t\t\t\t\t\t\t:x\n\t\t\t\t\t\t\t\t\t(if (every? #{:o} col)\n\t\t\t\t\t\t\t\t\t\t:o\n\t\t\t\t\t\t\t\t\t\t(recur (rest cols)))))))]\n\t\t\t\t(if (keyword? r2)\n\t\t\t\t\tr2\n\t\t\t\t\t(let [r3 (if (every? #{:x} @slash)\n\t\t\t\t\t\t\t\t:x\n\t\t\t\t\t\t\t\t(if (every? #{:o} @slash)\n\t\t\t\t\t\t\t\t\t:o\n\t\t\t\t\t\t\t\t\tnil))]\n\t\t\t\t\t\t(if (keyword? r3)\n\t\t\t\t\t\t\tr3\n\t\t\t\t\t\t\t(if (every? #{:x} @c-slash)\n\t\t\t\t\t\t\t\t:x\n\t\t\t\t\t\t\t\t(if (every? #{:o} @c-slash)\n\t\t\t\t\t\t\t\t\t:o\n\t\t\t\t\t\t\t\t\tnil))))))))))","user":"56cad309e4b0ea9b8538f720"},{"problem":73,"code":"(let [\nrotate (fn [n] (map vector (first n) (second n) (last n)))\ndiag (fn [n] [[(first (first n)) (second (second n)) (last (last n))] [(last (first n)) (second (second n)) (first (last n))]])\n      ]\n\n(fn [board] (let [sets (map #(into #{} %) (concat board (rotate board) (diag board))) winners (into #{} (map #(if (> (count %) 1) nil (first %)) sets))] (first (remove #(or (nil? %) (= :e %)) winners)) ))\n  )\n\n;;( (let [\n;;rotate (fn [n] (map vector (first n) (second n) (last n)))\n;;diag (fn [n] [[(first (first n)) (second (second n)) (last (last n))] [(last (first n)) (second (second n)) (first (last n))]])\n;;      ]\n\n;;(fn [board] (let [sets (map #(into #{} %) (concat board (rotate board) (diag board))) winners (into #{} (map #(if (> (count %) 1) nil (first %)) sets))] (first (remove #(or (nil? %) (= :e %)) winners)) ))\n ;; ) [[:x :e :e]\n  ;;         [:o :x :e]\n   ;;        [:o :e :x]])","user":"5b5874cfe4b02d533a91bd6a"},{"problem":73,"code":"(fn analyze-a-tic-tac-toe-board-solution\n  [board]\n  (let [board board\n        row0 (board 0)\n        row1 (board 1)\n        row2 (board 2)]\n  ;(letfn [(player [player row]\n  ;          (= player row))]\n\n  (letfn [(diag [player]\n            (if (or (every? #(= player %) [(row0 0) (row1 1) (row2 2)])\n                    (every? #(= player %) [(row0 2) (row1 1) (row2 0)])) true false))]\n  (letfn [(hor [player]\n            (if (or (every? #(= player %) row0)\n                    (every? #(= player %) row1)\n                    (every? #(= player %) row2)) true false))]\n\n  (letfn [(ver [player]\n            (if (or (every? #(= player %) [(row0 0)(row1 0)(row2 0)])\n                    (every? #(= player %) [(row0 1)(row1 1)(row2 1)])\n                    (every? #(= player %) [(row0 2)(row1 2)(row2 2)]))true false))]\n  (cond\n    (hor :x) :x\n    (hor :o) :o\n    (ver :x) :x\n    (ver :o):o\n    (diag :x) :x\n    (diag :o) :o\n    :else nil))))))","user":"583d669ee4b089d5ab817d9a"},{"problem":73,"code":"#( let [\n\tsize (count %)\n\tline (fn [x] (set (get % x)))\n\tcolumn (fn [x] (set (map (fn [l] (get l x)) %)))\n\tdiagonal1 (set (map (fn [i] (get (get % i) i)) (range size)))\n\tdiagonal2 (set (map (fn [i] (get (get % i) (- (dec size) i))) (range size)))\n\tff (fn [x] (and (= 1 (count x)) (not= (first x) :e)))\n\t]\n\t(first (map first (filter ff (concat (map line (range size)) (map column (range size)) [diagonal1 diagonal2]))))\n\t)","user":"52570aeae4b0541d1855ba42"},{"code":"(fn [y] \n\t(let [x (if (or (= (first(first y))  (first(second y))  (first(last y))  :x )\n\t\t\t\t    (= (second(first y)) (second(second y)) (second(last y)) :x )\n\t\t\t\t    (= (last(first y))   (last(second y))   (last(last y))   :x )\n\t\t\t\t\t(= (first(first y))  (second(first y))  (last(first y))  :x )\n\t\t\t\t    (= (first(second y)) (second(second y)) (last(second y)) :x )\n\t\t\t\t    (= (first(last y))   (second(last y))   (last(last y))   :x )\n\t\t\t\t\t(= (first(first y))  (second(second y)) (last(last y))   :x )\n\t\t\t\t\t(= (first(last y))   (second(second y)) (last(first y))  :x ))\n\t\t\ttrue false)  \n\t\t  o (if (or (= (first(first y))  (first(second y))  (first(last y))  :o )\n\t\t\t\t    (= (second(first y)) (second(second y)) (second(last y)) :o )\n\t\t\t\t    (= (last(first y))   (last(second y))   (last(last y))   :o )\n\t\t\t\t\t(= (first(first y))  (second(first y))  (last(first y))  :o )\n\t\t\t\t    (= (first(second y)) (second(second y)) (last(second y)) :o )\n\t\t\t\t    (= (first(last y))   (second(last y))   (last(last y))   :o ) \n\t\t\t\t\t(= (first(first y))  (second(second y)) (last(last y))   :o )\n\t\t\t\t\t(= (first(last y))   (second(second y)) (last(first y))  :o ))\n\t\t\ttrue false)  \n\t]\n\t(if x :x (if o :o nil))  ))","problem":73,"user":"5296008fe4b02ebb4ef7502a"},{"code":"(fn [matr]\n  (let [; rows\n        [r1 r2 r3] matr\n\n        ; cols\n        col (fn [i] (map #(% i) matr))\n        [c1 c2 c3] (map col [0 1 2])\n        \n        ; diags\n        [d1, d2] (map (partial map #(%1 %2) matr)\n                      [[0 1 2] [2 1 0]])\n\n        solid? #(apply (partial = (first %)) %)\n        winner (ffirst (filter solid?\n                               [c1 c2 c3 r1 r2 r3 d1 d2]))]\n    (if (= winner :e) nil winner)))","problem":73,"user":"515ead6be4b049add99a053e"},{"problem":73,"code":"(fn [field]\n  (let [verticals (apply map vector field)\n        tl-diagonal (map-indexed (fn [i v] (nth v i)) field)\n\t\tbl-diagonal (map-indexed (fn [i v] (nth v (- 2 i))) field)\n        lanes (set (concat field verticals [tl-diagonal bl-diagonal]))]\n    (cond\n     (contains? lanes [:x :x :x]) :x\n     (contains? lanes [:o :o :o]) :o\n     :else nil)))","user":"53abe2a7e4b047364c044453"},{"problem":73,"code":"(fn [b]\n   (let [rows [[[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]]\n         cols [[[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]]\n         dias [[[0 0] [1 1] [2 2]]\n               [[2 0] [1 1] [0 2]]]\n         all (concat rows cols dias)\n         val-fn (fn [grouping] (map #(get-in b %) grouping))]\n     (reduce (fn [found? [v0 v1 v2]]\n               (if (and (not found?) (not= v0 :e) (= v0 v1 v2))\n                 v0\n                 found?))\n             nil\n             (map val-fn all))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [b] (\n\tlet [winner (fn [r] (some identity (map #(if (= (distinct r) [%1]) %1) [:x :o])))]\n\t(some identity\n\t\t(concat\n\t\t\t(map winner b)\n\t\t\t(apply map #(winner %&) b)\n\t\t\t[(winner (map #(get %2 %1) [0 1 2] b))]\n\t\t\t[(winner (map #(get %2 %1) [2 1 0] b))]\n\t\t))\n))","problem":73,"user":"52cdb7efe4b07d0d72b2737c"},{"code":"(fn [b]\n  (let [win (fn [m] (seq (filter #(and (apply = %) (not= :e (first %))) m)))\n        transpose (fn [b] (apply map vector b))\n        diagonals (fn [mm]\n                    (loop [ld [], rd [], i 0, n (count mm), m mm]\n                      (if (= i n)\n                        [ld rd]\n                        (let [r (first m)]\n                          (recur\n                            (conj ld (get r i))\n                            (conj rd (get r (- n i 1)))\n                            (inc i)\n                            n\n                            (rest m))))))\n        res (or (win b) (win (transpose b)) (win (diagonals b)))]\n    (if res\n      (first (first res))\n      nil)))","problem":73,"user":"4e89ddf9535d3e98b8023284"},{"problem":73,"code":"(fn analyze-tic-tac-toe\n  [board]\n  (let [colls (apply map list board)\n        diagonal-l (list (map nth board [0 1 2]))\n        diagonal-r (list (map nth board [2 1 0]))\n        all (set (map set (concat board colls diagonal-l diagonal-r)))]\n    (cond\n      (all #{:x}) :x\n      (all #{:o}) :o)))","user":"557e9d17e4b05c286339e0d8"},{"problem":73,"code":"(fn [acs]\n  (let [dns (apply map vector acs)\n        [[a _ d]\n         [_ b _]\n         [e _ c]] acs\n\n        diags (list [a b c] [d b e])]\n    (->> (concat acs dns diags)\n         (map distinct)\n         (filter #(and (= (count %) 1)(not= :e (first %))))\n         ffirst)))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn ttt [col]\n  (let [cell-vaule (fn [m n] (nth (nth col n) m))\n        h-line (for [x (range 3) ]  [[x 0] [x 1] [x 2]])\n        v-line (for [y (range 3) ]  [[0 y] [1 y] [2 y]])\n        d-line [  [[0 0] [1 1] [ 2 2] ]    [[2 0] [1 1] [0 2]]  ]\n        all-lines (concat h-line  v-line d-line)\n        check-line (fn [theline]\n          (let [line-values (map (fn [[x y]] (cell-vaule x y ))  theline ) ]\n          (cond (every? #(= :o %) line-values) :o\n                (every? #(= :x %) line-values) :x\n                :else nil\n            )))\n        ]\n       (first (filter identity (map check-line all-lines)))\n\n    )\n\n\n  )","problem":73,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":73,"code":"(fn [board]\n  (let [diags (fn [board]\n  \t\t\t\t(vector (map-indexed #(nth %2 %) board)\n          \t\t\t    (map-indexed #(nth %2 (- 2 %)) board)))\n        vecs (fn [board]\n  \t\t\t\t(concat (map #(into '() %) board)\n          \t\t\t\t(vector (map first board))\n          \t\t\t\t(vector (map second board))\n          \t\t\t\t(vector (map #(nth % 2) board))\n          \t\t\t\t(diags board)))\n        triplets (vecs board)\n        x? (> (.indexOf triplets '(:x :x :x)) -1)\n        o? (> (.indexOf triplets '(:o :o :o)) -1)]\n    (cond\n     x? :x\n     o? :o\n     :else nil)))","user":"53e76bb2e4b036ad0777e47d"},{"problem":73,"code":";(\n(fn [rs]\n  (let [cs (->> rs\n                (apply interleave)\n                (partition 3))\n        ds (map (partial map nth rs)\n                [[0 1 2] [2 1 0]])\n        lines (concat rs cs ds)\n        win (fn [player]\n              (some #(every? (partial = player) %)\n                    lines))]\n    (cond (win :x) :x\n          (win :o) :o\n           )))\n;[[:x :o :o] [4 :x 6] [7 8 :x]])","user":"57df2722e4b0bd073c20245e"},{"problem":73,"code":"(fn [board]\n    (letfn [(get-points [sym m]\n              (filter identity\n                      (for [x (range (count m))\n                            y (range (count (m 0)))]\n                        (when (= ((m x) y) sym)\n                          [x y]))))\n            (line? [[x1 y1] [x2 y2]]\n              (or (= x1 x2)\n                  (= y1 y2)\n                  (= (Math/abs (- x1 x2)) (Math/abs (- y1 y2)))))\n            (slope [[x1 y1] [x2 y2]]\n              (let [dx (- x2 x1)\n                    dy (- y2 y1)]\n                [x2 y2 (cond\n                         (and (= dx 0) (= dy 0)) ::NaN\n                         (= dx 0) ::Inf\n                         :else (/ dy dx))]))\n            (winner? [sym]\n              (let [points (get-points sym board)\n                    clumps (map (fn [point]\n                                  (->> points\n                                       (filter #(line? point %))\n                                       (map #(slope point %))))\n                                points)\n                    lines (map (fn [clump]\n                                 (map (fn [p]\n                                        (map #(line? % p) clump))\n                                      clump))\n                               clumps)]\n                (some #(and (> (count %) 2)\n                            (apply = (->> % (map last) (filter (partial not= ::NaN)))))\n                      clumps)))]\n      (cond\n        (winner? :x) :x\n        (winner? :o) :o)))","user":"4f57c913e4b0a7574ea7183f"},{"code":"(fn [board]\n  (let [[[a b c] [d e f] [g h i]] board\n        res (fn [x] (if (= x :e) nil x))]\n    (cond\n      (= a b c) (res a)\n      (= d e f) (res d)\n      (= g h i) (res g)\n      (= a d g) (res a)\n      (= b e h) (res b)\n      (= c f i) (res c)\n      (= a e i) (res a)\n      (= c e g) (res c)\n      :else nil)))","problem":73,"user":"4f1c2a3a535d64f603146480"},{"code":"(fn tic-tac-toe [lst]\r\n  (letfn [(hor [sym lst]\r\n         (some #(= true %)\r\n\t\t     (map #(every? (fn [n] (= sym n)) %)\r\n\t\t\t  lst)))\r\n\t  (vert-hor [lst]   (map (fn [n] (map #(nth % n) lst)) [0 1 2]))\r\n\t  (vert [sym lst] (hor sym (vert-hor lst)))\r\n\t  (slanting [lst]\r\n\t\t    (loop [ls lst num [0 1 2] xs []]\r\n\t\t      (if (= nil (first ls))\r\n\t\t\txs\r\n\t\t\t(recur (rest ls) (rest num) (conj xs (nth (first ls) (first num)))))))\r\n\t  ]\r\n    (cond (= true (vert :x lst)) :x\r\n\t  (= true (vert :o lst)) :o\r\n\t  (= true (hor :x lst)) :x\r\n\t  (= true (hor :o lst)) :o\r\n\t  (= true (every? #(= :x %) (slanting lst))) :x\r\n\t  (= true (every? #(= :o %) (slanting lst))) :o\r\n\t  (= true (every? #(= :x %) (slanting (reverse lst)))) :x\r\n\t  (= true (every? #(= :o %) (slanting (reverse lst)))) :o\r\n\t  )))","problem":73,"user":"4ddc620d535d02782fcbea06"},{"problem":73,"code":"(fn [[ r1 r2 r3 :as brd ]]\n    (let [vld #{:x :o}\n          inverted (reduce (fn [b r] (map #(conj %1 %2) b r)) [[][][]] brd)\n          chk-row (fn chk-r\n                    ([l] (chk-r l brd))\n                    ([l b] (some #(apply = (conj % l)) b)))\n          chk-col #(chk-row % inverted)\n          chk-dia (fn [l]\n                    (or\n                      (= l\n                         (first r1)\n                         (first (rest r2))\n                         (last  r3))\n                      (= l\n                         (first r3)\n                         (first (rest r2))\n                         (last  r1))))\n          winner (filter #(or (chk-row %) (chk-col %) (chk-dia %)) #{:x :o})\n          ]\n      (if (empty? winner)\n        nil\n        (first winner))\n      )\n    )","user":"559a9a3de4b066d22e731f45"},{"problem":73,"code":"(fn [board]\n  (first\n    (for [\n      row\n          (map\n            (fn [x] (map #(get-in board [(quot % 3) (mod % 3)]) x))\n                [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]])\n      :when (and (apply = row) (not= (first row) :e))]\n        (first row))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":73,"code":"(fn [x]\n  (let [hori (map #(set %) x)\n        vert (map #(set %) (apply map list x))\n        cro1 (set (map #(get-in x %) [[0 0] [1 1] [2 2]]))\n        cro2 (set (map #(get-in x %) [[0 2] [1 1] [2 0]]))\n        sets (conj (concat hori vert) cro1 cro2)]\n    (first (some #{#{:x} #{:o}} sets))))","user":"569d095fe4b0542e1f8d1470"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [size (range 3)\n        ;; Create horizontal and vertical lines\n        lines (mapcat #(list\n                         (map vector (repeat %) size)\n                         (map vector size (repeat %)))\n                      size)\n        ;; Create both diagonal lines\n        lines (conj lines\n                    (map vector size size)\n                    (map vector (range 2 -1 -1) size))]\n    (->> lines\n         (map\n           (partial map (fn [[y x]]\n                          (-> board\n                              (nth y)\n                              (nth x)))))\n         (filter #(not-any? (partial = :e) %))\n         (filter #(->> % distinct count (= 1)))\n         ffirst)))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [board]\n(first (filter #(not (= %1 :e))\n(map\n  (fn [row] (reduce #(if (= %2 %1) %1 :e) row))\n  (->\n    board\n    (into (apply mapv vector board))\n    (conj (map #((board %1) %1) [0 1 2]))\n    (conj (map #((board %1) (- 2 %1)) [0 1 2])))))))","problem":73,"user":"50976c84e4b00ad8bab4e961"},{"problem":73,"code":"(fn [board]\n  (let [rows board\n        cols (apply map vector board)\n        get-diag (fn [b] (vector (map-indexed (fn [idx row] (nth row idx)) b)))\n        diag1 (get-diag board)\n        diag2 (get-diag (reverse board))]\n        (first (first (filter #(and (not= :e (first %)) (apply = %)) (concat rows cols diag1 diag2))))))","user":"5604bcf7e4b08b23635d315a"},{"code":"(fn [x]\n  (first (filter\n    (fn [p]\n      (some (fn [l] (every? #(= p (nth (flatten x) %)) l))\n        [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]))\n    [:x :o])))","problem":73,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":73,"code":"(fn [board] \n  (let [ getStone (fn [[x y]] (-> board (nth y nil) (nth x nil) ))\n         \n          win? (fn [[x y]] \n                   (reduce \n                     (fn [result [s1 s2]]\n                       (or result\n                        (contains? #{#{:x} #{:o}}  (set [(getStone s1) (getStone [x y]) (getStone s2)]))))\n                     false\n                     [\n                      [[(dec x) y] [(inc x) y]] \n                      [[x (dec y)] [x (inc y)]] \n                      [[(dec x) (dec y)] [(inc x) (inc y)]] \n                      [[(dec x) (inc y)] [(inc x) (dec y)]] ]))\n          \n          matIter (fn [mat] \n                      (apply concat \n                       (map-indexed (fn [y itm] (map-indexed (fn [x _] [x y]) itm) ) mat))) ]\n   (reduce \n     (fn [result pos]  (if (win? pos) (getStone pos) result)) \n     nil\n     (matIter board))))","user":"567798afe4b05957ce8c6169"},{"problem":73,"code":"#(->> (map (fn [n] (nth (flatten %) n))\n           [0 1 2, 3 4 5, 6 7 8, 0 3 6, 1 4 7, 2 5 8, 0 4 8, 2 4 6])\n      (partition 3)\n      (some {[:x :x :x] :x [:o :o :o] :o}))","user":"576e607ae4b0979f89651579"},{"problem":73,"code":"(fn [a m b]\n  (let [w (set (concat b \n                       (apply m vector b)\n                       [(m a b [0 1 2]) \n                        (m a b [2 1 0])]))]\n    (cond (w [:x :x :x]) :x\n       \t  (w [:o :o :o]) :o))) #(%1 %2) map","user":"55dab408e4b0e31453f64ad9"},{"problem":73,"code":"(fn [bb] (let [funpom\n(fn [board sym] (let [b (map (fn [r] (map #(if (= % sym) 1 0) r)) board)]\n                  (or (some #{3} (map #(reduce + %) b))\n                      (= 3 (reduce + (map first b)))\n                      (= 3 (reduce + (map second b)))\n                      (= 3 (reduce + (map last b)))\n                      (= 3 (+ (first (first b)) (second (second b)) (last (last b))))\n                      (= 3 (+ (last (first b)) (second (second b)) (first (last b))))\n                      ) ))]\n          (if (funpom bb :x) :x (if (funpom bb :o) :o nil))\n          \n          ))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":73,"code":"(let [all-win-coords [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] ; rows\n                      [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] ; columns\n                      [[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]] ; diagonals\n      get-runs (fn [board] (map (fn [win-coords] (map (fn [[r c]] ((board r) c)) win-coords)) all-win-coords))\n      has-winning-run (fn [player board] (some (partial every? #(= player %)) (get-runs board)))]\n      (fn [board]\n          (cond\n            (has-winning-run :x board) :x\n            (has-winning-run :o board) :o)))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":73,"code":"(fn\n  [board]\n  (letfn [(check [row]\n            (if (apply = row)\n              (first (clojure.set/intersection #{:x :o} (set row)))\n              nil))\n          (get-pos [board row col]\n            (nth (nth board row) col))\n          (transpose [board]\n             [[(get-pos board 0 0) (get-pos board 1 0) (get-pos board 2 0)]\n              [(get-pos board 0 1) (get-pos board 1 1) (get-pos board 2 1)]\n              [(get-pos board 0 2) (get-pos board 1 2) (get-pos board 2 2)]])\n          (diagonals [board]\n            [[(get-pos board 0 0) (get-pos board 1 1) (get-pos board 2 2)]\n             [(get-pos board 0 2) (get-pos board 1 1) (get-pos board 2 0)]])\n          (or-fn [coll]\n            (some identity coll))\n          (check-rows [board]\n            (or-fn (map check board)))\n          (check-cols [board]\n            (or-fn (map check (transpose board))))\n          (check-diagonals [board]\n            (or-fn (map check (diagonals board))))]\n\n    (or-fn [(check-rows board) (check-cols board) (check-diagonals board)])))","user":"4daf420cedd6309eace4d176"},{"code":"(fn [board]\n  (let [vecs (conj board \n                     (map first board)\n                     (map second board)\n                     (map last board)\n                   \t [(first (first board)) (second (second board)) (last (last board))]\n                     [(last (first board)) (second (second board)) (first (last board))])]\n    (cond (some #(= [:x :x :x] %) vecs) :x\n          (some #(= [:o :o :o] %) vecs) :o\n          :else nil)))","problem":73,"user":"51780f88e4b03d69594194c9"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [idx-colls [ ; Rows\n                   \t[[0 0] [1 0] [2 0]] \n                    [[0 1] [1 1] [2 1]]\n                    [[0 2] [1 2] [2 2]]\n                    ; Cols\n                    [[0 0] [0 1] [0 2]]\n                    [[1 0] [1 1] [1 2]]\n                    [[2 0] [2 1] [2 2]]\n                    ; Diagonal\n                    [[0 0] [1 1] [2 2]] \n                    [[0 2] [1 1] [2 0]] \n                   ]]\n    (->> idx-colls\n          (map (fn [points]\n                  (->> points\n                    (map (partial get-in board))\n                    distinct)))\n          (filter #(= 1 (count %)))\n          (map first)\n          (filter #{:x :o})\n          first)))","user":"5f431d32e4b0955706451fb5"},{"problem":73,"code":"(fn [board]\n  (let [transposed (apply mapv vector board)\n        row-win? (fn [which row]\n                  (every? #(= which %) row))\n\t\trows-win? (fn [which]\n                   (some #(row-win? which %) board))\n        cols-win? (fn [which]\n                   (some #(row-win? which %) transposed))\n        diagonal [(first (first board)) (second (second board)) (last (last board))]\n        diagonal-win? (fn [which]\n                       (every? #(= which %) diagonal))\n        r-diagonal [(last (first board)) (second (second board)) (first (last board))]\n        r-diagonal-win? (fn [which]\n                          (every? #(= which %) r-diagonal))\n        win? (fn [which]\n               (or \n                (rows-win? which) \n                (cols-win? which)\n                (diagonal-win? which)\n                (r-diagonal-win? which)))]\n    \t\n    (cond\n     (win? :x) :x\n     (win? :o) :o\n     :else nil)))","user":"52860baae4b0239c8a67ae09"},{"problem":73,"code":"(fn q73 [col]\n  (let [all (conj (partition 3 (flatten\n                                 (for [x (range 3)]\n                                   (let [r (nth col x) c (map (fn [row] (nth row x)) col)]\n                                     [c r]\n                                     ))))\n                  [(nth (nth col 0) 0) (nth (nth col 1) 1) (nth (nth col 2) 2)]\n                  [(nth (nth col 2) 0) (nth (nth col 1) 1) (nth (nth col 0) 2)])\n\n        f (fn [col]\n          (let [i (first col)]\n            (when (not= i :e)\n              (when (= col (filter (fn [x] (= x i)) col))\n                i))))]\n\n    (first (keep f all))\n    )\n    )","user":"54f5aa4ce4b0f2f3c5226e94"},{"problem":73,"code":"(fn tic-tac-toe [lst]\n  (let [\n    n (count lst)\n    steps (range n)\n    columns (map (fn [i] (map (fn [x] (x i)) lst)) steps)\n    xstep (map (fn [a b] (a b)) lst steps)\n    rxstep (map (fn [a b] (a b)) lst (reverse steps))\n    all (conj (concat lst columns) xstep rxstep)\n    winttt (fn [a] (if (and (apply = a) (not (= :e (first a)))) (first a) nil))\n    all-results (map winttt all)\n    all-final (filter (comp not nil?) all-results)]\n    (if (empty? all-final) \n      nil\n      (first all-final))))","user":"5374adc3e4b06d7f452d9e27"},{"problem":73,"code":"(fn ttt [[x y z :as horz]]\n  (let [verts (map vector x y z)\n        diags [[(nth x 0)(nth y 1)(nth z 2)]\n               [(nth x 2)(nth y 1)(nth z 0)]]\n        winner? (fn [k] (some true? (map #(every? (partial = k) %) (concat horz verts diags))))]\n    (cond \n      (winner? :x) :x\n      (winner? :o) :o\n      :else nil)))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn  [rows]\n  (let [cols (apply map #(list %1 %2 %3) rows)\n        diag (list ((rows 0) 0) ((rows 1) 1) ((rows 2) 2))\n        diag2 (list ((rows 0) 2) ((rows 1) 1) ((rows 2) 0))           \n        grid (concat cols rows (list diag diag2))]\n    (letfn [(win? [player col]\n              (not (empty? (filter\n                            #(= (list true true true) %)\n                            (map #(map\n                                   (fn [a]\n                                     (= a player)) %) col)))))]\n      (cond\n       (win? :x grid) :x \n       (win? :o grid) :o\n       :else nil))))","problem":73,"user":"4e7e33a3535db169f9c79708"},{"problem":73,"code":"(fn [board]\n  (letfn[\n    (triplets [board]\n      [(board 0)\n       (board 1)\n       (board 2)\n       (map #(first %) board)\n       (map #(second %) board)\n       (map #(last %) board)\n       (map get board [0 1 2])\n       (map get board [2 1 0])])\n    (winner [triplets]\n      (first\n        (filter keyword?\n          (map #(if (every? #{:x} %) :x\n                (when (every? #{:o} %) :o)) triplets))))]\n    (winner (triplets board))))","user":"55d1ec3ee4b0e31453f64a4c"},{"code":"(fn [board] \n  (ffirst \n    (filter \n      #(or (= % [:x :x :x]) (= % [:o :o :o])) \n      (concat \n        board \n        (partition 3 (apply interleave board)) \n        (map \n          #(take-nth 4 (flatten %)) \n          [board (map reverse board)])))))","problem":73,"user":"521e8227e4b0dd19981ad082"},{"code":"(fn tic-tac-analyze [board]\n  (let [hor-comb  board\n        vert-comb (partition 3 (apply interleave board))\n        forw-comb (list (reduce #(conj % (nth %2 (count %))) [] board))\n        back-comb (list (reduce #(conj % (nth %2 (- (count %2) (count %) 1))) []  board))\n        all-combs (concat hor-comb vert-comb forw-comb back-comb)\n        win-comb (some\n                  (fn [s] (if (or (every? #(= :x %) s) (every? #(= :o %) s))\n                           s\n                           nil)) all-combs)]\n    (if-let [h (first win-comb)] h nil)))","problem":73,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn [[[a b c] [d e f] [g h i]]] \n\t(let [winners [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]]] \n\t\t(cond (some #{true} (for [win-triple winners] (every? #{:x} win-triple)))\n                              :x\n              (some #{true} (for [win-triple winners] (every? #{:o} win-triple)))\n                              :o\n         )))","problem":73,"user":"50fca436e4b0d10d794c19fb"},{"code":"(fn [b] (let [r1 (first b) \n              r2 (second b) \n              r3 (last b)\n              c1 (map first [r1 r2 r3])\n              c2 (map second [r1 r2 r3])\n              c3 (map last [r1 r2 r3])\n              d1 [(first r1) (second r2) (last r3)]\n              d2 [(last r1) (second r2) (first r3)]\n              tx (fn [r] (if (every? #(= % :x) r) :x nil))\n              to (fn [r] (if (every? #(= % :o) r) :o nil))\n              fa  [  (tx r1) (tx r2) (tx r3) \n                     (to r1) (to r2) (to r3)\n                     (tx c1) (tx c2) (tx c3)\n                     (to c1) (to c2) (to c3)\n                     (tx d1) (tx d2)\n                     (to d1) (to d2)]\n              fxi (.indexOf fa :x)\n              foi (.indexOf fa :o)]\n         (cond (> fxi -1) :x\n               (> foi -1) :o\n               :else nil)))","problem":73,"user":"5078dedae4b08327cd804a5d"},{"problem":73,"code":"(fn tic-tac-toe [board]\n    (let [rows board\n          cols (apply map vector board)\n          diag-l (map (partial get-in board) [[0 0][1 1][2 2]])\n          diag-r (map (partial get-in board) [[0 2][1 1][2 0]])\n          all-groups (concat rows cols [diag-l] [diag-r])]\n        (some \n              (reduce #(if (= 1 (count (set %2))) (conj %1 (first %2)) %1)\n                #{} \n                all-groups)\n              [:x :o])))","user":"58ffaddee4b0438e51c2cffe"},{"code":"(fn tt [b]\n  (let [di #(= 1 (count (distinct %)))\n        ne #(not (= (first %) :e))\n        uni #(and (di %) (ne %))\n        br (apply map vector b)\n        di [[(ffirst b) (second (second b)) (last (last b))]\n              [(first (last b)) (second (second b)) (last (first b))]]\n        bind (fn [x] (map vector (map uni x) (map first x)))\n        [horz vert diag] (map bind [b br di])]\n    (cond\n      (some first horz) (second (first (filter first horz)))\n      (some first vert) (second (first (filter first vert)))\n      (some first diag) (second (first (filter first diag)))\n      :else nil)))","problem":73,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn tic-tac-toe [board]\r\n  (let [rows board\r\n        cols (map (fn [i] (map #(nth % i) board)) '(0 1 2))\r\n        diags [ [(first (first board)) (second (second board)) (nth (nth board 2) 2)]\r\n                [(first (nth board 2)) (second (second board)) (nth (first board) 2)] ]\r\n        alignment (concat board rows cols diags)]\r\n    (if (some #(= % [:x :x :x]) alignment)\r\n      :x\r\n      (if (some #(= % [:o :o :o]) alignment)\r\n        :o))))","problem":73,"user":"4dd023dd535d5973398f92ad"},{"problem":73,"code":"(fn [board]\n     (letfn [(line-win? [line]\n                        (cond (every? #(= % :x) line) :x\n                              (every? #(= % :o) line) :o\n                              :else nil))\n             (board-win? [board]\n                         (some line-win? board))\n             (rotate-board [board]\n                           (apply #(map vector %3 %2 %1) board))\n             (diag [board]\n                   (first (reduce (fn [[acc index] line] \n                                [(conj acc (line index))\n                                 (inc index)])\n                            [[] 0]\n                            board)))]\n            (let [board board\n                        rotated-board (rotate-board board)\n                        d1 (diag board)\n                        d2 (diag rotated-board)]\n              (or (some #(board-win? %) [board rotated-board])\n                  (some #(line-win? %) [d1 d2])))))","user":"4f867b25e4b033992c121c51"},{"problem":73,"code":"(fn get-winner [board]\n  (let [row-size (count board)\n        col-size (count (first board))\n        check    (fn [v]\n                   (cond\n                     (every? #(= % :x) v) :x\n                     (every? #(= % :o) v) :o))\n        row-winner (reduce (fn [ans row]\n                             (or ans (check row)))\n                           nil\n                           board)\n        col-winner (reduce (fn [ans col-index]\n                             (let [col (for [x (range row-size)]\n                                         (get (get board x) col-index))]\n                               (or ans (check col))))\n                           nil\n                           (range col-size))\n        diag-winner (or (check (for [i (range row-size)]\n                                 (get (get board i) i)))\n                        (check (for [i (range row-size)]\n                                 (get (get board i) (mod (- (- row-size 1) i) row-size)))))]\n    (or row-winner col-winner diag-winner)))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":73,"code":"(fn [board]\n  (letfn [(winner [b player]\n            (let [[[a b c] [d e f] [h i j]] b]\n              (or\n                (= a b c player)\n                (= d e f player)\n                (= h i j player)\n                (= a d h player)\n                (= b e i player)\n                (= c f j player)\n                (= a e j player)\n                (= c e h player))))]\n    (cond\n      (winner board :x) :x\n      (winner board :o) :o\n      :else nil)))","user":"54684c3be4b00cfc9eacc139"},{"code":"(letfn [(c [p b]\n           (let [v (apply + (map-indexed #(if (= p %2)\n                                            (bit-shift-left 1 %) 0) (flatten b)))]\n             (some #(= % (bit-and % v)) [292 146 73 448 56 7 273 84])))]\n       #(cond \n          (c :x %) :x\n          (c :o %) :o))","problem":73,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn [rows]\n\t(let [cols (apply map vector rows)\n\t      diag (fn [x] (map-indexed #(nth %2 %1) x))\n\t      lines (concat rows cols [(diag rows) (diag (map reverse rows))])\n\t      sets (map set lines)]\n\t  (first (some #{#{:x} #{:o}} sets))))","problem":73,"user":"50645e12e4b007509339a58a"},{"problem":73,"code":"#(->>\n  (concat % \n          (apply map vector %)\n          [[((% 0) 0) ((% 1) 1) ((% 2) 2)]]\n          [[((% 2) 0) ((% 1) 1) ((% 0) 2)]])\n  (filter (partial apply =))\n  (remove (partial apply = :e))\n  first\n  first)","user":"5ec6de19e4b08d0ec38692da"},{"problem":73,"code":"(fn [m]\n      (let [m' (apply map vector m)\n            [r1 r2 r3] m\n            [c1 c2 c3] m'\n            d1 [(first r1) (second r2) (last r3)]\n            d2 [(last r1) (second r2) (first r3)]\n            winner (some #(when (apply = %)\n                            (first %))\n                         [r1 r2 r3 c1 c2 c3 d1 d2])]\n        (when (contains? #{:x :o} winner)\n          winner)))","user":"59e0f38ae4b08badc2a0c500"},{"problem":73,"code":"(fn tictactoe [coll]\n  (some (fn [row]\n          (if (#{:o :x} (first row))\n            (reduce #(if (= %1 %2) %1 nil) row))) (let [flattened (flatten coll)]\n                                                    (concat coll\n                                                            (apply map vector coll)\n                                                            (vector (apply vector (take-nth 4 flattened)))\n                                                            (vector  (apply vector  (take 3 (take-nth 2 (drop 2 flattened)))))))))","user":"5ab490f4e4b073f17744261d"},{"code":"(fn tic-tac-toe-winner [board]\n  (let [v {:o -1 :e 0 :x 1}\n        len (count board)\n        cols (partition len (apply interleave board))\n        diag (conj\n               [(for [i (range len)] ((board i) i))]\n               (for [i (range len)] ((board i) (- len i 1))))\n        all (concat board cols diag)\n        sum (fn [coll] (apply + (map #(v %) coll)))\n        values (map sum all)\n        max-value (apply max values)\n        min-value (apply min values)]\n    (cond\n      (= max-value len) :x\n      (= min-value (- len)) :o\n      :else nil)))","problem":73,"user":"526ee63de4b03e8d9a4a733f"},{"problem":73,"code":"(fn [matrix] (let [r3 (range 3)\n                   col (fn [n] (for [i r3] [i n]))\n                   row (fn [n] (for [i r3] [n i]))\n                   diag0 (for [i r3] [i i])\n                   diag1 (for [i r3] [i (- 2 i)])\n                   win? (fn [coll symb] (every? #(= % symb) (map #(get-in matrix %) coll)))\n                   win-col (fn [symb] (or (win? (col 0) symb) \n                                          (win? (col 1) symb)\n                                          (win? (col 2) symb)))\n                   win-row (fn [symb]  (or (win? (row 0) symb) \n                                          (win? (row 1) symb)\n                                          (win? (row 2) symb)))\n                   win-diag (fn [symb] (or (win? diag0 symb) (win? diag1 symb)))\n                   win-symb? (fn [symb] (or (win-col symb) (win-row symb) (win-diag symb)))]\n               (cond\n                (win-symb? :x) :x\n                (win-symb? :o) :o\n                :else nil)))","user":"53976599e4b0b51d73faaeea"},{"problem":73,"code":"(fn [t]\n  (letfn [(wins? [x [[a b c]\n                    [d e f]\n                    [g h i]]]\n                (or (= x a b c)\n                    (= x d e f)\n                    (= x g h i)\n                    (= x a d g)\n                    (= x b e h)\n                    (= x c f i)\n                    (= x a e i)\n                    (= x c e g)))]\n  (cond\n   (wins? :x t) :x\n   (wins? :o t) :o\n   :else nil)))","user":"5478e57de4b0c51c1f4d72c1"},{"code":"(fn [board]\n  (let [check-three-boxes (fn [boxes] \n                            (if (and (apply = boxes) (not= (first boxes) :e))\n                              (first boxes) nil))\n        check-seq-of-threes (fn [rows-or-cols]\n                             (if (empty? rows-or-cols)\n                               false\n                               (or (check-three-boxes (first rows-or-cols))\n                                   (recur (rest rows-or-cols)))))]\n    (or\n     (check-seq-of-threes board)\n     (check-seq-of-threes (apply map vector board))\n     (check-three-boxes\n      (map #(get-in board [%1 %1]) (range 3)))\n     (check-three-boxes\n      (map #(get-in board [%1 (- 2 %1)]) (range 3))))))","problem":73,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn ttt [board]\n  (let [winner (fn [lsts] \n                 (first (for [lst lsts :when (and (apply = lst) (not= (first lst) :e))] (first lst)) ))\n        [[a1 a2 a3] \n         [b1 b2 b3] \n         [c1 c2 c3]] board\n        ]\n    (or\n      ; winner of rows\n      (winner board) \n      ; winner of columns\n      (winner [[a1 b1 c1] [a2 b2 c2] [a3 b3 c3]])\n      ; winner of \\ or /\n      (winner [[a1 b2 c3] [c1 b2 a3]])\n    ) ))","problem":73,"user":"4f2965ffe4b0d6649770a029"},{"problem":73,"code":"(fn [[[a b c :as u] [d e f :as s] [g h i :as t]]]\n    (some {[:o :o :o] :o [:x :x :x] :x}\n          [u s t [a d g] [b e h] [c f i] [a e i] [c e g]]))","user":"5c379636e4b0d62ef62d9f76"},{"problem":73,"code":"(fn [board]\n  (let [index-lists-to-check\n        (apply concat\n               [[[0 0] [1 1] [2 2]] \n                [[0 2] [1 1] [2 0]]]\n               (for [x (range 0 3)]\n                 [(for [y (range 0 3)]\n                    [x y])\n                  (for [y (range 0 3)]\n                    [y x])]))]\n    (->> index-lists-to-check\n         (map (fn [index-list] (map #(get-in board %) index-list)))\n         (map #(if (apply = %) (first %) nil))\n         (remove nil?)\n         (some #(when (not= :e %) %)))))","user":"57d82295e4b0bd073c2023e6"},{"code":"(fn[v]\n  (\n   #(if (seq %) (key(first(first(seq %)))) nil) \n   (filter #(and (= (count %) 1) (nil? (% :e))) \n           (map frequencies (concat v  \n                                    (into [] (apply map vector v)) \n                                    [[((v 0) 0) ((v 1) 1) ((v 2) 2)][((v 2)0)((v 1)1)((v 0)2)]])))))","problem":73,"user":"52bc6cb2e4b07a9af57922f5"},{"code":"(fn [b] \n (let [trans (fn [m] (apply map vector m))\n       diags (fn [b] (let [len (count b)]\n                          [(map-indexed #(nth %2 %1) b)\n                           (map-indexed #(nth %2 (- len %1 1)) b)]))\n       threes (fn [b] (concat b (trans b) (diags b)))\n\n       winner (fn [b] (some (fn [r] (or (and (every? #(= :x %) r) :x)\n                                        (and (every? #(= :o %) r) :o)))\n                            (threes b)))]\n      (winner b)))","problem":73,"user":"4e7e3cc4535db169f9c7970a"},{"problem":73,"code":"(fn [board]\n  (cond (apply = :x (first board))\n        :x\n        (apply = :o (first board))\n        :o\n      \t(apply = :x (second board))\n        :x\n        (apply = :o (second board))\n        :o\n      \t(apply = :x (last board))\n        :x\n        (apply = :o (last board))\n        :o\n      \t(= :x (first (first board)) (first (second board)) (first (last board)))\n        :x\n        (= :o (first (first board)) (first (second board)) (first (last board)))\n        :o\n      \t(= :x (second (first board)) (second (second board)) (second (last board)))\n        :x\n        (= :o (second (first board)) (second (second board)) (second (last board)))\n        :o\n      \t(= :x (last (first board)) (last (second board)) (last (last board)))\n        :x\n        (= :o (last (first board)) (last (second board)) (last (last board)))\n        :o\n      \t(= :x (first (first board)) (second (second board)) (last (last board)))\n        :x\n        (= :o (first (first board)) (second (second board)) (last (last board)))\n        :o\n      \t(= :x (last (first board)) (second (second board)) (first (last board)))\n        :x\n        (= :o (last (first board)) (second (second board)) (first (last board)))\n        :o\n        :else\n        nil))","user":"586d2f5be4b01531a375e98c"},{"code":"#(some\n (fn [v] (and (apply = v) ({:o :o :x :x :e nil} (first v))))\n (for [d [[0 1 2] [3 4 5] [6 7 8] [0 3 6]\n          [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n   (map (partial nth (flatten %)) d)))","problem":73,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":73,"code":"(fn [rows]\n  (let [h (-> \n           rows\n           (into (apply mapv conj (repeat 3 []) rows)) \n           (conj (map-indexed #(nth %2 %1) rows) (map-indexed #(nth %2 (- 2 %1)) rows) ))\n        testh (fn [l] (some (fn [r] (every? #(= l %) r)) h))]\n    (cond\n      (testh :x) :x\n      (testh :o) :o\n      :else nil)))","user":"5e9f38cce4b00a66d4a9517e"},{"code":"(fn [[[r00 r01 r02] [r10 r11 r12] [r20 r21 r22]]]\n  (cond\n   (and (= r00 r01 r02) (not= r01 :e)) r01\n   (and (= r10 r11 r12) (not= r10 :e)) r10\n   (and (= r20 r21 r22) (not= r20 :e)) r20\n   (and (= r00 r10 r20) (not= r00 :e)) r00\n   (and (= r01 r11 r21) (not= r01 :e)) r01\n   (and (= r02 r12 r22) (not= r02 :e)) r02\n   (and (= r00 r11 r22) (not= r00 :e)) r00\n   (and (= r20 r11 r02) (not= r20 :e)) r20   \n   :else nil))","problem":73,"user":"52b63875e4b0c58976d9ad41"},{"problem":73,"code":"(fn [b] \n  (let [s (concat\n           (apply merge (apply mapv list b) b)\n           (apply map \n                  list \n                  (for [c (range 3)] \n                    [((b c) c) \n                     ((b (- 2 c)) c)\n                     ])\n                  )\n           )\n        ]\n    (ffirst (filter #(and (= (count %) 1) \n                          (not= (first %) :e)) \n                    (map set s))\n            )\n    )\n  )","user":"5339cb07e4b0e30313ee6caf"},{"problem":73,"code":"(fn [[[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] \n  (letfn [(same [& s]\n   (ffirst (filter \n          (fn [[k v]] (and (#{:x :o} k) (= (count s) v))) (frequencies s))))]\n            (or \n             (same r11 r21 r31)\n             (same r12 r22 r32)\n             (same r13 r23 r33)\n             (same r11 r22 r33) \n             (same r13 r22 r31) \n             (same r11 r12 r13) \n             (same r21 r22 r23) \n             (same r31 r32 r33))))","user":"4f3b5219e4b0e243712b1f2a"},{"code":"(fn [rows]\n  (let [cols (apply map vector rows)\n        diags (map #(map % (range 3)) [#((rows %) %) #((rows %) (- 2 %))])\n        lines (concat rows cols diags)]\n    (first (some (comp #{#{:x} #{:o}} set) lines))))","problem":73,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn [board]\n   (let [winning [[[0 0] [0 1] [0 2]]\n                  [[1 0] [1 1] [1 2]]\n                  [[2 0] [2 1] [2 2]]\n                  [[0 0] [1 0] [2 0]]\n                  [[0 1] [1 1] [2 1]]\n                  [[0 2] [1 2] [2 2]]\n                  [[0 0] [1 1] [2 2]]\n                  [[0 2] [1 1] [2 0]]]\n         winner? (fn [player]\n                   (loop [winning winning winner nil]\n                     (cond winner winner\n                           (nil? (seq winning)) winner\n                           :else (recur (rest winning)\n                                        (let [win (first winning)]\n                                          (and (empty?\n                                                (filter false? \n                                                        (map #(= (get-in board %) player) win)))\n                                               player))))))]\n     (or (winner? :x) (winner? :o) nil)))","problem":73,"user":"52cc582ae4b07d0d72b27362"},{"code":"(fn tic-tac-toe [matrix]\n  (let [win-lines (concat\n                    (for [x (range 3)] (list [x 0] [x 1] [x 2])) ;; rows\n                    (for [y (range 3)] (list [0 y] [1 y] [2 y])) ;; cols\n                    '(([0 0] [1 1] [2 2]) ([0 2] [1 1] [2 0])))  ;; diag\n        is-win (fn [line side] (= #{side} (reduce #(conj % (get-in matrix %2)) #{} line)))\n        win-vec (for [l win-lines]\n                  (cond\n                    (is-win l :x) :x\n                    (is-win l :o) :o\n                    :else nil))]\n    (first (filter identity win-vec))))","problem":73,"user":"5125d963e4b05d10e3e395fe"},{"problem":73,"code":"(fn [b] (let [p (map #(if (< % 0) [(- %) 0] [0 %]) (range -2 3))\n              d (drop 2 (for [x [0 1] y [-1 0 1]] [x y]))\n              pd (for [p p d d] [p d])\n              s #(and % (not= :e %))]\n (some (fn [[p d]] (let [p1 (vec (map + p d))\n                         p2 (vec (map + p1 d))\n                         l (map #(get-in b %) (list p p1 p2))]             \n         (if (and (s (first l)) (apply = l)) (first l) )))\n  pd )))","user":"594c1baae4b07ddc2dafae59"},{"code":"(fn [b]\n  (let [v (->> (apply conj b (apply mapv vector b) )\n                (cons  (for [row [2 1 0]] (-> b (get row) (get row))))\n                (cons (vector (-> b (get 0) (get 2)) (-> b (get 1) (get 1)) (-> b (get 2) (get 0)))))]\n       (cond\n          (some #(= [:x :x :x] %) v) :x\n          (some #(= [:o :o :o] %) v) :o\n          :else nil)))","problem":73,"user":"5180dc04e4b06b8caf33fa01"},{"code":"(fn [b] (let [winners [#{0 1 2} #{3 4 5} #{6 7 8} #{0 3 6} #{1 4 7} #{2 5 8} #{0 4 8} #{2 4 6}]\n              fboard (flatten b)\n              owned-by (fn [p] (set (filter #(= (nth fboard %) p) (range 9))))\n              won? (fn [p] (reduce #(or %1 (clojure.set/subset? %2 (owned-by p))) false winners))\n              ]\n          (cond (won? :x) :x\n                (won? :o) :o\n                :else nil)))","problem":73,"user":"50dfb660e4b061dbdced7228"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (let [f\n        (fn [symbol]\n          (if (or (some (fn [row] (every? #(= % symbol) row)) board)\n                  (some (fn [column] (every? #(= (nth % column) symbol) board)) [0 1 2])\n                  (let [cell (fn [row column] (nth (nth board row) column))]\n                    (or (= (cell 0 0) (cell 1 1) (cell 2 2) symbol) (= (cell 0 2) (cell 1 1) (cell 2 0) symbol))\n                    )) symbol))\n        ]\n    (or (f :x) (f :o))))","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"#(some\n  {[:x :x :x] :x [:o :o :o] :o}\n  (concat % (apply map list %) [(map nth % [0 1 2]) (map nth % [2 1 0])]))","problem":73,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [b]\n  (let [check (fn [[x y dx dy]] \n         (if (not= (get-in b [y x]) :e) \n            (if (= (get-in b [y x]) \n                   (get-in b [(+ y dy) (+ x dx)])\n                   (get-in b [(+ y dy dy) (+ x dx dx)])) \n                    \n                (get-in b [y x]))))]\n\n       (some check [[0 0 1 0]\n                    [0 0 0 1]\n                    [0 0 1 1]\n                    [1 0 0 1]\n                    [2 0 0 1]\n                    [2 0 -1 1]\n                    [0 1 1 0]\n                    [0 2 1 0]])))","problem":73,"user":"5356e569e4b04ce2eb3ed272"},{"code":"(fn [s]\n  (letfn [(f [s] (some (fn [x] (when (every? #(= x %) s) x)) [:x :o]))\n        (dia [[[a _ b] [_ x _] [c _ d]]] [[a x d] [b x c]])]\n    (some f (concat s (apply map vector s) (dia s)))))","problem":73,"user":"4fdb02aae4b05e33b9224f56"},{"code":"#(let [\n       h %\n       v (partition 3 (apply interleave h))\n       d (partition 3 (apply interleave (map-indexed (fn [i x] [(nth x i) (nth x (- 2 i))]) h)))\n       s (set (concat h v d))\n       ]\n   (if (contains? s [:x :x :x])\n     :x\n     (if (contains? s [:o :o :o])\n       :o\n       nil\n       )\n     )\n   )","problem":73,"user":"5298d3f4e4b02ebb4ef75068"},{"code":"(fn check-board\n \n  [board]\n  (let [[h1 h2 h3] board\n        v1 [(first h1) (first h2) (first h3)]\n        v2 [(second h1) (second h2) (second h3)]\n        v3 [(last h1) (last h2) (last h3)]\n        d1 [(first h1) (second h2) (last h3)]\n        d2 [(last h1) (second h2) (first h3)]\n        all-lines [h1 h2 h3 v1 v2 v3 d1 d2]\n        results (map  (fn check-row\n                        [row]\n                          (when (or (every? #(= :x %) row)\n                                    (every? #(= :o %) row))\n                            (first row))) all-lines)]\n    (first (filter #(not (nil? %)) results))))","problem":73,"user":"4fd16778e4b04c3a95aa040f"},{"problem":73,"code":"(fn [board] \n  (let [\n        get-xy (fn [x y] (get (get board x) y))\n        row (fn [a b c] \n              (if (and (= :x a) (= a b) (= b c)) :x \n                (if (and (= :o a) (= a b) (= b c)) :o nil)))\n        evaluate (fn [a b] (if (nil? a) b a))\n       ]\n  \n    (reduce evaluate \n            [\n              (row (get-xy 0 0) (get-xy 1 0) (get-xy 2 0))\n              (row (get-xy 0 1) (get-xy 1 1) (get-xy 2 1))\n              (row (get-xy 0 2) (get-xy 1 2) (get-xy 2 2))\n              (row (get-xy 0 0) (get-xy 0 1) (get-xy 0 2))\n              (row (get-xy 1 0) (get-xy 1 1) (get-xy 1 2))\n              (row (get-xy 2 0) (get-xy 2 1) (get-xy 2 2))\n              (row (get-xy 0 0) (get-xy 1 1) (get-xy 2 2))\n              (row (get-xy 2 0) (get-xy 1 1) (get-xy 0 2))\n            ]\n    )          \n  )\n)","user":"560c31b4e4b05f002753df2d"},{"problem":73,"code":"(fn winner [rows]\n  (let [cols (apply map vector rows)\n        diags [(map get rows [0 1 2])\n               (map get rows [2 1 0])]]\n    (loop [[x & xs] (concat rows cols diags)]\n      (when-let [el (first x)]\n        (if (and (apply = x) (not= :e el))\n          el\n          (recur xs))))))","user":"541b1f25e4b01498b1a71a63"},{"problem":73,"code":"(fn best-find-winner [board]\n  (let [cols (apply map vector board)\n        diags [(map get board [0 1 2]) (map get board [2 1 0])]\n        three-in-a-row? (fn [squares] (if (every? #(= (first squares) %) squares) (first squares)))\n        won? (fn [board] (first (remove #(or (nil? %) (= :e %)) (map #(three-in-a-row? %) board))))]\n      (won? (concat board cols diags))))","user":"562eeba2e4b0ab312c17ebc1"},{"code":"(fn ttt-winner [[[b1 b2 b3]\n                   [b4 b5 b6]\n                   [b7 b8 b9]]]\n  (let [win? #(or (= % b1 b2 b3) (= % b4 b5 b6) (= % b7 b8 b9)\n                  (= % b1 b4 b7) (= % b2 b5 b8) (= % b3 b6 b9)\n                  (= % b1 b5 b9) (= % b3 b5 b7))]\n    (cond \n      (win? :x) :x\n      (win? :o) :o\n      :else nil)))","problem":73,"user":"5003deb9e4b0678c553fc445"},{"code":"(fn [x] \n  (let [r (vec (flatten x)),\n        row1 [(r 0) (r 1) (r 2)],\n        row2 [(r 3) (r 4) (r 5)],\n        row3 [(r 6) (r 7) (r 8)],\n        col1 [(r 0) (r 3) (r 6)],\n        col2 [(r 1) (r 4) (r 7)],\n        col3 [(r 2) (r 5) (r 8)],\n        dia1 [(r 0) (r 4) (r 8)],\n        dia2 [(r 2) (r 4) (r 6)],\n        a [row1 row2 row3 col1 col2 col3 dia1 dia2],\n        f (fn [l] (some #(every? (fn [c] (= c l)) %) a))]\n    (cond (f :x) :x\n          (f :o) :o\n          :else nil)))","problem":73,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":73,"code":"(fn [board]\n  (let [check-horizontally (fn [board]\n                             (loop [[r & more :as all] board]\n                               (if all\n                                 (if (and (apply = r) (not= :e (first r)))\n                                   (first r)\n                                   (recur more)))))\n        vertical-to-horizontal (fn [board]\n                                 (loop [[r & more :as all] (flatten board)\n                                        step 0\n                                        vertical '[[] [] []]]\n                                   (if all\n                                     (if (= step 2)\n                                       (recur more 0 (assoc vertical step (conj (vertical step) r)))\n                                       (recur more (inc step) (assoc vertical step (conj (vertical step) r))))\n                                     vertical)))\n        diagonal-to-horizontal (fn [board]\n                                 (loop [[r & more :as all] board\n                                        step 0\n                                        diagonals '[[] []]]\n                                   (if all\n                                     (if (= step 0)\n                                       (recur more (inc step) (assoc diagonals\n                                                                0 (conj (diagonals 0) (first r))\n                                                                1 (conj (diagonals 1) (last r))))\n                                       (if (= step 1)\n                                         (recur more (inc step) (assoc diagonals\n                                                                  0 (conj (diagonals 0) (second r))\n                                                                  1 (conj (diagonals 1) (second r))))\n                                         (recur more (inc step) (assoc diagonals\n                                                                  0 (conj (diagonals 0) (last r))\n                                                                  1 (conj (diagonals 1) (first r))))))\n                                     diagonals)))\n        h-match (check-horizontally board)\n        verticals (vertical-to-horizontal board)\n        v-match (check-horizontally verticals)\n        diagonals (diagonal-to-horizontal board)\n        d-match (check-horizontally diagonals)]\n    (cond\n     (not= nil v-match) v-match\n     (not= nil h-match) h-match\n     (not= nil d-match) d-match)))","user":"5c718e6ce4b0fca0c1622796"},{"code":"(letfn [(r [i] #(nth % i))\n        (c [i] (fn [m] (map #(nth % i) m)))\n        (d [& k] (fn [m] (map #(get-in m %) k)))\n        (q [b e] \n           (some #(every? #{e} %)\n             (map #(% b)\n               [(r 0) (r 1) (r 2) (c 0) (c 1) (c 2) (d [0 0] [1 1] [2 2]) (d [0 2] [1 1] [2 0])])))]\n(fn [b]\n  (cond\n    (q b :x) :x\n    (q b :o) :o\n    1 nil\n  )))","problem":73,"user":"4e82f85d535db62dc21a62ce"},{"problem":73,"code":"(fn [tab]\n  (letfn [(winner [coll]\n                  (when (apply = coll)\n                    (first coll)))\n          (get-diagonal [tab]\n                        (for [i (range 3)]\n                          (get-in tab [i i])))]\n  (let [rot (apply mapv (fn [x y z] [z y x]) tab)]\n    (some #{:x :o} (concat (map winner (conj tab (get-diagonal tab)))\n                  (map winner (conj rot (get-diagonal rot))))))))","user":"5cf935f4e4b0b71b1d808a8f"},{"code":"(fn [xs]\n  (let [ptn (fn [l]\n              (reduce\n               #(conj % (range %2 (+ %2 (inc (* l (dec l)))) l))\n               (reduce #(conj % (range (* %2 l) (* (inc %2) l))) \n                       [(take l (iterate #(+ l (inc %)) 0))\n                        (take l (iterate #(+ l (dec %)) (dec l)))] (range l))\n               (range l)))]\n    (#{:x :o} (ffirst (filter (partial apply =) (for [p (ptn (count xs)) :let [g (apply concat xs)]]\n                                                  (map #(nth g %) p)))))))","problem":73,"user":"4ef9c8f9535dced4c769f26b"},{"code":"(fn [s]\n           (let [wins '((0 1 2) (3 4 5) (6 7 8)\n                        (0 3 6) (1 4 7) (2 5 8)\n                        (0 4 8) (2 4 6))\n                p (mapcat identity s)\n                q (filter #(= 1 (count %)) \n                          (map distinct \n                               (map (fn [x](reduce #(conj % (nth p %2)) [] x)) \n                                    wins)))\n                ]\n                (if (or (= 0 (count q)) (= 8 (count q)))\n                    nil\n                    (first (flatten q)))))","problem":73,"user":"4f03f197535dcb61093f6b84"},{"code":"(fn [board]\n    (->> (concat board\n                 (apply map vector board)\n                 (let [[[a _ _] [_ b _] [_ _ c]] board] [[a b c]])\n                 (let [[[_ _ a] [_ b _] [c _ _]] board] [[a b c]]))\n     (some #{[:x :x :x] [:o :o :o]})\n     first))","problem":73,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn ttt[c]\r\n  (let [f (first c) s (second c) t (last c)]\r\n    (let [ans (filter (fn [x] (= 1 (count x)))\r\n      (conj #{} (set f) (set s) (set t)\r\n        (set (conj [] (first f) (first s) (first t)))\r\n        (set (conj [] (second f) (second s) (second t)))\r\n        (set (conj [] (last f) (last s) (last t)))\r\n        (set (conj [] (first f) (second s) (last t)))\r\n        (set (conj [] (last f) (second s) (first t)))\r\n        ))]\r\n      (get (first ans) :o (get (first ans) :x)))\r\n    )\r\n\r\n  )","problem":73,"user":"4e9def6b535dbda64a6f6b8f"},{"code":"(fn [g]\r\n  (letfn [(win [p rs] (some (fn [r] (= 3 (count (filter #(= p %) r)))) rs))\r\n          (column-to-row [c] [(nth (nth g 0) c) (nth (nth g 1) c) (nth (nth g 2) c)])\r\n          (diag1-row [] [(nth (nth g 0) 0) (nth (nth g 1) 1) (nth (nth g 2) 2)])\r\n          (diag2-row [] [(nth (nth g 0) 2) (nth (nth g 1) 1) (nth (nth g 2) 0)])]\r\n    (let [rows (conj g (column-to-row 0) (column-to-row 1)(column-to-row 2) (diag1-row) (diag2-row))]\r\n      (if (win :x rows)\r\n        :x\r\n        (if (win :o rows)\r\n          :o)))))","problem":73,"user":"4e79ff2a535db169f9c796a9"},{"code":"(fn \n  [board]\n  (let [flat (flatten board)\n        width (count board)\n        cols  (for [x (range (count board))] (map #(nth %1 x) board))\n        diags (conj () (for [x (range width)] (nth flat (+ (* width x) x)))\n                       (for [x (range 1 (inc width))] (nth flat (- (* width x) x) )))\n        all (for [line (concat board cols diags)]\n              (if (apply = line) (first line) nil))]\n    (first (filter #(or (= %1 :x) (= %1 :o)) all))))","problem":73,"user":"4f4544e1e4b0d56e7bb92b7a"},{"code":"(fn [board]\n    (let [by-cols (apply mapv vector board)\n          by-rows board\n          mirrored (vec(map #(vec( reverse %)) board))\n          down-cross (map #(get-in by-rows %) (map #(vector % %) (range 3)))\n          up-cross (map #(get-in mirrored %) (map #(vector % %) (range 3)))\n          o-row [:o :o :o]\n          x-row [:x :x :x]]\n      (cond\n       (not-empty (filter #(= % o-row) by-rows)) :o\n       (not-empty (filter #(= % o-row) by-cols)) :o\n       (not-empty (filter #(= % x-row) by-rows)) :x\n       (not-empty (filter #(= % x-row) by-cols)) :x\n       (= down-cross o-row) :o\n       (= down-cross x-row) :x\n       (= up-cross o-row) :o\n       (= up-cross x-row) :x\n       :else nil)))","problem":73,"user":"524d90c0e4b0a16e35cf6ded"},{"problem":73,"code":"(fn z [m]\n  (let [rot #(apply map vector %)\n        cl #(when (apply = %) (first %))\n \t\tchk #(some #{:x :o} (map cl %))\n        r1 #(map nth % (range 3))\n        r2 #(map nth % (range 2 -1 -1))\n\t]\n    (chk (concat m (rot m) [(r1 m) (r2 m)] ))\n  )\n)","user":"57c7a8b5e4b05aa3c4741d09"},{"problem":73,"code":"(fn foonction [m]\n  (letfn [(rowWinner [coll]\n           (if (and (apply = coll) (not (= :e (first coll))))\n                  (first coll)\n                  nil))\n          (transpose [m] (apply mapv vector m))\n          (topleft [m] (when-let [x (ffirst m)] (cons x (topleft (map rest (rest m))))))\n          (topright [m] (when-let [x (last (first m))] (cons x (topright (map butlast (rest m))))))\n          (getRows [m] (concat m (transpose m) [(topleft m)] [(topright m)]))]\n    (let [winners (map rowWinner (getRows m))]\n      (when-let [winner (first (filter identity winners))]\n        winner))))","user":"56fc0601e4b07572ad1a88db"},{"code":"(fn winner [board]\n  (loop [remaining [[[0 0] [0 1] [0 2]]                                                                                                                                 \n                   [[1 0] [1 1] [1 2]]                                                                                                                                  \n                   [[2 0] [2 1] [2 2]]                                                                                                                                  \n                   [[0 0] [1 0] [2 0]]                                                                                                                                  \n                   [[0 1] [1 1] [2 1]]                                                                                                                                  \n                   [[0 2] [1 2] [2 2]]                                                                                                                                  \n                   [[0 0] [1 1] [2 2]]                                                                                                                                  \n                   [[2 0] [1 1] [0 2]]]]                                                                                                                                \n    (if (empty? remaining)                                                                                                                                              \n      nil                                                                                                                                                               \n      (let [position (first remaining)                                                                                                                                  \n            items (map #((board (% 0)) (% 1)) position)                                                                                                                 \n            common? (apply = items)]                                                                                                                                    \n        (if (and common? (not (= (first items) :e)))                                                                                                                    \n          (first items)                                                                                                                                                 \n          (recur (rest remaining)))))))","problem":73,"user":"51899891e4b0288ada3dbdab"},{"problem":73,"code":"(fn ttt [bs]\n  (let [pred (fn [l]\n               (let [x (first l)]\n                 (when (and (not= x :e) (apply = l)) (first l))))\n        rnth (fn [ind coll] (nth coll ind))\n        trans (apply map list bs)\n        d1 (map-indexed rnth bs)\n        d2 (map-indexed rnth (reverse bs))]\n    (or\n     (some pred bs)\n     (some pred trans)\n     (pred d1)\n     (pred d2))))","user":"53e27bf1e4b036ad0777e3f2"},{"problem":73,"code":"(fn [x]\n           (let [rows (map #(distinct %) x)\n                 cols (map #(distinct %) (apply map vector x))\n                 tlbr (distinct (map-indexed #(nth %2 %1) x))\n                 trbl (distinct (map-indexed #(nth %2 (- (count %2) %1 1)) x))\n                 all (conj (concat rows cols) tlbr trbl)]\n             (cond\n               (some #(= [:x] %) all) :x\n               (some #(= [:o] %) all) :o\n               :else nil)))","user":"5654cb2de4b0f9d632dd848b"},{"code":"(fn tictactoe [x]\n     (let [y (vec (flatten x))]\n       (if (or (and (= (get y 0) :x) (= (get y 1) :x) (= (get y 2) :x))\n               (and (= (get y 3) :x) (= (get y 4) :x) (= (get y 5) :x))\n               (and (= (get y 6) :x) (= (get y 7) :x) (= (get y 8) :x))\n               (and (= (get y 0) :x) (= (get y 3) :x) (= (get y 6) :x))\n               (and (= (get y 1) :x) (= (get y 4) :x) (= (get y 7) :x))\n               (and (= (get y 2) :x) (= (get y 5) :x) (= (get y 8) :x))\n               (and (= (get y 0) :x) (= (get y 4) :x) (= (get y 8) :x))\n               (and (= (get y 2) :x) (= (get y 4) :x) (= (get y 6) :x)))\n         :x\n         (if (or (and (= (get y 0) :o) (= (get y 1) :o) (= (get y 2) :o))\n               (and (= (get y 3) :o) (= (get y 4) :o) (= (get y 5) :o))\n               (and (= (get y 6) :o) (= (get y 7) :o) (= (get y 8) :o))\n               (and (= (get y 0) :o) (= (get y 3) :o) (= (get y 6) :o))\n               (and (= (get y 1) :o) (= (get y 4) :o) (= (get y 7) :o))\n               (and (= (get y 2) :o) (= (get y 5) :o) (= (get y 8) :o))\n               (and (= (get y 0) :o) (= (get y 4) :o) (= (get y 8) :o))\n               (and (= (get y 2) :o) (= (get y 4) :o) (= (get y 6) :o)))\n           :o\n           nil))))","problem":73,"user":"532727bae4b09d4e7a9b54fa"},{"problem":73,"code":"(fn [board]\n  (let [ps (into #{} (concat board\n                             (->> board\n                                  (apply interleave)\n                                  (partition 3))\n                             (list (map-indexed #(nth %2 ([0 1 2] %1)) board))\n                             (list (map-indexed #(nth %2 ([2 1 0] %1)) board))))]\n    (cond (ps [:x :x :x]) :x\n          (ps [:o :o :o]) :o\n          :else nil)))","user":"5eb1c786e4b00a66d4a95201"},{"problem":73,"code":"(fn [board]\n  (let\n    [flatboard (flatten board),\n     indices [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]],\n     sets (filter\n           (fn [markset] (and (= (count markset) 1) (not= (first markset) :e)))\n           (map \n            (fn [indexblock] \n              (set \n                (map \n                 (fn [index] \n                   (nth flatboard index)\n                   ) \n                 indexblock\n                 )\n                )\n              ) \n            indices\n            )\n)\n     ]\n    (if (= 1 (count sets)) (first (first sets)) nil)\n    )\n  )","user":"58950f29e4b00487982d5270"},{"code":"#(->> (concat %\n         (apply map list %)\n         (let [[[x _ _] [_ y _] [_ _ z]] %] [[x y z]])\n         (let [[[_ _ x] [_ y _] [z _ _]] %] [[x y z]]))\n    (some #{(repeat 3 :x) (repeat 3 :o)})\n    first)","problem":73,"user":"515e8ce2e4b049add99a053d"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (let [player (fn [arg] (if (= :e arg) nil arg))]\n    (cond\n      (= a b c) (player a)\n      (= d e f) (player d)\n      (= g h i) (player g)\n      (= a d g) (player a)\n      (= b e h) (player b)\n      (= c f i) (player c)\n      (= a e i) (player a)\n      (= c e g) (player c)\n      :else nil)))","user":"5574c172e4b05c286339e059"},{"problem":73,"code":"(fn [board]\n   (let [flat (flatten board)\n         rotated (partition 3 (apply interleave board))]\n     (cond\n       (or (some true? (map (fn [row] (every? #(= % :x) row)) board))\n           (some true? (map (fn [row] (every? #(= % :x) row)) rotated))\n           (= :x (nth (nth board 0) 0) (nth (nth board 1) 1) (nth (nth board 2) 2))\n           (= :x (nth (nth board 0) 2) (nth (nth board 1) 1) (nth (nth board 2) 0))) :x\n       (or (some true? (map (fn [row] (every? #(= % :o) row)) board))\n           (some true? (map (fn [row] (every? #(= % :o) row)) rotated))\n           (= :o (nth (nth board 0) 0) (nth (nth board 1) 1) (nth (nth board 2) 2))\n           (= :o (nth (nth board 0) 2) (nth (nth board 1) 1) (nth (nth board 2) 0))) :o)))","user":"536be48ee4b0fc7073fd6e31"},{"problem":73,"code":"(fn [board]\n     (letfn [(columns [board]\n                (apply mapv vector board))\n             (diagonals [board]\n                [[(nth (nth board 0) 0) (nth (nth board 1) 1) (nth (nth board 2) 2)]\n                 [(nth (nth board 0) 2) (nth (nth board 1) 1) (nth (nth board 2) 0)]])]\n         (let [targets (concat board (columns board) (diagonals board))]\n             (if (some #(= % [:x :x :x]) targets)\n                 :x\n                 (if (some #(= % [:o :o :o]) targets)\n                     :o\n                     nil)))))","user":"600ae927e4b074f607df6689"},{"problem":73,"code":";not elegant, but working. \n(fn [board]\n  (let [group-indexes [[0 1 2] [3 4 5] [6 7 8]\n                       [0 3 6] [1 4 7] [2 5 8]\n                       [0 4 8] [2 4 6]]\n        groups (map (fn [indexes]\n                      (map (fn [index] ((vec (flatten board)) index)) indexes))\n                    group-indexes)]\n    (cond \n     (some #(= [:x :x :x] %) groups) :x\n     (some #(= [:o :o :o] %) groups) :o\n     :else nil)))","user":"5553b924e4b0deb715856e06"},{"code":"(fn find-winner\n  [board]\n  (let [board (flatten board)\n        players [:x :o]\n        match-coll [{:match [0 1 2], :sum 3, :repeat 3}\n   \t\t\t\t\t{:match [0 3 6], :sum 1, :repeat 3}\n   \t\t\t\t\t{:match [0 4 8], :sum 0, :repeat 1}\n   \t\t\t\t\t{:match [2 4 6], :sum 0, :repeat 1}]\n        match? (fn [player coll match]\n                 (every? true? (map #(= player (nth coll %)) match)))\n        generate-matches (fn [match]\n  \t\t\t\t\t\t\t(take (:repeat match)\n        \t\t\t\t\t\t(iterate (fn [coll]\n                   \t\t\t\t\t\t\t(map #(+ (:sum match) %) coll))\n                                         (:match match))))]\n    (some #(when % %)\n          (map (fn [player]\n                 (some #(when % player)\n                       (reduce (fn [result matches]\n                                 (concat result (map #(match? player board %) matches)))\n                               '() (map generate-matches match-coll))))\n               players))))","problem":73,"user":"5339af7de4b0e30313ee6cab"},{"problem":73,"code":"(fn [x]\n   (let [t #(every? (partial = %1) %2)\n         v #(some true? (map (partial t %1) x))\n         vx (v :x)\n         vo (v :o)\n         h #(loop [a x b false]\n              (if (or (every? empty? a) b)\n                b\n                (recur (map rest a) (t %1 (map first a)))))\n         hx (h :x)\n         ho (h :o)\n         d (loop [n 0 ac []]\n             (if (< n (count x)) \n               (recur (inc n) (conj ac (nth (nth x n) n)))\n               ac))\n         d2 (loop [n (dec (count x)) r 0 ac []]\n             (if (>= n 0)\n               (recur (dec n) (inc r) (conj ac (nth (nth x r) n)))\n               ac))\n         dx (t :x d)\n         do (t :o d)\n         d2x (t :x d2)\n         d2o (t :o d2)]\n     \n     (cond\n       (or hx vx dx d2x) :x\n       (or ho vo do d2o) :o\n       :else nil)))","user":"5910a43de4b0163c97b36ebf"},{"problem":73,"code":"(fn won\n   ([coll] (let [wonx (won coll :x)\n                 wono (won coll :o)]\n             (or wonx wono)))\n   ([coll x]\n    (let [m (map-indexed vector (map #(map-indexed vector %) coll))\n          winindexes (reduce (fn [ac row]\n                            (let [rowindex (first row)\n                                  rowvalue (second row)\n                                  index (reduce (fn [acc item]\n                                                  (if (= (second item) x)\n                                                    (conj acc [rowindex (first item)])\n                                                    acc))\n                                                [] rowvalue)]\n                              (println \"index:\" index)\n                              (vec (concat ac index))\n                              \n                              ))\n                          [] m)\n          ind_count (count winindexes)]\n      (println \"winindexes: \" winindexes)\n      (if (= 3 ind_count)\n        (let [main_index (count (filter true? (map (fn [indexes]\n                                                     (let [i (first indexes)\n                                                           j (second indexes)]\n                                                       (= i j)))\n                                                   winindexes)))\n              add_index (count (filter true? (map (fn [indexes]\n                                                    (let [i (first indexes)\n                                                          j (second indexes)]\n                                                      (= 2 (+ i j))))\n                                                  winindexes)))\n              row_index (count (set (reduce (fn [acc indexes]\n                                              (let [i (first indexes)]\n                                                (conj acc i)))\n                                            [] winindexes)))\n              col_index  (count (set (reduce (fn [acc indexes]\n                                               (let [i (second indexes)]\n                                                 (conj acc i)))\n                                             [] winindexes)))]\n          (println \"all indexes \" [main_index add_index row_index col_index])\n          (if (or (= 3 main_index) (= 3 add_index) (= 3 (* row_index col_index)))\n            x\n            nil))\n        nil))))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":73,"code":"(fn [board]\n  (let [lines (concat board\n                      (for [i (range 3)] (map #(nth % i) board))\n                      (vector (for [i (range 3)] (get-in board [i i])))\n                      (vector (for [i (range 3)] (get-in board [i (- 3 1 i)]))))\n        is-winner (fn [player] (some #(every? #{player} %) lines))]\n    (cond\n      (is-winner :x) :x\n      (is-winner :o) :o\n      :else nil)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [board]\n  (some #(when (apply = %1) (first %1))\n        (map (partial replace {:e nil})\n          (apply concat\n            ((juxt #(and %)\n                   (partial apply map list)\n                   #(list (for [i (range 3)] ((% i) i)))\n                   #(list (for [i (range 3)] ((% i) (- 2 i)))))\n             board)))))","problem":73,"user":"50166470e4b052339a490e76"},{"problem":73,"code":"(fn\n [[\n    [x1 x2 x3 :as r1]\n    [y1 y2 y3 :as r2]\n    [z1 z2 z3 :as r3]]]\n\n  (let\n   [linewinner  (fn [r]  (if (apply = r)\n       (let [f (first r)]\n         (if (= f :e) nil f))))\n\n        v1 [x1 y1 z1]\n        v2 [x2 y2 z2]\n        v3 [x3 y3 z3]\n\n        d1 [x1 y2 z3]\n        d2 [z1 y2 x3]]\n   (first (filter #(not= % nil) (flatten (map linewinner [r1 r2 r3 v1 v2 v3 d1 d2 ]))))))","user":"57ed8315e4b0bfb2137f5b9a"},{"code":"(fn analyze-tic-tac-toe-board\n  [board]\n  (letfn\n      [(check-rows [value b]\n         (and (some\n          (fn [row] (every? #(= value %) row))\n          b) value))\n       (transpose [b] (apply mapv vector b))\n       (check-cols [value b]\n         (and (check-rows value (transpose b)) value))\n       (check-diagonals [value b]\n         (and\n          (or\n           (every? identity\n            (for [i (range 3)]\n              (= value (nth (nth b i) i))))\n           (every? identity\n            (for [i (range 3)]\n              (= value (nth (nth b i) (- 2 i))))))\n          value))\n       (check-value [value b]\n         (or (check-rows value b)\n             (check-cols value b)\n             (check-diagonals value b)))]\n    (or (check-value :x board)\n        (check-value :o board)\n        nil)))","problem":73,"user":"511720eae4b0063b4e3e16da"},{"problem":73,"code":"(fn [board]\n  (first\n   (some #{[:x :x :x] [:o :o :o]}\n         (conj (concat board (apply mapv vector board))\n               (mapv get board (range))\n               (mapv get board [2 1 0])))))","user":"505aa653e4b021387fb89857"},{"code":"(fn [game]\n   (let [winning-combinations [[[0 0] [0 1] [0 2]]\n                               [[1 0] [1 1] [1 2]]\n                               [[2 0] [2 1] [2 2]]\n                               [[0 0] [1 0] [2 0]]\n                               [[0 1] [1 1] [2 1]]\n                               [[0 2] [1 2] [2 2]]\n                               [[0 0] [1 1] [2 2]]\n                               [[2 0] [1 1] [0 2]]]\n         winner? (fn [player]\n                   (not (not-any? true?\n                                  (for [comb winning-combinations]\n                                    (not-any? #(not= % player)\n                                              (map #(get-in game %) comb))))))]\n     (cond (winner? :x) :x\n           (winner? :o) :o\n           :else nil))\n   )","problem":73,"user":"4e9fd521535d7eef3080729a"},{"problem":73,"code":"(fn p73[t]\n(first (let [diag (fn diag[fun off]\n  (map-indexed (fn[i r] \n                 (nth r (fun off i))) t))]\n(filter #(if (nil? %) false (not= :e %))\n        (concat \n        (map (fn [index]\n          (let [\n                lrd (diag + 0)\n                rld (diag - 2)\n                vert ((fn[m i] (map #(nth % i) m)) t index) \n                hori (nth t index)\n               ]\n          (cond \n           (every? #{(first lrd)} lrd) (first lrd)\n           (every? #{(first rld)} rld) (first rld)\n           (every? #{(first vert)} vert) (first vert)\n           (every? #{(first hori)} hori) (first hori)\n          ))) [0 1 2])))\n  \n  )))","user":"52ab61f5e4b0c58976d9ac75"},{"problem":73,"code":"(fn [board]\n  (some\n    (fn [winner]\n      (if (some #(apply = winner %1)\n                (conj\n                  (concat\n                    board ;rows\n                    (map #(map nth board (repeat %1)) [0 1 2])) ;columns\n                  (map nth board (range)) ;UL-BR\n                  (map nth (reverse board) (range)))) ;UR-BL\n          winner))\n    [:x :o]))","user":"565f8fd2e4b068f2fe63dc41"},{"code":"(fn [tv]\n  (let [xs (vec (flatten tv))\n        p  (partition 3 (for [x [0 1 2, 3 4 5, 6 7 8,\n                                 0 3 6, 1 4 7, 2 5 8,\n                                 0 4 8, 2 4 6]]\n                          (get xs x)))]\n    (loop [xs p]\n      (let [s (first xs)]\n        (cond\n         (nil? s) nil\n         (every? #(= :x %1) s) :x\n         (every? #(= :o %1) s) :o\n         :else (recur (rest xs)))))))","problem":73,"user":"52fb64b7e4b047fd55837009"},{"code":"(fn check-tic-tac-toe [board]\n  (let [check-line (fn [line]\n                     (if (= ((frequencies line) :o) 3) :o\n                       (if (= ((frequencies line) :x) 3) :x\n                         nil)))\n        lines (concat board\n                      (map (fn [fun] (map fun board))\n                           (list first second last))\n                      (list (list (first (first board)) \n                            \t  (second (second board)) \n                            \t  (last (last board)))\n                      \t\t(list (last (first board)) \n                                  (second (second board)) \n                                  (first (last board)))))\n        determine-winner (fn [line-results]\n                           (if (some #{:o} line-results) :o\n                             (if (some #{:x} line-results) :x\n                               nil)))]\n    (determine-winner (map check-line lines))))","problem":73,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":73,"code":"(fn [board]\n    (let [diag1 [(ffirst board) (second (second board)) (nth (nth board 2) 2)]\n          diag2 [(nth (first board) 2) (second (second board)) (first (nth board 2))]\n          consid (concat board (apply map vector board) [diag1 diag2])]\n      (cond\n        (seq (filter (partial every? #{:o}) consid)) :o\n        (seq (filter (partial every? #{:x}) consid)) :x\n        :else nil)))","user":"53716539e4b0fc7073fd6eb1"},{"problem":73,"code":"(fn [board]\n(letfn [(rotate-board [[first-row :as board]]\n  (let [no-of-columns (count first-row)]\n    (map\n      (fn [col-index]\n        (map (fn [row] (nth row col-index)) board))\n      (range no-of-columns))))\n\n(winner-by-row [board]\n  (->> board\n       (map\n         (fn [[first-el :as row]]\n           ; `contains?` for arrays works not like you'd expect (cf. https://clojuredocs.org/clojure.core/contains_q)\n           (if (and (apply = row) (some #{first-el} [:x :o]))\n             first-el\n             nil)))\n       (remove nil?)\n       (first)))\n\n(winner-by-column [board]\n  (-> board\n      (rotate-board)\n      (winner-by-row)))\n\n(winner-by-diagonal [board]\n  ; TODO: make flexible for boards larger than 3x3\n  (let [diagonal1 [(get-in board [0 0])\n                   (get-in board [1 1])\n                   (get-in board [2 2])]\n        diagonal2 [(get-in board [0 2])\n                   (get-in board [1 1])\n                   (get-in board [2 0])]]\n    ; TODO: avoid repetition (same code as in `winner-by-row`)\n    (->> [diagonal1 diagonal2]\n         (map\n           (fn [[first-el :as diagonal]]\n             (if (and (some #{first-el} [:x :o]) (apply = diagonal)) first-el nil)))\n         (remove nil?)\n         (first))))]\n\n  (let [results [(winner-by-row board)\n                 (winner-by-column board)\n                 (winner-by-diagonal board)]]\n    (first (remove nil? results)))))","user":"552d2e4fe4b076ab5578f7e1"},{"code":"(fn [rows]\n  (let [cols [(map first rows)\n              (map second rows)\n              (map last rows)]\n        diagonals [[(first (nth rows 0))\n                    (second (nth rows 1))\n                    (last (nth rows 2))]\n                   [(last (nth rows 0))\n                    (second (nth rows 1))\n                    (first (nth rows 2))]]\n        winseqs (concat rows cols diagonals)\n        winner (fn [s]\n                 (if (or (= :e (first s)) (not (every? #(= (first s) %) s)))\n                   nil\n                   (first s)))]\n  (some winner winseqs)))","problem":73,"user":"53834ed3e4b06839e8705edb"},{"problem":73,"code":"(fn [grid]\n  (let [goal (fn [index f] \n               (let [wins (into #{} (take 3 (iterate f index)))]\n         \t (map #(contains? wins %) (take 9 (range)))))\n        goals (concat (map #(goal % inc) '(0 3 6))\n                      (map #(goal % (partial + 3)) '(0 1 2))\n                      (map #(goal % (partial + 4)) '(0)) \n                      (map #(goal % (partial + 2)) '(2)))\n        win? (fn [grid kw] \n              (let [fgrid (map #(= kw %) (flatten grid))]\n                (not (empty? (filter #(= fgrid %) goals)))))\n\t\txs (win? grid :x)\n        os (win? grid :o)]\n(if xs :x (if os :o nil))))","user":"5272645de4b03e8d9a4a742c"},{"code":"#(some {[:x :x :x] :x [:o :o :o] :o}\n   (concat\n     %\n     (apply map list %)\n     (map (partial map (partial get-in %))\n          [[[0 0] [1 1] [2 2]]\n           [[0 2] [1 1] [2 0]]])))","problem":73,"user":"4db1f7d223724b71670a9c07"},{"code":"(fn [ [[a b c]\n       [d e f]\n\t   [h i j] :as board] ]\n\t \n\t (let \n\t   [test-line (fn [line] (reduce #(when (= %1 %2) %1) line))\n\t    lines  (concat board (apply map vector board) [[a e j] [c e h]])\n\t\tscored-lines (map test-line lines) ]\n\t\n\t   (some #{:x :o} scored-lines)  ))","problem":73,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":73,"code":"(fn [field]\n  (let [row (fn [n]\n              (get field n))\n        col \n        (fn [n]\n          (map #(get % n) field))\n        diag1\n        (map #(get (row %) %) (range 3))\n        diag2\n        (map #(get (row %) (- 2 %)) (range 3))\n        who-win\n        (fn [r]\n          (and\n           (apply = r)\n           (not= (first r) :e)\n           (first r)))\n        rows field\n        cols (map col (range 3))\n        all-lines\n        (concat rows cols [diag1 diag2])\n        all-win (some identity (map who-win all-lines))]\n    all-win))","user":"592334c7e4b0a390037439ee"},{"problem":73,"code":"(fn [b]\n    (let [v (ffirst (filter (partial apply =)\n                            (map (fn [line] (mapv (partial get-in b) line))\n                                 (concat\n                                   (mapv (fn [r] (mapv (fn [c] [c r]) (range 3))) (range 3))\n                                   (mapv (fn [r] (mapv (fn [c] [r c]) (range 3))) (range 3))\n                                   [(mapv (fn [cr] [cr cr]) (range 3))]\n                                   [(mapv (fn [cr] [(- 2 cr) cr]) (range 3))]))))]\n      (if (= v :e) nil v)))","user":"5310e968e4b08068f379ecdd"},{"code":"(let [pats\n[[0 0 1 0]\n [0 0 1 1]\n [0 0 0 1]\n [1 0 0 1]\n [2 0 0 1]\n [0 1 1 0]\n [0 2 1 0]\n [2 0 -1 1]]]\n#(some\n       (fn [w] (or w nil))\n\n       (for [pat pats]\n         (let [p0 ((% (pat 0)) (pat 1))\n               p1 ((% (+ (pat 0) (pat 2))) (+ (pat 1) (pat 3)))\n               p2 ((% (+ (pat 0) (pat 2) (pat 2))) (+ (pat 1) (pat 3) (pat 3)))]\n           (cond\n            (= [p0 p1 p2] [:x :x :x]) :x\n            (= [p0 p1 p2] [:o :o :o]) :o\n            true nil)))))","problem":73,"user":"5196568fe4b04c0af7ff3c1c"},{"code":"(fn [b]\n   (let [lines (map #(set %) (concat b\n                                     (map #(map (fn [r] (nth r %)) b) (range 3))\n                                     [(map-indexed #(nth %2 %1) b)]\n                                     [(map-indexed #(nth %2 (- (dec (count b)) %1)) b)]))]\n     (cond\n      (some #(and (= 1 (count %)) (= :x (first %))) lines) :x\n      (some #(and (= 1 (count %)) (= :o (first %))) lines) :o\n      :else nil)))","problem":73,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn evalBoard [x] (let [\n    [[c1 c2 c3][c4 c5 c6][c7 c8 c9]] x\n    ]\n    (if (or\n          (every? #{:x} [c1 c2 c3])\n          (every? #{:x} [c4 c5 c6])\n          (every? #{:x} [c7 c8 c9])\n          (every? #{:x} [c1 c4 c7])\n          (every? #{:x} [c2 c5 c8])\n          (every? #{:x} [c3 c6 c9])\n          (every? #{:x} [c1 c5 c9])\n          (every? #{:x} [c3 c5 c7]))\n      :x (if (or\n          (every? #{:o} [c1 c2 c3])\n          (every? #{:o} [c4 c5 c6])\n          (every? #{:o} [c7 c8 c9])\n          (every? #{:o} [c1 c4 c7])\n          (every? #{:o} [c2 c5 c8])\n          (every? #{:o} [c3 c6 c9])\n          (every? #{:o} [c1 c5 c9])\n          (every? #{:o} [c3 c5 c7]))\n     :o nil))))","problem":73,"user":"514cfa27e4b019235f6c057d"},{"problem":73,"code":"(fn [b]\n  (let [w '(t m b l c r d p)\n        c {:tl [0 0] :tc [0 1] :tr [0 2]\n           :ml [1 0] :mc [1 1] :mr [1 2]\n           :bl [2 0] :bc [2 1] :br [2 2]\n           :d1 [0 0] :d2 [1 1] :d3 [2 2]\n           :p1 [0 2] :p2 [1 1] :p3 [2 0]}]\n    (letfn [(get-coords [s]\n              (map #(c (keyword %)) (filter #(re-seq (re-pattern (str s)) %) (map name (keys c)))))\n            (get-row [board coords]\n              (map #((board (first %)) (second %)) coords))\n            (winner? [row]\n              (reduce #(if (and (= % %2) (not (= % :e))) % nil) row))]\n      (loop [rm w, r nil]\n        (cond (not (nil? r)) r\n              (empty? rm) nil\n              :else (recur (rest rm) (winner? (get-row b (get-coords (first rm))))))))))","user":"538e36c7e4b0b51d73faae81"},{"problem":73,"code":"(fn f73 [coll]\n  (let [fr (first coll)\n        sr (second (second coll))\n        lr (last coll)\n        cond-1 (= 1 (->>\n                    (map #(first %) coll)\n                    (distinct)\n                    (count)))\n        cond-2 (= 1 (->>\n                      (map #(second %) coll)\n                      (distinct)\n                      (count)))\n        cond-3 (= 1 (->>\n                      (map #(last %) coll)\n                      (distinct)\n                      (count)))\n        cond-4 (not (empty? (filter #(= 1 (count %)) (map distinct coll))))\n        cond-5 (= (first fr) sr (last lr))\n        cond-6 (= (last fr) sr (first lr))\n        res (if (true? cond-1)\n              (first (map #(first %) coll))\n              (if (true? cond-2)\n                (first (map #(second %) coll))\n                (if (true? cond-3)\n                  (first (map #(last %) coll))\n                  (if (true? cond-4)\n                    (ffirst (filter #(= 1 (count %)) (map distinct coll)))\n                    (if (true? cond-5)\n                      (first fr)\n                      (if (true? cond-6)\n                        (last fr)\n                        nil))))))]\n    (if (= :e res)\n      nil\n      res)))","user":"57bbc9bde4b05aa3c4741c31"},{"code":"(fn [board]\n  (some #(cond (= :e (first %)) nil\n               (apply = %) (first %)\n               :else nil)\n        (map (fn [positions] (map #(get-in board %) positions))\n             [[[0 0] [0 1] [0 2]]\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]]\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]]])))","problem":73,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":73,"code":"(fn [board]\n\n  (letfn [(rows [board] board)\n\n          (column [board i]\n            (map (fn [row] (nth row i)) board))\n\n          (columns [board]\n            (map (partial column board) (range 3)))\n\n          (multi-nth [vec indexes]\n            (reduce (fn [vec i] (nth vec i)) vec indexes))\n\n          (diag1 [board]\n            (let [indexes (range 3)]\n              (map (partial multi-nth board) (map list indexes indexes))))\n\n          (diag2 [board]\n            (let [indexes (range 3)]\n              (map (partial multi-nth board) (map list indexes (reverse indexes)))))\n\n          (lines [board]\n            `(~@(rows board)\n              ~@(columns board)\n              ~(diag1 board)\n              ~(diag2 board)))\n\n          (winner-line? [player line]\n            (reduce (fn [result cell] (and result (= cell player))) true line))\n\n          (winner? [board player]\n            (not (empty? (filter (partial winner-line? player) (lines board)))))\n\n          (analyze [board]\n            (cond (winner? board :x) :x\n                  (winner? board :o) :o\n                  :else nil))]\n\n    (analyze board)))","user":"573b7ebbe4b0cd1946bd10a9"},{"problem":73,"code":"(fn who_won [board]\n    (let\n        [\n            cols (apply map list board)\n            diag_forward (map #(%1 %2) board (reverse (range (count board))))\n            diag_backward (map #(%1 %2) board (range (count board)))\n            all_possibilities (concat board cols [diag_forward diag_backward])\n        ]\n        (->> all_possibilities\n            (map set)\n            (filter #(= 1 (count %)))\n            (apply concat)\n            (some #(#{:o :x} %))\n        )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":73,"code":"(fn [[a b c]]\n  (let [l (set (conj (map vector a b c)\n                     a\n                     b\n                     c\n                     [(a 0) (b 1) (c 2)]\n                     [(a 2) (b 1) (c 0)]))]\n    (cond (l [:x :x :x])\n          :x\n          (l [:o :o :o])\n          :o)))","user":"5466aabbe4b01be26fd746e8"},{"problem":73,"code":"(fn [board]\n  (let [fb (flatten board)\n        wlines (for [[a b c] [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]] [(nth fb a) (nth fb b) (nth fb c)])]\n    (cond ((complement empty?) (filter #(= [:x :x :x] %) wlines)) :x\n          ((complement empty?) (filter #(= [:o :o :o] %) wlines)) :o\n          :else nil)))","user":"565a280be4b068f2fe63dbf7"},{"problem":73,"code":"(fn [[a b c]]\n  (some  \n(fn  [z ] (let [ x (set z ) ](if (= 1  (count x))(if (= :e (first x)) nil (first x))nil)))\n   [\n                   a \n                   b \n                   c \n                   [(first a) (first b) (first c)] \n                   [(second a) (second b) (second c)] \n                   [(nth a 2) (nth b 2) (nth c 2)] \n                   [(first a) (second b) (nth c 2 )] \n                   [(nth a 2) (second b) (first c) ] \n                   ]))","user":"57252172e4b0c5bde472c109"},{"code":"(fn [[v1 v2 v3]]\r\n  (let [three-same (fn [v] (= 1 (count (set v))))\r\n        coll (conj (map list v1 v2 v3)  \r\n                  v1 v2 v3 \r\n                  [(nth v1 0) (nth v2 1) (nth v3 2)]\r\n                  [(nth v1 2) (nth v2 1) (nth v3 0)]  )\r\n        _ (prn coll)]\r\n    (->> coll\r\n         (filter #(and (three-same %) (not= :e (first %))))\r\n        ffirst)))","problem":73,"user":"4def301c535d08e6dec9fe12"},{"problem":73,"code":"(fn [board]\n  (let [[r1 r2 r3] board\n        [a b c] r1\n        [d e f] r2\n        [g h i] r3\n        c1 [a d g]\n        c2 [b e h]\n        c3 [c f i]\n        d1 [a e i]\n        d2 [g e c]\n        three? (fn [row]\n                  (cond \n                    (every? #(= % :x) row) :x\n                    (every? #(= % :o) row) :o\n                    :else false)     )]\n    (->> [r1 r2 r3 c1 c2 c3 d1 d2]\n         (map three?)\n         (filter #(or (= % :x)\n                      (= % :o)))\n         first)))","user":"557e56aae4b05c286339e0d5"},{"problem":73,"code":"(fn winner [board]\n  (let [cols (apply map vector board)\n        rows board\n        bsize (count board)\n        diagnols [(vec (map #(get-in board %) (partition 2 (interleave (range bsize) (range bsize)))))\n                  (vec (map #(get-in board %) (partition 2 (interleave (range (dec  bsize) -1 -1) (range bsize)))))]\n        all-triples (filter #(not (contains? (set %) :e)) (lazy-cat rows cols diagnols))]\n    (first (first (drop-while #(not= (count (set %)) 1) all-triples)))))","user":"5b100648e4b0cc2b61a3be17"},{"problem":73,"code":"(fn win? [m]\n  (let [lines\n    (concat m    ; generate all \"lines\"\n            (apply map vector m)\n            [[(nth (nth m 0) 0) (nth (nth m 1) 1) (nth (nth m 2) 2)]\n             [(nth (nth m 0) 2) (nth (nth m 1) 1) (nth (nth m 2) 0)]])]\n    (->> lines (map set) (filter #(= 1 (count %))) (remove :e) first first)))","user":"53ecac57e4b0d648e757f4b3"},{"problem":73,"code":"(fn [board]\n  (let [rows    board\n        columns (for [col (range 3)] (map #(nth % col) board))\n        diags   (list\n                 (map #(get-in board [% %]) (range 3))\n                 (map #(get-in board [% (- 2 %)]) (range 3)))\n        all (concat rows columns diags)\n        winning-row? (fn [row] (and (not= :e (first row)) \n                                    (every? #(= % (first row)) row)))\n        winning-rows (filter winning-row? all)]\n    (first (first winning-rows))))","user":"553dd883e4b0a04f792994e6"},{"code":"(fn ttt [board]\n  (let [\n    eqOrNil (fn [lst]\n      (let [fst (first lst)]\n(cond\n  (apply = lst) (cond\n                  (= :e fst) nil\n                  :else fst\n  :else nil))))\n\n    transpose (fn transpose [lst i]\n      (cond\n        (neg? i) '()\n        :else (cons (map #(nth % i) lst)\n          (transpose lst (dec i)))))\n\n    check-cross (fn [board]\n      (let [\n        mid ((board 1) 1)\n        nw ((board 0) 0)\n        ne ((board 0) 2)\n        sw ((board 2) 0)\n        se ((board 2) 2) ]\n\n        (cond\n          (= mid :e) nil\n          (= mid nw se) mid\n          (= mid ne sw) mid\n          :else nil)))\n]\n  (first (filter #(not= nil %)\n    (into\n      (cons\n        (check-cross board)\n        (map eqOrNil (transpose board 2)))\n      (map eqOrNil board))))))","problem":73,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn [board]\n  (letfn [(alleq [xs]\n            (when (and (apply = xs)\n                       (not= :e (first xs)))\n              (first xs)))\n          (diag [matrix]\n            (map-indexed #(nth %2 %1) matrix))\n          (diags [matrix]\n            [(diag matrix) (diag (reverse matrix))])]\n    (some\n      alleq\n      (concat board\n              (apply map vector board)\n              (diags board)))))","problem":73,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"code":"(fn [b]\n  (letfn [(win [k]\n            (some #(every? #{k} %)\n              (concat b                                                    ; original board\n                (apply map vector b)                                       ; transposed\n                (vector (map #(nth %1 %2) b (range 3)))                    ; 1st diagonal\n                (vector (map #(nth %1 %2) b (reverse (range 3)))))))]      ; 2nd diagonal\n    (cond\n      (win :x) :x\n      (win :o) :o)))","problem":73,"user":"5164867fe4b003cf19fdde3e"},{"problem":73,"code":"(fn tic-tac-toe [[a b c]]\n   (letfn [(same? [[x y z]]\n             (cond \n               (= x y z) (if (= :e x)\n                           nil\n                           x)\n               :else :nil))]\n     (let [line? (list \n                   (same? a) (same? b) (same? c)\n                   (same? (map #(first %) [a b c]))\n                   (same? (map #(second %) [a b c]))\n                   (same? (map #(last %) [a b c]))\n                   (same? [(first a) (second b) (last c)])\n                   (same? [(first c) (second b) (last a)]))]\n       (cond\n         (not (empty? (filter #(= :o %) line?))) :o\n         (not (empty? (filter #(= :x %) line?))) :x\n         :else nil))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn [board]\n  (let [row-wins board\n        col-wins (apply map vector board)\n        top-bottom-diag-win [(map #(% %2) [first second last] board)]\n        bottom-top-diag-win [(map #(% %2) [last second first] board)]\n        win-configs (concat row-wins col-wins top-bottom-diag-win\n                            bottom-top-diag-win)]\n    (->> (map distinct win-configs)\n         (filter #(= 1 (count %)))\n         (flatten)\n         (into #{})\n         (some #{:x :o}))))","problem":73,"user":"515a6151e4b0394f658fe241"},{"code":"(fn[ss]\r\n  (let [\r\n  ok #(and (not (= (first %) :e)) (apply = %) (first %))\r\n]\r\n (or\r\n   (some ok (apply (partial map list) ss))\r\n   (some ok ss)\r\n(some ok [[((ss 0) 0) ((ss 1) 1) ((ss 2) 2)]\r\n          [((ss 0) 2) ((ss 1) 1) ((ss 2) 0)]])\r\n\r\n)\r\n))","problem":73,"user":"4dd66da7535d2dad7130b5c8"},{"problem":73,"code":"(fn [board]\n  (letfn [\n          (at [coord board] ((board (first coord)) (last coord)))\n          (row [tricoord board] (map #(at % board) tricoord))\n          (rows [tricoords board] (map #(row % board) tricoords))\n          ]\n    (first (first\n            (filter #(or (= [:x :x :x] %)\n                         (= [:o :o :o] %))\n                    (rows  [[[0 0] [0 1] [0 2]]\n                            [[1 0] [1 1] [1 2]]\n                            [[2 0] [2 1] [2 2]]\n\n                            [[0 0] [1 0] [2 0]]\n                            [[0 1] [1 1] [2 1]]\n                            [[0 2] [1 2] [2 2]]\n\n                            [[0 0] [1 1] [2 2]]\n                            [[2 0] [1 1] [0 2]]] board))))))","user":"5e078ba7e4b0978307768fb6"},{"problem":73,"code":"(fn tic-tac-toe-win [board]\n  (let [horizontal-winner (ffirst (filter (comp (partial = 1) count) (map distinct board)))\n        vertical-winner (ffirst (filter\n                                 (comp (partial = 1) count)\n                                 (apply map (fn [& bar] (distinct bar)) board)))\n        diagonal-winner (ffirst (filter (comp (partial = 1) count)\n                                        (map (comp\n                                              distinct\n                                              (partial map-indexed (fn [i row] (nth row i))))\n                                             [board (rseq board)])))]\n    (first (filter #{:x :o} [horizontal-winner vertical-winner diagonal-winner]))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [[[a b c :as u] [d e f :as v] [g h i :as w]]]\n  (let [p (fn [[x y z]] (if (and (not= x :e) (= x y z)) x))]\n    (first (filter identity (map p [u v w [a d g] [b e h] [c f i] [a e i] [c e g]])))))","problem":73,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn [[[r1c1 r1c2 r1c3] [r2c1 r2c2 r2c3] [r3c1 r3c2 r3c3]]]\n  (let [wins [[r1c1 r1c2 r1c3]    ; row 1\n              [r2c1 r2c2 r2c3]    ; row 2\n              [r3c1 r3c2 r3c3]    ; row 3\n              [r1c1 r2c1 r3c1]    ; col 1\n              [r1c2 r2c2 r3c2]    ; col 2\n              [r1c3 r2c3 r3c3]    ; col 3\n              [r1c1 r2c2 r3c3]    ; diag 1\n              [r1c3 r2c2 r3c1]]]  ; diag 2\n       (cond\n        (some #(every? (partial = :x) %) wins) :x\n        (some #(every? (partial = :o) %) wins) :o\n        :else nil)))","problem":73,"user":"4fe8a3bde4b07c9f6fd12c61"},{"problem":73,"code":"(fn tic-tac-toe [[[f1 f2 f3] [f4 f5 f6] [f7 f8 f9]]]\n  (let [positions [[f1 f2 f3] [f4 f5 f6] [f7 f8 f9]\n                   [f1 f5 f9] [f3 f5 f7]\n                   [f1 f4 f7] [f2 f5 f8] [f3 f6 f9]]]\n    (->> positions\n         (map #(when (apply = %) (first %)))\n         (remove #(or (nil? %) (= % :e)))\n         (first))))","user":"60849bd6e4b0736b099e42f2"},{"problem":73,"code":"(fn [board]\n\t(->>\n\t\t; generate a set of all rows, columns and the two diagonals\n\t\t(conj\n\t\t\t(set board) ; rows\n\t\t\t(map first board)      ; col 0\n\t\t\t(map second board)     ; col 1\n\t\t\t(map #(nth % 2) board) ; col 2\n\t\t\t(vector ((board 0) 0) ((board 1) 1) ((board 2) 2)) ; diagonal top left -> bottom right\n\t\t\t(vector ((board 0) 2) ((board 1) 1) ((board 2) 0)) ; diagonal top right -> bottom left\n\t\t)\n\n\t\t; filter duplicates in the vectors\n\t\t(map set)\n\n\t\t; then select all those of length 1 (those where all three cells are the same)\n\t\t(filter #(= (count %) 1))\n\n\t\t; filter those with :e\n\t\t(filter #(not= % #{:e}))\n\n\t\t; if any remains, return the first, otherwise nil (first (...) does precisely this)\n\t\t(first)\n\t\t(first)\n\t)\n)","user":"5f574662e4b0a0bc16850a90"},{"code":"#(some {[:x :x :x] :x [:o :o :o] :o}\r\n       (concat % (apply map list %) \r\n               (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\r\n                 (for [[x y] d] ((% x) y)))))","problem":73,"user":"4db858d1535d1e037afb218c"},{"code":"(fn winner[coll] \n          (let [my-keys \n                (fn[x, l]\n                  (let [keymap (map-indexed \n                    #(apply merge (map-indexed hash-map %2)) x) ] \n                     (map (fn[y](keep #(when (= (val %) l) (key %)) y)) keymap) ))\n                win (fn[x](let [y (sort (flatten x))\n                 [f s t] x]\n\t\t\t\t         (or (some #(= '(0 1 2) %) x)\n\t\t\t\t             (> (count (filter zero? y)) 2 ) \n\t\t\t\t             (> (count (filter #(= % 1) y)) 2 ) \n\t\t\t\t             (> (count (filter #(= % 2)  y)) 2 )\n\t\t\t\t             (and (some zero? f)\n\t\t\t\t                  (some #(= 1 %) s)\n\t\t\t\t                  (some #(= 2 %) t))\n\t\t\t\t             (and (some #(= 2 %) f)\n\t\t\t\t                  (some #(= 1 %) s)\n\t\t\t\t                  (some zero? t)                    \n\t\t\t\t             ))\n\t\t\t\t\t\t\t           )\n\t\t\t\t\t\t\t  )\n                \n                \n                xkeys (my-keys coll :x)\n                okeys (my-keys coll :o)]\n                 (if (win xkeys) :x \n                   (if (win okeys) :o nil ) \n      ))\n    )","problem":73,"user":"52d66ca0e4b09f7907dd135c"},{"code":"#(letfn \n  [(has-won [r x]\n    (reduce (fn [x y] (and x y)) (map (fn [z] (= z x)) r)))\n   (extract-row [b n]\n    (nth b n))\n   (extract-col [b n]\n    (map (fn [x] (nth x n)) b))\n  (extract-diagonals [b]\n    (reduce (fn [xs x] (conj xs (nth (extract-row b x) x))) [] (range (count b))))\n  (extract-diagonals-2 [b]\n    (reduce (fn [xs x] (conj xs (nth (extract-row b (first x)) (second x))))\n\t  [] (vec (zipmap (range (count b)) (reverse (range (count b)))))))\n   (win [b sym]\n    (reduce (fn [x y] (or x y)) false\n\t     (map (fn [x] (has-won x sym))\n\t\t    (concat [(extract-diagonals-2 b)\n\t\t\t           (extract-diagonals   b)]\n\t\t\t          (for [i (range (count b))]\n\t\t\t            (extract-row b i))\n\t\t\t          (for [i (range (count b))]\n\t\t\t            (extract-col b i))))))\n   (x-has-won [b] (if (win b :x) :x nil))\n   (o-has-won [b] (if (win b :o) :o nil))\n   (tic       [b] (or (x-has-won b) (o-has-won b)))]\n(tic %))","problem":73,"user":"4e273301535deb9a81d77ef7"},{"code":"(fn tic-tac-toe [board]\n  (let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n        rows (map same? board)\n        cols (map same? (apply map vector board))\n        diag1 (same? (map get board [0 1 2]))\n        diag2 (same? (map get board [2 1 0]))]\n    (some #{:x :o} (concat rows cols [diag1] [diag2]))))","problem":73,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn [board] (let [\n  horiz-win (fn [pos] \n    (if (= ((board (first pos)) (second pos)) \n      ((board (first pos)) (mod (+ (second pos) 1) 3))\n      ((board (first pos)) (mod (+ (second pos) 2) 3))\n      ) ((board (first pos)) (second pos)) nil\n    )\n  )\n  verti-win (fn [pos] \n    (if (= ((board (first pos)) (second pos))\n      ((board (mod (+ (first pos) 1) 3)) (second pos))\n      ((board (mod (+ (first pos) 2) 3)) (second pos))\n      ) ((board (first pos)) (second pos)) nil\n    )\n  )\n  main-diag (fn [pos] \n    (if (not= (first pos) (second pos)) nil\n      (if (= ((board (first pos)) (first pos))\n        ((board (mod (+ (first pos) 1) 3)) (mod (+ (first pos) 1) 3))\n        ((board (mod (+ (first pos) 2) 3)) (mod (+ (first pos) 2) 3))\n        ) ((board (first pos)) (first pos)) nil\n      )\n    )\n  )\n  off-diag (fn [pos] (if (not (= 2 (+ (first pos) (second pos)))) nil\n   (if (= ((board (first pos)) (second pos))\n    ((board (mod (+ (first pos) 1) 3)) (mod (- (second pos) 1) 3))\n    ((board (mod (+ (first pos) 2) 3)) (mod (- (second pos) 2) 3))\n    ) ((board (first pos)) (second pos)) nil\n   )\n   )\n  )]\n  (first \n   (filter (fn [z] (and (not (nil? z)) (not= z :e)))\n     (flatten \n      (for [x (range 3) y (range 3)] ((juxt horiz-win verti-win main-diag off-diag) [x y]))\n     )\n   )\n  )\n))","problem":73,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn tic-tac-toe [board]\n  ;; Validating the board by pre-condition:\n  {:pre [(= 3 (count board)),                 ; The board has 3 rows.\n         (every? #(= 3 (count %)) board),     ; Each row has 3 entries.\n         (every? (partial every? #{:x :o :e})\n                 board),                      ; Each entry is :x, :o, or :e.\n         ;; And the number of :x's is either equal to the number of :o's,\n         ;; or exactly one greater:\n         (let [count-piece\n               (fn [sym] (sym (frequencies (flatten board))))]\n           (or (= (count-piece :x) (count-piece :o))\n               (= (count-piece :x) (inc (count-piece :o)))))]}\n\n  ;; Now that we know the board is structurally correct, we create some tools to\n  ;; analyze it:\n\n  (let [;; It will be convenient to work with the board in the form of a single\n        ;; vector, so that we can address positions by index as in the diagram:\n        ;;   [[0 1 2]\n        ;;    [3 4 5]\n        ;;    [6 7 8]]\n        flat-board (->> board flatten vec),\n\n        ;; There are only eight winning positions in tic-tac-toe; if a player\n        ;; occupies all three entries in a given position, that player has\n        ;; won. This set enumerates them all.\n        wins #{[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]},\n\n        ;; The check-pos function wraps one of these winning positions in a\n        ;; predicate that returns :x or :o in the case of a win by that\n        ;; position, and nil otherwise.\n        check-pos (fn [[a b c :as pos]]\n                    (cond\n                      (apply not= (map flat-board pos))  nil\n                      (= (flat-board a) :e)              nil\n                      :else                              (flat-board a)))]\n\n    ;; And now it's just a matter of checking all positions.\n    (some check-pos wins)))","problem":73,"user":"4fc6305de4b0ee37620e180b"},{"code":"#(let [[_ & [_ & e :as d] :as c] (apply concat %)]\n  (some (fn [[x y z]] (and (= x y z) (#{:o :x} x)))\n    (concat % (map take-nth [3 3 3 4 2] [c d e c e]))))","problem":73,"user":"4e8f1ac6535d65386fec2146"},{"problem":73,"code":"(fn b [board]\n (let [same? (fn [sq] (if (apply = sq) (first sq) nil))\n        \n    rows (map same? board)\n    cols (map same? (apply map vector board))\n    fcl (same? (map get board (range 3)))\n    lcl (same? (map get board (range 2 -1 -1)))\n    ]\n    (some #{:x :o} (concat rows cols [fcl] [lcl]))\n    )\n)","user":"5fe09d1fe4b05ac5b16ea15b"},{"problem":73,"code":"(fn winner [ board ] \n  (let [d1 [(map get board [0 1 2])]\n        d2 [(map get board [2 1 0])]\n        all (concat board (apply map vector board) d1 d2)\n       \twin (set (map set all))\n        ]\n    (cond \n   \t (contains? win #{:x}) :x\n   \t (contains? win #{:o}) :o\n     :else nil\n    )\n ))","user":"57887de2e4b0ebec4cfb751c"},{"problem":73,"code":"(fn [board] (let [checktriple (fn [[a b c]] (if (and (= a b) (= a c) (not (= a :e)))\n                                            a\n                                            nil))\n                  checkrow (fn [n] (checktriple (get board n)))\n                  checkcol (fn [n] (checktriple (map #(get (get board %) n) (range 3))))\n                  diag1 (checktriple (map #(get (get board %) %) (range 3)))\n                  diag2 (checktriple (map #(get (get board %) (- 2 %)) (range 3)))]\n              (first (filter identity (concat [diag1 diag2] (map checkrow (range 3)) (map checkcol (range 3)))))))","user":"5e6ba862e4b04a83ad7cd27d"},{"code":"(fn [b]\n  (let [s? (fn [r s] (every? #(= % s) r))\n        hm (fn [bo s] (some (fn [r] (s? r s)) bo))]\n  (first (filter (fn [s]\n            (or (hm b s)\n                (hm (map (fn [i] (map #(nth % i) b)) (range 3)) s)\n                (s? (map (fn [i] (nth (nth b i) i)) (range 3)) s)\n                (s? (map (fn [i] (nth (nth b i) (- 2 i))) (range 3)) s))) [:x :o]))))","problem":73,"user":"4e773be8535d324fb2983d6e"},{"problem":73,"code":"(fn [m]\n  (let [positions [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] [[0 0] [1 1] [2 2]] [[0 2] [1 1] [0 2]]]]\n    (some (fn [l]\n            (let [result (map #(get-in m %) l)]\n              (cond\n                (every? #(= :o %) result) :o\n                (every? #(= :x %) result) :x)\n              )) positions)))","user":"50f10f7be4b06d9538fe211a"},{"problem":73,"code":"(fn [m]\n  (first\n    (filter\n      (fn win? [player]\n        (->> (let [idx [0 1 2]]\n                (concat m                               \n                  (map (fn [i] (map #(% i) m)) idx)     \n                  (vector (map #((m %) %) idx))         \n                  (vector (map #((m (- 2 %)) %) idx)))) \n             (map (fn [row] (count (filter #(= player %) row))))\n             (filter #(= % 3))\n             seq))\n      [:x :o])))","user":"56f4623ae4b046a417f9205d"},{"code":"(fn tic-tac-toe1 [sq]\n  (let [size (count sq)\n        diag1 (for [a (range size) b (range size)\n                         :when (= (dec size) (+ a b))]\n                     (get-in sq [a b]))\n        diag2 (map #(get-in sq  [% %]) (range size))\n        lines (-> sq (concat (apply map vector sq)) (conj diag1 diag2))\n        winner (fn[coll] (if (and (#{:o :x} (first coll)) (apply = coll))\n                           (first coll)))]\n    (some winner lines)))","problem":73,"user":"4f1ef6a0535d64f60314649b"},{"problem":73,"code":"(fn [table] (first (first\n (filter #(or (every? (partial = :x) %) (every? (partial = :o) %)) \n (into table (map \n (fn [is](map (fn [x i] (nth x i))\n           table is))\n  (conj  (map #(repeat 3 %) (range 3))  \n   (range 3) \n   (reverse (range 3)))\n  )   \n       ))\n  ))\n  )","user":"50856bd1e4b004985b776e4c"},{"problem":73,"code":"(fn compute-winner\n  [board]\n  (let [board-size (count board)\n        board-indices (range board-size)\n        column-coords (mapv\n                       (fn [col-index]\n                         [board-indices (repeat board-size col-index)])\n                       board-indices)\n        diag-coords [[board-indices board-indices]\n                     [board-indices (reverse board-indices)]]                \n        cols-and-diags (mapv\n                        (fn [[row-indices col-indices]] \n                          (mapv\n                           (fn [row-index col-index]\n                             (get-in board [row-index col-index]))\n                           row-indices \n                           col-indices))\n                        (concat column-coords diag-coords))\n        lines (concat board cols-and-diags)]\n    (some \n     (fn [line]\n       (cond\n         (every? #{:x} line) :x\n         (every? #{:o} line) :o\n         :else nil))\n     lines)))","user":"53de7484e4b0d874e779ae35"},{"problem":73,"code":"(fn [board]\n  (let [\n        transposed (apply (partial map vector) board)\n        flipped (reverse board)\n        row-of      (fn [b s] (when (some (fn [row] (every? #(= s %) row)) b) s))\n        ldiag-of    (fn [b s] (when (every? #(= s %) (map nth b (range))) s))\n        won         (fn [s] (some identity [(row-of board s) (row-of transposed s) (ldiag-of board s) (ldiag-of flipped s)]))]\n        (some won [:x :o])\n    ))","user":"57717915e4b0979f896515b3"},{"problem":73,"code":"(fn [b]\n  (let [diag [ [[0 0][1 1][2 2]] [[0 2][1 1][2 0]] ]\n        cols (map #(map vector (range 3) (repeat %)) (range 3))\n        rows (map #(map vector (repeat %) (range 3)) (range 3))\n        _all (concat diag rows cols)\n        coord-> (fn [b x y] (get (get b y) x))\n        check-all (fn [b sq] (map (fn [l] (map #(apply coord-> b %) l)) sq))\n        _result (check-all b _all)]\n    (cond\n      (some #(every? #{:x} %) _result)\n      :x\n\n      (some #(every? #{:o} %) _result)\n      :o\n\n      :else nil)))","user":"5ecc0831e4b016b56eae058c"},{"code":"(fn [board]\n  (let [ cols (for [i (range 3)] (map #(nth % i) board))\n        diags [(for [i (range 3)]\n                 (nth (nth  board i) i))\n               (for [i (range 3)]\n                 (nth (nth board i) (- 2 i)))]\n        parts (concat board cols diags)\n        wins (->> parts (map distinct)\n                  (filter #(= 1 (count %))) (map #(nth % 0))\n                  (filter #(not= :e %)))\n        nwins (count (filter #(not= :e %) wins))]\n    (if (= 1 nwins) (first wins))))","problem":73,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [[[a b c]\r\n      [d e f]\r\n      [g h i]]]\r\n  (nth (some #{[:x :x :x]\r\n               [:o :o :o]}\r\n         (partition 3 [a b c, d e f, g h i,\r\n                       a d g, b e h, c f i,\r\n                       a e i, c e g]))\r\n       0))","problem":73,"user":"4f890488e4b033992c121c76"},{"problem":73,"code":"(fn tic-tac-toe-winner [board]\n  (letfn [(line-winner [line]\n            (if (apply = line) (first line) nil))]\n    (let [rows (map line-winner board)\n          cols (map line-winner (apply map vector board))\n          diag-1 (line-winner (map get board (range 3)))\n          diag-2 (line-winner (map get board (range 2 -1 -1)))]\n      (some #{:x :o} (concat rows cols [diag-1] [diag-2])))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn [seq]\n  (let [test (conj seq\n    (map first seq)\n    (map second seq)\n    (map last seq)\n    (map #(get %2 %) [0 1 2] seq)\n    (map #(get %2 %) [2 1 0] seq))]\n    (first \n    (first \n    (filter \n    #(apply = %) \n    (filter (fn [s] (not(some #(= :e %) s))) test\n    ))))))","problem":73,"user":"4f0446f9535dcb61093f6bb8"},{"code":"#_ (fn ttt [rows]\n  (let [\n    board (apply concat rows)\n    rboard (apply concat (reverse rows))\n    cols (map #(take-nth 3 (drop % board)) [0 1 2])\n    diagonals [\n      (take-nth 4 board)\n      (take-nth 4 rboard)]\n    all (set (concat rows cols diagonals))]\n    (cond\n      (all [:x :x :x]) :x\n      (all [:o :o :o]) :o\n      :else nil)))\n\n(fn ttt [rows]\n  (first (some #{[:x :x :x] [:o :o :o]}\n    (concat\n      rows\n      (apply map list rows) \n      [(map #(%2 %) [0 1 2] rows)]\n      [(map #(%2 (- 2 %)) [0 1 2] rows)]))))","problem":73,"user":"4fe8b6afe4b07c9f6fd12c76"},{"code":"(fn tic-tac-toe [board]\n    (letfn [(winner [row]\n              (cond\n                (every? #(= % :x) row) :x\n                (every? #(= % :o) row) :o\n                :else nil\n                ))\n            (lines [board]\n              (conj board\n                    (map #(nth % 0) board)\n                    (map #(nth % 1) board)\n                    (map #(nth % 2) board)\n                    (list (nth (nth board 0) 0)\n                          (nth (nth board 1) 1)\n                          (nth (nth board 2) 2))\n                    (list (nth (nth board 0) 2)\n                          (nth (nth board 1) 1)\n                          (nth (nth board 2) 0))))]\n      (let [winners (map winner (lines board))]\n        (if (some #{:o} winners)\n          (if (some #{:x} winners)\n            nil\n            :o\n            )\n          (if (some #{:x} winners)\n            :x\n            nil\n            )))))","problem":73,"user":"4f039524535dcb61093f6b2c"},{"problem":73,"code":"(fn  [xs]\n  (let [idx (range 3)\n        win? #(and (= 1 (count %))\n                   (not= :e (first %))) ]\n    (first (first \n             (filter win? (concat (map set (for [i idx] (map #(nth % i) xs)))  \n                                  (map set xs)\n                                  [(set (for [i idx] (get-in xs [i, i])))]\n                                  [(set (for [i idx] (get-in xs [i, (- 2 i )])))] ))))))","user":"55c423e1e4b0e31453f64994"},{"problem":73,"code":"(fn [ bd ]\n  (->>\n     (-> bd\n         (into (apply map vector bd))\n         (conj (for [ x (range 3)] (nth (nth bd x) x)))\n         (conj (for [ [x y] (map vector (range 3) (range 2 -1 -1))] (nth (nth bd x) y)))\n         (seq))\n     (map set)\n     (filter #(= 1 (count %)))\n     (#(cond (empty? %) nil\n             (= 8 (count %)) nil \n            true (first (first %))))))","user":"5398305fe4b0b51d73faaef6"},{"code":"(fn tic-tac-toe [t]\n  (let [wins #{7 56 448 73 146 292 273 84}\n        serie-of-bin (iterate (partial * 2) 1)\n        flat (flatten t)\n        mapper (fn [xo] #(if (= %1 xo) 1 0))\n        reducer (fn [ss] (reduce #(+ %1 (apply * %2)) 0 (map vector ss serie-of-bin)))\n        xs (map (mapper :x) flat)\n        ys (map (mapper :o) flat)\n        xres (reducer xs)\n        yres (reducer ys)\n        checker (fn [res] (some zero? (map #(bit-and-not %1 res) wins)))\n        ]\n    (if (checker xres)\n      :x\n      (if (checker yres)\n        :o\n        nil)\n    )\n  ))","problem":73,"user":"5094057fe4b097f48cc38593"},{"code":"(fn [col]\n  (letfn [(check [posl]\n                 (reduce (fn [ret c] (let [[x y z] c] \n                                       (if (and (= x y z)\n                                                (or (= x :x )\n                                                    (= x :o ))\n                                                )\n                                         x ret)))\n                         nil posl))\n          (intlv [col]\n                 (partition 3 (apply interleave col)))\n          \n          (diag [col]\n                (for [x [0 1 2]] (nth (nth col x) x)))\n          (rdiag [col]\n                 (for [x [0 1 2]] (nth (nth col x) (- 2 x))))\n          ]\n    (if-let [ret (check col)]\n      ret\n      (if-let [ret (check (intlv col))]\n        ret\n        (if-let [ret (check (vector (diag col)))]\n          ret\n          (if-let [ret (check (vector (rdiag col)))]\n            ret\n            nil))))))","problem":73,"user":"513cb853e4b0b86ece9f322b"},{"problem":73,"code":"(fn [b]\n  (let [p (conj b (map first b))\n        q (conj p (map second b))\n        r (conj q (map #(get % 2) b))\n        s (conj r (for [z [0 1 2]]\n                    (get-in b [z z])))\n        t (conj s (for [z [2 1 0]]\n                    (get-in b [(- 2 z) z])))\n        u (fn [z] (= [:x :x :x] z))\n        v (fn [z] (= [:o :o :o] z))\n        w (map u t)\n        x (map v t)]\n    (cond (some true? w) :x\n          (some true? x) :o\n          :else nil)))","user":"4f037faf535dcb61093f6af8"},{"problem":73,"code":"(fn [b]\n  (let [ss ( ->>\n             (vector (vec (for [x [0 1 2] y [0 1 2] :when (= x y)] [x y])))\n             (concat (vector (vec (for [x [0 1 2] y [0 1 2] :when (= (+ x y) 2)] [x y]))))\n             (concat (for [x [0 1 2]] [[0 x] [1 x] [2 x]]))\n             (concat (for [x [0 1 2]] [[x 0] [x 1] [x 2]])))]\n    (letfn [\n            (eval-s [k]\n              (reduce \n                (fn [acc s]\n                  (or acc\n                      (let [p0 (get s 0) p1 (get s 1) p2 (get s 2)\n                            v0 ((get b (get p0 0)) (get p0 1))\n                            v1 ((get b (get p1 0)) (get p1 1))\n                            v2 ((get b (get p2 0)) (get p2 1))]\n                        (= k v0 v1 v2)))) false ss))]\n      (cond\n        (eval-s :x) :x\n        (eval-s :o) :o\n        :default nil))))","user":"57d9bca1e4b0bd073c202405"},{"problem":73,"code":"(fn [board]\n    (let [get-diag (fn [row c] (row c))\n        win? (fn [row]\n               (and (every? (fn [[x y]] (= x y))\n                            (map vector row (rest row)))\n                    (#{:x :o} (first row))))\n        rows board\n        cols (map (fn [c] (map (fn [row] (row c)) rows))\n                  (range 3))\n        diags (list (map get-diag rows (range 3))\n                    (map get-diag rows (reverse (range 3))))]\n\n    (ffirst (filter win?\n                    (concat rows cols diags)))))","user":"5427962de4b01498b1a71b26"},{"problem":73,"code":"(fn [coll]\n   (if (and (not= (first(first coll)) :e)(and (identical? (first (first coll)) (second (first coll))) (identical? (first (first coll)) (last (first coll)))))\n     (first (first coll))\n     \n     (if (and (not= (first(second coll)) :e)(and (identical? (first (second coll)) (second (second coll))) (identical? (first (second coll)) (last (second coll)))))\n       (first (second coll))\n       \n       (if (and (not= (first(last coll)) :e)(and (identical? (first (last coll)) (second (last coll))) (identical? (first (last coll)) (last (last coll)))))\n         (first (last coll))\n\n         (if (and (not= (first(first coll)) :e)(and (identical? (first (first coll)) (first (second coll))) (identical? (first (first coll)) (first (last coll)))))\n           (first (first coll))\n\n           (if (and (not= (second(first coll)) :e)(and (identical? (second (first coll)) (second (second coll))) (identical? (second (first coll)) (second (last coll)))))\n             (second (first coll))\n\n             (if (and (not= (last(first coll)) :e)(and (identical? (last (first coll)) (last (second coll))) (identical? (last (first coll)) (last (last coll)))))\n               (last (first coll))\n                \n               (if (and (not= (first(first coll)) :e)(and (identical? (first (first coll)) (second (second coll))) (identical? (first (first coll)) (last (last coll)))))\n                 (first (first coll))\n\n                 (if (and (not= (last(first coll)) :e)(and (identical? (last (first coll)) (second (second coll))) (identical? (last (first coll)) (first (last coll)))))\n                   (last (first coll))\n                   \n                   nil)))))))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":73,"code":"(fn [rect]\n  (->>\n   (apply map vector rect)\n   (#(conj % (reduce (fn [init row-coll] (conj init (nth row-coll (count init)))) [] rect)))\n   (#(conj % (reduce (fn [init row-coll] (conj init (nth row-coll (- (count row-coll) (count init) 1)))) [] rect)))\n   (#(filter (fn [coll] (apply = coll)) (concat rect %)))\n   first\n   first\n   (#(if (= % :e) nil %))))","user":"591072e0e4b0163c97b36ebc"},{"problem":73,"code":"(fn __ [board]\n(let [\n      cart-prod (fn [s1 s2] (for [x s1 y s2] [x y]))\n      vec-plus (fn [v1 v2] (map + v1 v2)) \n      in-bounds (fn [[x y]] (and (>= x 0) (>= y 0) (<= x 2) (<= y 2)))\n      starts [[0 0] [0 1] [0 2] [1 0] [2 0]]\n      r (range -1 2)\n      moves (remove #(= [0 0] %) (distinct (cart-prod r r)))\n      allowed-moves (fn [loc] (filter #(in-bounds (vec-plus loc %)) moves))\n      allowed-by-st (map allowed-moves starts)\n      path-by-st (fn [st al-mo] (for [m al-mo] (take 3 (iterate #(vec-plus m %) st))))\n      paths (mapcat identity (map path-by-st starts allowed-by-st))\n      board-paths (map (partial map (partial get-in board)) paths)\n      \n      ]\n;;       (path-by-st (first starts) (first allowed-by-st))\n                                      \n      (condp (fn [v paths] (some #(= % v) paths)) board-paths\n        [:x :x :x] :x\n        [:o :o :o] :o\n        nil)\n;;       (first board-paths)\n;;       (first paths)\n;;         paths\n;;       (path-by-st (first starts) (first allowed-by-st))\n      \n  \n     \n  ))","user":"54924f64e4b0b312c081ff42"},{"code":"(fn [[[c11 c12 c13] [c21 c22 c23] [c31 c32 c33]]]\r\n  (let\r\n    [winlines [[c11 c12 c13] [c21 c22 c23] [c31 c32 c33] [c11 c21 c31] [c12 c22 c32] [c13 c23 c33] [c11 c22 c33] [c13 c22 c13]]\r\n     wins (map #(first %) (filter #(apply = %) winlines))]\r\n  (cond\r\n      (some #(= :x %) wins) :x\r\n      (some #(= :o %) wins) :o\r\n)))","problem":73,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":73,"code":"(fn tic-tac-toe [[[a1 b1 c1] [a2 b2 c2] [a3 b3 c3]]]\n  (letfn [(winner [[a b c]] (when (= a b c) (#{:x :o} a)))]\n   (some winner\n         [[a1 b1 c1]\n          [a2 b2 c2]\n          [a3 b3 c3]\n          [a1 a2 a3]\n          [b1 b2 b3]\n          [c1 c2 c3]\n          [a1 b2 c3]\n          [a3 b2 c1]])))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":73,"code":"(fn [board] (first (filter (fn [player]\n  (letfn [(diag [bd] (every? #(= player %) (map-indexed #(%2 %1) bd)))]\n    (or\n      (some (partial every? #(= player %)) board)\n      (some (fn [n] (every? #(= (% n) player) board)) (vec (range 3)))\n      (diag board)\n      (diag (map (comp vec reverse) board))))) [:x :o])))","user":"5ab5f60be4b073f177442643"},{"code":"(letfn [(diags [b]\n               [(map #(get-in b [% %]) [0 1 2])\n                (map #(get-in b [% (- 2 %)]) [0 1 2])])\n        (cols [b]\n              (apply map vector b))\n        (rows [b] b)\n        (winner [r] (cond\n                     (apply = :o r) :o\n                     (apply = :x r) :x))]\n  (fn win? [board]\n   (some identity (map winner (concat (diags board) (cols board) (rows board))))))","problem":73,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn [[a b c :as rows]] ;should work for any sensible n\n  (letfn [(win [v] (if (and (= 1 (count (distinct v))) (not= :e (first v))) (first v)))]\n    (let [cols (apply map vector rows)\n\t\t  d1 (map #(nth % %2) rows (range))\n          d2 (map #(nth % %2) rows (range (dec (count a)) -1 -1))\n          diags [d1 d2]]\n      (->>\n       (concat rows cols diags)\n       (keep win)\n       first))))","problem":73,"user":"51efd397e4b0249c592fbdeb"},{"problem":73,"code":"(fn analyze-tic-tac-toe-board\n [rows]\n  (let [columns (apply map (fn [& args] args) rows)\n        diag1 (map (fn [row index] (nth row index)) rows (range))\n        diag2 (map (fn [row index] (nth (reverse row) index)) rows (range))\n        all (concat rows columns (vector diag1 diag2))\n        all-items-are-the-same? (fn [coll] (= 1 (count (set coll))))\n        winner (first (first (filter #(not= :e (first %)) (filter all-items-are-the-same? all))))]\n    winner))","user":"5e805895e4b085ba37836e44"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (let [s [[a b c]\n           [d e f]\n           [g h i]\n           [a d g]\n           [b e h]\n           [c f i]\n           [a e i]\n           [g e c]]]\n    (some {[:x :x :x] :x\n           [:o :o :o] :o} s)))","problem":73,"user":"4fccf4dae4b0ee37620e186f"},{"code":"#(some\n  {#{:x} :x #{:o} :o}\n  (map set `[~@%\n             ~@(apply map list %)\n             ~(map nth % [0 1 2])\n             ~(map nth % [2 1 0])]))","problem":73,"user":"4f38b7d9e4b0e243712b1ee0"},{"problem":73,"code":"(fn [board]\n\n  (let [get-col (fn [n & coll]\n                  (flatten (map #(vector (nth % n)) coll)))\n\n        check-win (fn [coll]\n                    (cond\n                      (every? #(= :x %) coll) :x\n                      (every? #(= :o %) coll) :o\n                      :else nil))\n\n        check-horizontal (fn [board] (map check-win board))\n\n        check-vertical (fn [board] (map check-win\n                                        (for [x (range 0 (count board))]\n                                          (flatten (map (partial get-col x) board)))))\n\n        check-diagonal (fn [board] (->> board\n                                        (map-indexed #(get %2 %1))\n                                        check-win))\n\n        check-diagonal-reverse (fn [board] (->> board (mapv (comp vec reverse)) check-diagonal))\n\n        check-fns [check-horizontal check-vertical check-diagonal check-diagonal-reverse]\n        stuff (map #(% board) check-fns)]\n\n     (->> stuff flatten (remove nil?) first)))","user":"58bdb36fe4b0888cdc949d35"},{"code":"(fn [rows]\n\t(-> []\n\t\t(into rows)\n\t\t(into (apply map vector rows))\n\t\t(conj (for [[i r] (zipmap (range 3)  rows) ] (nth r i))\n\t\t\t  (for [[i r] (zipmap (range 3) (reverse rows)) ] (nth r i)))\n\t\t((fn [cn] (filter #(and (= (repeat 3 (first %)) %) (not= (first %) :e)) cn)))\n\t\t(#(if (nil? (first %)) nil (first(first %))))\n))","problem":73,"user":"52bf6946e4b07a9af5792334"},{"problem":73,"code":"(fn solve [x]\n  (let [[[a b c]\n         [d e f] \n         [g h i]] x\n        solutions-set (set\n                       (vector\n                        [a b c]\n                        [d e f]\n                        [g h i]\n                        [a d g]\n                        [b e h]\n                        [c f i]\n                        [a e i]\n                        [c e g]))]\n    (cond\n      (contains? solutions-set [:x :x :x]) :x\n      (contains? solutions-set [:o :o :o]) :o\n      :else nil)))","user":"56f029cde4b04a395b9a0471"},{"problem":73,"code":"(fn tic-tac-toe [[v1 v2 v3 :as board]]\n  (first (first\n  (filter #((fn won? [v]\n              (let [reduced (distinct v)]\n                (if (and (== 1 (count reduced))\n                         (not (= :e (first reduced))))\n                  (first reduced)))) %)\n          (concat board [[(first v1)(second v2)(last v3)][(first v3)(second v2)(last v1)]]\n                  (map vector v1 v2 v3))))))","user":"525d44bfe4b0cb4875a45d6d"},{"problem":73,"code":"(fn [rs] \n          \n          (let \n            \n            [is_same (fn [a b c] (and (= a b c) (not (= :e a))))\n             [r1 r2 r3] rs\n               [r11 r12 r13] r1\n               [r21 r22 r23] r2\n               [r31 r32 r33] r3]\n            \n            (cond (is_same r11 r21 r31) r31\n                  (is_same r12 r22 r32) r32\n                  (is_same r13 r23 r33) r33\n                  (is_same r11 r12 r13) r11\n                  (is_same r21 r22 r23) r23\n                  (is_same r31 r32 r33) r33\n                  (is_same r11 r22 r33) r33\n                  (is_same r31 r22 r13) r13\n            \n            )))","user":"4ea882c7535d7eef308072fc"},{"problem":73,"code":"(fn winner [m]\n  (let [all (concat m\n                    (vector (map nth m [0 1 2]))\n                    (vector (map nth m [2 1 0]))\n                    (apply map vector m))\n        vf (set (flatten (filter #(apply = %) all)))\n        vf2 (filter #{:o :x} vf)]\n    (if (empty? vf2)\n      nil\n      (first vf2))))","user":"4dd6d7ee535d2dad7130b5cb"},{"code":"(letfn [(rows [b] b)\n        (cols [b] (apply map list b))\n        (diags [b] [[(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])]\n                    [(get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])]])\n        (wins? [p b] (some #(every? #{p} %) (concat (rows b) (cols b) (diags b))))]\n  (fn [board] (cond\n               (wins? :x board) :x\n               (wins? :o board) :o)))","problem":73,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":73,"code":"(fn winner? [table]\n  (let [get-table-value (fn [x y]\n                          (-> table\n                            (nth y)\n                            (nth x)))\n        collect (fn [xs]\n                  (->> xs\n                    (map (fn [f] (for [x (range 3)\n                                       y (range 3)\n                                       :when (f x y)] (get-table-value x y))))\n                    (filter (partial apply =))\n                    (map first)\n                    (remove (partial = :e))\n                    first))\n        fix-x (fn [c]\n                (fn [x y] (= x c)))\n        fix-y  (fn [c]\n                (fn [x y] (= y c)))\n        fixes (fn [f] (map (fn [x] (f x)) (range 3)))\n        diag1 (fn [x y] (= x y))\n        diag2 (fn [x y] (= x (- 2 y)))\n        filters (concat [diag1 diag2]\n                       (fixes fix-x)\n                       (fixes fix-y))]\n    (collect filters)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":73,"code":"(fn [x]\n    (letfn [(three? [b t]\n              (some true? (map #(every? #{t} %) b)))\n            (transpose [b]\n              (apply map vector b))\n            (diagonal [b]\n              [(map #(nth %1 %2) b (range))\n               (map #(nth %1 (- (dec (count %1)) %2)) b (range))])]\n      (cond\n        (or (three? x :x)\n            (three? (transpose x) :x)\n            (three? (diagonal x) :x)) :x\n        (or (three? x :o)\n            (three? (transpose x) :o)\n            (three? (diagonal x) :o)) :o\n        :else nil)))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":73,"code":"(fn tic-tac [board]\n  (let [tic #(get-in board [%1 %2])\n        r-l [(tic 0 2) (tic 1 1) (tic 2 0)]\n        l-r (map #(tic % %) (range 3))\n        col (fn [j]\n              (map #(tic % j) (range 3)))\n        check (fn [coll]\n                (when (apply = coll)\n                  (some #{:x :o} coll)))\n        coll (apply conj board r-l l-r (map col (range 3)))]\n      (some check coll)))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [board]\n    (let [triples\n          (fn [board]\n            (map #(map (partial get-in board) %)\n                 (concat\n                  (for [x [0 1 2]]\n                    [[x 0] [x 1] [x 2]])\n                  (for [y [0 1 2]]\n                    [[0 y] [1 y] [2 y]])  \n                  [[[0 0] [1 1] [2 2]]\n                  [[0 2] [1 1] [2 0]]]\n                  )))\n\n\n         ]\n      (ffirst (filter #(or (= [:o :o :o] %)\n                           (= [:x :x :x] %))\n                      (triples board)))\n      )\n    )","problem":73,"user":"4daea889edd6309eace4d15b"},{"problem":73,"code":"(fn [rows]\n  (let [third (fn [c] (second (next c)))\n        transpose (fn [m] (apply mapv vector m))\n        cols (transpose rows)\n        diag1 [(get (first rows) 0)\n               (get (second rows) 1)\n               (get (third rows) 2)]\n        diag2 [(get (first rows) 2)\n               (get (second rows) 1)\n               (get (third rows) 0)]\n        has-triple (fn [b e] (boolean (some #(= % (vec (repeat 3 e))) b)))\n        all (conj (concat rows cols) diag1 diag2)]\n    (cond\n      (has-triple all :x) :x\n      (has-triple all :o) :o\n      :else nil)))","user":"54d000c7e4b018d918be98d7"},{"problem":73,"code":"(fn [[top mid bot]]\n      (let [topwin (distinct top)\n            midwin (distinct mid)\n            botwin (distinct bot)\n            leftwin (distinct (map first [top mid bot]))\n            cenwin (distinct (map second [top mid bot]))\n            rightwin (distinct (map last [top mid bot]))\n            crosswin (distinct [(top 0) (mid 1) (bot 2)])\n            othercrosswin (distinct [(top 2) (mid 1) (bot 0)])]\n        (reduce #(if (or (= '(:x) %2) (= '(:o) %2)) (first %2) %1) nil (list topwin midwin botwin leftwin cenwin rightwin crosswin othercrosswin))))","user":"54d9366ce4b0a52adc2e204e"},{"problem":73,"code":"(fn [board]\n  (let [boardSize         (count board)\n        transposedBoard   (apply mapv vector board)\n        lineWinner        (fn [line]\n                            (let [player (first line)]\n                              (and (not= player :e)\n                                   (= boardSize (count (filter #(= % player) line)))\n                                   player)))\n        rowWinner         #(lineWinner (board %))\n        columnWinner      #(lineWinner (transposedBoard %))\n        transversalWinner #(lineWinner (if (= 0 %)\n                                         [((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                                         [((board 2) 0) ((board 1) 1) ((board 0) 2)]))]\n    (some #(or\n             (rowWinner         %)\n             (columnWinner      %)\n             (transversalWinner %))\n          (range boardSize))\n))","user":"5954cea2e4b066ee0a44af0a"},{"code":"(fn [rows]\n  (first\n   (some #(#{#{:x} #{:o}} (into #{} %))\n         (concat rows\n                 (partition 3 (apply interleave rows))\n                 (map #(map (partial get-in rows) %)\n                      [[[0 0] [1 1] [2 2]]\n                       [[0 2] [1 1] [2 0]]])))))","problem":73,"user":"4f3e5e87e4b0e243712b1f83"},{"code":"#(letfn [(f [a]\n             (condp every? a\n               #{:x} :x\n               #{:o} :o\n               nil))\n           (c [a n]\n             (map (fn [r] (r n)) a))]\n     (or\n       (f (% 0)) (f (% 1)) (f (% 2))\n       (f (c % 0)) (f (c % 1)) (f (c % 2))\n       (f [((% 0) 0) ((% 1) 1) ((% 2) 2)])\n       (f [((% 0) 2) ((% 1) 1) ((% 2) 0)])))","problem":73,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":73,"code":"(fn [board]\n  (let [getCol   #(list (nth (first board) %) (nth (second board) %) (nth (last board) %))\n        leftDiag  (list (first (first board)) (second (second board)) (last (last board)))\n        rightDiag (list (last (first board)) (second (second board)) (first (last board)))\n        check #(cond\n                (apply = (conj % :x)) :x\n                (apply = (conj % :o)) :o\n                :else nil)]\n    (or\n     (check (first board))\n     (check (second board))\n     (check (last board))\n     (check (getCol 0))\n     (check (getCol 1))\n     (check (getCol 2))\n     (check leftDiag)\n     (check rightDiag))))","user":"5e909685e4b0cb016954634d"},{"problem":73,"code":"(fn [ board]\n  (loop [x (range 3) y (range 3)]\n    (if (empty? x)\n      (if (= 1 (count y))\n        nil\n        (recur (range 3) (drop 1 y)))\n      (let [xpos (first x) ypos (first y) sign (get-in board [ypos xpos])]\n        (if (not (= :e sign))\n          (if (loop [incs [[2 1] [1 -1] [-1 -2]] pairs [[0 1] [1 0] [1 1] [-1 1]]]\n                (if (empty? incs)\n                  (if (= 1 (count pairs))\n                    false\n                    (recur [[2 1] [1 -1] [-1 -2]] (into [] (drop 1 pairs)) ))\n                  (let [x1 (+ xpos (* (get-in incs [0 0]) (get-in pairs [0 0])))\n                        x2 (+ xpos (* (get-in incs [0 1]) (get-in pairs [0 0])))\n                        y1 (+ ypos (* (get-in incs [0 0]) (get-in pairs [0 1])))\n                        y2 (+ ypos (* (get-in incs [0 1]) (get-in pairs [0 1])))]\n                    (if (and (= (get-in board [y1 x1]) sign) (= (get-in board [y2 x2]) sign)) true (recur (into [] (drop 1 incs)) pairs))))) sign (recur (drop 1 x) y))\n          (recur (drop 1 x) y)))))\n  )","user":"5968d73fe4b069c0a1a197d7"},{"problem":73,"code":"(fn [in]\n  (let [rows in\n        columns (for [n (range 3)] (map #(get % n) in))\n        diagonal1 (for [n (range 3)] (get (get in n) n))\n        diagonal2 (for [n (range 3)] (get (get in (- 2 n)) n))\n        lines (conj (concat rows columns) diagonal1 diagonal2)\n        winner-lines (filter #(and (= 1 (count %)) (not= (first %) :e)) (map distinct lines))]\n    (if (empty? winner-lines) nil (first (first winner-lines)))))","user":"5f972ed6e4b0715f5002d7f2"},{"problem":73,"code":"(fn check [table] (cond\n         (some #(every? (fn [y] (= :x y)) %) table) :x \n         (some #(every? (fn [y] (= :o y)) %) table) :o\n         (some #{true} (apply (fn [x y z] (map #(= :x %1 %2 %3) x y z)) table)) :x\n         (some #{true} (apply (fn [x y z] (map #(= :o %1 %2 %3) x y z)) table)) :o\n         (apply (fn [[x1 x2 x3] [y1 y2 y3] [z1 z2 z3]] (or (= :x x1 y2 z3) (= :x x3 y2 z1))) table) :x\n         (apply (fn [[x1 x2 x3] [y1 y2 y3] [z1 z2 z3]] (or (= :o x1 y2 z3) (= :o x3 y2 z1))) table) :o          \n             ))","user":"55d3811be4b0e31453f64a69"},{"code":"(fn [board]\n  (let [lines (concat board\n                      (apply map vector board)\n                      [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                       [((board 0) 2) ((board 1) 1) ((board 2) 0)]])]\n    (loop [lines-left lines]\n      (if (empty? lines-left)\n        nil\n        (cond\n         (= (first lines-left) [:x :x :x]) :x\n         (= (first lines-left) [:o :o :o]) :o\n         :else (recur (rest lines-left)))))))","problem":73,"user":"5186134ce4b0da5a5be3bac7"},{"code":"(fn [board]\r\n  (let [row1 (first board)\r\n        row2 (second board)\r\n        row3 (nth board 2)\r\n        col1 (map first board)\r\n        col2 (map second board)\r\n        col3 (map #(nth % 2) board)\r\n        dia1 (list  (ffirst board) \r\n                    (nth (nth board 1) 1) \r\n                    (nth (nth board 2) 2))\r\n        dia2 (list  (nth (first board) 2)\r\n                    (nth (second board) 1)\r\n                    (nth (nth board 2) 0))\r\n        all (list row1 row2 row3 col1 col2 col3 dia1 dia2)\r\n        x (map #(apply = :x %) all)\r\n        o (map #(apply = :o %) all)]\r\n    (cond\r\n      (some identity x) :x\r\n      (some identity o) :o\r\n      :else nil)))","problem":73,"user":"4e02bee8535d04ed9115e791"},{"problem":73,"code":"(fn [b]\n  (let [r1 (first b)\n        r2 (second b)\n        r3 (nth b 2)\n        c1 (map first b)\n        c2 (map second b)\n        c3 (map #(nth % 2) b)\n        d1 (map-indexed #(nth %2 %1) b)\n        d2 (map-indexed #(nth %2 (- (count %2) (inc %1))) b)]\n    (first (first (filter #(and (= (count %) 1) (not= '(:e) %)) (map distinct [r1 r2 r3 c1 c2 c3 d1 d2]))))))","user":"56228d00e4b03f08ee9a9227"},{"problem":73,"code":"(fn [board]\n  (letfn [(diag1 [b]\n            [((b 0) 2) ((b 1) 1) ((b 2) 0)])\n          (diag2 [b]\n            [((b 0) 0) ((b 1) 1) ((b 2) 2)])]\n  (first (first (filter \n    #(and (not (= :e (first %))) (apply = %)) \n    (concat [ (diag1 board) (diag2 board) (map last board) (map second board) (map first board)] board ))))))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn gradeboard [board]                                                                                                                           \n    (let [lines                                                                                                                                    \n          [                                                                                                                                        \n           [[0 0][0 1][0 2]]                                                                                                                       \n           [[1 0][1 1][1 2]]                                                                                                                       \n           [[2 0][2 1][2 2]]                                                                                                                       \n           [[0 0][1 0][2 0]]                                                                                                                       \n           [[0 1][1 1][2 1]]                                                                                                                       \n           [[0 2][1 2][2 2]]                                                                                                                       \n           [[0 0][1 1][2 2]]                                                                                                                       \n           [[0 2][1 1][2 0]] ]                                                                                                                     \n          linereduce (fn linereduce [line]                                                                                                         \n                       (let [lineresult (map #(get-in board %) line)                                                                               \n                             frst (first lineresult)]                                                                                              \n                         (if (every? #(= frst %) lineresult)                                                                                       \n                           frst                                                                                                                    \n                           :e)))]                                                                                                                  \n      (let [lresults (filter #(not (= % :e)) (map linereduce lines))]                                                                              \n        (if (> (count lresults) 0)                                                                                                                 \n          (first lresults)                                                                                                                         \n          nil))))","problem":73,"user":"50057f23e4b0678c553fc466"},{"code":"(fn [b]\n  (loop\n      [s (mapcat #(apply mapcat list %)\n                 [(for [i (range 3) j (range 3)]\n                    [[i j] [j i]])\n                  (for [i (range 3)]\n                    [[i i] [i (- 2 i)]])])]\n    (when-let [s (seq s)]\n      (let [[h t] (split-at 3 s)]\n        (case (map #(get-in b %) h)\n          [:x :x :x] :x\n          [:o :o :o] :o\n          (recur t))))))","problem":73,"user":"50142490e4b07d18bdaaf70a"},{"problem":73,"code":"(fn [b] (let [rows (for [r (range 3)] (nth b r))\n              cols (map #(into [] %) (partition 3 (for [r (range 3) c (range 3)] (nth (nth b c) r))))\n              d1 (into [] (for [r (range 3)] (nth (nth b r) r)))\n              d2 (into [] (for [r (range 3)] (nth (nth b r) (- 2 r))))\n              winners (concat rows cols [d1] [d2])]\n          (some #(and (apply = %) ((first %) #{:x :o})) winners)))","user":"504457c0e4b01f6c9a8b2360"},{"code":"(fn __ [b]\n  (let [rows b\n        cols (partition 3 (apply interleave b))\n        diags [[(ffirst b) (second (second b)) (nth (nth b 2) 2)]\n               [(first (nth b 2)) (second (second b)) (nth (first b) 2)]]\n        candidates (reduce into [rows cols diags])]\n    (ffirst (filter #(and \n              (= 1 (count (distinct %)))\n              (not= :e (first (distinct %)))) candidates))))","problem":73,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn [src]\n   (let [cnt (count src)\n         vert (partition-all cnt (for [i (range  cnt) v (map #(get % i) src)] v))\n         diag1 [(for [i (range cnt)] (get-in src [i i]))]\n         diag2 [(for [i (range cnt)] (get-in src [(- cnt i 1) i]))]\n         ]\n     (letfn [(chk [x] (distinct(filter #(and(=(count %)1)(not= :e (key(first %))))(map frequencies x))))]\n       \n        (reduce (fn [x y] y) nil (map #(key(first %))(chk(concat src vert diag1 diag2))))\n      )\n     )\n    )","problem":73,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":73,"code":"(fn [[[a b c]\n      [d e f]\n      [h i j] :as board]]\n  (let [test-line (fn [line] (reduce #(when (= %1 %2) %1) line))\n        lines (concat board (apply map vector board) [[a e j] [c e h]])\n        scored-lines (map test-line lines)]\n    (some #{:x :o} scored-lines)))","user":"56cf115de4b0ea9b8538f765"},{"problem":73,"code":"(fn my-tic-tac-toe [board]\n  (let [or-fn (fn [a b]\n                (or a b))\n        is-win (fn [sign coll]\n                 (if (reduce or-fn (map #(= (% 0) (% 1) (% 2) sign) coll)) true false))\n        is-win-x (fn [sign coll]\n                   (= (get-in coll [0 0]) (get-in coll [1 1]) (get-in coll [2 2]) sign))\n        is-win-y (fn [sign coll]\n                   (= (get-in coll [0 2]) (get-in coll [1 1]) (get-in coll [2 0]) sign))\n        trans-bord (fn [coll]\n                     (apply map vector coll))\n        \n        ]\n    (if (or (is-win :x board) (is-win :x (trans-bord board)) \n            (is-win-x :x board) (is-win-y :x board))\n      :x\n      (if (or (is-win :o board) (is-win :o (trans-bord board))\n              (is-win-x :o board) (is-win-y :o board))\n        :o\n        nil))))","user":"55eb026de4b0121d4835fdb7"},{"problem":73,"code":"(fn [[r1 r2 r3]]\n  (cond\n   (and (not= (r1 0) :e) (= (r1 0) (r1 1) (r1 2))) (r1 0)\n   (and (not= (r2 0) :e) (= (r2 0) (r2 1) (r2 2))) (r2 0)\n   (and (not= (r3 0) :e) (= (r3 0) (r3 1) (r3 2))) (r3 0)\n   (and (not= (r1 0) :e) (= (r1 0) (r2 0) (r3 0))) (r1 0)\n   (and (not= (r1 0) :e) (= (r1 0) (r2 1) (r3 2))) (r1 0)\n   (and (not= (r1 2) :e) (= (r1 2) (r2 1) (r3 0))) (r1 2)\n   :else nil))","user":"54864662e4b0e286459a11b8"},{"code":"(fn [board]\n  (let [sub (fn [vect positions]\n              (loop [l vect, pos positions, r []]\n                (if (empty? pos)\n                  r\n                  (recur l (rest pos) (if (not= nil (nth l (first pos) nil))\n                                        (conj r (nth l (first pos) nil))\n                                        r)))))\n        b (flatten board)\n        row-1 [0 1 2]\n        row-2 [3 4 5]\n        row-3 [6 7 8]\n        col-1 [0 3 6]\n        col-2 [1 4 7]\n        col-3 [2 5 8]\n        diag-l [0 4 8]\n        diag-r [2 4 6]]\n    (loop [positions [row-1 row-2 row-3 col-1 col-2 col-3 diag-l diag-r]]\n    \t(if (empty? positions)\n          nil\n          (let [sub-pos (sub b (first positions))]\n            (cond \n             (= [:x :x :x] sub-pos) :x\n             (= [:o :o :o] sub-pos) :o\n             :else (recur (rest positions))))))))","problem":73,"user":"517531c6e4b07031762f2eea"},{"problem":73,"code":"(fn [board]\n  (let [[top middle bottom] board\n        [[a0 b0 c0] [a1 b1 c1] [a2 b2 c2]] board\n        winning [top\n                 middle\n                 bottom\n                 [a0 a1 a2]\n                 [b0 b1 b2]\n                 [c0 c1 c2]\n                 [a0 b1 c2]\n                 [c0 b1 a2]]]\n    (ffirst (filter (fn [[a b c]]\n                      (and (not= a :e)\n                           (= a b c)))\n                   winning))))","user":"4db6d993535d1e037afb2180"},{"code":"(fn [[a b c]]\n  (letfn [\n          (check-diag-win[cand a b c]\n            (if (= cand (second b))\n              (or\n               (and (= cand (first a))\n                    (= cand (last c)))\n               (and (= cand (last a))\n                    (= cand (first c))))\n              nil))\n          \n          (check-col-win[cand a b c col]\n            (and\n             (= (nth a col) cand)\n             (= (nth b col) cand)\n             (= (nth c col) cand)))\n          \n          (check-row-win[cand a b c]\n            (or (every? #(= cand %) a)\n                (every? #(= cand %) b)\n                (every? #(= cand %) c)))\n          \n          (check-cand[cand a b c]\n            (if (or\n                 (check-col-win cand a b c 0)\n                 (check-col-win cand a b c 1)\n                 (check-col-win cand a b c 2)\n                 (check-row-win cand a b c)\n                 (check-diag-win cand a b c))\n              cand\n              nil))\n          ]\n    (or (check-cand :x a b c)\n        (check-cand :o a b c))))","problem":73,"user":"504ec4d3e4b069badc5a33c9"},{"code":"(fn [xss] \n  (letfn [(has-won? [player [[v11 _ v13] [_ v22 _] [v31 _ v33] :as xss]]\n                    (or\n                     (some #(every? (partial = player) %) xss)\n                     (every? #(= (first %) player) xss)\n                     (every? #(= (second %) player) xss)\n                     (every? #(= (nth % 2) player) xss)\n                     (= v11 v22 v33 player)\n                     (= v13 v22 v31 player)))]\n    (cond (has-won? :x xss) :x\n          (has-won? :o xss) :o\n          :else nil)))","problem":73,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn [board]\n  (let [b (to-array-2d board)\n        dims (range 3)\n        get-row (fn [r] (nth board r))\n        get-col (fn [c] (map #(aget b % c) dims ))\n        get-diag-1 (map #(aget b % %) dims)\n        get-diag-2 (map #(aget b (- 2 %) %) dims)\n        all (concat (map get-row dims) (map get-col dims) [get-diag-1] [get-diag-2])\n        s (map set all)\n        singles (set (map first (filter #(= 1 (count %)) s)))\n        ]\n    (cond\n     (contains? singles :o) :o\n     (contains? singles :x) :x\n     :else nil\n     )\n    )\n  )","problem":73,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":73,"code":"(fn [m]\n  (let [f (fn [[[a b c]\n                [d e f]\n                [g h i]] x]\n            (or (= a b c x)\n                (= d e f x)\n                (= g h i x)\n                (= a e i x)\n                (= g e c x)\n                (= a d g x)\n                (= b e h x)\n                (= c f i x)))]\n    (cond (f m :x) :x\n          (f m :o) :o)))","user":"59e8bb43e4b0249b72820735"},{"code":"(fn [x] (let [points-with \n              (fn [t] \n                (remove nil? \n                  (for [i (range (count x)) j (range 3)] (when (= (get-in x [i j]) t) [i j]))))\n              ordered (fn [more]\n                     (or (apply < more) (apply > more) (apply = more)))\n              lined (fn [t]\n                      (let [points (points-with t)]\n                          (when (= (count points) 3)\n                            (->> (apply map list points)\n                                (every? ordered))\n                          )\n                      ))\n              ]\n              (let [lx (lined :x) lo (lined :o)]\n                (cond (and lx (not lo)) :x\n                      (and lo (not lx)) :o\n                     ))\n))","problem":73,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (reduce \n    #(if (or (apply not= %2) (= :e (first %2)))\n      %1 (first %2)) \n    nil\n    [[a b c] [d e f] [g h i]\n     [a d g] [b e f] [c f i]\n     [a e i] [c e g]]))","problem":73,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [s] (some (fn [[x y z]] (if (and (= x y z) (not= x :e)) x false)) \n              (concat s (->> s (apply interleave) (partition-all 3)) \n                      (list (map get s (range)) \n                      (map get (reverse s) (range))))))","problem":73,"user":"523b1988e4b02f719975bdbc"},{"problem":73,"code":"(fn tic [board]\n  (let [lines (list \n                board \n                (apply map vector board) \n                (list\n                  (for [x `((0 0) (1 1) (2 2))] (get-in board x))\n                  (for [x `((0 2) (1 1) (2 0))] (get-in board x))))]\n  (first \n  (filter \n    identity \n    (for [line lines]\n      (some #(when \n          (and \n           (not (= :e (first (set %))))\n           (= (count (set %)) 1))\n         (first (set %)))\n        line))))))","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn [xo] (some \n  (fn [row] (reduce #(when (and (= %1 %2) (not= %2 :e)) %1) row))\n  (concat xo (apply map list xo) (map #(map get xo %) [[0 1 2] [2 1 0]]))))","problem":73,"user":"4ef8d47c535dced4c769f261"},{"code":"(fn [board]\n   (ffirst\n    (filter (fn [[x y z]]\n              (when (and (= x y z) (#{:o :x} x)) x))\n            (for [tripple [[0 1 2]\n                           [3 4 5]\n                           [6 7 8]\n                           [0 3 6]\n                           [1 4 7]\n                           [2 5 8]\n                           [0 4 8]\n                           [2 4 6]]]\n              (map #(nth (flatten board) %) tripple)))))","problem":73,"user":"4dda44f2535d02782fcbe9f1"},{"problem":73,"code":"(fn solve [x]\n  (let [[[a b c]\n         [d e f]\n         [g h i]] x\n        solutions (set\n                    (vector \n                      [a b c]\n                      [d e f]\n                      [g h i]\n                      [a d g]\n                      [b e h]\n                      [c f i]\n                      [a e i]\n                      [c e g]))]\n    (cond\n      (contains? solutions [:x :x :x]) :x\n      (contains? solutions [:o :o :o]) :o\n      :shit nil)))","user":"56f298b4e4b04a395b9a04a6"},{"problem":73,"code":"(fn [board]\n  (letfn [(row-same [[a b c]]\n            (when (= a b c) a))\n          (merge-row-results [a b]\n            (cond\n              (#{:x :o} a) a\n              (#{:x :o} b) b))\n          (transpose [board]\n            (apply map list board))]\n    (reduce merge-row-results\n            [(reduce merge-row-results \n                     (map row-same board))\n             (reduce merge-row-results\n                     (map row-same (transpose board)))\n             (row-same [(get-in board [0 0])\n                        (get-in board [1 1])\n                        (get-in board [2 2])])\n             (row-same [(get-in board [2 0])\n                        (get-in board [1 1])\n                        (get-in board [0 2])])])))","user":"5bc39d2be4b07a9b28b10045"},{"problem":73,"code":"(fn [m] (let [a (concat (apply map vector m) (seq m) ((fn [x] (let [g #(get-in x %) d (g [1 1])]\n                                                         (seq [[(g [0 0]) d (g [2 2])] [(g [0 2]) d (g [2 0])]])                                                           \n                                                         )) m))  h (fn [k] (some #(every? #{k} %) a))]\n           (if (h :x)\n             :x \n             (if (h :o)\n                  :o \n                  nil\n                  )) ))","user":"5464a536e4b01be26fd746cf"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [winner (fn [triple]\n                 (when (or (every? #(= :x %) triple) (every? #(= :o %) triple))\n                   (nth triple 0)))\n        rows board\n        cols (for [j (range 3)] (map #((board %) j) (range 3)))\n        diag1 (map #((board %) %) (range 3))\n        diag2 (map #((board %) (- 2 %)) (range 3))]\n    (some winner (conj (concat rows cols) diag1 diag2))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":73,"code":"(fn [board]\n  (let [diagonals (for [f [#(list % %) #(list % (- 2 %))]]\n                    (for [x (range 3)]\n                      (get-in board (f x))))\n        columns (apply map vector board)\n        checks (concat board diagonals columns)]\n    (first \n      (for [check checks \n            :let [dist (distinct check)] \n            :when (#{[:o] [:x]} dist)]\n        (first dist)))))","user":"5516bd41e4b06a49daca83b7"},{"code":"(fn tic-tac-toe [board]\n  (letfn [(transpose [board]\n            (map (fn [col]\n                   (map #(nth % col) board)) (range (count board))))\n          (is-row-filled? [player row]\n            (every? #(= % player) row))\n          (has-filled-row? [player board]\n            (not (not-any? (partial is-row-filled? player) board)))\n          (diagonal [board]\n            (map #(nth (nth board %) %) (range (count board))))\n          (has-won? [player]\n            (or (has-filled-row? player board)\n                (has-filled-row? player (transpose board))\n                (is-row-filled? player (diagonal board))\n                (is-row-filled? player (diagonal (map reverse board)))))]\n    (if (has-won? :x)\n      :x\n      (if (has-won? :o)\n        :o\n        nil))))","problem":73,"user":"4ff355a1e4b0678c553fc34d"},{"problem":73,"code":"(fn [y] (letfn\n          [\n           (rd [x] [(take-nth 4 (flatten x))])\n           (ld [x] [(rest (drop-last (take-nth 2 (flatten x))))])\n           (v [x]   (apply mapv vector x))\n           (buildOptions [x] (concat (v x) x (rd x) (ld x)))\n           (success? [x] (cond \n                          (some #(= % [:x :x :x]) x) :x\n                          (some #(= % [:o :o :o]) x) :o\n                          :else nil\n                          ))\n           ]\n          (success? (into [] (buildOptions y)))\n          ))","user":"56427910e4b08d4f616f5f19"},{"problem":73,"code":"#(let [\n       [a] %\n       [_ b] %\n       [_ _ c] %\n       [[d] [e] [f]] %\n       [[_ g] [_ h] [_ i]] %\n       [[_ _ j] [_ _ k] [_ _ l]] %\n       [[m] [_ n] [_ _ o]] %\n       [[_ _ p] [_ q] [r]] %\n       ]\n   (cond (or (= (distinct a) [:x])\n             (= (distinct b) [:x])\n             (= (distinct c) [:x])\n             (= (distinct [d e f]) [:x])\n             (= (distinct [g h i]) [:x])\n             (= (distinct [j k l]) [:x])\n             (= (distinct [m n o]) [:x])\n             (= (distinct [p q r]) [:x]))  :x\n         (or (= (distinct a) [:o])\n             (= (distinct b) [:o])\n             (= (distinct c) [:o])\n             (= (distinct [d e f]) [:o])\n             (= (distinct [g h i]) [:o])\n             (= (distinct [j k l]) [:o])\n             (= (distinct [m n o]) [:o])\n             (= (distinct [p q r]) [:o]))  :o\n         :else nil\n         ))","user":"566734c4e4b04acd4f672dcc"},{"code":"(fn test [board]\n  (let [destructured (let [[a b c \n                                 d e f \n                                 g h i] \n                                (flatten board) ] \n                            {:a a :b b :c c \n                             :d d :e e :f f \n                             :g g :h h :i i})\n        winning-lines [[:a :b :c] \n                       [:d :e :f] \n                       [:g :h :i] \n                       [:a :d :g] \n                       [:b :e :h] \n                       [:c :f :i] \n                       [:a :e :i] \n                       [:c :e :g]]\n        lines (map (partial map destructured) winning-lines)\n        is-win-for (fn [symbol line] (if (apply = symbol line) symbol nil))\n        is-win (fn [line] (or (is-win-for :x line) (is-win-for :o line)))\n        ] (some is-win lines)))","problem":73,"user":"525bcae9e4b0cb4875a45d30"},{"problem":73,"code":"(fn [[r1 r2 r3]] (ffirst\n (filter (fn [s] (not (= s #{:e})))\n         (filter (fn [s] (= 1 (count s)))\n                 (list (set r1) (set r2) (set r3)\n                       (set [(first r1) (first r2) (first r3)])\n                       (set [(second r1) (second r2) (second r3)])\n                       (set [(last r1) (last r2) (last r3)])\n                       (set [(first r1) (second r2) (last r3)])\n                       (set [(last r1) (second r2) (first r3)])\n                       )\n                 )\n         )\n                )\n  )","user":"56662275e4b0e91d5f5c566a"},{"problem":73,"code":"(fn [b]\n  (let [fb (flatten b),\n    sm (fn [s, a, b, c] (if (= (nth s (dec a)) (nth s (dec b)) (nth s (dec c))) (nth s (dec a)) nil))\n    s0 (sm fb 1 2 3), s1 (sm fb 4 5 6), s2 (sm fb 7 8 9), s3 (sm fb 1 4 7), s4 (sm fb 2 5 8), s5 (sm fb 3 6 9), s6 (sm fb 1 5 9), s7 (sm fb 3 5 7),\n    rx (or (= s0 :x) (= s1 :x) (= s2 :x) (= s3 :x) (= s4 :x) (= s5 :x) (= s6 :x) (= s7 :x)),\n    ro (or (= s0 :o) (= s1 :o) (= s2 :o) (= s3 :o) (= s4 :o) (= s5 :o) (= s6 :o) (= s7 :o))]\n  (if (true? rx) :x (if (true? ro) :o nil))))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn [i-board]\r\n    (let [\r\n        players [:x :o]\r\n        wins (fn [i-player i-cells]\r\n            (zero? (count (filter #(not= % i-player) i-cells))))\r\n        row-win (fn check-row\r\n            ([i-player] (check-row false i-player 0))\r\n            ([result i-player i-row]\r\n                (if (= i-row 3)\r\n                    result\r\n                    (let [\r\n                        row-result (wins i-player (map\r\n                                nth\r\n                                i-board\r\n                                (repeat 3 i-row)))\r\n                        ]\r\n                        (if (false? row-result)\r\n                            (check-row row-result i-player (inc i-row))\r\n                            row-result)))))\r\n        col-win (fn check-col\r\n            ([i-player] (check-col false i-player 0))\r\n            ([result i-player i-col]\r\n                (if (= i-col 3)\r\n                    result\r\n                    (let [\r\n                        col-result (wins i-player (nth i-board i-col))\r\n                    ]\r\n                    (if (false? col-result)\r\n                        (check-col col-result i-player (inc i-col))\r\n                        col-result)))))\r\n        diag-win (fn check-diag\r\n            ([i-player] (check-diag false i-player [(range 3) (reverse (range 3))]))\r\n            ([result i-player i-cells]\r\n                (if (zero? (count i-cells))\r\n                    result\r\n                    (let [\r\n                        diag-result (wins i-player (map\r\n                            nth\r\n                            i-board\r\n                            (first i-cells)))\r\n                        ]\r\n                        (if (false? diag-result)\r\n                            (check-diag diag-result i-player (rest i-cells))\r\n                            diag-result)))))\r\n        game-result (conj [] (map row-win players) (map col-win players) (map diag-win players))\r\n        get-winner (fn [result]\r\n            (reduce\r\n                #(let [[player result] %2] (if result player %1))\r\n                nil\r\n                (apply hash-map (interleave players result))))\r\n        ]\r\n            (reduce\r\n                #(if (nil? %2) %1 %2)\r\n                nil\r\n                (map get-winner game-result))))","problem":73,"user":"4dddf817535d08e6dec9fdd3"},{"problem":73,"code":"(fn [[a b c :as rows]]\n  (let [sets [(set a)\n              (set b)\n              (set c)\n              (set (map first rows))\n              (set (map second rows))\n              (set (map #(nth % 2) rows))\n              (set (map nth rows (range)))\n              (set (map nth (reverse rows) (range)))]]\n    (->> sets\n          (filter #(= 1 (count %)))\n          (apply clojure.set/union)\n          (#(disj % :e))\n          first)))","user":"5b64370ae4b0c6492753e73c"},{"code":"(letfn [(transpose\n         [matrix]\n         (apply mapv vector matrix))\n        \n        (diagonal'\n         [matrix]\n         (->> (range (count matrix))\n              (mapv #(get-in matrix [% %]))))\n        \n        (diagonals\n         [matrix]\n         (mapv diagonal'\n               [matrix\n                (mapv (comp vec rseq)\n                      matrix)]))\n        \n        \n        (check\n         [player board]\n         (some (partial every? #{player})\n               board))\n           \n        (wins?\n         [player board]\n         (some (partial check player)\n               ((juxt identity\n                      transpose\n                      diagonals)\n                board)))]\n  \n  (fn tic-tac-toe [board]\n    (some #(when (wins? % board) %)\n          [:x :o])))","problem":73,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":73,"code":"(fn tic-tac-toe-analyze [coll]\n  (letfn [(winner-symbols \n            [coll] \n            (first \n              (filter \n                #(or (every? #{:o} %)\n                     (every? #{:x} %))\n                coll)))\n          (index-chooser\n            [coll]\n            (keep-indexed\n               #(if (= 0 (rem %1 4)) %2)\n               (flatten coll)))]        \n    (if-let [winner-symbol (first (winner-symbols coll))]\n      winner-symbol\n      (let [adj-coll (partition 3 (apply interleave coll))]\n        (if-let [winner-symbol (first (winner-symbols adj-coll))]\n          winner-symbol\n          (let [adj-coll (partition 3 (concat (index-chooser coll)\n                                              (index-chooser (reverse coll))))]\n            (if-let [winner-symbol (first (winner-symbols adj-coll))]\n              winner-symbol\n              nil)))))))","user":"53d40508e4b00fb29b221332"},{"problem":73,"code":"(fn \n\t[[[a b c] [d e f] [g h i]]]\n\t(letfn [(win [x y z] (if (and (= x y z) (not= x :e)) x))]\n\t\t(first (filter (complement nil?)\n\t\t\t\t[(win a b c) (win d e f) (win g h i)\n\t\t\t\t (win a d g) (win b e h) (win c f i)\n\t\t\t\t (win a e i) (win c e g)]))))","user":"505fdf63e4b08f2a82ad10b9"},{"code":"(fn grade [input]\n  (let [[[a b c] [d e f] [g h i]] input]\n    (cond (and (= a d g) (not (= a :e))) a\n          (and (= a b c) (not (= a :e))) a\n          (and (= a e i) (not (= a :e))) a\n          (and (= b e h) (not (= b :e))) b\n          (and (= c f i) (not (= c :e))) c\n          (and (= c e g) (not (= c :e))) c\n          (and (= d e f) (not (= d :e))) d\n          (and (= g h i) (not (= g :e))) g\n          :else nil)))","problem":73,"user":"515737f0e4b0b0b4b87062d0"},{"problem":73,"code":"(fn [board]\n  (let [get-diag (fn [b] (let [size (count b)]\n                           (loop [e 0\n                                  res []]\n                             (if (= e size)\n                               res\n                               (recur (inc e) (conj res (get-in b [e e])))))))\n        tuples (concat board\n                       (apply map vector board) ;; get columns\n                       (vector (get-diag board))\n                       (vector (get-diag (apply vector (map (comp #(apply vector %) reverse) board)))))]\n    (cond\n      (some #(= % [:o :o :o]) tuples) :o\n      (some #(= % [:x :x :x]) tuples) :x\n      :else nil))\n  )","user":"60a42199e4b00e9e6653c454"},{"problem":73,"code":"(fn [board]\n (let [r (range 3)\n       hor board\n       ver (map\n            (fn [idx]\n             (reduce\n              #(conj %1 (nth %2 idx))\n              []\n              board))\n            r)\n       dia (map\n            (fn [idxv]\n             (reduce\n              conj\n              []\n              (map\n               nth\n               board\n               idxv)))\n            [r (reverse r)])\n       all (concat hor ver dia)\n       direct?\n        (fn [e]\n         (some\n          (fn [vec]\n           (every? #(= % e) vec))\n          all))]\n (cond (direct? :o) :o\n       (direct? :x) :x\n       :else nil)\n )\n)","user":"549a999be4b0f3d1d8e70f6f"},{"problem":73,"code":"(fn tic-tac-toe\n  [b]\n  (let [across [(first b) (second b) (last b)]\n        down [(map first b) (map second b) (map last b)]\n        zig [(first (first b)) (second (second b)) (last (last b))]\n        zag [(first (last b)) (second (second b)) (last (first b))]\n        candidates (concat across down [zig] [zag])\n        x-wins (some #(every? #{:x} %) candidates)\n        o-wins (some #(every? #{:o} %) candidates)]\n    (cond x-wins :x\n          o-wins :o\n          :else nil)))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":73,"code":"(fn [x] (let [b (mapcat zipmap [[0 1 2][3 4 5][6 7 8]] x)\n               w [#{0 1 2} #{3 4 5} #{6 7 8} #{0 3 6} #{1 4 7} #{2 5 8} #{0 4 8} #{2 4 6}]]\n                (some identity (for [p [:o :x]]\n                   (if (some identity (map (partial clojure.set/superset? (into #{} (keys (filter #(= (val %) p) b)))) w))\n                     p)))))","user":"566a3a26e4b0a866af689699"},{"code":"(fn [a]\n  (let [both     (reduce #(conj %1 %2) a (vec (for [x (range 3)]\n                (vec (for [y (range 3)]\n                  (nth (nth a y) x))))))\n        \n        diags  [(vec (for [xy (range 3)] (nth (nth a xy) xy)))\n                (vec (for [xy (reverse (range 3))] (nth (nth a xy) (- 2 xy))))]\n        \n        fil-n (fn [lol]\n                (first (remove nil?\n                        (for [idx (range (count lol))]\n                          (reduce\n                           #(cond\n                             (= :x %1 %2) :x\n                             (= :o %1 %2) :o\n                             :else nil) (nth lol idx))))))\n        both-res (fil-n both)\n        diags-res (fil-n diags)]\n    (first (remove nil? [both-res diags-res]))))","problem":73,"user":"4fb86dc9e4b081705acca2d8"},{"problem":73,"code":"(fn winner [board]\n   (let [winners #{:x :o}]\n     (letfn [(winning-row? [row]\n              (when (and\n                     (apply = row)\n                     (some #{(first row)} winners))\n                (first row)))\n             (check-lists [lists]\n               (filter #(not (nil? %)) (map winning-row? lists)))\n             (check-cols []\n               (let [transposed\n                     (for [x (range (count board))]\n                       (into [] (map #(% x) board)))]\n                 (check-lists transposed)))\n             (check-by-pos [pos]\n               (let [transposed\n                      (for [x pos]\n                           (get-in board x))]\n                 (check-lists [transposed])))]\n      (let [checks (flatten [(check-lists board)\n                             (check-cols)\n                             (check-by-pos '([0 0] [1 1] [2 2]))\n                             (check-by-pos '([2 0] [1 1] [0 2]))])]\n\n        (first checks)))))","user":"5a342188e4b0ddc586f153bd"},{"code":"(fn tic-tac [board]\n  (let [ column (fn [c] (map (fn [r] (get-in board [r c])) [0 1 2]))\n        diag1 (map (fn [i] (get-in board [i i]) ) [0 1 2])\n        diag2 (map (fn [i] (get-in board [i (- 2 i)]) ) [0 1 2])\n        cols (map column [0 1 2])\n        [w & _] (filter (fn [x] (and (= 1 (count x)) (not (x :e)))) \n                        (map (fn [x] (into #{} x))\n                             (concat board [diag1 diag2] cols)))]\n    (first (into [] w))))","problem":73,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn check [board] \n  (let [rows (for [row (range 3)] \n               (into [] (for [x (range 3)] [row x])))\n        cols (for [col (range 3)] \n               (into [] (for [x (range 3)] [x col])))\n        diags (vector (for [d (range 3)] [d d ] ) \n                      (for [d (range 3)] [(- 2 d) d ] ))\n        complete-line? (fn [board coll coin] \n  \t\t\t(every? #(= coin (get (get board (first %)) (second %))) coll))\n        wins? (fn [board coin] \n  \t\t\t(or \t(some #(complete-line? board % coin) cols)\n\t\t\t\t\t(some #(complete-line? board % coin) rows)\n\t\t\t\t\t(some #(complete-line? board % coin) diags))) ] \n    (cond (wins? board :x) :x\n        (wins? board :o) :o\n\t\t:else nil)))","problem":73,"user":"523a9fc9e4b081681ca7adca"},{"problem":73,"code":"(fn [board]\n  (let [a (flatten board)\n        res (map (fn [s]\n                   (let [x (->> s (map #(nth a %)) set)]\n                     (cond\n                       (= x #{:x}) :x\n                       (= x #{:o}) :o)))\n                 [[0 1 2] [3 4 5] [6 7 8]\n                  [0 3 6] [1 4 7] [2 5 8]\n                  [0 4 8] [2 4 6]])\n        ]\n    (first (keep identity res))))","user":"5628cb07e4b00e49c7cb47ef"},{"problem":73,"code":"(fn [args]\n(let [coll args\n      horizontal (concat coll)\n      vertical   (apply map vector coll)\n      diagonal-to-right   (loop [v (vec horizontal)\n           r []\n           c 0]\n      (if (< c 3)\n          (recur (next v)\n                 (conj r ((first v) c))\n                 (inc c))\n          r\n      )\n      )\n      diagonal-to-left (loop [v (vec horizontal)\n              r []\n              c 2]\n        (if (> c -1)\n            (recur (next v)\n                    (conj r ((first v) c))\n                    (dec c))\n            r\n        )\n      )\n      search-vector (conj (concat horizontal vertical) diagonal-to-right diagonal-to-left)]\n  \n     (some (fn [[x y z]] (if (and (= x y z) (not= x :e)) x nil)) search-vector)\n\n))","user":"51316a63e4b0431ba07e7feb"},{"code":"(fn [[l1 l2 l3]]\n  (let [lines [l1 \n               l2 \n               l3\n               [(l1 0) (l2 0) (l3 0)]\n               [(l1 1) (l2 1) (l3 1)]\n               [(l1 2) (l2 2) (l3 2)]\n               [(l1 0) (l2 1) (l3 2)]\n               [(l1 2) (l2 1) (l3 0)]\n               ]\n         line-winner (fn [line]\n\t\t\t\t\t\t(reduce #(if (= % %2) %) line)\n                     )\n         line-winners (keep line-winner lines)\n        ]\n    (first (filter #(not= :e %) line-winners))\n  )\n)","problem":73,"user":"510cda21e4b078ea71921126"},{"problem":73,"code":"(fn [board]\n          (let [lines (for [x [0 1 2] y [0 1 2]] [x y])\n                hlines (partition 3 lines)\n                vlines (partition 3 (map (comp vec reverse) lines))\n                diag [[[2 0] [1 1] [0 2]] [[0 0] [1 1] [2 2]]]\n                anss (map vec (concat vlines hlines diag))]\n\n            (first (remove nil?\n                           (for [[one two three] anss]\n                             (cond\n                              (= [:x :x :x] [(get-in board one) (get-in board two) (get-in board three)]) :x\n                              (= [:o :o :o] [(get-in board one) (get-in board two) (get-in board three)]) :o\n                              :else nil))))))","user":"51e3a549e4b0c611d6113e47"},{"problem":73,"code":"(fn [board]\n  (letfn [(check [[[a b c][d e f][g h i]] p]\n    (or (= p a b c)\n        (= p d e f)\n        (= p g h i)\n        (= p a d g)\n        (= p b e h)\n        (= p c f i)\n        (= p a e i)\n        (= p c e g)))]\n\n    (cond (check board :x) :x\n          (check board :o) :o\n          :else nil)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":73,"code":"(fn find-winner [b]\n  (let [horizontal\n        (fn [b]\n          (cond\n           (some #(= % [:x :x :x]) b) :x\n           (some #(= % [:o :o :o]) b) :o\n           :else nil))\n        rotated-board (apply map vector b)\n        diag-a (map #(nth %1 %2) b (range 0 3))\n        diag-b (map #(nth %1 %2) b [2 1 0])\n        ]\n    (or\n     (horizontal (concat b [diag-a diag-b]))\n     (horizontal rotated-board))))","user":"4ddb696b535d02782fcbe9fa"},{"problem":73,"code":"(fn [brd]\n  (some #(if (or (every? #{:x} %)\n                 (every? #{:o} %))\n           (first %)\n           nil)\n        (conj\n          (concat brd (apply map vector brd))\n          (map-indexed (fn [i e] (first (drop i e))) brd)\n          (map-indexed (fn [i e] (last (drop-last i e))) brd))))","user":"54b13a40e4b09f271ff37d1b"},{"code":"(fn [board]\n    (letfn [(column [i]\n              (map #(get % i) board))\n            (aligned3-hori? [k]\n              (some #(= (board %) (repeat 3 k)) (range 3)))\n            (aligned3-vert? [k]\n              (some #(= (column %) (repeat 3 k)) (range 3)))\n            (aligned3-diag? [k]\n              (or (=\n                    (vector\n                      (-> board (get 0) (get 0))\n                      (-> board (get 1) (get 1))\n                      (-> board (get 2) (get 2)))\n                    (repeat 3 k))\n                  (=\n                    (vector\n                      (-> board (get 2) (get 0))\n                      (-> board (get 1) (get 1))\n                      (-> board (get 0) (get 2)))\n                    (repeat 3 k))))\n            (won? [k]\n              (or (aligned3-hori? k) (aligned3-vert? k) (aligned3-diag? k)))\n           ]\n      (if (won? :x)\n        :x\n        (if (won? :o)\n          :o\n          nil))))","problem":73,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn [board]\n    (letfn [(sym-at [row col] (nth (nth board row) col))\n            (won? [sym]\n              (let [sss [sym sym sym]]\n                (or (= (nth board 0) sss) ; horizontal\n                    (= (nth board 1) sss)\n                    (= (nth board 2) sss)\n                    (= (map #(nth % 0) board) sss) ; diagonal\n                    (= (map #(nth % 1) board) sss)\n                    (= (map #(nth % 2) board) sss)\n                    (= (list (sym-at 0 0) (sym-at 1 1) (sym-at 2 2)) sss)\n                    (= (list (sym-at 0 2) (sym-at 1 1) (sym-at 0 2)) sss))))]\n      (cond (won? :x) :x\n            (won? :o) :o\n            :else nil)))","problem":73,"user":"4e89e939535d3e98b8023287"},{"code":"(fn [board]\n (letfn [(hs [b] b)\n         (vs [b]\n           [(vec (map first b))\n            (vec (map second b))\n            (vec (map last b))])\n         (ds [b]\n           [[(first (first b)) \n             (second (second b)) \n             (last (last b))]\n            [(first (last b)) \n             (second (second b)) \n             (last (first b))]])\n         (rs [b]\n           (concat (hs b) (vs b) (ds b)))]\n   (let [ws\n  (set (flatten (filter #(= (count %) 1)\n    (map keys\n      (map frequencies (rs board))))))]\n  (cond\n    (some #{:x} ws) :x\n    (some #{:o} ws) :o\n    :else nil))))","problem":73,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn [rows]\n  (let [extract (fn [idxs] (map #(nth %1 %2) rows idxs))\n        cols (map extract [[0 0 0] [1 1 1] [2 2 2]])\n        diags (map extract [[0 1 2] [2 1 0]])\n        three-sets (concat rows cols diags)\n        any-all-*s? (fn [sym]\n                      (fn [three-sets]\n                        (some (fn [row] (every? #(= sym %) row)) three-sets)))\n        any-all-xs? (any-all-*s? :x)\n        any-all-os? (any-all-*s? :o)]\n    (cond (any-all-xs? three-sets) :x\n          (any-all-os? three-sets) :o\n          :else nil)))","problem":73,"user":"4fae0b85e4b081705acca245"},{"problem":73,"code":"(fn [_]\n  (let [e #(apply = % %2)\n        a [0 1 2]\n        b [2 1 0]\n        s [:x :o]\n        d (fn [x y] (map #(get (_ %) %2) x y))]\n    (first (keep min\n              (concat\n                 (for [c s\n                       f [(fn [i] (map #(% i) _))\n                          #(_ %)]\n                       x a\n                       :when (e c (f x))]\n                   c)\n                 (for [c s\n                       :when (or (e c (d a a))\n                                 (e c (d b a)))]\n                   c))))))","user":"4ee4f4a9535d1385b2869d85"},{"problem":73,"code":"(fn [board]\n    (let [lines [(nth board 0) ; row 1\n                 (nth board 1) ; row 2\n                 (nth board 2) ; row 3\n                 (map first board) ; column 1\n                 (map second board) ; column 2\n                 (map #(nth % 2) board) ;column 3\n                 (map #(nth %1 %2) board (range)) ; upper left to lower right\n                 (map #(nth %1 (- 2 %2)) board (range))]] ; lower left to upper right\n          (cond (some identity (map #(apply = :x %) lines)) :x\n                (some identity (map #(apply = :o %) lines)) :o\n                :else nil)))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn [brd]\n  (let [won? (fn [p]\n    (reduce #(or %1 %2)\n       (flatten\n          [ (for [y (range 0 3)] (= p ((brd 0) y) ((brd 1) y) ((brd 2) y)))\n            (for [x (range 0 3)] (= p ((brd x) 0) ((brd x) 1) ((brd x) 2)))\n            (= p ((brd 0) 0) ((brd 1) 1) ((brd 2) 2))\n            (= p ((brd 0) 2) ((brd 1) 1) ((brd 2) 0))])))]\n    (cond (won? :x) :x (won? :o) :o :else nil)))","problem":73,"user":"50bce014e4b0594b91591c63"},{"problem":73,"code":"(fn tte [board]\n(letfn [\n\t(spb [b i] \n\t\t\t(keep-indexed #(if (= i (rem %1 3)) %2) (flatten b)))\n\t(horizontal-win [b t] \n\t\t\t(some (fn [x] (every? #(= t %) x)) b))\n\t(vertical-win [b t] \n\t\t\t(horizontal-win (map #(spb b %) (take 3 (range))) t))\n\t(diagonal-win [b t] \n\t\t\t(horizontal-win\n\t\t\t [\n\t\t\t \t\t[(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])]\n\t\t\t \t\t[(get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])]\n\t\t\t ] \n\t\t t))\n\t(got-winner [b t] (or (vertical-win b t) (horizontal-win b t) (diagonal-win b t)))\n (x-wins [b] (got-winner b :x))\n (o-wins [b] (got-winner b :o))\n]\n\n(if (x-wins board) \n :x\n\t(if (o-wins board) \n\t\t:o\n\t\tnil\n\t))))","user":"5c87c79be4b048ec896c591b"},{"problem":73,"code":"(fn analyze-tictak [gamefld]\n (when (and (= 3 (count gamefld))\n            (every? #(and (vector? %) (= 3 (count %))) gamefld)\n            (every? (fn [row] (every? #{:e :x :o} row)) gamefld))\n  (let [height (count gamefld)\n        width (count gamefld)\n        fldidx (for [i (range 0 height) j (range 0 width)] [i j])]\n    (letfn [\n      (flatten-seqs [colls] (reduce (fn [acc b] (into acc b)) [] colls))\n      (in-fld? [[i j]]\n        (and (>= i 0) (>= j 0) (< i height) (< j width)))\n      (move-left [[i j]] [i (dec j)])\n      (move-right [[i j]] [i (inc j)])\n      (move-up [[i j]] [(dec i) j])\n      (move-down [[i j]] [(inc i) j])\n      (move-upleft [[i j]] [(dec i) (dec j)])\n      (move-upright [[i j]] [(dec i) (inc j)])\n      (move-downleft [[i j]] [(inc i) (dec j)])\n      (move-downright [[i j]] [(inc i) (inc j)])\n      (get-pt-arrow [point movefn]\n        (letfn [(loc-grow-arrow [pt]\n                  (when (in-fld? pt)\n                    (lazy-seq (cons pt (loc-grow-arrow (movefn pt))))))]\n          (vec (loc-grow-arrow point))))\n      (stroke-right [pt] (get-pt-arrow pt move-right))\n      (stroke-down [pt] (get-pt-arrow pt move-down))\n      (get-item [[i j]] (get-in gamefld [i j]))]\n      (let [fst-row [[0 0] [0 1] [0 2]]\n            fst-col [[0 0] [1 0] [2 0]]\n            d-strokes (-> [] (conj ,,, (get-pt-arrow [0 0] move-downright))\n                             (conj ,,, (get-pt-arrow [0 2] move-downleft)))\n            h-strokes (vec (map stroke-right fst-col))\n            v-strokes (vec (map stroke-down fst-row))\n            all-strokes (vec (concat d-strokes h-strokes v-strokes))\n            all-results (vec (map (fn [stk] (vec (map get-item stk)))\n                             all-strokes))\n            wins-set (reduce (fn [acc bv] (if (every? #(= % (first bv)) bv)\n                                              (conj acc (first bv))\n                                              acc))\n                             #{} all-results)\n            ]\n        (cond\n          (:x wins-set) :x\n          (:o wins-set) :o\n          :otherwise    nil) )))))","user":"57f9011ee4b0d3187e900935"},{"problem":73,"code":"(fn ttt [matrix]\n  (let [value-check\n        (fn [value]\n          (let [equal-fn (partial identical? value)\n                check-fn (partial every? equal-fn)\n                trans-matrix (apply map (concat [list] matrix))\n                rows (range 0 (count matrix))\n                get-val (fn [[row col]] (get-in matrix [row col]))\n                get-diagonal (fn [rows cols] (map get-val (map list rows cols)))\n                left-diagonal (get-diagonal rows rows)\n                right-diagonal (get-diagonal rows (reverse rows))]\n            (or (some check-fn matrix)\n                (some check-fn trans-matrix)\n                (some check-fn [left-diagonal right-diagonal]))))]\n    (cond\n      (value-check :x) :x\n      (value-check :o) :o\n      :else nil)))","user":"58fed70de4b0438e51c2cfdd"},{"problem":73,"code":"(fn [board]\n  (let [rows  board\n        cols  (partition 3 (apply interleave board))\n        diag1 [(map (fn [row i] (get row i)) board (range))]\n        diag2 [(map (fn [row i] (get row (- (count row) i 1))) board (range))]]\n    (first\n     (remove (partial = :e)\n             (map first\n                  (get\n                   (group-by\n                    count\n                    (map\n                     set\n                     (concat rows cols diag1 diag2)))\n                   1))))))","user":"5a250b86e4b07f18be40aa19"},{"problem":73,"code":"(fn f [board]\n  (cond\n    (= (get-in board [0 0])\n       (get-in board [1 1])\n       (get-in board [2 2]))\n    (#{:o :x} (get-in board [0 0]))\n    (= (get-in board [0 2])\n       (get-in board [1 1])\n       (get-in board [2 0]))\n    (#{:o :x} (get-in board [0 2]))\n    true\n    (let [full-row (->> board\n                        (filter #(= 1 (count (set %))))\n                        first first)\n          full-col (->> board\n                        (apply mapv vector)\n                        (filter #(= 1 (count (set %))))\n                        first first)]\n      (or full-row full-col nil))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn [x]\n  (let [f (flatten x)\n        winning-combos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        result (for [[x y z] winning-combos :when\n                     (or\n                       (= :x (nth f x) (nth f y) (nth f z))\n                       (= :o (nth f x) (nth f y) (nth f z)))]\n                 (nth f x))]\n    (first result)))","problem":73,"user":"4f849f76e4b033992c121c36"},{"problem":73,"code":"(fn [g]\n  (let [di1 #(map get % (range))\n        di2 #(di1 (reverse %))\n        d1 (di1 g) d2 (di2 g)\n        g' (apply map vector g)\n        win? #(some (partial every? (partial = %)) %2)]\n    (condp win? (list* d1 d2 (concat g g'))\n      :x :x\n      :o :o\n      nil)))","user":"53dfdf01e4b0d874e779ae46"},{"problem":73,"code":"(fn winner [[[a b c :as top]\n             [d e f :as middle]\n             [g h i :as bottom]]]\n  (let [left     [a d g]\n        center   [b e h]\n        right    [c f i]\n        forward  [a e i]\n        backward [c e g]]\n    (when-let [winner (some #(when (or (every? #{:x} %) (every? #{:o} %)) %)\n                            [top middle bottom\n                             left center right\n                             forward backward])]\n      (first winner))))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":73,"code":"(let [winner (fn [board [a0 b0 a1 b1 a2 b2]]\n               (let [align? (= ((board a0) b0)\n                               ((board a1) b1)\n                               ((board a2) b2))]\n                 (when align? (#{:o :x} ((board a0) b0)))))\n      xyss [[0 0 0 1 0 2]\n            [1 0 1 1 1 2]\n            [2 0 2 1 2 2]\n            [0 0 1 0 2 0]\n            [0 1 1 1 2 1]\n            [0 2 1 2 2 2]\n            [0 0 1 1 2 2]\n            [2 0 1 1 0 2]]]\n  #(->> xyss\n        (map (partial winner %))\n        (some #{:o :x})))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":73,"code":"(fn [vs]\n  (let [lines [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        v (reduce into [] vs)\n        vals (map (fn [l] (map (fn [e] (v e)) l)) lines)]\n    (some {[:x :x :x] :x [:o :o :o] :o} vals)))","user":"4ede8e1d535d10e5ff6f5339"},{"problem":73,"code":"(fn winner? [board]\n  (let\n    [check (fn check [board combo pl]\n             (reduce (fn [sofar loc]\n                      (and sofar (= pl (get-in board loc))))\n                    true\n                    combo))\n     h (for [i [0 1 2]]\n        (for [j [0 1 2]]\n          [i j]))\n     v (for [i [0 1 2]]\n         (for [j [0 1 2]]\n           [j i]))\n     dr (for [i [0 1 2]]\n          [i i])\n     dl (for [i [0 1 2]]\n          [i (- 2 i)])\n     combos (-> (concat h v) (conj dr) (conj dl))]\n    (loop [result nil\n           notdone   combos]\n      (println (first notdone))\n      (if (seq notdone)\n          (if (not= (get-in board (-> notdone first first)) :e)\n              (if (check board (first notdone) (get-in board (-> notdone first first)))\n                (get-in board (-> notdone first first))\n                (recur nil (rest notdone)))\n              (recur nil (rest notdone)))\n          nil))))","user":"548fa2dfe4b0e286459a1240"},{"problem":73,"code":"(fn [arr]\n  (let [cols  (apply map (comp set vector) arr)\n        rows  (map set arr)\n        diags [(set (map get arr [0 1 2])) (set (map get arr [2 1 0]))]]\n    (reduce\n      #(if (and (= 1 (count %2)) (nil? (:e %2)))\n         (first %2)\n         %1)\n      nil\n      (concat cols rows diags))))","user":"5cf48f04e4b087f62be35a86"},{"problem":73,"code":"(fn winning-player\n  [board]\n  (let [rows (for [i (range 0 3)] (for [j (range 0 3)] [i j]))\n        cols (for [i (range 0 3)] (for [j (range 0 3)] [j i]))\n        main-diag (list (for [i (range 0 3)] [i i]))\n        anti-diag (list (for [i (range 0 3)] [i (- 2 i)]))\n        triples (concat rows cols main-diag anti-diag)\n        cell (fn [board [i j]] (get (get board i) j))\n        player (fn [board coords]\n                 (if (apply = (map (partial cell board) coords))\n                   (let [player (cell board (first coords))]\n                     (if (= player :e) nil player))\n                   nil))]\n    (some identity (map (partial player board) triples))))","user":"52ea025ae4b09f7907dd14b5"},{"code":"(letfn [(three-in-a-row [triple]\n                         (condp = triple\n                           [:x :x :x] :x\n                           [:o :o :o] :o\n                           nil))\n         (row-winner [board]\n                     (some \n                      identity\n                      (for [row board] (three-in-a-row row))))\n         (col-winner [board]\n                     (some \n                      identity\n                      (for [col (range 3)]\n                        (three-in-a-row [(get-in board [0 col])\n                                         (get-in board [1 col])\n                                         (get-in board [2 col])]))))\n         (diag-winner [board]\n                      (or (three-in-a-row [(get-in board [0 0])\n                                           (get-in board [1 1])\n                                           (get-in board [2 2])])\n                          (three-in-a-row [(get-in board [0 2])\n                                           (get-in board [1 1])\n                                           (get-in board [2 0])])))]\n   #(or (row-winner %) (col-winner %) (diag-winner %)))","problem":73,"user":"537bde5de4b06839e8705e73"},{"code":"(fn [coll]\n  (let [a  (concat\n             (partition 3 (flatten coll))\n\t           (apply map (fn [x y z](list x y z)) coll)\n\t           [[(first(first coll))(second (second coll))(last (last coll))]\n\t            [(last (first coll))(second (second coll))(first(last coll))]])]\n  (ffirst (filter (fn [coll] (or (every? #(= :o %) coll)(every? #(= :x %) coll))) a))))","problem":73,"user":"4db2cc55535df7e46ed9b6c5"},{"code":"(fn [[a b c]]\n     (let [q (into [a b c\n                    [(first a)(second b)(last c)]\n                    [(first c)(second b)(last a)]] (map vector a b c))\n           won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n       (first (remove nil? (map won? q)))))","problem":73,"user":"51fa7154e4b0f1313d4689da"},{"code":"(fn [v]\n  (let [winner (fn [[a b c]] (when (and (not= a :e) (= a b c)) a))\n        diag   (fn [[[a _ _] [_ b _] [_ _ c]]] [a b c])\n        cols   (apply mapv vector v)\n        diags  (vector (diag v) (diag (reverse v)))]\n    (reduce #(if % % (winner %2)) nil (concat v cols diags))))","problem":73,"user":"509b89b3e4b03049c49bd678"},{"problem":73,"code":"(fn winner [board]\n  (let [board (map (fn [r] (replace {:e nil} r)) board)\n        win-row (fn [rs]\n                  (map (fn [r]\n                         (if (= (count (distinct r)) 1)\n                           (first r)))\n                       rs))\n        arr (to-array-2d board)\n        hors (win-row board)\n        vers (win-row (for [i (range 3)]\n                        (for [j (range 3)]\n                          (aget arr j i))))\n        diags (win-row\n                [[(aget arr 0 0)\n                 (aget arr 1 1)\n                 (aget arr 2 2)]\n                [(aget arr 0 2)\n                 (aget arr 1 1)\n                 (aget arr 2 0)]])\n        ]\n    (some identity (concat hors vers diags))))","user":"5541fa50e4b0a04f79299515"},{"problem":73,"code":"(fn tic-tac-winner [board]\n  (letfn [(has-won? [board marker]\n            (let [win-line (repeat 3 marker)]\n              (or (some #(= % win-line) board)\n                  (some #(= % win-line) (apply mapv vector board))\n                  (= win-line (map #(get-in board [% %]) (range 3)))\n                  (= win-line (map #(get-in board [(- 2 %) %]) (range 3))))))]\n    (cond (has-won? board :x) :x\n          (has-won? board :o) :o)))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":73,"code":"(fn [board]\n  (let [process  (fn [lists] (->>\n                             lists\n                             (map #(set %))\n                             (filter #(= 1 (count %)))\n                             (filter #(not (= #{:e} %)))\n                             ffirst))\n        across   identity\n        down     #(apply map list %)\n        diagonal (fn [[[tl _ tr] [_ c _] [bl _ br]]] [[tl c br] [bl c tr]])]\n    (some #(process (% board)) [across down diagonal])))","user":"5463c824e4b01be26fd746c5"},{"code":"(fn winner [[one two three :as rows]]\n  (let [cols (apply map list rows)\n        bdiag (for [i (range 3)]\n                (get-in rows [i i]))\n        fdiag (for [i (range 3)]\n                (get-in rows [i (- 2 i)]))\n        triplets (concat rows cols [bdiag fdiag])]\n    (cond\n     (some #{(repeat 3 :x)} triplets) :x\n     (some #{(repeat 3 :o)} triplets) :o\n     :else nil)))","problem":73,"user":"530578ede4b0d8b024fd3760"},{"code":"(fn analyze-tic-tac-toe [board]\n\t(letfn [(row-filled? [board row value]\n\t\t\t\t(every? #(= value %) (nth board row))\n\t\t\t)\n\t\t\t(col-filled? [board col value]\n\t\t\t\t(every? #(= value %) (map #(nth % col) board))\n\t\t\t)\n\t\t\t(board-at [board x y]\n\t\t\t\t(nth (nth board x) y)\n\t\t\t)\n\t\t\t(diag-filled? [board value]\n\t\t\t\t(or (every? #(= value %) (map #(board-at board % %) (range 3)))\n\t\t\t\t\t(every? #(= value %) (map #(board-at board % (- 2 %)) (range 3)))\n\t\t\t\t)\n\t\t\t)\n\t\t\t(value-wins? [board value]\n\t\t\t\t(or (some #(row-filled? board % value) (range 3))\n\t\t\t\t\t(some #(col-filled? board % value) (range 3))\n\t\t\t\t\t(diag-filled? board value)\n\t\t\t\t)\t\n\t\t\t)\n\t\t]\n\t\t(first (filter #(value-wins? board %) '(:x :o))) \n\t)\n)","problem":73,"user":"52763696e4b03e8d9a4a74d7"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i] :as cells]]\n  (letfn [(win? [p]\n                (some #(= % [p p p])\n                      (concat cells \n                              (apply map list cells)\n                              [[a e i] [c e g]])))]\n    (cond\n     (win? :x) :x\n     (win? :o) :o\n     :else nil)))","user":"605b7a90e4b079a07f8593fc"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i]]]\n  (let [candidates [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]]\n        lines (filter #(= 1 (count %)) (map set candidates))\n        count_x (count (filter #(= #{:x} %) lines))\n        count_o (count (filter #(= #{:o} %) lines))]\n    (if (= count_x count_o)\n      nil\n      (if (< count_x count_o)\n        :o\n        :x))))","user":"53d86564e4b0e771c302546b"},{"problem":73,"code":"(fn [m]\n((fn victory[l]\n(let [res (filter\n                #(apply = %)\n                l\n                )]\n  (if (empty? res)\n    nil\n    ( if (not= :e (first (first res)))\n      (first (first res))\n      nil\n    ))))\n   \n((fn all3[[l1 l2 l3]]\n  (let [s (concat l1 l2 l3)]\n    (concat\n      ;; lines\n      (partition 3 s)\n      ;; cols\n      (map\n        #(take-nth 3 (drop % s))\n        (range 3))\n      ;; \\\n      (list (take-nth 4 s))\n      ;; /\n      (list (->> s (take-nth 2) (drop 1) (drop-last)))\n\n      ))) m)))","user":"5626447fe4b00e49c7cb47bd"},{"problem":73,"code":"(fn [board]\n  (first (first (filter #(or (every? #{:x} %)\n                             (every? #{:o} %)) \n                        (concat (map (fn [combo]\n                                     (map #(get-in board %) combo)) \n                                   [[[0 0] [1 1] [2 2]]\n                                    [[0 2] [1 1] [2 0]]\n                                    [[0 0] [1 0] [2 0]]\n                                    [[0 1] [1 1] [2 1]]\n                                    [[0 2] [1 2] [2 2]]\n                                    ])\n                                 board)))))","user":"544e9022e4b0e3978000698b"},{"problem":73,"code":"(fn [board]\n  (let [aux (fn [l]\n            (if (and (= 1 (count (set l))) (not= :e (first l))) (first l)))]\n    (or \n      (some aux board)\n      (some aux (apply map vector board))\n      (aux (map #(nth (last %) (first %)) (map-indexed vector board)))\n      (aux (map #(nth (last %) (first %)) (map-indexed vector (reverse board)))))))","user":"5550bcece4b00713264bd9ae"},{"code":"(fn [b]\n  (let [lines \n          (concat\n            (for [x [0 1 2]] (for [y [0 1 2]] [x y]))\n            (for [y [0 1 2]] (for [x [0 1 2]] [x y]))\n            '(([0 0] [1 1] [2 2]) ([0 2] [1 1] [2 0])))\n        collapsed\n          (zipmap \n            (for [x [0 1 2] y [0 1 2]] [x y]) \n            (flatten b))]\n    (some {#{:x} :x #{:o} :o} \n        (map #(set (map collapsed %)) lines))))","problem":73,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":73,"code":"(fn [[x y z]]\n  (let [u (set (map set (concat [x y z] (for [[a b c] [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]]\n                                          [(x a) (y b) (z c)]))))]\n    (cond (contains? u #{:x}) :x\n          (contains? u #{:o}) :o)))","user":"58f5b58ae4b0438e51c2cedc"},{"code":"(fn [t]\n  (let [g (vec (flatten t))\n        w #(let [v (map g %)]\n            (if (and (apply = v) (not= (first v) :e)) (first v) nil))\n        g [[0 1 2] [3 4 5] [6 7 8]\n           [0 3 6] [1 4 7] [3 5 8]\n           [0 4 8] [2 4 6]]]\n    (first (drop-while nil? (map w g)))))","problem":73,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn\n  [board]\n  (letfn\n      [(lookup [x y] ((board y) x))\n       (line\n         [start dir]\n         (take 3\n               (map (partial apply lookup)\n                    (iterate (partial map + dir) start))))\n       (line-winner\n         [start dir]\n         (let [line (line start dir)\n               first-line (first line)]\n           (if (and (not= :e first-line)\n                    (apply = line))\n             first-line)))]\n    (reduce #(or % %2)\n            (map line-winner\n                 [[0 0] [1 0] [2 0]\n                  [0 0] [0 1] [0 2]\n                  [0 0] [0 2]]\n                 (concat\n                  (repeat 3 [0 1])\n                  (repeat 3 [1 0])\n                  [[1 1] [1 -1]])))))","problem":73,"user":"4ebf11bc535dfed6da9c6d9c"},{"problem":73,"code":"(fn [[[a b c :as f] [d e f :as s] [g h i :as t]]]\n  (some {[:o :o :o] :o [:x :x :x] :x}\n        [f s t [a d g] [b e h] [c f i] [a e i] [c e g]]))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn quisimple? [TTTb]\n  (letfn [(q? [TTTb jugador]\n     (let [[[a b c]\n            [d e f]\n            [g h i]] TTTb]\n        (cond\n         (= a b c jugador) jugador\n         (= d e f jugador) jugador\n         (= g h i jugador) jugador\n         (= a e i jugador) jugador\n         (= g e c jugador) jugador\n         (= a d g jugador) jugador\n         (= b e h jugador) jugador\n         (= c f i jugador) jugador\n         :else nil))\n           )]\n\n      (cond\n       (= (q? TTTb :x) :x) :x\n       (= (q? TTTb :o) :o) :o\n       :else nil)))","problem":73,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"( fn [table] \n     (let [ \n       lcd (concat table \n                   (apply map vector table)\n                   (vector (map #(nth %2 %1) [0 1 2] table ))\n                   (vector (map #(nth %2 %1) [2 1 0] table ))\n                   )\n      ]  \n     (first (some #{ [:x :x :x] [:o :o :o]} lcd))))","problem":73,"user":"4f030775535dcb61093f6a43"},{"code":"(fn ttt [v] (letfn [(f [a b c] (if (and (= a b c) (not (= a :e))) a nil))] (let [g (remove nil? (cons (f ((v 0) 0) ((v 1) 1) ((v 2) 2)) (cons (f ((v 2) 0) ((v 1) 1) ((v 0) 2))  \n                     (concat (map #(apply f %) v) (apply map #(f % %2 %3) v) ))))] (first g))))","problem":73,"user":"51b90b88e4b050a1176cd6a2"},{"problem":73,"code":"(fn [[r1 r2 r3]]\n  (let [check-seq (fn [[h :as s]] (if (apply = s) h :e))\n        column (fn [i] (map #(% i) [r1 r2 r3]))\n        diagonal (fn [board] (map (fn [r i] (r i)) board (range)))\n        possibs (vector\n                  r1 r2 r3\n                  (column 0) (column 1) (column 2)\n                  (diagonal [r1 r2 r3])\n                  (diagonal [r3 r2 r1]))]\n    (first (filter #(not= :e %) (map check-seq possibs)))))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":73,"code":"(fn [field]\n  (letfn [(diagonal [field which]\n            (mapv\n              #(nth %1 %2)\n              (if (= which :left) field (reverse field))\n              (range 3)))\n          (vertical [field which]\n            (map #(nth % which) field))\n          (all= [coll x]\n            (reduce\n              #(if (false? %1) false (= %2 x))\n              true\n              coll))\n          (winner [row]\n            (cond\n              (all= row :x) :x\n              (all= row :o) :o\n              :else nil))]\n    (let [combinations (conj field (vertical field 0) (vertical field 1) (vertical field 2) (diagonal field :left) (diagonal field :right))]\n      (reduce\n        #(if %1 %1 (winner %2))\n        false\n        combinations))))","user":"5773f3a9e4b0979f896515f2"},{"problem":73,"code":"(fn __\n  [game-state]\n  (let [is-all-equal (fn [collection] (apply = collection))\n        is-winner (fn [[value :as collection]]\n                    (if (and (is-all-equal collection) (not= value :e))\n                      value))\n        get-main-diagonal (fn [collection]\n                            (list\n                              (first (first collection))\n                              (second (second collection))\n                              (last (last collection))))\n        get-secondary-diagonal (fn [collection]\n                                 (list\n                                   (first (last collection))\n                                   (second (second collection))\n                                   (last (first collection))))]\n    (loop [[row & rest-of-rows] (concat (conj game-state (get-main-diagonal game-state) (get-secondary-diagonal game-state))\n                        (apply map #(identity %&) game-state))]\n      (if (not (nil? row))\n        (if (is-winner row)\n          (first row)\n          (recur rest-of-rows))))))","user":"5ac91d90e4b0e27600da77bd"},{"problem":73,"code":"(fn [board]\n    (letfn [(allcomb [sa sb]\n              (if (empty? sa)\n                '()\n                (concat (partition 2 (interleave (repeat (first sa)) sb))\n                        (allcomb (rest sa) sb))))\n            (boardruns [n]\n                       (let [nr (range n)]\n                         (concat\n                          (list (map list nr nr))            ; main diagonal\n                          (list (map list nr (reverse nr)))  ; inverse diagonal\n                          (partition n (allcomb nr nr))\n                          (partition n (map reverse (allcomb nr nr))))))\n            (runwonby? [run side]\n                       (empty? (filter #(not= side %) run)))]\n      (let [n (count board)\n            allruns (map #(map (partial get-in board) %) (boardruns n))\n            x-won (some #(runwonby? % :x) allruns)\n            o-won (some #(runwonby? % :o) allruns)]\n        (cond\n          x-won :x\n          o-won :o\n          :else nil))))","user":"56eaad95e4b04a395b9a040f"},{"problem":73,"code":"(fn [board]\n  (let [all-vecs (conj board              ; rows\n                       (map first board)  ; first column\n                       (map second board) ; second column\n                       (map last board)   ; third column\n                       [(get-in board [0 0])\n                        (get-in board [1 1])\n                        (get-in board [2 2])] ; diagonal 1\n                       [(get-in board [0 2])\n                        (get-in board [1 1])\n                        (get-in board [2 0])] ; diagonal 2\n                       )\n        ]\n    (-> (filter #(and (apply = %)\n                      (not= (first %) :e))\n                all-vecs)\n        (first)\n        (first))\n    ))","user":"5ee75f8be4b029a2061bbea5"},{"code":"(fn winner? [rows]\n  (let [[trow mrow brow] rows\n        win? (fn [row]\n               (let [fst (first row)]\n                 (if (and (not= fst :e) (apply = row))\n                   fst\n                   nil)))]\n    (some win? (concat rows (map vector trow mrow brow) (vector (vector (first trow) (second mrow) (last brow))) (vector (vector (last trow) (second mrow) (first brow)))))))","problem":73,"user":"51195e77e4b055cfb310d499"},{"problem":73,"code":"(fn [board]\n  (letfn [\n          (rows [b] b)\n          (cols [b] (partition 3 (apply interleave b)))\n          (diags [b] (letfn [(m [row col] (nth (nth b row) col))]\n                       (vector (vector  (m 0 0) (m 1 1) (m 2 2))\n                               (vector (m 2 0) (m 1 1) (m 0 2)))))\n          (allrows [b] (concat (rows b) (cols b) (diags b)))\n          (winner [r] (reduce-kv (fn [i k v] (when (= 3 v) k)) nil (frequencies r)))]\n(->> board\n     (allrows)\n     (map winner)\n     (filter #(contains? #{:x :o} %))\n     first)))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn tic-tac-toe- [board]\n  ^{:doc \"73. Write a function which analyzes a tic-tac-toe board and                                                                                                   \n  returns :x if X has won, :o if O has won, and nil if neither player                                                                                                   \n  has won.\"}\n  (->> board ; rows                                                                                                                                                     \n       (cons (map first board)) ; col1                                                                                                                                  \n       (cons (map second board)) ; col2                                                                                                                                 \n       (cons (map last board)) ; col3                                                                                                                                   \n       (cons (list (ffirst board) (second (second board)) (last (last board)))) ; diag1                                                                                 \n       (cons (list (first (last board)) (second (second board)) (last (first board)))) ; diag1                                                                          \n       (filter (partial apply not= :e)) ; ignore empty rows                                                                                                             \n       (filter (partial apply =)) ; keep winning rows                                                                                                                   \n       (ffirst) ; return the winner                                                                                                                                     \n       ))","problem":73,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":73,"code":"(let [winner? (fn [board player]\n                (let [winning-state? (partial = (repeat 3 player))]\n                  (when (or (some winning-state? board)\n                            (some (comp winning-state? #(map % board)) [first second #(nth % 2)])\n                            (winning-state? (map-indexed (fn [i row] (nth row i)) board))\n                            (winning-state? (map-indexed (fn [i row] (nth row (- 2 i))) board)))\n                    player)))]\n  (fn [board]\n    (or (winner? board :x)\n        (winner? board :o))))","user":"5afc0f30e4b0cc2b61a3bcfe"},{"problem":73,"code":"(fn [board]\n    (let [third (fn [x] (second (rest x)))\n          rows board\n          columns [(map first board) (map second board) (map third board)]\n          diagonals [[(-> board first first) (-> board second second) (-> board third third)]\n                     [(-> board first third) (-> board second second) (-> board third first)]]\n          x [:x :x :x]\n          o [:o :o :o]\n          triplets (concat rows columns diagonals)]\n      (loop [triplets triplets]\n        (when (seq triplets)\n          (cond\n            (= (first triplets) x) :x\n            (= (first triplets) o) :o\n            :else (recur (rest triplets)))))))","user":"54be792ee4b0ed20f4ff6eeb"},{"code":"(fn [board]\n    (letfn [(won? [vector]\n                (if (apply = vector)\n                    (and (not (= (first vector) :e)) (first vector))\n                    false))\n            (diagonal [matrix indices]\n                (map (fn [row index]\n                        (nth row index))\n                     matrix\n                     indices))\n            (column [matrix index]\n                (map (fn [row] (nth row index))\n                    matrix))]\n       (or (some won? board)\n           (won? (diagonal board (range (count board))))\n           (won? (diagonal board (reverse (range (count board)))))\n           (some won? (map (partial column board) (range (count board))))\n           nil)))","problem":73,"user":"510bf81be4b078ea71921107"},{"problem":73,"code":"(fn [[[a b c]\r\n      [d e f]\r\n      [g h i]]]\r\n  (cond\r\n    (and (not= a :e) (or (= a b c) (= a d g) (= a e i))) a\r\n    (and (not= d :e) (= d e f)) d\r\n    (and (not= g :e) (or (= g h i) (= g e c))) g\r\n    (and (not= b :e) (= b e h)) b\r\n    (and (not= c :e) (= c f i)) c))","user":"5f2c02d1e4b033932238a65f"},{"code":"(fn tic-tac-toe [matrix]\n  (let [triplets (concat matrix\n                         (partition 3 (for [x [0 1 2] m matrix] (get m x)))\n                         [[((matrix 0) 0) ((matrix 1) 1) ((matrix 2) 2)]]\n                         [[((matrix 0) 2) ((matrix 1) 1) ((matrix 2) 0)]])]\n    (some #(when (and (apply = %) (not= :e (first %)))\n             (first %))\n          triplets)))","problem":73,"user":"4e5bff2b535d8a8b8723a2bd"},{"code":"(fn [b]\n  (let [solutions [\n                  [[0 0] [0 1] [0 2]]\n                  [[1 0] [1 1] [1 2]]\n                  [[2 0] [2 1] [2 2]]\n                  [[0 0] [1 0] [2 0]]\n                  [[0 1] [1 1] [2 1]]\n                  [[0 2] [1 2] [2 2]]\n                  [[0 0] [1 1] [2 2]]\n                  [[0 2] [1 1] [2 0]]\n                  ]\n        coord #(let [l (nth %1 (first %2))]\n                  (nth l (second %2)))\n        ccheck (fn [ib c]\n                (let [icheck (fn [ln] (every? #(= c (coord ib %)) ln))]\n                (some icheck solutions)))]\n    (if (ccheck b :x) :x\n      (if (ccheck b :o) :o nil))))","problem":73,"user":"4f03a3df535dcb61093f6b45"},{"problem":73,"code":"(fn [board]\n  (let [diagonals-idxs [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n        diagonal (partial map #(get-in board %))\n        columns (partial apply (partial map (fn [a b c] [a b c])))\n        rows identity\n        any-complete? (fn [mark coll]\n                        (some (fn [cell] (= 3 (count (filter #(= mark %) cell)))) coll))\n        wins? (fn [board mark]\n                (some (partial any-complete? mark)\n                      [(map diagonal diagonals-idxs) (columns board) (rows board)]))]\n    (cond (wins? board :x) :x\n          (wins? board :o) :o\n          :else nil)))","user":"52f3568fe4b05e3f0be25f0e"},{"problem":73,"code":"(fn [b]\n  (let [t (apply map vector b)\n        d [(map nth b (range))\n                  (map nth (rseq b) (range))]]\n    (->> (concat b t d)\n         (filter #(apply = %))\n         ffirst\n         #{:x :o})))","user":"603ae21de4b0d5df2af222fb"},{"problem":73,"code":"(fn [board]\n  (letfn [(third [x] (get x 2))\n          (win? [mark combo] (every? #(= % mark) combo))\n          (order [n] (cond (= n 1) first (= n 2) second (= n 3) third))]\n    (let [winner (atom nil)]\n      \n      ;; Check horizontal wins\n      (doseq [row board]\n        (cond\n         (win? :o row) (reset! winner :o)\n         (win? :x row) (reset! winner :x)))\n      \n      ;; Check vertical wins\n      (doseq [cnum (range 1 4)]\n        (cond\n         (win? :o (map (order cnum) board)) (reset! winner :o)\n         (win? :x (map (order cnum) board)) (reset! winner :x)))\n      \n      ;; Check diagonal wins\n      (cond \n       (win? :o [((comp first first) board) ((comp second second) board) ((comp third third) board)])\n       (reset! winner :o)\n       (win? :x [((comp first first) board) ((comp second second) board) ((comp third third) board)])\n       (reset! winner :x)\n       (win? :o [((comp first third) board) ((comp second second) board) ((comp third first) board)])\n       (reset! winner :o)\n       (win? :o [((comp first first) board) ((comp second second) board) ((comp third third) board)])\n       (reset! winner :x))\n      \n      @winner)))","user":"53d977f1e4b0e771c302547a"},{"problem":73,"code":";; brute-force destructuring version\n(fn [board]\n  (let [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]] board]\n    (->> [:x :o]\n         (some #(when (or (= a1 a2 a3 %)\n                         (= b1 b2 b3 %)\n                         (= c1 c2 c3 %)\n                         (= a1 b1 c1 %)\n                         (= a2 b2 c2 %)\n                         (= a3 b3 c3 %)\n                         (= a1 b2 c3 %)\n                         (= a3 b2 c1 %))\n                 %)))))\n;; alternate version\n;; TODO how to remove nested if-some\n;(fn [board]\n;  (if-some [horizontal-winner (->> [:x :o]\n;                                   (some #(when (some (partial every? (partial = %)) board) %)))]\n;    horizontal-winner\n;    (if-some [vertical-winner (->> [:x :o]\n;                                   (some\n;                                    #(when (some (fn [n]\n;                                                   (every? (partial = %)\n;                                                           (map (fn [row]\n;                                                                  (nth row n))\n;                                                                board)))\n;                                                 (range (count board)))\n;                                       %)))]\n;      vertical-winner\n;      (let [[[a _ b]\n;             [_ m _]\n;             [c _ d]] board] ;; TODO maybe use incrementing index instead? I.e. (map #(get-in board [% %]) (range (count board))\n;        (when-some [diagonal-winner (->> [:x :o]\n;                                         (some #(when (or (= a m d %)\n;                                                         (= b m c %))\n;                                                 %)))]\n;          diagonal-winner)))))","user":"60794173e4b0a637ed78035d"},{"code":"(fn [vs] (let [x (some #(if (apply = %) (first %))\n (concat vs  (apply map vector vs) [[(first (first vs)) (second (second vs)) (last (last vs))] [(last (first vs)) (second (second vs)) (first (last vs))]]))] \n(cond\n(= x :e) nil\n(= x :o) :o\n(= x :x) :x)\n))","problem":73,"user":"517945dce4b0684c1c981a43"},{"problem":73,"code":"(fn [board]\n (letfn [(check [[[a b c][d e f][g h i]] p]\n  (or (= p a b c)\n      (= p d e f)\n      (= p g h i)\n      (= p a d g)\n      (= p b e h)\n      (= p c f i)\n      (= p a e i)\n      (= p c e g)))]\n   (cond (check board :x) :x\n         (check board :o) :o\n         :else nil)))","user":"5b61aa6ae4b0c6492753e712"},{"problem":73,"code":"(fn [args]\n  (let [[nw n ne w c e sw s se] (mapcat (fn[row] (map #(case % :e 0 :x 1 :o -1) row)) args)\n        sum (list (+ nw w sw) (+ n c s) (+ ne e sw) (+ nw n ne) (+ w c e) (+ sw s se) (+ nw c se) (+ sw c ne))]\n    (loop [s sum]\n      (case (first s) nil nil 3 :x -3 :o (recur (rest s))))))","user":"53ab17cae4b047364c04444a"},{"code":"(fn [ttt] (letfn [(pivot [t] (reverse (for [p (range 3)] (map #(nth % p) t))))\n                             (diag [t] (map-indexed (fn [i l] (nth l i)) t))]\n                            (->> (concat ttt (pivot ttt) [(diag ttt) (diag (pivot ttt))])\n                              (map (fn [l] (when (and (apply = l) (not= (first l) :e)) (first l))))\n                              (some identity))))","problem":73,"user":"5137c3b0e4b0509a8b470482"},{"problem":73,"code":"(fn [board]\n(let [x-row (repeat 3 :x)\n      o-row (repeat 3 :o)\n      straight #(or (some #{x-row} %)\n                    (some #{o-row} %)\n                    nil)]\n  (or (first (straight board)) ; win by row\n      (let [transposed (apply map list board)]\n        (first (straight transposed))) ; win by column\n      (let [diagonals [(map #(get-in board [% %])\n                            [0 1 2])\n                       (map #(get-in board [%1 %2])\n                            [0 1 2] [2 1 0])]]\n        (first (straight diagonals))) ; win by diagonal\n      nil))) ; no win","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":73,"code":"(fn [g] (let [win (fn [v] (if (and (apply = v) (not= (v 0) :e)) (v 0)))\n              r (range 3)]\n            (some win (concat g\n                              (apply map vector g)\n                              [(mapv #((g %) %) r)\n                               (mapv #((g %1) %2) r (reverse r))]))))","user":"5175533fe4b0dea9bbfba575"},{"code":"(fn win [boarder]\n  (letfn [\n          \t(down-dir [[x y]] [(inc x) y])\n\n\t\t\t(right-dir [[x y]] [x (inc y)])\n\n\t\t\t(right-down-dir [[x y]] [(inc x) (inc y)])\n\n\t\t\t(left-down-dir [[x y]] [(inc x) (dec y)])\n\n            (all-posiontions []\n              (for [x (range 3)\n                    y (range 3)]\n                [x y]))\n          \n          \t(win-positions [f [x y]]\n \t\t\t (take 3 (iterate f [x y])))\n          \n         \t (who-win [[a b c]]\n  \t\t\t\t(if (or (= a b c :x) (= a b c :o))\n    \t\t\ta))\n           \t(is-position-suitable? [[x y]]\n  \t\t\t\t(and (> x -1) (> y -1) (< x 3) (< y 3)))\n       \t\t(all-win-positions []\n  \t\t\t\t(apply concat \n         \t\t\t(for [dir-fn [down-dir right-dir right-down-dir left-down-dir]]\n           \t\t\t\t(filter #(every? is-position-suitable? %) \n                   \t\t\t\t(map #(win-positions dir-fn %) (all-posiontions))))))]\n  (first \n   (remove nil? \n           (map who-win \n                (map #(for [xy-pos %] (get-in boarder xy-pos)) (all-win-positions)))))))","problem":73,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn [[[x1 _ x2][_ o _][y1 _ y2] :as c]]\n    (->> (map (fn [n] (map #(nth % n) c)) (range 3))\n         (concat c [[x1 o y2] [x2 o y1]])\n         (some {[:x :x :x] :x [:o :o :o] :o})))","problem":73,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (let [w\n  (or (and (= a b c) a)\n      (and (= d e f) d)\n      (and (= g h i) g)\n      (and (= a d g) a)\n      (and (= b e h) b)\n      (and (= c f i) c)\n      (and (= a e i) a)\n      (and (= g e c) g)\n      nil)]\n    (if (= w :e)\n      \tnil\n        w)))","problem":73,"user":"4feef09ae4b0678c553fc30e"},{"code":"(fn [board]\n  ;; define a function for row assessment\n  (let [row-fun (fn [board]\n                  (let [row-value-set (set (filter #(= 1 (count %)) (map (fn [x] (distinct x)) board)))]\n                    (cond\n                     (contains? row-value-set '(:o)) :o\n                     (contains? row-value-set '(:x)) :x\n                     :else                           nil)))\n        ;; Get values for each one rows, cols, and diags using row-fun\n        row  (row-fun board)\n        col  (row-fun (apply map vector board))\n        diag (let [diag1 [(get-in board [0 0])\n                          (get-in board [1 1])\n                          (get-in board [2 2])]\n                   diag2 [(get-in board [0 2])\n                          (get-in board [1 1])\n                          (get-in board [2 0])]]\n               (row-fun [diag1 diag2]))]\n    ;; Check for non-nil values, (first '()) will result in nil\n    (first (filter (complement nil?) [row col diag]))))","problem":73,"user":"53415755e4b00652c8746ecd"},{"problem":73,"code":"(fn [[[a b c][p q r][x y z]]]\n       (letfn [(has-won? [n] (reduce (fn [a b] (or a b)) (map #(every? (fn[el] (= n el)) %) [[b q y] [p q r] [a q z] [x q c] [a p x] [a b c] [c r z] [x y z]])))]\n    \n \t(cond\n      (has-won? :x) :x\n\t  (has-won? :o) :o\n     :else nil)\n   )\n   )","user":"55d7312ee4b0e31453f64a9f"},{"code":"(fn [b]\n  (ffirst (remove empty?\n    (for [p [:x :o]]\n      (first (filter #(apply = p %)\n                     (map #(map (partial nth (flatten b)) %)\n                          [[0 1 2] [3 4 5] [6 7 8]\n                           [0 3 6] [1 4 7] [2 5 8]\n                           [0 4 8] [2 4 6]])))))))","problem":73,"user":"4e4ad154535dc968683fc4d1"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (let [x :x o :o]\n    (letfn [(horizontal-check\n                [board]\n              (filter\n               #(not (nil? %))\n               (map #(cond (every? (partial = x) %)\n                          x\n                          (every? (partial = o) %)\n                          o) board)))\n            (invert-board\n              [board]\n              (if (seq (flatten board))\n                (cons (map first board) (invert-board (map rest board)))))\n            (diagonal\n              [board]\n              (if (seq (flatten board))\n                (cons (ffirst board) (diagonal (rest (map rest board))))))]\n      (first (drop-while nil? (flatten\n                ((juxt\n                 horizontal-check ;; check for horizontal win\n                 (comp horizontal-check invert-board) ;; check for vertical win\n                 (comp horizontal-check vector diagonal) ;; check for bottom-left-to-top-right win\n                 (comp horizontal-check vector diagonal #(map reverse %))) board))))))) ;; check for top-left-to-bottom-right win","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [board] (let [diagonal (fn [rows] (vector (first (first rows))\n                                              (second (second rows))\n                                              (nth (nth rows 2) 2)))\n                  row-winner (fn [[one two three]]\n                               (if (and (= one two three) (not= one :e))\n                                (identity one)\n                                (identity nil)))\n                  rows (reduce conj(into [] (apply map vector board))\n                                   (conj board\n                                         (diagonal board)\n                                         (diagonal (reverse board))))]\n (first(remove nil? (map row-winner rows)))))","problem":73,"user":"4fa38e3fe4b081705acca190"},{"code":"(fn [board]\n  (let [row-to-winner (fn [row] (reduce #(if (or (not= % %2) (= % :e)) nil %) row))]\n  (let [check (fn [colls] (reduce  #(if (nil? %) %2 %) (map row-to-winner colls)))]\n  (let [rotate (fn [colls] (apply map #(vector %1 %2 %3) (reverse colls)))]\n  (let [diag (fn [coll] (vector (ffirst coll) (second (second coll)) (last (last coll))))]\n    (or (first (remove nil?(vector (check board) (check (rotate board))  (row-to-winner(diag board))  (row-to-winner(diag (rotate board)))  ))) nil ))))))","problem":73,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(letfn\n    [(diaganol [[[h & t] & t :as rows]]\n       (when h (cons h (diaganol (map rest t)))))\n\n     (vertical [xs] (apply map vector xs))\n\n     (find-paths [board] (concat board\n                                 [(diaganol board)]\n                                 [(diaganol (reverse board))]\n                                 (vertical board)))]\n\n  (fn anal-tic [board]\n    (->> (find-paths board)\n         (remove #(apply = :e %))\n         (filter #(apply = %))\n         (ffirst))))","problem":73,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":73,"code":"(fn tic-tac [rows]\n  (let [all-equal? (fn [r x] (every? #(= % x) r))\n        verts (apply map vector rows)\n        diags [[(get-in rows [0 0]), (get-in rows [1 1]), (get-in rows [2 2])]\n               [(get-in rows [0 2]), (get-in rows [1 1]), (get-in rows [2 0])]]]\n    (if\n      (some #(all-equal? % :x) (concat rows verts diags))\n      :x\n      (if (some #(all-equal? % :o) (concat rows verts diags))\n        :o\n        nil))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [in]\r\n              (first (filter (complement nil?)\r\n                       (map (fn [is] \r\n                              (let [res (map (fn [[x y]] ((in x) y)) is)]\r\n                                (if (or\r\n                                      (every? #{:x} res)\r\n                                      (every? #{:o} res))\r\n                                  (first res)\r\n                                  nil)))\r\n                         [[[0 0] [0 1] [0 2]]\r\n                          [[1 0] [1 1] [1 2]]\r\n                          [[2 0] [2 1] [2 2]]\r\n                          [[0 0] [1 0] [2 0]]\r\n                          [[0 1] [1 1] [2 1]]\r\n                          [[0 2] [1 2] [2 2]]\r\n                          [[0 0] [1 1] [2 2]]\r\n                          [[0 2] [1 1] [2 0]]]))))","problem":73,"user":"4deb529a535d08e6dec9fe04"},{"code":"(fn [board]\n  (let [boardv (reduce into board)\n        upper-left (boardv 0)\n        center (boardv 4)\n        lower-right (boardv 8)\n        filled #{:x :o}]\n    (cond\n     (and\n      (filled center)\n      (some true? (for [i (range 4)]\n                    (= center (boardv i) (boardv (- 8 i))))))\n     , center\n     (and\n      (filled upper-left)\n      (or (= upper-left (boardv 1) (boardv 2))\n          (= upper-left (boardv 3) (boardv 6))))\n     , upper-left\n     (and\n      (filled lower-right)\n      (or (= lower-right (boardv 2) (boardv 5))\n          (= lower-right (boardv 6) (boardv 7))))\n     , lower-right\n     :else\n     , nil)))","problem":73,"user":"5095f761e4b0ba05ca7aebfd"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (cond (or (= a b c :x) (= d e f :x) (= g h i :x)\n            (= a d g :x) (= b e h :x) (= c f i :x)\n            (= a e i :x) (= c e g :x))\n        :x\n        (or (= a b c :o) (= d e f :o) (= g h i :o)\n            (= a d g :o) (= b e h :o) (= c f i :o)\n            (= a e i :o) (= c e g :o))\n        :o\n        :else nil))","problem":73,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":73,"code":"(fn analyze [board]\n  (letfn [(any-win [board]\n            (for [row board]\n              (if (and (= 1 (count (set row)))\n                       (not (= :e (first row))))\n                (first row)\n                nil)))]\n    ;; Check the rows of the board whether any wins \n    (let [row-check (filter #(not (nil? %)) (any-win board))]\n      (if-not (empty? row-check)\n        (first row-check)\n        ;; Check the columns of the board whether any wins\n        (let [columns (map (fn [x] (map #(nth % x) board)) [0 1 2])\n              column-check (filter #(not (nil? %)) (any-win columns))]\n          (if-not (empty? column-check)\n            (first column-check)\n            ;; Check the slanting diagonal  \n            (let [diag (map #(nth (nth board %) %) [0 1 2])\n                  diag-check (filter #(not (nil? %)) (any-win [diag]))]\n              (if-not (empty? diag-check)\n                (first diag-check)\n                ;; Check the climbing diagonal\n                (let [rev-diag (map #(nth (nth (reverse board) %) %) [0 1 2])\n                      rev-diag-check (filter #(not (nil? %)) (any-win [rev-diag]))]\n                  (if-not (empty? rev-diag-check)\n                    (first rev-diag-check)\n                    nil))))))))))","user":"5ddb6151e4b0948ae9d9adb0"},{"problem":73,"code":"(fn [rows] \n  (let [chk (concat \n             rows \n             (for [i (range 3)] (map #(nth % i) rows))\n             (for [d [[0 1 2] [2 1 0]]] (map #(nth % %2) rows d)))] \n    (first (filter #{:x :o} (map first (filter #(= 1 (count %)) (map distinct chk)))))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":73,"code":"(fn [col]\n\t(let [s (mapcat identity col)\n\t\t  r (mapcat reverse col)\n\t\t  d-a (apply concat (partition 1 4 s))\n\t\t  d-b (apply concat (partition 1 4 r))\n\t\t  all (conj (into col (apply map vector col)) d-a d-b)]\n\t\t(cond\n\t\t\t(->> (map (partial apply = :x) all) (some true?)) :x\n\t\t\t(->> (map (partial apply = :o) all) (some true?)) :o)))","user":"55b8c339e4b01b9910ae29b9"},{"problem":73,"code":"(fn [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]\n         (let [h1 (when (= a1 a2 a3) a1)\n               h2 (when (= b1 b2 b3) b1)\n               h3 (when (= c1 c2 c3) c1)\n               v1 (when (= a1 b1 c1) a1)\n               v2 (when (= a2 b2 c2) a2)\n               v3 (when (= a3 b3 c3) a3)\n               d1 (when (= a1 b2 c3) a1)\n               d2 (when (= a3 b2 c1) a3)\n               r [h1 h2 h3 v1 v2 v3 d1 d2]]\n           (first (filter #{:x :o} r))\n           ))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"(fn verify-ttt? [board]\n  (let [transpose (fn [[x y]] [y x])\n        shift (fn [q [x y]] [(+ x q) y])\n        shifts (mapv #(partial shift %) (range 3))\n        test-funs (for [tr [identity transpose] sh shifts]\n                    (comp tr sh))\n        get-in-t (fn [m transform coords]\n                   (mapv #(get-in m (transform %)) coords))\n        straights (set (map #(get-in-t board % [[0 0] [0 1] [0 2]]) test-funs))\n        all (set (concat [(get-in-t board identity [[0 0] [1 1] [2 2]])]\n                         [(get-in-t board identity [[0 2] [1 1] [2 0]])]\n                         straights))]\n    (cond (all [:x :x :x]) :x\n          (all [:o :o :o]) :o)))","problem":73,"user":"51a768e0e4b0da5f497bde84"},{"code":"(fn [[[a b c]\n      [d e f]\n      [g h i]]]\n  (let [lines [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]]\n        winning-line (fn [line]\n                       (cond (every? #{:x} line) :x\n                             (every? #{:o} line) :o))]\n    (some winning-line lines)))","problem":73,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":73,"code":"(fn [c]\n  (let [v (map vector (first c) (second c) (last c))\n        rs (vector (ffirst c) (second (second c)) (last (last c)))\n        ls (vector (last (first c)) (second (second c)) (first (last c)))\n        al (concat c v (vector rs) (vector ls))]\n    (ffirst (filter #(or (= [:x :x :x] %) (= [:o :o :o] %)) al))))","user":"55933c7ae4b0c79f6e1db938"},{"code":"(fn [rows]\n    (let [complete? (fn [player row]\n                          (= (replicate 3 player) row))\n          column (fn [i]\n                   (vec (map #(nth % i) rows)))\n          columns (vec (map column (range 3)))\n          diagonal (fn [rows]\n                     (vec (map (fn [i] (-> rows (nth i) (nth i)))\n                               (range 3))))\n          diagonal1 (diagonal rows)\n          diagonal2 (diagonal (map reverse rows))\n          wins? (fn [player] (some (partial complete? player)\n                                   (concat rows columns [diagonal1 diagonal2])))]\n      (cond (wins? :x) :x\n            (wins? :o) :o)))","problem":73,"user":"4f46bc41e4b0d56e7bb92ba5"},{"code":"(fn winner [board]\n  (letfn [(ew [n]\n            (if (apply = (board n)) (first (board n))))\n          (nw [n]\n            (if (apply = (map #(% n) board)) ((first board) n)))\n          (nw-se []\n            (let [[[x _ _] [_ y _] [_ _ z]] board]\n              (if (= x y z) x)))\n          (ne-sw []\n            (let [[[_ _ x] [_ y _] [z _ _]] board]\n              (if (= x y z) x)))]\n    (some #{:x :o} (conj (mapcat (juxt ew nw) (range 3)) (nw-se) (ne-sw)))))","problem":73,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn [b] \n  (let [check (fn [[[a b c] [d e f] [g h i]] s] \n    (some identity [(= a b c s) (= d e f s) (= g h i s)\n                    (= a d g s) (= b e h s) (= c f i s)\n                    (= a e i s) (= c e g s)]))] \n    (cond (check b :x) :x (check b :o) :o)))","problem":73,"user":"4f1fd734535d64f6031464a5"},{"problem":73,"code":"(fn tictactoe [board]\n  (let [board2  \n        (->> board (apply concat) (map-indexed (fn [idx item] [idx item])))\n        winning-combinations \n        [#{0 1 2}\n         #{3 4 5}\n         #{6 7 8}\n         #{0 4 8}\n         #{6 4 2}\n         #{0 3 6}\n         #{1 4 7}\n         #{2 5 8}] \n        {:keys [x-set o-set]}\n        (reduce (fn [{:keys [x-set o-set]} item]\n                  {:x-set \n                   (if (= :x (last item))\n                     (conj x-set (first item))\n                     x-set)\n                   :o-set \n                   (if (= :o (last item))\n                     (conj o-set (first item))\n                     o-set)})\n                {:x-set #{} :o-set #{}} board2)\n        win-for (fn [my-set]\n                  (println \"my-set\" my-set)\n                  (some #(clojure.set/subset? % my-set)  winning-combinations))]\n    (if false (do \n                (println \"xset=\" x-set)\n                (println \"oset=\" o-set)\n                (println \"winning-combinations\" winning-combinations) \n                (println \"board\" board)\n                (println \"board2\" board2)))\n    (cond\n      (win-for x-set)\n      :x  \n      (win-for o-set)\n      :o\n      true\n      nil)))","user":"539f9f79e4b0ca733b97449e"},{"code":"(fn f [b]\n  (let [transposed (apply map list b),\n        d1 [(map-indexed #(nth %2 %) b)],\n        d2 [(map-indexed #(nth %2 %) (reverse b))],\n        lines (mapcat identity [b, transposed, d1,  d2])]\n    (cond (some #{[:x :x :x]} lines) :x\n          (some #{[:o :o :o]} lines) :o\n          :else nil\n      )))","problem":73,"user":"4e7db3b4535db169f9c796e1"},{"problem":73,"code":"(fn  [x]\n  (let [s (vec (apply concat x) )\n        t [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        r  (map \n           (fn  [[a b c]] \n             (let [aa (s a) bb (s b) cc (s c) n (count (set [aa bb cc]))]  \n               (if (and (= n 1) (not= aa :e)) aa nil  )   \n               ) \n             )  \n           t)\n        ]\n    (  reduce (fn  [a b] (if (= nil b) a b) ) nil r   )\n   )\n )","user":"5da98129e4b000c986472c33"},{"code":"(fn w[b]\n  (let\n      [wins? (fn[b k]\n               (let [\n                     parse #(Integer/parseInt % %2)\n                     nums (map (fn[r](parse (apply str (map #(get {k 1} % 0) r)) 2 )) b)\n                     num (parse (apply str nums) 8)]\n                 (some #(= (bit-and num %) %)\n                       (map #(parse % 8)\n                            (re-seq #\"\\d+\" \"700 070 007 111 222 444 124 421\")))))]\n    (cond (wins? b :x) :x\n          (wins? b :o) :o\n          )))","problem":73,"user":"507c7c8be4b0b083f3ff82ef"},{"problem":73,"code":"(fn ttt \n  [board]\n  (let [check-three (fn [t] (reduce #(if (= %1 %2) (if (= :e %1) nil %1) nil) t))\n        check-rows (fn [s] (some identity (map check-three s)))]\n    (if-let [result (check-rows board)]\n      result\n      (let [cols-to-rows (apply map list board)]\n        (if-let [result (check-rows cols-to-rows)]\n          result\n          (let [[[d1 _ d2][_ d3 _][d4 _ d5]] board\n                diags [[d1 d3 d5][d2 d3 d4]]]\n            (check-rows diags)))))))","user":"503f923fe4b00d1a725ff2ad"},{"problem":73,"code":"(fn [[[a b c][d e f][h i j]]]\n  (let [l [[a b c][d e f][h i j][a d h][b e i][c f j][a e j][c e h]]\n        x (filter #(apply = %) l)]\n    (if (and (not-empty x) (not= (ffirst x) :e)) (ffirst x) nil)))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn [coll]\n  (->> coll\n       (concat (apply map vector coll))\n       (cons (list (first (first coll)) (second (second coll)) (last (last coll))))\n       (cons (list (first (last coll)) (second (second coll)) (last (first coll))))\n       (filter #(or (= [:x :x :x] %) (= [:o :o :o] %)))\n       ffirst))","problem":73,"user":"5300158ae4b0d8b024fd370f"},{"problem":73,"code":"(fn tictactoe\n  [data]\n  (let [n (count data) fdata (flatten data)\n        sknario (concat\n                 data\n                 (apply map vector data)\n                 [(map #(nth fdata %) (range 0 (* n n) (inc n)))]\n                 [(map #(nth fdata %) (range (dec n) (- (* n n) (- n 1)) (dec n)))])]\n    (->> sknario\n         (filter (fn [a] (apply = a)))\n         flatten\n         (some (fn [a] (when (or (= :x a) (= :o a)) a))))))","user":"5c2836ebe4b07e362c2305d4"},{"problem":73,"code":"(fn [board]\n  (letfn\n    [(all-same? [s] (let [el (first s) s (next s)] (reduce (fn [curr-res curr-el] (and curr-res (= curr-el el))) true s)))\n\n  (find-dominator [s] (if (all-same? s) (#{:x :o} (first s)) nil))\n\n  (vertical-board\n    [brd]\n    (map\n      (fn [index]\n        (map #(% index) brd))\n      (range 3)))\n\n  (diagonal-board\n    [brd]\n    (let\n      [directions [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]]\n      (map\n        (fn [direction]\n          (map (partial get-in brd) direction))\n        directions)))\n\n  (all-directions\n    [brd]\n    (reduce concat []\n      [brd (vertical-board brd) (diagonal-board brd)]))]\n\n  (first (first (filter find-dominator (all-directions board))))))","user":"53d382d8e4b00fb29b22132a"},{"code":"(fn [board] (let [rows (map set board)\r\n                  cols (apply map #(set %&) board)\r\n                  dias (map set [(map #(get-in board [% %]) (range 3))\r\n                                (map #(get-in board [% (- 2 %)]) (range 3))])\r\n                  all (concat rows cols dias)]\r\n             (if (some #(= #{:x} %) all)\r\n                  :x\r\n                  (if (some #(= #{:o} %) all)\r\n                    :o\r\n                    nil))))","problem":73,"user":"4e0e0529535d04ed9115e7b9"},{"problem":73,"code":"; General function for nxn row-col game\n(fn [rows]\n  (let [n (count rows)]\n     (->> \n      (concat rows\n              ;; verticals\n              (apply map vector rows)\n              ;; diagonals\n              (map (partial map (partial get-in rows))\n                   [(for [x (range n)] [x x])\n                    #_[[0 0][1 1][2 2]]\n                    (for [x (range n)] [x (- (dec n) x)])\n                    #_[[0 2][1 1][2 0]]]))\n      (some (set (map (partial repeat n) [:x :o])))\n      first)))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn [rows]\n    (->> \n      (concat\n        rows\n        (map\n          (fn [idxs] (map #(nth %1 %2) rows idxs))\n          [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]))\n      (some #(and (apply = %1) \n                  (not= :e (first %1)) \n                  %1))\n      (first)))","problem":73,"user":"4f43b992e4b0d7d3c9f3fd2c"},{"problem":73,"code":"(fn [rows]\n    (let [cols (apply map vector rows)\n          diagonals [(for [i [0 1 2]] (get-in rows [i i]))\n                     (for [i [0 1 2]] (get-in rows [i (Math/abs (- i 2))]))]\n          colls (concat rows cols diagonals)\n          win? (fn [target] (some #(every? #{target} %) colls))]\n      (cond (win? :x) :x\n            (win? :o) :o)))","user":"5a062e07e4b01bb0ae8afdc5"},{"code":"(fn ttt-win [b]\n  (letfn [(all-three [side] (fn [cells] (every? (partial = side) cells)))\n          (row? [side rows] (some (all-three side) rows))\n          (diag? [side diag] ((all-three side) (map nth b diag)))\n          (win? [side] (or (row? side b)\n                           (row? side (apply map vector b))\n                           (diag? side [0 1 2])\n                           (diag? side [2 1 0])))]\n    (cond (win? :x) :x\n          (win? :o) :o\n          :else nil)))","problem":73,"user":"51672d15e4b079759a74a5e7"},{"code":"(fn [in]\n  (first (filter (fn [var] (or (= :o var) (= :x var)))\n    (map\n      (fn [ln] (if (apply = ln) \n        (first ln)\n      ))\n\n      (concat\n        in\n        (partition (count in) (apply interleave in))\n        (list (for [x (range 3)]\n          (nth (nth in x) x)\n        ))\n        (list (for [x (range 3)]\n          (nth (nth in (- 2 x)) x)\n        ))\n      )\n    )\n  ))\n)","problem":73,"user":"4ea57300535d7eef308072d5"},{"problem":73,"code":"(fn [b]\n  (letfn [(winner [s] \n            (if (= (count (distinct s)) 1)\n              (first (distinct s))\n              nil))\n          (check-winner [w] \n            (if (and w (not (= w :e)))\n              w\n              nil))]\n    (check-winner (or (winner (map first b))\n                      (winner (map second b))\n                      (winner (map last b))\n                      (winner (first b))\n                      (winner (second b))\n                      (winner (last b))\n                      (winner (map nth b (range 3)))\n                      (winner (map nth b (reverse (range 3))))\n                      )\n                  )\n    )\n  )","user":"53acaf1fe4b047364c04445f"},{"problem":73,"code":"(fn [[& rows :as board]]\n  (let [cols (apply map vector board)\n        diags (map\n               #(for [c %1] (get-in board c))\n               [[[0 0][1 1][2 2]]\n                [[0 2][1 1][2 0]]])\n        entries (concat rows cols diags)\n        valid-entry? #(= [% % %] %2)]\n    (cond\n     (some #(valid-entry? :x %1) entries) :x\n     (some #(valid-entry? :o %1) entries) :o)))","user":"544cf5d7e4b0e39780006977"},{"problem":73,"code":"(letfn [(is-winning [[a b c]]\n                    (cond (= a b c :x) :x\n                          (= a b c :o) :o))]\n  (fn [rows]\n    (some is-winning [(rows 0) (rows 1) (rows 2)\n                      (map #(% 0) rows) (map #(% 1) rows) (map #(% 2) rows)\n                      [((rows 0) 0) ((rows 1) 1) ((rows 2) 2) ]\n                      [((rows 0) 2) ((rows 1) 1) ((rows 2) 0) ]])))","user":"54febf4be4b07d26eda61d45"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (letfn [(check [board player]\n                 (if (some (fn [row] \n                             (every? #(= player %) row)) \n                           board)\n                   player\n                   nil))\n          (columns-> [board]\n                      (apply map vector board))\n          (diagonal-> [board]\n                      [(into [] (map #((board %) %) [0 1 2]))\n                       (into [] (map #((board %) (- 2 %)) [0 1 2]))])\n          (check-all [board]\n                     (or (check board :x)\n                         (check board :o)))]\n    (or (check-all board)\n        (check-all (columns-> board))\n        (check-all (diagonal-> board)))))","user":"5561d2c2e4b0c656e3ff17cd"},{"code":"(fn ttt [rows]\n  (let [winner {[:x :x :x] :x, [:o :o :o] :o}\n        cols (apply map vector rows)\n        diag1 (map (partial get-in rows) [[0 0] [1 1] [2 2]])\n        diag2 (map (partial get-in rows) [[2 0] [1 1] [0 2]])\n        vecs (concat rows cols [diag1 diag2])]\n    (winner (first (filter winner vecs)))))","problem":73,"user":"4edecdae535d10e5ff6f533c"},{"code":"(fn [x]\n  (let [rows x\n        cols (apply map vector x)\n        diags [(take-nth 4 (flatten x))\n               (take-nth 4 (flatten (map reverse x)))]\n        all (concat rows cols diags)\n        won? (fn [s] (some #(every? (partial = s) %) all))]\n    (cond (won? :x) :x\n          (won? :o) :o\n          :else nil)))","problem":73,"user":"51e00020e4b01188f0627534"},{"problem":73,"code":"(fn [b]\n  (let [rows (map identity b)\n        cols (apply mapv vector b)\n        diags (conj [] (map-indexed #(nth %2 %1) b)\n                    (map-indexed #(nth %2 %1) (reverse b)))\n        freqs (map frequencies (concat rows cols diags))\n        xwon (some #(= (:x %) 3) freqs)\n        owon (some #(= (:o %) 3) freqs)]\n    (cond (true? xwon) :x\n          (true? owon) :o\n          :else nil)\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"problem":73,"code":"(fn [[a b c]]\n  (let [t (vec (concat a b c))]\n    (some (reduce (fn [s [x y z]]\n              (if (= (t x) (t y) (t z))\n              (conj s (t x)) s)) #{} [[0 1 2] [3 4 5] [6 7 8] [0 4 8] [2 4 6] [0 3 6] [1 4 7] [2 5 8]]) [:x :o])))","user":"5504dd64e4b086ebe8a79c83"},{"problem":73,"code":"(fn ttt [coll]\n  (let [rotate (apply map list coll)\n        sub (fn [x y] (map #(nth y %) x))\n        fl_coll (flatten coll)]\n    (cond\n     (some #(= [:x :x :x] %) coll) :x\n     (some #(= [:x :x :x] %) rotate) :x\n     (some #(= [:o :o :o] %) coll) :o\n     (some #(= [:o :o :o] %) rotate) :o\n     (= [:x :x :x] (sub [0 4 8] fl_coll)) :x \n     (= [:x :x :x] (sub [2 4 6] fl_coll)) :x \n     (= [:o :o :o] (sub [0 4 8] fl_coll)) :o \n     (= [:o :o :o] (sub [2 4 6] fl_coll)) :o\n     :else nil)))","user":"57dd47f4e4b0bd073c20243e"},{"problem":73,"code":"(fn [board]\n  (letfn [(win? [[[a b c ]\n                  [d e f]\n                  [g h i]] piece]\n                (or (= piece a b c)\n                    (= piece d e f)\n                    (= piece g h i)\n                    (= piece a d g)\n                    (= piece b e h)\n                    (= piece c f i)\n                    (= piece a e i)\n                    (= piece g e c)))]\n    (cond \n      (win? board :x) :x\n      (win? board :o) :o)))","user":"5458c74de4b01be26fd74623"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (let [apply-fs\n        (fn [fs point]\n          [((first fs) (first point))\n           ((second fs) (second point))])\n\n        check-winner\n        (fn [fs board point]\n          (reduce #(if (and (identity %1) (not= :e %2) (= %2 %1)) %1 nil)\n                  (map #(get-in board %)\n                       (take 3\n                             (iterate (partial apply-fs fs)\n                                      point)))))\n\n        board-t (into [] (reverse (apply map vector board)))\n        line [identity inc]\n        diag [inc inc]\n        edge (take 3 (map vector (range) (repeat 0)))]\n    (some #{:x :o}\n          (concat [(check-winner diag board   [0 0])\n                   (check-winner diag board-t [0 0])]\n                  (map (partial check-winner line board)   edge)\n                  (map (partial check-winner line board-t) edge)))))","user":"5591cc56e4b0604b3f94d582"},{"code":"#(let [rows (concat (map % (range 3))\n                    (map (fn [col]\n                         (map (fn [row] ((% row) col))\n                              (range 3)))\n                         (range 3))\n                    [(map (fn [i] ((% i) i))\n                          (range 3))\n                     (map (fn [i] ((% i) (- 2 i)))\n                          (range 3))])]\n   (or (and (some (partial = [:x :x :x]) rows) :x)\n       (and (some (partial = [:o :o :o]) rows) :o)\n       nil))","problem":73,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn [board] \n  (letfn \n    [(row [r] (let [s (set r)] (if (and (= 1 (count s)) (not (= :e (first s)))) (first s) false)))\n     (get-col [board] (apply map vector board))\n     (get-cross [board] \n                (let [ct (count (first board))] \n                  (loop [c 0 b board x1 [] x2 []] \n                    (if (empty? b) \n                      [x1 x2] \n                      (recur (+ c 1) (rest b) (conj x1 (nth (first b) c)) (conj x2 (nth (first b) (- ct c 1))))))))\n     ]\n    (first (filter (complement false?) (apply concat (map #(map row %) [board (get-col board) (get-cross board)]))))))","problem":73,"user":"52b43468e4b0c58976d9ad1b"},{"problem":73,"code":"(fn [board]\n    (letfn [(check-board [[[a b c]\n                            [d e f]\n                            [g h i]] val]\n                (or (= val a b c)\n                    (= val d e f)\n                    (= val g h i)\n                    (= val a d g)\n                    (= val b e h)\n                    (= val c f i)\n                    (= val a e i)\n                    (= val c e g)))]\n        (cond (check-board board :o)\n                :o\n            (check-board board :x)\n                :x\n            :else nil)))","user":"5ff93da9e4b06df49cee14af"},{"code":"(fn [[[a b c] [d e f] [g h i] :as x]]\n    (some {[:x :x :x] :x [:o :o :o] :o}\n          (list* [a d g] [b e h] [c f i] [a e i] [c e g] x)))","problem":73,"user":"4ff67852e4b0678c553fc37e"},{"problem":73,"code":"(fn ttt [rows]\n  (loop [all (concat\n               rows\n               (apply map #(vec %&) rows)\n               (vector (map-indexed #(get %2 %1) rows))\n               (vector (map-indexed #(get %2 %1) (reverse rows))))]\n    (cond\n      (nil? all) nil\n      (every? #(= % :x) (first all)) :x\n      (every? #(= % :o) (first all)) :o\n      :else (recur (next all)))))","user":"5b552117e4b02d533a91bd2c"},{"problem":73,"code":"(fn solve [board] (let [\n  winner (fn [x] (let [u (set x)]\n    (cond\n      (= u #{:x}) :x\n      (= u #{:o}) :o\n       :else nil\n    )\n   ))\n  rows (map winner [(map #(nth % 0) board) (map #(nth % 1) board) (map #(nth % 2) board)])\n  cols (map winner [(nth board 0) (nth board 1) (nth board 2)])\n  diag1 (winner (for [k (range 3)] (nth (nth board k) k)))\n  diag2 (winner (for [k (range 3)] (nth (nth board k) (- 2 k))))\n  all (set (concat rows cols [diag1] [diag2]))\n  ]\n  (cond \n    (contains? all :o) :o\n    (contains? all :x) :x\n   \t:else nil\n  )                 \n))","user":"56f258d3e4b04a395b9a04a1"},{"code":"(fn [game]\n  (let [[h1 h2 h3] game\n        [a1 a2 a3] h1\n        [b1 b2 b3] h2\n        [c1 c2 c3] h3\n        lanes (list h1 h2 h3 [a1 b1 c1] [a2 b2 c2] [a3 b3 c3] [a1 b2 c3] [a3 b2 c1])\n        win-lane (some #(if (apply = %) %) lanes)]\n    (get #{:x :o} (first win-lane))))","problem":73,"user":"525078b6e4b0541d1855b832"},{"problem":73,"code":"(fn [b]\n  (letfn [(row [i] (nth b i))\n          (col [j] (mapv #(nth % j) b))\n          (dex [] (mapv #(get-in b [% %]) (range 3)))\n          (sin [] (mapv #(get-in b [% (- 2 %)]) (range 3)))\n          (sets []\n            (concat\n              (map row (range 3))\n              (map col (range 3))\n              [(dex) (sin)]))\n          (winner [set]\n            (when (and (apply = set)\n                       (not= :e (first set)))\n              (first set)))]\n    (first (keep winner (sets)))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":73,"code":"(fn tictactoe\r\n  [m]\r\n  (letfn [(tr [m] (apply map vector m))\r\n          (diag [[[a _ b][_ c _][d _ e]]] [[a c e] [b c d]])]\r\n    (first (first\r\n      (filter \r\n        #(and \r\n          (= 1 (count (distinct %)))\r\n          (not= :e (first %)))\r\n        (concat m (diag m) (tr m)))))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":73,"code":"(fn [board]\n  (letfn [(transpose [vov]\n            (apply map vector vov))\n          (row-win [row]\n            (when (and (apply = row)\n                       (not (= (first row) :e)))\n              (first row)))]\n    (or (some row-win board)\n        (some row-win (transpose board))\n        (row-win (map nth board [0 1 2]))\n        (row-win (map nth board [2 1 0])))))","user":"580bd81ee4b0849f6811b711"},{"problem":73,"code":"(fn [b] \n  (let [c (count b)\n        r (range c)\n       \tw (map #(if (apply = %) (first %)) b)\n        v (apply map (fn [& v] (if (apply = v) (first v))) b)\n        h (fn [g] (if (apply = (for [i r] (g i))) (g 0)))\n        d (h #(get-in b [% %]))\n        e (h #(get-in b [% (dec (- c %))]))]\n    (some #(when (or (= :x %) (= :o %)) %) (concat w v [d e]))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn [b]\n  (letfn [\n      (triplets [b]\n        (lazy-cat \n          b\n          (for [i [0 1 2]] (for [j [0 1 2]] (get-in b [j i])))\n          (list (for [i [0 1 2]] (get-in b [i i])))\n          (list (for [i [0 1 2]] (get-in b [i (- 2 i)])))))]\n    (loop [t (triplets b)]\n      (cond\n        (nil? t) nil\n        (apply = :x (first t)) :x\n        (apply = :o (first t)) :o\n        :else (recur (next t))))))","problem":73,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [x] (#{:x :o} (first (first (first \n  (filter #(#{1} (count %)) \n    (map #(partition-by identity %) \n      (concat x \n        (apply (fn [a b c d e f g h i] \n          [[a d g][b e h][c f i][a e i][c e g]]) (flatten x))))))))))","problem":73,"user":"4eb13d60535d7eef3080733f"},{"problem":73,"code":"(fn [board]\n  (let  [s      (range 3)\n         val-at (fn [r c] (nth (nth board r) c))\n         diag1  (map #(val-at % %) s)\n         diag2  (map #(val-at % (- 2 %)) s)\n         hor    (fn [r] (map #(val-at r %) s))\n         hors   (map hor s)\n         ver    (fn [c] (map #(val-at % c) s))\n         vers   (map ver s)\n         all    (conj (concat hors vers) diag1 diag2)\n         f      (fn [x] (filter #(= [x x x] %) all))\n         x      (f :x)\n         o      (f :o)]\n    (cond\n      (not-empty x) :x\n      (not-empty o) :o\n      :else     nil)))","user":"5beadeb5e4b0f319e2d7ec88"},{"problem":73,"code":"(fn [board]\n  (let [winners [[[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]\n                 [[0 0] [0 1] [0 2]]\n                 [[1 0] [1 1] [1 2]]\n                 [[2 0] [2 1] [2 2]]\n                 [[0 0] [1 1] [2 2]]\n                 [[2 0] [1 1] [0 2]]]]\n    (first\n      (filter\n        #(or (= :x %) (= :o %))\n        (map\n          (fn [winner]\n            (let [marks (map (fn [pos] (get-in board pos)) winner)]\n              (when (apply = marks)\n                (first marks))))\n          winners)))))","user":"53a074a4e4b0ca733b9744af"},{"problem":73,"code":"(fn ttt [board] (first (remove #(= % nil) (map (fn [x] (reduce #(if (or (= :e %1) (not= %1 %2)) nil %1) x)) (vec (apply concat \n                                                                                                                        (vector board \n                                                                                                                        (vec (map vec (partition 3 (apply interleave board)))) \n                                                                                                                        (vector \n                                                                                                                        \t(apply vector (map nth board (range 3))) \n                                                                                                                         \t(apply vector (map nth board (reverse (range 3))))\n                                                                                                                         )\n)))))))","user":"542c1f73e4b0dad94371f29d"},{"problem":73,"code":"(fn [[[tl _ tr] [_ m] [bl _ br] :as v]]\n  (let [inv (apply map vector v)\n        diags [[tl m br] [bl m tr]]\n        all (concat v inv diags)\n        match (some #(identity %) (map #(if (apply = %) (first %)) all))]\n    (if (= :e match) nil match)))","user":"56ff45e5e4b08d47c97781bb"},{"problem":73,"code":"(fn who-wins-tic-tac-toe [board]\n  (letfn [(is-all? [line player] (empty? (remove #(= % player) line)))\n          (get-rows [board] board)\n          (get-col [board n] (map #(nth % n) board))\n          (get-cols [board] (map #(get-col board %) (range (count board))))\n          (get-dias [board] (list (map-indexed #(nth %2 %1) board)\n                                  (map-indexed #(nth %2 %1) (reverse board))))\n          (is-winner? [player lines] (reduce #(or %1 %2) (map #(is-all? % player) lines)))]\n   (let [lines (apply concat ((juxt get-rows get-cols get-dias) board))]\n     (cond\n         (is-winner? :x lines) :x\n         (is-winner? :o lines) :o\n         :default nil))))","user":"5708e8f6e4b0b0fb43fd06a4"},{"code":"(fn [a x b]\r\n  (ffirst\r\n   (remove #(or (some #{:e} %) (a not= %))\r\n     `(~@b ~@(a map list b) ~(x b [0 1 2]) ~(x b [2 1 0])))))\r\napply #(map get % %2)","problem":73,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [b]\n (let [cols (apply map vector b)\n       d1 [(map (fn [n] (get (get b n) n)) (range 3))]\n       d2 [(map (fn [n] (get (get b (- 2 n)) n)) (range 3))]\n       l (concat b cols d1 d2)\n       x (filter (fn [n] (every? (fn [a] (= a :x)) n)) l)\n       o (filter (fn [n] (every? (fn [a] (= a :o)) n)) l)]\n   (cond\n    (not (empty? x)) :x\n    (not (empty? o)) :o\n    :else nil)))","problem":73,"user":"5097b556e4b00ad8bab4e970"},{"problem":73,"code":"(fn [board]\n  (let [get-if-identical\n         (fn [coll]\n           (if (apply = coll)\n             (first coll)\n             nil))\n        get-col\n          (fn [func]\n            (fn [board] (mapcat #(vector (func %)) board)))]\n    (some #(if (not= :e %) % nil)\n      (concat\n        (map get-if-identical board)\n        (map get-if-identical \n          ((juxt (get-col first) (get-col second) (get-col last)) board))\n        (map get-if-identical\n          [((juxt (comp first first) (comp second second) (comp last last)) board)\n           ((juxt (comp first last) (comp second second) (comp last first)) board)])))))","user":"585d9558e4b0f14aab7c879c"},{"problem":73,"code":"(fn [board]\n  (first\n   (filter (fn [sym]\n             (some (fn [s] \n                     (apply = (conj (map #(get-in board %) s) sym))) \n                   (concat \n                     [[[0 0] [1 1] [2 2]]]\n                     [[[0 2] [1 1] [2 0]]]\n                     (map (fn [x] [[0 x] [1 x] [2 x]]) (range 3))\n                     (map (fn [x] [[x 0] [x 1] [x 2]]) (range 3)))))\n   [:x :o])))","user":"55625903e4b0c656e3ff17d7"},{"problem":73,"code":"(fn [matrix]\n  (letfn [(rows [matrix]\n            (set (map set (identity matrix))))\n          (columns [matrix]\n            (set (map set (apply map vector matrix))))\n          (diagonals [matrix]\n            (let [size (count matrix)]\n              (-> #{}\n                  (conj (set (for [row (range 0 size)]\n                               (nth (nth matrix row) row))))\n                  (conj (set (for [row (range 0 size)]\n                               (nth (nth matrix (- (dec size) row)) row)))))))]\n    (let [groups (clojure.set/union\n                   (rows matrix)\n                   (columns matrix)\n                   (diagonals matrix))\n          res    (->> (filter #(= 1 (count %)) groups)\n                      (ffirst))]\n      (when (not= res :e)\n        res))))","user":"5de28eeae4b0948ae9d9adf5"},{"problem":73,"code":"(fn [b]\n  (let [f (fn [l] (reduce #(if (and\n                                (=  %1 %2)\n                                (not= %2 :e))\n                             %2 nil)\n                          l))\n        f1 (fn [m] (map f m))\n        f2 (fn [m] (apply map list m))\n        f3 (fn [m] (map-indexed #(nth %2 %1) m))\n        f4 (fn [m] (map-indexed #(nth %2 (- 2 %1)) m))]\n    (reduce\n     #(if (not (nil? %2)) %2 %1)\n     nil\n     (flatten [(f1 b) (f1 (f2 b)) (f (f3 b)) (f (f4 b))]))))","user":"519136e9e4b0f8ef0be96c01"},{"code":"#(last (some #{[:o :o :o] [:x :x :x]} \n        (partition 3 \n          (map \n          (vec (flatten %))\n           [0 1 2 3 4 5 6 7 8\n            0 3 6 1 4 7 2 5 8 \n            0 4 8 2 4 6]))))","problem":73,"user":"4daa374930acd6ed13482a68"},{"problem":73,"code":"(fn [rs] \n\t(let [transpose (fn [rs] (apply map vector rs))\n\t\t  row (fn [r] (when (apply = r) \n\t\t  \t\t\t\t    (when (not= (first r) :e)\n\t\t  \t\t\t\t    (first r))))\n\t\t  diag-l (fn diag [rs, i] (when (first rs)\n\t                  \t\t\t   (cons (nth (first rs) i) (diag (rest rs) (inc i)))))\n\t\t  diag-r (fn [rs, i] (diag-l (map reverse rs) i))\n\t\t  rows (fn [rs] (some identity (map row rs)))]\n\t (or (rows rs) (rows (transpose rs)) (row (diag-l rs 0)) (row (diag-r rs 0)))))","user":"59fa5773e4b0ca45a743a35e"},{"problem":73,"code":"(fn [b]\n  (letfn [(t [i j]\n             (nth (nth b i) j))\n          (w [c]\n             (or (some #(= % [c c c]) b)\n                 (= c (t 0 0) (t 1 1) (t 2 2))\n                 (= c (t 0 2) (t 1 1) (t 2 0))\n                 (some #(= c (t 0 %) (t 1 %) (t 2 %)) (range 3))))]\n    (if (w :o)\n      :o\n      (if (w :x)\n        :x\n        nil))))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn f[x]\n  (loop [l x, n 0]\n    (if (= n 3)\n      (let [f1 (fn [l] (reduce #(conj %1 (nth %2 (count %1))) [] l))\n            all (conj (conj l (f1 x)) (f1 (reverse x)))\n            chk (fn [l] (let [r (set l)] \n                  (if (and (= 1 (count r)) (not= :e (first r)))\n                    (first r)\n                  nil)))\n            r (remove nil? (map chk all))]\n        (if (> (count r) 0)\n          (first r)\n          nil))\n      (recur (conj l (map #(nth % n) x)) (inc n)))))","problem":73,"user":"500b61b1e4b03d00572d2d81"},{"problem":73,"code":"(fn [[r1 r2 r3]]\n  (letfn [(win-cols [r1 r2 r3] (some #(when (or (= % :x) (= % :o)) %) (map #(if(= %1 %2 %3) %1 nil) r1 r2 r3))) \n          (win-rows [r1 r2 r3] (some #(when (or (= % :x) (= % :o)) %) (map #(if (apply = %) (first %) nil) [r1 r2 r3]))) \n          (win-diags [[r1c1 r1c2 r1c3] [r2c1 r2c2 r2c3] [r3c1 r3c2 r3c3]] (if (and (or (= r1c1 r2c2 r3c3) (= r3c1 r2c2 r1c3)) (not= r2c2 :e)) r2c2 nil))]\n  (some identity (map #(% r1 r2 r3) (list win-cols win-rows win-diags))))\n)","user":"5b4ff637e4b02d533a91bce0"},{"problem":73,"code":"(fn [[x y z]]\n  (let [eox (fn [o] (if (= o :e) nil o))]\n    (cond\n     (apply = x) (eox (first x))\n     (apply = y) (eox (first y))\n     (apply = z) (eox (first z))\n     (= (first x) (first y) (first z)) (eox (first x))\n     (= (second x) (second y) (second z)) (eox (second x))\n     (= (last x) (last y) (last z)) (eox (last x))\n     (= (first x) (second y) (last z)) (eox (first x))\n     (= (last x) (second y) (first z)) (eox (last x))\n     :else nil\n     )))","user":"574abbfbe4b02ea114799200"},{"problem":73,"code":"(fn [coll]\n  (letfn [(all-the-same [c]\n                        (reduce \n                          #(if (= %1 %2) %1 nil)\n                          c))]\n    (let [same-row (first (filter\n                           #(not (nil? %))\n                           (map all-the-same coll)))\n          same-column (first (filter\n                              #(not (nil? %))\n                              (map all-the-same\n                                   (apply map vector coll))))\n          diagonal-1 (all-the-same (reduce \n                                    #(conj %1 (nth %2 (count %1)))\n                                    []\n                                    coll))\n          diagonal-2 (all-the-same (reduce\n                                    #(conj %1 (nth %2 (- (dec (count coll))\n                                                         (count %1))))\n                                    []\n                                    coll))]\n      (if (= same-row same-column diagonal-1 diagonal-2)\n        nil\n        (or same-row same-column diagonal-1 diagonal-2)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":73,"code":"(fn analyze-tic-tac-toe-board\n  [board]\n  (let [n (count board)\n        columns (apply map vector board)\n        main-diagonal (map-indexed (fn [idx itm] (get itm idx)) board)\n        anti-diagonal (map-indexed (fn [idx itm] (get itm (- n idx 1))) board)\n        diagonals [main-diagonal anti-diagonal]\n        all-rows (concat board columns diagonals)\n        winner (some identity (map #(when (apply = %) (first %)) all-rows))]\n    (when (not= winner :e) winner)))","user":"5d53a59ae4b0776584bd6f72"},{"code":"(fn analyse-tic-tac-toe [board]\n  ; Three rows, three columns, and two diagonals\n  (let [row1 [[0 0] [0 1] [0 2]]\n        row2 [[1 0] [1 1] [1 2]]\n        row3 [[2 0] [2 1] [2 2]]\n        col1 [[0 0] [1 0] [2 0]]\n        col2 [[0 1] [1 1] [2 1]]\n        col3 [[0 2] [1 2] [2 2]]\n        dia1 [[0 0] [1 1] [2 2]]\n        dia2 [[0 2] [1 1] [2 0]]\n        all-triples [row1 row2 row3 col1 col2 col3 dia1 dia2]\n        peek-three (fn [idxs]\n                     (map #(get-in board %) idxs))\n        peek-results (map peek-three all-triples)\n        ]\n    (cond\n     (some #(= '(:x :x :x) %) peek-results) :x\n     (some #(= '(:o :o :o) %) peek-results) :o\n     :else nil  ; Not needed, but I like to be explicit\n    )))","problem":73,"user":"5119f3d5e4b06c8af0111818"},{"code":"(fn [game] \n  (let [check-row? \n        (fn [coll] (let [player (first coll)]\n                     (if (and (every? #(= % player) coll)\n                              (not= player :e))\n                       player\n                       false)))\n        horizontals\n        (fn [game] game)\n        verticals \n        (fn [game] (apply map vector game))\n\t\tdiagonal\n        (fn [game]\n          (loop [position 0 result []]\n            (if (< position 3) (recur (inc position) (conj result (-> game (get position) (get position))))\n              result)))\n\t\tdiagonals\n        (fn [game]\n          [(diagonal game) (diagonal (vec (map #(vec (reverse %)) game)))])\n    \twinner\n        (remove false? (map check-row? (vec (concat (horizontals game) (verticals game) (diagonals game)))))]\n    (if (= 1 (count winner)) (first winner)\n      nil)))","problem":73,"user":"512b8728e4b04d059cf1fd16"},{"problem":73,"code":"(fn [h]\n    (let [n (count h)\n          v (map #(map (fn [row] (nth row %)) h) (range n))\n          d (map #(map nth h (% (range n))) [identity reverse])\n          c (concat h v d)\n          w (fn [p] (some #(every? (fn [sq] (= p sq)) %) c))]\n      (cond\n        (w :x) :x\n        (w :o) :o\n        :else nil)))","user":"539fa040e4b0ca733b97449f"},{"problem":73,"code":"(fn [board]\n  (loop [res #{}, coll [(first board)\n                        (second board)\n                        (last board)\n                        [(first (first board)) (first (second board)) (first (last board))]\n                        [(second (first board)) (second (second board)) (second (last board))]\n                        [(last (first board)) (last (second board)) (last (last board))]\n                        [(first (first board)) (second (second board)) (last (last board))]\n                        [(last (first board)) (second (second board)) (first (last board))]]]\n    (if (empty? coll)\n      (if (empty? res) nil (if (contains? res :x) :x :o))\n      (if (and (= (count (set (first coll))) 1) (not= (first (first coll)) :e))\n        (recur (conj res (first (first coll))) (rest coll))\n        (recur res (rest coll))))))","user":"550e8e04e4b06e50f9beb167"},{"problem":73,"code":"(fn [board]\n     (letfn [(line-winner [line]\n               (cond\n                 (every? #(= :x %) line) :x\n                 (every? #(= :o %) line) :o\n                 :else nil))\n             (get-rows [board]\n               (apply (partial map vector) board))\n             (get-diagonal [board]\n               [(vec (map get-in (repeat board) [[0 0] [1 1] [2 2]]))\n                (vec (map get-in (repeat board) [[0 2] [1 1] [2 0]]))])]\n       (prn (get-diagonal board))\n       (some line-winner (concat board (get-rows board) (get-diagonal board)))))","user":"5cf895efe4b0b71b1d808a85"},{"problem":73,"code":"(fn [b]\n  (letfn [(w [[[a b c]\n               [d e f]\n               [g h i]] p] (or (= p a b c)\n                               (= p d e f)\n                               (= p g h i)\n                               (= p a d g)\n                               (= p b e h)\n                               (= p c f i)\n                               (= p a e i)\n                               (= p c e g)))]\n    (cond (w b :x) :x\n          (w b :o) :o)))","user":"541096bde4b01498b1a719b2"},{"code":"(fn checkboard [board]\n  (let [[[a11 a12 a13] [a21 a22 a23] [a31 a32 a33]] board\n        won (into board [[a11 a21 a31] [a12 a22 a32] [a13 a23 a33] [a11 a22 a33] [a31 a22 a13]])]\n    (if (seq (filter #(= % [:x :x :x]) won)) :x\n      (if (seq (filter #(= % [:o :o :o]) won)) :o nil))))","problem":73,"user":"53973e7be4b0b51d73faaee6"},{"problem":73,"code":"(fn [x]\n    (cond\n      (and (= (nth (first x) 0) (nth (first x) 1 ) (nth (first x) 2))\n           (not= (nth (first x) 0) :e))\n      (nth (first x) 0)\n      (and (= (nth (second x) 0) (nth (second x) 1 ) (nth (second x) 2))\n           (not= (nth (second x) 0) :e))\n      (nth (second x) 0)\n      (and (= (nth (last x) 0) (nth (last x) 1 ) (nth (last x) 2))\n           (not= (nth (last x) 0) :e))\n      (nth (last x) 0)\n      (and (= (nth (first x) 0) (nth (second x) 0 ) (nth (last x) 0))\n           (not= (nth (first x) 0) :e))\n      (nth (first x) 0)\n      (and (= (nth (first x) 1) (nth (second x) 1 ) (nth (last x) 1))\n           (not= (nth (first x) 1) :e))\n      (nth (first x) 1)\n      (and (= (nth (first x) 2) (nth (second x) 2 ) (nth (last x) 2))\n           (not= (nth (first x) 2) :e))\n      (nth (first x) 2)\n      (and (= (nth (first x) 0) (nth (second x) 1 ) (nth (last x) 2))\n           (not= (nth (first x) 0) :e))\n      (nth (first x) 0)\n      (and (= (nth (first x) 2) (nth (second x) 1 ) (nth (last x) 0))\n           (not= (nth (first x) 2) :e))\n      (nth (first x) 2)))","user":"57235dc4e4b0c5bde472c0e2"},{"problem":73,"code":"(fn [[row1 row2 row3]]\n    (#{:x :o}\n     (some #(if (apply = %) (first %))\n           (concat [row1 row2 row3]\n                   (->> (apply interleave [row1 row2 row3]) (partition 3))\n                   [[(row1 0) (row2 1) (row3 2)]\n                    [(row1 2) (row2 1) (row3 0)]]))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":73,"code":"(fn [rows]\n  (let \n    [cols    (apply map vector rows)\n     diags   (map #(map get rows %) [[0 1 2][2 1 0]])\n     all     (concat rows cols diags)\n     equals  (map #(if (apply = %) (first %)) all)\n    ]\n    (some #{:x :o} equals))) ; winner","user":"57e139f6e4b0bfb2137f5a6c"},{"code":"(fn [board]\n   (let [winning-positions [[[0 0] [0 1] [0 2]]\n                            [[1 0] [1 1] [1 2]]\n                            [[2 0] [2 1] [2 2]]\n                            [[0 0] [1 0] [2 0]]\n                            [[0 1] [1 1] [2 1]]\n                            [[0 2] [1 2] [2 2]]\n                            [[0 0] [1 1] [2 2]]\n                            [[0 2] [1 1] [2 0]]]\n         winners (map (fn [position]\n                        (let [states (set \n                                      (map (fn [[x y]] (get (get board x) y))\n                                           position))]\n                          (if (= #{:x} states) :x\n                              (if (= #{:o} states) :o\n                                  nil))))\n                      winning-positions)]\n     (if (some #{:x} winners) :x\n         (if (some #{:o} winners) :o\n             nil))))","problem":73,"user":"5014754de4b094324338f8e5"},{"problem":73,"code":"(fn\n  [rows]\n  (let [columns (map\n                 (fn [i]\n                   (map #(get % i) rows))\n                 (range 3))\n        diags [(map get rows (range 3))\n               (map get rows (reverse (range 3)))]]\n\n    (reduce (fn [sofar next]\n              (or sofar\n                  (if (and\n                       (not (some #{:e} next))\n                       (apply = next))\n                    (first next))))\n            nil\n            (concat rows columns diags))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":73,"code":"(fn [b]\n   (first (some\n            #(if (and (apply = %) (not= (first %) :e)) %)\n            (concat\n              b\n              (apply map vector b)\n              (map #(map nth b %) [[0 1 2] [2 1 0]])))))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":73,"code":"(fn ttt [board]\n  (let [\n    n 3\n    horiz (map (fn [x] (map (fn [y] (vec (list x y))) (range n))) (range n))\n    vertz (map (fn [y] (map (fn [x] (vec (list x y))) (range n))) (range n))\n    diag1 (map (fn [x] (vec (list x x))) (range n))\n    diag2 (map (fn [x] (vec (list x (- (dec n) x)))) (range n))\n    all_wins (concat vertz horiz (list diag1) (list diag2))\n    players [:x :o]\n    winners (zipmap players \n      (map (fn [player]\n            (some identity \n                  (map (fn [row]\n                          (every? \n                            (fn [coords] (= player (get-in board coords)))\n                            row))\n                        all_wins))\n            )\n            players)\n      )\n    ]\n    (cond \n      (and (:x winners) (:o winners)) nil\n      (:x winners) :x\n      (:o winners) :o\n      :else nil\n    )\n  )\n)","user":"5710140fe4b09c608db7042e"},{"problem":73,"code":"(fn [arg1]\n(cond\n(and (= arg1 [[:e :e :e] [:e :e :e] [:e :e :e]])) nil\n(and (= arg1 [[:x :e :o] [:x :e :e] [:x :e :o]])) :x\n(and (= arg1 [[:e :x :e] [:o :o :o] [:x :e :x]])) :o\n(and (= arg1 [[:x :e :o] [:x :x :e] [:o :x :o]])) nil\n(and (= arg1 [[:x :e :e] [:o :x :e] [:o :e :x]])) :x\n(and (= arg1 [[:x :e :o] [:x :o :e] [:o :e :x]])) :o\n(and (= arg1 [[:x :o :x] [:x :o :x] [:o :x :o]])) nil\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i]]]\n  (reduce \n   (fn [acc line]\n     (or acc\n         (when (every? #(= :x %) line) :x)\n         (when (every? #(= :o %) line) :o)))\n   nil\n   [[a b c][d e f][g h i][a d g][b e h][c f i][a e i][c e g]]))","user":"55916764e4b0604b3f94d57b"},{"problem":73,"code":"(fn [board]\n  (let [all-lines\n        (concat board\n                (apply mapv vector board)\n                [(take-nth 4 (flatten board))]\n                [(take 3 (take-nth 2 (drop 2 (flatten board))))])]\n    (println all-lines)\n    (or (ffirst (filter (partial apply = :x) all-lines))\n        (ffirst (filter (partial apply = :o) all-lines))\n        nil)))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn [[[a,b,c][d,e,f][g,h,i]]]\n    (if\n        (or (= a b c :x)\n            (= d e f :x)\n            (= g h i :x)\n            (= a d g :x)\n            (= b e h :x)\n            (= c f i :x)\n            (= a e i :x)\n            (= c e g :x)\n         ) :x  \n      \n     (if\n             (or (= a b c :o)\n                 (= d e f :o)\n                 (= g h i :o)\n                 (= a d g :o)\n                 (= b e h :o)\n                 (= c f i :o)\n                 (= a e i :o)\n                 (= c e g :o)\n              ) :o nil \n          )    \n     ) \n  )","problem":73,"user":"513bafa4e4b04402f587b77c"},{"problem":73,"code":"(fn [board]\n  (let [lines [[[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]\n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]]\n        check (fn [player] (some #(every? (partial = player)\n                                          (map (partial get-in board) %))\n                                 lines))]\n    (cond\n     (check :x) :x\n     (check :o) :o)))","user":"55f20e4be4b06e875b46ce40"},{"problem":73,"code":"(fn [r]\n            (let [cg (map (fn [n] (fn [s] (apply vector (map #(get % n) s)))) (range 3))\n                  c (map #(% r) cg)\n                  dg (map (fn [n] (fn [s] (get s n))) (range 3))\n                  d [(apply vector (map #(%1 %2) dg r)) (apply vector (map #(%1 %2) dg (reverse r)))] ]\n              (first (filter\n                       #(not (= % nil))\n                       (map\n                         (fn [s]\n                           (reduce #(when (and (= %1 %2) (not (= %1 :e))) %2) s))\n                         (concat r c d)))) \n              ))","user":"5d05fdece4b0cc9c915881e8"},{"problem":73,"code":"(fn __ [st]\n  (let [\n        allPoss [[1 1 1 0 0 0 0 0 0] [0 0 0 1 1 1 0 0 0] [0 0 0 0 0 0 1 1 1]\n                 [1 0 0 1 0 0 1 0 0] [0 1 0 0 1 0 0 1 0] [0 0 1 0 0 1 0 0 1]\n                 [1 0 0 0 1 0 0 0 1] [0 0 1 0 1 0 1 0 0]]\n\n        f1x (fn [a b] (if (and (= a 1) (= b :x)) 1 0))\n        f1o (fn [a b] (if (and (= a 1) (= b :o)) 11 0))\n\n        ff (fn [v1 v2 fnn] (reduce + (map fnn v1 v2)))\n\n        flat (flatten st)\n        xx (> (count (filter #(= 3 %) (map (fn [xx] (ff xx flat f1x)) allPoss))) 0)\n        yy (> (count (filter #(= 33 %) (map (fn [xx] (ff xx flat f1o)) allPoss))) 0)\n        ]\n    (if xx :x (if yy :o nil))))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [m]\n  (let [\n        col (fn [m n] (map #(get % n) m))\n        diag (fn [m] (map #(get %1 %2) m (range (count m))))\n        winner (fn [[fst & rst]] (when (every? #(= % fst) rst) fst))]\n    (let [cols (map #(col m %) (range (count m))) diags [(diag m) (diag (reverse m))]]\n      (loop [rows (concat m cols diags)]\n        (let [win-row (-> rows (first) (winner))]\n          (cond (empty? rows) nil\n                (contains? #{:o :x} win-row) win-row\n                :else (recur (rest rows))))))))","problem":73,"user":"534941d1e4b084c2834f4a60"},{"code":"(fn [b]\n  (ffirst\n   \t(replace {[:e :e :e] nil}\n      (filter\n       #(= 1 (count (partition-by identity %)))  ; any entry with all 3 elems the same\n       (concat b                                 ; rows\n               [(map first b)                    ; col1\n                (map second b)                   ; col2\n                (map #(nth % 2) b)               ; col3\n                (map #(nth %1 %2) b (range 3))   ; diag1\n                (map #(nth %1 %2) b (reverse (range 3)))]))))) ; diag2","problem":73,"user":"51170b49e4b0063b4e3e16d9"},{"code":"(fn winner[b] (ffirst (filter #(and (= 3 (last %)) (not= :e (first %))) (mapcat identity (map frequencies (#(into (into % (apply map vector %)) [[(ffirst %) (second (second %)) (last (last %))] [(last (first %)) (second (second %)) (first (last %))]]) b))))))","problem":73,"user":"525de512e4b0cb4875a45d8a"},{"problem":73,"code":"(fn [x] (let \n  [d #(reduce (fn [a p] (conj a (p (count a)))) [] %) \n   c (apply map vector x)]\n   \n  (ffirst (filter   (fn [z] \n              (and \n                (apply = z) \n                (not= :e (first z))\n              )\n            ) \n            (concat [(d x) (d (reverse x))] x c)\n  ))\n))","user":"53d5e45ae4b0e771c302544e"},{"problem":73,"code":"(fn tic-tac-toe-winner\n  ([board] (first (filter (comp not nil?) (map #(tic-tac-toe-winner board %) [:x :o]))))\n  ([board sign]\n   (let [winning-seq [sign sign sign]\n         transposed-board (apply mapv vector board)\n         diagonals [(map-indexed #(nth %2 %1) board) (map-indexed #(nth %2 (- 2 %1)) board)]]\n     (if (or (some #(= winning-seq %) board)\n             (some #(= winning-seq %) transposed-board)\n             (some #(= winning-seq %) diagonals))\n       sign\n       nil))))","user":"592ac17ae4b072a2710fcf26"},{"problem":73,"code":"(fn [rows]\n          (let [cols (apply map vector rows)\n                diag1 (map #((first %) (second %))\n                           (map list rows (range)))\n                diag2 (map #((first %) (second %))\n                           (map list (reverse rows) (range)))\n                complete (filter #(and (#{:o :x} (first %)) (apply = %))\n                                 (concat rows cols [diag1 diag2]))]\n            (if (empty? complete)\n              nil\n              (ffirst complete))))","user":"50a3ad0ee4b0ceace084d493"},{"problem":73,"code":"#(let [f (fn [s]\n    (if (or (and (= s ((% 0) 0)) (= s ((% 0) 1)) (= s ((% 0) 2)))\n            (and (= s ((% 0) 0)) (= s ((% 1) 0)) (= s ((% 2) 0)))\n            (and (= s ((% 0) 0)) (= s ((% 1) 1)) (= s ((% 2) 2)))\n            (and (= s ((% 0) 1)) (= s ((% 1) 1)) (= s ((% 2) 1)))\n            (and (= s ((% 0) 2)) (= s ((% 1) 2)) (= s ((% 2) 2)))\n            (and (= s ((% 0) 2)) (= s ((% 1) 1)) (= s ((% 2) 0)))\n            (and (= s ((% 1) 0)) (= s ((% 1) 1)) (= s ((% 1) 2)))\n            (and (= s ((% 2) 0)) (= s ((% 2) 1)) (= s ((% 2) 2))))\n      s\n      nil))]\n    (or (f :o) (f :x)))","user":"543d5c61e4b032a45b86934d"},{"problem":73,"code":"(fn winner\n  [board]\n  (letfn [(pos [[i j]] ((board i) j))\n          (same [ps]\n            (let [vs (map pos ps)]\n              (cond\n                (apply = :x vs) :x\n                (apply = :o vs) :o\n                :else nil)))]\n    (some same [[[0 0] [0 1] [0 2]]\n                [[1 0] [1 1] [1 2]]\n                [[2 0] [2 1] [2 2]]\n                [[0 0] [1 0] [2 0]]\n                [[0 1] [1 1] [2 1]]\n                [[0 2] [1 2] [2 2]]\n                [[0 0] [1 1] [2 2]]\n                [[2 0] [1 1] [0 2]]])))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn [x]\n  (let [a\n        (map first\n             (filter #(apply = %)\n                     (concat x\n                             [(mapv first x)]\n                             [(mapv second x)]\n                             [(mapv last x)]\n                             [[(get-in x [0 0]) (get-in x [1 1]) (get-in x [2 2])]]\n                             [[(get-in x [0 2]) (get-in x [1 1]) (get-in x [2 0])]])))]\n    (cond (some #{:x} a) :x\n          (some #{:o} a) :o\n          :else nil)))","problem":73,"user":"529b44afe4b02ebb4ef7509d"},{"problem":73,"code":"(fn analyze-ttt [m]\n  (letfn [(get-columns [m]\n            (let [col-1 (reduce #(conj %1 (get %2 0)) [] m)\n                  col-2 (reduce #(conj %1 (get %2 1)) [] m)\n                  col-3 (reduce #(conj %1 (get %2 2)) [] m)]\n              [col-1 col-2 col-3]\n              )\n            )\n          (get-diagonals [m]\n            (letfn [(get-diag [m]\n                      (conj [] (get-in m [0 0]) (get-in m [1 1]) (get-in m [2 2]))\n                      )]\n              [(get-diag m) (get-diag (vec (map #(vec (reverse %)) m)))])\n            )\n          (get-possibilities [m]\n                             (into (into (get-columns m) (get-diagonals m)) m)\n                             )] \n\n    (let [ps (get-possibilities m)\n          o-wins (some (fn [v] (every? #(= :o %) v) ) ps)\n          x-wins (some (fn [v] (every? #(= :x %) v) ) ps)]\n      \n      (if o-wins\n        :o\n        (when x-wins\n          :x)))))","user":"5ff676a9e4b06df49cee1497"},{"problem":73,"code":"(fn ttt [rows]\n  (let [columns (apply map vector rows)\n        diagonals (map (partial map get rows) [(range 3) (reverse (range 3))])\n        longest (fn [player]\n                  (->> (concat rows columns diagonals)\n                       (map (comp count (partial filter #{player})))\n                       (reduce max)))\n        winner (filter (comp (partial = 3) val) {:x (longest :x) :o (longest :o)})]\n    (if (seq winner) (first (first winner)) nil)))","user":"572ea970e4b0cd1946bd0f89"},{"problem":73,"code":"(fn \n  [b]\n  (if (and (.contains (map count (map distinct b)) 1) (not= ((b (.indexOf (map count (map distinct b)) 1) ) 0) :e))\n    ((b (.indexOf (map count (map distinct b)) 1)) 0)\n    (if (and (= ((b 1) 1) ((b 0) 0) ((b 2) 2) ) (not= ((b 1) 1) :e))\n      ((b 1) 1)\n      (if (and (= ((b 1) 1) ((b 0) 2) ((b 2) 0) ) (not= ((b 1) 1) :e))\n        ((b 1) 1)\n        (loop [x 0]\n          (if (not= x 3)\n            (if (and (= ((b 2) x) ((b 1) x) ((b 0) x)) (not= ((b 2) x) :e))\n              ((b 2) 0)\n              (recur (inc x))\n              )\n            nil\n            ))))))","user":"5772ddb0e4b0979f896515d4"},{"problem":73,"code":"(fn [board]\n  (let [verts (->> board\n                   (apply interleave)\n                   (partition 3)\n                   (map #(apply vector %)))\n        diags [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n               [((board 0) 2) ((board 1) 1) ((board 2) 0)]]\n        runs (concat board verts diags)\n        xwon? (fn [x] (every? #(= :x %) x))\n        owon? (fn [x] (every? #(= :o %) x))]\n    (cond\n     (some true? (map xwon? runs)) :x\n     (some true? (map owon? runs)) :o\n     :else nil)))","user":"50eeeadae4b02c17778c91f3"},{"problem":73,"code":"(let [transpose (partial apply map vector)\n      down-right-diag (fn [rows]\n                        (map #(get-in rows [% %])\n                             (range 3)))\n      winner-in-triplet (fn [[head :as trip]]\n                          (when (and (apply = trip)\n                                     (#{:x :o} head))\n                            head))]\n  (fn [rows]\n    (let [cols (-> rows transpose)\n          diags [(-> rows down-right-diag)\n                 (-> rows reverse vec down-right-diag)]]\n      (some winner-in-triplet\n            (concat rows cols diags)))))","user":"5424c523e4b01498b1a71b03"},{"problem":73,"code":"(fn tic-tac-toe [[& rows]]\n   (let [columns (apply map vector rows)\n         diagonals\n         (reduce\n          (fn [[d1 d2] [idx row]]\n            [(concat d1 (take 1 (drop idx row)))\n             (concat d2 (take 1 (drop idx (reverse row))))])\n          [[] []]\n          (map-indexed vector rows))\n         all (concat rows columns diagonals)\n         check (fn [s] (some (fn [line] (every? #(= s %) line)) all))]\n     (cond \n       (check :x) :x\n       (check :o) :o\n       :else nil)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":73,"code":"(fn [board]\n  (some\n    (fn [[a b c]]\n      (let [item (get-in board a)]\n        (if (and\n             (not= item :e)\n             (= item\n               (get-in board b)\n               (get-in board c))) item)))\n    [[[0 0] [0 1] [0 2]]\n     [[1 0] [1 1] [1 2]]\n     [[2 0] [2 1] [2 2]]\n     [[0 0] [1 0] [2 0]]\n     [[0 1] [1 1] [2 1]]\n     [[0 2] [1 2] [2 2]]\n     [[0 0] [1 1] [2 2]]\n     [[2 0] [1 1] [0 2]]]))","user":"55101237e4b06e50f9beb181"},{"problem":73,"code":"(fn att [board]\r\n  (let [\r\n        [row1 row2 row3] board\r\n        rotated-board (partition 3 (apply interleave board))\r\n        checker (fn [p]\r\n                  (cond\r\n                   (some #{[p p p]} board) p\r\n                   (some #{[p p p]} rotated-board) p\r\n                   (= [(row1 0) (row2 1) (row3 2)] [p p p]) p\r\n                   (= [(row1 2) (row2 1) (row3 0)] [p p p]) p\r\n                   :else false))\r\n        iks (checker :x)\r\n        oks (checker :o)]\r\n    (cond\r\n     iks iks\r\n     oks oks\r\n     :else nil)))","user":"5376966ae4b06839e8705e27"},{"code":"(fn tictac [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]\n    (letfn [(line? [x y z] (and (not= :e x) (= x y z)))]\n        (cond\n        (line? a1 a2 a3) a1\n        (line? b1 b2 b3) b1\n        (line? c1 c2 c3) c1\n        (line? a1 b1 c1) a1\n        (line? a2 b2 c2) a2\n        (line? a3 b3 c3) a3\n        (line? a1 b2 c3) a1\n        (line? a3 b2 c1) a3\n        :else nil)))","problem":73,"user":"4f128865535d64f603146428"},{"problem":73,"code":"(fn [s]\n  (let [f #(when (and (apply = %) (not= (first %) :e)) (first %))\n        g #(apply (partial map (fn [& x] (f x)) ) %)\n        o (fn [a b] `[~(a b) ~(a (- (count a) (inc b)))])]\n    (some identity (concat (keep f s) (g s) (g (map o s (range)))))))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn [g]\n  (let [cols (map (fn [col] (map #(nth % col) g)) (range 3))\n        diag [[(first (first g)) (second (second g)) (last (last g))]\n              [(last (first g)) (second (second g)) (first (last g))]]\n        lines (concat g cols diag)]\n       (cond\n        (some #(= % [:x :x :x]) lines) :x\n        (some #(= % [:o :o :o]) lines) :o\n        true nil)))","problem":73,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":73,"code":"(fn [z] (let [dir [first second last]]                                                                                                                                                                                                \n                  (letfn [(same? [x l] (every? #(= x %) l))                                                                                                                                                                                   \n                          (trav [r] (map  (fn [f z] (into [] (reduce #(conj % (f %2)) [] z))) dir (repeat 3 r)))                                                                                                                              \n                          (l->r [z] [(map #(% %2) dir z)])                                                                                                                                                                                    \n                          (r->l [z] [(map #(% %2) (reverse dir) z)])                                                                                                                                                                          \n                          (win? [e c]  (or (some #(same? e %) c)                                                                                                                                                                              \n                                           (some #(same? e %) (trav c))                                                                                                                                                                       \n                                           (some #(same? e %) (l->r c))                                                                                                                                                                       \n                                           (some #(same? e %) (r->l c))))]                                                                                                                                                                    \n                    (cond                                                                                                                                                                                                                     \n                     (win? :x z) :x                                                                                                                                                                                                           \n                     (win? :o z) :o                                                                                                                                                                                                           \n                     :else nil))))","user":"52265e41e4b04e78ff2e1981"},{"code":"(fn tic-tac-toe\n  [board]\n  (let [eq-and-value (fn [args]\n                       (if (apply = args)\n                         (if (= (first args) :e)\n                           nil\n                           (first args))))]\n  (let [col1 (eq-and-value (map first board))\n        col2 (eq-and-value (map #(nth % 1) board))\n        col3 (eq-and-value (map last board))]\n    (if-let [retv (or col1 col2 col3)]\n      retv\n      (let [row1 (eq-and-value (first board))\n            row2 (eq-and-value (nth board 1))\n            row3 (eq-and-value (last board))]\n        (if-let [retv (or row1 row2 row3)]\n          retv\n          (let [diag1 (eq-and-value [(first (first board))\n                                     (nth (nth board 1) 1)\n                                     (last (last board))])\n                diag2 (eq-and-value [(last (first board))\n                                     (nth (nth board 1) 1)\n                                     (first (last board))])]\n            (if-let [retv (or diag1 diag2)]\n              retv\n              nil))))))))","problem":73,"user":"511b233ae4b07ab9ec456180"},{"code":"#(letfn [\n  (winning-position? [p b i]\n    (and \n      (= p (b (i 0))) \n      (= p (b (i 1))) \n      (= p (b (i 2)))))\n  (won-game? [p b w]\n    (if (empty? w)\n      false\n      (if (winning-position? p b (first w))\n        true\n        (recur p b (rest w)))))]\n  (let [\n    w [[0 1 2][3 4 5][6 7 8][0 3 6][1 4 7][2 5 8][0 4 8][2 4 6]]\n    b\t(vec (flatten %))]\n    (if (won-game? :x b w)\n      :x\n      (if (won-game? :o b w)\n        :o\n        nil))))","problem":73,"user":"4e8f4f64535d65386fec2149"},{"problem":73,"code":"(fn [m]\n  (let [f (fn [e m]\n            (let [coordinates\n                  (partition 3 (concat\n                                 (for [x (range 3) y (range 3)] [y x])\n                                 (for [x (range 3) y (range 3)] [x y])\n                                 (for [i (range 3)] [i i])\n                                 (for [i (range 3)] [i (- 2 i)])))]\n              (for [c coordinates\n                    :when (every? #(= % e) (map #(get-in m %) c))] e)))\n        ]\n    (if (empty? (f :x m))\n      (if (empty? (f :o m)) nil :o)\n      :x)\n    ))","user":"53b530c6e4b047364c0444bc"},{"code":"(fn [board]\n  (letfn[\n(check [board key]\n  (or\n    (reduce #(or %1 %2) (for [row board]\n    (reduce #(and %1 %2) (map #(= key %) row))\n    ))\n    ( reduce #(or %1 %2) (for [n (range 3)]\n                 (reduce #(and %1 %2) (map #(= key %) \n                 (for [row board]\n                   (nth row n)\n                   )\n               )\n          )\n  ))\n    (reduce #(and %1 %2) \n          (map #(= key %)\n               (for [n (range 3)]\n                 (nth (nth board n) n)\n                 )               \n               )\n  )\n  (reduce #(and %1 %2) \n          (map #(= key %)\n               (for [n (range 3)]\n                 (nth (nth board (- 2 n)) n)\n                 )               \n               )\n  )\n    )\n)\n(ff [board]\n  (cond\n    (check board :x) :x\n    (check board :o) :o\n    true nil\n  )\n)\n]\n(ff board)\n)\n)","problem":73,"user":"4ecfa05c535d44c135fd68b9"},{"problem":73,"code":"(fn [colls]\n        (let [n 3 colls2 (flatten colls)]\n             (or\n               (some identity\n                     (for [row colls]\n                          (if (and (apply = row) (not= :e (first row)))\n                            (first row)\n                            )\n                          ))\n               (some identity\n                     (for [l (map\n                               (fn [x]\n                                   (for [l (range n)]\n                                        (+ (* l n) x)\n                                        ))\n                               (range n))]\n\n                          (if (and (apply = (map #(nth colls2 %) l)) (not= :e (nth colls2 (first l))))\n                            (nth colls2 (first l))\n                            )\n                          ))\n\n               (if (and (apply = (map #(nth colls2 %) (map #(+ % (* n %)) (range n)))) (not= :e (nth colls2 0)))\n                 (nth colls2 0)\n                 )\n\n               (if (and (apply = (map #(nth colls2 %) (map #(* (- n 1) (inc %)) (range n)))) (not= :e (nth colls2 (dec n))))\n                 (nth colls2 (dec n))\n                 )\n\n               )\n\n             )\n        )","user":"57086931e4b0b0fb43fd069e"},{"problem":73,"code":"(fn analyze-a-tic-tac-toe-board [board]\n  (letfn [(win? [who]\n            (some true?\n                  (for [x (range 3)\n                        y (range 3)\n                        [dx dy] [[1 0] [0 1] [1 1] [1 -1]]]\n                    (every? true? (for [i (range 3)]\n                                    (= (get-in board [(+ (* dx i) x)\n                                                      (+ (* dy i) y)])\n                                       who))))))]\n    (cond (win? :x) :x\n          (win? :o) :o\n          :else nil)))","user":"5693a53ee4b0dcc4269f4106"},{"problem":73,"code":"(fn [board]\n  (letfn [(some-other-combos []\n            (partition 3 (for [z (list #(do [%1 %1])\n                                       #(do [%1 (- 2 %1)]))\n                               x (range 3)] (z x))))\n          (some-winning-combos []\n            (partition 3 (for [z (list #(do [%1 %2])\n                                       #(do [%2 %1]))\n                               x (range 3)\n                               y (range 3)] (z x y))))\n          (winning-combos [] (concat (some-winning-combos) (some-other-combos)))\n          (winner-from-arrangment [board combo]\n            (reduce\n              #(if (and %1 (= %1 %2) (not (= :e %1))) %1)\n              (map #(get-in board %) combo)))\n          (winner [board] (first (filter (complement nil?) (map #(winner-from-arrangment board %) (winning-combos)))))]\n    (winner board)))","user":"5536dfaee4b09218d5f44fc4"},{"problem":73,"code":"(fn ttt [b]\n   (let [i (range 0 (count b))\n         size (apply max i) \n         eq (fn [a b] (when (= a b) a))\n         win? (fn [c] (some #{:x :o} c))\n         reduce-eq (fn [c] (reduce eq (first c) (rest c)))\n         row (win? (map reduce-eq b))\n         col (win? (map reduce-eq (apply map vector b)))\n         diag1 (win? (vector (reduce-eq (map #((b %) %) i))))\n         diag2 (win? (vector (reduce-eq (map #((b (- size %)) %) i))))\n         ]\n     (some #(identity %) (vector row col diag1 diag2))))","user":"535eaa73e4b04ce2eb3ed2d4"},{"code":"#(some {[:x :x :x] :x [:o :o :o] :o}\n       (let [x [0 1 2, 3 4 5, 6 7 8\n        \t\t0 3 6, 1 4 7, 2 5 8\n        \t\t0 4 8, 2 4 6]\n\t\t\t b (vec (flatten %))]\n          (partition 3 (map (partial nth b) x))))","problem":73,"user":"51197750e4b057cba170bc99"},{"code":"(fn \n  [t] (some {[:x :x :x] :x [:o :o :o] :o} \n  \t(concat t\n\t\t\t(map #(reduce (fn [c e] (conj c (nth e %))) [] t) [0 1 2])\n\t\t\t(list (map get t [0 1 2]) (map get t [2 1 0]))))\n)","problem":73,"user":"4f047542535dcb61093f6bc7"},{"code":"(fn ttt [rrs]\n  (loop [h\n(fn horiz [v rs]\n  (if (empty? rs)\n    nil\n    (if (= [v v v] (first rs))\n      v\n      (recur v (rest rs)))))\n        v\n(fn vert [v rs]\n  (loop [v v, p 0, [r1 r2 r3] rs]\n  (if (> p 2)\n    nil\n    (if (and (= (nth r1 p) v) (= (nth r2 p) v) (= (nth r3 p) v))\n      v\n      (recur v (inc p) [r1 r2 r3])))))\n        d\n(fn diag [v [r1 r2 r3]]\n  (if (or (and (= (nth r1 0) v) (= (nth r2 1) v) (= (nth r3 2) v))\n          (and (= (nth r1 2) v) (= (nth r2 1) v) (= (nth r3 0) v)))\n    v\n    nil))]\n  (if (and (nil? (h :x rrs)) (nil? (d :x rrs)) (nil? (v :x rrs))) \n    (if (and (nil? (h :o rrs)) (nil? (d :o rrs)) (nil? (v :o rrs)))\n      nil \n      :o)\n    :x)))","problem":73,"user":"4e123905535d04ed9115e7ce"},{"problem":73,"code":"(fn solve [board]\n  (let [same-side? (fn [items]\n          (when (= 1 (count (into #{} items)))\n            (first items)))\n        g (fn [col row] (fn [x] (get-in x [col row])))\n        h-t (juxt (g 0 0) (g 0 1) (g 0 2))\n        h-m (juxt (g 1 0) (g 1 1) (g 1 2))\n        h-b (juxt (g 2 0) (g 2 1) (g 2 2))\n        v-l (juxt (g 0 0) (g 1 0) (g 2 0))\n        v-m (juxt (g 0 1) (g 1 1) (g 2 1))\n        v-r (juxt (g 0 2) (g 1 2) (g 2 2))\n        tl-br (juxt (g 0 0) (g 1 1) (g 2 2))\n        tr-bl (juxt (g 0 2) (g 1 1) (g 2 0))\n        rst (->> (map #(same-side? (% board)) [h-t h-m h-b v-l v-m v-r tl-br tr-bl])\n              (set))]\n    (cond\n      (rst :x) :x\n      (rst :o) :o)))","user":"559622cee4b0c79f6e1db975"},{"code":"(fn [b] (let [\n  fb (vec (flatten b))\n  wins [[0 1 2] [3 4 5] [6 7 8]\n        [0 3 6] [1 4 7] [2 5 8]\n        [0 4 8] [2 4 6]]\n  mapped (map (fn [a] (map #(fb %) a)) wins)] \n    (cond \n      (some #(= % [:x :x :x]) mapped)\n      :x\n      (some #(= % [:o :o :o]) mapped)\n      :o)))","problem":73,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn [board]\n  (let\n    [at (fn [x y] ((board y) x))\n     row (fn [y] (map #(at % y) (range 3)))\n     col (fn [x] (map #(at x %) (range 3)))\n     diag1 (map #(at % %) (range 3))\n     diag2 (map #(at % (- 2 %)) (range 3))\n     all (concat\n          (map row (range 3))\n          (map col (range 3))\n          [diag1] [diag2])\n     winning (fn [p s] (every? #(= p %) s))\n     won (fn [p] (not-empty (filter #(winning p %) all)))]\n    \n    (cond\n     (won :x) :x\n     (won :o) :o\n     :else nil)))","problem":73,"user":"50d8f4b6e4b01f0871336e74"},{"problem":73,"code":"(fn [[[x1 x2 x3] [y1 y2 y3] [z1 z2 z3]]]\n  (let [valids (partition 3 [x1 x2 x3\n                             y1 y2 y3\n                             z1 z2 z3\n                             x1 y1 z1\n                             x2 y2 z2\n                             x3 y3 z3\n                             x1 y2 z3\n                             x3 y2 z1])\n        is-win? (fn [p] (some #(every? (partial = p) %) valids))]\n    (cond (is-win? :x) :x\n          (is-win? :o) :o\n          :else nil)))","user":"5d45749be4b07c84aa5ae6a2"},{"problem":73,"code":"(fn tic-tac-toe [board]\n    (let\n      [\n        horizontal-paths board\n\n        vertical-paths\n        (map\n          (fn [x]\n            (map\n              (fn [row]\n                (nth row x)\n              )\n              board\n            )\n          )\n          (range 3)\n        )\n\n        path-top-left\n        (map\n          (fn [i]\n            (nth\n              (nth board i)\n              i\n            )\n          )\n          (range 3)\n        )\n\n        path-top-right\n        (map\n          (fn [i]\n            (nth\n              (nth board i)\n              (- 2 i)\n            )\n          )\n          (range 3)\n        )\n\n        cross-paths\n        [path-top-left path-top-right]\n\n        paths\n        (concat\n          horizontal-paths\n          vertical-paths\n          cross-paths\n        )\n\n        wins?\n        (fn [player]\n          (some\n            (fn [p]\n              (every?\n                (fn [v]\n                  (= v player)\n                )\n                p\n              )\n            )\n            paths\n          )\n        )\n      ]\n      (cond\n        (wins? :x) :x\n        (wins? :o) :o\n        :else\n        nil\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn f73 [col]\n    (letfn [(hor [c n] (list (first (nth c n)) (apply = (nth c n))))\n            (ver [c n] (list (nth (first c) n) (apply = (map #(nth % n) c))))\n            (dig [c] (list (second (second c))\n                     (or (apply = (list (first (first c)) \n                                        (second (second c))\n                                        (nth (nth c 2) 2)))\n                         (apply = (list (nth (first c) 2)\n                                        (second (second c))\n                                        (first (nth c 2)))))))]\n        (let [winner (filter #(true? (second %)) \n                             (concat (map #(hor col %) (range 0 2))\n                                     (map #(ver col %) (range 0 2))\n                                     (list (dig col))))]\n            (cond (= :x (first (first winner)))\n                  :x\n                  (= :o (first (first winner)))\n                  :o))))","problem":73,"user":"528a3e14e4b0239c8a67ae72"},{"problem":73,"code":"(fn t [[\n[a b c]\n[d e f]\n[g h i]]]\n (let [\ncombos [\n[a b c]\n[d e f]\n[g h i]\n[a d g]\n[b e h]\n[c f i]\n[a e i]\n[c e g]]\naligned (filter #(apply = %) combos)\nnon-empties (filter #(not (= :e %)) (flatten aligned))\n]\n(first non-empties)))","user":"589b98fae4b00487982d533c"},{"code":"(fn [[a b c]]\n  (let [q (into [a b c \n                 [(first a)(second b)(last c)]\n                 [(first c)(second b)(last a)]] (map vector a b c))\n        won? (fn [[x & r]] (when (and (apply = x r) (not= :e x)) x))]\n    (first (remove nil? (map won? q)))))","problem":73,"user":"52d02380e4b07d0d72b273b7"},{"problem":73,"code":"(fn [board]\n    (let [vr (for [x (range 3)]\n              (get-in board[(+ x 0) (+ x 0)]))\n          vl (for [x (range 3)]\n               (get-in board [(+ x) (- 2 x)]))\n          columns (apply map vector board)\n          checks (concat board [vl] [vr] columns)]\n      (letfn [(check-board [[row & res]]\n                (if row\n                  (let [dist (distinct row)]\n                      (if (or (= dist [:o]) (= dist [:x]))\n                        (first dist)\n                        (recur res)))\n                  nil))]\n        (check-board checks))))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn [v]\n  (letfn [(swap [v]\n            [(vec (map first v))\n             (vec (map second v))\n             (vec (map #(% 2) v))])\n          (win? [m v]\n            (or\n              (some #(every? #{m} %) v)\n              (some #(every? #{m} %) (swap v))\n              (= m ((v 0) 0) ((v 1) 1) ((v 2) 2))\n              (= m ((v 0) 2) ((v 1) 1) ((v 2) 0))))]\n          (cond\n            (win? :x v) :x\n            (win? :o v) :o\n            :else nil)))","problem":73,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":73,"code":"(fn  [board]\n  (let [size         (count board)\n        top-corners  [[0 0] [0 (- size 1)]]\n        confined?    #(every? (fn [c] (< -1 c size)) %)]\n    (loop [y 0 x 0]\n      (if (>= y size)\n        nil\n        (let [point      [y x]\n              value      (get-in board point)\n              sym        (if (= :e value) nil value)\n              horz       (filter confined? (map #(map + point %) [[0 1] [0 2] [0 -1] [0 -2]]))\n              vert       (filter confined? (map #(map + point %) [[1 0] [2 0] [-1 0] [-2 0]]))\n              diag       (if (some #(= point %) top-corners)\n                           (filter confined? (map #(map + point %) [[1 1] [2 2] [1 -1] [2 -2]]))\n                           [])\n              horz-eq    (and (> (count horz) 1) (every? #(= sym (get-in board %)) horz))\n              vert-eq    (and (> (count vert) 1) (every? #(= sym (get-in board %)) vert))\n              diag-eq    (and (> (count diag) 1) (every? #(= sym (get-in board %)) diag))]\n          (if (or horz-eq vert-eq diag-eq)\n            sym\n            (if (>= (inc x) size)\n              (recur (inc y) 0)\n              (recur y (inc x)))))))))","user":"56372c3ce4b0bfe05bf117d1"},{"problem":73,"code":"(fn [board]\n  (let [solutions [[0 1 2] [3 4 5] [6 7 8]\n                   [0 3 6] [1 4 7] [2 5 8]\n                   [0 4 8] [2 4 6]]\n        flat (vec (mapcat identity board))\n        all? #(reduce (fn [x y] (if (= x y) x)) %)]\n    (->> solutions\n         (map (comp vals (partial select-keys flat)))\n         (some (comp #{:x :o} all?)))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":73,"code":"(fn [[row1 row2 row3 :as horizontals]]\n  (let [verticals (map (fn [i] [(row1 i) (row2 i) (row3 i)]) (range 3))\n        diagonal1 [(row1 0) (row2 1) (row3 2)]\n        diagonal2 [(row1 2) (row2 1) (row3 0)]\n        all-rows (concat [diagonal1 diagonal2] horizontals verticals)]\n    (loop [[row & rows] all-rows]\n      (cond\n        (nil? row) nil\n        (every? #{:x} row) :x\n        (every? #{:o} row) :o\n        :else (recur rows)))))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":73,"code":"(fn [b]\n(letfn [(w\n          ([xs ys] (w ((b (first xs)) (first ys)) (rest xs) (rest ys)))\n          ([winner xs ys]\n           (cond (= winner :e) nil\n                 (empty? xs) winner\n                 (= ((b (first xs)) (first ys)) winner)\n                 (w winner (rest xs) (rest ys))\n                 :else nil)))]\n  (or (some #{:x :o} (map #(w (repeat 3 %) (range 3)) (range 3)))\n      (some #{:x :o} (map #(w (range 3) (repeat 3 %)) (range 3)))\n      (w (range 3) (range 3))\n      (w (range 3) (reverse (range 3))))))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":73,"code":"(fn [x]\n  (let [t (fn transpose [m]\n            (apply mapv vector m))\n        v (fn [m a b] ((m a) b))\n        y (t x)\n        p (fn [z] (if (= z :e) nil z))]\n    (cond\n      (apply = (x 0)) (p (first (x 0)))\n      (apply = (x 1)) (p (first (x 1)))\n      (apply = (x 2)) (p (first (x 2)))\n      (apply = (y 0)) (p (first (y 0)))\n      (apply = (y 1)) (p (first (y 1)))\n      (apply = (y 2)) (p (first (y 2)))\n      (apply = (list (v x 0 0) (v x 1 1) (v x 2 2))) (p (first (x 0)))\n      (apply = (list (v x 0 2) (v x 1 1) (v x 2 0))) (p (first (x 2)))\n      :default nil)))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn f [[[x1 x2 x3 :as r1][y1 y2 y3 :as r2][z1 z2 z3 :as r3]]]\r\n  (let [c1 [x1 y1 z1]\r\n        c2 [x2 y2 z2]\r\n        c3 [x3 y3 z3]\r\n        d1 [x1 y2 z3]\r\n        d2 [x3 y2 z1]]\r\n    (first\r\n      (filter #(identity %)\r\n    (map #(when (and (not= (first %) :e) (apply = %)) (first %))\r\n         [r1 r2 r3 c1 c2 c3 d1 d2])))))","problem":73,"user":"4e6a6b83535d8ccf87e9fee0"},{"code":"(fn [board]\n  (letfn\n    [(all-eq [s thing]\n      (reduce #(and %1 (= thing %2)) true s))\n     (any [s]\n       (reduce #(or %1 %2) s))\n     (winner [three]\n      (cond\n        (all-eq three :x) :x\n        (all-eq three :o) :o\n        :else nil))\n     (diag [m xsys]\n       (map (partial get-in m) xsys))]\n    (let [first-row #(get % 0)\n          second-row #(get % 1)\n          third-row #(get % 2)\n          first-col (fn [s] (map #(get % 0) s))\n          second-col (fn [s] (map #(get % 0) s))\n          third-col (fn [s] (map #(get % 0) s))\n          diag1\n            #(diag % (map vector (range 3) (range 3)))\n          diag2\n            #(diag % (map vector (range 3) (reverse (range 3))))\n          functions [first-row second-row third-row\n                     first-col second-col third-col\n                     diag1 diag2]]\n      (any (map (fn [f] (winner (f board))) functions)))))","problem":73,"user":"4f28c979e4b0d6649770a01a"},{"code":"(fn ttt [board]\n  (let [bsize (count board)\n        transform #(map nth board %)\n        vert-indices (map repeat \n                          (repeat bsize) \n                          (range bsize))\n        diag-indices [(range bsize) \n                      (reverse (range bsize))]\n\n        permuts (concat board\n                        (map transform vert-indices)\n                        (map transform diag-indices))\n        similar (filter #(apply = %) permuts)\n        filled? #(not= :e (first %))\n        winner (ffirst (filter filled? similar))\n        ]\n  winner))","problem":73,"user":"50052d38e4b0678c553fc45c"},{"problem":73,"code":"(fn analyze [board]\n  (letfn [(analyze-items [& items]\n            (cond\n              (apply = :o items) :o\n              (apply = :x items) :x\n              :else nil))]\n    (some\n      identity\n      (concat\n        (for [row board]\n          (apply analyze-items row))\n        (for [col (apply map vector board)]\n          (apply analyze-items col))\n        (for [diagonal [[(get-in board [0 0])\n                         (get-in board [1 1])\n                         (get-in board [2 2])]\n                        [(get-in board [0 2])\n                         (get-in board [1 1])\n                         (get-in board [2 0])]]]\n          (apply analyze-items diagonal))))))","user":"56ac81ace4b03c432f187347"},{"problem":73,"code":"(fn [brd]\n  (let [whowon? (fn [slc]\n                  (if (and (apply = slc) (#{:x :o} (first slc)))\n                    (first slc)))\n        winslices (fn [brd]\n                    [(nth brd 0)      ; h wins\n                     (nth brd 1)\n                     (nth brd 2)\n                     (map #(nth % 0) brd) ; v wins\n                     (map #(nth % 1) brd)\n                     (map #(nth % 2) brd)\n                     (map #(nth % %2) brd [0 1 2]) ; d wins\n                     (map #(nth % %2) brd [2 1 0])])]\n    (last (distinct (map whowon? (winslices brd))))))","user":"4e8768f6535dceadca469850"},{"problem":73,"code":"(fn [board]\n  (let [attack? (fn [positions]\n                  (if (or (apply = (cons :x positions))\n                          (apply = (cons :o positions)))\n                    (first positions)\n                    nil))\n        positions (conj (concat board\n                                (apply map vector board))\n                        (map #(get (get board (first %)) (second %)) [[0 0] [1 1] [2 2]])\n                        (map #(get (get board (first %)) (second %)) [[0 2] [1 1] [2 0]]))]\n    (first (remove nil? (map attack? positions)))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":73,"code":"(fn\n  [board]\n  (let [rows board\n        cols (apply map vector board)\n        diags [(mapv #(get-in board %) [[0 0] [1 1] [2 2]])\n               (mapv #(get-in board %) [[0 2] [1 1] [2 0]])]\n        all (reduce into [] [rows cols diags])]\n    (letfn [(has-three [coll k] (every? #(= k %) coll))]\n      (cond\n        (some #(has-three % :x) all) :x\n        (some #(has-three % :o) all) :o))))","user":"57625c18e4b0994c1922fba4"},{"problem":73,"code":"(fn f [b]\n        (->> '(:x :o)\n             (map \n              #(when\n                   (or\n                    (= % ((b 0) 0) ((b 0) 1) ((b 0) 2))\n                    (= % ((b 1) 0) ((b 1) 1) ((b 1) 2))\n                    (= % ((b 2) 0) ((b 2) 1) ((b 2) 2))\n                    (= % ((b 0) 0) ((b 1) 0) ((b 2) 0))\n                    (= % ((b 0) 1) ((b 1) 1) ((b 2) 1))\n                    (= % ((b 0) 2) ((b 1) 2) ((b 2) 2))\n                    (= % ((b 0) 0) ((b 1) 1) ((b 2) 2))\n                    (= % ((b 0) 2) ((b 1) 1) ((b 2) 0)))\n                 %))\n             (filter #(not (nil? %)))\n             first))","user":"575fbe58e4b08062f99a4e87"},{"code":"(fn [b]\n    (let [cols (for [n (range (count b))] (map #(nth % n) b))\n          diag1 [(map-indexed #(nth %2 %1) b)]\n          diag2 [(map-indexed #(nth %2 (- (count %2) %1 1)) b)]]\n      \n      (some #(if (or (= :e %) (= nil %)) nil %) (map (fn [col] (if (every? #(= (first col) %) col) (first col))) (concat b cols diag1 diag2)))\n    ))","problem":73,"user":"4f77b68de4b0fbe0118ec581"},{"problem":73,"code":"(fn winner [board]\n  (let [\n    rows board,\n    cols (apply map vector board),\n    [[r11 r12 r13][r21 r22 r23][r31 r32 r33]] board,\n    diagonals [[r11 r22 r33][r13 r22 r31]],\n    triplets (concat rows cols diagonals),\n    winner? (fn [who] (some true? (map #(every? #{who} %) triplets)))]\n      (cond\n        (winner? :x) :x\n        (winner? :o) :o)\n    ))","user":"587a3babe4b01531a375eae2"},{"problem":73,"code":"(fn [board]\n   (letfn [(row [k] (get board k))\n           (col [k] (map #(get % k) board))\n           (diag [k] (map #(get (get board %) (if (= k 1) % (- 2 %))) (range 3)))\n           (abstract-win [x sym] (apply = (conj x sym)))\n           (wins [x] (cond (abstract-win x :x) :x (abstract-win x :o) :o))]\n     (let [all (concat [(diag 0) (diag 1)] (apply concat (map #(vector (col %) (row %)) (range 3))))\n           winners (filter (complement nil?) (map wins all))]\n       (if (seq winners)\n         (first winners)\n         nil))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":73,"code":"(fn test [[r1 r2 r3 :as rows]]\n  (let [diagonals [[(r1 0) (r2 1) (r3 2)] [(r1 2) (r2 1) (r3 0)]]\n        lines (concat rows diagonals (apply map vector rows))]\n    (cond\n      (seq (filter #(= % [:x :x :x]) lines)) :x\n      (seq (filter #(= % [:o :o :o]) lines)) :o\n      :else nil)))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn [rows]\r\n  (let [cols [(map first rows) \r\n              (map second rows) \r\n              (map last rows)]\r\n        dias [[(ffirst rows) \r\n               (second (second rows))\r\n               (last (last rows))]\r\n              [(last (first rows))\r\n               (second (second rows))\r\n               (first (last rows))]]\r\n        posns (concat rows cols dias)\r\n        winner? #(when (apply = %) (first %))]\r\n  (loop [[p & ps :as pos] posns]\r\n    (if (empty? pos)\r\n        nil\r\n        (if-let [win (winner? p)]\r\n          (if (= win :e) (recur ps) win)\r\n          (recur ps))))))","problem":73,"user":"4fb37882e4b081705acca2a0"},{"problem":73,"code":"(fn ; HULK SMASH\n  [[r0 r1 r2]]\n  (cond\n   ; HULK CHECK ROWS\n   (= (distinct r0) [:x]) :x\n   (= (distinct r1) [:x]) :x\n   (= (distinct r2) [:x]) :x\n   (= (distinct r0) [:o]) :o\n   (= (distinct r1) [:o]) :o\n   (= (distinct r2) [:o]) :o\n   ; HULK CHECK COLS\n   (= (distinct [(r0 0) (r1 0) (r2 0)]) [:x]) :x\n   (= (distinct [(r0 1) (r1 1) (r2 1)]) [:x]) :x\n   (= (distinct [(r0 2) (r1 2) (r2 2)]) [:x]) :x\n   (= (distinct [(r0 0) (r1 0) (r2 0)]) [:o]) :o\n   (= (distinct [(r0 1) (r1 1) (r2 1)]) [:o]) :o\n   (= (distinct [(r0 2) (r1 2) (r2 2)]) [:o]) :o\n   ; HULK CHECK DIAGS\n   (= (distinct [(r0 0) (r1 1) (r2 2)]) [:x]) :x\n   (= (distinct [(r0 2) (r1 1) (r2 0)]) [:x]) :x\n   (= (distinct [(r0 0) (r1 1) (r2 2)]) [:o]) :o\n   (= (distinct [(r0 2) (r1 1) (r2 0)]) [:o]) :o\n   :else nil))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"code":"(fn [board]\n  (letfn [(check-horizonal [board]\n            (first (flatten (filter #(every? #{:x :o } %) (filter #(= 1 (count (set %))) board)))))]\n    (let [h (check-horizonal board)]\n      (if\n        h\n        h\n        (let [v (check-horizonal (apply (partial map #(vec [%1 %2 %3])) board))]\n          (if\n            v\n            v\n            (let [fd (check-horizonal [[(first (first board)) (second (second board)) (last (last board))]])]\n              (if\n                fd\n                fd\n                (check-horizonal [[(last (first board)) (second (second board)) (first (last board))]])))))))))","problem":73,"user":"514d7e29e4b019235f6c0587"},{"problem":73,"code":"(fn [[r1 r2 r3 :as rows]]\n  (let [c1 (map first rows)\n        c2 (map second rows)\n        c3 (map last rows)\n        d1 [(first r1) (second r2) (last r3)]\n        d2 [(last r1) (second r2) (first r3)]\n        combos [r1 r2 r3\n                c1 c2 c3\n                d1 d2]\n        winner? (fn [player]\n                  (some (fn [combo]\n                          (every? #(= % player) combo))\n                        combos))\n        x-win? (winner? :x)\n        o-win? (winner? :o)]\n    (cond\n     (and x-win? (not o-win?)) :x\n     (and o-win? (not x-win?)) :o)))","user":"58d2af83e4b03c36ff7e5907"},{"code":"(fn tic-tac-toe\n  [x]\n  (let [one (first (first x))\n        two (second (first x))\n        three (get (first x) 2)\n        four (first (second x))\n        five (second (second x))\n        six (get (second x) 2)\n        seven (first (get x 2))\n        eight (second (get x 2))\n        nine (get (get x 2) 2)]\n        (let [comb-one (vector one two three)\n              comb-two (vector four five six)\n              comb-three (vector seven eight nine)\n              comb-four (vector one four seven)\n              comb-five (vector two five eight)\n              comb-six (vector three six nine)\n              comb-seven (vector one five nine)\n              comb-eight (vector three five seven)]\n              (let [all-of-them (vector comb-one comb-two comb-three comb-four comb-five comb-six comb-seven comb-eight)\n                    wins? (fn [x y]\n                            (if (empty? y)\n                              false\n                              (if (every? (sorted-set x) (first y))\n                                true\n                                (recur x (rest y)))))]\n                    (if (wins? :o all-of-them)\n                      :o\n                      (if (wins? :x all-of-them)\n                        :x nil))))))","problem":73,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(fn [[[x11 x12 x13] [x21 x22 x23] [x31 x32 x33] :as b]]\n  (let [win (concat b (apply map vector b) [[x11 x22 x33] [x13 x22 x31]])]\n    (first (some #{[:x :x :x] [:o :o :o]} win))))","problem":73,"user":"4ed94d69535d10e5ff6f5303"},{"problem":73,"code":"(fn [coll]\n  (let [[c1 c2 c3] coll\n        full-x (repeat 3 :x)\n        full-o (repeat 3 :o)\n        some-f (fn [xcoll]\n                 (some #(if ((comp not nil?) %)\n                          %\n                          nil) (for [c xcoll]\n                                 (cond\n                                   (= c full-x) :x\n                                   (= c full-o) :o\n                                   )) ))\n        h-result (some-f coll)]\n    (if h-result\n      h-result\n      (let [v-result (some-f (->> (interleave c1 c2 c3)\n                                  (partition 3)\n                                  ))]\n        (if v-result\n          v-result\n          (let [s-result (some-f [[(first c1) (nth c2 1) (last c3)]\n                                  [(last c1) (nth c2 1) (first c3)]\n                                  ])]\n            (when s-result\n              s-result)))))))","user":"5823d3e6e4b051871117beb8"},{"code":"(fn winner [board]\n  (let [winning-row?\n        (fn [ x y z]\n          (cond\n           (= :x x y z) :x\n           (= :o x y z) :o\n           :else nil))\n        [[a b c] [d e f] [g h i]] board]\n    (or\n     (winning-row? a b c)\n     (winning-row? d e f)\n     (winning-row? g h i)\n     (winning-row? a d g)\n     (winning-row? b e h)\n     (winning-row? c f i)\n     (winning-row? a e i)\n     (winning-row? c e g))))","problem":73,"user":"5220bc0fe4b0e6a83c8925a7"},{"problem":73,"code":"(fn [m] (let [\ncl (fn [n] (map #(% n) m))\nd  (fn [x]\n     (loop [[f & r :as x] x, n 0, a []]\n       (if (seq x) (recur r (inc n) (conj a (f n))) a )))\ndd (fn [x]\n     (loop [[f & r :as x] x, n 2, a []]\n       (if (seq x) (recur r (dec n) (conj a (f n))) a )))\nx (concat m [(cl 0)] [(cl 1)] [(cl 2)] [(d m)] [(dd m)])\nwin? (fn [p] (some identity (map (fn [c] (every? #(= p %) c)) x)))\n] (if (win? :x) :x (if (win? :o) :o nil))))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":73,"code":"(fn my-tic-tac [board]\n  (let [my-nth (fn [x] (fn [b] (nth b x)))\n        [a b c] board\n        [d e f] (map  #(map (my-nth %) board) (range 3))\n        g (map-indexed #(nth %2  %) board)\n        h (map-indexed #(nth %2  (*  (- % 2) -1)) board)\n        i (set [a b c d e f g h])]\n    (cond\n      (contains? i [:x :x :x]) :x\n      (contains? i [:o :o :o]) :o\n      :else nil)))","user":"52eaba10e4b09f7907dd14c2"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (let [cases [[a b c] [d e f] [g h i] [a e i]\n               [c e g] [a d g] [b e h] [c f i]]\n\n        player-win-case?\n        (fn [pkey case]\n          (every? #(= % pkey) case))\n        \n        player-win-game?\n        (fn [pkey]\n          (some #(player-win-case? pkey %) cases))]\n    (cond (player-win-game? :x) :x\n          (player-win-game? :o) :o)))","user":"4e7d1c22535db169f9c796c5"},{"problem":73,"code":"(fn [b]\n  (let\n    [chk #(let [s (into #{} %)] (if (and (not (contains? s :e)) (= (count s) 1)) (first %) nil))\n     d [0 1 2]]\n    \n    (some #(when (not (nil? %)) %) (map chk \n                                        (concat\n                                         [(map #(get (get b %) %) d)\n                                          (map #(get (get b %) (- 2 %)) d)]\n                                         (map (fn [i] (map #(get % i) b)) d)\n                                         b)))))","user":"55316b8ae4b076ab5578f825"},{"problem":73,"code":"(fn winner [board]\n  (loop [wins [#{1 2 3} #{4 5 6} #{7 8 9} #{1 4 7} #{2 5 8} #{3 6 9} #{1 5 9} #{3 5 7}] state ((fn processBoard [lst]\n  (loop [xSet #{} oSet #{} c 0]\n    (if (= c 9) [xSet oSet]\n      (if (= (nth (flatten lst) c) :x) (recur (conj xSet (+ c 1)) oSet (inc c))\n        (if (= (nth (flatten lst) c) :o) (recur xSet (conj oSet (+ c 1))(inc c))\n          (recur xSet oSet (inc c))))))) board) co 0]\n    (if (= co 8) nil\n      (if (= (clojure.set/intersection (nth wins co) (first state)) (clojure.set/intersection (nth wins co))) :x\n        (if (= (clojure.set/intersection (nth wins co) (second state)) (clojure.set/intersection (nth wins co))) :o\n          (recur wins state (inc co)))))))","user":"558378dce4b05c286339e115"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (->> \n    (lazy-cat\n      (for [row (range 3)] (map #(get % row) board))\n      (for [col (range 3)] (get board col))\n      (for [k [ (vec (zipmap (range 3) (range 3)))\n               (vec (zipmap (range 3) (reverse (range 3)))) ]]\n        (map #(get-in board %) k)))\n    (some #{[:o :o :o] [:x :x :x]})\n    first))","user":"534d1173e4b084c2834f4a98"},{"problem":73,"code":"(fn [board]\n  (let [[x y z] board\n        [a b c] (apply map vector board)\n        d1 [(x 0) (y 1) (z 2)]\n        d2 [(x 2) (y 1) (z 0)]]\n    (cond\n      (some true? (map (partial every? #{:x}) [x y z a b c])) :x\n      (some true? (map (partial every? #{:o}) [x y z a b c])) :o\n      (some true? (map (partial every? #{:x}) [d1 d2])) :x\n      (some true? (map (partial every? #{:o}) [d1 d2])) :o\n      :else nil)))","user":"5df08767e4b093ff717275bf"},{"code":"(fn [board]\n   (let [rows (concat board\n                      (apply map list board)\n                      (for [pos-seq [[0 0 1 1 2 2]\n                                     [0 2 1 1 2 0]]]\n                        (for [pos (partition 2 pos-seq)]\n                          (get-in board pos))))]\n     (first (for [[who :as row] rows\n                  :when (and (not= :e who)\n                             (apply = row))]\n              who))))","problem":73,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":73,"code":"(fn [board]\n  (let [left  (map first board)\n        vert  (map second board)\n        horz  (second board)\n        right (map last board)\n        diag1 [(first left) (second vert) (last right)]\n        diag2 [(first right) (second vert) (last left)]\n        chk (fn [row]\n              (if (and (not (= (first row) :e))\n                       (every? #(= % (first row)) row))\n                (first row)\n                nil))]\n    (first (remove nil? (map chk [left vert horz right diag1 diag2])))))","user":"4f774b17e4b0fbe0118ec57b"},{"problem":73,"code":"(fn [grid]\n  (let [check-line (fn [[a b c]] (and (= a b c) (#{:x :o} a)))\n        winner #(some check-line %)\n        rotated-90-ccw-grid (reverse (apply map vector grid))\n        all-lines (concat grid\n                          rotated-90-ccw-grid\n                          ;; diagonal 1\n                          [(take-nth 4 (apply concat grid))]\n                          ;; diagonal 2\n                          [(take-nth 4 (apply concat rotated-90-ccw-grid))])]\n    (winner all-lines)))","user":"59a080e3e4b0871e7608b837"},{"problem":73,"code":"(fn   ([b] (letfn [(w [c] (let [s (set c)] (if (= 1 (count s)) (some #{:o :x} s))))]\n         (some #{:x :o} (set (map w (concat\n                                           b\n                                           (apply map vector b)\n                                           [(map #(%1 %2) b (iterate dec 2))\n                                            (map #(%1 %2) b (iterate inc 0))]\n                                           )))))))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"(let [\n  lines [\n    [[0 0] [0 1] [0 2]]\n    [[1 0] [1 1] [1 2]]\n    [[2 0] [2 1] [2 2]]\n    [[0 0] [1 0] [2 0]]\n    [[0 1] [1 1] [2 1]]\n    [[0 2] [1 2] [2 2]]\n    [[0 0] [1 1] [2 2]]\n    [[0 2] [1 1] [2 0]]]\n  get-line (fn [board line]\n    (let [vals (map #(get-in board %) line)]\n      (if (apply = vals)\n        (if (= (first vals) :e)\n          nil\n          (first vals))\n        nil)))]\n  (fn [board]\n    (some identity (map #(get-line board %) lines))))","problem":73,"user":"4ec07699535dfed6da9c6da2"},{"code":"#(let [pairs [[0 0][0 1][0 2][1 0][1 1][1 2][2 0][2 1][2 2][0 0][1 0][2 0][0 1][1 1][2 1][0 2][1 2][2 2][0 0][1 1][2 2][0 2][1 1][2 0]]\n       l (partition 3 (map (partial get-in %) pairs))\n       f (fn [i]\n           (cond (every? (partial = :o) i) :o\n                 (every? (partial = :x) i) :x\n                 :else nil))]\n    (some f l))","problem":73,"user":"50a83315e4b054305ba5a830"},{"problem":73,"code":"(fn [b]\n  (letfn [(row? [b v] (->> (map (partial every? #(= v %)) b) (filter true?) first true?))\n          (col? [b v] (row? (->> (first b) count range (map (fn [i] (map #(get % i) b)))) v))\n          (diag? [b v] (let [l (count (first b))] (row? [(map #(get-in b [% %]) (range l))\n                                                         (map #(get-in b [(- (dec l) %) %]) (range l))]\n                                                        v)))]\n    (cond (or (row? b :x) (col? b :x) (diag? b :x)) :x\n          (or (row? b :o) (col? b :o) (diag? b :o)) :o)))","user":"54055aa9e4b0addc1aec6665"},{"problem":73,"code":"(fn [b] \n  (let [N (count (first b))]\n  ((comp first first) \n   (filter #(or (apply = :o %) (apply = :x %))\n      ; horizontals\n     (concat b\n      ; verticals\n      (for [x (range N)] (map #(nth % x) b))\n      ; diagnal nw to se\n      [(for [x (range N)] (nth (nth b x) x))]\n      ; diagnal ne to sw\n      [(for [x (range N)] (nth (reverse (nth b x)) x))])))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":73,"code":"(fn [rows]\n  (letfn [(diag [xss] (map #((xss %) %) (range 3)))]\n    (let [cols (for [i (range 3)] (map #(% i) rows))\n          d1 (diag rows)\n          d2 (diag (vec (reverse rows)))\n          xss (concat rows cols [d1 d2])]\n      (letfn [(three-in-a-row [sym] (some #(every? (partial = sym) %) xss))]\n        (cond\n         (three-in-a-row :x) :x\n         (three-in-a-row :o) :o)))))","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":73,"code":"(fn my-tic-tac-toe [board]\n  (letfn [(wins? [player]\n            (->> (concat \n                   (for [x (range 3) y (range 3)] [x y])\n                   (for [x (range 3) y (range 3)] [y x])\n                   (list [0 0] [1 1] [2 2] [0 2] [1 1] [2 0]))\n                 (partition 3)\n                 (map (fn [idxs]\n                        (every? #(= player %) \n                                (map #(get-in board %) idxs))))\n                 (some true?)))]\n      (cond (wins? :x) :x\n            (wins? :o) :o\n            :default nil)))","user":"581b19e7e4b04b46fc4b0ec4"},{"problem":73,"code":"(fn [rows]\n  (let\n    [checkxo (fn [pred] (if (pred :x) :x (if (pred :o) :o nil)))\n     alleq (fn [c coll] (apply = c coll))\n     hasgroupeq (fn [c groups] (some (partial alleq c) groups))\n     cols (apply map vector rows)\n     diag (map-indexed #(nth %2 %1) rows)\n     bdiag (map-indexed #(nth %2 (- (dec (count (first rows))) %1)) rows)]\n    (checkxo #(hasgroupeq % (concat rows cols [diag bdiag])))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn [board] \n  (let [indices (range (count (first board))) \n        possible-lines (concat \n                        (map identity board) \n                        (apply (partial map vector) board)\n                        (vector (map get board indices))\n                        (vector (map get (reverse board) indices)))]\n  (cond\n   (some (fn [line] (every? #(= :x %) line)) possible-lines) :x\n   (some (fn [line] (every? #(= :o %) line)) possible-lines) :o\n   :else nil)))","problem":73,"user":"527ccaf4e4b0757a1b17136d"},{"problem":73,"code":"(fn [table]\n  (let [empty-line? (fn [line]\n                      (= #{:e} (set line)))\n        win? (fn [line]\n               (when-not (empty-line? line)\n                 (= 1 (count (set line)))))\n        row-win (seq (filter win? table))\n        transpose [(mapv first table)\n                   (mapv second table)\n                   (mapv last table)]\n        col-win (seq (filter win? transpose))\n        diag-win (when (not= :e (get-in table [1 1]))\n                   (or (= (get-in table [0 0])\n                          (get-in table [1 1])\n                          (get-in table [2 2]))\n                       (= (get-in table [0 2])\n                          (get-in table [1 1])\n                          (get-in table [2 0]))))]\n    (or (when row-win (ffirst row-win))\n        (when col-win (ffirst col-win))\n        (when diag-win (get-in table [1 1])))\n    ))","user":"5054c853e4b0b1b9d1860eb3"},{"problem":73,"code":"(fn [board]\n  (let [win-conditions '([0 1 2] [3 4 5] [6 7 8] ;; rows\n                         [0 3 6] [1 4 7] [2 5 6] ;; columns\n                         [0 4 8] [2 4 6]) ;; diagonals\n        flatten-board  (vec (flatten board))]\n    \n    (some #(let [num1 (flatten-board (% 0))\n                 num2 (flatten-board (% 1))\n                 num3 (flatten-board (% 2))]\n             (cond (= num1 num2 num3 :x)\n                   :x\n                   (= num1 num2 num3 :o)\n                   :o))\n          win-conditions)))","user":"57204301e4b0c5bde472c093"},{"code":"#(let [v (vec (flatten %))]\r\n        (if (or\r\n             (= (v 0) (v 3) (v 6) :x)\r\n             (= (v 0) (v 4) (v 8) :x))\r\n          :x\r\n          (if (or\r\n             (= (v 3) (v 4) (v 5) :o)\r\n             (= (v 2) (v 4) (v 6) :o))\r\n            :o)))","problem":73,"user":"4fe9de74e4b0547ebccb2475"},{"code":"(fn tic [coll]\n  (letfn [(get-coll [idx0 idx1]\n                    (if (or (< idx0 0) (< idx1 0) (> idx0 2) (> idx1 2))\n                      nil\n                      ((coll idx0) idx1)))\n          (map2 [position]\n                {(some #(true? %)\n                (map (fn [coll2]\n                       (every? #(true? %)\n                       (for [x [position]\n                             y coll2]\n                         (let [result (get-coll (+ (x 0) (y 0)) (+ (x 1) (y 1)))]\n                           (if (= result :e)\n                             false\n                           (= result (apply get-coll position)))))))\n                    [[[-1 0] [1 0]]\n                    [[0 1] [0 2]]\n                    [[0 -1] [0 -2]]\n                    [[0 -1] [0 1]]\n                    [[-1 -1] [1 1]]\n                    [[1 -1] [-1 1]]]))\n                 (apply get-coll position)\n                 })]\n    ((apply merge (map (fn [position]\n           (map2 position))\n         [[1 0] [1 1] [1 2]])) true)))","problem":73,"user":"4f036d9b535dcb61093f6ac1"},{"code":"(fn [b]\n  (let [[[p1 p2 p3] [p4 p5 p6] [p7 p8 p9]] b]\n    (reduce #(or %1 %2)\n            (map (fn [[x y z]] (if (and (= x y) (= y z) (not= x :e)) x nil))\n                 [(b 0) (b 1) (b 2)\n                  [p1 p4 p7]\n                  [p2 p5 p8]\n                  [p3 p6 p9]\n                  [p1 p5 p9]\n                  [p3 p5 p7]]))))","problem":73,"user":"4f0d093b535d0136e6c22313"},{"problem":73,"code":"(fn [x]\n  (let [lines (conj x\n                      (map first x)\n                      (map second x)\n                      (map last x)\n                      [(ffirst x) (second (second x)) (last (last x))]\n                      [(last (first x)) (second (second x)) (first (last x))])]\n    (some {[:x :x :x] :x, [:o :o :o] :o} lines)))","user":"58247423e4b051871117bec5"},{"code":"(let [left-right [0 1 2]\n      right-left [2 1 0]]\n  (letfn [ (test-win [row]\n                     (when row\n                       (first (filter (fn [player] (every? #(= % player) row)) [:o :x]))))\n           (diagonal [b diag]\n                     (test-win (map #(nth %1 %2) b  diag)))\n           (vertical [b]\n                     (some test-win (partition 3 (for [x (range 3) \n                                                       y (range 3)] \n                                                   (nth (b y) x)))))\n           (horizontal [b]\n                       (some test-win (partition 3 (for [x (range 3) \n                                                         y (range 3)] \n                                                     (nth (b x) y)))))\n           (tic-tac-toe [b]\n                        (or\n                         (horizontal b)\n                         (vertical b )\n                         (diagonal b left-right)\n                         (diagonal b right-left)))]\n    tic-tac-toe))","problem":73,"user":"521d709ae4b050d5da0427ef"},{"code":"(fn [y] \n    (let [a (-> first) b (-> second) c (-> last)]\n    ((fn [x] (loop [l x]\n      (let [s (a l) r (rest l)]\n      (if (every? #(= (a s) %) s)\n        (if (= (a s) :e) nil (a s))\n        (if (empty? r) nil (recur r)))\n                  ))) (concat [(a y) (b y) (c y) (map (-> a) y) (map (-> b) y) (map (-> c) y) [(a (a y)) (b (b y)) (c (c y))] [(a (c y)) (b (b y)) (c (a y))]])\n              )))","problem":73,"user":"4f1595da535d64f603146444"},{"problem":73,"code":"(fn ticTacToeX [m]\n\t(cond\n\t\t((fn ticTacToeSymbol [m s]\n\t(let \n\t\t[\n\t\tx (get m 0)\n\t\ty (get m 1)\n\t\tz (get m 2)\n\t\t]\n\t\t\n\t(or\n\t((fn all [x s] (every? #(= % s) x)) x s)\n\t((fn all [x s] (every? #(= % s) x)) y s)\n\t((fn all [x s] (every? #(= % s) x)) z s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 0) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 1) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 2) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn diagonaLeft [x y z] [(get x 0)(get y 1)(get z 2)]) x y z) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn diagonalRight [x y z] [(get x 2)(get y 1)(get z 0)]) x y z) s)\n\t))\n) m :x) :x\n\t\t((fn ticTacToeSymbol [m s]\n\t(let \n\t\t[\n\t\tx (get m 0)\n\t\ty (get m 1)\n\t\tz (get m 2)\n\t\t]\n\t\t\n\t(or\n\t((fn all [x s] (every? #(= % s) x)) x s)\n\t((fn all [x s] (every? #(= % s) x)) y s)\n\t((fn all [x s] (every? #(= % s) x)) z s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 0) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 1) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn column [x y z n] [(get x n)(get y n)(get z n)]) x y z 2) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn diagonalLeft [x y z] [(get x 0)(get y 1)(get z 2)]) x y z) s)\n\t((fn all [x s] (every? #(= % s) x)) ((fn diagonalRight [x y z] [(get x 2)(get y 1)(get z 0)]) x y z) s)\n\t))\n) m :o) :o\n\t\t:else nil\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(let [win {[:x :x :x] :x [:o :o :o] :o}]\r\n    (fn [rows]\r\n      (or\r\n       (some win rows)\r\n       (some win (map vector (rows 0) (rows 1) (rows 2)))\r\n       (win (map #(get-in rows [% %]) (range 3)))\r\n       (win (map #(get-in rows [(- 2 %) %]) (range 3))))))","problem":73,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn [input-grid0]\n(let [zoom (flatten \n[[   2   4   8 ]\n [  16  32  64 ]\n [ 128 256 512 ]])\n      win [(+ 2 4 8) (+ 16 32 64) (+ 128 256 512) (+ 2 32 512) (+ 8 32 128) (+ 2 16 128) (+ 4 32 256) (+ 8 64 512) ]\n      input-grid (flatten input-grid0)]\n  \n  (some identity (for [[k v] (apply merge-with + (for [[k v] (map vector input-grid zoom)] {k v}))]\n     (when (and (not= :e k) (some (partial (fn is-win [x y] (= (bit-and x y) y)) v) win)) k)))\n  )\n)","problem":73,"user":"5032548ee4b0e78df07b092a"},{"problem":73,"code":"(fn [colls]\n  (let [vs (flatten colls)\n        ps [[0 1 2] [0 3 6] [0 4 8] [1 4 7] [2 4 6] [2 5 8] [3 4 5] [6 7 8]]\n        cs (reduce (fn [a x] (conj a (map #(nth vs %) x))) [] ps)\n        rs (filter (fn [[a b c]] (and (= a b c) (not (= :e a)))) cs)]\n    (if-not (empty? rs)\n      (-> rs first first)\n      nil)))","user":"606a70a5e4b069485764ddf2"},{"problem":73,"code":"(fn f1 [c]\n  (let [c (vec (flatten c))\n        l [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n    (loop [[af & ar] l]\n      (when-not (nil? af)\n        (condp #(apply = %1 %2) (replace c af)\n          :x :x\n          :o :o\n          (recur ar))))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [matrix]\n  (let [[[r1c1 r1c2 r1c3]\n         [r2c1 r2c2 r2c3]\n         [r3c1 r3c2 r3c3]] matrix]\n    (first\n     (first\n      (filter #(= (count %) 1)\n              (filter #(not (contains? % :e))\n                      (map set [[r1c1 r1c2 r1c3]\n                                [r2c1 r2c2 r2c3]\n                                [r3c1 r3c2 r3c3]\n                                [r1c1 r2c1 r3c1]\n                                [r1c2 r2c2 r3c2]\n                                [r1c3 r2c3 r3c3]\n                                [r1c1 r2c2 r3c3]\n                                [r1c3 r2c2 r3c1]])))))))","problem":73,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [R A M b]\n  (some #(and (A = %) (#{:x :o} (first %)))\n        ` (~@ b \n          ~@ (A M list b) \n          ~ (M #(%2 %) R b) \n          ~(M #(%2 (- 2 %)) R b)))) \n[0 1 2] apply map","problem":73,"user":"51e58e02e4b0efabf93c02d0"},{"problem":73,"code":"(fn [b]\n  (let [f first\n        s second\n        l last\n        p partial\n        m map\n        a (concat b [(m f b)\n                     (m s b)\n                     (m l b)\n                     [(-> b f f)\n                      (-> b s s)\n                      (-> b l l)]\n                     [(-> b f l)\n                      (-> b s s)\n                      (-> b l f)]])\n        r (->> a\n               (m set)\n               (filter #(= 1 (count %)))\n               (f)\n               (set))]\n    (or (:x r) (:o r))))","user":"5742ec91e4b05c31a32c0883"},{"problem":73,"code":"(fn [board]\n  (let [fboard (flatten board)\n        msquare [2 7 6 9 5 1 4 3 8]\n        combined (map vector fboard msquare)\n        zip-sum (fn [symb]\n                  (->> combined (filter #(= symb (first %))) (reduce #(+ %1 (second %2)) 0)))\n        x-sum (zip-sum :x)\n        y-sum (zip-sum :o)\n        ]\n          (cond (= x-sum 15) :x\n                (= y-sum 15) :o\n                :else nil)\n    )\n  )","user":"5bc935bde4b07a9b28b100d8"},{"problem":73,"code":"(fn [board]\n  (let [diagonals (vector\n          (map get board (range 3))\n          (map get board (reverse (range 3))))\n        rows board\n        columns (apply mapv vector board)]\n        (some {[:x :x :x] :x, [:o :o :o ] :o} (concat diagonals rows columns))))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn [board]                                                                                                                                                   \n  (letfn [(point [[x y]] (nth (nth board y) x))]                                                                                                              \n    (let [diags [(map point [[0 0] [1 1] [2 2]])                                                                                                              \n                 (map point [[0 2] [1 1] [2 0]])]                                                                                                             \n          rows board                                                                                                                                          \n          cols (apply map vector board)                                                                                                                       \n          runs (concat rows,cols,diags)                                                                                                                       \n          ]                                                                                                                                                   \n      (cond                                                                                                                                                   \n          (some (partial = [:x :x :x]) runs) :x                                                                                                               \n          (some (partial = [:o :o :o]) runs) :o                                                                                                               \n          :else nil))))","problem":73,"user":"510c1dd5e4b078ea71921113"},{"problem":73,"code":"(fn [s] (let [x (filter #(if (and (= (nth % 0) (nth % 1) (nth % 2)) (not= (nth % 0) :e) ) % nil) s) \n\t          y (filter #(if (and (= (nth % 0) (nth % 1) (nth % 2)) (not= (nth % 0) :e) ) % nil) (apply map vector s)) ] \n\t     (if ((comp not empty?) x)  (nth (nth x 0) 0) \n\t         (if ((comp not empty?) y) (nth (nth y 0) 0)\n\t           (if (and(or (= (nth (nth s 0) 0) (nth (nth s 1) 1) (nth (nth s 2) 2) ) \n                           (= (nth (nth s 0) 2) (nth (nth s 1) 1) (nth (nth s 2) 0)) )\n                       (not=(nth (nth s 1) 1) :e)) (nth (nth s 1) 1) nil  ) ) )))","user":"53b3ea79e4b047364c0444ab"},{"problem":73,"code":"(fn who-won [board]\n  (let [rows board\n        cols (apply map vector board)\n        sz (count board)\n        diags (list (map #(get (get board %) %) (range sz)) (map #(get (get board %) (- (dec sz) %)) (range sz)))\n        all-same (fn [colls]\n                   (first \n                    (filter\n                     (fn [coll] \n                      (and \n                       (not= (first coll) :e) \n                       (every? #(= (first coll) %) coll)\n                       )) \n                      colls)\n                     )\n                  )\n        ]\n    (first (concat (all-same board) (all-same cols) (all-same diags))\n    )\n  ))","user":"5245e320e4b09dbe66b56177"},{"problem":73,"code":"(fn [board]\n  (let [lines (-> (into board (apply mapv vector board))\n                  ((fn [new-board] (into new-board (mapv (partial mapv #(nth % %2) board)\n                                                        [(range (count board))\n                                                         (range (dec (count board)) -1 -1)])))))\n        check-for-winner (fn [x] (fn [line] (when (every? #{x} line) x)))]\n    (some (fn [line]\n            (or ((check-for-winner :x) line)\n                ((check-for-winner :o) line)))\n          lines)))","user":"5512aca6e4b055c2f668d4b4"},{"problem":73,"code":"(fn [[[a d g] [b e h] [c f i]]]\n    (some #(first\n            ((set (partition 3 \n                 [a d g\n                  b e h\n                  c f i\n                  a b c\n                  d e f\n                  g h i\n                  a e i\n                  g e c]))\n                [% % %]))\n          [:x :o]))","user":"55be39f9e4b01b9910ae2a06"},{"problem":73,"code":"(fn tictactoe [grid]\n  (let [row1 (first grid)\n        row2 (second grid)\n        row3 (last grid)\n        col1 (vector (first row1) (first row2) (first row3))\n        col2 (vector (second row1) (second row2) (second row3))\n        col3 (vector (last row1) (last row2) (last row3))\n        diag1 (vector (first row1) (second row2) (last row3))\n        diag2 (vector (first row3) (second row2) (last row1))\n        x [:x :x :x]\n        o [:o :o :o]]\n    (cond\n      (or (= row1 x) (= row2 x) (= row3 x)\n          (= col1 x) (= col2 x) (= col3 x)\n          (= diag1 x) (= diag2 x)) :x\n      (or (= row1 o) (= row2 o) (= row3 o)\n          (= col1 o) (= col2 o) (= col3 o)\n          (= diag1 o) (= diag2 o)) :o\n      :else nil)))","user":"5b02a170e4b0cc2b61a3bd52"},{"problem":73,"code":"(fn [board]\n  (let [winning-positions\n        [(fn [[[a _ _]\n               [b _ _]\n               [c _ _]]]\n           [a b c])\n         (fn [[[_ a _]\n               [_ b _]\n               [_ c _]]]\n           [a b c])\n         (fn [[[_ _ a]\n               [_ _ b]\n               [_ _ c]]]\n           [a b c])\n         (fn [[[a b c]\n               [_ _ _]\n               [_ _ _]]]\n           [a b c])\n         (fn [[[_ _ _]\n               [a b c]\n               [_ _ _]]]\n           [a b c])\n         (fn [[[_ _ _]\n               [_ _ _]\n               [a b c]]]\n           [a b c])\n         (fn [[[a _ _]\n               [_ b _]\n               [_ _ c]]]\n           [a b c])\n         (fn [[[_ _ a]\n               [_ b _]\n               [c _ _]]]\n           [a b c])]\n        won? (fn [mark]\n               (some #(if (apply = mark (% board))\n                       mark)\n                     winning-positions))]\n    (some won? [:x :o])))","user":"5353afa0e4b084c2834f4b03"},{"problem":73,"code":"(fn [tbl]\n  (loop [ll `(~(map #(get-in tbl %) [[0 0] [1 1] [2 2]])\n              ~(map #(get-in tbl %) [[2 0] [1 1] [0 2]])\n              ~@tbl\n              ~@(apply map vector tbl))]\n    (cond\n      (empty? ll) nil\n      (and (not= (ffirst ll) :e) (apply = (first ll))) (do (print ll) (ffirst ll))\n      :else (recur (rest ll)))))","user":"52c25645e4b07a9af579237d"},{"problem":73,"code":"(fn [b]\n  (let [i [[0 1 2] [3 4 5] [6 7 8]\n           [0 3 6] [1 4 7] [2 5 8]\n           [0 4 8] [2 4 6]]\n        c (apply concat b)\n        d (map (fn [x]\n                 (when (apply = (map #(nth c %) x))\n                   (nth c (x 0))))\n               i)]\n    (some #{:x :o} d)))","user":"55201d18e4b08d5046aa8a5d"},{"code":"(fn [tbl]\n  (letfn [(winner [[x1 x2 x3]]\n            (cond (= :o x1 x2 x3) :o\n                  (= :x x1 x2 x3) :x\n                  :else nil))\n          (third [[_ _ x]]\n            x)]\n    (or (winner (first tbl))\n        (winner (second tbl))\n        (winner (third tbl))\n        (winner (map first tbl))\n        (winner (map second tbl))\n        (winner (map third tbl))\n        (winner [(get-in tbl [0 0])\n                 (get-in tbl [1 1])\n                 (get-in tbl [2 2])])\n        (winner [(get-in tbl [0 2])\n                 (get-in tbl [1 1])\n                 (get-in tbl [2 0])]))))","problem":73,"user":"52487654e4b05ef8e38e63dc"},{"problem":73,"code":"(fn [d] \n  ( let [brd (concat d (apply map vector d)\n                         [(map get d [0 1 2])] [(map get d [2 1 0])])]\n   (first(first(filter #(and ((complement contains?) % :e) ( = 1 (count %))) (map set brd)))\n         )))","user":"55896a0ce4b059ccff29b204"},{"code":"(fn [b]\r\n  (let [v (reduce #(into %1 %2) b)\r\n\t      m (take-nth 3 v)\r\n\t      n (take-nth 3 (rest v))\r\n\t      o (take-nth 3 (rest (rest v)))\r\n\t      q (take-nth 4 v)\r\n\t      r (drop-last (take-nth 2 (rest (rest v))))\r\n\t      \r\n\t      u (map (fn [a] (reduce #(if (= %1 %2) %1 :e) a)) (into b [m n o q r]))\r\n\t      \r\n\t      v (into #{} u)]\r\n\t      \r\n\t      (if (= (v :x) :x)\r\n\t\t    :x\r\n\t\t    (v :o))))","problem":73,"user":"4e821ca5535db62dc21a62c2"},{"problem":73,"code":"(fn [[[a1 a2 a3][b1 b2 b3][c1 c2 c3]]]\n   (let [winlines [\n                   [a1 a2 a3] [b1 b2 b3] [c1 c2 c3] \n                   [a1 b1 c1] [a2 b2 c2] [a3 b3 c3] \n                   [a1 b2 c3] [a3 b2 c1]] ] \n     (first(first(filter (fn [line] (and (#{:x :o} (first line)) (every? #(= (first line) %) line))) winlines))))\n   )","user":"55f2c898e4b06e875b46ce4b"},{"problem":73,"code":"(fn [input]\n    (let [at #(nth (nth input %1) %2)\n          wins (fn [table k]\n                 (or\n                   (some (fn [row] (every? #(= k (at row %)) (range 3))) (range 3))\n                   (some (fn [col] (every? #(= k (at % col)) (range 3))) (range 3))\n                   (every? #(= k (at % %)) (range 3))\n                   (every? #(= k (at % (- 2 %))) (range 3))\n                   )\n                 )\n          ]\n      (some #(if (wins input %) %) '(:x :o))\n      ))","user":"529e8ba9e4b04e0c58e87b99"},{"problem":73,"code":"(fn tic-tac-toe [[r1 r2 r3 :as rows]]\n  (let [getCol (fn [n]\n                 (map #(nth % n) rows))\n        full-set (fn [col]\n                   (cond (every? (partial = :o) col) :o\n                         (every? (partial = :x) col) :x\n                         :else nil))\n        cols (map getCol (range 3))\n        diags [[(r1 0) (r2 1) (r3 2)] [(r1 2) (r2 1) (r3 0)]]\n        all (concat rows cols diags)]\n    (->> all\n         (map full-set)\n         (filter (comp not nil?))\n         first)))","user":"5396c94be4b0b51d73faaee3"},{"code":"(fn tictactoe [board]\n  (letfn [\n          (all-x-or-o [vec]\n            (let [[fst snd trd] vec]\n              (cond\n                (= fst snd trd :x) :x\n                (= fst snd trd :o) :o\n                :else nil)\n            )\n          )\n          (all-rows [b]\n            (let [top-left (ffirst board)\n                  middle (second (second board))\n                  bottom-left (first (last board))\n                  top-right (last (first board))\n                  bottom-right (last (last board))]\n              (concat b (apply map vector b) [[top-left middle bottom-right] [bottom-left middle top-right]])   \n            )\n          )]\n    (some all-x-or-o (all-rows board))\n  )\n)","problem":73,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":73,"code":"(fn [b] \n(let [check-rows (fn [[r1 r2 r3]]\n                   (let [diag [(first r1) \n                               (second r2) \n                               (last r3)]]\n                     (map (fn [[i1 i2 i3]] \n                            (if (= i1 i2 i3) i1 :e))\n                            [r1 r2 r3 diag])))\n      rotate (fn [[r1 r2 r3]] \n               (map #(vector %3 %2 %1) r1 r2 r3))\n \n      board b \n      res-horiz (check-rows board)\n      res-vert (check-rows (rotate board))\n      res (concat res-horiz res-vert)\n      f-res (filter #(not (= :e %)) res)]\n ; (prn res)\n ; (prn f-res)\n  (condp #(%1 %2 1) (count f-res)\n   > \"illegal state\"\n   < nil\n   = (first f-res))))\n ;;[[:e :e :e] [:o :x :o] [:o :o :o]] )","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn [game]\n  (let\n      [column (fn [game n]\n                (map #(nth % n) game))\n\n       test-row (fn [row]\n                  (if (= 1 (count (set row)))\n                    (first row)))\n\n       diagonal (fn [game rng]\n                  (map #(nth %1 %2) game rng))]\n    (some #(cond (= :x %) :x\n                 (= :o %) :o)\n          (flatten\n           (list\n            ;; test columns\n            (map #(test-row (column game %)) (range 3))\n            ;; test rows\n            (map test-row game)\n            ;; test top-left to bottom-right\n            (test-row (diagonal game (range 3)))\n            ;; test top-right to bottom-left\n            (test-row (diagonal game (range 2 -1 -1))))))))","problem":73,"user":"51fa90aae4b0f1313d4689e0"},{"problem":73,"code":"(fn [m]\n  (let [ps (vec (flatten m))]\n    (first (for [pt [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n          :let [v (set (map #(ps %) pt)) fv (first v)]\n          :when (= 1 (count v))\n          :when (not= :e fv)]\n      fv\n      ))\n    )\n  )","user":"53ae16e2e4b047364c044472"},{"problem":73,"code":"(fn [board]\n  (let [horizontal (map identity board)\n        vertical (partition 3 (for [x (range (count board)) c board] (nth c x)))\n        diag1 (for [x (range (count board))] (nth (nth board x) x))\n        diag2 (for [x (range (count board))] (nth (reverse (nth board x)) x))\n        triples (concat horizontal vertical [diag1] [diag2])]\n    (if-let [v\n             (first (filter\n                     #(and (every? (fn [n] (= n (first %)) ) %)(not= (first %) :e))\n                     triples))]\n      (first  v)\n    )\n  ))","user":"564a560ae4b0284900eef654"},{"problem":73,"code":"(fn [board]\n  (let [lines-coordinates [[[0 0] [1 0] [2 0]]\n                           [[0 1] [1 1] [2 1]]\n                           [[0 2] [1 2] [2 2]]\n                           [[0 0] [0 1] [0 2]]\n                           [[1 0] [1 1] [1 2]]\n                           [[2 0] [2 1] [2 2]]\n                           [[0 0] [1 1] [2 2]]\n                           [[2 0] [1 1] [0 2]]]\n        line-val          (fn [board line-coordinates]\n                            (let [vals (map #(get-in board %) line-coordinates)]\n                              (cond (every? #(= % :x) vals) :x\n                                    (every? #(= % :o) vals) :o\n                                    :else nil)))]\n    (some #{:x :o}\n          (map #(line-val board %)\n               lines-coordinates))))","user":"55586905e4b0deb715856e2b"},{"problem":73,"code":"(fn [board]\n    (let [coords (vec (for [y (range 3) x (range 3)] [x y]))\n          h (partition 3 coords)\n          v (apply map vector h)\n          d1 (map coords [0 4 8])\n          d2 (map coords [2 4 6])\n          lines (concat h v (vector d1 d2))\n          runs (filter #(apply = %) (map #(map (partial get-in board) %) lines))\n          results (remove (partial = :e) (map first runs))]\n      (if (= 1 (count results)) (first results) nil)))","user":"53c649d3e4b00fb29b221297"},{"code":"(letfn [(row-match [sym row]\r\n          (every? #(= sym %) row))\r\n        (diag1 [b]\r\n          [((b 0) 0) ((b 1) 1) ((b 2) 2)])\r\n        (diag2 [b]\r\n          [((b 0) 2) ((b 1) 1) ((b 2) 0)])\r\n        (transpose [b]\r\n          (vec (apply map vector b)))]\r\n  (fn [b]\r\n    (cond\r\n      (some identity (map #(row-match :x %) b)) :x\r\n      (some identity (map #(row-match :o %) b)) :o\r\n      (some identity (map #(row-match :x %) (transpose b))) :x\r\n      (some identity (map #(row-match :o %) (transpose b))) :o\r\n      (row-match :x (diag1 b)) :x\r\n      (row-match :o (diag1 b)) :o\r\n      (row-match :x (diag2 b)) :x\r\n      (row-match :o (diag2 b)) :o\r\n      :else nil)))","problem":73,"user":"4ddbfb8a535d02782fcbea00"},{"problem":73,"code":"(fn [board]\n  (let [winning-row? (fn [row] (and (apply = row) (#{:o :x} (first row))))\n        rotate (partial apply map vector)\n        diagonal (fn [board]\n                   (loop [lines (apply concat board)\n                          acc []]\n                     (if (seq lines)\n                       (recur (drop 4 lines) (conj acc (first lines)))\n                       [acc])))]\n    (->> (concat board\n                 (rotate board)\n                 (diagonal board)\n                 (diagonal (map reverse board)))\n         (some winning-row?))))","user":"50310713e4b05b7df5a0b84c"},{"code":"(fn check [ [[a b c]\n               [d e f]\n               [g h i] :as board] ]\n  (let [row (fn [[x y z]] (and (not= x :e) (= x y z) x))]\n    (or (some row board)\n        (some row (apply map list board))\n        (row [a e i])\n        (row [c e g])\n        nil)))","problem":73,"user":"511aa2a4e4b0c87c59c9670a"},{"code":"(fn [board]\n  (letfn [(win [[[a b c] [d e f] [g h i]] p]\n            (or (= p a b c)\n              (= p d e f)\n              (= p g h i)\n              (= p a d g)\n              (= p b e h)\n              (= p c f i)\n              (= p a e i)\n              (= p c e g)))]\n    (cond\n      (win board :x) :x\n      (win board :o) :o\n      :else nil)))","problem":73,"user":"527cd633e4b0757a1b17136f"},{"problem":73,"code":"(fn str-board [b]\n    (let [s \\|, [[b00 b01 b02] [b10 b11 b12] [b20 b21 b22]] b \n          bext (conj []  [b00 b01 b02 s] [b10 b11 b12 s] [b20 b21 b22 s] ;; rows\n                         [b00 b10 b20 s] [b01 b11 b21 s] [b20 b12 b22 s] ;; cols\n                         [b00 b11 b22 s] [b02 b11 b20 s]) ;; diagonals\n          bestr (apply str (replace {:e \\e, :x \\x, :o \\o} (reduce concat bext))) ]\n          (cond\n             (re-find #\"xxx\" bestr) :x\n             (re-find #\"ooo\" bestr) :o\n              :else nil\n           )))","user":"56fa2905e4b07572ad1a88be"},{"code":"(fn [[l1 l2 l3]]\n  (first\n    (filter \n      (partial contains? #{:o :x})\n      (map \n        (partial reduce #(if (and (= %1 %2) (not= %1 :e)) %1 nil))\n        (concat \n          [l1 l2 l3] \n          [[(first l1) (second l2) (last l3)]\n          [(last l1) (second l2) (first l3)]]\n          (apply map list [l1 l2 l3]))))))","problem":73,"user":"5034b0e1e4b062bc5d7ae167"},{"code":"(fn [m]\n  (first\n    (some #{[:x :x :x]\n            [:o :o :o]}\n          (map #(map (vec (flatten m)) %)\n               (partition 3 [0 1 2, 0 3 6, 0 4 8\n                             3 4 5, 1 4 7, 2 4 6\n                             6 7 8, 2 5 8])))))","problem":73,"user":"4f9d8083e4b0dcca54ed6d23"},{"problem":73,"code":"(fn [board] (let [all-lines (concat board                   ; board, by definition, has all the horizontal lines\n                                    (apply map list board)  ; generate the vertical lines\n                                    [(map #(-> board (nth %) (nth %)) (range 3)) ; generate the top-left to bottom-right diagonal\n                                     (map #(-> board (nth %) (nth (- 2 %))) (range 3))])] ; generate the top-rigth to bottom left diagonal\n              (ffirst (filter (fn [args] (and (apply = args) (not= (first args) :e))) all-lines))))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn\n  [board]\n  (let [[topr middler bottomr] board;top, middle, bottom row\n        lrd [(topr 0) (middler 1) (bottomr 2)]; left-right diagonal\n        rld [(topr 2) (middler 1) (bottomr 0)];right-left diagonal\n        lc [(topr 0) (middler 0) (bottomr 0)]; left column\n        mc [(topr 1) (middler 1) (bottomr 1)]; middle column\n        rc [(topr 2) (middler 2) (bottomr 2)]; right column\n        allrows [topr middler bottomr lrd rld lc mc rc]; combined\n        ]\n    \n    (let [results (for [symbol [:x :o]]\n                    (for [row allrows]\n                      (->> row (filter #(= % symbol)) (count))))]\n      (cond\n       (some #(= % 3) (first results)) :x\n       (some #(= % 3) (last results)) :o\n       true  nil))))","problem":73,"user":"4eddc5f4535d10e5ff6f532c"},{"code":"(fn [t]\n    (->> (concat (map identity t)       ; row\n                 (apply map vector t)   ; col\n                 [(map #(get-in t %) [[0 0] [1 1] [2 2]])\n                  (map #(get-in t %) [[0 2] [1 1] [2 0]])])\n         (map (partial reduce #(if (= %1 %2) %1 nil)))\n         (some #{:x :o})))","problem":73,"user":"52d6a9c2e4b09f7907dd1365"},{"problem":73,"code":"(fn [m] \n  (let [[x y z] m\n        [a b c] (map concat m (map #(vector % %2 %3) x y z))\n        [a1 _ a3] x\n        [_ b2] y\n        [c1 _ c3] z\n        a (conj a a1 a3)\n\t\tb (conj b b2 b2)\n        c (conj c c3 c1)  \n        win (reduce #(if (or (= :e %2) (nil? %2)) % %2) nil \n\t\t\t\t    (map #(when (= % %2 %3) %) a b c))]\n    (when (not= nil win) win) \n))","user":"5654d0e1e4b0f9d632dd848c"},{"problem":73,"code":"(fn dd [data]\n  (let [a1 [[0 0] [1 1] [2 2]]\n        a2 [[0 2] [1 1] [2 0]]\n        a3 [[0 0] [0 1] [0 2]]\n        a4 [[1 0] [1 1] [1 2]]\n        a5 [[2 0] [2 1] [2 2]]\n        a6 [[0 0] [1 0] [2 0]]\n        a7 [[0 1] [1 1] [2 1]]\n        a8 [[0 2] [1 2] [2 2]]\n        d (map (fn [c]\n                 (map #(get-in data %) c))\n               [a1 a2 a3 a4 a5 a6 a7 a8])]\n    (reduce (fn [a b] (or a b))\n            (map\n             (fn [dd]\n               (condp every? dd\n                 #(= :x %) :x\n                 #(= :o %) :o\n                 nil))\n             d))))","user":"54a11042e4b09f271ff37c49"},{"problem":73,"code":"(fn analyze-board [board]\n  (let [diagonal (fn [board rev]\n                   (let [[v1 v2 v3] board]\n                     (if rev\n                       (vector (first v3) (second v2) (second (rest v1)))\n                       (vector (first v1) (second v2) (second (rest v3)))\n                       )))\n        interleave-board (partition 3 (interleave (first board) (second board) (last board)))\n        same? (fn [row] (if (and (apply = row) (not (= :e (first row)))) (first row) false))\n        ]\n       (cond\n         (same? (diagonal board false)) (first (first board))\n         (same? (diagonal board true)) (first (last board))\n         (same? (first board)) (first (first board))\n         (same? (second board)) (first (second board))\n         (same? (last board)) (first (last board))\n         (same? (first interleave-board)) (first (first interleave-board))\n         (same? (second interleave-board)) (first (second interleave-board))\n         (same? (last interleave-board)) (first (last interleave-board))\n         )\n    )\n  )","user":"5e348945e4b0650de70e2b1d"},{"problem":73,"code":"(fn [v]\n  (last (first\n    (drop-while\n      #(or (apply = :e %) (apply not= %))\n        (conj (concat v (apply mapv vector v))\n              (mapv nth v (range))\n              (mapv #(nth (reverse %1) %2) v (range)))))))","user":"56cd44fde4b0ea9b8538f749"},{"code":"(fn [board]\n    (letfn [(cols [board] (map (fn [a b c] [a b c]) (first board) (second board) (nth board 2)))\n            (diag [board dir] [(map (fn [a] (nth (nth board (if (= dir :f) (- 2 a) a)) a)) (range 3))])]\n      (let [all-runs (concat board (cols board) (diag board :f) (diag board :b))\n            r (some #(if (apply = %) (first %)) all-runs)]\n        (if (= r :e) nil r))))","problem":73,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn tic-tac-toe [board]\n  (let [array (to-array-2d board)\n        size (count board)\n        rng (range size)\n        rows (map (fn [i] (map (fn [j] (aget array i j)) rng)) rng)\n        colls (map (fn [j] (map (fn [i] (aget array i j)) rng)) rng)\n        diags [(map (fn[i] (aget array i i)) rng) (map (fn[i] (aget array i (- size (inc i)))) rng)]\n        checks (concat rows colls diags)\n        winner? (fn [check] (when (and (not-any? #(= :e %) check) (apply = check)) (first check)))]\n    (some winner? checks)))","problem":73,"user":"51729002e4b044b2ef48a850"},{"problem":73,"code":"#(let [winner\n           (some\n             #{[:x :x :x] [:o :o :o]}\n             (lazy-cat\n               %\n               (partition 3 (apply interleave %))\n               [[(first (first %)) (second (second %)) (last (last %))]\n                [(last (first %)) (second (second %)) (first (last %))]]))]\n   (if winner\n     (first winner)))","user":"5e41b679e4b01d43a70e8e58"},{"problem":73,"code":"(fn check-ttt [b]\n  (letfn [(hwin [b]\n            (loop [b b]\n              (if (and b)\n                (let [player (first (first b))]\n                  (if (and (not= player :e) (= (count (set (first b))) 1))\n                    player\n                    (recur (next b)))))))\n\n          (vwin [b]\n            (loop [i 0]\n              (if (> i 2)\n                nil\n                (let [col (apply concat (partition 1 3 (drop i (apply concat b))))]\n                  (if (and (not= (first col) :e) (= (count (set col)) 1))\n                    (first col)\n                    (recur (inc i)))))))\n\n          (dwin [[[x1 __ x2]\n                       [__ x3 __]\n                       [x4 __ x5]]]\n            (cond\n              (and (not= :e x1) (= x1 x3 x5)) x1\n              (and (not= :e x2) (= x2 x3 x4)) x2\n              :else nil))\n          ]\n    (or (vwin b)\n        (hwin b)\n        (dwin b))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":73,"code":"(fn [board]\n   (->> (concat board\n           (apply map list board)\n           (map #(map (partial get-in board) %) [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]))\n        (filter (partial apply =))\n        (remove (partial = [:e :e :e]))\n        (ffirst)))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn [b]\n  (let [w {[:x :x :x] :x\n           [:o :o :o] :o}]\n    (or (some w b)\n        (some w (apply (partial map vector) b))\n        (some w [[((b 0) 0) ((b 1) 1) ((b 2) 2)]\n                 [((b 0) 2) ((b 1) 1) ((b 2) 0)]]))))","problem":73,"user":"4e7dd982535db169f9c796ee"},{"problem":73,"code":"(fn win?\n        [m]\n        (let [row-winner (fn [row] (cond\n                                     (= #{:x} (set row)) :x\n                                     (= #{:o} (set row)) :o\n                                     :else nil))\n              transpose (fn [m] (apply mapv vector m))\n              diagonal-1 (map (partial get-in m) [[0 0] [1 1] [2 2]])\n              diagonal-2 (map (partial get-in m) [[0 2] [1 1] [2 0]])\n              winner (partial keep row-winner)\n              winners (mapv winner [m (transpose m) [diagonal-1] [diagonal-2]])\n              results (filter #(not= '() %) winners)]\n          (first (mapv #(when (seq %) (nth % 0) ) results))))","user":"4ea5ba92535d7eef308072d9"},{"problem":73,"code":"(fn [board]\n  (let [b (map\n            (fn [p] (map #(cond (= % :e) 0\n                                (= % :x) 1\n                                (= % :o) -1)\n                         p))\n            board)\n        naname (fn [x]\n                 (loop [x x s 0 i 0]\n                   (if (empty? x)\n                     s\n                     (recur (rest x) (+ s (nth (first x ) i)) (+ 1 i)))))\n        naname2 (fn [x]\n                 (loop [x x s 0 i 0]\n                   (if (empty? x)\n                     s\n                     (recur (rest x) (+ s (nth (first x ) (- 2 i))) (+ 1 i)))))\n        c (fn [x] (cond (some #(= % 3) x) :x\n                        (some #(= % -3 )x) :o\n                        :else nil))]\n    (c (concat\n         (list (naname b))\n         (list (naname2 b))\n         (map #(reduce + %) b)\n         (map #(+ %1 %2 %3)\n              (nth b 0)\n              (nth b 1)\n              (nth b 2))))))","user":"53664e3be4b0243289761e74"},{"code":"(fn [t]\n  (first\n   (keep (fn [s]\n           (let [f (fn [r] (filter #{s} r))]\n             (cond \n              (some #{3} (map count (map f t))) s\n              (some #{3} (map count (map f (apply map vector t)))) s\n              (= 3 (count (f (map #(get-in t [% %]) [0 1 2])))) s\n              (= 3 (count (f (map #(get-in (vec (map (fn [b] (vec (reverse b))) t)) [% %]) [0 1 2])))) s))) [:o :x])))","problem":73,"user":"4e5867d1535d8a8b8723a291"},{"code":"(fn [x]\n  (let [check-win (fn [[a :as xs]] \n                    (if (and \n                          (not= :e a) \n                          (apply = xs)) xs []))]\n    (first \n      (first\n      (filter seq\n        [(check-win (map first x))\n         (check-win (map second x))\n         (check-win (map last x))\n         (check-win (first x))\n         (check-win (second x))\n         (check-win (last x))\n         (check-win (map #(%1 %2) [first second last] x))\n         (check-win (map #(%1 %2) [last second first] x))])))))","problem":73,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn tictactoe [board]\n   (letfn [(winner [[a b c]] (if (and (not (= a :e)) (= a b c)) a))\n           (cell-at [[x y]] (nth (nth board x) y))]\n     (or (some winner board)\n         (some winner (apply map list board))\n         (winner (map cell-at [[0 0] [1 1] [2 2]]))\n         (winner (map cell-at [[0 2] [1 1] [2 0]])))))","problem":73,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [[r0 r1 r2]]\n  (let [paths [[[r0 0] [r0 1] [r0 2]]\n               [[r0 0] [r1 1] [r2 2]]\n               [[r1 0] [r1 1] [r1 2]]\n               [[r0 0] [r1 0] [r2 0]]\n               [[r0 1] [r1 1] [r2 1]]\n               [[r0 2] [r1 2] [r2 2]]\n               [[r2 0] [r2 1] [r2 2]]\n               [[r2 0] [r1 1] [r0 2]]]]\n    (loop [[path & tail] paths]\n      (let [res (map (fn [[f i]] (f i)) path)]\n        (cond \n          (every? #{:x} res) :x\n          (every? #{:o} res) :o\n          (seq tail) (recur tail))))))","problem":73,"user":"4f21838fe4b0d66497709fd2"},{"code":"(fn [board] \n  (let [wins \n  [[1 1 1 0 0 0 0 0 0]\n   [0 0 0 1 1 1 0 0 0]\n   [0 0 0 0 0 0 1 1 1]\n   [1 0 0 1 0 0 1 0 0]\n   [0 1 0 0 1 0 0 1 0]\n   [0 0 1 0 0 1 0 0 1]\n   [1 0 0 0 1 0 0 0 1]\n   [0 0 1 0 1 0 1 0 0]]\n  pred (fn [side] (fn [[a b]] (and (= a side) (= b 1))))\n  win? (fn [side win-board] \n         (let [combined (map vector (flatten board) win-board)]\n           (= 3 (count (filter (pred side) combined)))))]\n  \t(cond \n     \t(some (partial win? :x) wins) :x\n     \t(some (partial win? :o) wins) :o\n     \t:else nil)))","problem":73,"user":"51990df9e4b068aa333628fc"},{"problem":73,"code":"(fn [b]                                                                                                                                                                                                                                                                  \n  (let [ts (filter #(not= [0 0] %) (for [x (range -1 2) y (range -1 2)] [x y]))                                                                                                                                                                                          \n        walk-path (fn [[x y] [tx ty]]                                                                                                                                                                                                                                    \n                    (for [i (range 3)]                                                                                                                                                                                                                                   \n                      (let [tx' (+ x (* i tx))                                                                                                                                                                                                                           \n                            ty' (+ y (* i ty))]                                                                                                                                                                                                                          \n                        (get (get b ty') tx'))))                                                                                                                                                                                                                         \n        all-paths (fn []                                                                                                                                                                                                                                                 \n                    (concat                                                                                                                                                                                                                                              \n                      (for [x (range 3)                                                                                                                                                                                                                                  \n                            y (range 3)                                                                                                                                                                                                                                  \n                            [tx ty] ts]                                                                                                                                                                                                                                  \n                        (walk-path [x y] [tx ty]))))                                                                                                                                                                                                                     \n        victor-paths (filter (fn [l] (every? #(= (first l) %) l)) (all-paths))                                                                                                                                                                                           \n        victors (map first victor-paths)                                                                                                                                                                                                                                 \n        non-empty-victors (filter #(not= :e %) victors)]                                                                                                                                                                                                                 \n    (first non-empty-victors)))","user":"5a012a43e4b01bb0ae8afd42"},{"problem":73,"code":"(fn whowon [board]\n  (let [rows (map #(get board %) (range 3))\n        cols (map (fn [ix] (map #(get-in board [% ix]) (range 3))) (range 3))\n        diag1 [(map #(get-in board %) [[0 0] [1 1] [2 2]])]\n        diag2 [(map #(get-in board %) [[2 0] [1 1] [0 2]])]]\n    (->>\n     (concat rows cols diag1 diag2)\n     (map frequencies)\n     (filter #(= (count %) 1))\n     (remove #(contains? % :e))\n     (first)\n     (#(cond (contains? % :x) :x\n             (contains? % :o) :o\n             :else nil)))))","user":"59be62d5e4b0a024fb6ae435"},{"code":"(fn [board]\n   (letfn [(agg-diag-tl-br\n              [board]\n              (map #(get-in board %) (for [index (range (count board))]\n              [index index])))\n           (agg-diag-bl-tr\n              [board]\n              (map #(get-in board %) (for [index (range (count board))]\n              [(- (count board) (+ index 1)) index])))\n           (agg-vertical\n              [board]\n              (apply interleave board))]\n     \n     (let [combinations (partition (count board) (flatten (conj board (agg-vertical board) (agg-diag-tl-br board) (agg-diag-bl-tr board))))]\n       (cond (some #(= [:o :o :o] %) combinations) :o\n             (some #(= [:x :x :x] %) combinations) :x\n             :else nil\n       )))\n)","problem":73,"user":"52fc34cee4b047fd55837015"},{"code":"(fn [board]\n(let [triples\n(fn [board]\n(map #(map (partial get-in board) %)\n(concat\n(for [x [0 1 2]]\n[[x 0] [x 1] [x 2]])\n(for [y [0 1 2]]\n[[0 y] [1 y] [2 y]])\n[[[0 0] [1 1] [2 2]]\n[[0 2] [1 1] [2 0]]])))]\n(ffirst (filter #(or (= [:o :o :o] %)\n(= [:x :x :x] %))\n(triples board)))))","problem":73,"user":"514f8926e4b0b449e54b8dfa"},{"problem":73,"code":"(fn [board]\n  (let [lines [[[0 0] [0 1] [0 2]] [[0 0] [1 0] [2 0]] [[0 0] [1 1] [2 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] [[2 0] [1 1] [0 2]]]]\n    (reduce #(if (and (not= (first %2) :e) (apply = %2)) (first %2) %1) nil (map (partial map #(get-in board %)) lines))))","user":"59ddae03e4b01968742fed65"},{"code":"(fn [b]\n  (let [rows (conj b\n               (map first b)\n               (map second b)\n               (map (comp first nnext) b)\n               (map #(get %1 %2) b (iterate inc 0))\n               (map #(get %1 %2) b (iterate dec 2)))\n        check #(some (partial every? %2) %1)]\n    (if (check rows #{:x})\n      :x\n      (when (check rows #{:o})\n        :o))))","problem":73,"user":"4dad51418e77d6ed55f12a44"},{"problem":73,"code":"(fn\n  [[[slot-1 slot-2 slot-3] [slot-4 slot-5 slot-6] [slot-7 slot-8 slot-9]]]\n  (cond\n    (and (not= slot-1 :e) (= slot-1 slot-2 slot-3)) slot-1\n    (and (not= slot-4 :e) (= slot-4 slot-5 slot-6)) slot-4\n    (and (not= slot-7 :e) (= slot-7 slot-8 slot-9)) slot-7\n    (and (not= slot-1 :e) (= slot-1 slot-5 slot-9)) slot-1\n    (and (not= slot-3 :e) (= slot-3 slot-5 slot-7)) slot-3\n    (and (not= slot-1 :e) (= slot-1 slot-4 slot-7)) slot-1\n    (and (not= slot-2 :e) (= slot-2 slot-5 slot-8)) slot-2\n    (and (not= slot-3 :e) (= slot-3 slot-6 slot-9)) slot-3\n    :else nil))","user":"5d8c8175e4b0915913b1d3e1"},{"code":"(fn [xs]\n   (let [x [:x :x :x] o [:o :o :o]\n    r (first (filter #(or (= x %) (= o %))\n     (concat xs\n             (apply map list xs)\n             (map (partial map #(nth %2 %) (range)) [xs (reverse xs)]))))]\n     (cond (= r x) :x (= r o) :o)))","problem":73,"user":"4f4f0287e4b03ad3f0c10cd7"},{"code":"(fn [b] \n  (let [p \n[[0 0 0 1 0 2]\n[1 0 1 1 1 2]\n[2 0 2 1 2 2]\n[0 0 1 0 2 0]\n[0 1 1 1 2 1]\n[0 2 1 2 2 2]\n[0 0 1 1 2 2]\n[0 2 1 1 2 0]],\n    tt\n(fn t [b e] (some #(every? (fn [[x y]] (= e ((b x) y))) (partition 2 %)) p))\n  ]    \n   (if (tt b :o) :o (if (tt b :x) :x nil))))","problem":73,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":73,"code":"(fn [board]\n  (let [[top middle bottom] board\n        left (into [] (map first board))\n        center (into [] (map #(nth % 1) board))\n        right (into [] (map last board))\n        diag1 (vector\n               (first top)\n               (nth middle 1)\n               (last bottom))\n        diag2 (vector (last top) (nth middle 1) (first bottom))\n        combos (vector top middle bottom left center right diag1 diag2)]\n    ((fn [x] (if (= x :e) nil x))\n      (first (first (filter #(apply = %) combos))))))","user":"516cdef4e4b06f078fab2527"},{"problem":73,"code":"(fn [board]\n  (reduce #(or %1\n               (if (and (apply = %2) (not= :e (first %2)))\n                 (first %2) nil))\n          nil\n          [(nth board 0)\n           (nth board 1)\n           (nth board 2)\n           (map #(nth % 0) board)\n           (map #(nth % 1) board)\n           (map #(nth % 2) board)\n           (reduce #(conj %1 (nth (nth board %2) %2)) [] (range 3))\n           (reduce #(conj %1 (nth (nth board %2) (- 2 %2))) [] (range 3))\n           ]))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn [board]\n    (let [good? (fn [p vecs] (some true? (map #(every? #{p} %) vecs)))\n          horiz? (fn [p] (good? p board))\n          verti? (fn [p] (let [cols (vec (for [i (range 3)]\n                                           [((board 0) i) ((board 1) i) ((board 2) i)]))]\n                           (good? p cols)))\n          diago? (fn [p]  (let [diags [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                                       [((board 0) 2) ((board 1) 1) ((board 2) 0)]]]\n                            (good? p diags)))\n          has-won? (fn [p] (or (horiz? p) (verti? p) (diago? p)))]\n      (cond\n       (has-won? :x) :x\n       (has-won? :o) :o\n       :else nil)))","problem":73,"user":"5154fa3fe4b0179c5115f4e6"},{"code":"#(some {[:o :o :o] :o [:x :x :x] :x} (partition 3 (map (vec (flatten %))\n           [0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6] )))","problem":73,"user":"51da5552e4b02ceefd947764"},{"code":"(fn [lns] (\n  let [cols (apply map list lns)\n       ds (map #(map nth lns %) [[0 1 2] [2 1 0]])\n       ws {[:x :x :x] :x [:o :o :o] :o}\n  ] (\n    some ws (concat lns cols ds)\n  )\n))","problem":73,"user":"4e7f4147535db966e863cc3d"},{"problem":73,"code":"(fn me [arg]\n\n  ;label each position\n  (let [  pos-rows   (map vector arg (range)) \n\n          m-fn (fn [row arg]\n\n                    (vector (second row) (second arg) (first arg))\n              )\n\n          poses      (for [row pos-rows] \n                            (map (partial m-fn row)   ( map vector (first row) (range) ))\n                     )    \n      \n          x-poses    (for [row poses]\n\n                        (map #(drop-last %) (filter #(= :x (last %)) row))\n                     )\n\n          o-poses    (for [row poses]\n                        (map #(drop-last %) (filter #(= :o (last %)) row))\n                    )\n\n          x-pposes  (partition 2 (flatten x-poses))\n\n          o-pposes  (partition 2 (flatten o-poses))\n\n          check-count (fn [arg]\n\n                        (>= (count arg) 3)\n                      )\n\n          check-ver-hor   (fn [f arg]\n\n                            (let [my-map (group-by f arg)]\n\n                            (or   (if ((complement nil?) (my-map 0)) (= 3 (count (my-map 0))) false)\n\n                                  (if ((complement nil?) (my-map 1)) (= 3 (count (my-map 1))) false)\n\n                                  (if ((complement nil?) (my-map 2)) (= 3 (count (my-map 2))) false)\n\n                            )\n                        )  \n                      )\n\n          check-diag  (fn [arg]\n\n                        (let [\n                                f-fn (fn [arg]\n\n                                     (or (and (= 1 (first arg)) (= 1 (second arg)) )\n                                         (= -2 (- (first arg) (second arg)))\n                                         (= 2  (- (first arg) (second arg)))\n                                     ) \n                                  )\n\n                             ]\n\n                             (or (= 3 (count (filter #(= (first %) (second %)) arg)))\n                                 (= 3 (count (filter f-fn arg)) )\n                             ) \n                          )\n                      )\n\n          winner (fn [arg]\n          \n              (if (check-count arg)\n                  (or (check-ver-hor first arg) (check-ver-hor second arg) (check-diag arg))\n                  false\n              )\n          )              \n\n       ]\n\n       \n       (if (and (nil? x-pposes)  (nil? o-pposes))  \n            nil\n\n            (cond\n               (winner x-pposes) :x\n               (winner o-pposes) :o\n               :else nil \n            )    \n       )\n\n  )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":73,"code":"(fn [m]\n  (let [size (count m)\n        fn-point (fn [[x y]] (-> m (get x) (get y)))\n        fn-match-row #(and (apply = (map fn-point %)) (case (fn-point (first %)) :x :x :o :o false))\n        xs (partition size (for [x (range size) y (range size)] [x y]))\n        ys (partition size (for [x (range size) y (range size)] [y x]))\n        d1 (partition size (for [x (reverse (range size))] [x x]))\n        d2 (partition size (for [x (reverse (range size))] [x (- (dec size) x)]))]\n     (some identity (map fn-match-row (concat xs ys d1 d2)))))","user":"530a6cbae4b02e82168697be"},{"code":"(fn [b]\n(let [b-flat (replace {:e nil} (flatten b))\n     to-check [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n \n(ffirst (remove nil?  \n  (for [i to-check]\n   (->> (map #(nth b-flat %) i)\n        frequencies\n        (filter #(= (second %) 3))\n        last))))))","problem":73,"user":"525c575be4b0cb4875a45d38"},{"code":"(fn [grid]\n     (letfn [(check-row [[a b c]] (and (= a b c) (#{ :x :o } a)))\n             (check [rows]\n                    (or (some check-row rows)\n                        (check-row (map #(get-in rows [% %]) (range 3)))))]\n            (or (check grid)\n                (check (vec (reverse (apply map vector grid))))\n                nil)))","problem":73,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":73,"code":"(fn [board]\n  (let [all (apply concat board)\n        ;; if only :x or :o, return it, else nil\n        get-if-only #(when (= (count %1) 1)\n                       (when (not= (first %1) :e)\n                         (first %1)))\n        get-chess #(get-if-only (set (keep-indexed (fn [i x]\n                                                     (when (%1 i) x))\n                                                   all)))\n        choosePosition [#{0 1 2} #{3 4 5} #{6 7 8}\n                        #{0 3 6} #{1 4 7} #{2 5 8}\n                        #{0 4 8} #{2 4 6}]]\n    (reduce #(or %1 %2) (map get-chess choosePosition))))","user":"60096aabe4b074f607df667f"},{"code":"(fn tictactoe [rows]\n  (let [columns (partition 3 (apply interleave rows))\n        diagonal1 [[(get (first rows) 0) (get (second rows) 1) (get (get rows 2) 2)]]\n        diagonal2 [[(get (first rows) 2) (get (second rows) 1) (get (get rows 2) 0)]]\n        all-sets (concat rows columns diagonal1 diagonal2)]\n    (if (some #(every? #{:x} %) all-sets)\n      :x\n      (if (some #(every? #{:o} %) all-sets)\n        :o\n        nil))))","problem":73,"user":"4dad76588e77d6ed63f12a44"},{"problem":73,"code":"(fn tic [t]\n  (letfn [(check [v] (partial = v))\n          (threerange [] (take 3 (range)))\n          (checkrow [v i] (every? (check v) (nth t i)))\n          (checkcol [v i] (every? (check v) (map #(nth % i) t)))\n          (checkrowcol [v i] (or (checkrow v i) (checkcol v i)))\n          (checkall [v] (some true? (map #(checkrowcol v %) (threerange))))\n          (nnth [i j] (nth (nth t j) i))\n          (checkdiag [v] (or (every? (check v) (map (fn [a] (nnth a a)) (threerange)))\n                             (every? (check v) (map (fn [a] (nnth (- 2 a) a)) (threerange))))\n            )]\n    (cond\n      (or (checkall :o) (checkdiag :o)) :o\n      (or (checkall :x) (checkdiag :x)) :x\n      :else nil\n      )\n    )\n  )","user":"55eeb37ae4b0121d4835fdf3"},{"problem":73,"code":"(fn __ [b]\n  (let [r (range (count b))]\n    (cond (some true? (map #(apply = :x (nth b %)) r)) :x\n          (some true? (map #(apply = :o (nth b %)) r)) :o\n          (some true? (map (fn [x] (apply = :x (map #(nth % x) b))) r)) :x\n          (some true? (map (fn [x] (apply = :o (map #(nth % x) b))) r)) :o\n          (true? (apply = :x (map #(nth (nth b %) %) r))) :x\n          (true? (apply = :o (map #(nth (nth b %) %) r))) :o\n          (true? (apply = :x (map #(nth (nth b (- 2 %)) %) r))) :x\n          (true? (apply = :o (map #(nth (nth b (- 2 %)) %) r))) :o\n        )))","user":"54c271b9e4b045293a27f602"},{"problem":73,"code":"(fn [b]\n    (letfn [(same [coll] (if (every? #(= % (first coll)) coll) (first coll)))]\n\n      (let [d1 (map (partial get-in b) [[0 0] [1 1] [2 2]])\n            d2 (map (partial get-in b) [[0 2] [1 1] [2 0]])\n\n            c1 (map (partial get-in b) [[0 0] [1 0] [2 0]])\n            c2 (map (partial get-in b) [[0 1] [1 1] [2 1]])\n            c3 (map (partial get-in b) [[0 2] [1 2] [2 2]])\n\n            r1 (b 0)\n            r2 (b 1)\n            r3 (b 2)\n\n            all [d1 d2 c1 c2 c3 r1 r2 r3]]\n\n        (first (filter #(or (= :x %) (= :o %)) (map same all))))))","user":"58b81490e4b0ebc645576d8c"},{"problem":73,"code":"(fn [board] \n  (let [check-triple (fn [l] (if (= (count (set l)) 1)\n                               (first l)\n                               nil))\n        flip (apply mapv vector board)\n        slash (mapv #(get-in board [% %]) (range 3))\n        back-slash (mapv #(get-in board [%1 %2]) (range 3) (reverse (range 3)))]\n    (->> (concat board flip [slash back-slash])\n         (map check-triple ,,)\n         (keep #{:x :o} ,,)\n         (distinct ,,)\n         (first ,,))))","user":"4dd0e8f7535da60f04a96e57"},{"problem":73,"code":"(let [winner-from\n      (fn winner-from\n        [three]\n        (if (every? #(= :o %) three) :o\n            (if (every? #(= :x %) three) :x nil)))\n      winner-from-many\n      (fn winner-from-many\n        [many]\n        (reduce (fn [accum next] (if (nil? next) accum next))\n                (map winner-from many)))\n      rows (fn rows [board] board)\n      cols (fn cols [board] [(map #(nth % 0) board)\n                             (map #(nth % 1) board)\n                             (map #(nth % 2) board)])\n      digs (fn digs [board] [[(nth (nth board 0) 0)\n                              (nth (nth board 1) 1)\n                              (nth (nth board 2) 2)]\n                             [(nth (nth board 0) 2)\n                              (nth (nth board 1) 1)\n                              (nth (nth board 2) 0)]])]\n  (fn tic-tac-toe-winner\n    [board]\n    (winner-from-many (concat (rows board) (cols board) (digs board)))))","user":"58152157e4b0f478707a0631"},{"problem":73,"code":"(fn analyze [board]\n  (let [winning-combinations [[[0 0] [0 1] [0 2]]\n                              [[1 0] [1 1] [1 2]]\n                              [[2 0] [2 1] [2 2]]\n                              [[0 0] [1 0] [2 0]]\n                              [[0 0] [1 0] [2 0]]\n                              [[0 1] [1 1] [2 1]]\n                              [[0 2] [1 2] [2 2]]\n                              [[0 0] [1 1] [2 2]]\n                              [[2 0] [1 1] [0 2]]]\n        win? (fn [board player winning-combination] (every? #(= player (get-in board %)) winning-combination))]\n    (cond\n      (some #(win? board :x %) winning-combinations) :x\n      (some #(win? board :o %) winning-combinations) :o)))","user":"5d1be50ce4b02ea6f0fb6986"},{"problem":73,"code":"(fn\n  [board]\n  (let [vertical-board (apply map list board)\n        diagonal-board (conj \n                        [(reduce #(conj %1 (nth %2 (count %1))) [] board)] \n                        (reduce #(conj %1 (nth %2 (count %1))) [] (reverse board)))\n        result (reduce\n         #(if (and (not= :e (first %2)) (apply = %2)) (first %2) %1)\n         nil\n         (concat board vertical-board diagonal-board))]\n    result))","user":"5d96edeae4b0d3f9b434ad35"},{"problem":73,"code":"(fn [c]\n  (let [vertical (apply map vector c)\n        diagonal [(map #(get-in c [% %]) (range 3)) (map #(get-in c [% %2]) (range 3) (reverse (range 3))) ]\n        m {[:x :x :x] :x [:o :o :o] :o}]\n    (reduce #(if (and (not %) (m %2)) (m %2) %) nil (concat c vertical diagonal))))","user":"5dc12b0ae4b0e59a23173d84"},{"code":"(fn tic-tac-toe\n  [board]\n  (do\n    (let [[[tl tm tr] [ml mm mr] [bl bm br] :as b] board\n          v1 [tl ml bl]\n          v2 [tm mm bm]\n          v3 [tr mr br]\n          h1 [tl tm tr]\n          h2 [ml mm mr]\n          h3 [bl bm br]\n          d1 [tl mm br]\n          d2 [tr mm bl]\n          wins (map (partial reduce (fn [a b] (if (= a b) a nil))) \n                    [v1 v2 v3 h1 h2 h3 d1 d2])]\n    (cond \n      (every? #(= :e %) b) nil\n      (some #(= :x %) wins) :x\n      (some #(= :o %) wins) :o\n      :else nil))))","problem":73,"user":"50fc48dde4b0d10d794c19f6"},{"code":"(fn tictactoe [board] (\n      let\n        [\n        starting-board (apply hash-map(interleave (range)(flatten board)))\n        rows (partition 3 (range 10))\n        cols (apply map list rows)\n        diags '((0 4 8)(2 4 6))\n        winposition (flatten(concat rows cols diags))\n        winvalues  (partition 3 (map #(get starting-board  %) winposition))\n        haswin (fn [player] (seq (filter #(= (repeat 3 player) %) winvalues)))\n          ]\n          (if (haswin :x) :x (if (haswin :o) :o nil) )\n       \n   ))","problem":73,"user":"5307e4ece4b02e82168697a9"},{"code":"#( cond \n \n \n\t(or\t\t \t\n\t\t( (fn [dat item]  (reduce (fn [i j] (or i j))  (map (fn [inp]  (= item (inp 0) (inp 1) (inp 2)))  dat ))) %1 :x )                                 \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t( (fn [dat item]  (reduce (fn [i j] (or i j))   (map (fn [inp] (= item (inp 0) (inp 1) (inp 2))) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [index 0 res []]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(cond (= index (count (dat 0)))  res\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:else                    (recur  (inc index) (conj res (vec (map  (fn [inp] ( inp index )) dat))))))))) %1 :x )  \n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t( (fn [dat item]\t(loop [index 0 res true]\n\t\t\t\t\t\t\t\t(cond (= index (count dat))   res  \n\t\t\t\t\t\t\t\t\t\t:else                (recur (inc index) (and res (= ((dat index) index ) item))))))  %1 :x )         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\t\n\t\t( (fn [dat item]\t(loop [index 0 res true]\n\t\t\t\t\t\t\t\t(cond (= index (count dat))   res  \n\t\t\t\t\t\t\t\t\t\t:else                (recur (inc index) (and res (= ( (vec (reverse ( dat index) )) index ) item))))))  %1 :x ) )     :x\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t(or\t\t \t\n\t\t\t( (fn [dat item]  (reduce (fn [i j] (or i j))  (map (fn [inp]  (= item (inp 0) (inp 1) (inp 2)))  dat ))) %1 :o )                                 \n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t( (fn [dat item]  (reduce (fn [i j] (or i j))   (map (fn [inp] (= item (inp 0) (inp 1) (inp 2))) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(loop [index 0 res []]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(cond (= index (count (dat 0)))  res\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:else                    (recur  (inc index) (conj res (vec (map  (fn [inp] ( inp index )) dat))))))))) %1 :o )  \n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t( (fn [dat item]\t(loop [index 0 res true]\n\t\t\t\t\t\t\t\t\t(cond (= index (count dat))   res  \n\t\t\t\t\t\t\t\t\t\t\t:else                (recur (inc index) (and res (= ((dat index) index ) item))))))  %1 :o )         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\n\t\n\t\t\t( (fn [dat item]\t(loop [index 0 res true]\n\t\t\t\t\t\t\t\t\t(cond (= index (count dat))   res  \n\t\t\t\t\t\t\t\t\t\t\t:else                (recur (inc index) (and res (= ( (vec (reverse ( dat index) )) index ) item))))))  %1 :o ) )     :o\n\n\n\t :else nil )","problem":73,"user":"52f5eefbe4b09b582c12c9cb"},{"code":"(fn check [board]\n  (let [flt (flatten board)\n        check-row (fn [r x] (every? #(= x %) r))\n        get-rows (concat board\n                         (partition 3 (apply interleave board))\n                         [(take-nth 4 flt)\n                          (take 3 (take-nth 2 (drop 2 flt)))])\n        win? (fn [x] (some #(check-row % x) get-rows))]\n\t\t(cond\n         (win? :x) :x\n         (win? :o) :o\n         :else nil)))","problem":73,"user":"511cca27e4b00c2a1fa7ff7d"},{"code":"(fn ttt [coll]\n  (let [merged (fn [x] (reduce str x))\n        who? (fn [x] (cond\n                      (= \":e:e:e\" x ) nil\n                      (= \":x:x:x\" x) :x\n                      (= \":o:o:o\" x) :o\n                      :else nil)\n               )\n        r1 (map (comp who? merged) coll)\n        r2 (apply map (fn [x y z] ((comp who? merged) [x y z])) coll)\n        r3 ((comp who? merged) [(last (first coll))\n                                (second (second coll))\n                                (first (last coll))])\n        r4 ((comp who? merged) [(first (first coll))\n                                (second (second coll))\n                                (last (last coll))])\n        r5 (filter #((complement nil?) %) (set (concat r1 r2 [r3] [r4])) )\n        ] (empty? r5) nil (first r5)  ))","problem":73,"user":"52140b53e4b0961f15ac4d7e"},{"problem":73,"code":"(fn tic-tac [board]\n  (letfn[(get-row [n]\n            (board n))   \n         (get-col [n]\n            (map #(aget (to-array-2d board) % n) (range 3)))   \n         (get-diag [] \n            (map #(aget (to-array-2d board) %1 %1) (range 3)))\n         (get-counter-diag [] \n           (map #(aget (to-array-2d board) %1 (- 2 %1)) (range 3)))\n         (player-wins? [player stride] \n            (every? #{player} stride))]\n         (let [strides (reduce concat [(map get-row (range 3)) \n                                       (map get-col (range 3)) \n                                       [(get-diag)] \n                                       [(get-counter-diag)]])]\n           (if (some (partial player-wins? :x) strides) :x\n             (if (some (partial player-wins? :o) strides) :o\n               nil)\n          ))))","user":"54b050cee4b09f271ff37d13"},{"problem":73,"code":"(fn solve [rows]\n  (let [cols  (apply map vector rows)\n        diag1 (map #(get-in rows [% %]) (range 3))\n        diag2 (map #(get-in rows [% (- 2 %)]) (range 3))\n        moves (concat rows cols [diag1 diag2])\n        win   (some #(when (= 1 (count (set %))) %) moves)]\n    (#{:x :o} (first win))))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":73,"code":"(fn [tictac]\n  (let [flip (fn [x] (map-indexed (fn [i e] (->> x (map #(nth % i)) (flatten))) x))\n        rev (fn [x] (map reverse x))\n        non-empty! (fn [x] (not (some #(= :e %) x)))\n        isone? (fn [x] (and (= (->> x (distinct) (count)) 1) (non-empty! x)))\n        col-row! (fn [colls] (->> colls (filter isone?) (flatten) (distinct)))\n        diag! (fn [colls] (->> colls (map-indexed #(nth %2 %1)) (distinct)))\n        ;;start checking\n        row (col-row! tictac) \n        col (col-row! (flip tictac)) \n        diagl (diag! tictac) \n        diagr (diag! (rev tictac))]\n    (cond\n      (isone? diagl) (first diagl)\n      (isone? diagr) (first diagr)\n      (isone? row) (first row)\n      (isone? col) (first col)\n      :else nil)))","user":"565b941ce4b068f2fe63dc07"},{"problem":73,"code":"(fn tic-tac-toe\n  [board]\n  (let [wins [[[0 0] [0 1] [0 2]]\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]]\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]]]\n        actuals (map (fn [row] (map #(get-in board %) row)) wins)\n        x? (->> actuals (filter #(= % [:x :x :x])) (count) (pos?))\n        o? (->> actuals (filter #(= % [:o :o :o])) (count) (pos?))]\n    (cond\n     x? :x\n     o? :o\n     :else nil)))","user":"4fc524aae4b081705acca37e"},{"problem":73,"code":"(fn [board]\n  (let [diagonals [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                   [((board 0) 2) ((board 1) 1) ((board 2) 0)]]]\n    (some\n      #(when (not (nil? %)) %)\n      (map\n        #(if\n          (and (apply = %) (not (= (first %) :e)))\n          (first %)\n          nil)\n        (->> []\n          (concat board)\n          (concat diagonals)\n          (concat (apply map vector board)))))))","user":"5ca622f3e4b048ec896c5be0"},{"problem":73,"code":"(fn[input] \n  (let [getFreqsOfXandOs (fn[i](frequencies (filter #(or (= :x %) (= :o %)) i))) \n        getWinnerFilter #(= 3 (first (vals %)))\n        getWinnerFromInput #(first (filter getWinnerFilter (map getFreqsOfXandOs %)))\n        verticalLists (interleave (first input) (second input) (last input))\n        diagonal1 (conj [] [(ffirst input) (second (second input)) (last (last input))])\n        diagonal2 (conj [] [(last (first input)) (second (second input)) (first (last input))]) \n        verticals (reduce #(conj %1 (into [] %2)) [] (partition 3 verticalLists))\n        ]\n        (cond\n          (not-empty (getWinnerFromInput input)) (ffirst (getWinnerFromInput input))\n          (not-empty (getWinnerFromInput verticals)) (ffirst (getWinnerFromInput verticals))\n          (not-empty (getWinnerFromInput diagonal1)) (ffirst (getWinnerFromInput diagonal1))\n          :else (ffirst (getWinnerFromInput diagonal2))\n          )\n        ))","user":"571172ece4b09c608db70446"},{"code":"(fn [ttt]\n  (let [lines (->> (range 3)\n     (map\n       (fn [y]\n         (map #(vector [% y] [y %] [% %] [(- 2 %) %])\n              (range 3))))\n     (mapcat #(apply map vector %))\n     distinct\n     (map (fn [l] (map #(get-in ttt %) l))))\n     pw (fn [p] (->> lines\n          (map (fn [l] (filter #(= p %) l)))\n          (map count)\n          (some #(= 3 %))))]\n  (cond (pw :o) :o\n        (pw :x) :x\n        :else nil)))","problem":73,"user":"4f1bb9d8535d64f60314647d"},{"problem":73,"code":"(fn [v]\n    (let [r0 (v 0)\n          r1 (v 1)\n          r2 (v 2)\n          c0 (vector (r0 0) (r1 0) (r2 0))\n          c1 (vector (r0 1) (r1 1) (r2 1))\n          c2 (vector (r0 2) (r1 2) (r2 2))\n          d1 (vector (r0 0) (r1 1) (r2 2))\n          d2 (vector (r2 0) (r1 1) (r0 2))\n          ev [r0 r1 r2 c0 c1 c2 d1 d2]\n          all-same? (fn [v] (apply = v))\n          all-empty? (fn [v] (every? (fn [i] (= :e i)) v))\n          fv (filter (fn [v] (and (all-same? v) (not (all-empty? v)))) ev)\n          ]\n      (first (first (seq fv)))\n      )\n    )","user":"515ebde3e4b01e5d11ccd0a8"},{"code":";TODO work with n*n board (means no hard coding winning rows\n#(some {[:x :x :x] :x [:o :o :o] :o} (let [[[r1c1 r1c2 r1c3] [r2c1 r2c2 r2c3] [r3c1 r3c2 r3c3]] %] \n    ;layout possible winning rows\n    [\n     \n     ;rows\n     [r1c1 r1c2 r1c3]\n     [r2c1 r2c2 r2c3]\n     [r3c1 r3c2 r3c3]\n     \n     ;cols\n     [r1c1 r2c1 r3c1]\n     [r1c2 r2c2 r3c2]\n     [r1c3 r2c3 r3c3]\n     \n     ;diagonal\n     [r1c1 r2c2 r3c3]\n     [r1c3 r2c2 r3c1]\n    \n    ]\n  )\n)","problem":73,"user":"53906b89e4b0b51d73faae99"},{"code":"(fn ttt [coll]\n  (let [[a b c] (nth coll 0),\n        [d e f] (nth coll 1),\n        [g h i] (nth coll 2)]\n    (if (= :e a b c d e f g h i)\n      nil\n      (cond\n        (and (= a b c) (not= :e a)) a\n        (and (= d e f) (not= :e d)) d\n        (and (= a b c) (not= :e a)) a        \n        (and (= d e f) (not= :e d)) d\n        (and (= g h i) (not= :e g)) g\n        (and (= a d g) (not= :e a)) a\n        (and (= b e h) (not= :e b)) b\n        (and (= c f i) (not= :e c)) c\n        (and (= a e i) (not= :e a)) a\n        (and (= c e g) (not= :e c)) c\n        :else nil))))","problem":73,"user":"512474ede4b02c3f2a072cce"},{"code":"#(ffirst (filter (fn [line] (and (= (count (set line)) 1) (not= :e (first line))))\r\n    (partition 3 (map (partial get-in %) \r\n       (partition 2 [0 0 0 1 0 2 1 0 1 1 1 2 2 0 2 1 2 2 0 0 1 0 2 0 0 1 1 1 2 1 1 2 1 2 2 2 0 0 1 1 2 2 0 2 1 1 2 0])))))","problem":73,"user":"4f29cdc8e4b0d6649770a033"},{"problem":73,"code":"(fn [coll] (let [ horizon (fn [collho] \n                                (map \n                                  (fn [n]\n                                     (if (apply = n) (if (= (first n) :e) nil (first n)) nil)) collho)) \n                 \n                   variant (fn  [listvariant]\n                   \t\t\t\t(horizon (partition 3 (apply interleave listvariant))))\n                  xie (fn  [listxie index]\n                           (vec (vals (select-keys (vec (flatten listxie)) index))))\n                 \n                 ] (first (remove nil? (flatten (list (horizon (list (xie coll [0 4 8]) (xie coll [2 4 6]))) (variant coll) (horizon coll)))))))","user":"5ac04101e4b073f177442737"},{"code":"(fn [board]\n  (letfn [(test-horizontal [e]\n            (some\n              (fn [b] \n                (some \n                  #(apply = e %)\n                  b))\n              [board (apply map vector board)])\n            )\n          (test-diag [e] \n            (let [diag (fn [b] (map-indexed #(nth %2 %) b))]\n              (some\n                #(apply = e (diag %))\n                [board (reverse board)])))\n          (test [e]\n            (some \n              #(% e)\n              [test-horizontal test-diag]))]\n    (first (filter test '(:x :o)))))","problem":73,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":73,"code":"(fn check-win [board]\n\t(let [\n\t\t\trows (for [x [0 1 2]] (map #(conj [x] %) (range 3))),\n\t\t\tcols (for [c rows] (map reverse c)),\n\t\t\tdiag [ [[0 0] [1 1] [2 2]], [[0 2] [1 1] [2 0]] ],\n          \n\t\t\tget-win-set (fn [coords] (set (for [[r c] coords] ((board r) c)))),\n          \n            win?\t\t(fn [s] \n                            (cond \n                              (= #{:x} s) :x \n                              (= #{:o} s) :o \n                              :else nil)) \n         ]\n\n\t\t(some #(win? (get-win-set %)) (lazy-cat diag rows cols))))","user":"564d02cde4b0284900eef679"},{"problem":73,"code":"(fn [b]\n  (cond\n   (= (first b) [:x :x :x]) :x\n   (= (first b) [:o :o :o]) :o\n   \n   (= (second b) [:x :x :x]) :x\n   (= (second b) [:o :o :o]) :o\n   \n   (= (last b) [:x :x :x]) :x\n   (= (last b) [:o :o :o]) :o\n   \n   (and (= (first (first b)) :x) (= (first (second b)) :x) (=  (first (last b)) :x)) :x\n   (and (= (first (first b)) :o) (= (first (second b)) :o) (=  (first (last b)) :o)) :o\n\n   (and (= (second (first b)) :x) (= (second (second b)) :x) (=  (second (last b)) :x)) :x\n   (and (= (second (first b)) :o) (= (second (second b)) :o) (=  (second (last b)) :o)) :o\n   \n   (and (= (last (first b)) :x) (= (last (second b)) :x) (=  (last (last b)) :x)) :x\n   (and (= (last (first b)) :o) (= (last (second b)) :o) (=  (last (last b)) :o)) :o\n   \n   (and (= (first (first b)) :x) (= (second (second b)) :x) (=  (last (last b)) :x)) :x\n   (and (= (first (first b)) :o) (= (second (second b)) :o) (=  (last (last b)) :o)) :o\n   \n   (and (= (last (first b)) :x) (= (second (second b)) :x) (=  (first (last b)) :x)) :x\n   (and (= (last (first b)) :o) (= (second (second b)) :o) (=  (first (last b)) :o)) :o\n   \n   :else nil\n   )\n )","user":"5676af21e4b05957ce8c6158"},{"problem":73,"code":"(fn [B] (let [counts (map frequencies \n                          (concat B \n                                  (apply mapv vector B) \n                                  [[(nth (nth B 0) 0) (nth (nth B 1) 1) (nth (nth B 2) 2)]] \n                                  [[(nth (nth B 2) 0) (nth (nth B 1) 1) (nth (nth B 0) 2)]]))]\n  (if (some #{{:x 3}} counts) :x\n    (if (some #{{:o 3}} counts) :o\n      nil))))","user":"55f25ae6e4b06e875b46ce43"},{"problem":73,"code":"(fn [board]\n  (let [vs board\n        hs (map (fn [n]\n                  (map #(% n) board)) [0 1 2])\n        d1 (map #(get-in board [% %]) [0 1 2])\n        d2 (map #(get-in board [%1 %2]) [0 1 2] [2 1 0])\n        rows (concat vs hs [d1 d2])]\n    (first (first (filter #(or (every? (partial = :x) %)\n                               (every? (partial = :o) %)) rows)))))","user":"5317d78ee4b08068f379ed63"},{"problem":73,"code":"(fn analyse-tictactoe [v]\n  (letfn [(test-rows [field] (map #(if (apply = %) (first %)) field))\n          (transpose [field] (for [n [0 1 2]] (map #(nth % n) field)))\n          (test-columns [field] (test-rows (transpose field)))\n          (at [i j] (get (get v i) j))\n          (test-diagonals [field] (let [center (at 1 1)]\n                                    (if (not= :e center)\n                                      (if (or (= center (at 0 0) (at 2 2))\n                                              (= center (at 2 0) (at 0 2)))\n                                        center\n                                        :e)\n                                      :e)))]\n    (some #{:x :o} (flatten [(test-rows v) (test-columns v) (test-diagonals v)]))))","user":"5f2c94b4e4b033932238a669"},{"problem":73,"code":"(fn ttt [board]\n  (let [winning-row? (fn [v row] (every? #(= v %) row))\n        row-indexes (concat board\n                            (map (fn [x] (map #(get % x) board)) (range 3))\n                            [(map #(get (get board %) %) (range 3))\n                             (map #(get (get board %) (- 2 %)) (range 3))])]\n    (cond\n      (some true? (map (partial winning-row? :o) row-indexes)) :o\n      (some true? (map (partial winning-row? :x) row-indexes)) :x)))","user":"500e6ddee4b04a05d36fcc06"},{"problem":73,"code":"(fn [board]\n  (let [winner? (fn [s] (if (apply = s) (first s) nil))\n        row-winner? (map winner? board)\n        col-winner? (map winner? (apply map vector board))\n        lft-diag-winner? (winner? (map get board (range 3)))\n        rgt-diag-winner? (winner? (map get board (range 2 -1 -1)))]\n    (some #{:x :o} (or (concat row-winner? col-winner? [lft-diag-winner? rgt-diag-winner?])))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn [b]\n  (first\n   (remove\n    #(= :e %)\n    (for [t (concat\n             [[[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]]]\n             (for [r [0 1 2]]\n               [[r 0] [r 1] [r 2]])\n             (for [c [0 1 2]]\n               [[0 c] [1 c] [2 c]]))]\n      (let [v (for [[r c] t]\n                ((b r) c))]\n        (if (apply = v)\n          (first v)\n          :e))))))","problem":73,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"(fn [[[a b c]\n      [e f g]\n      [h i j]]]\n   \n   (let [attempt (list (list a b c)\n                   (list e f g)\n                   (list h i j)\n                   (list a e h)\n                   (list b f i)\n                   (list c g j)\n                   (list a f j)\n                   (list h f c))]\n   (if (some #{'(:x :x :x)} attempt)\n       :x\n       (if (some #{'(:o :o :o)} attempt)\n           :o\n           nil))))","problem":73,"user":"4fccf7b9e4b0ee37620e1872"},{"problem":73,"code":"(fn [board]\n   (let [funcs [first second last]\n         playrs [:x :o]\n         row (fn [f p]\n               (every? #(= % p) (f board)))\n         col (fn [f p]\n               (every? #(= % p) (map f board)))\n         diag (fn [p]\n                (every? #(= % p) (map #(%2 %1) board funcs)))\n         rev-diag (fn [p]\n                    (every? #(= % p) (map #(%2 %1) board (reverse funcs))))\n         winner (for [f funcs\n                      p playrs\n                      :when (or (row f p) (col f p) (diag p) (rev-diag p))]\n                  p)]\n     (if (empty? winner)\n       nil\n       (first winner))))","user":"5ab23c99e4b073f1774425e2"},{"problem":73,"code":"(fn [board] \n  (first \n   (filter #(not (= nil %)) \n           (map (fn [row] \n                  (let [pieces-in-row (set row)]\n                    (if (or (> (count pieces-in-row) 1) (= (first pieces-in-row) :e))\n                      nil\n                      (first pieces-in-row)\n                      )\n                    )\n                  )\n                (concat board (apply map list board) \n              (list (list (nth (nth board 0) 0) (nth (nth board 1) 1) (nth (nth board 2) 2))\n              (list (nth (nth board 0) 2) (nth (nth board 1) 1) (nth (nth board 2) 0)))))\n  )))","user":"54cb3497e4b057c6fda3a272"},{"problem":73,"code":"(fn [board]\n  (let [win? (fn [coll player] (->> coll (filter (partial = player))\n                                                          count\n                                                          (= 3)))\n           row-win? (fn [row player] (win? (board row) player))\n           col-win? (fn [col player] (win? (map #(nth % col) board) player))\n           main-diag-win? (fn [player] (win? (map (fn [idx row] (nth row idx)) [0 1 2] board) player))\n           cross-diag-win? (fn [player] (win? (map (fn [idx row] (nth row idx)) [2 1 0] board) player))]\n    (cond\n      (or (some #(row-win? % :x) [0 1 2])\n             (some #(col-win? % :x) [0 1 2])\n             (main-diag-win? :x)\n             (cross-diag-win? :x)) :x\n      (or (some #(row-win? % :o) [0 1 2])\n             (some #(col-win? % :o) [0 1 2])\n             (main-diag-win? :o)\n             (cross-diag-win? :o)) :o\n     :else nil)))","user":"58949f8de4b00487982d525e"},{"code":"(fn [b]\n  (let [bf (vec (flatten b)),\n        t true?,\n        d (fn [a] (vec (map #(= a %) bf))),\n        x (d :x),\n        y (d :o),\n        i [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]],\n        f (fn [a] (some t (map (fn [s] (every? t (map #(a %) s))) i))),\n        m (f x),\n        n (f y)]\n    (if m\n      :x\n      (if n\n        :o\n        nil))))","problem":73,"user":"535d2533e4b04ce2eb3ed2bc"},{"code":"#(ffirst\n  (filter\n   #{[:x :x :x] [:o :o :o]}\n   (partition 3 (for [y [0 1 2 0 3 6 0 4 8 1 4 7 2 5 8 2 4 6 3 4 5 6 7 8]] ((% (quot y 3)) (rem y 3))))))","problem":73,"user":"4f296a80e4b0d6649770a02a"},{"problem":73,"code":"(fn whoswinning [board]\n  (let\n    [positions [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] ; horizontal\n                [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] ; vertical\n                [[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]] ; diagonal\n     position-contents (map (fn [pos] (map #(get-in board %) pos)) positions)\n     winning (fn [player] \n               (some \n                (fn [combo] \n                  (every? #(= % player)\n                  combo)) \n                position-contents))]\n    (cond (winning :o) :o\n          (winning :x) :x\n          :else nil)))","user":"551afdf8e4b07993ea3788cb"},{"problem":73,"code":"(fn check-ttt[l]\n  (reduce #(or %1 %2) \n    (replace {:e nil} (\n      (fn [d]\n    \t(map #(if (apply = %) (first %) nil) d))\n    \t(concat l                         ; rows\n            \t(apply mapv vector l)     ; cols\n            \t[(replace (vec (apply concat l)) [0 4 8])]  ; diag 1\n            \t[(replace (vec (apply concat l)) [2 4 6])]  ; diag 2\n    )))\n  )\n)","user":"566b8946e4b0a866af6896b0"},{"code":"#(some {[:o :o :o] :o [:x :x :x] :x} (partition 3 (map (vec (flatten %)) [0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6])))","problem":73,"user":"4e9d6a65535dbda64a6f6b87"},{"code":"(fn [board]\n  (let [winner (fn [player]\n    (when (or \n      (some identity (for [i [0 1 2]] \n        (->> (range 3) (map #((board %) i)) (every? #(= player %)))))\n        (some (fn [row] (every? #(= player %) row)) board)\n        (every? #(= player %) ((juxt (comp first first) (comp second second) (comp last last)) board))\n        (every? #(= player %) ((juxt (comp first last) (comp second second) (comp last first)) board))\n        ) player))]\n    (or (winner :x) (winner :o))))","problem":73,"user":"4f294c48e4b0d6649770a023"},{"code":"(fn [board]\n  (let [winning-list ((fn [n]\n                        (mapcat (fn [func]\n                                  (func (range n)))\n                                (list (partial map (fn [x] (map (fn [y] [x y]) (range n))))\n                                      (partial map (fn [y] (map (fn [x] [x y]) (range n))))\n                                      (comp list (partial map (fn [i] [i i])))\n                                      (comp list (partial map (fn [i] [i (- n i 1)]))))))\n                      3)]\n    (loop [coords winning-list]\n      (if (empty? coords)\n        nil\n        (let [v-list (map (partial get-in board) (first coords))             \n              v (first v-list)]\n          (if (and (apply = v-list) (not (= v :e)))\n            v\n            (recur (rest coords))))))))","problem":73,"user":"51105c7fe4b04c71fce993ef"},{"problem":73,"code":"(fn [boards]\n  (letfn [(found [s]\n                 (let [[f & r] (filter #(or (every? (partial = :x) %)\n                                           (every? (partial = :o) %)) s)]\n                   (if-not (nil? f)\n                     (first f)\n                     nil)))]\n    (or\n     (found boards)\n     (found (apply map #(vector %1 %2 %3) boards))\n     (found [[(nth (first boards) 0) (nth (second boards) 1) (nth (nth boards 2) 2)]\n             [(nth (first boards) 2) (nth (second boards) 1) (nth (nth boards 2) 0)]]))))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn aa [[[a b c] [d e f] [g h i]]]\n    \n     (cond\n      (and (= a b c) (not= a :e)) a\n      (and (= d e f) (not= d :e)) d\n      (and (= g h i) (not= g :e)) g\n      (and (= a d g) (not= a :e)) a\n      (and (= b e h) (not= b :e)) b\n      (and (= c f i) (not= c :e)) c\n      (and (= a e i) (not= a :e)) a\n      (and (= c e g) (not= c :e)) c\n\t  :else nil\t \n           )\n\t  )","problem":73,"user":"5105ed16e4b01150e115ebe2"},{"problem":73,"code":"(fn analyze-board [board]\n  (let [rows                      board\n        [col1 col2 col3 :as cols] [(map first board) (map second board) (map last board)]\n        diags                     [[(first col1) (second col2) (last col3)]\n                                   [(first col3) (second col2) (last col1)]]\n        winner?                   (fn [row] (cond (every? #{:o} row) :o\n                                                 (every? #{:x} row) :x\n                                                 :else              nil))]\n    (ffirst (filter winner? (concat rows cols diags)))))","user":"5db0d470e4b0f8c104ccfc9e"},{"problem":73,"code":"(fn [mat] \n  (let [horiz (for [x (range 3)] (for [y (range 3)] [x y]))\n\t\tvert (for [x (range 3)] (for [y (range 3)] [y x]))\n\t\tdiag1 (for [x (range 3)] [x x])\n\t\tdiag2 (for [x (range 3)] [x (- 2 x)])\n\t\tlines (conj (concat horiz vert) diag1 diag2)\n        nf {:e 0 :o 1 :x -1}\n        vl (fn [m c] ((m (first c)) (second c)))\n        res (set (map (fn [x] (apply + (map #(nf (vl mat %)) x))) lines))\n        ]\n   \t\t\t (cond (contains? res 3) :o\n                   (contains? res -3) :x\n                   :else nil\n                   \n       \t\t  )  \n  )  \n)","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":73,"code":"(fn [board]\n  (let [columns (apply map list board)\n        rows board\n        diagonal-fn #(reduce (fn [elements row] (conj elements (get row (count elements)))) [] %)\n        diagonals [(diagonal-fn rows) (diagonal-fn (map (comp vec reverse) rows))]\n        winning-group (first\n                        (filter\n                          (fn [group] (let [elements (set group)]\n                                        (and (= 1 (count elements))\n                                             (not (= :e (first elements))))))\n                          (concat columns rows diagonals)))]\n    (when winning-group (first winning-group)))\n  )","user":"4fdf9a9ae4b05e33b9224f9f"},{"problem":73,"code":"(fn game [vec-vec]\n  (let [result (or (some #(and (apply = %) (first %)) vec-vec)\n                   (some #(and (apply = %) (first %)) (apply map vector vec-vec))\n                   (let [lu (first (first vec-vec))\n                         ru (last (first vec-vec))\n                         md (second (second vec-vec))\n                         ld (first (last vec-vec))\n                         rd (last (last vec-vec))]\n                     (or (and (= lu md rd) lu)\n                         (and (= ru md ld) ru))\n                     )\n                   nil)]\n    (if (= result :e)\n      nil\n      result)))","user":"563f2eaae4b08d4f616f5ed1"},{"code":"(fn [qipan]\n  (let [\n    row? (fn [who]\n      (or (= [who who who] (first qipan))\n          (= [who who who] (second qipan))\n          (= [who who who] (last qipan)))\n    )\n    col? (fn [who] \n      (or (= who (first (first qipan)) (first (second qipan)) (first (last qipan)))\n          (= who (second (first qipan)) (second (second qipan)) (second (last qipan)))\n          (= who (last (first qipan)) (last (second qipan)) (last (last qipan))))\n    )\n    mid? (fn [who] \n      (or (= who (first (first qipan)) (second (second qipan)) (last (last qipan)))\n          (= who (last (first qipan)) (second (second qipan)) (first (last qipan))))\n    )\n    is-win? (fn [who]\n      (or (row? who) (col? who) (mid? who))\n      )]\n    (if (is-win? :x) :x\n      (if (is-win? :o) :o nil))))","problem":73,"user":"4f3242bae4b0d6649770a08f"},{"code":"#(let \n  [lines [\n    [[0 0] [0 1] [0 2]]\n    [[1 0] [1 1] [1 2]]\n    [[2 0] [2 1] [2 2]]\n    [[0 0] [1 0] [2 0]]\n    [[0 1] [1 1] [2 1]]\n    [[0 2] [1 2] [2 2]]\n    [[0 0] [1 1] [2 2]]\n    [[2 0] [1 1] [0 2]]]\n    g (fn [m x y] ((m x) y))\n    gp (fn [m p] (g m (p 0) (p 1)))\n    gl (fn [m l] [(gp m (l 0)) (gp m (l 1)) (gp m (l 2))])\n    sames (for [l lines :when (apply = (gl % l))] (gp % (l 0)))\n    d (vec (distinct sames))\n    d0 (get d 0)\n    result (if (= d0 :x) :x \n              (if (= d0 :o) :o))\n]\n  result)","problem":73,"user":"4edd038c535d10e5ff6f5327"},{"problem":73,"code":"(fn [rows] \n  (let [row1 (first rows) \n        row2 (second rows)\n        row3 (nth rows 2)\n        transp (apply map vector rows)]\n    \n  (cond \n   (reduce #(or (apply = (conj %2 :x)) %1) false rows) :x\n   (reduce #(or (apply = (conj %2 :o)) %1) false rows) :o\n   (reduce #(or (apply = (conj %2 :x)) %1) false transp) :x\n   (reduce #(or (apply = (conj %2 :o)) %1) false transp) :o\n   (and (= (first row1) (second row2) (nth row3 2)) (not (= (first row1) :e))) (first row1)\n   (and (= (nth row1 2) (second row2) (first row3)) (not (= (first row3) :e))) (first row3)\n   )))","user":"588fd085e4b00487982d51c0"},{"code":"(fn [tictac]\r\n  (let [get-at  (fn [x y] ((tictac x) y))\r\n  to-vec  (fn [s] (into [] s))\r\n\tsz (range 3)\r\n\ttr (to-vec (for [y sz] (get-at 0 y)))\r\n\tmr (to-vec (for [y sz] (get-at 1 y)))\r\n\tbr (to-vec (for [y sz] (get-at 2 y)))\r\n\tlc (to-vec (for [x sz] (get-at x 0)))\r\n\tmc (to-vec (for [x sz] (get-at x 1)))\r\n\trc (to-vec (for [x sz] (get-at x 2)))\r\n\tld (to-vec (for [x sz] (get-at x x)))\r\n\trd (to-vec (for [x sz] (get-at x (- 2 x))))\r\n\twinner (map (fn [sym] \r\n\t\t\t(if (reduce #(or %1 %2)\r\n\t\t\t\t    (map\r\n\t\t\t\t     (fn [r] (apply (fn [s] (every? #(= % sym) s)) [r]))\r\n\t\t\t\t     [tr mr br lc mc rc ld rd])) \r\n\t\t\t    sym)) '(:x :o))\r\n\twins? (fn [sym] (some #{sym} winner))]\r\n    (cond (wins? :x) :x\r\n\t  (wins? :o) :o\r\n\t  :default nil)))","problem":73,"user":"4f9c4080e4b0dcca54ed6d1a"},{"code":"(fn[rows]\n  (let [cols (partition 3 (for [idx [0 1 2] c rows] (nth c idx)))\n           d1 (keep-indexed (fn[idx item] (when (#{0 4 8} idx) item)) (mapcat identity rows))\n           d2 (keep-indexed (fn[idx item] (when (#{2 4 6} idx) item)) (mapcat identity rows))]\n       (let [res (ffirst (filter #(= 1 (count (set %))) (concat rows cols [d1] [d2])))]\n           (when (not= :e res)\n             res))))","problem":73,"user":"4e58bcd4535d8a8b8723a296"},{"problem":73,"code":"(fn [board]\n  (let [[r1 r2 r3] board\n        [c1 c2 c3] [[(first r1) (first r2) (first r3)]\n                    [(second r1) (second r2) (second r3)]\n                    [(last r1) (last r2) (last r3)]]\n        [d1 d2] [[(first r1) (second r2) (last r3)]\n                 [(last r1) (second r2) (first r3)]]]\n    \n    (some {[:x :x :x] :x [:o :o :o] :o}\n          [r1 r2 r3 c1 c2 c3 d1 d2])))","user":"5bbcb71ce4b0a20761a23629"},{"problem":73,"code":"(fn [l]\n  (let [tl (nth (first l) 0)\n        tm (nth (first l) 1)\n        tr (nth (first l) 2)\n        ml (nth (second l) 0)\n        mm (nth (second l) 1)\n        mr (nth (second l) 2)\n        bl (nth (nth l 2) 0)\n        bm (nth (nth l 2) 1)\n        br (nth (nth l 2) 2)\n        first-match (some #(if (apply = %) (first %) nil) [[tl tm tr] [ml mm mr] [bl bm br] [tl ml bl] [tm mm bm] [tr mr br] [tl mm br] [tr mm bl]])]\n    (cond (and first-match (not= first-match :e))\n          first-match\n          )\n    )\n  )","user":"5f419985e4b0955706451fab"},{"problem":73,"code":"(fn [board]\n  (let [lanes (apply conj board \n                          (map get board [0 1 2]) \n                          (map get board [2 1 0]) \n                          (apply map vector board))\n        winners {[:x :x :x] :x\n                 [:o :o :o] :o}]\n    (some winners lanes)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":73,"code":"(fn [b] (let [c [(first b) (second b) (last b)\n                 (map first b) (map second b) (map last b)                 \n                 [(-> b (first) (first))\n                  (-> b (second) (second))\n                  (-> b (last) (last))]\n                 [(-> b (last) (first))\n                  (-> b (second) (second))\n                  (-> b (first) (last))]]\n              d (filter (complement nil?) (map (fn [e] (cond (every? (partial = :x) e) :x\n                                   (every? (partial = :o) e) :o\n                                   :else nil))\n                     (filter (partial not-any? (partial = :e)) c)))]\n          (first d)))","user":"52d07cc5e4b07d0d72b273bb"},{"problem":73,"code":"(fn aa [v]\n    (let [v-col (apply map vector v) v-dip (conj [] (first (nth v-col 0)) (second (nth v-col 1)) (nth (nth v-col 2) 2))\n          v-dis (conj [] (first (nth v-col 2)) (second (nth v-col 1)) (nth (nth v-col 0) 2))]\n        (cond \n            (true? (apply = v)) nil\n            \n            (and (true? (apply = (nth v 0))) (true? (not= [:e :e :e] (nth v 0)))) (first (nth v 0))\n            (and (true? (apply = (nth v 1))) (true? (not= [:e :e :e] (nth v 1)))) (first (nth v 1))\n            (and (true? (apply = (nth v 2))) (true? (not= [:e :e :e] (nth v 2)))) (first (nth v 2))\n            \n            (and (true? (apply = (nth v-col 0))) (true? (not= [:e :e :e] (nth v-col 0)))) (first (nth v-col 0))\n            (and (true? (apply = (nth v-col 1))) (true? (not= [:e :e :e] (nth v-col 1)))) (first (nth v-col 1))\n            (and (true? (apply = (nth v-col 2))) (true? (not= [:e :e :e] (nth v-col 2)))) (first (nth v-col 2))\n            \n            (and (true? (apply = v-dip)) (true? (not= [:e :e :e] v-dip))) (first v-dip)\n         \t(and (true? (apply = v-dis)) (true? (not= [:e :e :e] v-dis))) (first v-dis)\n        )\n    )\n)","user":"5f0cb4f3e4b0f30dddfb5d4e"},{"code":"(fn [grid]\n  (some \n    #(let [f (first %)] (when (and (#{:x :o} f) (= % (repeat 3 f))) f))\n    (concat (apply mapv vector grid) ;; reverse to test grid columns\n            (conj grid               ;; grid lines\n              [((grid 0) 0) ((grid 1) 1) ((grid 2) 2)]       ;;first diag\n              [((grid 0) 2) ((grid 1) 1) ((grid 2) 0)]))))  ;;second diag","problem":73,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [b]\n    (some (fn [p]\n            (if (or\n                 ;; diag:\n                 (every? #{p}\n                         (for [i (range 3)]\n                           ((b i) i)))\n                 ;; anti-diag:\n                 (every? #{p}\n                         (for [i (range 3)]\n                           ((b i) (- 2 i))))\n                 ;; across:\n                 (some (fn [i]\n                         (every? #{p} (for [j (range 3)] ((b i) j))))\n                     (range 3))\n                 ;; down:\n                 (some (fn [i]\n                         (every? #{p} (for [j (range 3)] ((b j) i))))\n                       (range 3)))\n              p))\n          [:x :o]))","problem":73,"user":"4ee26f01535d10e5ff6f5368"},{"problem":73,"code":"(fn [h]\n  (let [v (vec (apply map vector h))\n        d #(vector (for [i (range 3)] ((% i) i)))\n        ss (concat h v (d h) (d (vec (rseq v))))\n        r (first (for [s ss :when (apply = s)] (first s)))]\n  (if (= :e r) nil r)))","user":"4eb5750a535d7eef30807366"},{"problem":73,"code":"(fn checktic [board]\n  (let [winner? (fn [row]\n                  (cond\n                   (= row [:x :x :x]) :x\n                   (= row [:o :o :o]) :o\n                   :else nil))\n        rotated (apply map vector board)\n        pull-diag (fn [v] (map-indexed (fn [idx itm] (nth itm idx)) v))\n        diags [(pull-diag board) (pull-diag (reverse board))]\n        rows (concat board rotated diags)]\n    (some identity (map winner? rows))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [board]\n  (let [cols (apply mapv vector board)\n        d (range (count board))\n        diag-idxs [(map vector d d) (map vector d (reverse d))]\n        diags (map #(map (partial get-in board) %) diag-idxs)\n        all (concat board cols diags)\n        row-wins? (fn [piece row] (every? (partial = piece) row))\n        wins? (fn [piece] (some (partial row-wins? piece) all))]\n    (cond (wins? :x) :x\n          (wins? :o) :o\n          :else nil)))","problem":73,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":73,"code":"(fn foo [brd]\n  (letfn [(transpose [m] (apply mapv vector m))\n     (diag [m d k] (mapv (fn[x] (get-in m [x (+ d (* k x))])) (range 3)))\n     (lines [m] (conj (into m (transpose m))\n       (diag m 0 1) (diag m 2 -1)))\n     (to-nums [brd]\n       (mapv (fn [ln] (mapv {:e 0 :x 1 :o -1} ln)) brd)\n     )\n      ]\n    ( {0 nil 1 :x -1 :o}  \n    (apply +  \n      (mapv (fn [ln] (quot (apply + ln) 3))\n        (to-nums (lines brd))\n      )\n    ))\n  )\n)","user":"533ea7e8e4b085b17e897d94"},{"code":"(fn winner [board]\n  (let [triplet-same-fn (fn [row] (when (apply = row) (first row)))\n        col-fn (fn [col-num] (map #(nth % col-num) board))\n        diag-1 (for [x (range 3)]\n                 (nth (nth board x) x))\n        diag-2 (for [x (range 3)]\n                 (nth (nth board x) (- 2 x)))\n        rows board\n        cols (map col-fn (range 3))\n        all-triplets (conj (concat rows cols) diag-1 diag-2)\n        winner-seq (->> all-triplets\n                        (map triplet-same-fn)\n                        (remove #(or (nil? %) (#{:e} %))))]\n    (when (seq winner-seq)\n      (first winner-seq))))","problem":73,"user":"51281b25e4b03a34742b4304"},{"problem":73,"code":"(fn declare-winner [board]\n  (letfn [(row-winner [row]\n                      (cond\n                       (= row [:x :x :x]) :x\n                       (= row [:o :o :o]) :o\n                       :else nil\n                       )\n                      )\n          (col-winners [board] \n                       (let [rotated-board (apply mapv vector board)\n                             col-winners (map row-winner rotated-board)\n                             ]\n                         col-winners\n                         )\n                       )\n          (diag-winners [board]\n                        (let [board-as-seq (flatten board)\n                              top-to-bottom-diag (take 3 (partition 1 4 board-as-seq))\n                              bottom-to-top-diag (take 3 (partition 1 2 (drop 2 board-as-seq)))\n                              diag-as-rows [(flatten top-to-bottom-diag) (flatten bottom-to-top-diag)]\n                              diag-winners (map row-winner diag-as-rows)\n                              ]\n                              diag-winners\n                          )\n                        )\n                      \n          ]\n    \n    (let [winner-of-each-row (map row-winner board)\n          winner-of-each-col (col-winners board)\n          winner-of-diag (diag-winners board)\n          winners (concat winner-of-each-row winner-of-each-col winner-of-diag)\n          winner-or-null-if-tied (reduce #(if (nil? %1) %2 %1) winners)]\n      winner-or-null-if-tied\n      )\n    )\n  )","user":"5394bb65e4b0b51d73faaece"},{"code":"(fn [[r1 r2 r3]] \n      (let [this (filter #(and (not= % #{:e})(= 1 (count %)))(map set [r1 r2 r3 (map first [r1 r2 r3]) \n                (map second [r1 r2 r3]) \n                (map last [r1 r2 r3]) \n                [(first r1) (second r2) (last r3)] \n                [(first r3) (second r2) (last r1)]  ]))]\n        (if (or (= '(:e) (map first this)) (empty? this)) nil (first (map first this)))))","problem":73,"user":"4eb44d78535d7eef30807360"},{"problem":73,"code":"(fn [board]((fn check-win [board eles]\n                      (when (seq eles)\n                        (if (some (fn [line] (every? #(= (first eles) %1) line))\n                                   (concat board\n                                           (map (fn [pos] (map (fn [row] (row pos)) board)) (range (count board)))\n                                           [(reduce (fn [diag row] (conj diag (row (count diag)))) [] board)\n                                            (reduce (fn [diag row] (conj diag (row (- (count row) (count diag) 1)))) [] board)]))\n                          (first eles)\n                          (check-win board (rest eles))))) board [:x :o]))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn who-won [brd]\n  (let\n      [wins [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n             [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]\n             [[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n       \n       get-cell #(get (get brd (second %))\n                      (first %))\n       get-wins (fn [] (map #(map get-cell %) wins))\n       \n       winner #(reduce (fn [a b] (if (= a b) a nil)) %)]\n    (first\n     (filter #(or (= % :x) (= % :o))\n             (map winner (get-wins))))))","problem":73,"user":"4f03818e535dcb61093f6b00"},{"problem":73,"code":"(fn tic-tac-toe [board]\n  (letfn [(checker [triplet]\n            (cond (every? #(= :x %) triplet) :x\n                  (every? #(= :o %) triplet) :o\n                  true nil))]\n    (let [triplets (concat board\n                           (apply (partial map vector) board)\n                           [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\n                            [((board 0) 2) ((board 1) 1) ((board 2) 0)]])]\n      (first (keep checker triplets)))))","user":"5b47874be4b02d533a91bc70"},{"problem":73,"code":"(fn tittactoe [tab]\n  (letfn \n    [(tic \n       [s tablero]\n       (if \n         (empty? tablero) \n         false\n         (let\n           [  [ x & resto] tablero]\n           (if \n             (= x [ s s s])\n             true\n             (tic s resto)))))\n     (diag [[uno dos tres]]\n         [[ (nth uno 0) (nth dos 1)(nth tres 2)]\n          [ (nth uno 2) (nth dos 1) (nth tres 0)]])\n     (transpose [tablero]\n       (apply mapv vector tablero))\n     (big [tablero] \n       (concat \n         tablero\n         (transpose tablero)\n         (diag tablero)))]\n\n    (cond\n      (tic :o (big tab)) :o \n      (tic :x (big tab)) :x\n      :else nil)))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":73,"code":"(fn Win? [board]\n  (letfn [(f [x]\n             (if (apply = x)\n               (let [y (get x 0)]\n                 (if (= y :e)\n                   nil\n                   y))))]\n    (or (reduce #(or %1 %2) (map f board))\n        (reduce #(or %1 %2) (map #(f (vec (map (fn [x] (get x %)) board))) (range 3)))\n        (f (vec (map #(get (get board %) %) (range 3))))\n        (f (vec (map #(get (get board %) (- 2 %)) (range 3))))\n        )))","user":"55f73078e4b06e875b46cea4"},{"problem":73,"code":"(fn [board]\n  (let [\n        same? (fn [xs]\n                (if (= 1 (count (set xs)))\n                  (cond (= :x (first xs)) :x\n                        (= :o (first xs)) :o\n                        :else nil)\n                  nil))\n\n        across-top    (nth board 0)\n        across-middle (nth board 1)\n        across-bottom (nth board 2)\n        down-left     (map #(nth % 0) board)\n        down-middle   (map #(nth % 1) board)\n        down-right    (map #(nth % 2) board)\n        diag1   (vector (nth across-top 0) (nth across-middle 1) (nth across-bottom 2))\n        diag2   (vector (nth across-top 2) (nth across-middle 1) (nth across-bottom 0))]\n\n    (or (same? across-top)\n        (same? across-middle)\n        (same? across-bottom)\n        (same? down-left)\n        (same? down-middle)\n        (same? down-right)\n        (same? diag1)\n        (same? diag2))\n    )\n  )","user":"547cd90ee4b0c51c1f4d72ec"},{"code":"(fn [board]\n   (let [extract (fn [board positions]\n                   (let [board (apply concat board)]\n                     (map #(nth board %) positions)))\n         get-winner (fn [cells]\n                      (let [[[p cnt] & others] (seq (frequencies cells))]\n                        (when (and (= cnt 3)\n                                   (not (= p :e))) p)))]\n     (first\n      (filter identity\n              (for [p [[0 1 2] [3 4 5] [6 7 8]\n                       [0 3 6] [1 4 7] [2 5 8]\n                       [0 4 8] [2 4 6]]]\n                (->> p\n                     (extract board)\n                     (get-winner))))))\n   )","problem":73,"user":"4f2d4d4ce4b0d6649770a058"},{"code":"(fn [board]\n  (let [transpose (fn [m] (apply mapv vector m))\n        rows board\n        cols (transpose board)\n        topLeftDiag [(get (get board 0) 0) (get (get board 1) 1) (get (get board 2) 2)]\n        topRightDiag [(get (get board 0) 2) (get (get board 1) 1) (get (get board 2) 0)]\n        all (concat rows cols [topLeftDiag topRightDiag])]\n    (cond (some #(every? #{:x} %) all) :x\n          (some #(every? #{:o} %) all) :o\n          :else nil)))","problem":73,"user":"50ef77a4e4b0bdaecbb47d99"},{"problem":73,"code":"(fn won? [grid]\n  (let [get (fn [row col] (nth (nth grid row) col))\n        rows grid\n        columns (apply map vector rows)\n        diagonals [(map #(get % %) (range 3)) \n                   (map #(get (- 2 %) %) (range 3))]\n        uniform? #(= 1 (count %))\n        not-empty? #(not= :e %)]\n    (->> (concat rows columns diagonals)\n         (map set)\n         (filter uniform?)\n         (map first)\n         (filter not-empty?)\n         (first))))","user":"5483d59fe4b0e286459a1194"},{"problem":73,"code":"(fn [board]\n  (let [[[x _ a] [_ y _] [b _ z]] board\n        diag1 [x y z] \n        diag2 [a y b]\n        swapped-board (apply map list board)\n        win? (fn [r] \n               (cond \n                (every? #(= :x %) r) :x\n                (every? #(= :o %) r) :o))]\n    (if-let\n        [w (win? diag1)] w\n        (if-let \n            [w (win? diag2)] w\n            (if-let\n                [w (some #{:x :o} (for [row board] (win? row)))] w\n                (if-let\n                    [w (some #{:x :o} (for [row swapped-board] (win? row)))] w\n                    nil))))))","user":"5405ae2be4b0addc1aec6671"},{"code":"(fn tic-tac-toe [board]\n    (let [row-fn (fn [board] board)\n        col-fn (fn [board] (partition 3 (for [x (range 3) y (range 3)]\n                               (get-in board [y x]))))\n        diag-fn (fn [board] (list\n                             (for [x (range 3) y (range 3) :when (= x y)]\n                              (get-in board [y x]))\n                             (map #(get-in board %) [[0 2] [1 1] [2 0]])))]\n       (loop [groups (apply concat (map #(%1 %2)\n                               (vector row-fn col-fn diag-fn) \n                               (repeat board)))]\n            (cond\n             (empty? groups) nil\n             (every? #{:x} (first groups)) :x\n             (every? #{:o} (first groups)) :o\n             :else (recur (rest groups))))))","problem":73,"user":"4feff3b6e4b0678c553fc31e"},{"code":"#(reduce-kv % nil (apply merge-with + \n                            (map hash-map \n                                 (flatten %2) \n                                 [2 3 4 3 4 5 4 5 6])))\n\n#(if (= 0 (rem %3 3)) (#{:x :o} %2) %)","problem":73,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn [rs]\n  (letfn [(transpose [r] (apply map (cons list r)))\n          (diag [r] (map-indexed #(get (vec %2) %) r))\n          (mirrorv [r] (map reverse r))]\n    (->>     (concat rs (transpose rs) [(diag rs)] [(diag (mirrorv rs))])\n             (filter #(not= [:e :e :e] %))\n             (map #(partition-by list %))\n             (filter #(= 1 (count %)))\n             ffirst\n             first\n             )))","problem":73,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn [a]\n  (first (first (filter #(or (= % [:x :x :x]) (= % [:o :o :o])) [\n     (a 0)\n     (a 1)\n     (a 2)\n     [((a 0) 0) ((a 1) 0) ((a 2) 0)]\n     [((a 0) 1) ((a 1) 1) ((a 2) 1)]\n     [((a 0) 2) ((a 1) 2) ((a 2) 2)]\n     [((a 0) 0) ((a 1) 1) ((a 2) 2)]\n     [((a 0) 2) ((a 1) 1) ((a 2) 0)]\n               ]))))","problem":73,"user":"50c8899ee4b00bb60fe0c541"},{"problem":73,"code":"(fn ttt [board]\n  (letfn\n   [(cell\n     [row col]\n     ((board row) col))\n    (group\n     [r0 c0 r1 c1 r2 c2]\n     [(cell r0 c0)\n      (cell r1 c1)\n      (cell r2 c2)])\n    (row\n     [n] (group n 0 n 1 n 2))\n    (column\n     [n] (group 0 n 1 n 2 n))\n    (diag0\n     [] (group 0 0 1 1 2 2))\n    (diag1\n     [] (group 0 2 1 1 2 0))\n    (groupwinner\n     [g]\n     (let [w (g 0)]\n      (if\n        (and\n         (not (= w :e))\n         (= w\n            (g 1)\n            (g 2))) w nil)))\n    (winner [groups]\n     (let [g (first groups)]\n       (when g\n         (let [w\n               (groupwinner g)]\n         (if w\n           w\n           (winner\n            (rest groups)))))))]\n     (println (row 0))\n      (winner\n      (list\n       (row 0)\n       (row 1)\n       (row 2)\n       (column 0)\n       (column 1)\n       (column 2)\n       (diag0)\n       (diag1)))))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn tic [b]\n  (let [possibilities (fn [b] \n                        (let [fr (first b)\n                              sr (second b)\n                              tr (nth b 2)]\n                          [fr sr tr \n                           [(first fr) (first sr) (first tr)] [(second fr) (second sr) (second tr)] [(nth fr 2) (nth sr 2) (nth tr 2)]\n                           [(first fr) (second sr) (nth tr 2)] [(nth fr 2) (second sr) (first tr)]]))]\n    (loop [ps (possibilities b)]\n      (cond \n        (empty? ps) nil\n        (every? #(= % :x) (first ps)) :x\n        (every? #(= % :o) (first ps)) :o\n        :true (recur (rest ps))))))","problem":73,"user":"4f03ebf7535dcb61093f6b7f"},{"code":"(fn [[[a _ b] [_ c _] [d _ e] :as l]]\n    (first\n     (some #{[:x :x :x] [:o :o :o]}\n           (concat l\n                   (apply map (cons list l))\n                   [[a c e] [d c b]]))))","problem":73,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn ttt [board]\n  (let [rows  (partition 3 (for [r (range 3), c (range 3)] [r c]))\n        cols  (partition 3 (for [c (range 3), r (range 3)] [r c]))\n        diags '(([0 0] [1 1] [2 2]) ([0 2] [1 1] [2 0]))\n        winning-pos (concat (concat rows cols) diags)\n        winner? (fn [player] (some identity \n                                  (map #(every? (fn [pos] (= (get-in board pos) player))\n                                                %) \n                                       winning-pos)))]\n    (cond\n      (winner? :x) :x\n      (winner? :o) :o)))","problem":73,"user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn [x]\n  (let [[one two three] x\n        lines [one two three ; horizontal lines\n          (map first x) (map second x) (map #(nth % 2) x) ; vertical lines\n          [(nth one 0) (nth two 1) (nth three 2)]\n          [(nth one 2) (nth two 1) (nth three 0)]]]\n        (cond\n          (some #(= [:x :x :x] %) lines) :x\n          (some #(= [:o :o :o] %) lines) :o\n          :else nil)))","problem":73,"user":"515828b8e4b0a069fd272c71"},{"problem":73,"code":"(letfn [(is-player [tic]\n          (some #(= tic %) [:x :o]))\n        (get-winner [sec]\n          (let [tic (first sec)\n                winner (and (apply = sec) (is-player tic))]\n            (if winner tic nil)))\n        (board-cols [board]\n          (apply map vector board))\n        (board-diag [board] \n          [(map-indexed (fn [i v] (v i)) board)])]\n  (fn [board]\n    (let [board-secs\n            (reduce concat \n              ((juxt identity board-cols board-diag #(board-diag (reverse %))) board))]\n      (first \n        (filter is-player \n          (map get-winner board-secs))))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":73,"code":"(fn [board]\n    (let [rows board\n          cols (map (fn [i] (map #(get % i) board)) [0 1 2])\n          diag [(map #(get (get board %) %) [0 1 2])\n                (map #(get (get board %) (Math/abs (- % 2))) [0 1 2])]\n          check (fn [k l] (some (fn [x] (every? #(= % k) x)) l))]\n      (cond\n        (or (check :x rows) (check :x cols) (check :x diag)) :x\n        (or (check :o rows) (check :o cols) (check :o diag)) :o\n        :default nil)))","user":"5a9d64c8e4b0d174b936c7eb"},{"code":"(fn [board]\r\n  (let [\r\n    diags (fn [b] (split-at 3 (map #(nth (flatten b) %) '(0 4 8 2 4 6))))\r\n    verts (fn [b] (apply map list b))\r\n    combos (concat board (diags board) (verts board))\r\n    filter-s (filter #(= (count %) 1) (map distinct combos))\r\n    filter-e (filter #(not= (first %) :e) filter-s)\r\n    ]\r\n    (ffirst filter-e)))","problem":73,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn [b] \n  (let \n    [dims [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n     board (vec (flatten b))\n     values (map #(map board %) dims)]\n    (ffirst (filter #(and (apply = %) (apply not= :e %)) values))))","problem":73,"user":"500aa15ee4b03d00572d2d76"},{"problem":73,"code":"(fn [board]\n  (let [rows board\n        cols (apply map list board)\n        diags [[(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2]) ]\n               [(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])]]\n        slices (concat rows cols diags)\n        three-in-row?\n        (fn [row]\n\t\t  (cond\n\t\t    (every? #(= % :x) row) :x\n\t\t    (every? #(= % :o) row) :o\n\t\t    :else nil))]\n    (some three-in-row? slices)))","user":"4fe49706e4b0e8f79898feb7"},{"code":"(fn __ [v]\n  (let [wins [[0 3 6] [1 4 7] [2 5 8] ; x-axis\n              [0 1 2] [3 4 5] [6 7 8] ; y-axis\n              [0 4 8] [2 4 6]]        ; diags\n        moves #(map first (filter (fn [[i x]] (= x %)) \n                                  (map-indexed vector (flatten v))))\n        wins? (fn [player] (some #(= (moves player) %) wins))]\n       (if (wins? :x) :x\n         (if (wins? :o) :o))))","problem":73,"user":"4ec9549d535d6d7199dd36fe"},{"problem":73,"code":"(fn winner [b] (cond (and (not= ((b 0) 0) :e) (or  (= ((b 0) 0) ((b 0) 1) ((b 0) 2)) (= ((b 0) 0) ((b 1) 0) ((b 2) 0)) (= ((b 0) 0) ((b 1) 1) ((b 2) 2)))) ((b 0) 0) (and (not= ((b 0) 1) :e) (= ((b 0) 1) ((b 1) 1) ((b 2) 1))) ((b 0) 1) (and (not= ((b 0) 2) :e) (= ((b 0) 2) ((b 1) 2) ((b 2) 2))) ((b 0) 2) (and (not= ((b 0) 2) :e) (= ((b 0) 2) ((b 1) 1) ((b 2) 0))) ((b 0) 2) (and (not= ((b 1) 0) :e) (= ((b 1) 0) ((b 1) 1) ((b 1) 2))) ((b 1) 0) (and (not= ((b 2) 0) :e) (= ((b 2) 0) ((b 2) 1) ((b 2) 2))) ((b 2) 0) :else nil))","user":"5646dff3e4b0284900eef615"},{"problem":73,"code":"(fn [state]\n  (let [stateVecs (vector\n                    (nth state 0)\n                    (nth state 1)\n                    (nth state 2)\n                    (vector\n                      (nth (nth state 0) 0)\n                      (nth (nth state 1) 1)\n                      (nth (nth state 2) 2))\n                    (vector\n                      (nth (nth state 0) 2)\n                      (nth (nth state 1) 1)\n                      (nth (nth state 2) 0))\n                    (vector\n                      (nth (nth state 0) 0)\n                      (nth (nth state 1) 0)\n                      (nth (nth state 2) 0))\n                    (vector\n                      (nth (nth state 0) 1)\n                      (nth (nth state 1) 1)\n                      (nth (nth state 2) 1))\n                    (vector\n                      (nth (nth state 0) 2)\n                      (nth (nth state 1) 2)\n                      (nth (nth state 2) 2)))]\n    (loop [vecs stateVecs]\n      (if (= (vector :o :o :o) (first vecs))\n        :o\n      (if (= (vector :x :x :x) (first vecs))\n        :x\n      (if (empty? vecs) \n        nil \n        (recur (subvec vecs 1))))))))","user":"51fea7d7e4b0f1313d468a74"},{"code":"(fn [grid]\n  (letfn [(cols [grid]\n                [(map #(nth % 0) grid)\n                 (map #(nth % 1) grid)\n                 (map #(nth % 2) grid)])\n          (diag [grid]\n                [[\n                  (nth (nth grid 0) 0)\n                  (nth (nth grid 1) 1)\n                  (nth (nth grid 2) 2)]\n                 [\n                  (nth (nth grid 2) 0)\n                  (nth (nth grid 1) 1)\n                  (nth (nth grid 0) 2)]])\n          (won-row [who, row]\n                   (if (every? (partial = who) row)\n                     who\n                     nil))\n          (won [rows]\n               (some #(or (won-row :x %) (won-row :o %)) rows))]\n  (or\n   (won grid)\n   (won (cols grid))\n   (won (diag grid)))))","problem":73,"user":"51365524e4b04ac1f358dd52"},{"problem":73,"code":"(fn [game]\n    (let [rows (count game)\n          winning-moves\n          (cons\n           (map #(nth (nth game %) %) (range rows))\n           (cons\n            (map #(nth (nth game %) (- rows 1 %)) (range rows))\n            (concat game (apply (partial map vector) game))))\n          all-winners (distinct (remove #(= :e %) (map first (filter #(apply = %) winning-moves))))]\n      (cond \n       (= all-winners '(:x)) :x\n       (= all-winners '(:o)) :o\n       :else nil)))","user":"5531e445e4b09218d5f44f76"},{"problem":73,"code":"(fn tic-tac-toe [b]\n  (letfn [(rev [rows]\n    (map (fn [i] (map (fn [r] (nth r i)) rows))\n      (range (count rows))))\n      (diagonal [rows]\n        (map (fn [i] (nth (nth rows i) i)) (range (count rows))))\n      (wins? [p row] (= (count row) (count (filter #(= % p) row))))]\n        (->> [b (rev b) [(diagonal b) (diagonal (reverse b))]]\n             (reduce concat)\n             (map (fn [x]\n                    (cond (wins? :x x) :x\n                          (wins? :o x) :o\n                          :else :e)))\n             (filter #(not= % :e))\n             first)))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":73,"code":"(fn [[[a b c][d e f][g h i]]]\n    (let [p [a b c d e f\n             g h i a d g\n             b e h c f i\n             a e i c e g]]\n        (->>\n            p\n            (partition 3)\n            (filter #(apply = %))\n            (ffirst)\n            (#{:x :o}))))","user":"5a01d8f6e4b01bb0ae8afd53"},{"problem":73,"code":"(fn f [board]\n  (let [check-win? (fn [col]\n                     (let [s (set col)]\n                       (if (and (= 1 (count s)) (not= (first s) :e)) (first s) nil)))\n\n        get-diagonal (fn [rows] (reduce (fn [diag row]\n                                          (conj diag (get row (count diag)))) [] rows))\n        rows board\n        cols (partition 3 (apply interleave board))\n        diagonals (vector (get-diagonal board) (get-diagonal (reverse board)))]\n\n    (->> [rows cols diagonals]\n         (mapcat (fn [col] (map check-win? col)))\n         (remove nil?)\n         (first))))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn [g]\n  (letfn \n    [(lines [grid]\n      (concat\n        grid\n        (apply map list grid)\n        (list (map nth grid (range 0 3)))\n        (list (map nth (reverse grid) (range 0 3)))))]\n   (let [eqlins (->> (lines g)\n                     (filter (partial apply =))\n                     (map first))]\n     (reduce (fn [v1 v2] (cond (= v2 :o) :o\n                               (= v2 :x) :x\n                               :else v1))\n            nil eqlins))))","problem":73,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":73,"code":"(fn [board]\n  (let [diag1 (juxt #((% 0) 0)\n                    #((% 1) 1)\n                    #((% 2) 2))\n\n        diag2 (juxt #((% 2) 0)\n                    #((% 1) 1)\n                    #((% 0) 2))\n\n        col (fn [n] (juxt #((% 0) n)\n                          #((% 1) n)\n                          #((% 2) n)))\n        row (fn [n] #(% n))]\n\n    (first\n     (filter #(or (= % :x)\n                  (= % :o))\n             (map (fn [winner]\n                    (->> winner\n                         (set)\n                         (first)))\n                  (filter (fn [line]\n                            (->> line\n                                 (set)\n                                 (count)\n                                 (= 1)))\n                          ((juxt diag1 diag2 (col 0) (col 1) (col 2) (row 0) (row 1) (row 2))\n                           board)))))))","user":"605f5c69e4b03746e80ebf5e"},{"code":"(fn [tct] \n           (let [t (concat \n                    tct\n                    (map (fn [c] (map #(nth % c) tct)) (range 0 3))\n                    [(reduce #(conj %1 (nth %2 (count %1))) [] tct)]\n                    [(reduce #(conj %1 (nth %2 (dec (- (count %2) (count %1))))) [] tct)])\n                g (fn [s] (some (fn [e] (every? #(= s %) e)) t))]\n                (cond\n                  (g :x) :x\n                  (g :o) :o\n                  :default nil)))","problem":73,"user":"4f34eb87e4b0e243712b1eba"},{"problem":73,"code":"(fn [board]\n  (let [board (reduce #(into % %2) board)]\n    (loop [symbols [:x :o]]\n       (let [el (first symbols)\n             els (map first (filter #(= (second %) el)\n                          (map-indexed vector board)))]\n         (when el\n            (if (and (= (count els) 3)\n                     (= (- (last els) (second els)) (- (second els) (first els))))\n               el\n               (recur (next symbols))))))))","user":"52f53589e4b05e3f0be25f2c"},{"code":"(fn p73 [board]\n  (let [indexes [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n  all-rows (concat board\n\t\t\t (map (fn [col]\n\t\t\t\t(map (fn [row idx] (nth row idx)) board col)) indexes))]\n    (some (fn [row] (and (apply = row)\n\t\t\t (#{:o :x} (first row))))\n\t  all-rows)))","problem":73,"user":"4e513ecf535dc968683fc4f6"},{"code":"(fn won? [board]\n  (let [reversed-board (partition 3 (apply interleave board))\n        all-x [:x :x :x]\n        all-o [:o :o :o]]\n    (letfn [(check-rows [board]\n              (let [b (set board)]\n                (cond\n                 (contains? b all-x) :x\n                 (contains? b all-o) :o\n                 :else nil)))\n\n            (check-cross [board]\n              (let [catb (apply concat board)\n                    bakslash [(first catb) (nth catb 4) (last catb)]\n                    fwdslash [(nth catb 2) (nth catb 4) (nth catb 6)]]\n                (cond\n                 (or (= fwdslash all-x) (= bakslash all-x)) :x\n                 (or (= bakslash all-o) (= fwdslash all-o)) :o\n                 :else nil)))]\n\n      (cond\n       (check-rows board) (check-rows board)\n       (check-rows reversed-board) (check-rows reversed-board)\n       (check-cross board) (check-cross board)\n       :else nil)))\n  )","problem":73,"user":"4e3bccb1535deb9a81d77f55"},{"problem":73,"code":"(fn [b]\n        (let [s [(b 0) (b 1) (b 2) (map first b) (map second b) (map last b)\n                 [(first (b 0)) (second (b 1)) (last (b 2))]\n                 [(last (b 0)) (second (b 1)) (first (b 2))]]]\n          (cond\n            (some #(= [:x :x :x] %) s) :x\n            (some #(= [:o :o :o] %) s) :o\n            :else nil)))","user":"546c4377e4b00cfc9eacc177"},{"code":"(fn f [board] \n (let [l [[0 0] [0 1] [0 2]\n        [1 0] [1 1] [1 2]\n\t\t  [2 0] [2 1] [2 2]\n\t\t  [0 0] [1 0] [2 0]\n\t\t  [0 1] [1 1] [2 1]\n\t\t  [0 2] [1 2] [2 2]\n\t\t  [0 0] [1 1] [2 2]\n\t\t  [0 2] [1 1] [2 0]]]\n\n\t((reduce (fn [x y]\n\t\t(let [ans (merge-with + x {y 1} {:count 1})]\n\t\t\t;(prn ans)\n\t\t\t(if (= (ans :count) 3) \n\t\t\t\t(cond (= (ans :o) 3) (assoc ans :win :o :x 0 :o 0 :count 0)\n\t\t\t\t\t(= (ans :x) 3) (assoc ans :win :x :x 0 :o 0 :count 0) \n\t\t\t\t\t:else (assoc ans :x 0 :o 0 :count 0)\n\t\t\t\t)\n\t\t\t\tans\n\t\t\t)\n\t\t)\n\t) {:win nil} (map (fn [x]\n\t\t(nth (nth board (first x)) (second x))\n\t) l)) :win)\n )\n)","problem":73,"user":"4f7b6b90e4b06e829148e1a4"},{"code":"(fn board-state [board]                  ;; will do any size\n  (let [size (-> board first count)\n        len (range (* size size))\n        b (flatten board)\n        rows (partition size len)\n        columns (vals (group-by #(rem % size) len))\n        diagonals (butlast (reduce (fn [[d1 d2 i] row] \n                                     [(conj d1 (nth row i)) \n                                      (conj d2 (nth row (- (- size 1) i))) \n                                      (inc i)]) \n                                   [[] [] 0] rows))]\n    (some #(let [row (distinct (map (fn [i] (nth b i)) %))] \n             (let [[win? & r] row]\n               (if-not r\n                 (case win?\n                   :x :x\n                   :o :o\n                   false)))) (concat rows columns diagonals))))","problem":73,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(fn [m]\n    (let [cols  (fn [m] (into [] (for [y (range 3)] (into [] (for [x (range 3)] (get (get m x) y)))))),\n          rows  (fn [m] (into [] (for [y (range 3)] (into [] (get m y))))),\n          diags (fn [m] (vector [((m 0) 0) ((m 1) 1) ((m 2) 2)], [((m 0) 2) ((m 1) 1) ((m 2) 0)])),\n          seq-contains? (fn [sequence item]\n                          (if (empty? sequence)\n                            false\n                            (reduce #(or %1 %2) (map #(= %1 item) sequence))))\n          v (concat (cols m) (rows m) (diags m))]\n      (cond\n        (seq-contains? v [:x :x :x]) :x\n        (seq-contains? v [:o :o :o]) :o\n        :else nil)))","problem":73,"user":"4f038567535dcb61093f6b0c"},{"code":"(fn [board]\n    (letfn [(all-same [[x y z]]\n              (when (and (= x y z) (not= x :e))\n                x))\n            (transpose [coll]\n              (apply map list coll))\n            (reverse-transpose [coll]\n              (apply map list (map reverse coll)))\n            (diagonal [coll]\n              (map-indexed (fn [idx xs]\n                             ((vec xs) idx))\n                           coll))]\n      (some #{:x :o} (concat (keep all-same board)\n                             (keep all-same (transpose board))\n                             (list (all-same (diagonal board)))\n                             (list (all-same (-> (reverse-transpose board) diagonal)))))))","problem":73,"user":"4dc0ff08535d020aff1edf84"},{"code":"#(let [p (concat % (apply map list %) \n           [(map nth % (range)) (map nth (map reverse %) (range))])]\n  (first (some #{[:x :x :x] [:o :o :o]} p)))","problem":73,"user":"4fb1d907e4b081705acca282"},{"code":"(fn [[row-one row-two row-three]]\n  (cond\n    ;; diagonal cases\n    (= [(first row-one) (second row-two) (last row-three)] [:x :x :x]) :x\n    (= [(first row-one) (second row-two) (last row-three)] [:o :o :o]) :o\n    (= [(first row-three) (second row-two) (last row-one)] [:x :x :x]) :x\n    (= [(first row-three) (second row-two) (last row-one)] [:o :o :o]) :o\n    ;; horizontal cases\n    (= row-one   [:x :x :x]) :x\n    (= row-two   [:x :x :x]) :x\n    (= row-three [:x :x :x]) :x\n    (= row-one   [:o :o :o]) :o\n    (= row-two   [:o :o :o]) :o\n    (= row-three [:o :o :o]) :o\n    ;; vertical cases\n    (= [(first row-one) (first row-two) (first row-three)] [:x :x :x]) :x\n    (= [(first row-one) (first row-two) (first row-three)] [:o :o :o]) :o\n    (= [(second row-one) (second row-two) (second row-three)] [:x :x :x]) :x\n    (= [(second row-one) (second row-two) (second row-three)] [:o :o :o]) :o\n    (= [(last row-one) (last row-two) (last row-three)] [:x :x :x]) :x\n    (= [(last row-one) (last row-two) (last row-three)] [:o :o :o]) :o))","problem":73,"user":"5030b820e4b05b7df5a0b849"},{"problem":73,"code":"(fn find-winner\n  [board]\n  (let [triplets ((fn get-triplets\n  [board]\n  (let [flat-board (->> board (flatten) (apply vector))]\n    (map (partial apply vector)\n         (conj board\n               (->> flat-board (take-nth 3))\n               (->> flat-board (drop 1) (take-nth 3))\n               (->> flat-board (drop 2) (take-nth 3))\n               (->> flat-board (take-nth 4))\n               (->> flat-board (drop 2) (drop-last 2) (take-nth 2)))))) board)]\n    (first (some (fn get-winner\n  [triplet]\n  (if (and (not= (first triplet) :e) (apply = triplet))\n      triplet\n      nil)) triplets))))","user":"597f8c93e4b0dbe32238d0c1"},{"problem":73,"code":"(fn [tab] \n  (let [axes [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]] f_tab (flatten tab)]\n   (->> axes\n       (map (fn [axis] (->> axis\n                            (map #(nth f_tab %))\n                            set\n                       )))\n       (filter #(= 1 (count %) ) )\n       (filter #(not= #{:e} %) )\n       first\n       first\n   )\n  )\n)","user":"55e8a85be4b0121d4835fd98"},{"problem":73,"code":"(fn [board]\n    (cond\n      (seq (filter #(every? #{:x} %) board)) :x\n      (seq (filter #(every? #{:o} %) board)) :o\n\n      (->> (map first board) (every? #{:x})) :x\n      (->> (map first board) (every? #{:o})) :o\n\n      (->> (map last board) (every? #{:x})) :x\n      (->> (map last board) (every? #{:o})) :o\n\n      (->> (map (comp first rest) board) (every? #{:x})) :x\n      (->> (map (comp first rest) board) (every? #{:o})) :o\n\n      (every? #{:x} ((juxt (comp first first) (comp second second) (comp last last)) board)) :x\n      (every? #{:o} ((juxt (comp first first) (comp second second) (comp last last)) board)) :o\n\n      (every? #{:o} ((juxt (comp last first) (comp second second) (comp first last)) board)) :o\n      (every? #{:x} ((juxt (comp last first) (comp second second) (comp first last)) board)) :x\n\n      :else nil))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn tic-tac-toe [board]\n  (let [clean-output (fn clean-output [s]\n                       (reduce (fn [a b]\n                                 (or a b)) s))\n        eval-row (fn eval-row [row]\n                   (if (and (= 1 (count (set row)))\n                            (not (= :e (first row))))\n                     (first row)\n                     nil))\n        check-horizontal (fn check-horizontal [board]\n                           (map\n                             eval-row\n                             board))\n        check-vertical (fn check-vertical [board]\n                         (map\n                           (fn [a b c]\n                             (eval-row (list a b c)))\n                           (first board)\n                           (second board)\n                           (last board)))\n        check-diagonal (fn check-diagonal [board]\n                         (map\n                           eval-row\n                           [[(ffirst board)\n                             (second (second board))\n                             (last (last board))]\n                            [(last (first board))\n                             (second (second board))\n                             (first (last board))]]))]\n        (or\n          (clean-output (flatten (list\n                                   (check-horizontal board)\n                                   (check-vertical board)\n                                   (check-diagonal board)))))))","problem":73,"user":"51db0d99e4b06aa4d4669a9d"},{"problem":73,"code":"(fn tictac [board]\n  (let [play (fn play [board player]\n               (cond\n                 ;up-down\n                 (reduce #(and %1 (= player (%2 0))) true board) player\n                 (reduce #(and %1 (= player (%2 1))) true board) player\n                 (reduce #(and %1 (= player (%2 2))) true board) player\n                 ;left-right\n                 (reduce (fn [prev line] (or prev (reduce #(and %1 (= player %2)) true line))) false board) player\n                 ;diag\n                 (or\n                   (and\n                     (= player ((board 0) 0))\n                     (= player ((board 1) 1))\n                     (= player ((board 2) 2)))\n                   (and\n                     (= player ((board 0) 2))\n                     (= player ((board 1) 1))\n                     (= player ((board 2) 0)))) player\n                 :else nil))]\n    (or (play board :x) (play board :o))))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":73,"code":"(fn [board]\n    ;;check horizontals\n    (let [res (some #(if (and (not (= :e (first %))) (= (first %) (second %) (last %))) (first %) nil) board)]\n      (if res\n        res\n        (let [res2 (and (not (= :e (first (get board 0)))) (= (first (get board 0)) (second (get board 1)) (last (get board 2))))\n              res3 (and (not (= :e (first (get board 0)))) (= (first (get board 2)) (second (get board 1)) (last (get board 0))))]\n          (if res2\n            (first (get board 0))\n            (if res3\n              (first (get board 2))\n\n\n              ;;Check virtcals\n              (let [res4 (loop\n                              [col1 (get board 0)\n                               col2 (get board 1)\n                               col3 (get board 2)]\n                            (if (not (empty? col1))\n                              (if (and (not (= :e (first col1))) (= (first col1) (first col2) (first col3)))\n                                (first col1)\n                                (recur (rest col1) (rest col2) (rest col3)))\n                              nil))]\n                (if res4\n                  res4\n                  nil)\n                )))))))","user":"586afe7be4b0f14aab7c88ca"},{"code":"(fn [M b]\n  (let [c (partition 3 (apply interleave b))\n        d-f #(M nth % (range))\n        s (concat b c [(d-f b) (d-f (M reverse b))])]\n    (ffirst (filter #{#{:x} #{:o}} (M set s)))))\nmap","problem":73,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn [b]\n  (let [elem-at (fn [b c y x] \n                  (let [e (get (get b y) x)] \n                    (if (= e c) true false)))\n        score (fn [b c] \n                (apply + \n                       (for [y (range 1 4) x (range 1 4)]\n                         (* (+ x (int (Math/pow 3 y))) \n                            (if (elem-at b c (dec y) (dec x)) 1 0)))))\n        win #{ 15 33 42 45 48 87 }\n        sx (score b :x)\n        so (score b :o)]\n    (println sx)\n    (println so)\n    (cond (contains? win sx) :x\n          (contains? win so) :o\n          :else nil)))","problem":73,"user":"4ed286d4535d44c135fd68d7"},{"code":"#(let [x (set \n (concat \n  %\n  (apply map vector %)\n  [[(get-in % [0 0]) (get-in % [1 1]) (get-in % [2 2])]]\n  [[(get-in % [0 2]) (get-in % [1 1]) (get-in % [2 0])]]\n ))]\n  (if (x [:x :x :x]) :x (when (x [:o :o :o]) :o)))","problem":73,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [board]\n   (let [columns (apply map vector board)\n         get-diagonal (fn [board] (for [n (range 3)]\n                                   (nth (nth board n) n)))\n         mirrored (map reverse board)\n         diagonals (map get-diagonal [board mirrored])\n         all (concat board columns diagonals)\n         row-win (fn [row]\n                   (let [pieces (distinct row)]\n                     (when (and\n                            (= 1 (count pieces))\n                            (not= :e (first pieces)))\n                       (first pieces))))]\n     (some row-win all)))","problem":73,"user":"524f213be4b0541d1855b7ff"},{"problem":73,"code":"(fn [[r1 r2 r3]]\n  (letfn\n\t[(row-eq? [r] (apply = r))\n     (col-eq? [n r1 r2 r3] (= (get r1 n) (get r2 n) (get r3 n)))\n     (diag-eq? [r1 r2 r3] (= (get r1 0) (get r2 1) (get r3 2)))]\n    (let [winner\n               (cond\n                (row-eq? r1) (get r1 0)\n     \t\t\t(row-eq? r2) (get r2 0)\n     \t\t\t(row-eq? r3) (get r3 0)\n     \t\t\t(col-eq? 0 r1 r2 r3) (get r1 0)\n     \t\t\t(col-eq? 1 r1 r2 r3) (get r1 1)\n     \t\t\t(col-eq? 2 r1 r2 r3) (get r1 2)\n     \t\t\t(diag-eq? r1 r2 r3) (get r1 0)\n     \t\t\t(diag-eq? r3 r2 r1) (get r3 0)\n          \t\t:else nil)]\n      (if (= winner :e) nil winner))))","user":"5514a60fe4b055c2f668d4d7"},{"problem":73,"code":"(fn [board]\n  (letfn [(col-win [board]\n            (first (filter #(apply = %)\n                           (remove #(every? #{:e} %)\n                                   board))))\n          (diag-win [board]\n            (let [row (map-indexed (fn [i row]\n                                     (nth row i))\n                                   board)]\n              (when (and (apply = row)\n                         (not= :e (first row)))\n                row)))]\n    (first (apply (some-fn col-win diag-win)\n                  [board\n                   (apply map vector board)\n                   (map reverse board)]))))","user":"510528a0e4b0730a5f55ad85"},{"problem":73,"code":"(fn[board]\n\t(let [legalRows [[0 1 2][3 4 5][6 7 8][0 3 6][1 4 7][2 5 8][0 4 8][2 4 6]]\n\t      mapping  {:e 0 :o 1 :x 4}\n              reverseMapping {12 :x 3 :o 0 nil}\n              flatBoard (map (fn [x] (x mapping)) (flatten board))\n              rowState (map (fn [x] (apply + (map (fn [i] (nth flatBoard i)) x ) )) legalRows )]\n          (reverseMapping(first (filter #(or (= % 3) (= % 12)) rowState)) )\n          ))","user":"54d2b411e4b0e8a36923e5f9"},{"code":"(fn goo [tic]\n  (let \n    [combos (conj\n              tic\n              (map #(% 0) tic)\n              (map #(% 1) tic)\n              (map #(% 2) tic)\n              (map-indexed (fn [index item] (item index)) tic)\n              (map-indexed (fn [index item] (item index)) (reverse tic)))]\n            \n            (ffirst (filter (fn [xs] (and (not-any? #(= :e %) xs) \n                                  (apply = xs)))\n                    combos))))","problem":73,"user":"50217818e4b00bba4502f7a7"},{"problem":73,"code":"(fn [tic-tac-toe] \n(let [getij (fn [board i j] \n                (-> board\n                  (get i)\n                  (get j))),\n      board-map (into {} (for [i (range 3)\n               j (range 3)]\n                      [[i j] (getij tic-tac-toe i j)])),\n\n      find-winner (fn [winning-set]\n                    (let [set-res (map #(board-map %) winning-set)\n                          is-same (apply = set-res)]\n                      (if is-same\n                        (first set-res)\n                        nil))),\n      winning-sets\n        #{#{[0 0] [0 1] [0 2]}\n          #{[1 0] [1 1] [1 2]}\n          #{[2 0] [2 1] [2 2]}\n          #{[0 0] [1 1] [2 2]}\n          #{[2 0] [1 1] [0 2]}\n          #{[0 0] [1 0] [2 0]}\n          #{[0 1] [1 1] [2 1]}\n          #{[0 2] [1 2] [2 2]}}, \n       win (first (filter #(not (nil? %)) (map find-winner winning-sets)))]\n  (if (or (= win :x) (= win :o)) \n    win \n    nil)))","user":"5783a897e4b0ebec4cfb74b9"},{"code":"(fn [board]\n  (letfn [(get-inds [sym]\n      (letfn [(get-sym [row col] (nth (nth board row) col))\n              (gen-ind [row col] (+ (* 10 row) col))\n              (get-inds* [row col acc]\n                (if (= row 3)\n                  acc\n                  (if (= col 3)\n                  (recur (inc row) 0 acc)\n                  (if (= sym (get-sym row col))\n                    (recur row (inc col) (conj acc (gen-ind row col)))\n                    (recur row (inc col) acc)))))]\n        (get-inds* 0 0 [])))\n      (won? [inds]\n        (letfn [(has-seq? \n                  ([start step repeats]\n                    (if (= 1 repeats)\n                      true\n                      (let [new-s (+ start step)]\n                        (if (some #{new-s} inds)\n                          (recur new-s step (dec repeats))\n                          false))))\n                  ([step repeats]\n                    (some #{true} (map #(has-seq? % step repeats) inds))))]\n          (or (has-seq? 1 3) (has-seq? 9 3) (has-seq? 10 3) (has-seq? 11 3))))]\n    (cond\n      (won? (get-inds :x)) :x\n      (won? (get-inds :o)) :o\n      :else nil)))","problem":73,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":73,"code":"(fn [xs]\n  (let [win [[0 1 2] [0 3 6] [0 4 8] [1 4 7] [2 5 8] [3 4 5] [6 7 8] [6 4 2]]\n        res (->>\n          (zipmap (range 9) (apply concat xs))\n          (group-by val)\n          (reduce-kv #(conj % {%2 (into #{} (map first %3))}) {})\n          (reduce-kv (fn [a k v]\n                     (conj a {k (some true? (map #(clojure.set/subset? %  v) win))}))\n                   {}))\n        ]\n    (cond\n      (res :x) :x\n      (res :o) :o\n      :else nil)))","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn [board]\n  (let [\n\t  columns (apply map vector board)\n\t  diagonals (let [[[c11 _ c13] [_ c22 _] [c31 _ c33]] board] [[c11 c22 c33] [c13 c22 c31]])\n\t  triples (concat board columns diagonals)\n\t  win? (fn [p coll] (every? #{p} coll))\n\t  win-x? (partial win? :x)\n\t  win-o? (partial win? :o)]\n\t  (first (for [t triples :when (or (win-x? t) (win-o? t))] (first t)))))","problem":73,"user":"4ded27db535d08e6dec9fe0a"},{"problem":73,"code":"(fn [b]\n  (let [b' (apply mapv vector b)\n        testn (fn [[v1 & vs]] (when (and (not= :e v1) (apply = v1 vs)) v1))\n        d1 (fn [b] (map #(get-in b [% %]) (range (count b))))\n        d2 (fn [b] (map #(get-in b [% (- (dec (count b)) %)]) (range (count b))))\n        ts (concat [(d1 b) (d2 b)] b b')]\n    (some testn ts)))","user":"53ea5307e4b036ad0777e4e2"},{"problem":73,"code":"(fn [v] (some identity\n\n                    (map #(cond\n                            (apply = (conj % :x)) :x\n                            (apply = (conj % :o)) :o\n                            )\n                         (concat\n                           v\n                           (apply map vector v)\n                           (vector (for [x (range 3)] (nth (nth v x) x)))            ;; ez miert nem vektor hanem lista?\n                           (vector (for [x (range 3)] (nth (nth v (- 2 x)) x)))\n                           )\n                         )\n                    )\n        )","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":73,"code":"(fn [rows]\n  (let [check (fn [rows type]\n                (some true? ;rows or columns\n                  (list\n                    (some true? ;columns\n                      (map \n                        (fn [row]\n                          (every? true? (map #(= % type) row)))\n                        (apply (partial map vector) rows))) \n                    (some true? ;rows\n                      (map \n                        (fn [row]\n                          (every? true? (map #(= % type) row)))\n                        rows))\n                    (every? true? (map #(= % type) ; diag\n                                    ((fn [grid]\n                                       (map (fn [i] (nth (nth grid i) i)) (range 3))) rows)))\n                    (every? true? (map #(= % type) ; diag\n                                    ((fn [grid]\n                                       (map (fn [i] (nth (nth grid i) (- 2 i))) (range 3))) rows))))))]\n    (cond \n      (check rows :x) :x\n      (check rows :o) :o\n      :else nil)))","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":73,"code":"(fn [matrix] (let [masks [[[1 1] [-1 -1]]\n                         [[1 -1] [-1 1]]\n                         [[0 1] [0 -1]]\n                         [[1 0][-1 0]]]\n                    test-points [[0 0] [1 1] [2 2]]\n                    good-point? (fn [point] (not-any? #(or (< % 0) (> % 2)) point))\n                    get-siblings (fn [point mask] (take-while good-point? (iterate #(map + % mask) point)))\n                    get-lines (fn [co] (filter (fn [o] (> (count o) 2)) (map #(set (reduce (fn [r c] (concat r (get-siblings co c))) [] %)) masks)))\n                    all-lines (seq (set (reduce #(concat % (get-lines %2)) []  test-points)))]\n  (some (fn [cords] (let [entries (map #(get-in matrix %) cords)\n                          first-elem (first entries)]\n                      (if (and (not= first-elem :e) (every? #(= first-elem %) entries))\n                        first-elem nil))) all-lines)))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"(fn [b]\n  (let [w #(if (= :e %) nil %)\n        [x y z] [(nth (nth b 0) 0) (nth (nth b 1) 1) (nth (nth b 2) 2)]\n        [p q r] [(w x) (w y) (w z)]]\n    (cond (and (apply = (nth b 0)) p) p\n          (and (apply = (nth b 1)) q) q\n          (and (apply = (nth b 2)) r) r\n          (and (apply = (map #(nth % 0) b)) p) p\n          (and (apply = (map #(nth % 1) b)) q) q\n          (and (apply = (map #(nth % 2) b)) r) r\n          (and (= x y z) q) q\n          (and (= (nth (nth b 0) 2) y (nth (nth b 2) 0)) q) q\n          :else nil)))","problem":73,"user":"51da631be4b02ceefd947766"},{"problem":73,"code":"(fn match-finder [board]\n  (let [master-match-list\n                  [[[0 0][0 1][0 2]]\n                   [[1 0][1 1][1 2]]\n                   [[2 0][2 1][2 2]]\n                  \n                   [[0 0][1 0][2 0]]\n                   [[0 1][1 1][2 1]]\n                   [[0 2][1 2][2 2]]\n                  \n                   [[0 0][1 1][2 2]]\n                   [[2 0][1 1][0 2]]]\n        get-match (fn [d]\n                    (let [[a b c] d\n                          xo-row         (map #(get-in board %) [a b c])\n                          xo-row-no-e    (filter #(not= :e %) xo-row)\n                          xo-row-count   (count xo-row-no-e)\n                          xo-row-count-d (count (distinct xo-row-no-e))]\n                      (if (= [xo-row-count xo-row-count-d] [3 1]) (first xo-row-no-e) nil)))]\n    (loop [match-list master-match-list]\n      (let [f (first match-list)]\n        (if (nil? f) nil\n         (let [match (get-match f)]\n           (if (nil? match) (recur (rest match-list)) match)))))))","user":"5546704be4b0a04f7929953d"},{"code":"(fn [xs]\n    (let\n      [diag\n        (fn [a] (map (fn [b n] (b n)) a (range)))\n        rs\n        (concat\n          xs\n          (apply (partial map vector) xs)\n          [(diag xs)]\n          [(diag (reverse xs))])\n      ]\n        (some\n          #(or (when (apply = :x %) :x) (when (apply = :o %) :o))\n          rs)))","problem":73,"user":"50427899e4b0add3005c0fc2"},{"code":"(fn [[a b c]] (let [r (into [a b c [(first a) (second b) (last c)] [(first c) (second b) (last a)]] (map vector a b c)) win? (fn [[x & r]] (when (and (apply = x r) (not (= x :e))) x))] (some win? r)))","problem":73,"user":"4f171e7d535d64f603146452"},{"problem":73,"code":"(fn tic-tac-toe-winner [board]\n  (let [rows board\n        cols (apply map vector board)\n        main-diag (map #(get-in board [% %]) (range 3))\n        side-diag (map #(get-in board [% (- 2 %)]) (range 3))\n        seqs-to-check (concat rows cols [main-diag] [side-diag])]\n    (cond\n      (some (partial = [:o :o :o]) seqs-to-check) :o\n      (some (partial = [:x :x :x]) seqs-to-check) :x)))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":73,"code":"#(some {[:o :o :o] :o [:x :x :x] :x} \n        (partition 3 \n                   (map \n                    (vec (flatten %))\n                    [0 1 2 3 4 5 6 7 8\n                     0 3 6 1 4 7 2 5 8 \n                     0 4 8 2 4 6])))","user":"4f041de1535dcb61093f6ba5"},{"problem":73,"code":"(fn [board]\n   (first\n   (flatten\n   (filter #(or (= '(:x) %) (= '(:o) %))\n   (map distinct\n  (conj (concat board (apply map vector board))\n  \t\t(map #(nth (nth board %) %) [0 1 2])\n  \t\t(map #(nth (reverse (nth board %)) %) [0 1 2])\n        )\n        )\n           )\n    )\n    )\n  )","user":"56304db8e4b073c1cf7a9be5"},{"problem":73,"code":"(fn ttt [v]\n  (let [ps (conj [] \n                  (get-in v [0 0])\n                  (get-in v [0 1])\n                  (get-in v [0 2])\n                  (get-in v [1 0])\n                  (get-in v [2 0]))]\n  (loop [p (first ps)\n         ps' (rest ps)\n         cnt 0\n         done false]\n    (if (= :e p)\n      (recur (first ps') (rest ps') (inc cnt) false)\n      (condp = cnt\n        0 (if-not done\n            (if (or (= p (get-in v [0 1]) (get-in v [0 2]))\n                    (= p (get-in v [1 1]) (get-in v [2 2]))\n                    (= p (get-in v [1 0]) (get-in v [2 0])))\n              (recur p nil 0 true)\n              (recur (first ps') (rest ps') 1 false))\n            p)\n        1 (if-not done\n            (if (= p (get-in v [1 1]) (get-in v [2 1]))\n              (recur p nil 1 true)\n              (recur (first ps') (rest ps') 2 false))\n            p)\n        2 (if-not done\n          (if (or\n                (= p (get-in v [1 2]) (get-in v [2 2]))\n                (= p (get-in v [1 1]) (get-in v [2 0]))\n                )\n            (recur p nil 2 true)\n            (recur (first ps') (rest ps') 3 false))\n          p)\n        3 (if-not done\n          (if (= p (get-in v [1 1]) (get-in v [1 2]))\n            (recur p nil 3 true)\n            (recur (first ps') (rest ps') 4 false))\n          p)\n        4 (if-not done\n          (if (= p (get-in v [2 1]) (get-in v [2 2]))\n            (recur p nil 4 true)\n            (recur (first ps') (rest ps') 5 false))\n          p)\n        5 nil)))))","user":"52c58561e4b0c2d177d620f8"},{"problem":73,"code":"(fn tictac [board]\n  (let [vertical [(vec (map first board)) (vec (map second board)) (vec (map #(nth % 2) board))]\n        diag [[(first (first board)) (second (second board)) (nth (nth board 2) 2)]\n              [(nth (first board) 2) (second (second board)) (first (nth board 2))]]\n        all  (concat board vertical diag)\n        fe  (filter #(not (some (fn [v] (= :e v)) %)) all)\n        xs  (filter #(every? (fn [v] (= :x v)) %) fe)\n        os  (filter #(every? (fn [v] (= :o v)) %) fe)]\n    (cond (> (count xs) 0) :x\n          (> (count os) 0) :o\n          :otherwise nil)\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"problem":73,"code":"(fn [g]\n(let [h (fn [v] (into #{} (flatten (filter (fn [n] (= 1 (count n))) (map distinct v)))))\n        rows (h g)\n        cols (h (partition 3 (apply interleave g)))\n        diag (h (vector (vector (nth (flatten g) 2) (nth (flatten g) 4) (nth (flatten g) 6)) (vector (nth (flatten g) 0) (nth (flatten g) 4) (nth (flatten g) 8))))\n        ]\n    (if (or (contains? rows :x) (contains? cols :x) (contains? diag :x))\n      :x (if (or (contains? rows :o) (contains? cols :o) (contains? diag :o))\n           :o nil))))","user":"551c66dae4b07993ea3788de"},{"problem":73,"code":"(fn analyze-ttt [board]\n  (letfn [(columns [board]\n            (partition (count (first board)) (apply interleave board)))\n          (not-all-empty? [xs] (not-every? #{:e} xs))\n          (diag1 [board] \n            (loop [i 0 res []]\n              (if (>= i (count board))\n                res\n                (recur (inc i) (conj res ((board i) i))))))\n          (diag2 [board] \n            (loop [i 0 res []]\n              (if (>= i (count board))\n                res\n                (recur (inc i) (conj res ((board i) (- (count board) i 1)))))))]\n    (first (first \n            (filter #(apply = %)\n                    (filter not-all-empty? \n                           (concat board (columns board) [(diag1 board) (diag2 board)])))))))","user":"52e657e4e4b09f7907dd1472"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (let [rows [[a b c] [d e f] [g h i],\n              [a d g] [b e h] [c f i],\n              [a e i] [c e g]],\n        check-row (fn [row]\n                    (cond (every? #(= :x %) row) :x\n                          (every? #(= :o %) row) :o\n                          :else nil))]\n    (first (remove nil? (map check-row rows)))))","user":"567695c2e4b05957ce8c6157"},{"problem":73,"code":"(fn [board]\n  (first (filter\n          (fn [side]\n            (let [o #(or %1 %2) r (range 3) c (fn [x] (every? #(= side (get-in board (x %) )) r))\n                  ro (fn [z] (reduce o (map #(c (z %)) r)))]\n            (or\n             (c (fn [x] [x x]))\n             (c (fn [x] [(- 2 x) x]))\n             (ro #(fn [x] [x %]))\n             (ro #(fn [x] [% x]))\n            ))) [:x :o])))","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn [m]\n  (letfn [(row-winner [[winner :as cells]]\n            (if (and (not= :e winner) (apply = cells)) winner))\n\n          (field-winner [m]\n            (reduce #(if (nil? %1) %2 %1) (apply map #(row-winner (vec %&)) m)))\n\n          (transp [m]\n            (vec (apply map vector (reverse m))))\n\n          (diag [m]\n            (for [x (range (count m))] ((m x) x)))\n\n          (solve [m]\n            (let [w (field-winner m)]\n              (if-not (nil? w)\n                w\n                (let [tm (transp m)\n                      w  (field-winner tm)]\n                  (if-not (nil? w)\n                    w\n                    (let [w (-> m diag row-winner)]\n                      (if-not (nil? w)\n                        w\n                        (let [w (-> tm diag row-winner)]\n                          (if-not (nil? w)\n                            w)))))))))]\n    (solve m)))","problem":73,"user":"5245fbbbe4b09dbe66b56183"},{"code":"(fn [v]\r\n  (let [get (fn [x y] (nth (nth v y) x))\r\n    res (if (some true?\r\n              [(= (get 0 0) (get 0 1) (get 0 2))\r\n              (= (get 0 0) (get 1 0) (get 2 0))\r\n              (= (get 0 0) (get 1 1) (get 2 2))])\r\n      (get 0 0)\r\n      (if (true?\r\n                (= (get 0 1) (get 1 1) (get 2 1)))\r\n        (get 0 1)\r\n        (if (true?\r\n                  (= (get 0 2) (get 1 1) (get 2 0)))\r\n          (get 0 2)\r\n          nil)))]\r\n    (if(= res :e) nil res)))","problem":73,"user":"4e99f2e1535dbda64a6f6b6c"},{"problem":73,"code":"(fn tictactoe [board]\n  (let [get-vals (fn [coll s] (for [idx s] (get-in coll idx)))\n        get-col (fn [n] (map #(list % n) (range 3)))\n        get-cols (list (get-col 0) (get-col 1) (get-col 2))\n        get-row (fn [n] (map #(list n %) (range 3)))\n        get-rows (list (get-row 0) (get-row 1) (get-row 2))\n        diags '(((0 0) (1 1) (2 2)) ((0 2) (1 1) (2 0)))\n        get-diag (fn [n] (nth diags n))\n        svals (fn [n f] (get-vals board (f n)))\n        all? (fn [coll] (if (every? #(= (first coll) %) coll) (first coll)))]\n    (some #{:x :o} (concat (map all? (map #(svals % get-col) (range 3)))\n          (map all? (map #(svals % get-row) (range 3)))\n          (map all? (map #(svals % get-diag) (range 2)))))\n  ))","user":"5972fcf6e4b01722bebd4c92"},{"problem":73,"code":"(fn [board]\n    (let [wins [ [ [0 0] [0 1] [0 2] ]\n                 [ [1 0] [1 1] [1 2] ]\n                 [ [2 0] [2 1] [2 2] ]\n\n                 [ [0 0] [1 0] [2 0] ]\n                 [ [0 1] [1 1] [2 1] ]\n                 [ [0 2] [1 2] [2 2] ]\n\n                 [ [0 0] [1 1] [2 2] ]\n                 [ [0 2] [1 1] [2 0] ] ]\n\n          winner (fn [board [a b c]]\n                    (let [va (get-in board a)\n                          vb (get-in board b)\n                          vc (get-in board c)]\n                        (if (and (not= va :e) (= va vb vc)) va nil))) ]\n\n          (some #(winner board %) wins)))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":73,"code":"(fn prob73 [m]\n  ;; return first path that contains all :x or :o\n  ;; if none return nil\n  (letfn [(triples [m]\n            (concat (rows m) (cols m) (diags m)))\n          (rows [m]\n            (map #(row m %) (range 3)))\n          (row [m n] (nth m n))\n          (cols [m]\n            (map #(col m %) (range 3)))\n          (col [m n] (vec (map #(nth % n) m)))\n          (diags [m] \n            (list [(last (col m 0)) (second (col m 1)) (first (col m 2))]\n                  [(first (col m 0)) (second (col m 1)) (last (col m 2))]))]\n  (let [tups (triples m)]\n    (print tups)\n    (print (count (filter #(= [:x :x :x] %) tups)))\n    (if (> (count (filter #(= [:x :x :x] %) tups)) 0)\n      :x\n      (if (> (count (filter #(= [:o :o :o] %) tups)) 0)\n        :o\n        nil\n        )))))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn tictac [mtx]\n  (let [xs (concat mtx\n                   (vec (apply map vector mtx))\n                   [(for [x [0 1 2]] (get-in mtx [x x]))\n                    (for [x [0 1 2]] (get-in mtx [x (- 2 x)]))])\n        who (fn [ys]\n          (and (apply = ys) (not= (first ys) :e) (first ys)))]\n    (loop [xs xs]\n      (when (seq xs)\n        (if-let [winner (who (first xs))]\n          winner\n          (recur (rest xs)))))))","problem":73,"user":"4ee88269535d93acb0a6687f"},{"code":"(fn tic-tac-toe [board]\n  (let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n        rows (map same? board)\n        cols (map same? (apply map vector board))\n        diag1 (same? (map get board (range 3)))\n        diag2 (same? (map get board (range 2 -1 -1)))]\n    (some #{:x :o} (concat rows cols [diag1] [diag2]))))","problem":73,"user":"4e113a81535d04ed9115e7c5"},{"problem":73,"code":"(fn x [[[a b c] [d e f] [g h i]]]\n  (let [s [[a b c] [d e f] [g h i]\n           [a d g] [b e h] [c f i]\n           [a e i] [c e g]]\n        xx (fn[ss](count(filter #(= :x %) ss)))\n        oo (fn[ss](count(filter #(= :o %) ss)))\n        xxx (map xx s)\n        ooo (map oo s)\n        xxxx (count (filter #(< 2 %) xxx))\n        oooo (count (filter #(< 2 %) ooo))\n        ]\n    (if (< 0 xxxx)\n      :x\n      (if (< 0 oooo)\n        :o\n        nil)\n      )\n    )\n  )","user":"5731e36be4b0cd1946bd0fc9"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i]]]\n  (let [m {[:x :x :x] :x, [:o :o :o] :o}]\n  \t(or (m [a b c]) (m [d e f]) (m [g h i]) (m [a d g]) (m [b e h]) (m [c f i]) (m [a e i]) (m [c e g]))))","user":"4ea03f70535d7eef308072a1"},{"problem":73,"code":"(fn [board] (condp #(some #{%1} %2) (map first (filter #(apply = %)\n                                  (concat board (apply map vector board)\n                                          (vector (vec (map #(nth %1 %2) board (range 3))) ;first diag\n                                                  (vec (map #(nth %1 %2) board (reverse (range 3))))))))\n                            :x :x\n                            :o :o\n                            nil))","user":"56baab13e4b0f26550335948"},{"code":"(fn [ttt]\n  (ffirst\n    (filter \n      #(and (= 1 (count %)) (not= :e (first %)))\n      (map\n        set\n        (conj\n          ttt\n          (map first ttt)\n          (map second ttt)\n          (map last ttt)\n          (map-indexed #(%2 %1) ttt)\n          (map-indexed #(%2 (- 2 %1)) ttt)\n        )\n      )\n    )\n  )\n)","problem":73,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn [b]\n  (let [\n    e (fn [x y m] (= m (nth (nth b y) x)))\n    r (fn [n m] (every? (fn[x]x)(list (e 0 n m) (e 1 n m) (e 2 n m))))\n    c (fn [n m] (every? (fn[x]x)(list (e n 0 m) (e n 1 m) (e n 2 m))))\n    dr (fn [m] (every? (fn[x]x)(list (e 0 0 m) (e 1 1 m) (e 2 2 m))))\n    dl (fn [m] (every? (fn[x]x)(list (e 0 2 m) (e 1 1 m) (e 2 0 m))))\n    ]\n    (cond\n      (r 0 :x) :x\n      (r 1 :x) :x\n      (r 2 :x) :x\n      (c 0 :x) :x\n      (c 1 :x) :x\n      (c 2 :x) :x\n      (dr :x) :x\n      (dl :x) :x\n      (r 0 :o) :o\n      (r 1 :o) :o\n      (r 2 :o) :o\n      (c 0 :o) :o\n      (c 1 :o) :o\n      (c 2 :o) :o\n      (dr :o) :o\n      (dl :o) :o\n      :else nil\n)))","problem":73,"user":"4e6e10d8535d5021c1a895fd"},{"problem":73,"code":"(fn [x]\n   (let [result (set\n                 (concat\n                  (map set x)\n                  (->> x (apply map vector) (map set))\n                  (list\n                   (->> x ((juxt ffirst #(second (second %)) #(last (last %)))) set)\n                   (->> x ((juxt #(last (first %)) #(second (second %)) #(first (last %)))) set))))]\n     (first\n      (or (result #{:o})\n          (result #{:x})))\n     ))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":73,"code":"(fn tic-tac-analyze [board]\n  (let [row-indexes (map (partial repeat 3) (range 0 3))\n        diag-indexes [(range 0 3)\n                      (reverse (range 0 3))]\n        transed-board (apply map vector board)\n        check (fn [shape rows indexes]\n                (= #{shape}\n                   (into #{} (map nth rows indexes))))\n        winning? (fn [shape]\n                   (or (some (partial check shape board) row-indexes)\n                       (some (partial check shape transed-board) row-indexes)\n                       (some (partial check shape transed-board) diag-indexes)))]\n    (cond (winning? :x) :x\n          (winning? :o) :o)))","user":"5515b138e4b055c2f668d4ed"},{"code":"#(let [board %\n      all-rows (fn []\n  \t\t(partition 3 (for [x (range 0 3) y (range 0 3)] [x y])))\n      all-cols (fn []\n  \t\t(partition 3 (for [x (range 0 3) y (range 0 3)] [y x])))\n      diagonals (fn []\n  \t\t(partition 3 (concat \n                 (for [x (range 0 3)] [x x])\n                 (for [x (range 0 3)] [x (- 2 x)]))))\n      possible-win-positions (fn []\n  \t\t(concat (all-rows) (all-cols) (diagonals)))\n\n      winner (fn [line]\n                 (cond \n                   (= \":x:x:x\" line)\n                   :x\n\n                   (= \":o:o:o\" line)\n                   :o\n\n                   :else \n                   nil))]\n    (loop [win-positions (possible-win-positions)]\n      (let [win-position (first win-positions)\n            line (apply str (map (fn [[x y]] ((board x) y)) win-position))\n            found-winner (winner line)]\n        (if (not (nil? found-winner))\n          found-winner\n          (when (next win-positions)\n            (recur (next win-positions)))))))","problem":73,"user":"5244a10de4b0d8acf9ed6ab3"},{"problem":73,"code":"(fn [y] (let [z (cons :e (apply concat y)) jo \n              #(and \n                (= %1 (nth z %2)) \n                (= %1 (nth z %3)) \n                (= %1 (nth z %4)))] \n          (if (or \n               (jo :x 1 2 3)\n               (jo :x 4 5 6)\n               (jo :x 7 8 9)\n               (jo :x 1 4 7)\n               (jo :x 2 5 8)\n               (jo :x 3 6 9)\n               (jo :x 1 5 9)\n               (jo :x 3 5 7))\n            :x (if (or\n               (jo :o 1 2 3)\n               (jo :o 4 5 6)\n               (jo :o 7 8 9)\n               (jo :o 1 4 7)\n               (jo :o 2 5 8)\n               (jo :o 3 6 9)\n               (jo :o 1 5 9)\n               (jo :o 3 5 7))\n                 :o nil))))","user":"53fc8424e4b0de5c418485b3"},{"code":"(fn [[a b c :as board]]\n  (letfn [(winner [n]\n            (cond (every? #(= % :x) n) :x\n                  (every? #(= % :o) n) :o\n                  :else                false))\n          (col [n]\n            (map #(nth % n) board))]\n    (or (winner a)\n        (winner b)\n        (winner c)\n        (winner (col 0))\n        (winner (col 1))\n        (winner (col 2))\n        (winner [(nth a 0) (nth b 1) (nth c 2)])\n        (winner [(nth c 0) (nth b 1) (nth a 2)])\n        nil)))","problem":73,"user":"4f84a4a4e4b033992c121c39"},{"code":"(fn [board]\n  (let [board-transposed (vec (apply map (comp vec reverse vector) board))\n        is-first-diagonal (fn [board player]\n          (every? \n            (partial = player)\n            (map #((board %) %) (range 3))))]\n    (reduce (fn [won player]\n      (if won won\n        (cond\n          (some (partial every? \n            (partial = player)) \n          (concat board board-transposed)) player\n          (or (is-first-diagonal board player)\n              (is-first-diagonal board-transposed player)) player\n          true nil)))\n    nil [:x :o])))","problem":73,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":73,"code":"(fn [board]\n   (ffirst\n     (filter\n       (fn [line]\n         (and\n           (#{:x :o} (first line))\n           (apply = line)))\n       (concat\n         board\n         (for [n (range 2)]\n           (map #(nth % n) board))\n         [[(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])]\n          [(get-in board [2 0]) (get-in board [1 1]) (get-in board [0 2])]]\n         ))))","user":"5ade6bafe4b0837691e92c23"},{"problem":73,"code":"#(cond\n(apply = :o (first %)) :o\n(apply = :o (second %)) :o\n(apply = :o (last %)) :o\n(apply = :o (map first %)) :o\n(apply = :o (map second %)) :o\n(apply = :o (map last %)) :o\n(= :o (first (first %)) (second (second %)) (last (last %))) :o\n(= :o (last (first %)) (second (second %)) (first (last %))) :o\n(apply = :x (first %)) :x\n(apply = :x (second %)) :x\n(apply = :x (last %)) :x\n(apply = :x (map first %)) :x\n(apply = :x (map second %)) :x\n(apply = :x (map last %)) :x\n(= :x (first (first %)) (second (second %)) (last (last %))) :x\n(= :x (last (first %)) (second (second %)) (first (last %))) :x\n)","user":"5aa8f753e4b0d174b936c8d9"},{"code":"(fn ttt\r\n  [board]\r\n\t(let [board (map (fn [lista] (replace {:e nil} lista)) board)]\r\n\t\t(letfn [(line-winner [line] \r\n\t\t\t\t\t\t\t(reduce (fn [c1 c2] (if (= c1 c2) c1 nil)) line))\r\n\t\t\t\t\t\t(third [x]\r\n\t\t\t\t\t\t\t(second (next x)))]\r\n\t\t\t(or\r\n\t\t\t\t(line-winner (first board))\r\n\t\t\t\t(line-winner (fnext board))\r\n\t\t\t\t(line-winner (third board))\r\n\t\t\t\t\r\n\t\t\t\t(line-winner [(ffirst board) (first (second board)) (first (third board))])\r\n\t\t\t\t(line-winner [(second (first board)) (second (second board)) (second (third board))])\r\n\t\t\t\t(line-winner [(third (first board)) (third (second board)) (third (third board))])\r\n\r\n\t\t\t\t(line-winner [(ffirst board) (second (second board)) (third (third board))])\r\n\t\t\t\t(line-winner [(first (third board)) (second (second board)) (third (first board))])))))","problem":73,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [m] \n  (let [\n        n (partition 3 3 (apply interleave m))\n        get-diagonal (fn [m] (reduce #(cons (%2 (count %1)) %1) (cons [] m)))\n        d1 (get-diagonal m)\n        d2 (get-diagonal (reverse m))\n        op (concat m n (list d1 d2))\n        get-eq (fn [l] ( if (apply = l ) (first l) :e ))\n         ] ((fn [l] \n        (cond (empty? l) nil \n          (not (= (get-eq (first l)) :e)) (first (first l)) \n          :else (recur (rest l)) ) ) op )  ))","problem":73,"user":"4fc43a8ee4b081705acca346"},{"problem":73,"code":"(fn tictactoe\n  [[r1 r2 r3]]\n  (cond\n    (some #(= 3 %) (for [itm [r1 r2 r3]] (count (filter #(= % :x) itm)))) :x\n    (some #(= 3 %) (for [itm [r1 r2 r3]] (count (filter #(= % :o) itm)))) :o\n    (some #(= 3 %) (for [itm (apply vector(map list r1 r2 r3))] (count (filter #(= % :x) itm)))) :x\n    (some #(= 3 %) (for [itm (apply vector(map list r1 r2 r3))] (count (filter #(= % :o) itm)))) :o\n    (= (r1 0) (r2 1) (r3 2) :x) :x\n    (= (r1 0) (r2 1) (r3 2) :o) :o\n    (= (r1 2) (r2 1) (r3 0) :x) :x\n    (= (r1 2) (r2 1) (r3 0) :o) :o\n    ))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":73,"code":"(fn [[[a b c] [d e f] [g h i] :as w]]\n  (some\n   #(case % [:x :x :x] :x [:o :o :o] :o nil)\n   (conj w [a d g] [b e h] [c f i] [a e i] [g e c])))","user":"5c94e60de4b048ec896c5a3e"},{"code":"(fn [d]\n  (let [n [0 1 2]\n        s (set\n            (concat\n              d\n              (apply map list d)\n              [(for [a n] (get-in d [a a]))\n               (for [a n] (get-in d [(- 2 a) a]))]))]\n    (cond\n      (s [:x :x :x]) :x\n      (s [:o :o :o]) :o\n      :e nil)))","problem":73,"user":"4f08b15b535dcb61093f6c40"},{"problem":73,"code":"(fn [grid]\n  (let [diag1 (distinct (map (fn [x] (nth (nth grid x) x)) [0 1 2]))\n        diag2 (distinct (map (fn [x] (nth (reverse (nth grid x)) x)) [0 1 2]))\n        hor1 (distinct (map (fn [x] (nth (first grid) x)) [0 1 2]))\n        hor2 (distinct (map (fn [x] (nth (second grid) x)) [0 1 2]))\n        hor3 (distinct (map (fn [x] (nth (nth grid 2) x)) [0 1 2]))\n        \n        ver1 (distinct (map (fn [x] (first (nth grid x))) [0 1 2]))\n        ver2 (distinct (map (fn [x] (second (nth grid x))) [0 1 2]))\n        ver3 (distinct (map (fn [x] (nth (nth grid x) 2)) [0 1 2]))]\n    \n    \n    (first (cond (and (not= :e (first diag1)) (= 1 (count diag1))) diag1\n          (and (not= :e (first diag2)) (= 1 (count diag2))) diag2\n          (and (not= :e (first hor1)) (= 1 (count hor1))) hor1\n          (and (not= :e (first hor2)) (= 1 (count hor2))) hor2\n          (and (not= :e (first hor3)) (= 1 (count hor3))) hor3\n          (and (not= :e (first ver1)) (= 1 (count ver1))) ver1\n          (and (not= :e (first ver2)) (= 1 (count ver1))) ver2\n          (and (not= :e (first ver3)) (= 1 (count ver1))) ver3\n          :else '(nil)))\n    \n    ))","user":"53a5c7ffe4b0ef122a8689c4"},{"code":"(fn [coll] \n  ; use destruct for each member + :as\n  (first (filter #(not (nil? %1)) \n                 (map (fn [what] \n                        (let [all (concat coll\n                                          ; rows, cols, diag, rdiag\n                                          (apply map vector coll) \n                                          [(map-indexed #(%2   %1 ) coll)] \n                                          [(map-indexed #(%2 (- (count %2) %1 1)) coll)])] \n                          ; use (#{[:x :x :x] [:o :o :o]} result) to match\n                          (when (some true? (map (fn [cand] (every? #(= % what) cand)) all)) what))) [ :x :o]))))","problem":73,"user":"50de11b2e4b061dbdced7217"},{"problem":73,"code":"(fn tic-tac-toe-winner [board]\n  (let [rows board\n        cols (apply map vector board)\n        diags (apply map vector (for [r (range (count board))]\n                 [((board r) r)\n                  ((board r) (- (count board) (inc r)))]))\n        all (set (map distinct (concat rows cols diags)))]\n    (cond\n      (clojure.set/subset? #{'(:x)} all) :x\n      (clojure.set/subset? #{'(:o)} all) :o\n      :else nil)))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn [board]\n        (first (filter #(not= % :e) (map (fn [el]\n              (if (=(el :x)3)\n                :x\n                (if (= (el :o) 3)\n                  :o\n                  :e))) (flatten\n                          (conj (map \n                                  (fn [row]\n                                    (frequencies row)) board)\n                                (map\n                                  (fn [col]\n                                    (frequencies col)) (apply mapv vector board))\n                                (map\n                                  (fn [diag]\n                                    (frequencies diag)) [\n                                                         [((board 0)0) ((board 1)1) ((board 2)2)]\n                                                         [((board 0)2) ((board 1)1) ((board 2)0)]])))))))","problem":73,"user":"50d3b03fe4b030b634c368b9"},{"code":"(fn [[ [a b c] [d e f] [g h i] ]]\n  (let [s [[a b c], [d e f], [ g h i], [a d g], [b e h ], [c f i ], [a e i] , [c e g]] \n        t (fn [[x y z]]  (if (= x y z) x ))\n        u (fn [v] (if (= :e v) nil v))]\n        (u (first (filter #(not (nil? %)) (map t s))))))","problem":73,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn tic-won? [t]\n        (let [[a b c :as t] (for [x t] (map #(get {:e nil} % %) x))]\n          (cond\n           (or (apply = (map first t))      (apply = a)) (first a)\n           (or (apply = (map #(nth % 2) t)) (apply = c)) (nth c 2)\n           (or (apply = (map second t))\n               (apply = b)\n               (apply = (map #(nth % %2) t [0 1 2]))\n               (apply = (map #(nth % %2) t [2 1 0]))) (second b))))","problem":73,"user":"4f031eac535dcb61093f6a67"},{"problem":73,"code":"(fn [b]\n  (letfn [(check [cs]\n            (let [ps (map (partial get-in b) cs)]\n              (when (and (apply = ps)\n                         (not= (first ps) :e))\n                (first ps))))]\n    (some check [[[0 0] [0 1] [0 2]]\n                 [[1 0] [1 1] [1 2]]\n                 [[2 0] [2 1] [2 2]]\n                 [[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]\n                 [[0 0] [1 1] [2 2]]\n                 [[0 2] [1 1] [2 0]]])))","user":"55c4e48be4b0e31453f649a7"},{"code":"(fn [c] (let [m map a apply t (m #(m {:e 0 :x 1 :o 4} %) c) n (fn [l] (m #(nth (nth l %) %) (range 3)))] (some {3 :x 12 :o} (flatten [ (a (partial m +) t) (m #(a + %) t) [ (a + (n t)) (a + (n (m reverse t))) ]]))))","problem":73,"user":"4dad8fe9c9a9d6ed1899dc57"},{"code":"(fn\n  [[[a b c] [d e f] [g h i]]]\n  (cond (and (= a b c) (not= a :e)) a\n        (and (= d e f) (not= d :e)) d\n        (and (= g h i) (not= g :e)) g\n        (and (= a d g) (not= a :e)) a\n        (and (= b e f) (not= b :e)) b\n        (and (= c f i) (not= c :e)) c\n        (and (= a e i) (not= a :e)) a\n        (and (= c e g) (not= c :e)) c\n        :else nil))","problem":73,"user":"52e1c276e4b09f7907dd142b"},{"problem":73,"code":"(fn [[[r11 r12 r13 :as r1]\n      [r21 r22 r23 :as r2] \n      [r31 r32 r33 :as r3] :as board]]\n  (let [triples (list r1 r2 r3\n                      (map first board) (map second board) (map #(% 2) board)\n                      [r11 r22 r33]\n                      [r31 r22 r13])]\n    ((fn aux [tpls]\n       (cond\n        (empty? tpls) nil\n        (= (first tpls) [:x :x :x]) :x\n        (= (first tpls) [:o :o :o]) :o\n        :else (recur (rest tpls))))\n     triples)))","user":"568e1871e4b0dcc4269f40cc"},{"code":"(fn solver [board]\n  (let [len (count board)\n        players #{:x :o}\n        all-first (fn [[f & r]]\n                    (when (every? #(= f %) r) f))\n        winner (fn [triple] (all-first (map players triple)))\n        triples (concat board \n                        (apply map vector board)\n                        [(for [i (range len)] (get-in board [i i]))\n                        (for [i (range len)] (get-in board [(- len i 1) i]))])]\n    (first (drop-while nil? (map winner triples)))))","problem":73,"user":"52d39033e4b099d49816f0c6"},{"problem":73,"code":"(fn a [b]\n  (let [p (concat\n            b\n            (partition 3 (apply mapcat list b))\n            [\n              [ ((b 0) 0) ((b 1) 1) ((b 2) 2) ]\n              [ ((b 0) 2) ((b 1) 1) ((b 2) 0) ]\n            ])]\n    (cond\n      (some #{[:x :x :x]} p) :x\n      (some #{[:o :o :o]} p) :o\n      :else nil\n      )))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn [m]\n  (letfn [(ndx [i] (nth (nth m (/ i 3)) (mod i 3)))]\n    (let [s [[0 3 6][1 4 7][2 5 8][0 4 8][2 4 6]]\n          f (concat m (map #(map ndx %) s))]\n      (cond\n       (some #(every? (partial = :x) %) f) :x\n       (some #(every? (partial = :o) %) f) :o\n       :else nil))))","problem":73,"user":"511d6a01e4b022853b0e07a5"},{"problem":73,"code":"(fn ttt [board]\n  (let  [rows board\n         columns (apply map vector board)\n         diags [(map-indexed (fn [i j] (get-in board [i j])) [0 1 2]) (map-indexed (fn [i j] (get-in board [i j])) [2 1 0])]\n         all (concat rows columns diags)\n         winner (some (fn [t] (if (every? (partial = (first t)) t) (first t))) all)]\n       (if (#{:x :o} winner) winner)))","user":"5958cef6e4b066ee0a44af94"},{"problem":73,"code":"(fn check-board [board]\r\n  (letfn [(check-horizontal [horizontal]\r\n            (->> horizontal\r\n                 (frequencies)\r\n                 (some (fn [[key val]]\r\n                         (if (= val 3)\r\n                           key)))\r\n                 (#{:x :o})))\r\n          (check-all-horizontals [rows]\r\n            (some check-horizontal rows))\r\n          (check-all-verticals [[r1 r2 r3]]\r\n            (some #{:x :o} (map (fn hi [& column]\r\n                                  (check-horizontal column))\r\n                                r1 r2 r3)))\r\n          (check-top-right-diagonal [[[_ _ a] [_ b] [c]]]\r\n            (check-horizontal [a b c]))\r\n          (check-top-left-diagonal [[[a] [_ b] [_ _ c]]]\r\n            (check-horizontal [a b c]))]\r\n    (or\r\n     (check-all-horizontals board)\r\n     (check-all-verticals board)\r\n     (check-top-right-diagonal board)\r\n     (check-top-left-diagonal board))))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn [board]\n  (let [rows board\n        cols [(map first rows) \n              (map second rows)\n              (map #(nth % 2) rows)]\n        gi #(get-in board [%1 %2])\n        diags [[(gi 0 0) (gi 1 1) (gi 2 2)]\n               [(gi 2 0) (gi 1 1) (gi 0 2)]]\n        all (concat rows cols diags)]\n    (cond\n     (some #{[:x :x :x]} all) :x\n     (some #{[:o :o :o]} all) :o\n     :else nil)))","problem":73,"user":"50bca033e4b0594b91591c5d"},{"problem":73,"code":"(fn [board]\n  (let [same? #(if (apply = %) (first %) nil)\n        rows (map same? board)\n        cols (map same? (apply map vector board))\n        left-diagonal (same? (map get board (range 3)))\n        right-diagonal (same? (map get board (range 2 -1 -1)))]\n    (some #{:x :o}  (concat rows cols [left-diagonal] [right-diagonal]))))","user":"57283dbce4b0c5bde472c154"},{"code":";; I should make this better later, but it was fun getting\n;; something working.\n(fn [board]\n  (let [marks (fn [board coords] (map #(get-in board %) coords))\n        winning-line? (fn [marks] (if (apply = marks)\n                                   (some #{(first marks)} [:x :o])))\n        winning-board? (fn [board]\n                        (let [winner (first (filter winning-line?\n                                      (map marks\n                                       (repeat 8 board)\n                                        [[[0 0] [0 1] [0 2]]\n                                        [[1 0] [1 1] [1 2]]\n                                        [[2 0] [2 1] [2 2]]\n                                        [[0 0] [1 0] [2 0]]\n                                        [[0 1] [1 1] [2 1]]\n                                        [[0 2] [1 2] [2 2]]\n                                        [[0 0] [1 1] [2 2]]\n                                        [[0 2] [1 1] [2 0]]])))]\n                            (if winner (first winner))))]\n  (winning-board? board)))","problem":73,"user":"4e42f930535dc968683fc49f"},{"problem":73,"code":"(fn [game]\n   (let [chx [[0 3 1 0 0 1]\n              [0 3 0 1 1 0]\n              [0 1 9 9 1 1]\n              [2 1 9 9 -1 1]]\n         game-rc (fn [g row col]\n                   (get (get g row) col))\n         bingo (atom nil)]\n     ;; each chx is a pattern to check one or three times (one for diagonals)\n     ;; each check consists of testing three cells\n     (doseq [[start-row check-ct chk-row-inc chk-col-inc cell-row-inc cell-col-inc] chx]\n       (when (nil? @bingo)\n         (dotimes [chk check-ct]\n           (let [played (atom nil)]\n             (dotimes [cell 3]\n               (when-not (= @played :nope) ;; already not a match \n                 (let [p (game-rc game\n                           (+ start-row (* chk chk-row-inc) (* cell cell-row-inc))\n                           (+ (* chk chk-col-inc)(* cell cell-col-inc)))]\n                   (cond\n                     (= p :e) (reset! played :nope)\n                     (nil? @played) (reset! played p)\n                     (not= p @played) (reset! played :nope)))))\n             (when-let [win (some #{@played} [:x :o])]\n               (println :bingo win :chk chk)\n               (reset! bingo win))))))\n     @bingo))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":73,"code":"(fn tic-tac\n\t[board]\n\t(let[\n\t\tnot-e #(not= (first %) :e)\n\t\teq #(apply = %)\n\t\thorz (filter  not-e (filter eq board))\n\t\tvert (filter not-e (filter eq (apply mapv vector board)))\n\t\tcross1 (filter not-e (filter eq [(map #(nth (flatten board) %) [0 4 8])]))\n\t\tcross2 (filter not-e (filter eq [(map #(nth (flatten board) %) [2 4 6])]))\n\t\t]\n\t\t(some identity (map (comp first first) [horz vert cross1 cross2]))\n\t\t)\n\t)","user":"5545477fe4b0a04f79299531"},{"problem":73,"code":"(fn [v]\n  (let [verts (partition 3 (apply interleave v))\n        diags [ [((v 0) 0) ((v 1) 1) ((v 2) 2)]\n                [((v 0) 2) ((v 1) 1) ((v 2) 0)]]\n        complete (concat v verts diags)]\n    (if (some #(= % [:x :x :x]) complete)\n      :x\n      (if (some #(= % [:o :o :o]) complete)\n        :o\n        nil))))","user":"53c1ce3ee4b00fb29b221268"},{"problem":73,"code":"(fn [board]\n  (let [all-win-keys\n        [[[0 0] [0 1] [0 2]]\n         [[1 0] [1 1] [1 2]]\n         [[2 0] [2 1] [2 2]]\n         [[0 0] [1 0] [2 0]]\n         [[0 1] [1 1] [2 1]]\n         [[0 2] [1 2] [2 2]]\n         [[0 0] [1 1] [2 2]]\n         [[2 0] [1 1] [0 2]]]]\n    (loop [win-keys (first all-win-keys)\n           rest-win-keys (rest all-win-keys)]\n      (if\n        (empty? win-keys)\n        nil\n        (let [\n          start-win-keys (first win-keys)\n          win-piece \n            ((board \n              (first start-win-keys))\n              (last start-win-keys))]\n          (if (or\n                (= win-piece :e)\n                (not-every?\n                  #(= win-piece \n                    ((board (first %)) (last %)))\n                  win-keys))\n            (recur \n              (first rest-win-keys)\n              (rest rest-win-keys))\n            win-piece))))))","user":"564c8e99e4b0284900eef674"},{"problem":73,"code":"(fn winner? [game]\n  (let [dimensions 3\n        init-gamestate {:board  {:rows (into [] (repeat dimensions :e)) \n                                 :cols (into [] (repeat dimensions :e)) \n                                 :dia  (into [] (repeat 2 :e))}\n                        :player [:x :o]}\n                     ]\n\n    (letfn [(get-row [n coll](nth \n           (partition-all dimensions \n           (flatten coll)) n))\n\n           (get-column [n coll](map #(nth % n) coll)) \n           \n           (get-diagonal1 [coll](flatten (partition-all 1 \n           (+ dimensions 1) \n           (flatten coll))))\n           \n           (get-diagonal2 [coll](flatten (partition-all 1 \n           (+ dimensions 1) \n           (flatten (map reverse coll)))))\n           \n           (all-equal? [vec & item] \n                (->>(reduce (fn [[truth previous] next] \n                (if (and (= truth true) (= previous next))\n                     [true next] [false next])) \n                     [true (if item (first item) (first vec))] vec)\n                (first)))\n\n            (populate-rows [gamestate dimensions coll] \n              (if (<= 0 dimensions) \n                (recur    (update-in gamestate [:board (nth (keys (gamestate :board)) 0)]    (fn [vec dimensions] \n                       (assoc vec dimensions (get-row dimensions coll))) dimensions) (dec dimensions) coll)\n                       gamestate))\n      \n            (populate-columns [gamestate dimensions coll] \n              (if (<= 0 dimensions) \n                (recur    (update-in gamestate [:board (nth (keys (gamestate :board)) 1)]    (fn [vec dimensions] \n                       (assoc vec dimensions (get-column dimensions coll))) dimensions) (dec dimensions) coll)\n                       gamestate))\n\n            (populate-diag1 [gamestate dimensions coll] \n                (update-in gamestate [:board (nth (keys (gamestate :board)) 2)]    (fn [vec dimensions] \n                       (assoc vec dimensions (get-diagonal1 coll))) dimensions))\n\n             (populate-diag2 [gamestate dimensions coll] \n                (update-in gamestate [:board (nth (keys (gamestate :board)) 2)]    (fn [vec dimensions] \n                       (assoc vec dimensions (get-diagonal2 coll))) dimensions) )        \n\n              (get-winner [gamestate](\n                for [a (gamestate :player)\n                b (keys (gamestate :board))]\n                (filter #(all-equal? % a) ((gamestate :board) b))))     \n\n              (decide [col](if (< 0 (count col)) (nth col 0) nil))\n                ]\n\n            (-> (populate-rows init-gamestate (dec dimensions) game)\n                 (populate-columns (dec dimensions) game)\n                 (populate-diag1 0 game)\n                 (populate-diag2 1 game)\n                 (get-winner)\n                 (flatten)\n                 (distinct)\n                 (decide)\n                 )\n                )))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"code":"(fn solve\n  [g]\n  (let [dg #(set (map-indexed (fn [i r] (r i))  %))\n        ps (set (concat\n                     (map set g )\n                     (apply map #(into #{} %&) g)\n                     (map dg [g (reverse g)])))]\n    (#{:o :x} (ffirst (filter #(= 1 (count %)) ps)))))","problem":73,"user":"4e6dd0f5535d5021c1a895f3"},{"problem":73,"code":"(fn winner [b]\n  (some {[:o :o :o] :o [:x :x :x] :x}\n        (concat b \n                (apply map vector b)\n                (for [i [[0 4 8] [2 4 6]]] \n                  (map (vec (flatten b)) i)))))","user":"53b39d82e4b047364c0444a6"},{"problem":73,"code":"(fn [[e f g :as b]]\n   (letfn [(c [[i j k]] (when (= i j k) i))\n           (d [b] (some identity (map c b)))]\n     (let [a (or (d b)\n                 (d (apply (partial map list) b))\n                 (c [(e 0) (f 1) (g 2)])\n                 (c [(e 2) (f 1) (g 0)])\n                 )]\n       (if (= a :e)\n         nil\n         a)\n       )))","user":"524025bce4b0ad64fa01030f"},{"problem":73,"code":"(fn  [board] \n  (let [ rows \tboard\n         cols   (apply map vector board) \n         diags  [(map get board [0 1 2]) (map get board [2 1 0])] \n         all    (concat cols rows diags)    \n\n         wins?  (fn [x ls]  (= 3 (count (filter #(= % x) ls)))) \n         check  (fn [bools] (reduce #(or %1 %2)  bools)) \n         \n         win-x? (check (map #(wins? :x %) all))\n         win-o? (check (map #(wins? :o %) all))]\n    \n    (cond \n       win-x? :x\n       win-o? :o \n     )))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn [[[a b c] [d e f] [g h i]]]\n   (cond (and (= a b c) (not= a :e)) a\n         (and (= d e f) (not= d :e)) d\n         (and (= g h i) (not= g :e)) g\n         (and (= a d g) (not= a :e)) a\n         (and (= b e h) (not= b :e)) b\n         (and (= c f i) (not= c :e)) c\n         (and (= a e i) (not= a :e)) a\n         (and (= c e g) (not= c :e)) c\n         :else nil))","problem":73,"user":"52d10680e4b07d0d72b273c3"},{"problem":73,"code":"(fn\n  [board]\n  (let [\n        get-tile (fn\n                   [[x-pos y-pos] board]\n                   (get (get board y-pos) x-pos))\n\n        next-tile (fn\n                    [[x-pos y-pos] [x-direction y-direction]]\n                    [(+ x-pos x-direction) (+ y-pos y-direction)])\n\n        get-line-tiles (fn\n                         [xy-pos xy-direction board-size]\n                         (take board-size (iterate #(next-tile % xy-direction) xy-pos)))\n\n        find-all-lines (fn\n                         [xy-pos board]\n                         (let [board-size (count board)]\n                           (map #(get-line-tiles xy-pos % board-size) [[1 -1] [1 0] [1 1] [0 1]])))\n\n        check-line (fn\n                     [line board original-xy]\n                     (when (apply = (map #(get-tile % board) line))\n                       (get-tile original-xy board)))\n\n        check-all-lines (fn\n                          [xy-pos board]\n                          (map #(check-line % board xy-pos) (find-all-lines xy-pos board)))\n\n        get-winner (fn\n                     [board piece]\n                     (let [board-height (count board)\n                           board-width (count (first board))]\n                       (some #{piece} (flatten (for [y (range 0 board-height)\n                                                     x (range 0 board-width)\n                                                     :when (= (get-tile [x y] board) piece)]\n                                                 (check-all-lines [x y] board))))))]\n    (cond\n      (get-winner board :x) :x\n      (get-winner board :o) :o\n      :else nil)))","user":"559fb147e4b0acc240e314ea"},{"code":"(fn [board]\n  (some #(cond\n          (every? #{:x} %) :x\n          (every? #{:o} %) :o\n          :else false)\n        (-> board\n            (into (apply mapv vector board))\n            (into (mapv (partial map #(nth % %2) board)\n                        [(range (count board))\n                         (range (dec (count board)) -1 -1)])))))","problem":73,"user":"4e513758535dc968683fc4f3"},{"code":"(fn t [t]\n  (->>\n    t\n    ((juxt  \n      identity\n      (partial apply map vector)\n      (fn [x] (map (partial map-indexed #(nth %2 %)) [x (reverse x)]))))\n    (apply concat)\n    (map set)\n    (some #(when (and (= 1 (count %)) (not (:e %))) (first %)))))","problem":73,"user":"513b43ede4b067e25a345ed3"},{"code":"(fn [rows]\n   (let [columns (apply map vector rows)\n         diags [(map #(% %2) [first second last] rows)\n               (map #(% %2) [last second first] rows)]\n         lines (concat rows columns diags)]\n  \t(ffirst (filter \n       #(and (= 1 (count %)) (not= (first %) :e)) \n        (map distinct lines)))))","problem":73,"user":"4dcfbc44535d5973398f92a7"},{"problem":73,"code":"#(first\n  (some #{[:x :x :x][:o :o :o]}\n        (-> %\n            (into (apply map vector %))\n            (conj (map nth % (range))\n                  (map nth (rseq %) (range))))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":73,"code":"(fn [m]\n  (first (first\n          (filter #(and (apply = %) (not= :e (first %)))\n                  (concat m\n                          (apply mapv vector m)\n                          (let [d (fn [m] (map (fn [x] (get-in m x)) (map #(list % %) (range 3))))] [(d m) (d ((comp vec reverse) m))]))))))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn check [b]\r\n  (letfn [(win-vert? [b p] (reduce #(or %1 %2) (apply (partial map #(= p %1 %2 %3)) b)))\r\n          (win-hori? [b p] (win-vert? (partition 3 (apply interleave b)) p))\r\n          (win-diag? [b p] (letfn [(test [x] (every? identity (map #(= p (get %1 %2)) x (range 3))))] (or (test b) (test (reverse b)))))\r\n          (win? [b p] (or (win-vert? b p) (win-hori? b p) (win-diag? b p)))]\r\n    (cond (win? b :x) :x (win? b :o) :o :else nil)))","problem":73,"user":"4dae916eedd6309eace4d155"},{"problem":73,"code":"(fn [board]\n                (letfn [(winner-of-run [r]\n                          (cond (every? #{:x} r) :x\n                                (every? #{:o} r) :o\n                                :else nil))\n                        (rows [b] b)\n                        (columns [b] (apply map vector b))\n                        (diagonals [b]\n                          [[(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])]\n                           [(get-in b [2 0]) (get-in b [1 1]) (get-in b [0 2])]])]\n                  (or\n                   (some identity (map winner-of-run (rows board)))\n                   (some identity (map winner-of-run (columns board)))\n                   (some identity (map winner-of-run (diagonals board))))))","user":"604b072ae4b0a426fc8b43d2"},{"problem":73,"code":"(fn [board]\n  (let [vert (mapv vec board)\n        transp (fn [board] (vec (apply map vector board)))\n        hori (map vec (transp board))\n        get-diag-l (fn [board] (reduce (fn [[acc pos] coll]\n                           [(conj acc\n                                  (nth coll (inc pos)))\n                            (inc pos)])\n                                   [[] -1] board))\n        get-diag-r (fn [board] (reduce (fn [[acc pos] coll]\n                                     [(conj acc\n                                            (nth coll (dec pos)))\n                                      (dec pos)])\n                                   [[] 3] board))\n        diag-ll (-> vert get-diag-l first)\n        diag-r (-> vert get-diag-r first)\n        comb-set (->\n               (apply merge\n                      (into #{} vert)\n                      (into #{} hori))\n               (conj diag-r diag-ll))]\n    (cond (some #{[:x :x :x]} comb-set) :x\n          (some #{[:o :o :o]} comb-set) :o\n          :else nil)))","user":"505d1b01e4b0e6aca564be04"},{"problem":73,"code":"(fn [board]\n   (let [three-x '(:x :x :x)\n         three-o '(:o :o :o)\n         forward-diagonal (list (ffirst board)\n                                (second (second board))\n                                (nth (nth board 2) 2))\n         backward-diagonal (list (nth (first board) 2)\n                                 (second (second board))\n                                 (first (nth board 2)))]\n     (cond\n       (= (map first board) three-x) :x\n       (= (map first board) three-o) :o\n       (= (map second board) three-x) :x\n       (= (map second board) three-o) :o\n       (= (map (fn [x] (nth board 2)) board) three-x) :x\n       (= (map (fn [x] (nth board 2)) board) three-o) :o\n       (= (first board) three-x) :x\n       (= (first board) three-o) :o\n       (= (second board) three-x) :x\n       (= (second board) three-o) :o\n       (= (nth board 2) three-x) :x\n       (= (nth board 2) three-o) :o\n       (= forward-diagonal three-x) :x\n       (= forward-diagonal three-o) :o\n       (= backward-diagonal three-x) :x\n       (= backward-diagonal three-o) :o\n       :else nil)))","user":"5600dccee4b04bb52996e175"},{"code":"(let [wins (fn [s t]\n(cond\n  (some identity (for [x (range 3)] (every? #(= s (nth % x)) t))) s\n  \n  (some identity (for [x (range 3)] (every? #(= s %) (nth t x)))) s\n  \n  (every? #(= s %) (for [x (range 3)] (nth (nth t x) x))) s\n  (every? #(= s %) (for [x (range 3)] (nth (nth t x) (- 2 x)))) s\n  \n  ))]\n\n#(cond \n  (wins :x %) :x\n  (wins :o %) :o\n))","problem":73,"user":"503917a0e4b088a6a14ca763"},{"problem":73,"code":"(fn [m]\n (let [c     (count m)\n       diag  [(map get m [0 1 2]) (map get m [2 1 0])]\n       inv-fq #(clojure.set/map-invert (frequencies %))\n       sets   (concat m (apply map vector m) diag)\n       freqs  (into {} (map inv-fq (remove #{[:e :e :e]} sets)))\n       win    (freqs 3)]\n      win))","user":"595914e0e4b066ee0a44af99"},{"problem":73,"code":"(fn [params] (let\n                [hor params\n                 ver (partition 3 (interleave (first params) (second params) (last params)))\n                 diag (vec [(vector ((first params) 0) ((second params) 1) ((last params) 2)) (vector ((first params) 2) ((second params) 1) ((last params) 0))])\n                 p1 [:o :o :o]\n                 p2 [:x :x :x]\n                 ] \n                (if (or (some #(= p1 %) hor) (some #(= p1 %) ver) (some #(= p1 %) diag)) :o (if (or (some #(= p2 %) hor) (some #(= p2 %) ver) (some #(= p2 %) diag)) :x nil)) ))","user":"5b7ed20fe4b047b03b203760"},{"problem":73,"code":"(fn [board]\n  (let [p? #(or (= :x %) (= :o %))\n        winner\n        (fn [rows]\n          (reduce (fn [win row]\n                    (if (and (every? p? row)\n                             (apply = row))\n                      (first row)\n                      win))\n                  nil\n                  rows))\n        horizontal?\n        (fn [board] (winner board))\n        vertical?\n        (fn [b] (winner\n                 (for [i (range 3)]\n                   (map #(nth % i) b))))\n        diagonal?\n        (fn [b]\n          (winner\n           (conj []\n                 (for [i (range 3)]\n                   (nth (nth b i) i))\n                 (loop [i 2 row [] [h & t] b]\n                   (if-not h\n                     row\n                     (recur (dec i)\n                            (conj\n                             row\n                             (nth h i))\n                            t))))))]\n     (or (horizontal? board)\n         (vertical? board)\n         (diagonal? board))))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":73,"code":"(fn [rows]\n  (let [transposed-rows (apply map vector rows)\n        diagonal (vector (map-indexed #(get %2 %1) rows))\n        reverse-diagonal (vector (map-indexed #(get %2 %1) (reverse rows)))\n        candidates (remove #(= [:e :e :e] %) (concat rows transposed-rows diagonal reverse-diagonal))]\n    (first (flatten (filter #(apply = %) candidates)))))","user":"5ba5802de4b0a20761a233fd"},{"code":"(fn checkboard2 [board] \n  (let [winnerline (fn [l] (reduce (fn [x y] (if (and (not= x :e) (= y x)) y nil)) l))]\n        (or (first (keep identity (for [i (range 0 3)]\n                                    (or (winnerline (nth board i))\n                                        (winnerline (map (fn [b] (nth b i)) board))))))\n            (winnerline (list (get-in board [0,0]) (get-in board [1,1]) (get-in board [2,2])))\n            (winnerline (list (get-in board [0,2]) (get-in board [1,1]) (get-in board [2,0]))))))","problem":73,"user":"4fae5401e4b081705acca249"},{"code":"(fn [b]\n    (let [possibilities [[[0 0] [0 1] [0 2]]\n                         [[1 0] [1 1] [1 2]]\n                         [[2 0] [2 1] [2 2]]\n                         [[0 0] [1 0] [2 0]]\n                         [[0 1] [1 1] [2 1]]\n                         [[0 2] [1 2] [2 2]]\n                         [[0 0] [1 1] [2 2]]\n                         [[0 2] [1 1] [2 0]]]\n          read-board (fn [possibility]\n                       (for [[i j] possibility] ((b i) j)))\n          winner (fn [p]\n                   (and (apply = p)\n                        (not= (first p) :e)))\n          the-wins (filter winner (map read-board possibilities))]\n      (if (seq the-wins)\n        (ffirst the-wins)\n        nil)))","problem":73,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn [board]\n    (let [row_winner\n          (fn [row] \n            (let [s (set row)]\n              (if (and (= 1 (count s)) (not (contains? s :e)))\n                (peek (vec s)) nil)))]\n      (let [rows (conj\n                   (concat board (apply mapv vector board))\n                   [((board 0) 0) ((board 1) 1) ((board 2) 2 )]\n                   [((board 2) 0) ((board 1) 1) ((board 0) 2 )])]\n        (println rows)\n        (->>\n          rows\n          (map #(row_winner %))\n          (reduce\n            (fn [a b]\n              (if (not (nil? a)) a b)))))))","problem":73,"user":"53527ce8e4b084c2834f4af1"},{"code":"(fn [b]\n  (let [m (fn [r] (map #(%1 %2) b r))\n        c (fn [] [(m (range 2 -1 -1))\n                  (m (range))\n                  (m (repeat 0))\n                  (m (repeat 1))\n                  (m (repeat 2))])\n        l (concat b (c))\n        x? #(= :x %)\n        o? #(= :o %)]\n    (cond (some #(= 3 (count (filter x? %))) l) :x\n          (some #(= 3 (count (filter o? %))) l) :o\n          :else nil)))","problem":73,"user":"4f32a7f1e4b0d6649770a095"},{"problem":73,"code":"(fn who [rows]\n  (let [[r1 r2 r3] rows\n        transpose #(apply map list %)\n        row-winner #(when (= (count (distinct %)) 1) ({:e nil} (first %) (first %)))]\n    (some row-winner (concat rows (transpose rows)\n                             [[(first r1) (second r2) (nth r3 2)]\n                              [(nth r1 2) (second r2) (nth r3 0)]]\n                             )\n          )))","user":"60436423e4b02d28681c77a3"},{"problem":73,"code":"(let [board_size 3\n      board-transpose (partial apply map list)]\n  (letfn [(win-horizontal? [player board]\n            (some (partial every? (partial = player))\n                  board))\n          \n          (win-vertical? [player board]\n            (win-horizontal? player (board-transpose board)))\n\n          (win-diagonal?\n            [player board]\n            (win-horizontal? player\n                             (board-transpose\n                              (for [n (range board_size)]\n                                [(nth (nth board n)\n                                      n)\n                                 (nth (nth board n)\n                                      (- board_size n 1))]))))\n\n          (win-board?\n            ([board]\n             (cond\n               (win-board? :x board) :x\n               (win-board? :o board) :o\n               :else nil))\n            ([player board]\n             (some #(% player board)\n                   [win-horizontal? win-vertical? win-diagonal?])))]\n    #(win-board? %)))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [b]\n  (->> (concat b (map #(map (fn [v] (nth v %)) b) '(0 1 2)) [[(ffirst b) (second (second b)) (last (last b))]]\n                                                            [[(last (first b)) (second (second b)) (first (last b))]])\n       (filter #(not-any? (fn [i] (= :e i)) %))\n       (filter #(= (first %) (second %) (last %)))\n       (ffirst)))","problem":73,"user":"51f28a64e4b0210f90e7454e"},{"code":"(fn [rows]\n   (let [dim (count rows)\n         indexes (range 0 dim) \n         cols (apply map vector rows)\n         diags (vector (map #(%1 %2) rows (reverse indexes)) (map #(%1 %2) rows indexes))\n         matches (distinct (filter #{:x :o} (map #(when (apply = %) (first %)) (concat rows cols diags))))]\n     (when (= 1 (count matches)) (first matches))))","problem":73,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":73,"code":"(fn tic-tac-toe-winner\n   [rows]\n   (let\n     [lines (cons\n             (list ((rows 0) 2) ((rows 1) 1) ((rows 2) 0))\n             (cons\n               (list ((rows 0) 0) ((rows 1) 1) ((rows 2) 2))\n               (concat\n                 rows\n                 (apply mapv vector rows))))]\n     (ffirst (filter #(not= :e (first %)) (filter #(apply = %) lines)))))","user":"56050f06e4b08b23635d3161"},{"code":"(fn [board]\r\n(let [third (fn [coll] (nth coll 2))\r\n      triplets (fn [board]\r\n        (concat board\r\n          [(map first board)]\r\n          [(map second board)]\r\n          [(map third board)]\r\n          [(vector (ffirst board)\r\n                   (second (second board))\r\n                   (third (third board)))]\r\n          [(vector (third (first board))\r\n                   (second (second board))\r\n                   (first (third board)))]))\r\n      wins? (fn [x triplets]\r\n        (when (some (fn [row] (every? #(= x %) row)) triplets) true))\r\n      x-wins? (wins? :x (triplets board))\r\n      o-wins? (wins? :o (triplets board))]\r\n  (cond (and x-wins? o-wins?) nil\r\n        x-wins? :x\r\n        o-wins? :o\r\n        :else nil)))","problem":73,"user":"4e89dbce535d3e98b8023283"},{"problem":73,"code":"(fn [b]\n  (let [w (fn [b s]\n            (or \n             (some #(= #{s} (set %)) b)\n             (some #(= #{s} (set (map % b))) [first second last])\n             (= #{s} (set [(first (first b)) (second (second b)) (last (last b))]))\n             (= #{s} (set [(first (last b)) (second (second b)) (last (first b))]))))]\n    (if (w b :x)\n      :x\n      (if (w b :o)\n        :o))))","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"(fn [board]\n  (let [[h1 h2 h3] board\n        [v1 v2 v3] (map vector h1 h2 h3)\n        d1 (vector (first h1) (second h2) (last h3))\n        d2 (vector (last h1) (second h2) (first h3))]\n    (some {[:x :x :x] :x [:o :o :o] :o}\n      [h1 h2 h3 v1 v2 v3 d1 d2])))","problem":73,"user":"4daee8e9edd6309eace4d166"},{"problem":73,"code":"(fn [rows]\n  (let [cols (apply map vector rows)\n        diags [(map #(get-in rows %) [[0 0] [1 1] [2 2]])\n               (map #(get-in rows %) [[2 0] [1 1] [0 2]])]]\n    (->> (concat rows cols diags)\n         (filter #(apply = %))\n         first\n         (some #{:x :o}))))","user":"550f1c99e4b06e50f9beb171"},{"code":"(fn tic-tac-toe- [board]\r\n  (->> board ; rows                                                                                                                                                     \r\n       (cons (map first board)) ; col1                                                                                                                                  \r\n       (cons (map second board)) ; col2                                                                                                                                 \r\n       (cons (map last board)) ; col3                                                                                                                                   \r\n       (cons (list (ffirst board) (second (second board)) (last (last board)))) ; diag1                                                                                 \r\n       (cons (list (first (last board)) (second (second board)) (last (first board)))) ; diag1                                                                          \r\n       (filter (partial apply not= :e)) ; ignore empty rows                                                                                                             \r\n       (filter (partial apply =)) ; keep winning rows                                                                                                                   \r\n       (ffirst) ; return the winner                                                                                                                                     \r\n       ))","problem":73,"user":"4f11b078535d64f603146422"},{"problem":73,"code":"(fn evaluate-board\n  [board]\n  (let [board (apply concat board)\n        winning-conditions [[0 1 2]\n                            [3 4 5]\n                            [6 7 8]\n                            [0 3 6]\n                            [1 4 7]\n                            [2 5 8]\n                            [0 4 8]\n                            [2 4 6]]\n        winning-rows (map (fn [condition]\n                            (map (fn [index]\n                                   (nth board index))\n                                 condition))\n                          winning-conditions)]\n    (cond \n      (some #(every? #{:x} %) winning-rows) :x\n      (some #(every? #{:o} %) winning-rows) :o\n      :else nil)))","user":"5fe5a64de4b05ac5b16ea187"},{"problem":73,"code":"(fn tic-tac-toe [t]\n  (letfn [(won? [sq]\n            (if (and (every? #(= (first sq) %) sq) (not (= (first sq) :e)))\n              (first sq)))]\n    (let [f1 (t 0)\n          f2 (t 1)\n          f3 (t 2)\n          c1 [(f1 0) (f2 0) (f3 0)]\n          c2 [(f1 1) (f2 1) (f3 1)]\n          c3 [(f1 2) (f2 2) (f3 2)]\n          h1 [(f1 0) (f2 1) (f3 2)]\n          h2 [(f1 2) (f2 1) (f3 0)]\n          ]\n      (reduce (fn [ac s] (if-not ac (won? s) ac)) nil [f1 f2 f3 c1 c2 c3 h1 h2])\n      )\n    )\n  )","user":"5fee18f2e4b05ac5b16ea1d2"},{"code":"(fn [ttt]\n  (let [\n    ptrn-match \n      (fn [pl ptrn]\n        (every? #(= pl %) (ptrn ttt)))\n    ptrns [first, second, last, \n          #(map first %)\n          #(map second %)\n          #(map last %)\n          (partial map-indexed #(nth %2 %))\n          (partial map-indexed #(nth %2 (- 2 %)))]\n    ]\n  (some \n    #(some \n      (fn [p] (if (ptrn-match % p) % nil))\n      ptrns)\n    [:x :o])))","problem":73,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [bd] (let [all-r [[[0 0][0 1][0 2]][[1 0][1 1][1 2]][[2 0][2 1][2 2]][[0 0][1 1][2 2]]\n              [[2 0][1 1][0 2]][[0 0][1 0][2 0]][[0 1][1 1][2 1]][[0 2][1 2][2 2]]]               \n              win? (fn [r] (if (and (apply = r) (not= :e (first r))) (first r) nil))]\n              (reduce #(if (nil? %1) %2 %1) (map win? (for [r all-r] (map #(get-in bd %) r)))) ))","problem":73,"user":"53512bc6e4b084c2834f4ae1"},{"code":"(fn [board] \n  (let [won?\n    (fn [s] \n      (not (empty?\n        (filter #(= (list s s s) %) \n          (concat board (vec (apply map vector board)) \n          (list (vector (get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])))\n          (list (vector (get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])))\n      ))))\n    )]\n    (cond\n      (won? :x) :x\n      (won? :o) :o\n    )\n))","problem":73,"user":"504e685fe4b0f6ff3350c4ae"},{"problem":73,"code":"(fn [b]\n  (let [ss (-> b\n               (into (apply map list b))\n               (conj (flatten (partition 1 4 (flatten b))))\n               (conj (flatten (partition 1 2 (drop 2 (take 7 (flatten b))))))\n               )]\n    (->> ss\n         (filter (comp #{:x :o} first))\n         (filter #(apply = %))\n         ffirst)))","user":"5571d6e5e4b09a3098a5253f"},{"problem":73,"code":"(fn game [bd]\n   (let [funcs [first second last]]\n      (->> (seq (conj (concat bd\n                        (map #(map % bd) funcs))\n                      (map #(%1 %2) funcs bd)\n                      (map #(%1 %2) (reverse funcs) bd)))\n           (map #(reduce (fn [x y] (if (= x y) x nil)) %))\n           (filter #(not= nil %))\n           (first)\n           (#(if (= % :e) nil %)))))","user":"5471f0f3e4b094393f72dd6f"},{"problem":73,"code":"(fn [b] (let [wpos '((1 2 3)\n                     (4 5 6)\n                     (7 8 9)\n                     (1 4 7)\n                     (2 5 8)\n                     (3 6 9)\n                     (1 5 9)\n                     (3 5 7))\n              val-at (fn [n brd]\n                       (nth (reduce into [] brd) n))\n              inpos? (fn [p brd]\n                       (or (if (reduce #(and %1 %2)\n                                       (map #(= :o (val-at (- % 1) brd))\n                                            p))\n                             :o)\n                           (if (reduce #(and %1 %2)\n                                       (map #(= :x (val-at (- % 1) brd))\n                                            p))\n                             :x)))]\n          (some #(if (not (= nil %))\n                   %)\n                (map #(inpos? %1 b) wpos))))","user":"50981062e4b04e098a4c7268"},{"problem":73,"code":"(fn ttt [board]\n  (letfn [(winnerrow? [row ch] (reduce #(and %1 (= %2 ch)) true row))\n          (winnercol? [col ch] (winnerrow? (map #(nth % col) board) ch))\n          (winnerdiag? [ch] (or (every? true? (map #(= (nth %1 %2) ch) board (range 0 3)))\n                                (every? true? (map #(= (nth %1 %2) ch) board (range 2 -1 -1)))))\n          (winner? [ch] (or (some true? (map #(winnerrow? % ch) board))\n                            (some true? (map #(winnercol? % ch) (range 0 3)))\n                            (winnerdiag? ch)))]\n    (cond (winner? :x) :x\n          (winner? :o) :o\n          :else nil)))","user":"560843dee4b046a4fc0ac00e"}]