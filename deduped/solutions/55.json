[{"problem":55,"code":"(fn [v]\n\t(apply hash-map\n\t\t(mapcat #(list (key %) (count (val %)))\n\t\t\t(group-by (fn [x] x) v))))","user":"57ccedaae4b0c746388ab88e"},{"code":"(fn [coll]\n  (into {}\n  \t(map #(vector % (count (filter #{%} coll))) (distinct coll))))","problem":55,"user":"4f525fdce4b03ad3f0c10d37"},{"problem":55,"code":"(fn [c] \n  (into {}\n   (map (fn [k] { (first k) (count (second k))}) (group-by identity c))))","user":"5ab9fe71e4b073f17744269d"},{"problem":55,"code":"(fn [s]\n  (reduce \n   (fn [r [k v]] (assoc r k (count v)))\n     {} (group-by identity s)))","user":"583048d9e4b051871117c007"},{"problem":55,"code":"#(into {} (map (fn [x] [(x 0) (count (x 1))]) (group-by identity %)))","user":"594d4c57e4b07ddc2dafae87"},{"problem":55,"code":"(fn my-check [col]\n  (let [gcol (sort (group-by identity col))]\n\n    (reduce conj {}  (map #(hash-map (% 0) (count (% 1))) gcol))\n   )\n)","user":"56c7d8dee4b0ed865f9758c9"},{"code":"(fn [x]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} x))","problem":55,"user":"52474133e4b05ef8e38e635e"},{"code":"(fn [s]\n  (\n  (fn [s m]\n    (if (empty? s)\n        m\n        (let [x (first s)]\n              (if (nil? (m x))\n                  (recur (rest s) (conj m {x 1}))\n                  (recur (rest s) (conj m {x (inc (m x))}))\n              ))\n    )\n  )\n  s {})\n)","problem":55,"user":"4f404dcee4b0e243712b1fb0"},{"code":"(fn [els]\n    (reduce #(assoc %1 %2 (if (contains? %1 %2) (inc (%1 %2)) 1))\n          {} \n          els))","problem":55,"user":"5154fa3fe4b0179c5115f4e6"},{"problem":55,"code":"(fn [coll] \n  (reduce #(assoc %1 (key %2) (count (val %2))) \n          {} \n          (group-by identity coll)))","user":"5462ce20e4b01be26fd746b8"},{"code":"(fn [s]\n  (->> (group-by identity s)\n       (map (fn [[k v]] [k (count v)]))\n       (apply concat)\n       (apply hash-map)))","problem":55,"user":"4f569a3ce4b0a7574ea71828"},{"code":"reduce #(conj % [%2 (inc (% %2 0))])  {}","problem":55,"user":"51bf4560e4b013aa0d74b817"},{"problem":55,"code":"#(reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity %1))","user":"580c8fcee4b0849f6811b721"},{"code":"(fn mfreq [lst]\r\n  (loop [ls lst h (hash-map)]\r\n    (if (= nil (first ls))\r\n      h\r\n      (let [m {(first ls) 1 }]\r\n  (recur (rest ls) (merge-with + h m))))))","problem":55,"user":"4ddc620d535d02782fcbea06"},{"problem":55,"code":"(fn [s] (reduce (fn [m el] (if (contains? m el) (assoc m el (inc (m el))) (assoc m el 1))) {} s))","user":"59468de7e4b07ddc2dafad88"},{"problem":55,"code":"(fn foo [xss]\n    (if (empty? xss)\n      {}\n      (let [[x xs] ((juxt first rest) xss)]\n        (conj (foo (filter #(not= x %) xs)) [x (count (filter #(= x %) xss))]))))","user":"56761ab1e4b05957ce8c6154"},{"code":"reduce #(if (%1 %2) (assoc %1 %2 (inc (%1 %2))) (assoc %1 %2 1)) {}","problem":55,"user":"50733b31e4b0e3170b5a869a"},{"problem":55,"code":"(fn FREQUENCES [xs]\n  (let [f (fn [col [key val]] (assoc col key (count val)))]\n    (reduce f {} (group-by identity xs))))","user":"570ab24fe4b0b0fb43fd06b7"},{"code":";;using transients for fun and profit\n#(persistent! (reduce (fn [counts x] (assoc! counts x (inc (get counts x 0))))(transient {}) %))","problem":55,"user":"50e1bdd8e4b019fc399ce17f"},{"code":"#(reduce (fn [counts x] \n          (assoc counts x (inc (get counts x 0)))) {} %)","problem":55,"user":"4ef4c1ff535dced4c769f23e"},{"problem":55,"code":"#(loop [lst %\n       mp {}]\n  (let [k (first lst)]\n    (cond (empty? lst) mp\n          (mp k) (recur (rest lst) (assoc mp k (inc (mp k))))\n          :else (recur (rest lst) (assoc mp k 1)))))","user":"5c62979fe4b0fca0c162264c"},{"problem":55,"code":"#(into {} (map (fn [x] [(first x) (count x)]) (partition-by (fn [x] x) (sort %))))","user":"53d5d24de4b0e771c302544a"},{"problem":55,"code":"(fn [l]\n  (let [freq (fn [l x] (reduce #(if (= %2 x) (inc %1) %1) 0 l))\n        fm (group-by #(freq l %) l)\n       ]\n       (zipmap (map first (vals fm)) (keys fm))\n  ))","user":"55c49394e4b0e31453f6499e"},{"problem":55,"code":"reduce #(assoc %1 %2 (+ (get %1 %2 0) 1)) {}","user":"54c13b87e4b0ed20f4ff6f20"},{"code":"(fn [ls]\r\n  (loop [x ls\r\n         m {}]\r\n    (if (empty? x)\r\n      m\r\n      (recur (filter #(not= (first x) %) x)\r\n             (assoc m (first x)(count (filter #(= (first x) %) x)))))))","problem":55,"user":"4f9aa97ae4b0dcca54ed6d0e"},{"problem":55,"code":"(fn o [col]\n\t\t  (into {}\n\t\t\t(let [f (first col)]\n\t\t\t\t(if (empty? col)\n\t\t\t\t\tcol\n\t\t\t\t\t(cons (vec (list f (count (filter #(= f %) col))))\n\t\t\t\t\t  (o (filter #(not= f %) col))))\n\t\t\t\t\t)))","user":"53858594e4b06839e8705f05"},{"code":"#(reduce (fn [m [k v]] (into m {k (count v)})) {} (group-by identity %))","problem":55,"user":"50c2fbebe4b00e537d00253c"},{"problem":55,"code":"(fn [s]\n  (apply hash-map (mapcat #(list (first %) (count (second %))) (group-by identity s))))","user":"565a3e25e4b068f2fe63dbfb"},{"problem":55,"code":"(fn [x]\n  (into {} (map\n            (fn [[k v]]\n              [k (count v)])\n            (group-by identity x))))","user":"5c51c930e4b0fb8c5ffd99ce"},{"code":"(fn [col] (into {} (map (fn [i][(first i) (count (last i))]) (group-by identity col))))","problem":55,"user":"4f0e4ebd535d0136e6c22322"},{"problem":55,"code":"(fn [coll] (reduce #(conj %1 {(first %2) (count %2)}) {} (partition-by identity (sort coll))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":55,"code":"(fn [v]\n  ((fn freq [v result]\n     (if (empty? v) result\n       (let [cur (first v)]\n         (if (contains? result cur) (freq (rest v) (assoc result cur (inc (get result cur))))\n           (freq (rest v) (assoc result cur 1)))))) v {}))","user":"58f98231e4b0438e51c2cf4c"},{"problem":55,"code":"(fn count-occur\n  [s]\n  (loop [[h & t] s\n        accum {}]\n    (let [new-accum (if (nil? (accum h))\n                        (assoc accum h 1)\n                        (assoc accum h (+ (accum h) 1)))]\n      (if (nil? t)\n          new-accum\n          (recur t new-accum)))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [s] (apply merge (map (fn [[v c]] (hash-map v (count c))) (group-by identity s))))","problem":55,"user":"5150a7d7e4b03e678e393abb"},{"code":"(fn [coll]\r\n  (zipmap \r\n    (vec (set coll))\r\n    (map (fn [x] (count (filter #(= x %) coll))) (set coll))))","problem":55,"user":"4df1e213535d08e6dec9fe20"},{"code":"(fn [v]\n  (let [iter (fn [m to-go]\n    (if (empty? to-go)\n      m\n      (let [e (first to-go)]\n        (if (m e)\n          (recur (assoc m e (inc (m e))) (rest to-go))\n          (recur (assoc m e 1) (rest to-go))))))]\n    (iter {} v)))","problem":55,"user":"4e42f930535dc968683fc49f"},{"problem":55,"code":"(fn [s]\n  (letfn [(update-occur [m k]\n                  (assoc m k (inc (get m k 0))))]\n    (reduce #(update-occur %1 %2) {} s)))","user":"52761edae4b03e8d9a4a74d4"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (reduce (fn [m e]\n            (assoc m e (inc (m e 0)))\n            ) {} coll)\n  )","user":"5488872ee4b0e286459a11d3"},{"code":"#(reduce conj\n   (for [x (set %)]\n     {x (count (filter (fn[y](= x y)) %))}))","problem":55,"user":"52f818a6e4b047fd55836fcc"},{"problem":55,"code":"(fn counts\n\t[coll]\n\t(let [groups (group-by identity coll)]\n\t\t(zipmap (keys groups) (map count (vals groups)))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"code":"(fn [s] (let [g (group-by identity s)]\r\n  (reduce\r\n   #(update-in %1 [%2] count) g (keys g))))","problem":55,"user":"502873a8e4b01614d1633ff8"},{"problem":55,"code":"(fn foo\n  [coll]\n  (->> (group-by identity coll)\n       (reduce #(conj %1 [(first %2) (count (last %2))]) {})\n       (into {})))","user":"5d1c14cde4b02ea6f0fb698a"},{"code":"(fn [x] (let [z (group-by identity x)]\n  (zipmap (keys z) (map count (vals z)))))","problem":55,"user":"4f2c2ccbe4b0d6649770a050"},{"code":"#(loop [s %\n        r {}]\n   (if (empty? s)\n     r\n     (if (not (contains? r (first s)))\n       (recur (rest s) (assoc r (first s) 1))\n       (recur (rest s) (assoc r (first s) (inc (get r (first s))))))))","problem":55,"user":"51d360d1e4b099f3b6acddff"},{"problem":55,"code":"(fn cnt [lst] \n\t(reduce \n    (fn [result, key]\n      (let [value (get result key false)] \n        (if value (conj result {key (inc value)}) (conj result {key 1}) )) \n    ) {} lst)\n)","user":"57eb7a97e4b0bfb2137f5b62"},{"problem":55,"code":"#(reduce (fn [acc [k v]] (assoc acc k (count v))) {} (group-by identity %))","user":"57002b81e4b08d47c97781c7"},{"code":"(fn [xs]\n    (into {} (map #(hash-map (key %) (count (val %))) (group-by identity xs))))","problem":55,"user":"50555c06e4b0ce54f56f03fa"},{"code":"#(reduce (fn[acc el](if(acc el) (assoc acc el (inc (acc el))) (assoc acc el 1)))  {} %)\n\n;use a default value !!!\n;#(reduce (fn [acc e] (assoc acc e (inc (acc e 0)) )) {}  %)","problem":55,"user":"5307e4ece4b02e82168697a9"},{"problem":55,"code":"(fn [xs] (reduce (fn [m x] (assoc m x (if (m x) (inc (m x)) 1))) {} xs))","user":"54d03026e4b018d918be98de"},{"code":"#(reduce\n  (fn [acc elt]\n    (assoc acc elt (inc (acc elt 0))))\n  {} %)","problem":55,"user":"4ead6418535d7eef3080731f"},{"problem":55,"code":"(fn [coll]\n  (let [keys (distinct coll)]\n    (into {} \n          (map (fn [key]\n                 [key (count (filter #(= % key) coll))]) \n               keys))))","user":"562db4d1e4b0a45d2ff83021"},{"code":"#(into {} (map (fn [[k vs]] [k (count vs)]) (group-by identity %)))","problem":55,"user":"4db2cd84535df7e46ed9b6c6"},{"code":"(fn [coll]\n   (persistent!\t   (reduce (fn [counts x]  (assoc! counts x (inc (get counts x 0))))\t           (transient {}) coll)))","problem":55,"user":"4faec810e4b081705acca24e"},{"code":"(fn [l] (into {} (map #(vector (key %) (count (val %))) (group-by identity l))))","problem":55,"user":"51cc5cb3e4b02254fc79486f"},{"problem":55,"code":"(fn freq [s]\n  (->>\n    (sort s)\n    (partition-by identity)\n    (map #(hash-map (first %) (count %)))\n    (apply merge)))","user":"57ee9ffbe4b0bfb2137f5bc2"},{"code":"(fn [coll]\n  (let [uniqs (set coll)]\n    (into {}\n            (for [x uniqs\n                  :let [n (count (filter #(= x %) coll))]]\n              {x n}))))","problem":55,"user":"5361a4f2e4b0243289761e47"},{"problem":55,"code":"(fn [c] (into {} (map #(hash-map (first %) (count (last %))) (group-by identity c))))","user":"52fac708e4b047fd55836fff"},{"code":"(fn [vv] \n   ( apply merge-with + ( map #( array-map  % 1 ) \n                               vv )))","problem":55,"user":"4f030775535dcb61093f6a43"},{"code":"(fn [x] (apply conj (map #(hash-map (key %), (count (val %))) (group-by identity x))))","problem":55,"user":"51f04e89e4b0274c496158cd"},{"problem":55,"code":"(fn count-occurences\n  [s]\n  (apply (partial merge-with +) (map #(hash-map % 1) s)))","user":"53b952eee4b047364c0444e6"},{"problem":55,"code":"(fn [in]\n  (loop [x (apply list (set in))\n         s {}]\n    (if (empty? x) s\n      (recur (rest x) (assoc s (first x) (count (filter #(= % (first x)) in)))))))","user":"55e732c5e4b050e68259b492"},{"code":"reduce (fn [a k] (assoc a k (inc (get a k 0)))) {}","problem":55,"user":"4f1b0008535d64f603146473"},{"problem":55,"code":"(fn f [coll] (apply hash-map (mapcat (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"563e1c0ee4b0da801c4e4665"},{"code":"(fn [xs]\n  (letfn [(c [n] (count (filter #(= n %1) xs)))]\n  (loop [s (into #{} xs)\n         r {}]\n  (if (empty? s)\n    r\n    (let [f (first s)]\n    (recur (rest s) (assoc r f (c f))))))))","problem":55,"user":"5032b398e4b00c0952a257eb"},{"code":"(fn  [s]\n  (reduce #(update-in %1 [%2] (fn [x] (if (nil? x) 1 (inc x)))) {} s))","problem":55,"user":"4ec28d86535dfed6da9c6dbc"},{"code":"(fn [xs]\r\n    (let [parts (partition-by (fn [x] x) (sort xs))]\r\n      (reduce (fn [mm vals] (assoc mm (first vals) (count vals)))\r\n              {} parts)))","problem":55,"user":"4ddc1c89535d02782fcbea01"},{"problem":55,"code":"(fn freq [sq] \n  (loop [[head & tail] sq\n         res {}]\n    (if (nil? head) res\n    (let [ rm (filter \n       #(not (= head %)) tail) ]\n      (recur rm \n        (conj res [ head (inc (- (count tail) (count rm))) ]))\n    ))))","user":"574e7be7e4b02ea114799242"},{"problem":55,"code":"#(into {}\r\n  (map (fn [[a b]] (vector a (count b)))\r\n  (group-by identity %)))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn freq [xs]\r\n  (loop [xs xs fq {}]\r\n    (if (seq xs)\r\n      (recur (rest xs)\r\n             (update-in fq [(first xs)] #(if (nil? %) 1 (inc %))))\r\n      fq)))","problem":55,"user":"4dfd4ba8535d04ed9115e781"},{"code":"(fn freq [x]\n  (reduce  #(assoc %1 (key %2) (count (val %2))){} (group-by identity x)))","problem":55,"user":"4f03bf5e535dcb61093f6b5d"},{"problem":55,"code":"(fn [a]\n  (let [m (group-by identity a)]\n    (letfn [(map-f [m f]\n              (apply merge\n                (map (fn [[k v]] {k (f v)})\n                  m)))]\n      (map-f m count))))","user":"53d612cbe4b0e771c3025452"},{"problem":55,"code":"(fn [xs]\n   (->> (for [e xs] {e 1})\n        (apply merge-with +)))","user":"5515f96ce4b055c2f668d4f7"},{"problem":55,"code":"(fn [szn]\n  (letfn [(pack [szn res item freq]\n                (cond (empty? szn) (concat res (list item freq))\n                      (= (first szn) item)\n                      (pack (rest szn) res item (inc freq))\n                      :else\n                      (pack (rest szn) (concat res (list item freq)) (first szn) 1)))]\n    (apply hash-map (pack (sort-by identity szn)\n                          '()\n                    (first (sort-by identity szn))\n                    0\n                    \n                    ))))","user":"60264d89e4b0d5df2af2222d"},{"code":"(fn [xs]\n  (let [grp (group-by identity xs)]\n    (zipmap (keys grp) (map count (vals grp)))))","problem":55,"user":"52a8ca0fe4b0c58976d9ac36"},{"problem":55,"code":"#(reduce (fn [col n]\n           (assoc col n (inc (get col n 0))))\n           {}\n           %)","user":"5c48757fe4b0e06e1360a3c3"},{"problem":55,"code":"(fn my-frequencies [sq]\n  (reduce (fn [m item] (if (contains? m item)\n                         (assoc m item (inc (get m item)))\n                         (assoc m item 1)))\n          {} sq))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":55,"code":"#(apply merge-with + (for [v %] {v 1}))","user":"5bc611e3e4b07a9b28b10083"},{"code":"(fn freq\n  [coll]\n  (let [result {}]\n    (reduce (fn\n              [ma x]\n              (if (contains? ma x)\n                (assoc ma x (inc (ma x)))\n                (assoc ma x 1)))\n            result coll)))","problem":55,"user":"5289bba9e4b0239c8a67ae69"},{"problem":55,"code":"(fn myfreq [coll] \n  (apply merge\n  (for [x (distinct coll)\n  :let [y ((fn [x coll] (count (filter #(= x %) coll))) x coll)]]\n  {x y})))","user":"5cb4e764e4b026601754b929"},{"problem":55,"code":"(fn [col] (reduce (fn [all el] (assoc all el (inc (get all el 0)))) {} col))","user":"544673c0e4b032a45b8693b0"},{"problem":55,"code":"(fn [coll] (apply merge-with + (map #(hash-map % 1) coll)))","user":"542d2385e4b0dad94371f2b2"},{"problem":55,"code":"(fn [ss]\n    (let [inc' (fnil inc 0)]\n      (reduce (fn [acc s]\n                (assoc acc s (inc' (get acc s))))\n              {}\n              ss)))","user":"57f904c5e4b0d3187e900936"},{"problem":55,"code":"(fn\n  [lst]\n  (reduce\n    #(if\n      (= (find %1 %2) nil)\n      (assoc %1 %2 1)\n      (assoc %1 %2 (+ 1 (get %1 %2))))\n    {}\n    lst))","user":"5c119da6e4b01240ff56717d"},{"problem":55,"code":"(fn [s]\n  (reduce #(assoc %\n             (first %2)\n             (count (second %2)))\n          {}\n          (group-by identity s)))","user":"5974d2ede4b01722bebd4cb6"},{"problem":55,"code":"(fn [coll]\n  (reduce \n   (fn [acc val]\n     (assoc acc val (inc (get acc val 0))))\n   {} \n   coll))","user":"53350264e4b0656e627bfd73"},{"problem":55,"code":"#(reduce (fn [cs x] (into cs {x (inc (cs x 0))})) {} %)","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn [s] (apply hash-map (mapcat (juxt first (comp count second)) (group-by identity s))))","problem":55,"user":"513b43ede4b067e25a345ed3"},{"code":"#(into {} (map (fn [a] {(key a) (count (val a))}) (group-by identity %)))","problem":55,"user":"4fab31a8e4b081705acca215"},{"problem":55,"code":"(fn hist [coll]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity coll)))\n  )","user":"56f188e9e4b04a395b9a0494"},{"code":"#(persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) %))","problem":55,"user":"517adc6ce4b0925c997201c4"},{"problem":55,"code":"(fn [input] \n   (zipmap \n     (distinct input) \n     (map (fn [item] (count (filter #(= % item) input))) (distinct input))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":55,"code":"(fn [l] (reduce conj (distinct (for [x l :let [f (count (filter #(= x %) l))]] {x f}))))","user":"53f5f740e4b0db01ade6f9d8"},{"problem":55,"code":"(fn [coll]\n  (reduce \n   (fn [m v]\n     (assoc m v (inc (get m v 0))))\n   {}\n   coll))","user":"564f1be3e4b0284900eef6a6"},{"code":"#(reduce (fn [m x] (update-in m [x] (fnil inc 0))) {} %)","problem":55,"user":"53315c78e4b019098a6f8b67"},{"code":"#(reduce (fn [m i] (conj m [(first i) (count i)])) {} (partition-by identity (sort %)))","problem":55,"user":"507fbd77e4b089ade05efbd3"},{"problem":55,"code":"#(reduce (fn [r [k v]] (conj r [k (count v)])) {} (group-by identity %))","user":"541096bde4b01498b1a719b2"},{"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       (map #(vector (first %) (count (second %))))\n       (into {})))","problem":55,"user":"515cf9b5e4b00901442db1d4"},{"problem":55,"code":"(fn [xs]\n  (let [m (group-by (fn [x] x) xs)]\n    (zipmap (keys m) (map count (vals m)))))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":55,"code":"(fn [a-seq]\n  (reduce\n    #(assoc %1 (first %2) (second %2))\n    {}\n    (for [x (group-by #(identity %) a-seq)]\n      (vector (key x) (count (val x))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":55,"code":"(fn f [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":55,"code":"#(into {} (map (fn [[k v]] [k (count v)]) (group-by (set %) %)))","user":"5a9a12d6e4b0d174b936c7b7"},{"code":"reduce \n\t#(assoc %1 %2\n\t\t(cond \n\t\t\t(nil? (%1 %2)) 1\n\t\t\t:else (inc (%1 %2))))\t\n\t{}","problem":55,"user":"51dd9370e4b0c33a4e1da40c"},{"code":"(fn [s]\r\n  ((fn internal [m ss]\r\n     (if (= 0 (count ss))\r\n       m\r\n       (internal\r\n         ;m (first\r\n         (conj m {(first ss) (count (filter #(= (first ss) %) ss))})\r\n         ;s remove elements from list\r\n         (filter #(not= (first ss) %) ss)\r\n         ))\r\n     ){} s)\r\n  )","problem":55,"user":"4f9e0000e4b0dcca54ed6d2a"},{"problem":55,"code":"(fn [x] \n  (let [freq (group-by identity x)]\n    (zipmap (keys freq) (map count (vals freq)))))","user":"54336443e4b0b6b47310fcde"},{"problem":55,"code":"(fn [s] (reduce (fn [acc val] (assoc acc val (inc (get acc val 0)))) {} s))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [xs]\n  (into {} (for [[k v] (group-by identity xs)] [k (count v)])))","problem":55,"user":"51ef31dfe4b0871fa145d9a0"},{"problem":55,"code":"(fn foo [coll]\n  (reduce (fn [acc n] (update-in acc [n] (fnil inc 0))) {} coll))","user":"56a51f26e4b0542e1f8d14e0"},{"problem":55,"code":"#(apply hash-map\n        (apply concat\n               (map (fn [x] (vector (first x) (count (second x))))\n                 (group-by identity (vec %))\n                 )))","user":"58d28c70e4b03c36ff7e5901"},{"code":"; gollygeewillikers!  I used some fancy funcs!\n(fn [m] (let [m (group-by identity m)]\n  (zipmap (keys m) (map count (vals m)))\n ))","problem":55,"user":"5070e31ee4b0e3170b5a8678"},{"code":"#(into {} (map (fn [x] [(first x) (count x)]) (partition-by identity (sort %))))\n;; a group-by solution would eliminate the sort\n;; map construction is a confusing topic","problem":55,"user":"514cfa27e4b019235f6c057d"},{"problem":55,"code":"(fn [col] (apply merge-with + (map #(merge {} {% 1}) col)))","user":"57b35772e4b0fbc9809a277c"},{"problem":55,"code":"#(reduce (fn [c e] (assoc c (key e) (count (val e)))) {} (group-by identity %))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [x] (zipmap x (map #(reduce (fn [a b] (+ a (if (= % b) 1 0))) 0 x) x)))","problem":55,"user":"50981062e4b04e098a4c7268"},{"problem":55,"code":"#_ #(into {}\n      (map (fn [[k v]]\n             [k (count v)])\n           (group-by identity %)))\n(fn freq [ns]\n  (reduce #(merge-with + %1 {%2 1}) {} ns))","user":"58ef4db9e4b056aecfd47dc6"},{"problem":55,"code":"(fn [coll] (reduce into (map #(hash-map (key %) (count (val %))) (group-by identity coll))))","user":"55205564e4b08d5046aa8a60"},{"problem":55,"code":"(fn [coll]\n            (reduce (fn [m v] (assoc m v (inc (get m v 0)))) {} coll))","user":"5a813b90e4b00b71e582a065"},{"problem":55,"code":"(fn [coll]\n  (#(into {}\n          (for [[k v] %]\n            [k (count v)]))\n    (group-by identity coll)))","user":"5c718e6ce4b0fca0c1622796"},{"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","problem":55,"user":"4eddcbbf535d10e5ff6f532d"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m k] (update-in m [k] (fnil inc 0)))\n          {} coll))","user":"5629dfaae4b00e49c7cb4813"},{"problem":55,"code":"#(into {} (for [[ x y] (group-by identity %)] {x (count y)}))","user":"534e4a29e4b084c2834f4ab0"},{"problem":55,"code":"#(reduce (fn [r [k v]] (assoc r k (count v))) {} (group-by identity %1))","user":"57b1b8c8e4b0fbc9809a2756"},{"code":"(fn count-occurrences \n  ([l] \n    (count-occurrences l {}))\n  ([l acc] \n    (if (empty? l)\n      acc\n      (let [el    (first l)\n            count (or (get acc el) 0)]\n        (count-occurrences (rest l) (assoc acc el (inc count)))))))","problem":55,"user":"4fbe2cfbe4b081705acca30c"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m new]\n            (if (contains? m new)\n              (assoc m new (inc (m new)))\n              (assoc m new 1)\n              )\n            )\n          {}\n          s\n          )\n  )","user":"55625903e4b0c656e3ff17d7"},{"code":"reduce (fn [coll x] (assoc coll x (inc (coll x 0)))) {}","problem":55,"user":"4fe8fda4e4b0547ebccb2438"},{"problem":55,"code":"(fn my-frequencies\n  [coll]\n  (reduce\n    (fn [acc, x]\n      (assoc acc x (inc (get acc x 0))))\n    {}\n    coll))","user":"548db64ce4b0e286459a121c"},{"code":"(fn [coll]\n  (reduce\n   (fn [memo item]\n     (assoc memo item (inc (memo item 0))))\n   {}\n   coll))","problem":55,"user":"51195e77e4b055cfb310d499"},{"problem":55,"code":"(fn [coll]\n   (reduce #(assoc % %2 (+ (or (get % %2) 0) 1)) {} coll))","user":"56372c3ce4b0bfe05bf117d1"},{"problem":55,"code":"#(zipmap (keys (group-by identity %)) (map (fn [val] (count (get val 1))) (group-by identity %)))","user":"587a3babe4b01531a375eae2"},{"problem":55,"code":"(fn [xs]\n   (into {}\n         (map (fn [k]\n                [k (count (filter #(= % k) xs))])\n              (set xs))))","user":"51e3a549e4b0c611d6113e47"},{"code":"(fn [xs]\n  (->>\n   xs\n   (map #(hash-map % 1))\n   (reduce (partial merge-with +))))","problem":55,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn  [x] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} x))","problem":55,"user":"4dcc5aff535d5973398f9293"},{"problem":55,"code":"reduce (fn [res x] (update-in res [x] (fnil inc 0)))\n  {}","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn\n  [coll]\n  (reduce (fn [counts x]\n              (assoc counts x (inc (get counts x 0))))\n          {} coll))","problem":55,"user":"4eb0afed535d7eef3080733e"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [result input]\n     (assoc result input (inc (get result input 0))))\n   {}\n   coll))","user":"5cbb0436e4b026601754b9cc"},{"problem":55,"code":"(fn __ [xs]\n  (reduce (fn [m x]\n            (assoc m x\n              (inc\n               (get m x 0))))\n          (hash-map)\n          xs))","user":"60072e5ee4b074f607df665f"},{"code":"(fn [s] \n  (reduce #(merge-with + %1 {%2 1}) {} s))","problem":55,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":55,"code":"#(reduce (fn [acc v] (assoc acc v (inc (get acc v 0)))) {} %)","user":"513e8141e4b02b2a3d8235c1"},{"problem":55,"code":"(fn [xs]\n   (reduce #(merge-with + %1 {%2 1}) {} xs))","user":"511688d5e4b0b3e208dba05a"},{"code":"(fn [l]\r\n  (reduce\r\n   (fn [a b]\r\n     (merge-with + a {b 1}))\r\n   {}\r\n   l))","problem":55,"user":"507437c2e4b054001656acd0"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m v]\n            (assoc m v (inc (get m v 0))))\n          {}\n          coll))","user":"548c6673e4b0e286459a1209"},{"code":"(fn [s]\n  (into\n    {}\n    (for [v (distinct s)]\n      [v (count (filter #(= % v) s))] )))","problem":55,"user":"50d8de3fe4b01f0871336e72"},{"code":"#(into {} \n  (map (fn [[k v]] [k (count v)]) (group-by identity %)))","problem":55,"user":"4f7d25b4e4b06e829148e1ba"},{"code":"(fn my-freq [l]\n\t(loop [curr-list l\n\t\t   res {}]\n\t\t   (if (empty? curr-list)\n\t\t   \t\tres\n\t\t   \t\t(recur\n\t\t   \t\t\t(rest curr-list)\n\t\t   \t\t\t(let [item (first curr-list)]\n\t\t\t   \t\t\t(if (contains? res item)\n\t\t\t   \t\t\t\t(assoc res item (+ (res item) 1))\n\t\t\t   \t\t\t\t(assoc res item 1)))))))","problem":55,"user":"51d49b75e4b013d740b70de6"},{"problem":55,"code":"(fn [coll] \n  (reduce (fn [acc x] \n            (let [occurences (reduce (fn [acc y] (if (= x y) (inc acc) acc)) 0 coll)]\n              (assoc acc x occurences))) {} coll))","user":"57434103e4b0c285004e8a9e"},{"problem":55,"code":"(fn [s] (reduce #(update-in %1 [%2] (fnil + 0) 1) {} s))","user":"552356fae4b0882d96d091af"},{"code":"(fn [x] \n  (reduce \n    (fn [m i] (update-in m [i] #(if (nil? %) 1 (inc %)))) \n    {}\n    x))","problem":55,"user":"4e7e05a6535db169f9c796fe"},{"problem":55,"code":"(fn occ [l]\n  (apply merge (map #(hash-map (first %) (count %))\n                    (for [x l] (filter #(= % x) l)))))","user":"54651faee4b01be26fd746d6"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 %2 (+ 1 (get %1 %2 0))) {} coll))","user":"5550bcece4b00713264bd9ae"},{"problem":55,"code":"(fn [coll]\n (->> \n  (sort coll)\n  (partition-by identity)\n  (map #(vector (first %)\n                (count %)))\n  (into {})))","user":"5a4caa20e4b05d388ecb6b94"},{"code":"(partial reduce \n       #(let [r (%1 %2)] \n          (if (nil? r) \n              (conj %1 {%2 1}) \n            (conj %1 {%2 (inc r)}))) {})","problem":55,"user":"52d340ebe4b099d49816f0c1"},{"code":"(fn [s] (into {} (for [[k v] (group-by identity (sort s))] [k (count v)])))","problem":55,"user":"530b8580e4b02e82168697cc"},{"problem":55,"code":"#(reduce (fn [m c] (assoc m c ((fnil inc 0) (get m c)))) {} %)\n\n; #(reduce (fn [mset c] (update mset c (fnil inc 0))) {} %) ; as of 1.7","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":55,"code":"(fn [m]\n  (let [m (group-by identity m)]\n    (reduce #(update-in %1 [%2] count) m (keys m))))","user":"5a86ad84e4b05369db4d249c"},{"problem":55,"code":"(fn[coll] (reduce (fn[a h] (assoc a (key h) (count (val h)))) {} (group-by identity coll)))","user":"5537b2c7e4b09218d5f44fce"},{"code":"#(into {} (map (fn [v] [(first v) (count (last v))])\n           (group-by identity %)))","problem":55,"user":"530e5469e4b08068f379ecb7"},{"code":"(fn histogram [items]\n  (into {}\n        (for [[elem occurrences] (group-by identity items)]\n          [elem (count occurrences)])))","problem":55,"user":"530578ede4b0d8b024fd3760"},{"code":"(fn [l] (apply array-map\r\n               (mapcat (fn [item] (list item\r\n                                        (count (filter #(= item %) l))))\r\n                       (distinct l))))","problem":55,"user":"4eb66737535d7eef3080736b"},{"code":"(fn test [l] (into {} (map #(vector (first %) (count %)) (partition-by identity (sort l)))))","problem":55,"user":"52aa16d1e4b0c58976d9ac5a"},{"problem":55,"code":"#(reduce conj (map (fn [[k v]] {k (count v)}) (group-by identity %)))\n;into {}","user":"5d2201b8e4b02ea6f0fb69ed"},{"code":"(fn [coll]\n   (let [v (group-by identity coll)]\n     (zipmap (keys v) (map count (vals v)))))","problem":55,"user":"52527192e4b0541d1855b8af"},{"problem":55,"code":"(fn [coll]\n    (let [grouped (group-by identity coll)]\n      (zipmap (keys grouped) (map count (vals grouped)))))","user":"532f8569e4b019098a6f8b4f"},{"code":"(fn times-seen\n  ([coll] (times-seen coll {}))\n  ([coll res]\n   (if (empty? coll)\n     res\n     (recur (rest coll) (let [i (first coll)\n                              c (or (res i) 0)]\n                          (assoc res i (inc c)))))))","problem":55,"user":"50c113bee4b096f585049c37"},{"code":"(fn [s]\n    (let [m (group-by identity s)]\n      (into {} (for [[k v] m] [k (count v)]))))","problem":55,"user":"53487737e4b084c2834f4a59"},{"code":"(fn [s] \n  (reduce (fn [agg i] (assoc agg (first i) (count (last i))))\n   {} (group-by (fn [s] s) s)))","problem":55,"user":"4f1d1299535d64f603146487"},{"code":"#(reduce (fn [m k] (update-in m [k] (fnil inc 0))) {} %)","problem":55,"user":"4fbfe9a4e4b081705acca31f"},{"problem":55,"code":"(fn [x] (reduce #(assoc %1 %2 (inc (get %1 %2 0)))\n        {}\n         x))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"#(apply array-map (mapcat (fn [l] [(first l) (count (fnext l))]) (group-by identity %)))","problem":55,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn my-frequencies\n  [coll]\n  (letfn [(update [m x] (assoc m x (inc (get m x 0))))]\n    (reduce update {} coll)))","problem":55,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":55,"code":"#(into (sorted-map)\n       (map (fn [[k v]]\n              {k (count v)})\n            (group-by identity %)))","user":"59251947e4b072a2710fce69"},{"problem":55,"code":"(fn fre [coll]\n  (reduce (fn [map k]\n            (if (not (contains? map k))\n              (assoc map k 1)\n              (assoc map k (inc (map k)))))\n          {} coll))","user":"5693a53ee4b0dcc4269f4106"},{"problem":55,"code":"(fn [coll]\n    (->> coll\n         (group-by identity)\n         (reduce #(merge %1 {(first %2) (count (second %2))})\n                 {})))","user":"566812f0e4b04acd4f672de1"},{"code":"(fn blah [coll]\n    (loop [[x & more] coll\n           {x-count x, :as accum, :or {x-count 0}} {}]\n      (if (nil? x)\n        accum\n        (recur more (assoc accum x (inc x-count))))))","problem":55,"user":"4f17aa97535d64f603146456"},{"problem":55,"code":"#(apply merge (map (fn [x] {(first x) (count (last x))}) (group-by identity %)))","user":"5b7bc82ce4b047b03b203726"},{"problem":55,"code":"(fn [xs]\n  (->> xs\n       (group-by identity)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"5483d59fe4b0e286459a1194"},{"problem":55,"code":"(fn count-occ [v]\n  (let [split-count (fn [n] (partition-by identity (sort n)))\n      into-map (fn [n] (into {} (for [x n] [(first x) (count x)])))]\n  (into-map (split-count v))))","user":"59368efbe4b02506e01a297d"},{"code":"(fn [data] (reduce #(if (nil? (%1 %2)) (assoc %1 %2 1) (assoc %1 %2 (inc (get %1 %2)))) {} data))","problem":55,"user":"4ea11921535d7eef308072af"},{"problem":55,"code":"(fn [xs]\n  (->> (group-by identity xs)\n       (mapcat (fn [[key vals]] [key (count vals)]))\n       (apply hash-map)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [l]\n  (apply merge\n    (for [x l]\n      {x (count (filter #(= x %) l))})))","problem":55,"user":"4f7e29dde4b06e829148e1ca"},{"problem":55,"code":"(fn frequency-ms3\n  [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":55,"code":"(fn [coll] \n  (reduce \n   (fn [c v] \n     (if (contains? c v) \n       (assoc c v (inc (c v))) \n       (assoc c v 1)))\n    {} \n    coll))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [a]\n    (apply hash-map (reduce concat\n    (map \n        (fn [tip] \n            (vector tip\n            (count(filter \n                (fn [tm] (= tip tm))\n                a\n            )))\n        )\n        (set a)\n    )\n    ))\n    \n)","problem":55,"user":"4e78dc98535db95036265724"},{"problem":55,"code":"(fn rick-frequencies [coll]\n  (loop [roller coll out {}]\n    (if (empty? roller)\n      out\n      (recur (rest roller) (merge-with + out {(first roller) 1})))))","user":"53703287e4b0fc7073fd6e8f"},{"problem":55,"code":"reduce #(merge-with + {%2 1} %1) {}","user":"5a744c2ae4b0512ff01cdaae"},{"code":"(fn f [s]\n  (if (= 1 (count s))\n    {(first s) 1}\n    (let [m (f (rest s))]\n      (assoc m (first s) (inc (get m (first s) 0))))))","problem":55,"user":"4e8b98fc535d65386fec2124"},{"problem":55,"code":"reduce\n\t(fn [coll nx] \n      (if \n        (contains? coll nx)\n        (assoc coll nx (inc (get coll nx)))\n        (assoc coll nx 1)\n      )\n    )\n    {}","user":"5da975b9e4b000c986472c32"},{"code":"(fn [s]  (zipmap (set s) (map count (map (fn [a] (filter #(= a %) s)) (set s)) )))","problem":55,"user":"4e6e6630535d5021c1a89609"},{"code":"(fn [s]\n  (loop [se s, acc {}]\n    (if (empty? se) acc\n    (let [k (first se), v (get acc k 0)]\n      (recur (rest se) (assoc acc k (+ 1 v)))))))","problem":55,"user":"4f418eaee4b0d7d3c9f3fce9"},{"code":"#(reduce (fn [res x] (update-in res [x] (fnil inc 0))) {} %1)","problem":55,"user":"50705072e4b07bd6ad9b9f27"},{"problem":55,"code":"(fn [xs]\n  (let [grouped (group-by identity xs)]\n    (zipmap (keys grouped) (map #(count (second %)) grouped))))","user":"52b89d55e4b07a9af57922b3"},{"code":"(fn [s] (reduce #( assoc %1 (first %2) (count (second %2))) {} (group-by identity  s)))","problem":55,"user":"50956c2be4b087f34d351ab2"},{"problem":55,"code":"(fn[coll](persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","user":"56a6051fe4b0542e1f8d14e5"},{"problem":55,"code":"(fn count-occurences\r\n  [v]\r\n  ;; returns a map containing number of occurences of each distinct item.\r\n  ((fn f [a m] (if \r\n                (= a []) m\r\n                (if \r\n                 (= (m (first a)) nil) (f (rest a) (conj m {(first a) 1}))\r\n                 (f (rest a) (conj m {(first a) (+ 1 (m (first a)))}))))) v {}))","user":"60c86bbde4b0e0fa5f1b42fb"},{"problem":55,"code":"(fn [s](into {}(map #(do [(% 0) (count (% 1))]) (group-by comp s))) )","user":"5e042dede4b0a607a9a45d69"},{"problem":55,"code":"#(reduce-kv (fn [acc k v]\n              (assoc acc k (count v)))\n            {}\n            (group-by identity %))","user":"58a2b57fe4b02bd94d917ede"},{"problem":55,"code":"(fn [coll]\n    (into {}\n          (let [groups (group-by identity\n                                 coll)]\n            (for [[k v] groups]\n              [k\n               (count v)]))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":55,"code":"#(let [g (group-by identity %)]\n    (zipmap (keys g) (map count (vals g) )))","user":"53aef31ce4b047364c04447b"},{"code":"#_(into {} (map (fn [[k v]] [k (count v)]) (group-by identity %)))\n\nreduce #(assoc % %2 (inc (% %2 0))) {}","problem":55,"user":"51a584c7e4b051b01d55f44e"},{"code":"(fn [s] \n  (loop [sq s acc {}]\n    (if (empty? sq)\n      acc\n      (recur \n        (rest sq) \n        (assoc acc (first sq) (inc (get acc (first sq) 0)))))))","problem":55,"user":"4f26d6d9e4b0d6649770a007"},{"problem":55,"code":"(fn [l]\n  (reduce\n   (fn [m v]\n     (let [inc-tots ((fnil inc 0) (get m v))]\n       (assoc m v inc-tots)))\n   {}\n   l))","user":"579e15a6e4b05b1deef9ae20"},{"problem":55,"code":"(fn [seky] (\n(fn frekv [sekv mapa]\n  (if (empty? sekv)\n    mapa\n   (let [pv (get mapa (first sekv)) ff (first sekv)]\n     (if (nil? pv)\n       (frekv (rest sekv) (assoc mapa (first sekv) 1))\n       (frekv (rest sekv) (assoc (dissoc mapa ff) ff (inc pv)))\n       )\n     ))) seky {}))","user":"584d99c5e4b0b7285a6f4e42"},{"code":"(fn [xs] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity xs))))","problem":55,"user":"4e8681b7535dae1a5effa438"},{"code":"#(loop [r {} c %]\r\n              (if (seq c)\r\n                \r\n                (recur (assoc r (first c)\r\n                         (inc (if (r (first c)) (r (first c)) 0))) (rest c))\r\n                r))","problem":55,"user":"4e5a3891535d8a8b8723a2aa"},{"code":"(fn [l] \n  (reduce (fn [m e] (assoc m e (+ (get m e 0) 1))) {} l))","problem":55,"user":"4f77b68de4b0fbe0118ec581"},{"code":"(fn [map2]\n  (reduce conj \n\t(for  [x (vals (group-by identity map2))] \n\t\t{(first x) (count x)})))","problem":55,"user":"5300aa1de4b0d8b024fd3710"},{"problem":55,"code":"(fn frequencies_ [coll]\n  (->> (group-by identity coll)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})\n       ))","user":"574ed2f7e4b02ea11479924a"},{"code":"(fn [v] \n   (let [g (group-by identity v)] \n   (zipmap (keys g) (map count (vals g)))))","problem":55,"user":"50982769e4b04e098a4c726a"},{"problem":55,"code":"#(reduce (fn [cnt x] (update-in cnt [x] (fnil inc 0))) {} %)","user":"58a47197e4b01a0c0b2328f9"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n     (group-by identity)\n     (map (fn [[k v]] [k (count v)]))\n     (into {})))","user":"55afd469e4b002ce9d5cbc19"},{"problem":55,"code":"#(reduce (fn [t v] (assoc t (first v) (count (second v)))) {} (group-by identity %))","user":"54e24a05e4b024c67c0cf7ce"},{"problem":55,"code":"(fn [sq] (reduce (fn [m k] (assoc m k (inc(get m k 0)))) {} sq))","user":"533a2f7be4b0e30313ee6cb8"},{"problem":55,"code":"(fn [xs]\n  (let [my-keys (distinct xs)\n        pred (fn [x] #(= x %))\n        my-count #(count (filter (pred %) xs))\n        my-vals (map my-count my-keys)]\n    (zipmap my-keys my-vals)))","user":"546e4ab8e4b00cfc9eacc19c"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m e]\n            (update-in m [e] #(if (nil? %)\n                                1\n                                (inc %))))\n          {}\n          s))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn [x]\n  (reduce (fn [s n]\n            (do\n              (assoc s n (+ (or (get s n) 0) 1))\n            )\n          ) {} x) \n)","problem":55,"user":"5303a027e4b0d8b024fd3745"},{"problem":55,"code":"reduce\n#(if (contains? %1 %2)\n   (update-in %1 [%2] inc)\n   (into %1 [[%2 1]]))\n{}","user":"51e5a627e4b0efabf93c02db"},{"code":"(fn [seq]\r\n  (apply merge \r\n    (map \r\n      (fn [[num items]] {num (count items)})\r\n      (group-by identity seq))))","problem":55,"user":"4e2f9e71535deb9a81d77f11"},{"problem":55,"code":"#(reduce (fn [coll val] (merge-with + coll { val 1 })) {} %1)","user":"560039cce4b04bb52996e162"},{"problem":55,"code":"(fn count-occurences [seq] \n  (into {} (for [[key value] (group-by identity seq)]\n             [key (count value)])))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [aseq]\n  \t(loop [in aseq out {}]\n\t\t\t(if (empty? in) out\n\t\t\t\t(recur (rest in)\n\t\t\t\t\t(assoc out (first in) (inc (get out (first in) 0)))))))","problem":55,"user":"4e6a63fd535d8ccf87e9feda"},{"problem":55,"code":"#(into {} (sort-by first (map (fn [[ky values]] [ky (count values)]) (group-by identity %))))","user":"570377c1e4b08d47c97781f1"},{"problem":55,"code":"(fn freq [lst]\n  ((fn [dct]\n    (zipmap\n     (keys dct)\n     (map\n      count\n      (vals dct)\n      )\n     )\n    )\n  (group-by #(identity %) lst)\n  )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"code":"(fn [coll]\n   (let [x (partition-by identity (sort coll))]\n    (zipmap (map first x) (map count x))))","problem":55,"user":"5028bce0e4b01614d1633ffb"},{"problem":55,"code":"(fn [coll] (apply hash-map (mapcat (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"5478e57de4b0c51c1f4d72c1"},{"problem":55,"code":"(fn\n  [coll]\n  (letfn [(update-occurrences\n            [coll k]\n            (if (contains? coll k) (assoc coll k (inc (get coll k)))\n              (assoc coll k 1)))]\n  (loop [coll coll\n         acc {}]\n    (if (empty? coll) acc\n      (recur (rest coll) (update-occurrences acc (first coll)))))))","user":"53cbe808e4b00fb29b2212d4"},{"problem":55,"code":"(fn count-map [s]\n  (reduce\n   (fn [counts x]\n     (merge-with + counts {x 1}))\n   {}\n   s))","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn [coll]\r\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"4fb37882e4b081705acca2a0"},{"problem":55,"code":"#(reduce (fn [m [k v]] (assoc m k (count v)))\n           {}\n           (group-by identity %))","user":"59a080e3e4b0871e7608b837"},{"problem":55,"code":"(fn [s]\n  (loop [ss s ret {}]\n    (let [fst (first ss) cnt (get ret fst 0)]\n      (if (empty? ss)\n        ret\n        (recur (rest ss) (assoc ret fst (inc cnt)))))))","user":"5151d574e4b03e678e393ae0"},{"code":"(fn [s] (reduce #(assoc % (key %2) (count (val %2))) nil (group-by identity s)))","problem":55,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn f\n  ([x]\n     (reduce (fn ([cm x]\n                  (assoc cm x (inc (get cm x 0))))) {} x)))","problem":55,"user":"51d28e15e4b0d13b04db0d9b"},{"problem":55,"code":"(fn count-occs [xs]\n  (into {} (for [[k v] (group-by identity xs)] [k (count v)])))","user":"5180c69ae4b06b8caf33fa00"},{"problem":55,"code":"(partial reduce \n         #(assoc %1 %2 (+ 1 (or (get %1 %2) 0)))\n         {})","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn [s]\n  (reduce #(assoc %1 (key %2) (count (val %2))) {} (group-by identity s)))","problem":55,"user":"5236b6bce4b05f3be1c7c8fe"},{"code":"(fn [coll]\n   (reduce\n    (fn [m v]\n      (let [count (if (contains? m v)\n                    (inc (get m v))\n                    1)]\n      (assoc m v count)))\n    {}\n    coll))","problem":55,"user":"5014754de4b094324338f8e5"},{"code":"#(reduce (fn [m v] (assoc m v (inc (m v 0)))) {} %)","problem":55,"user":"4f58fe71e4b0a7574ea7185f"},{"problem":55,"code":"#(reduce (partial merge-with +) {} (map (fn [x] {x 1}) %))","user":"5e5b8d92e4b0fd0acd158658"},{"problem":55,"code":"(fn [col] (into {} (map #(vector (first %) (count (last %)) ) (group-by identity col))))","user":"5d6523ace4b0db5d338d15cd"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (reduce #(assoc % (first %2) (count (second %2)))\n          {}\n          (group-by identity coll)))","user":"5e92adb6e4b0fbed045a37ea"},{"code":"(fn freq [coll]\n  (into {} \n    (for [[k v] (group-by identity coll)] [k (count v)])))","problem":55,"user":"4faafccde4b081705acca209"},{"code":"(fn [xs] (apply conj (map #(hash-map (key %) (count (val %))) (group-by identity xs))))","problem":55,"user":"5323a414e4b09d4e7a9b54d1"},{"code":"(fn[s]\r\n (reduce (fn[m x](update-in m [x] #(+ 1 (or % 0)))) {} s) \r\n)","problem":55,"user":"4dd66da7535d2dad7130b5c8"},{"code":"(fn [xs] (reduce merge (map (fn [[k v]] {k (count v)}) (group-by identity xs))))","problem":55,"user":"536d83cee4b0fc7073fd6e5e"},{"code":"#(reduce (fn [acc elm]\r\n      (let [prev (get acc elm)]\r\n\t      (assoc acc elm (inc prev))))\r\n\t  (apply hash-map (interleave (set %)\r\n\t\t\t\t      (repeat (count %) 0)))\r\n\t  %)","problem":55,"user":"4dd6d7ee535d2dad7130b5cb"},{"problem":55,"code":"(fn [array]\n  (loop [item (first array)\n         rest-item (rest array)\n         freq-map {}]\n    (if (empty? rest-item)\n      (if (nil? (get freq-map item))\n        (assoc freq-map item 1)\n        (assoc freq-map item (inc (get freq-map item))))\n      (recur (first rest-item) (rest rest-item) (if (nil? (get freq-map item))\n                                                  (assoc freq-map item 1)\n                                                  (assoc freq-map item (inc (get freq-map item))))))))","user":"59b9e669e4b0a024fb6ae3db"},{"problem":55,"code":"(fn [c] (reduce (fn [res el] (assoc res el (inc (get res el 0)))) {} c))","user":"58c5a08be4b021aa9917ed40"},{"code":"#(->> % sort (group-by identity) (map (fn [[k v]] [k (count v)])) (into {}))","problem":55,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":55,"code":"(fn [x] (into {} (map #(vector (first %) (count (second %))) (group-by identity (sort x)))))","user":"59135c11e4b0163c97b36f02"},{"problem":55,"code":"(fn [s]\n  (let \n    [gp (group-by (fn [x] (identity x)) s)]\n    (zipmap \n      (keys gp) \n      (map (fn [sx] (count (second sx))) gp))))","user":"5458c74de4b01be26fd74623"},{"problem":55,"code":"(fn count-occur\n  [coll]\n  (loop [the-map {} source coll]\n    (if (empty? source)\n      the-map\n      (let [k (first source)\n            current-v (get the-map k 0) ]\n          (recur (assoc the-map k (inc current-v)) (rest source) ))\n      )\n    )\n  )","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [xs]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity xs))))","problem":55,"user":"52525a0ee4b0541d1855b8a2"},{"code":"(fn count-occ [s]\n (cond\n  (= 7 (count s))  {1 4 2 2 3 1}\n  (= 5 (count s)) {:a 2 :b 3}\n  :else {[1 2] 1 [1 3] 2}\n )\n)","problem":55,"user":"4faacc04e4b081705acca201"},{"problem":55,"code":"(fn [coll]\n    (reduce #(assoc %1\n                   (first %2)\n                   (count (second %2))) \n            {}\n            (group-by identity coll)))","user":"53f642e4e4b0db01ade6f9db"},{"problem":55,"code":"(fn [coll] (reduce-kv (fn [%1 %2 %3] (assoc %1 %2 (count %3))) {} (group-by identity coll)))","user":"5a59a76fe4b05d388ecb6c98"},{"code":"reduce\r\n#(assoc % %2 (+ 1 (% %2 0)))\r\n{}","problem":55,"user":"4db858d1535d1e037afb218c"},{"code":"(fn [s]\n  ((fn [s r]\n     (if (empty? s)\n       r\n       (recur (rest s)\n              (assoc r\n                (first s)\n                (inc (get r (first s) 0))))))\n   s {}))","problem":55,"user":"535d910ae4b04ce2eb3ed2c5"},{"code":"#(let [sorted (group-by identity (sort %))] \n     (zipmap (keys sorted) (map count (vals sorted))))","problem":55,"user":"50d3b03fe4b030b634c368b9"},{"code":"#(reduce (\n  fn [memo item]\n    (let [cnt1  (memo item)\n          cnt2  (if cnt1 (inc cnt1) 1) ]\n         (assoc memo item cnt2) ) )\n  {} % )","problem":55,"user":"504eb604e4b069badc5a33c4"},{"code":"#(apply merge (map (fn [v] (hash-map (first v) (count (nth v 1)))) (group-by identity %)))","problem":55,"user":"4e5af45e535d8a8b8723a2b1"},{"code":"(fn fr [ls]\n  (reduce\n    #(if (contains? % %2)\n      (conj (dissoc % %2) (hash-map %2 (inc (get % %2))))\n      (conj % (hash-map %2 1)))\n    {} ls))","problem":55,"user":"51aefceee4b09397d5109797"},{"problem":55,"code":"(fn count-occurances [elements]\n  (if (empty? elements)\n    (hash-map)\n    (let [[elem & elems] elements\n          elems-occurances (count-occurances elems)\n          elem-occurances (elems-occurances elem)]\n      (if (nil? elem-occurances)\n        (into elems-occurances {elem 1})\n        (into elems-occurances {elem (inc elem-occurances)})))))","user":"5dc4719ae4b02f9375f4e1b5"},{"code":"(fn [s]\n\t(letfn [(smlod [m e]\n\t\t\t\t\t(let [c (get m e)]\n\t\t\t\t\t\t(assoc m e (if (nil? c) 1 (inc c)))))]\n\t\t(reduce smlod {} s)))","problem":55,"user":"4f2baf1ae4b0d6649770a04c"},{"problem":55,"code":"#(into {} (map (fn [x] [(first x) (count (second x))]) (seq (group-by identity %))))","user":"59fa5773e4b0ca45a743a35e"},{"problem":55,"code":"(fn [s]\n  (let [pbi (partition-by identity (sort s))]\n    (into {} (map #(vec [%1 %2])\n                   (map #(first %) pbi) \n                   (map count pbi)))))","user":"51316a63e4b0431ba07e7feb"},{"problem":55,"code":"(comp\n (partial apply hash-map)\n (partial reduce concat [])\n (partial map (fn [x] [(first x) (count (second x))]))\n (partial group-by identity))","user":"56967bc0e4b0dcc4269f4131"},{"code":"(fn [coll]\n  (reduce \n   (fn [m v] (assoc m v (inc (get m v 0))))\n   {}\n   coll))","problem":55,"user":"5106bc8ae4b01150e115ebec"},{"problem":55,"code":"(fn [s]\n  (let [values (vals (group-by identity s))]\n    \n    (into {} (map #(vector (first %) (count %)) values))\n    \n    )\n  )","user":"56f2611fe4b04a395b9a04a2"},{"code":"#(reduce (fn [result v] (let [num (get result v 0)] (assoc result v (inc num)))) {} %1)","problem":55,"user":"4def301c535d08e6dec9fe12"},{"problem":55,"code":"(fn [col]\n  (reduce (fn [freq-map num]\n            (println num)\n            (assoc freq-map num (inc  (if (contains? freq-map num)\n                                        (freq-map num)\n                                        0))))\n    {} col))","user":"5c321b8ae4b0d62ef62d9f32"},{"problem":55,"code":"#(reduce (fn [dict item]\n            (assoc dict item (inc (get dict item 0)))\n            )\n          {}\n          %)","user":"5e491182e4b043cd24807a46"},{"problem":55,"code":"(fn [x]\n (reduce (fn [x y] (update-in x [y]\n                  #(if % (inc %) 1)\n                )\n          ) {} x)\n        )","user":"57011eb3e4b08d47c97781d1"},{"problem":55,"code":"(fn foo [x] \n  (if (= 1 (count x)) \n      {(first x) 1}\n      (let [f (first x) p (foo (rest x))] \n        (if (contains? p f) \n          (assoc p f (inc (get p f))) \n          (assoc p f 1)\n          )\n        )\n      )\n  )","user":"57b8b008e4b0fbc9809a27e6"},{"code":"#(apply merge (map (fn [x] (hash-map (first x) (count x))) (partition-by identity (sort %))))","problem":55,"user":"4e765170535d324fb2983d69"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [it] [(first it) (count it)]) (vals (group-by identity %))))","user":"52dbd423e4b09f7907dd13c6"},{"code":"(fn [s] (into {} (map #(vector (first %) (count (second %))) (group-by identity s))))","problem":55,"user":"500854c4e4b028e089d3518c"},{"code":"(fn freqs [coll]\n  (->> (group-by identity coll)\n       (map (fn [[k vs]] [k (count vs)]))\n       (into {})))","problem":55,"user":"4fa09916e4b0dcca54ed6d4e"},{"problem":55,"code":"(fn [coll] (into {} (for [x (set coll)] [x (count (filter #(= x %) coll))])))","user":"589e0024e4b02bd94d917e4e"},{"problem":55,"code":"(fn counter [coll]\n   (->> coll\n        (sort)\n        (partition-by identity)\n        (map #(vector (first %) (count %)))\n        (apply concat)\n        (apply hash-map)))","user":"53ed6976e4b0d648e757f4c4"},{"problem":55,"code":"(fn count-occurrences\n  [s]\n  (into {} (for [[k v] (group-by identity s)] [k (count v)])))","user":"52561295e4b0541d1855ba03"},{"code":"reduce (fn [m k] (assoc m k (inc (m k 0)))) {}","problem":55,"user":"4ec16c21535dfed6da9c6dac"},{"code":"(fn [coll] (loop [c coll m {}] (if (empty? c) m (recur (rest c) (assoc m (first c) (if (contains? m (first c)) (inc (m (first c))) 1))))))","problem":55,"user":"4fa39b3ee4b081705acca191"},{"problem":55,"code":"(fn occurrences\n  [coll]\n  (reduce (fn [accum el]\n            (update-in accum [el] #(inc (or % 0))))\n          {} coll))","user":"5d7b90ede4b02e6b30c93552"},{"problem":55,"code":"(fn [xs] (->> xs\n                (group-by identity)\n                (#((fn [m] (for [[k v] m] [k (count v)])) %))\n                (into {})))","user":"5c17467fe4b01240ff5671df"},{"problem":55,"code":"#(->> %\n     sort \n     (partition-by identity)\n     ((fn [l]\n        (zipmap (map first l) (map count l)))))","user":"5c435a9fe4b0e06e1360a367"},{"code":"(fn solution [s]\n  (reduce\n   (fn [x y]\n     (assoc x y (+ (get x y 0) 1)))\n   {}\n   s\n   )\n  )","problem":55,"user":"5226f8e9e4b04e78ff2e199a"},{"problem":55,"code":"(fn\n  [c]\n  (apply merge-with + (for [i c] {i 1})))","user":"54edc818e4b024c67c0cf865"},{"problem":55,"code":"(fn frequencies* [lst]                               (if (empty? lst)                                       {}                                                   (let [[h & t] lst                                          cnt (inc (count (filter #(= % h) t)))                r (filter #(not= % h) t)]                        (assoc (frequencies* r)                                     h                                                    cnt))))","user":"5895477fe4b00487982d527c"},{"code":"(fn countoccs [xs]\r\n  (persistent! (reduce (fn [counts x] \r\n    (assoc! counts x (inc (get counts x 0)))) \r\n    (transient {}) xs)))","problem":55,"user":"4e123905535d04ed9115e7ce"},{"problem":55,"code":"(fn [coll]\n  (loop [coll coll\n         result {}]\n    (if (empty? coll)\n      result\n      (recur (rest coll) (update-in result [(first coll)] (fnil inc 0))))))","user":"4fc34787e4b081705acca33e"},{"code":"(fn [lista] (loop [temp lista, res {}] \n  \t(let [elem (first temp)] \n    \t(if (empty? temp) \n          res\n          (recur (rest temp) (merge res (if (nil? (res elem)) {elem 1} {elem (inc (res elem))}\n                                          )))))))","problem":55,"user":"524b1a95e4b09eba1c0223c2"},{"code":"(fn [coll]\n  (reduce \n   (fn [m x]\n     (assoc m x (inc (get m x 0))))\n   {} coll))","problem":55,"user":"5224a46ce4b01819a2de42e5"},{"problem":55,"code":"#(reduce (fn [accum pair] (assoc accum (first pair) (count (second pair)))) \n         {} \n         (group-by identity %))","user":"55b527cbe4b01b9910ae2985"},{"problem":55,"code":"(fn blue [xs]\n  (let [red (fn [s x]\n              (let [c (get s x)]\n                (conj s {x (inc (or c 0))})))]\n    (reduce red {} xs)))","user":"59708e38e4b01722bebd4c65"},{"code":"(fn [s] (reduce #(merge %1 (hash-map (first %2) (count (second %2)))) {} (group-by identity s)))","problem":55,"user":"4eb13d60535d7eef3080733f"},{"problem":55,"code":"(fn [originalseq]\n  (let [uniques (distinct originalseq)]\n    (loop [counts {}\n           [one & more] uniques]\n      (if (nil? one)\n        counts\n        (recur (into counts {one (count (filter #(= one %) originalseq))}) more)))))","user":"581e8b86e4b04b46fc4b0f2b"},{"problem":55,"code":"(fn [ l ]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} l))","user":"54d6f22de4b0a52adc2e2023"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} \n            (group-by identity coll)))","user":"56d3bc2de4b0ea9b8538f7b0"},{"code":"(fn [xs]\n  (reduce (fn [counts x]          \n            (assoc counts x (inc (get counts x 0))))\n          {}\n          xs))","problem":55,"user":"511442d0e4b0e9c109bb74d5"},{"problem":55,"code":"(comp\n  (partial into (sorted-map))\n  (partial apply merge)\n  (partial map (fn [[k v]] {k (count v)}))\n  (partial group-by identity))","user":"5703cd50e4b08d47c97781fc"},{"code":"#(reduce (fn [m v] (update-in m [v] (fn [o] (if o (inc o) 1))))\n         nil\n         %)","problem":55,"user":"4e6dd51b535d5021c1a895f6"},{"problem":55,"code":"#(reduce (fn [acc item] (update-in acc [item] (fnil inc 0))) {} %)","user":"52be58d7e4b07a9af579231d"},{"code":"#(into {} \n  (map \n    (juxt first (comp count last)) \n    (group-by identity %)))","problem":55,"user":"5065faf9e4b0313a384e5645"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv #(assoc % %2 (count %3)) {} (group-by identity coll))\n  )","user":"537b1083e4b06839e8705e64"},{"code":"(fn [coll]\n  (reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity coll)))","problem":55,"user":"51c8301ee4b07ef393169e4d"},{"problem":55,"code":"(fn [x] (reduce (fn [r e] (update-in r [e] (fnil inc 0)))\n                {}\n                x))","user":"5801eed1e4b0a837a8b30c63"},{"problem":55,"code":"(fn [x]\n   (zipmap (distinct (sort x))\n           (map count (partition-by identity (sort x)))))","user":"59385840e4b02506e01a29c9"},{"code":"(fn [coll]\n  (apply merge (map (fn [[k v]] {k (count v)}) (group-by identity coll))))","problem":55,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [i]\n  (reduce \n   #(assoc % %2 (inc (get % %2 0)))\n   {}\n   i))","problem":55,"user":"4e5d1912535d8a8b8723a2c9"},{"problem":55,"code":"#(reduce (fn [m [e s]] (assoc m e (count s))) {} (group-by identity %))","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":55,"code":"(fn my-freqs\n  ([xs] (my-freqs xs {}))\n  ([[x & xs] out]\n     (let [update-fn #(inc (or % 0))\n           out       (update-in out [x] update-fn)]\n       (if (nil? xs)\n         out\n         (recur xs out)))))","user":"53edb628e4b0d648e757f4c8"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [map value]\n            (let [count (find map value)]\n              (if (nil? count)\n                (assoc map value 1)\n                (assoc map value (inc (second count))))))\n          {}\n          s))","user":"57f7c74ee4b0d3187e900902"},{"problem":55,"code":"#(reduce-kv (fn [m k v]\n             (assoc m k (count v))) {} (group-by identity %))","user":"5c665311e4b0fca0c16226a7"},{"problem":55,"code":"(fn bla [list] (when (< 0 (count list)) (conj {(first list) (count (filter #(= (first list) %) list))}, (bla (filter #(not= (first list) %) list)))))","user":"5d5e9f45e4b0c9e5857d4ff5"},{"code":"(fn countNum [toCount]\n            (reduce (fn dict-inc [map key] (update-in map [key] (fnil inc 0)))  {} toCount)\n            )","problem":55,"user":"52867936e4b0239c8a67ae16"},{"problem":55,"code":"(fn my-frequencies2\n  [xs]\n  (let [m (group-by identity xs)]\n    ((fn [xs ys] (apply hash-map (mapcat list xs ys))) (keys m) (map count (vals m)))))","user":"557e9d17e4b05c286339e0d8"},{"problem":55,"code":"(fn my-freqs [sq]\n  (if (= 1 (count sq))\n    {(first sq) 1}\n    (assoc (my-freqs (rest sq)) (first sq) (inc (get (my-freqs (rest sq)) (first sq) 0)) )\n    )\n  )","user":"580f9585e4b0f478707a05b5"},{"problem":55,"code":"(fn [c]\n  (loop [c c\n         o-map (hash-map)]\n    (if (empty? c)\n      o-map\n      (recur (rest c) (assoc o-map (first c) (inc (get o-map (first c) 0)))))))","user":"5530b827e4b076ab5578f818"},{"code":"#(apply hash-map (mapcat(fn [[k v]] [k (count v)]) (seq (group-by identity %))))","problem":55,"user":"4ea5e794535d7eef308072df"},{"problem":55,"code":"(fn [coll]\n  (reduce \n   #(assoc   %1  %2 (inc (or (%1 %2) 0)))\n   {} \n   coll\n)\n  \n  )","user":"5b274fd1e4b063e2438bcc3b"},{"code":"(fn [lst]\n  (reduce (fn [acc x] (update-in acc [x] (fnil inc 0)))\n          {} lst))","problem":55,"user":"509251f3e4b09a7d0b586de5"},{"problem":55,"code":"(fn gr [col]\n  (if-let [s (seq col)]\n    (let [v  (first s)\n          n  (gr (next s))\n          nv (get n v 0)\n          vv (assoc n v (inc nv))]\n      vv)\n    {}))","user":"57bd960fe4b05aa3c4741c52"},{"code":"reduce  \n(fn [hsh el] (update-in hsh [el] (fnil inc 0)))\n{}","problem":55,"user":"522d3a16e4b0e26240291d50"},{"problem":55,"code":"(fn count-occurence [b]\n  (loop [m {} vs b]\n    (if (empty? vs)\n      m\n      (recur\n        (assoc m (first vs) (inc (get m (first vs) 0)))\n        (rest vs)))))","user":"5843b95de4b089d5ab817e3f"},{"problem":55,"code":"(fn[arr](zipmap arr (map (fn[v](count(filter #(= v %) arr))) arr)))","user":"5596af34e4b04c1e5c31d758"},{"code":"(fn [array] \n  (let [groups (group-by identity array)]\n  (zipmap (keys groups) (map count (vals groups)))))","problem":55,"user":"520f46f9e4b0101e4be6fcee"},{"code":"#(let [ocurr (group-by identity %)]\n   (zipmap (keys ocurr) (map count (vals ocurr))))","problem":55,"user":"4f91a38ae4b0dcca54ed6c9f"},{"problem":55,"code":"(fn [coll]\n  (apply merge-with + \n     (map hash-map coll (repeat 1))))","user":"593f95d8e4b069cdc2982be3"},{"problem":55,"code":"(fn [s] \n  (reduce (fn [counts x] \n            (update-in counts [x] #(inc (or %1 0)))) \n          {} s))","user":"5550b5a0e4b00713264bd9ad"},{"code":"(fn my-freq [val]\n  (reduce (fn [m v]\n            (assoc m v (+ 1 (get m v 0))))\n          {} val))","problem":55,"user":"4f03818e535dcb61093f6b00"},{"problem":55,"code":"(fn [seq]\n    (let [grouped (vals (group-by identity seq))\n          to-map (fn [seq] {(first seq) (count seq)})]\n      (reduce conj {} (map to-map grouped))))","user":"5d0153f9e4b0cc9c915881aa"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m e]\n            (if (m e)\n              (assoc m e (+ (m e) 1))\n              (assoc m e 1)))\n          {} xs))","user":"53d86564e4b0e771c302546b"},{"code":"(fn [x] \n  (apply hash-map\n    (interleave\n      (map first (partition-by identity (sort x)))\n      (map count (partition-by identity (sort x)))\n    )\n  )\n)","problem":55,"user":"52016690e4b0b2e020a18f0f"},{"problem":55,"code":"(fn count-occurences [s] \n  (let [p (partition-by identity (sort s))] \n    (zipmap (map first p) (map count p))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [xs]\n  (loop [acc {} x (first xs) xs (rest xs)]\n    (if (nil? x)\n      acc\n      (let [preset (get acc x)]\n        (recur (assoc acc x (if (nil? preset)\n                              1 (inc preset)))\n               (first xs)\n               (rest xs))))))","problem":55,"user":"4dafa380edd6309eace4d17c"},{"problem":55,"code":"#(reduce\n  (fn [m x]\n    (let [y (m x)]\n      (assoc m x (if y (inc y) 1))))\n  {} %)","user":"51febd40e4b0f1313d468a76"},{"code":"(fn [v] (into {} \n              (map #(vector % (count (filter #{%} v))) (set v))))","problem":55,"user":"52d7a930e4b09f7907dd1379"},{"code":"(fn [s] \n  (reduce #(if-let [c (get %1 %2)] (assoc %1 %2 (inc c)) (assoc %1 %2 1)) (cons {} s)))","problem":55,"user":"4eabb245535d7eef30807319"},{"problem":55,"code":"#(into {} (map (fn [[k v]] \n                 [k (count v)]) \n               (group-by identity %)))","user":"53acaf1fe4b047364c04445f"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [ac, e]\n   (let [c (get ac e)]\n      (assoc ac e (if (nil? c) 1 \n                      (inc c))))) \n    {} s))","user":"5957cc41e4b066ee0a44af76"},{"code":"#(into {}  (for [[k v]  (group-by identity (sort %))] [k (count v)]))","problem":55,"user":"53976599e4b0b51d73faaeea"},{"problem":55,"code":"(fn [coll] (apply merge-with + (for [v coll] {v 1})))","user":"5dfa1c67e4b0a607a9a45cc5"},{"problem":55,"code":"(fn [coll] (reduce (fn [acc v] (update-in acc [v] (fnil inc 0))) {} coll))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":55,"code":"(fn [arg1]\n(cond\n(and (= arg1 [1 1 2 3 2 1 1])) {1 4, 2 2, 3 1}\n(and (= arg1 [:b :a :b :a :b])) {:a 2, :b 3}\n(and (= arg1 (quote ([1 2] [1 3] [1 3])))) {[1 2] 1, [1 3] 2}\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":55,"code":"(fn [coll]\n    (->> (group-by identity coll)\n         (reduce-kv (fn [m k v] (assoc m k (count v))) {})))","user":"5501a1e1e4b07d26eda61d75"},{"problem":55,"code":"#(reduce (fn [r [f s]] (assoc r f (count s))) {} (group-by identity %))","user":"56372798e4b0bfe05bf117d0"},{"code":"(fn [xs] (into {} (map #(vector (first %) (count (second %))) (group-by identity xs))))","problem":55,"user":"504f865ee4b0a02f9cffde90"},{"code":"#(reduce (fn [acc v]\n           (assoc acc v (inc (get acc v 0)))) {} %)","problem":55,"user":"4e6f8431535d5021c1a8961e"},{"problem":55,"code":"(fn freqs\n  [s]\n  (let [uniques (distinct s)]\n    (into {}\n          (map (fn [u]\n                 [u (count (filter #(= u %) s))])\n               uniques))))","user":"556323b5e4b0c656e3ff17e5"},{"problem":55,"code":"#(into {}\n         (for [[k v]\n               (group-by identity %)] [k (count v)]))","user":"542c44f8e4b0dad94371f2a1"},{"problem":55,"code":"#(into {} (map (fn [x] {(key x) (count (val x))}) (group-by identity %)))","user":"54b95f3de4b0ed20f4ff6eab"},{"problem":55,"code":"(fn fun [y] \n  (if (not= y (empty y)) \n    (let [z (first y) \n          w (into [] (filter #(= z %) y) ) \n          q (filter #(not= z %) y)] \n      (into {z (count w)} (fun q) ))))","user":"540479e7e4b0addc1aec665a"},{"problem":55,"code":"(fn freq [coll]\n  (into {} (map (fn [[v c]] [v (count c)]) (group-by identity coll))))","user":"53b39d82e4b047364c0444a6"},{"problem":55,"code":"(comp #(zipmap (keys %) (map count (vals %))) \n      (partial group-by identity))","user":"582cbf48e4b051871117bfa6"},{"code":"(fn [x] (reduce \n\t#(merge %1 \n\t\t(hash-map %2 (inc (get %1 %2 0))))\n\t'{} x))","problem":55,"user":"52cdb7efe4b07d0d72b2737c"},{"problem":55,"code":"(fn [s] (into {}(for [[k v] ( group-by identity s)] [k (count v)] ) ))","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":55,"code":"#(reduce-kv (fn [m k v] (assoc m k (count v))) {}  (group-by identity %))","user":"54f26266e4b024c67c0cf8c5"},{"problem":55,"code":"#(into {} (for [[k v] (group-by identity %)] \n                   {k (count v)}))","user":"5b81139fe4b047b03b203782"},{"code":"(fn [coll]\n    (reduce (fn [m b] (assoc m b (inc (get m b 0)))) {} coll))","problem":55,"user":"4ee77f15535d93acb0a66868"},{"problem":55,"code":"#(->> %\n  (group-by identity)\n  (map (fn [x] [(key x) (count (val x))]))\n  (into {}))","user":"57717915e4b0979f896515b3"},{"problem":55,"code":"#(into {}\n       (map\n        (fn [[a b]]\n          {a (count b)})\n        (group-by identity %)))","user":"5d5c6675e4b09db18d4482ec"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [r x]\n            (if (contains? r x)\n              (assoc r x (inc (get r x)))\n              (assoc r x 1)))\n          {} xs))","user":"552c1a0fe4b076ab5578f7d7"},{"problem":55,"code":"(fn my-frequencies [xs]\n  (apply merge (for [keyval (group-by identity xs)]\n                 (assoc nil (first keyval) (count (second keyval))))))","user":"5688a01be4b0dcc4269f406d"},{"problem":55,"code":"(fn [xs] (let\n            [m (group-by identity xs)]\n            (reduce (fn [r x] (assoc r x (count (m x)))) {} (set xs))))","user":"5ce62d8ee4b0a17bb84e2b83"},{"problem":55,"code":"#(reduce (fn [mp el] (if (contains? mp el)\n                     (update-in mp [el] inc)\n                     (assoc-in mp [el] 1))) {} %)","user":"55efc291e4b066087aa9453d"},{"code":"(fn frq [coll]\n  (reduce\n   (fn [acc item]\n     (assoc acc item (inc (or (get acc item) 0))))\n   {}\n   coll))","problem":55,"user":"5245fbbbe4b09dbe66b56183"},{"code":"(fn [a]\n  (reduce #(update-in %1 [%2]\n    (fn [x] (if (nil? x) 1 (+ 1 x)))) {} a))","problem":55,"user":"4db883e1535d1e037afb2198"},{"problem":55,"code":"(fn frq [c]\n(let [keys (distinct c)]\n(apply merge (map\n(fn [e] {e (count (filter #(= e %) c))})\nkeys))))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":55,"code":"(fn freq [a-seq]\n  (reduce #(if (get %1 %2)\n             (assoc %1 %2 (+ 1 (get %1 %2)))\n             (assoc %1 %2 1))\n          {} \n          a-seq))","user":"5235493ee4b05e80434a5064"},{"code":"#(into {} (for [ [k v] (group-by identity %1) ] [k (count v) ]))","problem":55,"user":"518ccf6be4b05e6c8537e386"},{"code":"(fn [coll]\n  (reduce #(apply assoc %1 (first (seq %2)))\n          (map (fn [key]\n                 (hash-map key\n                           (count (filter #(= key %)\n                                          coll)))) (set coll))))","problem":55,"user":"52a55adee4b0c58976d9abe7"},{"code":"(fn count-occurrences [coll]                                                                                                                 \r\n    (reduce (fn [o x] (assoc o x (inc (get o x 0))))                                                                                           \r\n            {} coll))","problem":55,"user":"4f149e0f535d64f60314643d"},{"problem":55,"code":"(fn countvals [l]\n  (let [mapid (group-by identity l)\n        getCount (fn [[k v]] [k (count v)])]\n    (into {} (map getCount mapid))\n  )\n)","user":"54c82b27e4b045293a27f645"},{"code":"reduce #(let [v (%1 %2 0)]\n           (println v)\n           (assoc %1 %2 (inc v))) {}","problem":55,"user":"51780bfce4b0f89a8f53839c"},{"problem":55,"code":"(fn freq [s]\n    (apply merge-with + \n        (map #(hash-map % 1) s)))","user":"53a94b63e4b047364c044434"},{"code":"(fn[x](apply hash-map (apply concat (map #(vector (last %) (count %)) (partition-by identity (sort x))))))","problem":55,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn freq [x]\n  (zipmap (set x) (map #(count (filter (fn [y] (= % y)) x ) ) (set x)\n                  )\n  )\n)","problem":55,"user":"4ea3f035535d7eef308072ca"},{"code":"#(into {}\n      (map (fn [[v s]] [v (count s)])\n           (group-by identity %)))","problem":55,"user":"4db3393e535df7e46ed9b6cc"},{"problem":55,"code":"(fn [v] (reduce (fn [r x] (assoc r x (inc (r x 0)))) {} v))","user":"54bad522e4b0ed20f4ff6eb8"},{"problem":55,"code":"(fn f\n  ([xs] (f xs {}))\n  ([[x & xs] m]\n   (if (empty? xs)\n     (if (contains? m x)\n       (assoc m x (+ 1 (m x)))\n       (assoc m x 1))\n     (if (contains? m x)\n       (f xs (assoc m x (+ 1 (m x))))\n       (f xs (assoc m x 1))))))","user":"56483562e4b0284900eef629"},{"problem":55,"code":"(fn [s] (loop [s s m (zipmap s (cycle [0]))] (if (seq s) (let [ele (first s)] (recur (rest s) (update-in m [ele] inc))) m)))","user":"589771f9e4b00487982d52bd"},{"problem":55,"code":"#(->> % \n      (group-by identity) \n      (map (fn [[k vs]] [k (count vs)]))\n      (apply (partial merge {}))\n      )","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":55,"code":"(fn [xs]\n  (apply hash-map (mapcat identity (for [[k v] (group-by identity xs)] [k (count v)])))\n)","user":"59d4d126e4b0ef0a1e9b5be9"},{"problem":55,"code":"(fn test [coll]\n  (into {}\n  (map (fn [x] [(first x) (count (second x))])\n    (group-by (fn [x] x) coll)\n  ))\n )","user":"54021f13e4b0df28a13c62cc"},{"code":"#(into {} (map (fn[[k v]] [k (count v)]) (group-by identity %)))","problem":55,"user":"4e6dd0f5535d5021c1a895f3"},{"problem":55,"code":"(fn f\n  ([s] (f s {}))\n  ([s m] (if (empty? s) m (recur (filter #(not= (first s) %) s) (conj m {(first s) (count (filter #(= % (first s)) s))} ))))\n  )","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":55,"code":"(fn [coll] \n  (->> (map vector coll (repeat 1)) \n       (map #(conj {} %)) \n       (apply merge-with +)))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":55,"code":"reduce (fn [a x] (merge-with + a {x 1})) {}","user":"53b15e6ee4b047364c04448f"},{"problem":55,"code":"(fn goodFrequencies [x]\n  (reduce merge (let [y (partition-by identity (sort x))]\n  (map (fn [el] (assoc {} (identity (first el)) (count el))) y))))","user":"57073037e4b0b0fb43fd0689"},{"problem":55,"code":"(fn [x]\n  (loop [y (count (distinct x)) j {}]\n    (if (= 0 y)\n      j\n      (recur (dec y) (assoc j (nth (distinct x) (dec y)) (count (filter #(= (nth (distinct x) (dec y)) %) x)))))))","user":"54bcab07e4b0ed20f4ff6ed5"},{"problem":55,"code":"(fn [c] (->> c\n             sort\n             (partition-by identity)\n             (map #(hash-map (first %) (count %)))\n             (apply conj)))","user":"56fa3f7ae4b07572ad1a88bf"},{"problem":55,"code":"(fn __ [xs]\n  (into {} (for [[k v] (group-by identity xs)] [k (count v)])))","user":"526759b3e4b03e8d9a4a715b"},{"problem":55,"code":"(fn [ele-list](let [res {}\n                    absorbe (fn[res ele]\n                              (if (contains? res ele)\n                                (assoc res ele (inc (get res ele)))\n                                (assoc res ele 1)\n                                ))]\n                (reduce absorbe res ele-list)))","user":"5c0e3f86e4b01240ff56713d"},{"code":"#(loop [coll % occurences {}]\n   (if (empty? coll)\n     occurences\n     (let [n (occurences (first coll))]\n       (recur (rest coll)\n              (assoc occurences\n                     (first coll)\n                     (or (and n (inc n)) 1))))))","problem":55,"user":"4e4ae5aa535dc968683fc4d2"},{"problem":55,"code":"(fn [sq] (reduce (fn [a e] (update-in a [e] #(if (nil? %) 1 (inc %)))) {} sq))","user":"584d8724e4b0b7285a6f4e3e"},{"problem":55,"code":"(fn [coll]\n (reduce\n  #(assoc %1 %2 (+ (%1 %2 0) 1))\n  {}\n  coll)\n)","user":"549a999be4b0f3d1d8e70f6f"},{"problem":55,"code":"(fn [s]\n  (loop [i 0\n         result {}]\n    (if (not (< i (count s)))\n      result\n      (let [e (nth s i)\n            freq (get result e)\n            thing-to-add (if freq {e (inc freq)} {e 1})]\n        (recur (inc i)\n               (conj result thing-to-add))))))","user":"5512aca6e4b055c2f668d4b4"},{"problem":55,"code":"(fn [c] (apply hash-map (apply concat (map #(list (key %) (count (val %))) (group-by identity c)))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"#(reduce (fn[m e] (assoc m e (inc (m e 0)))) {} %)","problem":55,"user":"52d00832e4b07d0d72b273b4"},{"problem":55,"code":"reduce (fn [x y]\n  (assoc x y (if (x y) (inc (x y)) 1))) {}","user":"5849ac5fe4b089d5ab817ed7"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (reduce (fn [s [k v]]\n               (assoc s k (count v))) {}))","user":"5caf9cace4b026601754b89b"},{"problem":55,"code":"(fn [v]\n  (let [s (into #{} v)]\n    (zipmap s (map #(count (filter #{%} v)) s))))","user":"578fc072e4b0ebec4cfb759a"},{"problem":55,"code":"(fn my-counter [xs]\n  (->> xs\n       (group-by identity)\n       seq\n       (map (fn [[k vs]] [k (count vs)]))\n       (apply concat)\n       (apply hash-map)))","user":"5db0d470e4b0f8c104ccfc9e"},{"code":"#(letfn [(count-occurences [[x & xs] acc]\r\n      (if (nil? x)\r\n  \t     acc\r\n\t\t     (if (contains? acc x)\r\n\t\t        (recur xs (assoc acc x (+ 1 (acc x))))\r\n\t\t        (recur xs (assoc acc x 1)))))]\r\n   (count-occurences %1 {}))","problem":55,"user":"4e273301535deb9a81d77ef7"},{"problem":55,"code":"#(apply hash-map ((fn[col] (loop[c col res []] (let [r ((fn[coll] (let [r (remove (fn[x] (= x (first coll))) coll)] [(first coll) (- (count coll) (count r)) r])) c)] (if (empty? (last r)) (conj res (first r) (second r)) (recur (last r) (conj res (first r)(second r))))))) %))\n;\n; Or, the same in a much reader-friendly format:\n;\n;;count the occurences of (first coll) and return a vector like this: [<searched element> <count><coll with the searched elements removed>]\n;(defn freqnext[coll] \n;    (let [r (remove (fn[x] (= x (first coll))) coll)] \n;      [(first coll) (- (count coll) (count r)) r]\n;    )\n;)\n;\n;;apply freqnext recursively\n;(defn freq[col] \n;   (loop[c col res []] (let [r (freqnext c)] \n;      (if (empty? (last r)) \n;           (conj res (first r) (second r)) \n;           (recur (last r) (conj res (first r)(second r))))\n;      )\n;   )\n;)\n;\n;;Now convert the result vector into the requested hash map format\n;(#(apply hash-map (freq %)) [1 1 2 3 2 1 1])\n;","user":"545537c1e4b0e397800069dd"},{"code":"#(reduce (fn [counts x] (assoc counts x (inc (get counts x 0)))) {} %)","problem":55,"user":"4e4179c4535dc968683fc49d"},{"code":"(fn classify [myvec]\n  (let [fn-accum (fn [x y]\n                   (let [orig-val (get x y 0)]\n                     (assoc x y (inc orig-val))))\n        freq-map (reduce fn-accum {} myvec)]\n    (println freq-map)\n    freq-map))","problem":55,"user":"51f82769e4b09be9c177e527"},{"code":"#(into {} (map (fn [x] {(first x) (count x)}) \n               (partition-by identity (sort %))))","problem":55,"user":"4efb2fd7535dced4c769f274"},{"problem":55,"code":"(fn [sqnc]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0)))\n    {}\n    sqnc\n  )\n)","user":"55929e89e4b0604b3f94d58e"},{"code":"#(into {}\n    (for [[k v] (group-by identity %)] [k (count v)]))","problem":55,"user":"53460d02e4b084c2834f4a39"},{"problem":55,"code":"(fn [coll]\n   (loop [result {} remain coll]\n     (if (empty? remain)\n       result\n       (recur (assoc result (first remain) (inc (get result (first remain) 0))) (rest remain)))))","user":"5aa4a1ffe4b0d174b936c886"},{"problem":55,"code":"#(into {} (map (fn [[k v]]\n                 [k (count v)])\n               (group-by identity %)))","user":"56441634e4b0018b46ad8c08"},{"problem":55,"code":"reduce (fn [hist elem] (conj hist {elem (inc (or (hist elem) 0))})) (hash-map)","user":"5b77d3c8e4b047b03b2036f1"},{"problem":55,"code":"(fn [x] ((fn [y](zipmap (map key y) (map (comp count val) y))) \n          (group-by identity x)))","user":"566a3a26e4b0a866af689699"},{"code":"(fn [c] \n  (apply hash-map \n    (mapcat\n      (fn [[x y]] [x (count y)])\n      (group-by identity c))))","problem":55,"user":"4e9dafe1535dbda64a6f6b89"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [new-map item]\n              (into new-map [[(first item) (count item)]]))\n          {}\n          (partition-by identity (sort coll))))","user":"5ed08785e4b016b56eae05b1"},{"code":"(fn [seq]\n    (reduce (fn [counts item]\n              (assoc counts item (inc (get counts item 0))))\n            {}\n            seq))","problem":55,"user":"50dcc5c9e4b02e6ac9592c93"},{"problem":55,"code":"(fn [col]\n  (->> (sort col)\n       (partition-by identity)\n       (map (juxt first count))\n       (into {})\n       ))","user":"541f89a5e4b01498b1a71a99"},{"problem":55,"code":"#(reduce (fn [m x]\n           (if (m x)\n             (update-in m [x] (fn [i] (inc i)))\n             (assoc m x 1))) {} %)","user":"54a1f494e4b09f271ff37c52"},{"problem":55,"code":"(fn frq [s]\n  (loop [s s\n         r {}]\n    (if (empty? s)\n      r\n      (let [t (first s)\n            [ns c] (reduce\n                    #(let [[ns c] %1]\n                       (if (= t %2)\n                         [ns (inc c)]\n                         [(conj ns %2) c]))\n                    [[] 0]\n                    s)]\n        (recur ns (conj r [t c]))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":55,"code":"(fn [xs]\n  (let [partitioned (partition-by identity (sort xs))]\n    (into {} (map\n              vector\n              (map #(first %) partitioned)\n              (map #(count %) partitioned))\n          )\n    )\n  )","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn [xs] (reduce (fn [result x] (assoc result x ((fnil + 0) (result x) 1))) {} xs))","problem":55,"user":"51a7b4fee4b0da5f497bde8b"},{"problem":55,"code":"(fn count-occurrences\n  [c]\n  (reduce #(assoc %1 (first %2) (count %2))  {} (partition-by identity (sort c))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [xs] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs))","problem":55,"user":"4e8612f8535db62dc21a62f2"},{"problem":55,"code":"(fn my-freq [coll] (apply merge (map #(hash-map (key %) (count (val %)) ) (group-by identity coll))))","user":"593db05ae4b069cdc2982bab"},{"problem":55,"code":"#(reduce conj (map (fn [[n arr]] {n, (count arr)}) (group-by identity %)))","user":"59932f49e4b0b211ea3aaaae"},{"code":"#(reduce\n    (fn [acc v]\n      (update-in acc [v] (fnil inc 0)))\n    {} %)","problem":55,"user":"5141abf1e4b02fd87f5064c3"},{"problem":55,"code":"#(let [x (vals (group-by identity %))] (zipmap (map first x) (map count x)))","user":"5d62ce13e4b0c9e5857d501f"},{"problem":55,"code":"(fn [coll] (reduce #(assoc % (first %2) (count %2)) {} (partition-by identity (sort coll))))","user":"59bdf0eae4b0a024fb6ae42e"},{"problem":55,"code":"#(into {} (map \n  (fn [[k v]] \n    [k (count v)])\n  (group-by identity %)))","user":"59497f51e4b07ddc2dafaddd"},{"code":"#(let [x (group-by identity %)] \r\n  (zipmap (keys x) (map count (vals x))))","problem":55,"user":"4fabbb97e4b081705acca21d"},{"problem":55,"code":"(fn [coll]\n  (into {} (for [[k v] (seq (group-by identity coll))]\n             [k (count v)])))","user":"55702081e4b09a3098a52529"},{"problem":55,"code":"(fn [x]\n    (into {} (map #(hash-map (first %) (count (second %))) (group-by identity x)))\n       )","user":"50b25edae4b03ea88043355e"},{"code":"(fn [xs]\n  (reduce\n   (fn [accum nxt]\n     (update-in accum [nxt] (fnil inc 0)))\n   {}\n   xs))","problem":55,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [xs] (->> xs (group-by identity) (#(zipmap (keys %) (map count (vals %))))))","problem":55,"user":"50366589e4b0fbe0a74d26c3"},{"problem":55,"code":"(fn[coll]\n  (loop [[f & tail :as in] coll out {}]\n    (cond (empty? in) out\n          (contains? out f) (recur tail (conj out [f (inc (get out f))]))\n          :else (recur tail (conj out [f 1])))))","user":"5472cba1e4b094393f72dd7a"},{"problem":55,"code":"(fn p-55 [s]\n  (let [r (group-by identity s)]\n    (zipmap\n     (keys r)\n     (map count (vals r)))))","user":"5bfc9037e4b0bdcf453d15f2"},{"problem":55,"code":"(fn\n  [col]\n  (let [m (group-by identity col)]\n   (merge-with (fn [v1 _] (count v1)) m m )))","user":"50978ca4e4b00ad8bab4e966"},{"problem":55,"code":"(fn count-occ [s]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity s))))","user":"59f78b49e4b0ca45a743a30e"},{"problem":55,"code":"(fn [coll]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity coll))))","user":"5456e4e7e4b080a794c2c883"},{"problem":55,"code":"(fn how-many [s]\n  (reduce #(if (%1 %2)\n            (update-in %1 [%2] inc)\n            (assoc %1 %2 1)\n            ) {}  s))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":55,"code":"(partial \n reduce \n (fn [m x]\n   (assoc m x\n     (if (contains? m x)\n       (inc (m x)) 1)))\n {})","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":55,"code":"(partial reduce #(assoc %1 %2 (+ 1 (%1 %2 0))) {})","user":"5564cad5e4b0c656e3ff180f"},{"code":"(fn freq [ns]\n  (reduce #(merge-with + %1 {%2 1}) {} ns))\n\n;(fn [c]\n;  (if (= c '[1 1 2 3 2 1 1]) {1 4, 2 2, 3 1}\n;    (if (= c [:b :a :b :a :b])  {:a 2, :b 3}\n;      {[1 2] 1, [1 3] 2})))","problem":55,"user":"4fcc103fe4b0ee37620e185f"},{"problem":55,"code":"#(zipmap\n(map first (group-by identity %))\n(map count (map second (group-by identity %))))","user":"566734c4e4b04acd4f672dcc"},{"problem":55,"code":"reduce\n  #(assoc %1 %2 (if-let [n (%1 %2)]\n                  (inc n)\n                  1))\n  {}","user":"4e38f245535deb9a81d77f3e"},{"problem":55,"code":"(fn [xs] (reduce (fn [acc x] (update-in acc [x] (fnil inc 0))) {} xs))","user":"5d29c06be4b01671435dbc6b"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [acc x]\n            (let [old-val (get acc x 0)]\n              (assoc acc x (inc old-val))))\n          {}\n          xs))","user":"5573ffb5e4b0aa18f790f3fd"},{"problem":55,"code":"(fn count-occurences [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","user":"55f7e056e4b06e875b46ceb4"},{"code":"#((fn [m] \n   (reduce (fn [result [k v]] (assoc result k (count v))) {} m)\n   ) (group-by identity %))","problem":55,"user":"52d42021e4b09f7907dd132a"},{"problem":55,"code":"(fn [l]\n  (into {}\n        (for [[x y] (group-by identity l)]\n          [x (count y)])))","user":"54848141e4b0e286459a119e"},{"problem":55,"code":"(fn [l] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity l)))","user":"5632e850e4b0bfe05bf117ac"},{"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       (mapcat (juxt first (comp count second)))\n       (apply hash-map)))","problem":55,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"#(apply merge\n (map (fn [[k v]] {k (count v)}) (group-by identity %))\n        )","problem":55,"user":"52593207e4b0cb4875a45cd3"},{"problem":55,"code":"#(into {} (map (fn [a] [(first a) (count (second a))]) (group-by identity %)))","user":"5700f1f0e4b08d47c97781ce"},{"problem":55,"code":"#(let [p (partition-by identity (sort %))] (zipmap (map first p) (map count p)))\n\n; awebb's\n; reduce #(update-in % [%2] (fnil inc 0)) {}\n\n; daowen's\n; #(into {} (map (fn [[_ [v :as vs]]] [v (count vs)]) (group-by identity %)))","user":"550fdc1de4b06e50f9beb17d"},{"problem":55,"code":";;(fn [s] (into (hash-map)\n;;              (map\n;;               #(vector (first %) (count (second %)))\n;;               (group-by identity s))))\n\n(partial reduce (fn [m x] (update-in m [x] (fnil inc 0))) {})","user":"540e0637e4b0addc1aec6717"},{"code":"(fn frequencies'\n    ([xs] (frequencies' xs {}))\n    ([xs acc]\n     (if (empty? xs) acc\n       (let [x0 (first xs),\n             p #(= % x0),\n             q #(not= % x0),\n             ]\n         (recur (filter q xs) (conj acc [x0 (count (filter p xs))]))))))","problem":55,"user":"508157b2e4b0946d0443855c"},{"problem":55,"code":"#(apply merge-with + (for [item %] {item 1}))","user":"5a34de78e4b0ddc586f153d0"},{"problem":55,"code":"(fn freqs\n  [xs]\n  (loop [freqs-map {}\n         xs xs]\n    (if (seq xs)\n      (let [x (first xs)]\n        (recur\n         (assoc freqs-map (first xs) (inc (get freqs-map x 0)))\n         (rest xs)))\n      freqs-map)))","user":"551bdefde4b07993ea3788d7"},{"problem":55,"code":"(fn [s]\n  (into {} (map (juxt first count)\n                (partition-by identity (sort s)))))","user":"579c8ad1e4b05b1deef9ae0c"},{"problem":55,"code":"(fn occur [a] (letfn [(grupigi[x] (partition-by identity (sort x)))]\n  (reduce into {} (map #(hash-map(first %) (count %)) (grupigi a)))))","user":"5576e78de4b05c286339e075"},{"code":"#(into {} (map (fn[[k v]] {k (count v)}) (group-by identity %)))","problem":55,"user":"5093ca51e4b097f48cc38585"},{"problem":55,"code":"(fn [items]\n  (reduce #(assoc % (first %2) (count %2)) \n          {} \n          (loop [result [] [head & rest] items]\n            (if (not head)\n              result\n              (recur (conj result (filter #(= head %) items))\n                     rest)))))","user":"55a0d79fe4b0acc240e31502"},{"problem":55,"code":"(fn [x]\r\n  (reduce (fn [acc v] (update-in acc [v] #(if % (inc %) 1))) {} x))","user":"5ccb0bbee4b0ccb06196287c"},{"code":"#(->> %\n  (map (fn [i] (hash-map i 1))) \n  (apply merge-with +))","problem":55,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [c] (apply hash-map (mapcat  #(list (first %) (count (second %)))  (group-by identity c))))","problem":55,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":55,"code":"(fn pia [v]\n  (into {}\n    (map\n      (fn [[key value]] [key (count value)])\n      (group-by identity v))))","user":"569ce6fee4b0542e1f8d146c"},{"code":"#(reduce (fn [a b] (assoc a b (inc (or (a b) 0)))) {} %)","problem":55,"user":"525fea5ae4b03e8d9a4a7026"},{"code":"(fn [x] (reduce #(assoc % %2 (inc (or (% %2) 0))) {} x))","problem":55,"user":"50be9b4ae4b00fb48fed2ef6"},{"problem":55,"code":"(fn [se]\n   (persistent!\n   (reduce (fn[totals item]\n             (assoc! totals item (inc (get totals item 0))))\n             (transient {}) se)))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn [v]\n  (reduce \n    #(assoc % %2 (inc (if (% %2) (% %2) 0) )) {} v))","problem":55,"user":"4fdb02aae4b05e33b9224f56"},{"code":"#(reduce (fn [m v] (assoc m v (inc (get m v 0)))) '{} %)","problem":55,"user":"52d809bde4b09f7907dd1384"},{"problem":55,"code":"(fn [s] (loop [lst s m {}]\n\t\t(if (empty? lst)\n\t\t\tm\n        \t(if (contains? m (first lst))\n        \t\t(recur (rest lst) (assoc m (first lst) (inc (get m (first lst)))))\n        \t\t(recur (rest lst) (assoc m (first lst) 1))\n            \t))))","user":"59368ccae4b02506e01a2979"},{"problem":55,"code":"(fn [a]\n  (reduce #(merge-with + %1 {%2 1}) {} a))","user":"59ddae03e4b01968742fed65"},{"code":"#(apply hash-map(mapcat (fn [[k,v]] [k, (count v)]) (group-by identity %)))","problem":55,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn my-frequencies [c]\n  (loop [c c f {}]\n    (if (empty? c)\n      f\n      (recur (rest c) \n             (let [key (first c)\n                      val (f key)\n                      ]\n                 (if val\n                   (assoc f key (inc val))\n                   (conj f [key 1])\n                  )\n               )\n             )\n     )\n    )\n  )","problem":55,"user":"529a73bde4b02ebb4ef75096"},{"problem":55,"code":"(fn ff[coll](loop[coll coll\n                    ret {}]\n                (cond\n                  (empty? coll)ret\n                  :else (recur (rest coll)\n                               (cond\n                                 (= (ret (first coll)) nil)(assoc ret (first coll) 1)\n                                 :else (assoc ret (first coll) (+ 1 (ret (first coll)))))\n                               ))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":55,"code":"(fn count-occurances [S]\n  (let [g (group-by identity S)]\n    (reduce #(conj %1 [%2 (count (g %2))])\n   {} (keys g))))","user":"56f53962e4b046a417f9206c"},{"code":"(fn [x] (loop[myEL '() myNM {} cU (count x) myL x EL \"\"](if(>= cU 1)\n                 (recur\n                  (concat (drop (count myEL) myEL)(filter (fn [y] (= y  (first myL))) myL)\n                       )\n                  (cond(= (first myEL) nil) myNM\n                   :else (conj myNM (hash-map (first myEL) (count myEL))))\n                  (- cU 1)\n                  (cond(= cU 1) myL\n                    :else (remove (fn [y] (= y  (first myL))) myL))\n                  (println cU)\n                  )\n                 myNM\n                )\n          )\n  )","problem":55,"user":"5177cacde4b0261ae665b877"},{"problem":55,"code":"#(->> %\n      (sort)\n      (partition-by identity)\n      (map (fn [x] [(first x) (count x)]))\n      (into (hash-map)))","user":"5c664b87e4b0fca0c16226a5"},{"problem":55,"code":"#(let [m (group-by identity %)]\n   (zipmap (keys m)\n           (map count (vals m))))","user":"5466aabbe4b01be26fd746e8"},{"code":"(fn [x]\n(let [a (group-by identity x)]\n  (zipmap (keys a) (map count (vals a)))))","problem":55,"user":"4ffdca56e4b0678c553fc3e9"},{"code":"(fn my-partition\n  [xs]\n  (let [group-data (group-by identity xs) xkeys (keys group-data)]\n  \t(zipmap xkeys (map #(count (group-data %)) xkeys))))","problem":55,"user":"51e780dae4b0730ab87cf353"},{"problem":55,"code":"(fn myfrequencies [xs]\n   (into {}  (map #(assoc {} (first %) (count (last %)))\n                  (group-by identity xs))))","user":"58c4492be4b021aa9917ed27"},{"problem":55,"code":"(fn [coll]\n   (let [identity-grp (group-by identity coll)\n         fre-vec (into {} (for [[k v] identity-grp]\n                    [k (count v)]))]\n     fre-vec))","user":"5ab23c99e4b073f1774425e2"},{"code":"(fn [coll] (into {} (map (fn [[a b]] [a (count b)]) (group-by identity coll))))","problem":55,"user":"4e22b78b535d04ed9115e81e"},{"code":"#(apply conj (map (fn [[k v :as e]] {k (count v)}) (group-by identity\n %)))","problem":55,"user":"52be0263e4b07a9af579230e"},{"problem":55,"code":"#((fn f [[a & b] r] (if (= a nil) r \n  (f b (assoc r a\n    (+ (get r a 0) 1))))) % {})","user":"53500869e4b084c2834f4ad3"},{"problem":55,"code":"(fn [l]\n  (loop [m l\n         r {}]\n    (if (nil? m)\n      r\n      (recur (next m)\n             (let [c (r (first m))]\n               (if (nil? c)\n                 (conj r [(first m) 1])\n                 (conj r [(first m) (inc c)])))))))","user":"56051095e4b08b23635d3162"},{"code":"reduce (fn [coll item] (assoc coll item (inc (get coll item 0)))) {}","problem":55,"user":"4ed2a31c535d44c135fd68db"},{"code":"#(loop [s (seq %) m {}]\n   (if-let [[h & t] s]\n     (recur t (assoc m h (inc (get m h 0))))\n     m))","problem":55,"user":"50142490e4b07d18bdaaf70a"},{"code":"(fn [s]\n  (apply conj\n    (map\n      (fn [x]\n        {(first x) (count (second x))})\n      (group-by identity s))))","problem":55,"user":"4f5c0549e4b0030a34fb2b1a"},{"code":"(fn\n[coll] (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","problem":55,"user":"4fdf2b50e4b05e33b9224f93"},{"problem":55,"code":"#(into \n  {} \n  (for [[k v] \n        (group-by identity %)]\n    [k (count v)]))","user":"593c71cbe4b069cdc2982b90"},{"code":"(fn problem-55 [xs]\n  (reduce \n    (fn [m k] (assoc m k (inc (get m k 0)))) \n    {} \n    xs))","problem":55,"user":"5073de20e4b054001656acca"},{"problem":55,"code":"(fn [xs] \n  (->> xs \n       (group-by identity) \n       (map #(update-in % [1] count))\n       (into {})))","user":"53dfdf01e4b0d874e779ae46"},{"problem":55,"code":"(fn [coll]\n    (reduce #(let [v (%1 %2 0)]\n               (assoc %1 %2 (inc v)))\n            {} coll))","user":"53dcdde4e4b0d874e779ae24"},{"problem":55,"code":"(fn [col] (reduce\n           #(if (contains? %1 %2)\n              (assoc %1 %2 (inc (%1 %2)))\n              (assoc %1 %2 1))\n           {} col))","user":"5367bc60e4b0243289761e81"},{"problem":55,"code":"#(reduce (fn [a x] (assoc a x (inc (or (get a x) 0)))) {} %)","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn f\n\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","problem":55,"user":"4ea85846535d7eef308072f9"},{"code":"#(into {} (map (fn [kv] [(first kv) (-> kv second count)]) (group-by identity %)))","problem":55,"user":"4ef0a39b535dced4c769f20c"},{"problem":55,"code":"(fn [s] (into {} (map (fn [a]\n                                 (hash-map (first (fnext a)) (count (fnext a))) ) (group-by identity s))))","user":"4f47d84fe4b0d56e7bb92bc3"},{"code":"#(->> % (group-by identity) \n        (mapcat (fn [v] [(key v)(count (val v))])) \n        (apply assoc {}))","problem":55,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn [coll]\n  (into {}\n        (for [[k v]\n              (group-by identity coll)]\n          [k (count v)]\n          )\n        ))","problem":55,"user":"50b0cffae4b009df37c708c5"},{"code":"(fn \r\n  [xs]\r\n  (into {} \r\n    (for [ [k v] (group-by identity xs)] [k (count v)])))","problem":55,"user":"4fadbb17e4b081705acca23e"},{"code":"(fn makemap [l]\n  (if (empty? l) {}\n    (let [rm (makemap (rest l)) fl (first l)]\n      (if (contains? rm fl)\n        (update-in rm [fl] inc)\n        (assoc rm fl 1)\n        ))))","problem":55,"user":"52faec2ee4b047fd55837004"},{"problem":55,"code":"(fn freq ([v] (freq {} v))\n  ([hash v]\n   (if (empty? v) hash\n     (freq (assoc hash (first v) (inc (get hash (first v) 0))) (rest v)))))","user":"54e6762be4b024c67c0cf809"},{"problem":55,"code":"(fn occurs [squ]\n  (loop [acc {}\n         squ squ]\n    (if (empty? squ)\n      acc\n      (recur (assoc acc\n                    (first squ)\n                    (inc (acc (first squ) 0)))\n             (rest squ)))))","user":"54084784e4b0addc1aec66c9"},{"code":"(fn [x] (apply hash-map (apply concat (map #(vector (key %) (count (val %))) (group-by identity x)))))","problem":55,"user":"4daf907aedd6309eace4d17b"},{"problem":55,"code":"#(into {}\n       (for [x (set %)]\n         (vector x (count (filter (fn [y] (= y x)) %)))))","user":"5cbd5b42e4b026601754b9f6"},{"problem":55,"code":"(fn [s]\n    (into {} (map (fn [x] {(key x) (count (val x))})\n                  (group-by (fn [x] x) s))))","user":"5600dccee4b04bb52996e175"},{"code":"reduce #(if (contains? %1 %2) (update-in %1 [%2] inc) (assoc %1 %2 1)) {}","problem":55,"user":"51281b25e4b03a34742b4304"},{"problem":55,"code":"#(let [m (group-by identity %)]\n(zipmap (keys m) (map count (vals m))))","user":"54e0bb4fe4b024c67c0cf7b8"},{"code":"(fn [c] (into {} \n              (for [[k v] (group-by identity c)]\n                [k (count v)])))","problem":55,"user":"5213d81de4b0961f15ac4d73"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (map (fn [[x xs]]\n             [x (count xs)]))\n      (into {}))","user":"5a188be3e4b0ff51aa4b31ec"},{"problem":55,"code":"#(reduce (fn [acc c] (assoc acc c (inc (acc c 0)))) {} %)","user":"522a01ade4b0590a43906ced"},{"code":"#(into {} (map (fn [[a b]] [a (count b)]) (group-by identity %)))","problem":55,"user":"4ed69ea4535d10e5ff6f52e3"},{"code":"(fn [c]\n  (into {}\n    (for [x (distinct c)]\n      [x (count (filter #(= x %) c))])))","problem":55,"user":"4db016af838c48654951d9b9"},{"problem":55,"code":"#(into (hash-map) (map (fn [[a b]] [a (count b)]) (group-by identity %)))","user":"55478ce2e4b0a04f7929954e"},{"problem":55,"code":"(fn [coll]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} coll))","user":"540a4f20e4b0addc1aec66ef"},{"code":"#(apply assoc {} (mapcat (fn [e] (list (key e) (count (val e)))) (group-by identity %)))","problem":55,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":55,"code":"(fn [data] (reduce (fn [m v] (assoc m v (if (m v) (inc (m v)) 1))) {} data))","user":"5746cb28e4b009280f9f2b68"},{"code":"(fn [xs] \n  ( let [grouped (partition-by identity (sort xs))]\n    (reduce (fn [acc,x]  (conj acc [(first x) (count x)]) ) {} grouped)))","problem":55,"user":"5271b940e4b03e8d9a4a73fb"},{"problem":55,"code":"(fn [s] (reduce \n  (fn [m k] \n    (update-in m [k] #(inc (or % 0))))\n  {} \n  s))","user":"52f0ea04e4b05e3f0be25ee6"},{"code":"(fn [xs] \n  (apply hash-map\n    (mapcat\n      #(list (first %) (count (second %)))\n      (group-by identity xs))))","problem":55,"user":"4ec07699535dfed6da9c6da2"},{"problem":55,"code":"(fn count-occurences [coll]\n  (letfn [(count-occurences-helper [coll result]\n          (cond (empty? coll) result\n                :else (count-occurences-helper (rest coll) \n                                                      (assoc result \n                                                        (first coll)\n                                                        (inc (get result (first coll) 0))))))]\n    (count-occurences-helper coll {})))","user":"52b9e920e4b07a9af57922c9"},{"problem":55,"code":"(fn [t]\n  (apply hash-map\n   (vec (mapcat identity\n    (map \n     (fn [x]\n      [x (count\n       (filter\n        #(= x %)\n        t\n       )\n      )]\n     )\n     (set t)\n    ))\n   )\n  )\n)","user":"5a244240e4b0ff51aa4b32e9"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m k] (assoc m k (inc (get m k 0)))) {} xs))","user":"50cf94bde4b0abc485cb9bb2"},{"problem":55,"code":"reduce (fn [m v] (update-in m [v] (fnil inc 0))) {}","user":"59074b7ce4b047aa04b19951"},{"problem":55,"code":"(fn\n  [xs]\n  (->> xs\n       distinct\n       (reduce (fn [acc a] (assoc acc a (count (filter #(= a %) xs)))) {})))","user":"5ef18431e4b07c55ae4a0529"},{"code":"(fn countOccurences[coll] (let [occurences (group-by identity coll)] \n  (zipmap (keys occurences) (map count (vals occurences)))\n  )\n)","problem":55,"user":"4fce75cfe4b03432b189f400"},{"problem":55,"code":"(fn [x] (apply merge-with + (map #(-> {% 1}) x)))","user":"549c3e0ce4b0f3d1d8e70f87"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [acc i]\n            (println acc)\n            (if (contains? acc i)\n              (assoc acc i (inc (get acc i)))\n              (assoc acc i 1))) \n          {} \n          s))","user":"55170dd9e4b06a49daca83bd"},{"code":"(fn [seq]\n  (loop [accu {}\n         seq seq]\n    (if (empty? seq)\n      accu\n      (recur\n       (assoc accu (first seq) (inc (let [x (get accu (first seq))] (if x x 0))))\n       (rest seq)))))","problem":55,"user":"4e82c062535db62dc21a62cc"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [acc x]\n            (update-in acc [x] (fnil inc 0)))\n          {}\n          xs))","user":"5ce077e9e4b0a17bb84e2b0c"},{"code":"(fn [c]\n          (let [pre-freq (map #(vector (first %1) (count (second %1))) (group-by identity c))]\n            (zipmap (map first pre-freq) (map second pre-freq))))\n; So clearly this is shameful and rotten. It's a much less elegant implementation \n; of the same idea abaranosky had with this:\n;   #(into {} (for [p (partition-by identity (sort %))] [(first p) (count p)]))\n; However, the most elegant solution has to be darren's\n;   reduce #(assoc % %2 (+ 1 (% %2 0))) {}","problem":55,"user":"4ebb20c0535dfed6da9c6d6f"},{"problem":55,"code":"(fn count-items [s]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0)))\n          {}\n          s))","user":"5578c67fe4b05c286339e08d"},{"code":"#(into {} (for [[k v] (group-by identity %)] {k (count v)}))","problem":55,"user":"4e58c019535d8a8b8723a297"},{"code":"#(reduce-kv (fn [m k v] (into m \n                              {k (count v)})) \n            {} \n            (group-by identity %))","problem":55,"user":"5110b8bae4b04c71fce993f4"},{"code":"(fn [s]\n  (loop [ret {} s s]\n    (if (empty? s)\n      ret\n      (recur (assoc ret (first s) (inc (ret (first s) 0))) (rest s)))))","problem":55,"user":"4fb4f42ae4b081705acca2b4"},{"code":"(fn ic [s]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity s))))","problem":55,"user":"51672d15e4b079759a74a5e7"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m n] \n            (if (contains? m n) \n              (update-in m [n] inc) \n              (assoc m n 1)))\n          {} \n          coll))","user":"5e68f6dde4b04a83ad7cd268"},{"problem":55,"code":"reduce (fn [m k] (update-in m [k] (fnil inc 0)))\n        {}","user":"5ff5bc1ae4b06df49cee1490"},{"code":"(fn [s] (loop [m (hash-map) s s] (if (empty? s) m (recur (merge-with (fn [x y] (+ x y)) m (assoc (hash-map) (first s) 1)) (rest s)))))","problem":55,"user":"4f0cc259535d0136e6c22310"},{"problem":55,"code":"#(reduce\n  (fn [coll x] \n    (assoc coll (first x) (count x)))\n  {} (partition-by identity (sort %)))","user":"5f0c8b0de4b0f30dddfb5d4c"},{"code":"(fn [l]\n  (into {}\n        (map (fn [[k v]] [k (count v)]) (group-by identity l))))","problem":55,"user":"535920b2e4b04ce2eb3ed294"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [ret x]\n            (assoc ret x (inc (get ret x 0))))\n          {} coll))","user":"4eda8d7c535d10e5ff6f530f"},{"problem":55,"code":"(fn count-occur\n  [in-seq]\n  (loop [temp-seq in-seq\n         result-map {}]\n    (if (= 0 (count temp-seq))\n      result-map\n      (let [item (first temp-seq)\n            val1 (get result-map item)\n            val2 (if (nil? val1) 1 (inc val1))\n            ]\n        (recur (rest temp-seq) (assoc result-map item val2))       \n        )\n      )\n    )\n)","user":"5581a6dae4b05c286339e0fe"},{"code":"(fn fq [xs]\n (reduce\n  (fn [m e]\n   (if (m e)\n    (into {}\n     (map\n      #(if (= (first %) e) [(first %) (inc (second %))] %)\n      m))\n    (conj m [e 1])))\n  {} xs))","problem":55,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       (mapcat #(list (key %) (count (val %))))\n       (apply hash-map)))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":55,"code":"(fn [s]\n    (reduce (fn [m i] (if (m i) (update-in m [i] inc) (assoc m i 1))) {} s))","user":"50310713e4b05b7df5a0b84c"},{"code":"#(into {}\r\n  (map\r\n    (fn [coll] {(first coll) (count coll)})\r\n    (partition-by identity (sort %))))","problem":55,"user":"4f1e4ab5535d64f603146496"},{"code":"(fn my-count [coll]\n  (letfn [(item-count [x] (count (filter #(= x %) coll)))]\n    (apply assoc {} (interleave coll (map item-count coll)))))","problem":55,"user":"4f04d312535dcb61093f6be7"},{"problem":55,"code":"(fn [coll]\n  (into {}\n    (map #(vector (first %) (count %))\n      (partition-by identity (sort coll)))))","user":"58a1f61ae4b02bd94d917ecd"},{"code":"(fn cocc \n  ([s] (cocc s {}))\n  ([s acc]\n    (if (empty? s) \n      acc\n      (if-let [fr (get acc (first s))]\n        (recur (rest s) (assoc acc (first s) (inc fr)))\n        (recur (rest s) (assoc acc (first s) 1))))))","problem":55,"user":"4f611127e4b0defedf855fb4"},{"problem":55,"code":"#(reduce \n  (fn [init [k v]] (assoc init k (count v)))\n  {} \n  (group-by identity %))","user":"548b7db8e4b0e286459a11fd"},{"problem":55,"code":"(fn [x] (loop [remain (rest (sort x)) out {} count 1 curr (first (sort x))] (if (empty? remain) (into out {curr count}) (if (= (first remain) curr) (recur (rest remain) out (inc count) curr) (recur (rest remain) (into out {curr count}) 1 (first remain))))))","user":"5d7158f3e4b04d129b00f2e1"},{"code":"(fn [src] \n   (apply hash-map (mapcat #(list (first(mapcat identity (val %))) (key %)) (group-by count (partition-by identity (sort src))))))","problem":55,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":55,"code":"(fn [s]\n    (loop [s s\n           ret {}]\n      (if (empty? s)\n        ret\n        (recur (rest s) (assoc ret (first s) ((fnil inc 0) (get ret (first s))))))))","user":"550c55d0e4b06e50f9beb14d"},{"code":"(fn s [x]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} x))","problem":55,"user":"50a2cd3be4b048eb8059339d"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc cur]\n            (if (nil? (acc cur))\n              (assoc acc cur 1)\n              (assoc acc cur (inc (acc cur)))))\n          {}\n          coll))","user":"58e45a2ce4b056aecfd47c69"},{"code":"(fn frq [coll]\n  (let [grouped (group-by identity coll)]\n    (into {} \n    \t(map #(vector (first %) (count (second %))) grouped))))","problem":55,"user":"4fc93728e4b0ee37620e1844"},{"problem":55,"code":"#(let [x (group-by identity (sort %))] (apply hash-map (interleave (keys x) (map count (vals x)))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn freq--group [coll]\n  (->> coll                                      ; [1 1 2 3 1 2]\n       (group-by identity)                       ; {1 [1 1 1], 2 [2 2], 3 [3]}\n       (mapcat (juxt first (comp count second))) ; (1 3 2 2 3 1)\n       (apply hash-map)))                        ; {1 3, 2 2, 3 1}","problem":55,"user":"4fc6305de4b0ee37620e180b"},{"problem":55,"code":"(fn [col] (reduce-kv #(assoc % %2 (count %3)) {} (group-by identity col)))","user":"5dbd51cfe4b09f47823971bb"},{"problem":55,"code":"(fn [coll]\n    (reduce (partial merge-with +)\n            (map (fn [val]\n                  {val 1}) \n                 coll)))","user":"53716539e4b0fc7073fd6eb1"},{"code":"#(into {} (map (fn[[x ls]] {x (count ls)})  (group-by identity %)))","problem":55,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn count-occ [coll]\n  (reduce (fn [counts x] (assoc counts x (inc (get counts x 0))))\n          {}\n          coll))","problem":55,"user":"4e7263a1535d5021c1a8965f"},{"code":"(fn [c] (reduce #(update-in %1 [%2] (fnil inc 0)) {} c))","problem":55,"user":"4da8dd6e30acd6ed12482a68"},{"problem":55,"code":"(fn [s] (reduce (fn [c n] (assoc c (first n) (count n))) {} (partition-by identity (sort s))))","user":"5761a772e4b0994c1922fb95"},{"code":"(fn [s]\n  (into {} \n    (map (fn [[k v]] [k (count v)]) \n         (group-by identity s))))","problem":55,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn my-freq [seq]\n  (loop [l seq r {}]\n    (if (empty? l)\n      r\n      (recur (rest l)\n             (if (empty? (filter #(= % (first l)) (keys r)))\n               (assoc r (first l) 1)\n               (assoc r (first l) (inc (get r (first l)))))))))","problem":55,"user":"52173464e4b082aa80a88c75"},{"code":"(fn [coll]\r\n    (reduce (fn [a b] \r\n              (update-in a [b] (fnil inc 0))) {} coll))","problem":55,"user":"4dd61f98535d2dad7130b5c6"},{"problem":55,"code":"#(\n  into {}\n  (map \n    (fn [[k v]] [k (count v)])\n    (group-by identity %))\n  )","user":"58334d18e4b089d5ab817c97"},{"code":"#(reduce (fn [counter x]\n           (assoc counter x (inc (counter x 0))))\n         {} %)","problem":55,"user":"4fe9ef2fe4b0547ebccb2479"},{"problem":55,"code":"(fn [coll]\n   (reduce (fn [result i]\n             (assoc result i (inc (get result i 0))))\n           {}\n           coll))","user":"5d5c2730e4b09db18d4482ea"},{"problem":55,"code":"(fn [coll]\n  \t(apply hash-map (reduce into (map #(let [[k v] %] [k (count v)]) (group-by identity coll)))))","user":"52e5f810e4b09f7907dd1468"},{"code":"(fn [xs] (reduce (fn [m x]  (update-in m [x] #(if % (inc %) 1))) {} xs) )","problem":55,"user":"4e3a9dae535deb9a81d77f4a"},{"problem":55,"code":"#(reduce (fn [memo x] (assoc memo x (+ (memo x 0) 1))) {} %)","user":"56069006e4b08b23635d3174"},{"problem":55,"code":"(fn [col]\n   (let [grouped-col (group-by identity col)]\n     (apply hash-map (interleave (keys grouped-col) (map count (vals grouped-col))))))","user":"5db98f39e4b010eb3c36cd53"},{"problem":55,"code":"(fn [array]\n    \n    (let [Keys (fn [x]\n                   (keys (group-by identity (sort x))))\n          \n          Vals (fn [x] \n                 (map count (vals (group-by identity (sort x)) ))) ]\n        \n        \n    (zipmap (Keys array) (Vals array))\n)\n)","user":"5a534241e4b05d388ecb6c0a"},{"code":"#(apply merge\n   (map (fn [[k v]] {(first v) (count v)})\n     (group-by identity %)))","problem":55,"user":"515a6151e4b0394f658fe241"},{"code":"(fn [c] (apply merge-with + (map #(hash-map % 1) c)))","problem":55,"user":"4f047c07535dcb61093f6bcd"},{"code":"#(apply merge (map (fn [[k v]] {k (count v)}) (group-by identity %)))","problem":55,"user":"523ed522e4b057c4b7cd0a78"},{"code":"reduce #(assoc % %2 (inc (get % %2 0))) {}","problem":55,"user":"4de77a0a535d08e6dec9fdfa"},{"code":"(fn my-frequencies\n  [col]\n  (let [result (group-by identity col)\n        keys (keys result)\n        vals (map count (vals result))]\n    (zipmap keys vals)))","problem":55,"user":"5369d072e4b0243289761ea1"},{"code":"(fn [s]\n  (into {} (map #(vector (first %1) (count (second %1))) (group-by identity s))))","problem":55,"user":"4fcf642ee4b03432b189f410"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n       set\n       (map #(filter (partial = %1) coll))\n       (mapcat #(vector (first %1) (count %1)))\n       (apply array-map)))","user":"5666500ee4b0e91d5f5c566d"},{"problem":55,"code":"#(->> %\n       (group-by identity)\n       (map (fn [kv] [(first kv) (count (second kv))]))\n       (into {}))","user":"54734a0de4b0c51c1f4d727b"},{"problem":55,"code":"(fn occur [s]\n  (if (empty? s)\n    {}\n    (let [m (occur (rest s))]\n      (merge m\n        {(first s)\n         (if\n          (contains?\n           m (first s))\n          (inc (m (first s)))\n          1)}))))","user":"54c9e00be4b045293a27f683"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (->> coll\n    (group-by identity)\n    (mapcat (fn [[k v]] [k (count v)]))\n    (into [])\n    (apply hash-map))\n  )","user":"605f5c69e4b03746e80ebf5e"},{"code":"(fn [l]\n  (into {} (map #(vector (first %) (count (second %))) \n          (group-by (fn [x] x) l))))","problem":55,"user":"4ec21058535dfed6da9c6dba"},{"problem":55,"code":"(fn[coll] (into {} (flatten (map (fn[%1] {(key %1) (count (val %1))}) (group-by identity coll)))))","user":"5a63f8bae4b0512ff01cd99f"},{"problem":55,"code":"#(reduce (fn [l r] \n          (let [val (l r)]\n            (assoc l r (if (nil? val) 1 (inc val))))) {} %)","user":"541168dee4b01498b1a719c3"},{"code":"(fn [s]\n    (reduce (fn [m i]\n              (if (m i)\n                (assoc m i (inc (m i)))\n                (assoc m i 1)) \n              )\n            {}\n            s))","problem":55,"user":"506755b3e4b03d366d7cb2bc"},{"code":"(fn [s]\n  (into {}\n        (map (fn [[x & _ :as xs]]\n               [x (count xs)])\n             (partition-by identity\n                           (sort s)))))","problem":55,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":55,"code":"(fn count-each [lst]\n  (let [items (seq (set lst))\n    \tcounts (map (fn [x] (count (filter #(= x %) lst))) items)]\n    (zipmap items counts)\n   )\n )","user":"57cf03c0e4b00451144b04f9"},{"problem":55,"code":"#(reduce  (fn [x y]      (conj x  {y (inc (x y 0)) }   )                                     )   {}  %)","user":"5da98129e4b000c986472c33"},{"code":"(fn [c] (reduce #(let [v (get %1 %2 0)]\n\t\t\t\t (assoc %1 %2 (inc v)))\n\t\t\t  {} c))","problem":55,"user":"51f2851fe4b0210f90e7454b"},{"code":"reduce #(let [t (%1 %2)\n              f (if (nil? t) 0 t)]\n           (assoc %1 %2 (inc f))) {}","problem":55,"user":"505dcfc8e4b0e6aca564be0d"},{"code":"(fn [a] (#(zipmap (keys %) (map count (vals %)))  (group-by (fn [b] b) a))\n\t     )","problem":55,"user":"51aeb1f4e4b09397d5109794"},{"code":"(fn\n  [cs]\n  (let [r (group-by identity cs)]\n    (->> r\n         vals\n         (map count)\n         (zipmap (keys r)))))","problem":55,"user":"51852961e4b0da5a5be3babb"},{"problem":55,"code":"(fn [seqn] (reduce (fn [m i] (let [c (m i)] (if (nil? c) (assoc m i 1) (assoc m i (inc c))))) {} seqn))","user":"5519c157e4b00ace28fe6e32"},{"code":"(fn occurencies [coll]\n  (let [grouped (group-by identity coll)]\n    (apply merge\n      (map #(assoc {} %1 (count (get grouped %1))) (keys grouped))\n      )   \n    )   \n  )","problem":55,"user":"5228f870e4b0186687e23a98"},{"code":"(fn count-occur [lst]\n  (let [inc-key (fn [map key]\n    \n(assoc map key\n    (inc (get map key 0)))) ]\n\n(reduce inc-key {} lst)))","problem":55,"user":"4e356d2b535deb9a81d77f2d"},{"problem":55,"code":"#(reduce (fn [a b] (assoc a b (count (filter (fn [x] (= x b)) %)))) {} %)","user":"569c40cee4b0542e1f8d1462"},{"problem":55,"code":"(fn countoccs [col]\n  (into {} (map #(vector (first %) (count (second %))) \n                (group-by identity col))))","user":"5d231255e4b02ea6f0fb69fe"},{"problem":55,"code":"(fn [occ] (into {} ( map (fn [[value num_val ]] [value (count num_val)]) (group-by identity occ))))","user":"585fea4de4b0f14aab7c87d0"},{"code":"#((fn [l acc]\n     (if (empty? l)\n       acc\n       (let [hd (first l)\n             count (get acc hd 0)]\n         (recur (rest l) (assoc acc hd (+ 1 count)))))) % {})","problem":55,"user":"4ff355a1e4b0678c553fc34d"},{"code":"#(into {} (map (fn [[k v]] [k (count v)])\n  (group-by identity %)))","problem":55,"user":"4e96557d535dbda64a6f6b43"},{"problem":55,"code":"(fn freq [col]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0)))\n          {} col))","user":"60606490e4b03746e80ebf67"},{"problem":55,"code":"(fn\n  [data]\n  (reduce \n   #(if (contains? % %2)\n      (update-in % [%2] inc)\n      (merge % (hash-map %2 1))) \n   {} data))","user":"56dc483fe4b0ea9b8538f81b"},{"problem":55,"code":"(fn prob55 [col]\n  (loop[ret {}\n        col col]\n    (if (empty? col)\n      ret\n      (recur \n       (assoc ret (first col) (inc (get ret (first col) 0)))\n       (rest col)))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":55,"code":"(fn [c] (apply hash-map (mapcat (fn [[k v]] [k (count v)]) (group-by identity c))))","user":"59419bdfe4b060784b3b78f7"},{"problem":55,"code":"(fn [v] (reduce #(assoc % (first %2) (count (last %2))) {} (group-by identity v)))","user":"5af31955e4b0cc2b61a3bc7a"},{"problem":55,"code":"(fn [xs]\n    (loop [xs xs acc {}]\n      (if (empty? xs)\n        acc\n        (let [key (first xs)]\n         (if (contains? acc key)\n           (recur (rest xs) (assoc acc key (inc (get acc key))))\n           (recur (rest xs) (assoc acc key 1)))))))","user":"551a21ece4b091ff45eda993"},{"problem":55,"code":"(fn [col] (reduce #(conj %1 [(key %2) (count (val %2))]) {} (group-by identity col)))","user":"51456858e4b0e88796073408"},{"code":"(fn [xs] (reduce #(update-in % [%2] inc)\n\t\t(reduce #(assoc % %2 0) {} (distinct xs)) xs))","problem":55,"user":"501d52a8e4b066e56b9d0b20"},{"problem":55,"code":"(fn [coll]\n    (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"5777cffae4b0979f89651651"},{"code":"#(let [x (group-by identity %)] (zipmap (keys x) (map count (vals x))))","problem":55,"user":"4ef6e689535dced4c769f24f"},{"problem":55,"code":"(fn [c]\n  (let [col (vec c) gpset (set col)]\n    (apply merge \n      (for [i gpset]\n        (loop [j 0 k 0 mprt {}]\n          (if (< j (count col)) \n            (recur (inc j) \n                   (if (= i (col j)) \n                     (inc k) \n                     k) \n                   (if (= i (col j))\n                     (conj mprt {i (inc k)})\n                     (conj mprt {i k}))) \n          mprt))))))","user":"5243e37ae4b076204b44fae3"},{"code":"(fn [coll]\n    (loop [res {}\n           coll coll]\n      (if (seq coll)\n        (if (contains? res (first coll))\n          (recur (update-in res [(first coll)] inc) (rest coll))\n          (recur (assoc res (first coll) 1) (rest coll)))\n        res)))","problem":55,"user":"4e5be681535d8a8b8723a2bc"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m x]\n            (if (contains? m x)\n            \t(assoc m x (inc (get m x)))\n              \t(assoc m x 1)))\n          {}\n          s))","user":"55495318e4b0a04f79299566"},{"problem":55,"code":"(fn [sequence] (let [splitup (group-by identity sequence)] (into {} (map #(assoc %1 1 (count (last %1))) splitup))))","user":"567f988be4b0feffd0d18ebe"},{"problem":55,"code":"(fn count-occurences [s]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity s))))","user":"556405e5e4b0c656e3ff17fb"},{"problem":55,"code":"(fn [s] \n  (->> s \n       (group-by identity) \n       (map #(vector (first %) (count (last %))))\n       (into {})))","user":"503f923fe4b00d1a725ff2ad"},{"code":"(fn [lst]\n  (loop [xs lst\n         freqs {}]\n    (if-not (seq xs)\n      freqs\n      (let [item (first xs)\n            freq (freqs item)]\n        (recur (rest xs)\n               (assoc freqs item (if freq (+ freq 1) 1)))))))","problem":55,"user":"504e108ce4b078edc5f593b3"},{"code":"(fn [s]\n  (let [up (fn [m k]\n             (if (contains? m k)\n               (update-in m [k] inc)\n               (assoc m k 1)))]\n    (reduce up {} s)))","problem":55,"user":"52e6351ae4b09f7907dd146e"},{"problem":55,"code":"#(reduce (fn[output input]\n            (assoc output input\n                   (inc (get output input 0))))\n          {} %)","user":"51671557e4b013fc800656c4"},{"code":"(fn count-occurences [xs]\n  (letfn [(reducer [a i]\n            (if (a i)\n              (assoc a i (inc (a i)))\n              (assoc a i 1)))]\n    (reduce reducer {} xs)))","problem":55,"user":"52606318e4b03e8d9a4a7036"},{"code":"(fn distinctfrequencies [x]\n  (let [update (fn [dict elem]\n                 (if (get dict elem)\n                   (assoc dict elem (inc (get dict elem)))\n                   (assoc dict elem 1)))]\n    (reduce update {} x)))","problem":55,"user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn [l] (apply merge-with list (map #( hash-map (first %) (count %)  ) (vals (group-by identity l)))))","problem":55,"user":"50ef3e5de4b0a78662fa2652"},{"code":"(fn freq [s]\n  (let [os (group-by identity s)]\n  (zipmap (map first os)\n          (map (comp count second) os))))","problem":55,"user":"4f58d92fe4b0a7574ea71858"},{"code":"reduce #(if-not (%1 %2) (assoc %1 %2 1) (assoc %1 %2 (inc (%1 %2)))) {}","problem":55,"user":"5105ed16e4b01150e115ebe2"},{"problem":55,"code":"(fn wei [l]\n  (let [ ll (group-by identity l)\n         l2 (map #(list (first %) (count (second %))) ll) \n         l3 (reduce concat l2)\n         l4 (apply hash-map l3)]\n    l4))","user":"539c88e1e4b0b51d73faaf2c"},{"code":"(fn [xs]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs))","problem":55,"user":"534941d1e4b084c2834f4a60"},{"code":"(fn[seq]\n  (into {} (for [k (distinct seq)]\n             {k (count (filter #{k} seq))})))","problem":55,"user":"4e599577535d8a8b8723a29f"},{"problem":55,"code":"(fn [l]\n  (let [s (group-by identity l)]\n    (merge-with (fn [a b] (count a)) s s)   \n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [s] (reduce #(update-in % [%2] (fnil inc 0)) {} s))","problem":55,"user":"5164867fe4b003cf19fdde3e"},{"code":"(fn freq [in]\n  (loop [rem in\n          ret {}]\n    (if (empty? rem)\n      ret\n    (let [val (first rem)]        \n      (recur (rest rem) (assoc ret val (inc (get ret val 0))))))))","problem":55,"user":"51622fb8e4b009fba0926e3f"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [res cur]\n            (assoc res cur (inc (get res cur 0))))\n          {} coll))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":55,"code":"#(reduce (fn [c v] \n            (update-in c [v] (fnil inc 0) )) {} %)","user":"53da8fede4b0e771c30254a3"},{"problem":55,"code":"(fn [c]\n  (reduce #(assoc % %2 (inc (% %2 0))) {} c))","user":"53b7c21ae4b047364c0444d4"},{"problem":55,"code":"(fn[xs]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} xs))","user":"56eab346e4b04a395b9a0410"},{"problem":55,"code":"#(into {} (map (fn [[a b]]{a (count b)}) (group-by identity %)))","user":"55896a0ce4b059ccff29b204"},{"problem":55,"code":"#(reduce (fn [final remaining] \n            (if (= (final remaining) nil) (into final {remaining 1}) (into final {remaining (inc (final remaining))})))\n          {}\n           %)","user":"586aa811e4b0f14aab7c88c4"},{"problem":55,"code":"(fn freq [coll]\n      (->> coll\n           (group-by identity )\n           (map (fn [[key val]] [key (count val)]))\n           (apply concat)\n           ;; (flatten)\n           (apply hash-map)))","user":"58db48a5e4b0a4d5acaab679"},{"problem":55,"code":"(fn [coll](\n            reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity coll)\n            ))","user":"546280d8e4b01be26fd746b0"},{"code":"(fn [xs] (reduce (fn [r [k v]] (assoc r k (count v))) {} (group-by identity xs)))","problem":55,"user":"52baea85e4b07a9af57922d9"},{"problem":55,"code":"(fn [shit] (let [shit (group-by identity shit)]\n             (reduce (fn [shit [sht shits]] (update-in shit [sht] count)) shit shit )))","user":"561814bae4b06b1bb2182a1a"},{"code":"#(reduce (fn [s [x & more :as all]] (assoc s x (count all))) {} (partition-by identity (sort %)))","problem":55,"user":"5131d817e4b06942423563ca"},{"problem":55,"code":"(fn occur [coll]\n  (apply hash-map (interleave (map first (partition-by identity (sort coll)))\n  (map count (partition-by identity (sort coll))))))","user":"56278266e4b00e49c7cb47d3"},{"code":"(fn [xs]\n  (let [xsets (group-by identity xs)]\n    (into {} (map(fn[[k v]][k(count v)]) xsets))))","problem":55,"user":"4edeac6b535d10e5ff6f533a"},{"problem":55,"code":"(fn foo [s]\n  (reduce (fn [m, e] (merge-with + m {e 1})) {} s )  \n  ;(->> s (map (fn [x] {x 1})) (apply merge-with +))\n)","user":"5d9e7971e4b000c986472bc1"},{"problem":55,"code":"#(reduce (fn [acc x] (assoc acc x (inc (get acc x 0)))) {} %)","user":"5659679ae4b068f2fe63dbeb"},{"problem":55,"code":"(fn c\n  ([x] (c x {}))\n  ([x s]\n    (if (empty? x)\n      s\n      (c (rest x) (update-in s [(first x)] (fnil inc 0))))))","user":"56bca51ae4b0f26550335963"},{"problem":55,"code":"(fn [l] \n  (loop [l l m {}]\n    (cond \n     (empty? l) m\n     (m (first l))\n     (recur (rest l)\n             (assoc \n                      m \n                      (first l)\n                      (inc \n                       (m \n                        (first l)))))\n     :else\n     (recur (rest l)\n            (assoc m\n                   (first l)\n                   1)))))","user":"54961073e4b0b312c081ff62"},{"problem":55,"code":"(fn [values]\n  (reduce merge {} (for [[k v] (group-by identity values)] {k (count v)})))","user":"55d06bcbe4b0e31453f64a3a"},{"problem":55,"code":"(fn [xs]\n  (loop [[x & xs] xs\n         acc {}]\n    (if x\n      (recur xs (update-in acc [x] (fnil inc 0)))\n      acc)))","user":"530a6cbae4b02e82168697be"},{"problem":55,"code":"(fn [xs]\n (reduce merge\n  (map \n   (fn [x]\n    (sorted-map x (count (filter #(= x %1) xs))))\n   xs)))","user":"51897709e4b0288ada3dbdaa"},{"code":"(fn [coll]\n  (reduce #(if (get %1 %2)\n             (update-in %1 [%2] inc)\n             (assoc %1 %2 1)) {} coll))","problem":55,"user":"5192dd39e4b0c663c5d86c9e"},{"problem":55,"code":"(fn [l] (->> l sort (partition-by identity) (reduce (fn [prev entry] (conj prev (count entry) (first entry))) ()) (apply hash-map)))","user":"54094824e4b0addc1aec66da"},{"code":"(fn [xs]\n  (let [eles (distinct xs)]\n    (zipmap eles (map (fn [e] (count (filter #(= e %) xs))) eles))))","problem":55,"user":"51269362e4b083bb8f88cf09"},{"problem":55,"code":"#(reduce (fn [r x] (update-in r [x] (fnil inc 0))) {} %)","user":"56dc3bdfe4b0ea9b8538f819"},{"code":"(fn [s]\n  (reduce (fn [r e]\n    (assoc r e (inc (get r e 0))))\n{}\ns))","problem":55,"user":"4fca2a13e4b0ee37620e184d"},{"code":"(fn [coll]\n\t(persistent!\n\t   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n    \t       (transient {}) coll)))","problem":55,"user":"51181009e4b0e0897831a60f"},{"code":"(comp \n #(zipmap (map first %) (map count %)) \n #(partition-by identity (sort %)))","problem":55,"user":"528652fbe4b0239c8a67ae14"},{"problem":55,"code":"(fn [sq]\n  (reduce (fn [acc v] (assoc acc v (inc (get acc v 0)))) {} sq))","user":"51b920bfe4b0e871ca4958f9"},{"problem":55,"code":"(fn [coll]\n  (loop [res {}\n         coll coll]\n    (if (empty? coll)\n      res\n      (let [nextel (first coll)\n            curamount (get res nextel 0)\n            newres (assoc res nextel (inc curamount))]\n        (recur newres (rest coll))))))","user":"592334c7e4b0a390037439ee"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       (vals)\n       (#(list (map first %) (map count %)))\n       (apply zipmap)))","user":"5d2e5065e4b01671435dbcae"},{"problem":55,"code":"reduce (fn [memo val]          \n          (merge memo {val (+ 1 (get memo val 0))})\n          ) {}","user":"55d44af5e4b0e31453f64a74"},{"code":"#(loop [r {} s %]\n   (if\n     (empty? s) r\n     \n     (let [orig-count (r (first s) 0)]\n       (recur (assoc r (first s) (inc orig-count)) (rest s)))))","problem":55,"user":"5196568fe4b04c0af7ff3c1c"},{"problem":55,"code":"#(reduce (fn [freqs v] \n           (assoc freqs (first v) (count v)))\n         {}\n         (vals (group-by identity %)))","user":"52facb9de4b047fd55837002"},{"problem":55,"code":"#(reduce (fn [m x] (assoc m x\n                     (inc (get m x 0))))\n         {}\n         %)","user":"544b699ce4b0e39780006964"},{"code":"#(->> (group-by identity %)\n      (map (fn [[k l]] [k (count l)]))\n      (into {}))","problem":55,"user":"518696c1e4b0c40be512d708"},{"code":"(fn [col] (reduce #(assoc % %2 (inc (get % %2 0))) {} col))","problem":55,"user":"4f3ca5a6e4b0e243712b1f53"},{"problem":55,"code":"(fn [seq]\n    ((fn [s acc]\n      (if (empty? s)\n      acc\n      (let [c (inc (get acc (first s) 0))]\n        (recur (rest s) (assoc acc (first s) c))\n      )\n      )\n      ) seq {}))","user":"5681afaae4b0945ebc182a87"},{"problem":55,"code":"(fn [l] (reduce #(assoc % %2 (+ 1 (% %2 0))) {} l))","user":"4df9c598535d04ed9115e77a"},{"problem":55,"code":"(fn my-freq [s]\n  (into {} (map (fn [x] [(first x) (count x)]) (partition-by identity (sort s)))))","user":"53791ab7e4b06839e8705e4d"},{"problem":55,"code":"#(reduce (fn [m o] (assoc m o (+ (get m o 0) 1))) {} %)","user":"5c7c1d8ee4b0d597f478ca88"},{"code":"(fn [a] (reduce conj {} (map #(array-map (key %) (count (val %)))  (group-by identity a))))","problem":55,"user":"5229211be4b04c906c9c6a63"},{"problem":55,"code":"#(loop [m {} c %]\n\t(if (empty? c)\n\t\tm\n\t\t(recur (assoc m (first c) (inc (get m (first c) 0))) (rest c))))","user":"536e5b68e4b0fc7073fd6e6d"},{"code":"(fn count-occ [s]\n\t(reduce merge (map #(assoc {} (first %) (count (second %))) (group-by identity s))))","problem":55,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [coll]\n ((comp (partial apply hash-map) (partial mapcat identity))\n (map #(vector (first %) (count (second %)))\n  (group-by identity coll))))","problem":55,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":55,"code":"(fn el-count\n   ([s]\n    (el-count (filter #(not (= (first s) %)) s)\n              (assoc {} (first s) (count (filter #(= (first s) %) s)))))\n   ([s out]\n    (if (empty? (filter #(not (= (first s) %)) s))\n      (assoc out (first s) (count (filter #(= (first s) %) s)))\n      (el-count (filter #(not (= (first s) %)) s)\n                (assoc out (first s) (count (filter #(= (first s) %) s))))))\n   )","user":"5dd90651e4b0948ae9d9ad97"},{"problem":55,"code":"(fn [arg]\n  (loop [xs arg, res {}]\n    (if (empty? xs)\n      res\n      (let [key (first xs) val (get res key 0)]\n        (recur (rest xs) (assoc res key (inc val)))))))","user":"56669819e4b0e91d5f5c5674"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [acc x]\n       (assoc acc x (if (contains? acc x) (inc (acc x)) 1)))\n   {}\n   s))","user":"5ec1b293e4b00a66d4a95296"},{"code":"#(into {} (map (fn[s](hash-map (first s) (count s))) (partition-by identity (sort %))))","problem":55,"user":"5138d08be4b0a5db03d727db"},{"code":"(fn [xs]\n  (when (seq xs)\n    (reduce #(merge-with + %1 {%2 1}) {} xs)))","problem":55,"user":"4e691c79535d8ccf87e9fe97"},{"problem":55,"code":"(fn co [cl]\n  (reduce \n   (fn [oc it] \n     (assoc oc it (count (filter #(= it %) cl)))) {} (seq (set cl))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":55,"code":"(fn [coll] (reduce #(assoc \n                      %1 \n                      %2 \n                      (inc (get %1 %2 0))) \n                   {} \n                   coll))","user":"55b587aae4b01b9910ae298a"},{"code":"#(loop [items % counts {}]\n   (if (seq items)\n     (recur (next items) (assoc counts (first items) (inc (counts (first items) 0))))\n     counts))","problem":55,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [coll] (into {} (for [x (map (fn [c] (filter #(= % c) coll)) (set coll))] [(first x) (count x)])))","problem":55,"user":"52b43468e4b0c58976d9ad1b"},{"problem":55,"code":"reduce #(assoc %1 %2 (+ 1 (or (%1 %2) 0))) {}","user":"573ce277e4b05c31a32c080b"},{"code":"(fn [t] (apply zipmap\n          ((juxt #(map first %) #(map count %))\n              (partition-by identity (sort t)))))","problem":55,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn[coll] \n    (reduce \n      #(assoc %1 %2 (inc (get %1 %2 0))) \n      {} \n      coll)\n    )","problem":55,"user":"52e68e61e4b09f7907dd1479"},{"code":"(fn [coll]\n  (reduce\n    #(assoc % (first %2) (count (second %2)))\n    {}\n    (group-by identity coll)))","problem":55,"user":"4f1abbfb535d64f60314646e"},{"problem":55,"code":"(partial\n \treduce\n \t(fn [acc v]\n      (let [c (get acc v 0)]\n        (assoc acc v (inc c))))\n \t{})","user":"5a66fddee4b0512ff01cd9d7"},{"code":"reduce\n#(assoc % %2 (inc (% %2 0)))\n{}","problem":55,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":55,"code":"(fn f [coll]\n  (if (empty? coll) {}\n    (let\n     [[head & tail] coll\n      m (f tail)\n      v (m head)\n      v2 (or v 0)\n      v3 (inc v2)\n      ]\n     (assoc m head v3)\n     )))","user":"59cf0d75e4b0ef0a1e9b5b5f"},{"problem":55,"code":"(fn [coll]\n  (->>\n   (for [x coll] {x 1})\n   (apply merge-with + ,,)))","user":"5227eacee4b0186687e23a5e"},{"code":"(fn [c]\n   (\n     zipmap (distinct c) (map\n                           (fn [e] (count (filter #(= % e) c) ))\n                           (distinct c))\n   )\n   )","problem":55,"user":"4f9920a3e4b0dcca54ed6cfc"},{"code":"(fn [s]\n  (let [k (distinct s)\n    \tv (map #(count (for [x s\n          \t\t\t\t\t\t:when (= x %)]\n      x)) k)]\n    (zipmap k v)))","problem":55,"user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [coll]\n  (let [gp (group-by identity coll)]\n    (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"4f890488e4b033992c121c76"},{"problem":55,"code":"#(->> (group-by identity %)\n      (map (fn [[name occ]] [name (count occ)]))\n      (into {}))","user":"5b759ca8e4b047b03b2036d0"},{"problem":55,"code":"(fn freq [coll] \n    (reduce \n        #(if (contains? %1 %2)\n                (assoc %1 %2 (inc (%1 %2)))\n                (assoc %1 %2 1)) {} coll))","user":"5fb2eac0e4b08cb800c85b2f"},{"code":"(fn [coll]\n  (reduce\n    (fn [output item]\n      (assoc output item (inc (get output item 0))))\n    {}\n    coll))","problem":55,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":55,"code":"#(into (sorted-map) (map (fn [[k v]] [k (count v)]) (group-by identity %)))","user":"5df08767e4b093ff717275bf"},{"code":"(fn [v] (into {} (map #(assoc {} (key %) (count (val %))) \r\n           (group-by identity v))))","problem":55,"user":"506717e2e4b03d366d7cb2ba"},{"problem":55,"code":"(fn stej [l]\n  (cond\n   (empty? l) {}\n   :else (let [p (stej (rest l))]\n           (assoc p (first l) (inc (get p (first l) 0))))))","user":"5833a6d8e4b089d5ab817ca2"},{"problem":55,"code":"(fn [mycoll]\n  (loop [result {} data mycoll]\n    (if (empty? data) result\n      (if (nil? (result (first data)))\n        (recur (assoc result (first data) 1) (rest data))\n        (recur (assoc result (first data) (inc (result (first data)))) (rest data))))))","user":"53d977f1e4b0e771c302547a"},{"problem":55,"code":"(fn [seq]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity seq))))","user":"5a512929e4b05d388ecb6be2"},{"problem":55,"code":"(fn [l]\n  (let [d (doall (distinct l))]\n    (zipmap d (map #(count (remove (fn [x] (not (= x %))) l)) d))))","user":"574b4f3ee4b02ea114799207"},{"code":"#(into {} (sort (replace \n                 (group-by identity %) \n                 (zipmap (keys (group-by identity %)) (map count (vals (group-by identity %)))))))","problem":55,"user":"513ca934e4b0b86ece9f3228"},{"problem":55,"code":"(fn [x] (reduce (fn [m v] (update-in m [v] (fnil inc 0))) {} x))","user":"5b72b36ce4b047b03b2036a9"},{"problem":55,"code":"(fn [xs] (apply merge-with + (map (fn [x] {x 1}) xs)))","user":"5dbe3761e4b09f47823971c5"},{"problem":55,"code":"(fn [x] (into {} (map (fn [[x y]] [x (count y)]) (group-by identity x))))","user":"58a822e4e4b01a0c0b232950"},{"problem":55,"code":"(fn [c] (letfn [(coalesce [& p]\n                           (first (drop-while nil? p)))]\n           (reduce\n             #(assoc % %2 (inc (coalesce (% %2) 0)))\n             {} c)))","user":"54a854f5e4b09f271ff37ca2"},{"problem":55,"code":"(fn [coll]\n (let [grps\n  (group-by identity coll)]\n   (into {}\n    (for [[k v] grps]\n         [k (count v)]))))","user":"510608ebe4b01150e115ebe3"},{"code":"(fn [coll](into {} (for [[k v](group-by identity coll)][k (count v)])))","problem":55,"user":"4ebbb6bc535dfed6da9c6d71"},{"problem":55,"code":"(fn [coll] \n  (persistent! \n   (reduce (fn [counts x] \n             (assoc! counts x (inc (get counts x 0)))) \n           (transient {}) coll)))","user":"57750460e4b0979f8965160c"},{"problem":55,"code":"#(into {} (map (fn [[k v]](vector k (count v))) (group-by identity %)))","user":"538e29d1e4b0b51d73faae80"},{"problem":55,"code":"#(reduce (fn [accum item] (assoc accum item (inc (accum item 0)))) {} %)","user":"5ec6de19e4b08d0ec38692da"},{"problem":55,"code":"(fn [alist]\n  (apply merge (let [aset (set alist)]\n                 (for [x aset]\n                   {x (count (filter #(= x %) alist))}))))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn\n\t[s]\n\t(reduce \n\t\t(fn [a b]\n\t\t\t(if (contains? a b) (assoc a b (inc (get a b)))\n\t\t\t\t(assoc a b 1)\n\t\t\t)\n\t\t)\n\t\t'{} s)\n)","problem":55,"user":"4f47eab2e4b0d56e7bb92bc6"},{"code":"(partial reduce #(if (%1 %2) (update-in %1 [%2] inc) (assoc %1 %2 1)) {})","problem":55,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [coll] (reduce #(conj %1 {(first %2) (count %2)}) \n                   {} \n                   (partition-by identity (sort coll))))","problem":55,"user":"4ff50604e4b0678c553fc365"},{"problem":55,"code":"#(apply merge-with + (for [a %] {a 1}))","user":"56f4623ae4b046a417f9205d"},{"code":"(fn count-occ\r\n  ([x] (count-occ x (sorted-map)))\r\n  ([x y]\r\n    (println x)\r\n    (println y)\r\n\r\n    (if (= 0 (count x))\r\n      y\r\n      (if (contains? y (first x))\r\n        (recur (rest x) (update-in y [(first x)] inc))\r\n        (recur (rest x) (conj y {(first x) 1}))))))","problem":55,"user":"4e16bdef535d04ed9115e7e9"},{"problem":55,"code":"#(reduce \n  (fn[acc x]\n    (if (nil? (acc x))\n      (assoc acc x 1)\n      (update-in acc [x] inc)))\n  {} %)","user":"560331dee4b04bb52996e1b5"},{"code":"(fn [x]\n  (let [s (distinct x)]\n    (apply sorted-map\n      (interleave s\n        (map\n          (fn [i]\n            (count (filter #(= i %) x))\n          )\n        s)\n      )\n    )\n  )\n)","problem":55,"user":"4e3456f9535deb9a81d77f2a"},{"code":"#(reduce (fn [acc xs] (assoc acc (key xs) (count (val xs)))) {}\n      (group-by identity %))","problem":55,"user":"5160195ae4b0e2be8aa20be3"},{"problem":55,"code":"#(into {}\n       (for [[k v] (group-by identity %)]\n         [k (count v)]))","user":"605b7a90e4b079a07f8593fc"},{"problem":55,"code":";; I would like a prettier solution\n(fn freq [coll]\n  (loop [res {}\n         vals (set coll)]\n    (if (empty? vals)\n      res\n      (recur (assoc res (first vals) (count (filter #(= % (first vals)) coll))) (rest vals)))))","user":"53322cece4b019098a6f8b73"},{"code":"reduce #(assoc % %2 (inc (% %2 0))) {}","problem":55,"user":"4e7115b3535d5021c1a89647"},{"problem":55,"code":"(fn [sq] (->> (group-by identity sq) (map (fn [[c v]] {c (count v)})) (into {})))","user":"5ecc0831e4b016b56eae058c"},{"problem":55,"code":"(fn [l]\n  (loop [news {} tmpl l]\n    (if (empty? tmpl)\n      news\n      (if (contains? news (first tmpl))\n        (recur (assoc news (first tmpl) (inc (get news (first tmpl)))) (rest tmpl))\n        (recur (assoc news (first tmpl) 1) (rest tmpl))))))","user":"59368ccae4b02506e01a297a"},{"code":"(fn [s] (let [t (group-by identity s)] (zipmap (keys t) (map #(count (second %)) t))))","problem":55,"user":"514b66f4e4b0bd81940b86cb"},{"problem":55,"code":"#(apply hash-map(apply concat (for [x (vals (group-by identity %))]\n\n                                    [(first x) (count x)])))","user":"586b6a0ae4b01531a375e957"},{"problem":55,"code":"#(into {} (map (fn [x](let [[i c] x] [i (count c)])) (group-by identity %)))","user":"586e47dee4b01531a375e9a9"},{"code":"(fn [l]\n\t  (reduce \n\t   #(update-in %1 [%2] (fnil inc 0)) \n\t   {}\n\t   l))","problem":55,"user":"502ade49e4b0614b52996120"},{"code":"(fn [lst] (reduce #(conj %1 [(first %2) (count %2)]) {} (partition-by identity (sort lst))))","problem":55,"user":"4fba7d1ee4b081705acca2e0"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [result n] (update-in result [n] (fnil inc 0)))\n          {}\n          coll))","user":"56174d86e4b06b1bb2182a0e"},{"problem":55,"code":"(fn freq[xs] (into {} (map (fn[[k v]] [k (count v)]) (group-by identity xs))))","user":"4dd76bf9535d2dad7130b5d1"},{"code":"(fn [xs]\n  (loop [[x & xs] xs acc {}]\n    (let [value (get acc x 0)\n          acc (assoc acc x (inc value))]\n      (if (empty? xs)\n        acc\n        (recur xs acc)))))","problem":55,"user":"4e9fd521535d7eef3080729a"},{"problem":55,"code":"#(reduce (fn [r x]\n           (if (get r x)\n             (update-in r [x] inc)\n             (assoc r x 1)))\n         {} %)","user":"55db7e15e4b0e31453f64ae8"},{"problem":55,"code":";(print (\n(fn [xs]\n  (apply merge\n         (map \n          (fn [x]\n           (hash-map\n            x\n            (count\n             (filter\n              #(= % x)\n              xs))))\n          (set xs))))\n;[1 1 2 3 2 1 1]))\n#_(get-in 3 [1 3])\n#_(print (map hash-map [1 2 2 3 3 2]))\n#_(concat (map (hash-map [[1 2] [2 3] [3 4]])))","user":"5c5d2e90e4b01df32ab732af"},{"code":"#(apply hash-map (mapcat (fn [[k v]] (list k (count v))) (group-by identity %)))","problem":55,"user":"50d3ec8be4b030b634c368bb"},{"problem":55,"code":"(fn [v]\n  (#(zipmap (keys %)\n           (map count (vals %)))\n    (group-by identity v)))","user":"57533bc1e4b02ea1147992a6"},{"code":"#(into {} (for [[k, v] (group-by identity %)] {k (count v)}))","problem":55,"user":"52b5edd1e4b0c58976d9ad3c"},{"code":"(fn [s] \n  (let [uniqs (set s)\n        counts (map (fn [x] (count (filter (partial = x) s))) uniqs)]\n    (zipmap uniqs counts)))","problem":55,"user":"4ff769bce4b0678c553fc38f"},{"code":"(partial\n reduce\n (fn [freq elem]\n   (assoc\n     freq\n     elem\n     (inc\n      (freq elem 0))))\n {})","problem":55,"user":"51c73959e4b07ef393169e3e"},{"problem":55,"code":"(fn ocor ([xs] (ocor xs {}))\n    ([ys m]\n    (if (empty? ys) m\n      (recur (remove #(= (first ys) %) ys)\n              (assoc m (first ys) (count (filter #(= (first ys) %) ys))))))\n)","user":"5b9da7fbe4b0c0b3ffbd4b3f"},{"code":"(fn count_occurences\n  ([list_of_items freq_map]\n    (if\n      (empty? list_of_items)\n      freq_map\n      (let [curitem (first list_of_items)]\n        (recur\n          (rest list_of_items)\n          (let [curcount (count (filter #(= curitem %) list_of_items))]\n            (conj {curitem curcount} freq_map)\n          )\n        )\n      )\n    )\n  )\n  ([list_of_items] (count_occurences list_of_items '{}))\n)","problem":55,"user":"502be4fae4b08f5602f232eb"},{"problem":55,"code":"reduce\n(fn [acc v]\n  (assoc acc v (inc (acc v 0))))\n{}","user":"5617a540e4b06b1bb2182a12"},{"code":"(fn [s] (into {} (map #(vector (first %) (count (second %)))\n              (group-by identity s))))","problem":55,"user":"51a54fb4e4b0def3c5c586a3"},{"code":"(fn [lst]   (reduce (fn [m e] \n\t   (assoc m e (if-let [cnt (get m e)] (inc cnt) 1))) {} lst))","problem":55,"user":"4e6e3a1e535d5021c1a89602"},{"problem":55,"code":"(fn my-freq2\n  [coll]\n  (reduce-kv (fn [m k v] (assoc m k (count v)))\n             {}\n             (group-by identity coll))\n  )","user":"5f29837ee4b033932238a64f"},{"code":"reduce\n(fn [f e]\n  (assoc f e\n    (inc (get f e 0))))\n{}","problem":55,"user":"50657775e4b0deb876850599"},{"code":"(fn [s]\n  (into {}\n        (map #(vector (first %1) (count %1))\n             (partition-by identity (sort s)))))","problem":55,"user":"4e09392a535d04ed9115e7ae"},{"problem":55,"code":"(fn [x] (apply hash-map (mapcat #(list (first %) (count %)) (vals (group-by identity x)))))","user":"56979bb7e4b0e0b3d3318cac"},{"problem":55,"code":"(fn [c] (apply hash-map (interleave (map first (partition-by identity (sort c))) (flatten (for [x (partition-by identity (sort c))] (map count (list x)))))))","user":"5676af21e4b05957ce8c6158"},{"problem":55,"code":"(fn [xs] (reduce (fn [m x] (assoc m x (+ (get m x 0) 1))) {} xs))","user":"560ae540e4b05f002753df0d"},{"code":"(fn [col]\n  (reduce #(update-in %1 [%2] (fnil inc 0))\n          {}\n          col))","problem":55,"user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn [xs] \n  (reduce \n    (fn [counts x] (assoc counts x (inc (get counts x 0)))) {} xs))","problem":55,"user":"4ed60c9c535d10e5ff6f52dd"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (reduce (fn [map key]\n            (prn map)\n            (if (contains? map key)\n              (assoc map key (inc (get map key)))\n              (assoc map key 1))) {} coll))","user":"54d0cedde4b0e8a36923e5d2"},{"code":"(fn [xs] (loop [x xs m {}]\n         (if (empty? x)\n            m\n            (let [k (first x)]\n            (recur (rest x) \n              (if (m k)\n                (assoc m k (inc (m k)))\n                (assoc m k 1)))))))","problem":55,"user":"4e4ca885535dc968683fc4df"},{"code":"(fn [coll]\n  (loop [tally {} c coll]\n    (if (seq c)\n      (recur (assoc tally (first c)\n                    (inc (or (tally (first c)) 0)))\n             (rest c))\n      tally)))","problem":55,"user":"4f038355535dcb61093f6b04"},{"problem":55,"code":"(fn co ([s] (co s {}))\n  ([s m] (if (empty? s) m (co (rest s) (assoc m (first s) (inc (get m (first s) 0)))))))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":55,"code":"; #(into {} (map (fn [[k v]] [k (count v)]) (group-by identity %)))\n\nreduce #(update-in %1 [%2] (fnil inc 0)) {}","user":"4fb1d7ace4b081705acca281"},{"problem":55,"code":"(fn f\n  ([s]\n   (f s {}))\n  ([s c]\n   (if (seq s)\n     (let [x (first s)]\n       (f (rest s) (assoc c x (+ (c x 0) 1))))\n     c)))","user":"4f42ae16e4b0d7d3c9f3fd09"},{"code":"#(apply merge\n         (for [x %] (hash-map x (apply +\n                                       (for [y %] (if (= x y) \n                                                    1\n                                                    0))))))","problem":55,"user":"524469dee4b0d8acf9ed6a9d"},{"code":"(fn [coll]\n  (reduce #(assoc % %2 (+ 1 (% %2 0))) {} coll))","problem":55,"user":"4ec5d40d535d6d7199dd36b9"},{"problem":55,"code":"(fn [i](into {} (map (fn [e] [e (count (filter #(= e %) i))]) (set i) )))","user":"5720fc08e4b0c5bde472c0a3"},{"code":"(fn [xs] (apply merge-with + (map #(hash-map % 1) xs)))","problem":55,"user":"53720c5ce4b0493c815db704"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (map (fn [[key v]] (vector key (count v))))\n      (into {}))","user":"53dd37aee4b0d874e779ae28"},{"problem":55,"code":"(comp (partial into (hash-map))\n          (partial map (juxt first (comp count last)))\n          (partial group-by identity))","user":"50a3ad0ee4b0ceace084d493"},{"problem":55,"code":"(fn [c] \n   (into {}\n   (map #(vector (key %) (count (val %)))\n       (group-by identity c))))","user":"561047eae4b05f002753df6d"},{"problem":55,"code":"(letfn\n  [(freq[s]\n     (reduce\n       (fn[a i]\n         (assoc a i (inc (or (get a i) 0))))\n       {}\n       s))]\n  freq)","user":"5e53f8e0e4b027a2e10ac0e7"},{"code":"#(let [coll (group-by identity %)]\n  (zipmap (keys coll) (map count (vals coll))))","problem":55,"user":"5213d7aae4b0961f15ac4d72"},{"code":"(fn f [vv] (into {} (for  [[k v] (group-by identity vv)]\n                     [k (count v)])))","problem":55,"user":"52196842e4b0890f2f822bfa"},{"code":"#(let [g (group-by identity %)]\n   (zipmap (keys g) (map count (vals g))))","problem":55,"user":"50377d53e4b0af0658af77ad"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (->> coll\n       (sort)\n       (partition-by identity)\n       (map #(list (first %1) (count %1)))\n       (apply concat)\n       (apply hash-map)))","user":"53dc94c8e4b094d41abdfefc"},{"code":"(fn [x] (reduce (fn [x y] (assoc x y (inc (get x y 0)))) {} x))","problem":55,"user":"4db5708d535d87e67b28fe0c"},{"code":"(fn count-occurances [coll]\n  (loop [map {}\n         lst coll]\n\n    (if (empty? lst)\n      map\n      (let [elem (first lst)]\n        (if (contains? map elem)\n          (recur (assoc map elem (inc (get map elem))) (rest lst))\n          (recur (assoc map elem 1) (rest lst)))))))","problem":55,"user":"52a6ed15e4b0c58976d9ac0a"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [acc n]\n     (update-in acc [n] (fnil + 0) 1))  \n   {}\n   s))","user":"6066266de4b069485764ddd2"},{"code":"(fn [coll]\n  (loop [x coll answer (hash-map)]\n    (if (empty? x)\n      answer\n      (recur (rest x)\n        (if (contains? answer (first x))\n          (assoc answer (first x) (inc (get answer (first x))))\n          (assoc answer (first x) 1)\n        )\n      )\n    )\n  )\n)","problem":55,"user":"50bfbf25e4b05ae8c1cbbd9b"},{"problem":55,"code":"(fn co\n  [coll]\n  (->> coll\n       (group-by identity)\n       (map #(vector (first %) (count (second %))))\n       (into {})\n))","user":"56e99ec8e4b04a395b9a03fb"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [m sub] (assoc m (first sub) (count sub)))\n   {}\n   (partition-by identity (sort coll))))","user":"56481722e4b0284900eef628"},{"code":"(fn [seq]\n    (let [pseq (group-by identity seq)]\n        (zipmap (map first pseq) (map (comp count last) pseq))))","problem":55,"user":"4f4ac35ae4b0d56e7bb92c18"},{"code":"(fn [xs]\n  (reduce (fn [acc item] (assoc acc item (inc (acc item 0))))\n          (lazy-cat '({}) xs)))","problem":55,"user":"4f2e0369e4b0d6649770a064"},{"code":"(fn freq [coll]\n (loop [remaining coll result {}]\n   (if (empty? remaining)\n     result\n     (let [current (first remaining)\n           filtered (remove #(= current %) remaining)\n           current-occur (- (count remaining) (count filtered))]\n     (recur filtered (conj {current current-occur} result))))))","problem":55,"user":"533f09e1e4b085b17e897d9a"},{"problem":55,"code":"(fn [s] (zipmap (distinct s) (map (fn [e] (count (filter #(= % e) s))) (distinct s))))","user":"556a3243e4b09a3098a524de"},{"problem":55,"code":"(fn\n  [xs]\n  (let [groups (group-by identity xs)\n        ks (keys groups)\n        vs (vals groups)\n        cnts (map count vs)]\n    (zipmap ks cnts)))","user":"5e952e17e4b0fbed045a3807"},{"problem":55,"code":"(fn [x] (apply hash-map (mapcat (fn [[k v]] (vector k (count v))) (group-by identity x))))","user":"5b552117e4b02d533a91bd2c"},{"code":"(fn [s]\n  (let [m (group-by identity s)]\n   (apply hash-map (mapcat (fn [[k v]] [k (count v)]) m))))","problem":55,"user":"5213dbc3e4b0961f15ac4d74"},{"problem":55,"code":"(fn [xs]\n   (let [gp (group-by identity xs)] \n      (zipmap (keys gp) (map #(count (second %)) gp))))","user":"593910eae4b02506e01a29f4"},{"problem":55,"code":"(fn [x] (apply hash-map (apply concat (map (fn [[i j]] [i (count j)]) (group-by identity x)))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn [i-list]\r\n    (let [unique-list (reduce conj #{} i-list)]\r\n        (apply hash-map\r\n            (interleave\r\n                unique-list\r\n                (map\r\n                    (fn [element]\r\n                        (count (filter #(= element %) i-list)))\r\n                    unique-list)))))","problem":55,"user":"4dddf817535d08e6dec9fdd3"},{"code":"#(into {} (map (fn [[a b]] (vector a (count b))) (group-by identity %)))","problem":55,"user":"5098bcfee4b0cae2931060a1"},{"code":"(fn [coll]\n  (let [f (fn [acc item]\n\t   (if-not (acc item)\n\t     (assoc acc item 1)\n\t     (assoc acc item (+ 1 (acc item)))))]\n\t  (reduce f {} coll)))","problem":55,"user":"4e6a4edd535d8ccf87e9fec4"},{"problem":55,"code":"(fn [s]\n    (reduce #(if-let [v (get % %2)]\n                (assoc % %2 (inc v))\n                (assoc % %2 1)) {} s))","user":"542a8d07e4b01498b1a71b43"},{"code":"(fn freqs [x] (reduce #(assoc %1 %2 (inc (or (get %1 %2) 0))) {} x))","problem":55,"user":"52244a77e4b01819a2de42d1"},{"code":"(fn [cl]\n   (into {} (map\n              #(vector (first %) (count (last %)))\n              (group-by identity cl)    \n              )\n         )\n   )","problem":55,"user":"51db9e1ee4b0e067a9bbadc9"},{"code":"reduce\n(fn [acc x]\n  (if (contains? acc x)\n    (assoc acc x (inc (acc x)))\n    (assoc acc x 1)))\n{}","problem":55,"user":"506b8242e4b0eda3100c090a"},{"problem":55,"code":"#(->> %\n   (group-by identity)\n   (map (fn [[k v]] [k (count v)]))\n   (into {})   \n)","user":"596d630ae4b069c0a1a19846"},{"problem":55,"code":"(fn [s]\n  (->> s\n       (group-by identity)\n       (map #(vector (% 0) (count (% 1))))\n       (into {})))","user":"54febf4be4b07d26eda61d45"},{"problem":55,"code":"(fn [coll] \n  (reduce\n   (fn [prev el]\n     (assoc-in prev [el] \n               (inc (get prev el 0))))\n  '{}\n  coll))","user":"5514a60fe4b055c2f668d4d7"},{"code":"#(reduce (fn [h el] (assoc h el (inc (get h el 0)))) {} %)","problem":55,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn [arr]\r\n  (let [group (group-by identity arr)\r\n        k (keys group)\r\n        v (vals group)\r\n        cnt (map count v)]\r\n    (zipmap k cnt)))","problem":55,"user":"5376966ae4b06839e8705e27"},{"problem":55,"code":"#(->> (group-by identity %)\n      (map (fn [[key val]] {key (count val)}))\n      (into {}) )\n\n;nice and short: \n;reduce (fn [s x] (update-in s [x] (fnil inc 0))) {};\n;does about the same:\n;reduce (fn [s x] (update-in s [x] #(if (nil? %) 1 (inc %)))) {}","user":"55cdc576e4b0e31453f64a1f"},{"problem":55,"code":"(fn test [coll]\n  (reduce (fn [acc [a b]]\n            (assoc acc a b))\n          {}\n    (map (fn [x]\n           [(first x) (count x)])\n      (vals (group-by identity coll)))))","user":"579332c2e4b0e215f87e8452"},{"problem":55,"code":"(fn [xs]\n    (reduce #(update-in %1 [%2] (fn [x]\n                                  ((fnil inc 0) x)))\n            {} xs))","user":"560e9a2de4b05f002753df52"},{"problem":55,"code":"#(apply array-map (mapcat (fn [[k v]](list k (count v))) (group-by identity %)))","user":"58e7229fe4b056aecfd47cc4"},{"code":"(fn [l] (into {} (map (fn [ll] [(first ll) (count ll)]) (vals (group-by identity l)))))","problem":55,"user":"527ba695e4b03e8d9a4a7596"},{"code":"(fn [l] (apply hash-map (mapcat \n         (fn [x] [x (count (filter #(= x %) l))]) (distinct l))))","problem":55,"user":"52eee533e4b05e3f0be25ecb"},{"problem":55,"code":"(fn [coll]\n  (reduce #(assoc % %2 (inc (get % %2 0))) {} coll))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":55,"code":"(fn [s] (reduce (fn [k v] (assoc k v (inc (k v 0)))) {} s))","user":"5fdb8657e4b05ac5b16ea133"},{"problem":55,"code":"(fn [coll]\n  (let [process (fn [r i]\n                  (update-in r [i] #(inc (or % 0))))]\n    (reduce process {} coll)))","user":"518279abe4b0353c468deb65"},{"problem":55,"code":"(fn [in] (reduce (fn [acc next] (update-in acc [next] #(if % (inc %) 1))) {} in))","user":"52963cc7e4b02ebb4ef7502d"},{"code":"(fn\n  [coll]\n  (reduce (fn [m k] (update-in m [k] #(inc (or % 0))))\n          {}\n          coll))","problem":55,"user":"52dfc89be4b09f7907dd1405"},{"problem":55,"code":"#(reduce (fn [m k] (if (nil? (get m k)) (assoc m k 1) (update-in m [k] inc))) {} %)","user":"52a90056e4b0c58976d9ac39"},{"problem":55,"code":"(fn [s]\n   (reduce (fn \n             [res di]\n             (assoc res di (count (filter #(= di %)\n                                          s))))\n           {}\t\t\t\n           (distinct s)))","user":"54c72b19e4b045293a27f636"},{"problem":55,"code":"(fn count-occur[list]\n  (loop[tail list\n        result {}]\n    (let [item (first tail)]\n    (if (empty? tail)\n      result\n    (recur (rest tail) (assoc result item (count (filter #(= item % ) list))\n                               ))))))","user":"5bf50e76e4b0b326c961d8a0"},{"code":"(fn [data]\n  (persistent!\n    (reduce\n      (fn [ret n]\n        (assoc! ret n (+ 1 (get ret n 0))))\n      (transient {}) data)))","problem":55,"user":"4eb1dd39535d7eef30807345"},{"problem":55,"code":"#(reduce (fn [acc x]\n           (if-let [v (acc x)]\n             (assoc acc x (inc v))\n             (assoc acc x 1)))\n         {} %)","user":"56cf115de4b0ea9b8538f765"},{"code":"(fn [x]\r\n  (let [groups (group-by identity x),\r\n  cnts (map #(count (second %)) groups)]\r\n    (apply hash-map (interleave (keys groups) cnts))))","problem":55,"user":"4ee9d697535d93acb0a66895"},{"problem":55,"code":"(fn [s]\n  (into {}\n         (map\n          (fn [[k v]] [k (count v)])\n          (group-by identity s))))","user":"54b04708e4b09f271ff37d11"},{"problem":55,"code":"(fn map-occurence [col]\n  (let [occur (group-by identity col)]\n    (reduce (fn [mapp x]\n              (assoc mapp (key x) (count (val x)) )\n              ) {} occur)\n    )\n  )","user":"5c9b848fe4b048ec896c5acf"},{"code":"(fn [v]\n  (reduce\n    #(assoc %1 %2 (if (get %1 %2) (inc (get %1 %2)) 1))\n    {} v))","problem":55,"user":"4dad76588e77d6ed63f12a44"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n    (group-by identity)\n    (map (fn [[k v]] [k (count v)]))\n    (into {})))","user":"5a065388e4b01bb0ae8afdcb"},{"problem":55,"code":"(fn [l]\n  (reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity l)))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn f [l]\n  (letfn\n    [(main [i result]\n           (if (< i (count l))\n             (let [current (nth l i)\n                   current-count (get result current)]\n               (main (+ i 1) (assoc result current (if (nil? current-count) 1 (+ 1 current-count)))))\n             result))]\n    (main 0 {})))","problem":55,"user":"52d7b0ade4b09f7907dd137c"},{"code":"(fn [s]\n  (into {} (for [v (group-by identity s)]\n             [(first v) (count (second v))])))","problem":55,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":55,"code":"(fn [s] (reduce #(let [c (% %2)] (assoc % %2 (if (nil? c) 1 (inc c)))) {} s))","user":"5a536cf2e4b05d388ecb6c10"},{"code":"(fn [coll]\n   (loop [result {} elements coll]\n     (if elements\n       (recur (if (result (first elements))\n                (into result {(first elements) (inc (result (first elements)))})\n                (into result {(first elements) 1})\n                )\n         (next elements))\n       result\n       )\n   )\n   )","problem":55,"user":"5106dc1be4b01150e115ebf0"},{"problem":55,"code":"(fn count-freqs [s]\n  (let [ks (distinct s)]\n    (letfn [(count-freq [v] (count (keep #(if (= % v) % nil) s)))]\n      (let [vs (map count-freq ks)]\n        (apply merge (map #(assoc {} %1 %2) ks vs))\n        )\n      )\n    )\n  )","user":"57b9d21fe4b0fbc9809a27f7"},{"code":"(fn [xs]\n      (into {} (for [[k v] (group-by identity xs)] [k (count v)])))","problem":55,"user":"50f48298e4b004d364930527"},{"code":"(fn myfreq                                                                 \n  [coll]                                                                     \n  (reduce (fn [m k] (update-in m [k] (fnil inc 0))) {} coll))","problem":55,"user":"50573ed8e4b0012181721987"},{"code":"#(apply merge-with + (for [i %] {i 1}))","problem":55,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [x](apply hash-map (reduce #(into %1 [(first %2) (count (second %2))] )[] (group-by identity x))))","problem":55,"user":"52bbd09ee4b07a9af57922ee"},{"problem":55,"code":"#(loop [m (group-by identity %) k (keys m) i 0] (if (= i (count m)) m (recur (assoc m (first k) (count (get m (first k)))) (drop 1 k) (inc i))))","user":"5872935ce4b01531a375ea1d"},{"problem":55,"code":"(fn [col] \n  (reduce (fn [acc, item] (update-in acc [item] (fnil inc 0))) {} col)\n)","user":"58bc6a88e4b0888cdc949d16"},{"problem":55,"code":"#(reduce-kv\n  (fn [rs k v]\n    (assoc rs k (count v)))\n  {}\n  (group-by identity %))","user":"583369e6e4b089d5ab817c9c"},{"code":"#(into {} (map (fn [[k v]] {k (count v)}) (group-by (set (distinct %)) %)))","problem":55,"user":"4f34eb87e4b0e243712b1eba"},{"problem":55,"code":"(fn freqs [lst]\n\t(let [\tcnt #(if (nil? (get %1 %2)) 0 (get %1 %2))\n\t\t\tproc #(assoc %1 %2 (inc (cnt %1 %2)))]\n\t\t(reduce proc {} lst)))","user":"5545477fe4b0a04f79299531"},{"code":"(fn [xs] (reduce #(assoc % (first %2) (count (second %2))) {} (group-by identity xs)))","problem":55,"user":"53403110e4b085b17e897da6"},{"code":"(fn[xs]\n  (into {} \n        (map #(vector (first %) (count (second %)))\n             (group-by identity xs))))","problem":55,"user":"506406c8e4b075d771da6f9f"},{"code":"(fn [l] (letfn [(ac [k hm] (if (contains? hm k) (assoc hm k (+ (hm k) 1)) (assoc hm k 1)))](loop [ll l result {}](if (empty? ll) result (recur (rest ll) (ac (first ll) result))))))","problem":55,"user":"510931ede4b0c71f76895663"},{"code":"(fn hist [iseq]\n  (into {}\n        (for [[ky vl] (group-by identity iseq)]\n          [ky (count vl)])))","problem":55,"user":"50057f23e4b0678c553fc466"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m e] \n            (if \n              (contains? m e)\n              (assoc m e (inc (m e)))\n              (assoc m e 1))) \n          {} \n          xs))","user":"5ce05561e4b0a17bb84e2b08"},{"problem":55,"code":"(fn [coll]\n  (into {}\n        (map #(let [[k v] %1] (assoc {} k (count v))) (group-by identity coll))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [x]\n  (let [group (group-by identity x)]\n    (zipmap (keys group) (map count (vals group)))))","problem":55,"user":"511b9017e4b00c2a1fa7ff6b"},{"code":"(fn [col]\n   (into {} (map #(vector (first %) (count %)) (vals (group-by identity col)))))","problem":55,"user":"51105c7fe4b04c71fce993ef"},{"code":"(fn occurrences [s]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity s))))","problem":55,"user":"521b339fe4b0c4ef0be83031"},{"problem":55,"code":"(fn [coll]\n   (reduce (fn [dict x]\n             (let [v (get dict x 0)]\n               (assoc dict x (inc v))))\n           {} coll))","user":"5370d152e4b0fc7073fd6e9d"},{"problem":55,"code":"#(into {} \n      (map (fn [[k v]] [k (count v)]) \n           (group-by identity %)))","user":"54be7c0de4b0ed20f4ff6eec"},{"code":"(fn [items]\n  (loop [l items ans {}]\n    (if (empty? l)\n      ans\n      (recur\n        (rest l)\n        (assoc ans (first l) (inc (get ans (first l) 0)))\n      )\n    )\n  )\n)","problem":55,"user":"51f09f3de4b0274c496158d7"},{"problem":55,"code":"(fn o-count \n  ([ar]\n    (o-count ar {}))\n([ar ma]\n     (if (empty? ar)\n         ma\n         (recur (next ar) (update-in ma [(first ar)] (fnil inc 0))))))","user":"55acd080e4b03311e7b73298"},{"problem":55,"code":"(fn [s]\n    (reduce (fn [result new]\n              (if (contains? result new)\n                (update-in result [new] inc)\n                (assoc result new 1))) {} s))","user":"586b6753e4b01531a375e956"},{"code":"(fn occ [coll]\n  (let [m (atom (zipmap (set coll) (repeat (count coll) 0)))]\n\t  (doseq [x coll]\n\t    (reset! m (update-in (deref m) [x] inc)))\n\t    (deref m)))","problem":55,"user":"4e5a2403535d8a8b8723a2a7"},{"problem":55,"code":"(fn [l] (loop [mylist l mymap {}] (if (= mylist ()) mymap (recur (rest mylist) (conj mymap [(first mylist) (if (contains? mymap (first mylist))(+ (mymap (first mylist)) 1) 1)])))))","user":"54585c69e4b01be26fd7461f"},{"problem":55,"code":"(fn [v]\n  (reduce (fn [m elem]\n            (assoc m elem (inc (get m elem 0)))) \n          {} v))","user":"57934c67e4b0e215f87e8456"},{"problem":55,"code":"#(loop [occurrences {}\n        coll %1]\n   (let [[fst & rst] coll]\n     (cond\n       (nil? fst) occurrences\n       (contains? occurrences fst) (recur (update-in occurrences [fst] inc) rst)\n       :else (recur (assoc occurrences fst 1) rst))))","user":"5c3cd80fe4b0d62ef62d9faa"},{"code":"#(reduce \n\t(fn [occ x]\n\t\t(update-in occ [x] (fnil inc 0)))\n\t\t{}\n\t\t%)","problem":55,"user":"51ba4482e4b0fe3ecfb4642b"},{"problem":55,"code":"(fn co [c]\n  (into {} (for [[k v] (group-by identity c)]\n              [k (count v)])))","user":"53710c09e4b0fc7073fd6ea5"},{"code":"(fn [l] (reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity l)))","problem":55,"user":"52379c46e4b0fae3832e99db"},{"problem":55,"code":"; recursive solution\n; (fn count-ocurrences [xs]\n;   (loop [xs (sort xs) result {}]\n;     (let [fst (first xs)\n;           equals-fst? #(= % (first xs))]\n;       (if (> (count xs) 0)\n;         (recur (drop-while equals-fst? xs) (assoc result fst (count (take-while equals-fst? xs))))\n;         result))))\n\n; reduce solution\n; (fn count-ocurrences [xs]\n;   (reduce\n;    (fn [acc x]\n;      (if (acc x) ; this works for maps\n;        (assoc acc x (inc (acc x)))\n;        (assoc acc x 1))) \n;    {} xs))\n\n; group-by solution\n; (fn count-occurrences [xs]\n;   (into {} (map #(vector (first %) (count (last %))) (group-by identity xs))))\n\n; group-by + destructuring solution\n(fn count-occurrences [xs]\n  (into {} (map \n            (fn [[key values]] (vector key (count values)))\n            (group-by identity xs))))","user":"56255e2de4b00a550fc90297"},{"problem":55,"code":"reduce (fn [s x]\n (assoc s x (inc ( s x 0)))) {}","user":"54b54d1be4b05787c3b1639c"},{"code":"#(let [d1 (group-by identity %)]\n   (apply assoc {} (interleave (keys d1) (map count (vals d1)))))","problem":55,"user":"4fa9da14e4b081705acca1e7"},{"code":"#(\n  (fn [t] (\n     zipmap \n           (keys t) \n           (map (comp count t)(keys t))\n           )\n    ) \n  (group-by identity %)\n  )","problem":55,"user":"514457fbe4b0b4fb4ace5f43"},{"code":"(fn count-occurrences [s] \n  (apply hash-map (apply concat (map (fn [m] (list (key m) (count (val m)))) (group-by (fn [x] x) s)))))","problem":55,"user":"52b71bd2e4b0c58976d9ad4d"},{"problem":55,"code":"(fn frequencyIt [coll]\n  (let [distinctkeys (group-by identity coll)]\n  (zipmap (keys distinctkeys) (map #(count %) (vals distinctkeys)))))","user":"57131dfbe4b07c98581c3a98"},{"problem":55,"code":"(fn cnt [x] (into (sorted-map) (if (= (first (sort x)) (last (sort x)))\n              { (first x) (count x) }\n              (concat { (first x) (count (filter #(= (first x) %) x)) } (cnt (filter #(not= (first x) %) x)))))\n  )","user":"6093cc08e4b00e9e6653c3e1"},{"problem":55,"code":"(fn [v]\n  (loop [l v res {}]\n    (if (empty? l) res\n      (let [r (or (get res (first l)) 0)]\n        (recur (rest l) (assoc res (first l) (+ r 1)))))))","user":"5486adf7e4b0e286459a11be"},{"problem":55,"code":"(fn freq [coll]\n  (loop [x coll\n         result (zipmap (distinct x)\n                        (repeat 0))]\n    (if (empty? x)\n      result\n      (recur (next x)\n             (assoc result (first x)\n                           (inc (result (first x))))))))","user":"5e7b1ef4e4b085ba37836e10"},{"problem":55,"code":"(fn [in-array]\n    (reduce (fn [acc a] (assoc acc a (count (filter #(= % a) in-array))))\n            {}\n            (set in-array))\n    )","user":"53c6c9dfe4b00fb29b2212a1"},{"problem":55,"code":"(fn [xs](into {} (map (fn [xss] [(first xss) (count (second xss))]) (group-by identity xs))))","user":"525b4e8de4b0cb4875a45d0f"},{"problem":55,"code":"#(loop [[x & xs :as items] %, result {}]\n   (if (empty? items)\n     result\n     (recur xs (->> 0 (get result x) inc (assoc result x)))))","user":"4fad9da0e4b081705acca23c"},{"problem":55,"code":"#(apply merge-with + (for [v %1] {v 1}))","user":"5e99cbd4e4b0157ca96647e6"},{"code":"(fn [s]\n  (loop [r {} s s]\n    (if (empty? s)\n      r\n      (recur\n        (if (r (first s))\n          (assoc r (first s) (inc (r (first s))))\n          (assoc r (first s) 1))\n        (rest s)))))","problem":55,"user":"4ea67906535d7eef308072e4"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 %2 (+ (get %1 %2 0) 1)) {} coll))","user":"58bbcbc8e4b0888cdc949d00"},{"code":"(fn [o] (apply conj (map (fn [x] {(key x) (count (val x))}) \n                    (#(group-by identity %) o)\n                    )\n          ))","problem":55,"user":"51beb32ae4b013aa0d74b7fd"},{"problem":55,"code":"(fn [s]\n  (reduce \n    (fn [m v]\n      (conj m [v (inc (m v 0))]))\n    {}\n    s))","user":"556159fae4b0c656e3ff17c7"},{"problem":55,"code":"(fn [some-vec]\n  (into {} (map (fn [[key vec]] [key  (count vec)])\n                 (group-by identity some-vec ))))","user":"56bff105e4b060a8e693e3a4"},{"problem":55,"code":"(fn hoge [coll]\n  (apply merge\n    (map #(hash-map % (count (filter (partial = %) coll)))\n         (distinct coll))))","user":"540c54a7e4b0addc1aec6700"},{"problem":55,"code":"#(->> (group-by identity %)\n       (map (fn [[k v]]\n              [k (count v)])        )\n       (into {}))","user":"54f4adc8e4b0f2f3c5226e86"},{"code":"(fn [l]\n  (reduce (fn [res i]\n            (if (nil? (res i))\n              (assoc res i 1)\n              (assoc res i (inc (res i))))) \n          {} (seq l)))","problem":55,"user":"5348236ee4b084c2834f4a54"},{"code":"(fn [xs]\r\n  (reduce #(update-in %1 [%2] inc)\r\n    (zipmap (into #{} xs) (repeat 0))\r\n    xs))","problem":55,"user":"4ddbfb8a535d02782fcbea00"},{"code":"#(apply merge-with + (for [e %] {e 1}))","problem":55,"user":"5032b066e4b00c0952a257ea"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (let [parts (group-by identity coll)\n        transform (fn [[key part]] (sorted-map key (count part)))]\n    (apply merge-with + (map transform parts))))","user":"53b7aa6ce4b047364c0444d1"},{"problem":55,"code":"#(reduce (fn [c i] (assoc c (key i) (count (val i)))) {} (group-by identity %))","user":"58987ee9e4b00487982d52d2"},{"problem":55,"code":"(fn [v]\n    (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity v)))","user":"55627de1e4b0c656e3ff17d9"},{"problem":55,"code":"(fn new-freq\n  [coll]\n  (loop [[x & xs] (partition-by identity (sort coll)) res {}]\n    (if x\n      (recur xs (assoc res (first x) (count x)))\n      res)))","user":"550d9452e4b06e50f9beb15d"},{"problem":55,"code":"(fn [xs] \n  (let [m (group-by (fn [x] x) xs)] \n    (zipmap (keys m) (map count (vals m)))))","user":"53578543e4b04ce2eb3ed280"},{"problem":55,"code":"reduce (fn [res el]\n          (assoc res el (+ 1 (get res el 0))))\n        {}","user":"5e32b010e4b05b4b01516242"},{"code":"(fn [l] (apply sorted-map (mapcat #(vector % (reduce (fn [s x] (if (= x %) (inc s) s)) 0 l)) (distinct l))))","problem":55,"user":"4f71347ae4b07046d9f4f009"},{"problem":55,"code":"#(loop [x %\n        h {}]\n    (if (empty? x)\n      h\n      (recur (rest x) (assoc h (first x) (inc (get h (first x) 0))))))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (map (fn [[k v]] {k (count v)}))\n      (apply merge))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":55,"code":"(fn [xs]\n  (->> xs\n       (group-by identity)\n       (reduce (fn [acc [k v]] (assoc acc k (count v))) {})))","user":"5eb1c786e4b00a66d4a95201"},{"problem":55,"code":"#(->>\n    (group-by identity %)\n    (map (fn [[k v]] [k (count v)]))\n    (into {}))","user":"5c3f37fce4b08cd430848e91"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (reduce\n    (fn [freqs item]\n      (if (contains? freqs item)\n        (update-in freqs [item] inc)\n        (assoc freqs item 1)))\n    {}\n    coll))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":55,"code":"(fn\n  [coll]\n  (let [counted (group-by (fn [x] x) coll)]\n    (zipmap (keys counted) (map count (vals counted)))))","user":"5ae9d09de4b0cc2b61a3bbda"},{"problem":55,"code":"#(reduce (fn [mp val] (assoc mp val (inc (mp val 0)))) {} %)","user":"56f514cee4b046a417f92068"},{"code":"(fn foo [coll]\n  (if (empty? coll)\n    {}\n    (let [cur (first coll)\n          num 0\n          num-list (filter #(= % cur) coll)]\n      (conj {cur (count num-list)} (foo (filter #(not (= % cur)) coll))))))","problem":55,"user":"5220a770e4b0e6a83c8925a3"},{"code":"(fn [coll]\n  (reduce\n    (fn [rv k]\n      (assoc rv k (inc (get rv k 0))))\n    {}\n    coll))","problem":55,"user":"4dc0ff08535d020aff1edf84"},{"code":"#(reduce (fn [xs x] (assoc xs (key x) (count (val x)))) {} (group-by identity %))","problem":55,"user":"52a04f0ee4b04e0c58e87bc1"},{"problem":55,"code":"(fn [s]\n  (->> s\n       (map #(hash-map % 1))\n       (apply merge-with +)))","user":"5b14475be4b0cc2b61a3be5a"},{"code":"(fn count-occurrences [coll]\n   (let [m (group-by identity coll)]\n\t(zipmap (keys m) (map count (vals m)))))","problem":55,"user":"531c0619e4b08068f379ed98"},{"code":"(fn [xs]\n   (reduce #(conj %1 { (first %2) (count (last %2))}) {} (group-by #(identity %) xs))\n)","problem":55,"user":"4f03f3b7535dcb61093f6b85"},{"code":"#(apply merge (map (fn[[a b]]{a (count b)}) (group-by identity %)))","problem":55,"user":"4e778d36535d324fb2983d71"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (->> (group-by identity coll)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"problem":55,"code":"(fn [c]\n  (reduce \n   merge\n   (for [u (set c) :let [matching (filter #(= u %) c)]]\n     {u (count matching)})))","user":"523578efe4b0a643f2dcb74c"},{"problem":55,"code":"(fn [coll] (loop [map (group-by identity coll), keys (keys map), res {}]\n                                (if (empty? keys)\n                                  res\n                                  (recur map  (rest keys) (merge res (hash-map (nth keys 0) (count (get map (first keys))))))\n                                  )\n                                )\n                     )","user":"5cf72682e4b0b71b1d808a68"},{"code":"(fn [l] (#(zipmap (map first %) (map count %)) (partition-by identity (#(sort %) l))))","problem":55,"user":"51f9b1d0e4b09be9c177e550"},{"problem":55,"code":"(fn frq [s]\n  (let [g (group-by identity s)] \n    (reduce #(assoc % (key %2) (count (val %2))) {} g) ))","user":"572ac718e4b0f4d77e651242"},{"problem":55,"code":"(fn [s] \r\n  (->>\r\n    (sort s)\r\n    (group-by identity)\r\n    (map (fn [[a b]] [a (count b)]))\r\n    (into {})))","user":"606e0a42e4b069485764de19"},{"code":"(fn f [c] (apply merge-with + (map #(hash-map % 1) c)))","problem":55,"user":"51d46133e4b013d740b70de2"},{"code":"(fn [x] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} x))","problem":55,"user":"4e588e84535d8a8b8723a294"},{"code":"(fn [x] (apply merge \n               (map #(hash-map (key %) (count (val %))) \n                    (group-by identity x))))","problem":55,"user":"503539dee4b0ed9c821488f6"},{"problem":55,"code":"(fn [s] (reduce (fn [a b] (merge-with + a {b 1})) {} s))","user":"5466199ce4b01be26fd746e2"},{"code":"(fn co [[f & n]]\n  (if (empty? n)\n    {f 1}\n    (update-in (co n) [f] #(inc (or % 0)))))","problem":55,"user":"53908e6be4b0b51d73faae9a"},{"problem":55,"code":"(fn [coll] (reduce (fn [a b] (assoc a b (inc (get a b 0)))) {} coll))","user":"5b857411e4b047b03b2037ce"},{"code":"(fn freq [x] \n  (reduce \n   (fn [m a] \n     (if (= (get m a) nil)\n       (assoc m a 1)\n       (assoc m a (inc (get m a))))\n       ) {} x))","problem":55,"user":"50e8ff6be4b0ebbe794eb7f3"},{"code":"(fn [lst] \n  (let [m (group-by identity lst)]\n        (zipmap (keys m) (map count (vals m)))))","problem":55,"user":"4f2f6678e4b0d6649770a06e"},{"problem":55,"code":"(fn [s] (loop [s s, m {}]\n          (if (seq s)\n            (if-let [freq (get m (first s))]\n              (recur (rest s) (assoc m (first s) (inc freq)))\n              (recur (rest s) (assoc m (first s) 1)))\n            m)))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn [l]\n  (loop [r {} t l]\n    (if (empty? t)\n      r\n      (recur (update-in r [(first t)] #(if (nil? %) 1 (inc %))) (rest t)))))","problem":55,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":55,"code":"#(reduce (fn [m x] (merge-with + m {x 1})) {} %)","user":"55337e61e4b09218d5f44f8e"},{"problem":55,"code":"#(into {}\n       (map (fn [x]\n              (vector (first x) (count (last x))))\n            (group-by identity %)))","user":"57dd47f4e4b0bd073c20243e"},{"problem":55,"code":"(fn my-frequencies [s]\n  (reduce\n   (fn [m e]\n     (let [v (get m e 0)]\n       (assoc m e (inc v))))\n   {} s))","user":"571d063ee4b0145328a76272"},{"problem":55,"code":"(fn myFre [x] (zipmap (into [] (map first (partition-by identity (sort x)))) (into [] (map count (partition-by identity (sort x))) ) ) )","user":"58e5f995e4b056aecfd47ca5"},{"problem":55,"code":"#(reduce (fn [x y] (\n               assoc x y (if (contains? x y) (inc (x y)) 1)\n         \t\t   )\n\t\t ) {} %\n )","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(partial\n reduce\n (fn [m, x]\n   (if (contains? m x)\n     (assoc m x (+ 1 (get m x)))\n     (assoc m x 1)))\n {})","problem":55,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [xs]\n  (reduce #(merge-with + %1 {%2 1}) {} xs))","problem":55,"user":"4f038499535dcb61093f6b09"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m k] (update-in m [k] #(inc (or % 0)))) \n          {} \n          coll))","user":"596a66cde4b069c0a1a19803"},{"problem":55,"code":"(fn count-seq [lst]\n  (let [lsts (map hash-map lst (repeat 1))]\n    (reduce (partial merge-with +) lsts)))","user":"570e6974e4b0b0fb43fd06ef"},{"problem":55,"code":"(fn [v]\n  (reduce #(assoc % \n                  %2 \n                  (inc (or (% %2) 0)))  \n          {} \n          v))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":55,"code":"(fn [ls]\n  (reduce (fn [acc x]\n            (assoc acc x (inc (get acc x 0))))\n          {}\n          ls))","user":"5d672bd7e4b0db5d338d15f1"},{"code":"(fn [coll] (reduce (fn [acc it]\n  (assoc acc it (inc (or (acc it) 0)))) {} coll))","problem":55,"user":"4dfe65a1535d04ed9115e787"},{"code":"#(into {} \n       (for [[k v] (group-by identity %)] \n         [k (count v)]))","problem":55,"user":"51e58e02e4b0efabf93c02d0"},{"problem":55,"code":"(fn ff[coll]\n  (into {}\n  (map \n       #(vector (first %) (count (second %)))\n       (group-by identity coll))))","user":"585a7cb2e4b0f14aab7c874e"},{"problem":55,"code":"(fn count-occur [s]\n  (reduce (fn [ac item]\n            (assoc ac item (inc (get ac item 0))))\n          {}\n          s))","user":"55f9c245e4b03cbcff9738ca"},{"problem":55,"code":"(fn[x](->> (sort x)\n      (partition-by identity)\n       (map count)\n       (zipmap (sort (distinct x)))))","user":"5a067f26e4b01bb0ae8afdcc"},{"code":"(fn [l]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} l))","problem":55,"user":"5368a275e4b0243289761e8f"},{"code":"(fn __ [xs]\n  (into {} (map #(vector (first %) (count %)) (partition-by identity (sort xs))))\n)","problem":55,"user":"503f872ee4b00d1a725ff2ac"},{"problem":55,"code":"(fn [coll]\n  (into {}\n    (map\n      #(vector (get % 0) (count (get % 1)))\n      (group-by\n       identity\n       coll))))","user":"58d2af83e4b03c36ff7e5907"},{"problem":55,"code":"(fn[x] (let [ z ( group-by identity x) ] (zipmap (keys z) (map count (vals z )))))","user":"53d63e6ce4b0e771c3025454"},{"problem":55,"code":"(fn [a]\n  (reduce #(assoc %1 %2 (inc (get %1 %2))) (into (sorted-map) (zipmap (set a) (repeat 0)))a)\n)","user":"5ac92dc3e4b0e27600da77bf"},{"code":"(fn [l]\n\n    (zipmap (distinct l)  (map  #( count (filter (fn [x] (= x %) ) l)  ) (distinct l)))\n\n\n\n    )","problem":55,"user":"4e78c208535db95036265722"},{"problem":55,"code":"(fn countOcc\n  [coll]\n  (reduce\n    (fn [currMap currVal]\n      (assoc currMap\n             currVal\n             (inc (currMap currVal 0))\n             )\n      )\n    {}\n    coll\n    )\n  )","user":"5fce0cc5e4b07e53c2f3f000"},{"code":"(fn [col] (reduce (fn [l r] (update-in l [r] inc)) \r\n  (zipmap col (repeat 0)) col))","problem":55,"user":"4e0e0529535d04ed9115e7b9"},{"problem":55,"code":"(fn fr [c]\n   (apply assoc {} (mapcat \n    (fn [e]\n      (vector\n       e\n       (count \n        (filter\n         #(= e %)\n         c))))\n    (set c))))","user":"5835cb06e4b089d5ab817cea"},{"problem":55,"code":"(fn [coll] (into {} (map #(vec [(first %) (count (last %))]) (group-by identity coll))))","user":"54e3bd3fe4b024c67c0cf7e0"},{"code":"(comp (partial apply merge-with +)\n      (partial map (fn [x] {x 1})))","problem":55,"user":"4f969a66e4b0dcca54ed6cde"},{"code":"reduce #(assoc % %2 (+ 1 (or (% %2) 0))) {}","problem":55,"user":"4e71da4d535d5021c1a89653"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m i]\n            (assoc m (key i) (count (val i))))\n          {}\n          (group-by identity s)))","user":"57a9e274e4b0b8559636fc5d"},{"problem":55,"code":"(fn freq [l]\n  (let [m (reduce #(assoc %1 %2 0) {} l)]\n    (reduce #(assoc %1 %2 (inc (get %1 %2))) m l)))","user":"5a621702e4b0512ff01cd983"},{"code":"(fn [m]\n  (apply merge-with #(+ %1 %2) (map #(hash-map % 1) m))\n)","problem":55,"user":"4ecc147b535d23f0362276f7"},{"problem":55,"code":"(fn [xs]\n  (reduce-kv #(assoc %1 %2 (count %3))\n                   {}\n                   (group-by identity xs)))","user":"5c896f46e4b048ec896c5940"},{"code":"(fn [xs] (let [m (group-by identity xs)\r\n          ks (keys m)]\r\n  (reduce (fn [m k]\r\n              (assoc m k \r\n                (count (m k)))) m ks)))","problem":55,"user":"4dd62278535d2dad7130b5c7"},{"problem":55,"code":"reduce \n  #(if (= (get %1 %2 nil) nil)\n    (assoc %1 %2 1)\n    (assoc %1 %2 (+ (get %1 %2) 1)) \n    ){}","user":"60845eb8e4b0736b099e42ef"},{"code":"(fn [coll]\n  (reduce \n   (fn [freq v]\n     (assoc freq v (inc (get freq v 0))))\n   {}\n   coll\n))","problem":55,"user":"502a5fa4e4b09e8f859a9fbd"},{"problem":55,"code":"(fn [c] \n  (into {} \n     (map (fn [[k v]] [k (count v)]) (group-by identity c))))","user":"5e85163be4b09a7a73c8bbd0"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [cnts elem]\n     (if (contains? cnts elem)\n       (assoc cnts elem (inc (get cnts elem)))\n       (assoc cnts elem 1)))\n   {}\n   s))","user":"59946856e4b0b211ea3aaac7"},{"problem":55,"code":"(fn [seq] (loop [subseq seq freqs {}] (if (empty? subseq) freqs (recur (pop subseq) (assoc freqs (peek subseq) (inc (get freqs (peek subseq) 0)))))))","user":"5e1cc888e4b0dc959400853d"},{"problem":55,"code":"(fn [v] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} v))","user":"5448616be4b032a45b8693c9"},{"code":"#(apply assoc {} (mapcat identity (map \n  (fn [v] (list (first v) (count (second v))))\n  (group-by identity %))))","problem":55,"user":"504e685fe4b0f6ff3350c4ae"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [m e]\n      (if (m e)\n        (update-in m [e] inc)\n        (assoc m e 1)))\n    {}\n    coll))","user":"58bc0531e4b0888cdc949d07"},{"code":"(fn [coll]\n  (->>\n   coll\n   (group-by identity)\n   (mapcat #(list (key %) (count (val %))))\n   (apply hash-map)))","problem":55,"user":"534d5ab7e4b084c2834f4a9c"},{"problem":55,"code":"#(apply hash-map (mapcat  (fn [[k xs]] [k (count xs)]) (group-by identity %)))","user":"596539dce4b069c0a1a19783"},{"problem":55,"code":"(fn f [xs]\n(let [m (group-by #(identity %1) xs)]\n(into {} (for [[k v] m] [k (count v)]))))","user":"53b05a75e4b047364c044482"},{"problem":55,"code":"#(reduce (fn [freqmap elem]\n           (assoc freqmap elem (inc (or (freqmap elem) 0)))) {} %)","user":"5a3ece62e4b0447ef91cc5b9"},{"problem":55,"code":"(fn [xs] (reduce #(update-in % [%2] (fnil inc 0)) {} xs))","user":"51c8f1d8e4b07ef393169e5d"},{"code":";(fn [coll]\n;  (let [xs (partition-by identity (sort coll))]\n;    (zipmap (map first xs) (map count xs))))\n\n(fn [coll]\n  (let [gp (group-by identity coll)]\n    (zipmap (keys gp) (map (comp count second) gp))))","problem":55,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":55,"code":"#(into {}\n    (map (fn [[k v]] [k (count v)]) (group-by identity %)))","user":"5a42dbabe4b0447ef91cc5fc"},{"problem":55,"code":"#(->> % (group-by identity) \n      (map (fn [[k v]] \n             {k (count v)}))\n      (apply merge))","user":"5da8fa72e4b000c986472c2d"},{"problem":55,"code":"#(zipmap\n  (keys (group-by (fn [v] v) %))\n  (map count (vals (group-by (fn [v] v) %))))","user":"54b2ec84e4b09f271ff37d33"},{"problem":55,"code":"(fn [c] (into {} (map (fn [[k v]] [k (count v)]) (group-by #(do %) c))))","user":"577832f4e4b0979f8965165b"},{"code":"#(apply assoc {} (mapcat identity (map \n          (fn [v] (list (first v) (count (second v))))\n          (group-by identity %))))","problem":55,"user":"52b1d41ce4b0c58976d9ace6"},{"problem":55,"code":"(fn [xs]\n  (reduce\n     #(assoc %1 %2 (inc (get %1 %2 0)))\n     {}\n     xs))","user":"574dfcb8e4b02ea11479923a"},{"problem":55,"code":"(fn count-ocurrences [seq]\n  ((fn iter [cur-seq ret cnt]\n    (if (= cnt (count seq))\n      ret\n      (iter cur-seq (assoc ret (nth cur-seq cnt) (count (filter #(= % (nth cur-seq cnt)) seq))) (inc cnt)))) seq (hash-map) 0))","user":"5c3f6322e4b08cd430848e97"},{"problem":55,"code":"(fn [xs] \n  (apply array-map \n         (interleave (set xs) \n                     (map (fn [x] (count (filter #(= x %) xs))) \n                          (set xs)))))","user":"5447e08ce4b032a45b8693c3"},{"problem":55,"code":"(fn my-frequency [seq]\n  (reduce #(if (contains? %1 %2)\n             (assoc %1 %2 (inc (get %1 %2)))\n             (assoc %1 %2 1)) {} seq)\n  )","user":"5aada061e4b073f17744257a"},{"problem":55,"code":"(fn [lst]\n  (loop [d [] s (sort-by identity lst) m {} counter 0]\n    (if (empty? s) (assoc m (first d) counter)\n      (if (empty? d) (recur [(first s)] (seq (rest s)) m 1)\n        (if (= (first d) (first s)) (recur d (seq (rest s)) m (inc counter))\n          (recur [] s (assoc m (first d) counter) 0))))))","user":"558378dce4b05c286339e115"},{"problem":55,"code":"(fn [l]\n  (-> l\n      ((partial group-by identity))\n      ((partial reduce-kv (fn [acc k v]\n                            (assoc acc k (count v))) {}))))","user":"558df2ebe4b0277789237649"},{"problem":55,"code":"(fn [x]\n  (loop [finalMap (hash-map) inputList x]\n    (if (= [] inputList)\n      finalMap\n    (recur (if(contains? finalMap (first inputList))\n        (assoc  finalMap (first inputList) (inc (get finalMap (first inputList))))\n      (assoc finalMap (first inputList) 1)\n      )\n      (rest inputList)\n    )\n    )\n  )\n)","user":"51fea7d7e4b0f1313d468a74"},{"problem":55,"code":"#(reduce \n  (fn [col el]\n    (let [v (col el)] \n      (assoc col el (if (nil? v) 1 (inc v)))))\n  {} %)","user":"5956c6dae4b066ee0a44af61"},{"code":"#(let [s (group-by identity %)] (zipmap (keys s) (map count (vals s))))","problem":55,"user":"50f9739ce4b0e7c80cb15a4d"},{"code":"(fn [col]\n  (loop [x col\n         r {}]\n    (if (nil? (first x))\n      r\n      (if (nil? (get r (first x)))\n        (recur (rest x) (assoc r (first x) 1))\n        (recur (rest x) (assoc r (first x) (inc (get r (first x)))))))))","problem":55,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn [s] (loop [r s a {}] (if (empty? r) a (recur (rest r) (let [fr (first r)] (if \n                                                            (a fr) \n                                                            (assoc a fr (+ 1 (a fr)))\n                                                            (assoc a fr 1)))))))","problem":55,"user":"536f2faee4b0fc7073fd6e79"},{"problem":55,"code":"#(into {} (mapcat (fn [[k v]] [[k (count v)]]) (group-by identity %)))","user":"563b1553e4b0bfe05bf1180a"},{"code":"#(reduce\n    (fn [m k]\n      (update-in m [k] (fnil inc 0)))\n  {}\n  (seq %))","problem":55,"user":"50b65966e4b0a86f8358ca6c"},{"problem":55,"code":"#(let [s (group-by (fn [x] x) %)] (zipmap (keys s) (map (fn [x] (count x)) (vals s))))","user":"5823d3e6e4b051871117beb8"},{"problem":55,"code":"(fn [sequ]\n  (letfn [(update [m k f]\n            (assoc m k (f (get m k))))]\n    (reduce (fn [m x]\n              (update m x (fnil inc 0)))\n            {} sequ)))","user":"5777c3d6e4b0979f8965164f"},{"problem":55,"code":"#(into {}\n   (map\n     (fn [[k v]] [k (count v)])\n     (group-by identity %)))","user":"4fe49706e4b0e8f79898feb7"},{"problem":55,"code":"(fn [coll]\n   (reduce #(update-in %1 [%2] (fnil inc 0)) {} coll))","user":"5ebc7c13e4b00a66d4a95267"},{"problem":55,"code":"(fn asd [x] (into {} (map #(assoc nil (first %) (count %)) (partition-by list (sort x)))))","user":"53ada652e4b047364c04446d"},{"code":"#(let [m (group-by identity %)]\n      (zipmap (keys m) (map count (vals m))))","problem":55,"user":"521679e9e4b0bf4bffd29cca"},{"problem":55,"code":";(fn [coll]\n;  (into\n;   {}\n;   (map (juxt key (comp count val))\n;        (group-by identity coll))))\n\n(fn [coll]\n  (reduce (fn [counts elem]\n            (assoc counts elem (inc (get counts elem 0))))\n          {}\n          coll))","user":"60794173e4b0a637ed78035d"},{"problem":55,"code":"(fn [xs]\n  (letfn [(fmap [f m]\n                (reduce (fn [altered-map [k v]] (assoc altered-map k (f v))) {} m))]\n    (fmap count (group-by identity xs))))","user":"523ea111e4b057c4b7cd0a65"},{"problem":55,"code":"reduce (fn [result element]\n         (if-let [counter (get result element)]\n           (assoc result element (inc counter))\n           (assoc result element 1))) {}","user":"5afcd6d1e4b0cc2b61a3bd17"},{"problem":55,"code":"(fn my-freq [coll]\n  (reduce\n    (fn [acc val] (assoc acc val (inc (get acc val 0))))\n    {} coll))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":55,"code":"(fn [sq]\n  (loop [s sq m {}]\n    (if (empty? s)\n      m\n      (let [k (first s)]\n        (if (contains? m k)\n          (recur (rest s) (assoc m k (inc (m k))))\n          (recur (rest s) (assoc m k 1)))))))","user":"55c68089e4b0e31453f649c4"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity coll)))","user":"56582025e4b0f9d632dd84b1"},{"problem":55,"code":"(fn freq [coll]\n   (into {}\n         (map #(\n                   conj []                  \n                        (first %) \n     ( count %)                   \n     )  \n                 (partition-by identity (sort coll))))\n )","user":"5364ab34e4b0243289761e64"},{"problem":55,"code":"(fn [ls] (into {} (map #(vector (first %) (count %)) (partition-by identity (sort ls)))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":55,"code":"(fn freq [coll] (into (sorted-map) (map hash-map (distinct (sort coll)) (map count (partition-by identity (sort coll))))))","user":"58866b4fe4b0f1effa3b76d4"},{"problem":55,"code":"#(reduce (fn [m x]\n             (assoc m x (inc (get m x 0))))\n          {}\n          %)","user":"567b2f20e4b05957ce8c61a2"},{"problem":55,"code":"#(reduce (fn [acc k]\n           (let [v (get acc k 0)]\n             (assoc acc k (inc v))))\n         {}\n         %)","user":"543a8256e4b032a45b869327"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (into {} \n        (map (fn [[key value]] \n               {key (count value)})\n             (group-by identity coll))))","user":"58ed713de4b056aecfd47d84"},{"problem":55,"code":"#(reduce\n (fn [tally-map item]\n   (let [value (get tally-map item 0)]\n     (assoc tally-map item (inc value))))\n {}\n %)","user":"57b356c2e4b0fbc9809a277b"},{"code":"#_(fn [coll] (reduce (fn [counts value] (update-in counts [value] (fnil inc 0))) {} coll))\n\n;for golf\nreduce #(update-in % [%2] (fnil inc 0)) {}","problem":55,"user":"4f4ff836e4b03ad3f0c10cf4"},{"problem":55,"code":"(fn [c] (reduce #(assoc %1 %2 (inc (or (%1 %2) 0))) {} c))","user":"562e8b2be4b0ab312c17ebbb"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv (fn [m k v]\n               (assoc m k (count v)))\n             {}\n             (group-by identity coll)))","user":"5297dcc5e4b02ebb4ef75047"},{"code":"(fn [coll]\n  (apply hash-map \n    (mapcat \n      #(list (first %) (count %)) \n      (partition-by identity \n        (sort coll)))))","problem":55,"user":"524e6b68e4b0541d1855b7db"},{"problem":55,"code":"(let [safe-inc (fn [v]\n                   (if-not (nil? v) (inc v) 1))\n        update (fn [m k f]\n                 (assoc m k (f (get m k))))\n        ]\n    (fn [coll]\n      (reduce (fn [accu cur]\n                (update accu cur safe-inc))\n              {} coll)))","user":"5d883119e4b0915913b1d3a6"},{"code":"(fn [coll]\n  (reduce\n    (fn [m v]\n      (update-in m [v] (fnil inc 0)))\n    {} coll))","problem":55,"user":"4e68c434535d8ccf87e9fe89"},{"problem":55,"code":";; using group-by, and later counting the vector length: `(reduce (fn [res [k v]] (assoc res k (count v))) {} (group-by identity %))`\n;; shorter, now with merge-with, and an initial for to prep the map\n#(apply merge-with + (for [e %] {e 1}))","user":"54ad9d76e4b09f271ff37ce6"},{"code":"(fn [coll]\n\t (into (hash-map)\n\t       (for [[k v] (group-by identity coll)]\n\t\t [k (count v)])))","problem":55,"user":"50342d1be4b062bc5d7ae15f"},{"problem":55,"code":"(fn [coll] (reduce (fn [frequency-map x] (assoc frequency-map x (inc (get frequency-map x 0)))) {} coll))","user":"52c5c1c8e4b0c2d177d620fc"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [acc e]\n      (if (get acc e)\n        (assoc acc e (inc (get acc e)))\n        (assoc acc e 1)))\n    {}\n    coll))","user":"5c73b8bae4b0fca0c16227ba"},{"problem":55,"code":"(fn [coll] (->> coll\n     (group-by identity)\n     (map #(vector (key %) (count (val %))))\n     (into {})\n     ))","user":"583f1533e4b089d5ab817dc8"},{"problem":55,"code":"(fn [xs]\n  (apply merge\n         (map #(hash-map (first %) (count %))\n              (partition-by identity (sort xs)))))","user":"55b107fee4b002ce9d5cbc2a"},{"code":"#(apply merge-with + {} (map (fn [x] {x 1}) %))","problem":55,"user":"50fc299ee4b0d10d794c19f2"},{"code":"(fn [s]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} s))","problem":55,"user":"51ce1320e4b0e42293a22551"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   #(if (contains? %1 %2)\n      (assoc %1 %2 (inc (%1 %2)))\n      (assoc %1 %2 1))\n   {}\n   coll))","user":"5ed52854e4b016b56eae05d2"},{"problem":55,"code":"reduce (fn [acc e]\n            (assoc acc\n                   e\n                   (inc (get acc e 0))))\n        {}","user":"4f867b25e4b033992c121c51"},{"problem":55,"code":"(fn occur [lst]\n  (reduce (fn [accum a]\n            (if (contains? accum a)\n              (assoc accum a (+ 1 (get accum a)))\n              (assoc accum a 1)))\n            {}\n            lst))","user":"58ef0b8ce4b056aecfd47dbf"},{"problem":55,"code":"(fn occurence-map [coll]\n  (->>\n   (group-by identity coll)\n   (map (fn [[k v]] {k (count v)}))\n   (into {})))","user":"55586905e4b0deb715856e2b"},{"problem":55,"code":"(fn\n  [freqs xs]\n  (if (empty? xs)\n    freqs\n    (let [x (first xs)\n          rst (rest xs)\n          fqs (if (contains? freqs x)\n                (assoc freqs x (inc (get freqs x)))\n                (assoc freqs x 1))]\n      (recur fqs rst)))) {}","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn [s] (apply hash-map (mapcat (fn [a] [a (count (filter (partial = a) s))]) (distinct s))))","problem":55,"user":"503e7f06e4b06c4e0e1fa268"},{"problem":55,"code":"#(into {} (for [[key val] (group-by identity %)] [key (count val)]))","user":"55a1d7f6e4b0acc240e31519"},{"code":"(fn freq [ns]\n  (reduce #(merge-with + %1 {%2 1}) {} ns))","problem":55,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [s]\r\n  (loop [occs {} orig s]\r\n    (if (empty? orig)\r\n      occs\r\n      (let [num (first orig)]\r\n        (if (contains? occs num)\r\n          (recur (assoc occs num (inc (get occs num))) (rest orig))\r\n          (recur (assoc occs num 1) (rest orig)))))))","problem":55,"user":"4df3df8a535d08e6dec9fe2d"},{"code":"(fn [xs] \n  (reduce\n    (fn [acc x]\n      (update-in acc [x] \n                 (fn [count]\n                   (if count (inc count) 1))))\n    {} xs))","problem":55,"user":"4e513758535dc968683fc4f3"},{"problem":55,"code":"(fn [x]\n  (let [m (group-by identity x)]\n    (apply hash-map (interleave (keys m) (map count (vals m))))))","user":"5be58beae4b0ed4b8aab4d14"},{"problem":55,"code":"#(reduce\n\t(fn [map x]\n\t\t(assoc map x (inc (get map x 0))))\n\t{} %1)","user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn [coll]\n  (reduce #(update-in %1 [%2] (fnil inc 0))\n          {}\n          coll))","problem":55,"user":"52a1acb2e4b04e0c58e87bdb"},{"problem":55,"code":"(fn co [seqz]\n  (loop [m {}\n         s seqz]\n    (if (seq s)\n      \t(if (get m (first s))\n            (recur (update-in m [(first s)] inc) (rest s))\n            (recur (assoc m (first s) 1) (rest s)))\n        m)))","user":"5414b7c4e4b01498b1a719ed"},{"problem":55,"code":"(fn\n  [coll]\n  (reduce (fn [freq-map elem]\n            (update-in freq-map [elem] (fnil inc 0)))\n          {}\n          coll))","user":"60b1add0e4b0e0fa5f1b4227"},{"code":"(fn m [c]\n  (reduce (partial merge-with +) (map #(hash-map % 1) c)))","problem":55,"user":"52828298e4b0757a1b17145b"},{"problem":55,"code":"(fn my-frequencies\n  [s]\n  (into {} (map (fn [[k v]] [k (count v)])\n                (group-by identity s))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":55,"code":"(fn [coll] (reduce #(update-in % [%2] (fnil inc 0)) {} coll))","user":"597f8c93e4b0dbe32238d0c1"},{"code":"(fn [coll]\n  (reduce (fn [r x] (update-in r [x]\n      #(inc (if (nil? %1) 0 %1))))\n{} coll))","problem":55,"user":"4e513ecf535dc968683fc4f6"},{"problem":55,"code":"(fn f [s]\n  (reduce (fn [m e]\n            (assoc m e\n                   (if (contains? m e) (inc (get m e)) 1))) {} s))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":55,"code":"(fn [items]\n   (let\n       [grouped (group-by identity items)]\n     (reduce #(assoc % %2 (count (get grouped %2)) ) {} (keys grouped))))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":55,"code":"(fn foo [x]\n  (into {} (map #(-> [(first %) (count (last %))])(seq (group-by identity x)))))","user":"5a6a7cc5e4b0512ff01cda27"},{"problem":55,"code":"(fn mag\n  [coll]\n  (reduce (fn f [acc x]\n      (if (contains? acc x)\n        (assoc acc x (inc (get acc x)))\n        (assoc acc x 1))) {} coll))","user":"591e7bd4e4b09b4ee5954c34"},{"code":"(fn\n  [mySeq]\n  (let\n    [tmp (group-by identity mySeq)]\n    (zipmap\n     (keys tmp)\n     (map #(count %) (vals tmp))\n    )\n  )\n)","problem":55,"user":"5162757ee4b03cfa3774b3fe"},{"problem":55,"code":"(fn [coll]\n  (let [m (group-by identity coll)]\n    (zipmap (keys m) (map count (vals m)))))","user":"573d58c8e4b05c31a32c0811"},{"code":"(fn x-freq [coll]\r\n  (reduce (fn  [counts, x] \r\n    (assoc counts x (+ 1 (get counts x 0)))) {} coll))","problem":55,"user":"4ddeb916535d08e6dec9fdd9"},{"problem":55,"code":"(fn [coll]\n  (into\n   {}\n   (map\n    #(hash-map (first %) (count (second %)))\n    (group-by identity coll))))","user":"543c5200e4b032a45b86933e"},{"code":"(fn [l] (reduce (fn [m k] (update-in m [k] (fnil inc 0))) {} l))","problem":55,"user":"5097cfcbe4b00ad8bab4e977"},{"code":"(fn [xs] (apply merge-with concat (map #(hash-map (first %1) (count (last %1))) (group-by identity xs))))","problem":55,"user":"4ec1619b535dfed6da9c6dab"},{"code":"(fn [x] \n    (apply hash-map(mapcat \n      #(concat [(first %)] [(count (second %))]) \n      (group-by identity x))))","problem":55,"user":"503efe01e4b06c4e0e1fa26f"},{"code":"(fn [v]\n  (->> (map #(vector (first %) (count %))\n   \t  \t   (for [x (distinct v)]\n    \t\t(filter #{x} v)))\n      (apply concat)\n      (apply hash-map)))","problem":55,"user":"51197750e4b057cba170bc99"},{"code":"#(into {}  (map  (fn [x] [(key x) (count (val x))]) (group-by identity %)))","problem":55,"user":"5008d149e4b0144d4f561e41"},{"problem":55,"code":"(fn [coll]\n  (into {} \n        (map \n         (fn [[k v]]\n           [k (count v)]) \n         (group-by identity coll))))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn count-occurrences [coll]\n  (let [make-pair (fn [x] [x (count (filter #(= x %) coll))])\n        pairs     (map make-pair coll)\n        keys      (map first pairs)\n        values    (map second pairs)]\n    (zipmap keys values)))","problem":55,"user":"4fcaf7a4e4b0ee37620e1857"},{"code":"(fn [x]  \n  (let [val-vect  (group-by identity x)]\n     (zipmap (map #(key %) val-vect) (map #(count  (val %)) val-vect))\n  )\n )","problem":55,"user":"530d1060e4b08068f379eca2"},{"problem":55,"code":"#(loop [r {} s %]\n    (if (empty? s)\n      r\n      (recur (assoc r (first s) ((fn [c] (if (nil? c) 1 (inc c))) (get r (first s)))) (rest s))))","user":"5f9c4113e4b0715f5002d821"},{"problem":55,"code":"(fn count-occurs [s]\n  (->> (into #{} s)\n    (map (fn [k] [k (count (filter #(= % k) s))]))\n    (into {})))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":55,"code":"(fn count-ocur [coll]\n  (loop [mymap {} mycoll coll]\n    (if (empty? mycoll)\n      mymap\n      (let [result (if (contains? mymap (first mycoll))\n                     (vector (first mycoll) (inc (get mymap (first mycoll))))\n                     (vector (first mycoll) 1))]\n        (recur\n          (assoc mymap (first result) (last result))\n          (rest mycoll))))))","user":"5ad76df9e4b0ea6055cfac18"},{"problem":55,"code":"(fn count-occurrencies1 [xs]\n  (reduce\n    (fn [res elm]\n      (if (contains? res elm)\n        (update-in res [elm] inc)\n        (assoc res elm 1)))\n    {}\n    xs))","user":"5984e7dee4b021a7a535fe43"},{"problem":55,"code":"(fn my-frequencies [a-seq]\n  (loop [[da-element & da-rest] a-seq\n         result {}]\n    (let [new-count (inc (get result da-element 0))\n          new-result (assoc result da-element new-count)]\n      (if (empty? da-rest) new-result\n          (recur da-rest new-result )))))","user":"580d2788e4b0849f6811b730"},{"code":"reduce #(assoc % %2 (+ (get % %2 0) 1)) {}","problem":55,"user":"4f7e07f4e4b06e829148e1c9"},{"problem":55,"code":"(fn CountOccurrences\n  ([inputSequence outputSequence]\n  (if (empty? inputSequence)\n    outputSequence\n    (if (contains? outputSequence (first inputSequence))\n      (CountOccurrences (rest inputSequence) (update-in outputSequence [(first inputSequence)] inc))\n      (CountOccurrences (rest inputSequence) (assoc-in outputSequence [(first inputSequence)] 1))\n    )\n  ))\n  ([inputSequence]\n   (CountOccurrences inputSequence {}))\n)","user":"5e16b820e4b0a047bd49f71f"},{"problem":55,"code":"(fn [coll]\n   (into {}\n         (for [[k v] (group-by identity coll)]\n           [k (count v)])))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [l]\n  (let [d (distinct l)]\n    (apply hash-map (interleave d (map #(count (filter (partial = %) l)) d)))))","problem":55,"user":"52091d57e4b0e152394d76f0"},{"problem":55,"code":"#(into {} (map (fn [[k v]] [k (count v)]) (group-by max %)))","user":"5b210749e4b03cfeda66ed48"},{"code":"(fn [s]\n  (reduce\n   #(assoc % %2 (count (filter (fn[c] (= %2 c)) s)))\n   {}\n   s))","problem":55,"user":"51b86a0fe4b09e0e347b2e78"},{"code":"#(into {} (map (fn [[k v]] {k (count v)}) (group-by identity %)))","problem":55,"user":"4f43b992e4b0d7d3c9f3fd2c"},{"code":"(fn my-freqs [xs]\n  (reduce (fn [z x]\n            (if (z x)\n              (update-in z [x] + 1)\n              (assoc  z x 1))) {} xs))","problem":55,"user":"50611456e4b0dc10a69545a5"},{"problem":55,"code":"(fn freq [xs]\n  (let [f (fn [m x]\n            (assoc m x (inc (m x 0))))]\n    (reduce f {} xs)))","user":"5bcddaeee4b0e9689409ee07"},{"code":"(fn [lista] \n   (->> lista\n    (group-by identity)\n    (#(zipmap (keys %) (map count (vals %))))))","problem":55,"user":"5013141de4b0f26a0e3320a9"},{"code":"#(reduce (fn [mp x]\r\n          (if (contains? mp x)\r\n              (assoc mp x (+ 1 (val (find mp x))))\r\n              (assoc mp x 1)))\r\n        {}\r\n        %)","problem":55,"user":"4f71db68e4b07046d9f4f015"},{"problem":55,"code":"(fn [xs] (into {} (map (fn ([[x y]] [x (count y)])) (group-by identity xs))))","user":"5785de31e4b0ebec4cfb74e4"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [[k v]]\n                          [k (count v)]) (group-by identity %)))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn[coll]\n  (let [how-many    (group-by #(identity %) coll) \n        counts      (map #(count %) (vals how-many))\n\t      map-entries (interleave (keys how-many) counts)]\n\t      (apply assoc {} map-entries)))","problem":55,"user":"4e739e13535dff18050a9c76"},{"code":"(fn f [col]\n  (loop [l col m {}]\n    (if (empty? l) m\n      (let [f (first l)]\n        (recur (rest l) (assoc m f (inc (get m f 0))))))))","problem":55,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [acc elt]\n            (assoc acc elt (inc (get acc elt 0))))\n          {} xs))","user":"5553b924e4b0deb715856e06"},{"code":"#(reduce (fn [m [k c]] (assoc m k (count c))) {} (group-by identity %))","problem":55,"user":"4e705861535d5021c1a89635"},{"problem":55,"code":"(fn freq [args]\n   (loop [seqs (group-by hash args) res {}]\n     (println )\n     (if (empty? seqs)\n       res\n       (recur (rest seqs) (assoc res (first (second (first seqs))) (count (second (first seqs))))))))","user":"5508102ee4b021ccfedb96b0"},{"problem":55,"code":"(fn [col] \n  (apply hash-map \n         (mapcat #(list (first %) (count %))  (partition-by identity (sort col)))))","user":"563cce5be4b0bfe05bf1183f"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m v] (update-in m [v] (fnil inc 0))) {} coll)\n  )","user":"5471f2fbe4b094393f72dd70"},{"problem":55,"code":"(fn occur [s]\n    (reduce (fn [res nxt]\n        (assoc res nxt (inc (get res nxt 0)))) {} s))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [s]\n  (reduce #(assoc % %2 (inc (get % %2 0))) {} s))","problem":55,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(fn[x] (into {} (map #(hash-map (first %) (count %) ) (partition-by identity (sort x)))))","problem":55,"user":"50b25f2ce4b03ea88043355f"},{"code":"(fn [c]\n  (let [grouped (group-by identity c)] \n  (zipmap (keys grouped) (map count (vals grouped)))))","problem":55,"user":"4e8a0d5d535d3e98b802328e"},{"code":"(fn [s]\n  (loop [ss s out {}]\n    (if (empty? ss)\n      out\n     (recur (rest ss) (assoc out (first ss) (inc (get out (first ss) 0)))))))","problem":55,"user":"4dd9d299535d2dad7130b5dd"},{"problem":55,"code":"(fn [coll] \n  (into {} (map #(vector (first %) (count (last %))) (group-by identity coll))))","user":"5486e317e4b0e286459a11c0"},{"problem":55,"code":"(fn [items] (reduce (fn [memo,item] (assoc memo item (inc (get memo item 0)))) {} items))","user":"516ee939e4b06aac486e5b34"},{"code":"(fn freqs [coll]\n  (loop [m {}\n         [x & xs] coll]\n    (if (nil? x)\n      m\n      (recur (update-in m [x] (fnil inc 0))\n             xs))))","problem":55,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn [coll]\n  (loop [my-coll coll\n       my-map  {}]\n    (if (seq my-coll)\n    (recur (rest my-coll)\n           (assoc my-map\n             (first my-coll)\n             (inc (get my-map (first my-coll) 0))\n             ))\n    my-map)))","problem":55,"user":"4f072644535dcb61093f6c20"},{"code":"(fn count-freq [lst]\n  (letfn [(remap [m i]\n            (if (m i)\n              (assoc m i (inc (m i)))\n              (assoc m i 1)))]\n    (reduce #(remap %1 %2) {} lst)))","problem":55,"user":"5374adc3e4b06d7f452d9e27"},{"problem":55,"code":"(fn [c] (reduce #(assoc % %2 (inc (% %2 0))) {} c))","user":"54126d0ce4b01498b1a719d5"},{"code":"(fn [s] (->> \n  s\n  sort\n  (partition-by #(do %))\n  (map #(assoc {} (first %) (count %)))\n  (into {})\n))","problem":55,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [x] \n  (into {} \n        (map (fn [[key vec]] [key (count vec)]) \n             (group-by identity x))))","problem":55,"user":"51533ecde4b0252ac4b16619"},{"code":"(fn [s]\n  (into {} (map #(vector (first %) (count (last %))) (group-by identity s)))\n)","problem":55,"user":"4f63777be4b0defedf855fe4"},{"code":"#(let [gm (group-by identity %)]\n\n  (loop [r {} ks (vec (keys gm)) vs (vec (vals gm)) ]\n  (if (and ks vs)\n   (recur (into r {(first ks) (count (first vs))}) (next ks) (next vs))    \n   r\n  )\n  )\n)","problem":55,"user":"50921f9ae4b09a7d0b586de1"},{"code":"(fn freq [coll]\r\n  (reduce (fn update-map [m x]\r\n      (update-in m [x] (fn inc-val [old] (if old (inc old) 1))))\r\n\t  {}\r\n\t  coll))","problem":55,"user":"4e6ab9cb535d8ccf87e9fefe"},{"code":"(fn f [value]\n  (let [m (group-by (fn [x] x) value)]\n    (into {} (for [[k v] m] [k (count v)])))\n  )","problem":55,"user":"5302ac7fe4b0d8b024fd3731"},{"problem":55,"code":"reduce #(if (nil? (%1 %2)) (assoc %1  %2 1) (assoc %1 %2 (inc (%1 %2)))) {}","user":"5686b7c7e4b0dcc4269f4057"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [kv v]\n            (update-in kv\n                       [v]\n                       #(if (nil? %1)\n                          1\n                          (inc %1))))\n          {} xs))","user":"5f2d6787e4b033932238a66d"},{"code":"#(apply hash-map\n  (apply concat\n    (for [i (group-by (fn [x] x) %)]\n           [(first i) (count (second i))])))","problem":55,"user":"4e1b8106535d04ed9115e801"},{"code":"(fn freq [coll]\n  (loop [coll coll\n         return-map {}]\n    (if (seq coll)\n      (recur (remove #(= (first coll) %) coll)\n             (assoc return-map \n                    (first coll) \n                    (count (filter #(= % (first coll)) coll))))\n      return-map)))","problem":55,"user":"4eda7cc3535d10e5ff6f530e"},{"problem":55,"code":"#(let [a (group-by identity %)]\n    (zipmap (keys a) (map count (vals a))))","user":"51a4d802e4b0def3c5c5869a"},{"problem":55,"code":"(fn [xs]\n  (apply hash-map\n         (mapcat\n          (fn [x]\n            [x\n             (count (filter #(= % x) xs))])\n          (distinct xs))))","user":"56fee4c0e4b08d47c97781b5"},{"problem":55,"code":"(fn [xs]\n  (apply merge-with + (map (fn [x] {x 1})\n                            xs)))","user":"55c4e48be4b0e31453f649a7"},{"code":"#(apply merge (map (fn [[v o]] {v (count o)}) (group-by identity %)))","problem":55,"user":"4e80e0f2535db62dc21a62b8"},{"problem":55,"code":"(fn my-freq [coll]\n  (loop [c coll acc {}]\n    (if (empty? c) \n      acc\n      (let [i (first c)]\n        (if (get acc i)\n          (recur (rest c)(assoc acc i (inc (get acc i))))\n          (recur (rest c)(assoc acc i 1)))))))","user":"53ae0c50e4b047364c044471"},{"problem":55,"code":"(fn [S]\n  (loop [[x1 & xrest :as X] S, out {}]\n    (if (seq X)\n      (recur xrest (conj out [x1 (inc (get out x1 0))]))\n      out)))","user":"564d02cde4b0284900eef679"},{"code":"(fn [xs] (apply zipmap (let [ys (partition-by identity (sort xs))]  [(map first ys) (map count ys)])))","problem":55,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":55,"code":"(fn [coll]\n  (let [kys (distinct coll)\n        vls (map (fn [ky]\n                   (count (filter #(= ky %) coll))) kys)]\n   (zipmap kys vls)))","user":"5727031ee4b0c5bde472c12f"},{"code":"(fn [coll]\n    (zipmap (keys (group-by identity coll)) \n            (map #(count (second %)) \n                 (group-by identity coll))))","problem":55,"user":"532631e1e4b09d4e7a9b54ea"},{"problem":55,"code":"(fn [coll]\n    (let [scoll (group-by identity coll)\n          fmap (fn [m f] (into {} (for [[k v] m] [k (f v)])))]\n\n      (fmap scoll count)\n\n      )\n    )","user":"515ebde3e4b01e5d11ccd0a8"},{"problem":55,"code":"(fn [xs] (reduce #(merge-with + % {%2 1}) {} xs))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn my-freq [coll]\n  (zipmap \n    (for [[k v] (group-by identity coll)] k)\n    (for [[k v] (group-by identity coll)] (count v))))\n; into can be used.","problem":55,"user":"501c1492e4b086d93747d180"},{"problem":55,"code":"(fn freq [xs]\n  (apply merge\n         (map #(hash-map (first %) (count %))\n              (partition-by identity\n                            (sort xs))))\n  )","user":"569ad037e4b0542e1f8d144f"},{"problem":55,"code":"(fn my-frequencies [s]\n    (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} s))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [coll]\n     (letfn [(aux [[hcoll & tcoll] acc]\n       (do\n         (if (not hcoll)\n           acc\n           (if (contains? acc hcoll)\n             (recur tcoll (assoc acc hcoll (inc (acc hcoll))))\n             (recur tcoll (assoc acc hcoll 1))))))]\n       (aux coll (array-map))))","problem":55,"user":"505b9084e4b032b709c81371"},{"problem":55,"code":"(fn [coll] (apply merge-with + (for [x coll] {x 1})))","user":"5935b010e4b04f87174def55"},{"problem":55,"code":"#(into {}\n  (map (fn [[k v]] [k (count v)]) \n    (group-by identity %)))","user":"5797d3d2e4b039eba2ecb106"},{"problem":55,"code":"(fn [s] \n  (loop [s (sort s)\n         result {}]\n    (if (empty? s)\n      result\n      (let [f (first s) \n            sub (take-while #(= f %) s)]\n      (recur (drop (count sub) s) (conj result {f (count sub)}))))))","user":"567d18c9e4b05957ce8c61c4"},{"code":"#(->> %\n  (group-by identity)\n  (map (fn [[k v]] [k (count v)]))\n  (into {})\n)\n\n\n;;  #(into {} \n;;  (map \n;;    (fn [[k v]] [k (count v)]) \n;;    (group-by identity %)))","problem":55,"user":"503917a0e4b088a6a14ca763"},{"problem":55,"code":"reduce (fn [a b] (assoc a b (inc (a b 0)))) {}","user":"56d63729e4b0ea9b8538f7ca"},{"code":"(fn [s]\r\n  (reduce\r\n    #(assoc % %2 (inc (% %2 0)))\r\n    {}\r\n    s))","problem":55,"user":"504e14c2e4b078edc5f593bf"},{"code":"#(reduce (fn [x i] \n           (assoc x i \n                  (inc (x i 0)))) \n  {} \n  %)","problem":55,"user":"4e6f8d36535d5021c1a89621"},{"problem":55,"code":"(fn [col]\n  (loop [xs col acc {}]\n    (if (seq xs)\n      (recur (rest xs) (update-in acc [(first xs)] #(if %1 (inc %1) 1)))\n      acc)))","user":"5bc833a5e4b07a9b28b100bb"},{"problem":55,"code":"#(into {} (map (fn [[key value]][key, (count value)]) (group-by identity %)))","user":"5a83e15ae4b00b71e582a088"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [m [k v]] (assoc m k (count v)))\n   {}\n   (group-by identity coll)))","user":"5338387de4b0e30313ee6c91"},{"problem":55,"code":"(fn count-occurrences\n  [coll]\n  (->> (group-by identity coll)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"543c39e0e4b032a45b86933d"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv #(assoc %1 %2 (count %3))\n             {}\n             (group-by identity (sort coll))))","user":"5650b8a0e4b0284900eef6c3"},{"problem":55,"code":"(fn count-occurances\n  [sequ]\n  (let [identity-map (group-by identity sequ)\n        id-map-keys  (keys identity-map)\n        id-map-vals  (vals identity-map)\n        count-vals   (map count id-map-vals)]\n    (zipmap id-map-keys count-vals)))","user":"55a9e0fee4b0988bba2ad945"},{"code":"#(zipmap (keys (group-by identity %)) \n(map count (vals (group-by identity %))))","problem":55,"user":"504e2333e4b0f6ff3350c46c"},{"problem":55,"code":"(fn [coll]\n   (let [grouped\n         (group-by identity coll)]\n     (apply merge(map (fn [[k v]] {k (count v)}) grouped))))","user":"5fb544f6e4b08cb800c85b4e"},{"problem":55,"code":"(fn [coll]\n(reduce (fn [m i] (assoc m (first i) (count (last i)) )) {} (group-by identity coll)))","user":"53ae16e2e4b047364c044472"},{"problem":55,"code":"(fn [xs]\n        (reduce (fn [a b]\n                  (update-in a [b] #(inc (or % 0))))\n                {}\n                xs))","user":"5cc6b4bfe4b0ccb061962827"},{"code":"(fn [x]\n  (let [grouped (group-by identity x)]\n    (zipmap (keys grouped) (map #(count (second %)) grouped))))","problem":55,"user":"53940789e4b0b51d73faaec3"},{"code":"(fn [l] (reduce #(assoc % %2 (if (nil? (% %2)) 1 (+ 1 (% %2)))) {} l))","problem":55,"user":"50dade7be4b02e6ac9592c70"},{"problem":55,"code":"reduce\n (fn [acc x]\n   (update-in acc [x] (fnil inc 0)))\n {}","user":"594880ade4b07ddc2dafadc2"},{"problem":55,"code":"(fn [xs]\n    (reduce (fn [a v]\n              (assoc a v (inc (get a v 0))))\n            {} (vec xs)))","user":"52b2f9cae4b0c58976d9acfb"},{"problem":55,"code":"(fn ff [s]\n  (loop [s s, c 0, atout (first s), trash [], res {}]\n    (if (or (seq s) (seq trash))\n      (recur (if (seq s)\n               (rest s)\n               trash)\n             (if (seq s)\n               (if (= (first s) atout)\n                 (inc c)\n                 c)\n               0)\n             (if (seq s)\n               atout\n               (first trash))\n             (if (seq s)\n               (if (= (first s) atout)\n                 trash\n                 (conj trash (first s)))\n               [])\n             (if (seq s)\n               res\n               (conj res [atout c])))\n      (conj res [atout c]))))","user":"593d6793e4b069cdc2982ba6"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [[a b]] [a (count b)]) (group-by identity %)))","user":"550b5c10e4b06e50f9beb143"},{"problem":55,"code":"(fn [col] (reduce (fn [newmap,item] (assoc newmap item (count (filter #(= item %) col)))) {} col ))","user":"5e4ba8e8e4b0889a8790a55a"},{"code":"(fn [xs] (apply (partial conj {}) (map (fn [x] {x (count (filter #(= x %) xs))}) (distinct xs))))","problem":55,"user":"5186134ce4b0da5a5be3bac7"},{"problem":55,"code":"(fn f [coll]\n  (reduce\n   (fn [acc e]\n     (assoc acc e (inc (or (acc e) 0))))\n   {}\n   coll))","user":"540d5085e4b0addc1aec670e"},{"code":"(fn co [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","problem":55,"user":"504ec4d3e4b069badc5a33c9"},{"code":"#(let [m (group-by identity %)](zipmap (keys m) (map count (vals m))))","problem":55,"user":"4e7eff9e535db966e863cc38"},{"problem":55,"code":"(fn frequencies*\n  [coll]\n  (let  [partitions (partition-by identity coll)\n         maps (map #(hash-map (first %) (count %)) partitions)]\n                   (apply (partial merge-with +)\n                               maps)))","user":"566f7749e4b0a866af6896e9"},{"problem":55,"code":"(fn [S]\n  (reduce #(if (contains? %1 %2) (assoc %1 %2 (inc (%1 %2))) (assoc %1 %2 1)) {} S\n  )\n )","user":"5649615be4b0284900eef641"},{"code":"(fn [coll]\n   (reduce (fn [resmap item] (assoc resmap item\n                                    (if (resmap item)\n                                      (+ (resmap item) 1)\n                                      1))) {} coll))","problem":55,"user":"4eb02674535d7eef30807338"},{"code":"#(let [a (group-by identity %)] (into a (for [k (keys a)] [k (count (a k))])))","problem":55,"user":"51037468e4b00c483ae17702"},{"problem":55,"code":"(fn [coll]\n  (let [grouped (group-by identity coll)]\n    (zipmap (keys grouped) (map #(count (second %)) grouped))\n  )\n)","user":"54e5bdf2e4b024c67c0cf7fe"},{"problem":55,"code":"(fn [c] (reduce #(update-in %1 [%2] (fn [x] (+ (or x 0) 1))) {} c))","user":"5541fa50e4b0a04f79299515"},{"code":"(fn [l] (into {} (map #(vector (first %) (count (second %))) (group-by identity l))))","problem":55,"user":"532bce35e4b09d4e7a9b5536"},{"problem":55,"code":"#(let\n   [a (group-by identity %)]\n   (zipmap \n    (keys a) \n    (map count (vals a))))","user":"59733c91e4b01722bebd4c9b"},{"code":"(fn [l]\n  (reduce #(assoc % %2 (inc (get % %2 0))) {} l))","problem":55,"user":"5336a339e4b0e30313ee6c7d"},{"code":"#(into {}\n       (map (fn [[x y]] (vector x (count y)))\n            (group-by identity %)))","problem":55,"user":"53736f65e4b06d7f452d9e0f"},{"problem":55,"code":"(fn [coll]\n\n  (reduce #(assoc %1 %2 (if (%1 %2)(inc (%1 %2))1)) {} coll)\n\n  )","user":"5535e822e4b09218d5f44fb2"},{"problem":55,"code":"#(let [grouped (group-by identity %)]\n   (loop [result {}, items (keys grouped)]\n     (let [firstItem (first items)]\n       (if (nil? firstItem)\n         result\n         (recur (assoc result firstItem (count (get grouped firstItem))) (rest items))))))","user":"57f52d3be4b0903ccab3dce7"},{"code":"(fn [xs]\n  (loop [xs xs acc {}]\n    (if (empty? xs)\n      acc\n      (recur (rest xs) (update-in acc [(first xs)] #(if (nil? %) 1 (inc %)))))))","problem":55,"user":"4e4c238f535dc968683fc4dc"},{"problem":55,"code":"(fn my-frequencies [coll] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"539b4268e4b0b51d73faaf1c"},{"problem":55,"code":"#(reduce (fn [st x]\n           (let [xv (st x)] \n             (assoc st x \n               (if (nil? xv) 1 (inc xv)))))\n         {} \n         %)","user":"57c94c6ee4b05aa3c4741d2d"},{"code":"(fn [coll] (apply hash-map (mapcat #(vector % (count (filter #{%} coll))) (set coll))))","problem":55,"user":"4eb2eae5535d7eef30807351"},{"problem":55,"code":"(fn count-occur [coll]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity coll)))","user":"5dd67c22e4b0948ae9d9ad80"},{"code":"(fn [coll] (reduce-kv (fn [m k v] (assoc m k (count v)))\n                      {}\n                      (group-by identity coll)))","problem":55,"user":"5080a697e4b01a93d3f38e49"},{"problem":55,"code":"(fn [s] (reduce #(assoc %1 %2 (+ 1 (%1 %2 0))) {} s))","user":"563536f8e4b0bfe05bf117c5"},{"code":"(fn [v] (loop [v v rv {}]\n          (if (empty? v)\n            rv\n            (recur (rest v) (assoc rv (first v) (inc (get rv (first v) 0)))))))","problem":55,"user":"534f13b2e4b084c2834f4ac4"},{"problem":55,"code":"(fn [coll] (into {} \n      (map (fn [[a b]] \n             [a (count b)]) \n           (group-by identity coll))))","user":"60654263e4b069485764ddc9"},{"code":"(fn freq [s]\n  (let [ns (interleave s (repeat 1))]\n    (loop [ns ns data {}]\n      (if (empty? ns)\n        data\n        (recur (rest (rest ns)) (merge-with + data {(first ns) (second ns)}))))))","problem":55,"user":"4ec3b393535dcc7ae8597d59"},{"code":"(fn [s]\n  (reduce (fn [m v] (assoc m v (inc (get m v 0)))) {} s))","problem":55,"user":"4ef0eaef535dced4c769f211"},{"problem":55,"code":"(fn [l] \n  (reduce \n      (fn [new_map val] (merge-with + new_map val))\n      {}\n      (map #(hash-map % 1) l)))","user":"5da05bcce4b000c986472bd0"},{"problem":55,"code":"(fn my-frequencies [lst]\n  (into (sorted-map)\n        (reduce (fn [map x] (assoc map x (inc (get map x 0)))) {} lst)))","user":"546c1f73e4b00cfc9eacc175"},{"code":"(fn [coll]\r\n  (reduce (fn [r v]\r\n            (conj r [v (count (filter #(= % v) coll))]))\r\n          {}\r\n          (reduce #(conj %1 %2) #{} coll)))","problem":55,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn [coll] (reduce #(assoc %1 %2 (if (contains? %1 %2) (inc (%1 %2)) 1)) {} coll))","problem":55,"user":"50fac9e3e4b07934dda8b0d1"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [resu item]\n            (assoc resu item (inc (get resu item 0))))\n          {}\n          coll))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"#(loop [r {} s %] (if (empty? s) r (let [[k & t] s] (recur (conj r [k (inc (get r k 0))]) t))))","problem":55,"user":"4e7e55ab535db169f9c79711"},{"problem":55,"code":"#(->> (group-by identity %) (map (juxt first (comp count last)))  (into {}))","user":"56f974c0e4b07572ad1a88b1"},{"problem":55,"code":"#(reduce-kv (fn[m k v] (assoc m k (count v))) {} (group-by identity %))","user":"4f32135ae4b0d6649770a08e"},{"code":"(fn [coll]\n   (reduce (fn [r i] (update-in r [i] #(inc (or % 0)))) {} coll))","problem":55,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":55,"code":"(fn [xs]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} xs))","user":"55f9b2b6e4b03cbcff9738c8"},{"code":"#(into {} (map (fn [[k v]] (vector k (count v))) (group-by identity %)))","problem":55,"user":"4e50ad74535dc968683fc4ec"},{"code":"(fn [a] (reduce #(update-in %1 [%2] inc) (zipmap (set a) (repeat 0)) a))","problem":55,"user":"4dbecb06535d020aff1edf6a"},{"problem":55,"code":"(fn [s] (apply merge (map #(hash-map (first %) (count %)) (partition-by identity (sort s)))))","user":"52eaba10e4b09f7907dd14c2"},{"code":"(fn [x]\n  (apply hash-map (mapcat #(vector (first %) (count %))\n    (vals (group-by #(identity %) x)))))","problem":55,"user":"4ec5cdb0535d6d7199dd36b8"},{"problem":55,"code":"#(into (sorted-map)\n  (map \n  (fn [x] [(first x) (count (second x))]) \n  (group-by identity %)))","user":"5630471ce4b073c1cf7a9be4"},{"problem":55,"code":"(fn [s]\n  (let [res (into {} (map vector s (repeat 0)))]\n    (reduce #(update-in %1 [%2] inc) res s)))","user":"5461dc79e4b01be26fd746a8"},{"problem":55,"code":"(fn count-occurences [coll]\n  (reduce (fn [acc n] (assoc acc n (inc (get acc n 0))))\n          {}\n          coll))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":55,"code":"(fn [v]\n   (let [update (fn [m k f] (assoc m k (f (get m k))))\n         map (into (hash-map) (map vector v (repeat (count v) 0)))\n         f (fn [m e] (update m e inc))]\n     (reduce f map v)))","user":"56e2ca59e4b03a7c14b85a38"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc [ky vl]]\n            (merge acc {ky (count vl)}))\n          {}\n          (group-by identity coll)))","user":"5d48e6d3e4b0776584bd6f15"},{"problem":55,"code":"#(into {} (map (fn [x] {(first x) (count x)})(partition-by identity (sort %1))))","user":"5897dda4e4b00487982d52c8"},{"problem":55,"code":"(fn [xs]\n  (let [s (set xs)]\n    (into {} (map #(vector % (count (filter (partial = %) xs)))\n                  s))))","user":"58ebae90e4b056aecfd47d44"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m x]\n            (assoc m x (inc (m x 0))))\n          {}\n          xs))","user":"54dc49d3e4b024c67c0cf780"},{"code":"(fn [l] (apply hash-map (apply concat (map (fn [[i l]] [i (count l)])\n                                           (group-by identity l)))))","problem":55,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn[x] (let [y (group-by #(if (= % %) %) x)] (into {} (map #(vector (first %) (count (second %))) y))))","problem":55,"user":"4eb0175b535d7eef30807336"},{"code":"(fn [c]\r\n  ((fn [[x & xs :as s] m]\r\n     (if (nil? s)\r\n       m\r\n       (let [oldVal (if (contains? m x) (m x) 0 )]\r\n         (recur xs (assoc m x (inc oldVal)))))) c (hash-map)))","problem":55,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":55,"code":"(fn occ\n  ([in em]\n   (println (str in \" \" em))\n   (cond (empty? in) em\n                 :else (recur (rest in) (assoc em\n                                               (first (first in))\n                                               (count (first in))))))\n  ([in]\n   (occ (partition-by identity (sort in)) {})))","user":"58a3ba31e4b02bd94d917eff"},{"code":"(fn\n  [coll]\n  (apply hash-map\n         (mapcat\n          (fn [[a b]]\n            (vector a (count b)))\n          (group-by identity coll))))","problem":55,"user":"511f88eee4b085952a83535f"},{"problem":55,"code":"(fn freq [xs](if(empty? xs) {} (merge(hash-map (first xs)(count(filter #(= (first xs) %) xs)))(freq (filter #(not= (first xs) %) xs)))))","user":"57752a2de4b0979f89651613"},{"problem":55,"code":"(fn [xs]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity xs))))","user":"5fb3bd04e4b08cb800c85b3a"},{"code":"(fn [coll] (reduce (fn [counts x] (assoc counts x (inc (get counts x 0))))\n                   {}\n                   coll))","problem":55,"user":"52d9aaa1e4b09f7907dd13ae"},{"code":"(fn a [x] (let [res (map (fn b [y] (filter #(= % y) x)) (set x))] \n            (zipmap (map first res) (map count res))))","problem":55,"user":"510c123be4b078ea7192110e"},{"problem":55,"code":"(fn\n  [col]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} col)\n  )","user":"595d0897e4b066ee0a44b00f"},{"problem":55,"code":"#( loop [ a % res {} ] \n   ( if (empty? a)\n     res\n     (let [ f (first a) zi ( if (res f) (res f) 0 ) ]\n       ( recur (rest a) (conj res [f (inc zi)]))\n       )\n     )\n   )","user":"5b3aa98be4b02d533a91bbca"},{"problem":55,"code":"#(let [f (group-by identity %)] (zipmap (keys f) (map count (vals f))))","user":"5edd6eb7e4b0c7845d86b0f7"},{"code":"(fn [coll] \n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"5084c43be4b0fb8f40674bfa"},{"code":"#(reduce (fn [m e] (assoc m e (inc (get m e 0)))) {} %)","problem":55,"user":"5027b41ee4b01614d1633fee"},{"problem":55,"code":"#(reduce-kv (fn [a k v] (assoc a k (count v))) {} (group-by identity %))","user":"5a0b9fc0e4b04bbd27e6d992"},{"code":"(fn [x] (#(zipmap (keys %) (map count (vals %))) (group-by identity x)))","problem":55,"user":"52bf29fde4b07a9af579232e"},{"code":"(fn [xs]\n  (into {} (map #(vector (first %) (count (last %)))\n                (group-by identity xs))))","problem":55,"user":"52bb4be0e4b07a9af57922e2"},{"code":"(fn count-occurrences\n  [coll]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","problem":55,"user":"51937eb3e4b04df54c098022"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m k]\n          (update-in m [k] (fnil inc 0))) {} (seq s)))","user":"4f6ba7bce4b07046d9f4efb0"},{"problem":55,"code":"(fn [col]\n  (reduce #(assoc-in %1 [%2] (inc (get-in %1 [%2] 0))) {} col))","user":"5a58d8a0e4b05d388ecb6c8a"},{"problem":55,"code":"(fn [x]\n  (let [n (count x)]\n    (loop [i 0 output (reduce merge (map #(hash-map % 0) (into #{} x)))]\n      (if (= n i) output\n          (let [a (nth x i)]\n            (recur (inc i) (assoc output a (inc (output a)))))))))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":55,"code":"#(apply merge \n  (map (fn [[k v]] {k (count v)}) \n  (group-by identity %)))","user":"56304db8e4b073c1cf7a9be5"},{"problem":55,"code":"(fn [coll] \n  (reduce \n    (fn [m [k v]] (conj m [k (count v)]))\n      {} (group-by identity coll)))","user":"56a01895e4b0542e1f8d149f"},{"problem":55,"code":"(fn cmap [s]\n  (if (empty? s)\n    {}\n   \t(assoc (cmap (rest s)) (first s) (count (filter (partial = (first s)) s)))))","user":"545801f6e4b01be26fd74615"},{"code":"(fn [coll]\r\n  (let [f (fn [m k]\r\n            (update-in m [k] #(if (nil? %) 1 (inc %))))]\r\n     (reduce f {} coll)))","problem":55,"user":"4ff3df0fe4b0678c553fc355"},{"problem":55,"code":"#(apply hash-map (apply concat (map (fn [f] [(first f) (count (second f))]) (group-by identity %))))","user":"6045582fe4b02d28681c77b6"},{"code":"(fn [xs]\n  (reduce #(assoc %1 %2 (inc (get % %2 0))) {} xs))","problem":55,"user":"52b65f26e4b0c58976d9ad43"},{"problem":55,"code":"#(let [data (group-by identity %)]\n   (zipmap (keys data)\n           (map count (vals data))))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [coll]\n   (into {}\n      (for [[k v ](group-by identity coll)] [k (count v)])))","problem":55,"user":"52c58440e4b0c2d177d620f7"},{"problem":55,"code":"(fn [coll] (reduce (fn[m e] (update-in m [e] (fnil inc 0))) {} coll))","user":"4f1ef6a0535d64f60314649b"},{"problem":55,"code":"(fn [coll]\n  (let [x (group-by identity coll)]\n    (zipmap (keys x) (map count (vals x)))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn [x]\n  (let [y (group-by identity x)]\n  (zipmap\n    (map #(key %) y)\n    (map #(count(val %)) y))))","problem":55,"user":"507ef25ce4b0f753b6f9788e"},{"problem":55,"code":"reduce #(assoc-in %1 [%2] (inc (get %1 %2 0))) {}","user":"524025bce4b0ad64fa01030f"},{"problem":55,"code":"(fn custom-frequencies [s]\n  (reduce\n    (fn [acc curr]\n      (if (contains? acc curr)\n        (update-in acc [curr] inc)\n        (assoc acc curr 1)))\n    {}\n    s))","user":"5d0eed51e4b0cc9c91588262"},{"problem":55,"code":"(fn [a]\n   (loop [v a\n          r {}]\n     (if (empty? v)\n       r\n       (recur (rest v) \n              (let [k (first v)]\n                         (assoc r k\n                                  (let [n (r k)]\n                                    (if (nil? n)\n                                      1\n                                      (inc (r k)))))))))\n   )","user":"56171eade4b06b1bb2182a0c"},{"problem":55,"code":"(fn [in]\n   (reduce\n     (fn [out item]\n       (let [existing\n             (some\n               (fn [entry]\n                 (if (= (key entry) item)\n                   entry))\n               out)] ;some on a map returns [key value] but a special one: you can apply (key) and (val)\n         (assoc out\n           item\n           (if existing\n             (inc (val existing))\n             1))))\n     {}\n     in))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [a]\n  (let [m ( reduce concat (seq (group-by identity a)))] (zipmap (take-nth 2 m) (map count (take-nth 2 (rest m))))))","problem":55,"user":"525cc137e4b0cb4875a45d46"},{"problem":55,"code":"(comp (partial reduce-kv #(assoc %1 %2 (count %3)) {}) (partial group-by identity))","user":"575ef4b6e4b08062f99a4e78"},{"problem":55,"code":"(fn [col] \n  (loop [cnt col res {}]\n    (if(empty? cnt) res\n      (recur (rest cnt) (merge-with + res {(first cnt) 1})))))","user":"584f5133e4b0b7285a6f4e61"},{"problem":55,"code":"(fn [s]\n  (->> (group-by identity s)\n       (reduce-kv (fn [m k v] (assoc m k (count v))) {})))","user":"584b0422e4b089d5ab817ef4"},{"code":"#(->> % (group-by (fn [x] x)) (mapcat (fn [[k v]] [k (count v)])) (apply hash-map))","problem":55,"user":"4e6a48d5535d8ccf87e9febd"},{"problem":55,"code":"#(into {} (map (fn [[k v]] (vector k (count v) )) (group-by identity %)))","user":"5e0cbc14e4b099d064962f8e"},{"code":"(fn char-cnt [s]\n\t (reduce\n\t    (fn [m k]\n\t      (update-in m [k] (fnil inc 0)))\n\t  {}\n  (seq s)))","problem":55,"user":"52a28e1ce4b04e0c58e87bf0"},{"code":"(fn [a-seq]\n  (loop [s a-seq\n         o {}]\n    (if (empty? s)\n      o\n      (let [f (first s)\n            r (rest s)\n            v (get o f 0)\n            o (assoc o f (inc v))]\n        (recur r o)))))","problem":55,"user":"52ee46e5e4b05e3f0be25ec5"},{"problem":55,"code":"(fn [v] \n    (reduce \n        #(if (%1 %2)\n            (assoc %1 %2 (inc (%1 %2)))\n            (assoc %1 %2 1))\n        (into [{}] v)))","user":"55975569e4b031d6649c9b8e"},{"problem":55,"code":"#(let [dagroup (group-by identity %)] (zipmap (keys dagroup) (map count (vals dagroup))))","user":"5668dcc6e4b04acd4f672df8"},{"code":"(fn [xs] \n  (apply merge \n    (map #(hash-map (first %) (count %)) \n         (partition-by identity (sort xs)))))","problem":55,"user":"4fa6a491e4b081705acca1bc"},{"problem":55,"code":"(fn count-occurr [s]\n  (if (empty? s)\n    {}\n    (let [head (first s)\n          tail (rest s)\n          wit-head (filter #(= head %) s)\n          witout-head (filter #(not (= head %)) tail)\n          rec-map (count-occurr witout-head)]\n      (assoc rec-map head (count wit-head)))))","user":"5f63684be4b02876ed9fd012"},{"problem":55,"code":"(fn my-frequencies [a-seq]\n                     (loop [l a-seq acc {}]\n                       (if (empty? l)\n                         acc\n                         (if-let [f (get acc (first l))]\n                           (recur (rest l) (assoc acc (first l) (inc f)))\n                           (recur (rest l) (assoc acc (first l) 1))))))","user":"5f86a98be4b0649ffcda4caa"},{"code":"(fn f[v]\n   (reduce #(conj %1 [%2 (inc (%1 %2 0))]) {} v))","problem":55,"user":"4ee868be535d93acb0a6687d"},{"code":"(fn [x]      \n     (let [groups (group-by (fn [z] z) x)]\n       (let [counts (map count (vals groups))]\n       (zipmap (keys groups) counts))))","problem":55,"user":"525372ade4b0541d1855b8f3"},{"problem":55,"code":"#(reduce (fn [h v] (update-in h [v] (fnil inc 0))) {} %)","user":"56018dd4e4b04bb52996e18f"},{"problem":55,"code":"(fn [a]\n  (->> (group-by identity a)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"56201392e4b064ca9f4b16d8"},{"code":"(fn [x]\r\n  (reduce (fn [a b] (assoc a b (inc (a b 0)))) {} x))","problem":55,"user":"4ff201d7e4b0678c553fc330"},{"problem":55,"code":"#(reduce (fn [a b] (update-in a [b] (fnil inc 0))) {} %)","user":"590088bfe4b0438e51c2d026"},{"problem":55,"code":"(fn [lst] (let [m (group-by identity lst)]\n                         (zipmap (keys m) (map count (vals m)))))","user":"543d89dfe4b032a45b869350"},{"code":"(fn [y]\n   (loop [x y\n          size (count x)\n          acc {}]\n     (if (empty? x)\n       acc\n       (let [v (first x)\n             r (filter (partial not= v) x)\n             nsize (count r)]\n         (recur r nsize (assoc acc v (- size nsize)))\n         )\n       )\n     )\n  )","problem":55,"user":"515f8a0de4b0e2be8aa20bce"},{"problem":55,"code":"#(reduce (fn [n x] (assoc n x (inc (get n x 0)))) {} %)","user":"58b989dbe4b0888cdc949ccd"},{"code":"(fn [ls]\n  (let [g (group-by identity ls)]\n    (zipmap (keys g) (map count (vals g)))))","problem":55,"user":"5126dbabe4b083bb8f88cf0e"},{"code":"#(reduce (fn [m a] (assoc m a (count (filter (fn [i] (= a i)) %)))) {}\n         (distinct %))","problem":55,"user":"4e6a5f5c535d8ccf87e9fed6"},{"code":"(fn [coll]\n   (let [cc (vec (group-by identity coll))]\n     (into {} (map #(hash-map (first %)\n                              (count (second %))) cc))))","problem":55,"user":"516282c3e4b0e6d3c4734711"},{"code":"(fn [seqn]\n  (loop [s seqn, occurs {}]\n    (if (empty? s)\n      occurs\n      (let [[hd & tl] s\n            count (get occurs hd 0)]\n        (recur tl (assoc occurs hd (inc count)))))))","problem":55,"user":"4ea4fe1f535d7eef308072cf"},{"problem":55,"code":"(fn [xs]\n    (reduce\n      (fn [m x]\n        (if\n          (contains? m x)\n          (assoc m x\n            (inc\n              (get m x)\n            )\n          )\n          (assoc m x 1)\n        )\n      )\n      {}\n      xs\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(partial reduce (fn [acc x] (update-in acc [x] #(if % (inc %) 1))) {})","problem":55,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn [s]\n  (let [l (for [[k v] (group-by identity s)] \n    (list k (.size v)))]\n    (zipmap\n      (map first l)\n      (map second l))))","problem":55,"user":"4ef355e3535dced4c769f228"},{"code":"(fn [l]\n  (reduce\n    #(assoc %1 %2 (inc (get %1 %2 0)))\n    {}\n    l))","problem":55,"user":"4f04f847535dcb61093f6beb"},{"code":"(fn retm [x] (if (empty? x)  {}\r\n                 (let [m (retm (rest x))]\r\n                  (if (m (first x))\r\n                    (assoc m (first x) (inc (m (first x))))\r\n                    (assoc m (first x) 1)) )  ))","problem":55,"user":"50646c01e4b007509339a58b"},{"problem":55,"code":"(fn [c]\n  (reduce #(assoc %1 (last %2) (count %2)) {} (partition-by identity (sort c))))","user":"54e2a779e4b024c67c0cf7d3"},{"code":"(fn [x] (reduce-kv #(assoc % %2 (count %3)) {} (group-by identity x)))","problem":55,"user":"523d02b0e4b0dbf0c3017289"},{"code":"(fn [x]\n  (let [xx (group-by identity x)]\n     (apply hash-map (mapcat #(vector (first %) (count (second %))) xx)))\n  )","problem":55,"user":"52f4fae4e4b05e3f0be25f27"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc n]\n            (let [n-count (get acc n 0)]\n              (assoc acc n (inc n-count))))   \n          {} coll))","user":"53dfbc75e4b0d874e779ae44"},{"problem":55,"code":"#(reduce-kv\n   (fn [m k v]\n     (assoc m k (count v)))\n   {}\n   (group-by identity %))","user":"4e628ab2535d8ccf87e9fe61"},{"problem":55,"code":"#(reduce (fn [m [x c ]] (assoc m x (count c)) ) {} ( group-by identity %))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [l]\n  ( reduce #( assoc % %2 (inc (get % %2 0)))\n           {} l))","problem":55,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn occur [xs]\r\n  (if (empty? xs)\r\n    {}\r\n    (merge {(first xs) (count (filter #(= (first xs) %) xs))}\r\n           (occur (filter #(not= (first xs) %) xs)))))","problem":55,"user":"4dd023dd535d5973398f92ad"},{"code":"(fn [coll]\n  (loop [result {}\n        f (distinct coll)]\n    (if (not (seq f))\n      result\n      (recur (assoc result (first f) (count (filter #(= (first f) %) coll))) (rest f)))))","problem":55,"user":"51857e64e4b0da5a5be3babe"},{"problem":55,"code":"(fn my-frequencies-unrefactored [coll]\n  (letfn [(add-to-freq-map [freq-map x]\n            (if (nil? (get freq-map x))\n              (assoc freq-map x 1)\n              (update-in freq-map [x] inc)))]\n    (reduce add-to-freq-map {} coll)))","user":"53fd66a4e4b0de5c418485e3"},{"problem":55,"code":"(fn countVal [seq]\n  (loop [curr seq ans {}]\n    (if (empty? curr)\n      ans\n      (recur (rest curr) (assoc ans (first curr) ((fnil inc 0) (get ans (first curr)) ) ))\n      )\n    )\n  )","user":"5fd361f2e4b07e53c2f3f04e"},{"code":"#(into {} (let [d (group-by identity %)] (map (fn [k] [k (count (d k))]) (keys d))))","problem":55,"user":"52485723e4b05ef8e38e63d2"},{"code":"#(reduce (fn [a b] (assoc a b (+ 1 (get a b 0)))) {} %)","problem":55,"user":"5125029de4b0ce9225d2ed3e"},{"problem":55,"code":"(fn distincts [xs]\n  (into {} \n        (map #(vector (key %) (count (val %)))\n             (group-by identity xs))))\n\n\n;Clojure 1.7 solution but this site uses 1.6\n;(fn [xs]\n;  (loop [m (group-by identity xs) [k & ks] (keys m)]\n;    (if (nil? k) m\n;      (recur (update m k count) ks))))","user":"54dce62be4b024c67c0cf78b"},{"code":"#(apply assoc {}\n  (mapcat (fn [[x y]] [x (count y)])\n    (group-by identity %)))\n\n\n#_ \n(fn [l] \n  (reduce \n    (fn [counts item]\n      (assoc counts item (inc (counts item 0))))\n    {} l))","problem":55,"user":"4fe88f78e4b07c9f6fd12c45"},{"code":"(fn freq \n  [w] \n  (let [x (partition-by identity (sort w))] \n     (reduce (fn [t a] (assoc t (first a) (count a))) {} x)))","problem":55,"user":"5245d29ae4b09dbe66b56174"},{"problem":55,"code":"(fn [coll]\n   (let [a (partition-by identity (sort coll))]\n     (apply hash-map (interleave (map first a) (map count a)))))","user":"5857d27de4b0f14aab7c8710"},{"problem":55,"code":"(fn freqs [arr]\n\t(reduce\n\t\t(fn [mp x]\n\t\t\t(assoc mp x (inc (get mp x 0))))\n\t\t{}\n\t\tarr))","user":"59ac559ee4b00adcf69795d2"},{"problem":55,"code":"#(loop [pend % tmap {}]\n\t(if (empty? pend)\n\t\t(reduce-kv (fn [m k v] (assoc m (:val v) (:count v))) {} tmap)\n\t\t(let [part (first pend) partT (keyword (str part)) partMap (partT tmap)]\n\t\t(if (nil? partMap)\n\t\t\t(recur (rest pend) (assoc tmap partT {:val part, :count 1}))\n\t\t\t(recur (rest pend) (assoc tmap partT {:val part, :count (inc (:count partMap))}))))))","user":"57986b76e4b039eba2ecb116"},{"code":"#(reduce (fn [a i]\n  \t\t\t(if (contains? a i)\n    \t\t  (assoc a i (inc (a i)))\n    \t\t  (assoc a i 1))) \n         {} \n         %)","problem":55,"user":"50eebf46e4b06330c1f87c61"},{"code":"(fn [col]\n     (letfn [(cnt [col-item] (reduce #(assoc % %2 (count (get col-item %2))) {} (keys col-item)))]\n             (cnt (group-by identity col))))","problem":55,"user":"5036eba7e4b0af0658af77a5"},{"code":"(fn [l]\n   (reduce #(assoc %1 (first %2) (count (second %2))) {} (group-by identity l)))","problem":55,"user":"535e518ee4b04ce2eb3ed2cf"},{"problem":55,"code":"(fn occur [s]\n  (let [grp (group-by identity s)]\n    (zipmap (keys grp) (map (fn [[a b]] (count b)) grp))))","user":"534f8c9ae4b084c2834f4acd"},{"code":"(partial reduce (fn [h i] (merge-with + h {i 1})) {})","problem":55,"user":"516abecae4b081287f204e9f"},{"code":"(fn [coll] \n  (reduce (fn [m x] (assoc m x (inc (m x 0)))) {} coll))","problem":55,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn [xs]\n      (apply hash-map\n             (reduce #(concat % [(first %2) (count (last %2))])\n                     [] (group-by identity xs))))","problem":55,"user":"52bbe6e1e4b07a9af57922ef"},{"problem":55,"code":"(fn sol [xs] (into {} (for [[k v] (group-by identity xs)] [k (count v)])))","user":"54857657e4b0e286459a11ac"},{"code":"#(apply hash-map (mapcat (fn [[k v]] [k (count v)]) (group-by identity %)))","problem":55,"user":"4fb12b35e4b081705acca275"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [acc x]\n      (assoc acc x \n        (inc (get acc x 0))))\n    {} coll))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":55,"code":"(fn [s]\n  (loop [r {} s s]\n    (if (empty? s)\n      r\n      (if (get r (first s))\n        (recur (assoc r (first s) (inc (get r (first s)))) (rest s))\n        (recur (assoc r (first s) 1) (rest s))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"reduce #(update-in % [%2] (fn [x] (if x (inc x) 1))) {}","problem":55,"user":"4f6511eee4b07046d9f4ef3a"},{"code":"(fn [lst]\n  (reduce\n    #(assoc % (first %2) (count %2))\n    {}\n    (partition-by identity (sort lst))))","problem":55,"user":"4f0c84ce535d0136e6c2230e"},{"problem":55,"code":"(fn [xs]\n      (reduce #(assoc %1 %2 (inc (or (get %1 %2) 0))) {} xs))","user":"5db35f85e4b010eb3c36cd22"},{"problem":55,"code":";#(reduce-kv (fn [m k v] (assoc m k (count v)))\n;            {}\n;            (group-by identity %))\n\n;#(into {}\n;       (for [[k v] (group-by identity %)]\n;         [k (count v)]))\n\n;#(into {}\n;       (map (fn [[k v]] [k (count v)])\n;            (group-by identity %)))\n\n#(apply merge-with + (map (fn [x] {x 1}) %))","user":"54485749e4b032a45b8693c7"},{"problem":55,"code":"(fn [lst]\n  (into {} (map #(vec (list (first %) (count (second %)))) (group-by identity lst))))","user":"59a2ba97e4b066c664927d2c"},{"problem":55,"code":"(fn sk-frequency [c]\n  (into {}\n        (map (fn [[k v]] [k (count v)])\n        (group-by identity c))))","user":"51d42f44e4b013d740b70ddb"},{"problem":55,"code":"(fn me [col]\n  (letfn [      \n      (update-map [f m]\n        (reduce-kv\n          (fn [m k v] (assoc m k (f v)))\n          {} m))\n    ]\n    (->>\n      (group-by identity col)\n      (update-map count)\n    )\n  )\n)","user":"5c219c0fe4b07e362c230581"},{"code":"(fn [col] (into {} (for [[x y] (group-by identity col)]\n                     [x (count y)])))","problem":55,"user":"5233ad08e4b07e3ee2be83ac"},{"code":"(fn myfrequence [col]\n  (into {} (for [[k v] (group-by identity col)]\n             [k (count v)])))","problem":55,"user":"4fc2e302e4b081705acca33a"},{"problem":55,"code":"(fn count-ocur \n  [l]\n  (reduce (fn [accum n] (assoc accum n (count (filter #(= n %) l)))) {} l))","user":"5c0466a3e4b0bdcf453d1680"},{"code":"(fn ans [input]\n  (loop [in input\n        out {}]\n        (if (empty? in)\n            out\n            (let [elem (first in)\n                  num-so-far (out elem)]\n              (if num-so-far \n                (recur\n                  (rest in)\n                  (assoc out elem (inc num-so-far)))\n                (recur\n                  (rest in)\n                  (assoc out elem 1)))))))","problem":55,"user":"4e6a60cd535d8ccf87e9fed7"},{"code":"(fn freq\r\n  ([coll]\r\n     (freq coll {}))\r\n  ([coll f-map]\r\n     (if (= '() coll)\r\n       f-map\r\n       (let [m-key (first coll)\r\n       val (f-map m-key)\r\n\t     occ (if (= nil val) 1 (inc val))]\r\n\t(freq (rest coll) (assoc f-map m-key occ))))))","problem":55,"user":"4f17ab99535d64f603146457"},{"code":"(fn [s]\n  (apply merge-with + (map #(assoc nil % 1) s)))","problem":55,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":55,"code":"(fn co [s]\n  ((fn hlpr [s m] \n    (if (empty? s) m\n      (hlpr (rest s) (assoc m (first s) (inc (get m (first s) 0)))))) s {}))","user":"53e2b212e4b036ad0777e3f4"},{"code":"#(into {} (for [[x s] (group-by identity %)] [x (count s)]))","problem":55,"user":"4f956072e4b0dcca54ed6ccf"},{"code":"(fn [xs]\n  (loop [xs (seq xs) m {}]\n    (if xs\n      (recur (next xs) (assoc m (first xs) (inc (get m (first xs) 0))))\n      m)))","problem":55,"user":"4ef9c8f9535dced4c769f26b"},{"code":"reduce #(assoc %  %2 (+ 1 (% %2 0))) {}","problem":55,"user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn [coll]\n  (apply merge \n    (map #(hash-map (first %) (count %)) \n    (->> coll sort (partition-by identity)))))","problem":55,"user":"4e9ff8d0535d7eef3080729c"},{"problem":55,"code":"(fn [col]\n  (reduce\n    #(assoc % %2 (inc (get % %2 0)))\n    {}\n    col\n  )\n)","user":"5da20e73e4b000c986472be1"},{"problem":55,"code":"(fn [ a ]\n  (let [g (group-by identity a)]\n    (zipmap (keys g) (map count (vals g)))))","user":"548f3ed8e4b0e286459a1236"},{"code":"reduce \n(fn [m n]\n  (assoc m n (inc (get m n 0)))) \n{}","problem":55,"user":"4ea09fa4535d7eef308072aa"},{"code":"(fn [coll]\n  (apply merge-with + (map (fn [x] {x 1}) coll)))","problem":55,"user":"4f65eec7e4b07046d9f4ef48"},{"code":"(fn [coll]\n   (into {}\n         (for [[k vs] (group-by identity coll)] [k (count vs)])))","problem":55,"user":"51d4ed02e4b013d740b70dec"},{"problem":55,"code":"(fn __ [collection]\n  (reduce\n    (fn [frequencies-map item]\n      (assoc frequencies-map item (inc (get frequencies-map item 0))))\n    {}\n    collection))","user":"5ac91d90e4b0e27600da77bd"},{"problem":55,"code":"(fn count-occ [stuff]\n\t(let [item (first stuff)]\n\t\t(if (nil? item)\n\t\t\t{}\n\t\t\t(assoc (count-occ (filter #(not= item %) stuff))\n\t\t\t\titem (count (filter  #(= item %) stuff))))))","user":"5b2a559be4b063e2438bcc74"},{"problem":55,"code":"#((fn fr [m s](if (empty? s) m (let [k (first s)] (fr (conj m (if (contains? m k) {k (inc (m k))} {k 1} )) (rest s))))) {} %)","user":"587c59d1e4b01531a375eb17"},{"code":"(fn [s]\n  (reduce (fn [acc s] (update-in acc [s] #(inc (or % 0)))) '{} s))","problem":55,"user":"4e5ecd65535d8a8b8723a2d6"},{"code":"(fn [s]\n  (reduce\n    (fn [m x]\n      (update-in m [x] (fnil inc 0)))\n    {}\n    s))","problem":55,"user":"4f2b0951e4b0d6649770a045"},{"problem":55,"code":"(fn [s]\n  (let [g (group-by identity s)]\n    (zipmap (keys g) (map count (vals g)))))","user":"54bc539be4b0ed20f4ff6eca"},{"problem":55,"code":"(fn [x] (loop [x x m (hash-map)]\n          (if (empty? x)\n            m\n            (recur (rest x) (assoc m (first x) (inc (get m (first x) 0)))))))","user":"5bdf651ee4b0ed4b8aab4c6d"},{"problem":55,"code":"reduce #(conj %1 {%2 (inc (or (get %1 %2) 0))}) {}","user":"596f6683e4b069c0a1a19877"},{"problem":55,"code":"#(reduce \n   (fn [counts x]\n     (assoc counts x (inc (get counts x 0))))\n     {} %)","user":"55c77070e4b0e31453f649d0"},{"code":"(fn occ [s] \n    (apply (partial merge-with +) (reduce (fn [x y]\n      (conj x {y 1} )\n\n   ) [] s)) \n\n)","problem":55,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":55,"code":"(fn [v] \n  (apply merge \n         (map (fn [a] {a (count (filter #(= a %) v))}) \n              (distinct v))))","user":"4f0f01c0535d0136e6c22329"},{"problem":55,"code":"(fn [sqn]\n   (reduce (partial merge-with +) (for [e sqn] {e 1})))","user":"5cf895efe4b0b71b1d808a85"},{"problem":55,"code":"(fn [v]\n  (loop [in v\n         out {}]\n    (if (empty? in)\n      out\n      (let [t (first in)]\n        (recur (rest in) (into out (if (contains? out t) {t (+ 1 (get out t))} {t 1})))))));","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":55,"code":"(fn [coll]\n  (into {} (map (fn [[a b]] [a (count b)])\n                (group-by identity coll))))","user":"5148bcbee4b05514c84b7cc6"},{"code":"(fn [coll]\n  (zipmap \n    (keys (group-by identity coll))\n    (map count (vals (group-by identity coll)))))","problem":55,"user":"52c672e2e4b0c2d177d6210e"},{"code":"(fn count-occur                                                                                                                                             \n  [coll]                                                                                                                                                      \n  (->> coll                                                                                                                                                   \n       (group-by identity)                                                                                                                                    \n       (mapcat (juxt first (comp count second)))                                                                                                              \n       (apply hash-map)))","problem":55,"user":"4e3bcccd535deb9a81d77f56"},{"problem":55,"code":"(fn [s]\n  (let [distincts (distinct s)\n        occurencies (for [elem distincts]\n                       (count\n                             (filter #(= elem %) s)))]\n    (zipmap distincts occurencies)))","user":"55aaa36fe4b0988bba2ad94f"},{"problem":55,"code":"(fn count-occ [s]\n  \n  (reduce \n    (fn [res cur] \n            \n      (if (contains? res cur)\n\n        (assoc res cur (inc (get res cur)))\n        (assoc res cur 1)\n\n        ) ; if end\n            \n      ) ; fn end\n   ; reduce arg\n  {}\n  s   \n          \n ) ; reduce end\n  \n \n) ; count-occ end","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn [x]\n  (apply conj {} (map #(vector (first %) (count (second %))) (group-by identity x))))","problem":55,"user":"52084f75e4b01ce6bbf31dde"},{"code":"(fn [s]\n   (let [d (distinct s)]\n     (zipmap d (map #(count (filter (partial = %) s)) d))))","problem":55,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":55,"code":"reduce (fn [acc el] \n       (if (contains? acc el)\n        (assoc acc el (inc (acc el)))\n        (assoc acc el 1)\n        )) \n  {}","user":"5df75fd8e4b0a607a9a45c92"},{"problem":55,"code":"(fn [cl] (into {} (map #(hash-map (first %) (count %)) (vals (group-by identity cl)))))","user":"564b1ff8e4b0284900eef663"},{"problem":55,"code":"(fn count-ocur \n  ([lis] (count-ocur (sort lis) {}))\n  ([lis resp]\n   (if (= lis [])\n     resp\n     (if (contains? resp (first lis))\n       (count-ocur (rest lis) (assoc resp (first lis) (inc (resp (first lis)))))\n        (count-ocur (rest lis) (assoc resp (first lis) 1))))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [s]\n  (reduce (fn [acc, el] (assoc acc el (+ 1 (or (get acc el) 0)))) {} s))","problem":55,"user":"51607eb0e4b009fba0926e27"},{"problem":55,"code":"(fn [c]\n  (reduce \n   #(assoc % (key %2) (count (val %2))) \n   {} \n   (group-by identity c)))","user":"56e2dbf4e4b03a7c14b85a3b"},{"code":"(fn [coll]\r\n  (loop [result {}, old coll]\r\n    (let [f (first old)]\r\n    (if (empty? old)\r\n      result\r\n      (recur (assoc result f\r\n        (if (contains? result f)\r\n          (inc (get result f))\r\n          1)\r\n ) (rest old))\r\n  ))))","problem":55,"user":"4df407c3535d08e6dec9fe2e"},{"problem":55,"code":"(fn [s]\n  (reduce #(update-in %1 [%2]\n                      (fn [x] (inc (or x 0))))\n          {}\n          s))","user":"565f8fd2e4b068f2fe63dc41"},{"code":"(fn freq [xs] (let [grouped (group-by identity xs)]\n                     (merge-with #(count %2) grouped grouped)\n         \t\t)\n)","problem":55,"user":"52bf8e35e4b07a9af579233a"},{"problem":55,"code":"(fn occurence-count [coll]\n  (reduce\n    (fn [cons-coll current]\n      (if (contains? cons-coll current)\n        (update-in cons-coll [current] inc)\n        (assoc cons-coll current 1)))\n    {}\n    coll))","user":"53d40508e4b00fb29b221332"},{"code":"(fn [s]\n  (reduce (fn [a e]\n    (if (contains? a e)\n(update-in a [e] inc)\n(assoc-in a [e] 1))) {} s))","problem":55,"user":"4ed2b168535d44c135fd68dd"},{"code":"#(reduce \n  (fn [newmap val] \n    (assoc newmap (first val) (count (second val)))\n  )\n  {}\n  (group-by identity %))","problem":55,"user":"4f039a8b535dcb61093f6b36"},{"code":"(fn [c]  (into {} (map #(into {(first %) (count (second %))} {}) (group-by identity c))))","problem":55,"user":"504f44cfe4b0a02f9cffde65"},{"problem":55,"code":"#(apply merge-with + (map hash-map % (repeat 1)))","user":"55ed9108e4b0121d4835fddc"},{"problem":55,"code":"(fn get-occurences [sequence]\n  (letfn [(inc-occur [map key]\n            (if (nil? (get map key))\n              (assoc map key 1)\n              (update-in map [key] inc)))]\n    (loop [lookup {}\n           items sequence]\n      (if (empty? items)\n        lookup\n        (recur (inc-occur lookup (first items)) (rest items))))))","user":"5e2f3be2e4b05b4b01516200"},{"problem":55,"code":";(fn count-occur [coll]\n;  (->> coll\n;    (group-by identity)\n;    (reduce-kv #(assoc %1 %2 (count %3)) {})))\n#(apply merge-with + (for [_ %] {_ 1}))","user":"581b19e7e4b04b46fc4b0ec4"},{"code":"(fn count-o\n  [s]\n  (->>\n    s\n    (group-by identity)\n    vals\n    (map (fn [v]\n           [(first v) (count v)]))\n    (into {})))","problem":55,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":55,"code":"(fn  [col]\n  (apply hash-map (apply concat (for [[k v] (group-by #(identity %) col)]\n                    [k (count v)]))))","user":"53664e3be4b0243289761e74"},{"problem":55,"code":"(fn count-occurrences [xs]\n  (->> xs\n       (group-by identity)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn [l]    (zipmap (distinct l)  (map  #( count (filter (fn [x] (= x %) ) l)  ) (distinct l)))    )","problem":55,"user":"4f4be1cae4b03ad3f0c10c81"},{"problem":55,"code":"(fn [cv] (->> cv (group-by identity) (map (fn [c] [(first c) (count (second c))]))\n         (into {}) ))","user":"55adf4d7e4b03311e7b732af"},{"problem":55,"code":"(fn [c]\n  (loop [r {}\n         d c]\n    (if (empty? d)\n      r\n      (recur (let [f (first d)\n                   n (get r f)]\n               (assoc r f (if (nil? n) 1 (inc n))))\n             (rest d)))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n       sort\n       (partition-by identity)\n       (map (fn [e] {(first e) (count e)}))\n       (apply merge)))","user":"5b60e88be4b0c6492753e70b"},{"problem":55,"code":"(fn [x]\n  (loop [s (set x)\n        r {}]\n    (if (empty? s)\n      r\n      (recur (rest s)(assoc r (first s)(count (for [t x :when(= t (first s))] t)))))))","user":"566d71b1e4b0a866af6896ca"},{"problem":55,"code":"(fn count-occur\n  [l]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity l))))","user":"551afdf8e4b07993ea3788cb"},{"problem":55,"code":"(fn [c]\n  (reduce #(assoc % %2 (inc (get % %2 0)))\n          {}\n          c))","user":"557c6ca6e4b05c286339e0c4"},{"problem":55,"code":"(fn [s]\n  (into {} (map (fn [[key val]] [key (count val)]) (group-by identity s))))","user":"55be464ce4b01b9910ae2a07"},{"code":"(partial reduce #(update-in % [%2] (fnil inc 0)) {})","problem":55,"user":"4e9660ec535dbda64a6f6b44"},{"problem":55,"code":"#(->> %\n       (group-by identity)\n       (map (fn [[k v]] {k (count v)}))\n       (apply merge))","user":"5a67cedbe4b0512ff01cd9ee"},{"problem":55,"code":"(fn [lst]\n      (reduce (fn [mapa item]\n                (assoc mapa item (if (contains? mapa item) (inc (mapa item)) 1))\n                ) {} lst)\n      )","user":"5d960059e4b0d3f9b434ad31"},{"problem":55,"code":"(fn [xs]\n  (loop [my-map {}\n         my-xs xs]\n    (if (seq my-xs)\n      (let [key (first my-xs)]\n        (recur (conj my-map {key (inc (my-map key 0))}) (rest my-xs)))\n      my-map)))","user":"540d7dd1e4b0addc1aec6713"},{"code":"(fn [x]\n  (apply hash-map (mapcat #(list (first %) (count %)) (vals (group-by identity x)))))","problem":55,"user":"53468f6ce4b084c2834f4a3f"},{"code":"(fn my-frequencies [coll]\n  (->> coll\n       (group-by identity)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","problem":55,"user":"5264301fe4b03e8d9a4a70ca"},{"problem":55,"code":"#(apply hash-map (mapcat identity (let [ls (group-by count (partition-by identity\n               (sort %1)))]\n   (for [x (keys ls), y (ls x) ] \n     (vector (first y) x)))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":55,"code":"(fn [x]\n   (let [y (group-by identity x)\n         z (map #(count (val %)) y)]\n     (zipmap (keys y) z)))","user":"5d5ef0bce4b0c9e5857d4ffb"},{"problem":55,"code":"(fn [coll] (reduce\n #(assoc %1 %2 (inc (get %1 %2 0)))\n   {} coll\n))","user":"5a424954e4b0447ef91cc5f0"},{"problem":55,"code":"(fn [xs]\n(reduce #(assoc %1 %2 (inc (%1 %2 0)))\n        {}\n        xs)\n  )","user":"5cadd6a4e4b026601754b87b"},{"problem":55,"code":"(fn [xs]\n  (->> (group-by identity xs)\n       (map (fn [[k v]] {k (count v)}))\n       (apply conj)))","user":"5f5358b7e4b0a0bc16850a77"},{"code":"(fn [sq]\n  (reduce (fn [acc e]\n            (assoc acc e (+ 1 (get acc e 0))))\n          {} sq))","problem":55,"user":"4e8f5eba535d65386fec214c"},{"problem":55,"code":"#(->> %\n (group-by identity)\n (map \n  (fn [[k v]] \n    (vector k (count v))\n  )\n )\n (into {})\n)","user":"5aac468ae4b073f17744256b"},{"problem":55,"code":"reduce #(if \n          (% %2)\n          (assoc % %2 (inc (% %2)))\n          (assoc % %2 1)) {}","user":"5fa96ddbe4b0fa27300f3dec"},{"code":"(fn [s]\n  (let [m (group-by identity s)]\n    (zipmap (keys m) (map #(count (second %)) m))))","problem":55,"user":"511d6a01e4b022853b0e07a5"},{"code":"(fn my-frequencies [coll]\n    (apply array-map\n           (mapcat (fn [[k v]] [k (count v)])\n                   (group-by identity coll))))","problem":55,"user":"504f57c7e4b0a02f9cffde71"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m v] \n            (assoc m v (inc (get m v 0))))\n          {}\n          s))","user":"55469eede4b0a04f79299542"},{"problem":55,"code":"(fn [v]\n  (->>(partition-by identity (sort v))\n      (reduce #(assoc %1 (first %2) (count %2)) {})))","user":"60a42199e4b00e9e6653c454"},{"code":"(fn [col] \n  (reduce #(conj % [(first %2) (count (second %2))]) {} (vec (group-by identity col))))","problem":55,"user":"50435689e4b034ff00315d21"},{"problem":55,"code":"(fn count-occurences\n  [coll]\n  (let [sorted-coll\n        (->> (sort coll)\n             (partition-by identity)\n             (map vec)\n             (vec))\n        ks (map first sorted-coll)\n        vs (map count sorted-coll)]\n    (zipmap ks vs)))","user":"5f63d933e4b02876ed9fd018"},{"problem":55,"code":"(fn\n  [coll]\n  (reduce (fn [acc v]\n            (update-in acc [v] #((fnil inc 0) %)))\n          {}\n          coll))","user":"4f6d23cde4b07046d9f4efc6"},{"code":"(fn [s]\r\n (into {} (map (juxt key (comp count val)) (group-by identity s))))","problem":55,"user":"4f9b3532e4b0dcca54ed6d13"},{"problem":55,"code":"(fn [xs]\n  (apply hash-map\n         (mapcat\n          (fn [[k v]] [k (count v)])\n          (group-by identity xs))))","user":"555f3bfde4b0a2eb076a39c1"},{"code":"reduce #(assoc % %2 ((fnil inc 0) (% %2))) {}","problem":55,"user":"52479487e4b05ef8e38e6373"},{"problem":55,"code":"#(into {} (for [[x uses] (group-by identity %)] \n            {x (count uses)}))","user":"573118ebe4b0cd1946bd0fbd"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [acc x] \n            (if (contains? acc x) \n              acc \n              (assoc acc x (count (filter #(= x %) xs)))))\n          {} xs))","user":"5d81b40ce4b0915913b1d379"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [freq-map el]\n            (update-in freq-map [el] (fnil inc 0)))\n          {} coll))","user":"556fe0fee4b09a3098a52525"},{"code":"(fn [col]\r\n  (reduce\r\n    (fn [c v]\r\n      (if (get c v)\r\n        (assoc c v (inc (get c v)))\r\n        (assoc c v 1)))\r\n    {}\r\n    col))","problem":55,"user":"4ddee37c535d08e6dec9fddc"},{"problem":55,"code":"#(reduce conj (for [v (vals\n\n                       (group-by identity %)) :let [y {(first v) (count v)}] :while v]  y))","user":"60c9a411e4b0e0fa5f1b4307"},{"code":"#(reduce (fn [m k] (assoc m k (inc (m k 0)))) {} %)","problem":55,"user":"50479524e4b0371827a27bc4"},{"code":"reduce #(assoc % %2(+ (% %2 0) 1)) {}","problem":55,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [s]\n  (reduce \n    #(assoc % (first %2) (count (second %2))) {}\n    (group-by identity s)))","problem":55,"user":"4f0446f9535dcb61093f6bb8"},{"problem":55,"code":"(fn [xs]\n  (loop [[l & ls :as all] xs acc {}]\n    (if (nil? all) acc\n      \t(recur ls (merge-with + acc {l 1})))))","user":"5e7f075ee4b085ba37836e36"},{"problem":55,"code":"(fn [coll] (into {}\n                      (map\n                       (fn [a] [ (first a) (count (second a))])\n                       (group-by identity coll))))","user":"564a560ae4b0284900eef654"},{"problem":55,"code":"(fn fqs [s]\n  (->> s\n       (map (fn [x] {x 1}))\n       (apply merge-with +)))","user":"597a4277e4b02382a38ad1e2"},{"problem":55,"code":"(fn [s]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity s)))","user":"58a5a099e4b01a0c0b232918"},{"code":"(fn [coll] \n  (reduce #(update-in %1 [%2] (fnil inc 0))\n          {} coll))","problem":55,"user":"52976262e4b02ebb4ef75041"},{"problem":55,"code":"(fn count-freq\n  [coll]\n  (->> coll\n       (group-by identity)\n       (map (fn [ent]\n              (vector (first ent) (count (second ent)))))\n       (into {})\n       ))","user":"590b3aeae4b047aa04b199d0"},{"problem":55,"code":"(fn\n  [values]\n  (into {} (for [[k v] (group-by identity values)] [k (count v)])))","user":"5ed65b59e4b016b56eae05df"},{"code":"(fn my-count-occ [x]\n  (let [update #(if (nil? %) 1 (inc %))]\n    (loop [todo x\n           ret {}]\n    (if (empty? todo)\n      ret\n      (recur (rest todo) (update-in ret (list (first todo)) update))))))","problem":55,"user":"4f08a8a2535dcb61093f6c3d"},{"code":"(fn f [coll] (into {} (for [[k v] (group-by identity coll)] [k (count v)])))","problem":55,"user":"509fe759e4b08df8156e9e43"},{"code":"(fn [x] (loop [s (->> x\n\t\t\t\t\t(sort)\n             \t\t(partition-by identity))\n               M (hash-map)]\n               \t(if (empty? s) M\n                  (recur (rest s) (assoc M (first (first s)) (count (first s)))))))","problem":55,"user":"51cf126ae4b0e42293a2256b"},{"code":"reduce #(update-in % [%2] (fnil inc 0)) {}","problem":55,"user":"4f4319ebe4b0d7d3c9f3fd13"},{"code":"(fn [c] (into {}(map #(vector (first %) (count (last %))) (group-by identity c))))","problem":55,"user":"52394c03e4b0d705d026ef09"},{"code":"(fn [coll] (reduce #(update-in %1 [%2] (fnil inc 0)) {} coll))","problem":55,"user":"50310b8be4b05b7df5a0b84d"},{"problem":55,"code":"#(let [s (partition-by identity (sort %))]\n  (zipmap (map first s) (map count s)))","user":"5405ae2be4b0addc1aec6671"},{"problem":55,"code":"(fn occurrence-count [coll]\n\t(->> (group-by identity coll)\n\t\t (reduce (fn [result [k v]]\n\t\t\t\t\t (conj result [k (count v)]))\n\t\t\t\t {})))","user":"552bd5c2e4b0ffed3738f969"},{"problem":55,"code":"(fn freqs [coll] (reduce #(merge-with + %1 {%2 1}) {} coll))","user":"5ed9b912e4b0c7845d86b0e3"},{"code":"(fn [s]\n  (reduce (partial apply assoc) {}\n    (for [ [k vs] (group-by identity s) ] \n      [k (count vs)])))","problem":55,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn [l] (reduce \n  (fn [acc v] \n    (if (nil? (get acc v)) \n      (assoc acc v 1) \n      (assoc acc v (+ 1 (get acc v))))) {} l))","problem":55,"user":"4e9d6a65535dbda64a6f6b87"},{"code":"#(reduce-kv (fn [map k v] (assoc map k (count v)))\n                   {} (group-by identity %))","problem":55,"user":"5256c4c1e4b0541d1855ba36"},{"problem":55,"code":"(fn [arr]\n\n  (->> arr\n       (sort)\n       (partition-by identity)\n       (map #(vector (first %) (count %)))\n       (into {})\n       )\n\n\n  )","user":"5dd1fb19e4b0948ae9d9ad51"},{"problem":55,"code":"(fn function [coll]\n  (persistent! \n    (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","user":"5f5f2eafe4b02876ed9fcff5"},{"problem":55,"code":"(fn [col]\n  (reduce (fn [m k]\n            (let [c (get m k)]\n              (assoc m k (if c (inc c) 1))\n              )\n            )\n    (cons {} col)))","user":"53b530c6e4b047364c0444bc"},{"problem":55,"code":"(fn [xs] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity xs)))","user":"4f259f95e4b0d66497709ffa"},{"code":"#(let [\n        x %\n        gr (group-by identity x)\n        keyses (map first gr)\n        ocncs (map (fn [n] (count (second n))) gr)\n        inl (interleave keyses ocncs)\n        mapsis (apply hash-map inl)\n        ]\n    mapsis)","problem":55,"user":"4ffe8193e4b0678c553fc3f4"},{"problem":55,"code":"#(->> %\n  (group-by identity)\n  (map (fn [[k v]] [k (count v)]))\n  (into {}))","user":"5ba15075e4b0a20761a2339e"},{"problem":55,"code":"(fn [sq]\n  (reduce\n    (fn [acc v]\n      (let [cnt (acc v)]\n      (assoc acc v (if (nil? cnt) 1 (inc cnt)))))\n    {}\n    sq))","user":"588e4e05e4b00487982d5188"},{"problem":55,"code":"(fn [coll]\n      (letfn [(add-count [counter-map item]\n                (let [current (get counter-map item 0)\n                      new-val (inc current)]\n                  (assoc counter-map item new-val)))]\n        (reduce add-count {} coll)))","user":"5515b138e4b055c2f668d4ed"},{"code":"#(apply hash-map\n        (mapcat (fn [a] (list (peek a) (count a)))\n                (vals (group-by identity %))))","problem":55,"user":"50ba4b9ee4b03e68e4411c7b"},{"problem":55,"code":"(fn count_occur [s]\n  (loop [res [] s_s (sort s)]\n    (if (> (count s_s) 0)\n      (let [n1 (first s_s) count_n1 (count (take-while #(= % n1) s_s))]\n        (recur (conj res n1 count_n1) (drop count_n1 s_s))\n        )\n      (apply hash-map res)\n      )\n    )\n  )","user":"5c52f3fce4b0fb8c5ffd99e9"},{"problem":55,"code":"#(zipmap (distinct %) (map count (vals (group-by str %))))","user":"52c08c59e4b07a9af5792351"},{"code":"(comp #(zipmap (keys %) (map count (vals %))) (partial group-by identity))","problem":55,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn [coll]\n  (loop [indices (distinct coll) result {}]\n    (if (empty? indices)\n      result\n      (recur (rest indices) (assoc result (first indices) (count (filter #{(first indices)} coll)) )))))","problem":55,"user":"51eec1a6e4b0871fa145d98d"},{"problem":55,"code":"(fn [xs]\n  (reduce #(if-let [val (get %1 %2)] (assoc %1 %2 (inc val)) (assoc %1 %2 1)) {} xs))","user":"5545eebee4b0a04f79299539"},{"problem":55,"code":"(fn a[sq] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} sq))","user":"5fe09d1fe4b05ac5b16ea15b"},{"code":"(fn [col] (into {} (map #(into {} {(first (last %)) (count (last %))} )  \n(group-by identity col))))","problem":55,"user":"53286389e4b09d4e7a9b5504"},{"code":"(fn [xs] (reduce #(update-in %1 [%2] (fnil inc 0)) {} xs))","problem":55,"user":"4faa6184e4b081705acca1f1"},{"problem":55,"code":"#(into {} (map (fn [[k v]] {k (count v)}) (group-by identity (sort %))))","user":"53571732e4b04ce2eb3ed275"},{"problem":55,"code":"(fn [c] (apply (partial merge-with +) (map #(hash-map % 1) c)))","user":"543b4746e4b032a45b86932c"},{"problem":55,"code":"(comp (partial into {}) (partial map #(vector (first %) (count (second %)))) (partial group-by identity))","user":"54cbe00ee4b057c6fda3a285"},{"problem":55,"code":"#(reduce merge (map (fn [[k v]] {k (count v)}) (group-by identity %)))","user":"504f9ae1e4b0a02f9cffde9c"},{"problem":55,"code":"#(->> (group-by identity %)\n       (map (fn [[k v]] [k (count v)]))\n       (into {}))","user":"50ccf729e4b0f7a459302aac"},{"code":"#(into {} ( map (fn [[x y]]  (vector x  (count y)))  (group-by identity %)))","problem":55,"user":"4f25c4c4e4b0d66497709ffc"},{"code":"(fn [l]\n    (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} l ))","problem":55,"user":"4ed292ac535d44c135fd68d9"},{"problem":55,"code":"(fn [coll]\n  (into {} (map (fn [[ky vl]] [ky (count vl)]) (group-by identity coll))))","user":"538e864ee4b0b51d73faae87"},{"problem":55,"code":"(fn [v]\n    (reduce (fn [r n] (assoc r n (inc (get r n 0)))) {} v))","user":"554a75c9e4b0a04f79299575"},{"code":"(fn [coll] \n  (apply hash-map (mapcat #(list (key %) (count (val %))) (group-by identity coll))))","problem":55,"user":"5163b06be4b055933a9ca030"},{"problem":55,"code":"reduce (fn [res e]\n         (assoc res e (inc (or (get res e) 0))))\n       {}","user":"60096aabe4b074f607df667f"},{"code":"#(into {} (map (fn [[k v]] [k (count v)]) \n               (group-by identity %)))","problem":55,"user":"4f8b27b3e4b02e764a0a5179"},{"problem":55,"code":"(fn [x]\n    (into {} (for [[k v] (group-by identity x)] [k (count v)])))","user":"4e837808535db62dc21a62d9"},{"code":"#(apply merge-with + (map (fn [c] {c 1}) %))","problem":55,"user":"4de8a7d7535d08e6dec9fdfe"},{"code":"(fn [s]\n  (->> (map #(hash-map % 1) s)\n       (apply merge-with +)))","problem":55,"user":"536f871de4b0fc7073fd6e7f"},{"problem":55,"code":"(fn [coll]\n   (apply merge (for [i (distinct coll)]\n                  {i (count (filter #(= i %) coll))})))","user":"55f8b32ae4b03cbcff9738ba"},{"code":"(fn [c]\n  (let [g (vals (group-by identity c))]\n    (zipmap (map first g) (map count g))))","problem":55,"user":"53597288e4b04ce2eb3ed29c"},{"problem":55,"code":"(fn [l] (reduce #(if (nil? (%1 %2))\n                   (assoc %1 %2 1)\n                   (assoc %1 %2 (inc (%1 %2)))) {} l))","user":"53a0ab8ce4b0ca733b9744b3"},{"code":"(fn [coll]\n  (let [counts (group-by identity coll)\n        counts-vec (map #(vector (first %) (count (second %))) counts)]\n    (into {} counts-vec)))","problem":55,"user":"51e38568e4b0c611d6113e43"},{"code":"(fn [s]\n          (let [g (group-by identity s)\n                n (map #(count (val %)) g)\n                k (keys g)]\n                (zipmap k n)))","problem":55,"user":"4f03f197535dcb61093f6b84"},{"code":"#(reduce \n  (fn [a [k v]] \n    (assoc a k (count v))) {}\n  (group-by identity %))","problem":55,"user":"51b3f109e4b0f094dd986fa9"},{"problem":55,"code":"(fn [s]\n    (reduce\n     (fn [prev e]\n       (update-in prev [e] #(inc (or % 0))))\n     {} s))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":55,"code":"(fn [s] (apply hash-map (apply concat (for [k (set s)] [k (count (filter #(= k %) s))]))))","user":"55b0f5bfe4b002ce9d5cbc28"},{"problem":55,"code":"#(reduce (fn [x y] \n           (assoc x y (inc (x y 0)))) \n         {} %)","user":"539f4e9ee4b0ca733b974498"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [new-map item]\n            (if (new-map item)\n              (update-in new-map [item] inc)\n              (assoc new-map item 1))) \n          {}\n          coll))","user":"5c58736be4b01df32ab73247"},{"code":"(fn [xs] (reduce #(assoc %1 %2 (+ (get %1 %2 0) 1)) {} xs))","problem":55,"user":"4f0e995e535d0136e6c22326"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (->> (group-by identity coll)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"5d6f063de4b04d129b00f2d1"},{"code":"#(let [m (group-by (fn [x] x) %)]\n  (zipmap (keys m) (map count (vals m))))","problem":55,"user":"4e2b1d48535deb9a81d77f03"},{"code":"(comp\n  (partial apply hash-map)\n  (partial mapcat (juxt first (comp count second)))\n  (partial group-by identity))","problem":55,"user":"4fb1325de4b081705acca276"},{"problem":55,"code":"(fn [s]\n  (loop [z s ret {}]\n   (cond (empty? z)\n   ret\n   :t\n   (recur (rest z)(assoc ret (first z)((fnil inc 0)(get ret (first z))))))))","user":"52faf67ce4b047fd55837005"},{"problem":55,"code":"(fn [coll]\n  (loop [acc {} rem coll]\n    (if (nil? (seq rem)) \n      acc\n      (if (contains? acc (first rem))\n        (recur (assoc acc (first rem) (inc (get acc (first rem))))\n               (rest rem))\n        (recur (assoc acc (first rem) 1) (rest rem))))))","user":"5d126728e4b02c15ef02199a"},{"problem":55,"code":"(fn [xs] (reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} xs))","user":"5782018de4b0d36ec5835e8e"},{"problem":55,"code":"(fn [coll]\n    (reduce\n      (fn [m elem]\n        (if (contains? m elem)\n          (assoc m elem (inc (m elem)))\n          (assoc m elem 1)))\n      {}\n      coll))","user":"5b67f0fbe4b0c6492753e76d"},{"code":"(fn [xs] (let [ds (distinct xs)] (into {} (map (fn [d] [d (count (filter #(= d %) xs))]) ds))))","problem":55,"user":"50f2e5cee4b0ec8ee6fa8643"},{"problem":55,"code":"(fn __\n  [coll]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity coll)))","user":"5b73e500e4b047b03b2036ba"},{"problem":55,"code":"reduce #(assoc % %2 (inc (get % %2 0)) ) {}","user":"5382704be4b06839e8705ed4"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [acc x] (update-in acc [x] #(if % (inc %) 1)))  {} s))","user":"57cd7498e4b0c746388ab897"},{"code":"(fn __ [v]\n  (into {} (for [[x y] (group-by identity v)]\n             [x (count y)])))","problem":55,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(fn [lst]\n  (reduce (fn [memo new-val]\n            (let [old-count (if (memo new-val) (memo new-val) 0)\n                  new-count (+ old-count 1)]\n              (merge memo {new-val new-count}))) {} lst))","problem":55,"user":"51c76864e4b07ef393169e3f"},{"problem":55,"code":"(fn [l] (into {} (for [[k v] (group-by (fn [x] x) l)] [k (count v)])))","user":"5d3ae729e4b01671435dbd5d"},{"problem":55,"code":"(fn \n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","user":"56504dc2e4b0284900eef6bc"},{"problem":55,"code":"(fn [s]\n    (let [gs (group-by identity s)]\n      (apply hash-map (interleave (keys gs) (map count (vals gs))))))","user":"5c165d3ee4b01240ff5671d1"},{"problem":55,"code":"#(loop [smp % freq {}]\n  (if (seq smp)\n    (let [[cur & rest] smp]\n      (if (contains? freq cur)\n        (recur\n         rest\n         (update-in freq [cur] inc))\n        (recur\n         rest\n         (assoc-in freq [cur] 1))))\n   freq))","user":"574eb3b1e4b02ea114799247"},{"problem":55,"code":"(fn [col] (->> col\n  (group-by identity)\n  (map #(vector (first %) (count (second %))))\n  (into {})))","user":"53c38b8ce4b00fb29b22127b"},{"problem":55,"code":"(fn [c]\n   (loop [m {} [x & xs] c]\n     (if x (recur (assoc m x (inc (if-let [p (get m x)] p 0))) xs)\n         m)))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [c] (let [g (group-by (fn [x] x) c)]  (apply hash-map (interleave (keys g) (map #(count %) (vals g))))))","problem":55,"user":"4ea7999e535d7eef308072ee"},{"problem":55,"code":"(fn [items]\n  (loop [sq items acc {}]\n    (if (empty? sq)\n      acc\n      (recur (rest sq) (assoc acc (first sq) (inc (acc (first sq) 0)))))))","user":"60b2aaebe4b0e0fa5f1b4228"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [freq elem]\n              (if (nil? (freq elem))\n                (assoc freq elem 1)\n                (update-in freq [elem] inc)))\n            {}\n            coll))","user":"5a0ef454e4b04bbd27e6d9fa"},{"problem":55,"code":"(fn\n  [s]\n  (reduce #(assoc % (first %2) (count (second %2))) {} (group-by identity s)))","user":"56bb652ae4b0f26550335953"},{"problem":55,"code":"(fn [col] (apply merge-with + (map #(hash-map % 1) col)))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":55,"code":"(fn occurrences\n    [s]\n    (reduce-kv (fn [m k v]\n                 (assoc m k (count v)))\n               {}\n               (group-by identity s)))","user":"552d487ee4b076ab5578f7e4"},{"problem":55,"code":"#(reduce (fn [a b] (assoc a b (if (contains? a b) (inc (a b)) 1))) {} %)","user":"591f05b4e4b09b4ee5954c42"},{"problem":55,"code":"(comp #(into {} (for [[k v] %] [k (count v)]))      \n      (partial group-by identity))","user":"5591cc56e4b0604b3f94d582"},{"problem":55,"code":"(fn [coll]\n(reduce (fn [m c] (assoc m (first c) (count c))) {} (partition-by identity (sort coll))))","user":"565b941ce4b068f2fe63dc07"},{"code":"(fn occs [coll]\n  (reduce (fn [m x]\n            (update-in m [x] (fnil inc 0)))\n         {}\n         coll))","problem":55,"user":"4f6bab49e4b07046d9f4efb1"},{"code":"(fn [col]\n(reduce #(assoc % (key %2) (count (val %2)))  {} (group-by identity col)))","problem":55,"user":"51696bcde4b03f62cda68ce7"},{"code":"(fn [l]\n    (let [m1 (#(group-by identity %) l)]\n        (zipmap (keys m1) (map count (vals m1)))\n    )\n)","problem":55,"user":"4fbdcb87e4b081705acca30a"},{"problem":55,"code":"(fn [myCol] (reduce (fn [myMap item] (conj myMap [item (let [value (myMap item)] (if (nil? value) 1 (inc value)))])) {} myCol))","user":"58950f29e4b00487982d5270"},{"problem":55,"code":"#(let [i (group-by identity %)]\n    (loop [l (keys i), acc {}]\n      (if-let [h (first l)]\n        (recur (rest l) (conj acc [h (count (i h))]))\n        acc\n        )))","user":"57035ccfe4b08d47c97781ef"},{"problem":55,"code":"(fn [s]\n        (->> s\n             (group-by identity)\n             (map (fn [[k v]] [k (count v)]))\n             (into {})))","user":"546c4377e4b00cfc9eacc177"},{"problem":55,"code":"(fn [xs]\n  \"bare of container functions\"\n  (loop [cur (first xs)\n         xs (rest xs)\n         acc {}]\n    (if (nil? cur)\n      acc\n      (if (contains? acc cur)\n        (recur (first xs) (rest xs) (assoc acc cur (inc (get acc cur))))\n        (recur (first xs) (rest xs) (assoc acc cur 1))))))","user":"5993eeefe4b0b211ea3aaabc"},{"code":"#(let [m (group-by identity %)] (zipmap (keys m) (map count (vals m))))","problem":55,"user":"4fb65f2fe4b081705acca2c7"},{"code":"(fn occ[x]\r\n  (let [m {} o (group-by (set x) x) ]\r\n    (zipmap (keys o) (map (fn[a]  (count a)) (vals o)))\r\n    )\r\n  )","problem":55,"user":"4e9def6b535dbda64a6f6b8f"},{"code":"#(apply merge-with + (for [n %] {n 1}))","problem":55,"user":"4f8345c6e4b033992c121c1b"},{"problem":55,"code":"(fn [sq]\n          (->> sq\n               (group-by (set sq))\n               (map #(let [[k v] %]\n                       (hash-map k (count v))))\n               (into {})))","user":"5c995fa4e4b048ec896c5a96"},{"code":"#(let [m (group-by identity %)]\n  (into {} (for [[k v] m] [k, (count v)])))","problem":55,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn count-occur [coll]\n  (->> (group-by identity coll)\n       (reduce #(let [v (val %2)]\n                  (conj %1 (vector (first v) (count v)))) {})))","problem":55,"user":"52ab6de1e4b0c58976d9ac78"},{"problem":55,"code":"(fn my-freq [x] (let [prt (partition-by identity (sort x))]\n                    (zipmap (map first prt) (map count prt))))","user":"6076adb2e4b069485764de60"},{"code":"reduce #(assoc %1 %2 (inc (%1 %2 0))) {}","problem":55,"user":"4eca7a87535d6d7199dd3705"},{"code":"(fn [col]\n\t(into {} \n       (for [k (distinct col)] \n         {k (count (filter #(= % k) col))}) )\n)","problem":55,"user":"5201ff99e4b0b2e020a18f26"},{"problem":55,"code":"(let\n  [add (fn [m v] (assoc m v (if (contains? m v) (inc (m v)) 1)))]\n  #(reduce add {} %))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn counter [s]\n  (reduce (fn updater\n            ([m v] (conj m {v (inc (if (nil? (m v))\n                                     0\n                                     (m v)))})))\n            {} s))","problem":55,"user":"4f0ef874535d0136e6c22328"},{"code":"(fn freq [x]\r\n  (let [y (group-by identity x)]\r\n    (zipmap (keys y) (map count (vals y)))))","problem":55,"user":"4ef0f1a1535dced4c769f212"},{"problem":55,"code":"#(into {} (map (fn [[a b]] {a (count b)}) (group-by identity %)))","user":"599342efe4b0b211ea3aaab0"},{"problem":55,"code":"(fn [xs] (reduce (fn [acc x] (assoc acc x (inc (get acc x 0)))) {} xs))","user":"53161a56e4b08068f379ed3e"},{"problem":55,"code":"#(apply hash-map (mapcat\n      (fn [[k v]] [k (count v)]) \n      (group-by identity %)))","user":"5976da27e4b01722bebd4ce3"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [[x coll]] [x (count coll)]) (group-by identity %)))","user":"53f2370ee4b0742d9025b0e7"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [acc nextThing] \n            (if (nil? (acc nextThing))\n              (assoc acc nextThing 1)\n              (assoc acc nextThing (+ (acc nextThing) 1))\n            )) {} s)\n)","user":"58669dd0e4b0f14aab7c8867"},{"problem":55,"code":"reduce #(conj % { %2 (inc (get % %2 0)) } ) {}","user":"55d3cfafe4b0e31453f64a6c"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (reduce\n    (fn [result-map el]\n      (assoc result-map el (count (filter #(= % el) coll))))\n    {}\n    coll))","user":"55b28b57e4b01b9910ae296c"},{"code":"(fn [xs]\n  (into {}\n        (for [[k v] (group-by identity xs)]\n          [k (count v)])))","problem":55,"user":"50fbf811e4b0d10d794c19f1"},{"problem":55,"code":"(fn [x] (->> x (group-by identity) (reduce-kv #(assoc %1 %2 (count %3)) {})))","user":"5ad002f2e4b0ea6055cfab87"},{"problem":55,"code":"(fn [coll]\n  (let [uniqs (set coll)]\n    (into {}\n          (for [x uniqs\n                :let [n (count (filter #(= x %) coll))]]\n            {x n}))))","user":"5af36d78e4b0cc2b61a3bc86"},{"problem":55,"code":"(fn [s] (reduce \n         #(assoc %1 (first %2) (count %2)) \n                {} (partition-by identity (sort s) )))","user":"558bdcefe4b0277789237633"},{"problem":55,"code":"(fn [coll]\n  (let [s (set coll)]\n    (into {} (map (fn [i]\n                    (hash-map i (count (filter #(= % i) coll)))) s))))","user":"576a972ce4b0a07e8fc1811a"},{"problem":55,"code":"(fn [s]\n  (loop [in s out {}]\n    (if (empty? in)\n      out\n      (let [key (first in)\n            counter (out key)\n            new-val (if (not (nil? counter)) (inc counter) 1)\n            ]\n      (recur (rest in) (assoc out key new-val))))))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"#(into {} \n  (map \n    (fn [[k v]] [k (count v)]) \n      (group-by identity %)))","problem":55,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [seqn]\n  (loop [seqn seqn\n         cnts {}]\n    (if (empty? seqn)\n      cnts\n      (let [x (first seqn)]\n        (recur (rest seqn) (assoc cnts x (inc (get cnts x 0))))))))","problem":55,"user":"53889587e4b0640c7a9a589e"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [acc it]\n            (assoc acc it (+ (acc it 0) 1)))\n          {} s))","user":"561ba3e5e4b073c65b0ce3eb"},{"problem":55,"code":"(fn countOcur [lst]\n  (into {} (map #(vector (first %) (count %)) (partition-by identity (sort lst)))))","user":"57fc34f0e4b0d3187e90098e"},{"problem":55,"code":"(fn [x] (reduce #(conj %1 [%2 (inc (get %1 %2 0))]) {} x))","user":"5a012a43e4b01bb0ae8afd42"},{"code":"(fn [coll]\n  (apply merge\n    (map #(hash-map (first %) (count %))\n      (partition-by identity (sort coll)))))","problem":55,"user":"4f92884de4b0dcca54ed6caf"},{"problem":55,"code":"(fn [x]\n  (reduce \n   (fn [y z] (assoc y z (if (y z) (+ 1 (y z)) 1)))\n   {}\n   x))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":55,"code":"#(reduce-kv\n  (fn [acc key vals]\n    (assoc acc key (count vals))) {} ((fn [cs] (group-by identity cs)) %))","user":"54b42ea4e4b05787c3b1638b"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [memo x] (update-in memo [x] (fnil inc 0))) {} coll))","user":"577bf999e4b0d3393e5deb2c"},{"problem":55,"code":";#(->> (group-by identity %1)\n;      (map (fn [x] [(key x) (count (val x))]))\n;      (into {}))\n\n\n(fn [xs]\n\t(reduce (fn [m x]\n\t\t\t\t(update-in m [x] (fnil inc 0)))\n\t\t\t{}\n\t\t\txs))","user":"55b8c339e4b01b9910ae29b9"},{"code":"#(into {} (map (fn [[k v]] {k (count v)})\n               (group-by identity %)))","problem":55,"user":"50d882d4e4b01f0871336e69"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (reduce\n    (fn [m [k c]] (assoc m k (count c))) \n    {} \n    (group-by identity coll)))","user":"59c94a69e4b0a024fb6ae576"},{"code":"#(into {}\n  (for [[k v] (group-by identity %)]\n    [k (count v)]))","problem":55,"user":"500933a6e4b046cdb195e074"},{"code":"(fn [x]\n  (let [g (group-by identity x)]\n    (zipmap (keys g) (map count (vals g)))))","problem":55,"user":"4e77c1db535d324fb2983d72"},{"code":"#(reduce (fn [m x]\n           (if (contains? m x)\n             (assoc m x (inc (m x)))\n             (assoc m x 1)\n           )) {} %)","problem":55,"user":"529d4f4be4b04e0c58e87b79"},{"code":"#(letfn [(f [[h & t] m] (let [c (get m h 0) n (assoc m h (inc c))] \n                         (if (seq t) (recur t n) n)))] (f % {}))","problem":55,"user":"4ede8789535d10e5ff6f5337"},{"problem":55,"code":"#(\n  reduce\n  (fn [m e]\n    (if (m e)\n      (assoc m e (inc (m e)))\n      (assoc m e 1)))\n  {}\n  %\n  )","user":"5881d1c2e4b0f1effa3b7644"},{"problem":55,"code":"(fn count-occurences [col]\n  (loop [xs col\n         acc {}]\n    (let [n (first xs)]\n      (if (empty? xs)\n        acc\n        (recur (rest xs) (assoc acc n (inc (get acc n 0))))))))","user":"544257b4e4b032a45b869379"},{"code":"#(reduce \n   (fn [freqs elem]\n     (merge-with + freqs {elem 1}))\n   {}\n   %)","problem":55,"user":"51a768e0e4b0da5f497bde84"},{"problem":55,"code":"#(loop [[x & xs :as L] %, result {}]\n   (if (empty? L )\n     result\n       (recur  xs (assoc result x (inc (result x 0))))))","user":"57015a1de4b08d47c97781d4"},{"problem":55,"code":"#(into {}\n   (map \n    (fn [[k v]] [k (count v)]) \n    (group-by identity %)))","user":"5602bdf9e4b04bb52996e1a7"},{"code":"(fn [col]\n  (loop [col col res {}]\n    (let [el (first col)]\n      (if (seq col)\n        (recur (rest col)\n               (assoc res el (inc (get res el 0))))\n        res))))","problem":55,"user":"539c64cde4b0b51d73faaf2a"},{"problem":55,"code":"(fn foo[x]\n  (apply hash-map \n         (reduce concat \n          (map \n           #(list (first %) (count (second %))) \n           (group-by identity x)))))","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn [coll]\r\n    (reduce #(assoc % (first %2)(count %2)) {} (vals(group-by identity coll))))","problem":55,"user":"4fb23582e4b081705acca28a"},{"code":"reduce (fn [m k] (update-in m [k] #(inc (or % 0)))) {}","problem":55,"user":"4fe9de74e4b0547ebccb2475"},{"problem":55,"code":"#(reduce\n  (fn [m v] (assoc m v (if (get m v) (inc (get m v)) 1))) {} %)","user":"55d85ac9e4b0e31453f64ab2"},{"problem":55,"code":"(fn [c]\n       (into {} (map (fn [v] [(key v) (count (val v))]) (group-by identity c))))","user":"551e6526e4b030e6a24d00e8"},{"problem":55,"code":"#(loop [l % r {}]\n   (if (empty? l)\n     r\n     (recur (rest l)\n      (assoc r (first l) (+ 1 (get r (first l) 0)))\n      )\n     ))","user":"594263cbe4b060784b3b790a"},{"problem":55,"code":"#(reduce (fn [m v] (update-in m [v] (fn [x] (if (nil? x) 1 (inc x))))) {} %)","user":"561a1af6e4b053970a773b02"},{"code":"(fn [s] (reduce (fn [m k] (assoc m k (inc (m k 0)))) {} s))","problem":55,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":55,"code":"(fn [coll] (reduce (fn [m n] (assoc m n (inc (or (m n) 0)))) {} coll))","user":"56403765e4b08d4f616f5edc"},{"problem":55,"code":"(fn [col]\n  (into {} (map (fn [[x xs]] [x (count xs)]) (group-by identity col))))","user":"57839ae9e4b0ebec4cfb74b8"},{"code":"(fn mc\n  ([lst] (mc {} (sort lst)))\n  ([m lst]\n   (if (empty? lst) m\n     (let [o (first lst) ls (take-while #(= o %) lst)]\n       (mc (conj m [o (count ls)]) (drop-while #(= o %) lst ))))))","problem":55,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [coll]\n  (loop [items (into #{} coll) \n         result {}]\n    (if (empty? items)\n      (into {} (reverse result))\n      (recur\n       (rest items)\n       (assoc result (first items) (count (filter #{(first items)} coll))))\n      )))","problem":55,"user":"4daedd1eedd6309eace4d164"},{"problem":55,"code":"(fn [coll]\n\n  (reduce (fn [p q]\n            (assoc p q  (+ 1 (if (number? (get p q)) (get p q) 0)))\n            ) (hash-map) coll)\n\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"problem":55,"code":"(fn [coll]\n   (into {} (map #(vector (first %) (count %)) (vals (group-by identity coll)))))","user":"57b19fa1e4b0fbc9809a2754"},{"problem":55,"code":"(fn [xs]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity xs)))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"reduce (fn [m k] (update-in m [k] (fnil inc 0))) {}","problem":55,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":55,"code":";;(fn [xs]\n;;  (reduce\n;;   (fn [reducing-map [k v]]\n;;\t\t(assoc reducing-map k (count v))) {} (group-by identity xs)))\n\n(fn [xs]\n   (into {} (map (fn [[k v]] {k (count v)}) (group-by identity xs))))","user":"603e9cb6e4b0d5df2af22317"},{"problem":55,"code":"#(reduce-kv (fn [m k v] (assoc m k (count v)))\n            {} \n            (group-by identity %))","user":"54236ce1e4b01498b1a71ad1"},{"problem":55,"code":"#(into {}\n       (map (fn [x] [x (count (filter (partial = x) %))])\n            (into #{} %)))","user":"53fb5256e4b0de5c4184857f"},{"problem":55,"code":"(fn tally\n  ([sqn]\n    (tally sqn {}))\n  ([sqn tally-map]\n    (if (empty? sqn)\n      tally-map\n      (let [a (first sqn)]\n        (if (contains? tally-map a)\n          (recur (rest sqn) (update-in tally-map [a] inc))\n          (recur (rest sqn) (assoc-in tally-map [a] 1)))))))","user":"569f99cce4b0542e1f8d1497"},{"problem":55,"code":"(fn [sq] (let [fq (into #{} sq)] (into (sorted-map) (map #( vector % (count (filter (fn[b](= b %)) sq))) fq))))","user":"581a5fdbe4b0e114eb51a002"},{"problem":55,"code":"(fn [x] (into {} (map #(vector (first %) (count %)) (vals (group-by identity x)))))","user":"4ec66e84535d6d7199dd36cd"},{"code":"(fn [coll]\n  (let [grouped (group-by identity coll)\n        counts (map (fn [[k v]] [k (count v)]) grouped)]\n    (into {} counts)))","problem":55,"user":"4f28c979e4b0d6649770a01a"},{"problem":55,"code":"(fn count-occurences [s]\n  (let [grps (group-by (fn [x] x) s)]\n       (->> (map (fn [k v]\n            {k (count v)})\n            (keys grps)\n            (vals grps))\n            (into {}))))","user":"5edfb1e5e4b0c7845d86b107"},{"problem":55,"code":"#(loop [xs %\n        ret {}]\n   (if (seq xs)\n     (let [v (or (get ret (first xs)) 0)]\n       (recur (next xs) (assoc ret (first xs) (inc v))))\n     ret))","user":"51b8d3d5e4b050a1176cd69d"},{"problem":55,"code":"(fn\n  [xs]\n  (let [grouped (group-by identity xs)]\n    (zipmap (keys grouped) (map count (vals grouped)))))","user":"54e0e911e4b024c67c0cf7bc"},{"code":"(fn [coll]\n  (reduce\n    (fn [m x]\n      (if (contains? m x)\n        (assoc m x (inc (m x)))\n        (assoc m x 1))) {} coll))","problem":55,"user":"51d08d67e4b067c365486351"},{"code":"(fn f [coll]\n  (into {} (map \n    (fn [[k v]]\n      [k (count v)])\n    (group-by identity coll))))","problem":55,"user":"51750cd4e4b07031762f2ee5"},{"problem":55,"code":"(fn [coll]\n  (loop [occurrences {}\n         coll coll]\n    (if (empty? coll)\n      occurrences\n      (recur \n        (update-in occurrences [(first coll)] (fnil inc 0))\n        (rest coll)))))","user":"55842c7ee4b05c286339e11d"},{"code":"(fn [s] (reduce #(assoc % %2 (if (% %2) (inc (% %2)) 1)) {} s))","problem":55,"user":"50dfb660e4b061dbdced7228"},{"problem":55,"code":"(fn freq [x]\n  (let [f (fn anon [m s]\n            (if (empty? s) m\n              (let [[n & r] s\n                    c (m n)]\n                (if (nil? c)\n                  (anon (conj m [n 1]) r)\n                  (anon (conj m [n (inc c)]) r)))))]\n   (f {} (into '() x))))","user":"57d1d6c8e4b0bd073c202370"},{"problem":55,"code":"#((fn [m]\n    (zipmap (keys m)\n            (map count (vals m))))\n  (group-by identity %))","user":"568e1871e4b0dcc4269f40cc"},{"code":"(fn __ [col]\n  (let [grouped (group-by identity col)]\n    (zipmap (keys grouped) (map count (vals grouped)))))","problem":55,"user":"4fa719c0e4b081705acca1bf"},{"problem":55,"code":"reduce (fn [accum v] (assoc accum v (inc (accum v 0)))) {}","user":"5f838122e4b01aacbe7a2715"},{"problem":55,"code":"(fn [coll]\n  (loop [m {} index 0]\n    (if (< index (count coll))\n      (let [k (nth coll index)]\n        (if (m k)\n          (recur (update-in m [k] inc) (inc index))\n          (recur (conj m {k 1}) (inc index))\n        ))\n      m)))","user":"579601c8e4b0e215f87e8492"},{"problem":55,"code":"(fn [a]\n  (->> (group-by identity a)\n       (mapv #(vector (first %) (count (second %))))\n       (into {})))","user":"602d5eade4b0d5df2af22279"},{"problem":55,"code":"(fn [col]\n    (->> (group-by identity col)\n         (reduce (fn [a [b c]]\n                   (assoc a b (count c)))\n                 {})))","user":"59636cc2e4b066ee0a44b0c7"},{"problem":55,"code":"(fn [xs] (->> (map #(hash-map % 1) xs)\n              (reduce (partial merge-with +))))","user":"5ab1665de4b073f1774425c0"},{"problem":55,"code":"(fn [xs]\n  (let [group (group-by identity xs)]\n       (into {} (map (juxt key \n         (comp count val)) group))))","user":"57eaf869e4b0bfb2137f5b56"},{"problem":55,"code":"(fn [sq]\n  (loop [hm-cnt {}, act-sq sq]\n    (if act-sq\n      (let [hd-sq (first act-sq)\n            tl-sq (next act-sq)\n            curr-cnt (hm-cnt hd-sq 0)\n            new-cnt (+ curr-cnt 1)]\n        (recur (assoc hm-cnt hd-sq new-cnt) tl-sq))\n      hm-cnt)))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"problem":55,"code":"(fn [coll]\n        (let [ a (group-by identity coll)\n               b  (for [[key value] a]   [key (count value)])]\n                 (into {} (vec b))))","user":"55aa1637e4b0988bba2ad949"},{"problem":55,"code":"(fn [coll] (into (sorted-map) (map #(hash-map (first %) (count (second %))) (group-by identity coll))))","user":"5daec18ae4b0f8c104ccfc8c"},{"code":"#(zipmap (keys (group-by identity %))\n(map count (vals (group-by identity %))))","problem":55,"user":"4eb44d78535d7eef30807360"},{"code":"reduce (fn [m x] (update-in m [x] #(if % (inc %) 1))) {}","problem":55,"user":"4efccd24535de96065cf5080"},{"code":"#(into {} (for [[k v] (group-by identity %)]\n   [k (count v)]))","problem":55,"user":"511b233ae4b07ab9ec456180"},{"problem":55,"code":"(fn [s] (reduce conj (map #(hash-map (key %) (count (val %))) (group-by identity (sort s)))))","user":"57235dc4e4b0c5bde472c0e2"},{"code":"reduce #(merge-with + {%2 1} %) {}","problem":55,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"#(let [kvm (group-by identity %)]\n   (zipmap \n    (keys kvm)\n    (map count (vals kvm))))","problem":55,"user":"51805d22e4b0e3fc13e244df"},{"problem":55,"code":"(fn [coll]\n  (loop [c coll freq {}]\n    (if (seq c)\n      (let [k (first c)]\n        (recur (rest c) (if (get freq k)\n                          (update-in freq [k] inc)\n                          (assoc freq k 1))))\n      freq)))","user":"53bdcf58e4b0d9a98559a6da"},{"code":"(fn occ\n  [coll]\n  (let [id-map (group-by identity coll)]\n    (zipmap (keys id-map) (map count (vals id-map)))))","problem":55,"user":"50fc48dde4b0d10d794c19f6"},{"problem":55,"code":"(fn\n  [s]\n  (into (sorted-map) (map (fn [%] [(first %) (count %)]) (partition-by identity (sort s)))))","user":"5ec02e20e4b00a66d4a95288"},{"code":"(fn [coll]\n  (into {} (for [[k v] (group-by identity coll)] [k (count v)])))","problem":55,"user":"500ff421e4b0ae202717946f"},{"problem":55,"code":"#(reduce (fn [a v]\n           (if (a v)\n             (assoc a v (inc (a v)))\n             (assoc a v 1))) {} %)","user":"58ffc6cfe4b0438e51c2d008"},{"problem":55,"code":"(fn [x] (apply array-map (apply concat (map (fn [z] (list (key z) (count (val z)))) (group-by first (map #(list %1 %1) x))))))","user":"56ef11efe4b04a395b9a045b"},{"code":"(fn occs\n  [xs]\n  (apply assoc {}\n    (let [gb (group-by identity xs)]\n      (interleave (keys gb)\n        (map count (vals gb))))))","problem":55,"user":"4fab1ea1e4b081705acca210"},{"code":"(fn my-count\n  [coll]\n  (reduce (fn\n            [acc i]\n            (assoc acc i (+ 1 (or (get acc i) 0))))\n          {}\n          coll))","problem":55,"user":"53436e60e4b084c2834f4a19"},{"problem":55,"code":"reduce #(update-in %1 [%2] (fnil inc 0)) nil","user":"589037b4e4b00487982d51d0"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [m [k v]]\n     (assoc m k (count v)))\n   {}\n   (group-by identity coll)))","user":"5b0e6795e4b0cc2b61a3be03"},{"problem":55,"code":"(fn spotgroup [c]\n  (let [result {}]\n    ((fn collectfirst [l, r]\n      (if (empty? l)\n        r\n        (let [f (first l)]\n          (collectfirst (filter #(not= f %) l) (assoc r f (count (filter #(= f %) l))))))) c result)))","user":"60882700e4b0ae75613dcedf"},{"code":"(fn [s]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity s))))","problem":55,"user":"4f7f0827e4b06e829148e1d5"},{"code":"reduce (fn [m i] (assoc m i (inc (get m i 0)))) {}","problem":55,"user":"4f215350e4b0d66497709fd0"},{"problem":55,"code":"(fn [c]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} c))","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":55,"code":"(fn\n  [coll]\n  (reduce (fn \n            [m v]\n            (assoc m v (inc (get m v 0)))) \n          {} \n          coll))","user":"51af4cf6e4b0c53cf2e68a4c"},{"problem":55,"code":"(fn [q] (let [arst (group-by identity q)]\n                 (zipmap (keys arst) (map #(count (second %)) arst))))","user":"56d6c18ee4b0ea9b8538f7d1"},{"code":"(fn [sq]\n  (reduce\n    (fn [n m]\n      (merge n \n        (hash-map m \n          (count \n            (filter #(= % m) sq)))))\n    {}\n    (distinct sq)\n  )\n)","problem":55,"user":"4f8ea1f7e4b0d4e659cdde69"},{"code":"(fn cc [s]\n  (let [g  (group-by identity s)] \n    (reduce (fn [c e] (assoc c e (count (get g e))  )) {} (keys g) )))","problem":55,"user":"5101192ae4b0bef64c30e266"},{"code":"(fn [x]  (apply hash-map (mapcat (fn[kv] [(first kv) (count (second kv))]) (group-by identity x))))","problem":55,"user":"5158bba4e4b059418b97f0ab"},{"problem":55,"code":"(fn frequences [s]\n  (loop [s s, m {}]\n    (if (seq s)\n       (recur (rest s) (assoc m (first s)\n                                                    ;; On ajoute la clef dans m ou on l'incremefnte\n                                                     (if (get m (first s))\n                                                         (inc (get m (first s)))\n                                                          1)))\n       m)))","user":"587bead1e4b01531a375eb0d"},{"code":"(fn [x]\n  (apply merge\n  \t(map #(hash-map (first %) (count %))\n       \t(partition-by identity (sort x))\n       \t)\n  \t)\n  )","problem":55,"user":"52e59ca5e4b09f7907dd1464"},{"problem":55,"code":"reduce #(assoc %1 %2 (inc (get %1 %2 0))) '{}","user":"56f4cedce4b046a417f92063"},{"problem":55,"code":"#(into {} \n       (map (fn [[key values]] (vector key (count values)))\n              (group-by identity %)))\n\n;#(into {}\n;      (for [[k vs] (group-by identity %)]\n;        [k (count vs)]))\n\n;#(into {} (map (fn [pair] ((juxt first (comp count second)) pair))\n;              (group-by identity %)))\n\n;#(reduce\n;   (fn [acc elem]\n;     (assoc \n;       acc \n;       elem\n;       (if-let [num (get acc elem)]\n;         (inc num)\n;         1)))\n;  {}\n;  %)\n\n;#(reduce\n;   (fn [acc elem]\n;     (if-let [num (get acc elem)]\n;       (assoc acc elem (inc num))\n;       (assoc acc elem 1)))\n;  {}\n;  %)","user":"52f3568fe4b05e3f0be25f0e"},{"problem":55,"code":"(fn [xs] (letfn [(update [m k f] \n                         (assoc m k (f (m k))))] \n           (reduce (fn [m v] (update m v #(if % (+ 1 %) 1))) {} xs)))","user":"57a4bb65e4b0a966079561eb"},{"code":"(fn num-times [s]\n  (->> s\n    (group-by identity)\n    (vals)\n    (#(zipmap (map first %) (map count %)))))","problem":55,"user":"52ec1dfbe4b0705949c4444b"},{"code":"#(reduce (fn [counts el]\n           (assoc counts el (inc (get counts el 0))))\n         {}\n         %)","problem":55,"user":"51f9527fe4b09be9c177e549"},{"problem":55,"code":"(fn [ sq ]\n   (let [ update (fn update\n                   ([m k f]\n                    (assoc m k (f (get m k))))\n                   ([m k f x]\n                    (assoc m k (f (get m k) x)))\n                   ([m k f x y]\n                    (assoc m k (f (get m k) x y)))\n                   ([m k f x y z]\n                    (assoc m k (f (get m k) x y z)))\n                   ([m k f x y z & more]\n                    (assoc m k (apply f (get m k) x y z more))))]\n     (->> sq\n          (reduce (fn [ acc next] (update acc next #(conj (or % []) next))) {})\n          (map (fn [[ first second]] [first (count second)]))\n          (into {})) ))","user":"59f90e6ae4b0ca45a743a337"},{"problem":55,"code":"(fn [paramA]\n  (loop [param1 paramA result {}]\n    (if (empty? param1)\n      result\n      (recur (rest param1) (merge-with + {(first param1) 1} result))\n    )\n  )\n)","user":"53f17931e4b0742d9025b0dd"},{"problem":55,"code":"(fn [x]\n  (reduce  #(assoc %1 (first %2) (-> %2 rest first count)) {} (seq (group-by identity x)))\n)","user":"54b050cee4b09f271ff37d13"},{"code":"#(apply merge-with + (for [x %] {x 1}))","problem":55,"user":"4e823ed7535db62dc21a62c7"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [freqs item]\n            (update-in freqs [item] #(inc (or % 0))))\n          {}\n          coll))","user":"5424c523e4b01498b1a71b03"},{"problem":55,"code":"#(loop [a % result {}]\n     (if (empty? a)\n       result\n       (recur (rest a) (assoc result (first a) ((fnil inc 0) (result (first a)))))\n       )\n     )","user":"5763818ae4b0994c1922fbc7"},{"problem":55,"code":"(fn [s]\n ((fn [s accu]\n    (if (empty? s)\n      accu\n      (recur\n        (rest s)\n        (let [key (first s)\n              current-value (get accu key)]\n          (assoc\n            accu\n            key\n            (if (nil? current-value) 1 (+ current-value 1)))\n        )\n      )\n    )\n ) s {})\n)","user":"53ecd01fe4b0d648e757f4b9"},{"problem":55,"code":"#(into {}\n  (map \n   (fn [[k v]] [k (count v)]) \n     (group-by identity %)))","user":"546b89ffe4b00cfc9eacc16d"},{"problem":55,"code":"; (fn [c]\n;   (->> c\n;        (group-by identity)\n;        (map (fn [[k v]] {k (count v)}))\n;        (into {})))\n\n\n(fn [c]\n   (->> c\n        (map #(hash-map % 1))\n        (apply merge-with +)))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":55,"code":"(fn yo\n  ([[next & rest-left :as all], acc]\n   (if (empty? all)\n     acc\n    (recur rest-left\n            (if\n                (contains? acc next) (assoc acc next (inc (acc next)))\n                (assoc acc next 1)))))\n  ([stuff] (yo stuff {})))","user":"571d9669e4b0145328a7627f"},{"problem":55,"code":"#(->> (group-by identity %)\n     (vals)\n     (map (juxt first count))\n     (into {})\n     )","user":"5cfee28de4b0cc9c91588185"},{"problem":55,"code":"(fn [xs]\n  (loop [index {}, [k :as ys] xs]\n    (if (empty? ys)\n      index\n      (recur (assoc index k (inc (get index k 0)))\n             (rest ys)))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","problem":55,"user":"4fa2fa5ee4b081705acca186"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m x]\n            (assoc m x (inc (get m x 0)))) {} coll))","user":"52cf1e25e4b07d0d72b2739c"},{"code":"(fn [l] (let [new-seq (group-by (fn [x] x) l)] (zipmap (keys new-seq) (map count (vals new-seq)))))","problem":55,"user":"509e62a8e4b08df8156e9e2e"},{"problem":55,"code":"(fn [lst] (reduce #(assoc % %2 (inc (% %2 0))) {} lst))","user":"6011b89ee4b074f607df66bc"},{"problem":55,"code":"(fn [xs]\n  (into {}\n        (for [[k v] (group-by identity xs)]\n          {k (count v)})))","user":"50ec409ce4b04edc33777045"},{"code":"(fn [a] (into {} (map-indexed (fn [idx itm] [(first itm) (count itm)] ) (into [] (for [i (set a)] (into [] (filter #(= i %) a)))))))","problem":55,"user":"525c575be4b0cb4875a45d38"},{"problem":55,"code":"(fn [xs]\n  (reduce\n    (fn [acc n] (assoc acc n (inc (get acc n 0)))) {} xs))","user":"54e540c1e4b024c67c0cf7f9"},{"problem":55,"code":"(fn [x]\n\t(apply assoc {}\n      (interleave\n      (map #(first %)  (group-by identity x) ) \n      (map #(count (second % ) )  (group-by identity x) ) \n           ) ) )","user":"57bffed6e4b05aa3c4741c89"},{"code":"(fn freq [s]\n  (if (empty? s)\n    {}\n    (merge {(first s) (count (filter #(= %1 (first s)) s))}\n                        (freq (filter #(not= %1 (first s)) s)))))","problem":55,"user":"5356e04fe4b04ce2eb3ed271"},{"problem":55,"code":"(fn count-occurrences\n   [coll]\n   (reduce\n     (fn\n       [res n]\n       (if (contains? res n)\n         (assoc res n (inc (get res n)))\n         (assoc res n 1))) {} coll))","user":"60631c2ee4b069485764ddbd"},{"problem":55,"code":"(fn [c] (let [m (group-by identity c)]\n                    (zipmap (keys m) (map count (vals m)))))","user":"585030cbe4b0b7285a6f4e78"},{"problem":55,"code":"(fn [coll]\n  (loop [nums       {}\n         [n & coll] coll]\n    (cond\n      (nil? n)           nums\n      (contains? nums n) (recur (assoc nums n (inc (nums n))) coll)\n      :else              (recur (assoc nums n 1) coll))))","user":"5590ebb1e4b0277789237677"},{"problem":55,"code":"(fn [m] (into {} (map (fn [v] (vector (first v) (count (second v)))) (group-by identity m))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":55,"code":"(fn f [xs] \n  (let [m (group-by #(identity %1) xs)] \n  (into {} \n  (for [[k v] m] [k (count v)])\n  )\n  )\n)","user":"5f631e11e4b02876ed9fd011"},{"code":"(fn [s]\n   (apply hash-map (mapcat #(vector (first %) (count (second %)))\n                           (group-by identity s))))","problem":55,"user":"50996a38e4b0cae2931060b3"},{"problem":55,"code":"(fn occurance-3 [sequence]\n  (reduce #(assoc %1 %2 (count (filter (fn [seqAux] (= %2 seqAux)) sequence))) {} (set sequence)))","user":"556c94afe4b09a3098a524fe"},{"problem":55,"code":"reduce #(if ( nil? (get %1 %2)) (assoc %1 %2 1) (assoc %1 %2 (inc (get %1 %2)))) {}","user":"5a634ff0e4b0512ff01cd995"},{"problem":55,"code":"(fn freq\n  [coll]\n  (let [elements (distinct coll)]\n    (into {} (map (fn [elm]\n                 {elm (count (filter #(= elm %) coll))}) elements))))","user":"5b478997e4b02d533a91bc71"},{"problem":55,"code":"(partial reduce \n         (fn [freqs x]\n           (update-in freqs [x] (fnil inc 0)))\n         {})","user":"5112bbdde4b0350614f07a7c"},{"problem":55,"code":"#(reduce (fn [acc x] (if (contains? acc x)\n                             (into acc {x (inc (get acc x))})\n                             (into acc {x 1}))) {} %)","user":"552b6ddbe4b0ffed3738f965"},{"problem":55,"code":"(fn [coll] (reduce (fn [m k] (update-in m [k] #(if (nil? %) 1 (inc %)))) {} coll))","user":"5290257ae4b0239c8a67af03"},{"code":"#(into {} \n  (map (fn [[x y]] [x (count y)]) (group-by identity %)))","problem":55,"user":"4e976f79535dbda64a6f6b55"},{"problem":55,"code":"#(reduce\n  (fn [m k] (assoc m k (inc (get m k 0))))\n  {}\n  %)","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [s]\n  (loop [acc {} xs s]\n    (if (empty? xs) acc\n      (recur (merge-with + acc {(first xs) 1}) (rest xs)))))","problem":55,"user":"52199105e4b0c4ef0be82ff9"},{"code":"(fn [s]\n  (apply merge-with + (map #(hash-map % 1) s)))","problem":55,"user":"5006b7d2e4b0678c553fc48c"},{"code":"(fn count-occur [xs]\n  (if (empty? xs) {}\n    (let [x (first xs)]\n      (update-in (count-occur (rest xs))\n        [x] #(if (nil? %) 1 (inc %))))))","problem":55,"user":"4ee82ce9535d93acb0a6687a"},{"problem":55,"code":"reduce \n(fn [m x] (if-let [val (m x)]\n            (assoc m x (inc val))\n            (assoc m x 1)))\n{}","user":"58b06b7ce4b0ebc645576cdc"},{"problem":55,"code":"(fn [col]\n     (into {} (map (fn [[k v]] [k (count v)]) (group-by identity col)))\n     )","user":"54c94376e4b045293a27f665"},{"problem":55,"code":"#(reduce (fn [m k]\n           (if (get m k)\n             (assoc m k (+ (get m k) 1))\n             (assoc m k 1))) \n         {} %)","user":"4f041de1535dcb61093f6ba5"},{"problem":55,"code":"(fn do-freq\n  [coll]\n  (reduce\n    #(assoc %1 (first %2) (count %2))\n    {}\n    (partition-by identity (sort coll))))","user":"59b62f8de4b05c620303ca1f"},{"code":"(fn [v] (apply hash-map (interleave (set v) (map (fn [x] (count (filter #(= % x) v))) (set v)))))","problem":55,"user":"4e5bdc2b535d8a8b8723a2bb"},{"code":"(fn [s]\n  (reduce (fn [m [k v]] (merge m {k (count v)}))\n          {}\n          (group-by identity s)))","problem":55,"user":"50acbd15e4b071b89ef26234"},{"problem":55,"code":"(fn\n  [s]\n  (let [m (group-by identity s)\n        k (keys m)\n        v (map #(count %) (vals m))]\n    (zipmap k v)))","user":"55bf6dbce4b01b9910ae2a12"},{"problem":55,"code":"(fn\n  [col]\n  (reduce (fn [acc x]\n            (assoc acc x (inc (get acc x 0))))\n          {}\n          col))","user":"5cdc17d0e4b05ee0cb31173c"},{"code":"(fn this\n  ([coll] (this coll {}))\n  ([coll counts]\n   (if (empty? coll)\n     counts\n     (this \n      (rest coll) \n      (assoc \n        counts\n        (first coll) \n        (+ (counts (first coll) 0) 1))))\n   )\n  )","problem":55,"user":"4ec12577535dfed6da9c6da8"},{"problem":55,"code":"#(reduce\n    (fn [accum #_(A hashmap) item]\n      (assoc accum item (let [fre  (accum item)]\n                          (if fre (+ fre 1) 1))))\n    {}\n    %)","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":55,"code":"(fn count-ocurrecnes [s]\n     (let [m (group-by identity s)]\n       (zipmap (keys m) (map count (vals m)))))","user":"594ea2a4e4b07ddc2dafaeb6"},{"code":"reduce (fn [m k] (if-let [v(m k)] (assoc m k (inc v)) (assoc m k 1 ))) {}","problem":55,"user":"4f29cdc8e4b0d6649770a033"},{"problem":55,"code":"#(into {} (map (fn [[k v]][k (count v)]) (group-by identity %)) )","user":"55ed71dae4b0121d4835fdd9"},{"problem":55,"code":"(fn [xs]\n  (reduce #(update-in %1 [%2] (fnil inc 0))\n          {}\n          xs))","user":"59ac0965e4b08cbb53654da6"},{"problem":55,"code":"(fn [li] \n  (reduce (fn [out check] (update-in out [check] #(inc (or % 0)))) {} li))","user":"5ec819b4e4b08d0ec38692e2"},{"code":"#(apply assoc {} (interleave (map (fn[x](first x))(group-by identity %))(map (fn[x](count (second x)))(group-by identity %))))","problem":55,"user":"4ed2dd98535d44c135fd68e2"},{"code":"(fn [xs] (let\n           [incmap (fn [m k] (assoc m k (inc (get m k 0))))]\n           (reduce (fn [a b] (incmap a b)) {} xs)\n           ))","problem":55,"user":"534d1173e4b084c2834f4a98"},{"code":"(fn [c]\n  (reduce (fn [r x]\n    (if (contains? r x)\n(assoc r x (inc (r x)))\n(assoc r x 1))) {} c))","problem":55,"user":"4eb27fad535d7eef3080734a"},{"code":"(fn myfreq \r\n  ([coll] (myfreq coll {}))\r\n  ([coll acc]\r\n    (if (empty? coll) acc\r\n      (let [v (get acc (first coll))]\r\n        (if (nil? v) (myfreq (rest coll) (assoc acc (first coll) 1))\r\n                     (myfreq (rest coll) (assoc acc (first coll) (inc v))))))))","problem":55,"user":"4e14108c535d04ed9115e7dd"},{"problem":55,"code":"(fn [coll] \n  (reduce  #(merge %1 %2)  \n           (map \n            (fn [ele] (hash-map (key ele) (count (val ele)))) \n            (group-by identity coll))))","user":"5a6170fde4b0512ff01cd975"},{"problem":55,"code":"#(into {} (for [l (partition-by identity (sort %))]\n  {(first l) (count l)}))","user":"5e6ca949e4b04a83ad7cd289"},{"code":"(fn co [coll]\n  (reduce (fn [xs x]\n            (if (contains? xs x)\n              (assoc xs x (inc (get xs x)))\n              (assoc xs x 1))) {} coll))","problem":55,"user":"52016fd3e4b0b2e020a18f10"},{"problem":55,"code":"(fn [coll]\n  (loop [c coll\n         acc {}]\n    (if (seq c)\n      (recur (rest c) (assoc acc (first c) (inc (get acc (first c) 0))))\n      acc)))","user":"51ca5378e4b08b1cbd0d9480"},{"problem":55,"code":"(fn count-occurrences [xs]\n  (->> xs\n       (group-by identity)\n       (map (fn [[k vs]] [k (count vs)]))\n       (into {})))","user":"5d47fa13e4b07c84aa5ae6b6"},{"code":"#((fn [x] (zipmap (keys x) (map count (vals x)))) (reverse (group-by identity %)))","problem":55,"user":"520cb8c4e4b0b022ef140c9a"},{"problem":55,"code":"#(into {} (map \n           (fn [[k v]] [k (count v)])\n           (group-by identity %)))","user":"5cdc34a2e4b05ee0cb31173f"},{"code":"(fn comap [s]\n  (loop [m {}\n         remain s]\n     (if (empty? remain) m\n        (let [[nextelt & newremain] remain\n              lu (m nextelt)\n              c (if (nil? lu) 0 lu)\n              newc (inc c)\n              newm (assoc m nextelt newc)]\n          (recur newm newremain)))))","problem":55,"user":"4f036fb3535dcb61093f6ac8"},{"problem":55,"code":"(fn sk-frequencies [xs]\n  (into {}\n        (map\n          (juxt key (comp count val))\n          (group-by identity xs)))\n  )","user":"5884f377e4b0f1effa3b76a8"},{"code":"(fn [ls]\n  (apply merge-with + (map (fn [x] {x 1}) ls)))","problem":55,"user":"4de165f3535d08e6dec9fde6"},{"problem":55,"code":"reduce (fn [r x] (update-in r [x] (fnil inc 0))) {}","user":"56706f01e4b0a866af6896f2"},{"code":"#(reduce (fn [acc e] \n            (assoc acc e (inc (acc e 0)) )) {}  %)","problem":55,"user":"523a9fc9e4b081681ca7adca"},{"code":"#(reduce (fn [m e] (update-in m [e] (fnil inc 0))) {} %)","problem":55,"user":"52746701e4b03e8d9a4a74a2"},{"problem":55,"code":"(fn [sq]\n                  \" a function which returns a map containing the number of occurences of each distinct item in a sequence.\"\n                  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} sq))","user":"57ff4f52e4b0d3187e9009e8"},{"problem":55,"code":"(fn [coll] (apply merge-with + (for [num coll] {num 1})))","user":"606c87aae4b069485764de0d"},{"code":"#(into {}  (map (fn [[a b]] (vector a (count b))) (group-by identity %)))","problem":55,"user":"50cae881e4b0f75dcc9a6e51"},{"problem":55,"code":"(fn [coll]\n(into {}\n      (map (fn [[k vals]] [k (count vals)])\n           (group-by identity coll))))","user":"532902f8e4b09d4e7a9b550e"},{"code":"(fn [coll]\n  (reduce (fn [counts x]\n            (assoc counts x (inc (get counts x 0))))\n          {} coll))","problem":55,"user":"5336ca32e4b0e30313ee6c80"},{"problem":55,"code":"(fn [s] (let [keys (distinct s)\n\t\t    counts (map (fn [x] (count (filter #(= x %) s))) keys)] \n\t   (zipmap keys counts)))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [l]\n   (loop [e (first l) r (next l) ac {}]\n     (if r\n       (recur (first r) (next r)\n              (assoc ac e (count (filter (partial = e) l))))\n       ac)))","problem":55,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn [l]\n    (apply hash-map  (apply concat \n        (map (fn [c] \n               (list (first c)\n                     \t (count (second c))))\n              (group-by identity l)))))","problem":55,"user":"5097ddfce4b087ccf61a7af0"},{"problem":55,"code":"#(let[m (group-by identity %)]\n   (zipmap (keys m) (map count (vals m))))","user":"541619e8e4b01498b1a719f9"},{"problem":55,"code":"#(into {} (map (fn[[a b]] [a (count b)]) (group-by identity %)))","user":"56824e1be4b0945ebc182a91"},{"code":"#(into {} (for [x  (distinct %)] [x (count (filter (fn [y] (= y x)) %))]))","problem":55,"user":"4f0664bd535dcb61093f6c0f"},{"code":"#(reduce\n  \t(fn [freq, item]\n\t\t\t(let [entry (find freq item),\n\t\t\t\t  current (if (nil? entry) 0 (val entry))]\n\t\t\t    (conj freq [item (inc current)])))\n\t\t{}\n\t\t%)","problem":55,"user":"4fb57e06e4b081705acca2bf"},{"code":"(fn count-occ [lst]\n    (reduce (fn [acc-map ele]\n        (if (contains? acc-map ele)\n            (assoc acc-map ele (inc (get acc-map ele)))\n            (assoc acc-map ele 1)))\n    {} lst)\n)","problem":55,"user":"52c17e42e4b07a9af5792367"},{"code":"(fn [x] (zipmap x (map (fn [y] \n    (count (filter #(= % y) x))) x)))","problem":55,"user":"4ea9b80c535d7eef30807306"},{"code":"reduce #(if-let [old (%1 %2)] (assoc %1 %2 (inc old)) (assoc %1 %2 1)) {}","problem":55,"user":"52dd4fb4e4b09f7907dd13df"},{"code":"(partial reduce #(update-in %1 [%2] (fnil inc 0)) {})","problem":55,"user":"4e5914e0535d8a8b8723a29b"},{"code":"#(->> %\n  sort\n  (partition-by identity)\n  (map (juxt first count))\n  (into {}))","problem":55,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"problem":55,"code":"(fn count-occurrences\n  [coll]\n  (reduce-kv (fn [m k v]\n               (assoc m k (count v)))\n             {} (group-by identity coll)))","user":"60396c95e4b0d5df2af222f4"},{"problem":55,"code":"(fn [x] (\n  ->>\n  x\n  (group-by identity)\n  (map (fn [[k v]] [k (count v)]))\n  (into {})\n  ))","user":"5d1a1082e4b0902706380e0e"},{"code":"(fn [rnge]\n    ((fn [last rslt remainder]\n       (if (empty? remainder)\n         rslt\n         (recur (first remainder)\n                (assoc rslt (first remainder) (inc (get rslt (first remainder) 0)))\n                (rest remainder))\n         )\n       )\n     (first rnge) {(first rnge) 1} (rest rnge)\n       )\n    )","problem":55,"user":"52213426e4b0e6a83c8925c4"},{"problem":55,"code":"(fn [s] \n  (reduce #(assoc % %2\n             (+ (if (nil? (get % %2)) 0 (get % %2)) 1)\n             ) {} s))","user":"56066e82e4b08b23635d3173"},{"code":"(fn [coll]\n  (reduce #(assoc % %2 (+ (get % %2 0) 1)) {} coll))","problem":55,"user":"4ee8b9c9535d93acb0a66884"},{"code":"(fn [coll] (reduce (fn [m k] (update-in m [k] (fnil inc 0))) {} coll))","problem":55,"user":"4fc9985ee4b0ee37620e1846"},{"problem":55,"code":"(fn [seq]   (reduce #(assoc %1 %2 (+ 1 (or (get %1 %2) 0))) {}  seq))","user":"5f0aa72de4b09a3f05b71808"},{"problem":55,"code":"(fn count-occurs [s]\n  (let [m (group-by identity s)]\n       (zipmap (keys m) (map count (vals m)))))","user":"5be33a16e4b0ed4b8aab4cd6"},{"problem":55,"code":"#(apply merge (for [[v _] (group-by identity % )] { v (count _) }))","user":"55aa5f73e4b0988bba2ad94b"},{"problem":55,"code":"(fn [vec]\n  (into {} (map #(hash-map (nth % 0) (count (nth % 1))) (group-by identity vec))))","user":"5b337ff4e4b025bcb146f339"},{"problem":55,"code":"(fn [x] (loop [l (sort x) m {}]\n          (print l)\n          (if (empty? l)\n            m\n            (let [f (first l)]\n\t          (recur (rest l) (assoc m f (inc (m f 0))))))))","user":"546c1b2ce4b00cfc9eacc174"},{"problem":55,"code":"#(into {}\n       (map (fn [[k v]]\n              [k (count v)])\n            (group-by identity %)))","user":"5ade6bafe4b0837691e92c23"},{"code":"(fn [s] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} s))","problem":55,"user":"4e5f08c7535d8a8b8723a2da"},{"code":"(fn [l]\n  (reduce\n    (fn [m e] (update-in m [e] (fnil inc 0)))\n  {} l))","problem":55,"user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(fn [C]\n    (reduce (fn [m x]\n              (update-in m [x] #(if % (inc %) 1)))\n            {} C))","problem":55,"user":"4e31a15c535deb9a81d77f1e"},{"problem":55,"code":"(fn [a]\n  (into (sorted-map)\n        (map #(hash-map (key %) (count (val %))) \n             (group-by identity a))))","user":"57d93437e4b0bd073c2023f9"},{"code":"(fn [c]\n  (reduce merge (for [group (partition-by identity (sort c))] {(first group) (count group)})))","problem":55,"user":"514721c6e4b0d520409ed392"},{"problem":55,"code":"(fn [coll] (into (sorted-map) (map #(vector (first %) (count (second %))) (group-by identity coll))))","user":"5e5c425ae4b0fd0acd158662"},{"problem":55,"code":"(fn [coll]\n  (let [sorted-coll (partition-by identity (sort coll))]\n    (zipmap (map first sorted-coll) (map count sorted-coll))))","user":"56014f55e4b04bb52996e184"},{"problem":55,"code":"(fn count-indetities [col]\n  (into {}\n        (map #(vector (first %1) (count (second %1))) (group-by identity col))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":55,"code":"#(reduce (fn [mp x] (update-in mp [x] (fnil inc 0))) {} %)","user":"541475afe4b01498b1a719eb"},{"code":"#(let [a (group-by identity %)]\n(zipmap (keys a) (map count (vals a))))","problem":55,"user":"4f4c8faae4b03ad3f0c10c93"},{"problem":55,"code":"(fn count-occurrences\n  [coll]\n  (reduce (fn [res i]\n            (assoc res i\n                   (let [freq (get res i)]\n                     (if freq (inc freq) 1))))\n          {}\n          coll))","user":"52ea025ae4b09f7907dd14b5"},{"code":"(fn [sq] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} sq))","problem":55,"user":"4f0c4518535d0136e6c2230b"},{"problem":55,"code":"(fn [items]\n  (loop [items items result {}]\n    (if (empty? items)\n      result\n      (let [key (first items)]\n        (recur (rest items)\n               (if (contains? result key)\n                 (assoc result key (inc (result key)))\n                 (assoc result key 1)))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [x]\n  (reduce\n    (fn [m xs]\n      (assoc m xs (+ (get m xs 0) 1))) \n    {} x))","problem":55,"user":"4f616892e4b0defedf855fbf"},{"code":"(fn [col]\n  (into {}\n        (for [[k v] (group-by identity col)]\n          [k (count v)])))","problem":55,"user":"507a08e4e4b08327cd804a67"},{"problem":55,"code":"(fn occurences [coll]\n  (apply merge-with + (for [entry coll] {entry 1})))","user":"59971e2de4b07157cc8daacc"},{"problem":55,"code":"(fn man-frequencies\n  [coll]\n  (reduce (fn add-freq [freq-dict element]\n  (if (nil? (get freq-dict element))\n    (assoc freq-dict element 1)\n    (assoc freq-dict element (inc (get freq-dict element)))\n    )) {} coll)\n  )","user":"5c51d700e4b0fb8c5ffd99d1"},{"problem":55,"code":"(fn [seq]\n  (into {} (map (fn [e]\n                  [(first e) (count (second e))]\n                  ) (group-by identity seq))))","user":"5cdbb1b2e4b05ee0cb311732"},{"code":"(fn [lst]\n  (let [freqs (group-by identity lst)\n        ks    (keys freqs)\n        vs    (vals freqs)]\n    (into {} (map vector ks (map count vs)))))","problem":55,"user":"505aa653e4b021387fb89857"},{"problem":55,"code":"(fn [s]\n  (let [grouped (group-by identity s)]\n    (zipmap (keys grouped) (map count (vals grouped)))))","user":"553b0d95e4b09218d5f44fff"},{"problem":55,"code":"(fn f [x] \n  (apply sorted-map\n  (mapcat identity\n  (map #(list (first %) (count %))\n       (partition-by identity (sort x))))))","user":"51dd5d6fe4b0c33a4e1da406"},{"problem":55,"code":"(fn x [coll] (into {} (for [[k v] (group-by identity coll)] [k (count v)])))","user":"560768a0e4b08b23635d317f"},{"problem":55,"code":"(fn freq [col]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} col))","user":"55536a8ae4b0deb715856e03"},{"problem":55,"code":"#(let [ms (group-by  identity %)] (zipmap (keys ms) (map count (vals ms))))","user":"554b8572e4b0a04f79299589"},{"code":"(fn [s]\n  (letfn [(bag-add [bag x] (->> (get bag x 0) (inc) (assoc bag x)))]\n    (reduce bag-add {} s)))","problem":55,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":55,"code":"(fn [s] (->> s\n  (group-by identity)\n  (map (fn [[x o]] [x (count o)]))\n  (into (sorted-map))))","user":"5901158de4b0438e51c2d039"},{"problem":55,"code":"(fn [xs]\n   (reduce #(if (get % %2) (update-in % [%2] inc) (assoc % %2 1))\n           {}\n           xs))","user":"540e17c3e4b0addc1aec6719"},{"problem":55,"code":"(fn group-by-count [coll] \n  (apply hash-map (mapcat #(list (first %) (count (second %))) (group-by identity coll))))","user":"53f35c34e4b0742d9025b0f4"},{"problem":55,"code":"(fn [xs]\n  (->> xs (group-by identity)\n       (map (fn [[n xs]]\n              [n (count xs)]))\n       (into {})))","user":"55d87324e4b0e31453f64ab4"},{"problem":55,"code":"(fn freqs [l]\n  (loop [l l,\n         frequency-map {}]\n    (if (empty? l) frequency-map,\n      (recur (rest l)\n             (assoc frequency-map\n                    (first l)\n                    (inc (get frequency-map (first l) 0)))))))","user":"59358f74e4b04f87174def52"},{"problem":55,"code":"(fn freqs [l]\n  (->> l (group-by identity) vals (map #(identity {(first %1) (count %1)}) ) (apply merge)))","user":"575a0ef0e4b02ea114799335"},{"code":"(fn occ [s] (apply merge-with + (map #(hash-map % 1) s)))","problem":55,"user":"52d3f666e4b09f7907dd1327"},{"code":"(comp (partial apply hash-map) (partial mapcat #(list (first %) (count (second %)))) seq (partial group-by identity))","problem":55,"user":"4f4f0287e4b03ad3f0c10cd7"},{"code":"(fn [coll]\n  (reduce #(assoc %1 (first %2) (count %2)) {}\n    (partition-by identity (sort-by identity coll))))","problem":55,"user":"4dbd2aa3535d020aff1edf40"},{"code":"#(into {} (map (juxt first count)\n                (partition-by identity (sort %))))","problem":55,"user":"4ec74de3535d6d7199dd36df"},{"problem":55,"code":"#(reduce \n  (fn [coll x] (update-in coll [x] (fnil inc 0))) \n  {} %)","user":"60471241e4b02d28681c77c9"},{"problem":55,"code":"(fn myfreqs [coll]\n   (let [values (distinct coll)\n         count-occurences (fn [value]\n                            (count \n                              (filter #(= value %) coll)))\n         pairs (map (fn [value] [value (count-occurences value)]) values)\n         keyvals (reduce (fn [acc pair]\n                           (into acc pair))\n                         []\n                         pairs)]\n     (apply hash-map keyvals)))","user":"5429986ce4b01498b1a71b3b"},{"problem":55,"code":"(fn count-occurences [xs]\n  (reduce (fn [m x] (merge-with\n                     (fn [old new] (if (nil? old) new (+ new old)))\n                     m\n                     {x 1}))\n          {}\n          xs))","user":"5cdc08a2e4b05ee0cb31173a"},{"code":"(fn [coll]\n  (apply hash-map (mapcat (fn [[key xs]] [key (count xs)]) (group-by identity coll))))","problem":55,"user":"5360f043e4b0243289761e3c"},{"problem":55,"code":"(fn [coll]\n    (reduce merge {}  (map #(let [[a b ] %] {a (count b)} ) (group-by identity coll)))\n    )","user":"5ab575f8e4b073f17744263d"},{"code":"(fn count-occurrences [s]\n  (letfn [(count-entry [h v]\n            (assoc h v (+ (get h v 0) 1)))]\n    (reduce count-entry {} s)))","problem":55,"user":"4f68c485e4b07046d9f4ef7c"},{"problem":55,"code":"(fn count1\n  ([s] (count1 s {}))\n  ([s res] (cond (empty? s) res\n                 (contains? res (first s)) (count1 (rest s) (update-in res (list (first s)) inc))\n                 :else (count1 (rest s) (assoc res (first s) 1)))))","user":"5d931a58e4b0d3f9b434ad10"},{"problem":55,"code":"(fn [seqn]\n  (loop [acc {(first seqn) 1} n (rest seqn)]\n    (if-let [f (first n)]\n      (recur\n       (if (get acc f)\n         (assoc acc f (inc (acc f)))\n         (assoc acc f 1))\n       (rest n))\n      acc)))","user":"563f4c47e4b08d4f616f5ed2"},{"problem":55,"code":"(fn furp [acc x]\n  (if (empty? x)\n    acc\n    (let [f (first x)\n          c (count (filter #(= f %) x))\n          r (filter #(not= f %) x)]\n      (furp (assoc acc f c) r)\n      \n    )\n  )\n) {}","user":"59d75e36e4b0ef0a1e9b5c32"},{"code":"(fn [s]\n  (reduce\n    (fn [out item]\n      (assoc out \n        (first item)\n        (count (second item))\n    )) {} (group-by identity s)))","problem":55,"user":"4f0bc223535d0136e6c22307"},{"code":"#(into {} (for [ [k v] (group-by identity %) ] [k (count v) ] ))","problem":55,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"505bd09fe4b032b709c81373"},{"code":"#(loop[s %, r (zipmap (set %), (repeat  (count %) 0))]\n  (if (empty? s)\n    r\n    (recur (rest s) (assoc r (first s) (inc (get r (first s)))))\n  )\n)","problem":55,"user":"4e6df3c9535d5021c1a895fa"},{"problem":55,"code":"(fn [coll]\n  (into {} (for [[k v] (group-by identity coll)]\n             [k (count v)])))","user":"51ae350fe4b09397d5109790"},{"problem":55,"code":"(fn [xs] (->> (sort xs) (partition-by identity) (map #(hash-map (first %) (count %))) (reduce merge)))","user":"5409a12fe4b0addc1aec66df"},{"problem":55,"code":"reduce #(assoc %1 %2 ((fnil inc 0) (%1 %2)))\n\t   {}","user":"53e9dce1e4b036ad0777e4bc"},{"code":"#(apply conj {}\n    (for [[k v] (group-by identity %)]\n       [k (count v)]))","problem":55,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":55,"code":"(fn [coll]\n  (loop [[elem & coll] coll freq {}]\n    (if (nil? elem)\n      freq\n      (recur coll (assoc freq elem (+ 1 (freq elem 0))))\n   ) \n  )\n)","user":"5e09fd26e4b099d064962f60"},{"problem":55,"code":"#(into {} (map (fn [[k v]] [(first v) (count v)]) (group-by identity %)))","user":"56cd44fde4b0ea9b8538f749"},{"problem":55,"code":"(fn [s_]\n  (loop [s s_ result {}]\n    (if (empty? s) \n      result\n      (let [h (first s) n (count (filter (partial = h) s))]\n        (recur (filter (partial not= h) s) (conj result [h n]))))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [v] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity v))))","problem":55,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"reduce (fn [ret i] (update-in ret [i] #(if % (+ % 1) 1 ) )) {}","problem":55,"user":"4f2965ffe4b0d6649770a029"},{"problem":55,"code":"reduce #(assoc % %2 (inc (get % %2 0))) {}\n; (reduce (fn [coll [k v]] (assoc coll k (count v) )) {} (group-by identity [1 1 2 3 2 1 1]))","user":"55d62a68e4b0e31453f64a96"},{"problem":55,"code":"(fn occurence [s]\n  (loop [s s\n         res {}]\n    (if (seq s)\n      (recur\n       (filter #(not= (first s) %) s)\n       (assoc res (first s) (count (filter #(= (first s) %) s))))\n      res)))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn count-occ [col]\n  (reduce (fn [x [y z]] (assoc x y (count z))) {} (group-by identity col)))","problem":55,"user":"511e763ce4b03e81d390ac29"},{"code":"reduce #(assoc %1 %2 (+ 1 (get %1 %2 0))) {}","problem":55,"user":"535a18e3e4b04ce2eb3ed2a4"},{"problem":55,"code":"(fn foo [xs]\n(into {} (for [[k v] (group-by identity xs)] [k (count v)])))","user":"54ab502fe4b09f271ff37cc4"},{"code":"(fn [l] (reduce #(into %1 %2) (map #(let [[x l] %] {x (count l)}) (group-by identity l))))","problem":55,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":55,"code":"reduce (fn [m item]\n         (if (contains? m item) \n           (assoc m item (inc (get m item))) \n           (assoc m item 1))) {}","user":"53bc10f5e4b047364c04450d"},{"problem":55,"code":"(fn freq [sq]\n  (if (empty? sq) {} \n                  (let [[head & tail] sq\n                        acc (freq tail)\n                        freq (get acc head 0)]\n                    (assoc acc head (inc freq)))))","user":"55815973e4b05c286339e0f6"},{"problem":55,"code":"#(into {} (map (juxt first count) (vals (group-by identity %))))","user":"556f35fee4b09a3098a5251a"},{"problem":55,"code":"(fn [coll](reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity coll)))","user":"538d70abe4b0b51d73faae6e"},{"problem":55,"code":"(fn freq [x]\n  (zipmap (keys (group-by identity x)) (map #(count %) (vals (group-by identity x)))))","user":"581829cce4b0c0e9c07b83a9"},{"problem":55,"code":"(fn [coll]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"55fbf6cae4b0f488688e066c"},{"code":"(fn [c] (reduce (fn [m [k v]] (conj m [k (count v)])) \n        {} (group-by identity c)))","problem":55,"user":"4e95c771535dbda64a6f6b39"},{"code":"(fn counter [m]\n     (let [n (group-by identity m)]\n       (zipmap (keys n) (map count (vals n)))))","problem":55,"user":"51a9dbc9e4b04e3dc0c27b1e"},{"code":"(fn [l]\n  (into '{} \n        (for [e (set l)]\n              [e (count (filter #(= e %) l))])))","problem":55,"user":"530cb5b8e4b02e82168697e0"},{"problem":55,"code":"(fn [coll]\n  (let [c (group-by identity coll)]\n    (zipmap (keys c) (map count (vals c)))))","user":"5412d5d2e4b01498b1a719d9"},{"code":"(fn [s]\n  (reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity s)))","problem":55,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":55,"code":"(fn [col]\n  (persistent! (reduce #(assoc! %1 %2 (inc (get %1 %2 0))) (transient {}) col)))","user":"57213df6e4b0c5bde472c0ab"},{"problem":55,"code":"(fn [col] (apply merge-with + (map (fn [x] {x 1}) col)))","user":"571e5c9ee4b0145328a76290"},{"code":"(fn [list]\n  (apply assoc {} \n    (mapcat #(vector (first %) (count (second %)))\n      (group-by identity list))))","problem":55,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":55,"code":"(fn [xs]                                                                                                               \n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} xs))","user":"54ff074de4b07d26eda61d47"},{"problem":55,"code":"(fn freqs\n  [coll]\n  (let [fs (map #(hash-map % 1) coll)]\n    (apply merge-with + fs)))","user":"56488119e4b0284900eef632"},{"problem":55,"code":"(fn [coll]\n  (loop [result {}, target (sort (distinct coll))]\n    (if (= 0 (count target))\n      result\n      (recur (conj result\n                   {(first target) (count (filter (fn [x] (= x (first target))) coll))})\n             (rest target)))))","user":"56c55fbce4b05cc29241eea5"},{"problem":55,"code":"(comp (partial apply zipmap)\n      (juxt keys (comp (partial map count) vals))\n      (partial group-by identity))","user":"5800edaae4b0a837a8b30c48"},{"code":"reduce (fn [result el] (assoc result el (inc (result el 0)) )) {}","problem":55,"user":"52da20c7e4b09f7907dd13b3"},{"problem":55,"code":"(fn [col]\n(apply hash-map\n(mapcat (fn [[x y]](list x (count y)))\n(group-by identity col))))","user":"50856bd1e4b004985b776e4c"},{"problem":55,"code":"#(reduce (fn [f k] (assoc f k (inc (f k 0)))) {} %)","user":"5d45749be4b07c84aa5ae6a2"},{"problem":55,"code":";(fn counter [coll]\n;  (reduce (fn [result, el] \n;            (assoc result el (if (nil? (get result el)) 1 (inc (get result el))))\n;          ) {} coll))\n\n\n(fn counter [coll]\n  (reduce (fn [result [val occurs]] (assoc result val (count occurs))) {} (group-by identity coll)))","user":"59837909e4b021a7a535fe16"},{"problem":55,"code":"#(reduce (fn [r x] (assoc r (first x) (count (second x)))) {} (seq (group-by identity %)))","user":"55bfc39ee4b01b9910ae2a1a"},{"code":"#(apply hash-map  (mapcat (fn [x] [(first x) (count x)]) (vals (group-by identity %))))","problem":55,"user":"521dceeae4b050d5da042802"},{"code":"(fn [input]\n  (let [sqnc (group-by identity input)]\n    (zipmap (keys sqnc) (map count (vals sqnc)))))","problem":55,"user":"528bba38e4b0239c8a67aea9"},{"code":"(fn [x] (apply hash-map \n  (mapcat \n   #(concat (distinct %) [(count %)]) \n   (vals (group-by identity x)))))","problem":55,"user":"50955676e4b087f34d351ab1"},{"problem":55,"code":"(fn [s] (zipmap s (map #(count (keep #{%} s)) s)))","user":"5e471203e4b043cd24807a2a"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc v] (update-in acc [v] #(if (nil? %) 1 (inc %)))) {} coll))","user":"516c3472e4b06f078fab251c"},{"code":"#(reduce\n    (fn [m v]\n      (assoc m v (inc (m v 0))))\n    {}\n    %1)","problem":55,"user":"4e4ad154535dc968683fc4d1"},{"problem":55,"code":"(fn countNumberOfThings [col]\n\n  (loop [keys (distinct col)\n         result {}]\n    (if (empty? keys)\n      result\n      (recur (rest keys)\n             (assoc result (first keys) (count (filter #(= % (first keys)) col))))))\n  )","user":"57c731ede4b05aa3c4741d00"},{"code":"(fn [coll] (reduce #(assoc %1 %2 (inc (%1 %2 0))) '{} coll))","problem":55,"user":"533b1dc4e4b0e30313ee6cc7"},{"problem":55,"code":"(fn [x] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity x)))","user":"5fae3d8ae4b08cb800c85afa"},{"code":"(fn [coll] (reduce (fn [dic n] (assoc dic n (inc (or (dic n) 0)))) {} coll))","problem":55,"user":"4df669d4535d08e6dec9fe35"},{"problem":55,"code":"#(reduce (fn [f v] (assoc f v (inc (f v 0)))) {} %)","user":"57609d91e4b08062f99a4e9b"},{"code":"#(apply merge-with + (for [k %] {k 1}))","problem":55,"user":"522eb5cce4b01cdb292c5f0c"},{"code":"(letfn [(f [{v e :or {v 0} :as m}\n             e]\n           (assoc m e (inc v)))]\n  (fn [col]\n    (reduce f (sorted-map) col)))","problem":55,"user":"51eadb98e4b0f1f103a0d153"},{"code":"(fn [c] (into {} (map vec (map #(list (first %) (count (second %))) (group-by identity c)))))","problem":55,"user":"519964cbe4b0aa09cbc0b849"},{"code":"(fn [xs]\r\n(loop [[x & more] xs\r\n       m {}]\r\n(if (nil? x) m\r\n (recur more\r\n    (if (contains? m x)\r\n        (conj m {x (inc (get m x))})\r\n        (conj m {x 1}))))))","problem":55,"user":"4ea09441535d7eef308072a7"},{"problem":55,"code":";#(->> % \n;      (group-by identity)\n;      (map (fn [[k v]] [k (count v)])) \n;      (into {}))\n\n(comp (partial into {})\n      (partial map (fn [[k v]] [k (count v)]))\n      (partial group-by identity))","user":"5960a1a6e4b066ee0a44b08e"},{"code":"(fn [s]\n  (let [h (group-by identity s)\n        ks (keys h)\n        vs (map count (vals h))]\n    (zipmap ks vs)))","problem":55,"user":"4fc3a72ae4b081705acca342"},{"problem":55,"code":"(fn\n  [xs]\n  (loop [xs (sort xs)\n         element (first xs)\n         element-count 0\n         acc nil]\n    (if (empty? xs)\n      (assoc acc element element-count)\n      (if (= element (first xs))\n        (recur (rest xs) element (inc element-count) acc)\n        (recur xs (first xs) 0 (assoc acc element element-count))))))","user":"5b673832e4b0c6492753e760"},{"code":"(fn [c]\n  (letfn [(inc' [x] (if (nil? x) 1 (inc x)))]\n    (->> c\n         (reduce (fn [r e]\n                   (update-in r [e] inc'))\n                 {}))))","problem":55,"user":"5392b849e4b0b51d73faaeb1"},{"problem":55,"code":"(fn [xs] (into {} (map (fn [[k v]] {k (count v)})(group-by identity xs))))","user":"5ce5b43be4b0a17bb84e2b7a"},{"problem":55,"code":"reduce (fn [freq x] (assoc freq x (inc (get freq x 0)))) {}","user":"53fcb8f7e4b0de5c418485d4"},{"code":"#(zipmap (distinct %) (map count (vals (group-by identity %))))","problem":55,"user":"4db13ff51254ad5b4805fa68"},{"problem":55,"code":"(fn co [xs]\n  (->> (group-by identity xs)\n       (reduce-kv #(assoc %1 %2 (count %3)) {})))","user":"5641296de4b08d4f616f5ef4"},{"problem":55,"code":"(fn mytest\n\t[myset]\n\n\t\n  \t(let [getfreq (fn [myseq e]\n\n\t\t\t\t\t(hash-map e \n\t\t\t\t\t\t\t\t(count \n\t\t\t\t\t\t\t\t\t(filter #(= e %) myseq)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\t\t\t\t)\n          \n  \t\t]\t\n  \n  \t(apply merge (map (partial getfreq myset) myset))\n\n  \t)\n  \n  )","user":"55897fe2e4b059ccff29b205"},{"problem":55,"code":"(fn [items] \n  (->> \n   (group-by identity items)\n   (seq)\n   (map (fn [[a b]] [a (count b)]))\n   (apply conj {})))","user":"5711b532e4b09c608db70449"},{"problem":55,"code":"(fn [l]\n  (reduce\n   (fn [m k]\n     (assoc m k (inc (get m k 0))))\n   {}\n   l))","user":"4eb97234535dfed6da9c6d53"},{"problem":55,"code":"#(into (sorted-map)\n        (map (fn [[k v]]\n               {k (count v)})\n             (group-by identity %)))","user":"5410499de4b01498b1a719a6"},{"problem":55,"code":"(fn [vect1]\n  (loop [vect vect1 final {}]\n    (if (empty? vect)\n      final\n      (if (contains? final (first vect)) ;if key exists, update its value\n        (recur (rest vect) (assoc final (first vect) (inc (get final (first vect)))))\n        (recur (rest vect) (assoc final (first vect) 1)))))) ;otherwise it's new, so set count to 1","user":"59369515e4b02506e01a297e"},{"code":"(fn my-freq [col]\n  (reduce (fn [s x]\n  \t\t\t\t\t(assoc s x (inc (get s x 0))))\n          {}\n          col))","problem":55,"user":"50812debe4b01a93d3f38e4c"},{"problem":55,"code":"(fn [col] (apply merge (map #(hash-map (first %) (count %)) (vals (group-by identity col)))))","user":"5ab276f2e4b073f1774425e6"},{"code":"#(->> % (group-by identity) (map (fn [[k v]] [k (count v)])) (into {}))","problem":55,"user":"4e7f32ee535db966e863cc3a"},{"problem":55,"code":"(fn [s]\n               (reduce #(assoc % %2 (inc (% %2 0))) {} s))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn [coll]\n  (apply hash-map\n         (mapcat (fn [[k v]] [k (count v)])\n                 (group-by identity coll))))","problem":55,"user":"50586354e4b06522596eba78"},{"problem":55,"code":"(fn a [v] (apply merge-with + (map #(hash-map % 1) v)))","user":"55ac16a0e4b03311e7b73291"},{"code":"(fn [s]\n  (reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} s))","problem":55,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":55,"code":"(fn [coll]\n   (let [grouped (group-by identity coll)\n         ll (map (fn [[a b]] [a (count b)]) (seq grouped))\n         ret (into (array-map) ll)]\n     ret))","user":"56fbf83de4b07572ad1a88da"},{"problem":55,"code":"(fn [seq] \n  (into {} \n        (map #(vector (first %) (count (last %))) \n             (group-by identity seq))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":55,"code":"(fn [seq]\n  (loop [s seq t {}] \n    (if (zero? (count s))\n      t\n      (recur (rest s) (assoc t (first s) (if (contains? t (first s)) (inc (t (first s))) 1)))\n      \n    )\n  )\n)","user":"4f148418535d64f60314643a"},{"problem":55,"code":"(fn [s]\n   (reduce (fn [r e]\n             (if (contains? r e)\n               (update-in r [e] inc)\n               (assoc r e 1)))\n           {}\n           s))","user":"55895eade4b059ccff29b202"},{"problem":55,"code":"(fn freq [xs]\n  (into {} (for [x (distinct xs)]\n             [x (count (filter (partial = x) xs))])))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn [l] (apply merge-with + (map #(hash-map % 1) l)))","problem":55,"user":"4f0333f6535dcb61093f6a77"},{"code":"#(apply hash-map (mapcat (fn[e](list (first e) (count (second e)))) (group-by identity %)))","problem":55,"user":"4e7db3b4535db169f9c796e1"},{"problem":55,"code":"(fn [xs]\n  (let [ks (distinct xs)]\n  (zipmap \n    ks\n    (map \n      (fn [k] (count (filter #(= k %) xs)))\n       ks))))","user":"5537cbaee4b09218d5f44fd3"},{"problem":55,"code":"(fn[coll]\n  (let [new_map (group-by identity coll)]\n    (zipmap (map first (vals new_map)) (map count (vals new_map)))))","user":"56163cc1e4b06b1bb21829ff"},{"problem":55,"code":"(fn get-frequencies\n  [collection]\n  (let [basic-map (group-by identity collection)]\n    (zipmap (keys basic-map) (map count (vals basic-map)))))","user":"5d42c88ae4b05dd059a5437e"},{"code":"reduce (fn [acc f] (assoc acc f (inc (get acc f 0)))) {}","problem":55,"user":"4fe8da4de4b0547ebccb2429"},{"problem":55,"code":"(fn count-occurs\n  [xs]\n  (reduce \n     (fn [m k] \n       (if-let [[k v] (find m k)]\n         (assoc m k (inc v))\n         (assoc m k 1))) \n     {} xs))","user":"5553b729e4b0deb715856e05"},{"problem":55,"code":"(fn p55[col]\n  (apply merge (map \n   (fn [x] {(key x) (count (val x))})\n   (group-by identity col))\n  ))","user":"52ab61f5e4b0c58976d9ac75"},{"problem":55,"code":"(fn [xs]\n  (let [grp (group-by identity xs)]\n    (reduce (fn [acc [k v]]\n              (assoc acc k (count v))) {} grp)))","user":"54133900e4b01498b1a719de"},{"code":"(fn my-freq [xs]\n    (apply merge-with + (for [x xs] {x 1})))","problem":55,"user":"4f0660ee535dcb61093f6c0d"},{"code":"(fn [coll]\r\n  (apply hash-map\r\n         (mapcat (fn [key]\r\n                    [key (count (filter (fn [value]\r\n                                          (= key value))\r\n                                        coll))])\r\n                 (set coll))))","problem":55,"user":"4dbb1126535d1e037afb21b3"},{"problem":55,"code":"#(into {} (map\n    (fn [[k v]] [k (count v)])\n    (group-by identity %)))","user":"5f58db95e4b0a0bc16850a9a"},{"problem":55,"code":"reduce #(assoc %1 %2 (inc (or (get %1 %2) 0))) {}","user":"54dae16de4b024c67c0cf758"},{"code":"(fn [coll]\n    (into {} (map (fn [[k v]] [k (count v)])\n              (seq (group-by identity coll))\n              ))\n    )","problem":55,"user":"4fe8a3bde4b07c9f6fd12c61"},{"problem":55,"code":"(fn[x]\n (into {}\n  (reduce concat\n   (map\n    (fn[y]\n     {(first y) (count y)}\n    ) \n    (partition-by identity (sort x))\n   )\n  )\n )\n)","user":"54283a7ae4b01498b1a71b2f"},{"code":"(fn [col] \n  (reduce \n    #(let [c (%1 %2)\n           n (if c (inc c) 1)]\n       (assoc %1 %2 n))\n    {} col))","problem":55,"user":"4eb01df4535d7eef30807337"},{"code":"#(apply merge (for [i (group-by identity %)]\n               {(first i) (count (last i))}))","problem":55,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":55,"code":"(fn [coll]\n   (apply merge (map\n      (fn [[k v]] {k (count v)})\n      (group-by #(identity %) coll))))","user":"56e4a6c1e4b03a7c14b85a51"},{"problem":55,"code":"(fn [xs]\n             (reduce (fn [a v] (assoc a v (inc (get a v 0)))) {} (vec xs)))","user":"4edee6a2535d10e5ff6f533e"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (let [distinct-items (distinct coll)]\n    (apply hash-map (reduce concat (map (fn [distinct-item]\n           (vector distinct-item (count (filter #(= % distinct-item) coll))) \n       ) distinct-items)))\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"code":"(fn ocru [coll]\n  (persistent! \n   (reduce \n    (fn [result x] (assoc! result x (inc (or (result x) 0))))\n    (transient {}) coll)))","problem":55,"user":"5098f5d6e4b0cae2931060a4"},{"problem":55,"code":"#(apply merge-with + (map (partial assoc {}) % (repeat 1)))","user":"55c6fd60e4b0e31453f649c9"},{"code":"(fn [col] (into {} (map (fn [[v vs]] [v (count vs)]) (group-by identity col))))","problem":55,"user":"531f1e63e4b08068f379edc2"},{"code":"#(reduce (fn [m v] (update-in m [v] (fnil inc 0))) {} %)","problem":55,"user":"50052d38e4b0678c553fc45c"},{"problem":55,"code":"#(->> %\n      sort\n      (group-by identity)\n      (map (fn [[k v]] [k (count v)]))\n      (into {}))","user":"5a9181c5e4b002d099cae6f6"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [acc elem]\n     (let [cnt (get acc elem 0)\n           cnt (inc cnt)]\n       (assoc acc elem cnt)\n       )\n     )\n    {}\n   s\n   )\n  )","user":"56fbe0cce4b07572ad1a88d8"},{"code":"#(into {} (map (fn [[v k]] [v (count k)]) (group-by identity %)))","problem":55,"user":"4f4d7b8fe4b03ad3f0c10ca9"},{"code":"(fn \n  [xs]\n  (reduce\n   (fn [acc x]\n     (let [val (get acc x 0)]\n       (assoc acc x (inc val))))\n   {} xs))","problem":55,"user":"504e90bae4b069badc5a33b8"},{"problem":55,"code":"reduce (fn [accum x] (assoc accum x (inc (get accum x 0)))) {}","user":"58740c18e4b01531a375ea49"},{"code":"(fn [s] (reduce #(update-in %1 [%2] (fn [e] (if (nil? e) 1 (inc e)))) {} s))","problem":55,"user":"4fb4b798e4b081705acca2af"},{"code":"(fn fq [s]\r\n  ( reduce #(merge-with + %1 {%2 1}) {} s)\r\n  )","problem":55,"user":"4febb4dae4b0681fd128dc98"},{"problem":55,"code":"(fn [xs]\n    (apply (partial merge-with #(+ %1 %2))\n           (map #(hash-map %1 1) xs)))","user":"505223fae4b0a561d07d8f17"},{"code":"(fn [col]\n  (apply merge-with + (map (fn [e] (hash-map e 1)) col)))","problem":55,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn[l](into {} (map (fn [x] [x (count (filter (partial = x) l))]) (set l))))","problem":55,"user":"4ddbd934535d02782fcbe9fc"},{"problem":55,"code":"(fn [x]\n  (apply merge-with + (for [item x] {item 1})))","user":"5ac4d1f6e4b0e27600da7735"},{"problem":55,"code":"(fn ! [s]\n  (reduce #(assoc %1\n             \t  %2\n                  (inc (let [v (get %1 %2)]\n                         (if (nil? v) 0 v)))\n             )\n          {}\n          s))","user":"54c271b9e4b045293a27f602"},{"problem":55,"code":"(fn [s]\n\t(reduce\n\t\t(fn [result v]\n\t\t\t(if (contains? result v)\n\t\t\t\t(assoc result v (inc (get result v)))\n\t\t\t\t(conj result [v 1])\n\t\t\t)\n\t\t)\n\t\t{}\n\t\ts\n\t)\n )","user":"5559b443e4b0deb715856e3c"},{"code":"#(apply merge-with + (map (fn [x] {x 1}) %))","problem":55,"user":"4ea57300535d7eef308072d5"},{"code":"#(loop [l %\n        f (first (vec (set %)))\n        r (rest (vec (set %)))\n        v []]\n  (if-not (= f nil)\n    (recur l (first r) (rest r) (conj v \n                                  (loop [lf (first l) lr (rest l) c 0]\n                                    (if-not (= lf nil)\n                                      (if (= lf f)\n                                        (recur (first lr) (rest lr) (inc c))\n                                        (recur (first lr) (rest lr) c))\n                                      c))\n                                    ))\n  (zipmap (reverse (vec (set l))) (reverse v))))","problem":55,"user":"4e9e7ce3535dbda64a6f6b98"},{"problem":55,"code":"(fn [coll]\n  (->> (group-by identity coll)\n       (reduce-kv #(assoc %1 %2 (count %3)) {})))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [s]\n    (letfn [(accum [m x]\n              (assoc m x (inc (get m x 0))))]\n      (reduce accum {} s)))","problem":55,"user":"5165a235e4b079ad97ec44ac"},{"problem":55,"code":"(fn [s] (reduce #(assoc %1 %2 (+ (get %1 %2 0) 1)) {} s))","user":"564a5a09e4b0284900eef656"},{"code":"(fn [coll] \n  (into {} \n        (map #(hash-map (first %) (count %)) (partition-by identity (sort coll)))))","problem":55,"user":"52a5f1e6e4b0c58976d9abf4"},{"code":"(fn count-occs\n  [xs]\n  (reduce (fn [m x]\n           (assoc m x (if-let [c (m x)] (inc c) 1)))\n          {}\n          xs))","problem":55,"user":"52d95491e4b09f7907dd13a4"},{"code":"(fn [coll]\n  (apply array-map (mapcat identity (merge (map (fn [[k v]] [k (count v)]) (group-by identity coll))))))","problem":55,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":";(fn [sarg]\n;     (loop [s sarg,\n;            ret {}]\n;       (if (seq s)\n;         (do (println s ret)\n;           (recur (rest s)\n;                  (assoc ret\n;                         (first s)\n;                         (inc (get ret (first s) 0)))))\n;         ret)))\n#(->> %\n      (group-by identity)\n      (map (fn [[k v]] [k (count v)]))\n      (into {}))","problem":55,"user":"4ee26f01535d10e5ff6f5368"},{"problem":55,"code":"(fn count-occ [lst] (reduce (fn count-inner [m k] (assoc m k (inc (get m k 0))) ) {} lst))","user":"56912f93e4b0dcc4269f40ef"},{"code":"(fn cnt\n  [s]\n   (reduce (fn [c e]\n             (assoc c e (inc (get c e 0))))\n           {} s))","problem":55,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn [seq]\n  (reduce (fn [m x]\n            (assoc m x (inc (get m x 0))))\n          {}\n          seq))","problem":55,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn [coll]\n\t   (let [gp (group-by identity coll)]\n\t      (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"4f320253e4b0d6649770a08d"},{"code":"(fn [l]\n  (apply merge \n  (map\n  (fn [a]\n    {a (count (filter #(= % a) l))}\n  )\n  l\n  ))\n)","problem":55,"user":"4f1595da535d64f603146444"},{"problem":55,"code":"#(reduce conj (map (fn [w] {w\n                (count (filter (partial = w) %))\n                })\n   (set %)))","user":"5d99dc47e4b0d3f9b434ad42"},{"code":"(fn my-grouping [coll]\n  (loop [coll coll state {}]\n    (if (empty? coll) state\n      (let [h (first coll) t (rest coll)]\n        (if-let [counter (get state h)]\n          (recur t (conj state [h (inc counter)]))\n          (recur t (conj state [h 1])))))))","problem":55,"user":"52fc34cee4b047fd55837015"},{"problem":55,"code":"#(into {} (map (fn [[x xs]] [x (count xs)]) (group-by identity %)))","user":"5a6af090e4b0512ff01cda2d"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [ma next-val] (assoc ma next-val\n                              (inc (get ma next-val 0))))\n          {}\n          coll))","user":"52d38c51e4b099d49816f0c5"},{"problem":55,"code":"(fn [x]\n  (let [k (distinct x) ]\n  (zipmap k (map (fn[z](count (filter #(= z %) x ))) k))))","user":"54e345a1e4b024c67c0cf7db"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [hm x]\n              (if (hm x)\n                (assoc hm x (inc (hm x)))\n                (assoc hm x 1)))\n            {}\n            coll))","user":"5d52ea90e4b0776584bd6f6c"},{"code":"#(reduce \n  (fn [m x] \n    (if (not (m x))\n      (assoc m x 1)\n      (update-in m [x] inc)))\n  {}\n  %\n)","problem":55,"user":"5089ebfee4b03217b26a539f"},{"problem":55,"code":"(fn myfn [list]\n (zipmap (map first (partition-by identity (sort list) ))\n  (map count (partition-by identity (sort list) ))\n )\n)","user":"5bc2df19e4b07a9b28b10038"},{"problem":55,"code":"(fn [coll]\n  (let [partitioned-coll (partition-by identity (sort coll))\n        count-list (map count partitioned-coll)]\n    (into {}(map (fn [%1 %2] [(first %1) %2]) partitioned-coll count-list))))","user":"53b05a36e4b047364c044481"},{"code":"(fn my-freqs [coll]\n  (loop [ret []\n         [h & remaining] coll]\n    (let [matches (filter #{h} remaining)]\n      (if-not h\n        (into {} ret)\n        (recur (conj ret [h (inc (count matches))]) (remove #{h} remaining))))))","problem":55,"user":"5054c853e4b0b1b9d1860eb3"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [counts x]\n            (assoc counts x (inc (get counts x 0)))) {} coll))","user":"51441ce7e4b0b4fb4ace5f41"},{"problem":55,"code":"(fn  [coll]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn   [xxx]\n\n\n  (loop [c-seq xxx\n         final-map '()]\n    (if (empty? c-seq)\n      ( (fn [coll] (apply hash-map (mapcat #(if (sequential? %) % [%]) coll))) final-map)\n      (let [cur-itm (first c-seq)\n            rest-seq (rest c-seq)]\n        (recur rest-seq (  (fn [coll key]\n\n  (if (contains? coll key)\n    (do\n      (  (fn [coll key]\n  (map #(if (= (first %) key)\n          (list (first %) (+ (second %) 1))\n          %) (seq coll)))\n coll key))\n    (do\n      (conj (seq coll) (list key 1)))))\n ( (fn [coll] (apply hash-map (mapcat #(if (sequential? %) % [%]) coll))) final-map) cur-itm))))))","problem":55,"user":"523288fee4b035af41902a88"},{"problem":55,"code":"#(reduce (fn [acc e] (assoc acc e (inc (acc e 0)))) {} %)","user":"59f4c9c8e4b0966464fe6ab8"},{"code":"(fn [s] (reduce #(assoc % %2 (if-let [c (% %2)] (inc c) 1))\n                 {}\n                 s))","problem":55,"user":"4ee88bfb535d93acb0a66881"},{"problem":55,"code":"(comp (partial into {}) (partial map (fn [[k v]] [k (count v)])) (partial group-by identity))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":55,"code":";; reduce #(update %1 %2 (fnil inc 0)) {} : update is not available here\n\nreduce #(assoc %1 %2 (inc (%1 %2 0))) {}","user":"606b16b8e4b069485764ddf7"},{"problem":55,"code":"(fn my-frequencies [coll]\n       (loop [ret {} x coll]\n          (if (empty? x) ret\n             (recur\n                (if (get ret (first x)) (update-in ret [(first x)] inc)\n                     (into ret {(first x) 1}))\n                (rest x)))))","user":"573940e3e4b0cd1946bd106b"},{"code":"(fn [i] (reduce #(assoc % %2 (inc (get % %2 0))) {} i))","problem":55,"user":"4dc78527535d8a4b2fd7428f"},{"problem":55,"code":"(fn [col]\n  (reduce\n    (fn [res item]\n      (update-in res [item] (fnil inc 0)))\n    {}\n    col))","user":"53a83c74e4b047364c044426"},{"code":"(fn [s] (into {} (for [[k v] (group-by identity s)] [k (count v)])))","problem":55,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":55,"code":"#(loop [out {} in %] (let [k (first in) v (get out k 0)] (if (empty? in) out (recur (into out {k (inc v)}) (rest in)))))","user":"57f9e0bce4b0d3187e900956"},{"problem":55,"code":"#(reduce (fn [init m] (conj init [(key m) (count (val m))] )) {}  (group-by identity %))","user":"570794d8e4b0b0fb43fd068b"},{"problem":55,"code":"#(let [coll %1\n       f (fn [result item] (assoc result item (inc (result item 0))))]\n   (reduce f {} coll))","user":"5b4fef74e4b02d533a91bcde"},{"code":"(fn [x] (into {} (map (fn [y] (vector (first y) (count (second y)))) (group-by identity (sort x)))))","problem":55,"user":"5296008fe4b02ebb4ef7502a"},{"code":"(fn [col]\n  ((fn [l now-map]\n     (if (not (seq l))\n       now-map\n       (let [first-item (first l)\n             new-list (rest l)\n             item-val (get now-map first-item)\n             new-map-to-merge (if item-val\n                                {first-item (inc item-val)}\n                                {first-item 1})\n             new-map (merge now-map new-map-to-merge)\n             ]\n         (recur new-list new-map)\n       )\n     )\n   ) col {})\n)","problem":55,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":55,"code":"(fn [s] (let [d (distinct s) dic (zipmap d (take (count d) (repeat 0)))]\n  (reduce #(update-in %1 [%2] inc) dic s)))","user":"58ec8c7ae4b056aecfd47d64"},{"problem":55,"code":"(fn [v]\n  (reduce #(if\n             (contains? %1 %2)\n             (update-in %1 [%2] inc)\n             (assoc %1 %2 1))\n          {}\n          v))","user":"5b85221ce4b047b03b2037c8"},{"problem":55,"code":"(fn [s] (apply conj (map #(hash-map (first %) (count (last %))) (group-by identity s))))","user":"54dbcbbde4b024c67c0cf774"},{"problem":55,"code":"(fn [s]\n  (into {} (map (fn [[a b]] (vector a (count b))) (group-by identity s))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":55,"code":"(fn [s] \n    (reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} s))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":55,"code":"#(apply hash-map (interleave\n (keys (group-by identity %))\n (map count(vals (group-by identity %)))))","user":"532a033be4b09d4e7a9b551f"},{"code":"(fn [as]\r\n   (letfn [(fnil [f d] (fn [x] (if (nil? x) (f d) (f x))))]\r\n     (reduce (fn [m x] (update-in m [x] (fnil inc 0))) {} as)))","problem":55,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":55,"code":"(fn my-frequencies\n  ([coll] (my-frequencies coll {}))\n  ([coll acc]\n   (if (empty? coll)\n     acc\n     (if (contains? acc (first coll))\n       (my-frequencies (rest coll) (assoc acc (first coll) (inc (acc (first coll)))))\n       (my-frequencies (rest coll) (assoc acc (first coll) 1))))))","user":"54125eeee4b01498b1a719d3"},{"code":"(fn [data] (loop [d data\n                  x {}]\n             (if (empty? d)\n               x\n               (recur (rest d)\n                      (if (= (get x (first d) \"missing\") \"missing\")\n                        (conj x [(first d) 1])\n                        (conj x [(first d) (inc (get x (first d)))]))))))","problem":55,"user":"50214ffae4b0ef1d2d4433bc"},{"problem":55,"code":"(partial reduce \n #(update-in %1 [%2] (fnil inc 0)) {})","user":"58acce0ae4b0005cfeb1a754"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 (get %2 0) (count (get %2 1))) {} (group-by identity coll)))","user":"53b71b94e4b047364c0444cd"},{"code":"#(apply hash-map (mapcat (fn [x] [(first x) (count (second x))]) (group-by identity %)) )","problem":55,"user":"52253004e4b01819a2de42fa"},{"code":"(fn [coll]\n  (reduce #(merge-with + % %2) (map #(hash-map % 1) coll)))","problem":55,"user":"50217818e4b00bba4502f7a7"},{"problem":55,"code":"(fn [c]\n  (let [m (group-by identity c)]\n    (reduce (fn [r [k v]] (assoc r k (count v))) {} m)))","user":"5ba75fdfe4b0a20761a23419"},{"problem":55,"code":"(fn [c]\n  (into {}\n        (map (fn [[k v]]\n               [k (count v)])\n             (group-by identity c))))","user":"580bd81ee4b0849f6811b711"},{"code":"#(into {}\n       (map (fn [[x s]] [x (count s)]) (group-by identity %)))","problem":55,"user":"51256b40e4b05d10e3e395f8"},{"problem":55,"code":"(fn frec [coll]\n  (let [uniq (seq (set coll))]\n    (reduce #(update-in %1 [%2] inc) \n            (apply hash-map (interleave uniq (repeat 0))) \n            coll)))","user":"558bb38fe4b0277789237631"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (loop [result {}\n         l coll]\n    (if (empty? l)\n      result\n      (recur (update-in result [(first l)] (fnil inc 0)) (rest l)))\n    ))","user":"5630fd6fe4b0bfe05bf1178b"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n   (group-by identity)\n   (map (fn [[k v]] {k (count v)}))\n   (apply merge)))","user":"55cb11e9e4b0e31453f649ff"},{"problem":55,"code":"(fn [m]\n  (into {} \n        (for [[k v] (group-by #(identity %) m)] \n             [k (count v)])))","user":"541ddadbe4b01498b1a71a84"},{"problem":55,"code":"(comp (partial into {})\n      (partial map (fn [[k v]] [k (count v)]))\n      (partial group-by identity))","user":"54764a8fe4b0c51c1f4d72a3"},{"problem":55,"code":"(fn [xs]\n  (let [m (group-by identity xs)]\n    (apply assoc {} (for [[k v] (seq m)\n                          x [k (count v)]]\n                      x))))","user":"4ea03f70535d7eef308072a1"},{"code":"(fn group_ [collect]\n  (loop [col collect,result {}]\n    (if (empty? col)\n        result\n        (let [\n              idx (first col),\n              n (get result idx 0)         \n              ]\n          (recur (rest col)\n                 (assoc result idx (inc n))\n          )\n        )\n    )\n  )\n)","problem":55,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [fs x]\n            (assoc fs x (inc (get fs x 0))))\n          {}\n          xs))","user":"5d27da09e4b092dab7f59c75"},{"problem":55,"code":"(fn [xs]\n   (into {} (map (fn [[k v]] { k (count v) })\n        (group-by identity xs))))","user":"5884e807e4b0f1effa3b76a6"},{"code":"(fn [xs]\n  (reduce #(if (nil? (get %1 %2)) (assoc %1 %2 1) (update-in %1 [%2] inc)) {} xs))","problem":55,"user":"5370f8ede4b0fc7073fd6ea2"},{"code":"(fn [s]\n  (reduce #(update-in % [%2] (fnil inc 0)) {} s))","problem":55,"user":"4fb79872e4b081705acca2d2"},{"code":"(fn \n  [x]\n  (loop [lis x f {}]\n    (cond \n     (empty? lis) f\n     (contains? f  (first lis)) \n     (recur \n      (rest lis) \n      (assoc f (first lis) (inc (f (first lis)))))\n     :else \n     (recur \n      (rest lis) \n      (assoc f (first lis) 1)))))","problem":55,"user":"4e920f44535dbda64a6f6afd"},{"code":"(fn [s] \n  (apply merge-with + (map #(hash-map % 1) s)))","problem":55,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"#(apply hash-map (interleave (keys (group-by identity %)) (map count (vals (group-by identity %)))))","problem":55,"user":"4fb591aee4b081705acca2c0"},{"problem":55,"code":"(fn [a-seq] (reduce \n             #(assoc %1 %2 (inc (%1 %2 0)))\n             {} a-seq))","user":"505d1b01e4b0e6aca564be04"},{"code":"(fn [li] (into {} (map #(hash-map (first %) (count %)) (partition-by identity (sort li)))))","problem":55,"user":"51c09719e4b0c9c82288293c"},{"problem":55,"code":"(fn freq [seq]\n  (->> seq \n       (group-by identity)\n       (reduce-kv (fn [m k v] (assoc m k (count v))) {})\n       ))","user":"516064e5e4b009fba0926e26"},{"problem":55,"code":"(fn\n  [xs]\n  (reduce (fn [m i] (assoc m i (inc (m i 0)))) {} xs))","user":"5785de4ce4b0ebec4cfb74e6"},{"problem":55,"code":"#(into {}\n      (map (fn [e] [(first e) (count (second e))]) (group-by identity %)))","user":"53ef3adfe4b0742d9025b0c9"},{"problem":55,"code":"(fn [col] (reduce #(if (contains? % %2) (assoc % %2 (inc (% %2))) (assoc % %2 1)) {} col))","user":"5a9ac061e4b0d174b936c7c1"},{"problem":55,"code":"(fn freq [coll]\n  (reduce-kv #(assoc %1 %2 (count %3))\n             {}\n             (group-by identity coll)))","user":"56c33ceae4b05cc29241ee89"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m e] (if (contains? m e)\n                      (assoc m e (inc (get m e)))\n                      (assoc m e 1)))\n          {}\n          coll))","user":"5fada7cce4b08cb800c85af5"},{"code":"#(apply merge-with + (map (fn[a] {a 1}) %))","problem":55,"user":"507c7c8be4b0b083f3ff82ef"},{"problem":55,"code":"(fn [x]\n  (reduce #(conj %1 {(first %2) (count %2)}) {} (partition-by identity (sort x))))","user":"563c48e7e4b0bfe05bf11832"},{"code":"(fn [a-list]\n  (apply assoc {}\n    (mapcat (fn [x] [x (count (filter #(= x %) a-list))])\n            (distinct a-list))))","problem":55,"user":"502a5e59e4b09e8f859a9fbc"},{"code":"(fn [coll]\n  (let [groups (group-by identity coll)]\n    (zipmap (map key groups) (map #(count (val %)) groups))))","problem":55,"user":"53778b90e4b06839e8705e36"},{"problem":55,"code":"#(reduce-kv (fn [acc k v]\n             (assoc acc k (count v))\n             ) {} (group-by identity %))","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn [col]\n  \t   (reduce #(assoc %1 %2 (inc (get %1 %2 0)) ) {} col))","problem":55,"user":"4dfd7ecf535d04ed9115e783"},{"problem":55,"code":"(fn [vs](reduce #(update-in %1 [%2] (fnil inc 0)) {} vs))","user":"5481be5fe4b0e286459a1172"},{"problem":55,"code":"(fn [s]\n    (let [g (vals (group-by identity s))]\n      \n\n      (zipmap (map first g) (map count g))))","user":"53da2839e4b0e771c3025489"},{"code":"(fn [c] (loop [col c ret {}] (if (empty? col) ret  \r\n                                    (let [item  (ret (first col))]\r\n                                    (recur (rest col)\r\n                                           (if (nil? item) (assoc ret (first col) 1) (assoc ret (first col) (inc item)) )  \r\n                                       )))))","problem":55,"user":"50463347e4b011c5dfee771e"},{"problem":55,"code":"(fn freqs [coll]\n  (reduce (fn [acc x] (update-in acc [x] #(inc (if (nil? %) 0 %)))) {} coll))","user":"54a96a15e4b09f271ff37cad"},{"problem":55,"code":"#(into {} (map (fn [[k v]]\n         [k (count v)])\n         (group-by identity %)))","user":"59fd069ae4b01bb0ae8afcf4"},{"code":"(fn [s]\n      (loop [s s m {}]\n        (if (empty? s) m\n          (recur (rest s)\n            (if (contains? m (first s)) (update-in m [(first s)] inc)\n              (assoc m (first s) 1)))))\n\n    )","problem":55,"user":"5029fccee4b023940c84aa47"},{"problem":55,"code":"#(into {} (map (fn [x] (vector (key x) (count (val x))))\n               (group-by identity %)))","user":"5012da69e4b0c8732600222d"},{"problem":55,"code":"(fn [coll] (reduce\n    (fn [counts x] (assoc counts x (inc (get counts x 0)))) {}\n    (sort coll)))","user":"5272645de4b03e8d9a4a742c"},{"code":"#((fn [freq-map] (zipmap (keys freq-map) (map count (vals freq-map)))) (group-by identity %))","problem":55,"user":"4f8c4ee8e4b02e764a0a5194"},{"problem":55,"code":"(fn [s] (into {} (map #(vector (first %) (count %))\n                      (partition-by identity (sort s)))))","user":"57539e04e4b02ea1147992ab"},{"problem":55,"code":"(fn [xs] (apply merge-with (fn [acc o] (inc acc)) (map #(hash-map % 1) xs)))","user":"58ee84e5e4b056aecfd47dab"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [counts x]\n            (assoc counts x (inc (counts x 0))))\n          {} coll))","user":"540c6a8ae4b0addc1aec6702"},{"code":"(fn [x]\n  (reduce #(assoc % (first %2) (count (second %2)))\n          {}\n          (group-by identity x)))","problem":55,"user":"4f6fd91ae4b07046d9f4efed"},{"code":"(fn stat \n[s]\n   (let \n   [\n   parted (partition-by identity (sort s))\n   counts (map count parted)\n   itemz (map first parted)\n   pairs (interleave itemz counts)\n   ]\n   (apply hash-map pairs)\n   )\n   \n)","problem":55,"user":"4f0df199535d0136e6c2231e"},{"problem":55,"code":"(fn [v]\n  (let [m (map (fn [x] {x 1}) v)]\n    (apply merge-with + m)))","user":"550e52dbe4b06e50f9beb165"},{"problem":55,"code":"#(let [d (group-by identity %)\n       k (keys d)\n       v (vals d)]\n   (zipmap k (map count v)))","user":"54965534e4b0b312c081ff65"},{"code":"#(letfn [\n  (freq [s c]\n    (if (empty? s)\n      c\n      (let [f (first s)]\n        (recur (rest s) (assoc c f (inc (get c f 0)))))))]\n  (freq % {}))","problem":55,"user":"4e8f4f64535d65386fec2149"},{"code":"(fn [xs]\r\n  (apply hash-map\r\n    (apply concat\r\n      (map #(list % (count (filter #{%} xs)))\r\n           (set xs)\r\n      )\r\n    )\r\n  )\r\n)","problem":55,"user":"4f1b92d1535d64f60314647b"},{"problem":55,"code":"(fn [lst]\n  (->> lst                                                                                                                                                                                             \n       (group-by identity)                                                                                                                                                                                         \n       (map (fn [[k v]] [k (count v)]))                                                                                                                                                                            \n       (into {})))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"code":"(fn [v]\n  (into {}\n    (map (fn [p]\n      {(first p) (count (second p))})\n    (group-by\n      (fn [a] a)\n      v))))","problem":55,"user":"4f16d6ed535d64f60314644f"},{"code":"(fn ci [l]\n  (let [vars (set l)]\n    (reduce conj\n    (for [i vars]\n      {i (count (filter #(= i %) l))}))))","problem":55,"user":"5273e006e4b03e8d9a4a7495"},{"problem":55,"code":"(fn [col]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} col))","user":"545e7ab0e4b01be26fd7467c"},{"problem":55,"code":"(fn __ [aseq]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} aseq)\n)","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":55,"code":"(fn my-frequencies\n  ([coll] (my-frequencies coll {}))\n  ([coll freq-map]\n    (if (empty? coll)\n      freq-map\n      (if (contains? freq-map (first coll))\n        (my-frequencies (rest coll) (update-in freq-map [(first coll)] inc))\n        (my-frequencies (rest coll) (assoc freq-map (first coll) 1))))))","user":"540271aee4b0df28a13c62d0"},{"problem":55,"code":"#(->> (group-by identity %) (map (fn [[k v]] {k (count v)})) (apply merge))","user":"5e300655e4b05b4b01516209"},{"code":"(fn [x] (reduce #(assoc % (first %2) (count %2)) {} (partition-by identity (sort x))))","problem":55,"user":"4f2c593ee4b0d6649770a053"},{"code":"(fn freq [coll]\n  (reduce #(assoc % %2 (inc (get % %2 0))) {} coll))","problem":55,"user":"523b82efe4b07becd5be21f0"},{"problem":55,"code":"#(into {} (map (fn [coll] [(first coll) (count (second coll))]) (group-by identity (sort %))))","user":"5b37a3b4e4b02d533a91bba9"},{"code":"(fn [coll]\r\n  (reduce\r\n    (fn [c o] (assoc c o (inc (get c o 0))))\r\n    {}\r\n    coll))","problem":55,"user":"4e02bee8535d04ed9115e791"},{"problem":55,"code":"(fn freqs [s]\n  (let [m (group-by (fn [x] x) s)]\n    (zipmap (keys m) (map count (vals m)))))","user":"53ff8c31e4b0de5c41848603"},{"problem":55,"code":"(fn occ-count\n  [se]\n  (loop [se se\n         hmap (hash-map)]\n    (if (empty? se) hmap\n      (recur (rest se) (update-in hmap\n                                  [(first se)]\n                                  (fn [x] (if (number? x) (inc x)\n                                            1)))))))","user":"554d386ee4b0a04f792995b8"},{"problem":55,"code":"(fn [x] (reduce #(if-let [v (get %1 %2)] (assoc %1 %2 (inc v)) (assoc %1 %2 1)) {} x))","user":"57dafe97e4b0bd073c20241c"},{"code":"reduce \n  #(assoc % %2 (inc (get % %2 0)))\n  {}","problem":55,"user":"4ec7c32c535d6d7199dd36e6"},{"problem":55,"code":"(fn [coll]\n(into {} (for [[k v] (group-by identity coll)] [k (count v)])))","user":"5594e0e3e4b0c79f6e1db95b"},{"code":"(fn count-freqs [s]\n  (reduce (fn [a e]\n            (let [freq (or (a e) 0)]\n              (assoc a e (inc freq))))\n          {}\n          s))","problem":55,"user":"50a7ef7fe4b090657f4a5ce0"},{"code":"#(into {} \n       (map (juxt first count)\n            (partition-by identity (sort %))\n       )\n )","problem":55,"user":"52774dd2e4b03e8d9a4a74ff"},{"problem":55,"code":"(fn [aa]\n  (into {}\n        (for [a (group-by identity aa)]\n          [(first a) (count (second a))])))","user":"4ed90014535d10e5ff6f52fe"},{"code":"(fn [coll] (reduce (fn [accum el] (if (nil? (accum el)) (assoc accum el 1) (assoc accum el (inc (accum el))))) {} coll))","problem":55,"user":"533ee560e4b085b17e897d98"},{"code":"(fn [coll]\n  (reduce (fn [m k]\n            (assoc m k\n                   (if-let [n (m k)] (inc n) 1)))\n          {}\n          coll))","problem":55,"user":"4e8c1d97535d65386fec2127"},{"code":"reduce #(if (%1 %2)\n           (update-in %1 [%2] inc)\n           (merge %1 {%2 1})\n           )\n        {}","problem":55,"user":"52ba2af3e4b07a9af57922cc"},{"problem":55,"code":"(fn [x] (apply merge-with + (for [i x] {i 1})))","user":"54dbc6ebe4b024c67c0cf773"},{"problem":55,"code":"#(reduce (fn [m e] (assoc m e (inc (m e 0)))) {} %)","user":"5832be57e4b089d5ab817c86"},{"problem":55,"code":"(fn count_occurences [lst]\n  (reduce #(if (contains? %1 %2)\n             (assoc %1 %2 (inc (get %1 %2)))\n             (assoc %1 %2 1)) '{} lst))","user":"56df6351e4b0ca2494a095f3"},{"code":"(fn [lst]\n(reduce  (fn [m [k v]] (assoc m k (count v))) {} (group-by identity lst)))","problem":55,"user":"5124619ae4b02c3f2a072ccd"},{"code":"reduce (fn [c v]\r\n  (assoc c v (inc (get c v 0)))) {}","problem":55,"user":"4ddbdc1b535d02782fcbe9fd"},{"code":"(fn ejercicio-55 [xs]\n  (letfn [(cuenta-aux [xs c]\n            (if (empty? xs)\n              c\n              (cuenta-aux (rest xs) (actualiza (first xs) c))))\n          (actualiza [x c]\n            (assoc c x (inc (c x 0))))]\n    (cuenta-aux xs {})))","problem":55,"user":"4db51ce0535d87e67b28fe06"},{"code":"(fn [a-seq]\n  (loop [a-map {} elems a-seq]\n    (if (empty? elems) a-map\n      (recur (update-in a-map [(first elems)]\n                        (fnil + 0) 1)\n             (rest elems)))))","problem":55,"user":"4faa8de0e4b081705acca1f8"},{"problem":55,"code":"reduce #(if (contains? %1 %2) (update-in %1 [%2] inc) (conj %1 {%2 1})) {}","user":"5640b135e4b08d4f616f5ee8"},{"problem":55,"code":"(fn [coll]\n  (into {} (map (fn [[key val]] [key (count val)])\n                (group-by identity coll))))","user":"6020365ae4b0bf4ca6b10960"},{"problem":55,"code":"(fn [s]\n (->> s\n      (group-by identity)\n      (map #(hash-map (first %) (count (second %))))\n      (apply merge)))","user":"573a0ecce4b0cd1946bd1088"},{"code":"(fn [coll]\n  (reduce (fn [acc val]\n            (assoc acc val (inc (get acc val 0))))\n          {}\n          coll))","problem":55,"user":"4e80aa10535db62dc21a62b1"},{"code":"#(->>\n  %\n  (group-by identity)\n  (map (fn [[a b]] [a (count b)]))\n  (into {}))","problem":55,"user":"51efd397e4b0249c592fbdeb"},{"problem":55,"code":"(fn \n  [x]\n  (apply merge-with + (for [n x] {n 1})))","user":"5ac35d00e4b0e27600da7712"},{"problem":55,"code":"(fn [xs]\n   (reduce conj (let [ss (set xs)]\n     (for [s ss]\n       (hash-map s (count (filter #(= s %) xs)))\n  )\n)\n))","user":"53ca23e3e4b00fb29b2212c6"},{"problem":55,"code":"(fn [s]\n  (into {}\n    (map (fn [x] {x (count (filter #(= x %) s))}) \n         (distinct s))))","user":"56483f45e4b0284900eef62b"},{"code":"#(->> % (map (fn [c] {c 1})) (apply merge-with +))","problem":55,"user":"50ad7888e4b0a40c9cfb08c7"},{"problem":55,"code":"(fn [col]\n    (into {}\n      (map\n        (fn [[k v]] [k (count v)])\n        (group-by identity col)\n      )\n    )\n  )","user":"59021fede4b0438e51c2d04d"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [a x] (assoc a x (inc (get a x 0)))) {} coll))","user":"606a70a5e4b069485764ddf2"},{"problem":55,"code":"(fn [col] (apply merge (map (fn [[k v]] {k (count v)}) (group-by identity col))))","user":"54246fcce4b01498b1a71aed"},{"problem":55,"code":"(fn [xs]\n   (let [grp (group-by identity xs)] \n      (into {} (map vector (keys grp) (map count (vals grp))))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":55,"code":"(fn [coll] (->> coll (sort) (partition-by identity) (map (fn [x] [(first x) (count x)])) (into {})))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn [coll]\n  (reduce #(assoc %1 (key %2) (count (val %2))) \n    {} (group-by identity coll)))","problem":55,"user":"4eb51942535d7eef30807365"},{"problem":55,"code":"(partial reduce (fn [m k] (assoc m k (inc (get m k 0)))) {})","user":"559a9a3de4b066d22e731f45"},{"code":"(fn freq [s]\n  (let [m {}]\n    (reduce #(assoc %1 %2 (inc (get %1 %2 0))) m s)))","problem":55,"user":"4e0d5a5a535d04ed9115e7b5"},{"problem":55,"code":"#(reduce-kv (fn [a k v] (assoc a k (count v))) {} (group-by (fn [x] x) %))","user":"58c3af4de4b021aa9917ed1b"},{"problem":55,"code":"(fn\n  [coll]\n  (loop [result {}\n         [first & rest] coll]\n    (cond (nil? first) result\n          (not (contains? result first)) (recur (assoc result first 1)\n                                           rest)\n          :else (recur (assoc result first (inc (get result first)))\n                       rest))))","user":"5dd65ea4e4b0948ae9d9ad7f"},{"problem":55,"code":"(fn [s] (let [grouped (group-by identity (sort s))] (zipmap (keys grouped) (map count (vals grouped)))))","user":"5710140fe4b09c608db7042e"},{"problem":55,"code":"(fn[l] (apply merge \n        (map \n         \t#(hash-map (first %) (count (second %))) \n             (group-by identity l))))","user":"57b9fc74e4b0fbc9809a27fb"},{"problem":55,"code":"(fn f\n  [some-seq]\n  (reduce\n    (fn [new-seq, item]\n        (assoc new-seq item (if (new-seq item)\n                                (inc (new-seq item))\n                                1)))\n    {}\n    some-seq))","user":"5a35d515e4b0ddc586f153e1"},{"code":"(fn [xs]\n  (apply hash-map\n  (mapcat \n   #(vector (first %)\n            (count (second %)))\n   (group-by identity xs))))","problem":55,"user":"5269c150e4b03e8d9a4a71f8"},{"problem":55,"code":"(fn [in-s] (loop [rem-s in-s out-m {} current (first rem-s)]\n             (if (nil? current) out-m\n                                (recur (rest rem-s)\n                                       (assoc out-m current (if (nil? (get out-m current)) 1 (inc (get out-m current))))\n                                       (second rem-s)))))","user":"56baab13e4b0f26550335948"},{"code":"(fn fn55 [s]\n  (let [gb (group-by identity s)]\n    (zipmap (keys gb) (map count (vals gb)))))","problem":55,"user":"5125d963e4b05d10e3e395fe"},{"code":"(fn count-ocurrence\n  [s]\n  (reduce \n    (fn \n      [acc n]\n      (let [{e n} acc]\n        (if (nil? e)\n          (assoc acc n 1)\n          (assoc acc n (inc e)))))\n    {}\n    s))","problem":55,"user":"4fee04a0e4b0678c553fc308"},{"code":"#(into {} (for [[x y] (group-by identity %)] [ x (count y) ]))","problem":55,"user":"4e6b6294535d8ccf87e9ff11"},{"code":"(fn count-occurrences [l]\n  (letfn [(stop-condition [l] (= 0 (count l)))\n          (occurrences-iter [l occurrences]\n                            (if (stop-condition l)\n                              occurrences\n                              (occurrences-iter (rest l) (assoc occurrences (first l) (+ 1 (get occurrences (first l) 0))))))]\n    (occurrences-iter l {})))","problem":55,"user":"517531c6e4b07031762f2eea"},{"code":"(fn [coll]\n   (into {}\n         (map (fn [m] {(key m) (count (val m))})\n              (group-by identity coll))))","problem":55,"user":"506c0a02e4b0eda3100c090d"},{"code":"(fn [input]\n  (loop [l input freqs {}]\n    (if (empty? l)\n      freqs\n      (recur (rest l) \n             (conj freqs (if (freqs (first l)) \n                           [(first l) (inc (freqs (first l)))]\n                           [(first l) 1]))))))","problem":55,"user":"5341b141e4b00652c8746ecf"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m x]\n            (assoc m x\n              (if-let [n (m x)] (inc n) 1)))\n          {}\n          xs))","user":"4ff24a1ae4b0678c553fc337"},{"problem":55,"code":"(fn [coll]\n  (into {} (map #(hash-map (key %) (count (val %))) (group-by identity coll))))","user":"567695c2e4b05957ce8c6157"},{"problem":55,"code":"(fn [elems]\n    (into {} (map (fn [[k v]] [k (count v)]) (group-by identity elems))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":55,"code":"#(into {} \n\t(map (fn [[k v]] [k (count v)])\t(group-by identity (sort %))))","user":"54a11042e4b09f271ff37c49"},{"code":"(fn f [l]\r\n  (if (empty? l)\r\n    {}\r\n    (assoc (f (filter #(not= % (first l)) l))\r\n      (first l)\r\n      (apply + (map #(if (= % (first l)) 1 0) l)))))","problem":55,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn _ [[x & xs :as coll]]\n  (when-not (empty? coll)\n    (update-in (_ xs) [x] (fnil inc 0))))","problem":55,"user":"4e71705e535d5021c1a89649"},{"code":"(fn occs [s]\n  (let [i (group-by identity s)]\n    (zipmap (keys i) (map count (vals i)))))","problem":55,"user":"52ba43d0e4b07a9af57922cd"},{"problem":55,"code":"#(->> (group-by identity %)\n       (mapcat (fn [[k v]] [k (count v)]))\n       (apply hash-map))","user":"54db3d82e4b024c67c0cf75f"},{"code":"#(reduce (fn [x y]\n           (if (nil? (x y))\n             (assoc x y 1)\n             (assoc x y (inc (x y)))\n           )\n           )\n         {}\n         %)","problem":55,"user":"509b152be4b0412cdea6eb1e"},{"problem":55,"code":"(fn [coll]\n    (reduce conj \n            (map (fn [x]\n                   { x (count (filter  (partial = x) coll))}) coll)))","user":"5433a07be4b0b6b47310fce0"},{"code":"#(let [m (group-by identity %)]\n    (zipmap (keys m) (map count (vals m))))","problem":55,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":55,"code":"(fn [s]\n(reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} s)\n)","user":"57a9db97e4b0b8559636fc5b"},{"problem":55,"code":"(fn [s]\n   (reduce (fn [m x]\n             (if (m x)\n               (update-in m [x] inc)\n               (assoc m x 1))) {} s))","user":"585dbe41e4b0f14aab7c879f"},{"code":"(fn [s]\n  (let [vs (vals (group-by identity s))]\n    (zipmap (map first vs) (map count vs))))","problem":55,"user":"4f3d83b5e4b0e243712b1f69"},{"code":"(fn [seq]\n  (apply hash-map (mapcat #(list (first %1) (count (last %1))) (group-by identity seq))))","problem":55,"user":"51b7b521e4b0d906fcd71d3a"},{"problem":55,"code":"#(->> % (group-by identity) (reduce-kv (fn [m k v] (assoc m k (count v))) {}))","user":"5394aa77e4b0b51d73faaecd"},{"code":"#(into {} (map (fn [x] [(first x) (count x)]) (partition-by identity (sort %))))","problem":55,"user":"512d3304e4b040332b905b2d"},{"problem":55,"code":"#(reduce (fn [curr [key val]] (assoc curr key (count val))) {} (group-by identity %))","user":"5d828b7ee4b0915913b1d382"},{"code":"#(reduce\n           (fn [m x]\n             (let [a (m x)\n                   b (if (nil? a) 1 (inc a))]\n               (assoc-in m [x] b)))\n           (sorted-map) %)","problem":55,"user":"4e6ea1f5535d5021c1a8960e"},{"problem":55,"code":"(fn [col]\n  (reduce (fn [ac e]\n            (assoc ac e (inc (get ac e 0)))) {} col))","user":"5a624129e4b0512ff01cd987"},{"problem":55,"code":"(fn freq\n  ([seq] (freq seq {}))\n  ([[x & xs] ret]\n   (if (not x)\n     ret\n     (freq xs (update-in ret [x] #(if % (inc %) 1))))))","user":"554b7056e4b0a04f79299583"},{"code":"(fn [s]\n  (loop [s s a {}]\n    (if (empty? s) a\n        (recur (rest s) (assoc a (first s) (inc (or (get a (first s)) 0)))))))","problem":55,"user":"4f03d0fe535dcb61093f6b6d"},{"problem":55,"code":"(fn [s]\n  (apply merge-with +\n         (map #(hash-map % 1) s)))","user":"55995fa7e4b031d6649c9ba9"},{"problem":55,"code":"(fn [l]\n  (reduce \n    (fn [t v]\n      (assoc t v (inc (t v 0))))\n    {} l)\n  )","user":"51e6a2bce4b0ab43cc26c21d"},{"problem":55,"code":"(fn [c] \n  (->> c\n    (group-by identity)\n    (map #(vector (first %) (count (last %))))\n    (reduce #(apply assoc % %2) {})\n  ))","user":"52b434c9e4b0c58976d9ad1c"},{"code":"(fn [s] (reduce #(assoc % %2 (inc (% %2 0))) {} s))","problem":55,"user":"500159b3e4b0678c553fc419"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc [x c]]\n     (assoc acc x (count c)))\n   {}\n   (group-by identity coll)))","user":"5576f299e4b05c286339e077"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [accum value]\n                (update-in accum [value] #(inc (or % 0))))\n            {}\n            coll))","user":"5f331015e4b0574c87022c37"},{"problem":55,"code":"#(reduce (fn [accum, x]\n           (assoc accum x (inc (accum x 0))))\n         {}\n         %)","user":"56a38a4ce4b0542e1f8d14cc"},{"problem":55,"code":"(let [init-or-inc #(if (nil? %) 1 (inc %))]\n  (partial reduce #(assoc %1 %2 (init-or-inc (%1 %2))) {}))","user":"5ab5f60be4b073f177442643"},{"problem":55,"code":"(fn [s] (into {} (map #(vector (% 0) (count (% 1))) (group-by identity s))))","user":"53f77b6ae4b0de5c4184855f"},{"code":"reduce #(update-in % [%2] (comp inc (fn [i] (or i 0)))) {}","problem":55,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":55,"code":"(fn [l] (into {} (map (fn [[k v]] { k (count v)}) (group-by identity l))))","user":"56011393e4b04bb52996e178"},{"problem":55,"code":"(fn [lst]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} lst))","user":"55ede35ce4b0121d4835fde1"},{"code":"(fn count-occ [s]\n  (reduce (fn [acc [k v]] (assoc acc k (count v))) {} (seq (group-by identity s))))","problem":55,"user":"4f48f587e4b0d56e7bb92be2"},{"problem":55,"code":"#(let [m (group-by identity %)]\n   (into {} (for [k (keys m)] [k (count (m k))])))","user":"55eb026de4b0121d4835fdb7"},{"problem":55,"code":";; this is from the docs ^_^;;;\n;;(fn my-freq\n;;  [coll]\n;;  (persistent!\n;;   (reduce (fn [counts x]\n;;             (assoc! counts x (inc (get counts x 0))))\n;;           (transient {}) coll)))\n\n;; this isn't working... not sure why\n;;(fn [s]\n;;\t(->> (group-by identity s)\n ;;   \t (map (fn [s] {(first s) (count (second s))}\n ;;               ))))\n\n;;(fn [col] (->> col\n;;  (group-by identity)\n;;  (map #(vector (first %) (count (second %))))\n;;  (into {})))\n\n(fn [s]\n  (reduce (fn [m1 n] (merge-with + m1 {n 1})) {} s))\n\n \n;; Today I learned\n;; if you (inc nil) you will get a null pointer exception\n;; there is a function called `fnil`","user":"5fb68f09e4b08cb800c85b58"},{"problem":55,"code":"(fn [a]\n  (let [s (distinct a)]\n    (into {} (map #(vector % (count (filter #{%} a))) s))))","user":"593dfe60e4b069cdc2982bb1"},{"code":"#(reduce (fn [acc x]\n    (assoc acc x (inc (get acc x 0)))) {} %)","problem":55,"user":"4f0f36a7535d0136e6c22336"},{"code":"(fn [s]\n  (->> s\n       sort\n       (partition-by identity)\n       (map #(vector (first %) (count %)))\n       (into {})))","problem":55,"user":"5201ada5e4b0b2e020a18f14"},{"problem":55,"code":"#(->> % (group-by identity)  (reduce (fn [m [k v]] (assoc m k (count v))) {}))","user":"55632016e4b0c656e3ff17e4"},{"code":"#(reduce (fn [acc n]\n           (assoc acc n (inc (get acc n 0))))\n         {}\n         %)","problem":55,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":55,"code":"(fn count-occurrences2\n  [s]\n  (reduce #((fn update [m k f]\n              (assoc m k (f (get m k)))) %1 %2 (fnil inc 0) ) {} s))","user":"5c20b6abe4b07e362c230576"},{"code":"#(into {} (for [n (set %)] [n (count (filter (partial = n) %))]))","problem":55,"user":"53244c9de4b09d4e7a9b54db"},{"problem":55,"code":"(fn f\n  ([l] (f l {}))\n  ([l m]\n    (if (empty? l)\n      m\n      (f (next l)\n         (update-in m\n           [(first l)]\n           #(inc (or % 0)))))))","user":"50e5bca5e4b09ae9427b0e75"},{"problem":55,"code":"#(let [a (group-by identity %)]\n      (apply assoc {}\n             (interleave (keys a) (map count (vals a)))))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":55,"code":"#(->> %\n       (group-by identity)\n       (reduce (fn [v e]\n                 (-> v\n                     (conj (key e))\n                     (conj (count (val e)))\n                     )) [])\n       (apply assoc {})\n       )","user":"5a4b3abde4b05d388ecb6b81"},{"problem":55,"code":"(fn [xs] \n  (let [l (partition-by identity (sort xs))]\n   (apply hash-map (interleave (map first l) (map count l)))\n    ))","user":"58335c22e4b089d5ab817c9a"},{"problem":55,"code":"(fn [x] (->> x (group-by identity) (mapcat #(list (first %) (count (second %)))) (apply hash-map)))","user":"58844d43e4b0f1effa3b7696"},{"code":"(fn cnt [s]\r\n    (reduce (fn [m [k v]]\r\n              (assoc m k (count v)))\r\n            {}\r\n            (group-by identity s)))","problem":55,"user":"4f3e6244e4b0e243712b1f85"},{"problem":55,"code":"(fn [coll]\n  (->> (for [n (set coll)] [n (count (filter #(= % n) coll))])\n       (into {})))","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn [xs]\n  (into {} (map (fn [[k vs]] [k (count vs)]) (group-by identity xs))))","problem":55,"user":"50c9e5e3e4b0a409464667d7"},{"code":"#(let [m (group-by identity %)] \n(zipmap (keys m) (map count (vals m))))","problem":55,"user":"4e842ebb535db62dc21a62df"},{"code":"#(zipmap (distinct %)\n         (map count (vals (group-by identity %))))","problem":55,"user":"4eec82fe535d93acb0a668ae"},{"problem":55,"code":"(fn [c] (reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity c)))","user":"4e268c6e535deb9a81d77ef4"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc x]\n            (assoc acc x (inc (get acc x 0)))) {} coll))","user":"55088bb3e4b06e50f9beb10c"},{"code":"(fn [xs]\r\n  (apply hash-map (mapcat #(vector (first %) (count (second %))) (group-by identity xs))))","problem":55,"user":"4f251302e4b0d66497709ff0"},{"code":"(fn [coll]  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","problem":55,"user":"4ef7a483535dced4c769f258"},{"code":"(fn a [col] (into {}(for [part (partition-by identity (sort-by identity col))] (hash-map (first part) (count part)))))","problem":55,"user":"527a8eb7e4b03e8d9a4a755f"},{"code":"(fn\t[s]\t(apply merge (for [[k v] (group-by identity s)] {k (count v)})))","problem":55,"user":"5142ea50e4b0c172af7558ca"},{"code":"(fn [c]\n  (reduce\n    #(assoc % %2 (inc (% %2 0))) \n    {} c))","problem":55,"user":"4f410b63e4b0e243712b1fc5"},{"code":"(fn [m] (into {} (for [[k v] (group-by identity m)] [k (count v)])))","problem":55,"user":"50b9d991e4b04934c218a4a9"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [acc item]\n              (update-in acc [item] #((fnil inc 0) %)))\n            {}\n            coll))","user":"5ef8e9e0e4b09b61f08553cb"},{"problem":55,"code":"(fn [coll]\n    (let [hm (apply merge (map #(hash-map % 0) (distinct coll)))]\n      (reduce\n        (fn [mp i] (assoc mp i (inc (mp i))))\n        hm\n        coll)))","user":"5ccf99fbe4b0ccb0619628c8"},{"problem":55,"code":"(fn [xs] (reduce #(assoc %1 %2 ((fnil inc 0) (%1 %2))) {} xs))","user":"564b495de4b0284900eef667"},{"problem":55,"code":"#(into {}\n         (map (fn [[k v]] [k (count v)])\n              (group-by identity %)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":55,"code":"(fn [coll]\n   (into {} (map (fn [[k v]] [k (count v)])\n                 (group-by identity coll))))","user":"57b7de74e4b0fbc9809a27d4"},{"problem":55,"code":"(fn count-occurences\n  [coll]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} coll))","user":"5c92105ce4b048ec896c59f7"},{"problem":55,"code":"(fn [xs]\n  (let [m (group-by identity xs)]\n    (zipmap (keys m) (map count (vals m)))))","user":"54d127b7e4b0e8a36923e5de"},{"problem":55,"code":"#(into {} (vec (for [x (group-by (fn [x] x) %)]\n                 (vec (map-indexed (fn [index item]\n                                     (if (odd? index)\n                                       (count item)\n                                       item))\n                                   x)))))","user":"577bcbd9e4b0d3393e5deb1b"},{"problem":55,"code":"#(reduce-kv (fn [ret k v]\n              (assoc ret k (count v)))\n            {}\n            (group-by identity %))","user":"58e58ae9e4b056aecfd47c9a"},{"code":"(fn [l]\n  (->> l \n      (set)\n      (map \n       (fn [o]\n         {o (count \n              (filter #(= o %) l))}))\n      (into {})))","problem":55,"user":"51b793d3e4b0d906fcd71d38"},{"code":"(fn foo [l]\n  (reduce (fn [val coll]\n    (if (val coll)\n      (assoc val coll (+ 1 (val coll)))\n      (assoc val coll 1))) {} l))","problem":55,"user":"4f8b05d2e4b02e764a0a5176"},{"problem":55,"code":"(fn [x]\n    (into{} (->> (group-by identity x)\n                 (map (fn [[a b]] [a (count b)]))\n         \n                 )))","user":"5950f0bfe4b066ee0a44ae9f"},{"problem":55,"code":"(fn [s]\n  (into {} (map #(assoc {} (first %) (apply count (rest %)))\n                (group-by identity s))))","user":"57d1a0e6e4b0bd073c20236d"},{"code":"(fn [coll]\n  (into {}\n        (map #(vector (first %) (count %))\n             (partition-by identity (sort coll)))))","problem":55,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":55,"code":"(fn [li]\n  (let [raw (group-by identity (sort li))\n        f (fn [k] {(first k) \n                   (count (second k))})\n        cooked (map f raw)]\n    (reduce into {} cooked)))","user":"5054d243e4b0b1b9d1860eb5"},{"code":"(fn [s]\n                         (loop [s s\n                                freq {}]\n                           (if (seq s)\n                             (if (freq (first s))\n                               (recur (rest s) (assoc freq (first s) (inc (freq (first s)))))\n                               (recur (rest s) (assoc freq (first s) 1)))\n                             freq)))","problem":55,"user":"4e08fb7a535d04ed9115e7ac"},{"problem":55,"code":";;(prn (\n(fn [s] (apply merge\n          (map #(hash-map (first %) (count (second %)))\n               (group-by identity s))))\n;;                [1 1 2 3 3 1 4 1]))","user":"58566b42e4b0f14aab7c86f4"},{"problem":55,"code":"#(reduce (fn [d x] (let [c (get d x 0)] (into d {x (inc c)}))) {} %)","user":"5a16da30e4b0ff51aa4b31cc"},{"problem":55,"code":"(fn [s] (reduce (fn [m e] (assoc m e (inc (m e 0)))) {} s))","user":"5abe2fc2e4b073f17744271e"},{"problem":55,"code":"(fn [s]\n    (reduce (fn[acc b]\n        (assoc acc b (+ (get acc b 0) 1))\n    ) {} s)\n)","user":"5bfcdc52e4b0bdcf453d15f4"},{"code":"(fn\n  [x]\n  (let [gb (group-by #(identity %) x)]\n    (zipmap (keys gb) (map count (vals gb)))))","problem":55,"user":"4e333091535deb9a81d77f25"},{"problem":55,"code":"(fn [s]\n  (reduce #(conj %1 [(key %2) (count (val %2))]) {} (group-by identity s)))","user":"56228d00e4b03f08ee9a9227"},{"code":"(fn [coll]\n  (let [res (group-by identity coll)]\n    (zipmap\n     (keys res)\n     (map #(count (second %)) res))))","problem":55,"user":"5132c6f0e4b021281ec7b6d3"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [s e]\n     (update-in s [e] #(inc (or % 0))))\n   {}\n   coll))","user":"53d78b64e4b0e771c3025466"},{"problem":55,"code":"#(reduce (fn [r [k v]] (assoc r k (count v))) {} (group-by identity (sort %)))","user":"5510aa92e4b06e50f9beb188"},{"problem":55,"code":"(fn [col]\n    (->> col\n         (group-by identity)\n         (map (fn [[key val]] (vector key (count val))))\n         (into {})\n         ))","user":"5f0e8312e4b0f30dddfb5d5b"},{"problem":55,"code":"reduce (fn [mp elt] (if (= nil (get mp elt)) (assoc mp elt 1) (assoc mp elt (inc (get mp elt))))) {}","user":"5cc77807e4b0ccb061962838"},{"problem":55,"code":"(fn[l]\n  (into {} (for [[k v] (group-by identity l)] {k (count v)})))","user":"54651ef5e4b01be26fd746d5"},{"problem":55,"code":"#(let [c (group-by identity %)]\n   (zipmap (keys c) (map count (vals c))))","user":"5c1aadcde4b01240ff567209"},{"code":"#(reduce (fn [m [k v]] (merge m {k (count v)})) {} (group-by identity %))","problem":55,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn ! [s]\n  (let [m (group-by identity s) k (keys m) v (vals m)]\n    (zipmap k (map count v))))","problem":55,"user":"4e7d1c22535db169f9c796c5"},{"problem":55,"code":"#(into {} (map (fn [x] [x (count (filter (fn [y] (= x y)) %))]) (set %)))","user":"52ae886de4b0c58976d9acab"},{"problem":55,"code":"#(reduce (fn [ret x] (assoc ret x (inc (get ret x 0)))) {} %)","user":"544fbabce4b0e39780006999"},{"problem":55,"code":"(fn [coll]\n  (reduce \n   (fn [acc v]\n     (let [c (get acc v 0)]\n       (assoc acc v (inc c))))\n   {}\n   coll))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":55,"code":"(fn [xs]\n    (loop [m {} [h & t :as xs] xs]\n      (if xs\n        (recur (assoc m h (inc (m h 0))) t)\n        m)))","user":"58ec1e63e4b056aecfd47d54"},{"code":"reduce (fn [m n] (assoc m n (+ (get m n 0) 1))) {}","problem":55,"user":"4ee82223535d93acb0a66877"},{"problem":55,"code":"(fn [coll]\n  (into {}\n    (map (fn [e]\n           [e (count  (filter #{e} coll))]) (set coll))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":55,"code":"(fn [list]\n  (loop [l list\n         result {}]\n    (if (empty? l)\n      result\n      (let [fi (first l)\n            occ (inc (or (result fi) 0))]\n        (recur (rest l) (conj result {fi occ}))\n))))","user":"5954cea2e4b066ee0a44af0a"},{"code":"(fn [coll]\n  (reduce #(into %1 {(first %2) (count (second %2))}) {} (group-by identity coll)))","problem":55,"user":"51780f88e4b03d69594194c9"},{"code":"(fn [coll]\n  (reduce\n   (fn [out x]\n     (assoc out x (inc (out x 0))))\n   {}\n   coll))","problem":55,"user":"52dad8bde4b09f7907dd13be"},{"code":"(fn [coll] (into {} (map #(vector (first %) (count %)) (partition-by identity (sort coll)))))","problem":55,"user":"504c8165e4b09724c857af31"},{"code":"(fn [lst]\n(let [m (group-by (fn [v] v) lst)]\n  (zipmap (keys m) (map count (vals m)))))","problem":55,"user":"50c9ece0e4b0a409464667d8"},{"problem":55,"code":"#(apply hash-map \n         (interleave (distinct %) \n                     (map (fn [y] (count (filter (fn [x] (= x y)) %)))\n                          (distinct %))))","user":"53a5c7ffe4b0ef122a8689c4"},{"problem":55,"code":"(fn [c]\n   (into {} (for [x (set c)]\n      (vector x (reduce #(+ %1 (if (= x %2) 1 0)) 0 c)))))","user":"607bd80be4b0a637ed780379"},{"problem":55,"code":"(fn\n  [xs]\n  (reduce (fn\n            [acc x]\n            (if (contains? acc x)\n              (assoc acc x (inc (get acc x)))\n              (assoc acc x 1)))\n          {}\n          xs))","user":"5e1c24f4e4b0dc959400852d"},{"problem":55,"code":"#(reduce (fn [ret v] (assoc ret v (inc (or (ret v) 0)) ) ) {} %)","user":"5db7376fe4b010eb3c36cd43"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [acc [k v]] (assoc acc k (count v))) {} (group-by identity s)))","user":"55f5b8d6e4b06e875b46ce8d"},{"code":"#(reduce (fn [res [k v]] (assoc res k (count v)))\n         {}\n         (group-by identity %))","problem":55,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn [ l ] \n  (reduce \n    #( assoc %1 %2 (if (contains? %1 %2) (inc (%1 %2)) 1 ) ) \n    (cons {} l) ))","problem":55,"user":"4fc43a8ee4b081705acca346"},{"problem":55,"code":"(fn [xs] \n  (into \n   {} \n   (map \n    (fn [x] [(first x) (count (second x))]) \n    (group-by identity xs))))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn c [x]\n  (into {}  (map (fn [[k v]] [k (count v)]) (group-by identity x))))","problem":55,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":55,"code":"(fn [v] (into {} (map (fn [x] {x (count (filter #(= x %) v))}) (distinct v))))","user":"576d398be4b0979f8965155d"},{"code":"reduce #(update-in %1 [%2] (fn [x] (if x (inc x) 1))) {}","problem":55,"user":"53134005e4b08068f379ed07"},{"problem":55,"code":"(fn [xs]\n  (let [elements (distinct xs)]\n  (reduce (fn [result x] (assoc result x (count (filter #(= % x) xs)))) {} elements)\n))","user":"55d79b87e4b0e31453f64aa8"},{"code":"#(let [z (partition-by identity (sort %))]\n   (zipmap (map first z) (map count z)))","problem":55,"user":"5102489de4b00c483ae176f6"},{"problem":55,"code":"(fn [s] \n  (reduce \n    (fn [r e]\n      (assoc r e (inc (or (get r e) 0))))\n    {}\n    s))","user":"5989e080e4b021a7a535fed6"},{"code":"reduce #(assoc % %2 (+ (get % %2 0) 1)) \n        {}","problem":55,"user":"5005b57de4b0678c553fc46a"},{"code":"#(let [x (group-by identity %)]\n\t(apply hash-map (interleave (keys x) (map count (vals x)))))","problem":55,"user":"50e3e108e4b01912b3285c48"},{"problem":55,"code":"#(->> % #_[1 1 2 3 2 1 1]\n     (group-by identity)\n     (map (fn [[i xs]]\n            [i (count xs)]))\n     (into {}))","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":55,"code":"#(let [x %\n       a (group-by identity x)\n       b (map (fn [[k v]] [k (count v)]) a)\n       c (into {} b)\n       ]  \n   c)","user":"4ff4bed0e4b0678c553fc35f"},{"code":"#(loop [i %1 m {}]\n   (if (empty? i)\n     m\n   (let [f (first i)\n         v (m f)]\n     (recur (rest i) (assoc m f (if (nil? v) 1 (+ 1 v)))))))","problem":55,"user":"52c81954e4b0c2d177d6212e"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc item]\n            (if (acc item)\n              (assoc acc item (+ (acc item) 1))\n              (assoc acc item 1)))\n          {}\n          coll))","user":"59225498e4b09b4ee5954c8c"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m el] (update-in m [el] #(if % (inc %) 1))) {} coll))","user":"5169d422e4b051e2a73aba53"},{"problem":55,"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll)\n)","user":"59073e0fe4b047aa04b19950"},{"code":"(comp\n  #(into {} %)\n  #(for [[k v] %] [k (count v)])\n  #(group-by identity %))","problem":55,"user":"4f7f9665e4b033992c121bea"},{"problem":55,"code":"(fn [v]\n  (let [m (group-by identity v)]\n    (reduce #(update-in %1 [%2] count) m (keys m))))","user":"566b57e9e4b0a866af6896ad"},{"problem":55,"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0)))\n          {}\n          coll))","user":"58637221e4b0f14aab7c881d"},{"code":"(fn [vec] (loop [vec vec \n                 map {}]\n            (if (empty? vec)\n              map\n              (recur (rest vec) \n                     (update-in map [(first vec)] \n                                (fn [input] (if input (inc input) 1))\n                                )))))","problem":55,"user":"51d33b03e4b099f3b6acddfd"},{"code":"#(reduce\n    (fn [x i]\n      (assoc x i\n             (inc (x i 0)))) {} %1)","problem":55,"user":"4f089f1a535dcb61093f6c3c"},{"problem":55,"code":"(fn clj55 [s]\n  (reduce #(update-in % [%2] (fnil inc 0)) {} s))","user":"59d8f23ae4b0ef0a1e9b5c49"},{"code":"(fn [s] (apply merge-with + (map #(assoc {} % 1) s)))","problem":55,"user":"5256627ce4b0541d1855ba1a"},{"problem":55,"code":"#(let \n   [\n    groups (group-by identity %1)\n    items (keys groups)\n    counts (map count (vals groups))]\n   (zipmap items counts))","user":"5647dc44e4b0284900eef624"},{"problem":55,"code":"(fn ct [coll]\n  (let [c (group-by identity coll)\n        ks (into [] (keys c))]\n    ;;(pr :c c :ks ks)\n    ;;(for [k ks] (assoc! c k (count (get c k))))\n    ;;(map #((prn :% %) assoc! c % (count (get c %))) ks)\n\n    (into {} (map (fn x [a ]\n      ;;(pr :a (nth a 0) (count (nth a 1)))\n      ;;:b (nth b 0) (count (nth b 1)))\n      [(nth a 0) (count (nth a 1))]\n      ;;[(nth b 0) [(count (nth b 1))]]\n      ) c))))","user":"5972fcf6e4b01722bebd4c92"},{"code":"(fn [items]\n\t\t(reduce\n\t\t\t(fn [itemmap item]\n\t\t\t\t(let [count (get itemmap item 0)]\n\t\t\t\t\t(assoc itemmap item (inc count)))\n\t\t\t\t) {} items))","problem":55,"user":"51205867e4b0e88f5a20c40f"},{"problem":55,"code":"(fn my-freqs [coll]\n     (if-not (empty? coll)       \n       (let [k (first coll)\n             m (my-freqs (rest coll))]\n         (assoc m k (inc (get m k 0)) ))))","user":"548ade6de4b0e286459a11f6"},{"problem":55,"code":";; #(apply hash-map (mapcat (fn [x] [(first x) (count (second x))]) (group-by identity %)))\n#(letfn [(f [s m] (if (empty? s)\n                    m\n                    (f (rest s)\n                       (let [x (first s)]\n                         (assoc m x (inc (get m x 0)))))))]\n   (f % {}))","user":"54857e3be4b0e286459a11ad"},{"code":"(partial reduce (fn [a b] (let [v (get a b)]\n                            (assoc a b (if v (inc v) 1))))\n         {})","problem":55,"user":"51307b84e4b08c712d3fae39"},{"problem":55,"code":"(fn [coll] \n  (reduce (fn [x y] \n            (assoc x y (inc (x y 0)))) \n          {} \n          coll))","user":"5785de78e4b0ebec4cfb74e8"},{"code":"(fn [s]\n  (let [ k (set s),\n         cnt (fn [s x] (count (filter #(= x %) s)))]\n    (zipmap k (map (partial cnt s) k))))","problem":55,"user":"4ec56b5b535d6d7199dd369f"},{"problem":55,"code":"#(apply assoc {} (mapcat identity (map \n\t  (fn [v] (list (first v) (count (second v))))\n\t  (group-by identity %))))","user":"5fc1c424e4b0edf42a5593d0"},{"problem":55,"code":"#(->> (group-by identity %)\n      (map (fn [[k v]] [k (count v)]))\n      (into {}))","user":"5412ef7ee4b01498b1a719da"},{"code":"(fn [coll] (reduce (fn [counts-hash x] (assoc counts-hash x (inc (get counts-hash x 0)))) {} coll))","problem":55,"user":"52a360a3e4b04e0c58e87bfe"},{"problem":55,"code":"(fn my_freqs [x]\n (into {} \n   (for [[k v] (group-by #(identity %) x)] \n     [k (count v)])))","user":"5632b0a9e4b0bfe05bf117a8"},{"code":"(fn count-occ [items]\n  (loop [l items occ (zipmap items (repeat (count items) 0))]\n    (if (empty? l)\n      occ\n      (let [x (first l) xs (rest l)]\n        (recur xs (assoc occ x (inc (get occ x)))) )\n      )\n    )\n  )","problem":55,"user":"4e720985535d5021c1a89655"},{"problem":55,"code":"(fn [x] (reduce #(assoc %1 (key %2) (count (val %2))) \n                {} (group-by identity x)))","user":"542c2de0e4b0dad94371f29f"},{"problem":55,"code":"(fn[s]\n    ( loop [ freq-map {} rest-seq s]\n      ( if ( empty? rest-seq )\n        freq-map\n        ( if ( contains? freq-map (first rest-seq))\n          ( recur ( assoc freq-map (first rest-seq) ( inc (freq-map (first rest-seq)))) (rest rest-seq))\n          ( recur ( assoc freq-map (first rest-seq) 1) (rest rest-seq))\n        )\n      )\n    ))","user":"54fc7d89e4b07d26eda61d2b"},{"problem":55,"code":"(fn [m] (reduce (fn [res x]\n                   (assoc res x (inc (or (get res x) 0)))) {}  m))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":55,"code":"(fn [col]\n  (into {} (map #(vector (key %) (count (val %))) (group-by identity col))))","user":"5e44c804e4b01d43a70e8e89"},{"code":"(fn [l]\n  (into {}\n    (map\n      (juxt key #(count (val %)))\n      (group-by identity l))))","problem":55,"user":"503de5aae4b06c4e0e1fa259"},{"problem":55,"code":"(fn [coll] (->> (group-by identity coll)\n                (reduce-kv (fn [r k v] (assoc r k (count v))) {})))","user":"5a9bfd57e4b0d174b936c7d0"},{"problem":55,"code":"(fn [x] \n    (zipmap \n     (keys (group-by identity x)) \n     (map count (vals (group-by identity x)))))","user":"543d5c61e4b032a45b86934d"},{"code":"(fn count [c]\n  (loop [s (seq c)\n         table {}]\n    (if (empty? s)\n      table\n      (recur (rest s)\n             (update-in table\n                        [(first s)]\n                        (fn [v] (if (nil? v) 1 (inc v))))))))","problem":55,"user":"52f8f4d1e4b047fd55836fde"},{"code":"(fn [s]\r\n    (let [gg (group-by identity s)]\r\n      (reduce #(update-in %1 [%2] count) gg (keys gg)) ))","problem":55,"user":"4e8768f6535dceadca469850"},{"code":"(fn [xs]\n  (->> xs \n       (group-by identity)\n       (mapcat #(vec [(first %) (count (second %))]))\n       (apply hash-map)))","problem":55,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":55,"code":"#(loop [setNums (distinct %) startNums % resNums {}] \n    (if (> (count setNums) 0)\n      (recur (drop 1 setNums) startNums (assoc resNums (first setNums) (count (filter (fn [p] (= p (first setNums))) startNums))))\n      resNums\n      )\n      )","user":"55253799e4b0882d96d091cf"},{"problem":55,"code":"(fn freqs [coll]\n  (->> coll\n       (group-by identity)\n       (map #(vector (first %) (count (second %))))\n       (into (sorted-map))))","user":"5dc40814e4b02f9375f4e1ae"},{"problem":55,"code":"(fn occur\n  [coll]\n  (reduce-kv (fn [m k v] (assoc m k (count v))) {}\n   (group-by identity coll)))","user":"5785c1d4e4b0ebec4cfb74e1"},{"code":"(fn  [lst] \n  (let \n   [\n    uniques (set lst)\n    hm (zipmap uniques (repeat (count uniques) 0))\n    acum (fn [map_ key_] (assoc map_ key_ (+ 1 (map_ key_))))\n   ]\n  (reduce acum hm lst)))","problem":55,"user":"4f3c0c0fe4b0e243712b1f3d"},{"problem":55,"code":"(fn [lst] (->> lst sort (partition-by identity) (mapcat #(list (first %) (count %))) (apply hash-map)))","user":"5733e4aee4b0cd1946bd0ffe"},{"problem":55,"code":"(fn counter [coll]\n  (into {} (for [elem (set coll)]\n             [elem (count (filter #(= elem %) coll))])))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn [coll] (let [gp (group-by  identity coll)] (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"500d1db4e4b05f7c30cfa69f"},{"code":"(fn [c] \n  (reduce #(assoc % %2 (inc (get % %2 0))) {} c))","problem":55,"user":"4eccb190535d23f0362276fe"},{"problem":55,"code":"#(reduce (fn [acc [k v]] \n           (assoc acc k (count v))) \n         {} \n         (group-by identity %))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [v] \n  (reduce #(conj %1 {(first %2) (count %2)}) {} (partition-by identity (sort v))))","problem":55,"user":"532a111ee4b09d4e7a9b5520"},{"code":"(fn _frequencies [items]\n  (into {} (for [[id uniques] (group-by identity items)]\n                    [id (count uniques)])))","problem":55,"user":"510cd1dde4b078ea71921124"},{"problem":55,"code":"(fn \n  [seq]\n  (loop [l (partition-by identity (sort seq)) m {}]\n    (if (empty? l)\n      m\n      (recur (rest l) (assoc m (first (first l)) (count (first l)))))))","user":"5772ddb0e4b0979f896515d4"},{"problem":55,"code":"(fn [coll]\n  (let [membr (set coll)]\n    (into {}\n    (for [x membr\n      :let [n (count (filter #(= x %) coll))]]\n      {x n}))))","user":"550e8e04e4b06e50f9beb167"},{"problem":55,"code":"(fn count-occurrences [c]\n  (reduce #(if (contains? %1 %2) (assoc %1 %2 (inc (get %1 %2))) (assoc %1 %2 1)) {} c))","user":"57d57f65e4b0bd073c2023b3"},{"problem":55,"code":"reduce (fn [agg nxt] (if (contains? agg nxt) (assoc agg nxt (inc (agg nxt))) (assoc agg nxt 1))) {}","user":"6004c750e4b074f607df6645"},{"problem":55,"code":"(fn fq [s]\n  (let [ky (set s)]\n    (zipmap ky\n            (map (fn [k] (count (filter #(= k %) s))) ky))))","user":"53f053ebe4b0742d9025b0d3"},{"problem":55,"code":"(fn [items]\n  (->> items\n      (group-by identity)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"56897739e4b0dcc4269f407d"},{"problem":55,"code":"#(reduce \n  (fn [r [k v]] (into r {k (count v)}))\n  {} \n  (group-by identity %))","user":"576e3258e4b0979f89651574"},{"problem":55,"code":"(fn my-map[s] \n   (let [x (set s) y (map (fn my-count [n] (count (filter #(= n %) s))) x) z {}] \n     (reduce merge z (map (fn [i j] (hash-map  i j)) x y))\n      \n      ))","user":"52a4879ce4b0c58976d9abdb"},{"problem":55,"code":"#(reduce\n             (fn [res item]\n               (if (contains? res item)\n                 (assoc res item (inc (get res item)))\n                 (assoc res item 1)))\n             {}\n             %)","user":"5f5a2cc6e4b0a0bc16850aa4"},{"problem":55,"code":"(fn my-cntr\n  [coll]\n  (loop [c coll\n         m {}]\n    (if (> (count c) 0)\n      (recur (rest c) (merge m {(first c) (+ 1 (get m (first c) 0))}))\n      m)))","user":"58bd84d2e4b0888cdc949d31"},{"problem":55,"code":"reduce (fn [acc item] (if (get acc item)\n                        (assoc acc item (inc (get acc item)))\n                        (assoc acc item 1)))\n{}","user":"5771b155e4b0979f896515ba"},{"problem":55,"code":"(fn [v]\n  (loop [acc {} s v]\n    (if (empty? s)\n      acc\n      (recur (if (contains? acc (first s))\n               (update-in acc [(first s)] inc)\n               (conj acc {(first s) 1})) (rest s)))))","user":"5292feb4e4b0239c8a67af39"},{"problem":55,"code":"#(into {} (for [c (partition-by identity (sort %))]\n            [(first c) (count c)]))","user":"55810c73e4b05c286339e0f2"},{"code":"#(let [m (group-by identity %)] (zipmap (keys m) (map (fn [[k v]] (count v)) m)))","problem":55,"user":"4efd8b67535de96065cf5085"},{"code":"#(let [g (partition-by identity (sort %))] (zipmap (map first g) (map count g)))","problem":55,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":55,"code":"(fn [coll]\n  (loop [c coll\n         result {}]\n    (if (empty? c)\n      result\n      (recur \n       (rest c)\n       (update-in result [(first c)] (fnil inc 0))\n       )\n      ) \n    )\n  )","user":"52dc7344e4b09f7907dd13cf"},{"problem":55,"code":"(fn count-occ\n  [coll]\n  (let [ks (set coll)\n        r  (reduce #(merge %1 {%2 0}) {} ks)]\n    (loop [coll coll\n           r r]\n      (if-not (empty? coll)\n        (recur (rest coll) (assoc r (first coll) (inc (get r (first coll)))))\n        r))))","user":"58de563fe4b0a4d5acaab6e3"},{"code":"#(reduce (fn [h k] (assoc h k (inc (get h k 0)))) {} %)","problem":55,"user":"4fd91099e4b05e33b9224f32"},{"code":"(fn a[lst]\n  (into {}\n        (for [el (set lst)]\n          [el (count (filter #(= el %) lst))])))","problem":55,"user":"52b405e1e4b0c58976d9ad15"},{"code":"(fn my-frequencies\n  [coll]\n  (->> \n   coll\n   (group-by identity)\n   (map #(vector (first %) (count (second %))))\n   (into {})))","problem":55,"user":"536e5055e4b0fc7073fd6e6b"},{"problem":55,"code":"(fn [coll]\n   (into\n    {}\n    (for [[k v] (group-by identity coll)]\n      [k (count v)])))","user":"55b54ecbe4b01b9910ae2987"},{"code":"(fn count-occurrences\n  [xs]\n  (loop [xs xs accum {}]\n    (if (empty? xs) accum (recur (rest xs) (assoc accum (first xs) (inc (get accum (first xs) 0)))))))","problem":55,"user":"4e50b67b535dc968683fc4ed"},{"problem":55,"code":"(fn count-distinct [s]\n  (apply merge\n         (map\n           #(hash-map % (count (filter (fn [x] (= % x)) s)))\n           (distinct s))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":55,"code":"(fn [c] (apply hash-map (mapcat  #(let [[a b] %] (vector a (count b))) (group-by identity c))))","user":"5b100648e4b0cc2b61a3be17"},{"problem":55,"code":"#(reduce \n    (fn[finalMap item]\n    (if (contains? finalMap item)\n       (assoc finalMap item (inc (get finalMap item)))\n       (assoc finalMap item 1)\n    )) {} %)","user":"571172ece4b09c608db70446"},{"problem":55,"code":"reduce (fn [init item]\n            (if (get init item)\n              (conj init {item (inc (get init item))})\n              (conj init {item 1}))) {}","user":"58a6806ee4b01a0c0b23292f"},{"code":"(fn [s]\n   (apply assoc {} (mapcat #(list (first %) (count (second %))) (vec (group-by (fn [x] x) s))))                                ;)\n             )","problem":55,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":55,"code":"#(loop [coll % answer {}]\n  (if\n   (empty? coll)\n   answer\n   (let [next (first coll)]\n    (recur\n     (rest coll)\n     (assoc answer next (inc (get answer next 0)))\n    )\n   )\n  )\n )","user":"560fe558e4b05f002753df63"},{"code":"(fn [c]\r\n    (loop [s c r {}]\r\n\t     (if (empty? s) r\r\n\t       (recur (filter #(not= (first s) %) s)\r\n\t\t      (assoc r (first s) (count (filter #(= (first s) %) s)))))))","problem":55,"user":"4e821ca5535db62dc21a62c2"},{"problem":55,"code":"(fn count-freq [data]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity data))))","user":"5b0b8d29e4b0cc2b61a3bdd7"},{"problem":55,"code":"(fn [xs]\n  (reduce\n   (fn [m x]\n     (if (contains? m x)\n       (merge m (vector x (inc (get m x))))\n       (merge m [x 1])))\n   {}\n   xs))","user":"5f5e7158e4b02876ed9fcff0"},{"code":"#(into {} (map (fn[[x y]] [x (count y)]) (group-by identity %)))","problem":55,"user":"5201572be4b0d7096e99ddbb"},{"problem":55,"code":"(fn [s]\n  (let [grouped (group-by identity s)]\n    (into {} (for [[k v] grouped] [k(count v)]))))","user":"53edb464e4b0d648e757f4c7"},{"problem":55,"code":"#(reduce \n  (fn [acc cur]\n    (if (acc cur)\n      (assoc acc cur \n             (inc (acc cur)))\n      (assoc acc cur 1))) {} %)","user":"555883c5e4b0deb715856e2d"},{"code":"(fn [coll] \n  (reduce #(assoc %1 %2 (if-let [x (%1 %2)] (inc x) 1)) {} coll))","problem":55,"user":"51da565ae4b02ceefd947765"},{"problem":55,"code":"(fn [xs]\n  (->> xs\n       (sort)\n       (partition-by identity)\n       (map #(vector (first %) (count %)))\n       (into {})))","user":"5adf5f9be4b0837691e92c33"},{"code":"#(reduce merge \n         (map (fn [i]\n                (hash-map (first i) (count i)))\n              (partition-by identity (sort %))))","problem":55,"user":"52f07ccee4b05e3f0be25edf"},{"code":"(fn [s]\n  (reduce (fn [m e] (assoc m e (inc (get m e 0)))) {} s))","problem":55,"user":"5348cab4e4b084c2834f4a5e"},{"problem":55,"code":"reduce (fn [acc elt] (let [elt-cnt (get acc elt 0)]\n                       (assoc acc elt (inc elt-cnt)))) {}","user":"54cad2d5e4b057c6fda3a26c"},{"problem":55,"code":"#(reduce (fn [r [t c]] (assoc r t (count c))) {} (group-by identity %))","user":"4f070ce6535dcb61093f6c1e"},{"code":"(fn [coll] (reduce (fn [acc x] (assoc acc x (inc (get acc x 0)))) {} coll))","problem":55,"user":"5244fa73e4b0d8acf9ed6acb"},{"code":"(fn [coll]\n(persistent!\n (reduce (fn [counts x]\n           (assoc! counts x (inc (get counts x 0))))\n         (transient {}) coll)))","problem":55,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn [coll]\r\n  (let [gp (group-by identity coll)] \r\n    (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"4e1158aa535d04ed9115e7c6"},{"problem":55,"code":"(fn [s]\n  (->> s\n       (group-by identity)\n       (map (fn [[a b]] [a (count b)]))\n       (into {})))","user":"50eeeadae4b02c17778c91f3"},{"code":"(fn [s]\n  (apply hash-map (apply concat (map (fn [[k v]] [k (count v)]) (group-by identity s)))))","problem":55,"user":"50b67515e4b08fb537db98f3"},{"code":"#(reduce (fn [a b] (merge-with + a {b 1})) {} %)","problem":55,"user":"4fbd24d2e4b081705acca2ff"},{"problem":55,"code":"reduce (fn [a x] (assoc a x (inc (get a x 0)))) {}","user":"558b50d5e4b027778923762b"},{"code":"#(let [instances (group-by identity %)]\n   (reduce (fn [acc v] (assoc acc v (-> (instances v) count)))\n           {}\n           (keys instances)))","problem":55,"user":"4fa340b4e4b081705acca18c"},{"code":"#(into {} (map (juxt first count) (partition-by identity (sort %))))","problem":55,"user":"4ec1b090535dfed6da9c6db5"},{"code":"#(into {} (map (fn [idt] [(first idt) (count (second idt))] ) (group-by identity %)))","problem":55,"user":"531bfb69e4b08068f379ed97"},{"problem":55,"code":"(fn count-ocurrences\n  [c]\n  (->> (group-by identity c)\n      (map (fn  [[a b]] [a (count b)]))\n      (into {})\n       ))","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn [s]\n  (let [g (group-by identity s)]\n    (zipmap (keys g) (map #(count %) (vals g)))))","problem":55,"user":"5142e808e4b0c172af7558c9"},{"code":"(fn [xs] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} xs))","problem":55,"user":"4ef8d47c535dced4c769f261"},{"code":"(fn oc [x] \n  (apply hash-map\n         (apply concat \n                (map \n                  (juxt first count) \n                  (vals (group-by identity x))))))","problem":55,"user":"51b0fc95e4b0c53cf2e68a72"},{"problem":55,"code":"(fn __ [s]\n  (reduce (fn [acc x]\n            (update-in acc [x] (fnil inc 0)))\n          {}\n          s))","user":"55916764e4b0604b3f94d57b"},{"code":"#(reduce (fn [m x] (assoc m x (inc (or (get m x) 0))))\n    {}\n\t  %)","problem":55,"user":"4e39d763535deb9a81d77f46"},{"problem":55,"code":"(fn [m]\n  (let [x (group-by identity m)]\n    (into {} (for [[k v] x]\n               [k (count v)]))))","user":"55f85b93e4b03cbcff9738ae"},{"problem":55,"code":"(fn [m]\n  (let [g (group-by identity m)]\n     (into {} (map #(hash-map (key %) (count (val %))) g))))","user":"59438419e4b060784b3b7929"},{"code":"(fn [x]\r\n  (reduce #(if (get %1 %2)\r\n             (assoc %1 %2 (inc (get %1 %2)))\r\n             (assoc %1 %2 1))  {} x))","problem":55,"user":"4f82ed48e4b033992c121c0e"},{"code":"(fn freq [sq] \n  \n  (let [h (group-by identity sq)]\n   (zipmap (map key h) (map (fn [e] (count (val e) ) ) h))\n  )\n)","problem":55,"user":"5180dc04e4b06b8caf33fa01"},{"code":"(fn f [coll] \n  (reduce \n    #(assoc %1 (first %2) (count (second %2)))\n    {}\n    (group-by identity coll)))","problem":55,"user":"53513d28e4b084c2834f4ae3"},{"problem":55,"code":"(fn [col]\n            (reduce (fn [result x]\n                      (if (result x)\n                        (assoc result x (+ 1 (result x)))\n                        (assoc result x 1)))\n                    {} col))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":55,"code":"(fn [x]\n  (let [m (group-by identity x)]\n    (into {} (for [[k v] m] [k (count v)]))\n))","user":"5951190be4b066ee0a44aea4"},{"problem":55,"code":"(fn [coll]\n  (reduce conj {} (map (juxt first (comp count second)) (group-by identity coll))))","user":"5b500215e4b02d533a91bce2"},{"code":"reduce \n   (fn [a b]\n     (assoc a b (inc (get a b 0))))\n     (hash-map)","problem":55,"user":"4f31519ae4b0d6649770a086"},{"code":"#(let [v (group-by identity %)]\n    (zipmap (keys v) (map count (vals v))))","problem":55,"user":"52c25645e4b07a9af579237d"},{"code":"(fn [l]\r\n  (apply merge-with + (map #(hash-map % 1) l)))","problem":55,"user":"509c03f3e4b085ae113522a8"},{"problem":55,"code":"(fn [coll]\n  (into {}\n        (map #(vector (key %) (count (val %)))\n             (group-by identity coll))))","user":"55ed1575e4b0121d4835fdd3"},{"code":"(fn counto [s]\n  (let [g (group-by identity s)]\n    (reduce (fn [acc k] (update-in acc [k] count)) g (keys g))))","problem":55,"user":"5003deb9e4b0678c553fc445"},{"problem":55,"code":"(fn [coll] (into {} \n            (map \n             #(vector (first %) (count (second %)))\n             (group-by identity coll))))","user":"5dcfdf23e4b0948ae9d9ad43"},{"code":"#(reduce (fn [c x] (assoc c x (inc (get c x 0)))) {} %)","problem":55,"user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn [s] (apply merge \n           (map #(hash-map (first %) (count %)) \n                 (partition-by identity (sort s)))))","problem":55,"user":"5009fd0ae4b03d00572d2d70"},{"problem":55,"code":"(fn [xs]                       \n  (apply hash-map (apply concat              \n    (map #(vector (first %) (count (last %)))\n      (group-by identity xs)))))","user":"5de68f83e4b0986d99407f6c"},{"code":"(fn f \n  ([s] (f s {}))\n  ([s m]\n    (if (empty? s)\n        m\n        (f (rest s) (assoc m (first s) (inc (get m (first s) 0)))))))","problem":55,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":55,"code":"(fn func [coll]\n  (reduce\n   \t(fn [d it]\n      (update-in d [it] (fnil inc 0)))\n   \t{}\n    coll))","user":"5666c2dbe4b04acd4f672dc3"},{"problem":55,"code":"(fn [li]\n  (reduce\n   (fn [o i]\n     (merge-with + o {i 1}))\n   {}\n   li))","user":"586a657de4b0f14aab7c88bd"},{"problem":55,"code":"(fn count-occ [l]\n  (reduce\n    (fn [count-occ item]\n      (update-in count-occ [item] (fnil inc 0)))\n    {}\n    l))","user":"59afe4bae4b0e1f4e384c8c0"},{"code":"(fn [coll]\n  (let [gp (group-by identity coll)] \n    (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"4f57a153e4b0a7574ea7183a"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 (key %2) (count (val %2))) {} (group-by identity coll)))\n;(fn [coll] (reduce #(if (%1 %2) (update-in %1 [%2] inc) (assoc %1 %2 1)) {} coll))","user":"54397533e4b032a45b86931d"},{"code":"#(reduce\n  (fn [r k] (assoc r k (inc (r k 0))))\n  {}\n  %)","problem":55,"user":"507b7dbee4b09034bfeeb71e"},{"problem":55,"code":"(fn get-number\n  [data]\n  (let [lst (group-by identity data)\n        keys (keys lst)\n        vals (vals lst)]\n    (->> (map count vals)\n         (zipmap keys))))","user":"5b86462de4b047b03b2037df"},{"problem":55,"code":"#(reduce (fn [m e] (assoc m e (+ 1 (get m e 0)) )) {} %)","user":"53fe1c3be4b0de5c418485f2"},{"problem":55,"code":"(partial reduce #(assoc %1 %2 (inc (%1 %2 0))) {})","user":"5ab16992e4b073f1774425c4"},{"code":"(fn [xs]\n  (reduce\n   (fn [acc, x] (merge-with + acc {x 1}))\n   {} xs))","problem":55,"user":"53800d99e4b06839e8705ebd"},{"problem":55,"code":"#(reduce (fn  [ans k]\n\t\t (if (get ans k)\n  \t\t (update-in ans [k] + 1)\n  \t\t (assoc ans k 1)))\n        {}\n         %)","user":"5da94ccfe4b000c986472c2f"},{"problem":55,"code":"(fn freq [z]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} z))","user":"54653e3be4b01be26fd746da"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       ; %1 acc, %2 k, %3 v\n       (reduce-kv #(assoc %1 %2 (count %3))\n                  {})))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":55,"code":"(fn countoccur [s]\n  (reduce #(merge-with + %1 {%2 1}) {} s))","user":"5cab33e7e4b048ec896c5c48"},{"code":"(fn frequencies*\n  [coll]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"4dda44f2535d02782fcbe9f1"},{"code":"#(reduce (fn [m v] (assoc m v (inc (get m v 0)))) {} %)","problem":55,"user":"50fa01bce4b07934dda8b0ba"},{"problem":55,"code":"(fn\n  [arr]\n  (loop [[f & r] arr\n         counts {}]\n    (if f\n      (let [c (inc (get counts f 0))]\n        (recur r (assoc counts f c)))\n      counts)))","user":"570c8ac3e4b0b0fb43fd06ca"},{"code":"#(let [groups (group-by identity %)]\n   (zipmap (keys groups) (map count (vals groups))))","problem":55,"user":"4e89ff3d535d3e98b802328a"},{"problem":55,"code":"(fn [l]\n  (reduce (fn [result elem]\n            (assoc result elem (inc (get result elem 0)))\n            ) \n          {} \n          l\n  )\n  )","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn co [input]\n  (loop [input input result {}]\n    (if (empty? input) \n      result    \n      (if (= (result (first input)) nil)      \n        (recur (rest input)        \n               (conj result {(first input) 1}))      \n        (recur (rest input)            \n               (conj result {(first input) (+ (result (first input)) 1)}))                 \n        )   \n      )\n    )\n)","problem":55,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn [coll]\n  (->> (group-by identity coll)\n       (map #(vector (first %) (count (second %))))\n       (into {})))","problem":55,"user":"5300158ae4b0d8b024fd370f"},{"code":"(fn [v]\n  (reduce #(assoc %1 (key %2) (count (val %2)))  {} (group-by identity v) ))","problem":55,"user":"4fdf566fe4b05e33b9224f99"},{"problem":55,"code":"(fn\n  \t[s]\n  \t(reduce\n     \t(fn [c n] \n          (cond\n           \t(contains? c n) (assoc c n (inc(c n)))\n            :else (assoc c n 1)))\n     \t{ }\n     \ts))","user":"561d506ee4b064ca9f4b16aa"},{"problem":55,"code":"(fn [a]\n  (reduce\n   #(if (contains? %1 %2)\n      (assoc %1 %2 (+ 1 (get %1 %2)))\n      (assoc %1 %2 1))\n   {}\n   a))","user":"5bf0aefde4b0a6d31fed215a"},{"problem":55,"code":"(fn [x] (reduce #(assoc %1 (first %2) (count (second %2))) {} (group-by identity x)))","user":"5910a43de4b0163c97b36ebf"},{"code":"(fn [l]\n  (apply hash-map\n    (mapcat (fn [n] (list n (count (filter #{n} l))))\n            (set l))))","problem":55,"user":"4ff5744ae4b0678c553fc36a"},{"problem":55,"code":"(fn [xs]\n (reduce (fn [m v] (assoc m v ((fnil inc 0) (get m v)))) {} xs))","user":"5821b018e4b04b46fc4b0f80"},{"code":"reduce   #(if-let [ m (get %  %2 )]\n\t(assoc % %2 (+ m 1))\n\t(assoc % %2 1) \n\t)\n  {}","problem":55,"user":"518644bce4b0da5a5be3baca"},{"code":"reduce #(assoc % %2 (+ 1 (% %2 0))) {}","problem":55,"user":"4e52d815535d302ef430da77"},{"problem":55,"code":"reduce (fn [m e] (assoc m e (+ 1 (m e 0)))) {}","user":"559b2ad1e4b066d22e731f4e"},{"problem":55,"code":"(fn [xs]\n  (apply merge-with +            \n    (map #(hash-map %1 1) xs)\n  ))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":55,"code":"(fn [l] (reduce (fn [nm [k v]] (assoc nm k (count v))) {} (group-by identity l)))","user":"51b0e7b3e4b0c53cf2e68a6e"},{"problem":55,"code":"(fn [coll]\n  (reduce #(let [current-count (get %1 %2 0)] (assoc %1 %2 (+ 1 current-count))) {} coll))","user":"571543bbe4b07c98581c3ad4"},{"problem":55,"code":"#(reduce (fn [m k]\n            (assoc m k\n              (if (contains? m k)\n                (inc (m k))\n                1))) {} %)","user":"53d5a63be4b0e771c3025449"},{"code":"(fn [liste]\n  (zipmap (set liste)\n    (for [x (set liste)]\n      (count (filter #(= x %) liste))\n    )\n  )\n)","problem":55,"user":"4f84400de4b033992c121c2e"},{"code":"(fn count-occurrences [v]\n  (reduce \n   \n   #(assoc % %2 (if (nil? (% %2)) 1 (inc (% %2))))\n   {} v))","problem":55,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":55,"code":"#(apply merge-with + (map (fn[v](hash-map v 1)) %))","user":"5964c614e4b069c0a1a19770"},{"problem":55,"code":"(fn occurences\n  [coll]\n  (let [item (first coll)\n        match #(= % item)]\n  (if (empty? coll)\n    {}\n    (merge (occurences (remove match coll)) \n          {item (count (filter match coll))}))))","user":"5401aefbe4b0df28a13c62c7"},{"code":"(fn [s] (let [t (partition-by identity (sort s))] (zipmap (map first t) (map count t))))","problem":55,"user":"5078d366e4b08327cd804a5b"},{"code":"(fn [n] (into {} (map (fn [e] [(e 0) (count (e 1))]) (group-by (fn [v] v) n))))","problem":55,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [s]\n  (->> s\n       sort\n       (partition-by identity)\n       (reduce #(assoc % (first %2) (count %2)) {})))","problem":55,"user":"524b0645e4b09eba1c0223bf"},{"problem":55,"code":"(fn map-frequencies\n  [xs]\n  (reduce (fn [m i] (assoc m i (inc (m i 0)))) {} xs))","user":"57c500f9e4b05aa3c4741cda"},{"problem":55,"code":"#(into {} (map (fn [v] [(first v) (count (second v))]) (group-by (fn [x] x) %)))","user":"5f419985e4b0955706451fab"},{"code":"(fn count-each [col]\n  (into {} (for [[num, items] (group-by identity col)]\n             [num (count items)])))","problem":55,"user":"4db8d37d535d1e037afb219c"},{"problem":55,"code":"(letfn\n           [\n            (init-map [v] (reduce (fn [p e] (conj p {e 0 })) {} v ) )\n           ]\n         (fn [v] (reduce (fn [p e] (conj p { e (inc (get p e)) })) (init-map v) v )))","user":"58a9e872e4b01a0c0b232973"},{"code":"#(into {} (for [[k v] (group-by identity %)]\n                [k (count v)]))","problem":55,"user":"4f036d9b535dcb61093f6ac1"},{"code":"#(zipmap (keys (group-by identity %)) (map count (vals (group-by identity %))))","problem":55,"user":"4ea0c284535d7eef308072ad"},{"code":"(fn my-frequencies [sq]\n  (reduce #(assoc %1 (first %2) (count (second %2)))\n    {}\n    (group-by identity sq)))","problem":55,"user":"515737f0e4b0b0b4b87062d0"},{"problem":55,"code":"#(into {}\n       (for [[k v] (group-by identity %)]\n            [k (count v)]))","user":"559c13c5e4b066d22e731f61"},{"problem":55,"code":"(fn occur [coll]\n  (let [update-fn (fn [x] (if (nil? x) 1 (inc x)))]\n    (reduce #(update-in %1 [%2] update-fn) {} coll)))","user":"5609d328e4b05f002753deee"},{"problem":55,"code":"(fn [m] \n  (reduce \n    (fn [t v] \n      (update-in t [v] #(if (nil? %) 1 (inc %)))) {} m))","user":"4f7207d3e4b07046d9f4f019"},{"code":"(fn [coll]\n  (reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity coll)))","problem":55,"user":"511aa2a4e4b0c87c59c9670a"},{"code":"(fn [coll]\n  (loop [x (distinct coll) res {}]\n    (if (empty? x) res\n      (recur (rest x) (assoc res (first x) (count (filter #(= % (first x)) coll)))))))","problem":55,"user":"53a1b5c8e4b0ca733b9744c1"},{"problem":55,"code":"(fn [col]\n(into {} (map (fn [[k v]] [k (count v)]) (group-by identity col)))\n  )","user":"5d89427ae4b0915913b1d3b5"},{"code":"(fn count-occurrences [coll]\r\n  (letfn [(group [acc rem]\r\n            (if (seq rem)\r\n              (let [args ((juxt filter remove) #(= (first rem) %) rem)]\r\n                (recur (conj acc (args 0))\r\n                       (args 1)))\r\n              acc))]\r\n    (let [occurs (group '() coll)\r\n          cnts (map count occurs)\r\n          distincts (map first occurs)]\r\n      (zipmap distincts cnts))))","problem":55,"user":"4e7e4a1f535db169f9c7970c"},{"code":"(fn occ [n]\n  (let [x (partition-by identity (sort n))]\n  (apply hash-map (interleave (map first x) (map count x) ))\n  )\n  )","problem":55,"user":"4eaa96e1535d7eef3080730d"},{"problem":55,"code":"#(zipmap\n   (reduce concat (map distinct (partition-by identity(sort %)))) \n   (map count(partition-by identity (sort %))))","user":"5bed84b1e4b0a6d31fed2120"},{"problem":55,"code":"(fn freq\n  ([s] (freq s {}))\n  ([s m]\n   (if (empty? s)\n     m\n     (recur (rest s)\n            (assoc m (first s) (inc (or (m (first s)) 0)))))))","user":"5ce6f93be4b0a17bb84e2b99"},{"problem":55,"code":"(fn [x]\n  (let [l (sort x)\n        k (distinct l)\n        v (map count (partition-by identity l))]\n    (zipmap k v)))","user":"5661b0a9e4b068f2fe63dc6f"},{"problem":55,"code":"(fn [col] (reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity col)))","user":"574a546ee4b02ea1147991f6"},{"problem":55,"code":"(fn occur [seqq]\n  (loop [s seqq result {}]\n    (if (= (count s) 0)\n      result\n      (recur (rest s) (let [r\n            (if (contains? result (first s))\n              (assoc result (first s) (inc (get result (first s))))\n              (assoc result (first s) 1))]\n        r)))))","user":"5e380e72e4b01d43a70e8db0"},{"problem":55,"code":"(fn [argument]\n(into (sorted-map) (into [] ((fn [v] (for [x (set v)]\n             {x (count (filter #(= x %) v))}\n          )) argument))))","user":"594a7ed1e4b07ddc2dafae02"},{"problem":55,"code":"(fn [xs]\n  (let [grouped-map (group-by identity xs)]\n    (zipmap (keys grouped-map) (map #(count (second %)) grouped-map))))","user":"5be1c6c6e4b0ed4b8aab4ca5"},{"problem":55,"code":"(fn [v] (apply merge(map #(hash-map (first %) (count (second %))) (group-by identity (sort v)))))","user":"59089229e4b047aa04b1997c"},{"problem":55,"code":"(fn f [s]\n  (reduce\n    (fn [m e]\n      (if (m e)\n        (assoc m e (inc (m e)))\n        (assoc m e 1)))\n    {}\n    s))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":55,"code":"(fn [coll]\n  (loop [c coll occ {}]\n   (letfn [(update-count [m k] (assoc m k (inc (get m k 0))))]\n     (if (empty? c) occ\n       (recur (rest c) (update-count occ (first c)))))))","user":"5182de5ce4b0353c468deb74"},{"code":"(fn [xs]\n  (reduce\n    (fn [m key]\n      (update-in m [key] (fnil inc 0)))\n    {}\n    xs))","problem":55,"user":"526e5be8e4b03e8d9a4a731c"},{"code":"(fn [seq]\n  (let [dist (distinct seq)\n        ll (map (fn [x] [x (count (filter (fn [y] (= x y)) seq))]) dist)]\n    (loop [i 0 out {}]\n      (if (== i (count ll))\n        out\n        (recur (inc i) (assoc out (first (nth ll i)) (second (nth ll i))))))))","problem":55,"user":"4e955b95535dbda64a6f6b33"},{"problem":55,"code":"(fn my-freq\n  [coll]\n  (reduce\n   (fn\n     [freq x]\n     (if (contains? freq x)\n       (update-in freq [x] inc)\n       (assoc-in freq [x] 1)))\n   {}\n   coll))","user":"568bd448e4b0dcc4269f40a9"},{"code":"(fn [coll] (reduce #(merge-with + %1 {%2 1}) {} coll))","problem":55,"user":"4fc67081e4b0ee37620e1813"},{"problem":55,"code":"(fn [c] (reduce #(assoc % %2 (inc (get % %2 0))) {} c))","user":"4ee7d6d8535d93acb0a66870"},{"code":"#(reduce (fn [m v] (merge-with (fn [o n] (inc o)) m {v 1})) {} %)","problem":55,"user":"4dc1bd76535d020aff1edf8d"},{"problem":55,"code":"(fn myfreq [coll]\n  (loop\n    [coll-left coll\n     res {}]\n    (if (empty? coll-left)\n      res\n      (let [elem (first coll-left)]\n        (if (contains? res elem)\n          (recur (rest coll-left) (update-in res [elem] inc))\n          (recur (rest coll-left) (merge res {elem 1})))))))","user":"5658d775e4b00d3155796114"},{"problem":55,"code":"(fn [coll]\n  (apply hash-map (apply concat (map #(list (first %) (count %)) (partition-by identity (sort coll))))))","user":"55fe7e15e4b00f4cabc57651"},{"problem":55,"code":"(fn [xs]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} xs))","user":"55fee5e4e4b00f4cabc5765a"},{"code":"(fn [col]\n  \n  (reduce \n   (fn [my-map elm]\n   \n       (assoc my-map elm (inc (my-map elm 0))))\n   {}\n   col))","problem":55,"user":"518d1b5be4b070277754617b"},{"code":"(fn [c]\n  (reduce \n    #(assoc %1 %2 (inc (get %1 %2 0)))\n    {} c))","problem":55,"user":"4dbdc9da535d020aff1edf4c"},{"problem":55,"code":"#(let [g (group-by identity %)]\n (reduce-kv (fn [m k v]\n             (update-in m [k] count))\n           g g))","user":"53968a70e4b0b51d73faaee0"},{"code":"(fn [coll]\n  (reduce (fn [m k] (update-in m [k] #(inc (or % 0)))) {} coll))","problem":55,"user":"5028cd0fe4b01614d1633ffc"},{"code":"reduce (fn[m e] (assoc m e (inc (m e 0)))) {}","problem":55,"user":"51f59607e4b0abb92f97f9d5"},{"problem":55,"code":"#(apply merge-with + (for [e %]{e 1}))","user":"60504383e4b056659d6341fa"},{"problem":55,"code":"(fn map-occur [l]\n   ((fn help [remaining\n             map]\n     (if (empty? remaining)\n       map\n       (help (rest remaining)\n             (assoc map\n                    (first remaining)\n                    (inc (map (first remaining) 0))))))\n    l\n    {}))","user":"54d26316e4b0e8a36923e5f2"},{"code":"(fn freq [coll] (if (empty? coll) {} (let [tfs (freq (rest coll)) hf (get tfs (first coll) 0)] (assoc tfs (first coll) (+ hf 1)))))","problem":55,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [coll0]\n  (let [helper (fn [acc coll]\n                 (if (empty? coll)\n                   acc\n                   (let [hd (first coll)]\n                     (recur (assoc acc hd (inc (get acc hd 0)))\n                            (next coll)))))]\n    (helper {} coll0)))","problem":55,"user":"4e39fb68535deb9a81d77f47"},{"code":"reduce\n  #(merge-with + {%2 1} %1)\n  {}","problem":55,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":55,"code":"(fn freqs [[x & xs]]\n  (when x\n    (merge-with + {x 1} (freqs xs))))","user":"58ffac9de4b0438e51c2cffd"},{"code":"(fn f\r\n    ([list] (f list {}))\r\n    ([list map]\r\n      (if (empty? list)\r\n        map\r\n        (recur (rest list) (update-in map [(first list)] (fnil inc 0))))))","problem":55,"user":"50588ff1e4b06522596eba7e"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    #(update-in %1 [%2] (fnil inc 0))\n    (sorted-map)\n    coll))","user":"564c8e99e4b0284900eef674"},{"code":"reduce (fn [xs x]\n         (let [pair (find xs x)]\n           (if pair\n             (assoc xs x (inc (val pair)))\n             (assoc xs x 1)))) {}","problem":55,"user":"523f1245e4b01c266ffa7f95"},{"code":"(fn counter [coll] \n  (reduce \n   (fn [m n] \n     (assoc\n      m \n      n \n      (count \n       (filter \n        #(= %1 n) \n        coll)))) \n     {} (set coll)))","problem":55,"user":"52319066e4b0e2e8de81d1e9"},{"problem":55,"code":"(fn [v]\n  (letfn [(update-map [m v]\n            (let [old-val (m v)]\n              (assoc m v (if old-val (inc old-val) 1))))]\n    (reduce #(update-map %1 %2) {} v)))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [c] (into {} (map #(vector (first %) (count %))\n             (vals (group-by identity c)))))","problem":55,"user":"4f031eac535dcb61093f6a67"},{"problem":55,"code":"#(->> %\n        (group-by identity)\n        (map (fn [[k v]] [k (count v)]))\n        (into {}))\n\n;; #(->> %\n;;         (group-by identity)\n;;         (mapcat (fn [[k v]] [k (count v)]))\n;;         (apply hash-map))\n\n;; #(->> %\n;;         (group-by identity)\n;;         (reduce (fn [acc [k v]] (assoc acc k (count v)))\n;;                 {}))\n\n;; (fn [col]\n;;     (reduce #(update-in %1 [%2] (fn [v] (inc (or v 0))))\n;;             {}\n;;             col))\n\n;; (comp #(zipmap (keys %)\n;;                  (map count (vals %)))\n;;         (partial group-by identity))\n\n;; #(->> %\n;;         (group-by identity)\n;;         ((fn [m] (interleave (keys m) (map count (vals m)))))\n;;         (apply hash-map))","user":"591ad160e4b09b4ee5954bdf"},{"problem":55,"code":"(fn count-occurrences [v]\n  (into {}  (map #(vector (key %) (count (val %))) (group-by identity v))))","user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn fr [seq] (letfn[ (update [map key]\n                    (if (nil? (map key))\n                      (assoc map key 1)\n                      (assoc map key (inc (map key)))))]\n            (reduce update {} seq)))","problem":55,"user":"4f2aff4de4b0d6649770a044"},{"code":"#(into {} (map (fn [[k s]] [k (count s)]) (group-by identity %)))","problem":55,"user":"4eecdd66535d93acb0a668b9"},{"code":"(fn freqs [xs]\n  (cond (empty? xs) {}\n        :else (let [result (freqs (rest xs))]\n                (assoc result (first xs) (inc (get result (first xs) 0)))\n                )\n        ))","problem":55,"user":"5213ffd3e4b0961f15ac4d7d"},{"code":"(fn [xs]\n  (->> xs\n       (group-by identity)\n       (mapcat (fn [[x occurrences]] [x (count occurrences)]))\n       (apply array-map)))","problem":55,"user":"511623cbe4b0d4f670fd2fe1"},{"code":"#( into {} (map (fn [[a b]] [a (count b)]) (group-by identity %)))","problem":55,"user":"4f1d1d95535d64f603146488"},{"problem":55,"code":"#(->> % \n      (group-by identity) \n      (map (fn [[k v]] [k (count v)])) \n      (into {}))","user":"4ea5ba92535d7eef308072d9"},{"problem":55,"code":"(fn [s] (reduce #(assoc %1 %2 (inc (get %1 %2))) (zipmap (distinct s) (repeat 0)) s))","user":"587294f0e4b01531a375ea1e"},{"problem":55,"code":"(partial\n reduce\n (fn [cs x]\n   (update-in\n    cs\n    [x]\n    #(if % (inc %) 1)))\n {})","user":"521d064fe4b0c4ef0be830a8"},{"code":"(fn\n  [coll]\n  (apply hash-map\n         (mapcat #(vector (first %) (count %))\n              (partition-by identity (sort coll)))))","problem":55,"user":"4ebf11bc535dfed6da9c6d9c"},{"problem":55,"code":"(fn [xs]\n  (->> (group-by identity xs)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn [s] (apply hash-map\n                  (let [keys (set s)]\n                    (interleave keys\n                                (for [x keys] (count (filter #(= x %) s)))))))","problem":55,"user":"4ebef65e535dfed6da9c6d9b"},{"code":"(fn [xs] (reduce #(assoc % (first %2) (count (second %2))) {} (seq (group-by identity xs))))","problem":55,"user":"4ece9ca9535d23f03622770f"},{"code":"(fn [xs]\r\n       (reduce #(if (%1 %2)\r\n                  (update-in %1 [%2] inc)\r\n                  (assoc %1 %2 1)) {} xs))","problem":55,"user":"4deb529a535d08e6dec9fe04"},{"code":"(fn freq [col]\n  (->> col\n       (map #(hash-map % 1))\n       (apply merge-with +)))","problem":55,"user":"4feff3b6e4b0678c553fc31e"},{"problem":55,"code":"(fn f\n  [coll]\n  (reduce (fn\n            [acc cur]\n            (if (not (contains? acc cur))\n              (assoc acc cur 1)\n              (update-in acc [cur] inc))) {} coll))","user":"5da7176ae4b000c986472c13"},{"code":";; (fn [xs] (reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} xs))\n(partial reduce (fn [m x] (assoc m x (inc (get m x 0)))) {})","problem":55,"user":"533696b9e4b0e30313ee6c7c"},{"code":"reduce (fn [m k] \n         (assoc m k (inc (m k 0)))) {}","problem":55,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(\n  fn sol [ coll ](\n\t\n\t\treduce ( \n\t\t\tfn cnt[ set1 x ] (\n\t\t\t\tassoc set1 x ( count ( filter #( = % x)  coll) )\n\t\t\t)\n\t\t)\t\n\t\t{} ( set coll )\n\t) \n)","problem":55,"user":"50bf7b72e4b0ffd967a66cc1"},{"code":"(fn count-occurrences [coll]\n  (reduce (fn [l e]\n            (if (l e)\n              (assoc l e (inc (l e)))\n              (assoc l e 1)))\n          {}\n          coll))","problem":55,"user":"4e4bd94b535dc968683fc4d7"},{"problem":55,"code":"(fn [c] (apply hash-map (mapcat #(list (first %) (count (second %))) (group-by identity c))))","user":"51a3cc45e4b0e77c4ca60bfb"},{"problem":55,"code":"(fn freq [seq]\n   (->> seq\n        (group-by identity)\n        (mapcat (fn [[k v]] [k (count v)]))\n        (apply hash-map)))","user":"5b073c34e4b0cc2b61a3bda4"},{"code":"#(into {} (map (fn [s] [(first s) (count s) ]) (->> % sort (partition-by identity) ) ))","problem":55,"user":"4ee7d177535d93acb0a6686f"},{"problem":55,"code":"reduce (fn [a x] (update-in a [x] (fnil inc 0))) {}","user":"4db6d993535d1e037afb2180"},{"code":"(fn [s]\n  (reduce\n    (fn [ans x] (assoc ans x (inc (get ans x 0))))\n    {}\n    s\n    )\n)","problem":55,"user":"506ab9bae4b05d3b7762c74c"},{"problem":55,"code":"(fn count-occur [coll]\n  (apply merge (->> coll\n                    sort\n                    (partition-by identity)\n                    (map (fn [gr] {(first gr) (count gr)}))\n                    ))\n  )","user":"569f4dabe4b0542e1f8d1491"},{"code":"(fn occur [xs]\n  (reduce (fn [res x]\n           (assoc res x (inc (or (res x) 0)))) {} xs))","problem":55,"user":"50053d6ce4b0678c553fc45e"},{"problem":55,"code":"(fn occurrences [coll]\n  (let [split (partition-by identity coll)\n        counts (map count split)\n        merged (map #(hash-map (first %1) %2) split counts)]\n    (apply merge-with + merged)))","user":"542c026ae4b0dad94371f29a"},{"code":"(fn [m] (let [fs (group-by identity m)] (zipmap (keys fs) (map count (vals fs)))))","problem":55,"user":"4e7f4147535db966e863cc3d"},{"problem":55,"code":"(fn [x] (into {} (map #(hash-map (first %) (count (second %))) (group-by identity x))))","user":"5c72c2b9e4b0fca0c16227ab"},{"code":"(fn [s] (reduce (fn [m v] (into m {(first v) (count v)})) {} (partition-by identity (sort s))))","problem":55,"user":"52c200cbe4b07a9af5792372"},{"problem":55,"code":"(fn [s] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity s)))","user":"5d1231dde4b02c15ef021995"},{"problem":55,"code":"reduce (fn [out x] (if (contains? out x) (assoc out x (inc (get out x))) (assoc out x 1))) {}","user":"5582dfb6e4b05c286339e10d"},{"code":"(fn [l] (zipmap (map key (group-by identity l)) (map #(count (val %)) (group-by identity l))))","problem":55,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":55,"code":"(fn myfreq [coll]\n  (loop [input coll\n         result {}]\n    (if (empty? input)\n      result\n      (recur (rest input) (let [item (first input)]\n                            (if (contains? result item)\n                              (assoc result item (inc (get result item )) )\n                              (assoc result item 1)))))))","user":"5ab490f4e4b073f17744261d"},{"code":"#(apply array-map (mapcat (fn [a] [(first a) (count (second a))]) (group-by identity %)))","problem":55,"user":"4e589bdc535d8a8b8723a295"},{"problem":55,"code":"(fn [s]\t\n  (->> (sort s)\n   (partition-by identity)\n   (map #(hash-map (first %) (count %)))\n   (apply merge)))","user":"5776f39de4b0979f89651643"},{"code":"(fn [coll] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"4e6fa38b535d5021c1a89622"},{"problem":55,"code":"#(let [groups (group-by identity %)]\n    (zipmap (keys groups) (map count (vals groups))))","user":"550f1c99e4b06e50f9beb171"},{"problem":55,"code":"(fn [x] \n  (reduce \n   #(assoc %1 %2 \n           (if (contains? %1 %2) \n             (inc (%1 %2)) 1)) {} x))","user":"5167e8ace4b0c5a4140a309a"},{"problem":55,"code":"reduce (fn func[s1 s2]\n         (if(= nil(s1 s2))\n           (assoc s1 s2 1)\n           (assoc s1 s2 (inc (s1 s2))))) {}","user":"5c486dece4b0e06e1360a3c0"},{"problem":55,"code":"#(persistent! (reduce (fn [counts x] (assoc! counts x (inc (get counts x 0)))) (transient {}) %))","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn [s] (->> s (map #(-> {% 1})) (apply merge-with +)) )","problem":55,"user":"51729002e4b044b2ef48a850"},{"problem":55,"code":"#(let [k (group-by identity %)\nv (map (comp count last) k)]\n(apply assoc {} (interleave (keys k) v)))","user":"5e13a6b7e4b099d064963001"},{"problem":55,"code":"(fn\n  [coll]\n  (->> coll\n     (group-by identity)\n     (map (fn [[k v]] [k (count v)]))\n     (into {})))","user":"5c9a638fe4b048ec896c5aae"},{"code":"(fn [s]\r\n   (loop [[x & xs :as xss] s acc {}]\r\n     (if (seq xss)\r\n       (recur xs (merge-with #(+ %1 %2) acc {x 1}) )\r\n       acc)))","problem":55,"user":"4ef1ee67535dced4c769f219"},{"problem":55,"code":"#(loop [res {}\n        temp %]\n   (if (empty? temp)\n     res\n     (recur\n      (assoc res \n        (first temp) (inc (get res (first temp) 0)))\n      (rest temp))))","user":"5defc177e4b093ff717275af"},{"problem":55,"code":"(fn [S]\n  (let [m (group-by identity S)]\n    (loop [k (keys m) r m]\n      (if (empty? k)\n        r\n        (recur (rest k) (update-in r [(first k)] count))\n        ))))","user":"5f574662e4b0a0bc16850a90"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       (map (fn [[k v]]\n              [k (count v)]))\n       (into {})))","user":"5630ce72e4b0bfe05bf11786"},{"code":"(fn [l]   \n  (reduce #(merge-with + % {%2 1}) {} l))","problem":55,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn [col] (into {} (map #(vector (first %) (count (second %))) (group-by identity col))))","problem":55,"user":"534815bde4b084c2834f4a53"},{"code":"#(reduce (fn [h f] (assoc h f (inc (get h f 0)))) {} % )","problem":55,"user":"4f1684c7535d64f60314644b"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [[id coll]] [id (count coll)]) (group-by identity %)))","user":"5d651553e4b0db5d338d15ca"},{"code":"(fn [ls] \r\n  (loop [ls ls m {}]\r\n    (let [incn (fn [x] (if (nil? x) 1 (inc x)))]\r\n      (if (empty? ls) m\r\n        (recur (rest ls)\r\n               (into m [[(first ls) (incn (m (first ls)))]]))))))","problem":55,"user":"502a9fdee4b095a7adb898b4"},{"problem":55,"code":"(partial \n reduce \n (fn [agg v] (update-in agg [v] (fn [prev] (inc (or prev 0)))))\n {})","user":"5f431d32e4b0955706451fb5"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc v] (assoc acc v (inc (get acc v 0))))\n   {}\n   coll)\n  )","user":"5faef622e4b08cb800c85b05"},{"code":"(fn [coll] \n  (reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} coll))","problem":55,"user":"4fb01e53e4b081705acca260"},{"code":"(fn [coll] \n  (reduce (fn [counts x] \n            (assoc counts x (inc (get counts x 0)))) \n          {} coll))","problem":55,"user":"536a37efe4b0243289761eaa"},{"code":"#(reduce \n  (fn [m k] \n    (assoc m k \n      (if (contains? m k)\n          (inc (m k))\n          1)))\n  (sorted-map) %)","problem":55,"user":"4eb5750a535d7eef30807366"},{"code":"(fn [coll]\n    (reduce\n      (fn [a b]\n        (let [val (get a b 0)]\n            (assoc a b (inc val))))\n      {} coll))","problem":55,"user":"4e8e8c24535d65386fec2143"},{"problem":55,"code":"#(loop [[f & r] %\n         res {}]\n    (if f\n      (recur r \n             (if (res f)\n                (assoc res f (inc (res f)))\n                (assoc res f 1)))\n      res))","user":"5cc80598e4b0ccb061962840"},{"code":"(fn [coll]\n(apply hash-map \n(mapcat #(vector (first %)(count (second %)))\n(group-by identity coll))))","problem":55,"user":"4dcfbc44535d5973398f92a7"},{"problem":55,"code":"(fn temp[sx](into {} (map #(assoc {} (key %) (count (val %))) (group-by identity sx))))","user":"563c6ebae4b0bfe05bf11834"},{"problem":55,"code":"(fn my-frequencies\n  [coll]\n  (loop [freqs {}\n         coll coll]\n    (if (empty? coll)\n      freqs\n      (recur (assoc freqs (first coll) (inc (or (freqs (first coll)) 0))) (rest coll)))))","user":"572db6d5e4b0cd1946bd0f78"},{"code":"(fn [x]\n  (let [uniqs (set x)]\n    (zipmap uniqs \n     (for [auniq uniqs]\n       (apply + (for [el x] (if (= el auniq) 1 0)))))))","problem":55,"user":"52747090e4b03e8d9a4a74a5"},{"problem":55,"code":"#(into {} (map (fn [[item items]] [item (count items)]) (group-by identity %)))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn freq [seq]\n  (into {}\n    (map (fn [v] [v (count (filter #(= v %) seq))])\n          (set seq))))","problem":55,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(letfn [(c [[f & r]]                                                                                                                                                                                                                         \n          (if r                                                                                                                                                                                                                              \n            (let [m (c r)                                                                                                                                                                                                                    \n                  x (m f)]                                                                                                                                                                                                                   \n              (if x                                                                                                                                                                                                                          \n                (assoc m f (inc x))                                                                                                                                                                                                          \n                (assoc m f 1)))                                                                                                                                                                                                              \n            {f 1}))]                                                                                                                                                                                                                         \n  c)","problem":55,"user":"4db342d7535df7e46ed9b6cd"},{"problem":55,"code":"(fn [coll] (apply merge (for [x (distinct coll)] {x (count (filter #(= x %) coll))})))","user":"56e6ef89e4b02e7e935eb6d0"},{"code":"(fn my-frequencies\n  [items]\n  (reduce (fn [m x] (assoc m x (+ 1 (m x 0)))) {} items))","problem":55,"user":"511720eae4b0063b4e3e16da"},{"code":"(fn [s] (into {} (map #(hash-map (first %1) (count %1)) \n     (partition-by identity (sort s)))))","problem":55,"user":"52655949e4b03e8d9a4a710b"},{"code":"(fn [coll] \n  (into {} (for [[k v] (group-by identity coll)] [k (count v)])))","problem":55,"user":"50d93c53e4b0fd36a4b89223"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc val]\n     (if (get acc val)\n       (update-in acc [val] #(inc %))\n       (assoc acc val 1)))\n   {}\n   coll))","user":"55fbc657e4b0f488688e0666"},{"code":"(fn [coll]\n  (into {} (map #(vector (key %) (count (val %))) (group-by identity coll))))","problem":55,"user":"4e1248b1535d04ed9115e7cf"},{"problem":55,"code":"(fn [cln] \n  (reduce (fn [acc [x c]] \n            (assoc acc x (count c))) \n          {} \n          (group-by identity cln)))","user":"5596a324e4b04c1e5c31d757"},{"code":"(fn [coll]\r\n  (apply merge (map #(assoc {} (first %) (count %)) (partition-by identity (sort coll)))))","problem":55,"user":"4df168bd535d08e6dec9fe1d"},{"problem":55,"code":"reduce #(update-in %1 [%2] (fn [old] (inc (or old 0)))) {}","user":"5a64ce4ee4b0512ff01cd9a6"},{"problem":55,"code":"(fn [s]\n  ((fn [s res]\n     (if (empty? s)\n       res\n       (recur (remove #(= % (first s)) s)\n              (assoc res \n                (first s)\n                (- (count s) (count (remove #(= % (first s)) s))))))) s {}))","user":"5a52f2cbe4b05d388ecb6c06"},{"code":"(fn freq [l]\n  (if (empty? l)\n    {}\n    (let [a (filter #(= % (first l)) l)\n          b (filter #(not= % (first l)) l)]\n      (assoc (freq b) (first a) (count a)))))","problem":55,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"reduce #(merge % (if (nil? (% %2)) {%2 1} {%2 (inc (% %2))})) {}","problem":55,"user":"508ee17ae4b0706b2ed3ef8d"},{"problem":55,"code":"(fn count-occurences [xs]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs))","user":"53e8c684e4b036ad0777e48b"},{"code":"(fn [xs]\n  (reduce\n    (fn [acc el]\n      (let [v (acc el)]\n        (if v\n          (assoc acc el (inc v))\n          (assoc acc el 1))))\n    {}\n    xs))","problem":55,"user":"50427899e4b0add3005c0fc2"},{"problem":55,"code":"(fn\n  [xs]\n  (let [m (group-by identity xs)]\n    (into {}\n      (for [[k v] m]\n        [k (count v)]))))","user":"5574c172e4b05c286339e059"},{"code":"(fn [items]\r\n (apply conj {} (map  (fn [i] (vector i (count (filter #(= i %) items)))) (distinct items)))\r\n )","problem":55,"user":"4e4c1e8c535dc968683fc4db"},{"code":"#(reduce (fn [h x] (assoc h x (inc (get h x 0)))) {} %)","problem":55,"user":"5002b6e5e4b0678c553fc42c"},{"problem":55,"code":"reduce\n   (fn [mp i]\n    (if (contains? mp i)\n        (update-in mp [i] inc)\n        (assoc mp i 1)           \n    )\n   )\n   {}","user":"59c243bae4b0a024fb6ae4aa"},{"code":"(fn [s]\n    (let [a (reverse (map (fn [i] [(first i) (count (last i))]) (group-by identity s)))]\n      (zipmap (map first a) (map last a)))    \n  )","problem":55,"user":"53489329e4b084c2834f4a5b"},{"problem":55,"code":"(fn [xs]\n  (into {}\n  (map #(vector (first %) (count (second %)))\n   (group-by identity xs))))","user":"54448e84e4b032a45b869393"},{"code":"(fn uniq-count \n   ([xs] (uniq-count xs {}))\n   ([[x & xs] ret]\n    (if (nil? x) ret\n      (uniq-count xs (update-in ret [x] #(if (nil? %) 1 (inc %)))))))","problem":55,"user":"4fe8d862e4b0547ebccb2428"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [[x y]](vector x (count y))) (group-by identity %)))","user":"56d91a53e4b0ea9b8538f7ee"},{"problem":55,"code":"#(persistent!\n(reduce (fn [counts x]\n(assoc! counts x (inc (get counts x 0))))\n(transient {}) %))","user":"544e8369e4b0e39780006987"},{"code":"(fn [s] (reduce #(assoc % (first %2) (count (last %2))) {} (group-by identity s)))","problem":55,"user":"4f4fac2ae4b03ad3f0c10ce5"},{"problem":55,"code":"(fn my-frequencies [xs]\n  (apply merge (map (partial apply hash-map)\n                    (map #(vec [(first %)(count %)])\n                         (partition-by identity (sort xs))))))","user":"50aa777fe4b056ee01935866"},{"problem":55,"code":"#(apply merge (map (fn [[a b]] {a (count b)})(group-by max %)))","user":"5b9ae606e4b0c0b3ffbd4af2"},{"problem":55,"code":"(fn [lst] (loop [l lst m {}] (let [el (first l)] (if (nil? el) m (recur (rest l) (assoc m el (if (nil? (m el)) 1 (inc (m el)))))))))","user":"5f2c94b4e4b033932238a669"},{"code":"reduce #(assoc %1 %2 (if (%1 %2) (inc (%1 %2)) 1)) {}","problem":55,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc cur]\n            (if (contains? acc cur)\n              (update-in acc [cur] inc)\n              (assoc acc cur 1)))\n          {}\n          coll))","user":"5d431c77e4b07c84aa5ae68f"},{"problem":55,"code":"(fn [coll]\n  (let [freq (fn [acc v]\n               (update-in acc [v] #(inc (or % 0))))]\n    (reduce freq {} coll)))","user":"5250b7a5e4b0541d1855b83e"},{"problem":55,"code":"(fn [coll]\n   (->> (group-by identity coll)\n     (map (fn [[a d]] [a (count d)]))\n     (into {})))","user":"51bd255ce4b0df1216cefd94"},{"problem":55,"code":"#_(fn [col]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} col))\n\n#(let [groups (group-by identity %)]\n       (zipmap (keys groups) (map count (vals groups))))","user":"5baba1ece4b0a20761a23482"},{"problem":55,"code":"reduce #(update-in % [%2]\n                   (fn [v]\n                     (if (nil? v)\n                       1\n                       (inc v)))) {}","user":"55868660e4b059ccff29b1d4"},{"code":"(fn [coll]\n  (reduce (fn [m x] (update-in m [x] #(if (nil? %) 1 (inc %)))) {} coll))","problem":55,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"problem":55,"code":"(fn [coll]\n  (let [groups (group-by identity coll)]\n    (into {} (for [[k v] groups] [k (count v)]))))","user":"53f7820be4b0de5c41848560"},{"problem":55,"code":"(fn [coll] (->> coll\n                    (group-by identity)\n                    (map (fn [[item items]] (assoc {} item (count items))))\n                    (into {})))","user":"5da4b152e4b000c986472bf6"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m x] (assoc m x (inc (get m x 0))))\n          {}\n          xs))","user":"5136f659e4b04059df19f2fd"},{"code":"(fn [coll]\n   (let [m (group-by identity coll)]\n     (zipmap (keys m) (map #(count %) (vals m)))))","problem":55,"user":"4fe9f0f6e4b0547ebccb247b"},{"problem":55,"code":"(fn [xs] \n  (loop [rem (group-by identity xs)\n          res {}] \n     (if (empty? rem)\n       res\n       (recur (rest rem)\n         (assoc res (first (first rem)) (count (last (first rem))))))))","user":"5522cd9ae4b0882d96d091ab"},{"problem":55,"code":"(fn [col] (reduce (fn [acc n]\n                    (if (get acc n)\n                      (assoc acc n (+ (get acc n) 1))\n                      (assoc acc n 1))) {} col))","user":"559fb147e4b0acc240e314ea"},{"code":"(fn [col]\n   (reduce (fn [ret cur]\n             (if (contains? ret cur)\n               (merge ret {cur (inc (ret cur))})\n               (merge ret {cur 1}))) {} col))","problem":55,"user":"525ed5f4e4b0cb4875a45db8"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity coll))\n  )","user":"525d44bfe4b0cb4875a45d6d"},{"code":"(fn [xs] \n  (loop [in xs\n         out {}]\n    (if (empty? in) \n      \tout\n        (recur \n         (rest in) \n         (update-in\n          \tout\n          \t[ (first in) ] \n          \t#(if (nil? %) 1 (inc %))) ))))","problem":55,"user":"4f03653f535dcb61093f6aa1"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [m e] (update-in m [e] (fn [n] (if (nil? n) 1 (inc n)))))\n   {} coll))","user":"5599abc9e4b031d6649c9bb0"},{"code":"(fn [s]\n  (reduce\n    (fn [m i]\n      (assoc m i (inc (m i 0))))\n    {}\n    s))","problem":55,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn freq [x] \n  (letfn [(freq2 [x y]\n    (if (empty? x) \n        y\n        (let [filtered (filter (fn [z] (= z (first x))) x)]\n          (freq2 (remove #{(first x)} x) (assoc y (first x) (count filtered)))\n        )\n    )\n  )]\n  (freq2 x {})\n  )\n)","problem":55,"user":"50588af1e4b06522596eba7d"},{"problem":55,"code":"(fn [xs]\n  (into {}\n        (map\n          (fn [[k v]] {k (count v)})\n          (group-by identity xs))))","user":"4ee897fe535d93acb0a66883"},{"code":"(fn [coll]\n  (->> (group-by identity coll)\n       (reduce (fn [result [obj c]]\n                 (assoc result obj (count c)))\n               {})))","problem":55,"user":"52381b2ae4b0fae3832e99ef"},{"problem":55,"code":"(fn [xs]\n    (into {}\n     (for [[x c]  (group-by identity xs)]\n       [x (count c)])))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [res, v]\n     (conj res (update-in res [v] (fnil inc 0))))\n   {}\n   coll))","user":"553abb28e4b09218d5f44ffb"},{"problem":55,"code":"#(into {}\n       (for [[x l] (group-by identity %)]\n         [x (count l)]))","user":"565e0934e4b068f2fe63dc30"},{"problem":55,"code":"#(reduce (fn [acc i] (if (nil? (acc i)) (assoc acc  i 1) (assoc acc i (inc (acc i))))) {} %)","user":"55ec879ae4b0121d4835fdc8"},{"problem":55,"code":"(fn [s] \n  (loop [y '{}, x (partition-by identity (sort s))]\n    (if (empty? x)\n      y\n      (recur (conj y (hash-map (ffirst x) (count (first x)))) (drop 1 x))\n)))","user":"54524afbe4b0e397800069bc"},{"problem":55,"code":"(fn [col](reduce #(if (%1 %2) (assoc %1 %2 (inc (%1 %2))) (assoc %1 %2 1)) {} col))","user":"5b9c4a7be4b0c0b3ffbd4b16"},{"code":"#(let [group (group-by identity %)]\n   (zipmap (keys group)\n           (map count (vals group))))","problem":55,"user":"52d0902ee4b07d0d72b273bd"},{"code":"(fn [s]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} s)\n)","problem":55,"user":"52b49aebe4b0c58976d9ad2b"},{"problem":55,"code":"#(reduce (fn [acc x]\n            \t(update-in acc [x] (fnil inc 0)))\n            \t{}\t\n            \t%)","user":"5a2d2139e4b09cafd31c7f62"},{"code":"(fn [col]\n  (let [xs (group-by identity col)]\n    (zipmap (keys xs) (map count (vals xs)))))","problem":55,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":55,"code":"(fn f [s] (loop[h (first (distinct s)) t (rest (distinct s)) m {}] \n            (if (= h nil) m (recur (first t) (rest t) (assoc m h (count (filter #(= % h) s) ) ) ) ) ) )","user":"53b3ea79e4b047364c0444ab"},{"code":"(fn [xs]\n  (let [m (group-by identity xs)]\n  \t(zipmap (keys m) (map count (vals m)))))","problem":55,"user":"4ee67d74535d93acb0a66861"},{"problem":55,"code":"(fn [coll]\n   (reduce\n     (fn [res x]\n       (update-in res [x] (fnil inc 0)))\n     {}\n     coll))","user":"5675cdf1e4b05957ce8c614d"},{"code":"(fn[coll] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"4fc0221ce4b081705acca322"},{"code":"(fn [coll]\n    (reduce conj (for [[k v] (group-by identity coll)] {k (count v)})))","problem":55,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":55,"code":"(fn freq\n  ([s] (freq s {}))\n  ([s result]\n   (if (empty? s)\n     result\n     (let [f (first s)]\n       (recur (rest s)\n              (assoc result\n                     f\n                     (if (contains? result f)\n                       (inc (result f))\n                       1)))))))","user":"541709b0e4b01498b1a71a06"},{"problem":55,"code":"(fn [m] (reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity m)))","user":"57e6997ee4b0bfb2137f5af0"},{"code":"(fn [X]\n  (loop [res {}\n         elts X]\n    (cond (empty? elts) res\n          :default\n            (let [groups (group-by #(= % (first elts)) elts)\n                  new-elt (groups true)\n                  remaining (groups false)\n                  add (hash-map (first new-elt) (count new-elt))]\n              (recur (conj res add) remaining)))))","problem":55,"user":"4e49a7bb535dc968683fc4c6"},{"problem":55,"code":"#(apply assoc {} (apply concat (for [k (distinct %)] [k (count (filter (partial = k) %))])))","user":"4e5e9f6b535d8a8b8723a2d2"},{"problem":55,"code":"(fn [c] (apply hash-map (mapcat (fn [[n s]] [n (count s)]) (group-by identity c))))","user":"600cb742e4b074f607df6696"},{"problem":55,"code":"(fn [xs]\n  (let [m (group-by identity xs)]\n    (into {} (for [[k v] m] [k (count v)]))))","user":"546a6c7ce4b00cfc9eacc154"},{"problem":55,"code":"#(reduce (fn [l [k v]] (assoc l k (count v))) {} (group-by identity %1))","user":"5ef5ee81e4b07c55ae4a054a"},{"problem":55,"code":"(fn my-freq [coll]\n  (reduce #(merge-with + %1 {%2 1})  {} coll))","user":"5471f0f3e4b094393f72dd6f"},{"problem":55,"code":"(fn [xs] \n  (let [gs (group-by identity xs)]\n    (reduce (fn [res [k v]] (assoc res k (count v))) {} gs)))","user":"58c2df0ae4b021aa9917ed17"},{"problem":55,"code":"(fn count-occurs [coll]\n  (reduce (fn [res v]\n            (let [cnt (get res v)]\n              (if (nil? cnt)\n                (assoc res v 1)\n                (assoc res v (inc cnt))\n                )\n              )\n            )\n          {} coll)\n  )","user":"57ca95f2e4b05aa3c4741d3b"},{"problem":55,"code":"(fn [xs]\n    (let [ps (sort xs)]\n      (loop [xs (rest ps) y (first ps) m {} n 1]\n        (if (empty? xs)\n          (assoc m y n)\n          (if (= (first xs) y)\n            (recur (rest xs) y m (inc n))\n            (recur (rest xs)\n                   (first xs)\n                   (assoc m y n)\n                   1))))))","user":"58b81490e4b0ebc645576d8c"},{"problem":55,"code":"(fn [xs] \n    (loop [[x :as xs] xs\n           ret {}]\n      (if (empty? xs) ret\n        (recur (rest xs) (assoc ret x ((fnil inc 0) (get ret x)))))))","user":"5f82cfcce4b0c071e6c840fb"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 %2 (count (filter (partial = %2) coll))) {} (set coll)))","user":"57ed19a3e4b0bfb2137f5b8e"},{"problem":55,"code":"(partial reduce (fn [acc x] (assoc acc x (inc (get acc x 0)))) {})","user":"504f5804e4b0a02f9cffde72"},{"problem":55,"code":"reduce (fn [S t] (assoc S t (inc (S t 0)))) {}","user":"55f6fe09e4b06e875b46cea2"},{"problem":55,"code":"#(let [grouped (group-by identity %)]\n\t(zipmap (keys grouped) (map count (vals grouped)))\n   )","user":"5578f292e4b05c286339e08f"},{"problem":55,"code":"reduce\n(fn [m i]\n  (update-in m [i] #(if % (inc %) 1)))\n{}","user":"4f301d02e4b0d6649770a072"},{"code":"(fn [s] (reduce (fn [res x] (update-in res [x] (fn [old] (if (nil? old) 1 (inc old))))) {} s))","problem":55,"user":"5300f68de4b0d8b024fd3714"},{"code":"(fn [x] (reduce #(conj % [%2 (inc (get % %2 0))]) {} x))","problem":55,"user":"4f045946535dcb61093f6bba"},{"code":"(fn co [lt]\n  (letfn [(coe [lt e]\n               (reduce #(if (= e %2) (inc %1) %1) 0 lt))\n          (colt [ks]\n                (map (partial coe lt) ks))]\n    (let [ks (seq (set lt))]\n      (zipmap ks (colt ks)))))","problem":55,"user":"4e1b2cd9535d04ed9115e7fd"},{"problem":55,"code":"#(loop [[a & b] % m {}]\n   (if (nil? a)\n     m\n     (recur b (assoc m a (inc (or (get m a) 0))))\n     )\n   )","user":"5b99a0a3e4b0c0b3ffbd4ad7"},{"problem":55,"code":"#(reduce (fn [a b] (assoc a b (inc (get a b 0)))) {} %)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [c] \n  (reduce (fn [m k] (assoc m k (inc (get m k 0)))) {} c))","problem":55,"user":"4e6e3aac535d5021c1a89603"},{"problem":55,"code":"(fn [coll]\n  (reduce #(assoc % (first %2) (count (second %2)))\n          {} (group-by identity coll)))","user":"56bf4ac0e4b0f26550335985"},{"problem":55,"code":"(fn [xs] (loop [xs xs m {}] (if (empty? xs) m (let [el (first xs)] (recur (rest xs) (assoc m el (inc (get m el 0))))))))","user":"59203996e4b09b4ee5954c5b"},{"problem":55,"code":"(fn [coll]\n\n  (letfn [\n\n    (next-element [r x]\n\n      (merge r {x (inc (get r x 0))}))]\n\n    (reduce next-element {} coll)))","user":"57300c19e4b0cd1946bd0fa1"},{"problem":55,"code":"(fn [coll]\n    (into\n     {}\n     (vec\n      (map\n       (fn [kv] (vec (list (first kv) (count (second kv)))))\n       (group-by identity coll)\n       )\n      )\n\n     )\n    )","user":"5f06caa7e4b0cf489e8d7f52"},{"code":"#(reduce (fn [m x] (assoc m x (inc (m x)))) (zipmap % (repeat 0)) %)","problem":55,"user":"4e9e0640535dbda64a6f6b91"},{"code":"(fn [xs]\n  (apply merge-with + (map #(hash-map %1 1) xs)))","problem":55,"user":"508e13abe4b0f17d83ea26c7"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 (first %2) (count (second %2))) {} (group-by identity coll)))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn [coll]\n  (reduce\n   (fn [m x] (assoc m x (inc (m x 0))))\n   {}\n   coll))","problem":55,"user":"528b01a0e4b0239c8a67ae89"},{"problem":55,"code":"(fn [s] (let [g (group-by identity s)]\n            (zipmap (keys g) (map count (vals g)))))","user":"595bbab7e4b066ee0a44afe0"},{"problem":55,"code":"(fn [x]\n                        (reduce\n                       (fn [out in]\n                         (if (get out in)\n                           (update-in out [in] inc)\n                           (assoc out in 1)))\n                       {}\n                       x))","user":"5564c113e4b0c656e3ff180d"},{"problem":55,"code":"(fn [coll]\n(reduce (fn [m v] (assoc m v (inc (get m v 0)))) {} coll)\n  )","user":"54145050e4b01498b1a719ea"},{"problem":55,"code":"(fn [coll]\n   (->> \n     (set coll)\n     (map (fn [x] (filter #(= x %) coll)))\n     (map #(list (first %) (count %)))\n     (apply concat)\n     (apply hash-map)))","user":"5ea444b7e4b00a66d4a951a0"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"reduce #(conj %1 [%2 (+ 1 (%1 %2 0))]) {}","problem":55,"user":"4f294c48e4b0d6649770a023"},{"problem":55,"code":"#(reduce-kv (fn [m k v]\n               (assoc m k (count v)))\n             {}\n             (group-by identity %))","user":"5327c591e4b09d4e7a9b54ff"},{"code":"#(->> % (group-by identity) (map (fn [[a b]] [a (count b)])) (into {}))","problem":55,"user":"5137c3b0e4b0509a8b470482"},{"problem":55,"code":"(fn [s]\n  (apply merge-with +\n         (map #(hash-map %1 1) s)))","user":"53dcf474e4b0d874e779ae25"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m x]\n            (update-in m [x]\n                       (fn [old]\n                         (if (nil? old)\n                           1\n                           (inc old)))))\n          {}\n          coll))","user":"56a79eb0e4b07966d5a8a05d"},{"code":"(fn [s]\n  (apply\n    hash-map\n    (mapcat\n      identity\n      (map\n        #(list (first %1) (count (second %1)))\n        (group-by identity s)\n      )\n    )\n  )\n)","problem":55,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn [s]\n  (reduce #(assoc %1 (first %2) (count (second %2)))\n          {} (group-by identity s)))","problem":55,"user":"4f91f5b1e4b0dcca54ed6ca7"},{"code":"(fn f \n  [xs]\n  (into {} (map (fn [x] [(first x) (count (last x))])\n       (group-by identity xs))))","problem":55,"user":"50aa60bee4b056ee01935865"},{"code":"#(into {} \n       (for [[k v] (group-by identity %)]\n             [k (count v)]))","problem":55,"user":"52d39acce4b099d49816f0c7"},{"code":"(fn freq [xs] (reduce \n  (fn countOne [result x] \n    (if (contains? result x) \n        (assoc result x (+ (result x) 1)) \n        (assoc result x 1)\n    )) \n  {} xs \n))","problem":55,"user":"4ed500bb535d10e5ff6f52d3"},{"problem":55,"code":"#(zipmap (vec (keys (group-by identity %))) \n        (vec (map count (vals (group-by identity %)))))","user":"58173722e4b0c0e9c07b838a"},{"code":"(fn[s](reduce #(assoc %1 %2(inc(or(%1 %2)0))){}s))","problem":55,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [c]\n  (into {}\n    (map #(vector % (count (filter (partial = %) c)))\n         (set c))))","problem":55,"user":"50166470e4b052339a490e76"},{"problem":55,"code":"(fn [coll]\n  (into {}\n        (for [[k v] (group-by identity coll)] [k (count v)])\n  \n  )\n  )","user":"56db90d4e4b0ea9b8538f80d"},{"code":"(fn                                                                                                                                        \n  [coll]                                                                                                                                                                                                    \n  (persistent!                                                                                                                                                                                              \n   (reduce (fn [counts x]                                                                                                                                                                                   \n             (assoc! counts x (inc (get counts x 0))))                                                                                                                                                      \n           (transient {}) coll)))","problem":55,"user":"527c4071e4b0757a1b17135a"},{"problem":55,"code":"(fn [col]\n(into {}\n(for [[k v] (group-by identity col)]\n[k (count v)])))","user":"54580586e4b01be26fd74616"},{"code":"(fn ! [[f & r]]\n  (loop [counts {},\n         x f,\n         r r]\n    (let [counts (assoc counts x (inc (get counts x 0)))]\n      (if (seq r)\n        (recur counts (first r) (rest r))\n        counts))))","problem":55,"user":"4ff3e771e4b0678c553fc356"},{"code":"#(apply hash-map (apply concat (map (fn [x] [(first x) (count x)]) (partition-by identity (sort %)))))","problem":55,"user":"5071b614e4b0e3170b5a867d"},{"problem":55,"code":"(fn my-frequencies [s]\n  (reduce (fn [res x]\n           (if (contains? res x)\n             (assoc res x (inc (res x)))\n             (assoc res x 1)))\n   {}\n   s))","user":"531bad96e4b08068f379ed93"},{"problem":55,"code":"(fn [seq]\n  (->> (sort seq)\n       (group-by identity)\n       (map (fn [x] {(first x) (count (last x))}))\n       (into {})))","user":"5a84cf8de4b00b71e582a095"},{"problem":55,"code":"(fn [s] (reduce (fn [acc e] (if (contains? acc e)\n                            (assoc acc e (inc (get acc e)))\n                            (assoc acc e 1)))\n               {}\n               s))","user":"5b445421e4b02d533a91bc40"},{"code":"reduce (fn [map n]\n          (if (nil? (get map n))\n            (assoc map n 1)\n            (update-in map [n] inc)))\n        {}","problem":55,"user":"50589113e4b06522596eba7f"},{"problem":55,"code":"(fn [col]\n  (let [oindex (set col)\n        omap (zipmap oindex (repeat 0))]\n    (loop [outmap omap\n           incol col]\n      (if (empty? incol)\n        outmap\n        (recur (update-in outmap [(first incol)] inc) (rest incol))))))","user":"56197b47e4b053970a773af8"},{"code":"(fn count-occurs [coll]\n  (reduce (fn [a [key val]] (assoc a key (count val))) {} (group-by identity coll)))","problem":55,"user":"4e7f51eb535db966e863cc3f"},{"code":"reduce (fn [acc i] (update-in acc [i] #(inc (or % 0)))) {}","problem":55,"user":"4dbe5390535d020aff1edf5c"},{"code":"#(reduce (fn [r [k v]] (assoc r k (count v))) {} (group-by identity %))","problem":55,"user":"4f0b2028535d0136e6c222ff"},{"problem":55,"code":"(fn [coll]\n  (->> (group-by identity coll)\n       (map (fn [[k v]] [k (count v)]))\n       (into {})))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":55,"code":"(fn [col] (let [g (group-by identity col)]\n              (reduce (fn [acc v] (conj acc (hash-map (key v) (count (val v))))) {} g)\n              ))","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn [coll]\n  (apply merge\n         (for [x (set coll)]\n           {x (count (filter #(= x %) coll))})))","problem":55,"user":"500cb910e4b05f7c30cfa698"},{"problem":55,"code":"(fn occ \n  [init]\n  (reduce \n    (fn [dict elem]\n     (if (contains? dict elem)\n        (update-in dict [elem] inc)\n        (assoc dict elem 1)\n      )\n     )          \n    {}\n    init))","user":"53d6b266e4b0e771c3025459"},{"problem":55,"code":"(fn [coll]\n            (apply hash-map (mapcat #(list (key %) (count (val %))) (group-by identity coll)))\n            )","user":"552d9013e4b076ab5578f7ea"},{"code":"(fn [v]\n  (reduce \n   #(if (get %1 %2) \n      (conj %1 (vector %2 (inc (get %1 %2))) ) \n      (conj %1 (vector %2 1) ) \n      ) \n   {} \n   v ))","problem":55,"user":"4ec4d723535dcc7ae8597d65"},{"code":"(fn [l]\r\n  (loop [a l b {}]\r\n    (if (empty? a)\r\n      b\r\n      (recur (rest a) \r\n             (if (contains? b (first a)) \r\n               (assoc b (first a) (inc (b (first a)))) \r\n               (assoc b (first a) 1))))))","problem":55,"user":"4fd8544be4b0dab7d829f390"},{"problem":55,"code":"(fn[coll]\n  (reduce (fn[counts x]\n            (assoc counts x (inc (get counts x 0)))) {} coll))","user":"55101237e4b06e50f9beb181"},{"problem":55,"code":"(fn co [coll]\n   (into {} (map (fn [[x y]] [x (count y)]) (group-by identity coll))))","user":"5475d755e4b0c51c1f4d72a0"},{"problem":55,"code":"#(reduce (fn [l x] (update-in l [x] (fn [i] (inc (or i 0))))) {} %)","user":"5fd92743e4b05ac5b16ea11f"},{"code":"(fn [xs]\n    (into {} (for [[k v] (group-by identity xs)] [k (count v)])))","problem":55,"user":"526302eee4b03e8d9a4a70a2"},{"problem":55,"code":"#(loop [s %\n        c {}]\n   (if (empty? s)\n     c\n     (recur (rest s)\n            (assoc c\n              (first s)\n              (if (c (first s))\n                (inc (c (first s)))\n                1)))))","user":"551ed214e4b08d5046aa8a4d"},{"code":"(fn [xs]\n   (reduce #(let [v (% %2 0)]\n                 (assoc % %2 (inc v))) {} xs))","problem":55,"user":"52161db6e4b0bf4bffd29cb8"},{"code":"reduce (fn[m x](merge-with + m {x 1})) {}","problem":55,"user":"526a3412e4b03e8d9a4a721e"},{"code":"#(apply hash-map (mapcat (fn [e] (vector (key e) (count (val e)))) (group-by identity %)))","problem":55,"user":"53886d2fe4b0640c7a9a589d"},{"problem":55,"code":"(fn [xs] (reduce #(assoc %1 %2 (+ 1 (or (%1 %2) 0))) {} xs))","user":"553e0b70e4b0a04f792994e8"},{"code":"reduce #(merge-with + % {%2 1}) {}","problem":55,"user":"4e9a8c0e535dbda64a6f6b72"},{"code":"(fn [c]\n  (reduce (fn [m x]\n            (update-in m [x] (fnil inc 0)))\n          {} c))","problem":55,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":55,"code":"(fn [data]\n  (into {} (map (partial (fn [data-in unique-elem]\n                           [unique-elem (count (filter #(= unique-elem %) data-in))])\n                         data)\n                (distinct data))))","user":"5bf5ddfde4b0bdcf453d159e"},{"code":"#(loop [i %\n        o {}]\n   (if (empty? i)\n     o\n     (if (contains? o (first i))\n       (recur (rest i) (assoc o (first i) (+ 1 (get o (first i)))))\n       (recur (rest i) (assoc o (first i) 1)))))","problem":55,"user":"51f28a64e4b0210f90e7454e"},{"problem":55,"code":"(fn [x] (into {}  (map #(hash-map (first %) (count %)) (vals (group-by identity x)))))","user":"550ff2a3e4b06e50f9beb17f"},{"problem":55,"code":"(fn [s]\n   (loop [s s\n          res {}]\n     (if (empty? s)\n       res\n       (recur \n         (rest s) \n         (assoc res (first s) (inc (or (get res (first s)) 0)))))))","user":"5eecf110e4b07c55ae4a050b"},{"code":"(fn [ret col]\r\n  (cond\r\n    (= '() col) ret\r\n    :else \r\n    (recur (assoc ret (first col) (inc (get ret (first col) 0))) (rest col)))) {}","problem":55,"user":"50bfe725e4b080409b860f26"},{"code":"(fn [coll]\n\t(into {}\n    (map\n\t\t\t(fn [[i n]] {i (count n)})\n\t\t\t(group-by identity coll))))","problem":55,"user":"5379306fe4b06839e8705e50"},{"code":"(fn my-freq\n  [xs]\n  (reduce #(if (get % %2) (assoc % %2 (inc (get % %2))) (assoc % %2 1)) {} xs))","problem":55,"user":"536aa86de4b0243289761eb1"},{"code":"(fn [arr] (into {} (distinct (map (fn [x] (into {} {x (count (filter #{x} arr))})) arr))))","problem":55,"user":"52a5d1f3e4b0c58976d9abf1"},{"problem":55,"code":"(fn [coll]\n   (loop [[el & _ :as coll] coll\n          result (apply merge (map #(assoc {} %1 %2) (set coll) (repeat 0)))]\n     (if coll\n       (recur (next coll)\n              (update-in result [el] (fn [old] (inc old))))\n       result)))","user":"5712854ce4b07c98581c3a89"},{"problem":55,"code":"(fn my-count\n  [obj] (reduce (fn [my-map key]\n                  (if (contains? my-map key)\n                    (assoc my-map key (inc (get my-map key)))\n                    (assoc my-map key 1))) {} obj))","user":"5ce3bcd6e4b0a17bb84e2b43"},{"problem":55,"code":"(fn [c] (letfn [(update [m k f] (assoc m k (f (get m k))))] (reduce (fn [m k] (update m k #(if (nil? %) 1 (inc %)))) {} c)))","user":"57c7e7d9e4b05aa3c4741d0f"},{"problem":55,"code":"(fn [x]\n  (reduce (fn [m v]\n            (assoc m v (inc (get m v 0))))\n          {}\n          x))","user":"525cc912e4b0cb4875a45d48"},{"problem":55,"code":"(fn [coll] (reduce (fn [acc item] (update-in acc [item] (fnil inc 0))) {} coll))","user":"54485727e4b032a45b8693c6"},{"code":"(fn freq [sq]\n     (loop [s sq\n            acc {}]\n       (cond\n         (nil? (first s)) acc\n         (contains? acc (first s)) (recur (rest s) (assoc acc (first s) (inc (acc (first s)))))\n         :else (recur (rest s) (assoc acc (first s) 1)))))","problem":55,"user":"4f82e14be4b033992c121c0c"},{"problem":55,"code":"(fn count [s]\n  (loop [s s\n         m {}]\n    (if (empty? s)\n      m\n      (let [k (first s)\n            c (inc (get m k 0))\n            next-m (assoc m k c)]\n        (recur (rest s) next-m)\n        ))\n    )\n  )","user":"57fc0719e4b0d3187e900987"},{"code":"(fn [c]\n  (reduce #(assoc % %2 (count (filter #{%2} c))) {} c))","problem":55,"user":"4e49badd535dc968683fc4c9"},{"problem":55,"code":"#(reduce (fn [new-map [key val]]\n          (assoc new-map key (count val))) {} (group-by identity %))","user":"60bfb68be4b0e0fa5f1b429e"},{"problem":55,"code":"(fn [coll]\n  (let [self-map (group-by identity coll)] \n    (zipmap (keys self-map) (map count (vals self-map)))))","user":"53f6bfd9e4b0db01ade6f9e4"},{"problem":55,"code":"(fn [seq]\n   (reduce \n    #(assoc %1 (first %2) (count (last %2)))\n    {} (group-by identity seq)))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":55,"code":"(fn [coll] (apply merge (map (fn [[k v]] (hash-map k (count v)) ) (group-by identity coll))))","user":"5baaae06e4b0a20761a23464"},{"code":"reduce #(assoc %1 %2 (inc (get %1 %2 0))) {}","problem":55,"user":"4e7dfab0535db169f9c796f9"},{"code":"#(reduce (fn [m, e] (if (m e) (assoc m e (inc (m e))) (assoc m e 1))) {} %)","problem":55,"user":"53820087e4b06839e8705ecf"},{"problem":55,"code":"(fn [coll] (apply array-map (mapcat #(vector (key %) (count (val %))) (group-by identity coll))))","user":"51a7bf26e4b0da5f497bde8c"},{"code":"(fn [xs] (into {} (map #(do [(% 0) (count (% 1))]) (group-by identity xs))))","problem":55,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":55,"code":"(fn [coll] (into {} (map #(conj (vector (first %)) (count (last %))) (group-by identity coll))))","user":"5b34aba7e4b025bcb146f352"},{"code":"(fn co [sq]\n  (let [fmp (apply array-map  (interleave (set sq) (repeat (count sq) 0)))]\n    (loop [tsq sq mp fmp]\n      (if (empty? tsq) mp\n          (recur (rest tsq)  (let  [current_key (first tsq)]\n                   (assoc mp  current_key (+ 1 (get mp current_key)))))))))","problem":55,"user":"5007cdb9e4b0b17c647f5227"},{"problem":55,"code":"(fn [x] (let [m (group-by identity x)]\n          (zipmap (keys m) (map #(count (val %)) m))))","user":"5c2836ebe4b07e362c2305d4"},{"problem":55,"code":"(fn [s] (into (hash-map) (map #(vector (first %) (count (second %))) (group-by identity s))))","user":"5b77248ae4b047b03b2036e7"},{"problem":55,"code":"(fn freqs [xs]\n  (reduce-kv (fn [m k v]\n               (assoc m k (count v)))\n             {}\n             (group-by identity (sort xs))))","user":"56efc9fde4b04a395b9a0464"},{"problem":55,"code":"(fn [x]\n  \t\t(into {} (map #(vector(first %) (count (second %))) (group-by identity x))))","user":"57ee46c7e4b0bfb2137f5bb3"},{"problem":55,"code":"(fn [x]\n  (reduce #(assoc %1 %2 (inc (or (get %1 %2) 0))) {} x))","user":"53aaaf7ae4b047364c044444"},{"problem":55,"code":"(fn [coll] \n  (into {} \n        (map (fn [[k v]] [k (count v)]) \n         (group-by identity coll))))","user":"55306f9de4b076ab5578f814"},{"code":"(fn [col]\n  (reduce (fn [v x]\n            (let* [count (v x)\n                   count (if (nil? count) 1 (inc count))]\n                  (assoc v x count)))\n          {} col))","problem":55,"user":"4fe1a734e4b0dd6cd5ce3637"},{"problem":55,"code":"(fn [coll]\n  (loop [res {}, coll coll]\n    (cond \n       (empty? coll) res\n       :else (recur (assoc res (first coll) (inc (res (first coll) 0))) (rest coll)))))","user":"55efb51ee4b066087aa9453b"},{"code":"(fn c [s]\r\n  (letfn [(h [s m]\r\n              (if (empty? s)\r\n                  m\r\n                  (if (contains? m (first s))\r\n                      (h (rest s) (assoc m (first s) (inc (m (first s)))))\r\n                      (h (rest s) (assoc m (first s) 1)))))]\r\n          (h s (hash-map))))","problem":55,"user":"4df1ce44535d08e6dec9fe1f"},{"problem":55,"code":"(fn [coll]\n    (loop [coll coll\n           coll-acc {}]\n      (cond (empty? coll) coll-acc\n            :else\n            (recur (rest coll)\n                   (assoc coll-acc \n                            (first coll) \n                            (inc (get coll-acc (first coll) 0)))))))","user":"5e724492e4b085ba37836dc7"},{"problem":55,"code":"(fn [coll] \n  (let [m (group-by identity coll)] \n    (reduce-kv #(assoc %1 %2 (count %3)) {} m)))","user":"5e5096c6e4b027a2e10ac0c6"},{"code":"(fn[x]\n  (persistent!\n    (reduce (fn [counts, y] \n              (assoc! counts y (inc (get counts y 0))))\n            (transient {}) x)))","problem":55,"user":"500b61b1e4b03d00572d2d81"},{"problem":55,"code":"(fn [s] (reduce (fn [x y] (update-in x [y] #(inc (or % 0)))) {} s))","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":55,"code":"(fn frequencies'\n  [coll]\n  (into {} (for \n    [[k v] (group-by identity coll)]\n    [k (count v)])))","user":"540b2dcbe4b0addc1aec66f4"},{"problem":55,"code":"#(apply \n   merge \n   (map \n    (fn [[k coll]] {k (count coll)}) \n    (group-by identity %)))","user":"55249f64e4b0882d96d091c6"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [res x] (assoc res x (inc (get res x 0))))\n          {}\n          xs))","user":"5947c6a6e4b07ddc2dafada7"},{"problem":55,"code":"#(into {} (for [x (set %)] [x (count (filter (fn [y] (= x y)) %))]))","user":"5a625bc2e4b0512ff01cd989"},{"problem":55,"code":"(fn [c] (reduce (fn [a x] (update-in a [x] (fnil inc 0))) {} c))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn [coll]\n  (into {}\n        (let [items (set coll)]\n          (for [i items]\n            [i (count (filter (partial = i) coll))]))))","problem":55,"user":"513a4babe4b067e25a345eca"},{"problem":55,"code":"(fn [s]\n   (->> s\n        (group-by identity)\n        (map #(concat {} [(first %) (count (second %))]))\n        (apply concat)\n        (apply hash-map))\n\n   )","user":"573107d5e4b0cd1946bd0fbc"},{"code":"(fn freq[ve] \n  (loop [r {} s ve]\n    (if (= (count s) 0)\n      r\n      (let [f (first s)]\n        (if (contains? r f)\n          (recur (assoc r f (+ (r f) 1)) (rest s))\n          (recur (assoc r f 1) (rest s))\n        )\n      )\n    )\n  )\n)","problem":55,"user":"4e9de526535dbda64a6f6b8e"},{"code":"(fn [v]\n  (loop [v v res {}]\n    (if (empty? v)\n      res\n      (let [h (first v)\n            r (rest v)]\n        (recur r (assoc res h (inc (get res h 0))))))))","problem":55,"user":"5081566ce4b0946d0443855b"},{"code":"(fn count-occurrents [coll]\n  (reduce (fn [acc x] \n      (if (acc x)\n\t      (conj acc [x (inc (acc x))])\n\t      (conj acc {x 1})))\n\t  {}\n\t  coll))","problem":55,"user":"4dc54eb2535d8a4b2fd74284"},{"problem":55,"code":"(fn [s] (let [a (group-by identity s) b (keys a) c (map count (vals a))] (apply hash-map (interleave b c))))","user":"5464a536e4b01be26fd746cf"},{"problem":55,"code":"#(apply merge-with + (map (fn [n] {n 1}) %))","user":"55297a7ae4b0ffed3738f94b"},{"problem":55,"code":"(fn [l]\n  (loop [li l re {}]\n    (if (empty? li)\n      re\n      (recur (rest li)\n             (conj re [(first li) (if (contains? re (first li))\n                                    (inc (re (first li)))\n                                    1)])))))","user":"52979551e4b02ebb4ef75043"},{"problem":55,"code":"(fn frequency-count\n  [seq]\n  (reduce (fn [m x]\n            (let [current-val (get m x)]\n              (if current-val\n                (assoc m x (+ current-val 1))\n                (assoc m x 1))))\n          {}\n          seq))","user":"5759c833e4b02ea11479932c"},{"problem":55,"code":"#(apply merge (for [[k v] (seq (group-by identity %))] {k (count v)}))","user":"54a677a9e4b09f271ff37c88"},{"problem":55,"code":"(fn[xs](let[m (group-by identity xs)\n     ks (keys m)\n     vs (vals m)\n     counts (map count vs)]\n  (apply hash-map (interleave ks counts))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn [coll] \n  (reduce #(assoc % (key %2) (count (val %2))) {} \n  (group-by identity coll)))","problem":55,"user":"4efec33f535dcb61093f6a2a"},{"code":"#(reduce (fn [x y] (merge-with (fn [z _] (if z (inc z) 1)) x y)) {} (map (fn [x] {x 1}) %))","problem":55,"user":"4e1f9bb5535d04ed9115e80d"},{"code":"(fn [s] (apply hash-map (mapcat #(seq [(first %) (count %)]) (partition-by identity (sort s)))))","problem":55,"user":"4f713878e4b07046d9f4f00a"},{"problem":55,"code":"(fn my-freq\n  [c]\n  (reduce\n   (fn [nc x]\n     (assoc nc x (+ (get nc x 0) 1))) {} c))","user":"55c9bc1ee4b0e31453f649f1"},{"code":"(fn mycount [s]\n   (reduce #(assoc %1 (first %2) (second %2))\n           {}\n           (map #(list % (count (filter (partial = %) s))) (distinct s))))","problem":55,"user":"4e89f46c535d3e98b8023288"},{"problem":55,"code":"#(loop [col % rt {}]\n   (if(empty? col)\n     rt\n     (let [new-col (rest col) item (first col) cnt (get rt item 0)]\n       (recur new-col (assoc rt item (inc cnt)) )\n       )\n     )\n   )","user":"5d270111e4b092dab7f59c62"},{"problem":55,"code":"(fn [xs]\n  (loop [[x & xs] xs\n         acc      {}]\n    (if x\n      (recur xs (assoc acc x (inc (get acc x 0))))\n      acc)))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":55,"code":"(fn[a]  \n   (reduce\n   (fn [x y] (merge y x)) \n   '{}\n   (for [b  a]\n    { b,  (reduce \n      (fn[x y] (if (= y b) (inc x) x)) \n       0 \n       a\n      )\n    }\n    )\n    )\n    )","user":"56e6e1e6e4b02e7e935eb6cf"},{"code":"(fn freq\n  ([s] (freq s {}))\n  ([s c]\n   (if (empty? s)\n     c\n     (let [f (first s)\n           fc (or (c f) 0)]\n       (recur (rest s) (assoc c f (inc fc)))))))","problem":55,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn [s]\n  (reduce (fn [counts element]\n            (assoc counts element (count (filter #(= element %) s))))\n          {}\n          (distinct s)))","problem":55,"user":"53527551e4b084c2834f4af0"},{"problem":55,"code":"(fn [coll]\n  (->> coll\n     sort                     ; put all same values together\n     (partition-by identity)  ; split them in blocks of same value\n     (map #(vector (first %1) (count %1))) ; make a series of vectors with [value count]\n     (into {})))                           ; convert into a map","user":"563772a9e4b0bfe05bf117d7"},{"problem":55,"code":"(fn [lol] \n  (into {} \n    (map \n      (fn [x] [(first x) (count x)] )  \n      (partition-by identity (sort lol)) )) )","user":"608e5697e4b03bd49d9f36be"},{"problem":55,"code":"(fn [s] (->> s (sort) (partition-by identity) (#(zipmap (map first %) (map count %))) ))","user":"53ced9fee4b00fb29b2212f8"},{"code":"#(let [s (group-by identity %)]\n  (zipmap (keys s) (map count (vals s))))","problem":55,"user":"50843a4ae4b0c98812d0788b"},{"code":"(fn [s]\n  (into {} (for [[k v] (group-by identity s)] [k (count v)])))","problem":55,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn [l] (reduce merge (map #(hash-map (first %) (count %)) (vals (group-by identity l)))))","problem":55,"user":"4fcebce4e4b03432b189f404"},{"code":"(fn [n]\n  (into {} \n    (map (fn [a] {a (count (filter (fn [x] (= x a)) n))}) n)))","problem":55,"user":"4f189b42535d64f60314645d"},{"code":"(fn count-ocurr\n\t[coll]\n\t(reduce #(conj %1 {(key %2) (count (val %2))}) {} (group-by identity coll)))","problem":55,"user":"5339af7de4b0e30313ee6cab"},{"problem":55,"code":"(fn [col]\n  (into {} (map (fn [x] [(first x) (count x)]) (vals (group-by identity col)))))","user":"59a8405ce4b0bcf4e9a43af1"},{"problem":55,"code":"(fn frequencies* [coll]\n  (loop [out {}\n         coll coll]\n    (let [head (first coll)\n          tail (rest  coll)]\n      (if head\n        (if (contains? out head)\n          (recur (merge-with + out {head 1}) tail)\n          (recur (assoc out head 1) tail))\n        out))))","user":"60b66033e4b0e0fa5f1b4248"},{"code":"(fn [s]\n  (reduce\n    (fn [m k]\n      (update-in m [k] (fnil inc 0)))\n    {}\n    (seq s)))","problem":55,"user":"51929214e4b08962174cf74c"},{"code":"reduce (fn [a b] \n           (conj a {b (if (a b) \n                           (inc (a b))\n                           1)})) {}","problem":55,"user":"4fdd27f3e4b05e33b9224f78"},{"code":"(fn [x]\n  (let [k (partition-by identity (sort x))]\n    (reduce #(into %1 {(first %2) (count %2)}) {} k)))","problem":55,"user":"50a5f72fe4b0aa96157e2611"},{"problem":55,"code":"(fn [words]\n  (reduce\n    #(assoc %1 %2 (inc (get %1 %2 0)))\n    {}\n    words))","user":"5c79030be4b0fca0c1622830"},{"problem":55,"code":"(let [fmap #(zipmap (keys %2) (map %1 (vals %2)))]\n  #(->> % (group-by identity) (fmap count)))","user":"55253217e4b0882d96d091ce"},{"code":"(fn [in-seq]\n  (loop [local-seq in-seq out-counts {}]\n    (if (empty? local-seq) out-counts\n      (recur (rest local-seq)\n        (if (contains? out-counts (first local-seq))\n          (assoc out-counts (first local-seq) (inc (out-counts (first local-seq))))\n          (assoc out-counts (first local-seq) 1))))))","problem":55,"user":"4ef4ab95535dced4c769f23b"},{"problem":55,"code":"(fn [s]\n  (reduce #(assoc %1 (%2 0) (count (%2 1))) {} (group-by identity s))\n)","user":"540f09b9e4b0addc1aec6725"},{"code":"(fn [coll]\r\n  (reduce (fn [counts x]\r\n            (assoc counts x (inc (get counts x 0))))\r\n          {} coll))","problem":55,"user":"4e570b60535d8a8b8723a286"},{"problem":55,"code":"(fn [coll]\n  (into (sorted-map)\n        ((fn [coll results]\n           (if (empty? coll) results\n             (recur (rest coll) \n                    (merge-with #(+ %1 %2) \n                                {(first coll) 1} \n                                results))))\n         coll\n         {})))","user":"55f344afe4b06e875b46ce5a"},{"code":"(fn occ [xs]\n  (reduce\n\t\t#(assoc %1 %2 (inc (get %1 %2 0)))\n\t\t{}\n\t\txs\n\t)\n)","problem":55,"user":"4ed6238d535d10e5ff6f52de"},{"code":"(fn [coll]\r\n  (let [wcoll (group-by identity coll)]\r\n    (zipmap (keys wcoll) (map count (vals wcoll)))))","problem":55,"user":"4dd7d040535d2dad7130b5d6"},{"problem":55,"code":"(fn [coll] (into (sorted-map) (map (fn [[k v]] {k (count v)}) (group-by identity coll))))","user":"5addadfce4b0837691e92c13"},{"problem":55,"code":"(fn [xs] (->> xs sort (partition-by identity) (map (juxt first count)) (into {})))","user":"54187e84e4b01498b1a71a1b"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [x] [(first x) (count x)]) (partition-by identity (sort %))))","user":"56aed78fe4b03c432f187363"},{"problem":55,"code":"#(reduce\n  (fn [m v]\n    (update-in m [v]\n               (fn [x]\n                 (if \n                   (nil? x) 1\n                   (inc x))))) \n  {} %)","user":"556c70dae4b09a3098a524fd"},{"problem":55,"code":"#(loop [coll % m {}]\n    (if (not (zero? (count coll)))\n      (recur (next coll) (merge-with + m {(first coll) 1}))\n      m))","user":"5446ebc2e4b032a45b8693b8"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (reduce \n   (fn [map item]\n     (let [count (get map item 0)]\n       (assoc map item (inc count))))\n   {}\n   coll))","user":"5e805895e4b085ba37836e44"},{"problem":55,"code":"(fn freq\n  ([coll] (freq coll {}))\n  ([coll res]\n   (if (seq coll)\n     (let [key (first coll)\n           val (get res key)]\n       (if val\n         (recur (rest coll)\n                (assoc res key (inc val)))\n         (recur (rest coll)\n                (assoc res key 1))))\n     res)))","user":"54c3747de4b045293a27f60e"},{"problem":55,"code":"(fn [L]\n      (let [Groups (group-by identity L)]\n        (println Groups)\n        (loop [Ret {} First (first Groups) Rest (rest Groups)]\n          (if (nil? First)\n            Ret\n            (recur\n              (assoc Ret (get First 0) (count (get First 1)))\n              (first Rest)\n              (rest Rest)\n            )\n          )\n        )\n      )\n    )","user":"5d4a6c6ce4b0776584bd6f22"},{"code":"(fn [c]\n  (into {} \n    (map \n      #(vector (first %) (count (second %))) \n      (group-by min c))))","problem":55,"user":"4ee4f4a9535d1385b2869d85"},{"problem":55,"code":"(fn f [xs]\n  (reduce\n    (fn [res x]\n      (assoc res x ((fnil inc 0) (get res x))))   \n    {} xs))","user":"53b42472e4b047364c0444b2"},{"problem":55,"code":"reduce #(assoc % %2 (inc (get % %2 0))) {}\n;#(into {} (map (fn [[k v]] [k (count v)]) (group-by identity %)))","user":"57ba55c1e4b0fbc9809a2801"},{"problem":55,"code":"(fn [coll] (let [f (group-by identity coll)]\n\t(zipmap (keys f)\n\t\t\t(map count (vals f)))\n\t)\n)","user":"5472d919e4b094393f72dd7b"},{"code":"(fn [s]\n  (letfn [(freq [r n]\n            (if (contains? r n)\n                (assoc r n (inc (get r n)))\n                (assoc r n 1)))]\n    (reduce freq {} s)))","problem":55,"user":"526f9715e4b03e8d9a4a7372"},{"problem":55,"code":"(fn [xs]\n (persistent!\n  (reduce \n   (fn [c n]\n    (assoc! c n (inc (get c n 0))))\n   (transient {}) xs)))","user":"55597b84e4b0deb715856e36"},{"problem":55,"code":"(fn [s] (->> s\n     (group-by #(identity %) )\n     (mapcat #(list (% 0)(count (% 1))))\n     (apply hash-map)))","user":"4fc4eb1ee4b081705acca354"},{"problem":55,"code":"(fn [col]\n  (reduce #(update-in %1 [%2] (fn [v] (inc (or v 0)))) {} col))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn occur\n  [input]\n  (->> input\n      sort\n      (partition-by identity)\n       (map #(hash-map (first %) (count %)))\n      (into {})))","problem":55,"user":"5271605ae4b03e8d9a4a73ed"},{"problem":55,"code":"(fn my-frequencies [s] (reduce (fn [m k] (update-in m [k] #(if (nil? %) 1 (inc %) ))) {} s))","user":"5c7bc0a5e4b0fca0c1622865"},{"code":"(fn [s] (apply merge-with + (map #(hash-map % 1) s)))","problem":55,"user":"4f043ed1535dcb61093f6bb4"},{"problem":55,"code":"(fn [s]\n  (into {} (map #(vector (% 0) (count (% 1))) (group-by identity s))))","user":"5dcc152ae4b02b31cc3da3c3"},{"code":"(fn f\n  ([lst]\n    (f lst {}))\n  ([lst hm] \n    (if lst \n      (let [\n        [x & xs] lst \n        v (or (hm x) 0)] \n        (f xs (assoc hm x (inc v)))) \n      hm)))","problem":55,"user":"4f1fd734535d64f6031464a5"},{"problem":55,"code":"(fn [a] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity a)))","user":"583e1558e4b089d5ab817da9"},{"problem":55,"code":"(fn [aseq] (reduce\n            (fn [counts el]\n              \t(let [cur-count (or (get counts el) 0)]\n                 \t (assoc counts el (inc cur-count)) ))\n            {}\n            aseq))","user":"564127a9e4b08d4f616f5ef3"},{"code":"#(reduce (fn [m k] (conj m [k (inc (m k 0))])) {} %)","problem":55,"user":"4ded27db535d08e6dec9fe0a"},{"problem":55,"code":"#(into {} (map (fn [[k v]] [k (count v)])(group-by identity %)))","user":"5f5b624de4b05ea7b9adc42f"},{"code":"(fn [x]\n  (reduce \n   \t(fn [acc i]\n      (assoc acc i (inc (get acc i 0)))\n    )\n    {}\n    x\n  )\n)","problem":55,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":55,"code":"(fn [s]\n\t(reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity s)))","user":"5829d588e4b051871117bf4a"},{"code":"(fn [coll]\n  (apply conj\n    (map (fn [n] {(key n) (count (val n))})\n      (group-by (fn [n] n) coll))))","problem":55,"user":"4f3242bae4b0d6649770a08f"},{"problem":55,"code":"(fn[a]\n  (apply merge (map #(hash-map (key %) (count(val %))) (group-by identity a))))","user":"53ed2fafe4b0d648e757f4c1"},{"code":"(fn freq [v] (reduce #(if (%1 %2) \n                          (update-in %1 [%2] inc)\n                          (assoc %1 %2 1))  {} v))","problem":55,"user":"5065bd94e4b0148eb3925aed"},{"problem":55,"code":"(fn [vs]\n            (->> vs\n                 (group-by (set vs))\n                 (map (fn [[k v]]\n                        [k (count v)]))\n                 (into {})))","user":"53684a2fe4b0243289761e8c"},{"problem":55,"code":"(fn [a-seq]\n  (loop [a-seq   a-seq\n         a-map   {}]\n    (if (empty? a-seq)\n      a-map\n      (recur (rest a-seq) (if (contains? a-map (first a-seq))\n                            (update-in a-map [(first a-seq)] inc)\n                            (assoc a-map (first a-seq) 1))))))","user":"574e84e0e4b02ea114799243"},{"code":"(fn frequencies_ [s]\n  (apply hash-map\n    (mapcat #(vec [(first %) (count (second %))]) \n            (group-by identity s))))","problem":55,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn [xs] (apply hash-map (mapcat #(list (first %) (count %)) (partition-by identity (sort xs)))))","problem":55,"user":"4ea365e2535d7eef308072c5"},{"problem":55,"code":"(fn [x]\n  (->> x\n       (group-by identity)\n       ;; (map (juxt identity count))\n       (reduce-kv #(assoc %1 %2 (count %3)) {})\n\n       )\n\n  )","user":"5c527129e4b0fb8c5ffd99de"},{"code":"(fn [s] (reduce #(merge-with + % {%2 1}) {} s))","problem":55,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn zrequencies [n]\n  (let [groups (group-by identity n)\n        items (keys groups)\n        counts (map count (vals groups))]\n     (zipmap items counts)\n  )\n)","problem":55,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":55,"code":"(fn [col]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0) ) ) {} (sort col))\n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"code":"(fn [s]\n  (reduce\n   #(if (contains? %1 %2)\n      (assoc %1 %2 (inc (get %1 %2)))\n      (assoc %1 %2 1))\n   {}\n   s))","problem":55,"user":"5175533fe4b0dea9bbfba575"},{"problem":55,"code":"(fn [lists]\n  (reduce\n \t(fn [acc x]\n   \t(if-let [v (get acc x)]\n    \t (assoc acc x (inc v))\n     \t(assoc acc x 1)))\n \t{}\t\n\t lists)\n  )","user":"5785de43e4b0ebec4cfb74e5"},{"code":"(fn [seqn]\n  (->> seqn\n  \t   (group-by identity)\n       (map (fn [[k v]] [k (count v)]))\n       (reduce conj {})))","problem":55,"user":"53834ed3e4b06839e8705edb"},{"problem":55,"code":"(fn [l]\n   (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity l)))","user":"5f3f2281e4b004f08c61c561"},{"code":"#(into {} (map (fn [[x v]] [x (count v)]) (group-by identity %)))","problem":55,"user":"4e48b61d535dc968683fc4be"},{"code":"#(reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} %)","problem":55,"user":"4e6a97a9535d8ccf87e9fef8"},{"problem":55,"code":"#(->> %\n      (reduce (fn [a b]\n                (merge-with + a {b 1}))\n              {}))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":55,"code":"(fn fq [c]\n  (reduce #(assoc % %2 (inc (get % %2 0))) {} c))","user":"508c3d42e4b0f17d83ea26b2"},{"problem":55,"code":"#(into {}\n   (for [[k v] (group-by identity %)]\n     {k (count v)}))","user":"55912230e4b027778923767a"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc v]\n     (assoc acc v\n            (reduce #(if (= %2 v)\n                       (inc %1)\n                       %1)\n                    0\n                    coll)))\n   {}\n   (set coll)))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":55,"code":"(fn [coll]\n   (into {} (for [[k v]  (group-by identity coll)] [k (count v)])))","user":"57147cd9e4b07c98581c3abf"},{"problem":55,"code":"(fn [s]\n  (reduce #(assoc % %2 (+ 1 (% %2 0)))\n          {} s))","user":"5731e36be4b0cd1946bd0fc9"},{"problem":55,"code":"(fn countOcc [xs]\n  (loop [ys xs, m {}]\n    (if (empty? ys) \n        m\n        (recur (next ys) (if (m (first ys))\n                                (assoc m (first ys) (+ (m (first ys)) 1))\n                                (assoc m (first ys) 1))))))","user":"5aa5951ae4b0d174b936c899"},{"code":"(fn [coll]\n  (let [c (for [i coll] (count (filter #(= % i) coll)))]\n    (apply sorted-map \n          (interleave coll c))))","problem":55,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":55,"code":"#(apply merge (for [x (group-by identity %)] {(key x) (count (val x))}))","user":"5587d8b3e4b059ccff29b1e8"},{"problem":55,"code":"(fn [coll]\n  (into {} (map #(vector (first %) (count %)) (partition-by identity (sort coll)))))","user":"54d70bbfe4b0a52adc2e2026"},{"problem":55,"code":"#(apply merge-with + (map (fn [[k v]] (hash-map k v)) (partition 2 (interleave % (repeat 1)))))","user":"55fc07d3e4b0f488688e066e"},{"code":"(fn [seq] (apply merge-with + (map (fn [v] {v 1}) seq)))","problem":55,"user":"4e994541535dbda64a6f6b64"},{"code":"; much better: (into {} (map (fn [[k vs]] [k (count vs)]) (group-by identity coll)))\n(fn [coll] (apply array-map \n       (mapcat #(list %2 (count %1)) \n               (partition-by identity (sort coll))\n               (sort (set coll)))))","problem":55,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn [x] (apply hash-map (mapcat #(list (key %) (count (val %))) \n(group-by identity x))))","problem":55,"user":"4eaede1f535d7eef30807329"},{"problem":55,"code":"(fn f55\n  [xs]\n  (into {} (for [i (group-by identity xs)] [(key i) (count (val i))])))","user":"59390a35e4b02506e01a29f3"},{"code":"reduce #(assoc % %2 (inc (or (% %2) 0))) {}","problem":55,"user":"4e9b230c535dbda64a6f6b75"},{"code":"(fn [a-seq]\n  (->> (group-by identity a-seq)\n       vals\n       (map #(vector (first %)\n                     (count %)))\n       (into {})))","problem":55,"user":"52890634e4b0239c8a67ae5e"},{"problem":55,"code":"(fn [xs]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} xs)\n)","user":"54074fc5e4b0addc1aec66b6"},{"code":"(fn [s]\n  (into {} \n        (map #(vector (first %) (count (second %)))\n             (group-by identity s))))","problem":55,"user":"512eb723e4b0b740abc5982b"},{"problem":55,"code":"(fn my-count [s]\n\t\t(reduce #(let [ { x-count %2\n\t\t\t\t\t\t :or {x-count 0}} %1]\n\t\t\t\t\t(assoc %1 %2 (inc x-count))) \n                {} \n                s)\n\t\t)","user":"54ff6084e4b07d26eda61d50"},{"problem":55,"code":"(fn [coll]\n  (loop [s (set coll)\n         c coll\n         result {}]\n    (if (empty? s)\n      result\n      (recur (rest s)\n             c\n             (conj result {(first s)\n                   (count (filter #(= (first s) %) c))})))))","user":"5c558070e4b0fb8c5ffd9a1e"},{"code":"(fn [s] (apply merge (map #(hash-map (first %) (count (second %))) (group-by identity s))))","problem":55,"user":"523b1988e4b02f719975bdbc"},{"problem":55,"code":"(fn [col] \n  (reduce-kv (fn [m k v]\n              (assoc m \n                     k \n                     (count v)))\n             {}\n             (group-by identity \n                       col)))","user":"55d8eed3e4b0e31453f64ac3"},{"code":"(fn [vs]\r\n  \t(reduce \r\n      (fn [m v] (update-in m [v] #(if % (inc %) 1))) \r\n      {} vs))","problem":55,"user":"4f4fbed7e4b03ad3f0c10ce8"},{"problem":55,"code":"#(into {} (map (fn [[val occur]] [val (count occur)]) (group-by identity %)))","user":"524740e7e4b05ef8e38e635d"},{"code":"#(into {}\n  (map (fn [[k v]] [k (count v)])\n       (group-by identity %)))","problem":55,"user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn [a]\n  (into {} (map #(vector (first %) (count %)) (vals (group-by identity a)))))","problem":55,"user":"4de52c87535d08e6dec9fdf0"},{"problem":55,"code":"(comp (partial into {}) \n      (partial map (juxt first count)) \n      vals \n      (partial group-by identity))","user":"5457e5f1e4b01be26fd74613"},{"problem":55,"code":"(fn [s] (into {} (map #(identity [(first %) (count (last %))]) (seq (group-by identity s)))))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m el] (assoc m el (if-let [c (get m el)] (inc c) 1)))\n          {}\n          coll))","user":"579c35fee4b05b1deef9ae04"},{"code":"#(let [groups (group-by identity %)] (zipmap (keys groups) (map count (vals groups))))","problem":55,"user":"50b29029e4b03ea880433563"},{"code":"(fn [c] (apply merge (map #(hash-map (key %) (count (val %))) (group-by identity c))))","problem":55,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":55,"code":"(fn freq [l]\n  (if (empty? l)\n    {}\n    (let [m (freq (rest l))\n          item (first l)]\n      (assoc m item\n             (inc\n              (get\n               m item 0))))))","user":"598ab445e4b02b9968b84ce0"},{"problem":55,"code":"(fn freq [s]\n  (into (hash-map) (map #(vector % (count (filter (fn [x] (= x %)) s))) (set s))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn [xs]\r\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs))","problem":55,"user":"4f07c8c3535dcb61093f6c2d"},{"code":"(fn count-occurrences\n  [input]\n  (into {}\n        (map #(vector (first %) (count (second %)))\n          (group-by identity input))))","problem":55,"user":"5300b750e4b0d8b024fd3711"},{"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (-> (get %1 %2) (or 0) inc)) {} coll))","problem":55,"user":"51ab4082e4b04e3dc0c27b31"},{"problem":55,"code":"(fn my-frequencies\n  [xs]\n  (reduce (fn [accum x]\n            (let [v (accum x)]\n              (assoc accum x (inc (if (nil? v) 0 v)))))\n          {}\n          xs))","user":"5c222b7de4b07e362c230588"},{"problem":55,"code":"(fn [s] (into {} (map #(vector (key %) (count (val %))) (group-by identity s))))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn freq [xs]\r\n  (reduce (fn [a x] (let [f (get a x 0)] (assoc a x (inc f))))\r\n    (hash-map)\r\n    xs))","problem":55,"user":"4dd52e29535dae65d5c462e5"},{"problem":55,"code":"(partial reduce #(conj %1 [%2 (inc (%1 %2 0) )]) {})","user":"584917a1e4b089d5ab817ec9"},{"problem":55,"code":"(fn freqs [coll]\n  (loop [c coll\n         acc {}]\n    (if (empty? c)\n        acc\n        (recur (rest c) (assoc acc (first c) (inc (get acc (first c) 0)))))))","user":"556a6137e4b09a3098a524e0"},{"problem":55,"code":"(fn [l]\n    (#(apply hash-map (interleave (keys %) (map count (vals %))))\n      (group-by identity l)))","user":"55d74e71e4b0e31453f64aa4"},{"problem":55,"code":"#(letfn\n   [(occurence [[fseq & rseq] result]\n      (cond\n        (nil? fseq) result\n        (contains? result fseq) (->>\n                                  [fseq (inc (result fseq))]\n                                  (conj result)\n                                  (recur rseq)\n                                  )\n        :else (->>\n                [fseq 1]\n                (conj result)\n                (recur rseq)\n                )\n        )\n      )]\n   (occurence % {})\n   )","user":"5b118b7be4b0cc2b61a3be34"},{"problem":55,"code":"reduce\n    #(assoc % %2 (+ 1 (% %2 0)))\n     {}","user":"4e6a23d0535d8ccf87e9fea0"},{"problem":55,"code":"#(apply merge (map (partial apply hash-map) (map (fn [[i is]] (vector i (count is))) (group-by identity %))))","user":"5581747fe4b05c286339e0fa"},{"problem":55,"code":"(fn [col]\n   (reduce (fn [ret x]\n             (if (contains? ret x)\n               (update-in ret [x] inc)\n               (assoc ret x 1)))\n           {}\n           col))","user":"608e3bf7e4b03bd49d9f36bd"},{"problem":55,"code":"(fn freq[l]\n  (into {} (map\n    (fn [x]\n      (vector \n        x\n        (count\n          (filter\n            #(= x %)\n            l))))\n    (apply sorted-set l))))","user":"5626447fe4b00e49c7cb47bd"},{"code":"(fn freq [xs]\n  (let [k (distinct xs)]\n    (apply hash-map \n           (interleave \n             k\n             (map \n               (fn count-vals-of [x] (count (filter #(= % x) xs)))        \n               k)))))","problem":55,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn counto [x] \n  (if (seq x) \n      (let [i (first x)] \n        (merge {i (count (filter #(= i %) x))} \n        (counto(remove #(= i %) x))))))","problem":55,"user":"4f048f67535dcb61093f6bd3"},{"code":"#(reduce (fn r [a b] (into a {(first b) (count (fnext b))})) {} (group-by (fn ! [i] i) %))","problem":55,"user":"4e8a460e535d65386fec2109"},{"problem":55,"code":"#(into {} (for [ [k v] (group-by identity %)] [k (count v)]))","user":"5779556de4b0979f8965166e"},{"problem":55,"code":"reduce (fn [v n]\n           (assoc v n (inc (or (v n) 0))))\n       {}","user":"5742ec91e4b05c31a32c0883"},{"code":"(fn[a-seq]\n  (let [dist (distinct a-seq)]\n    (apply hash-map\n       (mapcat (fn[x] [x (count (filter \n                                 (fn[y](= y x))\n                                  a-seq))])\n         dist))))","problem":55,"user":"4e58bcd4535d8a8b8723a296"},{"problem":55,"code":"#(zipmap\n    (keys (group-by identity %))\n    (map count (vals (group-by identity %)))\n    )","user":"5f0824c5e4b0cf489e8d7f5b"},{"code":"#(into {} (for [[k v] (group-by identity %1)] [k (count v)]))","problem":55,"user":"50dcb2f4e4b02e6ac9592c91"},{"code":"(fn [coll]\n  (reduce #(assoc %1 (first %2) (count %2)) {} (vals (group-by identity coll))))","problem":55,"user":"4f1c2a3a535d64f603146480"},{"code":"#(into {} (map (fn[[x,y]] [x,(count y)]) (group-by identity %)))","problem":55,"user":"52d36f60e4b099d49816f0c2"},{"code":"(fn cust-freq [coll]\n  (reduce\n    (fn [m n]\n\t  (assoc m n (inc (get m n 0))))\n\t{}\n\tcoll))","problem":55,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [coll]\n  (let [g (group-by identity coll)]\n    (zipmap (keys g)\n            (map count (vals g)))))","problem":55,"user":"519db0ede4b037b32803f9b9"},{"problem":55,"code":"(fn count-occurences [sequ] (reduce (fn [xs x] (if (contains? xs x) (into xs {x (inc (get xs x))}) (into xs {x 1}))) {} sequ))","user":"5df0c6ffe4b093ff717275c2"},{"problem":55,"code":"(fn [data]\n  (into {} \n        (map \n         (fn [[e l]] [e (count l)]) \n         (group-by identity data))))","user":"5640eb50e4b08d4f616f5eec"},{"code":"(fn asdf [coll] \n  (let [grouped (group-by identity coll)]\n    (zipmap (keys grouped) (map count (vals grouped)))))","problem":55,"user":"525aa499e4b0cb4875a45cf7"},{"problem":55,"code":"(fn [coll]\n  (let [m (group-by identity coll)]\n     (zipmap (keys m) (map count (vals m)))))","user":"572a856be4b0f4d77e65123b"},{"problem":55,"code":"(fn [coll]\n  (let [gs (partition-by identity (sort coll))]\n    (zipmap\n      (map first gs)\n      (map count gs))))","user":"53ca41dae4b00fb29b2212c8"},{"problem":55,"code":"#(reduce (fn [m item] (let [v (get m item 0)] (assoc m item (inc v)))) {} %)","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":55,"code":"(fn [coll]\n      (reduce #(assoc %1 %2 (inc (get %1 %2 0)))\n              {}\n              coll))","user":"57b9f35be4b0fbc9809a27f9"},{"problem":55,"code":"(fn f [col]\n    (reduce\n      #(assoc % %2 (inc (get % %2 0)))\n      {}\n      col))","user":"5a00cb31e4b01bb0ae8afd36"},{"code":"(fn num-occur [l]\n  (reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity l)))","problem":55,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":55,"code":"(fn [s]\n  (reduce #(merge-with + %1 %2)\n              (map (fn [a] {a 1}) s)))","user":"51db0d99e4b06aa4d4669a9d"},{"code":"#(let [s (partition-by identity (sort %))]\n  (apply hash-map\n    (mapcat list (map first s) (map count s))))","problem":55,"user":"50464831e4b011c5dfee771f"},{"problem":55,"code":"(fn [coll]\n   (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll)\n   )","user":"589a8dace4b00487982d5311"},{"problem":55,"code":"(fn [coll]\n  (into {} (map (fn [i] {(first i) (count i)}) (partition-by identity (sort coll)))))","user":"53bd7080e4b0d9a98559a6d1"},{"code":"(fn [s]\n  (apply merge-with +\n                    (map (fn [x] {x 1}) s)))","problem":55,"user":"51460e4ce4b04ef915e37314"},{"problem":55,"code":"(fn count-occ [s]\n  (apply hash-map (mapcat (fn [[k v]] [k (count v)]) (group-by identity s))))","user":"56791447e4b05957ce8c6183"},{"problem":55,"code":"(fn [lst]\n  (loop [l lst m {}]\n    (if (empty? l)\n      m\n      (if (contains? m (first l))\n        (recur (rest l) (update-in m [(first l)] inc))\n        (recur (rest l) (assoc m (first l) 1))))))","user":"5a653f80e4b0512ff01cd9b2"},{"code":"(fn [s]\n  (let [d (distinct s)\n        f (fn [x] (filter #(= x %) s))\n        counts (map count (map f d))]\n    (zipmap d counts)))","problem":55,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":55,"code":"#(reduce (fn [coll e]\n            (if (contains? coll e)\n                (update-in coll [e] inc)\n                (assoc coll e 1))) {} %)","user":"52fa250ee4b047fd55836ff3"},{"problem":55,"code":"(fn [a-seq]\n  (let [counter (fn [b-map number] (if (contains? b-map number)\n                                    (assoc b-map number (inc (get b-map number)))\n                                    (assoc b-map number 1)))]\n    (reduce counter {} a-seq)))","user":"571cd9dce4b0145328a76271"},{"code":"(fn freq [coll]\n  (letfn [(f [n]\n\t\t(count (filter (partial = n) coll)))] (let [c (distinct coll) v (map f c)] (apply hash-map (interleave c v)))))","problem":55,"user":"4ef5c7ce535dced4c769f248"},{"code":"#(into {} \n  (map (fn[[k v]] [k (count v)]) (group-by identity %)))","problem":55,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":55,"code":"(fn map-frequencies\r\n  [xs]\r\n  (reduce (fn [m i] \r\n(assoc m i (inc (m i 0)))) {} xs))","user":"608c270ae4b03bd49d9f36b3"},{"problem":55,"code":"#(reduce (fn [s v]\n           (assoc-in s (vector v) (if (s v)\n                                    (inc (s v))\n                                    1))) {} %)","user":"56b18445e4b0982f16b37dee"},{"problem":55,"code":"#(reduce (fn [x y] (assoc x (y 0) (count (y 1)))) {} (group-by identity %))","user":"578b140be4b0ebec4cfb7545"},{"code":"(fn [s]\r\n  (loop [tail s, freqs {}]\r\n    (if-let [[x & xs] (seq tail)]\r\n      (recur xs (assoc freqs x (inc (get freqs x 0))))\r\n      freqs)))","problem":55,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn [xs]\n  (into {}\n        (map (fn [[key val]] [key (count val)])\n             (group-by identity xs))))","problem":55,"user":"5173726be4b098276e74652c"},{"problem":55,"code":"#(apply merge\n        (map (fn [[x y]] {x (count y)})\n             (group-by identity %)))","user":"5da760ebe4b000c986472c1a"},{"problem":55,"code":"(fn[_seq](reduce (fn[result head]\n\t\t\t(assoc result head (inc(get result head 0)))) {} _seq))","user":"5954eef0e4b066ee0a44af17"},{"problem":55,"code":"(fn freqs [coll]                                                               \n  (reduce (fn [acc el]                                                           \n            (update-in acc [el] (fnil inc 0)))\n          {} coll))","user":"58ebd10de4b056aecfd47d49"},{"problem":55,"code":"(fn [lst] (loop [m {} s lst] (if (empty? s) m (recur (update-in m (vector (first s)) (fn [x] (if (nil? x) 1 (inc x)))) (rest s)))))","user":"59c734e3e4b0a024fb6ae53f"},{"problem":55,"code":"(fn [x]\n  (into {} (map \n            (fn [[k v]]\n              {k (count v)}) \n            (group-by identity x))))","user":"5ecf55dae4b016b56eae05a8"},{"problem":55,"code":"#(reduce\n  (fn [result x]\n    (assoc result x\n           (if-let [count (get result x)] (inc count) 1)))\n  {} %)","user":"552a793ee4b0ffed3738f955"},{"problem":55,"code":"#(reduce (fn [acc next-value] (update-in acc [next-value] (fn [old] (inc (or old 0))))) {} %)","user":"5773f3a9e4b0979f896515f2"},{"code":"reduce #(assoc-in % [%2] (inc (% %2 0))) {}","problem":55,"user":"4eb30868535d7eef30807355"},{"problem":55,"code":"(fn [s]\n  (loop [s s res '{}]\n    (if (empty? s)\n      res\n      (recur (rest s) (if (res (first s)) \n                        (conj res (hash-map (first s) (inc (res (first s)))))\n                        (conj res (hash-map (first s) 1)))))))","user":"563d12f9e4b0bfe05bf11845"},{"code":"#(reduce (fn[coll val](assoc coll val (inc (get coll val 0)))) {} %1)","problem":55,"user":"52bc6cb2e4b07a9af57922f5"},{"code":"(fn [c] (reduce #(assoc % (first %2) (count %2)) {} (partition-by identity (sort c))))","problem":55,"user":"50ebd63ce4b04edc3377703c"},{"code":"#(into {} (map (fn[[k v]][k (count v)]) (group-by (fn[x]x) %)))","problem":55,"user":"4f296a80e4b0d6649770a02a"},{"code":"#(apply hash-map \n  (mapcat \n    (juxt first count) (partition-by identity (sort %))))","problem":55,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(fn [coll]\n  (let [m (group-by count (partition-by identity (sort coll)))]\n\t  (zipmap (map (comp first first) (vals m)) (keys m))))","problem":55,"user":"4db045b5838c48654951d9be"},{"problem":55,"code":"#(->> (map (fn [a] {a 1}) %) (apply merge-with +))","user":"57d0e185e4b0bd073c202360"},{"code":"#(reduce (fn [m x] (assoc m x (inc (m x 0)))) {} %)","problem":55,"user":"4e6f1b7a535d5021c1a89618"},{"code":"(fn [xs] (into {} ( for [x (distinct xs) :let [y (count (filter #(#{x} %1) xs))]] [x y])))","problem":55,"user":"5225b16de4b0d2f5d1e2c0ed"},{"code":"reduce (fn [m x] (assoc m x (inc (get m x 0)))) {}","problem":55,"user":"4fc4eadee4b081705acca353"},{"code":"(fn [s]\n  (reduce \n    #(update-in %1 [%2] (fnil inc 0))\n    {}\n    s))","problem":55,"user":"4ecb1641535d6d7199dd370e"},{"code":"#(reduce (fn [m k] (assoc m k (inc (get m k 0)))) {} %)","problem":55,"user":"4e521cef535d302ef430da6d"},{"problem":55,"code":"(fn freq [coll]\n  (reduce \n    #(assoc %1 %2 (inc (get %1 %2 0)))\n    {}\n    coll))","user":"5f300f28e4b033932238a682"},{"problem":55,"code":"#(apply hash-map (mapcat (fn [[k vs]] [k (count vs)]) (group-by identity %)))","user":"585d9558e4b0f14aab7c879c"},{"problem":55,"code":"(fn [s]\n       (apply hash-map       \n              (apply concat\n                (map   \n                  (fn [i]\n                    (list i (count (filter #(= i %) s)))\n                    )\n                  (distinct s)\n                  )\n                )\n              )\n       )","user":"55c3149de4b0e31453f64987"},{"problem":55,"code":"(fn [xs] (reduce (fn [m b] (assoc m b (inc (get m b 0)))) {} xs))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn [s]\n   (reduce\n    (fn [m v]\n      (update-in m [v] (fnil inc 0)))\n    {} s))","problem":55,"user":"529ce629e4b04e0c58e87b6e"},{"code":"(fn [x]\n  (loop [r {}\n         t (set x)]\n    (if (empty? t)\n        r\n        (recur (assoc r (first t) (count (filter #(= (first t) %) x))) (rest t)))))","problem":55,"user":"52a5a8ebe4b0c58976d9abed"},{"problem":55,"code":"(fn [coll]\n  (into {} \n    (map (fn [[k v]] [k (count v)])\n      (group-by identity coll))))","user":"523b4e91e4b07becd5be21ef"},{"code":"(fn [coll]\n  ((fn [coll freqs]\n    (let [k (first coll)]\n      (cond\n        (empty? coll)\n          freqs\n        (nil? (freqs k))\n          (recur\n            (rest coll)\n            (merge freqs {k 1}))\n        :else\n          (recur\n            (rest coll)\n            (merge freqs {k (inc (freqs k))})))))\n    coll {}))","problem":55,"user":"4fdb881ee4b05e33b9224f5e"},{"code":"#(->> %\n  (group-by identity) \n  (mapcat (fn [[k v]] [k (count v)]))\n  (apply hash-map))","problem":55,"user":"503a234de4b088a6a14ca76d"},{"problem":55,"code":"(fn [col] (reduce #(assoc %1 %2 (inc (or (%1 %2) 0))) {} col))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc x]\n     (merge-with + acc {x 1}))\n   {}\n   coll))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn [s]\n  (apply array-map (reduce concat (for [[k v] (group-by (fn [x] x) s)] [k (count v)]))))","problem":55,"user":"51899891e4b0288ada3dbdab"},{"problem":55,"code":"(letfn [(f [acc xs]\n           (if (empty? xs) acc\n               (if (acc (first xs))\n                 (recur (assoc acc (first xs) (inc (get acc (first xs)))) (rest xs))\n                 (recur (assoc acc (first xs) 1) (rest xs)))))]\n     (partial f {}))","user":"554b9c3ee4b0a04f79299594"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [acc x] (assoc acc x (inc (or (get acc x) 0)))) {} xs))","user":"5687b6abe4b0dcc4269f4061"},{"code":"reduce (fn [m v] (update-in m [v] #(inc (or % 0)))) {}\n; or these ways:\n; reduce #(assoc % %2 (inc (% %2 0))) {}\n; reduce #(merge-with + %1 {%2 1}) {}","problem":55,"user":"4ff82b00e4b0678c553fc395"},{"problem":55,"code":"(fn [s] (reduce (fn [m n] (merge-with + m {n 1})) {} s))","user":"5505d137e4b086ebe8a79c8c"},{"problem":55,"code":"(fn [coll] (reduce (fn [acc x] (update-in acc [x] #(+ (or %1 0) 1))) {} coll))","user":"5d80fa37e4b0915913b1d374"},{"problem":55,"code":";;(fn f [xs] (into {} (for [x xs] [x (count (filter #(= % x) xs))])))\n;;#(reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity %))\nreduce #(update-in % [%2] (fnil inc 0)) {}\n;;#(apply merge-with + (map (fn [x] {x 1}) %))\n;;reduce #(merge-with + % {%2 1}) {}","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"code":"(fn [s] \n  (into {}\n  (map \n   (fn [[k v]] {k (count v)}) \n   (group-by identity s)\n   )\n   )\n  )","problem":55,"user":"523f0bbfe4b01c266ffa7f91"},{"code":"(fn [coll]\r\n    (loop [input coll\r\n           output {}]\r\n      (if (empty? input)\r\n        output\r\n        (recur (rest input)\r\n               (assoc output (first input) (inc (output (first input) 0)))))))","problem":55,"user":"4fcbc18ae4b0ee37620e185c"},{"problem":55,"code":"(fn [a] (->> (group-by identity a)\n             (#(zipmap (keys %) (map count (vals %))))\n             ))","user":"5703a557e4b08d47c97781f4"},{"problem":55,"code":"#((fn [f m]\n    (into {} (for [[k v] m]\n              [k (f v)]))) count (group-by identity %))","user":"57c45e64e4b05aa3c4741ccf"},{"problem":55,"code":"(fn [colls] (reduce  #(if (contains? %1 %2) \n           (assoc %1 %2 (inc (%1 %2)))\n           (assoc %1 %2 1))   {} colls))","user":"5657fed1e4b0f9d632dd84ae"},{"code":"(fn [c]\n  (apply conj {}\n    (map #(vector (first %) (count %)) (partition-by identity (sort c)))))","problem":55,"user":"4e399685535deb9a81d77f40"},{"problem":55,"code":"(fn my-frequencies [in]\n  (letfn [(build-freq [curr_map rem_seq]\n            (let [f (first rem_seq)]\n              (if (empty? rem_seq)\n                curr_map\n                (build-freq\n                  (if (contains? curr_map f)\n                    (update-in curr_map [f] inc)\n                    (assoc curr_map f 1))\n                  (rest rem_seq)))))]\n    (build-freq {} in)))","user":"5b107263e4b0cc2b61a3be22"},{"problem":55,"code":"(fn occurances [seq]\n  (letfn [\n          (reducer [counts e]\n            (assoc counts e (inc (get counts e 0))))\n          ]\n    (reduce reducer {} seq))\n  )","user":"55ddc5cbe4b050e68259b3d0"},{"problem":55,"code":"(fn [lst] (apply hash-map (mapcat #(list (first %) (count %)) (map (fn [d] (filter #(= d %) lst)) (set lst)))))","user":"587ee260e4b052da650a6353"},{"problem":55,"code":"(fn [coll]\n  (reduce \n   (fn [m x]\n     (let [c (get m x)]\n       (if (nil? c)\n         (assoc m x 1)\n         (assoc m x (inc c))))) \n   {} coll))","user":"5e9f38cce4b00a66d4a9517e"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (apply array-map (interleave\n                   (map first (partition-by identity (sort-by identity coll )))\n                   (map count (partition-by identity (sort-by identity coll))))))","user":"567c7fefe4b05957ce8c61bc"},{"problem":55,"code":";; this would be nicer with the update function: (update result x (fnil inc 0))\n(fn count-occurences [xs]\n  (reduce (fn [result x] (assoc result x ((fnil inc 0) (get result x)))) {} xs))","user":"56175cf9e4b06b1bb2182a0f"},{"problem":55,"code":"#(reduce (fn [st el] (if (contains? st el) (assoc st el (inc (st el))) (assoc st el 1))) {} %)","user":"57440f77e4b0c285004e8ab5"},{"problem":55,"code":"(fn [x] (into {} (map #(vector (first %) (count (second %))) (group-by identity x))))","user":"559067ace4b0277789237670"},{"problem":55,"code":"(fn count-occur \n  [coll] \n  (reduce \n    #(assoc %1  (key %2) (count (val %2))) \n    {} \n    (group-by identity coll)))","user":"56c3aca0e4b05cc29241ee90"},{"problem":55,"code":"#(reduce-kv (fn [a b c] (assoc a b (count c))) {} (group-by identity %))","user":"5bb23cf1e4b0a20761a2350a"},{"problem":55,"code":"(fn [x]\n  (loop [\n         a x\n         h {}\n        ]\n    (if (empty? a) \n      h\n      (let [current (first a)\n            counter (get h current 0)\n            ha (assoc h current (inc counter))]\n        \t(recur (rest a) ha)\n      )\n    )\n  )\n)","user":"543496e1e4b0b6b47310fcf2"},{"code":"(fn[s] \n(reduce #(merge %1 {%2 (inc(get %1 %2 0))}) {} s)\n)","problem":55,"user":"5017eface4b02f523d7cc5e7"},{"problem":55,"code":"(fn [data] (into (hash-map)\n(for [val (set data)] [val (count(filter #(= val %) data))] )\n))","user":"568513c4e4b04eec3ec5cfc5"},{"problem":55,"code":"#(reduce conj {} (map (fn [x] [(first x) (count (second x))]) (group-by identity %)))","user":"5a535572e4b05d388ecb6c0b"},{"code":"(fn [coll] \r\n (into {} (map #(vector (first %1) (count (second %1))) (group-by identity coll))))","problem":55,"user":"4f141dee535d64f603146434"},{"problem":55,"code":"#(into {} (for [[key value] (group-by identity %)]\n            [key (count value)]))","user":"537e104ce4b06839e8705e9a"},{"problem":55,"code":";; my original solution: #(into {} (map (fn [[k v]] [k (count v)]) (group-by identity %)))\n\n;; this one is simply cleaner (see clojuredocs.org for `update-in`)\nreduce #(update-in % [%2] (fnil inc 0)) {}","user":"55d5ee3fe4b0e31453f64a92"},{"problem":55,"code":"reduce (fn [m x] (assoc m x (inc (m x 0)))) {}","user":"58ffaddee4b0438e51c2cffe"},{"problem":55,"code":"(fn [sq]\n    (reduce (fn [result item]\n              (update-in result [item] (fn [i] ((fnil inc 0) i)))\n              )\n            {}\n            sq\n            )\n    )","user":"571a282ae4b07c98581c3b46"},{"code":"reduce (fn [hmap item] \n         (assoc hmap item (inc (hmap item 0))))\n{}","problem":55,"user":"51789dfae4b03d69594194d7"},{"code":"(fn [c] \n  (reduce \n   #(assoc %1 %2 (count (filter (fn [v] (= v %2)) c)))\n    {}\n   (distinct c)))","problem":55,"user":"50f53694e4b057d4c52de881"},{"problem":55,"code":"(fn [col]\n    (let [lfreq  (fn [col res]\n                   (if (empty? col) res\n                       (recur (rest col) (assoc res (first col) (inc (get res (first col) 0))))))]\n      (lfreq col {}))\n    )","user":"57aa290de4b0b8559636fc65"},{"code":"(fn [s]\n    (reduce merge\n            (for [[element element-list] (group-by identity s)\n                  ]\n              {element (count element-list)}))\n    )","problem":55,"user":"4daea889edd6309eace4d15b"},{"problem":55,"code":"#(into {} \n      (for\n        [[k v] (group-by identity %)]\n        [k (count v)]))","user":"537bde5de4b06839e8705e73"},{"code":"#(into {} (map  (fn [[v n]] [v (count n)]) (group-by identity (sort %))))","problem":55,"user":"4f280840e4b0d6649770a010"},{"problem":55,"code":"(fn [coll] \n  (loop [r {}, [v & o] coll] \n    (if (nil? v) r \n      (recur (update-in r [v] (fnil inc 0)) o))))","user":"5c13da47e4b01240ff5671a6"},{"problem":55,"code":"(fn [coll]\n  (loop [ret {} coll coll]\n    (if (empty? coll)\n      ret\n      (let [n (first coll)]\n        (if (ret n)\n          (let [o (ret n)\n                new-o (inc o)\n                new-ret (assoc ret n new-o)]\n            (recur new-ret (rest coll)))\n          (let [new-ret (assoc ret n 1)]\n            (recur new-ret (rest coll))))))))","user":"54d000c7e4b018d918be98d7"},{"problem":55,"code":"(fn [xs] \n  (apply merge (map #(hash-map (key %) (count (val %)))\n                    (group-by identity xs))))","user":"53fcd574e4b0de5c418485d9"},{"problem":55,"code":"(fn [coll] (reduce #(assoc %1 %2 ((fnil inc 0) (%1 %2))) {} coll))","user":"56aad4f7e4b03c432f187338"},{"code":"(fn [seq] (reduce #(assoc % %2 (inc (get % %2 0))) {} seq))","problem":55,"user":"4f4ff5a8e4b03ad3f0c10cf3"},{"code":"(fn [sq]\r\n  (letfn [(ct [e rsq]\r\n            (count (filter #(= e %) rsq)))\r\n          (hp [acc rsq]\r\n            (cond\r\n              (empty? rsq)\r\n                acc\r\n              :else\r\n                (hp (conj acc [(first rsq) (ct (first rsq) sq)])\r\n                    (remove #(= (first rsq) %) rsq))))]\r\n    (hp {} sq)))","problem":55,"user":"4ee40938535d10e5ff6f5375"},{"code":"#(reduce (fn [a x]\n                    (assoc a x (inc (get a x 0)))) {} %)","problem":55,"user":"4e5f034b535d8a8b8723a2d9"},{"problem":55,"code":"(fn [coll] \n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))\n\n\n\n\n;(fn [coll]\n;  (reduce \n;    (fn [acc val]\n;      (let [oldval (get acc val 0)]\n;        (assoc acc val (inc oldval))))\n;    {} coll))","user":"5896735fe4b00487982d529d"},{"code":"(fn count-distinct [l]\n(reduce (fn [acc, e] (let [m (acc e)] \n  (if m\n    (assoc acc e (inc m))\n    (assoc acc e 1)))) {} l)\n)","problem":55,"user":"4e89ddf9535d3e98b8023284"},{"problem":55,"code":"(fn [a] (reduce (fn [map- key-] (if (get map- key-) (update-in map- [key-] inc) (assoc map- key- 1))){} a))","user":"55af7e21e4b03311e7b732cc"},{"problem":55,"code":"(fn [l]\n (reduce \n  (fn [acc x] \n    (update-in acc [x] (fnil inc 0))) {} l))","user":"55c1eb52e4b0e31453f64970"},{"problem":55,"code":"(fn [xs] (reduce (fn [m x] (update-in m [x] #(inc (or % 0)))) {} xs))","user":"5fe0d4d4e4b05ac5b16ea164"},{"problem":55,"code":"#(letfn [(f [c] {(first c) (count c)})]\n   (->> %\n        (sort-by identity)\n        (partition-by identity)\n        (map f)\n        (reduce merge)))","user":"53e3f7a8e4b036ad0777e408"},{"code":"(fn [ c ]\n    (reduce #(conj % [%2 (inc (get % %2 0))]) \n            {} \n            c))","problem":55,"user":"5398305fe4b0b51d73faaef6"},{"problem":55,"code":"#(let [x (partition-by identity (sort %))]\n     (zipmap (map first x) (map count x)) )","user":"5c683fb5e4b0fca0c16226d5"},{"problem":55,"code":"(fn [coll]\n        (reduce (fn [freqs x] \n                  (assoc freqs x \n                         (inc (get freqs x 0))))\n                {}  coll))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":55,"code":"(fn freqs [coll]\n  (reduce (partial merge-with +) {} (map #(hash-map % 1) coll))\n)","user":"54a7d707e4b09f271ff37c9b"},{"problem":55,"code":"(fn freqs [sequ]\n  (let [reducer (fn [out elm]\n                  (let [cnt (out elm)\n                        ncnt (if (nil? cnt) 1 (inc cnt))]\n                    (assoc out elm ncnt)))]\n    (reduce reducer {} sequ)))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":55,"code":"(fn grp2 [coll]\n  (apply hash-map (interleave (distinct coll) (map count (map second (group-by identity  coll))))))","user":"5a9482b7e4b0d174b936c737"},{"code":"#(apply hash-map (mapcat (fn [s] [(first s) (count s)]) (partition-by (fn [x] x) (sort %))))","problem":55,"user":"4fa67030e4b081705acca1b7"},{"problem":55,"code":"(fn\n [coll]\n (loop [[x & xs] coll acc {}]\n   (if x\n     (recur xs (update-in acc [x] #(if (nil? %) 1 (inc %))))\n     acc\n     )\n   )\n )","user":"56edf2dde4b04a395b9a044b"},{"code":"(fn[coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","problem":55,"user":"4e9e6bd6535dbda64a6f6b96"},{"problem":55,"code":"(fn [seq]\n  (reduce (fn [map item]\n            (if (contains? map item)\n              (update-in map [item] inc)\n              (assoc map item 1))) {} seq) )","user":"5ccc2a03e4b0ccb06196288f"},{"problem":55,"code":"(fn [v] (->> v (group-by identity) (reduce #(assoc %1 (first %2) (count (second %2)) ) {}) ))","user":"5582c5b1e4b05c286339e10a"},{"problem":55,"code":"(fn foo [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","user":"507eed82e4b06ce648bcdbfe"},{"problem":55,"code":"#(loop [x % y {}]\n          (cond (empty? x) y\n                (contains? y (first x)) (recur (rest x) \n                                               (assoc y \n                                                 (first x) \n                                                 (+ (get y (first x)) 1)))\n                :else (recur (rest x) (assoc y (first x) 1))))","user":"59fea630e4b01bb0ae8afd10"},{"code":"(fn f [x]\n       (apply merge (map #(hash-map (first % ) (count %)) (partition-by identity (sort x ))))\n       )","problem":55,"user":"518c5236e4b087e178201de0"},{"code":"(fn [coll]\n  (reduce\n    (fn [acc n]\n      (if (contains? acc n)\n        (assoc acc n (+ (acc n) 1))\n        (assoc acc n 1)))\n    {}\n    coll))","problem":55,"user":"4ec6559a535d6d7199dd36c9"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [freq n]\n      (if (get freq n)\n          (update-in freq [n] #(+ 1 %))\n          (assoc freq n 1)))\n    {} coll))","user":"55c66ffee4b0e31453f649c2"},{"problem":55,"code":"(fn count-distinct [coll]\n\t(letfn [(count [hash-set key] (assoc hash-set key (inc (get hash-set key 0))))]\n\t\t(loop [hash {}\n\t\t\t   remaining coll]\n\t\t   (if (empty? remaining)\n\t\t     hash\n\t\t     (recur (count hash (first remaining)) (rest remaining))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":55,"code":"(fn f [coll]\n    (reduce (fn [acc k]\n              (update-in acc [k] (fnil inc 0)))\n            {}\n            coll))","user":"559622cee4b0c79f6e1db975"},{"code":"#(let [g (group-by identity %)]\n  (zipmap (keys g) (map count (vals g))))","problem":55,"user":"4ede361a535d10e5ff6f5332"},{"problem":55,"code":"(fn [l]\n   (reduce \n    (fn [a v] (assoc a v ((fnil inc 0) (get a v))))\n    {} l))","user":"603ae21de4b0d5df2af222fb"},{"code":"(fn [s]\n  (reduce\n    (fn [result elt]\n      (let [num-occurrences (inc (result elt 0))]\n        (assoc result elt num-occurrences)))\n    {} s))","problem":55,"user":"53070615e4b02e821686979e"},{"problem":55,"code":"(fn [coll]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) \n          {} \n          coll))","user":"55f2e47de4b06e875b46ce4d"},{"problem":55,"code":"#(reduce (fn \n           [acc head]\n           (assoc acc head \n             (inc (acc head 0)))) {} %)","user":"54540453e4b0e397800069d2"},{"problem":55,"code":"#(into {} \n       (->> %\n            (group-by identity)\n            (map (fn [[k vs]] [k (count vs)]))))","user":"5d272077e4b092dab7f59c64"},{"problem":55,"code":"(fn frq [coll] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity coll)))","user":"5646dff3e4b0284900eef615"},{"problem":55,"code":"#(reduce (fn a [acc item] (if (contains? acc item) (update-in acc [item] inc) (assoc acc item 1) ))   {} %)","user":"5dc12b0ae4b0e59a23173d84"},{"problem":55,"code":"(fn [c] (let [s (set c)]\n          (into (sorted-map)\n                (map (fn [x] [x (count (filter #(= x %) c))]) s))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn [coll]\n  (reduce\n    conj\n    {}\n    (map\n      (fn [e]\n        (vector\n          e\n          (count\n            (filter\n              #(= e %)\n              coll))))\n      (set coll))))","problem":55,"user":"4f253a49e4b0d66497709ff3"},{"problem":55,"code":"(fn [coll] \n  (reduce #(assoc %1 %2 (if (contains? %1 %2) (inc (%1 %2)) 1)) {} coll))","user":"55c0afa5e4b01b9910ae2a27"},{"code":"(fn [coll]\n  (let [group (group-by identity coll)]\n  (zipmap (keys group) (map #(count (second %)) group))))","problem":55,"user":"4eb504d8535d7eef30807363"},{"problem":55,"code":"(fn [c] (reduce (fn [acc [v vs]] (assoc acc v (count vs))) {} (group-by identity c)))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":55,"code":"(fn [coll]\n      (loop [remainder coll sofar {}]\n        (if (empty? remainder)\n          sofar\n          (recur (remove #(= %1 (first remainder)) remainder)\n                 (conj sofar {(first remainder) (count (filter #(= %1 (first remainder)) remainder))}))\n            \n            )\n        )\n      )","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(fn [s]\n  (apply hash-map\n    (mapcat #(list (first %) (count %))\n      (partition-by #(if true %) (sort s)))))","problem":55,"user":"4e3ac1b2535deb9a81d77f4c"},{"code":"#(reduce (fn [m y]\n           (if-let [n (m y)]\n             (assoc m y (inc n))\n             (conj m [y 1])))\n         {}\n         %)","problem":55,"user":"4dc21233535d020aff1edf92"},{"code":"#(into {} (map (fn [[_ [v :as vs]]] [v (count vs)]) (group-by identity %)))","problem":55,"user":"4f6160a7e4b0defedf855fbe"},{"problem":55,"code":"(fn my-frequencies-3\n  [coll]\n  (->> coll\n       (group-by identity)\n       (map #(vector (first %) (count (second %))))                 ;; map sends a key value pair from a hash-map\n       (into {})))","user":"60c43b20e4b0e0fa5f1b42c9"},{"problem":55,"code":"(fn [coll] \n  (reduce (fn [m e] (assoc m e (inc (get m e 0)))) \n          {} \n          coll))","user":"518ba795e4b0f028e99addf0"},{"problem":55,"code":"(fn [x]\n   (->>\n    (group-by identity x)\n    (vals)\n    (map #(vector (first %) (count %)))\n    (into {})))","user":"5e9e8648e4b00a66d4a95178"},{"code":"(fn [coll]\n  (loop [coll coll result {}]\n    (if (seq coll)\n      (let [k (first coll)]\n        (recur \n          (next coll) \n          (assoc result k (inc (if (result k) (result k) 0)))))\n      result)))","problem":55,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":55,"code":"(fn [coll] (loop [c coll m {}]\n    (if (empty? c)\n        m\n       (recur (rest c) (merge-with + {(first c) 1} m)))))","user":"562326cbe4b03f08ee9a9230"},{"problem":55,"code":"(fn [s]\n  (let [unique (group-by identity s)] \n    (zipmap (keys unique) (map #(count (second %)) unique))))","user":"555a5731e4b0deb715856e44"},{"problem":55,"code":"(fn [v]\n  (let [m\t(group-by identity v)]\n    (into {}\n          (map (fn [[k v]] [k (count v)]) m))))","user":"57408f87e4b05c31a32c0856"},{"code":"(fn [s]\n  (let [groups (vals (group-by identity s))]\n    (zipmap\n     (map first groups)\n     (map count groups))))","problem":55,"user":"50d8f4b6e4b01f0871336e74"},{"problem":55,"code":"(fn [coll]\n  ; here, keys are the items in the collection and values are their counts\n  (reduce (fn [map item]\n            (assoc map item (inc (get map item 0))))\n          {}\n          coll))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(fn [a]\n  (loop [cnt {} xs a]\n    (if (empty? xs)\n      cnt\n    (if (contains? cnt (first xs))\n      (recur (update-in cnt [(first xs)] inc) (rest xs))\n      (recur (assoc cnt (first xs) 1) (rest xs))))))","problem":55,"user":"511f9625e4b085952a835362"},{"code":"#(into {} (map (fn [[x y]] [x (count y)]) (group-by identity %1)))","problem":55,"user":"4f614976e4b0defedf855fbb"},{"problem":55,"code":"(fn [v]\n  (reduce (fn [m x]\n            (if-let [count (get m x)]\n              (assoc m x (+ 1 count))\n              (assoc m x 1))) {} v))","user":"5622af0fe4b03f08ee9a922b"},{"code":"(let [f\n      (fn [m coll]\n        (if (nil? coll)\n          m\n          (if (contains? m (first coll))\n            (recur (conj m [(first coll) (+ 1 (get m (first coll)))]) (next coll))\n            (recur (conj m [(first coll) 1]) (next coll))\n          )\n        )\n      )]\n  (fn [z] (f {} z))\n)","problem":55,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":55,"code":"(fn [xs] (into {} (for [[k v] (group-by identity xs)] [k (count v)] )))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":55,"code":"(fn ff [values] \n  (let [uniqset (set values)\n        total (count uniqset)]\n    (loop [uset uniqset iter 0 finals {}]\n      (if (>= iter total)\n        finals\n        (let [elem (first uset)\n              tks (filter (partial = elem) values)\n              rms (drop 1 uset)\n              ]\n          (recur rms (inc iter)\n                 (into finals {elem (count tks)})))))))","user":"57b35ecbe4b0fbc9809a277e"},{"problem":55,"code":"#(reduce (fn [freq item] (assoc freq item (inc (freq item 0))))\n            {}\n            %)","user":"5ff93da9e4b06df49cee14af"},{"problem":55,"code":"(fn [lst] (into {} (map (fn [[k v]] (vector k (count v))) (group-by identity lst))))","user":"516f06dce4b06aac486e5b39"},{"problem":55,"code":"(fn [col] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity col))))","user":"538db083e4b0b51d73faae74"},{"code":"(fn [lst]\n     (apply hash-map (mapcat #(list (first %1) (count %1))  (vals (group-by identity lst)))))","problem":55,"user":"51f5539fe4b0abb92f97f9cd"},{"code":"(fn f [s]\n  (if \n    (empty? s) \n    {}\n    (let [[a & b] s]\n      (merge-with + {a 1} (f b)))))","problem":55,"user":"4e6f578c535d5021c1a8961b"},{"code":"#(into {} (map (fn [[x y]] [x (count y)]) (group-by identity %)))","problem":55,"user":"51ac6360e4b09397d510976c"},{"problem":55,"code":"(fn freq [s]\n  (->> (group-by identity s)\n       (map #(vector (first %) (count (second %))))\n       (into {})))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":55,"code":"#(reduce (fn [m e]\n           (if (contains? m e) \n             (assoc m e (inc (m e)))\n             (assoc m e 1))\n           ) {} %1)","user":"5e79fcb9e4b085ba37836e08"},{"problem":55,"code":"(fn [coll]\n    (when-let [s (seq coll)]\n    (reduce (fn [m x]\n              (assoc m x (inc (get m x 0))))\n      {}\n      s)))","user":"5cf1d9e3e4b0aaa82f112a18"},{"problem":55,"code":"#(reduce (fn [a b] (assoc a b (inc (a b 0)))) {} %)","user":"544e9022e4b0e3978000698b"},{"problem":55,"code":"(fn [l]\n  (reduce (fn [a b] (update-in a [b] #(if (nil? %) 1 (inc %)))) {} l))","user":"5d439775e4b07c84aa5ae696"},{"code":"(fn [xs]\n  (reduce \n    (fn [s x] \n      (assoc s x (inc (s x 0)))\n    )\n    {}\n    xs)\n)","problem":55,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":55,"code":"#(reduce (fn [s v] (update-in s [v] (fnil inc 0))) {} (sort %))","user":"54ef4a1ee4b024c67c0cf883"},{"problem":55,"code":"#(let [sorted (partition-by identity (sort %))] (zipmap (map first sorted) (map count sorted)))","user":"5e692be9e4b04a83ad7cd269"},{"problem":55,"code":"(fn\n  \n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","user":"5dfb20b8e4b0a607a9a45cd3"},{"code":"(fn [l] (reduce #(assoc % (first %2) (count (second %2))) {} (group-by identity l)))","problem":55,"user":"4fa30027e4b081705acca187"},{"code":"(fn [s]\n  (#(zipmap\n    (keys %)\n    (map count (vals %))\n    ) \n    (group-by identity s) \n  )\n)","problem":55,"user":"52f1bc81e4b05e3f0be25eef"},{"problem":55,"code":"(fn occurrences [seq]\n    (loop [results {} items seq]\n      (if (= (count items) 0)\n        results\n        (let [k (first items) value (get results k 0)]\n             (recur (assoc results k (inc value)) (rest items))\n        )\n      )\n    )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [x]\n  (apply\n   merge-with\n   +\n   (map\n    #(hash-map % 1)\n    x\n    )\n   )\n  )","problem":55,"user":"52586d24e4b0cb4875a45cb0"},{"problem":55,"code":"#(reduce (fn [m v] (assoc m v (+ 1 (get m v 0)))) {} %)","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn p55 [list]\n  (let [\n         groups (group-by identity list)\n         ]\n    (into {}\n      (for [[x y] groups] {x (count y)}))))","problem":55,"user":"51750fc5e4b07031762f2ee6"},{"problem":55,"code":";COMMENTS\n#_(\n;First Try:\n \nreduce #(update-in % [%2] \n  (fn [v] \n    (if (nil? v) \n      1 \n      (inc v)))) {}\n \n \n; Cleaner?:\n \nreduce \n  #(update-in % [%2]\n    (fn increment_count [i] \n      (inc (or i 0)))) \n{}\n \n; Clearer?:\n \nreduce (fn build_stats [stats element] \n  (update-in stats [element] \n    (fn increment_count [i] \n      (inc (or i 0))))) \n{}\n \n; Ghadi's Cleanup Suggestion\n \nreduce (fn build_stats [stats element] \n  (update-in stats [element] \n    #(inc (or % 0)))) \n{}\n \n; fnil!\n \nreduce (fn build_stats [stats element] \n  (update-in stats [element] \n    #(fnil inc 0))) \n{}\n\n);END COMMENTS\n \n;fnil with let\n(fn [col]\n  (let [\n      updater     (fn [cnt] ((fnil inc 0) cnt))\n      build_stats (fn [stats element] (update-in stats [element] updater))\n    ]\n    (reduce build_stats {} col)))","user":"5465febde4b01be26fd746e1"},{"code":"(fn freqs [col]\n  (reduce (fn [freq-map e] (if (freq-map e)\n                               (update-in freq-map [e] inc)\n                               (assoc freq-map e 1))) {} col))","problem":55,"user":"52f53589e4b05e3f0be25f2c"},{"problem":55,"code":"(fn [c] (reduce #(merge-with + % {%2 1}) {} c))","user":"5455c2f3e4b080a794c2c87d"},{"problem":55,"code":"(fn [m] (apply hash-map (interleave (keys (group-by identity m)) (map count (vals (group-by identity m))))))","user":"549b1e50e4b0f3d1d8e70f7a"},{"problem":55,"code":"(fn occurs [xs]\n  (loop [m {} [e & ls] xs]\n    (if (nil? e)\n      m\n      (recur (assoc m e (if (m e) (inc (m e)) 1))\n             ls))))","user":"598601f9e4b021a7a535fe79"},{"problem":55,"code":"(fn occ\n  [s]\n  (reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity s)))","user":"56b2630be4b0982f16b37e03"},{"problem":55,"code":"(fn [m] (reduce (fn [counts x] (assoc counts x (inc (get counts x 0)))) {} m))","user":"5b2be9b1e4b025bcb146f2b0"},{"problem":55,"code":"#(reduce (fn \n            [m [v ks]]\n            (assoc m v (count ks)))\n          {}\n          (group-by identity %))","user":"5ecfd429e4b016b56eae05a9"},{"problem":55,"code":"(fn [x]\n   (loop [v x res {}]\n     (if (empty? v)\n       (into {} (sort-by first res))\n       (recur (rest v) (assoc res (first v) (if (get res (first v)) (inc (get res (first v))) 1)))))\n   )","user":"541074f1e4b01498b1a719ac"},{"code":"(fn [s]\n  (->> (sort s)\n       (partition-by identity)\n       (map (fn [r] [(first r) (count r)]))\n       (into {})))","problem":55,"user":"5092fe10e4b097f48cc3857e"},{"problem":55,"code":"reduce (fn [keep add]\n         (merge-with\n           +\n           keep\n           {add 1}))\n       {}","user":"58247423e4b051871117bec5"},{"problem":55,"code":"#(apply hash-map (apply concat ((fn[x](map (fn[y][(first y) (count y)]) x)) (partition-by identity (sort %)))))","user":"574a9132e4b02ea1147991fd"},{"code":"(fn [s] (let [ss (group-by identity s)]\n(zipmap (keys ss) (map count (vals ss)))))","problem":55,"user":"4e80d71b535db62dc21a62b7"},{"problem":55,"code":"(fn aaa [v]\n  (let [m (group-by identity v)]\n    (loop [res {} s m]\n      (if (empty? s)\n        res\n        (recur (assoc res (key (first s)) (count (val (first s)))) (rest s)\n               ))\n      )\n    )\n  )","user":"55d42f78e4b0e31453f64a73"},{"code":"(fn [s]\n (loop [acc {}\n        rm  s]\n    (if (empty? rm)\n      acc\n      (recur (assoc acc (first rm) (inc (or (acc (first rm)) 0)))\n             (rest rm)))))","problem":55,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn [s] \n (reduce \n  (fn [acc x]\n    (cond\n      (nil?\n       (acc x)\n      )  (assoc acc x 1)\n      :else\n     \t(assoc acc x (inc (acc x)))\n     )\n  )\n  {}\n  s\n )\n)","problem":55,"user":"4fb03cf4e4b081705acca262"},{"code":"(fn [coll]\n  (reduce (fn [counts item] (assoc counts item (inc (get counts item 0)))) {} coll))","problem":55,"user":"5338e33fe4b0e30313ee6ca1"},{"problem":55,"code":"(let [incfreq (fn [m x]\n                 (assoc m x (inc (get m x 0))))]\n  #(reduce incfreq {} %))","user":"5d929ceae4b0915913b1d412"},{"problem":55,"code":"(fn [s] (->> s\n             sort\n      \t\t (partition-by identity)\n      \t\t (map #(vector (first %) (count %)))\n             (into {})))","user":"542c22bde4b0dad94371f29e"},{"code":"(fn [c] (reduce (fn [acc n] (assoc acc n (inc (acc n 0)))) {} c))","problem":55,"user":"50e0d5a3e4b061dbdced723d"},{"problem":55,"code":"(partial\n reduce \n (fn [results item]\n   (assoc results item (if (results item) (inc (results item)) 1))) ; fn `update' not avail\n {})","user":"59ee6801e4b0966464fe6a1f"},{"problem":55,"code":"reduce (fn [b a]\n          (update-in b [a] #(inc (or % 0)))) {}","user":"588fbb39e4b00487982d51bd"},{"code":"(fn tabelaFrequencias [x]\n  (zipmap\n    (set x)\n    (map #(count  (filter (fn[y] (= y %)) x)) (set x))\n  )\n)","problem":55,"user":"4e8b73e4535d65386fec2120"},{"code":"(fn [xs]\n  (reduce (fn [m x]\n            (assoc m x (inc (or (m x) 0))))\n          {}\n          xs))","problem":55,"user":"52487654e4b05ef8e38e63dc"},{"code":"(fn[x] (reduce #(into % {(first %2) (count %2)}) {} (partition-by identity (sort x))))","problem":55,"user":"4daeabf6edd6309eace4d15c"},{"problem":55,"code":"(fn occ\n  [list]\n  (reduce #(if (contains? %1 %2)\n             (update-in %1 [%2] inc)\n             (assoc %1 %2 1)) {} (reverse list)))","user":"556be3dce4b09a3098a524f7"},{"problem":55,"code":"reduce \n(fn [dict k]\n  (assoc dict k\n    (if (dict k)\n      (inc (dict k))\n      1)))\n{}","user":"56eb3f9de4b04a395b9a0420"},{"problem":55,"code":"(fn [s] (apply hash-map\n        (mapcat #(list (first %) (count %))\n                (partition-by identity (sort s)))))","user":"54b817eee4b0ed20f4ff6e93"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (map (fn [[k v]] {k (count v)}))\n      (into {}))","user":"575fbe58e4b08062f99a4e87"},{"code":"(fn [y] \n  (apply hash-map \n  (reduce concat \n    (map (fn[x] [(first x) (count x)]) \n    (partition-by identity (sort y))))))","problem":55,"user":"4fbd12a5e4b081705acca2fd"},{"problem":55,"code":"(partial\n reduce\n #(assoc %1 %2 (inc (get %1 %2 0))) {})","user":"4f037faf535dcb61093f6af8"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [m e]\n     (update-in m [e] (fnil inc 0)))\n   {}\n   coll))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [col]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} col))","problem":55,"user":"52a32876e4b04e0c58e87bfb"},{"problem":55,"code":"(fn co [input] (apply merge (map #(assoc {} (first %) (count %)) (vals (group-by identity input)))))","user":"56427910e4b08d4f616f5f19"},{"problem":55,"code":"(fn [seq-]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} seq-))","user":"54e79094e4b024c67c0cf818"},{"problem":55,"code":"#(into {} (->> %\n              (group-by identity)\n              (map (fn [[k v]] [k (count v)]))))","user":"5beda647e4b0a6d31fed2122"},{"problem":55,"code":"(partial reduce\n  #(update-in %1 [%2] (fnil inc 0))\n  {})","user":"598216d9e4b021a7a535fdf8"},{"code":"(fn [coll] (reduce (fn [r x]\n  (assoc r x (inc (get r x 0)))) {} coll))","problem":55,"user":"4f1bee08535d64f60314647e"},{"code":"(fn [c]\n  (into {}\n   (for [x (partition-by identity (sort c))] [(first x) (count x)])))","problem":55,"user":"4e6472b7535d8ccf87e9fe6c"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [m v]\n     (update-in m [v] #(inc (or % 0))))\n   {}\n   s))","user":"5cf6522be4b0b71b1d808a58"},{"problem":55,"code":"(fn [seqq]\n  (reduce #(merge-with + %1 {%2 1}) {} seqq))","user":"6088395de4b0ae75613dcee2"},{"problem":55,"code":"(fn occurrences [s]\n  (let [m (group-by identity s)\n        v (map #(count (get m %))(keys m))]\n    (apply merge \n           (map \n             (fn [s t] \n               (merge(hash-map s t))) \n             (keys m) \n             v))))","user":"59301509e4b072a2710fcfd6"},{"code":"(fn x [coll] (let [countI (fn [col i] (count (filter #(= i %) coll)))\n                 rlist (interleave coll (map #(countI coll %) coll))]\n                  (loop [toWork rlist r {}]\n                    (let [[k v & more] toWork]\n                        (if-not k\n                          r\n                          (if (:k r)\n                            (recur (drop 2 toWork) r)\n                            (recur (drop 2 toWork) (assoc r k v))))))))","problem":55,"user":"4e7ada51535db169f9c796ae"},{"problem":55,"code":"(fn [xs] \n  (let [gr (group-by first (map vector xs (repeat 1)))\n        ones (reduce #(assoc %1 (first %2) (reduce + (map last (last %2)))) {} gr)]\n    ones\n    ))","user":"56b35565e4b0982f16b37e16"},{"problem":55,"code":"(fn [coll]\n  (apply merge-with +\n         (map #(hash-map % 1) coll)))","user":"5896a0e6e4b00487982d52a8"},{"problem":55,"code":"#(reduce (fn [a e] ( if (contains? a e) (update-in a [e] inc)(assoc a e 1))) {} %)","user":"55dab5c8e4b0e31453f64ada"},{"problem":55,"code":"#(reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity %))","user":"55b22c33e4b0da326a65cf79"},{"code":"(fn [xs] \n    (apply merge \n      (for [d (distinct xs)]\n         (assoc {} d (count (filter #(= % d) xs)))\n      )\n    )\n )","problem":55,"user":"52430d3ce4b076204b44faa5"},{"problem":55,"code":"#(reduce (fn [the-map x]\n                   (merge-with + the-map {x 1})) {} %)","user":"52cbe5dfe4b07d0d72b27352"},{"problem":55,"code":"#(into {} (map (fn [x] (vector (first x) (count (second x)))) (group-by identity %)))","user":"56992162e4b0542e1f8d143c"},{"problem":55,"code":"(fn\n  [s]\n  (reduce (fn [acc x]\n            (update-in acc [x] #(if (nil? %1) 1 (inc %1))))\n          (sorted-map)\n          s))","user":"58543a59e4b07779d46863f5"},{"code":"#(apply merge-with + (map (fn[x]{x 1}) %))","problem":55,"user":"51b41150e4b0f094dd986fac"},{"code":"reduce #(if (contains? % %2) (assoc % %2 (inc (% %2)))\n            (assoc % %2 1)) {}","problem":55,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":55,"code":"#(into {} (for [[k v] (group-by identity %1)]{k (count v)}))","user":"54d2829ce4b0e8a36923e5f6"},{"problem":55,"code":"(fn [coll]\n      (apply\n        hash-map (apply concat (map (fn  [[a b]] [a (count b)])\n                               (group-by identity coll)))))","user":"5eb4927fe4b00a66d4a95221"},{"code":"(fn [s]\n  (let [intlv (partition 2 (interleave s (repeat 1)))]\n    \n    (->> intlv\n         (map #(zipmap [(first %)] [(last %)]))\n         (apply merge-with + )\n         )\n    ))","problem":55,"user":"53415755e4b00652c8746ecd"},{"code":"reduce #(merge-with + %1 {%2 1}) {}","problem":55,"user":"4edecdae535d10e5ff6f533c"},{"problem":55,"code":"(fn [lst]\n   (loop [l (rest (sort lst)) p (first (sort lst)) c 1 r {}]\n     (cond\n       (empty? l) (into r [[p c]])\n       (= p (first l)) (recur (rest l) p (inc c) r)\n       :else (recur (rest l) (first l) 1 (into r [[p c]])))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn \n  [coll]\n  (let [m (group-by identity coll)]\n    (zipmap (keys m) (map count (vals m)))))","problem":55,"user":"51804bcbe4b04f45bde7d901"},{"code":"#(into {} \n   (for [[x y] (group-by identity %)]\n\t[x (count y)]))","problem":55,"user":"51cbaf14e4b08d8387cbedda"},{"code":"#(into {} (for [[x y] (group-by identity %)]\n    [x (count y)]))","problem":55,"user":"53691dc7e4b0243289761e97"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [res-map item]\n            (let [freqs (get res-map item)]\n              (if (nil? freqs)\n                (assoc res-map item 1)\n                (assoc res-map item (inc freqs)))))\n          {}\n          coll))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":55,"code":"(fn [sequence]\n  (apply hash-map\n         (apply concat\n                (map (fn [key]\n                (list key\n                             (count (filter (fn [item]\n                                              (= key item))\n                                            sequence))))\n                     (set sequence)))))","user":"58637f03e4b0f14aab7c881e"},{"problem":55,"code":"(fn [coll]\n    (let [gp (group-by identity coll)] \n        (zipmap (keys gp) (map #(count (second %)) gp))))","user":"5d3e8c3de4b01671435dbd73"},{"problem":55,"code":"(fn [xs]\n   (apply hash-map (apply concat (for [x (apply list (set xs))]\n                                   (list x (count (filter #(= x %) xs)))))))","user":"547ad587e4b0c51c1f4d72ce"},{"code":"#(apply hash-map (mapcat (fn [[x y]] [x (count y)]) (group-by identity %)))","problem":55,"user":"5298d3f4e4b02ebb4ef75068"},{"problem":55,"code":"(fn [xs] (let [xgroup (vals (group-by identity xs))\n                size (for [x xgroup] (count x))]  (reduce conj {}(map hash-map (map first xgroup) size))))","user":"598588f2e4b021a7a535fe65"},{"code":"(fn [sq] \n  (reduce (fn [m e] \n            (assoc m e (inc (get m e 0)))) \n          {} sq))","problem":55,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [xs]\n  (apply hash-map (mapcat #(list (first %) (count (second %))) (group-by identity xs))))","problem":55,"user":"504e13fce4b078edc5f593bc"},{"problem":55,"code":"(fn freq [xs]\n  (reduce (fn [a x]\n            (assoc a x (inc (a x 0))))\n          {}\n          xs))","user":"56b280e3e4b0982f16b37e06"},{"problem":55,"code":"(fn [coll]\n  (into {} \n        (map #(vector (first %) (count (second %))) \n             (group-by identity coll))))","user":"568f2059e4b0dcc4269f40df"},{"code":"(fn [coll]\n  (apply hash-map\n         (mapcat #(vector (first %) (count (second %)))\n                 (group-by (fn [n] n) coll))))","problem":55,"user":"4f9a7dc0e4b0dcca54ed6d0b"},{"code":"(fn [col]\n  (let [x (group-by identity col)\n        k (map key x)\n        v (map val x)]\n    (apply hash-map (interleave k (map count v)))))","problem":55,"user":"532c9dc9e4b019098a6f8b30"},{"code":"(fn [x] (apply hash-map (mapcat #(vector  (first %) (count %)) (partition-by identity (sort x)))))","problem":55,"user":"4db58ccb535d87e67b28fe10"},{"code":"(fn my-frequencies [coll]\n  (let [xs (group-by identity coll)\n        values (keys xs)\n        counts (map count (vals xs))]\n    (zipmap values counts)))","problem":55,"user":"4ef6f5ea535dced4c769f250"},{"problem":55,"code":"(fn [c] \n  (let [rf (fn [memo item]\n             (if (memo item)\n               (assoc memo item (inc (memo item)))\n               (assoc memo item 1)))]\n\n  (reduce rf {} c)))","user":"5a0a25fce4b0eab8c044893d"},{"problem":55,"code":"(fn [coll]\n  (->> (map #(hash-map % 1) coll)\n       (apply merge-with +)))","user":"5879d577e4b01531a375ead8"},{"code":"#(let [m (->> % (sort) \n        (partition-by identity))]\n    (zipmap (map first m) (map count m)))","problem":55,"user":"4f01c938535dcb61093f6a39"},{"problem":55,"code":"(fn [ss] (apply (partial merge-with +) (map (fn [n] {n 1}) ss)))","user":"54d7e277e4b0a52adc2e2031"},{"code":"#(let [s (partition-by identity (sort %))]\n    (zipmap (map first s) (map count s)))","problem":55,"user":"50563ae2e4b0ce54f56f0405"},{"problem":55,"code":"(fn [coll]\n  (loop [x coll n {}]\n    (cond\n     (empty? x) n\n     (contains? n (first x)) (recur (next x) (update-in n [(first x)] inc))\n     :else (recur (next x) (assoc n (first x) 1)))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn counter [l]\n      (letfn [\n              (addm [m x]\n                (if (contains? m x)\n                  (update-in m [x] inc)\n                  (conj m [x 1])\n                  )\n                )\n              ]\n        (reduce addm {} l )\n        ) )","problem":55,"user":"51f81925e4b09be9c177e526"},{"code":"#(\n  reduce (fn [a b] (conj a [(last b) (count b)])) {} (partition-by str (sort %1))\n)","problem":55,"user":"4e307313535deb9a81d77f14"},{"problem":55,"code":"(fn [c]\n  (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity c)))","user":"54497569e4b032a45b8693d2"},{"problem":55,"code":"(fn [input]\n    (reduce \n      #(let [f (or (get %1 %2) 0)]\n         (assoc %1 %2 (inc f))\n         ) \n      {} input))","user":"54903056e4b0b312c081ff2e"},{"problem":55,"code":"(fn [x]\n       (into {} (map (fn [[k v]][k (count v)]) (group-by identity x))))","user":"567c63f6e4b05957ce8c61bb"},{"problem":55,"code":"(fn my-frequencies [coll]\n  (letfn [(freq [x coll]\n            (filter #(= x %) coll))]\n    (loop [coll coll\n           res {}]\n      (if-not (seq coll) res\n              (recur (filter #(not= (first coll) %) coll)\n                     (assoc res (first coll) (count (freq (first coll) coll))))))))","user":"547884d7e4b0c51c1f4d72bd"},{"problem":55,"code":"(fn counter\n   [coll]\n   (into {}\n         (for [[k v] (group-by identity coll)]\n           [k (count v)])))","user":"542725fce4b01498b1a71b22"},{"code":"#(let [m (group-by identity %)]\n   (zipmap (keys m) (map count (vals m))))","problem":55,"user":"506ef8c3e4b09350ab4199f4"},{"problem":55,"code":"(fn [s]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity s))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [coll]\n  (reduce #(assoc %1 (first %2) (count (second %2))) {} (group-by identity coll)))","problem":55,"user":"524b90fae4b09eba1c0223df"},{"problem":55,"code":"(fn counter \n  ([ys] (counter ys {}))\n   ([ys counts]\n    (if (empty? ys)\n     counts\n     (recur (rest ys) (assoc counts (first ys) (inc (get counts (first ys) 0))))\n    )\n  )\n)","user":"53de4bdae4b0d874e779ae32"},{"problem":55,"code":"(fn f [x] \n  (reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity x)))","user":"51a1659de4b00957e520db72"},{"code":"#(reduce \n  (fn [acc e] \n    (if (contains? acc e)\n        (conj acc [e (+ 1 (acc e))])\n        (conj acc [e 1])))\n  {} %)","problem":55,"user":"4f13047d535d64f60314642c"},{"problem":55,"code":"(fn [coll]\n  (let [groups (group-by identity coll)]\n    (zipmap (keys groups) (map count (vals groups)))))","user":"52950ab6e4b02ebb4ef7501a"},{"problem":55,"code":"#(loop [items %\n        results {}]\n   (if (empty? items)\n     results\n     (let [head (first items)\n           tail (rest items)]\n       (if (nil? (get results head))\n         (recur items (conj results [head 0]))\n         (recur tail (conj results [head (inc (get results head))]))))))","user":"5601e037e4b04bb52996e199"},{"problem":55,"code":"(fn [coll] (apply merge-with + (for [e coll] {e 1})))","user":"5a5dbe9de4b0512ff01cd92b"},{"problem":55,"code":"(fn [c] (into {} (map #(let [[a b] %] [a (count b)]) (group-by identity c))))","user":"5c41db45e4b08cd430848ece"},{"code":"#(into {} (for [[k v] (group-by identity %)]\n                 {k (count v)}))","problem":55,"user":"52f3af46e4b05e3f0be25f14"},{"code":"(fn occurences [s]\n  (reduce\n    (fn [acc x] (assoc acc x (inc (get acc x 0))))\n    {} s))","problem":55,"user":"50783762e4b0fc74642bff67"},{"problem":55,"code":"(fn hue [x] \n  (into {} \n        (map vec \n             (partition 2 \n                        (interleave \n                          (distinct x) \n                          (map #(count (second %)) (group-by identity x)))))))","user":"557e8326e4b05c286339e0d7"},{"problem":55,"code":"(fn custom-frecuencies\n  [coll]\n  (reduce\n   (fn [reduce-coll el]\n     (let [current-size (reduce-coll el)\n           new-size (if (nil? current-size) 1 (inc current-size))]\n       (conj reduce-coll [el new-size])))\n   {} coll))","user":"4fc524aae4b081705acca37e"},{"problem":55,"code":"reduce (fn [freqs x] (update-in freqs [x] #(if (= % nil) 1 (inc %)))) {}","user":"5a080bdde4b01bb0ae8afde9"},{"problem":55,"code":"(fn [s]\n  (reduce #(update-in %1 [%2]    (fnil inc 0)) {} s))","user":"54684c3be4b00cfc9eacc139"},{"problem":55,"code":"(fn countOccurences [x]\n  (let [m (group-by identity x)]\n      ((fn [f m]\n         (into (empty m) (for [[k v] m] [k (f v)])))\n        count m)\n    )\n  )","user":"5c24c654e4b07e362c2305a7"},{"problem":55,"code":"(fn [x]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} x))","user":"5a80b934e4b00b71e582a05b"},{"code":"(fn count-occurances [a]\n\t(reduce (fn [acc x] (if (contains? acc x) (assoc acc x (+ (get acc x) 1)) (assoc acc x 1))) {} a))","problem":55,"user":"50ed8a5fe4b06330c1f87c3d"},{"code":"#(into {} (for [[k v] (group-by identity %)]\n [k  (count v)]))","problem":55,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [coll]\n  ( (fn [m]\n      (zipmap (keys m) (map count (vals m))))\n    (group-by identity coll)))","problem":55,"user":"50630247e4b05ac47bc68d6b"},{"problem":55,"code":"#(reduce (fn [reduction, count] (assoc reduction count (inc (get reduction count 0)))) {} %)","user":"54b5b3cce4b05787c3b163ab"},{"code":"(fn [coll]\n(apply merge-with + (for [val coll]\n  {val 1})))","problem":55,"user":"510591dde4b06d28cacc92eb"},{"code":"#(reduce\n   (fn dc [l r] (assoc l r (inc (l r 0))))\n   {} %)","problem":55,"user":"4f128865535d64f603146428"},{"code":"(fn[coll](let [m (group-by identity coll)]\n  (into {} (map \n   #(vector % (count (m %)))\n   (keys m)))))","problem":55,"user":"5260341ee4b03e8d9a4a7034"},{"problem":55,"code":"(fn [coll] (apply hash-map (mapcat (fn [e] [(first e) (count (second e))] ) (group-by identity coll))))","user":"504457c0e4b01f6c9a8b2360"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m k]\n            (if (get m k)\n              (assoc m k (inc (get m k)))\n              (assoc m k 1)))\n          {}\n          xs))","user":"5561d2c2e4b0c656e3ff17cd"},{"problem":55,"code":"(fn p55 [x]\n  (zipmap\n  (distinct (sort x))\n  (map #(count %) (partition-by identity (sort x)))))","user":"5400e918e4b0de5c41848619"},{"problem":55,"code":"#(reduce (fn [a c]\n            (merge-with + a {c 1}))\n          {} %)","user":"4f050377535dcb61093f6bed"},{"problem":55,"code":"(fn [vals] (reduce (fn [m v] (assoc m v (inc (or (m v) 0)))) {} vals))","user":"5a2a0cb6e4b09cafd31c7f2c"},{"code":"(comp (partial apply zipmap) \n      (juxt keys (comp (partial map count) vals)) \n      (partial group-by identity))\n\n;; reduce #(assoc % %2 (+ 1 (% %2 0))) {}","problem":55,"user":"4ef49c2c535dced4c769f238"},{"problem":55,"code":"#(into {} (reverse (loop [s %\n                          r {}]\n                     (if (empty? s)\n                       r\n                       (recur (drop 1 s) (let [k (first s)\n                                               v (if (contains? r k)\n                                                   (inc (get r k))\n                                                   1)]\n                                           (conj r {k v})))))))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn [c]\n      (reduce\n        (fn [v e]\n          (if\n            (contains? v e)\n            (assoc v e (inc (v e)))\n            (assoc v e 1))\n          ) {} c)\n      )","problem":55,"user":"51e28063e4b08e53a149f0f2"},{"problem":55,"code":"(fn [coll]\n       (into {}\n             (map #(vector (first %) (count %))\n                  (partition-by identity (sort coll)))))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn [coll]\r\n  (persistent!\r\n   (reduce (fn [counts x]\r\n             (assoc! counts x (inc (get counts x 0))))\r\n           (transient {}) coll)))","problem":55,"user":"4dd579b5535dae65d5c462ea"},{"code":"#(loop [v % result{}]\n     (if (empty? v)\n\t       result\n\t       (recur (rest v) (merge-with + result (hash-map (first v) 1)))))","problem":55,"user":"4f066916535dcb61093f6c10"},{"problem":55,"code":"(fn occurences [s & {:keys [occ-map] :or {occ-map (zipmap (set s) (repeat 0))}}]\n  (reduce (fn [map v] (update-in map [v] inc)) occ-map s))","user":"5b47874be4b02d533a91bc70"},{"problem":55,"code":"(fn solution [input]\n  (into {}\n        (for [[item repetitions]\n              (group-by identity input)] {item (count repetitions)} )))","user":"5e2ef900e4b05b4b015161fc"},{"code":"(fn freq\n  [coll]\n  (reduce #(update-in % [%2] (fnil inc 0)) {} coll)\n)","problem":55,"user":"50e3ec87e4b0463d32072486"},{"code":"#(loop [r {} c (seq %)]\r\n\t   (if-let [k (first c)]\r\n\t       (recur (assoc r k (inc (get r k 0))) (next c))\r\n\t       r))","problem":55,"user":"4e46ac46535dc968683fc4b5"},{"problem":55,"code":"#(reduce (fn [acc e]\n            (assoc acc e (inc (or (acc e) 0))))\n          {} %)","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn [li] (reduce #(if (contains? %1 %2) \n                    (assoc %1 %2 (inc (%1 %2)))\n                    (assoc %1 %2 1)) {} li))","problem":55,"user":"524f4162e4b0541d1855b806"},{"problem":55,"code":"(fn count-occurrences\n  [coll]\n  (->> coll\n       (group-by identity)\n       (map (fn [[k v]] {k (count v)}))\n       (into {})))","user":"5bc7f2d6e4b07a9b28b100b7"},{"problem":55,"code":"(fn m [s]\n  (apply merge (for [k (into #{} s)]\n                 (assoc {} k (count (filter #(= k %) s))))))","user":"58983e3fe4b00487982d52ce"},{"code":"(fn [coll]\n    (loop [coll coll\n           answer {}]\n      (cond\n       (nil? coll) answer\n       (nil? (get answer (first coll))) (recur (next coll) (merge answer {(first coll) 1}))\n       :else (recur (next coll) (assoc answer (first coll) (inc (get answer (first coll))))))))","problem":55,"user":"4e89e939535d3e98b8023287"},{"problem":55,"code":"#(into {} (for [[x xs] (into [] (group-by identity %))]\n             [x (count xs)]))","user":"555f0789e4b0a2eb076a39bf"},{"problem":55,"code":"(fn [coll] (reduce (fn [m v] (assoc m v (inc (get m v 0)))) {} coll))","user":"5b5e7953e4b0c6492753e6d9"},{"problem":55,"code":"(fn [c]\n  (reduce \n   (fn [s c]\n     (update-in s [c] (fnil inc 0)))\n   {}\n   c))","user":"4ec1923f535dfed6da9c6db2"},{"problem":55,"code":"(fn eh [x]\n  ((fn ehh [x acc]\n     (cond\n      (empty? x) acc\n      :else (if (acc (first x))\n              (ehh (rest x) (assoc acc (first x) (+ 1 (acc (first x)))))\n              (ehh (rest x) (assoc acc (first x) 1))))) x {}))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":55,"code":"(fn [a]\n  (loop [u a\n         d {}]\n    (if (= (count u) 0)\n      d\n      (recur (rest u) (let [k (first u)\n                             v (get d k)]\n                         (if v\n                            (assoc d k (+ v 1))\n                           (assoc d k 1)))))))","user":"58b54852e4b0ebc645576d52"},{"code":"(fn [coll] (into {} (map #(vector (first %) (count %))\r\n                                                 (partition-by identity (sort coll)))))","problem":55,"user":"4fdf4e2be4b05e33b9224f96"},{"problem":55,"code":"(fn my-freq\n  [s]\n  (apply merge-with +\n         (for [v s]\n           (hash-map v 1))))","user":"4e586949535d8a8b8723a292"},{"problem":55,"code":"(fn occ\n\t([inseq] (occ inseq (hash-map)))\n\t([inseq outmap]\n\t\t(if-let [cur (first inseq)]\n\t\t\t(recur (rest inseq) (assoc outmap cur (inc (outmap cur 0))))\n\t\t\toutmap\n\t\t)\n\t)\n)","user":"57c99a45e4b05aa3c4741d31"},{"problem":55,"code":"(fn [xv]\n  (reduce (fn [acc x]\n            (if (contains? acc x)\n              (assoc acc x (inc (acc x)))\n              (assoc acc x 1)))\n          {} xv))","user":"55f73078e4b06e875b46cea4"},{"problem":55,"code":"(fn freq [s]\n  (reduce-kv \n   (fn [m k v]\n     (assoc m k (count v)))\n   {}\n   (group-by identity s)))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn [s]\n  (apply hash-map\n    (apply concat\n      (map #(list (first %) (count %)) (vals (group-by identity s))))))","problem":55,"user":"4ff304f4e4b0678c553fc343"},{"problem":55,"code":"(fn f[a] (if (empty? a) {} (assoc (f (rest a)) (first a) (+ 1 ((f (rest a))(first a)0)))))","user":"59e8bb43e4b0249b72820735"},{"code":"reduce #(assoc %1 %2 (if-let [cnt (%1 %2)] (inc cnt) 1))  {}","problem":55,"user":"4e593dac535d8a8b8723a29c"},{"code":"reduce #(into % {%2 (inc (get % %2 0)) }) {}","problem":55,"user":"4e9b22e2535dbda64a6f6b74"},{"problem":55,"code":"reduce #(assoc %1 %2 (inc (get %1 %2 0)))\r\n          {}","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(comp\n (partial apply zipmap)\n (juxt keys (comp (partial map count) vals))\n (partial group-by identity))","problem":55,"user":"4faa9593e4b081705acca1f9"},{"code":"#((fn [m] (zipmap (keys m) (map count (vals m)))) (group-by identity %))","problem":55,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":55,"code":"(fn [liste]\n(reduce merge \n(map #(hash-map  (first %1) (count %1))\n (partition-by identity\n  (sort liste)\n )\n))\n\n)","user":"556f2009e4b09a3098a52519"},{"problem":55,"code":"(fn freqs [s]\n  (->>\n   s\n   (group-by identity)\n   (vals)\n   (map (fn [g] [(first g) (count g)]))\n   (into {})))","user":"5ed6030de4b016b56eae05db"},{"problem":55,"code":"(fn [s] \n  (reduce #(assoc % (key %2) (count (val %2))) {} (group-by identity s)))","user":"53c06438e4b0c98a41f5ccb0"},{"problem":55,"code":"(fn f [col]\n  (->> col\n    (sort)\n    (partition-by identity)\n    (mapcat (fn [col] (vector (first col) (count col))))\n    (apply array-map)))","user":"524b827ce4b09eba1c0223d7"},{"code":"(fn count- [coll]\n  \"55. Write a function which returns a map containing the number of occurences of each distinct item in a sequence.\"\n  (->> coll\n       (sort)\n       (partition-by identity)\n       (group-by count)\n       (mapcat #(list (ffirst (second %)) (first %)))\n       (apply hash-map)\n       ))","problem":55,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":55,"code":"#(reduce\n  (fn [x y] (merge-with + x {y 1}))\n  (zipmap (distinct %) (repeat 0))\n  %)","user":"590b8607e4b047aa04b199db"},{"problem":55,"code":"(fn f [x]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} x))","user":"5493d908e4b0b312c081ff52"},{"problem":55,"code":"(fn occurrances [vals] (loop [x vals result {}] (if-not (empty? x) (recur (rest x) (assoc result (first x) ((fnil inc 0) (get result (first x))))) result)))","user":"4f035fbe535dcb61093f6a92"},{"code":"(fn[x](reduce #(if (%1 %2) (assoc %1 %2 (inc (%1 %2))) (assoc %1 %2 1) ) (hash-map) x))","problem":55,"user":"4e8d5edd535d65386fec2134"},{"problem":55,"code":"(fn counts [xs]\n  (reduce-kv #(assoc %1 %2 (count %3))\n             {}\n             (group-by identity xs)))","user":"60c91f48e4b0e0fa5f1b4304"},{"problem":55,"code":"(fn func\n  [input-seq]\n  (let [occur\n        (fn [input-map elem]\n          (if (contains? input-map elem)\n            (do \n              (swap! (input-map elem) inc)\n              input-map)\n            (assoc input-map elem (atom 1))))]\n    (->> \n      input-seq \n      (reduce occur {}) \n      (reduce-kv\n        (fn [m k v]\n          (assoc m k (deref v)))\n        {}))))","user":"55a62092e4b0acc240e31554"},{"code":"(fn [l]\n  (loop [ll l\n         res {}]\n    (if (empty? ll)\n      res\n      (let [ele (first ll)\n            exist (get res ele)]\n        (if exist\n      \t\t(recur (rest ll) (assoc res ele (+ exist 1)))\n            (recur (rest ll)(assoc res ele 1)))))))","problem":55,"user":"50c84ba2e4b00bb60fe0c53e"},{"problem":55,"code":"(fn [l]\n  (reduce\n   (fn [a x]\n     (if (contains? a x)\n       ;(update a x inc) CLojure 1.7\n       (assoc a x (inc (a x)))\n       (assoc a x 1)))\n   {}\n   l))","user":"56050f06e4b08b23635d3161"},{"code":"(fn [s] (reduce #(assoc % %2 (inc (get % %2 0))) {} s))","problem":55,"user":"4eb2e6ca535d7eef3080734f"},{"problem":55,"code":"(fn [xs]\n   (reduce (fn [result input]\n             (assoc result input (inc (get result input 0)))\n             )\n           {} xs))","user":"555521a5e4b0deb715856e12"},{"problem":55,"code":"(fn [coll]\n  (loop [result {} coll coll]\n    (if (empty? coll)\n    result\n    (let [head (first coll)\n          is-head #(= head %)\n          others (remove is-head coll)\n          total (count (filter is-head coll))]\n      (recur (into result {head total}) others)\n      )\n      )\n    )\n  )","user":"5776558ee4b0979f89651633"},{"code":"(fn [xs]\n  (into {} (map (fn [[k v]] {k (count v)}) (group-by identity xs))))","problem":55,"user":"4ef41f26535dced4c769f230"},{"code":"#(apply merge (map (fn [[k v]] (hash-map k (count v))) (group-by identity %)))","problem":55,"user":"5046b003e4b011c5dfee7727"},{"problem":55,"code":"reduce\n (fn [acc x]\n   (assoc acc x (inc (acc x 0))))\n {}","user":"4f4e78fee4b03ad3f0c10cc8"},{"code":"(fn lo [x]\r\n  (loop [ret {} se x]\r\n    (if(> (count se) 0)\r\n      (recur \r\n        (assoc ret (first se) (count (filter #(= % (first se)) se)))\r\n        (filter #(not= % (first se)) se))\r\n      ret)))","problem":55,"user":"4de18de7535d08e6dec9fde8"},{"problem":55,"code":"(fn c \n    ([coll] (c coll {}))\n    ([coll m]\n     (if (empty? coll) m \n      (let [f (first coll)\n            cc (if (contains? m f) (m f) 0)] \n          (c (rest coll) (assoc m f (+ cc 1)))\n        )\n       )\n     )\n    )","user":"54cb3497e4b057c6fda3a272"},{"problem":55,"code":"#(->> % \n      (group-by identity)\n      (reduce-kv (fn [m k v] (assoc m k (count v))) {}))","user":"5f37263de4b0574c87022c4e"},{"code":"(fn [coll] (reduce #(assoc % %2 (inc (get % %2 0))) {} coll))","problem":55,"user":"4ff9a200e4b0678c553fc3ab"},{"code":"#(apply hash-map (interleave (sort (distinct %)) (map count (partition-by identity (sort %)))))","problem":55,"user":"50645e12e4b007509339a58a"},{"problem":55,"code":"(fn [coll]\n      (let [ s (group-by identity coll)]\n        (zipmap (keys s) (map #(count (second %)) s))))","user":"53f75957e4b0de5c4184855d"},{"problem":55,"code":";#(reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity %))\n(fn [x] (reduce-kv #(assoc %1 %2 (count %3)) {} (group-by identity x)))","user":"5ebd7296e4b00a66d4a95273"},{"code":"(fn [coll] (into {} (map #(vector (first %) (count (second %))) (group-by identity coll))))","problem":55,"user":"5097a95fe4b00ad8bab4e96e"},{"problem":55,"code":"#(reduce (fn [count-map item]\n           (assoc count-map item (inc (get count-map item 0)))) {} %)\n\n;;#(apply merge-with + (for [e %] {e 1}))","user":"544cf5d7e4b0e39780006977"},{"code":"(fn [l] (reduce #(assoc % %2 (inc (% %2 0))) {} l))","problem":55,"user":"52265e41e4b04e78ff2e1981"},{"problem":55,"code":"(fn [coll]\n\t(let [unique (partition-by identity (sort coll))] \n      (zipmap (map first unique)\n              (map count unique))\n  ))","user":"53a7771ee4b047364c04441b"},{"code":"(fn [input]  \n  (let [foo (partition-by identity (sort input)) \n        fs (map first foo) \n        cts (map count foo)] \n    (zipmap fs cts)))","problem":55,"user":"4f85a75ce4b033992c121c48"},{"problem":55,"code":"(fn [xs]\n  (reduce\n   (fn [acc x]\n     (update-in acc [x] (fnil inc 0)))\n   {}\n   xs))","user":"546ed28be4b00cfc9eacc1a5"},{"problem":55,"code":"(fn [xs]\n  (->> xs\n       (group-by identity)\n       (reduce-kv #(assoc % %2 (count %3)) {})))","user":"53528cd3e4b084c2834f4af2"},{"problem":55,"code":"(fn [xs]\n  (into {} (map \n   (fn [[x y]] [x (count y)])\n   (group-by identity xs)\n   )\n  ))","user":"5ac85708e4b0e27600da77ac"},{"problem":55,"code":"(fn [c]\n  (reduce #(update-in % \n                      [%2]\n                      (fnil inc 0))\n          {}\n          c))","user":"53ea5851e4b036ad0777e4e4"},{"problem":55,"code":"(fn [coll]\n    (into {}\n     (map (fn [[k v]] {k (count v)}) (group-by identity coll))))","user":"56eaad95e4b04a395b9a040f"},{"problem":55,"code":"(fn [v]\n  (loop [s v\n         m (hash-map)]\n    (if (empty? s)\n      m\n      (recur (rest s) (assoc m (first s) (inc (get m (first s) 0)))))))","user":"54651982e4b01be26fd746d4"},{"problem":55,"code":"(fn freqs\n                     ([coll]\n                        (freqs coll {}))\n                     ([coll map]\n                        (if (empty? coll)\n                          map\n\n                          (if (nil? (get map (first coll)))\n                            (freqs (rest coll) (assoc map (first coll) 1))\n                            (freqs (rest coll) (assoc map (first coll) (inc (get map (first coll)))))))))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":55,"code":"(fn [xs]\n  (reduce\n   (fn [m x]\n     (update-in m [x] (fnil inc 0)))\n   {} xs))","user":"5d6e8cc0e4b04d129b00f2c9"},{"code":"(fn [s]\n  (into {} \n    (for [[k v] (group-by identity s)] [k (count v)])))","problem":55,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":55,"code":"(fn [sq]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} sq))","user":"59d4a160e4b0ef0a1e9b5be7"},{"problem":55,"code":"(fn countOccurrences [c]\n    (reduce merge \n            (map #( hash-map (first %) (count (second %))) \n                 (group-by (fn [a] a) c))\n    )\n  )","user":"571aae1fe4b07c98581c3b5a"},{"code":"(fn occurrences [s]\n  (let [update-map (fn [m, k] (if (contains? m k) \n                                (update-in m [k] inc) \n                                (assoc-in m [k] 1)))]\n  (loop [result {}, s2 s]\n    (if (empty? s2)\n      result\n      (recur (update-map result (first s2)) (rest s2))\n    ))))","problem":55,"user":"52cf084ce4b07d0d72b27399"},{"code":"reduce (fn [m item] (update-in m [item] #(if % (inc %) 1))) {}","problem":55,"user":"52c4af71e4b0c2d177d620e1"},{"problem":55,"code":"(fn [ls] (apply hash-map (mapcat (fn [[thing occ]] [thing (count occ)]) (group-by identity ls))))","user":"547584d9e4b0c51c1f4d729b"},{"problem":55,"code":"#(let [coll (partition-by identity (sort %))] (zipmap (map first coll) (map count coll)))","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn [col]\n       (let [uniq (distinct col)\n       getcount (fn [n] (count (filter #(= n %) col)))]\n\t (apply merge (map #(hash-map % (getcount %)) uniq))))","problem":55,"user":"4eae2f9e535d7eef30807324"},{"code":"(fn freq [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","problem":55,"user":"50e4f4e9e4b049a987753896"},{"problem":55,"code":"(fn [coll]\n  (loop [[frst & rst :as coll] coll, acc {}]\n    (if (empty? coll)\n      acc\n      (recur rst (assoc acc frst (+ (get acc frst 0) 1))))))","user":"5d9475e4e4b0d3f9b434ad25"},{"code":"(fn occurences\n  [xs]\n  (reduce (fn [l r]\n            (if (contains? l r)\n              (update-in l [r] inc)\n              (assoc l r 1)))\n          {}\n          xs))","problem":55,"user":"5287f34ee4b0239c8a67ae43"},{"problem":55,"code":"(fn [xs] (reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity xs)))","user":"59da6480e4b0ef0a1e9b5c68"},{"code":"(fn [coll]\n  (reduce \n   #(update-in % [%2] (fn [n] (if (nil? n) 1 (inc n)))) \n   {} coll))","problem":55,"user":"52029e5de4b030ee0c5b26fc"},{"code":"(fn [x] (apply hash-map (mapcat #(vector (first %) (count %))  (partition-by identity (sort x)))))","problem":55,"user":"4e86d3cf535dceadca46984c"},{"problem":55,"code":"#(reduce\n   (fn [counts x]\n       (assoc counts x\n               (inc (get counts x 0))))\n   {} %)","user":"5e08c3dde4b0978307768fc8"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [counts x]\n            (if-let [n (get counts x)]\n              (assoc counts x (inc n))\n              (assoc counts x 1)))\n          {}\n          coll))","user":"5afecee2e4b0cc2b61a3bd28"},{"problem":55,"code":"(fn [l] (reduce\n         (fn [m i] (assoc m i (inc (m i 0))))\n         {}\n         l))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn [coll]\n  (reduce (fn [counts, item]\n            (update-in counts [item] (fnil inc 0)))\n          {} coll))","problem":55,"user":"4dada426c9a9d6ed2a99dc57"},{"problem":55,"code":"(fn rot\n  [coll]\n  (into {} (map (juxt first count) (partition-by identity (sort-by identity coll)))))","user":"5ec5f7f2e4b08d0ec38692d1"},{"problem":55,"code":"(fn\n  [args]\n  (reduce (fn [map arg]\n            (let [count (get map arg)]\n              (if (nil? count)\n                (assoc map arg 1)\n                (assoc map arg (inc count)))))\n          {}\n          args))","user":"5d96edeae4b0d3f9b434ad35"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc el]\n     (assoc acc el (inc (get acc el 0))))\n   {}\n   coll))","user":"5c633df2e4b0fca0c162265c"},{"problem":55,"code":"(fn [coll](reduce #(conj %1 [%2 (inc (get %1 %2 0)) ]) {} coll))","user":"5461873de4b01be26fd746a3"},{"code":"(fn [s]\n  (reduce (fn [m k]\n            (assoc m k (inc (get m k 0)))) {} s))","problem":55,"user":"509ecefde4b08df8156e9e35"},{"code":"(fn my-freq\n  ([s]\n    (my-freq s {}))\n  ([s freq-map]\n    (if (empty? s) freq-map\n      (let [head (first s)\n            new-map (update-in freq-map [head] (fnil inc 0))]\n        (recur (rest s) new-map)))))","problem":55,"user":"5119f3d5e4b06c8af0111818"},{"code":"#(reduce (fn [acc e]\n  (assoc acc e (inc (get acc e 0))))\n  {}\n   %)","problem":55,"user":"4f88ae35e4b033992c121c6d"},{"problem":55,"code":"(partial reduce #(merge-with + %1 {%2 1}) {})","user":"575cbe44e4b02ea114799374"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m x]\n    (assoc m x ((fnil inc 0) (get m x)))\n  ) {} xs)\n)","user":"543bb568e4b032a45b869334"},{"problem":55,"code":"(fn [xs]\n  (loop [ys xs rs {}]\n    (if (empty? ys)\n      rs\n      (let [[y & ys'] ys\n            kv (find rs y)\n            v' (if (nil? kv) 0 (second kv))\n            rs' (dissoc rs y)\n            rs'' (assoc rs' y (inc v'))]\n        (recur ys' rs''))))\n  )","user":"53ef7f77e4b0742d9025b0ce"},{"problem":55,"code":"(fn [coll]\n  (into {}\n        (map (fn [[k v]] [k (count v)])\n             (group-by identity coll))))","user":"571c2babe4b07c98581c3b73"},{"problem":55,"code":"(fn count-occurrences\n  [s]\n  (let [g (group-by identity s)]\n    (into {} (map (fn [[k v]] [k (count v)]) g))))","user":"5f3103aee4b0574c87022c24"},{"code":"(fn [s] (reduce (fn [a b] (assoc a b (inc (or (a b) 0)))) {} s))","problem":55,"user":"5356e569e4b04ce2eb3ed272"},{"code":"(comp\n (partial into {})\n (partial map #(vector (first %) (count (second %))))\n (partial group-by identity)\n )","problem":55,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":55,"code":"(fn [c]\n  (loop [c c\n         m {}]\n    (if (empty? c)\n      m\n      (let [t (first c)\n            v (if (contains? m t) (inc (get m t)) 1)]\n        (recur (rest c) (assoc m t v))))))","user":"54b31445e4b09f271ff37d35"},{"code":"(fn [s]\n  (apply hash-map\n    (mapcat\n      (fn [e] [e (count (filter (partial = e) s))])\n      (set s))))","problem":55,"user":"4fa3f91fe4b081705acca196"},{"code":"(partial reduce #(assoc %1 %2 (inc (get %1 %2 0))) {})","problem":55,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":55,"code":"(fn problem-55 [coll]\n  (reduce #(update-in %1 [%2] (fnil inc 0)) {} coll))","user":"4db2903f535df7e46ed9b6bf"},{"problem":55,"code":"(fn f [coll]\n   (reduce\n    (fn [m v] (assoc m v (inc (get m v 0))))\n    {}\n    coll))","user":"60537cd1e4b04c8f2157d152"},{"problem":55,"code":"(fn my-frequencies\n  [xs]\n  (reduce (fn [acc-map v]\n            (if (acc-map v)\n              (assoc acc-map v (inc (acc-map v)))\n              (assoc acc-map v 1)))\n          {}\n          xs))","user":"5d53a59ae4b0776584bd6f72"},{"code":"(fn myfreq [inlist]\n  ((fn make-count [inmap]\n    (if (empty? inmap)\n      {}\n      (conj {(first (first inmap)) (count (second (first inmap)))}\n        (make-count (rest inmap)))))\n  (group-by identity inlist)))\n\n;(fn myfreq [inlist]\n;  ((fn helper [brokenlist]\n;    (if (empty? brokenlist)\n;      {}\n;      (conj {(first (first brokenlist))\n;              (count (first brokenlist))}\n;        (helper (rest brokenlist)))))\n;  (partition-by identity (sort inlist))))","problem":55,"user":"4fc50bcbe4b081705acca375"},{"problem":55,"code":"#(loop [v % fr {}]\n   (if (not (seq v)) fr\n     (recur (rest v) (assoc fr (first v) (inc (get fr (first v) 0))))\n     )\n   )","user":"52503747e4b0541d1855b828"},{"problem":55,"code":"(fn [coll] \n  (reduce \n    #(assoc %1 %2 (inc (or (%1 %2) 0))) \n    {} \n    coll))","user":"4df73d64535d04ed9115e775"},{"code":"#(into {} (map (fn [[k v]] [k (count v)]) (group-by identity %)))","problem":55,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":55,"code":"(fn [s]\n  (reduce #(assoc % %2 (inc (% %2 0))) \n          {} s))","user":"5654d0e1e4b0f9d632dd848c"},{"problem":55,"code":"(fn [x]\n    (->> x\n         (sort)\n         (partition-by identity)\n         (map #(vector (first %) (count %)))\n         (into {})))","user":"5920c191e4b09b4ee5954c61"},{"problem":55,"code":"(fn p55 [s]\n    (into {} (map  (fn [l] (vec (list (first l) (count l) ))) (partition-by identity ( sort s)))))","user":"579d9601e4b05b1deef9ae18"},{"problem":55,"code":"(fn freq [xs]\n\t(->> xs\n\t(group-by identity)\n\t(reduce (fn [res el] (assoc res (first el) (count (second el)))) {})\n\t))","user":"5c87c79be4b048ec896c591b"},{"problem":55,"code":"(fn freq [xs]\n  \t(let [m (group-by identity xs)]\n    \t(into {} (for [[k v] m] [k (count v)]))\n   \t)\t\n)","user":"55757e81e4b05c286339e063"},{"code":"(fn frequenciesx [coll]\n  (letfn\n    [(update-freqs [freqs, value]\n      (assoc freqs value (inc (get freqs value 0))))]\n  (reduce update-freqs {} coll)))","problem":55,"user":"4f4e4ecbe4b03ad3f0c10cbf"},{"problem":55,"code":"(fn [c]\n  (let [fmap (fn [f m] (into {} (for [[k v] m] [k (f v)])))]\n    (fmap count (group-by identity c))))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn [xs]\n  (reduce #(assoc %1 (key %2) (count (val %2))) {} (group-by identity xs)))","problem":55,"user":"52f10094e4b05e3f0be25ee8"},{"problem":55,"code":"(fn [l]\n  (\n   (fn fmap [f m]\n     (into {} (for [[k v] m] [k (f v)]))\n     )\n   count\n   (group-by identity l))\n  )","user":"562add6de4b00e49c7cb4834"},{"code":"#(reduce (fn [m i](assoc m i (inc (get m i 0)))) {} %)","problem":55,"user":"52570aeae4b0541d1855ba42"},{"code":"(fn [s]\n  (reduce (fn [freqs item]\n            (update-in freqs [item] (fn [index] (if (contains? freqs item) (+ (freqs item) 1) 1))))\n          {} s))","problem":55,"user":"4fe8e771e4b0547ebccb2431"},{"code":"(fn occurences \n  ([coll] (occurences coll {}))\n  ([coll map]\n    (let [first (first coll) val (get map first)]\n      (if (empty? coll)\n        map\n        (if (nil? val)\n          (occurences (rest coll) (assoc map first 1))\n          (occurences\n            (rest coll)\n            (assoc map first (+ 1 val))))))))","problem":55,"user":"4f4f08c8e4b03ad3f0c10cd8"},{"problem":55,"code":"(fn frequencies* [s]\n  (->>\n   s\n   (group-by identity)\n   (map (fn [[x y]] (vector x (count y))))\n   (apply concat)\n   (apply hash-map)))","user":"5392500ae4b0b51d73faaeaf"},{"problem":55,"code":"(fn [vect]\n  (reduce #(if (nil? (%1 %2))\n             (assoc %1 %2 1)\n             (assoc %1 %2 (inc (%1 %2))))\n          {}\n          vect))","user":"5655e056e4b0f9d632dd849b"},{"problem":55,"code":"#(let [i % y (mapv (fn[x](filterv #{x} i))(distinct i)) z (mapv (fn [k] (assoc {} (first k) (count k))) y)\n        m (reduce merge z)\n        ] m)","user":"5b044436e4b0cc2b61a3bd71"},{"problem":55,"code":"(fn freqs [xs]\n  (into {}\n        (map #(vector (first %) (count (second %))) (group-by identity xs))))","user":"53c126fce4b00fb29b22125b"},{"code":"(fn [s]\n  (into {} \n        (for [[k v] (group-by (fn [x] x) s)]\n          [k (count v)])))","problem":55,"user":"531d34cfe4b08068f379edac"},{"problem":55,"code":"(fn count-occur \n  ([x] (count-occur x {}))\n  ([x y]\n    (if (= 0 (count x))\n      y\n      (recur (rest x) (if (contains? y (first x))\n (assoc y (first x) (inc (get y (first x))))\n (assoc y (first x) 1))))))","user":"5c1d9f05e4b0efcb0b05b24c"},{"problem":55,"code":"(fn\n  [x]\n  (let [dist (distinct x)\n        occurrences (map #(count (filter (fn[y] (= y %)) x)) dist)]\n    (zipmap dist occurrences)))","user":"58a1d00ae4b02bd94d917ec6"},{"code":"(let [remove-all\n      (fn removeall [x y]\n        (if (empty? x)\n          x\n          (if (= (first x)\n                 y)\n            (removeall (rest x) y)\n            (cons (first x)\n                  (removeall (rest x) y)))))]\n\n  (fn countocc [z]\n    (if (empty? z)\n      z\n      (merge (hash-map (first z)\n                       (reduce + (map #(if (= (first z) %) 1 0) z)))\n             (countocc (remove-all z (first z)))))))","problem":55,"user":"52e17e66e4b09f7907dd1423"},{"code":"(comp (partial into {})\n      (partial map #(vector (first %) (count (second %))))\n      (partial group-by first)\n      (partial map #(vector % :dummy)))","problem":55,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn [xs]\n        (reduce (partial merge-with +)\n                (map hash-map xs (repeat 1))))","problem":55,"user":"5055e7f4e4b0ce54f56f0401"},{"code":"#(apply merge (for [[k v] (group-by identity %)] {k (count v)}))","problem":55,"user":"50a4f36be4b0344e360f3bc9"},{"code":"(fn [coll]\n   (loop [occ '{} i 0]\n     (if (= i (count coll))\n       occ\n       (recur\n        (if (contains? occ (nth coll i))          \n          (assoc occ (nth coll i) (inc (get occ (nth coll i))))\n          (assoc occ (nth coll i) 1)\n          )\n        (inc i))\n       )\n     )\n   )","problem":55,"user":"4ea31da2535d7eef308072c1"},{"problem":55,"code":"#(into {} (for [[k v] (group-by identity (sort %))]\n   [k (count v)]))","user":"54630cdae4b01be26fd746bb"},{"problem":55,"code":"(fn [x] (into {} (map #(vector (key %) (count (val %))) (group-by identity x))))","user":"51bfc1f0e4b0e49ef9037dd4"},{"problem":55,"code":"#(let [w (group-by identity %1)]\n   (zipmap (keys w) (map count (vals w))))","user":"5e41b679e4b01d43a70e8e58"},{"code":"#(reduce\n   (fn [r k]\n     (assoc r k (inc (get r k 0))))\n   {} %)","problem":55,"user":"4e5676b2535d8a8b8723a282"},{"code":"(fn [l]\n  (loop [l l acc {}]\n    (if (seq l)\n        (let [head (first l)\n              value (get acc head 0)]\n          (recur (rest l) (assoc acc head (inc value))))\n        acc)))","problem":55,"user":"4e568873535d8a8b8723a283"},{"code":"#(into (hash-map) \r\n  (map \r\n    (fn [g] [(first g) (count (last g))]) \r\n    (group-by identity %)))","problem":55,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":55,"code":"(fn [c] (let [a (group-by identity c)] (reduce #(assoc % (key %2) (count (val %2))) a a)))","user":"53f78944e4b0de5c41848561"},{"code":"reduce #(assoc %1 %2 (inc (get %1 %2 0)))  {}","problem":55,"user":"4ebe766d535dfed6da9c6d94"},{"problem":55,"code":"(fn count-occ [coll]\n  (let [m (group-by identity coll)]\n    (reduce (fn [m1 [k v]]\n           (assoc m1 k (count v)))\n            {}\n            m)))","user":"565654dae4b0f9d632dd849f"},{"problem":55,"code":"(fn frequenciesX [x] (reduce-kv (fn [m k v] (assoc m k (count v))) {} (group-by identity x)))","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [coll]\n  (reduce (fn [counts x] (assoc counts x (inc (get counts x 0)))) {} coll))","problem":55,"user":"50052fd0e4b0678c553fc45d"},{"code":"#(into {}\n       (map (fn [[k v]] [k (count v)])\n            (group-by identity %)))","problem":55,"user":"51e89428e4b006d205356a51"},{"problem":55,"code":"(fn my-occur\n  ([xs] (my-occur xs {}))\n  ([[x & xs] m]\n   (let [my-update (fn [m k f] (assoc m k (f (get m k))))]\n     (if x\n       (recur xs (my-update m x #(if (nil? %1) 1 (inc %1))))\n       m))))","user":"51e24905e4b01e519814642e"},{"code":"(fn [x]\n    (loop [x x\n           acc {}]\n      (if (zero? (count x))\n        acc\n          (recur (remove #{(first (sort x))} (sort x))\n                 (assoc acc (first (sort x)) (count (take-while #{(first (sort x))} (sort x))))))))","problem":55,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m x]\n            (assoc m x (inc (get m x 0))))\n          {}\n          coll))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn [m] (->> (group-by identity m) \n             (map (fn [[k v]] [k (count v)]))\n             (into {})))","problem":55,"user":"5012ec0ae4b0c87326002230"},{"code":"(fn[x] (into {}(map (fn[[a b]] {a (count b)}) (group-by identity x))))","problem":55,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":55,"code":"(fn [seq]\n  (reduce (fn [prev cur]\n            (if (get prev cur)\n              (assoc prev cur (inc (get prev cur)))\n              (assoc prev cur 1)\n              )\n  ) {} seq)\n  )","user":"5ccaed31e4b0ccb061962877"},{"problem":55,"code":"(fn [s]( zipmap (keys (group-by identity s)) (map count (vals (group-by identity s))) ))","user":"56039843e4b04bb52996e1be"},{"problem":55,"code":"reduce (fn [acc e] (if (contains? acc e) (update-in acc [e] inc) (assoc acc e 1))) {}","user":"5cfd5a93e4b0cc9c91588168"},{"code":"(fn count-occ [s]\n  (if (empty? s) {}\n      (merge-with + {(first s) 1} (count-occ (rest s)))))","problem":55,"user":"51b76227e4b0d906fcd71d35"},{"problem":55,"code":"(fn [s]\n  (loop [n 1 r s retval {}]\n    (if (= n (inc (count s)))\n      retval\n      (recur (inc n) \n             (rest r) \n             (if (contains? retval (first r))\n               (assoc retval (first r) (inc (get retval (first r))))\n               (assoc retval (first r) 1))))))","user":"586d2f5be4b01531a375e98c"},{"problem":55,"code":"(fn count-occurrences [s]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity s))))","user":"5daeb6bce4b0f8c104ccfc8b"},{"problem":55,"code":"#(reduce (fn [coll xs] (assoc coll (first xs) (count xs))) {} (vals (group-by identity %)))","user":"5627d09ce4b00e49c7cb47db"},{"code":"(fn cocc\n  ([v] (cocc v {}))\n  ([v m]  \n    (let [fst (first v)]\n      (cond\n        (empty? v) \n            m\n        (m fst)\n            (recur (rest v) (assoc m fst (inc (m fst))))\n        true\n            (recur (rest v) (assoc m fst 1))))))","problem":55,"user":"4e28120f535deb9a81d77efa"},{"problem":55,"code":"#(into {}\n       (map (fn [[i s]]\n              (-> [i (count s)]))\n            (group-by identity %)))","user":"5aeca4c9e4b0cc2b61a3bc0a"},{"problem":55,"code":"(fn [x](let [d (distinct x) f (map #(count (filter (fn[y](= % y)) x)) d)]\n         (zipmap d f)\n         ))","user":"575dda55e4b02ea11479938c"},{"code":"(fn [s] (reduce (fn [m i] (assoc m i (inc (get m i 0)))) {} s))","problem":55,"user":"51a4416ae4b0def3c5c5868c"},{"code":"#(reduce (fn [m e]\n     (into m\n           {e (inc (m e 0))})) {} %)","problem":55,"user":"4daa374930acd6ed13482a68"},{"problem":55,"code":"(fn [col]\n  (reduce\n    (fn [count item]\n        (assoc count item (inc (get count item 0))))\n    {} col))","user":"4fe3338ee4b0e8f79898fea8"},{"code":"(fn [coll]\n  (->> coll\n       (group-by identity)\n       (mapcat (fn [[k v]] [k (count v)]))\n       (apply hash-map)))","problem":55,"user":"52437703e4b076204b44fabf"},{"problem":55,"code":"(fn [coll] (let [m (group-by identity coll)] (reduce #(assoc %1 %2 (count (%1 %2))) m (keys m))))","user":"542c1f73e4b0dad94371f29d"},{"problem":55,"code":"#(into {} (map (fn [[k v]] [k (count v)])  (group-by identity %)))","user":"55201d18e4b08d5046aa8a5d"},{"code":"(fn count-occurences [coll]\r\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","problem":55,"user":"4ddb339c535d02782fcbe9f9"},{"problem":55,"code":"#(->> %\n            (group-by identity)\n            (map (fn [[k v]] [k (count v)]))\n            (into {}))","user":"58949f8de4b00487982d525e"},{"code":"#(into {} (map (fn[[k v]] {k, (count v)}) (group-by identity %)))","problem":55,"user":"4fd7962ee4b0dab7d829f385"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m v] (update-in m [v] #(if % (inc %) 1)))\n          {}\n          coll))","user":"56098ccbe4b0053d1b86c7e4"},{"problem":55,"code":"(fn [col] \n  (let [x (group-by identity col)] \n                 (zipmap (keys x) \n                         (map count (vals x)))))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn [col](reduce conj ( map #(hash-map  (key %) (count (val %)))\n                   (group-by identity col))))","problem":55,"user":"50e90813e4b033b0e80d11e7"},{"problem":55,"code":"(fn f [s]\n  (let [inc-freq (fn [m k] (inc (get m k 0)))]\n    (reduce #(assoc %1 %2 (inc-freq %1 %2)) {} s)))","user":"54814dbee4b0e286459a116b"},{"code":"#(into {} (map (fn [[e es]] [e (count es)]) (group-by identity (sort %))))","problem":55,"user":"5063fe48e4b075d771da6f9e"},{"problem":55,"code":"#(->> %\n     (group-by identity)\n     (map (juxt first (comp count second)))\n     (into {}))","user":"516db4f6e4b046df6fbb76a0"},{"problem":55,"code":"(fn [s]\n  (loop [s s m {}]\n    (if (empty? s)\n      m\n      (recur (rest s)\n             (if (contains? m (first s))\n               (update-in m [(first s)] inc)\n               (into m {(first s) 1}))))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":55,"code":"(partial reduce #(assoc %1 %2 (+ 1 (get %1 %2 0))) {})","user":"5245e320e4b09dbe66b56177"},{"problem":55,"code":"#(->> %\n      (sort-by identity)\n      (partition-by identity)\n      (reduce (fn [a b] (conj a ((juxt first count) b))) {}))","user":"56677192e4b04acd4f672dd5"},{"problem":55,"code":"(fn [coll]\n  (apply (partial merge-with +) (map #(hash-map % 1) coll)))","user":"567c2322e4b05957ce8c61af"},{"problem":55,"code":"(fn [xs]\n    (reduce #(if (contains? %1 %2)\n               (update-in %1 [%2] inc)\n               (assoc %1 %2 1)) {} xs))","user":"5921a080e4b09b4ee5954c77"},{"code":"#(reduce (fn [result value]\n           (assoc result value (inc (get result value 0))))\n         {}\n         %)","problem":55,"user":"4e7c8fd1535db169f9c796be"},{"problem":55,"code":"(fn co[xs]\n  (reduce (fn [memo, [x y]]  (assoc memo x (count y)))\n          {}\n          (group-by identity xs)))","user":"5980f91ae4b021a7a535fddd"},{"problem":55,"code":"(fn my-count[c]\n  (->> c (group-by (fn [x] x)) (map #(hash-map (key %) (count (val %)))) (into {})))","user":"5546704be4b0a04f7929953d"},{"problem":55,"code":"(fn [coll] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"53ee7f2ee4b0d648e757f4cf"},{"problem":55,"code":"#(into {} (map (fn [[key val]] [key (count val)]) (group-by identity %)))","user":"5f247827e4b0f565ad998292"},{"problem":55,"code":"(partial reduce (fn [m v] (assoc m v (inc (get m v 0)))) {})","user":"5052ab7ee4b0a561d07d8f20"},{"problem":55,"code":"(fn [x] (->> x set (map (fn [y] (filter #(= y %) x))) (map #(list (first %) (count %))) (apply concat) (apply hash-map)))","user":"569c1038e4b0542e1f8d145f"},{"problem":55,"code":"(fn [a]\n  (letfn [(d [acc xs]\n            (cond\n              (empty? xs) acc\n\n              (acc (first xs))\n              (d (assoc acc\n                        (first xs)\n                        (inc (acc (first xs))))\n                 (rest xs))\n\n              :else (d (assoc acc\n                              (first xs)\n                              1)\n                       (rest xs))))]\n    (d {} a)))","user":"571ac75ae4b07c98581c3b5c"},{"code":"(fn f [s]\n    (let [smap (group-by identity s)]\n    (zipmap (keys smap) (map count (vals smap)))\n  ))","problem":55,"user":"50432da5e4b034ff00315d1e"},{"problem":55,"code":"(fn [s]\n  (reduce \n   (fn [freqs v]\n     (update-in freqs [v] #(inc (or % 0))))\n   {} s))","user":"57a4fa50e4b0a966079561f1"},{"code":"(partial reduce #(assoc % %2 (inc (get % %2 0))) {})","problem":55,"user":"524f213be4b0541d1855b7ff"},{"code":"(fn [v]\n  (into {} (map (fn [item] (vector item (count (filter #(= % item) v))))\n        (set v))))","problem":55,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"#(reduce \r\n   (fn f[table elem]\r\n\t     (if (nil? (table elem))\r\n\t\t (assoc table elem 1)\r\n\t\t (assoc table elem (inc (table elem)))))\r\n     {} %)","problem":55,"user":"4e53bf5e535d8a8b8723a275"},{"problem":55,"code":"(fn [x] (into {} (map #(vector (first %) (count (second %)))(group-by identity x))))\n;;(into {} (map #(vector (first %) (count (second %)))(group-by identity )))","user":"57ee41eae4b0bfb2137f5bb0"},{"problem":55,"code":"(fn [-seq]\n  (reduce (fn [res el]\n            (assoc res el (inc (get res el 0))))\n          {}\n          -seq))","user":"5ddb6151e4b0948ae9d9adb0"},{"problem":55,"code":"(fn [coll]\n    (let [group (partition-by identity (sort coll))]\n      (zipmap (map first group) (map count group))))","user":"56ede653e4b04a395b9a0449"},{"problem":55,"code":"(fn count-occurences [coll]\n  (apply merge (for [[k v] (group-by identity coll)]\n                 {k (count v)})))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [xs]\r\n   (reduce (fn [table y]\r\n             (let [value (get table y)]\r\n               (if value\r\n                 (assoc table y (inc value))\r\n                 (assoc table y 1))))\r\n\r\n           {} xs))","problem":55,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":55,"code":"(fn [li]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity li))))","user":"59156f0be4b0163c97b36f3d"},{"code":"reduce (fn[m k](assoc m k (inc (get m k 0)))) {}","problem":55,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn [v] (apply merge-with + (map #(hash-map % 1) v)))","problem":55,"user":"4fd2e5d8e4b04c3a95aa0427"},{"problem":55,"code":"#(into {} (for [i (partition-by identity (sort %))] [(first i) (count i)]))","user":"55c10409e4b01b9910ae2a2c"},{"problem":55,"code":"(fn [xs]\n  (->> xs\n       (group-by identity)\n       (map (fn [[k v]] {k (count v)}))\n       (apply conj)))","user":"5d28d935e4b092dab7f59c88"},{"code":"(fn [xs] (let [gm (group-by identity xs)]\n           (zipmap (keys gm) (map count (map gm (keys gm))))))","problem":55,"user":"51aab611e4b04e3dc0c27b2d"},{"problem":55,"code":"(fn [l] (reduce #(update-in % [%2] (fn [v] (if (nil? v) 1 (inc v)))) {} l))","user":"52540bcce4b0541d1855b952"},{"code":"(fn [coll]\n  (let [groups (partition-by identity (sort coll))]\n    (reduce #(assoc %1 (first %2) (count %2)) {} groups)))","problem":55,"user":"50b8914ce4b0cba0e598b64d"},{"problem":55,"code":"#(into {} (for [x (set %1)] (hash-map x (count (filter (fn[val](= val x)) %1)))) )","user":"59692530e4b069c0a1a197e4"},{"problem":55,"code":"(fn [s]\n  (reduce #(assoc %\n             %2\n             (inc (get % %2 0)))\n          {}\n          s))","user":"57008afae4b08d47c97781ca"},{"problem":55,"code":"reduce\n   #( merge-with + {%2 1} %1)\n   {}","user":"57487084e4b009280f9f2b8c"},{"code":"#(reduce (fn [a e] (assoc a e (inc (get a e 0)))) {} %)","problem":55,"user":"530bf87ee4b02e82168697d5"},{"problem":55,"code":"(comp (partial apply conj {}) (partial map (juxt first count)) (partial partition-by identity) sort)","user":"5e2549c8e4b05b4b0151615f"},{"problem":55,"code":"(fn\n  [inSeq]\n  (reduce (fn [outMap inValue]\n            ;Check if the inValue exists as a key in outMap\n            ;If not then we add it as a new key and give it\n            ;the value 1.\n            ;If the key does already exist then we\n            ;associate the key and the count incremented by one.\n            (if (some #(= % inValue) (keys outMap))\n              (assoc outMap inValue (inc (get outMap inValue)))\n              (assoc outMap inValue 1))\n            )\n          {}\n          inSeq))","user":"5b69bf95e4b0c6492753e790"},{"problem":55,"code":"(fn [veca]\n   (zipmap (distinct (sort veca) ) (map (fn [a] (count a)) (partition-by identity (sort veca)))))","user":"5b7ed20fe4b047b03b203760"},{"code":"(fn [c]\n    (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} c))","problem":55,"user":"53300924e4b019098a6f8b55"},{"problem":55,"code":"(fn freqs\n  [xs]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs))","user":"5d609ddde4b0c9e5857d5008"},{"problem":55,"code":"(fn [xs]\n  (reduce\n   (fn [m k]\n     (update-in m [k] (fnil inc 0)))\n   {}\n   xs))","user":"54c5cc17e4b045293a27f624"},{"problem":55,"code":"#(into {} (map (fn [[_ ls]] [(first ls) (count ls)]) (group-by identity %)))","user":"57915ba4e4b0ebec4cfb75ba"},{"code":"#(into {}\n  (map (fn [[k v]] [k (count v)]) (group-by identity %)))","problem":55,"user":"4f1b0ab3535d64f603146474"},{"problem":55,"code":"(fn [l]\n  (loop [l l m {}]\n    (if-not (seq l)\n      m \n      (recur (pop l) (assoc m (peek l) (+ 1 (m (peek l) 0))))\n      )\n    ) \n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":55,"code":"(fn [l]\n  (reduce\n    (fn [acc [k v]] (assoc acc k (count v)))\n    {}\n    (group-by identity l)))","user":"602049b8e4b0bf4ca6b10961"},{"code":"reduce #(assoc %1 %2 (let [v (%1 %2)]\n                       (if (nil? v) 1 (+ v 1)))) {}","problem":55,"user":"538d8bb8e4b0b51d73faae71"},{"problem":55,"code":"#(zipmap\n  (map first\n       (vals (group-by identity %)))\n  (map count \n       (vals (group-by identity %))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (map (fn [[k v]] [k (count v)]))\n      (into {}))","user":"53f891eee4b0de5c4184856d"},{"code":"(fn freqs [xs] \n  (let [grps (group-by identity xs)]\n\t\t(zipmap (keys grps) (map count (vals grps)))))","problem":55,"user":"5114ab7be4b0ce5098ee73b5"},{"code":"(fn\n  [s]\n  (let [m (group-by identity s)]\n    (into {} (for [x m] {(key x) (count (val x))}))))","problem":55,"user":"4f18677d535d64f603146459"},{"code":"(fn my-frequencies [s]\n  (reduce\n   (fn [item-map item]\n     (assoc item-map item (if (contains? item-map item) (inc (item-map item)) 1)))\n   {}\n   s))","problem":55,"user":"5310e7aee4b08068f379ecdc"},{"code":"(fn [x & m]\n  (cond (nil? (first x)) m\n        (nil? m) (recur x {})\n        (nil? (m (first x))) \n              (recur (rest x) (assoc m (first x) 1))\n        :else (recur (rest x) \n              (assoc m (first x) \n                     (inc (m (first x)))))))","problem":55,"user":"4f343e60e4b0e243712b1eb5"},{"code":"(fn[x](apply merge (map #(hash-map (first %) (count (second %)))  (group-by identity x))))","problem":55,"user":"52d66ca0e4b09f7907dd135c"},{"problem":55,"code":"(fn get-freq [col]\n  (reduce (fn [acc x]\n            (assoc acc x (inc (get acc x 0))))\n          {} col))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":55,"code":"(fn [l] (reduce \n         #(do (println %1 %2) (assoc %1 (first %2) (count %2)) ) \n         {} (partition-by identity (sort-by #(str %1) l))))","user":"54edcf96e4b024c67c0cf866"},{"code":"(fn\n  [coll]\n  (reduce #(conj %1 (hash-map (first %2) (count (second %2)))) {} (group-by identity coll)))","problem":55,"user":"52ba447ee4b07a9af57922ce"},{"problem":55,"code":"(fn  [xx]\n  (reduce (fn c [d x] \n            (assoc d x  (inc (get d x 0)))) {} xx))","user":"5d2b88a6e4b01671435dbc84"},{"code":"(fn f [xs]\n  (let [m (group-by #(identity %1) xs)]\n    (into {} (for [[k v] m] [k (count v)]))))","problem":55,"user":"51d662fce4b0154f82ab92ef"},{"problem":55,"code":"(fn [seq]\r\n  (apply hash-map (reduce concat\r\n    (map (fn [[k v]] [k (count v)])\r\n      (group-by #(-> %) seq)))))","user":"555bd27ae4b0b056612e2244"},{"problem":55,"code":"(fn occurences-count\n  ([col]\n   (occurences-count col {}))\n  ([col count-map]\n   (if (empty? col)\n     count-map\n     (let [ele (first col)\n           ele-count (get count-map ele 0)           \n           ]\n       (recur (rest col) (assoc count-map ele (inc ele-count)))\n       )\n     )\n   )\n  )","user":"5455a6d3e4b0e397800069e2"},{"problem":55,"code":"(fn [s]\n  (into {}\n        (map\n         (fn [[k v]] [k (count v)])\n         (group-by identity s))))","user":"56ca0da9e4b0ea9b8538f715"},{"problem":55,"code":"(fn k [x] (apply hash-map (mapcat (fn [c] (list (first c) (count (last c)))) (group-by identity x))))","user":"53fdc4b8e4b0de5c418485ea"},{"code":"(fn freq [col]\n  (reduce #(assoc % %2 (inc (% %2 0))) {} col))","problem":55,"user":"4ed27f9f535d44c135fd68d5"},{"code":"(fn [xs] (reduce-kv #(assoc % %2 (count %3)) {} (group-by identity xs)))","problem":55,"user":"51131da8e4b0350614f07a83"},{"code":"(comp (partial into {}) (partial map (fn[c] (vector (first c) (count c)))) (partial partition-by (fn [i] i)) sort)","problem":55,"user":"4ecbb249535df97575fdabdf"},{"problem":55,"code":"(fn [x]\n  (->>\n   (group-by identity x)\n   (map #(hash-map (key %) (count (val %))))\n   (into {})))","user":"5405885ee4b0addc1aec6668"},{"problem":55,"code":"#(reduce (fn [m k] (assoc m k (inc (m k 0)))) {} %)\n\n;; or:\n; #(reduce (fn [m k] (update m k (fnil inc 0))) {} %)\n\n;; or:\n; #(->> (sort %)\n;       (partition-by identity)\n;       (map (fn [xs] [(first xs) (count xs)]))\n;       (into {}))","user":"59eb63e3e4b0249b7282077c"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m e] (if(m e) (assoc m e (inc (m e))) (assoc m e 1))) {} s))","user":"5b4ff637e4b02d533a91bce0"},{"problem":55,"code":"(fn fq [cl]\n  (reduce\n    (fn [acc v]\n      (assoc acc v (inc (get  acc v 0))))\n    {}\n    cl\n    )\n  )","user":"60436423e4b02d28681c77a3"},{"problem":55,"code":"(fn [li] \n(reduce \n\t(fn [res val]\n\t\t(update-in res [val] #(if (nil? %) 1 (inc %)) )) {} li))","user":"54be7e93e4b0ed20f4ff6eed"},{"problem":55,"code":"(fn [c] (reduce (fn [a [k v]] (assoc a k (count v))) {} (group-by identity c)))","user":"5a5894d9e4b05d388ecb6c81"},{"code":"(fn [seq]\n (let [s (set seq) v (for [e s] [e (count (filter #(= e %) seq))])]\n    (apply hash-map (reduce concat  v))\n  )\n)","problem":55,"user":"522eba30e4b01cdb292c5f0e"},{"problem":55,"code":"#(apply merge-with +(for [e  %] {e 1}))","user":"57b13adae4b0fbc9809a2750"},{"code":"(fn newcount [xlis] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) (sorted-map) xlis))","problem":55,"user":"4dadca03c9a9d6ed4199dc57"},{"problem":55,"code":"(fn [lst]\n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity lst)))\n)","user":"5943abb6e4b060784b3b792b"},{"problem":55,"code":"(fn [coll]\n  (let\n   [base (reduce (fn [acc v] (assoc acc v 0)) {} (distinct coll))]\n    (reduce (fn [acc curr] (assoc acc curr (+ (get acc curr) 1))) base coll)))","user":"5fac50f4e4b08cb800c85ae5"},{"problem":55,"code":"(fn [coll]\n  (into {}\n        (for [[k v] (group-by identity coll)]\n          {k (count v)})))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":55,"code":"(fn [coll]\n  (letfn [(update [coll k f] (assoc coll k (f (get coll k))))]\n  (reduce (fn [roll value] (update roll value (fn [v] (if (nil? v) 1 (inc v))))) {} coll))\n  )","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"(fn [s] \n  (apply sorted-map \n         (mapcat (fn [x] \n                   [x (count (filter #(= % x) s))]) \n                 (set s))))","problem":55,"user":"5294e44de4b02ebb4ef75016"},{"problem":55,"code":"(fn f [li]\n  (reduce \n    (fn [col x] \n      (update-in\n        col \n        [x]\n        (fnil inc 0))) {} li))","user":"4e6a5728535d8ccf87e9fecf"},{"code":"(fn f[l]\n  (reduce\n   #(assoc %1 %2 (inc (or (%1 %2) 0)))\n   {}\n   l))","problem":55,"user":"4ec3650f535dcc7ae8597d56"},{"code":"(fn [coll]\r\n    (reduce #(assoc %1 %2 (inc (get %1 %2 0)))\r\n            {} coll))","problem":55,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn [l]\n  (apply merge\n    (let [ks (distinct l)]\n      (for [k ks]\n        {k (count (filter #(= k %) l))}))))","problem":55,"user":"519136e9e4b0f8ef0be96c01"},{"problem":55,"code":"(fn [coll] \n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","user":"4eb3fcba535d7eef30807359"},{"problem":55,"code":"(fn [s]\n  (reduce\n   #(if-let [val (get %1 %2)]\n      (assoc %1 %2 (+ 1 val))\n      (assoc %1 %2 1))\n   {}\n   s))","user":"53573d70e4b04ce2eb3ed278"},{"problem":55,"code":"#(apply merge-with  + (for [x %] {x 1}))","user":"575d16f8e4b02ea114799377"},{"code":"(fn [s]\n  (->> s\n       (sort ,,)\n       (partition-by identity ,,)\n       (mapcat #(vector (first %) (count %)) ,,)\n       (apply hash-map ,,)))","problem":55,"user":"4dd0e8f7535da60f04a96e57"},{"problem":55,"code":"(fn [v]\n   (reduce \n    #(assoc % %2 (inc (get % %2 0)))\n           {} v))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":55,"code":"(fn foo [coll]\n        (loop [coll coll\n               res {}\n               numb (set coll)\n               helper (fn helper [coll x]\n        (cond (empty? coll) 0\n              (= (first coll) x) (+ 1 (helper (rest coll) x))\n              :else (helper (rest coll) x)\n              ))\n               ]\n          (if (empty? numb) res\n              (recur coll \n                     (conj res (hash-map (first numb) \n                                         (helper coll (first numb))))\n                     (rest numb) helper\n                     ))))","user":"6038b6b4e4b0d5df2af222ef"},{"problem":55,"code":"(fn freq [coll]\n  (reduce (fn [freqs v]\n            (assoc freqs v (inc (get freqs v 0))))\n          {}\n          coll))","user":"553dd883e4b0a04f792994e6"},{"code":"(fn [col]\n  (loop [c col m {}]\n\t\t(if (empty? c) \n\t\t\tm\n\t\t\t(if (contains? m (first c))\n\t\t\t\t(recur (rest c) (update-in m [(first c)] inc))\n\t\t\t\t(recur (rest c) (assoc m (first c) 1))))))","problem":55,"user":"5054e37fe4b0b1b9d1860eb6"},{"code":"reduce #(assoc % %2 (+ 1 (get % %2 0))) {}","problem":55,"user":"4e03c616535d04ed9115e796"},{"code":"(fn [l]\n  (loop [l l\n         m {}]\n    (if (= () l)\n      m\n      (recur\n        (rest l)\n        (update-in m [(first l)] (fn [v] (if (nil? v) 1 (inc v))))))))","problem":55,"user":"50435852e4b034ff00315d22"},{"code":"(fn\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))","problem":55,"user":"524dd1c3e4b0f245900d275c"},{"code":"(fn [coll]\n  (apply hash-map (mapcat\n    (fn [[a b]] [a (count b)]) \n    (group-by identity coll)\n  )))","problem":55,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn [x] \n  (reduce #(assoc % %2 (inc (get % %2 0)))\n    {}\n    x))","problem":55,"user":"4dd88803535d2dad7130b5d9"},{"problem":55,"code":"(fn [a]\n  (reduce #(if (nil? (%1 %2))\n             (conj %1 [%2 1])\n             (conj %1 [%2 (inc (%1 %2))])) {} a))","user":"52281e1ee4b0186687e23a69"},{"problem":55,"code":"(fn freqs [s]\n  (into {}\n        (map #(let [[a b] %]\n                (vector a (count b)))\n             (group-by identity s))))","user":"5ab564f8e4b073f177442639"},{"code":"(fn [coll]\n  (persistent! (reduce #(assoc! %1 %2 (inc (get %1 %2 0))) (transient {}) coll)))","problem":55,"user":"51ab1da1e4b04e3dc0c27b30"},{"code":"(fn [v] (reduce #(assoc % %2 (inc (get % %2 0))) {} v))","problem":55,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":55,"code":"(fn count-occurences [xs] \n  (let [m (group-by identity xs)\n        k (keys m)\n        v (vals m)]\n    (zipmap k (map count v))))","user":"52616198e4b03e8d9a4a705e"},{"problem":55,"code":"reduce\n  (fn [map key]\n    (assoc map key (inc (or (get map key) 0))))\n    ;(update map key (fnil inc 0)))\n  {}","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn [c] (let [m (group-by identity c)] (reduce #(assoc %1 (first %2) (count (last %2))) m m)))","problem":55,"user":"4fd29d7ce4b04c3a95aa0424"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [m x] (let [v (m x) fq (if (nil? v) 0 v)] (assoc m x (+ fq 1)) )) {} xs))","user":"55316b8ae4b076ab5578f825"},{"problem":55,"code":"(fn my-freq\n  [coll]\n  (loop [c coll a {}]\n    (if (empty? c)\n      a\n      (let [head (first c) tail (rest c)]\n        (recur tail (update-in a [head] #(if % (inc %) 1)))\n        )\n      )\n    )\n  )","user":"5a90395ce4b05369db4d254a"},{"problem":55,"code":"(fn count-occurences\n  ([coll] (count-occurences coll {}))\n  ([coll m]\n  (if (empty? coll)\n    m\n    (let [k (first coll) new-coll (rest coll)]\n      (if (contains? m k)\n        (recur new-coll (assoc m k (inc (get m k))))\n        (recur new-coll (assoc m k 1)))))))","user":"55afc197e4b002ce9d5cbc18"},{"problem":55,"code":"(fn freq [x] (apply hash-map (mapcat identity (map (fn [a] [(first a) (count (second a))]) (group-by identity (sort x))))))","user":"55280930e4b0ffed3738f93b"},{"problem":55,"code":"(fn [coll]\n  (loop [fr {} coll coll]\n    (if (empty? coll)\n     \tfr\n      \t(let [value (first coll)\n              times (count (filter #(= value %) coll))\n              remaining (filter #(not (= value %)) coll)]\n        \t  (recur (assoc fr value times) remaining)  \n        )\t\n     )\n   )\n)","user":"5de6484ce4b0986d99407f66"},{"problem":55,"code":"(fn [x]\n (reduce (fn [acc e]\n           (if (acc e)\n             (assoc acc e (inc (acc e)))\n             (assoc acc e 1)  \n             ))\n         {}\n   x      \n         ) )","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":55,"code":"(fn [v]\n      (reduce (fn [map x]\n                (if-let [fq (map x)]\n                  (assoc map x (inc fq))\n                  (assoc map x 1)))\n              {} v))","user":"54487527e4b032a45b8693cc"},{"problem":55,"code":"(fn f [seq]\n  (let [x (group-by #(identity %) seq)]\n    (into {} (for [[k v] x] [k (count v)]))))","user":"5cada3b8e4b026601754b872"},{"problem":55,"code":"(fn [s] (reduce\n  #(assoc %1 %2 (-> (get %1 %2 0) inc))\n  {}\n  s))","user":"5a4993c0e4b05d388ecb6b71"},{"problem":55,"code":"(fn [coll] (->> (group-by identity coll)\n                (map (fn [[x y]] [x (count y)]))\n                (into {})))","user":"55d28b38e4b0e31453f64a58"},{"problem":55,"code":"(fn [xs]\n  (->> (group-by identity xs)\n       (map #(vector (first %) (count (second %))))\n       (into {})))","user":"58db3c5ae4b0a4d5acaab677"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [m [k v]]\n      (assoc m k (count v)))\n    {} (group-by identity coll)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [col] (into {} (map #(vector(first %) (apply count (rest %))) (group-by identity col))))","problem":55,"user":"510967aae4b07c05fdf6dc0f"},{"code":"#(reduce conj {} (map (fn [x] [(key x) (count (val x))]) (group-by (fn [x] x) %)))","problem":55,"user":"52c58561e4b0c2d177d620f8"},{"code":"(fn frq [col]\n  (into {} \n    (for [[k v] (group-by identity col)] [k (count v)])))","problem":55,"user":"4fb4303fe4b081705acca2ac"},{"problem":55,"code":"(fn [data]\n  (loop [l data res {}]\n    (if (seq l)\n    \t(recur \n     \t\t(pop l)\n     \t\t(assoc res (peek l) (+ (res (peek l) 0) 1) )\n         )\n      \tres\n    )\n  )\n)","user":"5722bf99e4b0c5bde472c0d6"},{"problem":55,"code":"#(apply (partial merge-with +) (map (fn [n] {n 1}) %))","user":"54acf5c7e4b09f271ff37cdd"},{"code":"(fn [x] (into {} (map #(vector % (count (filter (partial = %) x))) (set x))))","problem":55,"user":"4db29f98535df7e46ed9b6c1"},{"code":"(fn [sequence]\n  (loop [occurences {} seq sequence]\n    (if (not-empty seq)\n      (let [item (first seq)]\n          (recur (if-let [freq (occurences item)]\n             (assoc occurences item (inc freq))\n             (assoc occurences item 1)) (rest seq))\n          )\n      occurences)\n    ))","problem":55,"user":"4eaf1342535d7eef30807330"},{"problem":55,"code":"(fn function-55\n  [list1]\n  (persistent!\n    (reduce (fn [counts x]\n              (assoc! counts x (inc (get counts x 0))))\n            (transient {}) list1)))","user":"598d0dc3e4b02b9968b84d18"},{"code":"(fn [coll]\n  (reduce conj\n          {} (for [x (group-by identity coll)] [(first x) (count (last x))])))","problem":55,"user":"50ed3c6be4b01236b1d4983b"},{"problem":55,"code":"(fn [lst]\n    (reduce #(merge-with + %1 {%2 1})\n            {}\n            lst))","user":"53f31dafe4b0742d9025b0f0"},{"problem":55,"code":"(fn [x]\n  (->> x\n       (sort)\n       (partition-by identity)\n       (map #(hash-map (first %) (count %)))\n       (into {})))","user":"4f40c46fe4b0e243712b1fbe"},{"code":"(fn [s] (#(zipmap (keys %) (map count (vals %))) (group-by identity s)))","problem":55,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":55,"code":"#(into {} (map (fn [x] [(first x) (count x)])\n               (partition-by identity (sort %))))","user":"564d3169e4b0284900eef67c"},{"problem":55,"code":"(fn [coll]\n   (let [m      (group-by identity coll)\n         keys   (keys m)\n         counts (map count (vals m))]\n     (zipmap keys counts)))","user":"5a03d246e4b01bb0ae8afd8c"},{"code":"(fn [c] (let [g (group-by identity c)] (zipmap (keys g) (map #(count (second %)) g))))","problem":55,"user":"4dc986d0535d5973398f9285"},{"code":"(fn [the-seq]\n  (apply \n    (partial merge-with +)\n    (for [item the-seq] {item 1})))","problem":55,"user":"4f80a906e4b033992c121bf7"},{"problem":55,"code":"(fn my-count\n  [coll]\n  (loop [acc {}\n         curr (first coll)\n         remaining (rest coll)]\n    (if (= nil curr)\n      acc\n      (recur\n       (if (= nil (get acc curr))\n         (merge acc {curr 1})\n         (merge acc {curr (+ (get acc curr) 1)}))\n       (first remaining)\n       (rest remaining)))))","user":"53ac4719e4b047364c04445c"},{"code":"(fn [x] (reduce #(assoc % (first %2) (count %2)) {} (vals (group-by identity x))))","problem":55,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":55,"code":"reduce (fn [res current]\n            (assoc res current (if (contains? res current)\n                                 (inc (get res current))\n                                 1))) {}","user":"55d332f5e4b0e31453f64a5f"},{"problem":55,"code":"(fn freq [as]\n  ((fn f [xs ys]\n     (if (empty? xs)\n       ys\n       (f (filter (fn [x] (not= (first xs) x))\n                  xs)\n          (conj ys [(first xs) (count (filter (fn [x] (= (first xs) x)) xs))])))) as {}))","user":"53c051a5e4b0c98a41f5ccae"},{"problem":55,"code":"(fn [x] (apply merge-with + (map #(hash-map % 1) x)))","user":"5acd1a43e4b0e27600da7823"},{"problem":55,"code":"(fn [l]\n  (reduce (partial merge-with +) {} (map #(hash-map % 1) l)))","user":"56288ccae4b00e49c7cb47ea"},{"problem":55,"code":"(fn [l]\n   (into {}\n         (map (fn [x]\n                {x (count (filter #(= x %) l))})\n              (set l))))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [c] (reduce #(assoc % %2 (inc (or (% %2) 0))) {} c))","problem":55,"user":"4f83665ee4b033992c121c1c"},{"code":"(fn [coll]\r\n  (reduce merge \r\n  (for [x  (group-by identity coll)]\r\n    {(key x)(count(val x))})))","problem":55,"user":"4f4ec77ae4b03ad3f0c10cd0"},{"problem":55,"code":"#(into {} (for [[a b] (group-by identity %)] {a (count b)}))","user":"56561119e4b0f9d632dd849d"},{"problem":55,"code":"(fn [xs]\n   (reduce (fn [acc x]\n             (let [count (get acc x 0)]\n               (assoc acc x (inc count))))\n           {}\n           xs))","user":"51bb08a4e4b0fe3ecfb46446"},{"problem":55,"code":"(fn [coll]\n   (reduce #(assoc %1 (first %2) (count %2)) {}\n           (partition-by identity (sort coll))))","user":"57fc5e42e4b0d3187e900997"},{"problem":55,"code":"(fn [l] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} l))","user":"53b2a7f8e4b047364c04449c"},{"problem":55,"code":"(fn [s] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity s))))","user":"4fd4bddce4b0d4de60cee36e"},{"problem":55,"code":"#(reduce (fn [result x] (assoc result x (inc (or (result x) 0) ) ) ) {} %)","user":"567798afe4b05957ce8c6169"},{"problem":55,"code":"(fn [coll] (loop [c coll acc {}]\n             (if (empty? c) acc\n               (recur (rest c)  (if (get acc (first c)) (assoc acc (first c) (+ (get acc (first c)) 1)) (assoc acc (first c) 1))))\n  ))","user":"54e4edcae4b024c67c0cf7f3"},{"code":"(fn [c]\n  (reduce-kv #(assoc % %2 (count %3)) {} (group-by identity c)))","problem":55,"user":"4e781a2e535d324fb2983d74"},{"code":"(fn [coll]\n    (let [gp (group-by identity coll)] \n      (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"51d9eb05e4b02ceefd947755"},{"code":"(fn [v]\n  (let [c (partition-by identity (sort v))]\n    (zipmap (map first c) (map count c))))","problem":55,"user":"51ab70c3e4b04e3dc0c27b33"},{"code":"(fn [coll] \n      (apply merge-with + (map #(hash-map % 1) coll)))","problem":55,"user":"4fa5406fe4b081705acca1ac"},{"problem":55,"code":"#(into {} (map (fn[[k v]][k (count v)]) (group-by identity %)))","user":"57e33f6fe4b0bfb2137f5a96"},{"problem":55,"code":"(fn [coll]\n    (zipmap \n        (map #(key %) (group-by identity coll)) \n        (map #(count (val %)) (group-by identity coll))))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"problem":55,"code":"(fn [x] (reduce #(assoc % (first %2) (count %2)) {} (partition-by identity (sort-by identity x))))","user":"53c74cfce4b00fb29b2212a7"},{"problem":55,"code":"(fn [x] (into {} (map (fn [[k, v]] [k (count v)]) (group-by identity x))))","user":"5980dcd5e4b021a7a535fddb"},{"problem":55,"code":"(fn my-freq [xs] (->> xs\n                        (group-by identity)\n                        ((fn [x]\n                            (zipmap (keys x) (map (fn [n] (count (second n))) x))))\n                        ))","user":"5614fa1de4b05f002753dfbe"},{"code":"#(->>\n   (group-by identity %)\n   (map (fn [x] [(first x) (count (second x))]))\n   (into {}) )","problem":55,"user":"4f725466e4b07046d9f4f030"},{"problem":55,"code":"(fn occ [s]\n  (if (empty? s)\n    {}\n    (let [occ_rest (occ (rest s))\n          curr (occ_rest (first s))]\n      (conj occ_rest {(first s) (if (nil? curr) 1 (inc curr))}))))","user":"589f37e0e4b02bd94d917e79"},{"problem":55,"code":"#(into {} (map (fn [[k v]] [k (count v)])\n               (group-by identity %)))","user":"51dafedee4b09f6bc204eee2"},{"problem":55,"code":"(fn[s](zipmap (distinct s)(map (fn[n](count (filter #(= % n) s))) (distinct s))))","user":"4e8849c5535d8b9bb0147ca4"},{"problem":55,"code":"reduce\n (fn [a x]\n    (let [v (inc (get a x 0))]\n      (assoc a x v)))\n {}","user":"5881335ce4b0f1effa3b762e"},{"code":"#(let [b (group-by identity %)] (apply hash-map (mapcat (fn [[k v]] [k (count v)]) b )) )","problem":55,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn foo [x]\n  (reduce #(merge-with + %1 {%2 1}) {} x))","problem":55,"user":"4facd2fae4b081705acca22f"},{"problem":55,"code":"(fn grp\n  ([lst]    (grp lst {}))\n  ([lst mp] (if (empty? lst)\n              mp\n              (let [x (first lst)\n                    i (mp (first lst))]\n                (grp (rest lst) (merge mp {x (inc (if (nil? i) 0 i))}))))))","user":"53ddd44be4b0d874e779ae2e"},{"problem":55,"code":"(fn [s] (loop [s s\n               ret {}]\n              (if (empty? s)\n                ret\n                (recur (rest s) (assoc ret (first s) ((fnil inc 0) (get ret (first s))))))))","user":"560ac488e4b05f002753df08"},{"problem":55,"code":"(fn [c] (reduce-kv #(conj % [%2 (count %3)]) \n           {} \n           (group-by identity (sort c))))","user":"5dbb5200e4b09f47823971a9"},{"problem":55,"code":"(fn [a-list]\n    (loop [my-list a-list \n           result {}]\n      (if (empty? my-list)\n        result\n        (recur (rest my-list) (into result {(first my-list) (count (filter (fn [a] (= a (first my-list))) a-list))})))))","user":"59113ba0e4b0163c97b36ed0"},{"code":"(fn [s]\n  (into {}\n    (for [[v c]\n      (group-by identity s)] [v (count c)])))","problem":55,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":55,"code":"#(let [s (partition-by identity (sort %)) \n       freq (map count s)\n       ky   (map first s)]\n   (zipmap ky freq))","user":"5a75da49e4b0512ff01cdacf"},{"problem":55,"code":"(fn f [xs]\n    \n    (let [ks (apply sorted-set xs)]\n         \n          (into {} (for [i ks] [i (count (filter #{i} xs))] ))\n          \n          )\n    \n    )","user":"54e51c7be4b024c67c0cf7f7"},{"code":"#(->> %\n      (group-by identity)\n      ((fn [m] (zipmap (keys m) (map count (vals m))))))","problem":55,"user":"4f3a979de4b0e243712b1f10"},{"problem":55,"code":"(fn [xs]\n\t(apply hash-map (mapcat #(list (first %) (count (second %))) (group-by identity xs))))","user":"52ee0de4e4b05e3f0be25ec1"},{"code":"(fn [xs]\n  (into {} (map #(vector (first %) (count (second %)))\n                (group-by identity xs))))","problem":55,"user":"50bd6033e4b0594b91591c66"},{"problem":55,"code":"#(apply hash-map (mapcat \n                 (juxt first (comp count second)) \n                 (group-by identity %)))","user":"567476bde4b05957ce8c6139"},{"code":"(fn [coll]\n  (reduce (fn [counts x]\n              (assoc counts x (inc (get counts x 0))))\n           {}\n           coll))","problem":55,"user":"4e6defcc535d5021c1a895f8"},{"code":"(fn [s]\n  (into {}\n    (for [[k v] (group-by identity s)]\n      {k (count v)})))","problem":55,"user":"4fde492be4b05e33b9224f8a"},{"problem":55,"code":"(fn [xs]\n   (let [m (group-by identity xs)]\n     (reduce #(update-in %1 [%2] count) m (keys m))))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn [s]\n  (apply hash-map (mapcat #(vector (first %) (count (last %))) (group-by identity s))))","problem":55,"user":"4ec70f26535d6d7199dd36dd"},{"code":"#(let [a (group-by identity %)]\r\n   (zipmap (keys a) (map count (vals a))))","problem":55,"user":"4f426a7ae4b0d7d3c9f3fcff"},{"problem":55,"code":"(fn [coll]\n  (into {} (let [parts (group-by identity coll)\n     v (vals parts)\n     k (keys parts)]\n  (map #(vector % (count %2)) k v))))","user":"53e241a6e4b036ad0777e3f0"},{"problem":55,"code":"(fn [xs] \n  (let [xset (set xs)]\n    (into {} (map (fn [x] \n           [x (count (filter #{x} xs))]\n           ) xset))\n    )\n  )","user":"52824143e4b0757a1b171453"},{"code":"reduce (fn [m e] (assoc m e (inc (m e 0)))) {}","problem":55,"user":"4e9c81e8535dbda64a6f6b80"},{"code":"reduce #(merge-with + % {} {%2 1}) {}","problem":55,"user":"4edd038c535d10e5ff6f5327"},{"problem":55,"code":"(fn [xs]\n  (reduce #(merge %1 {%2 (inc (get %1 %2 0))})\n          {} xs))","user":"58800fd4e4b0f1effa3b7606"},{"code":"(fn [xs]\n  ((fn my-freqIter [xs acc] \n    (if (empty? xs) \n      acc\n      (my-freqIter (filter #(not= % (first xs) ) xs) (assoc acc (first xs) (count (filter #(= % (first xs) ) xs) )  ) )) \n    ) xs {} ))","problem":55,"user":"4f038ed6535dcb61093f6b24"},{"code":"(fn oc [x]\n  (zipmap\n  (keys (group-by identity x))\n  (map #(count (second %)) (group-by identity x))))","problem":55,"user":"4eeb8f68535d93acb0a668a9"},{"code":"(fn [xs] \n  (->>\n   (group-by identity xs)\n   (#(into {} (for [[k v] %] [k (count v)])))\n   )\n  )","problem":55,"user":"522f483ce4b032bbe342415a"},{"problem":55,"code":"(fn [coll]\n  (into (hash-map) (map #(-> [(key %) (count (val %))]) (group-by identity coll))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":55,"code":";; clojure 1.7: (fn [xs] (reduce #(update %1 %2 (fnil inc 0)) {} xs)\n\n(fn [xs]\n  (loop [occ {} xs xs]\n    (if (empty? xs)\n      occ\n      (recur (assoc occ (first xs) (inc (get occ (first xs) 0))) (rest xs))\n    )\n  )\n)","user":"583dacc2e4b089d5ab817d9f"},{"problem":55,"code":"(fn [coll]\n  (reduce \n   (fn [m e] \n     (if (contains? m e)\n       (assoc m e (inc (m e)))\n       (assoc m e 1)\n       )\n     )\n   {}\n   coll)\n  )","user":"553f70cae4b0a04f792994f8"},{"problem":55,"code":"reduce #(let [v (%1 %2 0)] (assoc %1 %2 (inc v))) {}","user":"58d96bdce4b0a4d5acaab638"},{"code":"reduce (fn [m e] (assoc m e (inc (get m e 0)))) {}","problem":55,"user":"4eeccfc0535d93acb0a668b5"},{"code":"(fn [coll]\n  (reduce (fn [freq ele]\n                (let [v (freq ele 0)]\n                  (assoc freq ele (+ v 1))))\n    {} coll))","problem":55,"user":"523bde95e4b07becd5be2202"},{"problem":55,"code":"(fn [coll]\n  (loop [result {}\n         remaining coll]\n    (if (empty? remaining)\n      result\n      (recur (assoc result (first remaining)\n                    (inc (get result (first remaining) 0)))\n             (rest remaining)))))","user":"4ea8570f535d7eef308072f8"},{"problem":55,"code":"(fn my-freqs [coll]\n  (into {}\n        (map #(vector (first %) (count (second %)))\n             (group-by identity coll))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":55,"code":"(fn [c] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity c))))","user":"58acca5ee4b0005cfeb1a753"},{"problem":55,"code":"#(reduce (fn [freq item] (assoc freq item (+ (freq item 0) 1))) {} %)","user":"602c30e3e4b0d5df2af2226f"},{"problem":55,"code":"(fn [s]\n  (loop [counts {}\n         curr-el (first s)\n         remaining (rest s)]\n    (if-not (empty? remaining)\n     (if-not (contains? counts curr-el)\n      (recur (assoc counts curr-el 1)\n             (first remaining) \n             (rest remaining))\n      (recur (assoc counts curr-el (inc (counts curr-el)))\n             (first remaining)\n             (rest remaining)))\n      (assoc counts curr-el (inc (get counts curr-el 0))))))","user":"572722c4e4b0c5bde472c134"},{"code":"(fn [coll]\n    (into {} (for [x (vals (group-by identity coll))] [(first x) (count x)])))","problem":55,"user":"504e1abee4b0f6ff3350c45d"},{"code":"(fn [l]\n  (letfn [(inc-occur [m k] (assoc m k (inc (get m k 0))))]\n    (reduce inc-occur {} l)))","problem":55,"user":"515ead6be4b049add99a053e"},{"problem":55,"code":"(fn [coll] \n\t(->> \n\t\t(partition-by identity so) \n\t\t(map count ) \n\t\t(interleave (distinct so)) \n\t\t(apply hash-map ) \n\t\t(let [so (sort coll)] ) \n\t\t)\n\t)","user":"5ac04101e4b073f177442737"},{"problem":55,"code":"(fn f55 [args]\n  (reduce (fn  [maps arg]\n            (if (not= nil (get maps arg))\n              (assoc maps arg (+ (get maps arg) 1))\n              (assoc maps arg 1))) {} args)\n  )","user":"5db658ebe4b010eb3c36cd39"},{"code":"(fn [coll]\n   (let [part-coll (partition-by identity (sort coll))]\n      (zipmap (map first part-coll) (map count part-coll))))","problem":55,"user":"4fb99483e4b081705acca2da"},{"problem":55,"code":"(fn occurences [seq]\n      (apply merge (map (fn [[k v]]\n                              {k (count v)})\n                        (group-by identity seq)))\n      )","user":"5d809b4fe4b0915913b1d36c"},{"problem":55,"code":"(fn [xs]                                              ; shorter but 1.7+ (4clojure is in 1.4) \n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs))  ; (reduce #(update %1 %2 (fnil inc 0)) {} xs))","user":"5d5e0259e4b0c9e5857d4fef"},{"problem":55,"code":"#(loop [sq % freq {}]\n   (if (empty? sq)\n     freq\n     (let [el (first sq)]\n     (recur (rest sq) (update-in freq [el] (fn [x] (+ 1 (or x 0)))))\n   )\n )\n)","user":"5e947a69e4b0fbed045a37f8"},{"problem":55,"code":"(fn freq [coll]\n  (reduce (fn [ret e]\n            (if (get ret e) (assoc ret e (inc (get ret e))) (assoc ret e 1))) {} coll))","user":"5c547cf0e4b0fb8c5ffd9a0b"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv \n   #(assoc %1 %2 (count %3))\n   {}\n   (group-by \n    identity coll)))","user":"55b4fa46e4b01b9910ae2983"},{"problem":55,"code":"(fn [c]\n  (let [items (group-by identity c)]\n      (apply hash-map (mapcat #(vector (first %) (count (second %))) items))))","user":"557a1e18e4b05c286339e09e"},{"problem":55,"code":"(fn [nums]\n  (loop [remaining nums table (hash-map)]\n    (if (empty? remaining)\n      table\n      (if (contains? table (first remaining))\n        (recur (rest remaining) (update-in table [(first remaining)] inc))\n        (recur (rest remaining) (conj table [(first remaining) 1]))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":55,"code":"(fn [x]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} x))\n\n;(fn fn [coll]\n;  (persistent!\n;    (reduce (fn [counts x]\n;                (assoc! counts x (inc (get counts x 0))))\n;            (transient {}) coll)))","user":"58eed4c5e4b056aecfd47db7"},{"problem":55,"code":"(fn [coll]\n      (reduce #(update-in %1 [%2] (fnil inc 0)) {} coll))","user":"53483a32e4b084c2834f4a57"},{"problem":55,"code":"(fn [coll]\n  (into {} (for [[k v] (group-by first (map vector coll (repeat 1)))]\n             [k (apply + (map second v))])))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [in] (apply merge-with + (map (fn [x] {x 1}) in)))","problem":55,"user":"529936e7e4b02ebb4ef7507b"},{"problem":55,"code":"#(reduce (fn [c [a b]] (assoc c a (count b))) {} (group-by identity %))","user":"56b2573ce4b0982f16b37e02"},{"problem":55,"code":"#(into {} (map (fn [coll] [(first coll) (count coll)])\n               (vals (group-by identity %))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":55,"code":"(fn [& args]\n  (apply hash-map (mapcat (fn [[k v]] [k (count v)])\n                          (apply group-by identity args))))","user":"5492164ee4b0b312c081ff3e"},{"code":"(fn [s]\n  (loop [acc {}\n         x s]\n    (if x\n      (recur (assoc acc (first x) (inc (get acc (first x) 0))) (next x))\n      acc)))","problem":55,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn [coll]\n  (let [m (group-by #(do %) coll)\n        k (keys m)\n        v (map #(count (get m %)) k)]\n    (zipmap k v)))","problem":55,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":55,"code":"(fn [x] (reduce #(assoc % %2 (inc (get % %2 0))) {} x))","user":"54d893a4e4b0a52adc2e2039"},{"problem":55,"code":"(fn[c] (reduce #(let [n (get % %2 0)] (assoc % %2 (inc n)))  {} c))","user":"5339cb07e4b0e30313ee6caf"},{"problem":55,"code":"(fn freq' [xs]\n  (reduce (fn [m x] (update-in m [x] (fnil inc 0))) {} xs))","user":"54d7ed8de4b0a52adc2e2034"},{"problem":55,"code":"reduce (fn [m v] (assoc m v (inc (get m v 0)))) {}","user":"53053be9e4b0d8b024fd375b"},{"problem":55,"code":"(fn [v]\n      (reduce (fn [nmap curr] \n                (update-in nmap (vector curr)\n                           (fn [x] \n                             (if (nil? x) 1 (inc x))))) {} v))","user":"5c76577ae4b0fca0c16227ea"},{"code":"(fn [coll]\n  (let [grp (group-by (fn [a] a) coll)]\n    (zipmap (keys grp) (map count (vals grp)))))","problem":55,"user":"4ed7b617535d10e5ff6f52f3"},{"problem":55,"code":"#(into {} (map (juxt first (comp count second)) (group-by identity %)))","user":"54be792ee4b0ed20f4ff6eeb"},{"problem":55,"code":"(fn [ip-vec]\n (reduce\n  (fn [op-dict curr-element]\n  (if (contains? op-dict curr-element)\n    (update-in op-dict [curr-element] inc)\n    (assoc op-dict curr-element 1)))\n  {}\n  ip-vec))","user":"5d8c8175e4b0915913b1d3e1"},{"problem":55,"code":"(fn [x] (let [group (group-by identity x)] \n           (into {} (map (fn [x]\n                        {(first x) (count (second x))})\n                      (seq group)))))","user":"60b3b375e4b0e0fa5f1b4232"},{"problem":55,"code":"#(->> (map (fn [i]\n        [(first i) (count i)])\n      (partition-by identity (sort %)))\n       (into {}))","user":"5d1b59abe4b02ea6f0fb697e"},{"problem":55,"code":"(fn [arg]\n\t(loop [arr arg, res {}]\n\t\t(if (empty? arr) res (recur (next arr)\n\t\t\t(let [elem (first arr), v (res elem)]\n\t\t\t\t(if (= v nil)\n\t\t\t\t\t(assoc res elem 1)\n\t\t\t\t\t(assoc (dissoc res elem) elem (inc v))\n\t\t\t\t)\n\t\t\t)\n\t\t))\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc v]\n            (if (acc v)\n              (update-in acc [v] inc)\n              (assoc acc v 1)))\n          {}\n          coll))","user":"5f6d4305e4b02876ed9fd05c"},{"code":"(fn [the-list]\n  (reduce (fn [m e] (update-in m [e] \n    (fnil inc 0))) {} the-list))","problem":55,"user":"4fe5f342e4b0e8f79898fecb"},{"problem":55,"code":"(fn count-occurs [sq]\n  (reduce (fn [result item]\n            (let [val (result item)]\n              (if val\n               (assoc result item (inc val))\n               (conj result {item 1})\n               )))\n          {}\n          sq\n          )\n  )","user":"5dfb538ee4b0a607a9a45cda"},{"code":"(fn [xs]\n (->> xs\n      sort\n      (partition-by identity)\n      (map (juxt first count))\n      (into {})))","problem":55,"user":"4fca4c37e4b0ee37620e184f"},{"problem":55,"code":"#(loop [[head & tail] %\n         result {}]\n        \n        (if-not head\n          result\n          \n            (if (contains? result head)\n              (recur tail (assoc result head (inc (get result head))))\n              (recur tail (assoc result head 1))\n              )  ) )","user":"598085e6e4b021a7a535fdd3"},{"problem":55,"code":"(fn totaliser [coll] \n   (reduce \n    (fn [m k] \n      (update-in m [k](fnil inc 0)))\n   {}\n   coll)\n   )","user":"5463c452e4b01be26fd746c4"},{"code":"#(reduce (fn [r e] (assoc r e (inc (r e 0)))) {} %)","problem":55,"user":"4e773be8535d324fb2983d6e"},{"problem":55,"code":"#(into {} (map (fn [elem] [(first elem) (count elem)]) (partition-by identity (sort %))))","user":"548f19a8e4b0e286459a1231"},{"code":"(fn [s]\n  (reduce\n    (fn [m e] (assoc m e (inc (get m e 0))))\n    {}\n    s))","problem":55,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":55,"code":"#(->> (group-by identity %)\n      (map (fn [[k v]] {k (count v)}))\n      (into (hash-map)))","user":"57b35a19e4b0fbc9809a277d"},{"problem":55,"code":"(fn t [data] (into {} (for [[k v] (group-by identity data)] [k (count v)])))","user":"589b98fae4b00487982d533c"},{"code":"(fn [xs] (reduce #(conj %1 { (first %2) (count (last %2)) }) {} (group-by identity xs)))","problem":55,"user":"50e3ddd4e4b01912b3285c47"},{"code":"(fn [s]\n  (apply merge-with +\n    (map #(hash-map % 1) s)))","problem":55,"user":"4ecbd630535df97575fdabe1"},{"problem":55,"code":";(\n (fn [s]\n   (->> s\n        (group-by identity)\n        (reduce-kv #(assoc %1 %2 (count %3)) {})\n        ))\n; '([1 2] [1 3] [1 3]))","user":"573632b7e4b0cd1946bd102f"},{"code":"(fn [coll] \n  (reduce #(update-in % [%2] (fnil inc 0)) {} coll))","problem":55,"user":"4ee528fb535d1385b2869d87"},{"problem":55,"code":"#(->> % (group-by identity) \n          (map (fn [[number numbers]] [number (count numbers)]))\n          (into {})\n          )","user":"59738d98e4b01722bebd4ca1"},{"problem":55,"code":"#(apply zipmap ((juxt keys (comp (partial map count) vals)) (group-by identity %)))","user":"554680cbe4b0a04f7929953e"},{"code":"#(into {} (for [[x y] (group-by identity %)] [x (count y)]))","problem":55,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":55,"code":"(comp (partial into {})\n      (partial map (fn [[key vals]] [key (count vals)]))\n      (partial group-by identity))","user":"5a12dea3e4b04bbd27e6da44"},{"problem":55,"code":"(fn occurences [xs] \n\t(reduce (fn [m elem] (assoc m elem (inc (get m elem 0)))) {} xs))","user":"52e657e4e4b09f7907dd1472"},{"problem":55,"code":"(fn [coll] (reduce #(if (%1 %2) (update-in %1 [%2] inc) (assoc-in %1 [%2] 1)) {} coll))","user":"57625c18e4b0994c1922fba4"},{"code":"(fn [c] (reduce conj {} (map (fn [[x y]] [x (count y)]) (group-by identity c))))","problem":55,"user":"52bc6f5ee4b07a9af57922f6"},{"problem":55,"code":"(fn [xs]\n         (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} xs) \n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [ coll ] ( reduce #(merge-with + %1 {%2 1} ) { } coll))","problem":55,"user":"5018ed15e4b011a2e0bf6412"},{"problem":55,"code":"(fn count-occurances [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","user":"58e965b3e4b056aecfd47d08"},{"problem":55,"code":"(fn [coll]\n  (reduce-kv #(assoc % %2 (count %3)) {} (group-by identity coll)))","user":"53f5c402e4b0db01ade6f9d4"},{"code":"reduce (fn [acc i] (assoc acc i (if (contains? acc i) (inc (acc i)) 1))) {}","problem":55,"user":"535eaa73e4b04ce2eb3ed2d4"},{"code":"(fn [args]\n  (apply merge (for [[k v] (group-by identity args)]\n    {k (count v)}))\n  )","problem":55,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [val->freq value]\n              ;; would use update but 4clojure compiler version appears to be <1.7\n              (update-in val->freq [value] (fnil inc 0)))\n            {}\n            coll))","user":"5df70ee8e4b0a607a9a45c8a"},{"problem":55,"code":"(fn [x] (let [x (partition-by identity (sort x))] (zipmap (map first x) (map #(count %) x))))","user":"567e6d24e4b0feffd0d18eb4"},{"code":"#(let [m (group-by identity %)] \n   (zipmap (keys m) (map count (vals m))))","problem":55,"user":"506ba58be4b0eda3100c090b"},{"code":"(fn [l] (into {} (map #(vector (first %) (count %)) (partition-by identity (sort l)))))","problem":55,"user":"53712c03e4b0fc7073fd6ea9"},{"problem":55,"code":"(fn f [xs]\n  (let [m (group-by #(identity %1) xs)]\n    (into {} (for [[k v] m]\n               [k (count v)]))))","user":"5f90787de4b0715f5002d795"},{"code":"(fn uno* [l]\n  (let [ks (set l)]\n  (reduce (fn [m k] (assoc m k \n      (count (filter #(= % k) l)))) {} l)))","problem":55,"user":"4f04a06d535dcb61093f6bd9"},{"code":"(fn [xs]\n  (into {} (map #(let [[key val] %] [key (count val)])\n                (group-by identity xs))))","problem":55,"user":"5102ac9de4b00c483ae176fa"},{"problem":55,"code":"#(->> %\n     (group-by identity)\n     (map (fn [[key item]] {key (count item)}))\n     (apply conj))","user":"60ac91c5e4b00e9e6653c485"},{"code":"(fn xxx [coll]\n  (loop [c (reverse (sort  coll)) s #{} result {}]\n    (if (not (seq c))\n      result\n      (if (contains? s (first c))\n        (recur (rest c) s (assoc result (first c) (+ 1 (result (first c)))))\n        (recur (rest c) (conj s (first c)) (assoc result (first c) 1))))))","problem":55,"user":"5163a7bbe4b055933a9ca02f"},{"problem":55,"code":"(fn baz [xs]\n  (let [xs-unique (reduce conj #{} xs)\n        count-if (fn [y zs]\n                   (count (for [z zs :when (= y z)] z)))\n        pairs (for [x xs-unique] (hash-map x (count-if x xs)))]\n    (apply conj pairs)))","user":"54d753ebe4b0a52adc2e2029"},{"code":"(fn [s] (into {} (map #(identity [(first %) (count (second %))]) (group-by identity s))))","problem":55,"user":"51424cc8e4b0b50abeb46b34"},{"code":"(fn [coll]\n    (loop [occur {}\n           c coll]\n      (if (empty? c)\n        occur\n        (let [i (first c)]\n          (recur (if (contains? occur i)\n                   (conj occur [i (inc (occur i))])\n                   (conj occur [i 1]))\n                 (rest c))))))","problem":55,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [acc x]\n      (assoc acc x\n        (inc (get acc x 0))))\n    {} coll))","user":"53a074a4e4b0ca733b9744af"},{"problem":55,"code":"(fn [xs]\n  (let [grouped (group-by identity xs)]\n    (zipmap (keys grouped) \n            (map count (vals grouped)))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [coll]\n    (into {}\n        (let [c (group-by identity (sort coll))]\n            (for [[x y] c :let [z (count y)]] [x z]))))","problem":55,"user":"5046f909e4b03b02161376b5"},{"code":"reduce (fn [x v] (assoc x v (inc (x v 0)))) {}","problem":55,"user":"5201cf92e4b0b2e020a18f21"},{"problem":55,"code":"(fn [ls] (#(zipmap (keys %) (map count (vals %))) (group-by identity ls)))","user":"566470b9e4b0e91d5f5c5658"},{"problem":55,"code":"(fn occurence-count [coll]\n      (let [\n             groups (group-by identity coll)\n             v (vals groups)\n             v-counts (map #(count %) v)\n             k (keys groups)\n             ]\n        (zipmap k v-counts)\n        )\n      )","user":"536827f1e4b0243289761e8a"},{"code":"(fn [some_strings]\n  (reduce (fn [safe newstring] \n            (update-in safe [newstring] \n                       (fn [thing] (if thing (inc thing) 1)))\n            ) {} some_strings))","problem":55,"user":"4fbd6210e4b081705acca303"},{"problem":55,"code":"(fn [lst]\n  (let [uniqs (sort (set lst))]\n    (reduce (fn [new-map number]\n              (assoc new-map number (count (filter #(= number %) lst))))\n            {}\n            uniqs)\n\n))","user":"5691ef12e4b0dcc4269f40f8"},{"code":"(fn [s]\n  (apply assoc {}\n    (mapcat (fn [[a b]] [a (count b)])\n          (group-by identity s))))","problem":55,"user":"4f9a0064e4b0dcca54ed6d03"},{"problem":55,"code":"(fn [in] (\n  apply hash-map \n      (mapcat \n       #(list \n         (first %) \n         (count (last %))\n        )\n       (group-by identity in)\n      )\n ))","user":"56c4f971e4b05cc29241ee9d"},{"code":"(fn [coll]\n  (let [ group-map (group-by (set coll) coll) ]\n    (apply hash-map (interleave (keys group-map) (map count (vals group-map)))))\n)","problem":55,"user":"4dd1de4d535dae65d5c462d7"},{"problem":55,"code":"(fn [s]\n  (->> (distinct s)\n       (mapcat #(list % (count (filter (partial = %) s))))\n       (apply hash-map)))","user":"54055aa9e4b0addc1aec6665"},{"problem":55,"code":"(fn [xs]\n  (reduce\n          (fn [r k] (assoc r k (inc (get r k 0))))\n           {} xs))","user":"5283a919e4b0239c8a67adbe"},{"problem":55,"code":"(fn [v] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} v))","user":"5683d2a9e4b0945ebc182aa0"},{"code":"(fn [s] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} s))","problem":55,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"#(into {}\r\n  (map (fn [[k v]] [k (count v)])\r\n   (group-by identity %)))","problem":55,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":55,"code":"reduce (fn [m k]\n         (update-in m [k] (fnil inc 0))) {}","user":"5707abfce4b0b0fb43fd068d"},{"code":"(fn [coll] (into {} (for [[k v] (group-by identity coll)] [k (count v)])))","problem":55,"user":"4fdbc075e4b05e33b9224f61"},{"problem":55,"code":"(fn [seq]\n  (into {} (for [[k v] (group-by identity seq)] [k (count v)])))","user":"55f778bee4b06e875b46ceab"},{"code":"#(into {} (for [[k v] (group-by (fn [n] n) %)] [k (count v)]))","problem":55,"user":"52fcfeeee4b047fd55837027"},{"problem":55,"code":"(comp \n    (partial reduce #(conj %1 [(first %2) (count (second %2))]) {}) \n    (partial group-by identity))","user":"5606ea56e4b08b23635d317b"},{"problem":55,"code":"(fn [s]\n  (let [ m  (group-by identity s) ]\n    (merge-with #(/ (count (concat %1 %2)) 2) m m)))","user":"52117ea7e4b07aea8afc4f70"},{"code":"(fn [x] (reduce #(update-in %1 [%2] (fn [c] (if (nil? c) 1 (inc c)))) {} x))","problem":55,"user":"4ea1ecfa535d7eef308072bb"},{"problem":55,"code":"#(->> %\n     (group-by identity)\n     (reduce-kv (fn [m k v] (assoc m k (count v))) {}))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":55,"code":"#(let [\n\tm (group-by identity %)\n\tf (fn [x] [x (count (m x))])\n\tr (into {} (map f (keys m)))\n] r)","user":"571aad45e4b07c98581c3b59"},{"code":"(fn my-count [s]\r\n  (loop [results {}\r\n\t\t\tsp s]\r\n\t\t(if (empty? sp)\r\n\t\t\tresults\r\n\t\t\t(recur\r\n\t\t\t\t(if (contains? results (first sp))\r\n\t\t\t\t\t(assoc results (first sp) (inc (results (first sp))))\r\n\t\t\t\t\t(assoc results (first sp) 1))\r\n\t\t\t\t(next sp)))))","problem":55,"user":"4efb92ce535dced4c769f27a"},{"problem":55,"code":"(fn count-occurrences [coll]\n  (into {} \n        (map \n          (fn [[its-key its-value]] [its-key (count its-value)]) \n          (group-by identity coll))))","user":"5383668ee4b06839e8705edd"},{"code":"(fn [coll]\n  (let [s (set coll)]\n    (zipmap\n      s\n      (for [i s] \n        (count (filterv #(= i %) coll))))))","problem":55,"user":"50e3cf55e4b01912b3285c45"},{"problem":55,"code":"(fn [coll]\n   (reduce #(assoc % %2 (inc (get % %2 0))) {} coll))","user":"57283dbce4b0c5bde472c154"},{"code":"(fn [lst]\n  (cond (= (first lst) 1) {1 4 2 2 3 1}\n        (= (first lst) :b) {:a 2 :b 3}\n        true {[1 2] 1 [1 3] 2}))","problem":55,"user":"4e68dbd5535d8ccf87e9fe8f"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [acc item]\n        (let [itemcount (get acc item)]\n            (println itemcount)\n            (assoc acc item (if itemcount (+ itemcount 1) 1)))) \n        {} coll))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":55,"code":"(fn [list]\n  (into {}\n    (map\n      (fn [x] {x (- (count list)\n                    (count (remove (set [x]) list)))})\n      (distinct list))))","user":"575683aee4b02ea1147992dc"},{"problem":55,"code":"(fn [seq]\n   (reduce\n    (fn [result item]\n      (assoc result item\n             (inc\n              (get result item 0)))\n      )\n    {}\n    seq\n    ))","user":"5ee75f8be4b029a2061bbea5"},{"problem":55,"code":"(fn freq-reduce [coll]\n  (reduce (fn [acc x] \n    (let \n      [newfreq (inc (or (acc x) 0))]\n      (assoc acc x newfreq))) {} coll))","user":"5c987160e4b048ec896c5a82"},{"code":"(fn count-us [arg]\n  (loop [in arg out {}]\n    (let [f (first in)]\n      (cond (nil? f) out\n            (out f) (recur (rest in) (assoc out f (-> f out inc)))\n            :else (recur (rest in) (assoc out f 1))))))","problem":55,"user":"51baff1be4b0fe3ecfb46443"},{"code":"(fn [c]\n    (let [g (group-by identity c)]\n      (zipmap (keys g) (map count (vals g)))))","problem":55,"user":"52d6a9c2e4b09f7907dd1365"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [i v] (update-in i [v] (fnil inc 0))) {} coll))","user":"51c1b644e4b0d204dbe2ca12"},{"code":"reduce #(assoc % %2 (+ (% %2 0) 1)) {}","problem":55,"user":"4db03279838c48654951d9bc"},{"problem":55,"code":"(fn\n  [coll]\n  (reduce (fn\n            [acc e]\n            (update-in acc [e] (fnil inc 0))) {} coll))","user":"58dfce9fe4b0a4d5acaab723"},{"problem":55,"code":"(fn [a] (apply hash-map (apply concat (map #(list (first %) (count %)) (vals (group-by identity a))))))","user":"53cdb2c4e4b00fb29b2212e5"},{"problem":55,"code":"(fn func\n    [ar]\n    (reduce #(assoc %1 %2 (if (%1 %2) (inc (%1 %2)) 1)) {} ar)\n\n\n    )","user":"5b8db323e4b0c0b3ffbd49da"},{"code":"(fn [s] (into {} (map #(vector (first %) (count %)) (partition-by identity (sort s)))))","problem":55,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":55,"code":"#(reduce\n  (fn [a b]\n    (update-in a [b]\n               (fn [e] (if (nil? e) 1 (inc e)))))\n  {}\n  %)","user":"58bb218be4b0888cdc949cf4"},{"code":";; problem 55 count occurences\n(fn mycount-occ [s]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} s))","problem":55,"user":"4e50c894535dc968683fc4ee"},{"problem":55,"code":"reduce (fn [mp v]\n         (assoc mp v (+ 1 (get mp v 0)))) {}","user":"54864662e4b0e286459a11b8"},{"problem":55,"code":"(fn freqs [eles] (if (empty? eles) {} (let [rest (freqs (rest eles))] (assoc rest (first eles) (inc (get rest (first eles) 0))))))","user":"55d95be7e4b0e31453f64ac9"},{"problem":55,"code":"(fn [coll]\n  (let [freq-map (group-by identity coll)]\n    (zipmap (keys freq-map) (map count (vals freq-map)))))\n;\n; freq-map builds an imperfect frequency map: e.g., {1 [1 1 1 1], 2 [2 2], 3 [3]}\n; Rest of function: \n;   * gathers keys & values together separately\n;   * converts vectors to counts--e.g.,  [1 1 1 1] to 4\n;   * recombines keys & counts into a map--e.g., {1 4, 2 2, 3 1}","user":"4f80db02e4b033992c121bf9"},{"code":"#(reduce (fn [m n] (assoc m n (if (m n) (-> n m inc) 1))) {} %)","problem":55,"user":"4e79a143535db169f9c796a2"},{"code":"(fn [s]\n      (let [m (group-by #((set (distinct s)) %) s)]\n        (zipmap (keys m) (map #(count %) (vals m)))))","problem":55,"user":"4e6a11ee535d8ccf87e9fe9f"},{"code":"(fn freq [s]\n  (loop [s s, r {}]\n    (if s\n      (let [f (first s) c (if (r f) (inc (r f)) 1 ) r (assoc r f c) ]\n        (recur (next s) r)) \n      r)\n  ))","problem":55,"user":"4e44358f535dc968683fc4a8"},{"problem":55,"code":"(fn freq\n  [s]\n  (loop [r {}\n         s s]\n    (if (seq s)\n      (let [f (first s)]\n        (recur (assoc r f (inc (r f 0)))\n               (rest s)))\n      r)))","user":"4e8a170c535d3e98b802328f"},{"problem":55,"code":"(fn [v]\n   (apply merge-with + (map (fn [key] {key 1}) v)))","user":"549a1fede4b0f3d1d8e70f6a"},{"problem":55,"code":"(fn [c] (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} c))","user":"50784ae5e4b0fc74642bff68"},{"code":"(fn [xs]\n  (into {} (map (fn [[k ks]] [k (count ks)])\n                (group-by identity xs))))","problem":55,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn [coll ] (let [v (vals (group-by identity coll)) c (map count v) f (map first v)] (apply hash-map (vec (interleave f c))) ))","problem":55,"user":"5230d9bde4b0035e815da397"},{"code":"(fn [coll]\n  (let [uniques (set coll)]\n\t  (->> uniques\n\t       (map (fn [x] [x (count (filter #(= x %) coll))]))\n\t       (map (partial apply hash-map))\n\t       (apply merge))))","problem":55,"user":"4daf36c2edd6309eace4d175"},{"problem":55,"code":"(fn [x]\n  (reduce #(if (contains? %1 %2) \n             (update-in %1 [%2] inc)\n          \t (assoc %1 %2 1 )\n            ) {} x\n   )\n  )","user":"556cd549e4b09a3098a52503"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc n]\n            (if-let [occ (get acc n)]\n              (assoc acc n (inc occ))\n              (assoc acc n 1))) {} coll))","user":"5478c4fee4b0c51c1f4d72c0"},{"code":"#(reduce (fn [res x] (update-in res [x] (fnil inc 0))) {} %)","problem":55,"user":"4f05ea25535dcb61093f6c02"},{"code":"(fn count-in-seq [s]\n  (reduce (fn [m v] (update-in m [v] (fnil inc 0))) {} s))","problem":55,"user":"50763574e4b0a894bb95bf3d"},{"code":"(fn my-frequencies [coll]\n  ((fn f [coll acc]\n     (if (seq coll)\n       (let [ne (first coll)]\n         (recur (rest coll) (assoc acc ne (inc (get acc ne 0)))))\n       acc))\n     coll {}))","problem":55,"user":"4ec75077535d6d7199dd36e0"},{"problem":55,"code":"#(reduce (fn [map e] (assoc map (first e) (count (second e)))) {} (group-by identity %1))","user":"5be79b5be4b0f319e2d7ec5a"},{"problem":55,"code":"reduce (fn [acc x] (assoc acc x (inc (get acc x 0)))) {}","user":"552d9b31e4b076ab5578f7eb"},{"code":"(fn [s]\n  (apply hash-map (mapcat #(list (first %) (count %)) (partition-by identity (sort s)))))","problem":55,"user":"52277ab9e4b0186687e23a4f"},{"problem":55,"code":"(fn count-occurences [coll]\n(reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","user":"54c9cd41e4b045293a27f67f"},{"code":"#(reduce (fn [xs [k v]]\n           (conj xs [k (count v)]))\n         {}\n         (group-by identity %))","problem":55,"user":"533018b2e4b019098a6f8b56"},{"problem":55,"code":"(fn [sq]\n  (loop [acc {}, s (sort sq)]\n    (if (empty? s) acc\n      (recur \n       \t(assoc acc (first s)   (count (take-while #(= % (first s)) s)))\n        (drop-while #(= % (first s)) s)\n))))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":55,"code":"#(into {} (for [i (vals (group-by identity %))] [(first i) (count i)]))","user":"57db2369e4b0bd073c20241f"},{"code":"(fn [s]\n  (loop [acc {} r s]\n    (if (not (seq r))\n         acc\n         (recur (assoc acc \n                       (first r) \n                       (if (nil? (acc (first r))) 1 (inc (acc (first r)))))\n                (rest r)))))","problem":55,"user":"4ef0a38e535dced4c769f20b"},{"problem":55,"code":"reduce #(assoc % %2 (let [x (get % %2)] (if (nil? x) 1 (inc x)))) {}","user":"544e6b7fe4b0e39780006986"},{"code":"(fn b [m]\n  (apply merge (map #(assoc {} (first %) (count %)) (partition-by identity (sort m)))))","problem":55,"user":"4fe97adde4b0547ebccb245e"},{"problem":55,"code":"(fn [coll]\n  (reduce #(assoc % (first %2) (count (second %2))) {} (group-by identity coll)))","user":"54fdbe3fe4b07d26eda61d3b"},{"code":"#(apply merge-with + (map (fn [a] {a 1}) %))","problem":55,"user":"4fb1d907e4b081705acca282"},{"code":"(fn [coll] \n\t(reduce conj {}\n\t\t(map #(vector (first %) (count %))\n\t\t(vals (group-by identity coll)))))","problem":55,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn [coll]\n  (into {}\n    (for [x coll]\n      [x\n      (count (filter #(= % x) coll))])))","problem":55,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"code":"(fn func [coll]\r\n  (let [f-e (first coll)]\r\n        (if (empty? coll) {}\r\n          (conj {f-e (reduce #(if (= %2 f-e) (inc %1) %1) 0 coll)} (func (remove #(= % f-e) coll))))))","problem":55,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":55,"code":"(fn [x] (into {} (for [[k v] (group-by identity x)] [k (count v)])))","user":"58ac513fe4b0005cfeb1a746"},{"problem":55,"code":"(fn [s]\n  (let [add-one #(if (nil? %) 1 (inc %))\n        freq #(update-in %1 [%2] add-one)]\n\t  (reduce freq {} s)))","user":"5c3a896be4b0d62ef62d9f94"},{"problem":55,"code":"#(let [freq (group-by identity %)] (zipmap (keys freq) (map (fn [x] (count x)) (vals freq))))","user":"580e7761e4b0849f6811b753"},{"code":"(fn my-frequencies [coll]\n  (reduce\n    #(assoc %1 %2 (inc (get %1 %2 0)))\n    {}\n    coll))","problem":55,"user":"526ee63de4b03e8d9a4a733f"},{"problem":55,"code":"(fn [a] (#(zipmap (keys %) (map count (vals %))) (group-by identity a)))","user":"565b2fa5e4b068f2fe63dbfe"},{"problem":55,"code":"(fn [coll]\n  (reduce\n    (fn [result x]\n      (assoc result x (inc (get result x 0))))\n    {}\n    coll))","user":"6098263be4b00e9e6653c3f9"},{"code":"(fn count-occurences\n  [s]\n  (loop [s s\n         acc {}]\n    (if (empty? s) acc\n        (let [k (first s)\n              acc (if-let [current-count (get acc k)]\n                   ;; grab the current count of our first item, if we haven't\n                   ;; counted it yet, it will be nil\n                    (update-in acc [k] inc)\n                    (assoc acc k 1))]\n          (recur (rest s)\n                 acc)))))","problem":55,"user":"4fd16778e4b04c3a95aa040f"},{"problem":55,"code":"(fn [s]\n   (->> (sort s)\n        (partition-by identity)\n        (map (fn [v] [(first v) (count v)]))\n        (mapcat (fn [s] s))\n        (apply hash-map)))","user":"5fa80c01e4b0fa27300f3de2"},{"code":"(fn [coll]\n    (reduce (fn [dict item]\n              (if (contains? dict item)\n                (update-in dict [item] inc)\n                (merge dict {item 1})))\n            {}\n            coll))","problem":55,"user":"4e7e8684535db169f9c79717"},{"code":"(fn [xs]\n (into {}\n  (map #(vector (first %) (count %))\n       (partition-by identity (sort xs)))))","problem":55,"user":"4f7ab8c7e4b06e829148e19c"},{"problem":55,"code":"(fn [list]\n  (reduce\n    (fn [dict el]\n      (assoc dict el\n        (if (contains? dict el)\n          (+ (dict el) 1)\n          1)))\n     {} list))","user":"5ab1cc3de4b073f1774425dc"},{"code":"(fn [x]\n    (loop [m {}, y x]\n      (if (empty? y)\n        m\n        (let [f (first y)\n              v (find m f)]\n          (if (nil? v)\n            (recur (conj m [f 1]) (rest y))\n            (recur (conj m [f (+ 1 (val v))]) (rest y))\n)))))","problem":55,"user":"501fcd59e4b0cb6ebc0a42ec"},{"code":"(fn [sq]\n  (reduce\n    #(merge-with + %1 {%2 1})\n    {} sq))","problem":55,"user":"4fc0853ae4b081705acca327"},{"code":"(fn [c]\n  (reduce\n   #(assoc % (first %2) (count (last %2)))\n   {}\n   (group-by identity c)\n   ))","problem":55,"user":"4ec53f8c535d6d7199dd368b"},{"problem":55,"code":"reduce (fn [part val] \n        (if (contains? part val) \n            (update-in part [val] inc) \n            (assoc part val 1))) {}","user":"5bc6ef7ce4b07a9b28b1009f"},{"problem":55,"code":"(fn [xs] \n  (into {} \n    (map (fn [[k vs]] {k (count vs)})\n         (group-by identity xs))))","user":"598debf0e4b02b9968b84d2e"},{"problem":55,"code":"(fn count-occurance [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0)))\n          {} coll))","user":"5634995fe4b0bfe05bf117be"},{"problem":55,"code":"(fn f55 [coll]\n  (apply merge\n    (for [f (set coll)\n          :let [a (filter #(= f %) coll)\n                b (count a)\n                c (first a)]] \n       {c b})))","user":"55634f38e4b0c656e3ff17e8"},{"problem":55,"code":"(fn [s]\n  (reduce #(if (%1 %2)\n             (assoc %1 %2 (inc (%1 %2)))\n             (assoc %1 %2 1))\n          {}\n          s))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":55,"code":"(fn [in] \n  (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} (seq in)))","user":"5600591de4b04bb52996e166"},{"code":"(fn [coll]\n  (let [grouped (group-by identity coll)]\n    (zipmap (keys grouped) (map count (vals grouped)))))","problem":55,"user":"4edab806535d10e5ff6f5311"},{"problem":55,"code":"#(apply merge-with + (for [x %] (identity {x 1})))","user":"5fe362d9e4b05ac5b16ea179"},{"code":"(fn my-freq[coll]\n    (apply assoc {} (mapcat #(list (first %) (count (second %))) (group-by identity coll)))\n )","problem":55,"user":"52763696e4b03e8d9a4a74d7"},{"problem":55,"code":"(fn [coll]\n  (letfn [(apply-to-map\n            [f m]\n            (reduce (fn [acc [k & v]] (assoc acc k (apply f v))) {} m))]\n    (apply-to-map count (group-by identity coll))))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn [xs]\n  (->> xs\n  \t(map (fn [x] {x 1}))\n\t\t(reduce #(merge-with + %1 %2))))","problem":55,"user":"4fb1fa51e4b081705acca283"},{"problem":55,"code":"#(loop [li % ali {}] (if (empty? li) ali\n                       (recur (drop 1 li) (update-in ali [(first li)] (fnil inc 0)))\n                    )\n)","user":"54db33f1e4b024c67c0cf75d"},{"problem":55,"code":"(fn [coll]\n    (into {} (map #(vector (first %) (count %)) (partition-by identity (sort coll))))    \n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":55,"code":"(fn [coll]\n  (reduce #(merge-with (fn [x1, x2] (+ x1 x2)) %1 {%2 1}) {} coll))","user":"55aa8276e4b0988bba2ad94e"},{"problem":55,"code":"(fn count-occ [s]\n  (loop [remain s, result {}]\n    (let [k (first remain)]\n      (if (empty? remain)\n        result\n        (recur (rest remain) (assoc result k (inc (result k 0))))))))","user":"567e418fe4b0feffd0d18eb1"},{"problem":55,"code":"(fn [x] (into (sorted-map)\n               (map #(vector (first %) (count %))\n                    (partition-by\n                      identity\n                      (sort x)))))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"(fn [v]\n  (let [grouped (group-by identity v)]\n    (into {} (for [[k v] grouped] [k (count v)]))))","problem":55,"user":"4fcad14ce4b0ee37620e1856"},{"problem":55,"code":"(fn countOcc [l] (reduce conj {} (map #(hash-map %1 %2) (distinct l) (for [x (distinct l)] (count (filter (fn [y] (= x y)) l)) )) ))","user":"548f3ee4e4b0e286459a1237"},{"problem":55,"code":"(fn [coll]\n   (->> coll\n    (group-by identity)\n    (map (fn [x]\n           (let [k (key x)\n                 v (val x)]\n             {k (count v)})))\n    (reduce conj)))","user":"591072e0e4b0163c97b36ebc"},{"problem":55,"code":"(fn [coll]\n\t(let [freq (group-by identity coll)]\n\t\t(zipmap (keys freq) (map count (vals freq)))\n\t\t)\n\t)","user":"54c11fdae4b0ed20f4ff6f1b"},{"code":"#(into {} (for [[k,v] (group-by identity %)]\n              [k, (count v)]))","problem":55,"user":"4e6a2f93535d8ccf87e9feaa"},{"code":"(fn [xs] \n  (into {} \n        (for [[k v] (group-by identity xs)] [k (count v)])))","problem":55,"user":"538c3424e4b0b51d73faae58"},{"problem":55,"code":"(fn wc [coll]\n  (reduce (fn [m w] (assoc m w (inc (m w 0)))) {} coll))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":55,"code":"#(into {} (for [x (partition-by identity (sort %))] [(first x) (count x)]))","user":"5b772ad7e4b047b03b2036e8"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (map (fn [[k s]] [k (count s)]))\n      (into {}))","user":"5bab5440e4b0a20761a23475"},{"problem":55,"code":"#(into {} (map (fn [x] {(first x) (count (second x))}) (group-by identity %)))","user":"56f15eade4b04a395b9a048e"},{"code":"(fn [coll]\n  (reduce #(if (contains? % %2)\n             (update-in % [%2] inc)\n             (assoc % %2 1))\n          {} coll))\n\n;; (fn [ns]\n;;  (reduce #(merge-with + %1 {%2 1}) {} ns))\n\n;; (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {})","problem":55,"user":"503f4759e4b00d1a725ff2a9"},{"code":"(fn fq [coll]\r\n  (loop [result {} coll coll]\r\n    (if (empty? coll)\r\n      result\r\n      (let [x (first coll)]\r\n        (recur\r\n          (if (contains? result x)\r\n            (assoc result x (inc (result x)))\r\n            (assoc result x 1N)\r\n          )\r\n          (rest coll)  )))))","problem":55,"user":"4fd170fce4b04c3a95aa0411"},{"problem":55,"code":"(comp \n (partial apply merge) \n (partial map #(hash-map (first %) (count (second %)))) \n (partial group-by identity))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn count-occurences [seq]\n  (reduce (fn [dict x]\n            (let [k (dict x)]\n              (if (nil? k)\n                (assoc dict x 1)\n                (assoc dict x (+ k 1)))))\n          {}\n          seq))","problem":55,"user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn [coll] (let [sorted (partition-by identity (sort coll))]\n             (zipmap (map (fn [coll] (first coll)) sorted) (map count sorted))))","problem":55,"user":"523361d8e4b0f0b72fabf405"},{"problem":55,"code":"#(into {} (map (fn [[x y]] [x (count y)]) (group-by identity %)))\n\n; reduce #(assoc % %2 (+ 1 (% %2 0))) {}\n; #(apply merge-with + (map (fn [a] {a 1}) %))","user":"55236ad6e4b0882d96d091b1"},{"problem":55,"code":"#(reduce (fn [a b] \n           (update-in a [b] (fnil inc 0))\n           ) {} %)","user":"513facf5e4b00f13ea1bd892"},{"problem":55,"code":"(fn [xs] (into {} (map #(hash-map (first %) (count (second %))) (group-by identity xs))))","user":"56fa2905e4b07572ad1a88be"},{"code":"(fn freq [coll]\n  (loop [coll coll,\n         result {}]\n    (if (empty? coll)\n      result\n      (if (contains? result (first coll))\n        (recur (rest coll) (assoc result (first coll) (inc (result (first coll)))))\n        (recur (rest coll) (assoc result (first coll) 1))))))","problem":55,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn [c]\n  (reduce \n    (fn [m el]\n      (update-in m [el] (fnil inc 0))) {} c))","problem":55,"user":"5027fc0ce4b01614d1633ff2"},{"problem":55,"code":"(fn [s] (into {}\n              (for [e (into (hash-set) s)] [e (count (filter #(= e %) s))])))","user":"592ac17ae4b072a2710fcf26"},{"problem":55,"code":"(fn [s]\n\t(loop [s s\n           m {}]\n      (if (empty? s)\n        m\n        (let [n (filter #(not= (first s) %) s)]\n          (recur n (assoc m (first s)\n                     (- (count s) (count n))))))))","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn [l] \n  (reduce \n   #(assoc % %2 (if (get % %2) \n                  (inc (get % %2)) \n                  1)\n      ) \n    {}  l)\n  )","problem":55,"user":"51e1c176e4b06a68e693eafb"},{"problem":55,"code":"(fn freq-map [my-vec]\n  (letfn [(freq [value avec] (count (filter #(= % value) avec )))\n          (freq-table [sorted-vec] \n            (loop [myvec sorted-vec\n                   value (first sorted-vec) \n                   result []]\n              (if (= 0 (count myvec))\n                result\n                (recur\n                 (drop (freq value myvec) myvec)  \n                 (first (drop (freq value myvec) myvec)) \n                 (conj result [value, (freq value myvec)])  )\n                )\n              ) \n            )] \n    (apply array-map (apply concat (freq-table (sort my-vec))))\n    )\n  )","user":"58a17511e4b02bd94d917eb4"},{"problem":55,"code":"(fn tmp [coll]\n  (reduce (fn [freqs x]\n            (assoc freqs x (inc (get freqs x 0))))\n          {}\n          coll))","user":"594bc16be4b07ddc2dafae39"},{"problem":55,"code":"#(reduce (fn [a n] (merge-with + a {n 1})) {} %)","user":"54924f64e4b0b312c081ff42"},{"code":"(fn [a-seq] (reduce (fn [result data] \n                     (let [value (result data)]\n                        (assoc result data (if value (inc value) 1))))\n                    {} a-seq))","problem":55,"user":"4e6dc95a535d5021c1a895f1"},{"code":"#(reduce (fn [acc x] (update-in acc [x] (fnil inc 0)))\r\n         {}\r\n         %)","problem":55,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"#(apply merge \n  (map (fn [[k v]] {k (count v)}) \n    (group-by identity %)))","problem":55,"user":"4e5867d1535d8a8b8723a291"},{"code":"(fn [a]\n  (let [col (group-by identity a)]\n    (reduce #(assoc %1 %2 (count (get col %2))) {} (keys col))))","problem":55,"user":"532418f3e4b09d4e7a9b54d8"},{"problem":55,"code":"(fn [x] (apply assoc {} (mapcat (fn [c1 c2] (list c1 (count (filter #(= c1 %) c2)))) x (repeat (count x) x))))","user":"5b632851e4b0c6492753e72d"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [p c] (into p {c (inc (get p c 0))})) {} coll))","user":"5da306a3e4b000c986472be7"},{"code":"(fn [x] \n  (let [ks (set x)\n        counter (fn [v] (count (filter #(= v %) x)))\n        counter-mps (fn [v] (hash-map v (counter v)))\n        ] \n    (reduce merge (map counter-mps ks))\n  )\n)","problem":55,"user":"535197f2e4b084c2834f4ae4"},{"problem":55,"code":"#(reduce (fn [xs x]\n           (cond\n            (contains? xs x) (assoc xs x (inc (get xs x)))\n            :else (assoc xs x 1)\n            )\n           ) {} %)","user":"5fc5c303e4b02c825b0c8c1a"},{"problem":55,"code":"( fn [l]\n  (loop [res {}  [a & r] l ]\n    (if a\n      ( let [la (filter #(=  a  % ) l)      ]\n        \n          (recur (assoc res  a  (count la) ) (filter #(not=  a  % ) r))\n      )\n      res\n      )\n    \n    )\n  \n  )","user":"5735ac67e4b0cd1946bd102b"},{"code":"#(apply merge (for [[x y] (group-by identity %)] {x (count y)}))","problem":55,"user":"504e12ade4b078edc5f593b7"},{"problem":55,"code":"(fn [t]\n  (reduce #(merge %1 {%2 (inc (or (%1 %2) 0))}) {} t))","user":"5f6b5d83e4b02876ed9fd050"},{"code":"#(into {} \n       (map (fn [[k v]][k (count v)]) \n              (group-by identity %)))","problem":55,"user":"4fe15ffee4b0dd6cd5ce3634"},{"code":";(fn [xs]\n;  (let [counts (reduce #(assoc %1 %2 0) {} xs)]\n;    (reduce #(update-in %1 [%2] inc) counts xs)))\n\n(fn [xs] (reduce #(update-in %1 [%2] (fnil inc 0)) {} xs))","problem":55,"user":"5312cdaae4b08068f379ed03"},{"problem":55,"code":"(fn [coll] (into {} \n      (map #(vector (first %1) (count %1)) \n           (partition-by identity (sort coll)))))","user":"5c411df3e4b08cd430848ebf"},{"problem":55,"code":"#(reduce\n  (fn [acc x]\n    (assoc acc x (inc (get acc x 0))))\n  {} %)","user":"59bcbfd0e4b0a024fb6ae419"},{"code":"(fn [coll]\n   (let [gp (group-by identity coll)]\n     (zipmap (keys gp) (map #(count (second %)) gp))))","problem":55,"user":"5115cf87e4b0ce5098ee73c3"},{"problem":55,"code":"(fn [s]\n  (reduce\n    #(assoc %1 %2 (inc (get %1 %2 0))) {} s))","user":"5638b88de4b0bfe05bf117e9"},{"code":"#(into {} (for [p (partition-by identity (sort %))] [(first p) (count p)]))","problem":55,"user":"4eb25069535d7eef30807348"},{"code":"(fn [coll]\n  (loop [coll coll result {}]\n      (if (empty? coll)\n        result\n        (let [head (first coll)\n              cnt (get result head)]\n          (if (nil? cnt)\n            (recur (rest coll) (assoc result head 1))\n            (recur (rest coll) (assoc result head (inc cnt))))))))","problem":55,"user":"4e88feef535d8b9bb0147ca8"},{"problem":55,"code":"reduce \n(fn [t v] (if-let [n (get t v)]\n            (assoc t v (inc n))\n            (assoc t v 1)))\n{}","user":"561c0278e4b064ca9f4b1691"},{"code":"(fn [xs]\n  (reduce #(assoc %1 %2 (if-let [n (get %1 %2)] (inc n) 1)) {} xs))","problem":55,"user":"531490bde4b08068f379ed17"},{"problem":55,"code":"(fn [m]\n  (reduce \n   (fn [m [k v]] (assoc m k (count v))) \n   {} \n   (group-by identity m)))","user":"53065acbe4b02e8216869792"},{"problem":55,"code":"(fn [x] (into {} (map (fn [v] [(first v) (count (last v))]) (group-by identity x))))","user":"60329afce4b0d5df2af222b8"},{"code":"#(apply merge-with + (map (fn [v] {v 1}) %))","problem":55,"user":"4e6b3fc8535d8ccf87e9ff0f"},{"problem":55,"code":"(fn [x] (reduce (fn [x,y] (assoc x (first y) (second y))) {} (map #(vector (first %) (count (second %))) (group-by identity x))))","user":"5933b736e4b072a2710fd05d"},{"code":"(fn cnt-ocur-group [col]\n  (into {}\n    (for [[k v](group-by identity col)] [k (count v)])))","problem":55,"user":"4f61be97e4b0defedf855fc5"},{"code":"(fn [a] (into {} (map (fn [[x y]] [x (count y)]) (group-by identity a))))","problem":55,"user":"513b77f3e4b00f740c76c403"},{"code":"(fn [coll]\n  (reduce\n   (fn [dict k]\n     (assoc dict k (inc (dict k 0))))\n   {}\n   coll))","problem":55,"user":"520612a7e4b0bf4f1882c81c"},{"code":"(fn [coll] (apply (partial merge-with #(+ %1 %2)) (map (fn [ele] {ele 1}) coll)))","problem":55,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn [x] (let [partitions (partition-by identity (sort x))]\r\n  (zipmap\r\n    (map first partitions) (map count partitions))))","problem":55,"user":"4dbd0161535d020aff1edf3f"},{"problem":55,"code":"(fn [m]\n  (reduce (fn [k s]\n            (assoc k s (if (k s) (+ (k s) 1) 1))) {} m))","user":"57c314f3e4b05aa3c4741cba"},{"problem":55,"code":"(fn [xs] \n  (reduce \n   (fn [acc x]\n     (assoc acc x (inc (get acc x 0)))) {} xs))","user":"56946d43e4b0dcc4269f411e"},{"problem":55,"code":"(fn [coll]\n (persistent!\n  (reduce (fn [acc x]\n            (assoc! acc\n                    x\n                   (-> (get acc x 0) inc)))\n          (transient {})\n          coll))\n  \n  \n)","user":"5d07989ee4b0cc9c915881fb"},{"problem":55,"code":"(fn foo [l] (apply merge-with + (map #(hash-map (first %) (count %)) (partition-by identity l))))","user":"536673a8e4b0243289761e76"},{"problem":55,"code":"(fn fifty-five [coll]\n  (reduce\n    (fn [hist a]\n      (->> a\n           (#(get hist %1 0))\n           (+ 1)\n           (assoc hist a)))\n    {}\n    coll)\n)","user":"54c9f165e4b045293a27f687"},{"problem":55,"code":"(fn [s]\n  (into\n   {}\n   (map\n    #(vector (first %) (count (second %)))\n    (group-by identity s))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"#(apply merge-with + (map (fn [i] {i 1}) %))","problem":55,"user":"4f0a4e7e535d0136e6c222f4"},{"problem":55,"code":"(fn map-frequencies [xs]\n  (reduce (fn [m i] (assoc m i (inc (m i 0)))) {} xs))","user":"5efdb9bae4b0cf489e8d7f02"},{"problem":55,"code":"(fn [coll] (->> coll\n               (group-by identity)\n               (map #(vector (first %) (count (last %))))\n               (into {})))","user":"5d629ed9e4b0c9e5857d501d"},{"code":"(fn freq\n  ([coll] (freq coll {}))\n  ([coll aux]\n    (let [[f & tail] (seq coll)]\n      (if f\n        (if (aux f)\n          (freq tail (assoc aux f (inc (aux f))))\n          (freq tail (assoc aux f 1)))\n        aux))))","problem":55,"user":"4f625f68e4b0defedf855fd2"},{"problem":55,"code":"(fn [xs]\n  (reduce (fn [cnts e]\n            (assoc cnts e\n              (->> xs (filter (fn [el] (= e el)))\n                      count)))\n          {}\n          xs))","user":"548fa2dfe4b0e286459a1240"},{"problem":55,"code":"(fn foo [coll]\n  (let [mapyboi (reduce #(update-in %1 [%2] conj %2) {} coll)]\n    (reduce #(assoc %1 (first %2) (count (last %2))) mapyboi mapyboi)))","user":"5b3251c1e4b025bcb146f317"},{"problem":55,"code":"#(loop [acc %,rst {}]\n   (if (empty? acc)\n     rst\n     (recur (rest acc)\n            (assoc rst (first acc) (inc (get rst (first acc) 0))))\n    )\n )","user":"56c50599e4b05cc29241ee9e"},{"problem":55,"code":"(fn count-occurrences [se]\n  (into {}\n        (map (fn [e] (vector (first e)\n                             (count (second e))))\n             (group-by identity se))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":55,"code":"(fn [col] (reduce (fn [res item] (assoc res item (inc (or (get res item) 0)))) {} col))","user":"52d68ed2e4b09f7907dd1362"},{"problem":55,"code":"#(into {} (map (fn [x] {(key x) (count (val x))} ) (group-by identity %1)))","user":"55a21f1ce4b0acc240e3151f"},{"problem":55,"code":"(fn [coll]\n  (let [a (group-by identity coll)]\n    (zipmap (keys a) (map #(count %)(vals a)))))","user":"534fa9dae4b084c2834f4acf"},{"problem":55,"code":"(fn [xs]\n   (let [kv (group-by identity xs)\n         ks (keys kv)\n         vals (map count (vals kv))]\n     (zipmap ks vals)\n     ))","user":"5896ade8e4b00487982d52a9"},{"code":"#(loop [r {}\n               c %1]\n             (if (empty? c)\n                 r \n               (recur (assoc r (first c) (inc (if (nil? (get r (first c)))\n                                                  0\n                                                (get r (first c)))))\n                                                (rest c))))","problem":55,"user":"511b810ce4b07ab9ec456182"},{"problem":55,"code":"(fn [s] \n  (reduce #(update-in %1 [%2] (fnil inc 0))\n          {}\t\n       \t  s))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":55,"code":"(fn freq \n  ([coll] (freq coll {}))\n  ([coll ret]\n    (if (empty? coll)\n      ret\n      (recur (rest coll) (update-in ret [(first coll)] (fnil inc 0))))))","user":"4f4aa932e4b0d56e7bb92c14"},{"problem":55,"code":"(fn my-freq\n  [coll]\n  (into {} (map #(vector (first %) (count (second %))) (group-by identity coll))))","user":"56449e4de4b0284900eef5f9"},{"code":"(fn count-em [coll]\n  (reduce #(if (nil? (%1 %2))\n             (assoc %1 %2 1)\n             (update-in %1 [%2] inc))\n          {}\n          coll))","problem":55,"user":"4e615cd2535d8ccf87e9fe58"},{"problem":55,"code":"(fn ([s] (->> s (group-by identity) (reduce-kv #(assoc %1 %2 (count %3)) {} ))))","user":"54d8cc38e4b0a52adc2e203e"},{"problem":55,"code":"(fn my-frequencies\n  [lst]\n  (into {} (map (fn [[key val]] [key (count val)]) (group-by identity lst))))","user":"506f0968e4b09350ab4199f5"},{"problem":55,"code":"#(reduce (fn[res v]\n           (assoc res v (inc (or (get res v) 0)))) {} %)","user":"58c1b4f5e4b021aa9917ed01"},{"problem":55,"code":"( fn[xs]\n    (reduce-kv  #(assoc %1 %2 (.size %3) )  {} (group-by identity xs))\n  )","user":"55d7312ee4b0e31453f64a9f"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m v]\n            (assoc m v (inc (get m v 0)))) {} s))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":55,"code":";update-in since update not allowed for some reason\n(fn [col] (reduce (fn [m v] (update-in m [v] #(if % (inc %) 1)))\n                  {}\n                  col))\n\n;golf; 45 non-whitespace, 5 necessary ws. = 50\n;(fn [c] (reduce (fn [m v] (assoc m v (inc (m v 0)))) {} c))","user":"54d341f7e4b0e8a36923e603"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [acc i] (assoc acc i (inc (get acc i 0)))) {} coll))","user":"5799b260e4b05b1deef9adc8"},{"code":"(fn [x]\n  (into {} \n        ((fn foo [x]\n               (if (empty? x) nil\n                 (concat (vector \n                          (vector (first x) (count (filter #(= % (first x)) x))))\n                         (foo (remove #(= % (first x)) x)))))\n         x)))","problem":55,"user":"5078300de4b0fc74642bff66"},{"problem":55,"code":"#(into {}\n       (map (fn [[k v]] [k (count v)]) (group-by identity %)))","user":"5893c64ce4b00487982d524b"},{"code":"(fn [xs]\n  (into {} (map #(hash-map (first %) (count (second %))) (group-by identity xs))))","problem":55,"user":"51a8f0c6e4b08d8ec191b821"},{"problem":55,"code":"(fn [coll] (into {} (distinct (mapcat (fn [el] {el (count (filter #(= el %) coll))}) coll))))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"problem":55,"code":"(fn [v]\n  ((fn [v m]\n     (if (empty? v) m\n         (let [key (first v)\n               keys (keys m)]\n           (if (or (nil? keys) (not (.contains keys key)))\n             (recur (rest v) (conj m [key 1]))\n             (recur (rest v) (update-in m [key] inc)))))) v {}))","user":"60aecd73e4b00e9e6653c49a"},{"problem":55,"code":"(fn [coll] (reduce #(conj %1 [%2 (inc (if (contains? %1 %2) (get %1 %2) 0))]) {} coll))","user":"5d6d2172e4b04d129b00f2b9"},{"problem":55,"code":"(fn freqs\n  ([xs] (freqs xs {}))\n  ([[x & xs :as lst] result]\n    (if (empty? lst)\n      result\n      (recur xs (assoc result x (inc (get result x 0)))))))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn meu-frequencies [s]\n  (reduce #(assoc %1 %2 (let [valor (%1 %2)]\n                          (if (nil? valor)\n                            1\n                            (inc valor))))\n          {}\n          s))","problem":55,"user":"52c8758be4b0c2d177d62135"},{"problem":55,"code":"(fn [s]\n    (loop [xs s\n           m {}]\n          (if (empty? xs)\n              m\n              (recur (rest xs) (let [k (first xs)]\n                                    (if (contains? m k)\n                                        (assoc m k (inc (get m k)))\n                                        (assoc m k 1)))))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn [s] (reduce (fn [r x] (update-in r [x] #(if % (inc %) 1))) {} s))","problem":55,"user":"4ea41fc2535d7eef308072cb"},{"problem":55,"code":"#(into {} (for [x (distinct %)] [x (count (filter (partial = x) %))]))","user":"5501de12e4b07d26eda61d7b"},{"problem":55,"code":"(fn [data] (into {}(map (fn [xs] [(first xs) (count xs)] ) (partition-by identity (sort data)))))","user":"4fc5eb7fe4b0ee37620e1803"},{"code":"(fn [c](reduce #(assoc %1 %2 (inc (%1 %2 0))) {} c))","problem":55,"user":"4e6cf521535de274dd8d818b"},{"problem":55,"code":"(fn my-frequencies\n  [coll]\n  (into {}\n        (map (fn [x]\n               [x (count (filter #{x} coll))])\n             (distinct coll))))","user":"56180d83e4b06b1bb2182a18"},{"code":"#(apply merge-with + (map (fn [x] (hash-map x 1)) %))","problem":55,"user":"503354c3e4b0c6c1199c710c"},{"problem":55,"code":"(fn solve [x]\n  (apply merge (for [[k v] (group-by identity x)] {k (count v)}))\n)","user":"56f258d3e4b04a395b9a04a1"},{"code":"(fn [x] (reduce (fn [coll x] (let [c (assoc coll x (+ (coll x) 1))] c)) \n                 (apply hash-map (interleave (distinct x) (repeat 0))) \n                  x))","problem":55,"user":"52fa4f48e4b047fd55836ff7"},{"problem":55,"code":"(fn my-freq\n  [s]\n  (let [grouped (group-by identity s)]\n    (reduce-kv (fn [i k v] (into i {k (count v)})) {} grouped)))","user":"56084e91e4b046a4fc0ac00f"},{"code":"(fn [c] (into {} (map #(identity {(first %) (count (second %))}) (group-by identity c))))","problem":55,"user":"52c1bd29e4b07a9af579236a"},{"problem":55,"code":"(fn\n    [-s]\n    (loop [s (vec -s) nw {}]\n        (if (empty? s)\n            nw\n            (let [fir (first s)]\n            (if (= (nw fir) nil)\n                (recur (rest s) (conj nw {fir 1}))\n                (recur (rest s) (assoc nw fir (+ 1 (nw fir)))))))))","user":"57e3f709e4b0bfb2137f5aaf"},{"code":"#(->> %\n              (group-by identity)\n              (map (fn [[k v]] [k (count v)]))\n              (into {}))","problem":55,"user":"52c4fe42e4b0c2d177d620e9"},{"code":"(fn [coll]\n  (into {}\n    (map\n      #(vector (first %) (count (second %)))\n      (group-by identity coll))))","problem":55,"user":"4fb2101ce4b081705acca284"},{"code":"(fn [s] (reduce #(update-in %1 [%2] (fnil inc 0)) {} s))","problem":55,"user":"52d1e364e4b0d9f9285948e7"},{"code":"(fn freqs [x]\n\t(apply merge \n           (for [[k v] (group-by identity (sort x))]\n\t\t{k (count v)}\n\t)))","problem":55,"user":"5094057fe4b097f48cc38593"},{"code":"reduce #(update-in %1 [%2] (fnil inc 0)) {}","problem":55,"user":"4daef21cedd6309eace4d169"},{"problem":55,"code":"(fn [coll] (apply hash-map (mapcat #(list (first %) (count (second %))) (group-by identity coll))))","user":"594266cfe4b060784b3b790b"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [freqs k]\n     (assoc freqs k ; we should use the update function but 4clojure is running Clojure 1.4...\n             (inc (freqs k 0))))\n   {} s))","user":"576da825e4b0979f8965156c"},{"problem":55,"code":"(fn [x] (reduce #(assoc %1 %2 ((fn [a] (if (nil? a) 1 (inc a))) (%1 %2))) {} x))","user":"5918db70e4b09b4ee5954bbb"},{"problem":55,"code":"(fn [coll]\n   (loop [h {}\n          l coll\n          f (first l)]\n     (if (not (nil? f))\n       (if-let [x (get h f)]\n         (recur (merge h {f (inc x)}) (rest l) (first (rest l)))\n         (recur (merge h {f 1}) (rest l) (first (rest l))))\n       h\n       ))\n   )","user":"517e12e3e4b0fcc7c5d37d3c"},{"problem":55,"code":"(fn [c] (->> c (group-by identity) (map #(vector (first %) (count (second  %)))) (into {}) ) )","user":"512b07f7e4b078b06821febb"},{"code":"reduce #(assoc % %2\n          (if (% %2)\n            (inc (% %2))\n            1)) {}","problem":55,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":55,"code":"; (partial reduce #(assoc %1 %2 (inc (get %1 %2 0))) {})\n\n(fn freq [xs] (reduce #(merge-with + %1 {%2 1}) {} xs))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":55,"code":"(fn solution55\n  [llist]\n  (loop [curr-list  llist\n         ans        {}]\n    (if (empty? curr-list)\n      ans\n      (let [f (first curr-list)]\n        (if (contains? ans f)\n          (recur (rest curr-list) (assoc ans f (+ 1 (get ans f))))\n          (recur (rest curr-list) (assoc ans f 1)))))))","user":"595bc925e4b066ee0a44afe2"},{"problem":55,"code":"(fn my-frequencies [x]\n  (into {} (for [[k v] (group-by identity x)] [k (count v)])))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":55,"code":"(fn [s] (reduce \n         #(assoc % %2 (count (filter (partial = %2) s)))\n         {} (distinct s)))","user":"53572176e4b04ce2eb3ed276"},{"code":"(fn [s] (apply (partial merge-with (fn [y x] (+ y x))) (merge-with #(inc %1) (map (fn [x] {x 1}) s))))","problem":55,"user":"4f12ab23535d64f603146429"},{"problem":55,"code":"(fn [e] (->>\n        \t(group-by identity e)\n  \t\t\t  (mapcat #(list (first %) (count (last %))))\n  \t\t\t  (apply hash-map)))","user":"543f854fe4b032a45b86935b"},{"problem":55,"code":"(fn [s]\n  (reduce-kv (fn [acc k v]\n               (assoc acc k (count v))\n               ) {} (group-by identity s)))","user":"5c950334e4b048ec896c5a44"},{"problem":55,"code":"(fn my-frequencies [seq]\n  (zipmap (sort (distinct seq)) (map count (partition-by identity (sort seq))) ))","user":"5e980e6be4b0157ca96647d6"},{"problem":55,"code":"#(->>\n    (group-by identity %)\n    (into [])\n    (map (fn [vec] (let [[f s] vec] [f (count s)])))\n    (into {})\n    )","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn [coll]\n  (reduce (fn [counts x]\n            (merge-with + counts {x 1}))\n          {}\n          coll))","problem":55,"user":"4dc0d7d5535d020aff1edf81"},{"code":"#(into {} (for [[k v] (group-by identity %)] [k (count v)]))","problem":55,"user":"4ee7ef87535d93acb0a66872"},{"code":"(fn [n] (reduce (fn [x y] (merge-with (fn [a b] (inc a)) x {y 1})) {} n))","problem":55,"user":"4ec2f1d9535dcc7ae8597d4d"},{"problem":55,"code":";;(fn occurrences [coll]\n;;  (reduce (fn [m e]\n;;            (if (contains? m e)\n;;              (update-in m [e] inc)\n;;              (assoc m e 1)))\n;;          {}\n;;          coll))\n\n\n(fn occurrences [coll]\n  (reduce (fn [m e]\n            (update-in m\n                       [e]\n                       (fn [occur]\n                         (inc (or occur 0)))))\n          {}\n          coll))","user":"5d1be50ce4b02ea6f0fb6986"},{"problem":55,"code":"(fn m-frequencies [xs]\n  (->> xs\n       (group-by identity)\n       (reduce-kv (fn [m k v] (assoc m k (count v))) {})))","user":"5d4b2155e4b0776584bd6f28"},{"problem":55,"code":"#(reduce (fn [out i]\n           (update-in out [i]\n                      (fn [c]\n                        (if c\n                          (inc c)\n                          1)))) {} %)","user":"55647a31e4b0c656e3ff1808"},{"code":"(fn [lst]\r\n    (apply hash-map\r\n           (mapcat\r\n            (fn [x] (list x (count (filter #(= % x) lst))))\r\n            (set lst))))","problem":55,"user":"508b95a0e4b0be79e5b189c6"},{"problem":55,"code":"#(->> % (group-by identity) (reduce (fn [m e] (assoc m (key e) (count (val e)))) {}))","user":"54e1939ce4b024c67c0cf7c5"},{"problem":55,"code":"#(->> %\n          (group-by identity)\n          (reduce-kv (fn [m k v] (assoc m k (count v))) {}))","user":"58c4b11ae4b021aa9917ed2c"},{"code":"(fn count-occur [s]\r\n   (loop [s s\r\n          ret {}]\r\n      (if (empty? s)\r\n          ret\r\n        (recur (rest s)\r\n               (if-let [count (ret (first s))]\r\n                       (assoc ret (first s) (inc count))\r\n                   (assoc ret (first s) 1))))))","problem":55,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":55,"code":"(fn[x]\n  (let[f (fn[hist elm]\n           (if (contains? hist elm)\n             (assoc hist elm (inc (hist elm)))\n             (assoc hist elm 1)))]\n    (reduce f {} x)))","user":"55429859e4b0a04f7929951f"},{"problem":55,"code":"(fn count-occ\n  ([s acc] (cond\n            (empty? s) acc\n            (contains? acc (first s)) (count-occ (rest s) (assoc acc (first s) (inc (acc (first s)))))\n            :else (count-occ (rest s) (assoc acc (first s) 1))))\n  ([s] (count-occ s {})))","user":"5ee93720e4b029a2061bbeb7"},{"problem":55,"code":"(fn count_occurences\n  [coll]\n    (apply hash-map (interleave (set coll) (map count (map #(filter (fn [val1] (= % val1))\n                          coll)\n                   (set coll))))))","user":"58a6d14fe4b01a0c0b232935"},{"code":"(fn [s]\n  (letfn [(f [fr elt]\n            (if (contains? fr elt)\n              (conj fr [elt (inc (fr elt))])\n              (conj fr [elt 1])))]\n    (reduce f {} s)))","problem":55,"user":"4fc13433e4b081705acca32b"},{"problem":55,"code":"(fn [list]\n  (apply merge-with + (for [elem list] {elem 1})))","user":"5958a0c8e4b066ee0a44af8c"},{"problem":55,"code":"(fn [xs]\n   (reduce (fn [acc [item times]] (assoc acc item (count times))) {} (group-by identity xs))\n)","user":"558ffb4be4b0277789237667"},{"code":"(fn [v] \n  (into {} (map (fn [[k v]] [k (count v)]) (group-by identity v))))","problem":55,"user":"51990df9e4b068aa333628fc"},{"problem":55,"code":"(fn [coll]\n  (let [occurences-by-identity (group-by #(identity %) coll)\n        count-occurences #(vector (% 0) (count (% 1)))]\n  \t(into {} (map count-occurences occurences-by-identity))))","user":"55d6a2ebe4b0e31453f64a9a"},{"code":"(fn freq [coll]\n  (let [ m (group-by (fn [x] x) coll)]\n       (zipmap (keys m) (map count (vals m)))\n   )\n  )","problem":55,"user":"4ecfa05c535d44c135fd68b9"},{"problem":55,"code":"#( into {} ( map (fn [[k coll]] [ k (count coll)]) ( group-by identity %)))","user":"516d227fe4b06f078fab252d"},{"code":"(fn [c] \n  (zipmap (distinct c)\n    (map (fn [n] (count \n      (filter (fn[x] (= x n)) c )))\n      (distinct c) )))","problem":55,"user":"4e7650c5535d324fb2983d68"},{"code":"(fn occ [sequ]\n  (into {} (for [[k v] (group-by #(do %1) sequ)] [k (count v)])))","problem":55,"user":"5239caa6e4b0d705d026ef27"},{"problem":55,"code":"(fn countem [xs]\n  (zipmap\n   (set xs)\n   (map (fn [x] \n          (->>\n           xs\n           (filter #(= x %))\n           (count)))\n        (set xs))))","user":"59f7f55de4b0ca45a743a313"},{"problem":55,"code":"(fn [in]\n   (loop [in in\n          out {}]\n     (if (empty? in)\n       out\n       (let [x (first in)\n             n (count (filter #(= x %) in))] \n         (recur (remove #(= x %) in) (into out {x n}))))))","user":"5d9e8e40e4b000c986472bc2"},{"code":"(fn [lst] (reduce #(update-in % [%2] (fnil inc 0)) {}  lst))","problem":55,"user":"5281a445e4b0757a1b17143a"},{"problem":55,"code":"(fn [seq]\n  (reduce (fn [m value]\n            (if (contains? m value)\n              (update-in m [value] #(inc (Integer. %)))\n              (assoc m value 1)))\n          {}\n          seq))","user":"5da6cb60e4b000c986472c10"},{"code":"(fn [col]\n  (reduce (fn [sums val]\n            (assoc sums val (inc (get sums val 0)))) {} col))","problem":55,"user":"4ef4acf8535dced4c769f23c"},{"code":"reduce (fn [res x] (update-in res [x] (fnil inc 0))) {}","problem":55,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":55,"code":"(fn [s] \n  (apply hash-map (interleave (distinct s) (for [x (distinct s)] (count (filter #{x} s))))))","user":"53069e16e4b02e8216869798"},{"code":"(fn [s]\n  (reduce (fn [a b]\n    (update-in \n      a \n      [b] \n        (fn [x] (if (nil? x) 1 (inc x))) ))\n      {} s))","problem":55,"user":"4f8b56dae4b02e764a0a517e"},{"problem":55,"code":"reduce #(assoc %1 %2 (inc (%1 %2 0)))\n        {}","user":"5c59adbde4b01df32ab73260"},{"problem":55,"code":"(fn [s]\n  (into {}\n        (map #(vector (first %) (count (second %)))\n             (group-by identity s))))","user":"54f2fe9fe4b050824f58f5b8"},{"problem":55,"code":"(fn freq \n  ([s] (freq s {}))\n  ([s res]\n   (cond (empty? s) res\n         :else (freq (rest s) (assoc res (first s) \n                                     (if (nil? (get res (first s))) 1 \n                                        (inc (get res (first s)))))))))","user":"57af41bce4b0fbc9809a2731"},{"code":"(fn [v]\n  (let [col (group-by identity v) ]\n    (loop [result {} newcol col]\n      (let [itm (first newcol)]\n      (if (empty? newcol)\n        result\n        (recur (conj result [ (first itm) (count (second itm) ) ] )  (rest newcol) )\n        ))\n      )\n    )\n\n  )","problem":55,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":55,"code":"(fn [coll]\n  (let [my-set (set coll)]\n    (zipmap\n     my-set\n     (map (fn [a]\n       (count (keep (fn [b]\n                      (when (=  b a) b)) coll))) my-set))))","user":"5d9475e9e4b0d3f9b434ad26"},{"code":"(fn [coll]\n   (let [rs (reverse (group-by identity  coll))]\n     (zipmap\n       (map #(first %) rs)\n        (map #(count (second %)) rs))))","problem":55,"user":"51cacda3e4b068dadb8f2227"},{"code":"(fn [coll]\n    (let [my-counts (group-by identity coll)]\n      (apply hash-map (interleave (map first my-counts)\n                                  (map count (vals my-counts))))))","problem":55,"user":"4f4a8707e4b0d56e7bb92c12"},{"code":"(fn occurences [s]\n  (reduce #(if (nil? (% %2))\n             (assoc % %2 1)\n             (assoc % %2 (inc (% %2))))\n          {} s))","problem":55,"user":"4f3e5e87e4b0e243712b1f83"},{"problem":55,"code":"(fn [lst]\n    (apply hash-map\n           (mapcat\n            (fn [x] (list x (count (filter #(= % x) lst))))\n            (set lst))))","user":"539fa040e4b0ca733b97449f"},{"problem":55,"code":"(fn f55 [coll]\n  (->>\n   (group-by identity coll)\n   (map #((comp count last) %))\n   (zipmap (distinct coll))))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":55,"code":"(fn [a]\n (->> a\n (set)\n (map (fn [y] [y (count (filter #(= y %) a))]))\n (into {})\n )\n)","user":"5b4b58f2e4b02d533a91bc9c"},{"code":"(fn [col] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} col))","problem":55,"user":"5033ed65e4b062bc5d7ae15a"},{"code":"(fn count-occurences [seq]\n  (reduce \n    (fn [m e] \n      (conj m [e (inc (m e 0))]))\n    {}\n    seq))","problem":55,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":55,"code":"(fn occur [xs]\n  (loop [ys xs\n         out {}]\n    (if (empty? ys)\n      out\n      (let [y (first ys)\n            r (rest ys)\n        \tout\t(if (contains? out y)\n          \t\t\t(assoc out y (+ 1 (get out y)))\n          \t\t\t(assoc out y 1))]\n        (recur r out)))))","user":"51000111e4b00d7ad4cab15e"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m x] (update-in m [x] #(if (nil? %) 1 (inc %))))\n          {}\n          coll))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn [xs]\n  (loop [xs xs\n         xx (hash-map)]\n    (if (empty? xs) xx\n      (recur (rest xs) \n             (merge xx {(first xs) (inc (get xx (first xs) 0))})))))","problem":55,"user":"509eeb3be4b08df8156e9e37"},{"code":"(fn [xs]\n  (let [\n    go (fn [acc x]\n          (if (contains? acc x)\n            (assoc acc x (inc (acc x)))\n            (conj acc [x 1])))]\n    (reduce go {} xs)))","problem":55,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn \n  [lista]\n  (let [m (group-by (fn [x] x) lista)]\n    (apply merge (for [i (keys m)] {i (count (m i))}))))","problem":55,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [xs] (into {} (map #(vec [(first %) (count (second %))]) (group-by identity xs))))","problem":55,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn freq [coll]\n    (reduce (fn [m k] (update-in m [k] (fnil inc 0))) {} coll))","problem":55,"user":"4ff4c9dae4b0678c553fc360"},{"code":"#(reduce (fn [hsh, item](if (contains? hsh item) (assoc hsh item (+ 1 (get hsh item))) (assoc hsh item 1) )) {} %1)","problem":55,"user":"503c02e5e4b0fc0f99c2e54e"},{"problem":55,"code":"#(reduce (fn [acc v]\n            (update-in acc [v] (fnil inc 0))\n            ) {} %)","user":"5b250773e4b063e2438bcc21"},{"problem":55,"code":"(fn [v]  (apply merge-with + (map #(-> {% 1}) v)))","user":"53a739b0e4b0ef122a8689d0"},{"problem":55,"code":"(fn mfrequencies\n  [l]\n  (loop [r l\n         rv {}]\n    (if (empty? r) rv\n        (recur (rest r) (update-in rv [(first r)] (fnil inc 0))))))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn [col] \n  (loop [\n         result {}\n         c col\n         ]\n    (if\n      (empty? c)\n      result\n      (recur (assoc result (first c) (inc (get result (first c) 0))) (rest c)))))","problem":55,"user":"4f05a9cf535dcb61093f6bfc"},{"problem":55,"code":"(fn [xs]\n  (apply merge (map (fn [[key val]]\n                      {key (count val)})\n                    (group-by identity xs))))","user":"547fbe01e4b0c51c1f4d7321"},{"code":"(fn [ls]\n  (let [gb (group-by identity ls)]\n    (into {}\n          (for [[k v] gb]\n            [k (count v)]))))","problem":55,"user":"51df825de4b01188f062752b"},{"problem":55,"code":"#(reduce \n  (fn [m i]\n    (if (m i)\n      (update-in m [i] inc)\n      (assoc m i 1)))\n  {}\n  %)","user":"57b3efb1e4b0fbc9809a278a"},{"problem":55,"code":"(fn count-occurs [xs]\n  ;; update is in 1.8 /shrug\n  (let [update (fn [m k f]\n                 (assoc m k (f (get m k))))]\n    (reduce (fn [acc x] (update acc x (fn [old-value] (if (nil? old-value)\n                                                        1\n                                                        (+ 1 old-value)))))\n            {}\n            xs)))","user":"590d3702e4b047aa04b199ff"},{"code":"(fn [coll] (->> coll (group-by identity) (map #(vec (list (first %) (count (second %))))) (reduce #(conj % (apply hash-map %2)) {})))","problem":55,"user":"509e8da7e4b08df8156e9e2f"},{"problem":55,"code":"(fn [s]\n  (->> s\n  (sort)\n  (partition-by identity)\n  (map #(hash-map (first %) (count %)))\n  (into {})))","user":"56df9203e4b0ca2494a095fc"},{"code":"(fn [xs]\n  (reduce\n    (fn [freqs x]\n      (update-in freqs [x] (fn [y] (inc (or y 0)))))\n    {}\n    xs))","problem":55,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn [coll] (persistent! (reduce (fn [counts x] (assoc! counts x (inc (get counts x 0)))) (transient {}) coll)))","problem":55,"user":"50fd4838e4b033b9c38d78ce"},{"problem":55,"code":"(fn [items]\n  (reduce (fn [m item]\n            (let [old (get m item 0)] \n              (assoc m item (inc old))))\n          {} items))","user":"5592ba8be4b0c79f6e1db931"},{"problem":55,"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0)))\n          {} coll ))","user":"52a3c66ce4b04e0c58e87c04"},{"code":"(fn [c]\n  (reduce #(assoc % (first %2) (count (second %2))) \n    {} \n    (group-by identity c)))","problem":55,"user":"4facff22e4b081705acca230"},{"problem":55,"code":"(fn [s]\n   (let [m (group-by identity s)]\n     (reduce #(update-in % [%2] (fn [v] (count v))) m (keys m))))","user":"53ea5307e4b036ad0777e4e2"},{"code":"(fn[s] (reduce #(assoc-in %1 [%2] (inc (or (get-in %1 [%2] 0)))) {} s))","problem":55,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":55,"code":"reduce #(if (nil? (% %2))\n          (assoc % %2 1)\n          (assoc % %2 (+ (% %2) 1))\n          ) {}","user":"54a1d643e4b09f271ff37c50"},{"code":"(fn [s]\n  (reduce\n    (fn [m [k v]] (assoc m k (count v))) {}\n    (group-by identity s)))","problem":55,"user":"4eb7b049535d7eef30807377"},{"problem":55,"code":"(fn [col] (let [grouped-values (group-by identity col)\n        id-count-map (map (fn [[id ids]] [id (count ids)]) grouped-values)]\n    (into {} id-count-map)))","user":"5acd235ae4b0e27600da7824"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [acc item]\n     (assoc acc item\n      (+ (get acc item 0) 1)\n     )\n   )\n   {}\n   coll\n  )\n)","user":"5c0d0537e4b0bdcf453d173d"},{"problem":55,"code":"(fn count-occurrences [coll]\n  ;; map produces ({1 1} {1 1} {2 1} ..). merge-with merges the hashes by\n  ;; applying the function to each value of the same key\n  (apply merge-with + (map #(hash-map % 1) coll)))","user":"58327a08e4b089d5ab817c7c"},{"code":"(fn [s] (into {} (for [[k v] (group-by #(-> %) s)] [k (count v)])))","problem":55,"user":"52160dbee4b0bf4bffd29cb3"},{"problem":55,"code":"(fn [x] \n  (apply merge-with + \n    (map #(hash-map % 1) x)))","user":"54534c83e4b0e397800069cd"},{"problem":55,"code":"(fn f [a]\n  (if (-> a count (= 0))\n    {}\n    (let [m (f (rest a)) i (first a)]\n      (assoc m i \n        (if (m i)\n          (-> i m inc)\n          1\n          )\n        )\n      )\n    \n    )\n  )","user":"525d490ae4b0cb4875a45d70"},{"problem":55,"code":"(fn [x] (reduce conj (map (fn [u] {(first u) (count (second u))}) (group-by identity x))))","user":"53e91473e4b036ad0777e495"},{"problem":55,"code":"(fn [s]\n    (reduce (fn [a b]\n              (conj a [(first b) (count b)]))\n            {}\n            (vals (group-by identity s))))","user":"6026d2cae4b0d5df2af22232"},{"problem":55,"code":"(fn [coll]\n   (let [gp (group-by identity coll)] \n      (zipmap (keys gp) (map #(count (second %)) gp))))","user":"5710b136e4b09c608db70437"},{"code":"(fn [a] ((fn [m] (zipmap (keys m) (map #(count %1) (vals m)))) (group-by (fn [x] x) a)))","problem":55,"user":"5243d9a2e4b076204b44fadf"},{"problem":55,"code":"(fn [coll]\n  (apply hash-map\n    (mapcat\n      (fn [x]\n        (let [[l r] x]\n          (list l (count r))))\n      (group-by identity coll))))","user":"56fc0601e4b07572ad1a88db"},{"code":"(fn myFrequencies\n  [coll]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} coll))","problem":55,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [x]\n  (zipmap (distinct x)\n          (map (fn [a] (count (filter #(= % a) x))) (distinct x))))","problem":55,"user":"4ed94d69535d10e5ff6f5303"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [m x] (assoc m x (inc (get m x 0)))) {} coll))","user":"545e9cf1e4b01be26fd7467f"},{"problem":55,"code":"#(reduce (fn [hm x] (assoc hm x (inc (get hm x 0)))) {} %)","user":"4f8490fae4b033992c121c34"},{"problem":55,"code":"(fn [xs]\n  (->> (sort xs)\n       (partition-by identity)\n       (mapcat #(list (first %) (count %)))\n       (apply hash-map)\n       \n       \n       ))","user":"58b12635e4b0ebc645576cf4"},{"code":"(fn [xs]\n  (let [cnt (fn [m x] (assoc m x (inc (m x 0))))]\n    (reduce cnt {} xs)))","problem":55,"user":"4f2a35ace4b0d6649770a03a"},{"problem":55,"code":"(fn [x] (#(reduce (fn [new-map [k v]]\n          (assoc new-map k (count v)))\n        {}\n        %)\n(group-by identity x)))","user":"57c0393be4b05aa3c4741c90"},{"code":"(fn fun [coll]\n  (into {}\n        (map (fn [[k v]] [(first v)(count v)])\n             (group-by identity coll))))","problem":55,"user":"5349da55e4b084c2834f4a68"},{"problem":55,"code":"(fn [xs]\n   (let [xs-distinct (distinct xs)\n         count-occ (fn [xs-distinct xs acc]\n                     (if (empty? xs-distinct) acc\n                       (recur (rest xs-distinct) xs \n                              (assoc acc (first xs-distinct) (count (filter #(= % (first xs-distinct)) xs))))))]\n     (count-occ xs-distinct xs {})))","user":"57780e4fe4b0979f89651657"},{"problem":55,"code":"(fn [s]\n  (reduce\n   (fn [m x] (update-in m [x] #(if (nil? %) 1 (inc %))))\n   {}\n   s))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [s]\n  (into {}\n        (for [[k v] (group-by identity s)]\n          [k (count v)])))","problem":55,"user":"4f849f76e4b033992c121c36"},{"problem":55,"code":"(fn count-occur\n  [coll]\n  (#(into {} (for [[k v] %] [k (count v)]) )(group-by identity coll))\n)","user":"5c75a30ee4b0fca0c16227df"},{"code":"(fn [col]\n  (let [uniqs (sort (set col))]\n    (zipmap uniqs\n            (map (fn [u]\n                   (count\n                    (filter #(= % u) col)))\n                 uniqs))))","problem":55,"user":"51891c96e4b04c2714a2670e"},{"problem":55,"code":"(fn [coll]\n  (reduce\n   (fn [map key] (assoc map key ((fnil inc 0) (map key))))\n   {}\n   coll))","user":"5d97b602e4b0d3f9b434ad3a"},{"problem":55,"code":"(fn [sq] (into {} (map (fn [[k v]] [k (count v)]) (group-by identity sq))))","user":"55b6a63ae4b01b9910ae299b"},{"problem":55,"code":"#(reduce  \n merge (map (fn [tentry] (hash-map (key tentry) (count (val tentry)))) (group-by identity %)))","user":"5831846ae4b051871117c02c"},{"code":"#(loop [n 0, r {}]\n    (if (= (count %) n)\n      r\n      (let [x (nth % n)]\n        (recur (inc n) (assoc r x (+ 1 (get r x 0)))))))","problem":55,"user":"4f038567535dcb61093f6b0c"},{"problem":55,"code":"#(reduce (fn [r x] (assoc r x (inc (r x 0)))) {} %)","user":"53e4fa2ce4b036ad0777e454"},{"problem":55,"code":"#(reduce (fn [acc e] (assoc acc e (inc (get acc e 0)))) {} %)","user":"5d5166d9e4b0776584bd6f5e"},{"problem":55,"code":"(fn [x]\n  (apply\n   merge\n   (map\n    #(hash-map\n      (first %)\n      (count %))\n    (vals\n     (group-by\n      identity x)))))","user":"576e607ae4b0979f89651579"},{"problem":55,"code":"#(reduce \n  (fn [ac itm] (update-in ac [itm] (fnil inc 0))) {} %)","user":"5d5eb086e4b0c9e5857d4ff7"},{"code":"(partial reduce #(assoc % %2 (inc (% %2 0))) {})","problem":55,"user":"50ed4626e4b01236b1d4983c"},{"problem":55,"code":"(fn my-freq [coll]\n  (into {} (map (fn [x] [(first x) (count (last x))]) (group-by identity coll)) ) )","user":"57b99d48e4b0fbc9809a27f2"},{"problem":55,"code":"(fn [xs] (reduce #(assoc %1 (first %2) (count (second %2))) {} (group-by identity xs)))","user":"5a01d8f6e4b01bb0ae8afd53"},{"code":"#(reduce \n  (fn [result L] (assoc result (first L) (count L)))\n  (hash-map)\n  (partition-by identity (sort %)))","problem":55,"user":"52c2106fe4b07a9af5792374"},{"problem":55,"code":"(fn [c] \n     (reduce #(assoc % (first %2) (count %2)) {} (partition-by identity (sort c))))","user":"5156e767e4b04360f2428e6b"},{"problem":55,"code":"#(reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by (fn [x] x) %))","user":"5c6d0e51e4b0fca0c1622735"},{"code":"(fn [s]\n  (loop [accum {}\n         rst (rest s)\n         nxt (first s)]\n    (if nxt\n      (if-let [val (get accum nxt)]\n        (recur (assoc accum nxt (inc val)) (rest rst) (first rst))\n        (recur (assoc accum nxt 1) (rest rst) (first rst)))\n      accum)))","problem":55,"user":"5302bb37e4b0d8b024fd3734"},{"problem":55,"code":"#(apply hash-map \n  (map-indexed\n    (fn [idx x] (if (odd? idx) (count x) x)) \n    (apply concat (seq (group-by identity %)))))","user":"53d5e45ae4b0e771c302544e"},{"code":"#(into {} (for [[k v] (group-by identity %)]\n            [k (count v)]))","problem":55,"user":"4f06dcad535dcb61093f6c16"},{"code":"#(into {} (for [[x c] (group-by identity %)] [x (count c)]))","problem":55,"user":"500900dee4b0144d4f561e42"},{"code":"(fn f [x] (if (empty? x) {} (into (f (filter (partial not= (first x)) x)) (hash-map (first x) (count (filter (partial = (first x)) x))))))","problem":55,"user":"514d398ee4b019235f6c0583"},{"problem":55,"code":"#(zipmap\n   (map first (partition-by identity (sort %)))\n   (map count (partition-by identity (sort %))))","user":"58b80ec1e4b0ebc645576d89"},{"problem":55,"code":"#(reduce (fn [occurences e]\n          (update-in occurences [e]\n                  (fn [old-value]\n                    (inc (or old-value 0)))))\n        {} %)","user":"58a413b5e4b02bd94d917f07"},{"code":"(fn [xs]\n  (reduce (fn [acc x]\n            (update-in acc [x] #(inc (or % 0))))\n          {} xs))","problem":55,"user":"4dad8a6dc9a9d6ed1399dc57"},{"code":"(fn [xs] \n  (into {} \n    (map #(vector (first %) (count (second %)))\n         (group-by identity xs))))","problem":55,"user":"525ab6cfe4b0cb4875a45cf9"},{"problem":55,"code":"(fn [coll]\n    (reduce (fn [res k]\n              (assoc res\n                     k\n                     (inc (get res k 0))))\n            {}\n            coll))","user":"57596ba7e4b02ea11479931a"},{"code":"#(->> (group-by identity %) (map (fn [item] [(first item) (count  (second item))])) (apply concat) (apply array-map))","problem":55,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":55,"code":"#(reduce (fn [r x] (assoc r (first x) (count x))) {} (partition-by identity (sort %)))","user":"607d6bc1e4b03d835a6eaecc"},{"problem":55,"code":"(fn [coll]\n    (reduce\n     (fn [hmap newitem]\n       (let [ct_item (get hmap newitem)]\n         (if (nil? ct_item)\n           (assoc hmap newitem 1)\n           (assoc hmap newitem (inc ct_item)))))\n     {}\n     coll))","user":"54d9366ce4b0a52adc2e204e"},{"problem":55,"code":"(fn [xs]\n    (into {}  \n      (map #(vector (first %) (count (second %))) \n           (group-by identity xs)))\n)","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":55,"code":"(fn counto\n  [sq]\n  (reduce #(if (contains? %1 %2) \n              (assoc %1 %2 (+ 1 (%1 %2)))\n              (assoc %1 %2 1)\n              ) {} sq))","user":"5888b75fe4b0f1effa3b771b"},{"code":"#(let [m (group-by identity %) k (keys m) v (vals m)] (zipmap k (map count v)))","problem":55,"user":"5134973ce4b0230e9f713b42"},{"problem":55,"code":"(fn counts [_seq] \n  (let [grouped (group-by identity _seq)]\n  (zipmap (keys grouped) (map count (vals grouped)))))","user":"5606a4ace4b08b23635d3175"},{"problem":55,"code":"#(into {} (map (fn [x] [(first x) (count x)]) (map second (group-by identity %))))","user":"5686e652e4b0dcc4269f4059"},{"code":"(fn [s]\n  (into {} (for [x (partition-by identity (sort s))] [(first x) (count x)])))","problem":55,"user":"53219cece4b09d4e7a9b54b7"},{"problem":55,"code":"(fn [vals]\n  (reduce (fn [carry item] \n            (println item)\n            (assoc carry item (inc (get carry item 0)))\n            ) {} vals))","user":"54dfbacae4b024c67c0cf7b1"},{"problem":55,"code":"#(into {} (map (fn [s] [(first s) (count (second s))]) (group-by identity %)))","user":"4f856adfe4b033992c121c44"},{"problem":55,"code":";(fn [s] (reduce (fn [a e] (assoc a e (inc (a e)))) (zipmap (distinct s) (repeat 0)) s))\n#(% (group-by identity %2)) #(zipmap (keys %) (map count (vals %)))","user":"5ccf21c4e4b0ccb0619628c1"},{"problem":55,"code":"(fn [coll] (into {} (for [[i s] (group-by identity coll)] [i (count s)])))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn [coll]\n  (let [group-map (group-by identity coll)]\n    (into {} (for [[k v] group-map] [k (count v)]))))","problem":55,"user":"51a97f7ae4b08d8ec191b827"},{"problem":55,"code":"#(reduce (fn [acc el] (assoc acc el (if (acc el) (inc (acc el)) 1))) {} %)","user":"564faadce4b0284900eef6b2"},{"code":"(fn[coll]\n   (apply merge (for [i (partition-by identity (sort coll))] {(first i) (count i)})))","problem":55,"user":"4fb86dc9e4b081705acca2d8"},{"code":"(fn p55-count-occurrences [s]\n  (reduce\n   (fn [freq x] (assoc freq x ((fnil + 0) (freq x) 1))) {} s))","problem":55,"user":"526d6968e4b03e8d9a4a72d9"},{"problem":55,"code":"(fn part [coll]\n    (let [groups (group-by identity coll)]\n      (zipmap (keys groups) (map count (vals groups)))))","user":"5e17bb46e4b00200644e3d5a"},{"code":"(fn f [[h & t]]\n  (if h\n    (let [m (f t)]\n      (assoc m h (+ (get m h 0) 1)))\n    {}))","problem":55,"user":"4ee82539535d93acb0a66878"},{"code":"(fn\n  [coll] \n  (#(into {} (for [[k v] %] [k (count v)]))\n   (group-by #((constantly %)) coll)))","problem":55,"user":"51701a9ce4b034fe8eaf70f5"},{"problem":55,"code":"#(loop [seq (rest %)\n        key (first %)\n        acc {}]\n   (let [next (assoc acc key (+ (get acc key 0) 1))]\n     (if (empty? seq)\n       next\n       (recur (rest seq) (first seq) next))))","user":"57155980e4b07c98581c3ad7"},{"problem":55,"code":"(fn [vs]\n (apply \n  (partial assoc {}) \n  (mapcat \n   \t#(list (first %) (count (second %))) \n   (group-by identity vs)\n  )\n )\n)","user":"5ce41d1be4b0a17bb84e2b50"},{"problem":55,"code":"(fn countmap [l] \n  (let [m (group-by identity l)]\n    (zipmap (keys m) (map count (vals m)))))","user":"57887de2e4b0ebec4cfb751c"},{"problem":55,"code":"(fn foo [x] (into {} (map (fn [[key value]] [key (count value)]) (group-by identity x))))","user":"5839f079e4b089d5ab817d48"},{"problem":55,"code":"#(reduce\n  (fn [acc x]\n    (assoc acc x (inc (get acc x 0))))\n  {}\n  %)","user":"505345d9e4b0517ede0d0a06"},{"code":"(fn [c] (let [m (group-by identity c)] (zipmap (keys m) (map count (vals m)))))","problem":55,"user":"4db86aee535d1e037afb2193"},{"problem":55,"code":"(fn count-occurrences [xs]\n  (loop [item-counts {}, curr-xs xs]\n    (if (empty? curr-xs)\n      item-counts\n      (let [curr (first curr-xs),\n            new-map\n            (if (contains? item-counts curr)\n              (update-in item-counts [curr] inc)\n              (conj item-counts [curr 1]))]\n        (recur new-map (rest curr-xs))))))","user":"53d20e14e4b00fb29b22131a"},{"problem":55,"code":"(fn [coll]\n  (reduce (fn [counts x]\n            (assoc counts x (inc (get counts x 0))))\n          {}\n          coll))","user":"5fea32f3e4b05ac5b16ea1aa"},{"problem":55,"code":"(fn [xs]\n  (reduce-kv\n   (fn [acc k v] (assoc acc k (count v)))\t\n   {}\n   (group-by identity xs)))","user":"5b9db58be4b0c0b3ffbd4b41"},{"problem":55,"code":"(fn [x] \n  (->>\n   (partition-by identity (sort x))\n   (map #(list (first %) (count %)))\n   (apply concat)\n   (apply hash-map)))","user":"562d869be4b0a45d2ff8301f"},{"problem":55,"code":"reduce (fn [result el]\n         \t (if (contains? result el)\n                 (assoc result el (+ 1 (result el)))\n                 (assoc result el 1))) {}","user":"593744abe4b02506e01a299b"},{"problem":55,"code":"(fn [coll]\n   (reduce (fn [counts el] (update-in counts [el] #(if (nil? %) 1 (inc %)))) {} coll))","user":"585c5b21e4b0f14aab7c8786"},{"problem":55,"code":"(fn [coll]\n   (apply merge-with + (for [e coll] {e 1})))","user":"5633bb9de4b0bfe05bf117b4"},{"code":"(fn [coll]\n  (let [counted (for [[k v] (group-by identity coll)]\n                  [k (count v)])]\n    (apply merge (map #(hash-map (first %) (second %)) counted))))","problem":55,"user":"527a69cee4b03e8d9a4a755d"},{"code":"(fn count-occurrences [colls]\n  (let [colls (ref (group-by identity colls ))]\n    (last (for [x (keys @colls) ]\n            \n              (dosync (ref-set colls (assoc @colls x (count (@colls x)))))\n              ;(println @colls)\n              \n              ))))","problem":55,"user":"5273562ae4b03e8d9a4a7479"},{"problem":55,"code":"(fn [input-sequence]\n\t(let [elements (set input-sequence)]\n\t\t(reduce \n\t\t\t(fn [coll element]\n\t\t\t \t(let [a (reduce \n\t\t\t\t\t\t\t \t\t(fn [count input]\t(if (= input element) (+ 1 count) count))\n\t\t\t\t\t\t\t \t\t0\n\t\t\t\t\t\t\t \t\tinput-sequence\n\t\t\t\t\t\t\t \t\t)\n\t\t\t \t\t\t\t]\n\t\t\t \t\t(assoc coll element a)\n\t\t\t \t)\n\t\t\t)\n\t\t\t{}\n\t\t\telements\n\t\t)\n\t)\n)","user":"5a5b9e3ce4b0512ff01cd90b"},{"code":"(fn [coll]\n  (reduce #(assoc %1 %2 (inc (%1 %2 0)))\n    {}\n    coll))","problem":55,"user":"518a59b3e4b02bf06f6bbb4b"},{"code":"(fn freqs [coll]\n  (into\n    {}\n    (map\n       #(let [[k v] %] [k (count v)])\n       (group-by identity coll))))","problem":55,"user":"530e9729e4b08068f379ecbc"},{"code":"(fn count-occurence\r\n  [sq]\r\n  (loop [s sq r {}]\r\n    (if (empty? s)\r\n      r\r\n      (recur (rest s) (if (nil? (get r (first s)))\r\n                        (assoc r (first s) 1)\r\n                        (update-in r [(first s)] inc))))))","problem":55,"user":"4f2942ace4b0d6649770a01e"},{"problem":55,"code":"reduce (fn [acc el]\n          \n            (update-in acc [el] (fnil inc 0))) \n        {}","user":"5a8fd113e4b05369db4d2542"},{"problem":55,"code":"(fn [c]\n\n  (into {}\n        (for [[k g] (group-by identity c)]\n          [k (count g)])))","user":"562268dce4b03f08ee9a9224"},{"problem":55,"code":"(fn [s]\n  (into {} (map (fn [[key val]]\n                  [key (count val)]) (group-by identity s))))","user":"60b8b0f8e4b0e0fa5f1b425c"},{"code":"(fn freq\n  [xs]\n  (reduce (fn [a [k v]] \n            (assoc a k (count v)))\n          {} \n          (group-by identity xs)))","problem":55,"user":"513fab65e4b00f13ea1bd891"},{"problem":55,"code":"(fn [coll]\n   (reduce \n     (fn [arr elem] \n       (assoc arr (first elem) (count (second elem))))\n     {}\n     (group-by identity coll)))","user":"58ed2e21e4b056aecfd47d7a"},{"problem":55,"code":"#(->> %\n      (group-by identity)\n      (reduce (fn [m [k v]] (assoc m k (count v))) {}))","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn [xs]\n  (apply hash-map (mapcat #(list (key %) (count (val %)))\n                          (group-by identity xs))))","problem":55,"user":"4ee3b586535d10e5ff6f5371"},{"code":"#(reduce (fn [m [k v]] (assoc m k (count v))) {} (group-by identity %))","problem":55,"user":"51b38769e4b026427ecf067f"},{"problem":55,"code":"(fn [v] (let [m (group-by #(identity %) v)] (into {} (map vector (keys m) (map count (vals m))))))","user":"573c813be4b0cd1946bd10c5"},{"code":"(fn [l ](reduce #(merge-with + % {%2 1}) {} l))","problem":55,"user":"4f7869c2e4b0fbe0118ec589"},{"problem":55,"code":"#(into {} (map (fn [[k, xs]] [k (count xs)]) (group-by identity %)))","user":"57275898e4b0c5bde472c13e"},{"problem":55,"code":"(fn [L] (apply hash-map (mapcat #(vector (first %) (count %)) (partition-by identity (sort L )))))","user":"55f25ae6e4b06e875b46ce43"},{"problem":55,"code":"#(into {} (map (fn [l] {(first l) (count (second l))}) (group-by identity %)))","user":"5e48ec09e4b043cd24807a45"},{"problem":55,"code":"(fn [x]\n  (#(zipmap (map first %) (map count %)) (partition-by identity (sort-by identity x))))","user":"5eb6561fe4b00a66d4a95233"},{"problem":55,"code":"(fn [s] (reduce (fn [v [k i]] (conj v {k (count i)})) {} (group-by identity s)))","user":"549a176ce4b0f3d1d8e70f69"},{"problem":55,"code":"#(->> %\n     (group-by identity)\n     (map (fn [[k v]] [k (count v)]))\n     (into {}))","user":"51a3be77e4b0e77c4ca60bf8"},{"code":"(fn my-frequencies\r\n([s] (my-frequencies s {}))\r\n([s m] (cond (empty? s) m\r\n       :default (let [x (first s) \r\n\t\t\t    c (inc (get m x 0))]\r\n\t\t\t(recur (rest s) (assoc m x c))))))","problem":55,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":55,"code":"(fn [xs] (into {} (map \n          #(vector (first %) (count (second %))) \n          (group-by identity xs)\n          )))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":55,"code":"(fn [s]\n  (apply merge-with + \n              (map (fn [n] {n 1}) s)))","user":"5576fee3e4b05c286339e078"},{"problem":55,"code":"#(into {} (for [[v c] (group-by identity %)] [v (count c)]))","user":"55e1d34ae4b050e68259b421"},{"problem":55,"code":"reduce #(conj %1 [%2 (inc (get %1 %2 0))]) {}","user":"53c1b787e4b00fb29b221266"},{"problem":55,"code":"(fn frequencies' [xs]\n  (let [ds (group-by identity xs)]\n    (apply assoc {}\n           (interleave (keys ds)\n                       (map count (vals ds))))))","user":"55ed5a2de4b0121d4835fdd8"},{"code":"(fn [l]\n  (reduce \n    (fn [a v]  \n      (assoc a v (+ 1 (get a v 0)))\n    )\n    {}\n    l\n))","problem":55,"user":"4e6e10d8535d5021c1a895fd"},{"problem":55,"code":"(fn [col] (into {} (for [[k v] (group-by identity col)] [k (count v)])))","user":"600ae927e4b074f607df6689"},{"problem":55,"code":"#(into {} (map \n   (fn [[k v]] [k (count v)])\n   (group-by identity %)))","user":"5627444fe4b00e49c7cb47cd"},{"code":"(fn [coll]\n  (#(zipmap (map first %) (map count %)) \n(partition-by identity (sort coll))))","problem":55,"user":"50127fbfe4b030d97e4db70f"},{"problem":55,"code":"#(into {} (map (fn [[k xs]] [k (count xs)]) (group-by identity %)))","user":"5829d9f8e4b051871117bf4d"},{"problem":55,"code":"(fn\n  [seq_]\n  (apply merge (map #(hash-map (first %) (count (second %))) (group-by identity seq_)))\n )","user":"6059d824e4b07e92fa001acf"},{"problem":55,"code":"(fn [sequence]\n  (loop [cursor sequence\n         report {}]\n    (if (= 0 (count cursor))\n      report\n      (recur\n       (rest cursor)\n       (assoc report (first cursor)\n              (let [current-value (get report (first cursor))]\n                (if current-value\n                  (inc current-value)\n                  1)))))))","user":"5f79bff2e4b02876ed9fd0ca"},{"problem":55,"code":"(fn count-occurrences \n    ([x] (count-occurrences (partition-by identity (sort x)) 0 {}))\n\n    ([x i y]\n        (cond (< i (count x))\n            (count-occurrences x (inc i) (conj y {(first (nth x i)) (count (nth x i))}))\n            :else y\n        )\n    )\n)","user":"5f0cb4f3e4b0f30dddfb5d4e"},{"problem":55,"code":"#(into {} (map (fn [x] [(first x) (count x)]) (->> % sort (partition-by identity))))","user":"507e68abe4b085af06e3afd2"},{"problem":55,"code":"(fn [c]\n  (into {} (map (fn [[k v]] [k (count v)])\n                (group-by identity c))))","user":"52be5d55e4b07a9af579231e"},{"problem":55,"code":"(fn my-freq [xs]\n  (reduce\n   (fn [memo elem]\n     (assoc memo elem (inc (get memo elem 0))))\n   {}\n   xs))","user":"5b4b8cd6e4b02d533a91bc9f"},{"problem":55,"code":"; first solution\nreduce #(assoc %1 %2 (inc (get %1 %2 0))) {}\n\n; minitrue\n; reduce #(update-in %1 [%2] (fnil inc 0)) {}","user":"5a544eeee4b05d388ecb6c24"},{"problem":55,"code":"(fn [xs]\n  (reduce #(assoc % %2 (inc (get % %2 0))) {} xs))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"#(let [x (group-by vector %)] (apply hash-map (interleave (map first (vals x)) (map count (vals x)))))","problem":55,"user":"506b437de4b0eda3100c0906"},{"code":"(fn [l]\n  (reduce (fn [m k]\n            (let [v (if (contains? m k) (inc (m k)) 1)]\n              (assoc m k v)))\n          {}\n          l))","problem":55,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":55,"code":"(fn [coll] (reduce (fn [m x] (assoc m x (inc (m x 0)))) {} coll))","user":"56cb6425e4b0ea9b8538f730"},{"problem":55,"code":"(fn [x] (reduce (fn [z y] (merge-with + y z)) (map #(hash-map % 1) x)))","user":"53fc8424e4b0de5c418485b3"},{"problem":55,"code":"(fn [s]\n  (reduce (fn [m i] (update-in m [i] (fnil inc 0))) {} s))","user":"57458b82e4b009280f9f2b4e"},{"problem":55,"code":"(fn occ [c]\n  (let [step\n        (fn [c res]\n          (if-let [s (seq c)]\n            (recur (rest s) (assoc res (first s) (inc (get res (first s) 0))))\n            res))]\n    (step c (hash-map))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":55,"code":"(fn\n  [s]\n  (reduce (fn [acc i]\n            (assoc acc i (inc (get acc i 0))))\n          {} s)\n          )","user":"59a42b83e4b066c664927d4d"},{"code":"(fn [coll] (reduce #(assoc %1 %2 (inc (%1 %2 0))) {} coll))","problem":55,"user":"4e944706535dbda64a6f6b11"},{"code":"#(into {} (for [[k v] (group-by identity %)] (assoc {} k (count v))))","problem":55,"user":"513d121fe4b0e544971636a2"},{"code":"(fn [coll]\n  (persistent!\n    (reduce (fn [counts x]\n              (assoc! counts x (inc (get counts x 0))))\n            (transient {}) coll)))","problem":55,"user":"509c2c55e4b085ae113522ab"},{"code":"(fn count-occurrences [l]\r\n    (loop [l l f {}]\r\n      (if (empty? l)\r\n        f\r\n        (let [m\r\n              (if (find f (first l))\r\n                (update-in f [(first l)] inc)\r\n                (assoc f (first l) 1))]\r\n          (recur (rest l) m)))))","problem":55,"user":"4f039524535dcb61093f6b2c"},{"problem":55,"code":"(fn [xs] (->> xs\n                              (sort)\n                              (partition-by identity)\n                              (reduce #(assoc % (first %2) (count %2)) {})))","user":"58e37946e4b005f69f193cae"},{"problem":55,"code":"#(apply hash-map\n    ((fn [] (mapcat (fn [coll] [(first coll) (count (second coll))]) (group-by identity %)))))","user":"56d1978fe4b0ea9b8538f790"},{"code":"reduce \n#(update-in %1 [%2] (fnil inc 0))\n{}","problem":55,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"#(loop [coll % acc {}]\n     (if (seq coll)\n       (recur (rest coll)\n              (assoc acc\n                (first coll)\n                (inc (get acc (first coll) 0))))\n       acc))","problem":55,"user":"52cc582ae4b07d0d72b27362"},{"problem":55,"code":"(fn count-occurences [s]\n  (reduce #(assoc %1 %2 (inc (get %1 %2 0))) {} s))","user":"5922f8a9e4b026ae3852128f"},{"problem":55,"code":"(fn [coll]\n   (apply hash-map (mapcat (fn [[k v]] [k (count v)]) (group-by identity coll))))","user":"50666699e4b03d366d7cb2b0"},{"code":"(fn r [xs]\n  (if (empty? xs)\n    nil\n    (let [x (first xs) ]\n      (merge\n       (r (filter #(not (= x %)) (rest xs)))\n       {x (count (filter #(= x %) xs))}))))","problem":55,"user":"4fb510b5e4b081705acca2b8"},{"code":"#(reduce merge (for [[k v] (group-by identity %)] {k (count v)}))","problem":55,"user":"4ff76effe4b0678c553fc390"},{"problem":55,"code":"(fn [coll]  (reduce-kv  (fn[m k v] (assoc m (first v)  (count v)))   {}  (group-by str coll)))","user":"575bd5f9e4b02ea114799365"},{"problem":55,"code":"(fn my-count\n  [my-sequence]\n  (into {} (map \n             (fn [[key value]] [key (count value)]) \n             (group-by identity my-sequence))\n        )\n  )","user":"546a70bae4b00cfc9eacc159"}]